alue:
 Success

--*/
{


    NdisZeroMemory (&pAdapter->SerRcv, sizeof(pAdapter->SerRcv));
    InitializeListHead(&pAdapter->SerRcv.Queue);

    NdisMInitializeTimer (&pAdapter->SerRcv.Timer,
                      pAdapter->MiniportAdapterHandle,
                      RcvIndicateTimer  ,
                      pAdapter);



    return NDIS_STATUS_SUCCESS;

}


VOID
nicDeInitSerializedReceiveStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
 Deinits the Recv Init routine

Arguments:


Return Value:


--*/
{



}













NDIS_STATUS
nicQueueReceivedPacket(
    PNDIS_PACKET pPacket, 
    PVCCB pVc, 
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
  Queues a receive packet in the adapter's receive packet queue.
  If no timer routins is in operation or already set, then this thread
  will set the timer

Arguments:
  Self explanatory

Return Value:


--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fSetTimer = FALSE;

    do
    {
        PRSVD           pRsvd;
        PINDICATE_RSVD  pIRsvd;

        extern ULONG TotRecvs;
        TotRecvs++;

        pRsvd =(PRSVD)((pPacket)->ProtocolReserved);
        pIRsvd = &pRsvd->IndicateRsvd;
        pIRsvd->pPacket = pPacket;
        pIRsvd->pVc = pVc;
        pIRsvd->pAdapter = pAdapter; 
        
        ADAPTER_ACQUIRE_LOCK (pAdapter);


        //
        // Set up a tag used to track the packet
        //
        pIRsvd->Tag =  NIC1394_TAG_QUEUED; // perhaps change to something else

        ASSERT (pAdapter->SerRcv.PktsInQueue < 100);

        //
        // If the timer is not set, then this thread must set it
        //
        
        if (pAdapter->SerRcv.bTimerAlreadySet == FALSE)
        {
            fSetTimer = TRUE;
            pAdapter->SerRcv.bTimerAlreadySet = TRUE;
        }

        
        InsertTailList(
                &pAdapter->SerRcv.Queue,
                &pIRsvd->Link
                );
        pAdapter->SerRcv.PktsInQueue++;

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Now queue the timer
        //
        
        if (fSetTimer == TRUE)
        {
            //
            //  Set the timer
            //
                         

            
            TRACE( TL_V, TM_Recv, ( "   Set Timer "));
            
            NdisMSetTimer ( &pAdapter->SerRcv.Timer, 0);

    
        }


        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    ASSERT (Status == NDIS_STATUS_SUCCESS);
    return Status;
}








VOID
RcvIndicateTimer (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:
  This function dequeues a packet and sends it upto NDIS and the protocols/. 
  The Function context is the adapter object which has the Receive queue in it.
  

Arguments:
    Function context - adapter

Return Value:


--*/
{
    PADAPTERCB      pAdapter = (PADAPTERCB)FunctionContext; 

    TRACE( TL_T, TM_Recv, ( "==>RcvIndicateTimer  Context %x", FunctionContext));
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT (pAdapter->ulTag == MTAG_ADAPTERCB);
        return;
    
    }

    ADAPTER_ACQUIRE_LOCK (pAdapter);



    //
    // Get the stats out
    //

    nicSetCountInHistogram(pAdapter->SerRcv.PktsInQueue, RcvStats); 

    nicSetMax(nicMaxRcv,  pAdapter->SerRcv.PktsInQueue);

    nicIncrementRcvTimerCount();


    //
    // Empty the Queue indicating as many packets as possible
    //
    while (IsListEmpty(&pAdapter->SerRcv.Queue)==FALSE)
    {
        LIST_ENTRY *pLink;
        PINDICATE_RSVD pIRsvd;

        pAdapter->SerRcv.PktsInQueue--;
        pLink = RemoveHeadList(&pAdapter->SerRcv.Queue);

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Indicate the packet without the lock
        //
        pIRsvd = CONTAINING_RECORD(
                            pLink,
                            INDICATE_RSVD,
                            Link
                            );

        pIRsvd->Tag =  NIC1394_TAG_INDICATED; 

        nicIncrementRcvVcPktCount(pIRsvd->pVc,pIRsvd->pPacket);
        
        NdisMCoIndicateReceivePacket(pIRsvd->pVc->Hdr.NdisVcHandle, &pIRsvd->pPacket, 1);

        if (NDIS_GET_PACKET_STATUS(pIRsvd->pPacket) == NDIS_STATUS_RESOURCES)
        {
            //
            // Complete the packet
            //
            ASSERT (0);
            pIRsvd->Tag =  NIC1394_TAG_RETURNED; 

            nicInternalReturnPacket(pIRsvd->pVc, pIRsvd->pPacket );
        }

        ADAPTER_ACQUIRE_LOCK (pAdapter);

    }
    
    //
    // clear the flag
    //

    ASSERT (pAdapter->SerRcv.PktsInQueue==0);
    ASSERT (IsListEmpty(&pAdapter->SerRcv.Queue));


    pAdapter->SerRcv.bTimerAlreadySet = FALSE;


    ADAPTER_RELEASE_LOCK (pAdapter);

    NdisMCoReceiveComplete(pAdapter->MiniportAdapterHandle);


    
    TRACE( TL_T, TM_Recv, ( "<==RcvIndicateTimer "));

}






NDIS_STATUS
nicInitSerializedReassemblyStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
  Initialize the Reassembly serialization structure

Arguments:
  padapter

Return Value:
 Success

--*/
{


    NdisZeroMemory (&pAdapter->Reassembly, sizeof(pAdapter->Reassembly));
    InitializeListHead(&pAdapter->Reassembly.Queue); // Not be Used

    NdisInitializeEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent);
    pAdapter->Reassembly.CompleteEvent.EventCode = Nic1394EventCode_InvalidEventCode;

    NdisMInitializeTimer (&pAdapter->Reassembly.Timer,
                         pAdapter->MiniportAdapterHandle,
                         ReassemblyTimerFunction ,
                         pAdapter);



    return NDIS_STATUS_SUCCESS;

}


VOID
nicDeInitSerializedReassmblyStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
 Deinits the Reassembly routine routine

  if the timer is set, it waits the timer out.
 As all the reassemblies will be marked as aborted in nicFreeAllPendingReassemblies (below)
 it queues a timer one last time to go in and delete all the reassembly structures.
 
Arguments:


Return Value:


--*/
{
 

    do
    {
        
        BOOLEAN bTimerAlreadySet = FALSE;
        //
        // If this adapter is halting, then mark all reassemblies as aborted
        //
        nicFreeAllPendingReassemblyStructures(pAdapter);


        //
        // First wait for any pending timer to fire.
        //
        ADAPTER_ACQUIRE_LOCK (pAdapter);
        bTimerAlreadySet = pAdapter->Reassembly.bTimerAlreadySet ;               
        if (bTimerAlreadySet == TRUE)
        {
            //
            // if the (bTimerAlreadySet==TRUE ), it means we can clear/init the event. 
            // Because the TimerAlreadySet is cleared and the Event is always set within
            // the same Acquire-Release Spinlock
            //
            NdisResetEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent);
            pAdapter->Reassembly.CompleteEvent.EventCode = Nic1394EventCode_InvalidEventCode;
        
            
        }
        ADAPTER_RELEASE_LOCK(pAdapter);


        if (bTimerAlreadySet == TRUE)
        {
            NdisWaitEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent,WAIT_INFINITE); 
        }

        //
        // Reset the event , to prepare for the next wait.
        //
        pAdapter->Reassembly.CompleteEvent.EventCode = Nic1394EventCode_InvalidEventCode;

        NdisResetEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent);


        //
        // Now enqueue the timer one last time to free all pending reassemblies.
        // and Stop any further reassembly timers 
        //

        nicQueueReassemblyTimer (pAdapter,TRUE); 


        //
        // Wait for the last timer to fire.
        //

        bTimerAlreadySet = pAdapter->Reassembly.bTimerAlreadySet ;               

        //
        // Only do the wait, if nicQueueReassembly Timer actually queued a reassembly timer
        //
        if (bTimerAlreadySet == TRUE)
        {   
            NdisWaitEvent (&pAdapter->Reassembly.CompleteEvent.NdisEvent,WAIT_INFINITE); 
        }



    } while (FALSE);
    
        
 

}



NDIS_STATUS
nicQueueReassemblyTimer(
    PADAPTERCB pAdapter,
    BOOLEAN fIsLastTimer
    )
/*++

Routine Description:

  Queues a timer to be fired in one second. 
  If there is already a timer active it quietly exists

Arguments:
  Self explanatory

Return Value:


--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    BOOLEAN fSetTimer = FALSE;

    do
    {
    

        ADAPTER_ACQUIRE_LOCK (pAdapter);



        //
        // If the timer is not set, then this thread must set it
        //


        if (pAdapter->Reassembly.bTimerAlreadySet == FALSE && // timer is not set
            pAdapter->Reassembly.PktsInQueue > 0 &&   // there are packets to be reassembled
            ADAPTER_TEST_FLAG (pAdapter,fADAPTER_NoMoreReassembly) == FALSE ) // the adapter is not halting
        {
            fSetTimer = TRUE;
            pAdapter->Reassembly.bTimerAlreadySet = TRUE;
        }

        if (fIsLastTimer == TRUE)
        {
            //
            // Stop any further reassembly timers 
            //

            ADAPTER_SET_FLAG (pAdapter, fADAPTER_NoMoreReassembly);
        }


        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Now queue the timer
        //
        
        if (fSetTimer == TRUE)
        {
            //
            //  Set the timer
            //
                         

            
            TRACE( TL_V, TM_Recv, ( "   Set Timer "));
            
            NdisMSetTimer ( &pAdapter->Reassembly.Timer, 2000);

    
        }


        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    ASSERT (Status == NDIS_STATUS_SUCCESS);
    return Status;
}


VOID
nicFifoAllocationScheme (
    PRECVFIFO_VCCB pRecvFIFOVc
)
/*++

Routine Description:
 If there are less than 20 fifo allocated, it starts a workitem to 
 allocate a lot more fifos

Arguments:
   

Return Value:


--*/
{

    BOOLEAN fQueueWorkItemInThisThread = FALSE;
    PNIC_WORK_ITEM pFifoWorkItem = NULL;
    do
    {
        if (pRecvFIFOVc->NumAllocatedFifos != NUM_RECV_FIFO_FIRST_PHASE)
        {
            break ; 
        }

        if (pRecvFIFOVc->FifoWorkItemInProgress == TRUE)        
        {
            break;
        } 
        
        pFifoWorkItem  = ALLOC_NONPAGED (sizeof(NIC_WORK_ITEM), MTAG_WORKITEM); 

        if (pFifoWorkItem == NULL)
        {
            break;
        }

        VC_ACQUIRE_LOCK(pRecvFIFOVc);

        if (pRecvFIFOVc->FifoWorkItemInProgress == FALSE)        
        {
            fQueueWorkItemInThisThread = TRUE;


            pRecvFIFOVc->FifoWorkItemInProgress = TRUE;

            // Add reference to the VC . Derefed in the WorkItem
            //
            nicReferenceCall((VCCB*)pRecvFIFOVc, "Queueing miniport Work Item\n");
        }

        VC_RELEASE_LOCK (pRecvFIFOVc);

        if (fQueueWorkItemInThisThread  == FALSE)
        {
            break;
        }

        //
        // Queue the workitem
        //
        NdisInitializeWorkItem ( &pFifoWorkItem->NdisWorkItem, 
                                 (NDIS_PROC) nicAllocateRemainingFifoWorkItem,
                                 (PVOID) pRecvFIFOVc);

        NdisScheduleWorkItem (&pFifoWorkItem->NdisWorkItem);

    } while (FALSE);
    
}



VOID
nicAllocateRemainingFifoWorkItem (
    PNDIS_WORK_ITEM pNdisWorkItem, 
    IN PVOID Context
    )
/*++

Routine Description:
    This follows a simple algorithm. It simply allocates fifos 
    until we reach our expected number of 100

Arguments:
   

Return Value:


--*/
{
    PRECVFIFO_VCCB pRecvFIFOVc = NULL;
    BOOLEAN fIsVcActive = FALSE;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    

    pRecvFIFOVc = (PRECVFIFO_VCCB) (Context);
    
    fIsVcActive = VC_ACTIVE(pRecvFIFOVc);

    do
    {
        PADDRESS_FIFO pRecvFifoElement = NULL;

        fIsVcActive = VC_ACTIVE(pRecvFIFOVc);

        if (fIsVcActive == FALSE)
        {
            break;
        }

        NdisStatus = nicGetInitializedAddressFifoElement (pRecvFIFOVc->Hdr.MTU, 
                                                    &pRecvFifoElement);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        ASSERT (pRecvFifoElement  != NULL);
 

        nicSetTagInFifoWrapper(pRecvFifoElement, NIC1394_TAG_QUEUED);
        
        ExInterlockedPushEntrySList ( &pRecvFIFOVc->FifoSListHead,
                                     &pRecvFifoElement->FifoList,
                                     &pRecvFIFOVc->FifoSListSpinLock);

        //
        // Add this once for every Address Fifo element inserted 
        // Will be decremented by  a call to nicFreeAddressFifo
        //
        VC_ACQUIRE_LOCK (pRecvFIFOVc);

#if FIFO_WRAPPER

        pRecvFIFOVc->pFifoTable[pRecvFIFOVc->NumAllocatedFifos] = pRecvFifoElement;

#endif

        nicReferenceCall ((PVCCB) pRecvFIFOVc, "nicWorkItemFileSList");

        pRecvFIFOVc->NumAllocatedFifos++;

        VC_RELEASE_LOCK (pRecvFIFOVc);
      

    } while (pRecvFIFOVc->NumAllocatedFifos < NUM_RECV_FIFO_BUFFERS);

    pRecvFIFOVc->FifoWorkItemInProgress = FALSE;

    nicDereferenceCall ((PVCCB)pRecvFIFOVc,"nicAllocateRemainingFifoWorkItem" );

    FREE_NONPAGED(pNdisWorkItem);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\send.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// send.c
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port Send routines
//
// 12/28/1998 ADube Created, adapted from the l2tp and 1394diag sources.
//
    
//
// The Send Complete functions begin here. Send.c starts here
// Also present are the all thr buffer management routines that need to be expanded 
//

//
//  A Send follows this simple algorithm:
//  Copy incoming data to local buffers
//  Insert Fragment Headers if necessary
//  Create an Mdl for the local copy
//  Store the IRB and VC in the ndispacket
//  Use the ndispacket as context in the irp's completion routine
//  

#include <precomp.h>

//-----------------------------------------------------------------------------
// Global counts
//-----------------------------------------------------------------------------
extern UINT BusSendCompletes;
extern UINT NicSendCompletes;
extern UINT BusSends;
extern ULONG MdlsAllocated[NoMoreCodePaths];
extern ULONG MdlsFreed[NoMoreCodePaths];

//-----------------------------------------------------------------------------
// prototypes implementations (alphabetically)
//-----------------------------------------------------------------------------

NDIS_STATUS
nicCopyNdisBufferChainToBuffer(
    IN PNDIS_BUFFER pInBuffer,
    IN OUT PVOID pLocalBuffer,
    IN UINT BufferLength )
{


    //
    //  This function copies the data the belongs to the 
    //  pInMdl chain to the local Buffer. 
    //  BufferLength is used for validation purposes only
    //  Fragmentation and insertion of headers will take place here
    //


    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;
    UINT LocalBufferIndex = 0;      // Used as an index to the LocalBuffer, used for validation
    UINT MdlLength = 0;             
    PVOID MdlAddress = 0;
    PNDIS_BUFFER pCurrBuffer;

    TRACE( TL_T, TM_Send, ( "==>nicCopyNdisBufferChainToBuffer pNdisbuffer %x, Buffer %x, Length %x",
                           pInBuffer, pLocalBuffer,BufferLength ) );

    ASSERT (pLocalBuffer != NULL);

    pCurrBuffer = pInBuffer;
    
    do
    {

        MdlLength = nicNdisBufferLength(pCurrBuffer);
        MdlAddress= nicNdisBufferVirtualAddress(pCurrBuffer);

        if (MdlLength != 0)
        {
            if (MdlAddress == NULL)
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                TRACE (TL_A, TM_Send, ("Ndis Buffer at %x", pCurrBuffer) );
                BREAK (TM_Send, ("   nicCopyNdisBufferChainToBuffer: Mdl Address = NULL") );

            }

            if ( LocalBufferIndex + MdlLength > BufferLength)
            {

                ASSERT(LocalBufferIndex + MdlLength <= BufferLength);

                NdisStatus = NDIS_STATUS_BUFFER_TOO_SHORT;

                BREAK (TM_Send, ("nicCopyNdisBufferChainToBuffer Copy Failed" ) );
            }

            //
            //  Copy the Data to local memory.
            //


            NdisMoveMemory((PVOID)((ULONG_PTR)pLocalBuffer+LocalBufferIndex),
                        MdlAddress,
                        MdlLength);

            LocalBufferIndex += MdlLength;
        }

        pCurrBuffer = pCurrBuffer->Next;

    } while (pCurrBuffer!= NULL);

    TRACE( TL_T, TM_Send, ( "<==nicCopyNdisBufferChainToBuffer %x",NdisStatus ) );

    return NdisStatus;

}


NDIS_STATUS
nicFreeIrb(PIRB pIrb)
    //
    //  Frees the Memory occcupied by the Irb
    //

{

    

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;   
    
    ASSERT(pIrb != NULL);

    TRACE( TL_T, TM_Irp, ( "==>nicFreeIrb %x", pIrb ) );

    if (pIrb != NULL)
    {
        FREE_NONPAGED(pIrb); 
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeIrb, NdisStatus %x",NdisStatus ) );
    
    return NdisStatus;


}

NDIS_STATUS
nicFreePrivateIrb(
    PNDIS1394_IRB pIrb
    )
    //
    //  Frees the Memory occcupied by the Irb
    //

{

    

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;   
    
    ASSERT(pIrb != NULL);

    TRACE( TL_T, TM_Irp, ( "==>nicFreeIrb %x", pIrb ) );

    if (pIrb != NULL)
    {
        FREE_NONPAGED(pIrb); 
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeIrb, NdisStatus %x",NdisStatus ) );
    
    return NdisStatus;


}

NDIS_STATUS
nicFreeIrp(PIRP pIrp)

    //
    //  Frees the memory occupied by the  Irp
    //


{

    NDIS_STATUS NdisStatus  = NDIS_STATUS_SUCCESS;

    ASSERT(pIrp != NULL);   

    TRACE( TL_T, TM_Irp, ( "==>nicFreeIrp at %x",pIrp ) );

    if (pIrp != NULL)
    {
        IoFreeIrp(pIrp);
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicFreeIrp, NdisStatus %x",NdisStatus  ) );


    return NdisStatus;


}



NDIS_STATUS
nicFreeLocalBuffer (
    IN UINT Length,
    IN PVOID Address )
    //
    //  Free the Memory pointed to by Address.
    //  The Length parameter is superfluous and will be removed
    //  once I am sure we don;t need it
    //
{
    

    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;

    ASSERT(Address != NULL);

    TRACE( TL_T, TM_Send, ( "==>nicFreeLocalBuffer , Address %x", Address) );

    if (Address != NULL)
    {
        FREE_NONPAGED((PVOID)Address);
    }
    
    TRACE( TL_T, TM_Send, ( "<==niFreeLocalBuffer, NdisStatus %x",NdisStatus ) );
    

    return NdisStatus;

}


NDIS_STATUS
nicFreeMdl(PMDL pMdl)
    //
    //  This frees the memory belonging to the Mdl. Does not free the  
    //  memory that the Mdl Points to
    //

{
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;

    ASSERT (pMdl != NULL)
    
    TRACE( TL_T, TM_Send, ( "==> nicFreeMdl pMdl %x", pMdl ) );
    
    if (pMdl != NULL)
    {
        IoFreeMdl(pMdl);
    }
    
    TRACE( TL_T, TM_Send, ( "<== nicFreeMdl, NdisStatus %x",NdisStatus ) );

    return NdisStatus;
}

VOID
nicFreeToNPagedLookasideList (
    IN PNIC_NPAGED_LOOKASIDE_LIST pLookasideList,
    IN PVOID    pBuffer
    )

    // Function Description:
    //   Return the local buffer to the lookaside list
    //
    // Atguments
    // Lookaside list and its buffer
    // Return Value:
    // None 
{

    
    TRACE( TL_T, TM_Send, ( "==> nicFreeToNPagedLookasideList , Lookaside list %x, plocalbuffer %x",pLookasideList, pBuffer ) );

    NdisFreeToNPagedLookasideList (&pLookasideList->List, pBuffer);     
    NdisInterlockedDecrement (&pLookasideList->OutstandingPackets);

    TRACE( TL_T, TM_Send, ( "<== nicFreeToNPagedLookasideList ") );


}













NDIS_STATUS
nicGetIrb(
    OUT     PIRB *ppIrb )


    //
    // This function is to be used in retrieving a free IRB.
    // that will be supplied as an argument for an IRP
    //
    //  Initially, this will simple allocate an IRB 
    //  Intiailization could be added here
    //
    
{

    NDIS_STATUS NdisStatus;

    
    TRACE( TL_T, TM_Irp, ( "==>nicGetIrb" ) );
    
    *ppIrb = (PIRB)ALLOC_NONPAGED ( sizeof(IRB), MTAG_HBUFPOOL );

    if (*ppIrb != NULL)
    {   
        NdisZeroMemory ( *ppIrb, sizeof(IRB) );
        NdisStatus = NDIS_STATUS_SUCCESS;
        TRACE( TL_V, TM_Send, ( "   nicGetIrb: Irb allocated at %x", *ppIrb ) );

    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;
    }
    
    TRACE( TL_T, TM_Irp, ( "<==nicGetIrb NdisStatus %x",NdisStatus ) );
    
    return NdisStatus;
}


NDIS_STATUS
nicGetIrp(
    IN  PDEVICE_OBJECT pPdo,
    OUT PIRP *ppIrp 
    )


    //
    // This function returns am irp to the calling routine
    // The irp is free and is owned by the nic1394. 
    // NEED TO CHANGE THE STACK SIZE
    //
{

    NDIS_STATUS NdisStatus;
    PIRP  pIrp;
    CCHAR StackSize =0; 

    ASSERT (pPdo != NULL);
    
    TRACE( TL_T, TM_Irp, ( "==>nicGetIrp Pdo %x", pPdo ) );

    if (pPdo == NULL)
    {
        ASSERT (pPdo != NULL);      
        NdisStatus = NDIS_STATUS_FAILURE;
        *ppIrp = NULL;
        return NdisStatus;
    }


    //
    //  Allocate the Irp with the correct stacksize
    //
    StackSize = pPdo->StackSize+1;

    ASSERT (StackSize <=3);
    
    pIrp = IoAllocateIrp (StackSize, FALSE);

    do
    {
    
        if (pIrp == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        TRACE( TL_V, TM_Send, ( "  Irp allocated at %x, Stacksize %x",pIrp , StackSize ) );

        *ppIrp = pIrp;
    
        //
        // Initialize the Irp
        //

        IoInitializeIrp ( *ppIrp, sizeof(IRP), StackSize );

        if (*ppIrp != NULL)
        {
            NdisStatus = NDIS_STATUS_SUCCESS;
        }
        else
        {
            nicIncrementMallocFailure();
            NdisStatus = NDIS_STATUS_FAILURE;
        }
    
    } while (FALSE);

    TRACE( TL_T, TM_Irp, ( "<==nicGetIrp ,irp %x",*ppIrp  ) );
    
    return NdisStatus;
}



NDIS_STATUS
nicGetPrivateIrb(
    IN PADAPTERCB pAdapter OPTIONAL,
    IN PREMOTE_NODE pRemoteNode OPTIONAL,
    IN PVCCB pVc,
    IN PVOID pContext,
    OUT PNDIS1394_IRB *ppIrb 
    )


    //
    // This function is to be used in retrieving a free IRB.
    // that will be supplied as an argument for an IRP
    //
    //  Initially, this will simple allocate an IRB 
    //  Intiailization could be added here
    //
    
{

    NDIS_STATUS NdisStatus;
    PNDIS1394_IRB pIrb = NULL;
    
    TRACE( TL_T, TM_Irp, ( "==> nicGetPrivateIrb pRemoteNode %x, pVc %x", pRemoteNode, pVc  ) );
    
    *ppIrb = (PNDIS1394_IRB)ALLOC_NONPAGED ( sizeof(NDIS1394_IRB), MTAG_HBUFPOOL );

    if (*ppIrb != NULL)
    {   
        NdisZeroMemory ( *ppIrb, sizeof(IRB) );
        NdisStatus = NDIS_STATUS_SUCCESS;

        pIrb = *ppIrb;

        pIrb->pAdapter = pAdapter;
        pIrb->pRemoteNode = pRemoteNode;
        pIrb->pVc = pVc;
        pIrb->Context = pContext;
        
        TRACE( TL_V, TM_Send, ( "   nicGetPrivateIrb: Irb allocated at %x", *ppIrb ) );

    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;
    }

    TRACE( TL_T, TM_Irp, ( "<==nicGetPrivateIrb NdisStatus %x",NdisStatus ) );
    
    return NdisStatus;
}


NDIS_STATUS
nicGetLocalBuffer(
    OPTIONAL IN  ULONG Length,
    OUT PVOID *ppLocalBuffer 
    )

    //
    //  If the lookaside list is not NULL then it is used to allocate the local buffer
    //
    //  This function allocates memory of size 'Length' and returns 
    //  a pointer to this memory 
    //  Subsequently allocation will be done away with and pools will
    //  be used
    //
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    TRACE( TL_T, TM_Send, ( "==>nicGetLocalBuffer  Length %x",  Length ) );
    
    //
    // There is a bug in the Nic if this is zero
    // 
    ASSERT (Length != 0 );


    //
    // There is no lookaside list, We need to allocate memory
    //
    *ppLocalBuffer = ALLOC_NONPAGED (Length, MTAG_FBUFPOOL);
        

    if (*ppLocalBuffer != NULL)
    {
        NdisStatus = NDIS_STATUS_SUCCESS;   
    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus = NDIS_STATUS_FAILURE;
    }

    
    TRACE( TL_T, TM_Send, ( "<==nicGetLocalBuffer, NdisStatus %x at %x",NdisStatus,*ppLocalBuffer ) );
    
    return NdisStatus;

}





PVOID
nicGetLookasideBuffer(
    IN  PNIC_NPAGED_LOOKASIDE_LIST pLookasideList
    )
    // Function Description:
    //    Allocate an buffer from the lookaside list.
    //    will be changed to a macro
    //
    //
    //
    // Arguments
    //  Lookaside list - from which the buffer is allocated
    //
    //
    // Return Value:
    //  Return buffer can be NULL
    //
{

    PVOID pLocalBuffer = NULL;
    
    TRACE( TL_T, TM_Send, ( "==>nicGetLookasideBuffer pLookasideList %x", pLookasideList) );
    
    ASSERT (pLookasideList != NULL);

    //
    // Optimize the lookaside list code path
    //
    pLocalBuffer = NdisAllocateFromNPagedLookasideList (&pLookasideList->List);

    if (pLocalBuffer != NULL)
    {   
        NdisZeroMemory (pLocalBuffer, pLookasideList->Size); 
        NdisInterlockedIncrement (&pLookasideList->OutstandingPackets);
    }
    else
    {
        nicIncrementMallocFailure();
    }

        
    
    TRACE( TL_T, TM_Send, ( "<==nicGetLookasideBuffer, %x", pLocalBuffer ) );
    
    return pLocalBuffer ;

}



NDIS_STATUS
nicGetMdl(
    IN UINT Length,
    IN PVOID pLocalBuffer,
    OUT PMDL *ppMyMdl)


    //
    //  Return a locally owned Mdl to the caller.
    //  This will also initialize the MDl with the localbuffer
    //  Initial implementation will allocate mdls
    //  
{

    NDIS_STATUS NdisStatus;
    
    TRACE( TL_T, TM_Send, ( "==>nicGetMdl" ) );
    
    ASSERT(pLocalBuffer != NULL);

    //
    // Allocate an MDl to point to the structure
    //
    (*ppMyMdl) = NULL;
    (*ppMyMdl) = IoAllocateMdl( pLocalBuffer,
                             Length,
                             FALSE,
                             FALSE,
                             NULL );
    
    //
    //  Initialize the data structures with correct values
    //

    if (*ppMyMdl != NULL)
    {
        MmBuildMdlForNonPagedPool(*ppMyMdl);

        (*ppMyMdl)->Next = NULL;
        
        NdisStatus = NDIS_STATUS_SUCCESS;
    }
    else
    {
        nicIncrementMallocFailure();
        NdisStatus =  NDIS_STATUS_FAILURE;
        *ppMyMdl = NULL;
    }
    
    
    
    TRACE( TL_T, TM_Send, ( "<==nicGetMdl, Mdl %x, LocalBuffer %x",
                                        *ppMyMdl, pLocalBuffer) );
    
    return NdisStatus;
}






VOID
nicInitAsyncStreamIrb(
    IN     PCHANNEL_VCCB pChannelVc, 
    IN     PMDL pMdl, 
    IN OUT PIRB pIrb
    )
    
    // This function initializes the Irb that will be used in the Irb
    // It specifically handles the AsyncStream IRB
    // It arguments are the Vc block (for destination address), 
    // Mdl (Memory desctiptor for the data and a pointer to the 
    // Irb structure that will be initialized 




{
    ASSERT (pMdl != NULL);
    ASSERT (pIrb != NULL);

    NdisZeroMemory (pIrb, sizeof (IRB) );
    pIrb->FunctionNumber = REQUEST_ASYNC_STREAM;
    pIrb->Flags = 0;
    pIrb->u.AsyncStream.nNumberOfBytesToStream = MmGetMdlByteCount(pMdl);
    pIrb->u.AsyncStream.fulFlags = 0;

    //
    // See comments for ISOCH_TAG 
    //
    pIrb->u.AsyncStream.ulTag = g_IsochTag; 
    pIrb->u.AsyncStream.nChannel = pChannelVc->Channel;
    pIrb->u.AsyncStream.ulSynch = pChannelVc->ulSynch;
    pIrb->u.AsyncStream.nSpeed = (INT)pChannelVc->Speed;
    pIrb->u.AsyncStream.Mdl = pMdl;
    
        
        
    TRACE( TL_V, TM_Send, ( "Number of Bytes to Stream %x ", pIrb->u.AsyncStream.nNumberOfBytesToStream  ) );
    TRACE( TL_V, TM_Send, ( "fulFlags %x ", pIrb->u.AsyncStream.fulFlags  ) );
    TRACE( TL_V, TM_Send, ( "ulTag %x ", pIrb->u.AsyncStream.ulTag ) );
    TRACE( TL_V, TM_Send, ( "Channel %x", pIrb->u.AsyncStream.nChannel  ) );
    TRACE( TL_V, TM_Send, ( "Synch %x", pIrb->u.AsyncStream.ulSynch  ) );
    TRACE( TL_V, TM_Send, ( "Speed %x", pIrb->u.AsyncStream.nSpeed  ) );
    TRACE( TL_V, TM_Send, ( "Mdl %x", pIrb->u.AsyncStream.Mdl ) );

}


VOID
nicInitAsyncWriteIrb(
    IN     PSENDFIFO_VCCB pSendFIFOVc, 
    IN     PMDL pMyMdl, 
    IN OUT PIRB pMyIrb
    )
    
    // This function initializes the Irb that will be used in the Irb
    // It specifically handles the AsyncWrite IRB
    // It arguments are the Vc block (for destination address), 
    // Mdl (Memory desctiptor for the data and a pointer to the 
    // Irb structure that will be initialized 




{

        //
        // Sanity check
        //
        ASSERT ((*(PULONG)pMyIrb) == 0)

        pMyIrb->u.AsyncWrite.nNumberOfBytesToWrite = MmGetMdlByteCount(pMyMdl);
        pMyIrb->u.AsyncWrite.nBlockSize = 0;
        pMyIrb->u.AsyncWrite.fulFlags = 0;
        pMyIrb->u.AsyncWrite.Mdl = pMyMdl;
    
        pMyIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
        pMyIrb->Flags = 0;
        pMyIrb->u.AsyncWrite.nSpeed = (UCHAR)pSendFIFOVc->MaxSendSpeed ;

        pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = pSendFIFOVc->FifoAddress.Off_High;
        pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low = pSendFIFOVc->FifoAddress.Off_Low;
        pMyIrb->u.AsyncWrite.ulGeneration = *pSendFIFOVc->Hdr.pGeneration;

    
        pMyIrb->u.AsyncWrite.nBlockSize = 0;
        pMyIrb->u.AsyncWrite.fulFlags = ASYNC_FLAGS_NONINCREMENTING;

        //temporary additions from the 1394diag
        pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_ID.NA_Bus_Number = 0x3ff;
        
        
        
        TRACE(TL_V, TM_Send, ("DestinationAddress.IA_Destination_ID.NA_Bus_Number = 0x%x\n", pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_ID.NA_Bus_Number) );
        TRACE(TL_V, TM_Send, ("DestinationAddress.IA_Destination_ID.NA_Node_Number = 0x%x\n", pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_ID.NA_Node_Number) );
        TRACE(TL_V, TM_Send, ("DestinationAddress.IA_Destination_Offset.Off_High = 0x%x at 0x%x\n", pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High, &pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High) );
        TRACE(TL_V, TM_Send, ("DestinationAddress.IA_Destination_Offset.Off_Low = 0x%x at 0x%x\n", pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low,&pMyIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low) );
        TRACE(TL_V, TM_Send, ("nNumberOfBytesToWrite = 0x%x\n", pMyIrb->u.AsyncWrite.nNumberOfBytesToWrite));
        TRACE(TL_V, TM_Send, ("nBlockSize = 0x%x\n", pMyIrb->u.AsyncWrite.nBlockSize));
        TRACE(TL_V, TM_Send, ("fulFlags = 0x%x\n", pMyIrb->u.AsyncWrite.fulFlags));
        TRACE(TL_V, TM_Send, ("Mdl = 0x%x\n", pMyIrb->u.AsyncWrite.Mdl ));
        TRACE(TL_V, TM_Send, ("ulGeneration = 0x%x at 0x%x \n", pMyIrb->u.AsyncWrite.ulGeneration, &pMyIrb->u.AsyncWrite.ulGeneration));
        TRACE(TL_V, TM_Send, ("chPriority = 0x%x\n", pMyIrb->u.AsyncWrite.chPriority));
        TRACE(TL_V, TM_Send, ("nSpeed = 0x%x\n", pMyIrb->u.AsyncWrite.nSpeed));

}





NDIS_STATUS
DummySendPacketsHandler(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    )
    //
    // To be used on a non-send VC
    //
{

    return NDIS_STATUS_FAILURE;

}
















VOID
nicSendFailureInvalidGeneration(
    PVCCB pVc
    )

    
    // Function Description:
    //
    //  An AsyncStream or AnsyncWrite Irp  may be completed
    //  with a status of InvalidGeneration. This function will try and
    //  get a new generation, so that future sends will not be blocked
    //
    // Arguments
    //
    //
    //
    // Return Value:
    //
    //
    //
    //

{
    NDIS_STATUS NdisStatus  = NDIS_STATUS_FAILURE;
    PADAPTERCB pAdapter = pVc->Hdr.pAF->pAdapter;
    
    TRACE( TL_T, TM_Send, ( "==>nicSendFailureInvalidGeneration ") );

    ASSERT (pVc != NULL);
    
    do
    {
        PNDIS_WORK_ITEM pGetGenerationWorkItem  = NULL;
        BOOLEAN fWorkItemAlreadyLaunched  = FALSE;
        BOOLEAN fQueueWorkItem = FALSE;

        
        TRACE( TL_A, TM_Send, ( "Cause: Invalid generation on the asyncwrite packet"  ) );

        VC_ACQUIRE_LOCK (pVc);

        if (VC_ACTIVE(pVc) == TRUE)
        {
            fQueueWorkItem = TRUE;
        }
        
        fWorkItemAlreadyLaunched = (VC_TEST_FLAGS (pVc, VCBF_GenerationWorkItem));
        
        if (fWorkItemAlreadyLaunched)
        {
            //
            // If the Work Item has already been launched, then do not launch another instance
            //
            fQueueWorkItem = FALSE;
        }
        
        if ( fQueueWorkItem )
        {
            nicReferenceCall (pVc, "nicSendFailureInvalidGeneration");
        }
        
        VC_RELEASE_LOCK (pVc);

        

        if (fQueueWorkItem == FALSE)
        {
            // this thread simply exits 
            break;
        }
        //
        // We need to update the generation count
        //
        pGetGenerationWorkItem = ALLOC_NONPAGED (sizeof(NDIS_WORK_ITEM), MTAG_WORKITEM); 

        if (pGetGenerationWorkItem == NULL)
        {
            TRACE( TL_A, TM_Cm, ( "Local Alloc failed for WorkItem - GetGeneration FAILED" ) );

            break;
        }

        VC_ACQUIRE_LOCK (pVc);

        VC_SET_FLAG(pVc, VCBF_GenerationWorkItem    );
        
        VC_RELEASE_LOCK (pVc);

        NdisInitializeWorkItem ( pGetGenerationWorkItem , 
                              (NDIS_PROC)nicGetGenerationWorkItem,
                              (PVOID)pVc );

        NdisInterlockedIncrement(&pAdapter->OutstandingWorkItems);

        NdisScheduleWorkItem (pGetGenerationWorkItem );

        
        NdisStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);





    TRACE( TL_T, TM_Send, ( "<==nicSendFailureInvalidGeneration %x", NdisStatus) );



}





NDIS_STATUS
nicInsertGaspHeader (
    IN PADAPTERCB pAdapter,
    IN PNDIS_PACKET pNdisPacket
    )
    // Function Description:
    //   For an async stream a GASP header needs to inserted at the head of the packet
    //   This will then be used in the send.
    //   The GASP Header will be removed before returning the Packet to the protocol
    // Arguments
    //  pAdapter- Local Host
    //  pNdisPacket - Packet To be transmitted
    //
    // Return Value:
    //  Status - success, if all allocations and insertions succeed
    //
{
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_BUFFER        pGaspNdisBuffer = NULL;
    PGASP_HEADER        pGaspHeader=NULL;
    USHORT              SourceID;
    TRACE( TL_T, TM_Send, ( "==>nicInsertGaspHeader pAdapter %x, pNdisPacket%x", pAdapter, pNdisPacket) );

    do
    {
        //
        //  Get Mdl and Memory for the GASP Header. Eventually we will have lookaside list of MDLS and Buffers
        //

        NdisStatus = nicGetGaspHeader ( &pGaspNdisBuffer);

        if (NdisStatus != NDIS_STATUS_SUCCESS || pGaspNdisBuffer== NULL)
        {
            BREAK( TL_A, ( "nicInsertGaspHeader : nicGetGaspHeader FAILED") );
        }

        pGaspHeader = nicNdisBufferVirtualAddress(pGaspNdisBuffer);

        ASSERT (pGaspHeader != NULL);
        
        TRACE( TL_V, TM_Send, ( "pGaspNdisBuffer %x, GaspHeader %x", pGaspNdisBuffer, pGaspHeader) );

        TRACE( TL_V, TM_Send, ( "pAdapter->NodeAddress %x", pAdapter->NodeAddress) );
            

        SourceID = *((PUSHORT)&pAdapter->NodeAddress);

        TRACE( TL_V, TM_Send, ( "SourceId %x at %x", SourceID, &SourceID) );
        
        pGaspHeader->FirstQuadlet.Bitmap.GH_Source_ID = SourceID ; 

        pGaspHeader->FirstQuadlet.Bitmap.GH_Specifier_ID_Hi = GASP_SPECIFIER_ID_HI;
        
        pGaspHeader->SecondQuadlet.Bitmap.GH_Specifier_ID_Lo = GASP_SPECIFIER_ID_LO;

        pGaspHeader->SecondQuadlet.Bitmap.GH_Version = 0;       

        NdisChainBufferAtFront (pNdisPacket, pGaspNdisBuffer);

        pGaspHeader->FirstQuadlet.GaspHeaderHigh = SWAPBYTES_ULONG (pGaspHeader->FirstQuadlet.GaspHeaderHigh );
        pGaspHeader->SecondQuadlet.GaspHeaderLow  = SWAPBYTES_ULONG (pGaspHeader->SecondQuadlet.GaspHeaderLow   );

        TRACE( TL_V, TM_Send, ( "Gasp Header High %x", pGaspHeader->FirstQuadlet.GaspHeaderHigh) );
        TRACE( TL_V, TM_Send, ( "Gasp Header Low  %x", pGaspHeader->SecondQuadlet.GaspHeaderLow  ) );

        NdisStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);
    
    TRACE( TL_T, TM_Send, ( "<==nicInsertGaspHeader pNdisBuffer %x, NdisStatus %x ", pGaspNdisBuffer, NdisStatus) );

    return NdisStatus;
}


NDIS_STATUS
nicGetGaspHeader (
    IN OUT PNDIS_BUFFER *ppNdisBuffer
    )
    // Function Description:
    //
    //   Gets memory and an initialized NdisBuffer that can be used for 
    //   the gasp header
    // Arguments
    //  ppNdisBuffer  - returned NdisBuffer 
    // Return Value:
    //  Status - success, if all allocations succeed
    //
{

    PVOID pBuffer= NULL;
    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
    
    TRACE( TL_T, TM_Send, ( "==>nicGetGaspHeader  ppNdisBuffer %x", ppNdisBuffer) );

    *ppNdisBuffer = NULL;
    
    do
    {
        pBuffer = ALLOC_NONPAGED(sizeof(GASP_HEADER), MTAG_DEFAULT);
        
        if (pBuffer == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            nicIncrementMallocFailure();
            BREAK ( TM_Send, ( "nicGetGaspHeader : MEM Alloc FAILED ") );
        }


        NdisStatus = nicGetNdisBuffer(sizeof(GASP_HEADER), pBuffer, ppNdisBuffer);

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            BREAK(  TM_Send, ( "nicGetGaspHeader : nicGetNdisBuffer FAILED") );
        }

        NdisStatus = NDIS_STATUS_SUCCESS;
            
    } while (FALSE);


    TRACE( TL_T, TM_Send, ( "==>nicGetGaspHeader pNdisBuffer %x , Status %x", *ppNdisBuffer, NdisStatus) );
    return NdisStatus;  

}


VOID
nicFreeGaspHeader (
    IN PNDIS_BUFFER pGaspNdisBuffer
    )
    // Function Description:
    //
    //   Frees memory occupied by the Gasp Header. frees the Ndis Buffer pointing to the Gasp Header
    //
    // Arguments
    // pGapsNdisBuffer  - returned NdisBuffer 
    //
    // Return Value:
    //  None
{

   TRACE( TL_T, TM_Send, ( "==>nicFreeGaspHeader  pGaspNdisBuffer %x ", pGaspNdisBuffer) );
    ASSERT (pGaspNdisBuffer != NULL); 
    //
    // Free the locally allocated memory that the ndis buffer points to 
    //

    FREE_NONPAGED (nicNdisBufferVirtualAddress (pGaspNdisBuffer) );

    //
    // Free the ndis buffer itself
    //
    NdisFreeBuffer (pGaspNdisBuffer);


   TRACE( TL_T, TM_Send, ( "<==nicFreeGaspHeader  pGaspNdisBuffer %x ", pGaspNdisBuffer) );


}
    

VOID
nicMakeGaspHeader (
    IN PADAPTERCB pAdapter,
    IN PGASP_HEADER pGaspHeader
    )
    // Function Description:
    //   This function will take the adapter structure and construct a Gasp Header out of it. 
    //   This will be used to make the AsyncStream packets.
    //  
    //
    //
    // Arguments
    //  pAdapter - Local Host in question
    //  pGaspHeader - Location where the Gasp Header is to be stored
    //
    // Return Value:
    //  None
    //

{
    USHORT              SourceID;
    NODE_ADDRESS        LocalNodeAddress;
    NDIS_STATUS         NdisStatus;

    TRACE( TL_T, TM_Send, ( "==>nicMakeGaspHeader  padapter %x, pGaspNdisBuffer %x ", pAdapter, pGaspHeader) );
    
    ASSERT (pGaspHeader != NULL);
    

    TRACE( TL_V, TM_Send, ( "pAdapter->NodeAddress %x", pAdapter->NodeAddress) );
        

    SourceID = *((PUSHORT)&pAdapter->NodeAddress);

    if(SourceID ==0)
    {
        NdisStatus  = nicGet1394AddressFromDeviceObject (pAdapter->pNdisDeviceObject, 
                                                          &LocalNodeAddress, 
                                                          USE_LOCAL_NODE);

        if ( NdisStatus == NDIS_STATUS_SUCCESS)
        {       
            SourceID = *((PUSHORT)&LocalNodeAddress);

            ADAPTER_ACQUIRE_LOCK (pAdapter);

            pAdapter->NodeAddress = LocalNodeAddress;
                
            ADAPTER_RELEASE_LOCK (pAdapter);
        }
        //
        // Do not handle failure. As the BCM or a Reset will fix this problem
        //
    }


    TRACE( TL_V, TM_Send, ( "SourceId %x at %x", SourceID, &SourceID) );
    
    pGaspHeader->FirstQuadlet.Bitmap.GH_Source_ID = SourceID ; 

    pGaspHeader->FirstQuadlet.Bitmap.GH_Specifier_ID_Hi = GASP_SPECIFIER_ID_HI;
    
    pGaspHeader->SecondQuadlet.Bitmap.GH_Specifier_ID_Lo = GASP_SPECIFIER_ID_LO;

    pGaspHeader->SecondQuadlet.Bitmap.GH_Version = 1;       

    pGaspHeader->FirstQuadlet.GaspHeaderHigh = SWAPBYTES_ULONG (pGaspHeader->FirstQuadlet.GaspHeaderHigh );
    pGaspHeader->SecondQuadlet.GaspHeaderLow  = SWAPBYTES_ULONG (pGaspHeader->SecondQuadlet.GaspHeaderLow   );

    TRACE( TL_V, TM_Send, ( "Gasp Header High %x", pGaspHeader->FirstQuadlet.GaspHeaderHigh) );
    TRACE( TL_V, TM_Send, ( "Gasp Header Low  %x", pGaspHeader->SecondQuadlet.GaspHeaderLow  ) );

    TRACE( TL_T, TM_Send, ( "<==nicFreeGaspHeader %x, %x ", pGaspHeader->FirstQuadlet.GaspHeaderHigh, pGaspHeader->SecondQuadlet.GaspHeaderLow  ) );


}








NTSTATUS
AsyncWriteStreamSendComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pMyIrp,
    IN PVOID            Context   
    )


    //
    //  N.B.  this completes both Fifo and channels
    //
    //
    //  This function is Completion handler for the Irp used to send data.
    //  This function will invoke NDisCoSendComplete Handler
    //  Needs to use the VC Handle stored in the MiniportReserved[0] 
    //  of the packet. 
    //  We free all the data structures allocated on the way down,  
    //  by SendPacketsHandler (the Irb. Irp and Local memory used and Mdl) 
    //
    //  The LookasideHeader->OutstandingFragments should normally be one for 
    //  the defualt ( non-fragmented) case. However, if a failure in SendPackets
    //  occurs, Outstanding fragments  will be zero or the context will be null, 
    //  in that case we will only free the lookaside buffer (if it exists) and exit,  
    //  it will be the responsibility of the SendPacketsHandler
    //  to fail the packet.
    //

{

    
    NDIS_STATUS                 NdisStatus  = NDIS_STATUS_SUCCESS;  
    NTSTATUS                    IrpStatus   = STATUS_UNSUCCESSFUL;
    PVOID                       pLookasideListBuffer  = Context;  
    PLOOKASIDE_BUFFER_HEADER    pLookasideHeader = (PLOOKASIDE_BUFFER_HEADER)pLookasideListBuffer ; 
    PNDIS_PACKET                pPacket = NULL;
    PVCCB                       pVc = NULL; 
    PREMOTE_NODE                pRemoteNode = NULL;
    NDIS_HANDLE                 NdisVcHandle = NULL;
    ULONG                       OutstandingFragments  = 0;
    BUS_OPERATION               AsyncOp;
    PNIC_NPAGED_LOOKASIDE_LIST  pLookasideList = NULL;
    STORE_CURRENT_IRQL;


    TRACE( TL_T, TM_Send, ( "==>AsyncWriteStreamSendComplete, pMyIrp %x, Context %x", 
                                 pMyIrp, Context   ) );

    do 
    {
        if (pLookasideHeader == NULL)
        {
            TRACE( TL_V, TM_Send, ( "   AsyncSendComplete -  pLookasideHeader == NULL") );
            break;

        }
    

        //
        // This means that a lookaside buffer was allocated and
        // perhaps MDLS were allocated 
        //  if this is the last fragment, Free all the MDLs first
        //

        //
        // Get all the valuable information out of the header. 
        //

        pPacket         = pLookasideHeader->pNdisPacket;
        pVc             = pLookasideHeader->pVc; 
        pRemoteNode     = pVc->Hdr.pRemoteNode;
        pLookasideList  = pLookasideHeader->pLookasideList;
        AsyncOp         = pLookasideHeader->AsyncOp;

        ASSERT (AsyncOp != InvalidOperation);
        
        TRACE( TL_V, TM_Send, ( " Vc %x,, pLookaside Buffer %x, pPacket, %x", 
                                pVc, pLookasideHeader ,pPacket  ) );

        ASSERT (pLookasideList != NULL);

        //
        // This will tell us if this thread has received the last fragment
        // OustandingPackets == 0 gets to free the MDLS, and complete the packet
        //
        OutstandingFragments = NdisInterlockedDecrement (&pLookasideHeader->OutstandingFragments );


        if (OutstandingFragments == 0)
        {
            //
            // If there are no more fragments, then we need to 
            // free all the allocated structures ( the MDLS) on this buffer
            //
            
            ULONG  MdlsToFree = pLookasideHeader->FragmentsGenerated;

            PIRB pIrb = &((PUNFRAGMENTED_BUFFER)pLookasideHeader)->Irb;
            

            //
            // The maximum number of MDLS we can have is equal to
            // the maximum number of Fragments that were generated
            //
            while (MdlsToFree != 0)
            {
                PMDL pMdl = NULL;

                GET_MDL_FROM_IRB (pMdl, pIrb, AsyncOp);
                

                TRACE( TL_V, TM_Send, ( " Freeing Mdl %x of Irb %x ", 
                                         pMdl, pIrb) );

        
                if (pMdl != NULL)
                {
                    nicFreeMdl (pMdl);
                    if (pVc->Hdr.VcType == NIC1394_SendFIFO)  
                    {                                           
                        nicDecFifoSendMdl();                    
                    }                                           
                    else                                           
                    {                                           
                        nicDecChannelSendMdl();                 
                    }                                           
                
                }

                //
                // Set up for the next iteration
                //
                MdlsToFree --; 

                pIrb = (PVOID)((ULONG_PTR)pIrb + sizeof (IRB));


            } //while (MdlsToFree  != 0)



        } //if (OutstandingFragments == 0)


        //
        //  Map the NT_STATUS belonging to the Irp to an NdisStatus and call NdisMCoSendComplete
        //  Print Debug Output to help in testing. Need to Add more status cases  
        //
        if (pMyIrp == NULL)
        {   
            TRACE( TL_V, TM_Send, ( "   AsyncSendComplete - pIrp is NULL") );
            IrpStatus = STATUS_UNSUCCESSFUL;
        }
        else
        {
            

            //
            // We have a valid IRP, lets see if we failed the IRP and why
            // 
            IrpStatus   = pMyIrp->IoStatus.Status;

            nicIncrementBusSendCompletes(pVc);
        }
        
        if (IrpStatus != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Send, ( "==>IRP FAILED StatusCode = %x",IrpStatus  ) );

            nicIncrementBusFailure();
            nicIncrementVcBusSendFailures(pVc, pPacket);

            //
            // The generation of the bus has changed. Lets get a new one.
            //
            
            if (IrpStatus == STATUS_INVALID_GENERATION)
            {
                nicSendFailureInvalidGeneration((PVCCB)pVc);
            }
            
            NdisStatus = NtStatusToNdisStatus(IrpStatus);
            
            NdisInterlockedIncrement (&pVc->Hdr.pAF->pAdapter->AdaptStats.ulXmitError);
        }
        else
        {
            NdisInterlockedIncrement(&pVc->Hdr.pAF->pAdapter->AdaptStats.ulXmitOk);
            nicIncrementVcBusSendSucess(pVc, pPacket);
        }

        //
        // Free the Irp and don't touch it after this
        //
        if (pMyIrp != NULL)
        {
            nicFreeIrp (pMyIrp);
            pMyIrp = NULL;
        }
        
        //
        // At this point, we know that the IRP went down to the bus driver
        // We know if this is the last fragment. So lets figure out if we need
        // to Complete the packet
        //

        if (OutstandingFragments != 0)
        {
            //
            // We need to wait for other fragments to complete
            //
            TRACE( TL_V, TM_Send, ( "   AsyncSendComplete = NOT  the last fragment") );

            break;

        }
        
    
        //
        // This means that this thread has marked the lookaside header as 'to be freed'
        // and it is this thread's responsibility to free it.
        //
        NdisVcHandle = pVc->Hdr.NdisVcHandle;
        
        TRACE( TL_V, TM_Send, ( "Calling NdisCoSendComplete, status %x, VcHandle %x, pPacket %x",
                                NdisStatus,NdisVcHandle, pPacket ) );

        
        nicMpCoSendComplete (NdisStatus,
                            pVc,
                            pPacket);


        nicFreeToNPagedLookasideList (pLookasideList, pLookasideListBuffer); 

        nicDereferenceCall (pVc, "AsyncWriteStreamSendComplete");

        //
        // Remove the reference on the PDO that the IRP was sent to
        //
        if (AsyncOp == AsyncWrite)
        {
            //
            // Async Write references the remote node 
            //
            ASSERT (pRemoteNode != NULL);
            nicDereferenceRemoteNode (pRemoteNode, "AsyncWriteStreamSendComplete");
        }
        

    } while (FALSE);


    TRACE( TL_T, TM_Send, ( "<== AsyncWriteStreamSendComplete, NdisStatus %x,IrpStatus %x ",
                             NdisStatus, IrpStatus ) );
  
    //
    // ALWAYS RETURN STATUS_MORE_PROCESSING_REQUIRED
    //

    MATCH_IRQL;

    return STATUS_MORE_PROCESSING_REQUIRED;
}




NDIS_STATUS
AsyncWriteSendPacketsHandler(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    )
    
    //
    //  This is the VC handler when packet is sent using the 
    //  AsyncWrite 1394 Bus Api
    //  This function, copies the contents of the packet to locally 
    //  owned memory, sets up the Irb and the Irp and calls 
    //  nicSubmitIrp which is the generic cal to do a IoCallDriver
    // 
    // The return value is success, if the I/o was successfully pended
{
    
    PSENDFIFO_VCCB                  pSendFIFOVc = (SENDFIFO_VCCB*)pVc;
    PMDL                            pMyMdl = NULL;
    PIRB                            pMyIrb = NULL;
    PIRP                            pMyIrp = NULL;
    BOOLEAN                         fVcActive = TRUE;
    PREMOTE_NODE                    pRemoteNode = NULL;
    NDIS_STATUS                     NdisStatus = NDIS_STATUS_FAILURE;
    NTSTATUS                        NtStatus = STATUS_UNSUCCESSFUL;
    ULONG                           PacketLength = 0;
    PVOID                           pLookasideListBuffer  = NULL;
    PADAPTERCB                      pAdapter = NULL;
    USHORT                          FragmentLength = 0;
    PNDIS_BUFFER                    pStartNdisBuffer = NULL;
    PVOID                           pStartPacketData  = NULL;
    PLOOKASIDE_BUFFER_HEADER        pLookasideHeader = NULL;
    PNIC_NPAGED_LOOKASIDE_LIST      pLookasideList = NULL;
    ENUM_LOOKASIDE_LIST             WhichLookasideList = NoLookasideList;
    FRAGMENTATION_STRUCTURE         Fragment;
    ULONG                           NumFragmentsNeeded ;
    STORE_CURRENT_IRQL;


    NdisZeroMemory (&Fragment, sizeof (FRAGMENTATION_STRUCTURE));
    
    TRACE( TL_T, TM_Send, ( "==>AsyncWriteSendPacketHandler, Vc %x,Packet %x, FragmentationStruct %x", 
                           pSendFIFOVc, pPacket , &Fragment ) );

    pRemoteNode = pSendFIFOVc->Hdr.pRemoteNode;
    ASSERT (pRemoteNode != NULL);



    do 
    {
        
        VC_ACQUIRE_LOCK (pSendFIFOVc);

        //
        // Make sure that the Vc is Activated and that no close calls 
        // are pending or that we have already completed a close call
        //

        
        if ( VC_ACTIVE (pSendFIFOVc) == FALSE || REMOTE_NODE_ACTIVE(pRemoteNode) == FALSE)
        {
            fVcActive = FALSE;  
        }

        if (VC_TEST_FLAG( pSendFIFOVc, VCBF_GenerationWorkItem) == TRUE)
        {
            TRACE( TL_N, TM_Send, ( "AsyncWriteSendPacketHandler, Getting a new Gen, Fail send ") );

            fVcActive = FALSE;  
        }

        //
        // This reference will either be dereferenced below in a call to FreeSendPacketDataStructure
        // below or a call to FreeSendPacketDataStructure made from the Irp's completion routine
        //

        if (fVcActive == TRUE)
        {
            nicReferenceCall (pVc, "AsyncWriteSendPacketsHandler");

            nicReferenceRemoteNode (pRemoteNode, "AsyncWriteSendPacketsHandler");

        }
        
        VC_RELEASE_LOCK (pSendFIFOVc);

        if (fVcActive  == FALSE)
        {
            TRACE( TL_N, TM_Send, ( "AsyncWriteSendPacketHandler, VC Not Active, Vc %x Flag %x", pSendFIFOVc,pSendFIFOVc->Hdr.ulFlags ) );

            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        pAdapter = pSendFIFOVc->Hdr.pAF->pAdapter;
        
        //
        //  Copy NdisBuffer in Packet to Local Memory and get an Mdl that points 
        //  to this memory 
        //
        NdisQueryPacket( pPacket,
                         NULL,
                         NULL,
                         NULL,
                         &PacketLength);

        ASSERT (pPacket->Private.Head != NULL);

        //
        // Temporary debug spew
        //
        PrintNdisPacket (TM_Send, pPacket);


        //
        // Initialize the start variables
        //

        pStartNdisBuffer = pPacket->Private.Head;
        pStartPacketData = nicNdisBufferVirtualAddress (pStartNdisBuffer);

        if (pStartPacketData == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            TRACE( TL_N, TM_Send, ( "AsyncWriteSendPacketHandler, pStartPacketData ") );

            break;
        }

        TRACE( TL_V, TM_Send, ( "PacketLength %x", PacketLength) );

        //
        // Make a decision on which lookaside list to use. If the tx is unfragmented 
        // then copy over the ndis packet as well
        //

        //
        // first choose the lookaside list. the actual lookaside list is chosen so that the 
        // each can accomodate the maximum number of fragments at its payload
        //
        //
        if (PacketLength < PAYLOAD_100)
        {
            pLookasideList = &pAdapter->SendLookasideList100;
            WhichLookasideList = SendLookasideList100;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_100 Lookaside List %x", 
                                    &pAdapter->SendLookasideList100) );

        }
        else 
        if (PacketLength < PAYLOAD_2K)
        {
            pLookasideList = &pAdapter->SendLookasideList2K;
            WhichLookasideList = SendLookasideList2K;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_2K Lookaside List %x", 
                                    &pAdapter->SendLookasideList2K) );


        } 
        else
        if (PacketLength < PAYLOAD_8K)
        {
            pLookasideList = &pAdapter->SendLookasideList8K;
            WhichLookasideList  = SendLookasideList8K;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_8K Lookaside List %x", 
                                    &pAdapter->SendLookasideList8K) );

    
        }
        else
        {
            //
            // Large Sends not supported
            // TODO : Add code for local allocation
            //
            ASSERT (!"SendPacket Too Large - Not supported Yet" );
            break;  
        }

        //
        // are we going to fragment
        // 
        ASSERT (pLookasideList != NULL)

        //
        // We are not going to fragment. Optimize this path
        //
        pLookasideListBuffer = nicGetLookasideBuffer (pLookasideList);
        
        if (pLookasideListBuffer == NULL )
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            BREAK (TM_Send, ("nicGetLookasideBuffer  FAILED") );
        }

        //
        // Initialize the header with relevant information that the send complete
        // will need
        //
    
        pLookasideHeader = (PLOOKASIDE_BUFFER_HEADER)pLookasideListBuffer;
        pLookasideHeader->IsFragmented          = FALSE;  // Default
        pLookasideHeader->FragmentsGenerated    = 0;
        pLookasideHeader->pLookasideList        = pLookasideList;
        pLookasideHeader->pNdisPacket           = pPacket;
        pLookasideHeader->pVc                   =(PVCCB)pVc;
        pLookasideHeader->AsyncOp               = AsyncWrite;

        //
        // Initialize the Fragment structure
        //
        //
        //  Do we fragment or not. Base it on the MaxPayload possible
        //
        
        TRACE( TL_V, TM_Send, ( "    PacketLength %x, pSendFIFOVc->MaxPayload%x ", 
                                 PacketLength ,pSendFIFOVc->Hdr.MaxPayload) );


        if (PacketLength <= pSendFIFOVc->Hdr.MaxPayload)
        {
            //
            // No need to fragment here. We will use the UNFRAGMENTED Layout
            //
            // First Get a local buffer from our lookaside list
            //
            PUNFRAGMENTED_BUFFER pUnfragmentedBuffer = (PUNFRAGMENTED_BUFFER )pLookasideHeader;

            NumFragmentsNeeded = 1;

            NdisStatus = nicCopyNdisBufferChainToBuffer (pStartNdisBuffer, 
                                                        (PVOID)&pUnfragmentedBuffer ->Data[0],
                                                         pLookasideList->MaxSendSize );
                                             
    
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                pLookasideHeader->OutstandingFragments  = 1;  // this is our refcount
                BREAK ( TM_Send, ( "   AsyncStreamSendPacketHandler, nicCopyNdisPacketToUnfragmentedBuffer Failed ") );
            }
    
            ASSERT (pLookasideListBuffer != NULL);

            // 
            // Initialize all the variable needed by the Next section of the code.
            // This deals with setting up the Mdl and the IRB
            //
            
            pStartNdisBuffer = NULL;

            Fragment.pStartFragment = (PVOID) &pUnfragmentedBuffer ->Data[0];
            Fragment.FragmentLength  = PacketLength;
            Fragment.pCurrNdisBuffer = NULL;

            pLookasideHeader->FragmentsGenerated = 1; 
            pLookasideHeader->IsFragmented = FALSE;                                    
            pLookasideHeader->OutstandingFragments  = 1;  // this is our refcount
        
        }
        else
        {
            //
            // We need to fragment
            //
            ULONG Dgl = NdisInterlockedIncrement(&pAdapter->dgl);

            //
            // Fragments will be needed . Make sure the calculation for numFragments catches the boundary conditions
            //

            
            NumFragmentsNeeded = nicNumFragmentsNeeded (PacketLength,
                                                        pSendFIFOVc->Hdr.MaxPayload,
                                                        sizeof (NDIS1394_FRAGMENT_HEADER) );


            //
            // Initialize the fragment structure. The unfragmented code path
            // does not care about these fields
            //

            //
            // This structure is local to this function and this thread. 
            //
            Fragment.TxHeaderSize = sizeof (NDIS1394_FRAGMENT_HEADER);
            Fragment.pLookasideListBuffer = pLookasideListBuffer;
            Fragment.AsyncOp = AsyncWrite;
            Fragment.pAdapter = pRemoteNode->pAdapter;
            Fragment.pLookasideList = pLookasideList;
            Fragment.IPDatagramLength = (USHORT)PacketLength - sizeof (NDIS1394_UNFRAGMENTED_HEADER); 
            
            //
            // Get Start of first Dest fragment
            //
            Fragment.MaxFragmentLength = pSendFIFOVc->Hdr.MaxPayload;                                                                   
            Fragment.NumFragmentsNeeded = NumFragmentsNeeded;
        
            

            
            // 
            // Set up the Fragment Headers that will be used in fragmentation
            //

            NdisStatus = nicFirstFragmentInitialization (pPacket->Private.Head,
                                                     Dgl,
                                                     &Fragment);


            if (pLookasideListBuffer  == NULL || NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK (TM_Send, (" AsyncWriteSendPacketsHandler: nicFirstFragmentInitialization : FAILED" )) ;
            }       

            ASSERT (pLookasideListBuffer != NULL);
            
            pLookasideHeader->IsFragmented = TRUE;                                     
            pLookasideHeader->OutstandingFragments  = NumFragmentsNeeded ;  // this is our refcount
            
        }


        TRACE( TL_V, TM_Send, ( "NumFragments  %x, pSendFIFOVc->MaxSendSize %x, Packet Size %x", 
                                 NumFragmentsNeeded,pSendFIFOVc->Hdr.MaxPayload, PacketLength) );


        //
        // Now begin the loop which will send n fragments
        //
        do 
        {   

            //
            // Do we need to fragment. If so , extract one fragment out of the NdisPacket
            //
            if (pLookasideHeader->IsFragmented == TRUE )
            {   
            
                //
                // We copy one fragment over and this will allocate the lookaside list
                //

                NdisStatus = nicCopyOneFragment (&Fragment);
                
                if (NDIS_STATUS_SUCCESS != NdisStatus)
                {
                    BREAK ( TM_Send, ( "   AsyncWriteSendPacketHandler, nicCopyOneFragment  Failed ") );
                }
                                              
                //
                // Get the pointer to the Irb here . Amd set it up for the next time
                //
                pMyIrb = Fragment.pCurrentIrb;
                Fragment.pCurrentIrb = (PIRB)((ULONG_PTR)Fragment.pCurrentIrb + sizeof (IRB) );
                TRACE( TL_V, TM_Send, ( " pMyIrb  %x, Next Irb %x  ", pMyIrb  , Fragment.pCurrentIrb ) );

            }
            else
            {
                //
                // No Curr NdisBuffer as this packet was never fragmented. 
                //
                
                ASSERT (pLookasideHeader->IsFragmented == FALSE);                                      

                pMyIrb =  &((PUNFRAGMENTED_BUFFER )pLookasideHeader)->Irb;
            }
            
            //
            // At this point we have one fragment that needs to be transmitted.
            // Data structures have been updated to set up the MDL and the IRB
            //
            ASSERT (Fragment.pStartFragment != NULL);

            NdisStatus = nicGetMdl (Fragment.FragmentLength  , 
                                    Fragment.pStartFragment, 
                                    &pMyMdl);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                pMyMdl = NULL;
                BREAK ( TM_Send, ( "   AsyncWriteSendPacketHandler, nicCopyNdisBufferChainToBuffer Failed ") );
            }       

            nicIncFifoSendMdl();
            //
            //  Fill in the Irb with the correct values from the VC
            //  Stuff we need to add to the send VC - BlockSize,Generation
            //  

            nicInitAsyncWriteIrb(pSendFIFOVc, pMyMdl, pMyIrb);

            //
            // Get a free Irp 
            //

            NdisStatus  = nicGetIrp (pRemoteNode->pPdo, &pMyIrp); 
        
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                pMyIrp = NULL;
                break;
            }
            //
            // At this point, we have a guarantee that the Completion routine will be called
            //
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

            //
            // Dump the Fragment 
            //
            nicDumpMdl (pMyMdl , 0, "AsyncWrite Fragment");

            NIC1394_LOG_PKT(
                pAdapter,
                NIC1394_LOGFLAGS_SEND_FIFO,
                pAdapter->BCRData.LocalNodeNumber,          // SourceID
                pRemoteNode->RemoteAddress.NA_Node_Number,  // DestID
                Fragment.pStartFragment, 
                Fragment.FragmentLength
                );


            //
            // This function implements the common functionality to be implemented by
            // all other send/recv cals to IoCallDriver
            //
            //
            // We IGNORE the NtStatus as the completion handler will be called
            //
            nicIncrementBusSends(pVc);
                    
            NtStatus = nicSubmitIrp(pRemoteNode->pPdo,
                                    pMyIrp,
                                    pMyIrb,
                                    AsyncWriteStreamSendComplete,
                                   (PVOID)pLookasideListBuffer);

            TRACE( TL_V, TM_Send, ( " pCurrNdisBuffer  %x, NdisStatus %x ", Fragment.pCurrNdisBuffer , NdisStatus ) );

            
        } while (Fragment.pCurrNdisBuffer != NULL && NdisStatus == NDIS_STATUS_SUCCESS);

    
    } while (FALSE);

    //
    // DO NOT touch the packet if status == NDIS_STATUS_SUCCESS. 
    //

    
    //
    //  CleanUp if any of the allocations failed. We do not have a pointer
    //  to the LocalBuffer (it is embedded in the Mdl)  so it remains NULL
    //
    //  NdisStatus != Success means that we never got to nicSubmitIrp
    //
    
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {   

        ASSERT (pMyIrp == NULL);

        //
        // fVc Active makes sure that we actually got around to allocating 
        // and referencing structures
        //
        
        if (fVcActive == TRUE)
        {

            if (pLookasideListBuffer != NULL)
            {

                //
                // Complete this fragment, as we never submit'd the IRP to
                // the 1394 bus driver
                //
                AsyncWriteStreamSendComplete(NULL, // PDO
                                             NULL, 
                                             pLookasideListBuffer);

                NdisStatus =NDIS_STATUS_SUCCESS;
            }                                  
            else
            {

                //
                // This thread needs to decrement the refcounts as 
                // AsyncWriteStreamSendComplete was not called
                //
                nicDereferenceCall ((PVCCB) pSendFIFOVc, "AsyncWriteSendPacketsHandler");

                nicDereferenceRemoteNode (pRemoteNode, "AsyncWriteSendPacketsHandler");

            }

            
        }

    }


    

    TRACE( TL_T, TM_Send, ( "<==AsyncWriteSendPacketHandler, NdisStatus  %x", NdisStatus ) );
    MATCH_IRQL;

    return NdisStatus;
}





//
// Split the lookaside header to a local variable + context
//

NDIS_STATUS
nicCopyOneFragment (
    PFRAGMENTATION_STRUCTURE pFragment
    )
    
    // Function Description:
    //   This creates one fragment filled with valid data and returns it
    //
    //
    // Arguments
    // ppCurrNdisBuffer - CurrNdisBuffer from which the data is to be copied
    // ppLookasideListBuffer - if this is NULL, it implies that this is the first fragment 
    //                      and a lookaside buffer will be allocated
    //
    // ppSourceAddress  -  is the current pointer to the start of the data that needs to be copied
    //                     Should always lie within the NdisBuffer or be NULL 
    // Return Value:
    //  ppCurrNdisBuffer - If the CurrNdisBuffer does not contain enough data for the 
    //                   fragment, then CurrNdisBuffer will be incremented and the new
    //                  CurrNdisBuffer will be returned here
    //
    //
{
    NDIS_STATUS                         NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_BUFFER                        pCurrNdisBuffer = pFragment->pCurrNdisBuffer;
    PVOID                               pSourceAddressInNdisBuffer = pFragment->pSourceAddressInNdisBuffer;
    ULONG                               FragmentLengthRemaining = pFragment->MaxFragmentLength;
    USHORT                              FragmentLength=0;
    PVOID                               pSource = NULL;
    PVOID                               pDestination = NULL;
    PVOID                               pStartFragmentData = NULL;
    ULONG                               NdisBufferLengthRemaining = pFragment->NdisBufferLengthRemaining;
    ULONG                               LengthToCopy = 0;
    ULONG                               FragmentCopyStatus=0;
    PLOOKASIDE_BUFFER_HEADER            pLookasideHeader = NULL;
    enum 
    {
        FRAGMENT_COPY_Invalid,
        FRAGMENT_COPY_NdisBufferCompleted,
        FRAGMENT_COPY_NdisBufferAndFragmentCompleted,
        FRAGMENT_COPY_FragmentCompleted
    };
    
    TRACE( TL_T, TM_Send, ( "==>nicCopyOneFragment  pFragment %x", pFragment )  );
    ASSERT (pCurrNdisBuffer != NULL);
    do 
    {

        //
        //  lets get the destination. We need to account for 
        //  ther fragment size and add it to the previous start address
        //

        {
            ULONG   CurrFragOffset;

            CurrFragOffset  = pFragment->MaxFragmentLength * (pFragment->CurrFragmentNum++);
            
            pStartFragmentData  = (PVOID) ((ULONG_PTR) pFragment->pStartOfFirstFragment + CurrFragOffset );
        
        }



        pFragment->pStartFragment  = pStartFragmentData;

        TRACE( TL_V, TM_Send, ( " pStartFragmentData  %x", pStartFragmentData) );

        pLookasideHeader = (PLOOKASIDE_BUFFER_HEADER)pFragment->pLookasideListBuffer;



        //
        // Do the bookkeeping , Increase refcount and num of fragments used. Refcount decremented in FreeSendDataStructures
        // 

        NdisInterlockedIncrement (&pLookasideHeader->FragmentsGenerated);

        //
        // The Start of the data beginning with the fragment header goes here or in the 
        // case of async stream fragment header and gasp header go here
        //
        ASSERT (pFragment->TxHeaderSize  == 8 || pFragment->TxHeaderSize  == 16);

        
        pDestination = (PVOID) ((ULONG_PTR)pStartFragmentData + pFragment->TxHeaderSize );

        FragmentLengthRemaining -= pFragment->TxHeaderSize;

        //
        // Now we start the copy. Keep on copying into the current fragment until the MaxLength is reached 
        // or the NdisBufferChain is exhausted
        //

        pSource = pSourceAddressInNdisBuffer; 


        do
        {


            TRACE( TL_T, TM_Send, ( " LengthNdisBuffer  %x, FragmentLengthRemaining %x, pCurrNdisBuffer %x", 
                    NdisBufferLengthRemaining , FragmentLengthRemaining ,pCurrNdisBuffer ) ); 

            if (FragmentLengthRemaining > NdisBufferLengthRemaining )
            {
                //
                // Copy the complete NdisBuffer over
                //

                LengthToCopy = NdisBufferLengthRemaining; 
                FragmentCopyStatus = FRAGMENT_COPY_NdisBufferCompleted;

            }

            
            if (FragmentLengthRemaining < NdisBufferLengthRemaining )
            {
                //
                // Copy only as much as required
                //

                LengthToCopy = FragmentLengthRemaining;
                FragmentCopyStatus = FRAGMENT_COPY_FragmentCompleted;
                    
            }
            
            if (FragmentLengthRemaining == NdisBufferLengthRemaining  )
            {
                //
                // Copy the complete  Ndis Buffer , move  to the next ndis buffer
                // and update the NdisBufferLengthRemaining field  
                //
                LengthToCopy = NdisBufferLengthRemaining; 
                FragmentCopyStatus = FRAGMENT_COPY_NdisBufferAndFragmentCompleted;


            }

            //
            // Sanity check to make sure we are not overwriting into free memory.
            // As this should never happen, there is no recovery mechanism in place.
            //
            ASSERT (((PUCHAR)pDestination +  LengthToCopy) <=  (((PUCHAR) pLookasideHeader) + (pLookasideHeader->pLookasideList->Size) ));
            
            //
            // Do the copy
            //
                    
            TRACE ( TL_V, TM_Send, (" nicCopyOneFragment  pSource  %x , pDestination %x, Length %x", pSource, pDestination, LengthToCopy ) );
            
            NdisMoveMemory (pDestination, pSource, LengthToCopy);
            

            //
            // Update the fragment length remaininig and Total Buffer Size
            //
            FragmentLengthRemaining  -= LengthToCopy;

            FragmentLength += (USHORT)LengthToCopy;

            pDestination = (PVOID) ((ULONG_PTR) pDestination + LengthToCopy);
            //
            // Update the NdisBuffer variables 
            //
            ASSERT (pCurrNdisBuffer != NULL);
    
            TRACE( TL_V, TM_Send, ( " FragmentCopyStatus %x", FragmentCopyStatus) ); 

            switch (FragmentCopyStatus)
            {
                case FRAGMENT_COPY_NdisBufferCompleted:
                case FRAGMENT_COPY_NdisBufferAndFragmentCompleted:
                {
                    
                    //
                    // Move to the next Ndisbuffer
                    //
                    pCurrNdisBuffer = pCurrNdisBuffer->Next;
    
                    if (pCurrNdisBuffer  != NULL)
                    {
                        NdisBufferLengthRemaining = nicNdisBufferLength (pCurrNdisBuffer);

                        pSourceAddressInNdisBuffer = nicNdisBufferVirtualAddress(pCurrNdisBuffer);

                        if (pSourceAddressInNdisBuffer == NULL)
                        {
                            NdisStatus = NDIS_STATUS_RESOURCES;
                            BREAK (TM_Send, ("nicNdisBufferVirtualAddress FAILED " ) );                         
                        }

                        //
                        // Set up the values for the next iteration
                        //
                        pSource = pSourceAddressInNdisBuffer;
                        NdisBufferLengthRemaining   = nicNdisBufferLength (pCurrNdisBuffer);

                    }
                    else
                    {
                        //
                        // we have reached the end of the NdisPAcket. Mark the fragment header as such
                        //
                        pFragment->lf = lf_LastFragment;
                    }
                        
                    break;
                }
                
                case FRAGMENT_COPY_FragmentCompleted:
                {   
                    //
                    // Fragment has completed. Do not move to the next NdisBuffer
                    // However update StartCopy Address  in the NdisBuffer
                    // 
                    pSourceAddressInNdisBuffer  = (PVOID) ((ULONG_PTR) pSource + LengthToCopy );    

                    NdisBufferLengthRemaining -= LengthToCopy ;
                    
                    break;
                }


                default :
                {
                    ASSERT (0);
                }

            }

            TRACE( TL_T, TM_Send, ( "      LengthToCopy %x, FragmentLength %x, ", LengthToCopy, FragmentLength) ); 
            TRACE( TL_T, TM_Send, ( "      FragmentLengthRemaining %x, pCurrNdisBuffer %x",FragmentLengthRemaining , pCurrNdisBuffer ) ); 
            

        }while (FragmentLengthRemaining  > 0 && pCurrNdisBuffer != NULL);       


            
        
        //
        // Now that we have the buffer size. Add the fragment header
        //
        
        nicAddFragmentHeader (pStartFragmentData, 
                                pFragment,
                                FragmentLength);
                                     
                            
        TRACE( TL_T, TM_Send, ( " Fragment Header added %x", *(PULONG)pStartFragmentData) ); 

        NdisStatus = NDIS_STATUS_SUCCESS;

    }while (FALSE);

    //
    // Now update the output parameters.
    //

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {

        //
        // Update the Lookaside Header structure, to reflect the new position of all the pointers
        //
        pFragment->pCurrNdisBuffer  = pCurrNdisBuffer; 
        pFragment->pSourceAddressInNdisBuffer = pSourceAddressInNdisBuffer;

        //
        // Update the fragment structure with the length remaining in the NdisBuffer
        //
    
        pFragment->NdisBufferLengthRemaining = NdisBufferLengthRemaining ;
        pFragment->FragmentLength =  FragmentLength + pFragment->TxHeaderSize;  

        

    }
    

    TRACE( TL_T, TM_Send, ( "<==nicCopyOneFragment   pStartFragmentData %x, pLookasideListBuffer %x, pSourceAddressInNdisBuffer %x, NdisStatus %x", 
                            pStartFragmentData, pSourceAddressInNdisBuffer, NdisStatus) );

    return NdisStatus;
}










VOID
nicCopyUnfragmentedHeader ( 
    IN PNIC1394_UNFRAGMENTED_HEADER pDestUnfragmentedHeader,
    IN PVOID pSrcUnfragmentedHeader
    )
    // Function Description:
    //  Expect the  Src to be a big Endian  unfragmented packet header
    //  It will reverse the byte order in a temp variable and copy it into the 
    //  Destination provided.
    //
    // Arguments
    //   pDestUnfragmentedHeader - Destination (Little Endian
    //   pSrcUnfragmentedHeader - Source (Big Endian)
    //
    // Return Value:
    //
    //   Success if all the pointers and copy is valid
    //
{

    ULONG UnfragmentedHeader;
    
    TRACE( TL_T, TM_Send, ( "==> nicCopyUnfragmentedHeader  pDestUnfragmentedHeader %x, pSrcUnfragmentedHeader %x", 
                            pDestUnfragmentedHeader, pSrcUnfragmentedHeader ) );

    ASSERT (pSrcUnfragmentedHeader != NULL && pDestUnfragmentedHeader != NULL) ;
    
    *((PULONG)pDestUnfragmentedHeader) = SWAPBYTES_ULONG ( *(PULONG) pSrcUnfragmentedHeader);

    TRACE( TL_T, TM_Send, ( "pDestUnfragmentedHeader %x, ", *(PULONG)pDestUnfragmentedHeader) );

    
    TRACE( TL_T, TM_Send, ( " <== nicCopyUnfragmentedHeader   " ) );

}




NDIS_STATUS
nicFirstFragmentInitialization (
    IN PNDIS_BUFFER pStartNdisBuffer,
    IN ULONG DatagramLabelLong,
    IN OUT PFRAGMENTATION_STRUCTURE  pFragment           
    )
    // Function Description:
    //   This will set up the fragement headers that are required for 
    //   transmitting multiple fragments.
    //   Sets up the first source and destination for the first fragment
    //
    // Arguments
    //  pAdapter - to be used to get the dgl label and the lookaside list
    //  pStartOfData - start of the packet data . To be used in extracting the Unfragmented Header 
    //  ppLookasideListBuffer Points to the allocated lookaside buffer
    //  pplookasideheader - points to the lookaside header
    //
    // Return Value:
    //  Success if the allocation succeeds
    //
    //
{

    NDIS_STATUS                   NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS1394_FRAGMENT_HEADER   pHeader = NULL;
    PVOID                       pPacketStartData = NULL;
    USHORT                      dgl = (USHORT) DatagramLabelLong;

    
    TRACE( TL_T, TM_Send, ( "==> nicFirstFragmentInitialization  pStartNdisBuffer%x,  pFragment%x dgl %x ", 
                             pStartNdisBuffer, pFragment,    dgl ) );

    do
    {

        //
        // Get the start address for the 1st NdisBuffer.    This contains
        // the unfragmented header
        //
        pPacketStartData = nicNdisBufferVirtualAddress(pStartNdisBuffer);

        if (pPacketStartData == NULL) 
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            BREAK (TM_Send, ("NdisBufferVirtual Address is NULL " ) );
        }


        pFragment->UnfragmentedHeader.HeaderUlong = 
                SWAPBYTES_ULONG (((PNDIS1394_UNFRAGMENTED_HEADER)pPacketStartData)->HeaderUlong);

        TRACE ( TL_V, TM_Send, (" Unfragmented Header %x, pPacketStartData %x", 
                                   pFragment->UnfragmentedHeader.HeaderUlong , pPacketStartData) );

        TRACE ( TL_V, TM_Send, (" original Header lf %x, etherType %x", 
                                   pFragment->UnfragmentedHeader.u.FH_lf,
                                   pFragment->UnfragmentedHeader.u.FH_EtherType) );

                                   
    
        //
        // Now construct a fragmentation header to be used by all the fragments.
        //
        pHeader  = &pFragment->FragmentationHeader;

            
        pHeader ->u.FirstQuadlet.FH_lf = lf_FirstFragment;
        pHeader ->u.FirstQuadlet.FH_buffersize = pFragment->IPDatagramLength-1;
        
        pHeader ->u.FirstQuadlet_FirstFragment.FH_EtherType 
                        = pFragment->UnfragmentedHeader.u.FH_EtherType;
        
        pHeader ->u1.SecondQuadlet.FH_dgl = dgl;

        TRACE ( TL_V, TM_Send, (" fragmented Header Hi %x   Lo %x", 
                                   pHeader->u.FH_High, 
                                   pHeader->u1.FH_Low) );

        TRACE ( TL_V, TM_Send, (" fragmented Header lf %x  EtherType  %x", 
                                   pHeader ->u.FirstQuadlet_FirstFragment.FH_lf ,
                                   pHeader ->u.FirstQuadlet_FirstFragment.FH_EtherType ) );

        //
        // temporaty debug spew
        //
        TRACE (TL_V, TM_Send, (" copy Header at %x, Orig Header at %x", 
                               &pHeader ->u.FirstQuadlet_FirstFragment, 
                               pFragment->UnfragmentedHeader) );
        
        //
        // Initialize the fragmentation structure with packet's first ndis buffer
        //
        pFragment->pSourceAddressInNdisBuffer = NdisBufferVirtualAddress (pStartNdisBuffer);

        if (pFragment->pSourceAddressInNdisBuffer  == NULL)
        {
            NdisStatus = NDIS_STATUS_FAILURE;   

        }

        //
        // Set up the copy source . The first four bytes of data contain the unfragmented header.
        // We need to skip past these bytes and start the copy from the next byte
        // 
        pFragment->pSourceAddressInNdisBuffer  = (PVOID) ((ULONG_PTR)pFragment->pSourceAddressInNdisBuffer  +
                                                         sizeof (NDIS1394_UNFRAGMENTED_HEADER) );
        
        
        pFragment->NdisBufferLengthRemaining = NdisBufferLength (pStartNdisBuffer) - sizeof (NDIS1394_UNFRAGMENTED_HEADER);
        pFragment->pCurrNdisBuffer = pStartNdisBuffer;
        //
        // Set up the destination
        //
        pFragment->pStartFragment = (PVOID)((ULONG_PTR)pFragment->pLookasideListBuffer 
                                                  + (pFragment->NumFragmentsNeeded*sizeof(IRB)));


        ((PLOOKASIDE_BUFFER_HEADER)pFragment->pLookasideListBuffer)->pStartOfData = pFragment->pStartFragment;
        
        pFragment->pStartOfFirstFragment = pFragment->pStartFragment ;
        pFragment->CurrFragmentNum = 0;


        pFragment->lf = lf_FirstFragment;

        //
        // The First IRB will reside at the end of the lookaside-header 
        //
        pFragment->pCurrentIrb = &((PUNFRAGMENTED_BUFFER)pFragment->pLookasideListBuffer)->Irb;
        
        TRACE( TL_T, TM_Send, ( " pStartFragment %x, pFragment %x,NumFragmentsNeeded %x,MaxFragmentLength %x  ", 
                                  pFragment->pStartFragment, 
                                  pFragment->NumFragmentsNeeded,
                                  pFragment->MaxFragmentLength) );

        
        NdisStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    
    
    TRACE( TL_T, TM_Send, ( " <== nicFirstFragmentInitialization  NdisStautus %x, pFragment %x, ", 
                             NdisStatus, pFragment) );

    return NdisStatus;
}





VOID
nicAddFragmentHeader (
    IN PVOID pStartFragmentData, 
    IN PFRAGMENTATION_STRUCTURE pFragmentStructure,
    IN ULONG FragmentLength
    )
    // Function Description:
    //   Copies the Fragment header over after byteswapping it.
    //   For the the first time, the ether type and so forth is already initialized and waiting to be copied.
    //   This funciotn also sets up the values for the next invocation of this function
    // Arguments
    //   pStartFragmentData - Start of the fragment. Header goes after the gasp header if necessary .
    //   pFragmentationHeader - Header to copy over
    //   fIsFirstFragment - TRUE if this is the first fragment and needs a special header
    // Return Value:
    //   None
    //
{
    
    PNDIS1394_FRAGMENT_HEADER  pDestFragmentHeader = (PNDIS1394_FRAGMENT_HEADER)pStartFragmentData;
    PNDIS1394_FRAGMENT_HEADER  pSrcFragmentHeader = &pFragmentStructure->FragmentationHeader;   
    
    
    TRACE( TL_T, TM_Send, ( "==> nicAddFragmentHeader pStartFragmentData %x, pFragmentationHeader %x, , FragmentLength %x,  lf %x", 
                            pStartFragmentData , pSrcFragmentHeader , FragmentLength, pFragmentStructure->lf) );

    if (pFragmentStructure->AsyncOp == AsyncStream)
    {
        //
        // First Copy the GaspHeader
        //
        NdisMoveMemory (pStartFragmentData , 
                          &pFragmentStructure->pAdapter->GaspHeader, 
                          sizeof (GASP_HEADER) );

        //
        // Increment the pointers so that the fragment header will be copied after the gasp header
        //
        pStartFragmentData = (PVOID) ((ULONG_PTR) pStartFragmentData + sizeof (GASP_HEADER) );
        pDestFragmentHeader  = (PVOID) pStartFragmentData;
        
        TRACE( TL_T, TM_Send, ( " nicAddFragmentHeader Added Gasp Header from  %x ", 
                               pFragmentStructure->pAdapter->GaspHeader) );
        
    }


    //
    // Sanity check , are we overwriting anybody ?
    //
    ASSERT (*(PULONG)pDestFragmentHeader == 0);
    ASSERT (*(PULONG)pFragmentStructure->pCurrentIrb == 0);

    TRACE( TL_V, TM_Send, ( " pSrcFragmentHeader Hi %x,Lo %x", 
                             pSrcFragmentHeader->u.FH_High, pSrcFragmentHeader->u1.FH_Low) ); 

    //
    //  Copy over the lf;
    //
    pSrcFragmentHeader->u.FirstQuadlet.FH_lf = pFragmentStructure->lf;

    //
    // Now copy over the 8 bytes of the fragment header and byteswap them into big endian
    //

    
    pDestFragmentHeader->u.FH_High =  SWAPBYTES_ULONG ( pSrcFragmentHeader->u.FH_High);

    pDestFragmentHeader->u1.FH_Low = SWAPBYTES_ULONG ( pSrcFragmentHeader->u1.FH_Low);

    TRACE( TL_V, TM_Send, ( "  Fragment Offset %x", pSrcFragmentHeader->u.FirstQuadlet.FH_fragment_offset   ) );

    //
    // PREPARE the FRAGMENT STRUCTURE FOR THE NEXT ITERATION
    //

    //
    // Set the first fragment completed flag to true and set up the header for the next fragment
    //
    if (pFragmentStructure->lf == lf_FirstFragment)
    {
        pFragmentStructure->lf = lf_InteriorFragment;
        pSrcFragmentHeader->u.FirstQuadlet.FH_fragment_offset = 0;

    }

    //
    // Increase the fragment offset for use in the next fragment
    //
    pSrcFragmentHeader->u.FirstQuadlet.FH_fragment_offset += FragmentLength;





    TRACE( TL_T, TM_Send, ( "<== nicAddFragmentHeader lf %x", pFragmentStructure->lf) );

}



NDIS_STATUS
AsyncStreamSendPacketsHandler (
    IN PVCCB pVc,
    IN PNDIS_PACKET pPacket 
    )
    // Function Description:
    //  This function is used to send packets to the bus 
    //  via the async stream irp. the Ndis Packet is copied 
    //  to locally owned buffers and mdls and then sent
    //  down to the bus driver
    //
    //  This code is borrowed heavily from the AsyncStreamIrp code below
    //
    // Arguments
    // pChannelVc - The Vc which needs to send the packets
    // pPacket - the packet being transmitted
    //
    // Return Value:
    // NdisStatus - if all allocations and irp operations complete 
    // successfully, and the i/o will be completed asynchronously
    //
{
    NDIS_STATUS                     NdisStatus = NDIS_STATUS_FAILURE;
    NTSTATUS                        NtStatus = STATUS_UNSUCCESSFUL;
    PCHANNEL_VCCB                   pChannelVc = (PCHANNEL_VCCB) pVc;
    BOOLEAN                         fVcActive = TRUE;
    PMDL                            pMyMdl = NULL;
    PIRB                            pMyIrb = NULL;
    PIRP                            pMyIrp = NULL;
    ULONG                           PacketLength = 0;
    PVOID                           pLookasideListBuffer = NULL;
    PADAPTERCB                      pAdapter = NULL;
    PNDIS_BUFFER                    pStartNdisBuffer = NULL ;
    PVOID                           pStartPacketData= NULL ;
    PNIC_NPAGED_LOOKASIDE_LIST      pLookasideList = NULL;
    PLOOKASIDE_BUFFER_HEADER        pLookasideHeader = NULL;
    ULONG                           NumFragmentsNeeded = 0;
    FRAGMENTATION_STRUCTURE         Fragment;
    STORE_CURRENT_IRQL;


    NdisZeroMemory (&Fragment, sizeof (FRAGMENTATION_STRUCTURE));
    
    TRACE( TL_T, TM_Send, ( "==>AsyncStreamSendPacketsHandler , pVc  %x, pPacket %x", 
                                 pChannelVc , pPacket ) );
    
    pAdapter = pChannelVc->Hdr.pAF->pAdapter;
    //
    // This reference will either be dereferenced below in a call to FreeSendPacketDataStructure
    // below or a call to FreeSendPacketDataStructure made from the Irp's completion routine
    //
    


    do 
    {
        VC_ACQUIRE_LOCK (pVc);



        //
        // Make sure that the Vc is Activated and that no close calls 
        // are pending or that we have already completed a close call
        //

        
        if ( VC_ACTIVE (pChannelVc) == FALSE || ADAPTER_ACTIVE(pAdapter) == FALSE)
        {
            fVcActive = FALSE;  
        }

        if (VC_TEST_FLAG( pChannelVc, VCBF_GenerationWorkItem) == TRUE)
        {
            TRACE( TL_N, TM_Send, ( "AsyncStreamSendPacketHandler, Getting a new Gen, Fail send ") );

            fVcActive = FALSE;  
        }

        if (fVcActive == TRUE)
        {
            nicReferenceCall (pVc, "AsyncStreamSendPacketsHandler");
        }
        
        VC_RELEASE_LOCK (pVc);

        if (fVcActive  == FALSE)
        {
            TRACE( TL_N, TM_Send, ( "AsyncStreamSendPacketHandler, VC Not Active VC %x , Flag %x", pVc, pVc->Hdr.ulFlags ) );

            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        
        //
        //  Copy NdisBuffer in Packet to Local Memory and get an Mdl that points 
        //  to this memory (we get 1 Mdl only)
        NdisQueryPacket( pPacket,
                       NULL,
                       NULL,
                       NULL,
                       &PacketLength);

        ASSERT (pPacket->Private.Head != NULL);


        pStartNdisBuffer = pPacket->Private.Head;
        pStartPacketData = nicNdisBufferVirtualAddress (pStartNdisBuffer);

        if (pStartPacketData == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            TRACE( TL_N, TM_Send, ( "AsyncStreamSendPacketHandler, pStartPacketData ") );

            break;
        }


        TRACE( TL_V, TM_Send, ( "PacketLength %x", PacketLength) );



        NumFragmentsNeeded = nicNumFragmentsNeeded (PacketLength,
                                                    pChannelVc->Hdr.MaxPayload,
                                                    sizeof (NDIS1394_FRAGMENT_HEADER) + ISOCH_PREFIX_LENGTH );

        TRACE( TL_V, TM_Send, ( "NumFragments  %x, pVc->MaxSendSize", 
                                 NumFragmentsNeeded,pVc->Hdr.MaxPayload) );

        //
        // first choose the lookaside list
        //
        //

        
        if (PacketLength < PAYLOAD_100)
        {
            pLookasideList = &pAdapter->SendLookasideList100;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_100 Lookaside List %x", 
                                    &pAdapter->SendLookasideList100) );

        }
        else 
        if (PacketLength < PAYLOAD_2K)
        {
            pLookasideList = &pAdapter->SendLookasideList2K;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_2K Lookaside List %x", 
                                    &pAdapter->SendLookasideList2K) );


        } else
        if (PacketLength < PAYLOAD_8K)
        {
            pLookasideList = &pAdapter->SendLookasideList8K;
            TRACE( TL_V, TM_Send, ( " PAYLOAD_8K Lookaside List %x", 
                                    &pAdapter->SendLookasideList8K) );

    
        }else
        {
            //
            // Add code for local allocation
            //
            ASSERT (0);
        }

        //
        // are we going to fragment
        // 
        ASSERT (pLookasideList != NULL)

        //
        // We are not going to fragment. Optimize this path
        //
        pLookasideListBuffer = nicGetLookasideBuffer (pLookasideList);
        
        if (pLookasideListBuffer == NULL )
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            BREAK (TM_Send, ("nicGetLookasideBuffer  FAILED") );
        }

        //
        // Initialize the header with relevant information that the send complete
        // will need
        //
    
        pLookasideHeader = (PLOOKASIDE_BUFFER_HEADER)pLookasideListBuffer;
        pLookasideHeader->IsFragmented          = FALSE;  // Default
        pLookasideHeader->FragmentsGenerated    = 0;
        pLookasideHeader->pLookasideList        = pLookasideList;
        pLookasideHeader->pNdisPacket           = pPacket;
        pLookasideHeader->pVc                   =(PVCCB)pVc;
        pLookasideHeader->AsyncOp               = AsyncStream;
        pLookasideHeader->OutstandingFragments = NumFragmentsNeeded ;

        //
        // Initialize the Fragment structure
        //
        //
        //  Do we fragment or not. Base it on the MaxPayload field
        //
        
        TRACE( TL_V, TM_Send, ( "   Fragment  PacketLength %x, pVc->MaxPayload %x ", 
                                 PacketLength ,pVc->Hdr.MaxPayload) );

                                 
        //
        // Do we need to fragment. Use the number of fragments generated to figure it out
        //
        
        if (NumFragmentsNeeded == 1)
        {
            //
            // No need to fragment here. We will use the UNFRAGMENTED Layout
            //
            // First Get a local buffer from our lookaside list
            //
            PUNFRAGMENTED_BUFFER pUnfragmentedBuffer = (PUNFRAGMENTED_BUFFER )pLookasideHeader;
            PPACKET_FORMAT pDestination = (PPACKET_FORMAT)&pUnfragmentedBuffer->Data[0];
            //
            // Add the gasp header
            //
            NdisMoveMemory ((PVOID)&pDestination->AsyncStreamNonFragmented.GaspHeader, 
                            &pAdapter->GaspHeader,
                            sizeof (GASP_HEADER) );


            //
            // copy the data over,  to the location just after the Gasp Header
            // In the unfragmented case, the packet already has the correct header
            //
            NdisStatus = nicCopyNdisBufferChainToBuffer (pStartNdisBuffer, 
                                                         (PVOID)&pDestination->AsyncStreamNonFragmented.NonFragmentedHeader,
                                                         pLookasideList->MaxSendSize);
                                             
    
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Send, ( "   AsyncStreamSendPacketHandler, nicCopyNdisPacketToUnfragmentedBuffer Failed ") );
            }
    
            
            ASSERT (pLookasideListBuffer != NULL);

            // 
            // Initialize all the variable needed by the Next section of the code.
            // This deals with setting up the Mdl and the IRB
            //
            
            pStartNdisBuffer = NULL;

            Fragment.pStartFragment = (PVOID)pDestination;
            Fragment.FragmentLength  = PacketLength + sizeof (GASP_HEADER);
            Fragment.pCurrNdisBuffer = NULL;

            pLookasideHeader->FragmentsGenerated = 1; 
            pLookasideHeader->IsFragmented = FALSE;                                    
            
        }
        else
        {
            //
            // We need to fragment
            //
            ULONG Dgl = NdisInterlockedIncrement(&pAdapter->dgl);

            //
            // Initialize the fragment header. The unfragmented code path
            // does not care about these fields
            //
            Fragment.TxHeaderSize = sizeof (NDIS1394_FRAGMENT_HEADER) + sizeof (GASP_HEADER);
            Fragment.AsyncOp = AsyncStream;
            Fragment.pLookasideList = pLookasideList;
            Fragment.pAdapter = pAdapter;
            Fragment.pLookasideListBuffer = pLookasideListBuffer;
            Fragment.IPDatagramLength = (USHORT)PacketLength - sizeof (NDIS1394_UNFRAGMENTED_HEADER);   

            Fragment.MaxFragmentLength = pChannelVc->Hdr.MaxPayload;                                                                    
            Fragment.NumFragmentsNeeded = NumFragmentsNeeded;

            //
            // Allocate from the fragmented pool and initialize the fragment header structure
            //
            

            NdisStatus = nicFirstFragmentInitialization (pPacket->Private.Head,
                                                         Dgl,
                                                         &Fragment);


            if (pLookasideListBuffer  == NULL || NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK (TM_Send, (" AsyncStreamSendPacketsHandler: nicFirstFragmentInitialization : FAILED" )) ;
            }       

            ASSERT (pLookasideListBuffer != NULL);
            
            pLookasideHeader->IsFragmented = TRUE;                                     
                                       
            
        }


        //
        // Now begin the loop which will send n fragments
        //
        do 
        {   

            //
            // Do we need to fragment. If so , extract one fragment out of the NdisPacket
            //
            if (pLookasideHeader->IsFragmented == TRUE )
            {   
            
                //
                // We copy one fragment over and this will allocate the lookaside list
                //

                NdisStatus = nicCopyOneFragment (&Fragment);
                if (NDIS_STATUS_SUCCESS != NdisStatus)
                {
                    BREAK ( TM_Send, ( "   AsyncStreamSendPacketHandler, nicCopyOneFragment  Failed ") );
                }
                                              
                //
                // Get the pointer to the Irb here. and set it up for the next time
                //
                //
                pMyIrb = Fragment.pCurrentIrb;
                Fragment.pCurrentIrb = (PIRB)((ULONG_PTR)Fragment.pCurrentIrb + sizeof (IRB) );
                
            }
            else
            {
                //
                // No Curr NdisBuffer as this packet was never fragmented. 
                //
                
                ASSERT (pLookasideHeader->IsFragmented == FALSE);                                      

                pMyIrb =  &((PUNFRAGMENTED_BUFFER )pLookasideHeader)->Irb;
            }
            
            //
            // At this point we have one fragment that needs to be transmitted.
            // Data structures have been updated to set up the MDL and the IRB
            //

            NdisStatus = nicGetMdl (Fragment.FragmentLength  , 
                                    Fragment.pStartFragment , 
                                    &pMyMdl);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                BREAK ( TM_Send, ( "   AsyncStreamSendPacketHandler, nicCopyNdisBufferChainToBuffer Failed ") );
            }       

            nicIncChannelSendMdl()
            //
            //  Fill in the Irb with the correct values from the VC
            //  Stuff we need to add to the send VC - BlockSize,Generation
            //  

            nicInitAsyncStreamIrb((PCHANNEL_VCCB)pVc, pMyMdl, pMyIrb);

            //
            // Get a free Irp 
            //

            NdisStatus  = nicGetIrp (pAdapter->pNdisDeviceObject, &pMyIrp); 
        
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                break;
            }
            //
            // At this point, we have a guarantee that the Completion routine will be called
            //
            ASSERT (NdisStatus == NDIS_STATUS_SUCCESS);

            //
            // Dump the Fragment 
            //
            nicDumpMdl (pMyMdl , 0, "AsyncStream Fragment");




            NIC1394_LOG_PKT(
                pAdapter,
                NIC1394_LOGFLAGS_SEND_CHANNEL,
                pAdapter->BCRData.LocalNodeNumber,          // SourceID
                pChannelVc->Channel,
                Fragment.pStartFragment, 
                Fragment.FragmentLength
                );

            //
            // This function implements the common functionality to be implemented by
            // all other send/recv cals to IoCallDriver
            //

            //
            // We IGNORE the NtStatus as the completion handler will be called
            //
            nicIncrementBusSends(pVc);
            
            NtStatus = nicSubmitIrp(pAdapter->pNdisDeviceObject,
                                    pMyIrp,
                                    pMyIrb,
                                    AsyncWriteStreamSendComplete,
                                   (PVOID)pLookasideListBuffer);

            TRACE( TL_V, TM_Send, ( " pCurrNdisBuffer  %x, NdisStatus %x ", Fragment.pCurrNdisBuffer , NdisStatus ) );

            
            
        } while (Fragment.pCurrNdisBuffer != NULL && NdisStatus == NDIS_STATUS_SUCCESS);

    
    } while (FALSE);

    //
    // DO NOT touch the packet if status == NDIS_STATUS_SUCCESS. 
    //

    
    //
    //  CleanUp if any of the allocations failed. We do not have a pointer
    //  to the LocalBuffer (it is embedded in the Mdl)  so it remains NULL
    //
    //  NdisStatus != Success means that we never got to nicSubmitIrp
    //
    
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {   

        ASSERT (pMyIrp == NULL);

        //
        // fVc Active makes sure that we actually got around to allocating 
        // and referencing structures
        //
        
        if (fVcActive == TRUE)
        {

            if (pLookasideListBuffer != NULL)
            {

                //
                // Complete this fragment, as we never submit'd the IRP to
                // the 1394 bus driver
                //
                AsyncWriteStreamSendComplete(NULL, // PDO
                                             NULL, 
                                             pLookasideListBuffer);

                NdisStatus =NDIS_STATUS_SUCCESS;
            }                                  
            else
            {

                //
                // This thread needs to decrement the refcounts as 
                // AsyncWriteStreamSendComplete was not called
                //
                nicDereferenceCall ((PVCCB) pVc, "AsyncStreamSendPacketsHandler");

            }

        }

    }


    

    TRACE( TL_T, TM_Send, ( "<==AsyncStreamSendPacketHandler, NdisStatus  %x", NdisStatus ) );
    MATCH_IRQL;

    //
    // Make sure this is NDIS_STATUS_PENDING if the Irp was sent down or 
    // AsyncWriteStreamSendCOmplete was called.
    //
    return NdisStatus;
}
        

NDIS_STATUS
nicEthernetVcSend(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    )
/*++

Routine Description:
  reroutes all sends as an CL receive

Arguments:


Return Value:


--*/
{

    PETHERNET_VCCB      pEthernetVc = (PETHERNET_VCCB)pVc;
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    BOOLEAN             fVcActive = FALSE;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    PNDIS_PACKET        pMyPacket = NULL;
    NDIS_STATUS         IndicatedStatus= NDIS_STATUS_FAILURE;
    PPKT_CONTEXT        pPktContext = NULL;
    
    TRACE( TL_T, TM_Send, ( "==>nicEthernetVcSend, pVc   %x, pPacket %x", 
                                 pVc , pPacket ) );

    do
    {




    
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        if (VC_ACTIVE (pEthernetVc)==TRUE)
        {
            fVcActive = TRUE;
            nicReferenceCall (pVc, "nicEthernetVcSend" ) ;
            
        }

        ADAPTER_RELEASE_LOCK (pAdapter);
        
        if (fVcActive == FALSE)
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        nicAllocatePacket (&NdisStatus,
                       &pMyPacket ,
                       &pEthernetVc->PacketPool ); 

        if (NdisStatus != NDIS_STATUS_SUCCESS || pMyPacket == NULL)
        {
            pMyPacket = NULL;
            BREAK (TM_Send, "Ethernet VC - AllocatePacket failed" ) ;
        }


        pMyPacket->Private.Head = pPacket->Private.Head;
        pMyPacket->Private.Tail = pPacket->Private.Tail;
        

        IndicatedStatus = NDIS_STATUS_RESOURCES;
        NDIS_SET_PACKET_STATUS(pMyPacket, IndicatedStatus);

        //
        // Set up the context
        // 
        pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReservedEx; 
        pPktContext->EthernetSend.pOrigPacket = pPacket;    

        //
        // Dump the packet
        //

        {
            nicDumpPkt (pMyPacket, "Conn Less Rcv ");
            nicCheckForEthArps (pMyPacket);
        }
        //
        // Now indicate the packet
        //

        //
        // Bluff the OOB Size. To get past an assert on debug Ndis
        //
        NDIS_SET_PACKET_HEADER_SIZE (pMyPacket, 14); 
        NdisMIndicateReceivePacket (pAdapter->MiniportAdapterHandle,
                                &pMyPacket,
                                1);
        

        
        pPktContext = (PPKT_CONTEXT)&pMyPacket->MiniportReservedEx; 
        ASSERT ( pPacket == pPktContext->EthernetSend.pOrigPacket );

        nicMpCoSendComplete (NDIS_STATUS_SUCCESS,
                             pVc,
                             pPacket);


        //
        // We have successfully pended the Io/ 
        // Now the completion routine will be called
        //
        NdisStatus = NDIS_STATUS_SUCCESS;
        

    } while (FALSE);

    if (pMyPacket != NULL)
    {
        //
        // Free the locally allcoate packet
        //
        nicFreePacket(pMyPacket, &pEthernetVc->PacketPool);
    }

    if (fVcActive == TRUE)
    {
        nicDereferenceCall (pVc, "nicEthernetVcSend" ) ;

    }



    TRACE( TL_T, TM_Send, ( "<==nicEthernetVcSend, ") );

    return NdisStatus;
}






VOID
nicGetGenerationWorkItem(
    NDIS_WORK_ITEM* pGetGenerationWorkItem,
    IN PVOID Context 
    )
    // Function Description:
    // Work Item used to submit a Get Generation IRP at Passive Level
    //
    // Arguments
    //
    // Return Value:
    //    Generation - 



{
    PVCCB               pVc = (PVCCB) Context;
    PADAPTERCB          pAdapter = pVc->Hdr.pAF->pAdapter;
    NDIS_STATUS         NdisStatus = NDIS_STATUS_FAILURE;
    UINT                Generation = 0;

    TRACE( TL_T, TM_Mp, ( "==>nicGetGenerationWorkItem, pVc", Context ) );


    NdisStatus = nicGetGenerationCount (pAdapter , &Generation);


    //
    // Update the generation
    //
    VC_ACQUIRE_LOCK (pVc);
    
    if (NdisStatus == NDIS_STATUS_SUCCESS && Generation > *pVc->Hdr.pGeneration )
    {
        pAdapter->Generation = Generation;
    
    }
    
    VC_CLEAR_FLAGS(pVc, VCBF_GenerationWorkItem);
    
    VC_RELEASE_LOCK (pVc);

    // Dereference the call, this will allow the close call to complete. Do not touch VC after this.
    //
    nicDereferenceCall(pVc, "nicSendFailureInvalidGeneration");

    

    TRACE( TL_T, TM_Mp, ( "<==nicGetGenerationWorkItem, Gen %x", Generation) );

    FREE_NONPAGED (pGetGenerationWorkItem);
    NdisInterlockedDecrement(&pAdapter->OutstandingWorkItems);

}

VOID
nicUpdatePacketState (
    IN PNDIS_PACKET pPacket,
    IN ULONG Tag
    )
/*++

Routine Description:
    Validates and then updates that packet tag. So we can heep track of the packet

Arguments:


Return Value:


--*/
{

    switch (Tag)
    {
        case NIC1394_TAG_COMPLETED:
        {

            *(PULONG)(&pPacket->MiniportReserved[0]) = NIC1394_TAG_COMPLETED;

            break;
        }

        case NIC1394_TAG_IN_SEND:
        {
            *(PULONG)(&pPacket->MiniportReserved[0]) = NIC1394_TAG_IN_SEND;
            break;      
        }

        default:
        {
            ASSERT (!"Invalid Tag on NdisPacket");
        }

    }


}










NDIS_STATUS
nicQueueSendPacket(
    PNDIS_PACKET pPacket, 
    PVCCB pVc 
    )
/*++

Routine Description:

    This function inserts a packet into the send queue. If there is no timer servicing the queue
    then it queues a timer to dequeue the packet in Global Event's context


Arguments:

    Self explanatory 
    
Return Value:
    Success - if inserted into the the queue

--*/
    
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    BOOLEAN fSetTimer = FALSE;
    PADAPTERCB pAdapter = pVc->Hdr.pAF->pAdapter;
    PNDIS_SEND_CONTEXT  pSendContext = (PNDIS_SEND_CONTEXT)(pPacket->MiniportReservedEx) ;


    do
    {
        extern ULONG TotSends;
        TotSends++;

        //
        // Store the pvc in the Miniport Reserved
        //
        pSendContext->pVc = pVc;
                
        ADAPTER_ACQUIRE_LOCK (pAdapter);

        //
        // Find out if this thread needs to fire the timer
        //

        if (pAdapter->SerSend.bTimerAlreadySet == FALSE)
        {
            fSetTimer = TRUE;
            pAdapter->SerSend.bTimerAlreadySet = TRUE;

        }
                
        InsertTailList(
                &pAdapter->SerSend.Queue,
                &pSendContext->Link
                );
        pAdapter->SerSend.PktsInQueue++;

        nicReferenceCall (pVc, "nicQueueSendPacket ");

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Now queue the timer
        //
        
        if (fSetTimer == TRUE)
        {
            PNDIS_MINIPORT_TIMER pSendTimer;
            //
            //  Initialize the timer
            //
            pSendTimer = &pAdapter->SerSend.Timer;      

            
            TRACE( TL_V, TM_Recv, ( "   Set Timer "));
            
            NdisMSetTimer ( pSendTimer, 0);

        }


        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    ASSERT (Status == NDIS_STATUS_SUCCESS);
    return Status;
}



NDIS_STATUS
nicInitSerializedSendStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:
    Used to initialize the Send Serialization Struct

Arguments:



Return Value:


--*/
{


    NdisZeroMemory (&pAdapter->SerSend, sizeof(pAdapter->SerSend));
    InitializeListHead(&pAdapter->SerSend.Queue);

    NdisMInitializeTimer (&pAdapter->SerSend.Timer,
                      pAdapter->MiniportAdapterHandle,
                      nicSendTimer ,
                      pAdapter);


    return NDIS_STATUS_SUCCESS;

}


VOID
nicDeInitSerializedSendStruct(
    PADAPTERCB pAdapter
    )
/*++

Routine Description:

    Deinit's the Serialize send struct. Does nothing for now

Arguments:


Return Value:


--*/
{





}

VOID
nicSendTimer (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:
   This function dequeues a packet and invokes the appropriate send handler
   to fire this packet off to the 1394 bus driver

Arguments:

    Function context - Adapter structure, which has the Packet queue. 
    Each packet has the VC embedded in it.

Return Value:


--*/
{
    

    PADAPTERCB      pAdapter = (PADAPTERCB) FunctionContext;
    BOOLEAN         fVcCorrupted = FALSE;

    TRACE( TL_T, TM_Recv, ( "==>nicSendTimer  Context %x", FunctionContext));

    nicIncrementSendTimerCount();

    ADAPTER_ACQUIRE_LOCK (pAdapter);
    

    //
    // Get the stats out
    //
    nicSetCountInHistogram(pAdapter->SerSend.PktsInQueue, SendStats);   

    nicSetMax(nicMaxSend, pAdapter->SerSend.PktsInQueue);
    


    //
    // Empty the Queue indicating as many packets as possible
    //
    while (IsListEmpty(&pAdapter->SerSend.Queue)==FALSE)
    {
        PNDIS_SEND_CONTEXT      pSendContext;
        PNDIS_PACKET            pPacket;
        PVCCB                   pVc;
        PLIST_ENTRY             pLink;
        NDIS_STATUS             NdisStatus;

        pAdapter->SerSend.PktsInQueue--;

        pLink = RemoveHeadList(&pAdapter->SerSend.Queue);

        ADAPTER_RELEASE_LOCK (pAdapter);

        //
        // Extract the send context
        //
        pSendContext = CONTAINING_RECORD(
                                           pLink,
                                           NDIS_SEND_CONTEXT,
                                           Link);


        pVc = pSendContext->pVc;

        if (pVc->Hdr.ulTag != MTAG_VCCB)
        {
            ASSERT (pVc->Hdr.ulTag == MTAG_VCCB);
            fVcCorrupted = TRUE;
            break;
    
        }

        //
        // Now get the packet
        //
        pPacket = CONTAINING_RECORD ( pSendContext,
                                       NDIS_PACKET,
                                       MiniportReservedEx);


        //
        // Call the send handler for the Vc, packet
        //
        nicUpdatePacketState (pPacket, NIC1394_TAG_IN_SEND);

        NdisStatus = pVc->Hdr.VcHandlers.SendPackets(pVc, pPacket);

        //
        // Reference was made before queueing the packet
        //
        nicDereferenceCall (pVc, "nicSendTimer ");
        //
        // Complete the packet , if the send was synchronous
        //
        if (NT_SUCCESS(NdisStatus) == FALSE) // can pend
        {
            nicMpCoSendComplete( NdisStatus,pVc,pPacket);
        }
        

        ADAPTER_ACQUIRE_LOCK (pAdapter);

    }
    
    //
    // clear the flag
    //

    ASSERT (pAdapter->SerSend.PktsInQueue==0);
    ASSERT (IsListEmpty(&pAdapter->SerSend.Queue));

    pAdapter->SerSend.bTimerAlreadySet = FALSE;


    ADAPTER_RELEASE_LOCK (pAdapter);

    
    TRACE( TL_T, TM_Recv, ( "<==nicSendTimer  "));

    


}






VOID
nicMpCoSendComplete (
    NDIS_STATUS NdisStatus,
    PVCCB pVc,
    PNDIS_PACKET pPacket
    )
/*++

Routine Description:
  Wrapper function around NdisMCoSendComplete

Arguments:


Return Value:


--*/
{

        nicIncrementSendCompletes (pVc);
        
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            nicIncrementVcSendPktCount(pVc, pPacket);
        }
        else
        {
            nicIncrementVcSendFailures (pVc, pPacket);
        }

        nicUpdatePacketState (pPacket, NIC1394_TAG_COMPLETED);

        NdisMCoSendComplete(NdisStatus,
                            pVc->Hdr.NdisVcHandle,
                            pPacket);


}



UINT
nicNumFragmentsNeeded (
    UINT PacketLength ,
    UINT MaxPayload,
    UINT FragmentOverhead
    )
/*++

Routine Description:

     Now account for the Fragment headers as well. A fragment header will be added 
     at the head of each fragment.  The Unfragmented header at the head of the data
     will be removed
                
                


Arguments:

    FragmentOverhead - the size of the fragment header, in the asyncstream it includes the gasp header+fragment header.
                      for asyncwrite it is just the fragmentation header

Return Value:


--*/

                
    
{

        UINT NewPacketSize; 
        UINT TotalCapacitySoFar;
        UINT NumFragmentsNeeded ;

        ASSERT (PacketLength  != 0 );
        ASSERT (MaxPayload != 0) ;
        ASSERT (FragmentOverhead != 0);

        //
        // This division takes care of the case where PacketLength 
        // is an integral multiple of the MaxPayload.  Since we add 1 to the fragment
        // it takes care of the overhead added by the fragment headers
        //
        NumFragmentsNeeded = (PacketLength / MaxPayload) + 1;

         

        //
        // If we add the fragment and gasp header to our fragments, we
        // might need another fragment due to an overflow
        //

        //
        // Calculate the new packet size after fragmentation 
        //
        {
            //
            // Add the length of the fragment headers 
            //
            NewPacketSize = PacketLength + (NumFragmentsNeeded * FragmentOverhead);

            //
            // Now remove the default non-fragment header
            //
            NewPacketSize -= sizeof (NDIS1394_UNFRAGMENTED_HEADER)   ;
        }

        //
        // 
        //
        
        TotalCapacitySoFar = NumFragmentsNeeded * MaxPayload;
        
        if ( NewPacketSize > TotalCapacitySoFar)
        {
            //
            // We'll need one more fragment
            //
            NumFragmentsNeeded ++;
        }

        return NumFragmentsNeeded ; 

}





VOID
nicCheckForEthArps (
    IN PNDIS_PACKET pPkt
    )
/*++

Routine Description:

    It will print the pkt if an eth arp or arp response goes 
    through nic1394
                
Arguments:

Return Value:


--*/
{

    PNDIS_BUFFER pBuffer;
    ULONG Len;
    ENetHeader* pENetHeader = NULL;
    PETH_ARP_PKT pArp = NULL;
    USHORT PacketType;
    USHORT opcode;
    extern ULONG g_ulDumpEthPacket ;
    do
    {

        if (g_ulDumpEthPacket == 0)
        {
            break;
        }

        pBuffer = pPkt->Private.Head;
        Len = NdisBufferLength (pBuffer);

        if (Len < sizeof (ENetHeader) )
        {
            ASSERT (Len >= sizeof (ENetHeader) );
            break;
        }

        pENetHeader = (ENetHeader*) NdisBufferVirtualAddress (pBuffer);

        if (pENetHeader == NULL)
        {
            ASSERT ( pENetHeader != NULL);
            break;
        }

        PacketType = ntohs (pENetHeader->eh_type);

        
        if (PacketType == ARP_ETH_ETYPE_IP)
        {
            break;
        }

        if (PacketType == ARP_ETH_ETYPE_ARP)
        {
            DbgPrint ("Arp Pkt - ");
        }

        pArp = (ETH_ARP_PKT*)pENetHeader;

        opcode = ntohs(pArp->opcode);

        if (opcode == ARP_ETH_REQUEST )
        {
            DbgPrint ("Request ");
        }
        else if (opcode == ARP_ETH_RESPONSE )
        {
            DbgPrint ("Response ");
        }
        else
        {
            break;
        }

        // Print the packet
        DbgPrint("\n");
 
        {

            ENetAddr    Addr;

            Addr = pArp->sender_hw_address;

            DbgPrint ("Sender Hw Addr %x %x %x %x %x %x \n",
                        Addr.addr[0],
                        Addr.addr[1],
                        Addr.addr[2],
                        Addr.addr[3],
                        Addr.addr[4],
                        Addr.addr[5]);
                        
            DbgPrint ("Ip Addr %x\n",pArp->sender_IP_address);

            Addr = pArp->target_hw_address;

            DbgPrint ("Target Hw Addr %x %x %x %x %x %x \n",
                        Addr.addr[0],
                        Addr.addr[1],
                        Addr.addr[2],
                        Addr.addr[3],
                        Addr.addr[4],
                        Addr.addr[5]);
                        
            DbgPrint ("Ip Addr %x\n",pArp->target_IP_address);

        }
        

    } while (FALSE);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\priv.h ===
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// priv.h
//
// IEEE 1394 NDIS mini-port/call-manager driver
//
// Main private header
//
// 12/28/1998 JosephJ Created (adapted from the l2tp project)
//
//


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------


extern ULONG  g_IsochTag;
extern LONG  g_ulMedium;
extern ULONGLONG g_ullOne;

//-----------------------------------------------------------------------------
// Advance Declarations and simple typedefs
//-----------------------------------------------------------------------------



// Forward declarations.
//
typedef union _VCCB VCCB;
typedef struct _ADAPTERCB ADAPTERCB, *PADAPTERCB;
typedef struct _RECVFIFO_VCCB RECVFIFO_VCCB, *PRECVFIFO_VCCB;
typedef struct _ETHERNET_VCCB ETHERNET_VCCB, *PETHERNET_VCCB;
typedef struct _RECV_FIFO_DATA  RECV_FIFO_DATA, *PRECV_FIFO_DATA;
typedef struct _ISOCH_DESCRIPTOR ISOCH_DESCRIPTOR, *PISOCH_DESCRIPTOR, **PPISOCH_DESCRIPTOR;
typedef struct _TOPOLOGY_MAP TOPOLOGY_MAP, *PTOPOLOGY_MAP, **PPTOPOLOGY_MAP;
typedef struct _CHANNEL_VCCB CHANNEL_VCCB, *PCHANNEL_VCCB;
typedef struct _GASP_HEADER GASP_HEADER;
typedef struct _NDIS1394_FRAGMENT_HEADER NDIS1394_FRAGMENT_HEADER, *PNDIS1394_FRAGMENT_HEADER;
typedef struct _NDIS1394_REASSEMBLY_STRUCTURE NDIS1394_REASSEMBLY_STRUCTURE, *PNDIS1394_REASSEMBLY_STRUCTURE;
typedef struct _REMOTE_NODE REMOTE_NODE, *PREMOTE_NODE;
typedef union  _NDIS1394_UNFRAGMENTED_HEADER NDIS1394_UNFRAGMENTED_HEADER, *PNDIS1394_UNFRAGMENTED_HEADER;
typedef union  _NIC_WORK_ITEM NIC_WORK_ITEM, *PNIC_WORK_ITEM;


#define NIC1394_STATUS_INVALID_GENERATION  ((NDIS_STATUS)STATUS_INVALID_GENERATION)

//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------


typedef struct _NODE_TABLE
{
    PREMOTE_NODE RemoteNode[MAX_NUMBER_NODES];  

} NODE_TABLE, *PNODE_TABLE;



typedef struct _GASP_HEADER 
{
    union 
    {
        //
        // Ist Quadlet
        //
        struct 
        {
            ULONG               GH_Specifier_ID_Hi:16;  
            ULONG               GH_Source_ID:16;        

        } Bitmap;

        struct 
        {
            USHORT              GH_Specifier_ID_Hi;
            USHORT              GH_Source_ID;

        } u;

        struct 
        {
            USHORT              GH_Specifier_ID_Hi;
            NODE_ADDRESS        GH_NodeAddress;             
        } u1;
        
        ULONG GaspHeaderHigh;

    } FirstQuadlet; 

    union 
    {    
        struct
        {
            ULONG               GH_Version:24;          // Bits 0-23
            ULONG               GH_Specifier_ID_Lo:8;   //Bits 24-31

        } Bitmap;
        
        ULONG GaspHeaderLow;

    } SecondQuadlet;
    
} GASP_HEADER, *PGASP_HEADER;


//
// The Ndis miniport's wrapper around the Packet Pool
//
typedef struct _NIC_PACKET_POOL
{
    ULONG AllocatedPackets;

    KSPIN_LOCK Lock;    //  Only in Win9X.
    
    NDIS_HANDLE Handle;


} NIC_PACKET_POOL, *PNIC_PACKET_POOL;


//
// The Ndis miniport's wrapper around the Packet Pool
//
typedef struct _NIC_BUFFER_POOL
{
    ULONG AllocatedBuffers;

    KSPIN_LOCK Lock;    //  Only in Win9X.
    
    NDIS_HANDLE Handle;


} NIC_BUFFER_POOL, *PNIC_BUFFER_POOL;



//
// The structure that defines the lookaside list used by this miniport
//
typedef struct _NIC_NPAGED_LOOKASIDE_LIST 
{
    //
    // The lookaside list structure
    //
    NPAGED_LOOKASIDE_LIST   List;   

    //
    // The size of an individual buffer
    //
    
    ULONG Size;

    //
    // Outstanding Fragments - Interlocked access only
    //
    ULONG OutstandingPackets;

    //
    // Lookaside Lists are used for sends. So this is a maximum 
    // send packet size that this lookaside list can handle
    //
    ULONG MaxSendSize;
    
} NIC_NPAGED_LOOKASIDE_LIST , *PNIC_NPAGED_LOOKASIDE_LIST ;



//
// Structure used for references, Adapted from Ndis
// The Event will be signalled when the refcount goes down to zero
// The filed closing signifies that the object that the reference belongs to is
// closing and it;s refernces will not be incremented anymore
//
typedef struct _REF
{
//  NDIS_SPIN_LOCK              SpinLock;
    ULONG                       ReferenceCount;
    BOOLEAN                     Closing;
    NDIS_EVENT                  RefZeroEvent;
} REF, * PREF;

typedef enum  _EVENT_CODE 
{
    Nic1394EventCode_InvalidEventCode,
    Nic1394EventCode_NewNodeArrived,
    nic1394EventCode_BusReset,
    nic1394EventCode_FreedAddressRange,
    nic1394EventCode_ReassemblyTimerComplete,
    nic1394EventCode_QueryPowerLowPower


} EVENT_CODE, *PEVENT_CODE;

typedef struct _NIC1394_EVENT
{
    NDIS_EVENT NdisEvent;
    EVENT_CODE EventCode;
    
} NIC1394_EVENT, *PNIC1394_EVENT;


typedef ENetAddr MAC_ADDRESS, *PMAC_ADDRESS;


//
// nic Spin lock structure. Keeps track of the file and line numer 
// that last touched the lock
//


#define LOCK_FILE_NAME_LEN              48


typedef struct _NIC_SPIN_LOCK
{
#ifdef TRACK_LOCKS 
        ULONG                   IsAcquired;   // Internal tracking of lock state
        PKTHREAD                OwnerThread; // thread that has the lock
        UCHAR                   TouchedByFileName[LOCK_FILE_NAME_LEN]; // File name which called Acquire Lock
        ULONG                   TouchedInLineNumber; // Line Number in the file
#endif

        NDIS_SPIN_LOCK          NdisLock;  // Actual Lock

} NIC_SPIN_LOCK, *PNIC_SPIN_LOCK;

//
// Statistics Structure - to be collected on a per adapter basis
//
typedef struct _NIC_SEND_RECV_STATS
{
    ULONG ulSendNicSucess;
    ULONG ulSendBusSuccess;
    ULONG ulSendBusFail;
    ULONG ulSendNicFail;
    ULONG ulRecv;


} NIC_SEND_RECV_STATS;


//
// These are stats that can be reset
//
typedef struct _RESETTABLE_STATS
{
    ULONG ulNumOutstandingReassemblies;
    ULONG ulMaxOutstandingReassemblies;
    ULONG ulAbortedReassemblies;
    ULONG ulNumResetsIssued ;
    ULONG ulNumSends;
    ULONG ulNumSendsCompleted;
    ULONG ulNumBusSends;
    ULONG ulNumBusSendsCompleted;
    NIC_SEND_RECV_STATS Fifo;
    NIC_SEND_RECV_STATS Channel;
    
    
} RESETTABLE_STATS, *PRESETTABLE_STATS;

typedef struct _ADAPT_STATS
{
    ULONG ulXmitOk;
    ULONG ulXmitError ;
    ULONG ulRcvOk  ;
    ULONG ulRcvError ;
    ULONG ulNumResetsIssued ;
    ULONG ulNumResetCallbacks ;
    ULONG ulBCMIterations ;
    ULONG ulNumRemoteNodes;
    ULONG ulResetTime;
    RESETTABLE_STATS TempStats;
    
} ADAPT_STATS,  *PADAPT_STATS; 

//
// Can be used to keep data in buckets of 10
//


typedef struct _STAT_BUCKET
{

    ULONG Bucket[16];


} STAT_BUCKET, *PSTAT_BUCKET;

//
// Wrapper around the Address Fifo structure
//
typedef struct _ADDRESS_FIFO_WRAPPER
{
    ADDRESS_FIFO Fifo;
    ULONG Tag;


}ADDRESS_FIFO_WRAPPER, *PADDRESS_FIFO_WRAPPER;


//
// To be used on Win9x To serialize send and receives
//

typedef struct _NIC_SERIALIZATION
{
    UINT                PktsInQueue;        // Number of packets in queue.
    BOOLEAN             bTimerAlreadySet;
    BOOLEAN             bInitialized;
    USHORT              usPad;
    LIST_ENTRY          Queue;  // Serialized by adapter lock.

    union {
    NDIS_MINIPORT_TIMER Timer;
    NDIS_WORK_ITEM      WorkItem;
    };
    
    NIC1394_EVENT	CompleteEvent;
    
} NIC_SERIALIZATION, *PNIC_SERIALIZATION;



//
// Each request to allocate and address range 
// returns certain values that need to be stored for the 
// request to free the address range. This structure contains 
// those values
//

typedef struct _ADDRESS_RANGE_CONTEXT
{

    //
    // Handle returned by the bus driver
    //
    HANDLE hAddressRange;

    //
    // Address Range returnded by the bus driver
    //
    ADDRESS_RANGE AddressRange;

    //
    // Number of Address returned from the call to 
    // allocate address range
    // 
    ULONG AddressesReturned;

    //
    // Mdl used in allocate address range . can be NULL
    //
    PMDL pMdl;

} ADDRESS_RANGE_CONTEXT, *PADDRESS_RANGE_CONTEXT;



// This structure is the Per Pdo/ per RecvFIFOVc structure. 
// This will be included in every Pdo Strcuture. And should contain  
// the fields that are related to the recvFifo and the Pdo block
// 
typedef struct _RECV_FIFO_DATA
{
    //
    // Indicates whether the address range was allocated regardless of the Make
    // Call State (pending or success)
    // 
    BOOLEAN AllocatedAddressRange;
    
    //
    // Recv Vc's related  data structures
    //
    ADDRESS_RANGE   VcAddressRange;

    // The Bus Driver's Handle to the Address ranges that  
    // the Nic was allocated
    //
    HANDLE hAddressRange;

    // This is the number of address ranges that the bus driver
    // returned. For now, it is expected to be one.
    //
    UINT AddressesReturned;

    // The Recv Fifo Vc that this structure is associated with
    //  
    PRECVFIFO_VCCB pRecvFIFOVc;

    // The Pdo Associated with this structure
    //
    //DEVICE_OBJECT *pPdo;

} RECV_FIFO_DATA, *PRECV_FIFO_DATA;


//
// Flags for the Broadcast Channel
//
#define BCR_LocalHostIsIRM          0x00000001
#define BCR_ChannelAllocated        0x00000002
#define BCR_LocalHostBCRUpdated     0x00000004
#define BCR_MakeCallPending         0x00000008
#define BCR_Initialized             0x00000010
#define BCR_BCMFailed               0x00000020  // Informational purposes only . Do not Test or REad
#define BCR_InformingRemoteNodes    0x00000040
#define BCR_BCMInProgress           0x00000100
#define BCR_LastNodeRemoved         0x00000200
#define BCR_Freed                   0x00000400
#define BCR_BCRNeedsToBeFreed       0x00000800
#define BCR_NewNodeArrived          0x00001000
#define BCR_NoNodesPresent          0x00002000

//
// This is information useful in maintaining the BCR
// Broadcast Channels Register.
//


typedef struct _BROADCAST_CHANNEL_DATA
{

    //
    // Flags
    //
    ULONG Flags;

    //
    // IRM;s BCR. This is the actual record of the bus's IRM. And is meant to indicate the current state 
    //
    NETWORK_CHANNELSR IRM_BCR;

    
    //
    // Broadcast Channels Register for the local host. This is the one a remote node will write to and read from
    // pLocalBcRMdl points to this structure . This is Byteswapped to reppresent the BigEndian 1394 Bus Format
    //
    ULONG LocalHostBCRBigEndian;


    //
    // Mdl pointing to Local Host BCR. Other machines will write to this MDL.
    //
    PMDL pLocalBCRMdl;  


    //
    // Data pointed to by the pRemoteBCRMdl and will copied to IRM_BCR. The data that will be read will
    // be in the BigEndian format Pointed to by RemoteBCRMDl
    //
    ULONG RemoteBCRMdlData;
    
    //
    // MDL pointing to Remote Nodes' BCR. This will be used in reading other machine's 
    // BCR. This points to the RemoteBCRMdlData
    //
    
    PMDL pRemoteBCRMdl;

    //
    // Make a copy of the BCR that is used in informing other nodes 
    // about this node's BCR when the local node is the IRM
    //
    ULONG AsyncWriteBCRBigEndian;

    PMDL pAsyncWriteBCRMdl;

    
    //
    // Local Node Address. This changes from Reset to Reset  
    //
    NODE_ADDRESS LocalNodeAddress;


    ULONG LocalNodeNumber;

    //
    // Address Range Context needed for Broadcast Channels
    // Register
    //
    ADDRESS_RANGE_CONTEXT AddressRangeContext;

    //
    // Topology Buffer
    //
    PTOPOLOGY_MAP               pTopologyMap;

    //
    // Event that the Make call will pend on for completion of the BCM 
    //
    NIC1394_EVENT MakeCallWaitEvent;

    //
    // BoadcastChannelVc
    //
    PCHANNEL_VCCB pBroadcastChanneVc;

    //
    // Locally Allocated Channel Num. Is only valid when the 
    //
    ULONG LocallyAllocatedChannel;

    //
    // The Generation at which the IRM was set. This can then be used to check the 
    // validity of the IRM

    ULONG IrmGeneration;

    //
    // Event To specify that a new node has come in and waiting threads can continue
    //
    NIC1394_EVENT BCRWaitForNewRemoteNode;

    //
    // Event to synchronize the shutting down of the adapter and freeing the address range
    //
    NIC1394_EVENT BCRFreeAddressRange;
    
} BROADCAST_CHANNEL_DATA, *PBROADCAST_CHANNEL_DATA;




//
// Flags for the PDO Control Block
//
#define PDO_NotValid                            0x00000001
#define PDO_Activated                           0x00000002 
#define PDO_Removed                             0x00000004
#define PDO_BeingRemoved                        0x00000008
#define PDO_AllocateAddressRangeFailure         0x00000010
#define PDO_AllocateAddressRangeSucceeded       0x00000020
#define PDO_AddressRangeFreed                   0x00000040
#define PDO_AllocateAddressRangeFlags           0x000000F0
#define PDO_ResetRegistered                     0x00000100
#define PDO_NotInsertedInTable                  0x00000200  // Informational purposes


typedef struct  
_REMOTE_NODE
{
    // The Tag should MTAG_REMOTE_NODE
    //
    
    ULONG ulTag;

    //
    // The Vurrent Node Address
    //
    NODE_ADDRESS RemoteAddress;

    //
    // Ushort Gap 
    //
    USHORT Gap;
    
    // The PDO itself
    //
    
    PDEVICE_OBJECT pPdo;

    // This is the pointer to the next field in the PDO
    //
    LIST_ENTRY linkPdo;

    // 64 bit Unique Id associated with a 1394 Node
    //
    UINT64 UniqueId;

    //
    // Enum1394 handle for the node
    //
    PVOID Enum1394NodeHandle;


    // flags can be one of the following. Essentially marks the PDO as 
    // good or bad
    //  
    ULONG ulFlags;

    // Back link to the Adapter that PDO hangs off
    //
    PADAPTERCB pAdapter;

    // The refcount associated with the Pdo
    //
    REF Ref;

    // This is the linked list of VCs, that are using the Pdo to preform
    //
    LIST_ENTRY VcList;

    // All the fields that are related to the Recv Fifo are present in this
    // structure
    //
    RECV_FIFO_DATA RecvFIFOData;

    //
    // Lock to synchronize all the reassembly operations in the Node
    //
    NIC_SPIN_LOCK ReassemblyLock;
    
    //
    // Linked list of Reassembly Structure 
    //
    LIST_ENTRY ReassemblyList;

    // This structure maintains cached information about the remote node.
    //
    struct
    {
        UINT SpeedTo;                     // From GetMaxSpeedBetweenNodes.
        UINT MaxRec;                      // From the node's config ROM.
        UINT EffectiveMaxBufferSize;      // Computed from the SpeedTo, MaxRec,
                                          // and local speed.

    } CachedCaps;

    //
    // Ethernet Address - to be used by the bridge to recognize packets
    // originating from this node. An MD5 Signature of the Euid
    //
    ENetAddr ENetAddress;
}
REMOTE_NODE, *PREMOTE_NODE, **PPREMOTE_NODE;

//
// These flags are common to the Adapter 
//

//
//fADAPTER_IndicatedMediaDisonnect  - indicateds that the miniport has already
//                                    called NdisMIndicateStatus
//

#define fADAPTER_Halting                        0x00000001
#define fADAPTER_RegisteredWithEnumerator       0x00000002
#define fADAPTER_FailedRegisteration            0x00000004
#define fADAPTER_IndicatedMediaDisonnect        0x00000008
#define fADAPTER_InvalidGenerationCount         0x00000010
//#define fADAPTER_BCMWorkItem                  0x00000020
#define fADAPTER_RegisteredAF                   0x00000040
#define fADAPTER_Reset10Sec                     0x00000080
#define fADAPTER_FailedInit                     0x00000100
#define fADAPTER_VDOInactive                    0x00000200
#define fADAPTER_FreedRcvTimers                 0x00001000  // debugging purposes
#define fADAPTER_FreedTimers                    0x00002000  // debugging purposes
#define fADAPTER_DeletedLookasideLists          0x00004000  // debugging purposes
#define fADAPTER_UpdateNodeTable                0x00008000  // set if no remote node for reassembly
#define fADAPTER_DoStatusIndications            0x00010000  // if set, call NdisMIndicateStatus 
#define fADAPTER_DeletedWorkItems               0x00100000  // debugging purposes
#define fADAPTER_NoMoreReassembly               0x00200000
#define fADAPTER_RemoteNodeInThisBoot           0x00400000  //was a remote node in this boot
#define fADAPTER_BridgeMode                     0x00800000  // is the Adapter in bridge mode
#define fADAPTER_LowPowerState                  0x01000000  // adapter is in low power state

// Adapter control block defining the state of a single L2TP mini-port
// adapter.  An adapter commonly supports multiple VPN devices.  Adapter
// blocks are allocated in MiniportInitialize and deallocated in MiniportHalt.
//
typedef struct
_ADAPTERCB
{
    // Set to MTAG_ADAPTERCB for easy identification in memory dumps and use
    // in assertions.
    //
    ULONG ulTag;

    // Next/prev adapter control block.
    LIST_ENTRY linkAdapter;

    
    // ACBF_* bit flags indicating various options.  Access restrictions are
    // indicated for each individual flag.  Many of these flags are set
    // permanently at initialization and so have no access limitation.
    //
    //
    ULONG ulFlags;

    //
    // List of PDO control blocks, each representing a remote
    // device.
    //
    LIST_ENTRY PDOList;

    //
    // Reference count on this control block.  The reference pairs are:
    //
    //
    // Access is via ReferenceAdapter and DereferenceAdapter only.
    // Serialization is via interlocked operations.
    //
    LONG lRef;


    //
    // This is the adapter-wide lock, serializing access to everything except
    // to the contents of VCs, which are serialized by their own lock.
    //
    NDIS_SPIN_LOCK lock;

    //
    // Generation Count of the physical Bus 1394
    // 
    UINT Generation;

    
    //
    // NDIS's handle for this mini-port adapter passed to us in
    // MiniportInitialize.  This is passed back to various NdisXxx calls.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    //
    // unique ID for the local host controller this adapter is representing
    //
    UINT64 UniqueId;

    //
    // List of address-family control blocks, each representing
    // an open address family binding.
    //
    LIST_ENTRY AFList;


    //
    // List of Recv-FIFO control blocks, each representing one
    // local receive FIFO.
    //
    PRECVFIFO_VCCB pRecvFIFOVc;

    //
    // This event is used to wake up the work Item that will complete
    // the RecvFIFO make call
    //
    NDIS_EVENT RecvFIFOEvent;

    //
    // The is the LocalHost information that is used in identifying 
    // the local host. This contains the PDO and the Unique ID 
    // for the Host and is a per Adapter quantity
    //
    PDEVICE_OBJECT pNdisDeviceObject;

    PREMOTE_NODE pLocalHost;

    
    // Information about the broadcast channel.
    //
    struct
    {
        ULONG ulFlags;
        ULONG ulChannel;

        LIST_ENTRY      VcList;
    } BroadcastChannel;

     
    // Stores information about the Hardware Status of the NIc
    //
    NDIS_HARDWARE_STATUS HardwareStatus;

    // Store the MediaConnectStatus that Ndis requests
    //

    NDIS_MEDIA_STATE                MediaConnectStatus;

    // NodeAddress of the physical bus  
    //
    NODE_ADDRESS NodeAddress;

    //
    // enum1394 handle for the adapter
    //
    PVOID   EnumAdapterHandle;

    //
    // BCR Related Information is stored here
    //
    BROADCAST_CHANNEL_DATA BCRData;

    //
    // Bitmap Channnels allocated by this adapter
    //
    ULONGLONG ChannelsAllocatedByLocalHost;

    //
    // Speed - of the local network
    //
    ULONG SpeedMbps;

    //
    // Speed according to the 1394 speed codes
    //
    ULONG Speed;

        
    //
    // Gasp header that will bew inserted before every Broadcast write
    //
    
    GASP_HEADER GaspHeader;

    //
    // Lookaside lists for Large sends 
    //
    NIC_NPAGED_LOOKASIDE_LIST SendLookasideList8K;

    //
    // Lookaside List to handle packets of 2k 
    //

    NIC_NPAGED_LOOKASIDE_LIST SendLookasideList2K;

    //
    // Small Lookaside list for packets less than 100 bytes
    //
    NIC_NPAGED_LOOKASIDE_LIST SendLookasideList100; 

    //
    // Datagram Label Number - used in fragmentation
    //
    ULONG dgl;

    USHORT MaxRec;
    USHORT Gap;
    //
    // Node Table - Mapping of Node Address with RemoteNodes
    //
    NODE_TABLE NodeTable;

    //
    // Number of remote nodes present 
    //
    ULONG NumRemoteNodes;
    //
    // Timer used for reassembly invalidation
    //
    NDIS_MINIPORT_TIMER ReassemblyTimer;

    //
    // Packet pool for loopback packets.
    //
    NIC_PACKET_POOL LoopbackPool;

    //
    // Buffer pool for loopback packets.
    //
    NDIS_HANDLE LoopbackBufferPool;


    //
    // Handle for the config rom that was added to the bus driver
    //
    HANDLE hCromData;

    //
    // WaitForRemoteNode - threads which need to wait for
    // the arrival of a remote node use this event
    //
    NIC1394_EVENT WaitForRemoteNode;


    //
    // Config Rom Mdl that points to the config rom string
    //
    PMDL pConfigRomMdl;

    PREMOTE_NODE pLastRemoteNode;
    
    //
    // Packet Log (used only for tracking packets).
    //
    PNIC1394_PKTLOG pPktLog;

    //
    // Per adapter stats 
    //
    ADAPT_STATS AdaptStats;
    //
    // Read/WriteCapabilities
    //
    GET_LOCAL_HOST_INFO2 ReadWriteCaps;

    //
    // SCode - speed of the bus
    //
    ULONG SCode;

    //
    // Max packet size that this adapter can read
    //
    ULONG MaxSendBufferSize; 
    ULONG MaxRecvBufferSize; 
    ULONG CurrentLookahead;

    //
    // PacketFilter - Ethernet structs
    //

    PETHERNET_VCCB pEthernetVc;
    ULONG           CurPacketFilter ;
    ULONG           ProtocolOptions;
    MAC_ADDRESS     McastAddrs[MCAST_LIST_SIZE];
    ULONG           McastAddrCount;
    ULONG           CurLookAhead ;
    MAC_ADDRESS     MacAddressEth;


    //
    // ReceivePacket Serialization
    //
    NIC_SERIALIZATION  SerRcv;

    NIC_SERIALIZATION SerSend;

    NIC_SERIALIZATION Status;

    NIC_SERIALIZATION Reassembly;

    NIC_SERIALIZATION LoadArp;

    // 
    // Outstanding work Items
    ULONG OutstandingWorkItems;

    //
    // Outstanding Reassemblies
    //
    ULONG OutstandingReassemblies; 

    //
    // Miniport Name
    //
    WCHAR AdapterName[ADAPTER_NAME_SIZE];

    //
    // Size of Name
    //
    ULONG AdapterNameSize;

    //
    // Ioctl Sent to the Arp module
    //

    ARP1394_IOCTL_COMMAND ArpIoctl;

    //
    // Is Arp Started
    //

    BOOLEAN fIsArpStarted;

    //
    // Power State
    //
    NET_DEVICE_POWER_STATE PowerState;
} ADAPTERCB, *PADAPTERCB;


//
// Address Family Flags
//

#define ACBF_Allocated                      0x00000001
#define ACBF_Initialized                    0x00000002  
#define ACBF_ClosePending                   0x00000100
#define ACBF_CloseComplete                  0x00000200


// Address family control block, describing the state of an ndis address family.
// Each block may have zero or more VCs associated with it.
//
typedef struct
_AFCB
{
    // Set to MTAG_AFCB for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;

    // ACBF_* bit flags indicating various options.  Access restrictions are
    // indicated for each individual flag.  Many of these flags are set
    // permanently at initialization and so have no access limitation.
    //
    //
    ULONG ulFlags;


    // Reference count on this control block.  The reference pairs are:
    //
    // (a) A reference is added when this block is linked to the adapter's
    //     list of af blocks, and removed when it is unlinked.
    //
    // (a) A reference is added when a call on a VCCB is created
    //     removed when it is deleted.
    //
    // Access is via ReferenceTunnel and DereferenceTunnel only which use
    // 'ADAPTERCB.lockTunnels' for protection.
    //
    LONG lRef;

    // Links to the prev/next AFCB in the owning adapter's AF list.
    // Access to the list links is protected by 'ADAPTERCB.lock'.
    //
    LIST_ENTRY linkAFCB;


    // List of all VCs associated with this address family. 
    // Access is protected by the adapter lock.
    //
    LIST_ENTRY AFVCList;

    // Back pointer to owning adapter's control block.
    //
    PADAPTERCB pAdapter;

    // NDIS's handle for our Address Family as passed to our CmOpenAfHandler
    // or NULL if none.
    //
    NDIS_HANDLE NdisAfHandle;


}
AFCB, *PAFCB;




// Call statistics block.
//
typedef struct
_CALLSTATS
{
    // System time call reached established state.  When the block is being
    // used for cumulative statistics of multiple calls, this is the number of
    // calls instead.
    //
    LONGLONG llCallUp;

    // Duration in seconds of now idle call.
    //
    ULONG ulSeconds;

    // Total data bytes received and sent.
    //
    ULONG ulDataBytesRecd;
    ULONG ulDataBytesSent;

    // Number of received packets indicated up.
    //
    ULONG ulRecdDataPackets;
   
   // TODO: add more stats if required.

    ULONG ulSentPkts;

    //
    // NDis Packet failures
    //
    ULONG ulSendFailures;   

    //
    // Bus AsyncWrite or Stream failires
    //

    ULONG ulBusSendFailures;
    
    ULONG ulBusSendSuccess;

}
CALLSTATS;

typedef
NDIS_STATUS
(*PFN_INITVCHANDLER) (
        VCCB *pVc
    );




typedef
NDIS_STATUS
(*PFN_SENDPACKETHANDLER) (
        VCCB *pVc,
        NDIS_PACKET * pPacket
    );

typedef
NDIS_STATUS
(*PFN_CLOSECALLHANDLER) (
    VCCB *pVc
    );

typedef 
VOID
(*PFN_RETURNHANDLER) (
    VCCB *pVc,
    PNDIS_PACKET *pPacket
    );

// Table of vc-type-specific handler functions.
//
typedef struct  _VC_HANDLERS
{
    PFN_INITVCHANDLER MakeCallHandler;
    PFN_CLOSECALLHANDLER CloseCallHandler;
    PFN_SENDPACKETHANDLER SendPackets;

} VC_HANDLERS;


typedef enum _NIC1394_VC_TYPE
{
    NIC1394_Invalid_Type,
    NIC1394_SendRecvChannel,
    NIC1394_RecvFIFO,
    NIC1394_SendFIFO,
    NIC1394_MultiChannel,
    NIC1394_Ethernet,
    NIC1394_SendChannel,
    NIC1394_RecvChannel,
    Nic1394_NoMoreVcTypes

} NIC1394_VC_TYPE, *PNIC1394_VC_TYPE;



// Virtual circuit control block header defining the state of a single VC that
// is common to all the different types of VCs.
//
typedef struct
_VCHDR
{
    // Set to MTAG_VCCB_* for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;
    


    // The Pdo Block that will be used to perform all the operations  for this Vc 
    //
    //

    PREMOTE_NODE pRemoteNode;

    //
    // pLocalHostVdo - local host's VDO  that will be used for all channel and 
    // recv fifo allocations
    //
    PDEVICE_OBJECT pLocalHostVDO;

    // Links to the prev/next VCCB in the owning AF's control block.
    // Access is protected by 'ADAPTERCB.lock'.
    //
    LIST_ENTRY linkAFVcs;

    //  The VCType and Destination of the call that has been set up on the VC
    //  The VCType can be either Isoch or Async, Sends or Recieve. Each type
    //  of VC has an address associated with it
    
    NIC1394_VC_TYPE VcType;

    
    // This stores the generation of the physical adapter. And should match the value
    // kept in the adapter block
    PUINT pGeneration;


    // VCBF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines.
    //
    // VCBF_IndicateReceivedTime: Set if MakeCall caller sets the
    //     MediaParameters.Flags RECEIVE_TIME_INDICATION flag requesting the
    //     TimeReceived field of the NDIS packet be filled with a timestamp.
    //
    // VCBF_CallClosableByClient: Set when a call is in a state where
    //     NicCmCloseCall requests to initiate clean-up should be accepted.
    //     This may be set when VCBF_CallClosableByPeer is not, which means we
    //     have indicated an incoming close to client and are waiting for him
    //     to do a client close in response (in that weird CoNDIS way).  The
    //     flag is protected by 'lockV'.
    //
    // VCBF_VcCreated: Set when the VC has been created successfully.  This is
    //     the "creation" that occurs with the client, not the mini-port.
    // VCBF_VcActivated: Set when the VC has been activated successfully.
    // VCBM_VcState: Bit mask including each of the above 3 NDIS state flags.
    //
    // VCBF_VcDeleted: Set when the DeleteVC handler has been called on this
    //     VC.  This guards against NDPROXY double-deleting VCs which it has
    //     been known to do.
    //
    // The pending bits below are mutually exclusive (except ClientClose which
    // may occur after but simultaneous with ClientOpen), and so require lock
    // protection by 'lockV':
    //
    // VCBF_ClientOpenPending: Set when client attempts to establish a call,
    //     and the result is not yet known.
    // VCBF_ClientClosePending: Set when client attempts to close an
    //     established call and the result is not yet known.  Access is
    //     protected by 'lockV'.
    // VCBM_Pending: Bit mask that includes each of the 4 pending flags.
    //
    // VCBF_ClientCloseCompletion: Set when client close completion is in
    //     progress.
    //
    // VCBF_WaitCloseCall: Set when the client is expected to call our call
    //     manager's CloseCall handler.  This is strictly a debug aid.
    //
    // VCBF_FreedResources - VC This is a channel VC and because the last           
    //      node in the network was being removed, its resources have been freed
    
    ULONG ulFlags;
        #define VCBF_IndicateTimeReceived   0x00000001
        #define VCBF_CallClosableByClient   0x00000002
        #define VCBF_VcCreated              0x00000100
        #define VCBF_VcActivated            0x00000200
        #define VCBF_VcDispatchedCloseCall  0x00000400
        #define VCBF_MakeCallPending        0x00002000
        #define VCBF_CloseCallPending       0x00008000
        #define VCBF_VcDeleted              0x00010000
        #define VCBF_MakeCallFailed         0x00020000
        #define VCBF_CloseCallCompleted     0x00040000
        #define VCBF_WaitCloseCall          0x00200000
        #define VCBF_NewPdoIsActivatingFifo 0x01000000
        #define VCBF_PdoIsBeingRemoved      0x02000000
        #define VCBF_NeedsToAllocateChannel 0x04000000
        #define VCBF_GenerationWorkItem     0x10000000
        #define VCBF_AllocatedChannel       0x20000000
        #define VCBF_BroadcastVc            0x40000000
        #define VCBF_FreedResources         0x80000000

        #define VCBM_VcState                0x00000700
        #define VCBM_Pending                0x0000F000
        #define VCBM_NoActiveCall           0x000F0000
        #define VCBM_PdoFlags               0x0F000000


    // Back pointer to owning address family control block.
    //
    AFCB* pAF;


    // Reference count on the active call.
    // References may only be added
    // when the VCCB_VcActivated flag is set, and this is enforced by
    // ReferenceCall.  The reference pairs are:
    //
    // (a) A reference is added when a VC is activated and removed when it is
    //     de-activated.
    //
    // (b) A reference is added when the send handler accepts a packet.
    //
    // The field is accessed only by the ReferenceCall and DereferenceCall
    // routines, which protect the field with 'lock'.
    //
    REF CallRef;

    // Reference count on this VC control block.  The reference pairs are:
    //
    // (a) NicCoCreateVc adds a reference that is removed by NicCoDeleteVc.
    //     This covers all clients that learn of the VCCB via NDIS.
    //
    // The field is accessed only by the ReferenceVc and DereferenceVc
    // routines, which protect with Interlocked routines.
    //
    LONG lRef;


    //
    // This is a copy the parameters that are passed to the VC in 
    // a Make Call. Each VC needs to keep a copy. This is stored here
    //
    
    NIC1394_MEDIA_PARAMETERS Nic1394MediaParams;
    

    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this VC passed to us in MiniportCoCreateVcHandler.
    // This is passed back to NDIS in various NdisXxx calls.
    //
    NDIS_HANDLE NdisVcHandle;

    // This linked list is used to designate all the VCs that are using a single PdoCb
    // The head of this list resides in a REMOTE_NODE. So that when a Pdo goes away, we can go and
    // close all the Vcs that are dependent on it. No RecvFIFO included

    LIST_ENTRY SinglePdoVcLink;
    
    // CALL SETUP ------------------------------------------------------------

    // Address of the call parameters passed down in CmMakeCall.  This field
    // will only be valid until the NdisMCmMakeCallComplete notification for
    // the associated call is made, at which time it is reset to NULL.  Access
    // is via Interlocked routines.
    //
    PCO_CALL_PARAMETERS pCallParameters;

    UINT    MTU;

    // This is the initialize handler used to initialize the Vc
    // Each Vc has its own specific initialize handler so that all the 
    // data structures that specific to it, can be filled
    //
    VC_HANDLERS VcHandlers;
    

    // STATISTICS ------------------------------------------------------------

    // Statistics for the current call.  Access is protected by 'lock'.
    //
    CALLSTATS stats;

    // This is a pointer to the lock in the adapater
    // structure. 
    PNDIS_SPIN_LOCK plock;

    //
    // MaxPayload that this VC will send in a single IRP
    // To be used in Lookaside lists
    //
    ULONG MaxPayload;

}
VCHDR;

//
// Virtual circuit control block defining the state of a single SendFIFO VC.
//
typedef struct
_SENDFIFO_VCCB
{
    // Common header for all types of VCs
    //
    VCHDR Hdr;

    
    // Prev/next in the list of SendFIFO VCs for a particular destination
    // PDO
    //
    LIST_ENTRY SendFIFOLink;

    // SendFIFO-specific VC Info
    //
    NIC1394_FIFO_ADDRESS     FifoAddress;

    // Shortcuts to the Values we were passed in the Make call 
    // that activated the VC
    //
    //      UINT MaxSendBlockSize;
    UINT  MaxSendSpeed;

    
} SENDFIFO_VCCB, *PSENDFIFO_VCCB;


// Virtual circuit control block defining the state of a single RecvFIFO VC.
//
typedef struct
_RECVFIFO_VCCB
{
    // Common header for all types of VCs
    //
    VCHDR Hdr;

    // Prev/next in the list of RecvFIFO VCs for a particular Recv FIFO
    // address.
    //
    LIST_ENTRY RecvFIFOLink;

    // Packet Pool Handle 
    //
    NIC_PACKET_POOL PacketPool;

    //NDIS_HANDLE PacketPoolHandle;

    // Slist Header. All buffers are posted here, using Interlocked routines
    //

    SLIST_HEADER FifoSListHead;

    // Slist Spin lock that protects the Slist
    //
    KSPIN_LOCK FifoSListSpinLock;

    //
    // Num Fifo Elements allocated
    //
    ULONG NumAllocatedFifos;

    // Num of Fifo that have been indicated to the miniport
    // Count of Fifo that the Nic has not returned to the bus driver
    //
    ULONG NumIndicatedFifos;
    
    // This is the address range that is returned in the allocate
    // address irb. Will be changed to a pointer or an array
    //
    
    ADDRESS_RANGE   VcAddressRange;

    // This is the number of address ranges that the bus driver
    // returned. For now, it is expected to be one.
    //
    UINT AddressesReturned;


    //
    // Handle to the address range
    //
    HANDLE hAddressRange;

    //
    // Buffer pool
    //
    NIC_BUFFER_POOL BufferPool;

    //NIC_WORK_ITEM FifoWorkItem;

    BOOLEAN FifoWorkItemInProgress ;

    UINT NumOfFifosInSlistInCloseCall; 

#if FIFO_WRAPPER

    PADDRESS_FIFO pFifoTable[NUM_RECV_FIFO_BUFFERS];

#endif
    
} RECVFIFO_VCCB, *PRECVFIFO_VCCB;


// Virtual circuit control block defining the state of a single CHANNEL VC.
//
typedef struct
_CHANNEL_VCCB
{
    // Common header for all types of VCs
    //
    VCHDR Hdr;

    // Prev/next in the list of channel VCs for a particular destination
    // channel
    //
    LIST_ENTRY ChannelLink;


    // Channel-specific VC Info
    //
    UINT    Channel;

    // The speed at which this Channel will stream data
    //
    UINT Speed;

    // Indicates the Sy field in packets that will indicated up
    //
    ULONG ulSynch;

    // the Tag used in submitting asyncstream irps
    //
    ULONG ulTag;

    // MaxBytesPerFrameRequested and available
    //
    ULONG MaxBytesPerFrameRequested;
    ULONG BytesPerFrameAvailable;

    // Handle to the Resources allocated 
    //
    HANDLE hResource;

    // Speeds Requested and speed returned
    //
    ULONG SpeedRequested;
    ULONG SpeedSelected;

    // Maximum Buffer Size
    //
    ULONG MaxBufferSize;

    // Num of descriptors that were attached to the resources
    //
    ULONG NumDescriptors;

    // Pointer to an array of isochDescriptors used in AttachBuffers
    //
    PISOCH_DESCRIPTOR       pIsochDescriptor;   

    // PacketPool Handle
    //
    NIC_PACKET_POOL PacketPool;

    //NDIS_HANDLE hPacketPoolHandle;
    //
    // Temporary
    //
    UINT PacketLength;

    //
    // Number of Isoch Descriptors that the Bus driver has indicated to the miniport
    //
    ULONG NumIndicatedIsochDesc;


    //
    // Event to signal that the last of the Isoch descriptors have
    // been returned to the bus driver. Only set when Vc is closing (after IsochStop)
    //
    NDIS_EVENT LastDescReturned;

    //
    // Channel Map used in Multichannel Vcs
    //
    ULARGE_INTEGER uliChannelMap;

    
} CHANNEL_VCCB, *PCHANNEL_VCCB;


typedef struct
_ETHERNET_VCCB
{
    // Common header for all types of VCs
    //
    VCHDR Hdr;


    NIC_PACKET_POOL     PacketPool;
    
} ETHERNET_VCCB, *PETHERNET_VCCB;





// The following union has enough space to hold any of the type-specific
// VC control blocks.
//
typedef union _VCCB
{
    VCHDR Hdr;
    CHANNEL_VCCB ChannelVc;
    SENDFIFO_VCCB SendFIFOVc;
    RECVFIFO_VCCB RecvFIFOVc;
    ETHERNET_VCCB EthernetVc;
    
} VCCB, *PVCCB;

// The next structure is used when sending a packet, to store context 
// information in an NdisPacket. These are pointers to the Vc and the Irb   
// and are stored in the MiniportWrapperReserved field of the NdisPacket
// and has a limit of 2 PVOIDs
//
typedef union _PKT_CONTEXT
{
        struct 
        {
            PVCCB pVc;
            PVOID  pLookasideListBuffer;
        
        } AsyncWrite;

        struct 
        {
            PVCCB pVc;
            PVOID  pLookasideListBuffer;

        } AsyncStream;

        //
        // For receives make sure the first element is the Vc or we will break;
        //
        struct
        {
            PRECVFIFO_VCCB pRecvFIFOVc;
            PADDRESS_FIFO pIndicatedFifo;

        } AllocateAddressRange;

        struct 
        {   
            PCHANNEL_VCCB pChannelVc;
            PISOCH_DESCRIPTOR pIsochDescriptor;
            
        } IsochListen;

        struct
        {
            //
            // First DWORD is the Vc
            //
            PVCCB pVc;

            //
            // Second is the isoch descriptor or Fifo
            //
            union 
            {
                PISOCH_DESCRIPTOR pIsochDescriptor;  // channels use isoch desc

                PADDRESS_FIFO pIndicatedFifo;   // fifo use AddressFifo

                PVOID   pCommon;  // to be used in the common code path
    
            } IndicatedStruct;

        } Receive;

        struct 
        {
            
            PNDIS_PACKET pOrigPacket;

        } EthernetSend;

        

} PKT_CONTEXT,*PPKT_CONTEXT,**PPPKT_CONTEXT; 


typedef struct _NDIS1394_FRAGMENT_HEADER
{
    union 
    {
        struct 
        {
            ULONG   FH_fragment_offset:12;
            ULONG   FH_rsv_0:4;
            ULONG   FH_buffersize:12;
            ULONG   FH_rsv_1:2;
            ULONG   FH_lf:2;

        } FirstQuadlet;

        struct 
        {
            ULONG   FH_EtherType:16;
            ULONG  FH_buffersize:12;
            ULONG   FH_rsv_1:2;
            ULONG   FH_lf:2;

    
        } FirstQuadlet_FirstFragment;

        ULONG FH_High;
    } u;

    union
    {
        struct 
        {
        
            ULONG FH_rsv:16;
            ULONG FH_dgl:16;

        } SecondQuadlet;

        ULONG FH_Low;
    } u1;
    
} NDIS1394_FRAGMENT_HEADER, *PNDIS1394_FRAGMENT_HEADER;







#define LOOKASIDE_HEADER_No_More_Framgents                  1
#define LOOKASIDE_HEADER_SendPacketFrees                    2
#define LOOKASIDE_HEADER_SendCompleteFrees                  4


//
// This structure is used with the above flags to maintain state within the lookaside buffer
//


typedef  union _LOOKASIDE_BUFFER_STATE
{
    struct 
    {
        USHORT Refcount;
        USHORT Flags;
    } u;

    LONG FlagRefcount;

} LOOKASIDE_BUFFER_STATE, *PLOOKASIDE_BUFFER_STATE;


typedef enum _BUS_OPERATION 
{
    InvalidOperation,
    AsyncWrite,
    AsyncStream,
    AddressRange,
    IsochReceive
    

} BUS_OPERATION, *PBUS_OPERATION;


//
// This will be used as a local variable
// during a send operation and will
// keep all the state information 
// regarding fragmentation
//
typedef struct _FRAGMENTATION_STRUCTURE
{
    //
    // Start of the buffer that will be used in the send.
    // Usually from a lookaside list
    //
    PVOID pLookasideListBuffer;
    

    //
    // Fragment Length
    //
    ULONG FragmentLength ; 

    //
    // Start of the this fragment to be used
    //
    PVOID pStartFragment;   

    //
    // Specified if an async write or an asyncstream operation is occurring
    //
    BUS_OPERATION AsyncOp;

    //
    // LookasideBuffer associated with the fragmentation
    //
    PVOID pLookasideBuffer;


    //
    // Start  of the next fragment
    //
//  PVOID pStartNextFragment;
    //
    // Length of each fragment
    //
    ULONG MaxFragmentLength;

    //
    // NumFragments that will be generated
    //
    ULONG NumFragmentsNeeded ;

    //
    // Current NdisBuffer which is being fragmented
    //
    PNDIS_BUFFER pCurrNdisBuffer;

    //
    // Length that needs to be copied in CurrNdisBuffer
    //
    ULONG NdisBufferLengthRemaining;

    //
    // Point to which copying has occurred in the pCurrNdisBuffer
    //
    PVOID pSourceAddressInNdisBuffer;
    
    //
    // UnFragment Header from this NdisPacket
    //

    NDIS1394_UNFRAGMENTED_HEADER UnfragmentedHeader;

    //
    // Fragmented Header to be used by all the fragments 
    // generated by this NdisPackets
    //
    

    NDIS1394_FRAGMENT_HEADER FragmentationHeader;
    
    
    //
    // Status of the lf field in the fragment header. Also serves as an 
    // implicit flag about the state of the fragmentation
    //
    NDIS1394_FRAGMENT_LF lf;

    //
    // Length of the Ip Datagram, to be used as the buffersize in fragment header
    //
    USHORT IPDatagramLength;

    //
    // An AsyncStream will have a gasp header as well . So the starting 
    // offset can either be either 8 or 16. Only applicable for fragmentation code path
    //
    ULONG TxHeaderSize;

    //
    // Pointer to the lookaside list that this buffer was allocated from
    // 
    PNIC_NPAGED_LOOKASIDE_LIST pLookasideList;

    //
    // Adapter - local host
    //
    PADAPTERCB pAdapter;

    //
    // Pointer to the IRB to be used in the current fragment
    //
    PIRB pCurrentIrb;

    //
    // Current Fragment Number 
    // 
    ULONG CurrFragmentNum;

    PVOID pStartOfFirstFragment;
    
}FRAGMENTATION_STRUCTURE, *PFRAGMENTATION_STRUCTURE;                



typedef struct _LOOKASIDE_BUFFER_HEADER 
{

    //
    // Refcount
    //
    ULONG OutstandingFragments; 
    
    //
    // NumOfFragments generated by the NdisPacket So Far
    //
    ULONG FragmentsGenerated;

    //
    // Will this Buffer contain fragments
    //
    BOOLEAN IsFragmented; 
    
    //
    // Pointer to the NdisPacket whose data is being transmitted
    // by the lookaside buffer
    //
    PNDIS_PACKET pNdisPacket;

    //
    // pVc Pointer to the Vc on which the packet was indicated
    // Used to complete the packet
    //
    PVCCB pVc;

    //
    // Pointer to the lookaside list that this buffer was allocated from
    // 
    PNIC_NPAGED_LOOKASIDE_LIST pLookasideList;

    //
    // Bus Op AsyncStream or AsyncWrite. 
    // AsyncWrite reference the RemoteNode. AsuncWrite does not
    //
    BUS_OPERATION AsyncOp;

    //
    // Start of Data
    //
    PVOID pStartOfData;

    
} LOOKASIDE_BUFFER_HEADER, *PLOOKASIDE_BUFFER_HEADER;

typedef enum _ENUM_LOOKASIDE_LIST
{
    NoLookasideList,
    SendLookasideList100,
    SendLookasideList2K,
    SendLookasideList8K
    
} ENUM_LOOKASIDE_LIST, *PENUM_LOOKASIDE_LIST;


//
// Unfragmented Buffer
//
typedef struct _UNFRAGMENTED_BUFFER
{
    LOOKASIDE_BUFFER_HEADER Header;

    IRB Irb;

    UCHAR  Data [1];

} UNFRAGMENTED_BUFFER, *PUNFRAGMENTED_BUFFER;



#define PAYLOAD_100 100

//
// A simple packet with no fragmentation . This will primarily be used for the IP Acks and ARP req
//
typedef struct _PAYLOAD_100_LOOKASIDE_BUFFER
{

    LOOKASIDE_BUFFER_HEADER Header;

    IRB Irb;

    UCHAR  Data [PAYLOAD_100 + sizeof (GASP_HEADER)];

} PAYLOAD_100_LOOKASIDE_BUFFER;

//
// This lookaside will handle packets upto 2K. 
//
// Calculate the theoretical maximum number of fragments that can occur for a 
// a 2K Packet
//
#define PAYLOAD_2K ASYNC_PAYLOAD_400_RATE

#define NUM_FRAGMENT_2K ((PAYLOAD_2K/ASYNC_PAYLOAD_100_RATE)  +1)

typedef struct _PAYLOAD_2K_LOOKASIDE_BUFFER
{

    LOOKASIDE_BUFFER_HEADER Header;

    //
    // There can be a maximum of 2048 bytes in 1 Async Packet fragment
    // on ASYNC_PAYLOAD_400 so this will cater to 
    // that, but it will be prepared for the worst
    //
    //
    IRB Irb[NUM_FRAGMENT_2K];

    //
    // We get a data size large enough to handle 2048 bytes of data chopped up 
    // into the max num of fragments and leave room for header (fragmentation and Gasp)
    // To access we'll just use simple pointer arithmetic
    //
    
    UCHAR Data[PAYLOAD_2K+ (NUM_FRAGMENT_2K *(sizeof (GASP_HEADER)+sizeof (NDIS1394_FRAGMENT_HEADER)))];

} PAYLOAD_2K_LOOKASIDE_BUFFER, *PPAYLOAD_2K_LOOKASIDE_BUFFER;


//
// This is to handle large packets > 2K .For now I have chosen an arbitrary large amount
// of 8K
//
#define PAYLOAD_8K   ASYNC_PAYLOAD_400_RATE *4
   
#define NUM_FRAGMENT_8K (PAYLOAD_8K /ASYNC_PAYLOAD_100_RATE  +1)

typedef struct _PAYLOAD_8K_LOOKASIDE_BUFFER
{
    //
    // The same comments as the 2K_Lookaside Header apply here
    //
    LOOKASIDE_BUFFER_HEADER Header;

    IRB Irb[NUM_FRAGMENT_8K ];


    UCHAR Data[PAYLOAD_8K  + (NUM_FRAGMENT_8K*(sizeof (GASP_HEADER)+sizeof (NDIS1394_FRAGMENT_HEADER)))];



}PAYLOAD_8K_LOOKASIDE_BUFFER, *PPAYLOAD_8K_LOOKASIDE_BUFFER;







//
// The 1394 fragment that is passed down can have a gasp header, fragmentation header, 
// unfragmented header. Define Types to format these headers so that we can make 
// compiler do the pointer arithmetic for us.
//
typedef union _PACKET_FORMAT
{


    struct
    {
        GASP_HEADER GaspHeader;

        NDIS1394_FRAGMENT_HEADER FragmentHeader;
        
        UCHAR Data[1];

    } AsyncStreamFragmented;

    struct
    {
        GASP_HEADER GaspHeader;

        NDIS1394_UNFRAGMENTED_HEADER NonFragmentedHeader;

        UCHAR Data[1];

    } AsyncStreamNonFragmented;

    struct 
    {
        NDIS1394_FRAGMENT_HEADER FragmentHeader;
        
        UCHAR Data[1];
        
    } AsyncWriteFragmented;


    struct 
    {
        NDIS1394_UNFRAGMENTED_HEADER NonFragmentedHeader;

        UCHAR Data[1];

    }AsyncWriteNonFragmented;


    struct 
    {
        //
        // Isoch receive header has a prefix, isoch header, gasp header
        //
        ULONG Prefix;

        ISOCH_HEADER IsochHeader;

        GASP_HEADER GaspHeader;

        NDIS1394_UNFRAGMENTED_HEADER NonFragmentedHeader;

        UCHAR Data[1];
        

    } IsochReceiveNonFragmented;


    struct 
    {
        //
        // Isoch receive header has a prefix, isoch header, gasp header
        //

        ULONG Prefix;

        ISOCH_HEADER IsochHeader;

        GASP_HEADER GaspHeader;

        NDIS1394_FRAGMENT_HEADER FragmentHeader;

        UCHAR Data[1];


    }IsochReceiveFragmented;

}PACKET_FORMAT, DATA_FORMAT, *PPACKET_FORMAT, *PDATA_FORMAT;


//
// Used as an Info Struct for Out of Order Reassembly
//

typedef struct _REASSEMBLY_CURRENT_INFO 
{
    PMDL                pCurrMdl;
    PNDIS_BUFFER        pCurrNdisBuffer;
    PADDRESS_FIFO       pCurrFifo;
    PISOCH_DESCRIPTOR   pCurrIsoch;

} REASSEMBLY_CURRENT_INFO,  *PREASSEMBLY_CURRENT_INFO ;

typedef enum _REASSEMBLY_INSERT_TYPE
{
        Unacceptable,
        InsertAsFirst,
        InsertInMiddle,
        InsertAtEnd

}REASSEMBLY_INSERT_TYPE, *PREASSEMBLY_INSERT_TYPE;

//
// This is used as a descriptor for indicated fragments that are waiting for reassembly
//

typedef struct _FRAGMENT_DESCRIPTOR
{
    ULONG Offset;  // Offset of the incoming fragment
    ULONG IPLength;  // Length of the fragment
    PNDIS_BUFFER pNdisBuffer; // NdisBufferpointing to actual data
    PMDL pMdl;  // Mdl that belongs to the bus 
    NDIS1394_FRAGMENT_HEADER  FragHeader; // Fragment header of the Descriptor
    
    union 
    {
        PADDRESS_FIFO pFifo;
        PISOCH_DESCRIPTOR pIsoch;
        PVOID pCommon;
        PSINGLE_LIST_ENTRY pListEntry;
        
    }IndicatedStructure;
    

} FRAGMENT_DESCRIPTOR, *PFRAGMENT_DESCRIPTOR;

//
// Reassembly structure : An instance of the reassembly is created for
// every packet that is being reassembled. It contains all the relevant 
// bookkeeping information
// 
// This needs to be allocated from a lookaside list
// Each PDO will contain a list of all outstanding packets that are being reassembled/
//

//
// REASSEMBLY_NOT_TOUCHED  - Each reassembly structure will be marked as Not touched 
//                            in the timer routine. If the flag is not cleared by the next
//                            invocation of the timer, this structure will be freed
// REASSMEBLY_FREED -         The structure is about to be thrown away.
#define REASSEMBLY_NOT_TOUCHED      1
#define REASSEMBLY_FREED            2
#define REASSEMBLY_ABORTED          4





typedef struct  _NDIS1394_REASSEMBLY_STRUCTURE
{

    //
    // Reference Count - Interlocked access only
    //
    ULONG Ref;

    // 
    // Next Reassembly Structure
    //
    LIST_ENTRY ReassemblyListEntry;

    //
    // Tag - used for memory validatation
    //
    ULONG Tag;
    //
    // Receive Operation
    //
    BUS_OPERATION ReceiveOp;


    //
    // Dgl  - Datagram label. Unique for every reassembly structure gernerated by this local host
    //
    USHORT Dgl;

    //
    // Ether type of the reassembled packet . Populated in the first fragment
    //
    USHORT EtherType;
    //
    // pRemoteNode  -> RemoteNode + Dgl are unique for each reassembly structure
    //
    PREMOTE_NODE pRemoteNode;
    
    //
    // Flags pertaining to the reassembly
    //
    ULONG Flags;

    //
    // ExpectedFragmentOffset is computed by the LAST Fragment's Offset + 
    // length of fragment. Does not account for gaps in the reassembled packet.
    // 
    ULONG ExpectedFragmentOffset;   // Last is based on offset,  not time of indication

    //
    // Buffer Size - total length of the datagram being reassembled
    //
    ULONG BufferSize;

    //
    // Bytes Received So far
    //
    ULONG BytesRecvSoFar;

    //
    // Head NdisBuffer
    //
    PNDIS_BUFFER pHeadNdisBuffer;
    
    //
    // LastNdisBuffer that was appended to the packet 
    //
    PNDIS_BUFFER pTailNdisBuffer;

    //
    // Mdl chain Head - pointing to the actual indicated fragment
    //
    PMDL pHeadMdl;

    //
    //Mdl Chain Tail - pointing to the last Mdl in the list
    //  
    PMDL pTailMdl ;
    //
    // Packet that is being reassembled
    //
    PNDIS_PACKET pNdisPacket;

    //
    // NumOfFragmentsSoFar;
    //
    ULONG NumOfFragmentsSoFar; 
    
    //
    // Pointer to the head of the MDL chain that the 1394 bus
    // driver is indicating up. Will be used to return the buffers to 
    // the BusDriver
    //
    union
    {
        PADDRESS_FIFO pAddressFifo;
        PISOCH_DESCRIPTOR pIsochDescriptor;
        PVOID pCommon;
    } Head;

    //
    // Last -  Last Mdl that was appended to this packet in the reassembly structure
    //

    union 
    {
        PADDRESS_FIFO pAddressFifo;
        PISOCH_DESCRIPTOR pIsochDescriptor;
        PVOID pCommon;

    } Tail;

    //
    // Flag to signal if any out of order fragments were received. Default FALSE
    //
    BOOLEAN OutOfOrder;

    //
    // Flag to indicate if all fragments are completed . Default False
    //
    BOOLEAN fReassemblyComplete;

    //
    // Vc that this packet is being assembled for 
    //
    PVCCB pVc;

    //
    // MaxIndex in the Fragment Table. 
    // At all times, MaxOffset points to an first empty element in the array
    //
    ULONG MaxOffsetTableIndex;

    //
    // FragmentOffset Table
    //
    FRAGMENT_DESCRIPTOR FragTable[MAX_ALLOWED_FRAGMENTS]; 

    
} NDIS1394_REASSEMBLY_STRUCTURE, *PDIS1394_REASSEMBLY_STRUCTURE, *PPDIS1394_REASSEMBLY_STRUCTURE;


//
// This structure is local to each Isoch descriptor or fifo that is indicated up
// to the nic1394 miniport. It stores all the local information extracted
// from the GASP header and Isoch Header
//

typedef struct
{
    BUS_OPERATION   RecvOp;         // Fifo or Isoch Receive
    PDATA_FORMAT    p1394Data;      // Start of 1394 pkt
    ULONG           Length1394;     // Length of the 1394 data
    PVOID           pEncapHeader;   // Points to start of frag/defrag encap header
    ULONG           DataLength;     // length of the packet, from the EncapHeader
    BOOLEAN         fGasp;          // Has GASP header
    NDIS1394_UNFRAGMENTED_HEADER UnfragHeader; // Unfragmented header 
    NDIS1394_FRAGMENT_HEADER FragmentHeader;  // Fragment Header
    PGASP_HEADER    pGaspHeader;    // Gasp Header
    PVOID           pIndicatedData; // Data indicated up, includes the isoch header, unfrag headers
    PMDL            pMdl;
    //
    // Following information from the fragmented/unfragmented header...
    //
    BOOLEAN         fFragmented;    // Is fragmented
    BOOLEAN         fFirstFragment; // Is the First fragment
    ULONG           BufferSize;
    ULONG           FragmentOffset;
    USHORT          Dgl;            // Dgl 
    ULONG           lf;             // Lf - Fragmented or not
    ULONG           EtherType;      // Ethertype
    PNDIS_BUFFER    pNdisBuffer;    // Ndis buffer - used to indicate data up.
    PVOID           pNdisBufferData;   // Points to the start of the data that the Ndis Buffer points to  

    //
    // Sender specific information here
    //
    USHORT           SourceID;
    PREMOTE_NODE    pRemoteNode;

    //
    // Vc Specific Information here
    //
    PVCCB           pVc;
    PNIC_PACKET_POOL pPacketPool;

    //
    // Indication data
    //
    union
    {
        PADDRESS_FIFO       pFifoContext;
        PISOCH_DESCRIPTOR   pIsochContext;
        PVOID               pCommon; // to be used in the common code path

    }NdisPktContext;

} NIC_RECV_DATA_INFO, *PNIC_RECV_DATA_INFO;




//
// Fragment Header as defined in the IP/1394 spec. Each packet greater than the MaxPayload
// will be split up into fragments and this header will be attached.
//

#define FRAGMENT_HEADER_LF_UNFRAGMENTED 0
#define FRAGMENT_HEADER_LF_FIRST_FRAGMENT 1
#define FRAGMENT_HEADER_LF_LAST_FRAGMENT 2
#define FRAGMENT_HEADER_LF_INTERIOR_FRAGMENT 3


typedef struct _INDICATE_RSVD
{
    PNDIS_PACKET pPacket;
    PVCCB pVc;
    PADAPTERCB pAdapter;
    LIST_ENTRY   Link;
    ULONG   Tag;

} INDICATE_RSVD, *PINDICATE_RSVD;



typedef struct _RSVD
{
    
    UCHAR   Mandatory[PROTOCOL_RESERVED_SIZE_IN_PACKET]; // mandatory ndis requirement
    INDICATE_RSVD IndicateRsvd; // to be used as extra context

#ifdef USE_RECV_TIMER

    NDIS_MINIPORT_TIMER RcvIndicateTimer;  // Used as a timer for win9x. All rcv Indicates are done here

#endif  

} RSVD, *PRSVD;



//
// Used only in Win9x as a context for the send timer routine
//
typedef struct _NDIS_SEND_CONTEXT
{
    LIST_ENTRY Link;
    PVCCB pVc;
    

}NDIS_SEND_CONTEXT, *PNDIS_SEND_CONTEXT;


typedef struct _NDIS_STATUS_CONTEXT
{
    LIST_ENTRY                  Link;
    IN  NDIS_STATUS             GeneralStatus;
    IN  PVOID                   StatusBuffer;
    IN  UINT                    StatusBufferSize;


}NDIS_STATUS_CONTEXT, *PNDIS_STATUS_CONTEXT;



//
// This is the Irb structure used by the Bus Driver. 
// There is extra room allocated at the end for the miniport's Context
//

typedef struct _NDIS1394_IRB
{
    //
    // Original Irb used by the bus driver
    //
    IRB Irb;

    //
    // Adapter - local host -optional
    //
    PADAPTERCB pAdapter;

    //
    // remote node to which the Irp was sent - optional
    //
    PREMOTE_NODE pRemoteNode;

    //
    // VC for which the Irp was sent. - optional 
    //
    PVCCB pVc;

    //
    // Context if any - optinal 
    //
    PVOID Context;


}NDIS1394_IRB, *PNDIS1394_IRB;




#pragma pack (push, 1)


typedef ULONG IP_ADDRESS;

//* Structure of an Ethernet header (taken from ip\arpdef.h).
typedef struct  ENetHeader {
    ENetAddr    eh_daddr;
    ENetAddr    eh_saddr;
    USHORT      eh_type;
} ENetHeader;



// Structure of an Ethernet ARP packet.
//
typedef struct {
    ENetHeader  header;
    USHORT      hardware_type; 
    USHORT      protocol_type;
    UCHAR       hw_addr_len;
    UCHAR       IP_addr_len; 
    USHORT      opcode;                  // Opcode.
    ENetAddr    sender_hw_address;
    IP_ADDRESS  sender_IP_address;
    ENetAddr    target_hw_address;
    IP_ADDRESS  target_IP_address;

} ETH_ARP_PKT, *PETH_ARP_PKT;



#pragma pack (pop)

// These are ethernet arp specific  constants
//
#define ARP_ETH_ETYPE_IP    0x800
#define ARP_ETH_ETYPE_ARP   0x806
#define ARP_ETH_REQUEST     1
#define ARP_ETH_RESPONSE    2
#define ARP_ETH_HW_ENET     1
#define ARP_ETH_HW_802      6

typedef enum _ARP_ACTION {

    LoadArp = 1,
    UnloadArp ,
    UnloadArpNoRequest,
    BindArp
}ARP_ACTION , *PARP_ACTION; 


typedef struct _ARP_INFO{
    //
    // List entry to handle serialization of requests to ARP
    // 

    LIST_ENTRY Link;

    //
    // Action to be done by the Arp module
    //
    ARP_ACTION Action;

    //
    // Request to be compeleted - optional
    //
    PNDIS_REQUEST pRequest;

} ARP_INFO, *PARP_INFO;



//-----------------------------------------------------------------------------
// Macros/inlines
//-----------------------------------------------------------------------------

// These basics are not in the DDK headers for some reason.
//
#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#define InsertBefore( pNewL, pL )    \
{                                    \
    (pNewL)->Flink = (pL);           \
    (pNewL)->Blink = (pL)->Blink;    \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

#define InsertAfter( pNewL, pL )     \
{                                    \
    (pNewL)->Flink = (pL)->Flink;    \
    (pNewL)->Blink = (pL);           \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}


// Winsock-ish host/network byte order converters for short and long integers.
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)

// Place in a TRACE argument list to correspond with a format of "%d.%d.%d.%d"
// to print network byte-ordered IP address 'x' in human readable form.
//
#define IPADDRTRACE( x ) ((x) & 0x000000FF),         \
                         (((x) >> 8) & 0x000000FF),  \
                         (((x) >> 16) & 0x000000FF), \
                         (((x) >> 24) & 0x000000FF)

// Place in a TRACE argument list to correspond with a format of "%d" to print
// a percentage of two integers, or an average of two integers, or those
// values rounded.
//
#define PCTTRACE( n, d ) ((d) ? (((n) * 100) / (d)) : 0)
#define AVGTRACE( t, c ) ((c) ? ((t) / (c)) : 0)
#define PCTRNDTRACE( n, d ) ((d) ? (((((n) * 1000) / (d)) + 5) / 10) : 0)
#define AVGRNDTRACE( t, c ) ((c) ? (((((t) * 10) / (c)) + 5) / 10) : 0)

// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.  The
// stash-area is a ULONGLONG so that all allocated blocks remain ULONGLONG
// aligned as they would be otherwise, preventing problems on Alphas.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = ulTag;
    return (pBuf + MEMORY_ALLOCATION_ALIGNMENT);
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}

#define ALLOC_NDIS_WORK_ITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistWorkItems )
#define FREE_NDIS_WORK_ITEM( pA, pNwi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistWorkItems, (pNwi) )

#define ALLOC_TIMERQITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistTimerQItems )
#define FREE_TIMERQITEM( pA, pTqi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistTimerQItems, (pTqi) )

#define ALLOC_TUNNELCB( pA ) \
    ALLOC_NONPAGED( sizeof(TUNNELCB), MTAG_TUNNELCB )
#define FREE_TUNNELCB( pA, pT ) \
    FREE_NONPAGED( pT )

#define ALLOC_VCCB( pA ) \
    ALLOC_NONPAGED( sizeof(VCCB), MTAG_VCCB )
#define FREE_VCCB( pA, pV ) \
    FREE_NONPAGED( pV )

#define ALLOC_TIMERQ( pA ) \
    ALLOC_NONPAGED( sizeof(TIMERQ), MTAG_TIMERQ )
#define FREE_TIMERQ( pA, pTq ) \
    FREE_NONPAGED( pTq )

//
// Log packet macro
//
#ifdef PKT_LOG

#define NIC1394_ALLOC_PKTLOG(_pAdapter)                                     \
            nic1394AllocPktLog(_pAdapter)

#define NIC1394_DEALLOC_PKTLOG(_pAdapter)                                       \
            Nic1394DeallocPktLog(_pAdapter)

#define NIC1394_LOG_PKT(_pAdapter, _Flags, _SourceID, _DestID, _pvData, _cbData)\
                    (((_pAdapter)->pPktLog) ?                                   \
                        Nic1394LogPkt(                                          \
                                (_pAdapter)->pPktLog,                           \
                                (_Flags),                                       \
                                (_SourceID),                                    \
                                (_DestID),                                      \
                                (_pvData),                                      \
                                (_cbData)                                       \
                                )                                               \
                    : 0)
#else

#define NIC1394_ALLOC_PKTLOG(_pAdapter)                                     
#define NIC1394_DEALLOC_PKTLOG(_pAdapter)                                   
#define NIC1394_LOG_PKT(_pAdapter, _Flags, _SourceID, _DestID, _pvData, _cbData)

#endif

#define NIC1394_LOGFLAGS_RECV_CHANNEL               0x00000001
#define NIC1394_LOGFLAGS_SEND_FIFO                  0x00000010
#define NIC1394_LOGFLAGS_SEND_CHANNEL               0x00000011
#define NIC1394_LOGFLAGS_RECV_FIFO                  0x00000100
#define NIC1394_LOGFLAGS_BCM_FAILED                 0x00001000
#define NIC1394_LOGFLAGS_BCM_IS_IRM_TIMEOUT         0x00002000
#define NIC1394_LOGFLAGS_BCM_NOT_IRM_TIMEOUT        0x00004000
#define NIC1394_LOGFLAGS_BCM_IRM_NOT_FOUND          0x00008000

#if 0 
//
// To get the MaxRec we extract the 0xf000 nibble
//
#define GET_MAXREC_FROM_BUSCAPS(_pBus, _pMaxRec)        \ 
{                                                       \
    ULONG _LitEnd = SWAPBYTES_ULONG(_pBus);             \
    _LitEnd = _LitEnd & 0xf000;                         \
    _LitEnd = _LitEnd >>  12;                           \
    *(_pBusRec) = _LitEnd;                              \
}
#endif

//
// To get the MaxRec we extract the 0xf000 nibble
//
#define GET_MAXREC_FROM_BUSCAPS(_Bus)       (((_Bus) & 0xf00000) >> 20); 


//-----------------------------------------------------------------------------
//    F L A G S   &   L O C K S              
//-----------------------------------------------------------------------------



//
// These macros are just present to make accessing the VC's flags easier 
// and concentrate the implementations at one place
//
#define VC_TEST_FLAG(_V, _F)                ((nicReadFlags(&(_V)->Hdr.ulFlags) & (_F))!= 0)
#define VC_SET_FLAG(_V, _F)                 (nicSetFlags(&(_V)->Hdr.ulFlags, (_F)))
#define VC_CLEAR_FLAGS(_V, _F)              (nicClearFlags(&(_V)->Hdr.ulFlags , (_F)))
#define VC_TEST_FLAGS(_V, _F)               ((nicReadFlags(&(_V)->Hdr.ulFlags) & (_F)) == (_F))
#define VC_READ_FLAGS(_V)                   ((nicReadFlags(&(_V)->Hdr.ulFlags) 
#define VC_ACTIVE(_V)                       (((_V)->Hdr.ulFlags & (VCBF_CloseCallPending | VCBF_VcDeleted | VCBF_VcActivated |VCBF_MakeCallPending )) == VCBF_VcActivated)



#define REMOTE_NODE_TEST_FLAG(_P, _F    )           ((nicReadFlags(&(_P)->ulFlags) & (_F))!= 0)
#define REMOTE_NODE_SET_FLAG(_P, _F)                (nicSetFlags(&(_P)->ulFlags, (_F)))
#define REMOTE_NODE_CLEAR_FLAGS(_P, _F)             (nicClearFlags(&(_P)->ulFlags , (_F)))
#define REMOTE_NODE_TEST_FLAGS(_P, _F)              ((nicReadFlags(&(_P)->ulFlags) & (_F)) == (_F))
#define REMOTE_NODE_READ_FLAGS(_P)                  ((nicReadFlags(&(_P)->ulFlags) 
#define REMOTE_NODE_ACTIVE(_P)                      (((_P)->ulFlags & (PDO_Activated | PDO_BeingRemoved)) == PDO_Activated)

#define ADAPTER_TEST_FLAG(_A, _F)               ((nicReadFlags(&(_A)->ulFlags) & (_F))!= 0)
#define ADAPTER_SET_FLAG(_A, _F)                (nicSetFlags(&(_A)->ulFlags, (_F)))
#define ADAPTER_CLEAR_FLAG(_A, _F)              (nicClearFlags(&(_A)->ulFlags , (_F)))
#define ADAPTER_TEST_FLAGS(_A, _F)              ((nicReadFlags(&(_A)->ulFlags) & (_F)) == (_F))
#define ADAPTER_READ_FLAGS(_A)                  ((nicReadFlags(&(_A)->ulFlags) 
#define ADAPTER_ACTIVE(_A)                      ((((_A)->ulFlags) & fADAPTER_VDOInactive) != fADAPTER_VDOInactive)

#define BCR_TEST_FLAG(_A, _F)               ((nicReadFlags(&(_A)->BCRData.Flags) & (_F))!= 0)
#define BCR_SET_FLAG(_A, _F)                (nicSetFlags(&(_A)->BCRData.Flags, (_F)))
#define BCR_CLEAR_FLAG(_A, _F)              (nicClearFlags(&(_A)->BCRData.Flags , (_F)))
#define BCR_CLEAR_ALL_FLAGS(_A)            ((_A)->BCRData.Flags = 0) 
#define BCR_TEST_FLAGS(_A, _F)              ((nicReadFlags(&(_A)->BCRData.Flags) & (_F)) != 0)
#define BCR_READ_FLAGS(_A)                  ((nicReadFlags(&(_A)->BCRData.Flags) 
#define BCR_IS_VALID(_B)                    ((_B)->NC_One == 1 && (_B)->NC_Valid ==1)
#define IS_A_BCR(_B)                        ((_B)->NC_One == 1 )

#define LOOKASIDE_HEADER_SET_FLAG(_H, _F)       (nicSetFlags(&(_H)->State.u.Flags, (_F)))
#define LOOKASIDE_HEADER_TEST_FLAG(_H, _F)      ((nicReadFlags(&(_H)->State.u.Flags) & (_F))!= 0)
    
#define REASSEMBLY_ACTIVE(_R)               (((_R)->Flags & (REASSEMBLY_ABORTED | REASSEMBLY_FREED)) == 0)
#define REASSEMBLY_TEST_FLAG(_R,_F)         ((nicReadFlags(&(_R)->Flags) & (_F))!= 0)
#define REASSEMBLY_SET_FLAG(_R,_F)          (nicSetFlags(&(_R)->Flags, (_F)))
#define REASSEMBLY_CLEAR_FLAG(_R,_F)        (nicClearFlags(&(_R)->Flags , (_F)))


#define NIC_GET_SYSTEM_ADDRESS_FOR_MDL(_M) MmGetSystemAddressForMdl(_M)
#define NIC_GET_BYTE_COUNT_FOR_MDL(_M) MmGetMdlByteCount(_M)

#define nicNdisBufferVirtualAddress(_N)     NdisBufferVirtualAddress(_N)
#define nicNdisBufferLength(_N)             NdisBufferLength(_N)

//
// These macros are used to assert that the IRQL level remains the same
// at the beginning and end of a function
//
#if DBG

#define STORE_CURRENT_IRQL                  UCHAR OldIrql = KeGetCurrentIrql();
#define MATCH_IRQL                          ASSERT (OldIrql == KeGetCurrentIrql() ); 

#else

#define STORE_CURRENT_IRQL                  
#define MATCH_IRQL                          
#endif // if DBG

//
// Macros used to access the Reference Structure (not used yet)
//
#define NIC_INCREMENT_REF (_R)              nicReferenceRef (_R);
#define NIC_DEREFERENCE_REF (_R)            nicDereferenceRef (_R)


#define nicInitializeCallRef(_pV)           nicInitializeRef (&(_pV)->Hdr.CallRef);
#define nicCloseCallRef(_pV)                nicCloseRef (&(_pV)->Hdr.CallRef);



//
// Macros used to acquire and release lock by the data structures (Vc, AF, Adapter)
// Right now, they all point to the same lock (i.e.) the lock in the Adapter structure
//

#define VC_ACQUIRE_LOCK(_pVc)               NdisAcquireSpinLock (_pVc->Hdr.plock);
#define VC_RELEASE_LOCK(_pVc)               NdisReleaseSpinLock (_pVc->Hdr.plock);

#define AF_ACQUIRE_LOCK(_pAF)               NdisAcquireSpinLock (&_pAF->pAdapter->lock);
#define AF_RELEASE_LOCK(_pAF)               NdisReleaseSpinLock (&_pAF->pAdapter->lock);

#define ADAPTER_ACQUIRE_LOCK(_pA)           NdisAcquireSpinLock (&_pA->lock);
#define ADAPTER_RELEASE_LOCK(_pA)           NdisReleaseSpinLock (&_pA->lock);

#define REMOTE_NODE_ACQUIRE_LOCK(_pP)       NdisAcquireSpinLock (&_pP->pAdapter->lock);
#define REMOTE_NODE_RELEASE_LOCK(_pP)       NdisReleaseSpinLock (&_pP->pAdapter->lock);

#define REASSEMBLY_ACQUIRE_LOCK(_R)         REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK(_R->pRemoteNode);
#define REASSEMBLY_RELEASE_LOCK(_R)         REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(_R->pRemoteNode);

#ifdef TRACK_LOCKS


#define REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK(_Remote)                                    \
    nicAcquireSpinLock (&_Remote->ReassemblyLock , __FILE__ , __LINE__);


#define REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(_Remote)                                                \
    nicReleaseSpinLock (&_Remote->ReassemblyLock , __FILE__ , __LINE__);




#else

#define REMOTE_NODE_REASSEMBLY_ACQUIRE_LOCK(_Remote)        NdisAcquireSpinLock (&_Remote->ReassemblyLock.NdisLock);
#define REMOTE_NODE_REASSEMBLY_RELEASE_LOCK(_Remote)        NdisReleaseSpinLock (&_Remote->ReassemblyLock.NdisLock);
  
#endif


#define REASSEMBLY_APPEND_FRAG_DESC(_pR, _Off, _Len)                        \
    _pR->FragTable[_pR->MaxOffsetTableIndex].Offset =_Off;                  \
    _pR->FragTable[_pR->MaxOffsetTableIndex].IPLength  = _Len;              \
    _pR->MaxOffsetTableIndex++;


//-----------------------------------------------------------------------------
//           S T A T S   &    F A I L U R E    M A C R O S 
//-----------------------------------------------------------------------------


// Used to distinguish stats collected that are collected in the various code paths

typedef enum 
{
    ChannelCodePath,
    FifoCodePath,
    ReceiveCodePath,
    NoMoreCodePaths
};


#if TRACK_FAILURE

extern ULONG            BusFailure;
extern ULONG            MallocFailure;
extern ULONG            IsochOverwrite;
extern ULONG            MaxIndicatedFifos;

#define nicInitTrackFailure()           BusFailure = 0;MallocFailure= 0;

#define nicIncrementBusFailure()        NdisInterlockedIncrement(&BusFailure);
#define nicIncrementMallocFailure()     NdisInterlockedIncrement(&MallocFailure);
#define nicIsochOverwritten()           NdisInterlockedIncrement(&IsochOverwrite);

#define  nicStatsRecordNumIndicatedFifos(_Num)                      \
        {                                                           \
            ULONG _N_ = (_Num);                                     \
            ASSERT((_N_) <= 100);                                   \
            MaxIndicatedFifos = max((_N_), MaxIndicatedFifos);      \
        }

#define nicIncChannelSendMdl()     NdisInterlockedIncrement(&MdlsAllocated[ChannelCodePath]);
#define nicIncFifoSendMdl()         NdisInterlockedIncrement(&MdlsAllocated[FifoCodePath]);

#define nicDecChannelSendMdl()     NdisInterlockedIncrement(&MdlsFreed[ChannelCodePath]);
#define nicDecFifoSendMdl()         NdisInterlockedIncrement(&MdlsFreed[FifoCodePath]);

#define nicIncChannelRecvBuffer()     NdisInterlockedIncrement(&NdisBufferAllocated[ChannelCodePath]);
#define nicIncFifoRecvBuffer()         NdisInterlockedIncrement(&NdisBufferAllocated[FifoCodePath]);

#define nicDecChannelRecvBuffer()     NdisInterlockedIncrement(&NdisBufferFreed[ChannelCodePath]);
#define nicDecFifoRecvBuffer()         NdisInterlockedIncrement(&NdisBufferFreed[FifoCodePath]);


#define nicIncRecvBuffer(_bisFifo)    \
{                               \
    if (_bisFifo)               \
    {    nicIncFifoRecvBuffer(); }    \
        else                    \
    {    nicIncChannelRecvBuffer();} \
}

#define nicDecRecvBuffer(_bisFifo)    \
{                               \
    if (_bisFifo)               \
     {   nicDecFifoRecvBuffer();  }   \
    else                    \
     {   nicDecChannelRecvBuffer(); }\
}
        
       
#else

#define nicInitTrackFailure()           
#define nicIncrementBusFailure()        
#define nicIncrementMallocFailure()     
#define nicIsochOverwritten()           
#define  nicStatsRecordNumIndicatedFifos(_Num)                      
#define nicIncChannelSendMdl()     
#define nicIncFifoSendMdl()         
#define nicDecChannelSendMdl()     
#define nicDecFifoSendMdl()         
#define nicFreeMdlRecordStat()

#endif


#if  QUEUED_PACKETS_STATS


extern ULONG            RcvTimerCount;
extern ULONG            SendTimerCount;

#define nicInitQueueStats()                                     \
        NdisZeroMemory (&SendStats, sizeof(SendStats) );        \
        NdisZeroMemory (&RcvStats, sizeof(RcvStats) );          \
        nicMaxRcv = 0;                                          \
        nicMaxSend = 0;


#define nicSetCountInHistogram(_PktsInQueue, _Stats)    NdisInterlockedIncrement (&(_Stats.Bucket [ (_PktsInQueue/10) ] ) );
#define nicIncrementRcvTimerCount()                     NdisInterlockedIncrement(&RcvTimerCount);
#define nicIncrementSendTimerCount()                    NdisInterlockedIncrement(&SendTimerCount);
#define nicSetMax(_nicMax, _PktsInQueue)                _nicMax  = max(_nicMax, _PktsInQueue);






#else

#define nicInitQueueStats()
#define nicSetCountInHistogram(_PktsInQueue, _Stats)    
#define nicSetMax(_nicMax, _PktsInQueue)                
#define nicIncrementRcvTimerCount()
#define nicIncrementSendTimerCount()

#endif
//
// Isoch descriptor macros - Used in the send/recv code path
//
typedef enum 
{
    IsochNext,
    IsochTag,
    IsochChannelVc,
    MaxIsochContextIndex
    
} IsochContextIndex;

//
// The following structure is used to add more contexts to a work item.
// NOTE: the Adapter is passed in as the context always.
//
typedef  union _NIC_WORK_ITEM
{
    NDIS_WORK_ITEM NdisWorkItem;

    struct{
        NDIS_WORK_ITEM NdisWorkItem;
        PNDIS_REQUEST pNdisRequest;
        VCCB* pVc;
    } RequestInfo;

    struct{
        NDIS_WORK_ITEM NdisWorkItem;
        ULONG Start;
        PNDIS_REQUEST pNdisRequest;
    } StartArpInfo;


    struct {
        NDIS_WORK_ITEM NdisWorkItem;
    } Fifo;

} NIC_WORK_ITEM, *PNIC_WORK_ITEM;

#define STORE_CHANNELVC_IN_DESCRIPTOR(_pI,_pVc)     (_pI)->DeviceReserved[IsochChannelVc]  =(ULONG_PTR) _pVc
#define GET_CHANNELVC_FROM_DESCRIPTOR(_pI) (_pI)->DeviceReserved[IsochChannelVc]  

#define MARK_ISOCH_DESCRIPTOR_INDICATED(_pI)                                        \
    (_pI)->DeviceReserved[IsochTag]  = (ULONG)NIC1394_TAG_INDICATED;                \
    (_pI)->DeviceReserved[IsochNext]  = 0;


#define MARK_ISOCH_DESCRIPTOR_IN_REASSEMBLY(_pI)                                    \
    (_pI)->DeviceReserved[IsochTag]  = (ULONG)NIC1394_TAG_REASSEMBLY;               

#define CLEAR_DESCRIPTOR_OF_NDIS_TAG(_pI)                                           \
    (_pI)->DeviceReserved[IsochTag] = 0;


#define APPEND_ISOCH_DESCRIPTOR(_Old, _New)                                         \
    (_Old)->DeviceReserved[IsochNext]  = (ULONG_PTR)&((_New)->DeviceReserved[IsochNext]);


#define NEXT_ISOCH_DESCRIPTOR(_pI) (_pI)->DeviceReserved[IsochNext]


#define CLEAR_DESCRIPTOR_NEXT(_pI) (_pI)->DeviceReserved[IsochNext] = 0;

#define GET_MDL_FROM_IRB(_pM, _pI, _Op)                                             \
    if (_Op==AsyncWrite)                                                            \
    {                                                                               \
        _pM = _pI->u.AsyncWrite.Mdl;                                                \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        ASSERT (_Op == AsyncStream);                                                \
        _pM = _pI->u.AsyncStream.Mdl ;                                              \
    }               
    
//
// Macros used to walk a doubly linked list. Only macros that are not defined in ndis.h
// The List Next macro will work on Single and Doubly linked list as Flink is a common
// field name in both
//

/*
PLIST_ENTRY 
ListNext (
    IN PLIST_ENTRY 
    );
    
PSINGLE_LIST_ENTRY 
ListNext (
    IN PSINGLE_LIST_ENTRY 
    );
*/
#define ListNext(_pL)                       (_pL)->Flink

/*
PLIST_ENTRY
ListPrev (
    IN LIST_ENTRY *
    );
*/        
#define ListPrev(_pL)                       (_pL)->Blink

#define OnlyElementInList(_pL)               (_pL->Flink == _pL->Blink ? TRUE : FALSE)

#define BREAK(_TM_Mode, _String)                        \
{                                                       \
        TRACE( TL_A, _TM_Mode, ( _String ) );           \
        break;                                          \
}                       



// USHORT
// SWAPBYTES_USHORT(USHORT  Val )
//
#define SWAPBYTES_USHORT(Val)   \
                ((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))


// ULONG
// SWAPBYTES_ULONG(ULONG    Val )
//

#define SWAPBYTES_ULONG(Val)    \
                ((((Val) & 0x000000ff) << 24)   |   \
                 (((Val) & 0x0000ff00) << 8)    |   \
                 (((Val) & 0x00ff0000) >> 8)    |   \
                 (((Val) & 0xff000000) >> 24) )



//
// nicRemoveEntry List
// Just add a check to make sure that we are actually pointing to a valid next
//
#define nicRemoveEntryList(_L)                  \
{                                               \
    ASSERT ((_L)->Flink != (_L));               \
    RemoveEntryList (_L);                       \
}
//#define nicFreeToNPagedLookasideList(_L, _E) NdisFreeToNPagedLookasideList(_L, _E)        
//#define nicDeleteLookasideList(_L) NdisDeleteNPagedLookasideList(_L)

//
// Timing Query Routines
//
#define nicQueryTickCount()                     \
    LARGE_INTEGER   TickStart;                  \
    KeQueryTickCount(&TickStart);   

#define nicPrintElapsedTicks(_s)                                                        \
{                                                                                       \
    LARGE_INTEGER       TickEnd, TickDiff;                                              \
    ULONG Increment = KeQueryTimeIncrement() ;                                          \
    KeQueryTickCount(&TickEnd);                                                         \
    TickDiff.QuadPart = TickEnd.QuadPart - TickStart.QuadPart;                          \
    TickDiff.QuadPart =  (TickDiff.QuadPart  * Increment);                              \
    DbgPrint (_s);                                                                      \
    DbgPrint("  TickStart %x %x, Time End %x %x Time Diff %x %x Increment %x\n",TickStart.HighPart , TickStart.LowPart , TickEnd.HighPart, TickEnd.LowPart, TickDiff.HighPart, TickDiff.LowPart, Increment);     \
}


#define nicEntryTimeStamp()                                 \
    UINT EntryMilliSec;                                     \
    EntryMilliSec= nicGetSystemTimeMilliSeconds();      
    



#if DO_TIMESTAMPS

void
nicTimeStamp(
    char *szFormatString,
    UINT Val
    );
    
#define  TIMESTAMP(_FormatString)           nicTimeStamp("TIMESTAMP %lu:%lu.%lu nic1394 " _FormatString "\n" , 0)
#define  TIMESTAMP1(_FormatString, _Val)        nicTimeStamp( "TIMESTAMP %lu:%lu.%lu ARP1394 " _FormatString  "\n" , (_Val))



#else // !DO_TIMESTAMPS


#define  TIMESTAMP(_FormatString)
#define  TIMESTAMP1(_FormatString, _Val)

#endif // !DO_TIMESTAMPS


#if ENTRY_EXIT_TIME 

#define TIMESTAMP_ENTRY(_String)            TIMESTAMP(_String)
#define TIMESTAMP_EXIT(_String)             TIMESTAMP(_String)

#else

#define TIMESTAMP_ENTRY(s);
#define TIMESTAMP_EXIT(s);

#endif


#if INIT_HALT_TIME

#define TIMESTAMP_INITIALIZE()   TIMESTAMP("==>InitializeHandler");
#define TIMESTAMP_HALT()       TIMESTAMP("<==Halt");

#else

#define TIMESTAMP_INITIALIZE()
#define TIMESTAMP_HALT()


#endif

//-----------------------------------------------------------------------------
//              S T A T I S T I C    M A C R O S
//-----------------------------------------------------------------------------


//
// Reasembly counts
//
#define nicReassemblyStarted(_pAdapter)     \
{                                       \
    NdisInterlockedIncrement( &(_pAdapter->AdaptStats.TempStats.ulNumOutstandingReassemblies)); \
    NdisInterlockedIncrement ( &(_pAdapter->Reassembly.PktsInQueue)); \
    NdisInterlockedIncrement ( &(_pAdapter->OutstandingReassemblies));\
}


#define nicReassemblyCompleted(_A)      \
{                                       \
    NdisInterlockedDecrement(&(_A->AdaptStats.TempStats.ulNumOutstandingReassemblies));\
    NdisInterlockedDecrement(&(_A->Reassembly.PktsInQueue));\
    NdisInterlockedDecrement ( &(_A->OutstandingReassemblies));\
}


#define nicReassemblyAborted(_A)    \
{                                   \
    NdisInterlockedDecrement ( &(_A->OutstandingReassemblies));     \
    NdisInterlockedIncrement (&(_A->AdaptStats.TempStats.ulAbortedReassemblies)); \
}


// 
//  Top level stat collection macros
//

#define nicIncrementRcvVcPktCount(_Vc, _Pkt)        \
{                                                   \
    if ((_Vc)->Hdr.VcType == NIC1394_RecvFIFO)      \
    {                                               \
        nicIncrementFifoRcvPktCount(_Vc, _Pkt);     \
    }                                               \
    else                                            \
    {                                               \
        nicIncrementChannelRcvPktCount(_Vc, _Pkt);  \
    }                                               \
}

#define nicIncrementVcSendPktCount(_Vc, _Pkt)       \
{                                                   \
    if ((_Vc)->Hdr.VcType == NIC1394_SendFIFO)      \
    {                                               \
        nicIncrementFifoSendPktCount(_Vc, _Pkt);    \
    }                                               \
    else                                            \
    {                                               \
        nicIncrementChannelSendPktCount(_Vc, _Pkt); \
    }                                               \
}


#define nicIncrementVcSendFailures(_Vc, _Pkt)       \
{                                                   \
    if ((_Vc)->Hdr.VcType == NIC1394_SendFIFO)      \
    {                                               \
        nicIncrementFifoSendFailures(_Vc, _Pkt);    \
    }                                               \
    else                                            \
    {                                               \
        nicIncrementChannelSendFailures(_Vc, _Pkt); \
    }                                               \
}


#define nicIncrementVcBusSendFailures(_Vc, _Pkt)        \
{                                                       \
    if ((_Vc)->Hdr.VcType == NIC1394_SendFIFO)          \
    {                                                   \
        nicIncrementFifoBusSendFailures(_Vc, _Pkt);     \
    }                                                   \
    else                                                \
    {                                                   \
        nicIncrementChannelBusSendFailures(_Vc, _Pkt);  \
    }                                                   \
}

#define nicIncrementVcBusSendSucess(_Vc, _Pkt)          \
{                                                       \
    if ((_Vc)->Hdr.VcType == NIC1394_SendFIFO)          \
    {                                                   \
        nicIncrementFifoBusSendSucess(_Vc, _Pkt);       \
    }                                                   \
    else                                                \
    {                                                   \
        nicIncrementChannelBusSendSucess(_Vc, _Pkt);    \
    }                                                   \
}




//
// Fifo counts
//
#define nicIncrementFifoSendPktCount(_Vc, _Pkt)         NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulSendNicSucess));
#define nicIncrementFifoSendFailures(_Vc, _Pkt)         NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulSendNicFail));
#define nicIncrementFifoBusSendFailures(_Vc,_Pkt)               NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulSendBusFail));
#define nicIncrementFifoBusSendSucess(_Vc,_Pkt)                 NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulSendBusSuccess));
#define nicIncrementFifoRcvPktCount(_Vc, _Pkt)              NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Fifo.ulRecv));

//
// Channel Counts
//
#define nicIncrementChannelSendPktCount(_Vc, _Pkt)      NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulSendNicSucess));
#define nicIncrementChannelSendFailures(_Vc, _Pkt)      NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulSendNicFail));
#define nicIncrementChannelBusSendFailures(_Vc,_Pkt)                NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulSendBusFail));
#define nicIncrementChannelBusSendSucess(_Vc, _Pkt)             NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulSendBusSuccess));
#define nicIncrementChannelRcvPktCount(_Vc, _Pkt)           NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.Channel.ulRecv));



//
// Generic counts
//

#define nicIncrementSendCompletes(_Vc)  NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.ulNumSendsCompleted   )); \
                                NdisInterlockedIncrement(&NicSendCompletes);

#define nicIncrementSends(_Vc)  NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.ulNumSends)); \
                                NdisInterlockedIncrement (&NicSends);


#define nicIncrementBusSends(_Vc)  NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.ulNumBusSends)); \
                                   NdisInterlockedIncrement (&BusSends);


#define nicIncrementBusSendCompletes(_Vc)  NdisInterlockedIncrement(&((_Vc)->Hdr.pAF->pAdapter->AdaptStats.TempStats.ulNumBusSendsCompleted )); \
                                NdisInterlockedIncrement(&BusSendCompletes);


#if FIFO_WRAPPER

#define nicSetTagInFifoWrapper(_pF, _Tag)           \
{                                                   \
    ((PADDRESS_FIFO_WRAPPER)(_pF))->Tag = _Tag;     \
                                                    \
}                                               
#else

#define nicSetTagInFifoWrapper(_pF, _Tag)               

#endif

//-----------------------------------------------------------------------------
//                  N I C   E R R O R    C O D E S 
//-----------------------------------------------------------------------------
#define NIC_ERROR_CODE_INVALID_UNIQUE_ID_0          0xbad0000
#define NIC_ERROR_CODE_INVALID_UNIQUE_ID_FF         0xbadffff



//-----------------------------------------------------------------------------
//           R E M O T E    N O D E    F U N C T I O N S
//-----------------------------------------------------------------------------



#if 0
VOID
NicMpNotifyHandler(
    IN  PDEVICE_OBJECT              RemoteNodePhysicalDeviceObject,
    IN  PDEVICE_OBJECT              LocalHostPhysicalDeviceObject,
    IN  ULONG                       UniqueId0,
    IN  ULONG                       UniqueId1,
    IN  NDIS1394ENUM_NOTIFY_CODE    NotificationCode
    );
#endif



NDIS_STATUS
NicInitializeRemoteNode(
    OUT REMOTE_NODE **ppRemoteNode,
    IN   PDEVICE_OBJECT p1394DeviceObject,
    IN   UINT64 UniqueId 
    );

NTSTATUS
nicAddRemoteNode(
    IN  PVOID                   Nic1394AdapterContext,          // Nic1394 handle for the local host adapter 
    IN  PVOID                   Enum1394NodeHandle,             // Enum1394 handle for the remote node      
    IN  PDEVICE_OBJECT          RemoteNodePhysicalDeviceObject, // physical device object for the remote node
    IN  ULONG                   UniqueId0,                      // unique ID Low for the remote node
    IN  ULONG                   UniqueId1,                      // unique ID High for the remote node
    OUT PVOID *                 pNic1394NodeContext             // Nic1394 context for the remote node
    );

NTSTATUS
nicRemoveRemoteNode(
    IN  PVOID                   Nic1394NodeContext      // Nic1394 context for the remote node
    );


NDIS_STATUS
nicFindRemoteNodeFromAdapter( 
    IN PADAPTERCB pAdapter,
    IN PDEVICE_OBJECT pRemotePdo,
    IN UINT64 UniqueId,
    IN OUT REMOTE_NODE ** ppRemoteNode
    );


NDIS_STATUS
nicGetLocalHostPdoBlock (
    IN PVCCB pVc,
    IN OUT REMOTE_NODE **ppRemoteNode
    );





NDIS_STATUS
nicRemoteNodeRemoveVcCleanUp (
    IN PREMOTE_NODE pRemoteNode
    );


UINT
nicNumOfActiveRemoteNodes(
    IN PADAPTERCB pAdapter 
    );


BOOLEAN
nicReferenceRemoteNode (
    IN REMOTE_NODE *pRemoteNode,
    IN PCHAR pDebugPrint
    );


BOOLEAN
nicDereferenceRemoteNode (
    IN REMOTE_NODE *pRemoteNode,
    IN CHAR DebugPrint[50]
    );


VOID
nicInitalizeRefRemoteNode(
    IN REMOTE_NODE *pRemoteNode
    );


BOOLEAN
nicCloseRefRemoteNode(
    IN REMOTE_NODE *pRemoteNode
    );
    

//-----------------------------------------------------------------------------
//          U T I L I T Y       F U N C T I O N S 
//-----------------------------------------------------------------------------

VOID
nicCallCleanUp(
    IN VCCB* pVc
    );


VOID
nicClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask
    );

BOOLEAN
nicCloseRef(
    IN PREF RefP
   );


VOID
nicReferenceAdapter(
    IN ADAPTERCB* pAdapter ,
    IN PCHAR pDebugPrint
    );

BOOLEAN
nicDereferenceCall(
    IN VCCB* pVc,
    IN PCHAR pDebugPrint
    );


BOOLEAN
nicDereferenceRef(
    IN PREF RefP
    );

VOID
nicDereferenceAdapter(
    IN PADAPTERCB pAdapter, 
    IN PCHAR pDebugPrint
    );



VOID
nicDereferenceVc(
    IN VCCB* pVc
    );




NDIS_STATUS
nicExecuteWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext,
    IN ULONG ulArg1,
    IN ULONG ulArg2,
    IN ULONG ulArg3,
    IN ULONG ulArg4
    );


VOID
nicInitializeRef(
    IN PREF  RefP
        );


ULONG
nicReadFlags(
    IN ULONG* pulFlags
    );


VOID
nicReferenceAdapter(
    IN ADAPTERCB* pAdapter,
    IN PCHAR pDebugPrint
    );
    

BOOLEAN
nicReferenceCall(
    IN VCCB* pVc,
    IN PCHAR pDebugPrint
    );

    
BOOLEAN
nicReferenceRef(
    IN  PREF RefP
    );

VOID
nicReferenceVc(
    IN VCCB* pVc
    );

NDIS_STATUS
nicScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext
    );


VOID
nicSetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask
    );

CHAR*
nicStrDup(
    IN CHAR* psz
    );

CHAR*
nicStrDupNdisString(
    IN NDIS_STRING* pNdisString
    );

CHAR*
nicStrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra
    );

VOID
nicUpdateGlobalCallStats(
    IN VCCB *pVc
    );

NDIS_STATUS
NtStatusToNdisStatus (
    NTSTATUS NtStatus 
    );


VOID
PrintNdisPacket (
    ULONG TM_Comp,
    PNDIS_PACKET pMyPacket
    );





VOID
nicAllocatePacket(
    OUT PNDIS_STATUS pNdisStatus,
    OUT PNDIS_PACKET *ppNdisPacket,
    IN PNIC_PACKET_POOL pPacketPool
    );


VOID
nicFreePacket(
    IN PNDIS_PACKET pNdisPacket,
    IN PNIC_PACKET_POOL pPacketPool
    );

VOID
nicFreePacketPool (
    IN PNIC_PACKET_POOL pPacketPool
    );


VOID
nicAcquireSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock,
    IN PUCHAR   FileName,
    IN UINT LineNumber
    );
    

VOID
nicReleaseSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock,
    IN PUCHAR   FileName,
    IN UINT LineNumber
);

VOID
nicInitializeNicSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock
    );


VOID 
nicFreeNicSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock
    );


VOID
nic1394DeallocPktLog(
    IN ADAPTERCB* pAdapter
    );

    
VOID
nic1394AllocPktLog(
    IN ADAPTERCB* pAdapter
    );

VOID
Nic1394LogPkt (
    PNIC1394_PKTLOG pPktLog,
    ULONG           Flags,
    ULONG           SourceID,
    ULONG           DestID,
    PVOID           pvData,
    ULONG           cbData
);

VOID
Nic1394InitPktLog(
    PNIC1394_PKTLOG pPktLog
    );



ULONG 
SwapBytesUlong(
    IN ULONG Val
    );

VOID
nicUpdatePacketState (
    IN PNDIS_PACKET pPacket,
    IN ULONG Tag
    );

UINT
nicGetSystemTime(
    VOID
    );
    
UINT
nicGetSystemTimeMilliSeconds(
    VOID
    );

 
VOID
nicGetFakeMacAddress(
    UINT64 *Euid, 
    MAC_ADDRESS *MacAddr
    );

VOID
nicWriteErrorLog (
    IN PADAPTERCB pAdapter,
    IN NDIS_ERROR_CODE ErrorCode,
    IN ULONG ErrorValue
    );

//-----------------------------------------------------------------------------
//      S E R I A L I Z E    S E N D / R E C E I V E    F U N C T I O N S 
//-----------------------------------------------------------------------------


NDIS_STATUS
nicInitSerializedReceiveStruct(
    PADAPTERCB pAdapter
    );

VOID
nicDeInitSerializedReceiveStruct(
    PADAPTERCB pAdapter
    );


NDIS_STATUS
nicQueueReceivedPacket(
    PNDIS_PACKET pPacket, 
    PVCCB pVc, 
    PADAPTERCB pAdapter
    );
    

NDIS_STATUS
nicInitSerializedSendStruct(
    PADAPTERCB pAdapter
    );

VOID
nicDeInitSerializedSendStruct(
    PADAPTERCB pAdapter
    );

NDIS_STATUS
nicQueueSendPacket(
    PNDIS_PACKET pPacket, 
    PVCCB pVc 
    );



//-----------------------------------------------------------------------------
//          G L O B A L    V A R I A B L E S
//-----------------------------------------------------------------------------

UINT NumChannels;
//-----------------------------------------------------------------------------
//          E N U M E R A T O R         F U N C T I O N S 
//-----------------------------------------------------------------------------


extern ENUM1394_REGISTER_DRIVER_HANDLER     NdisEnum1394RegisterDriver;
extern ENUM1394_DEREGISTER_DRIVER_HANDLER   NdisEnum1394DeregisterDriver;
extern ENUM1394_REGISTER_ADAPTER_HANDLER    NdisEnum1394RegisterAdapter;
extern ENUM1394_DEREGISTER_ADAPTER_HANDLER  NdisEnum1394DeregisterAdapter;

extern NIC1394_CHARACTERISTICS Nic1394Characteristics;


NTSTATUS
NicRegisterEnum1394(
    IN  PNDISENUM1394_CHARACTERISTICS   NdisEnum1394Characteristcis
    );
    
VOID
NicDeregisterEnum1394(
    VOID
    );

VOID
Nic1394Callback(
    PVOID   CallBackContext,
    PVOID   Source,
    PVOID   Characteristics
    );

VOID
Nic1394RegisterAdapters(
    VOID
    );

NTSTATUS
Nic1394BusRequest(
    PDEVICE_OBJECT              DeviceObject,
    PIRB                        Irb
    );

NTSTATUS
Nic1394PassIrpDownTheStack(
    IN  PIRP            pIrp,
    IN  PDEVICE_OBJECT  pNextDeviceObject
    );

NTSTATUS
Nic1394IrpCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

VOID 
nicDumpMdl (
    IN PMDL pMdl,
    IN ULONG LengthToPrint,
    IN CHAR *str
    );
    
VOID
nicDumpPkt (
    IN PNDIS_PACKET pPacket,
    CHAR * str
    );

VOID
nicCheckForEthArps (
    IN PNDIS_PACKET pPkt
    );

VOID
nicGetMacAddressFromEuid (
	UINT64 *pEuid,
	MAC_ADDRESS *pMacAddr
	);
  


VOID
nicInitializeLoadArpStruct(
    PADAPTERCB pAdapter
    );

extern PCALLBACK_OBJECT             Nic1394CallbackObject;
extern PVOID                        Nic1394CallbackRegisterationHandle;


//-----------------------------------------------------------------------------
//          S T A T I S T I C    B U C K E T S          
//-----------------------------------------------------------------------------



extern STAT_BUCKET      SendStats;
extern STAT_BUCKET      RcvStats;
extern ULONG            nicMaxRcv;
extern ULONG            nicMaxSend;
extern ULONG            SendTimer;  // In ms
extern ULONG            RcvTimer; // In ms
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\receive.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// receive.h
//
// IEEE1394 mini-port/call-manager driver
//
// Mini-port Receive routines
//
// 2/13/1998 ADube Created, adapted from the l2tp and 1394diag sources.
//

#define ISOCH_PREFIX_LENGTH (sizeof(LONG) + sizeof (ISOCH_HEADER))

VOID
nicAbortReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    );


VOID
nicAllocateAddressRangeCallback( 
    IN PNOTIFICATION_INFO NotificationInfo 
);

VOID
nicAllocateAddressRangeDebugSpew(
    IN PIRB pIrb 
    );

NDIS_STATUS
nicAllocateAddressRangeSucceeded (
    IN PIRB pIrb,
    IN OUT PRECVFIFO_VCCB    pRecvFIFOVc
    );



NDIS_STATUS
nicGetInitializedAddressFifoElement(
    IN     UINT BufferLength, 
    IN OUT PADDRESS_FIFO *ppElement 
    );



NDIS_STATUS
nicInitAllocateAddressIrb(
   IN PIRB                  pIrb,   
   IN PVOID                 pContext,   
   IN ULONG                 fulFlags,
   IN ULONG                 nLength,
   IN ULONG                 MaxSegmentSize,
   IN ULONG                 fulAccessType,
   IN ULONG                 fulNotificationOptions,
   IN PADDRESS_OFFSET       pOffset,
   IN PRECVFIFO_VCCB        pRecvFIFOVc
   );





NDIS_STATUS
nicGetEmptyAddressFifoElement(
    IN PADDRESS_FIFO *ppElement
    );
    


NDIS_STATUS
nicAllocateAddressRange(
    IN PADAPTERCB pAdapter,
    IN PRECVFIFO_VCCB pRecvFIFOVc
    );

NDIS_STATUS
nicFillAllocateAddressRangeSList(
    IN RECVFIFO_VCCB *pRecvFIFO,
    IN UINT *Num 
    );

NDIS_STATUS
nicFreeRecvFifoAddressRange(
    IN REMOTE_NODE *pRemoteNode
    );


NDIS_STATUS
nicFreeRecvFifoAddressRangeOnAllRemoteNodes (
    IN PADAPTERCB pAdapter 
    );          

NDIS_STATUS
nicFreeAllAllocatedAddressRangesOnPdo (
    IN PREMOTE_NODE pRemoteNode
    );
    

NDIS_STATUS
nicFreeAllocateAddressRangeSList(
    IN PRECVFIFO_VCCB pRecvFIFOVc 
    );
    

NDIS_STATUS
nicGetNdisBuffer(
    IN UINT Length,
    IN PVOID pLocalBuffer,
    IN OUT PNDIS_BUFFER *ppNdisBuffer 
    );

NDIS_STATUS
nicFreeAddressFifo(
    IN PADDRESS_FIFO pAddressFifo,
    IN PRECVFIFO_VCCB pRecvFIFOVc 
    );
    



VOID 
nicFifoReturnPacket (
    IN PVCCB pVc,
    IN PNDIS_PACKET pMyPacket
    );
    

// 
// Isoch Functions
//

NDIS_STATUS
nicAllocateAndInitializeIsochDescriptors (
    IN PCHANNEL_VCCB pChannelVc,
    IN UINT NumDescriptors,
    IN UINT BufferLength,
    IN OUT PPISOCH_DESCRIPTOR  ppIsochDescriptor
    );


NDIS_STATUS
nicFreeIsochDescriptors(
    IN UINT Num,
    IN PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN PVCCB pVc
    );

NDIS_STATUS
nicFreeSingleIsochDescriptor(
    IN PISOCH_DESCRIPTOR  pIsochDescriptor,
    IN PVCCB pVc
    );

VOID
nicReturnNdisBufferChain (
    IN PNDIS_BUFFER pNdisBuffer,
    IN PVCCB pVc
    );


VOID 
nicChannelReturnPacket (
    IN PVCCB pVc,
    IN PNDIS_PACKET pMyPacket
    );



NDIS_STATUS
nicFindReassemblyStructure (
    IN PREMOTE_NODE pRemoteNode,
    IN USHORT dgl,
    IN BUS_OPERATION BusOp,
    IN PVCCB pVc,
    OUT PNDIS1394_REASSEMBLY_STRUCTURE* ppReassembly
    );




NDIS_STATUS
nicGetReassemblyStructure ( 
    IN PNDIS1394_REASSEMBLY_STRUCTURE* ppReassembly
    );




VOID
nicFreeReassemblyStructure ( 
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    );





NDIS_STATUS
nicInitializeReassemblyStructure (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN USHORT Dgl,
    IN PREMOTE_NODE pRemoteNode,
    IN PVCCB pVc,
    IN BUS_OPERATION ReceiveOp
    );


    





VOID
nicReturnFifoChain (
    IN PADDRESS_FIFO pAddressFifo,
    IN PRECVFIFO_VCCB pRecvFifoVc
    );




VOID
nicReturnDescriptorChain ( 
    IN PISOCH_DESCRIPTOR pIsochDescriptor ,
    IN PCHANNEL_VCCB pChannelVc
    );


VOID
nicInternalReturnPacket(
    IN  PVCCB                   pVc ,
    IN  PNDIS_PACKET            pPacket
    );

//
// Generic Receive functions 
//


VOID
NicReturnPacket(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            pPacket
    );

    
VOID
nicIndicateNdisPacketToNdis (
    PNDIS_PACKET pPacket, 
    PVCCB pVc, 
    PADAPTERCB pAdapter
    );


VOID
RcvIndicateTimer (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );


    

VOID
nicIndicateMultiplePackets(
    PNDIS_PACKET *ppPacket, 
    NDIS_HANDLE NdisVcHandle, 
    PADAPTERCB pAdapter,
    ULONG NumPackets
    );






VOID
nicAbortReassemblyList (
    PLIST_ENTRY pToBeFreedList
    );




VOID
nicFreeAllPendingReassemblyStructures(
    IN PADAPTERCB pAdapter
    );





ULONG
nicDereferenceReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PCHAR pString
    );




ULONG
nicReferenceReassembly (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PCHAR pString
    );  




NDIS_STATUS
nicValidateRecvData(
    IN  PMDL                pMdl,
    IN  BUS_OPERATION       RecvOp,
    IN  PVOID               pIndicatedStruct,
    IN PVCCB                pVc,
    OUT PNIC_RECV_DATA_INFO pInfo
    );

VOID
nicInitRecvDataFragmented (
    IN  PMDL                pMdl,
    IN  BUS_OPERATION       RecvOp,
    IN  PVOID               pIndicatedStruct,
    OUT PNIC_RECV_DATA_INFO pRcvInfo
    );




NDIS_STATUS
nicReceiveInOrderReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PVOID pIndicatedStructure,
    PNDIS_BUFFER pNdisBuffer,
    PVOID pNdisBufferStartData,
    ULONG   IPLength,
    PNDIS1394_FRAGMENT_HEADER     pHeader,
    IN ULONG FragOffset
    );


NDIS_STATUS
nicReceiveOutOfOrderReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    PVOID pIndicatedStructure,
    PNDIS_BUFFER pNdisBuffer,
    PVOID pNdisBufferStartData,
    ULONG   IPLength,
    PNDIS1394_FRAGMENT_HEADER     pHeader,
    IN ULONG FragOffset
    );


VOID
nicInsertEarliestFragment (
    PMDL pMdl,
    PNDIS_BUFFER pNdisBuffer,
    PVOID pStartData,
    PVOID pIndicatedStructure,
    ULONG CurrFragOffset,
    ULONG IPLength,
    PNDIS1394_FRAGMENT_HEADER     pHeader,
    PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    );


BOOLEAN
nicIsOutOfOrderReassemblyComplete (
    IN  PNDIS1394_REASSEMBLY_STRUCTURE pReassembly
    );


    

NDIS_STATUS
nicValidateOutOfOrder(
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN ULONG CurrFragOffset,
    IN ULONG IPLength,
    OUT PULONG pFragmentNum,
    OUT PREASSEMBLY_INSERT_TYPE pInsertionManner,
    OUT PBOOLEAN pfAbort
    );


NDIS_STATUS
nicDoReassembly ( 
    IN PNIC_RECV_DATA_INFO pRcvInfo,
    OUT PNDIS1394_REASSEMBLY_STRUCTURE *ppReassembly,
    PBOOLEAN pfReassemblyComplete
    );


VOID
nicAddUnfragmentedHeader (
    IN PNDIS1394_REASSEMBLY_STRUCTURE pReassembly,
    IN PVOID pEncapHeader
    );
    

VOID
nicReceiveCommonCallback (
    IN PVOID pIndicatedStruct,
    IN PVCCB pVc,
    BUS_OPERATION RecvOp,
    PMDL pMdl
    );


NDIS_STATUS
nicGetNdisBufferForReassembly(
    IN PNIC_RECV_DATA_INFO pRcvInfo,
    OUT PNDIS_BUFFER *ppNdisBuffer
    );






NDIS_STATUS
nicInsertFragmentInReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly,
    PNIC_RECV_DATA_INFO pRcvInfo
    );






VOID
nicFindInsertionPosition (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassmbly, 
    ULONG FragOffset, 
    ULONG IPLength, 
    PULONG pFragmentNum
    );





VOID 
nicChainReassembly (
    PNDIS1394_REASSEMBLY_STRUCTURE  pReassembly
    );



VOID
nicRecvNoRemoteNode(
    PADAPTERCB pAdapter
    );


VOID
nicInsertNodeAddressAtHead (
    IN PNDIS_PACKET pPacket, 
    IN PNIC_RECV_DATA_INFO pRcvInfo
    );

VOID
nicUpdateNodeTable(
    NDIS_WORK_ITEM* pUpdateTable,
    IN PVOID Context 
    );


NDIS_STATUS
nicInitSerializedReassemblyStruct(
    PADAPTERCB pAdapter
    );

VOID
nicDeInitSerializedReassmblyStruct(
    PADAPTERCB pAdapter
    );

NDIS_STATUS
nicQueueReassemblyTimer(
    PADAPTERCB pAdapter,
    BOOLEAN fIsLastTimer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\util.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// util.c
//
// IEEE1394 mini-port/call-manager driver
//
// General utility routines
//
// 12/28/1998 JosephJ Created, adapted from the l2tp sources.
//


#include "precomp.h"


// Debug counts of oddities that should not be happening.
//
ULONG g_ulAllocTwFailures = 0;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber );

VOID
ReversePsz(
    IN OUT CHAR* psz );

VOID
TunnelWork(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf );


//-----------------------------------------------------------------------------
// General utility routines (alphabetically)
//-----------------------------------------------------------------------------





CHAR*
nicStrDup(
    IN CHAR* psz )

    // Return a duplicate of 'psz'.  Caller must eventually call FREE_NONPAGED
    // on the returned string.
    //
{
    return nicStrDupSized( psz, strlen( psz ), 0 );
}


CHAR*
nicStrDupNdisString(
    IN NDIS_STRING* pNdisString )

    // Returns null-terminated ASCII copy of the NDIS_STRING 'pNdisString'
    // Caller must eventually call FREE_NONPAGED on the returned string.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( pNdisString->Length + 1, MTAG_UTIL );
    if (pszDup)
    {
        NdisZeroMemory( pszDup, pNdisString->Length + 1 );
        if (pNdisString->Length)
        {
            NdisMoveMemory( pszDup, pNdisString->Buffer, pNdisString->Length );
        }

        // NDIS_STRING is UNICODE_STRING on NT but need the corresponding
        // ASCII (not multi-byte ANSI) value from NDIS_STRING on any system.
        // If it looks like a Unicode string then "convert" it by picking out
        // every other byte, hopefully all the non-zero ones.  This is not
        // foolproof, but then Unicode doesn't convert to ASCII in any
        // foolproof way.
        //
        if (pNdisString->Length > 1 && pszDup[ 1 ] == '\0')
        {
            USHORT i;

            for (i = 0; i * 2 < pNdisString->Length; ++i)
            {
                pszDup[ i ] = pszDup[ i * 2 ];
            }

            pszDup[ i ] = '\0';
        }
    }

    return pszDup;
}


CHAR*
nicStrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra )

    // Return a duplicate of the first 'ulLength' bytes of 'psz' followed by a
    // null character and 'ulExtra' extra bytes, or NULL on error.  Caller
    // must eventually call FREE_NONPAGED on the returned string.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( ulLength + 1 + ulExtra, MTAG_UTIL );
    if (pszDup)
    {
        if (ulLength)
        {
            NdisMoveMemory( pszDup, psz, ulLength );
        }
        pszDup[ ulLength ] = '\0';
    }

    return pszDup;
}



//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber )

    // Convert string of digits 'pszNumber' to it's ULONG value.
    //
{
    ULONG ulResult;

    ulResult = 0;
    while (*pszNumber && *pszNumber >= '0' && *pszNumber <= '9')
    {
        ulResult *= 10;
        ulResult += *pszNumber - '0';
        ++pszNumber;
    }

    return ulResult;
}


#if DBG
VOID
ReversePsz(
    IN OUT CHAR* psz )

    // Reverse the order of the characters in 'psz' in place.
    //
{
    CHAR* pchLeft;
    CHAR* pchRight;

    pchLeft = psz;
    pchRight = psz + strlen( psz ) - 1;

    while (pchLeft < pchRight)
    {
        CHAR ch;

        ch = *pchLeft;
        *pchLeft = *pchRight;
        *pchRight = *pchLeft;

        ++pchLeft;
        --pchRight;
    }
}
#endif


#if DBG
VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf )

    // Convert 'ul' to null-terminated string form in caller's 'pszBuf'.  It's
    // caller job to make sure 'pszBuf' is long enough to hold the returned
    // string.
    //
{
    CHAR* pch;

    pch = pszBuf;
    do
    {
        *pch++ = (CHAR )((ul % 10) + '0');
        ul /= 10;
    }
    while (ul);

    *pch = '\0';
    ReversePsz( pszBuf );
}
#endif

VOID
nicSetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = *pulFlags;
        ulNewFlags = ulFlags | ulMask;
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

VOID
nicClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = *pulFlags;
        ulNewFlags = ulFlags & ~(ulMask);
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}

ULONG
nicReadFlags(
    IN ULONG* pulFlags )

    // Read the value of '*pulFlags' as an interlocked operation.
    //
{
    return *pulFlags;
}



//
// Reference And Dereference functions taken directly from Ndis
//



BOOLEAN
nicReferenceRef(
    IN  PREF                RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference was added.
    FALSE if the object was closing.

--*/

{
    BOOLEAN rc = TRUE;
    KIRQL   OldIrql;

    TRACE( TL_V, TM_Ref, ( "nicReferenceRef, %.8x", RefP ) );

//  NdisAcquireSpinLock (&RefP->SpinLock);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else
    {
        NdisInterlockedIncrement (&RefP->ReferenceCount);
    }

//  NdisReleaseSpinLock (&RefP->SpinLock);

    TRACE( TL_V, TM_Ref, ( "nicReferenceRef, Bool %.2x, Ref %d", rc, RefP->ReferenceCount ) );

    return(rc);
}


BOOLEAN
nicDereferenceRef(
    IN  PREF                RefP
    )

/*++

Routine Description:

    Removes a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference count is now 0.
    FALSE otherwise.

--*/

{
    BOOLEAN rc = FALSE;
    KIRQL   OldIrql;

    TRACE( TL_V, TM_Ref, ( "==>nicDeReferenceRef, %x", RefP ) );

//  NdisAcquireSpinLock (&RefP->SpinLock);

    NdisInterlockedDecrement (&RefP->ReferenceCount);

    if (RefP->ReferenceCount == 0)
    {
        rc = TRUE;
        NdisSetEvent (&RefP->RefZeroEvent);

    }
    if ((signed long)RefP->ReferenceCount < 0)
    {
        ASSERT ( !"Ref Has Gone BELOW ZERO");
    }

//  NdisReleaseSpinLock (&RefP->SpinLock);


    TRACE( TL_V, TM_Ref, ( "<==nicDeReferenceRef, %.2x, RefCount %d", rc, RefP->ReferenceCount ) );
            
    return(rc);
}


VOID
nicInitializeRef(
    IN  PREF                RefP
    )

/*++

Routine Description:

    Initialize a reference count structure.

Arguments:

    RefP - The structure to be initialized.

Return Value:

    None.

--*/

{
    TRACE( TL_V, TM_Ref, ( "==>nicInitializeRef, %.8x", RefP ) );


    RefP->Closing = FALSE;
    RefP->ReferenceCount = 1;
    
//  NdisAllocateSpinLock (&RefP->SpinLock);
    NdisInitializeEvent (&RefP->RefZeroEvent);

    TRACE( TL_V, TM_Ref, ( "<==nicInitializeRef, %.8x", RefP ) );
}


BOOLEAN
nicCloseRef(
    IN  PREF                RefP
    )

/*++

Routine Description:

    Closes a reference count structure.

Arguments:

    RefP - The structure to be closed.

Return Value:

    FALSE if it was already closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;

    TRACE( TL_N, TM_Ref, ( "==>ndisCloseRef, %.8x", RefP ) );

//  NdisAcquireSpinLock (&RefP->SpinLock);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else RefP->Closing = TRUE;

//  NdisReleaseSpinLock (&RefP->SpinLock);

    TRACE( TL_N, TM_Ref, ( "<==ndisCloseRef, %.8x, RefCount %.8x", RefP, RefP->ReferenceCount ) );
            
    return(rc);
}

//
//
// These are self expanatory Pdo Reference functions
// which will be turned into macros once we have functionality 
// working
//



BOOLEAN
nicReferenceRemoteNode (
    IN REMOTE_NODE *pPdoCb,
    IN PCHAR pDebugPrint
    )
/*++

Routine Description:
    

Arguments:


Return Value:

--*/
{
    BOOLEAN bRefClosing = FALSE;


    bRefClosing = nicReferenceRef (&pPdoCb->Ref);
    TRACE( TL_V, TM_RemRef, ( "**nicReferenceRemoteNode pPdoCb %x, to %d, %s, ret %x ", 
                          pPdoCb, pPdoCb->Ref.ReferenceCount, pDebugPrint, bRefClosing  ) );

    return bRefClosing ; 
}


BOOLEAN
nicDereferenceRemoteNode (
    IN REMOTE_NODE *pPdoCb,
    IN PCHAR pDebugPrint
    )
/*++

Routine Description:
    

Arguments:


Return Value:

--*/
{
    TRACE( TL_V, TM_RemRef, ( "**nicDereferenceRemoteNode  %x to %d , %s", 
                              pPdoCb , pPdoCb->Ref.ReferenceCount -1, pDebugPrint  ) );
    
    return nicDereferenceRef (&pPdoCb->Ref);
}


VOID
nicInitalizeRefRemoteNode(
    IN REMOTE_NODE *pPdoCb
    )
/*++

Routine Description:
    
    Closes Ref on the remote node
Arguments:

    IN REMOTE_NODE *pPdoCb - RemoteNode

Return Value:

    None
--*/
{
    TRACE( TL_N, TM_Ref, ( "**nicinitalizeRefPdoCb pPdoCb %.8x", pPdoCb   ) );

    nicInitializeRef (&pPdoCb->Ref);
}


BOOLEAN
nicCloseRefRemoteNode(
    IN REMOTE_NODE *pPdoCb
    )
/*++

Routine Description:
    
    Closes Ref on the remote node
Arguments:

    IN REMOTE_NODE *pPdoCb - RemoteNode

Return Value:

    Return value of nicCloseRef

--*/


{
    TRACE( TL_N, TM_Ref, ( "**nicClosePdoCb pPdoCb %.8x", pPdoCb   ) );

    return nicCloseRef (&pPdoCb->Ref);
}


NDIS_STATUS
NtStatusToNdisStatus (
    NTSTATUS NtStatus 
    )

/*++

Routine Description:
    
    Dumps the packet , if the appropriate Debuglevels are set

Arguments:

    NTSTATUS NtStatus  - NtStatus to be converted


Return Value:

    NdisStatus - NtStatus' corresponding NdisStatus

--*/


{
    NDIS_STATUS NdisStatus;
    
    switch (NtStatus)
    {
        case STATUS_SUCCESS:
        {
            NdisStatus = NDIS_STATUS_SUCCESS;
            break;
        }

        case STATUS_UNSUCCESSFUL:
        {   
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }

        case STATUS_PENDING:
        {
            NdisStatus = NDIS_STATUS_PENDING;
            break;
        }

        case STATUS_INVALID_BUFFER_SIZE:
        {
            NdisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        case STATUS_INSUFFICIENT_RESOURCES:
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        case STATUS_INVALID_GENERATION:
        {
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;
            break;
        }
        case STATUS_ALREADY_COMMITTED:
        {
            NdisStatus = NDIS_STATUS_RESOURCE_CONFLICT;
            break;
        }

        case STATUS_DEVICE_BUSY:
        {
            NdisStatus = NDIS_STATUS_MEDIA_BUSY;
            break;
        }

        case STATUS_INVALID_PARAMETER:
        {
            NdisStatus = NDIS_STATUS_INVALID_DATA;
            break;

        }
        case STATUS_DEVICE_DATA_ERROR:
        {
            NdisStatus = NDIS_STATUS_DEST_OUT_OF_ORDER;
            break;
        }

        case STATUS_TIMEOUT:
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }
        case STATUS_IO_DEVICE_ERROR:
        {
            NdisStatus = NDIS_STATUS_NETWORK_UNREACHABLE;
            break;
        }
        default:
        {
            NdisStatus = NDIS_STATUS_FAILURE;
            TRACE( TL_A, TM_Send, ( "Cause: Don't know, INVESTIGATE %x", NtStatus  ) );

            //ASSERT (0);
        }

    }

    return NdisStatus;



}




VOID
PrintNdisPacket (
    ULONG TM_Comp,
    PNDIS_PACKET pMyPacket
    )
/*++

Routine Description:
    
    Dumps the packet , if the appropriate Debuglevels are set

Arguments:

    ULONG TM_Comp = Debug Component

    PNDIS_PACKET pMyPacket - Packet to be printed 


Return Value:

    None

--*/
{


    PNDIS_BUFFER pPrintNdisBuffer = pMyPacket->Private.Head;

    //
    // Print out the complete NdisPacket . Change to DEBUG ONLY
    //
    while (pPrintNdisBuffer != NULL)
    {
        PVOID pPrintData = NdisBufferVirtualAddress(pPrintNdisBuffer);
        ULONG PrintLength = NdisBufferLength (pPrintNdisBuffer);

        TRACE( TL_D, TM_Comp, ( "  pNdisbuffer %x, pData %x, Len %x", pPrintNdisBuffer, pPrintData, PrintLength) );   

        if (pPrintData != NULL)
        {
            DUMPB (TL_D, TM_Recv, pPrintData, PrintLength);
        }

        pPrintNdisBuffer = pPrintNdisBuffer->Next;
    }


}



VOID
nicAllocatePacket(
    OUT PNDIS_STATUS pNdisStatus,
    OUT PNDIS_PACKET *ppNdisPacket,
    IN PNIC_PACKET_POOL pPacketPool
    )
/*++

Routine Description:
    
    Calls the ndis API to allocate a packet. On Win9X calls to  allocate packets are serialized


Arguments:

    pNdisStatus  - pointer to NdisStatus 

    *ppNdisPacket - Ndis packet Allocated by Ndis,

    pPacketPool - packet pool from which the packet is allocated


Return Value:

    return value of the call to Ndis

--*/

{
    KIRQL OldIrql;

#ifdef Win9X
#if PACKETPOOL_LOCK

    KeAcquireSpinLock(&pPacketPool->Lock, &OldIrql);
#endif
#endif


    NdisAllocatePacket (pNdisStatus,
                        ppNdisPacket,
                        pPacketPool->Handle );
    
#ifdef Win9X
#if PACKETPOOL_LOCK

    KeReleaseSpinLock(&pPacketPool->Lock, OldIrql);
#endif
#endif

    if (*pNdisStatus == NDIS_STATUS_SUCCESS)
    {
            PRSVD pRsvd = NULL;
            PINDICATE_RSVD  pIndicateRsvd = NULL;
            pRsvd =(PRSVD)((*ppNdisPacket)->ProtocolReserved);

            pIndicateRsvd = &pRsvd->IndicateRsvd;

            pIndicateRsvd->Tag  = NIC1394_TAG_ALLOCATED;

            NdisInterlockedIncrement (&pPacketPool->AllocatedPackets);

    }
    else
    {
        *ppNdisPacket = NULL;
        nicIncrementMallocFailure();
    }


}




VOID
nicFreePacket(
    IN PNDIS_PACKET pNdisPacket,
    IN PNIC_PACKET_POOL pPacketPool
    )
/*++

Routine Description:
    
    Free the packet and decrements the outstanding Packet count.

    All calls are serialized on Win9x

Arguments:

    IN PNDIS_PACKET pNdisPacket - Packet to be freed
    IN PNIC_PACKET_POOL pPacketPool  - PacketPool to which the packet belongs 


Return Value:

    None

--*/

{

    KIRQL OldIrql;
    PRSVD pRsvd = NULL;
    PINDICATE_RSVD pIndicateRsvd = NULL;

    pRsvd =(PRSVD)(pNdisPacket->ProtocolReserved);

    pIndicateRsvd = &pRsvd->IndicateRsvd;

    pIndicateRsvd->Tag  = NIC1394_TAG_FREED;

#ifdef Win9X
#if PACKETPOOL_LOCK

    KeAcquireSpinLock(&pPacketPool->Lock, &OldIrql);

#endif
#endif

    NdisInterlockedDecrement (&pPacketPool->AllocatedPackets);

    NdisFreePacket (pNdisPacket);

#ifdef Win9X
#if PACKETPOOL_LOCK

    KeReleaseSpinLock(&pPacketPool->Lock, OldIrql);
#endif
#endif

}



VOID
nicFreePacketPool (
    IN PNIC_PACKET_POOL pPacketPool
    )
/*++

Routine Description:

    frees the packet pool after waiting for the outstanding packet count to go to zero      

Arguments:

    IN PNIC_PACKET_POOL pPacketPool  - PacketPool which is to be freed


Return Value:

    None

--*/
{
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    

    while (NdisPacketPoolUsage (pPacketPool->Handle)!=0)
    {
        TRACE( TL_V, TM_Cm, ( "  Waiting PacketPool %x, AllocatedPackets %x", 
        pPacketPool->Handle, pPacketPool->AllocatedPackets  ) );   

        NdisMSleep (10000);
    }
    
    NdisFreePacketPool (pPacketPool->Handle);

    pPacketPool->Handle = NULL;
    ASSERT (pPacketPool->AllocatedPackets   == 0);
}

VOID
nicAcquireSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock,
    IN PUCHAR   FileName,
    IN UINT LineNumber
    )
/*++

Routine Description:

    Acquires a spin lock and if the Dbg, then it will spew out the line and file

Arguments:

    NIC_SPIN_LOCK - Lock to be acquired

Return Value:

    None

--*/
{
    
        PKTHREAD                pThread;

        TRACE (TL_V, TM_Lock, ("Lock %x, Acquired by File %s, Line %x" , pNicSpinLock, FileName, LineNumber)) ; 

        NdisAcquireSpinLock(&(pNicSpinLock->NdisLock));

#if TRACK_LOCKS     
        pThread = KeGetCurrentThread();


        pNicSpinLock->OwnerThread = pThread;
        NdisMoveMemory(pNicSpinLock->TouchedByFileName, FileName, LOCK_FILE_NAME_LEN);
        pNicSpinLock->TouchedByFileName[LOCK_FILE_NAME_LEN - 1] = 0x0;
        pNicSpinLock->TouchedInLineNumber = LineNumber;
        pNicSpinLock->IsAcquired++;

#endif
}



VOID
nicReleaseSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock,
    IN PUCHAR   FileName,
    IN UINT LineNumber
)
/*++

Routine Description:

    Release a spin lock and if Dbg is On, then it will spew out the line and file

Arguments:

    pNicSpinLock - Lock to be Release
    FileName - File Name
    LineNumber - Line

Return Value:

    None

--*/
{
    
        PKTHREAD                pThread;

        TRACE (TL_V, TM_Lock, ("Lock %x, Released by File %s, Line %x" , pNicSpinLock, FileName, LineNumber)) ; 

#if TRACK_LOCKS     
        
        pThread = KeGetCurrentThread();

        NdisMoveMemory(pNicSpinLock->TouchedByFileName, FileName, LOCK_FILE_NAME_LEN);
        pNicSpinLock->TouchedByFileName[LOCK_FILE_NAME_LEN - 1] = 0x0;
        pNicSpinLock->TouchedInLineNumber = LineNumber;
        pNicSpinLock->IsAcquired--;
        pNicSpinLock->OwnerThread = 0;
#endif
        NdisReleaseSpinLock(&(pNicSpinLock->NdisLock));

}




VOID
nicInitializeNicSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock
    )
/*++

Routine Description:

    Initializes the lock in the SpinLock

Arguments:
    pNicSpinLock - SpinLock
    
Return Value:

    None

--*/
{
    NdisAllocateSpinLock (&pNicSpinLock->NdisLock); 
}


VOID 
nicFreeNicSpinLock (
    IN PNIC_SPIN_LOCK pNicSpinLock
    )
/*++

Routine Description:

        Frees the spinlock
        
Arguments:
    pNicSpinLock - SpinLock
    
Return Value:

    None

--*/
{
    ASSERT ((ULONG)pNicSpinLock->NdisLock.SpinLock == 0);
    NdisFreeSpinLock (&pNicSpinLock->NdisLock); 
}


UINT
nicGetSystemTime(
    VOID
    )
/*++
    Returns system time in seconds.

    Since it's in seconds, we won't overflow unless the system has been up 
for over
    a  100 years :-)
--*/
{
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000000;          //100-nanoseconds to seconds.

    return Time.LowPart;
}


UINT
nicGetSystemTimeMilliSeconds(
    VOID
    )
/*++
    Returns system time in seconds.

    Since it's in seconds, we won't overflow unless the system has been up 
for over
    a  100 years :-)
--*/
{
    LARGE_INTEGER Time;
    NdisGetCurrentSystemTime(&Time);
    Time.QuadPart /= 10000;          //10-nanoseconds to seconds.

    return Time.LowPart;
}




ULONG 
SwapBytesUlong(
    IN ULONG Val)
{
            return  ((((Val) & 0x000000ff) << 24)   |   (((Val) & 0x0000ff00) << 8) |   (((Val) & 0x00ff0000) >> 8) |   (((Val) & 0xff000000) >> 24) );
}




void
nicTimeStamp(
    char *szFormatString,
    UINT Val
    )
/*++

Routine Description:
  Execute and print a time stamp
 
Arguments:


Return Value:


--*/
{
    UINT Minutes;
    UINT Seconds;
    UINT Milliseconds;
    LARGE_INTEGER Time;


    NdisGetCurrentSystemTime(&Time);



    Time.QuadPart /= 10000;         //10-nanoseconds to milliseconds.
    Milliseconds = Time.LowPart; // don't care about highpart.
    Seconds = Milliseconds/1000;
    Milliseconds %= 1000;
    Minutes = Seconds/60;
    Seconds %= 60;


    DbgPrint( szFormatString, Minutes, Seconds, Milliseconds, Val);
}




VOID
nicDumpPkt (
    IN PNDIS_PACKET pPacket,
    CHAR * str
    )
{
    PNDIS_BUFFER pBuffer;
    extern BOOLEAN g_ulNicDumpPacket ;
    
    if ( g_ulNicDumpPacket == FALSE)
    {
        return ;
    }


    pBuffer = pPacket->Private.Head;


    DbgPrint (str);
    DbgPrint ("Packet %p TotLen %x", pPacket, pPacket->Private.TotalLength);
     
    do
    {
        ULONG Length = nicNdisBufferLength (pBuffer);
        PUCHAR pVa = nicNdisBufferVirtualAddress (pBuffer);


        DbgPrint ("pBuffer %p, Len %x \n", pBuffer, Length);    
        Dump( pVa, Length, 0, 1 );

        pBuffer = pBuffer->Next;


    } while (pBuffer != NULL);



}


VOID 
nicDumpMdl (
    IN PMDL pMdl,
    IN ULONG LengthToPrint,
    IN CHAR *str
    )
{

    ULONG MdlLength ;
    PUCHAR pVa;
    extern BOOLEAN g_ulNicDumpPacket ;

    if ( g_ulNicDumpPacket == FALSE )
    {
        return;
    }

    MdlLength =  MmGetMdlByteCount(pMdl);
    //
    // if Length is zero then use MdlLength
    //
    if (LengthToPrint == 0)
    {
        LengthToPrint = MdlLength;
    }
    //
    // Check for invalid length
    // 
    
    if (MdlLength < LengthToPrint)
    {
        return;
    }

    pVa =  MmGetSystemAddressForMdlSafe(pMdl,LowPagePriority );

    if (pVa == NULL)
    {
        return;
    }
    
    DbgPrint (str);
    DbgPrint ("pMdl %p, Len %x\n", pMdl, LengthToPrint);    
    
    Dump( pVa, LengthToPrint, 0, 1 );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\tools\ipfwadm\common.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

	common.h

Abstract:

	IEEE1394 ARP Admin Utility.

	Usage:

		a13adm 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1999	Created

--*/

#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <devioctl.h>
#include <setupapi.h>

#define PROTOCOL_RESERVED_SIZE_IN_PACKET (4 * sizeof(PVOID)) // from ndis.h
#define USER_MODE 1
#include <nic1394.h>
#include <nicarp.h>
#include <rfc2734.h>
#include <a13ioctl.h>


VOID
DoCmd(
  	PARP1394_IOCTL_COMMAND pCmd
);

BOOL
GetBinaryData(
	TCHAR *tszPathName,
	TCHAR *tszSection,
	TCHAR *tszKey,
	UCHAR *pchData,
	UINT  cbMaxData,
	UINT *pcbDataSize
	);

extern CHAR *g_szPacketName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\tools\ipfwadm\cmd.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

	cmd.c

Abstract:

	 IEEE1394 ARP Admin Utility.

	Usage:

		a13adm 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	04-10-1999	Created

--*/

#include "common.h"

#ifndef NDIS_STATUS
#define NDIS_STATUS		ULONG
#endif

#define ANSI_ARP_CLIENT_DOS_DEVICE_NAME "\\\\.\\ARP1394"

#define DUMMY 0
#define FAKE_DUMP 0

VOID
DoBusInfoCmd(
    HANDLE DeviceHandle,
  	PARP1394_IOCTL_COMMAND pCmd
  	);

#if DUMMY

BOOL
DummyDeviceIoControl(
	HANDLE		DeviceHandle,
	UINT		Ioctl,
  	PARP1394_IOCTL_COMMAND pInCmd,
  	UINT		Size,
  	PARP1394_IOCTL_COMMAND pOutCmd,
  	UINT		OutSize,
  	PUINT		pBytesReturned,
  	PVOID		Blah
  	);

#define DeviceIoControl	DummyDeviceIoControl

#endif // DUMMY

HANDLE
OpenDevice(
	CHAR	*pDeviceName
);

extern CHAR *g_szPacketName;

VOID
CloseDevice(
	HANDLE		DeviceHandle
);

VOID
DumpArpCache(
		PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd
		);

VOID
DumpPacketStats(
	PARP1394_IOCTL_GET_PACKET_STATS pStatsCmd
	);

VOID
DumpTaskStats(
	PARP1394_IOCTL_GET_TASK_STATS pStatsCmd
	);


VOID
DumpArpStats(
	PARP1394_IOCTL_GET_ARPCACHE_STATS pStatsCmd
	);

VOID
DumpCallStats(
PARP1394_IOCTL_GET_CALL_STATS pStatsCmd
	);

VOID
DumpPacketCounts(
	PARP1394_PACKET_COUNTS pPktCounts,
	BOOL				  fRecv,
	char *szDescription
	);

VOID
Dump1394UniqueID(
	UINT64 UniqueID
	);

VOID
DumpNicInfo(
	ARP1394_IOCTL_NICINFO *pNicInfo
	);


#if OBSOLETE
VOID
DumpBusInfo(
    PNIC1394_BUSINFO pBi
    );
#endif // OBSOLETE

VOID
DumpChannelInfo(
    PNIC1394_CHANNELINFO pCi
    );

VOID
DumpRemoteNodeInfo(
    PNIC1394_REMOTENODEINFO pRni
    );

VOID
arpDumpChannelMap(
		char *szPrefix,
		UINT64 Map
		);

VOID
arpDumpPktStats(
		char *szPrefix,
		NIC1394_PACKET_STATS *pPs
		);
VOID
DumpEuidMapInfo(
	PARP1394_IOCTL_EUID_NODE_MAC_INFO pEuidInfo
	);




VOID
DoCmd(
  	PARP1394_IOCTL_COMMAND pCmd
)
{
	BOOL 	fRet = FALSE;
	PUCHAR 	pc;
	HANDLE	DeviceHandle;
	DWORD 	BytesReturned;
    BOOL fDumpNicInfo=FALSE;

    // Special case -- DumpNicInfo.
    //
    if (pCmd->Hdr.Op == ARP1394_IOCTL_OP_GET_NICINFO)
    {
        PNIC1394_NICINFO pNi =  &pCmd->IoctlNicInfo.Info;

        if (pNi->Hdr.Op ==  NIC1394_NICINFO_OP_BUSINFO)
        {
            fDumpNicInfo = TRUE;
        }
    }
	pc = (PUCHAR)&pCmd->Hdr.IfIpAddress;

	// Open device
	//
	DeviceHandle = OpenDevice(ANSI_ARP_CLIENT_DOS_DEVICE_NAME);
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		printf("Could not access IP/1394 ARP Client module.\n");
	}
	else if (fDumpNicInfo)
    {
        DoBusInfoCmd(DeviceHandle, pCmd);
		CloseDevice(DeviceHandle);
    }
    else
	{
		BOOL fResetStats = (pCmd->Hdr.Op == ARP1394_IOCTL_OP_RESET_STATS);

		printf("Opened handle 0x%p\n", DeviceHandle);


		// Submit Ioctl
		//
		fRet =	DeviceIoControl(
						DeviceHandle,
						ARP_IOCTL_CLIENT_OPERATION,
						pCmd,
						sizeof(*pCmd),
						pCmd,
						sizeof(*pCmd),
						&BytesReturned,
						NULL
						);

		//
		// Special case "resetstats" -- we reset both ARP and NIC stats
		//
		if (fResetStats)
		{
  			ARP1394_IOCTL_COMMAND Cmd = *pCmd;
			PNIC1394_NICINFO	pNi = &Cmd.IoctlNicInfo.Info;
			Cmd.Hdr.Op 		= ARP1394_IOCTL_OP_GET_NICINFO;
			pNi->Hdr.Version 	= NIC1394_NICINFO_VERSION;
			pNi->Hdr.Op 		= NIC1394_NICINFO_OP_RESETSTATS;

			// Submit Ioctl
			//
			fRet =	DeviceIoControl(
							DeviceHandle,
							ARP_IOCTL_CLIENT_OPERATION,
							&Cmd,
							sizeof(Cmd),
							&Cmd,
							sizeof(Cmd),
							&BytesReturned,
							NULL
							);
		}
	
		//	Close device
		//
		CloseDevice(DeviceHandle);

		if (!fRet)
		{
			printf("Request failed with error code 0x%08lx\n", GetLastError());
		}
	}

	if (!fRet)
	{
		return;				// 	EARLY RETURN
		BytesReturned=0;
	}

	// Display results.
	//
	switch(pCmd->Hdr.Op)
	{
	case ARP1394_IOCTL_OP_GET_ARPCACHE:
		DumpArpCache(&pCmd->GetArpCache);
		break;

	case ARP1394_IOCTL_OP_ADD_STATIC_ENTRY:
		{
			PARP1394_IOCTL_ADD_ARP_ENTRY pAddCmd =  &pCmd->AddArpEntry;

			printf(
				"Added the following static arp entry to IF %d.%d.%d.%d:\n",
				pc[0], pc[1], pc[2], pc[3]
				);

			pc = (PUCHAR)&pAddCmd->IpAddress;

			printf(
				"    %d.%d.%d.%d -> ",
					pc[0], pc[1], pc[2], pc[3]
				);

			Dump1394UniqueID(pAddCmd->HwAddress.UniqueID);
			printf("\n");
		}
		break;

	case ARP1394_IOCTL_OP_DEL_STATIC_ENTRY:
		{
			PARP1394_IOCTL_DEL_ARP_ENTRY pDelCmd =  &pCmd->DelArpEntry;

			printf(
		"Deleted all entries from IF %d.%d.%d.%d for the following destinations:\n",
				pc[0], pc[1], pc[2], pc[3]
				);

			pc = (PUCHAR)&pDelCmd->IpAddress;

			printf(
				"    %d.%d.%d.%d\n",
					pc[0], pc[1], pc[2], pc[3]
				);
		}
		break;

	case ARP1394_IOCTL_OP_PURGE_ARPCACHE:
		printf(
			"Purged all dynamic arp entries  from IF %d.%d.%d.%d.\n\n",
			pc[0], pc[1], pc[2], pc[3]
			);
		break;

	case ARP1394_IOCTL_OP_GET_PACKET_STATS:
		DumpPacketStats(&pCmd->GetPktStats);
		break;

	case ARP1394_IOCTL_OP_GET_TASK_STATS:
		DumpTaskStats(&pCmd->GetTaskStats);
		break;

	case ARP1394_IOCTL_OP_GET_ARPCACHE_STATS:
		DumpArpStats(&pCmd->GetArpStats);
		break;

	case ARP1394_IOCTL_OP_GET_CALL_STATS:
		DumpCallStats(&pCmd->GetCallStats);
		break;

	case ARP1394_IOCTL_OP_RESET_STATS:
		printf(
			"Reset arp and nic statistics collection on IF %d.%d.%d.%d.\n\n",
			pc[0], pc[1], pc[2], pc[3]
			);
		break;

	case ARP1394_IOCTL_OP_REINIT_INTERFACE:
		printf(
			"Reinited IF %d.%d.%d.%d.\n\n",
			pc[0], pc[1], pc[2], pc[3]
			);
		break;

	case ARP1394_IOCTL_OP_SEND_PACKET:
		printf(
			"Sent %lu-byte packet \"%s\" on IF %d.%d.%d.%d.\n\n",
			pCmd->SendPacket.PacketSize,
			g_szPacketName,
			pc[0], pc[1], pc[2], pc[3]
			);
		break;

	case ARP1394_IOCTL_OP_RECV_PACKET:
		printf(
			"Simulated receive of %lu-byte packet \"%s\" on IF %d.%d.%d.%d.\n\n",
			pCmd->RecvPacket.PacketSize,
			g_szPacketName,
			pc[0], pc[1], pc[2], pc[3]
			);
		break;

	case ARP1394_IOCTL_OP_ETHERNET_START_EMULATION:
		printf(
			"Requested ARP to START Ethernet emulation on adapter \"%s\"\n\n",
			g_szPacketName
			);
        break;

	case ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION:
		printf(
			"Requested ARP to STOP Ethernet emulation on adapter \"%s\"\n\n",
			g_szPacketName
			);
        break;

	case ARP1394_IOCTL_OP_GET_NICINFO:
		DumpNicInfo(&pCmd->IoctlNicInfo);
		break;
		
	case ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE:
		DumpEuidMapInfo(&pCmd->EuidNodeMacInfo);
		break;

	default:
		printf("HAIII!!!\n");
		break;

	}
}



VOID
DumpArpCache(
		PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd
		)
{
	UINT u;
	PARP1394_ARP_ENTRY pEntry = pGetCacheCmd->Entries;
	PUCHAR pc;

#if FAKE_DUMP
	pGetCacheCmd->NumEntriesInArpCache = 30;
	pGetCacheCmd->NumEntriesUsed = 2;
	pGetCacheCmd->Index = 0;
	((PULONG)&(pEntry[0].HwAddress.UniqueID))[0] = 0x12;
	((PULONG)&(pEntry[0].HwAddress.UniqueID))[1] = 0x34;
	pEntry[0].IpAddress = 0x0100000a;
	((PULONG)&(pEntry[1].HwAddress.UniqueID))[0] = 0x56;
	((PULONG)&(pEntry[1].HwAddress.UniqueID))[1] = 0x78;
	pEntry[1].IpAddress = 0x0200000a;
#endif // FAKE_DUMP

	pc = (PUCHAR)&pGetCacheCmd->Hdr.IfIpAddress;
	printf("Arp Cache of IF %d.%d.%d.%d [", pc[0], pc[1], pc[2], pc[3]);

	Dump1394UniqueID(pGetCacheCmd->LocalHwAddress.UniqueID);
	printf(
		" (%04lx:%08lx)]\n",
		pGetCacheCmd->LocalHwAddress.Off_Low,
		pGetCacheCmd->LocalHwAddress.Off_High
		);

	for (u=0;u<pGetCacheCmd->NumEntriesUsed;u++,pEntry++)
	{
		PUCHAR pc = (PUCHAR)&pEntry->IpAddress;
		printf(
			"    %d.%d.%d.%d -> ",
				pc[0], pc[1], pc[2], pc[3]
			);
		Dump1394UniqueID(pEntry->HwAddress.UniqueID);
		printf("\n");
	}
}


VOID
DumpPacketStats(
	PARP1394_IOCTL_GET_PACKET_STATS pStatsCmd
	)
{
	PUCHAR pc;


	pc = (PUCHAR)&pStatsCmd->Hdr.IfIpAddress;
	printf("Packet stats for IF %d.%d.%d.%d\n", pc[0], pc[1], pc[2], pc[3]);

	printf("                 Duration: %d seconds\n", pStatsCmd->StatsDuration);

	printf("              Total sends: %d\n", pStatsCmd->TotSends);
	printf("               Fast sends: %d\n", pStatsCmd->FastSends);
	printf("             Medium sends: %d\n", pStatsCmd->MediumSends);
	printf("               Slow sends: %d\n", pStatsCmd->SlowSends);
	printf("                Backfills: %d\n", pStatsCmd->BackFills);
	printf("          Header buf uses: %d\n", pStatsCmd->HeaderBufUses);
	printf("    Header buf cache hits: %d\n", pStatsCmd->HeaderBufCacheHits);

	//
	// Some recv stats
	//
	printf("           Total receives: %d\n", pStatsCmd->TotRecvs);
	printf("         No-copy receives: %d\n", pStatsCmd->NoCopyRecvs);
	printf("            Copy receives: %d\n", pStatsCmd->CopyRecvs);
	printf("        Resource receives: %d\n", pStatsCmd->ResourceRecvs);

	//
	// Packet counts
	//
	DumpPacketCounts(&pStatsCmd->SendFifoCounts, FALSE, "FIFO sends");
	DumpPacketCounts(&pStatsCmd->RecvFifoCounts, TRUE, "FIFO receives");
	DumpPacketCounts(&pStatsCmd->SendChannelCounts, FALSE, "Channel sends");
	DumpPacketCounts(&pStatsCmd->RecvChannelCounts, TRUE, "Channel receives");
}


VOID
DumpTaskStats(
	PARP1394_IOCTL_GET_TASK_STATS pStatsCmd
	)
{
	PUCHAR pc;

	pc = (PUCHAR)&pStatsCmd->Hdr.IfIpAddress;
	printf("Task stats for IF %d.%d.%d.%d\n", pc[0], pc[1], pc[2], pc[3]);

	printf("                 Duration: %d seconds\n", pStatsCmd->StatsDuration);
	printf("              Total tasks: %d\n", pStatsCmd->TotalTasks);
	printf("            Current tasks: %d\n", pStatsCmd->CurrentTasks);

	//
	// Task times
	//
	{

		int i;
	
		#if 0
		|<=1us   | ...100us |...1ms   |...10ms  | >10ms
		---------+--------+----------+---------+---------+--------
		|10000000| 10000000 |10000000 |10000000 |     100
		|(100000)| (100000) |(100000  |(100000) |    (100)
		#endif // 0
	
		printf("Task times:\n");
		printf("    |<=1ms    |...100ms |...1s    |...10s   | >10s\n");
		printf("    +---------+---------+---------+---------+--------\n");
		printf("   ");
		for (i=0;i<ARP1394_NUM_TASKTIME_SLOTS;i++)
		{
		#if FAKE_DUMP
			pStatsCmd->TimeCounts[i] = i*100000;
		#endif // FAKE_DUMP
			printf(" |%8lu", pStatsCmd->TimeCounts[i]);
		}
		printf("\n");
	}
}


VOID
DumpArpStats(
	PARP1394_IOCTL_GET_ARPCACHE_STATS pStatsCmd
	)
{
	PUCHAR pc;

	pc = (PUCHAR)&pStatsCmd->Hdr.IfIpAddress;
	printf("Arp cache stats for IF %d.%d.%d.%d\n", pc[0], pc[1], pc[2], pc[3]);

	printf("                 Duration: %d seconds\n", pStatsCmd->StatsDuration);
	printf("            Total queries: %d\n", pStatsCmd->TotalQueries);
	printf("       Successful queries: %d\n", pStatsCmd->SuccessfulQueries);
	printf("           Failed queries: %d\n", pStatsCmd->FailedQueries);
	printf("          Total responses: %d\n", pStatsCmd->TotalResponses);
	printf("            Total lookups: %d\n", pStatsCmd->TotalLookups);
	printf("         Links per lookup: %d\n", pStatsCmd->TraverseRatio);
}


VOID
DumpCallStats(
PARP1394_IOCTL_GET_CALL_STATS pStatsCmd
	)
{
	PUCHAR pc;
	pc = (PUCHAR)&pStatsCmd->Hdr.IfIpAddress;
	printf("Call stats for IF %d.%d.%d.%d\n", pc[0], pc[1], pc[2], pc[3]);

	printf(
	 	"         Total send FIFO make-calls: %d\n",
	 	pStatsCmd->TotalSendFifoMakeCalls
	 	);
	printf(
	 	"    Successful send FIFO make-calls: %d\n",
	 	pStatsCmd->SuccessfulSendFifoMakeCalls
	 	);
	printf(
	 	"        Failed send FIFO make-calls: %d\n",
	 	pStatsCmd->FailedSendFifoMakeCalls
	 	);
	printf(
	 	"      Incoming closes on send FIFOs: %d\n",
	 	pStatsCmd->IncomingClosesOnSendFifos
	 	);

	printf(
	 	"           Total channel make-calls: %d\n",
	 	pStatsCmd->TotalChannelMakeCalls
	 	);
	printf(
	 	"      Successful channel make-calls: %d\n",
	 	pStatsCmd->SuccessfulChannelMakeCalls
	 	);
	printf(
	 	"          Failed channel make-calls: %d\n",
	 	pStatsCmd->FailedChannelMakeCalls
	 	);
	printf(
	 	"        Incoming closes on channels: %d\n",
	 	pStatsCmd->IncomingClosesOnChannels
	 	);
}


VOID
DumpPacketCounts(
	PARP1394_PACKET_COUNTS pPktCounts,
	BOOL				  fRecv,
	char *szDescription
	)
{
	int i,j;
	char *rgTitles[ARP1394_NUM_PKTSIZE_SLOTS+1] = 
	{
	"   <= 128",
	"  129-256",
	"  257-1K ",
	"   1K-2K ",
	"    > 2K ",
	"         "
	};

#if 0
size\time|<=1us   | ...100us |...1ms   |...10ms  | >10ms
---------+--------+----------+---------+---------+--------
  <= 128 |10000000| 10000000 |10000000 |10000000 |     100
         |(100000)| (100000) |(100000  |(100000) |    (100)
  ...256 |10000000| 10000000 |10000000 |10000000 |10000000
         |(100000)| (100000) |(100000  |(100000) |    (100)
   ...1K |10000000| 10000000 |10000000 |10000000 |10000000
         |(100000)| (100000) |(100000  |(100000) |    (100)
   ...2K |10000000| 10000000 |10000000 |10000000 |10000000
         |(100000)| (100000) |(100000  |(100000) |    (100)
    > 2K |10000000| 10000000 |10000000 |10000000 |10000000
         |(100000)| (100000) |(100000  |(100000) |    (100)
#endif // 0

	printf("\n%s packet counts:\n", szDescription);

	if (fRecv)
	{
		printf(" size     |         \n");
		printf(" ---------+---------\n");
	}
	else
	{
		printf(" size\\time|<=100us  |...1ms   |...10ms  |...100ms | >100ms\n");
		printf(" ---------+---------+---------+---------+---------+--------\n");
	}

	for (i=0;i<ARP1394_NUM_PKTSIZE_SLOTS;i++)
	{
		UINT u;
		UINT GoodCounts=0;
		UINT BadCounts=0;

		//
		// Compute total goodcounts and badcounts for this size bin.
		//
		for (j=0;j<ARP1394_NUM_PKTTIME_SLOTS;j++)
		{
			GoodCounts += pPktCounts->GoodCounts[i][j];
			BadCounts  += pPktCounts->BadCounts[i][j];
		}

		if (GoodCounts ==0 && BadCounts==0)
		{
			continue;	// No packets in this size bin.
		}

		printf("%s", rgTitles[i]);
		for (j=0;j<ARP1394_NUM_PKTTIME_SLOTS;j++)
		{
			u =  (fRecv)? GoodCounts : pPktCounts->GoodCounts[i][j];

			if (u)
			{
				printf(" |%8lu", u);
			}
			else
			{
				printf(" |        ");
			}
			if (fRecv) break;
		}

		printf("\n%s",rgTitles[ARP1394_NUM_PKTSIZE_SLOTS]);
		for (j=0;j<ARP1394_NUM_PKTTIME_SLOTS;j++)
		{
			u =  (fRecv)? BadCounts : pPktCounts->BadCounts[i][j];
			if (u)
			{
				printf(" |(%6lu)", u);
			}
			else
			{
				printf(" |        ");
			}
			if (fRecv) break;
		}
		printf("\n");
	}
}

HANDLE
OpenDevice(
	CHAR	*pDeviceName
)
{
	DWORD	DesiredAccess;
	DWORD	ShareMode;
	LPSECURITY_ATTRIBUTES	lpSecurityAttributes = NULL;

	DWORD	CreationDistribution;
	DWORD	FlagsAndAttributes;
	HANDLE	TemplateFile;
	HANDLE	Handle;

	DesiredAccess = GENERIC_READ|GENERIC_WRITE;
	ShareMode = 0;
	CreationDistribution = OPEN_EXISTING;
	FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
	TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

#if DUMMY

	Handle = (HANDLE) 0x1;

#else // !DUMMY

	Handle = CreateFile(
				pDeviceName,
				DesiredAccess,
				ShareMode,
				lpSecurityAttributes,
				CreationDistribution,
				FlagsAndAttributes,
				TemplateFile
			);
#endif // !DUMMY

	return (Handle);
}

VOID
CloseDevice(
	HANDLE		DeviceHandle
)
{
#if !DUMMY
	CloseHandle(DeviceHandle);
#endif
}

VOID Dump1394UniqueID(UINT64 UniqueID)
{
	unsigned char *pc = (char *) &UniqueID;

	printf(
		"%02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx",
		pc[4], pc[5], pc[6], pc[7],
		pc[0], pc[1], pc[2], pc[3]
		);
}

VOID DumpENetAddress(ENetAddr ENetAddress)
{
	unsigned char *pc = (char *) &ENetAddress;

	printf(
		"%02lx-%02lx-%02lx-%02lx-%02lx-%02lx",
		pc[0], pc[1], pc[2], pc[3],pc[4], pc[5]);
}

#if DUMMY

BOOL
nicFillBusInfo(
    IN OUT  PNIC1394_BUSINFO pBi
    );

BOOL
nicFillChannelInfo(
    IN OUT  PNIC1394_CHANNELINFO pCi
    );

BOOL
nicFillRemoteNodeInfo(
    IN OUT  PNIC1394_REMOTENODEINFO pRni
    );


BOOL
nicFillNicInfo (
	PNIC1394_NICINFO pInNicInfo,
	PNIC1394_NICINFO pOutNicInfo
	)
{
	BOOL Ret = FALSE;

#if 0
		pBi->ChannelMapLow  	= (0x1<<1) | (0x1<<3) | (0x1<<5) | (0x1<<7);
		pBi->ChannelMapHigh  	= (0x1<<8) | (0x1<<10) | (0x1<<12) | (0x1<<14);
		pBi->NumBusResets		= 12345;
		pBi->SecondsSinceLastBusReset = 3600;
		pBi->NumRemoteNodes		= 3;

		pLi = &pBi->LocalNodeInfo;
		pLi->UniqueID 		 = 0xabcd;
		pLi->NodeAddress 	 = 	  0x31;
		pLi->MaxRecvBlockSize=0x32;
		pLi->MaxRecvSpeed	 =0x33;

		pRi = pBi->RemoteNodeInfo;

		u = pBi->NumRemoteNodes;
		for (; u; u--, pRi++)
		{
			if (u==1) 		pRi->Flags = ARP1394_IOCTL_REMOTEFLAGS_ACTIVE;
			else if (u==2)	pRi->Flags = ARP1394_IOCTL_REMOTEFLAGS_LOADING;
			else 			pRi->Flags  = ARP1394_IOCTL_REMOTEFLAGS_UNLOADING;
			pRi->UniqueID 			= u;
			pRi->NodeAddress 		= u+1;
			pRi->MaxRecvBlockSize	=u+2;
			pRi->MaxRecvSpeed		=u+3;
			pRi->MaxSpeedBetweenNodes=u+4;
		}
#endif // 0

	do
	{
		//
		// First check internal version
		//
		if (pInNicInfo->Hdr.Version != NIC1394_NICINFO_VERSION)
		{
			printf("DummyIoctl:  NICINFO.Version mismatch. Want %lu got %lu\n",
						NIC1394_NICINFO_VERSION,
						pInNicInfo->Hdr.Version
						);
			break;
		}

		//
		// Struct-copy the old to the new. It's wasteful, but we don't want
		// to dig into how much of the in buffer contains valid data.
		//
		*pOutNicInfo = *pInNicInfo;

		//
		// Rest is op-specific
		//
		switch(pOutNicInfo->Hdr.Op)
		{

		case NIC1394_NICINFO_OP_BUSINFO:
			Ret = nicFillBusInfo(&pOutNicInfo->BusInfo);
			break;

		case NIC1394_NICINFO_OP_REMOTENODEINFO:
			Ret = nicFillRemoteNodeInfo(&pOutNicInfo->RemoteNodeInfo);
			break;

		case NIC1394_NICINFO_OP_CHANNELINFO:
			Ret = nicFillChannelInfo(&pOutNicInfo->ChannelInfo);
			break;

		case NIC1394_NICINFO_OP_RESETSTATS:
			printf("DummyIoctl: RESETTING NIC STATS!\n");
			Ret = TRUE;
			break;

		default:
			printf( "DummyIoctl:  NICINFO.Op (%lu) is unknown.\n",
						pInNicInfo->Hdr.Op
						);
			break;
		}

	} while (FALSE);

	return Ret;
}


NIC1394_LOCAL_NODE_INFO
BogusLocalNodeInfo =
{
	456,	//UniqueID
	457,	//BusGeneration
	4,		//NodeAddress
	0,		//Reserved
	2,		//MaxRecvBlockSize
	3,		//MaxRecvSpeed
};

NIC1394_PACKET_STATS
BogusPktStats = 
{
	345,	// TotNdisPackets
	346,	// NdisPacketsFailures
	347,	// TotBusPackets
	348	// BusPacketFailures
};

BOOL
nicFillBusInfo(
	IN	OUT	PNIC1394_BUSINFO pBi
	)
{
	//
	// Fill with Dummy data
	//
	pBi->NumBusResets = 1234;
	pBi->SecondsSinceBusReset = 1235;
	pBi->Flags =  NIC1394_BUSINFO_LOCAL_IS_IRM;
	pBi->NumOutstandingIrps = 1236;

	pBi->LocalNodeInfo = BogusLocalNodeInfo;

	//
	// CHANNEL RELATED INFORMATION
	//
	pBi->Channel.BusMap = 0x123;
	pBi->Channel.ActiveChannelMap = 0x456;

	pBi->Channel.Bcr = 0x790;
	pBi->Channel.BcSendPktStats = BogusPktStats;
	pBi->Channel.BcRecvPktStats = BogusPktStats;
	
	pBi->Channel.SendPktStats = BogusPktStats;
	pBi->Channel.RecvPktStats = BogusPktStats;	

	//
	// FIFO RELATED INFORMATION.
	//
	pBi->Fifo.Recv_Off_Low = 0x1bc;
	pBi->Fifo.Recv_Off_High = 0xdef;

	pBi->Fifo.RecvPktStats = BogusPktStats;
	pBi->Fifo.SendPktStats = BogusPktStats;

	pBi->Fifo.NumFreeRecvBuffers  = 33;
	pBi->Fifo.MinFreeRecvBuffers  = 34;

	pBi->Fifo.NumOutstandingReassemblies = 8;
	pBi->Fifo.MaxOutstandingReassemblies = 9;

	strcpy(pBi->Private.FormatA, "    0x%08lx Gadzooks\n");
	pBi->Private.A0 = 0x99;
	//
	// Information about remote nodes. More information about each of these nodes
	// may be queried using *OP_REMOTE_NODEINFO
	//
	pBi->NumRemoteNodes = 1;
	pBi->RemoteNodeUniqueIDS[0] = 0x1234;
	
	return TRUE;
}

BOOL
nicFillChannelInfo(
	IN OUT	PNIC1394_CHANNELINFO pCi
	)
{
	return TRUE;
}

BOOL
nicFillRemoteNodeInfo(
	IN OUT	PNIC1394_REMOTENODEINFO pRni
	)
{
	pRni->UniqueID = 0xabc;
	pRni->NodeAddress = 2;
	pRni->EffectiveMaxBlockSize = 3;
	pRni->MaxRec = 4;
	pRni->MaxSpeedBetweenNodes = 5;
	pRni->Flags = NIC1394_REMOTEINFO_ACTIVE;

	pRni->SendFifoPktStats = BogusPktStats;
	pRni->RecvFifoPktStats = BogusPktStats;
	pRni->RecvChannelPktStats = BogusPktStats;

	return TRUE;
}



BOOL
DummyDeviceIoControl(
	HANDLE		DeviceHandle,
	UINT		Ioctl,
  	PARP1394_IOCTL_COMMAND pInCmd,
  	UINT		Size,
  	PARP1394_IOCTL_COMMAND pOutCmd,
  	UINT		OutSize,
  	PUINT		pBytesReturned,
  	PVOID		Blah
  	)
{
	BOOL fRet = FALSE;

	if (Ioctl !=  ARP_IOCTL_CLIENT_OPERATION) return FALSE;


	switch(pInCmd->Hdr.Op)
	{

	default:
	printf ("UNKNOWN IOCTL!\n");
	fRet = TRUE;
	break;

	case  ARP1394_IOCTL_OP_RESET_STATS:
	printf ("RESET ARP STATS!\n");
	break;

	case ARP1394_IOCTL_OP_SEND_PACKET:
	printf ("DUMMY IOCTL: Prrocessing ioctl SEND packet.\n");
	fRet = TRUE;
	break;

	case ARP1394_IOCTL_OP_RECV_PACKET:
	printf ("DUMMY IOCTL: Prrocessing ioctl RECV packet.\n");
	fRet = TRUE;
	break;

	case ARP1394_IOCTL_OP_GET_NICINFO:
	{
		fRet =  nicFillNicInfo (
					&pInCmd->IoctlNicInfo.Info,
					&pOutCmd->IoctlNicInfo.Info
					);
	}
	break;

	}

	return fRet;
}
#endif // DUMMY

VOID
DumpNicInfo(
	ARP1394_IOCTL_NICINFO *pINi
	)
{
	PNIC1394_NICINFO pNi =  &pINi->Info;
	unsigned char *pc = (PUCHAR)&pINi->Hdr.IfIpAddress;

	do
	{
		//
		// First check internal version
		//
		if (pNi->Hdr.Version != NIC1394_NICINFO_VERSION)
		{
			printf("  NICINFO.Version mismatch. Want %lu got %lu\n",
						NIC1394_NICINFO_VERSION,
						pNi->Hdr.Version
						);
			break;
		}

		//
		// Rest is op-specific
		//
		switch(pNi->Hdr.Op)
		{

		case NIC1394_NICINFO_OP_BUSINFO:
			printf("\nUnexpected commande!\n"); // We handle this command earlier.
			break;

		case NIC1394_NICINFO_OP_REMOTENODEINFO:
			printf("\nNode information for node %lu on IF %d.%d.%d.%d\n\n",
					pNi->RemoteNodeInfo.NodeAddress,
					pc[0], pc[1], pc[2], pc[3]);
			DumpRemoteNodeInfo(&pNi->RemoteNodeInfo);
			break;

		case NIC1394_NICINFO_OP_CHANNELINFO:
			printf("\nChannel information for channel %lu on IF %d.%d.%d.%d\n\n",
					pNi->ChannelInfo.Channel,
					pc[0], pc[1], pc[2], pc[3]);
			DumpChannelInfo(&pNi->ChannelInfo);
			break;

		case NIC1394_NICINFO_OP_RESETSTATS:
			printf("\nReset NIC stats for IF %d.%d.%d.%d\n\n",
					pc[0], pc[1], pc[2], pc[3]);
			break;

		default:
			printf( "  NICINFO.Op (%lu) is unknown.\n",
						pNi->Hdr.Op
						);
			break;
		}

	} while (FALSE);

}


#if OBSOLETE
VOID
DumpBusInfo(
    PNIC1394_BUSINFO pBi
    )
{
	PUCHAR pc;

	printf(
"   Generation: %02lu; Bus resets: %02lu; Last reset: %lu seconds ago.",
		pBi->LocalNodeInfo.BusGeneration,
		pBi->NumBusResets,
		pBi->SecondsSinceBusReset
		);

	printf(
"   Outstanding IRPs: %02lu;",
		pBi->NumOutstandingIrps
		);
	//
	// Flags
	//
	if (pBi->Flags & NIC1394_BUSINFO_LOCAL_IS_IRM)
	{
		printf(
"  Flags: IRM\n"
			);
	}
	else
	{
		printf(
"  Flags: <none>\n"
			);
	}

	//
	// CHANNEL INFO
	//
	printf("\n   Channel information:\n");

	arpDumpChannelMap("           Channels in bus map:", pBi->Channel.BusMap);
	arpDumpChannelMap("       Locally active channels:", pBi->Channel.ActiveChannelMap);


	printf(
"       BCR: 0x%08lx\n", 
		pBi->Channel.Bcr
		);
		
	arpDumpPktStats("        BC Sends:", &pBi->Channel.BcSendPktStats);
	arpDumpPktStats("        BC Recvs:", &pBi->Channel.BcRecvPktStats);

	//
	// RECV FIFO
	//
	printf("\n   Recv FIFO information:\n");
	printf(
		"        Addr: 0x%lx:0x%lx; Free recv bufs:%lu (%lu max)\n",
		pBi->Fifo.Recv_Off_High,
		pBi->Fifo.Recv_Off_Low,
		pBi->Fifo.NumFreeRecvBuffers,
		pBi->Fifo.MinFreeRecvBuffers
		);
	printf(
		"        Recv reassemblies: %lu outstanding; %lu max outstanding; %lu aborted\n",
		pBi->Fifo.NumOutstandingReassemblies,
		pBi->Fifo.MaxOutstandingReassemblies,
		pBi->Fifo.NumAbortedReassemblies
		);
	
	//
	// Private information
	//
	if (*pBi->Private.FormatA || *pBi->Private.FormatB)
	{
		printf("\n   Private information:\n");

		if  (*pBi->Private.FormatA)
		{
			printf(
				pBi->Private.FormatA,
				pBi->Private.A0,
				pBi->Private.A1,
				pBi->Private.A2,
				pBi->Private.A3
				);
		}

		if  (*pBi->Private.FormatB)
		{
			printf(
				pBi->Private.FormatB,
				pBi->Private.B0,
				pBi->Private.B1,
				pBi->Private.B2,
				pBi->Private.B3
				);
		}
	}

	{

		UINT64 *pUID;
		PNIC1394_LOCAL_NODE_INFO pLi;

		UINT u = pBi->NumRemoteNodes;
		 
		printf("\n   Node Information:\n");
		
			printf(
"     GUID                    Node Size Speed SpeedTo State\n"
				);

		pLi = &pBi->LocalNodeInfo;
		printf("    *");
		Dump1394UniqueID(pLi->UniqueID);
		printf(
			"  %02lx   %02lx   %02lx           %s\n",
			pLi->NodeAddress,
			pLi->MaxRecvBlockSize,
			pLi->MaxRecvSpeed,
			"local"
			);

		pUID = pBi->RemoteNodeUniqueIDS;
		for (; u; u--, pUID++) // pRi++
		{
#if 0
		    ARP1394_IOCTL_REMOTE_NODE_INFO Ri;
		    PARP1394_IOCTL_REMOTE_NODE_INFO pRi = NULL;
			char *szState = "unknown";

			printf("     ");
			Dump1394UniqueID(*pUID);
            
            if (GetRemoteNodeInfo(
            
            if (pRi!=NULL)
            {

                if (pRi->Flags & ARP1394_IOCTL_REMOTEFLAGS_ACTIVE)
                {
                    szState = "active";
                }
                if (pRi->Flags & ARP1394_IOCTL_REMOTEFLAGS_LOADING)
                {
                    szState = "loading";
                }
                if (pRi->Flags & ARP1394_IOCTL_REMOTEFLAGS_UNLOADING)
                {
                    szState = "unloading";
                }
                printf(
                    "  %02lx   %02lx   %02lx    %02lx     %s\n",
                    pRi->NodeAddress,
                    pRi->MaxRecvBlockSize,
                    pRi->MaxRecvSpeed,
                    pRi->MaxSpeedBetweenNodes,
                    szState
                    );
            }
			printf("\n");
#endif // 0
		}
	}

}
#endif // OBSOLETE

VOID
DumpChannelInfo(
    PNIC1394_CHANNELINFO pCi
    )
{
	printf("DUMP OF CHANNELINFO\n");
}

VOID
DumpRemoteNodeInfo(
    PNIC1394_REMOTENODEINFO pRni
    )
{
	printf("DUMP OF REMOTENODEINFO\n");
}


VOID
arpDumpChannelMap(
		char *szPrefix,
		UINT64 Map
		)
{
	UINT ChannelMapLow = (UINT) (Map & 0xffffffff);
	UINT ChannelMapHigh = (UINT) (Map >> 32);


	if (ChannelMapLow==0 && ChannelMapHigh==0)
	{
		printf ("%s <none>\n", szPrefix);
	}
	else
	{
		UINT c;
		#define Bit(_Val, _Bit) (((_Val) & (1<<_Bit))!=0)

		printf (szPrefix);
		// printf("\n    "); Dump1394UniqueID(Map); printf("\n    ");
		for (c=0;c<32;c++)
		{
			if (Bit(ChannelMapLow, c))
			{
				printf (" %lu", c);
			}
		}
		for (c=0;c<32;c++)
		{
			if (Bit(ChannelMapHigh, c))
			{
				printf (" %lu", c+32);
			}
		}
		printf ("\n");
	}
}

VOID
arpDumpPktStats(
		char *szPrefix,
		NIC1394_PACKET_STATS *pPs
		)
{
	printf("%s ndis: %06lu total, %05lu failed; bus: %06lu total, %05lu failed\n",
		szPrefix,
		pPs->TotNdisPackets,
		pPs->NdisPacketsFailures,
		pPs->TotBusPackets,
		pPs->BusPacketFailures
		);
}

VOID
DoBusInfoCmd(
    HANDLE DeviceHandle,
  	PARP1394_IOCTL_COMMAND pCmd
  	)
{
    PNIC1394_NICINFO pNi = &pCmd->IoctlNicInfo.Info;
    PNIC1394_BUSINFO pBi = &pNi->BusInfo;
	unsigned char *pc = (PUCHAR)&pCmd->Hdr.IfIpAddress;
    BOOL fRet;
	DWORD 	BytesReturned;

    if (pCmd->Hdr.Op != ARP1394_IOCTL_OP_GET_NICINFO
        || pNi->Hdr.Op !=  NIC1394_NICINFO_OP_BUSINFO)
    {
        printf("DoBusInfoCmd: unexpected pCmd!\n");
        return;
    }

    printf("\nBus information for IF %d.%d.%d.%d\n\n", pc[0], pc[1], pc[2], pc[3]);

    // Submit NICINFO.BUSINFO Ioctl
    //
    fRet =	DeviceIoControl(
                    DeviceHandle,
                    ARP_IOCTL_CLIENT_OPERATION,
                    pCmd,
                    sizeof(*pCmd),
                    pCmd,
                    sizeof(*pCmd),
                    &BytesReturned,
                    NULL
                    );

    //  
    //
    if (!fRet)
    {
        printf("Request failed with error code 0x%08lx\n", GetLastError());
        return;
    }


	printf(
"   Generation: %02lu; Bus resets: %02lu; Last reset: %lu seconds ago.",
		pBi->LocalNodeInfo.BusGeneration,
		pBi->NumBusResets,
		pBi->SecondsSinceBusReset
		);

#if 0
	printf(
"   Outstanding IRPs: %02lu;",
		pBi->NumOutstandingIrps
		);
#endif // 0

	//
	// Flags
	//
	if (pBi->Flags & NIC1394_BUSINFO_LOCAL_IS_IRM)
	{
		printf(
"  Flags: IRM\n"
			);
	}
	else
	{
		printf(
"  Flags: <none>\n"
			);
	}

	//
	// CHANNEL INFO
	//
	printf("\n   Channel information:\n");

	arpDumpChannelMap("           Channels in bus map:", pBi->Channel.BusMap);
	arpDumpChannelMap("       Locally active channels:", pBi->Channel.ActiveChannelMap);


	printf(
"       BCR: 0x%08lx\n", 
		pBi->Channel.Bcr
		);
		
	arpDumpPktStats("        BC Sends:", &pBi->Channel.BcSendPktStats);
	arpDumpPktStats("        BC Recvs:", &pBi->Channel.BcRecvPktStats);

	//
	// RECV FIFO
	//
	printf("\n   FIFO information:\n");
	printf(
		"        Addr: 0x%lx:0x%lx; Free recv bufs:%lu (%lu max)\n",
		pBi->Fifo.Recv_Off_High,
		pBi->Fifo.Recv_Off_Low,
		pBi->Fifo.NumFreeRecvBuffers,
		pBi->Fifo.MinFreeRecvBuffers
		);
	printf(
		"        Recv reassemblies: %lu outstanding; %lu max outstanding; %lu aborted\n",
		pBi->Fifo.NumOutstandingReassemblies,
		pBi->Fifo.MaxOutstandingReassemblies,
		pBi->Fifo.NumAbortedReassemblies
		);
	
	arpDumpPktStats("        FIFO Sends:", &pBi->Fifo.SendPktStats);
	arpDumpPktStats("        FIFO Recvs:", &pBi->Fifo.RecvPktStats);

	//
	// Private information
	//
	if (*pBi->Private.FormatA || *pBi->Private.FormatB)
	{
		printf("\n   Private information:\n");

		if  (*pBi->Private.FormatA)
		{
			printf(
				pBi->Private.FormatA,
				pBi->Private.A0,
				pBi->Private.A1,
				pBi->Private.A2,
				pBi->Private.A3
				);
		}

		if  (*pBi->Private.FormatB)
		{
			printf(
				pBi->Private.FormatB,
				pBi->Private.B0,
				pBi->Private.B1,
				pBi->Private.B2,
				pBi->Private.B3
				);
		}
	}

	{

		UINT64 *pUID;
		PNIC1394_LOCAL_NODE_INFO pLi;

		UINT u = pBi->NumRemoteNodes;
		 
		printf("\n   Node Information:\n");
		
			printf(
"     GUID                    Node Maxrec SpeedTo State\n"
				);

		pLi = &pBi->LocalNodeInfo;
		printf("    *");
		Dump1394UniqueID(pLi->UniqueID);
		printf(
			"  %02lx    %02lx   %02lx     %s\n",
			pLi->NodeAddress,
			pLi->MaxRecvBlockSize,
			pLi->MaxRecvSpeed,
			"local"
			);

		pUID = pBi->RemoteNodeUniqueIDS;
		for (; u; u--, pUID++) // pRi++
		{
			char *szState = "unknown";

			printf("     ");
			Dump1394UniqueID(*pUID);
            
            {
                ARP1394_IOCTL_COMMAND Cmd = *pCmd;
                PNIC1394_NICINFO	pNi = &Cmd.IoctlNicInfo.Info;
                Cmd.Hdr.Op 		= ARP1394_IOCTL_OP_GET_NICINFO;
                pNi->Hdr.Version 	= NIC1394_NICINFO_VERSION;
                pNi->Hdr.Op 		=  NIC1394_NICINFO_OP_REMOTENODEINFO;
                pNi->RemoteNodeInfo.UniqueID = *pUID;
                pNi->RemoteNodeInfo.NodeAddress = 0;
    
                // Submit Ioctl
                //
                fRet =	DeviceIoControl(
                                DeviceHandle,
                                ARP_IOCTL_CLIENT_OPERATION,
                                &Cmd,
                                sizeof(Cmd),
                                &Cmd,
                                sizeof(Cmd),
                                &BytesReturned,
                                NULL
                                );
                if (fRet == FALSE)
                {
                    printf ("  <error reading node info>\n");
                }
                else
                {
                    PNIC1394_REMOTENODEINFO pRi =  &pNi->RemoteNodeInfo;

                    if (pRi->Flags &  NIC1394_REMOTEINFO_ACTIVE)
                    {
                        szState = "active";
                    }
                    if (pRi->Flags &  NIC1394_REMOTEINFO_LOADING)
                    {
                        szState = "loading";
                    }
                    if (pRi->Flags &  NIC1394_REMOTEINFO_UNLOADING)
                    {
                        szState = "unloading";
                    }
                    printf(
			            "  %02lx    %02lx   %02lx     %s\n",
                        pRi->NodeAddress,
                        pRi->MaxRec,
                        pRi->MaxSpeedBetweenNodes,
                        szState
                        );
                }
		    }
		}
    }
}


VOID
DumpEuidMapInfo(
	PARP1394_IOCTL_EUID_NODE_MAC_INFO pEuidInfo
	)
{
	PEUID_TOPOLOGY pMap = &pEuidInfo->Map;
	UINT i =0;

	printf ("Number of Remote Nodes = %x\n",pMap->NumberOfRemoteNodes);

	if (pMap->NumberOfRemoteNodes ==0)
	{
		return;
	}
	printf ("Table :-\n");
		
	// iterate through the number of remote nodes and print them out.
	printf ("Node    UniqueId                  MacAddress\n");

	while (i<pMap->NumberOfRemoteNodes)
	{
		// Skip this node if it is an invalid node
		if (pMap->Node[i].Euid ==0)
		{
			continue;
		}

		printf ("%x       ",i);
		Dump1394UniqueID(pMap->Node[i].Euid);
		printf("   ");
		DumpENetAddress (pMap->Node[i].ENetAddress);
		printf("\n");
		i++;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\nic\sys\send.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// send.h
//
// IEEE1394 mini-port/call-manager driver
//
// Send.h - Mini-port Send routines
//
// 06/20/1999 ADube Created, 
//

//
//  A Send follows this simple algorithm:
//  Copy incoming data to local buffers
//  Insert Fragment Headers if necessary
//  Create an Mdl for the local copy
//  Store the IRB and VC in the ndispacket
//  Use the ndispacket as context in the irp's completion routine
//  



NDIS_STATUS
AsyncStreamSendPacketsHandler (
    IN PVCCB pChannelVc,
    IN PNDIS_PACKET pPacket 
    );


NDIS_STATUS
AsyncWriteSendPacketsHandler(
    IN VCCB *pVC,
    IN NDIS_PACKET *Packet 
    );


NDIS_STATUS
nicCopyNdisBufferChainToBuffer(
    IN     PNDIS_BUFFER pInMdl,
    IN OUT PVOID        pLocalBuffer, 
    IN     UINT         Length 
    );


NDIS_STATUS
nicFreeIrb(
    IN PIRB pIrb 
    );


NDIS_STATUS
nicFreeIrp(
    IN PIRP pIrp 
    );


NDIS_STATUS
nicFreeLocalBuffer(
    IN UINT Length,
    IN PVOID pLocalBuffer 
    );


NDIS_STATUS
nicGetIrb(
    OUT PIRB *ppIrb 
    );


NDIS_STATUS
nicGetIrp(
    IN  PDEVICE_OBJECT pPdo,
    OUT PIRP *ppIrp 
    );


NDIS_STATUS
nicFreeMdl( 
    IN  PMDL pMdl 
    );


NDIS_STATUS
nicFreePrivateIrb(
    PNDIS1394_IRB pIrb
    );


NDIS_STATUS
nicGetPrivateIrb(
    IN PADAPTERCB pAdapter OPTIONAL,
    IN PREMOTE_NODE pRemoteNode OPTIONAL,
    IN PVCCB pVc,
    IN PVOID pContext,
    OUT PNDIS1394_IRB *ppIrb 
    );


NDIS_STATUS
nicGetLocalBuffer(
    IN  ULONG Length,
    OUT PVOID *ppLocalBuffer 
    );

PVOID
nicGetLookasideBuffer(
    IN  PNIC_NPAGED_LOOKASIDE_LIST pLookasideList
    );


NDIS_STATUS
nicGetMdl(
    IN UINT     Length,
    IN PVOID    LocalBuffer,
    OUT PMDL    *ppMyMdl
    );


NDIS_STATUS
nicGetMdlToTransmit(
    IN PNDIS_PACKET     pPacket, 
    OUT PMDL            *ppMyMdl 
    );


NDIS_STATUS
DummySendPacketsHandler(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    );

VOID
nicSendFailureInvalidGeneration(
    PVCCB pVc
    );
    

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------


NTSTATUS
AsyncStreamDummySendComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pMyIrp,
    IN PVOID           Context   
    );
    

NTSTATUS
AsyncWriteStreamSendComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pMyIrp,
    IN PVOID           Context   
    );


NTSTATUS
AsyncStreamSendComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pMyIrp,
    IN PVOID            Context 
    );


NDIS_STATUS
nicFreeAsyncWritePacketDataStructures(
    IN PVCCB pVc,
    IN PIRP  pIrp               OPTIONAL,
    IN PVOID pLocalBuffer       OPTIONAL,
    IN PNIC_NPAGED_LOOKASIDE_LIST   pLookasideList   OPTIONAL
  );


NDIS_STATUS
nicEthernetVcSend(
    IN PVCCB        pVc,
    IN PNDIS_PACKET  pPacket 
    );





VOID
nicInitAsyncStreamIrb(
    IN     PCHANNEL_VCCB pChannelVc, 
    IN     PMDL pMdl, 
    IN OUT PIRB pIrb
    );


VOID
nicInitAsyncWriteIrb(
    IN     PSENDFIFO_VCCB pVc, 
    IN     PMDL pMyMdl, 
    IN OUT PIRB pMyIrb
    );




NDIS_STATUS
nicInsertGaspHeader (
    IN PADAPTERCB pAdapter,
    IN PNDIS_PACKET pNdisPacket
    );


NDIS_STATUS
nicGetGaspHeader (
    IN OUT PNDIS_BUFFER *ppNdisBuffer
    );



VOID
nicFreeGaspHeader (
    IN PNDIS_BUFFER pGaspNdisBuffer
    );

VOID
nicFreeToNPagedLookasideList (
    IN PNIC_NPAGED_LOOKASIDE_LIST pLookasideList,
    IN PVOID    pBuffer
    );
    
VOID
nicMakeGaspHeader (
    IN PADAPTERCB pAdapter,
    IN PGASP_HEADER pGaspHeader
    );

NDIS_STATUS
nicCopyOneFragment (
    PFRAGMENTATION_STRUCTURE pFragment
    );

VOID
nicCopyUnfragmentedHeader ( 
    IN PNIC1394_UNFRAGMENTED_HEADER pDestUnfragmentedHeader,
    IN PVOID pSrcUnfragmentedHeader
    );
    




NDIS_STATUS
nicFirstFragmentInitialization (
    IN PNDIS_BUFFER pStartNdisBuffer,
    IN ULONG DatagramLabelLong,
    OUT PFRAGMENTATION_STRUCTURE  pFragment          
    );


VOID
nicInitializeLookasideListHeader (
    IN OUT PLOOKASIDE_BUFFER_HEADER pHeader,
    IN PNDIS_PACKET pNdisPacket,
    IN PVCCB pVc,
    IN PNDIS_BUFFER pCurrNdisBuffer,
    IN BUS_OPERATION AsyncOp,
    IN PADAPTERCB pAdapter
    );
    

NDIS_STATUS
nicCopyNdisPacketToUnfragmentedBuffer(
    IN PNIC_NPAGED_LOOKASIDE_LIST  pLookasideList,
    IN PNDIS_BUFFER pStartNdisBuffer,
    IN ULONG PacketLength,
    IN BUS_OPERATION AsyncOp,
    IN PGASP_HEADER pGaspHeader,
    OUT PVOID*  ppStartFragmentAddress,
    OUT PVOID *ppLookasideListBuffer
    );

    

VOID
nicAddFragmentHeader (
    IN PVOID pStartFragmentData, 
    IN PFRAGMENTATION_STRUCTURE pFragmentStructure,
    IN ULONG BufferSize
    );




NDIS_STATUS
nicFreeAsyncStreamPacketDataStructures(
    IN PVCCB pVc,
    IN PIRP  pIrp               OPTIONAL,
    IN PVOID pLocalBuffer       OPTIONAL,
    IN PNIC_NPAGED_LOOKASIDE_LIST   pLookasideList   OPTIONAL
  );


VOID
nicGetGenerationWorkItem(
    NDIS_WORK_ITEM* pGetGenerationWorkItem,
    IN PVOID Context 
    );

VOID
nicMpCoSendComplete (
    NDIS_STATUS NdisStatus,
    PVCCB pVc,
    PNDIS_PACKET pPacket
    );



VOID
nicSendTimer (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );



UINT
nicNumFragmentsNeeded (
    UINT PacketLength ,
    UINT MaxPayload,
    UINT FragmentOverhead
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\tools\ipfwadm\ini.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

	ini.c

Abstract:

	 IEEE1394 ARP Admin Utility.

	Usage:

		a13adm 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	04-10-1999	Created

--*/

#include "common.h"

BOOL
GetBinaryData(
	TCHAR *tszPathName,
	TCHAR *tszSection,
	TCHAR *tszKey,
	UCHAR *pchData,
	UINT  cbMaxData,
	UINT *pcbDataSize
	)
{
	BOOL fRet = FALSE;
	INFCONTEXT InfCtxt;
	INFCONTEXT LineCtxt;
	HINF hInf = NULL;
	UINT uLine = 0;

	do
	{

    	hInf = SetupOpenInfFile(tszPathName, NULL, INF_STYLE_WIN4, &uLine);

		if (hInf == INVALID_HANDLE_VALUE)
		{
			UINT Error = GetLastError();

			if (Error == 0xe0000100)
			{
				printf( "\nBadly formatted ini file %s\n", tszPathName);
				printf( "Make sure the file contains the following section:\n"
						"    [Version]\n"
						"    Signature=\"$CHICAGO$\"\n\n"
						);
			}
			else if (Error == 0x2)
			{
				printf("\nCould not find INI file %s\n", tszPathName);
			}
			hInf = NULL;
			break;
		}

		fRet = SetupFindFirstLine(
				hInf,
				tszSection,
				tszKey,
				&LineCtxt
				);

		if (!fRet)
		{
			printf( "\nError 0x%08lx finding key \"%s\" in section \"%s\"\n        in file %s\n",
					 GetLastError(), tszKey, tszSection, tszPathName);
			break;
		}

		fRet = SetupGetBinaryField(
				&LineCtxt,
				1,
				pchData,
				cbMaxData,
				pcbDataSize
				);

		if (!fRet)
		{
			#if 0
			printf(
				TEXT("SetupGetBinaryField fails. Err = %08lu\n"),
				GetLastError()
				);
			#endif // 0
			printf( "\nError 0x%08lx reading data from key \"%s\" in section \"%s\"\n        in file %s\n",
					 GetLastError(), tszKey, tszSection, tszPathName);
			break;
		}

	} while (FALSE);

    if (hInf != NULL)
	{
        SetupCloseInfFile(hInf);
		hInf = NULL;
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarp\aac.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	aas.c

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include "common.h"
#include "..\atmarpc\ioctl.h"
#include "atmmsg.h"


#define MAX_ATMARPC_ADAPTERS	64
#define MAX_ATMARPC_LISS		64
#define MAX_ATMARPC_NAME_LEN	256
#define MAX_ATMARPC_ARP_ENTRIES	4096
#define MAX_ATMARPC_CONNECTIONS	4096

//
//	Globals
//
static CHAR							DefaultDeviceName[] =  "\\\\.\\ATMARPC";
static CHAR							*pDeviceName = DefaultDeviceName;

BOOLEAN
AACCheckVersion(
	HANDLE		DeviceHandle
)
{
	ULONG						Version;
	ULONG						BytesReturned;

	printf("In AACCheckversion\n");
	if (!DeviceIoControl(
				DeviceHandle,
				ARPC_IOCTL_QUERY_VERSION,
				(PVOID)&Version,
				sizeof(Version),
				(PVOID)&Version,
				sizeof(Version),
				&BytesReturned,
				0))
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ARPC_VERSION_INFO);
		return FALSE;
	}	

	if (Version != ARPC_IOCTL_VERSION)
	{
		DisplayMessage(FALSE, MSG_ERROR_INVALID_ARPC_INFO_VERSION);
		return FALSE;
	}

	return TRUE;
}

	
void
DoAAC(OPTIONS *po)
{
	HANDLE	DeviceHandle;
	char 	InterfacesBuffer[1024];
	ULONG		cbInterfaces = sizeof(InterfacesBuffer);


	DisplayMessage(FALSE, MSG_ARPC_BANNER);

	DeviceHandle = OpenDevice(pDeviceName);
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		DisplayMessage(FALSE, MSG_ERROR_OPENING_ARPC);
		return;
	}

	//
	//	First check the version
	//
	if (!AACCheckVersion(DeviceHandle))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	CloseDevice(DeviceHandle);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarp\externs.h ===
//
//	Private types
//
typedef struct {
	DWORD				Message;
	LPSTR				String;
} MESSAGE_STRING, *PMESSAGE_STRING;

#define MSG_NO_MESSAGE			0


typedef struct
{
	BOOL DispStats;
	BOOL DispCache;
	BOOL DoResetStats;

} OPTIONS;

//
//  LoadMessageTable
//
//  Loads internationalizable strings into a table, replacing the default for
//  each. If an error occurs, the English language default is left in place.
//
//
VOID
LoadMessageTable(
	PMESSAGE_STRING	Table,
	UINT MessageCount
);

VOID
DisplayMessage(
	IN	BOOLEAN			Tabbed,
	IN	DWORD			MessageId,
	...
);


HANDLE
OpenDevice(
	CHAR	*pDeviceName
);



VOID
CloseDevice(
	HANDLE		DeviceHandle
);

void DoAAS(OPTIONS *po);
void DoAAC(OPTIONS *po);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarp\common.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	common.h

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <winerror.h>
#include <winsock.h>

#include <ntddndis.h>
#include <atm.h>

#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\1394\tools\ipfwadm\ipfwadm.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

	ipfwadm.c	-- actually calls down the the ip/1394 arp module.

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	04-12-1999	Created

--*/

#include "common.h"


#define NUM_ARPENTRIES_TO_GET 10
#define PROGRAM "ipfwadm"

typedef struct
{
	ARP1394_IOCTL_COMMAND Cmd;

	// MUST IMMEDIATELY follow Cmd -- space for Cmd.GetArpCache.Entries
	//
	ARP1394_ARP_ENTRY Reserved[NUM_ARPENTRIES_TO_GET];

} OPTIONS;


HANDLE
OpenDevice(
	CHAR	*pDeviceName
);


VOID
CloseDevice(
	HANDLE		DeviceHandle
);

BOOL
ParseCmdLine(
	int argc, 
	char * argv[]
	);

BOOL
ParseIpAddress(
	PCHAR 	buf,
	PULONG	pIpAddress
	);

BOOL
ParseHwAddress(
	PCHAR 						buf,
	PARP1394_IOCTL_HW_ADDRESS	pHwAddr
	);

BOOL
ValidateCommand(PARP1394_IOCTL_COMMAND pCmd);

BOOL
ParsePacket(
	PCHAR buf,
	UCHAR *data,
	UINT  cbData,
	UINT *pcbPacketSize
	);

BOOL
ParseAdapter(
	PCHAR buf,
	UCHAR *data,
	UINT  cbData,
	UINT *pcbAdapterSize
	);

OPTIONS g;

void 
Usage(void);
	
VOID __cdecl
main(
	INT			argc,
	CHAR		*argv[]
)
{

	//
	// Parse args, determine if this is concerns the arp client or server.
	//
	if (!ParseCmdLine(argc, argv))
	{
		return;
	}

	DoCmd(&g.Cmd);

}

void 
Usage(void)
{
	//
	// Also hidden compat options: -s, -d, -g
	//

	printf( "\nWindows 2000 IP/1394 Utility\n\n");

	printf(
		PROGRAM " -a\n"
		PROGRAM " -add inet_addr hw_addr      [-n if_addr]\n"
		PROGRAM " -del inet_addr              [-n if_addr]\n"
		PROGRAM " -stats [arp|call|pkts|tsks] [-n if_addr]\n"
		PROGRAM " -resetstats                 [-n if_addr]\n"
		PROGRAM " -purgecache                 [-n if_addr]\n"
		PROGRAM " -reinit                     [-n if_addr]\n"
		PROGRAM " -send  pkt                  [-n if_addr]\n"
		PROGRAM " -recv  pkt                  [-n if_addr]\n"
		PROGRAM " -bstart  adapter\n"
		PROGRAM " -bstop   adapter\n"
		PROGRAM " -nicinfo [a|n node|c channel|reset]   [-n if_addr]\n"
		PROGRAM " --                          [-n if_addr]\n"
		PROGRAM " -euidmap\n"
		"\n"
		);

	printf(
"  -a            Displays current ARP entries. If more than one ip/1394 network\n"
"                interface exist, entries for each ARP table are displayed.\n"
		);

	printf(
"  -add          Adds the host and associates the Internet address inet_addr\n"
"                with the Physical address hw_addr. The entry is permanent.\n"
		);

	printf(
"  -del          Deletes the host specified by inet_addr.\n"
		);

	printf(
"  -stats        Displays arp/call/packet/task statistics.\n"
		);

	printf(
"  -resetstats   Resets statistics collection.\n"
		);

	printf(
"  -purgecache   Deletes all dynamic arp entries.\n"
		);

	printf(
"  -reinit       Deactivates and then reactivates the interface.\n"
		);

	printf(
"  -send pkt     Sends the specified packet on the broadcast channel.\n"
		);

	printf(
"  -recv pkt     Simulates a receive of the specified packet on the.\n"
"                broadcast channel.\n"
		);

	printf(
"  -nicinfo      Displays information about the 1394 network adapter.\n"
"                    -a        displays adapter-wide information\n"
"                    -n node   displays information about the node with node ID \"node\"\n"
"                    -c channel   displays information about channel \"channel\"\n"
		);

	printf(
"  -bstart adapter    Starts Ethernet emulation (bridging) on the specified adapter.\n"
		);

	printf(
"  -bstop adapter     Stops Ethernet emulation (bridging) on the specified adapter.\n"
		);

	printf(
"  --            Takes commands from standard input. Commands are options\n"
"                without the '-' prefix. Use ^C or 'q' to exit the program.\n"
		);

	printf(
"  -n if_addr    Displays information for the network interface specified\n"
"                by if_addr.  If not present, the first applicable interface will\n"
"                be used.\n"
		);

	printf(
"  inet_addr     Specifies an internet address.\n"
		);

	printf(
"  hw_addr       Specifies a physical address (64-bit Unique ID). The Physical\n"
"                address is given as 8 hexadecimal bytes separated by hyphens.\n"
		);

	printf(
"  pkt           Specifies the key name under the [Packets] section of\n"
"                " PROGRAM ".INI. The value of the key contains the packet data.\n"
		);

	printf(
"  euidmap		Prints The Euid, Node Address and Fake Mac Address \n"
"               assigned to a Remote Node\n"
		);
	
	printf(
"\nExample:\n"
"  > " PROGRAM " -s 157.55.85.212   00-aa-00-62-c6-09-01-02  .... Adds a static entry.\n"
"  > " PROGRAM " -a                                          .... Displays the arp table.\n"
"  > " PROGRAM " -stats arp -n 10.0.0.1                      .... Displays arp statistics\n"
"                                                           for interface 10.0.0.1.\n"
		);

}

UINT FindOption(
	char *lptOpt, 
	char **ppVal,
	BOOL fCmdLine
	);

enum
{
	DO_DISP_HELP,
	DO_GET_ARPCACHE,
	DO_ADD_ARPENTRY,
	DO_DEL_ARPENTRY,
	DO_PURGE_ARPCACHE,
	DO_GET_STATS,
	DO_RESET_STATS,
	DO_REINIT_IF,
	DO_SWITCH_TO_STDIN,
	DO_SPECIFIC_IF,
	DO_GET_NICINFO,
	DO_SEND_PACKET,
	DO_RECV_PACKET,

	DO_X_ARP,
	DO_X_CALL,
	DO_X_TSKS,
	DO_X_PKTS,
	DO_X_ALL,

	DO_NI_CHANNELINFO,


    DO_BSTART,
    DO_BSTOP,
	DO_EUIDMAP,
	UNKNOWN_OPTION,

    // Put the at the end
    //
	DO_NI_BUSINFO = DO_GET_ARPCACHE, // Because both are "a"
	DO_NI_NODEINFO = DO_SPECIFIC_IF,
};

struct _CmdOptions {
    char *  lptOption;
    UINT    uOpt;
} CmdOptions[]    =
{
	{"?"			, DO_DISP_HELP		    },
	{"a"			, DO_GET_ARPCACHE		}, // Also DO_NI_BUSINFO
	{"s"			, DO_ADD_ARPENTRY		},
	{"g"			, DO_ADD_ARPENTRY		},
	{"add"			, DO_ADD_ARPENTRY		},
	{"del"			, DO_DEL_ARPENTRY		},
	{"purgecache"	, DO_PURGE_ARPCACHE		},
	{"stats"		, DO_GET_STATS			},
	{"resetstats"	, DO_RESET_STATS		},
	{"reinit"		, DO_REINIT_IF			},
	{"-"			, DO_SWITCH_TO_STDIN	},
	{"n"			, DO_SPECIFIC_IF		}, // Also DO_NI_NODEINFO
	{"send"			, DO_SEND_PACKET		},
	{"recv"			, DO_RECV_PACKET		},
	{"nicinfo"		, DO_GET_NICINFO		},
	{"bstart"		, DO_BSTART		},
	{"bstop"		, DO_BSTOP		},
	{"euidmap"		, DO_EUIDMAP   },

	// Following are sub-options of /stats...
	//
	{"arp"			, DO_X_ARP				},
	{"call"			, DO_X_CALL				},
	{"tsks"			, DO_X_TSKS				},
	{"pkts"			, DO_X_PKTS				},
	{"pkt"			, DO_X_PKTS				},

	// Following are sub-options of /nicinfo...
	//
	// {"b"			, DO_NI_BUSINFO			},
	// {"n"			, DO_NI_NODEINFO		},
	{"c"			, DO_NI_CHANNELINFO		}
};

INT iCmdOptionsCounts = sizeof(CmdOptions)/sizeof(struct _CmdOptions);


BOOL
ParseCmdLine(
	int argc, 
	char * argv[]
	)
{
	BOOL	bRetVal = TRUE;
	int		iIndx=1;
	UINT	uOpt;
	char	*pVal;

	ZeroMemory(&g.Cmd, sizeof(g.Cmd));
	ZeroMemory(&g.Reserved, sizeof(g.Reserved));

	while(bRetVal && iIndx < argc)
	{
		
		uOpt = FindOption(argv[iIndx++], &pVal, TRUE);

		switch(uOpt)
		{
	
		case DO_GET_ARPCACHE:
			//
			// "arp13 -a\n"
			//
			{
				PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd =  &g.Cmd.GetArpCache;

				if (argc != 2)
				{
					printf("Too many arguments for '-a'\n");
					bRetVal = FALSE;
					break;
				}

				pGetCacheCmd->Hdr.Version 			= ARP1394_IOCTL_VERSION;
				pGetCacheCmd->Hdr.Op 				= ARP1394_IOCTL_OP_GET_ARPCACHE;
				pGetCacheCmd->NumEntriesAvailable   = NUM_ARPENTRIES_TO_GET;
			}
			break;
		
		case DO_ADD_ARPENTRY:
			//
			// "arp13 -add inet_addr hw_addr"
			//
			{
				PARP1394_IOCTL_ADD_ARP_ENTRY pAddCmd =  &g.Cmd.AddArpEntry;
				bRetVal = FALSE;

				if ((iIndx+1) < argc)
				{
					bRetVal = ParseIpAddress(argv[iIndx++], &pAddCmd->IpAddress);
					if (!bRetVal) break;
	
					bRetVal = ParseHwAddress(argv[iIndx++], &pAddCmd->HwAddress);
				}
				else
				{
					printf("Not enough arguments for '-add'\n");
				}

				if (!bRetVal) break;

				pAddCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pAddCmd->Hdr.Op 		= ARP1394_IOCTL_OP_ADD_STATIC_ENTRY;

			}
			break;
		
		case DO_DEL_ARPENTRY:
			//
			// "arp13 -del inet_addr"
			//
			{
				PARP1394_IOCTL_DEL_ARP_ENTRY pDelCmd =  &g.Cmd.DelArpEntry;
				bRetVal = FALSE;

				if (iIndx < argc)
				{
					bRetVal = ParseIpAddress(argv[iIndx++], &pDelCmd->IpAddress);
				}
				else
				{
					printf("Not enough arguments for '-del'\n");
				}

				if (!bRetVal) break;

				pDelCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pDelCmd->Hdr.Op 		= ARP1394_IOCTL_OP_DEL_STATIC_ENTRY;

			}
			break;
		
		case DO_PURGE_ARPCACHE:
			//
			// "arp13 -purgecache"
			//
			{
				PARP1394_IOCTL_PURGE_ARPCACHE pPurgeCmd =  &g.Cmd.PurgeArpCache;

				pPurgeCmd->Hdr.Version 		= ARP1394_IOCTL_VERSION;
				pPurgeCmd->Hdr.Op 			= ARP1394_IOCTL_OP_PURGE_ARPCACHE;
			}
			break;
		break;

		case DO_GET_STATS:
			//
			// "arp13 -stats [arp|call|tsks|pkts]"
			//
			{
				PARP1394_IOCTL_COMMAND pCmd =  &g.Cmd;
				INT StatsOp;


				if (iIndx >= argc)
				{
					StatsOp = DO_X_ARP;
				}
				else
				{
					StatsOp =  FindOption(argv[iIndx++], &pVal, FALSE);
				}
				
				pCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;

				switch(StatsOp)
				{
				case DO_X_ARP:
					pCmd->Hdr.Op 	=  ARP1394_IOCTL_OP_GET_ARPCACHE_STATS;
					break;

				case DO_X_CALL:
					pCmd->Hdr.Op 	=  ARP1394_IOCTL_OP_GET_CALL_STATS;
					break;
					break;

				case DO_X_TSKS:
					pCmd->Hdr.Op 	=  ARP1394_IOCTL_OP_GET_TASK_STATS;
					break;
					break;

				case DO_X_PKTS:
					pCmd->Hdr.Op 	=  ARP1394_IOCTL_OP_GET_PACKET_STATS;
					break;

				default:
					// Assume default and put parsed value back.
					//
					StatsOp = DO_X_ARP;
					iIndx--;
					break;
				}
			}
			break;
		
		case DO_RESET_STATS:
			//
			// "arp13 -resetstats"
			//
			{
				PARP1394_IOCTL_RESET_STATS pResetStatsCmd =  &g.Cmd.ResetStats;

				pResetStatsCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pResetStatsCmd->Hdr.Op 			= ARP1394_IOCTL_OP_RESET_STATS;
			}
			break;

		case DO_REINIT_IF:
			//
			// "arp13 -reinit"
			//
			{
				PARP1394_IOCTL_REINIT_INTERFACE pReinitIfCmd;
				pReinitIfCmd = &g.Cmd.ReinitInterface;

				pReinitIfCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pReinitIfCmd->Hdr.Op 		= ARP1394_IOCTL_OP_REINIT_INTERFACE;
			}
			break;

		case DO_SEND_PACKET:
			//
			// "arp13 -send pkt"
			//
			{
				PARP1394_IOCTL_SEND_PACKET pSendCmd =  &g.Cmd.SendPacket;
				bRetVal = FALSE;

				if (iIndx < argc)
				{
					bRetVal = ParsePacket(
								argv[iIndx++],
								pSendCmd->Data,
								sizeof(pSendCmd->Data),
								&pSendCmd->PacketSize
								);
				}
				else
				{
					printf("Not enough arguments for '-send pkt'\n");
				}

				if (!bRetVal) break;

				pSendCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pSendCmd->Hdr.Op 		= ARP1394_IOCTL_OP_SEND_PACKET;

			}
			break;

		case DO_RECV_PACKET:
			//
			// "arp13 -recv pkt"
			//
			{
				PARP1394_IOCTL_RECV_PACKET pRecvCmd =  &g.Cmd.RecvPacket;
				bRetVal = FALSE;

				if (iIndx < argc)
				{
					bRetVal = ParsePacket(
								argv[iIndx++],
								pRecvCmd->Data,
								sizeof(pRecvCmd->Data),
								&pRecvCmd->PacketSize
								);
				}
				else
				{
					printf("Not enough arguments for '-recv pkt'\n");
				}

				if (!bRetVal) break;

				pRecvCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pRecvCmd->Hdr.Op 		= ARP1394_IOCTL_OP_RECV_PACKET;
			}
			break;

		case DO_BSTART:
		case DO_BSTOP:
			//
			// "arp13 -bstart adapter"
			//
			{
                UINT Size;
                PARP1394_IOCTL_ETHERNET_NOTIFICATION pEthCmd = 
                                                        &g.Cmd.EthernetNotification;
				bRetVal = FALSE;

				if (iIndx < argc)
				{
					bRetVal = ParseAdapter(
								argv[iIndx++],
								(PUCHAR) pEthCmd->AdapterName,
								sizeof(pEthCmd->AdapterName)-sizeof(WCHAR),
								&Size
								);
                    pEthCmd->AdapterName[Size/2]=0;
				}
				else
				{
					printf("Not enough arguments for '-send pkt'\n");
				}

				if (!bRetVal) break;

                pEthCmd->Hdr.Version 	= ARP1394_IOCTL_VERSION;
		        if (uOpt == DO_BSTART)
                {
                    // printf("BRIDGE START\n");
                    pEthCmd->Hdr.Op 	= ARP1394_IOCTL_OP_ETHERNET_START_EMULATION;
                }
                else
                {
                    // printf("BRIDGE STOP\n");
                    pEthCmd->Hdr.Op 	= ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION;
				}
			}
            break;

		case DO_GET_NICINFO:
			//
			// ipfwadm -nicinfo [a|n node_id |c channel_number]
			//
			{
				PNIC1394_NICINFO	pNi = &g.Cmd.IoctlNicInfo.Info;
				INT NicOp;
				UINT Num;


				if (iIndx >= argc)
				{
					NicOp = DO_NI_BUSINFO;	// Default
				}
				else
				{
					NicOp =  FindOption(argv[iIndx++], &pVal, FALSE);
				}
				
				
				g.Cmd.Hdr.Version 	= ARP1394_IOCTL_VERSION;
				g.Cmd.Hdr.Op 		= ARP1394_IOCTL_OP_GET_NICINFO;
				pNi->Hdr.Version 	= NIC1394_NICINFO_VERSION;

				//
				// Parse the sub-command
				//
				switch(NicOp)
				{
				default:
					// Assume default and put parsed value back.
					//
					iIndx--;
					
					// FALL THROUGH

				case DO_NI_BUSINFO:
					pNi->Hdr.Op = NIC1394_NICINFO_OP_BUSINFO;
					break;

				case DO_NI_NODEINFO:
					pNi->Hdr.Op = NIC1394_NICINFO_OP_REMOTENODEINFO;

					// Read mandatory node number
					//
					bRetVal = FALSE;
					if (iIndx < argc)
					{
						if (sscanf(argv[iIndx++], "%d", &Num)==1)
						{
							bRetVal = TRUE;
						}
					}
					if (bRetVal)
					{
						pNi->RemoteNodeInfo.NodeAddress = (USHORT) Num;
					}
					else
					{
						printf("Missing node id\n");
					}
					break;

				case DO_NI_CHANNELINFO:
					pNi->Hdr.Op = NIC1394_NICINFO_OP_CHANNELINFO;

					// Read mandatory channel number
					//
					bRetVal = FALSE;
					if (iIndx < argc)
					{
						if (sscanf(argv[iIndx++], "%d", &Num)==1)
						{
							bRetVal = TRUE;
						}
					}
					if (bRetVal)
					{
						pNi->ChannelInfo.Channel = Num;
					}
					else
					{
						printf("Missing channel number\n");
					}
					break;
				}
			}
			break;

		case DO_EUIDMAP:
			{
				PARP1394_IOCTL_EUID_NODE_MAC_INFO pMapInfo = &g.Cmd.EuidNodeMacInfo;

				pMapInfo->Hdr.Version 	= ARP1394_IOCTL_VERSION;
				pMapInfo->Hdr.Op 		= ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE;				
				printf("Receved EuidMap");
			}
			break;
		case DO_SWITCH_TO_STDIN:
			//
			// "arp13 --"
			//
			printf("Switch to stdin UNIMPLEMENTED.\n");
			bRetVal = FALSE;
			break;
		
		case DO_SPECIFIC_IF:
	        //
			//  "-n if_addr"
			//
			{
				PARP1394_IOCTL_HEADER pHdr =  &g.Cmd.Hdr;

				bRetVal = ParseIpAddress(argv[iIndx++], &pHdr->IfIpAddress);
				if (!bRetVal) break;
			}
			break;

		default:
			printf("Unknown option:  %s\n", argv[iIndx-1]); // fall through
			//
			// FALL THROUGH...
			//

		case DO_DISP_HELP:
			Usage();
			bRetVal = FALSE;
			break;
		}
	}

	if (argc<=1)
	{
		//
		// Display help...
		//
		Usage();
	}

	if (bRetVal)
	{
		bRetVal = ValidateCommand(&g.Cmd);
	}

	return bRetVal;
}


UINT FindOption(
	char *lptOpt, 
	char **ppVal,
	BOOL	fCmdLine
	)
{
	int		i;
	UINT    iLen;
	char	c = *lptOpt;

	// if (fCmdLine), expect, and skip past the '-', or '/'...
	//
	if (fCmdLine)
	{
		if (c == '-' || c == '/')
		{
			lptOpt++;
		}
		else
		{
			return UNKNOWN_OPTION;			// EARLY RETURN
		}
	}
	
	for(i = 0; i < iCmdOptionsCounts; i++)
	{
		if(strlen(lptOpt) >= (iLen = strlen(CmdOptions[i].lptOption)))
		{
			if(0 == strcmp(lptOpt, CmdOptions[i].lptOption))
			{
				*ppVal = lptOpt + iLen;
				return CmdOptions[i].uOpt;
			}
		}
	}

    return UNKNOWN_OPTION;
}

BOOL
ParseIpAddress(
	PCHAR 	buf,
	PULONG	pIpAddress
	)
/*++

Routine Description:

	Parse IP address in buf the form a.b.c.d and return the parsed value
	in *pIpAddress in network byte order.

Return Value:

	TRUE iff correctly formed IP address. False otherwise.

--*/
{
	BOOL fRet = FALSE;

	do
	{
		INT rgi[4];
		INT i;

		i = sscanf(buf, "%d.%d.%d.%d", rgi+0, rgi+1, rgi+2, rgi+3);
	
		if (i<4) break;

	
		fRet = TRUE;

		for (i=0; i<4; i++)
		{
			INT iTmp = rgi[i];
			if (iTmp == -1)
			{
				iTmp = 255;
			}
			if (iTmp<0 || iTmp>255)
			{
				fRet = FALSE;
				break;
			}

			rgi[i] = iTmp;
		}

		if (!fRet) break;

		// Construct IP address in network byte order.
		//
		{
			ULONG u = (ULONG) rgi[0];
			u |= ((ULONG)rgi[1])<<8;
			u |= ((ULONG)rgi[2])<<16;
			u |= ((ULONG)rgi[3])<<24;
			*pIpAddress = u;
		}

	#if 0
		printf(
			"(%d.%d.%d.%d)->0x%08lx\n",
			rgi[0], rgi[1], rgi[2], rgi[3], *pIpAddress
			);
	#endif // 0


	} while (FALSE);

	if (!fRet)
	{
		printf("Invalid IP address: %s\n", buf);
	}

	return fRet;
}


BOOL
ParseHwAddress(
	PCHAR 						buf,
	PARP1394_IOCTL_HW_ADDRESS	pHwAddr
	)
/*++

Routine Description:

	Parse IEEE1394 HW address in buf the form of 8 bytes separated by hyphens.
	Return the parsed value in *pHwAddr in network byte order.

Return Value:

	TRUE iff correctly formed HW address. False otherwise.

--*/
{
	BOOL fRet = FALSE;

	do
	{
		ULONG rgu[8];
		INT i;

		i = sscanf(
				buf,
				"%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx",
				 rgu+0, rgu+1, rgu+2, rgu+3,
				 rgu+4, rgu+5, rgu+6, rgu+7
				);
	
		if (i<8) break;
	
		fRet = TRUE;

		for (i=0; i<8; i++)
		{
			ULONG u = rgu[i];

			if (u>255)
			{
				fRet = FALSE;
				break;
			}
			((PUCHAR)(&pHwAddr->UniqueID))[i] = (UCHAR) u;
		}

		if (!fRet) break;

	#if 0
		printf(
			"(%d-%d-%d-%d-%d-%d-%d-%d) -> 0x%08lx:0x%08lx\n",
			rgu[0], rgu[1], rgu[2], rgu[3],
			rgu[4], rgu[5], rgu[6], rgu[7],
			((PULONG)(&pHwAddr->UniqueID))[0],
			((PULONG)(&pHwAddr->UniqueID))[1]
			);
	#endif // 0

	} while (FALSE);

	if (!fRet)
	{
		printf("Invalid HW address: %s\n", buf);
	}
	return fRet;
}

BOOL
ValidateCommand(PARP1394_IOCTL_COMMAND pCmd)
{
	BOOL fRet = FALSE;

	if (pCmd->Hdr.Version != ARP1394_IOCTL_VERSION) return FALSE; // EARLY RETURN

	switch(pCmd->Hdr.Op)
	{
	case ARP1394_IOCTL_OP_GET_ARPCACHE:
		{
			PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd =  &pCmd->GetArpCache;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_ARPCACHE;\n"
				"    IpIf      = 0x%08lx;\n"
				"    NumAvail  = %lu;\n"
				"};\n",
				pGetCacheCmd->Hdr.IfIpAddress,
				pGetCacheCmd->NumEntriesAvailable
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_ADD_STATIC_ENTRY:
		{
			PARP1394_IOCTL_ADD_ARP_ENTRY pAddCmd =  &pCmd->AddArpEntry;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = ADD_ENTRY;\n"
				"    IpIf      = 0x%08lx;\n"
				"    IpAddress = 0x%08lx;\n"
				"    HwAddress = 0x%08lx:0x%08lx;\n"
				"};\n",
				pAddCmd->Hdr.IfIpAddress,
				pAddCmd->IpAddress,
				((PULONG)&pAddCmd->HwAddress)[0],
				((PULONG)&pAddCmd->HwAddress)[1]
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_DEL_STATIC_ENTRY:
		{
			PARP1394_IOCTL_DEL_ARP_ENTRY pDelCmd =  &pCmd->DelArpEntry;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = DEL_ENTRY;\n"
				"    IpIf      = 0x%08lx;\n"
				"    IpAddress = 0x%08lx;\n"
				"};\n",
				pDelCmd->Hdr.IfIpAddress,
				pDelCmd->IpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_PURGE_ARPCACHE:
		{
			PARP1394_IOCTL_PURGE_ARPCACHE pPurgeCmd =  &pCmd->PurgeArpCache;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_PURGE_ARPCACHE;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pPurgeCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_PACKET_STATS:
		{
			PARP1394_IOCTL_GET_PACKET_STATS pStatsCmd =  &pCmd->GetPktStats;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_PACKET_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_TASK_STATS:
		{
			PARP1394_IOCTL_GET_TASK_STATS pStatsCmd =  &pCmd->GetTaskStats;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_TASK_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_ARPCACHE_STATS:
		{
			PARP1394_IOCTL_GET_ARPCACHE_STATS pStatsCmd =  &pCmd->GetArpStats;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_ARPCACHE_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_CALL_STATS:
		{
			PARP1394_IOCTL_GET_CALL_STATS pStatsCmd =  &pCmd->GetCallStats;

		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_CALL_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_RESET_STATS:
		{
			PARP1394_IOCTL_RESET_STATS pStatsCmd =  &pCmd->ResetStats;
		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_RESET_STATS;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pStatsCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_REINIT_INTERFACE:
		{
			PARP1394_IOCTL_REINIT_INTERFACE pReinitCmd =  &pCmd->ReinitInterface;
		#if 0
			printf(
				"CMD = \n{"
				"    Op        = GET_REINIT_INTERFACE;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pReinitCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_SEND_PACKET:
		{
			PARP1394_IOCTL_SEND_PACKET pSendCmd =  &pCmd->SendPacket;
		#if 0
			printf(
				"CMD = \n{"
				"    Op        = SEND_PACKET;\n"
				"    Pkt       = %s;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				g_szPacketName,
				pSendCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_RECV_PACKET:
		{
			PARP1394_IOCTL_RECV_PACKET pRecvCmd =  &pCmd->RecvPacket;
		#if 0
			printf(
				"CMD = \n{"
				"    Op        = RECV_PACKET;\n"
				"    Pkt       = %s;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				g_szPacketName,
				pRecvCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

    case ARP1394_IOCTL_OP_ETHERNET_START_EMULATION:
    case ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION:
		{
			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_NICINFO:
		{
			PARP1394_IOCTL_NICINFO pNicInfoCmd =  &pCmd->IoctlNicInfo;
		#if 0
			printf(
				"CMD = \n{"
				"    Op        = NICINFO;\n"
				"    IpIf      = 0x%08lx;\n"
				"};\n",
				pNicInfoCmd->Hdr.IfIpAddress
				);
		#endif // 0

			fRet = TRUE;
		}
		break;

	case ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE:
		{
			fRet = TRUE;
		}
	default:
		break;

	}

	return fRet;
};


CHAR *g_szPacketName;

BOOL
ParsePacket(
	PCHAR buf,
	UCHAR *data,
	UINT  cbData,
	UINT *pcbPacketSize
	)
{
	char Path[256];
	UINT u;
	BOOL fRet = FALSE;


	g_szPacketName = buf;

    u = GetCurrentDirectory(sizeof(Path), Path);

    if (u==0)
    {
    	printf("Couldn't get current directory.\n");
    	return FALSE;
    }
    strcat(Path, "\\");
    strcat(Path, PROGRAM);
    strcat(Path, ".ini");
    // printf("INI file location = %s\n", Path);

	fRet = GetBinaryData(
			Path,
			"Packets",
			buf,
			data,
			cbData,
			pcbPacketSize
			);

#if 0


	static IP1394_MCAP_PKT Pkt =
	{
		{
			H2N_USHORT(0),		// Node id
			H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
		},

		H2N_USHORT(
			sizeof(IP1394_MCAP_PKT) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
		0, // reserved
		IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
		{
			sizeof(IP1394_MCAP_GD),
			IP1394_MCAP_GD_TYPE_V1,
			0, //  reserved;
			60, // expiration;
			2,  // channel
			2,  // speed
			0,  // reserved2;
			0,  // bandwidth;
			0x010000e1 // IP multicast group  address 225.0.0.1
		}
	};

	PIP1394_MCAP_PKT pPkt;
	pPkt = &Pkt;

	if (cbData >= sizeof(Pkt))
	{
		printf ("ParsePacket: MCAP packet of size %lu.\n", sizeof(Pkt));
		*(PIP1394_MCAP_PKT) data = *pPkt;
		*pcbPacketSize = sizeof (Pkt);
		fRet = TRUE;
	}
	else
	{
		printf ("ParsePacket: buffer size too small.\n");
	}
#endif // 0


	return fRet;
}

BOOL
ParseAdapter(
	PCHAR buf,
	UCHAR *data,
	UINT  cbData,
	UINT *pcbAdapterSize
	)
{
	char Path[256];
	UINT u;
	BOOL fRet = FALSE;


	g_szPacketName = buf;

    u = GetCurrentDirectory(sizeof(Path), Path);

    if (u==0)
    {
    	printf("Couldn't get current directory.\n");
    	return FALSE;
    }
    strcat(Path, "\\");
    strcat(Path, PROGRAM);
    strcat(Path, ".ini");
    // printf("INI file location = %s\n", Path);

	fRet = GetBinaryData(
			Path,
			"Adapters",
			buf,
			data,
			cbData,
			pcbAdapterSize
			);

	return fRet;
}

typedef struct
{
    
    IP1394_MCAP_PKT Pkt;
    IP1394_MCAP_GD Gd2;

} MYPKT2;

typedef struct
{
    
    IP1394_MCAP_PKT Pkt;
    IP1394_MCAP_GD Gd2;
    IP1394_MCAP_GD Gd3;

} MYPKT3;

typedef struct
{
    
    IP1394_MCAP_PKT Pkt;
    IP1394_MCAP_GD Gd2;
    IP1394_MCAP_GD Gd3;
    IP1394_MCAP_GD Gd4;

} MYPKT4;

#define SWAPBYTES_USHORT(Val)	\
				((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))
#define H2N_USHORT(Val)	SWAPBYTES_USHORT(Val)

IP1394_MCAP_PKT Pkt1  =
{
    {
        H2N_USHORT(0),		// Node id
        H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
    },

    H2N_USHORT(
        sizeof(IP1394_MCAP_PKT) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
    0, // reserved
    IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
    {
        sizeof(IP1394_MCAP_GD),
        IP1394_MCAP_GD_TYPE_V1,
        0, //  reserved;
        60, // expiration;
        2,  // channel
        2,  // speed
        0,  // reserved2;
        0,  // bandwidth;
        0x010000e1 // IP multicast group  address 225.0.0.1
    }
};


MYPKT2 Pkt2 = 
{
    {
        {
            H2N_USHORT(0),		// Node id
            H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
        },
    
        H2N_USHORT(
            sizeof(MYPKT2) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
        0, // reserved
        IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
        {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x010000e1 // IP multicast group  address 225.0.0.1
        }
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x020000e1 // IP multicast group  address 225.0.0.2
    }
};


MYPKT3 Pkt3 = 
{
    {
        {
            H2N_USHORT(0),		// Node id
            H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
        },
    
        H2N_USHORT(
            sizeof(MYPKT3) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
        0, // reserved
        IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
        {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x010000e1 // IP multicast group  address 225.0.0.1
        }
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x020000e1 // IP multicast group  address 225.0.0.2
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x030000e1 // IP multicast group  address 225.0.0.3
    }
};

MYPKT4 Pkt4 = 
{
    {
        {
            H2N_USHORT(0),		// Node id
            H2N_USHORT(NIC1394_ETHERTYPE_MCAP)
        },
    
        H2N_USHORT(
            sizeof(MYPKT4) - sizeof(NIC1394_UNFRAGMENTED_HEADER)),
        0, // reserved
        IP1394_MCAP_OP_ADVERTISE, // IP1394_MCAP_OP_SOLICIT
        {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x010000e1 // IP multicast group  address 225.0.0.1
        }
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x020000e1 // IP multicast group  address 225.0.0.2
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x030000e1 // IP multicast group  address 225.0.0.3
    },
    {
            sizeof(IP1394_MCAP_GD),
            IP1394_MCAP_GD_TYPE_V1,
            0, //  reserved;
            60, // expiration;
            2,  // channel
            2,  // speed
            0,  // reserved2;
            0,  // bandwidth;
            0x040000e1 // IP multicast group  address 225.0.0.4
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarp\aas.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	aas.c

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include "common.h"
#include "..\atmarps\arp.h"
#include "..\atmarps\ioctl.h"
#include "atmmsg.h"


//
//	Globals
//
static CHAR							DefaultDeviceName[] =  "\\\\.\\AtmArpServer";
static CHAR							*pDeviceName = DefaultDeviceName;


//
//  LoadMessages - courtesy IPCONFIG
//
//  Loads all internationalizable messages into the various tables
//
VOID
LoadMessages(
)
{
}


BOOL
CheckVersion(
	HANDLE		DeviceHandle
)
{
    return TRUE;
}


BOOL
AasGetInterfaces(
	HANDLE		DeviceHandle,
	PINTERFACES pInterfaces,
	ULONG		cbInterfaces
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;

	if (DeviceIoControl(
				DeviceHandle,
				ARPS_IOCTL_QUERY_INTERFACES,
				(PVOID)pInterfaces,
				cbInterfaces,
				(PVOID)pInterfaces,
				cbInterfaces,
				&BytesReturned,
				0))
	{
		UINT u = pInterfaces->NumberOfInterfaces;
		//
		// Fixup pointers
		//
		for (u=0;u<pInterfaces->NumberOfInterfaces;u++)
		{
			INTERFACE_NAME *pInterface = (pInterfaces->Interfaces)+u;
			pInterface->Buffer = (PWSTR)(  (ULONG_PTR)pInterface->Buffer
								 		 + (PUCHAR)pInterface);

			//
			// check that all this is valid...
			//
			if (   ((PUCHAR)pInterface->Buffer < (PUCHAR) pInterface)
				|| (   ((PUCHAR)pInterface->Buffer + pInterface->Length)
					 > ((PUCHAR)pInterfaces + cbInterfaces)))
			{
				printf("WHOA THERE!\n");
				DebugBreak();
			}
			else
			{
			#if 0
				printf("INTERFACE: Len=%lu, Name=\"%c%c%c%c...\n",
					pInterface->Length,
					pInterface->Buffer[0],
					pInterface->Buffer[1],
					pInterface->Buffer[2],
					pInterface->Buffer[3]
					);
			#endif // 0
			}
		}

		Result = TRUE;
	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_INTERFACE_LIST);
	}

	return Result;
}


BOOL
AasGetArpCache(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface,
	PIOCTL_QUERY_CACHE
					pArpCache,
	ULONG			cbArpCache
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;
	UINT		BufferOffset;

	BufferOffset = FIELD_OFFSET(struct QUERY_ARP_CACHE_INPUT_PARAMS, Name) +
						sizeof(pArpCache->Name);
	pArpCache->Name.Buffer = (PWSTR)sizeof(pArpCache->Name);
	pArpCache->Name.Length = pInterface->Length;
	pArpCache->Name.MaximumLength = pInterface->MaximumLength;
	memcpy((PUCHAR)pArpCache + BufferOffset,
			pInterface->Buffer,
			pInterface->MaximumLength);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_QUERY_ARPCACHE,
					(PVOID)pArpCache,
					BufferOffset + pInterface->Length,
					(PVOID)pArpCache,
					cbArpCache,
					&BytesReturned,
					NULL);

	if (Result)
	{
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, cArps=%lu, cArpsInBuf=%lu\n",
			BytesReturned,
			pArpCache->Entries.TotalNumberOfEntries,
			pArpCache->Entries.NumberOfEntriesInBuffer
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ARP_CACHE);
	}

	return Result;
}

BOOL
AasGetMarsCache(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface,
	PIOCTL_QUERY_MARS_CACHE
					pMarsCache,
	ULONG			cbMarsCache
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;
	UINT		BufferOffset;

	BufferOffset = FIELD_OFFSET(struct QUERY_MARS_CACHE_INPUT_PARAMS, Name) +
						sizeof(pMarsCache->Name);

	pMarsCache->Name.Buffer = (PWSTR)sizeof(pMarsCache->Name);
	pMarsCache->Name.Length = pInterface->Length;
	pMarsCache->Name.MaximumLength = pInterface->MaximumLength;
	memcpy((PUCHAR)pMarsCache + BufferOffset,
			pInterface->Buffer,
			pInterface->MaximumLength);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_QUERY_MARSCACHE,
					(PVOID)pMarsCache,
					BufferOffset + pInterface->Length,
					(PVOID)pMarsCache,
					cbMarsCache,
					&BytesReturned,
					NULL);

	if (Result)
	{
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, Sig=0x%lx, cMars=%lu, cMarsInBuf=%lu\n",
			BytesReturned,
			pMarsCache->MarsCache.Sig,
			pMarsCache->MarsCache.TotalNumberOfEntries,
			pMarsCache->MarsCache.NumberOfEntriesInBuffer
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_MARS_CACHE);
	}

	return Result;
}

BOOL
AasGetArpStats(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface,
	PARP_SERVER_STATISTICS
					pArpStats
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;

	// printf ( " In AasGetArpStats\n");

	//
	// Temporarily fixup buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (PUCHAR)pInterface->Buffer
								- (PUCHAR)pInterface);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_QUERY_ARP_STATISTICS,
					(PVOID)pInterface,
					(UINT) (((ULONG_PTR)pInterface->Buffer)+pInterface->Length),
					(PVOID)pArpStats,
					sizeof(*pArpStats),
					&BytesReturned,
					NULL);

	//
	// Restore buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (ULONG_PTR)pInterface->Buffer
								+ (PUCHAR)pInterface);

	if (Result)
	{
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, TotRcvPkts=%lu\n",
			BytesReturned,
			pArpStats->TotalRecvPkts
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_ARP_STATS);
	}

	return Result;
}

BOOL
AasGetMarsStats(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface,
	PMARS_SERVER_STATISTICS
					pMarsStats
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;

	// printf ( " In AasGetMarsStats\n");

	//
	// Temporarily fixup buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (PUCHAR)pInterface->Buffer
								- (PUCHAR)pInterface);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_QUERY_MARS_STATISTICS,
					(PVOID)pInterface,
					(UINT) (((ULONG_PTR)pInterface->Buffer)+pInterface->Length),
					(PVOID)pMarsStats,
					sizeof(*pMarsStats),
					&BytesReturned,
					NULL);

	//
	// Restore buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (ULONG_PTR)pInterface->Buffer
								+ (PUCHAR)pInterface);

	if (Result)
	{
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, TotRcvPkts=%lu\n",
			BytesReturned,
			pMarsStats->TotalRecvPkts
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_GETTING_MARS_STATS);
	}

	return Result;
}

BOOL
AasResetStatistics(
	HANDLE			DeviceHandle,
	INTERFACE_NAME *pInterface
)
{
	ULONG		BytesReturned;
	BOOL		Result = FALSE;

	//
	// Temporarily fixup buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (PUCHAR)pInterface->Buffer
								- (PUCHAR)pInterface);

	Result =	DeviceIoControl(
					DeviceHandle,
					ARPS_IOCTL_RESET_STATISTICS,
					(PVOID)pInterface,
					(UINT) (((ULONG_PTR)pInterface->Buffer)+pInterface->Length),
					NULL,
					0,
					&BytesReturned,
					NULL);

	//
	// Restore buffer pointer
	//
	pInterface->Buffer = (PWSTR)(  (ULONG_PTR)pInterface->Buffer
								+ (PUCHAR)pInterface);

	if (Result)
	{
		DisplayMessage(FALSE, MSG_STATS_RESET_STATS);
	#if 0
		printf(
			"DeviceIoCtl: cbRet = %lu, TotRcvPkts=%lu\n",
			BytesReturned,
			pMarsStats->TotalRecvPkts
			);
	#endif // 0

	}
	else
	{
		DisplayMessage(FALSE, MSG_ERROR_RESETTING_STATS);
	}

	return Result;
}


#if 0

LPSTR
ElanStateToString(ULONG In)
{
	switch(In)
	{
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			return (ElanState[In].String);
		default:
			return (ElanState[0].String);
	}
}


LPSTR
ElanLanTypeToString(ULONG In)
{
	switch(In)
	{
		case 0:
			return LanType[1].String;
		case 1:
			return LanType[2].String;
		case 2:
			return LanType[3].String;
		default:
			return LanType[0].String;
	}
}

LPSTR
ElanMaxFrameSizeToString(ULONG In)
{
	switch(In)
	{	
		case 0:
			return Misc[3].String;
		case 1:
			return "1516";
		case 2:
			return "4544";
		case 3:
			return "9234";
		case 4:
			return "18190";
		default:
			return " ? ";
	}
}

LPSTR
McastVcTypeToString(ULONG In)
{
	switch(In)
	{	
		case 0:
			return McastSendVcType[1].String;
		case 1:
			return McastSendVcType[2].String;
		case 2:
			return McastSendVcType[3].String;
		default:
			return McastSendVcType[0].String;
	}
}

PUCHAR
MacAddrToString(PVOID In)
    {
    static UCHAR String[20];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR EthAddr = (PUCHAR) In;
    UINT i;
    PUCHAR s;
    
    for (i = 0, s = String; i < 6; i++, EthAddr++)
        {
        *s++ = HexChars[(*EthAddr)>>4];
        *s++ = HexChars[(*EthAddr)&0xf];
        *s++ = '.';
        }
    *(--s) = '\0';
    return String; 
    }
#endif // 0


PUCHAR
IpAddrToString(IPADDR		*pIpAddr)
{
	PUCHAR puc = (PUCHAR) pIpAddr;
    static UCHAR String[80];
    wsprintf(String, "%u.%u.%u.%u", puc[0], puc[1], puc[2], puc[3]);
    return String; 
}

PUCHAR
AtmAddrToString(ATM_ADDRESS *pAtmAddress)
{
    static UCHAR String[80];
    static PUCHAR HexChars = "0123456789abcdef";
    PUCHAR AtmAddr = (PUCHAR) &(pAtmAddress->Address);
    PUCHAR s = String;

    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 1
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 2
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 3
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 4
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 5
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 6
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 7
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 8
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 9
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 10
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 11
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 12
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 13
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 14
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 15
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 16
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 17
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 18
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 19
    *s++ = '.';
    *s++ = HexChars[(*AtmAddr)>>4];
    *s++ = HexChars[(*AtmAddr++)&0xf];	// 20
    *s = '\0';
    return String; 
}


VOID
AasDisplayArpCache(
	PIOCTL_QUERY_CACHE pArpCache
)
{
	PARPENTRY			pEntry = pArpCache->Entries.Entries;
	UINT i;

	for (i = 0; i < pArpCache->Entries.NumberOfEntriesInBuffer; i++)
	{
		DisplayMessage(FALSE, MSG_AAS_ARP_CACHE_ENTRY,
			IpAddrToString(&(pEntry->IpAddr)),
			AtmAddrToString(&pEntry->AtmAddress));

		pEntry ++;
	}

}

VOID
AasDisplayMarsCache(
	PIOCTL_QUERY_MARS_CACHE pMarsCache
)
{

	PMARSENTRY			pEntry = pMarsCache->MarsCache.Entries;
	UINT i;

	for (i = 0;
		 i < pMarsCache->MarsCache.NumberOfEntriesInBuffer;
		 i++, pEntry++)
	{
		UINT j;
		char* szIpAddr =  IpAddrToString(&(pEntry->IpAddr));
		char  rgBlanks[128];

		ATM_ADDRESS *pAtmAddr = (ATM_ADDRESS*)
								((PUCHAR)pEntry + pEntry->OffsetAtmAddresses);

		FillMemory(rgBlanks, lstrlen(szIpAddr), ' ');
		rgBlanks[lstrlen(szIpAddr)]=0;
	#if 0
		printf("Entry[i] @ 0x%lx: Ip=%u.%u.%u.%u NumAddr=%lu Offset=%lu\n",
					pEntry,
					((PUCHAR)&pEntry->IpAddr)[0],
					((PUCHAR)&pEntry->IpAddr)[1],
					((PUCHAR)&pEntry->IpAddr)[2],
					((PUCHAR)&pEntry->IpAddr)[3],
					pEntry->NumAtmAddresses,
					pEntry->OffsetAtmAddresses);
	#endif // 0


		for (j = 0;
			 j < pEntry->NumAtmAddresses;
			 j++, pAtmAddr++)
		{
			// printf("\t pAddr=%lx\n", pAtmAddr);

			if (!j)
			{
				if (pEntry->IpAddr == 0)
				{
					DisplayMessage(FALSE, MSG_AAS_ARP_PROMIS_CACHE_ENTRY,
						AtmAddrToString(pAtmAddr));
				}
				else
				{
					DisplayMessage(FALSE, MSG_AAS_ARP_CACHE_ENTRY,
						IpAddrToString(&(pEntry->IpAddr)),
						AtmAddrToString(pAtmAddr));
				}

			}
			else
			{
				DisplayMessage(FALSE, MSG_AAS_ARP_CACHE_ENTRY,
					rgBlanks,
					AtmAddrToString(pAtmAddr));
			}
		}

	}

}

VOID
AasDisplayArpStats(
	PARP_SERVER_STATISTICS pArpStats
)
{
#if 0
    Recvd Pkts: ->TotalRecvPkts 			(->DiscardedRecvPkts discarded)
	Arp Entries:	->CurrentArpEntries current	( ->MaxArpEntries max)
    Arp Responses: ->Acks acks  ( ->Naks naks)
    Client VCs: ->CurrentClientVCs current (->MaxClientVCs max)
    Incoming Calls: ->TotalIncomingCalls total (->FailedIncomingCalls failed)

      Received: 10000 	total		(100 discarded)
	   Entries: 10		current		(15  max)
     Responses: 1000 	acks 		(200 naks)
    Client VCs: 5 		current 	(12  max)
Incoming Calls: 500 	total 		(20  failed)
#endif //

	DisplayMessage(FALSE,  MSG_AAS_C01_ARP_STATS);

	DisplayMessage(FALSE, MSG_STATS_ELAPSED_TIME, 	pArpStats->ElapsedSeconds);
	DisplayMessage(FALSE, MSG_ARPS_RECVD_PKTS, 		pArpStats->TotalRecvPkts,
													pArpStats->DiscardedRecvPkts);
	DisplayMessage(FALSE, MSG_ARPS_ARP_ENTRIES, 	pArpStats->CurrentArpEntries,
													pArpStats->MaxArpEntries);
	DisplayMessage(FALSE, MSG_ARPS_ARP_RESPONSES, 	pArpStats->Acks,
													pArpStats->Naks);
	DisplayMessage(FALSE, MSG_ARPS_CLIENT_VCS, 		pArpStats->CurrentClientVCs,
													pArpStats->MaxClientVCs);
	DisplayMessage(FALSE, MSG_ARPS_INCOMING_CALLS, 	pArpStats->TotalIncomingCalls);
													// pArpStats->TotalActiveVCs
}

VOID
AasDisplayMarsStats(
	PMARS_SERVER_STATISTICS pMarsStats
)
{
	DisplayMessage(FALSE,  MSG_AAS_C02_MARS_STATS);

	DisplayMessage(FALSE, MSG_MARS_RECVD_PKTS, 		pMarsStats->TotalRecvPkts,
													pMarsStats->DiscardedRecvPkts);
	DisplayMessage(FALSE, MSG_MARS_RECVD_MCDATA_PKTS,pMarsStats->TotalMCDataPkts,
													pMarsStats->DiscardedMCDataPkts,
													pMarsStats->ReflectedMCDataPkts);
	DisplayMessage(FALSE, MSG_MARS_MEMBERS, 		pMarsStats->CurrentClusterMembers,
													pMarsStats->MaxClusterMembers);
	DisplayMessage(FALSE, MSG_MARS_PROMIS, 			pMarsStats->CurrentPromiscuous,
    												pMarsStats->MaxPromiscuous);
	DisplayMessage(FALSE, MSG_MARS_ADD_PARTY, 		pMarsStats->TotalCCVCAddParties,
													pMarsStats->FailedCCVCAddParties);
	DisplayMessage(FALSE, MSG_MARS_REGISTRATION,	pMarsStats->RegistrationRequests,
													pMarsStats->FailedRegistrations);
	DisplayMessage(FALSE, MSG_MARS_JOINS,	 		pMarsStats->TotalJoins,
													pMarsStats->FailedJoins,
													pMarsStats->DuplicateJoins);
	DisplayMessage(FALSE, MSG_MARS_LEAVES,	 		pMarsStats->TotalLeaves,
													pMarsStats->FailedLeaves);
	DisplayMessage(FALSE, MSG_MARS_REQUESTS, 		pMarsStats->TotalRequests);
	DisplayMessage(FALSE, MSG_MARS_RESPONSES,	 	pMarsStats->VCMeshAcks
												    +pMarsStats->MCSAcks,
												    pMarsStats->Naks);
	DisplayMessage(FALSE, MSG_MARS_VC_MESH,	 		pMarsStats->SuccessfulVCMeshJoins,
												    pMarsStats->VCMeshAcks);
	DisplayMessage(FALSE, MSG_MARS_GROUPS,	 		pMarsStats->CurrentGroups,
    												pMarsStats->MaxGroups);
	DisplayMessage(FALSE, MSG_MARS_GROUP_SIZE,	 	pMarsStats->MaxAddressesPerGroup);

}


	
void
DoAAS(OPTIONS *po)
{
	HANDLE	DeviceHandle;
	char 	InterfacesBuffer[1024];
	PINTERFACES pInterfaces = (PINTERFACES) InterfacesBuffer;
	ULONG		cbInterfaces = sizeof(InterfacesBuffer);


#if 0
	PUNICODE_STRING				pAdapterName;
	PUNICODE_STRING				pElanName;
	ULONG						i, j;
	BOOL						Result;
#endif // 0
	
	DisplayMessage(FALSE, MSG_ATMARPS_BANNER);

	DeviceHandle = OpenDevice(pDeviceName);
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		DisplayMessage(FALSE, MSG_ERROR_OPENING_ATMARPS);
		return;
	}

	//
	//	First check the version
	//
	if (!CheckVersion(DeviceHandle))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	//
	//	get the list of available adapters
	//
	if (!AasGetInterfaces(DeviceHandle, pInterfaces, cbInterfaces))
	{
		CloseDevice(DeviceHandle);
		return;
	}

	// printf ( " Looping through interfaces...\n");
	//
	//	Loop thru the interfaces, displaying info about each.
	//
	{
		UINT u=0;

		for (u=0;u<pInterfaces->NumberOfInterfaces;u++)
		{
			CHAR 	Buffer[4000];
			ULONG	cbBuffer = sizeof(Buffer);
			PIOCTL_QUERY_CACHE pArpCache
								 = (PIOCTL_QUERY_CACHE) Buffer;
			PIOCTL_QUERY_MARS_CACHE pMarsCache
								 = (PIOCTL_QUERY_MARS_CACHE) Buffer;
			INTERFACE_NAME *pInterface = (pInterfaces->Interfaces)+u;
			PARP_SERVER_STATISTICS  pArpStats  = (PARP_SERVER_STATISTICS)  Buffer;
			PMARS_SERVER_STATISTICS pMarsStats = (PMARS_SERVER_STATISTICS) Buffer;
			UINT		StartIndex;

			//
			// Display the interface name -- must be null terminated.
			//
			{
				WCHAR *pwc = pInterface->Buffer+pInterface->Length/sizeof(WCHAR);
				WCHAR wc = *pwc;
				*pwc = 0;
				DisplayMessage(FALSE, MSG_ADAPTER, pInterface->Buffer );
				*pwc = wc;
			}

			if (po->DispCache)
			{
				StartIndex = pArpCache->StartEntryIndex = 0;

				DisplayMessage(FALSE,  MSG_AAS_C00_ARP_CACHE);

				while (AasGetArpCache(DeviceHandle, pInterface, pArpCache, cbBuffer) &&
						pArpCache->Entries.NumberOfEntriesInBuffer)
				{
					AasDisplayArpCache(pArpCache);
					StartIndex += pArpCache->Entries.NumberOfEntriesInBuffer;
					pArpCache->StartEntryIndex = StartIndex;
					if (StartIndex == pArpCache->Entries.TotalNumberOfEntries)
					{
						break;
					}
				}
	
				StartIndex = pMarsCache->StartEntryIndex = 0;

				DisplayMessage(FALSE,  MSG_AAS_C00_MARS_CACHE);

				while (AasGetMarsCache(DeviceHandle, pInterface, pMarsCache, cbBuffer) &&
						pMarsCache->MarsCache.NumberOfEntriesInBuffer)
				{
					AasDisplayMarsCache(pMarsCache);
					StartIndex += pMarsCache->MarsCache.NumberOfEntriesInBuffer;
					pMarsCache->StartEntryIndex = StartIndex;
				}
			}

			if (po->DispStats)
			{
				if (AasGetArpStats(DeviceHandle, pInterface, pArpStats))
				{
					AasDisplayArpStats(pArpStats);
				}
	
				if (AasGetMarsStats(DeviceHandle, pInterface, pMarsStats))
				{
					AasDisplayMarsStats(pMarsStats);
				}
			}

			if (po->DoResetStats)
			{
				AasResetStatistics(DeviceHandle, pInterface);
			}
		}
	}

#if 0
	//
	//	Loop thru the adapters getting each adapter's elan list
	//
	pAdapterName = &pAdapterList->AdapterList;
	for (i = 0; i < pAdapterList->AdapterCountReturned; i++)
	{
		DisplayMessage(FALSE, MSG_ADAPTER, 
			(PWSTR)((PUCHAR)pAdapterName + sizeof(UNICODE_STRING)));

		if (GetElanList(DeviceHandle, pAdapterName))
		{

			//
			//	Loop thru the elan list getting ELAN info
			//
			pElanName = &pElanList->ElanList;
			for (j = 0; j < pElanList->ElanCountReturned; j++)
			{
				DisplayMessage(FALSE, MSG_ELAN, 
					(PWSTR)((PUCHAR)pElanName + sizeof(UNICODE_STRING)));

				if (GetElanInfo(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanInfo();
				}

				if (GetElanArpTable(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanArpTable();
				}

				if (GetElanConnTable(DeviceHandle, pAdapterName, pElanName))
				{
					DisplayElanConnTable();
				}

				//
				//	next elan
				//
				pElanName = (PUNICODE_STRING)((PUCHAR)pElanName +
						sizeof(UNICODE_STRING) + pElanName->Length);
			}

		}

		//
		//	next adapter
		//
		pAdapterName = (PUNICODE_STRING)((PUCHAR)pAdapterName +
				sizeof(UNICODE_STRING) + pAdapterName->Length);
	}
#endif // 0

	CloseDevice(DeviceHandle);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarp\atmarp.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	atmlane.c

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include "common.h"
#include "atmmsg.h"

BOOL
ParseCmdLine(
	int argc, 
	char * argv[]
	);

OPTIONS g;

void 
Usage(void);
	
VOID __cdecl
main(
	INT			argc,
	CHAR		*argv[]
)
{

	//
	// Parse args, determine if this is concerns the arp client or server.
	//
	if(!ParseCmdLine(argc, argv)){
		Usage();
		return;
	}

	DoAAS(&g);

	//
	// Following tries to open atmarpc.sys...
	//
	// DoAAC(&g);

}

void 
Usage(void)
{
	printf( "\n  Windows NT IP/ATM Information\n\n");
	printf(
		"USAGE:     atmarp [/s] [/c] [/reset]\n");

	printf(
		"  Options\n"
		"      /?       Display this help message.\n"
		"      /s       Display statistics for the ARP and MARS server.\n"
		"      /c       Display the ARP and MARS caches.\n"
		"      /reset   Reset the ARP and MARS statistics.\n\n"
		);
	
	printf(
		"The default is to display only the ARP and MARS statistics.\n\n"
		);
}

UINT FindOption(
	char *lptOpt, 
	char **ppVal
	);

enum
{
DISP_HELP,
DISP_STATS,
DISP_CACHES,
DO_RESET,
UNKNOWN_OPTION
};

struct _CmdOptions {
    char *  lptOption;
    UINT    uOpt;
} CmdOptions[]    = {
                      {"/?"		, DISP_HELP		    },
                      {"-?"		, DISP_HELP		    },
                      {"/s"		, DISP_STATS		},
                      {"-s"		, DISP_STATS		},
                      {"/c"		, DISP_CACHES		},
                      {"-c"		, DISP_CACHES		},
                      {"/reset"	, DO_RESET			},
                      {"-reset"	, DO_RESET			}
                    };
INT iCmdOptionsCounts = sizeof(CmdOptions)/sizeof(struct _CmdOptions);


BOOL
ParseCmdLine(
	int argc, 
	char * argv[]
	)
{
	BOOL	bRetVal = TRUE;
	int		iIndx;
	UINT	uOpt;
	char	*pVal;

	for(iIndx = 1; iIndx < argc; iIndx++)
	{
		
		uOpt = FindOption(argv[iIndx], &pVal);

		switch(uOpt){

		case DISP_STATS:
			g.DispStats = TRUE;
			break;

		case DISP_CACHES:
			g.DispCache = TRUE;
			break;

		case DO_RESET:
			g.DoResetStats = TRUE;
			break;
		
		default:
			printf("Unknown option - %s\n", argv[iIndx]); // fall through
		case DISP_HELP:
			bRetVal = FALSE;
		}
	}

	if (argc<=1)
	{
		//
		// Set default
		//
		g.DispStats = TRUE;
	}

	return bRetVal;
}


UINT FindOption(
	char *lptOpt, 
	char **ppVal
	)
{
int		i;
UINT    iLen;

    for(i = 0; i < iCmdOptionsCounts; i++){
		if(strlen(lptOpt) >= (iLen = strlen(CmdOptions[i].lptOption)))
			if(0 == _strnicmp(lptOpt, CmdOptions[i].lptOption, iLen)){
				*ppVal = lptOpt + iLen;
				return CmdOptions[i].uOpt;
			}
	}

    return UNKNOWN_OPTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\aaqos.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	aaqos.h

Abstract:

	QOS structures and definitions for the ATMARP module.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-07-96    Created

Notes:

--*/

#ifndef _AAQOS__H
#define _AAQOS__H

//
//  Encapsulation method used on a VC.
//
typedef enum
{
	ENCAPSULATION_TYPE_LLCSNAP,		// LLC/SNAP encapsulation
	ENCAPSULATION_TYPE_NULL			// NULL encapsulation

} ATMARP_VC_ENCAPSULATION_TYPE, *PATMARP_VC_ENCAPSULATION_TYPE;


//
//  Flow specifications for an ATMARP connection.
//
typedef struct _ATMARP_FLOW_SPEC
{
	ULONG							SendAvgBandwidth;		// Bytes/sec
	ULONG							SendPeakBandwidth;		// Bytes/sec
	ULONG							SendMaxSize;			// Bytes
	SERVICETYPE						SendServiceType;
	ULONG							ReceiveAvgBandwidth;	// Bytes/sec
	ULONG							ReceivePeakBandwidth;	// Bytes/sec
	ULONG							ReceiveMaxSize;			// Bytes
	SERVICETYPE						ReceiveServiceType;
	ATMARP_VC_ENCAPSULATION_TYPE	Encapsulation;
	ULONG							AgingTime;

} ATMARP_FLOW_SPEC, *PATMARP_FLOW_SPEC;


//
//  Filter specifications for an ATMARP connection.
//
typedef struct _ATMARP_FILTER_SPEC
{
	ULONG							DestinationPort;// IP port number

} ATMARP_FILTER_SPEC, *PATMARP_FILTER_SPEC;

//
//  The wild-card IP port number matches all destination ports
//
#define AA_IP_PORT_WILD_CARD		((ULONG)-1)

//
// The instance name of a flow is a FIXED size array, of the form below,
// and is embedded in the ATMARP_FLOW_INFO struct.
// The 8-character all-zeros field is filled in with the "flow number", which
// is guaranteed to be unique across all existing flows within atmarpc (
// the number may be recycled as flows come and go).
// The "A993E347" constant is a random number that represents a signature
// that with high probability is unique to atmarpc.
//
// We should re-visit this naming scheme once QOS mandates a more structured
// mechanism for naming flows.
//
#define AA_FLOW_INSTANCE_NAME_TEMPLATE	L"00000000:A993E347"
#define AA_FLOW_INSTANCE_NAME_LEN \
		((sizeof(AA_FLOW_INSTANCE_NAME_TEMPLATE)/sizeof(WCHAR))-1)

//
//  The FLOW INFO structure represents a flow instantiated by, for
//  example, RSVP.
//
//  One of these structures is created when the Generic Packet Classifier
//  (GPC) notifies us about a flow creation.
//
typedef struct _ATMARP_FLOW_INFO
{
	struct _ATMARP_FLOW_INFO *		pNextFlow;
	struct _ATMARP_FLOW_INFO *		pPrevFlow;
#ifdef GPC
	PVOID							VcContext;
	GPC_HANDLE						CfInfoHandle;
	WCHAR							FlowInstanceName[AA_FLOW_INSTANCE_NAME_LEN];
#endif // GPC
	ULONG							PacketSizeLimit;
	ATMARP_FILTER_SPEC				FilterSpec;
	ATMARP_FLOW_SPEC				FlowSpec;

} ATMARP_FLOW_INFO, *PATMARP_FLOW_INFO;


#ifdef QOS_HEURISTICS


typedef enum _ATMARP_FLOW_TYPES
{
	AA_FLOW_TYPE_LOW_BW,
	AA_FLOW_TYPE_HIGH_BW,
	AA_FLOW_TYPE_MAX

} ATMARP_FLOW_TYPES;


//
//  Default QOS parameters for a Low Bandwidth VC
//
#define AAF_DEF_LOWBW_SEND_BANDWIDTH			6000	// Bytes/Sec
#define AAF_DEF_LOWBW_RECV_BANDWIDTH			6000	// Bytes/Sec
#define AAF_DEF_LOWBW_SERVICETYPE			SERVICETYPE_BESTEFFORT
#define AAF_DEF_LOWBW_ENCAPSULATION			ENCAPSULATION_TYPE_LLCSNAP
#define AAF_DEF_LOWBW_AGING_TIME				  30	// Seconds
#define AAF_DEF_LOWBW_SEND_THRESHOLD		    1024	// Bytes

#define AAF_DEF_HIGHBW_SEND_BANDWIDTH		  250000	// Bytes/Sec
#define AAF_DEF_HIGHBW_RECV_BANDWIDTH			6000	// Bytes/Sec
#define AAF_DEF_HIGHBW_SERVICETYPE			SERVICETYPE_GUARANTEED
#define AAF_DEF_HIGHBW_ENCAPSULATION		ENCAPSULATION_TYPE_LLCSNAP
#define AAF_DEF_HIGHBW_AGING_TIME				  10	// Seconds

#endif // QOS_HEURISTICS

//
//  Filter and Flow spec extractor function template:
//  Given a packet, it extracts flow and filter info out of it.
//
typedef
VOID
(*PAA_GET_PACKET_SPEC_FUNC)(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PATMARP_FLOW_INFO			*ppFlowInfo,
	OUT	PATMARP_FLOW_SPEC *			ppFlowSpec,
	OUT	PATMARP_FILTER_SPEC *		ppFilterSpec
);

#define NULL_PAA_GET_PACKET_SPEC_FUNC	((PAA_GET_PACKET_SPEC_FUNC)NULL)

//
//  Flow-spec matcher function template
//
typedef
BOOLEAN
(*PAA_FLOW_SPEC_MATCH_FUNC)(
	IN	PVOID					Context,
	IN	PATMARP_FLOW_SPEC		pSourceFlowSpec,
	IN	PATMARP_FLOW_SPEC		pTargetFlowSpec
);

#define NULL_PAA_FLOW_SPEC_MATCH_FUNC	((PAA_FLOW_SPEC_MATCH_FUNC)NULL)


//
//  Filter-spec matcher function template
//
typedef
BOOLEAN
(*PAA_FILTER_SPEC_MATCH_FUNC)(
	IN	PVOID					Context,
	IN	PATMARP_FILTER_SPEC		pSourceFilterSpec,
	IN	PATMARP_FILTER_SPEC		pTargetFilterSpec
);

#define NULL_PAA_FILTER_SPEC_MATCH_FUNC	((PAA_FILTER_SPEC_MATCH_FUNC)NULL)


#ifdef GPC

#define GpcRegisterClient		(pAtmArpGlobalInfo->GpcCalls.GpcRegisterClientHandler)
#define GpcClassifyPacket		(AtmArpGpcClassifyPacketHandler)
#define GpcDeregisterClient		(pAtmArpGlobalInfo->GpcCalls.GpcDeregisterClientHandler)
#define GpcGetCfInfoClientContext (AtmArpGpcGetCfInfoClientContextHandler)

#endif // GPC

#endif	// _AAQOS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\aawmi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	aawmi.h

Abstract:

	Structures and definitions for WMI support in ATMARP Client.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     12-17-97    Created

Notes:

--*/

#ifndef _AAWMI__H
#define _AAWMI__H



#define ATMARP_MOF_RESOURCE_NAME		L"AtmArpMofResource"
#define ATMARP_WMI_VERSION				1

//
//  Get a pointer to the ATMARP Interface structure from
//  the Device Extension field in a Device Object.
//
#define AA_PDO_TO_INTERFACE(_pDevObj)	\
			(*(PATMARP_INTERFACE *)((_pDevObj)->DeviceExtension))


//
//  A local smaller ID is used to simplify processing.
//
typedef ULONG		ATMARP_GUID_ID;

#define AAGID_QOS_TC_SUPPORTED					((ATMARP_GUID_ID)0)
#define AAGID_QOS_TC_INTERFACE_UP_INDICATION	((ATMARP_GUID_ID)1)
#define AAGID_QOS_TC_INTERFACE_DOWN_INDICATION	((ATMARP_GUID_ID)2)
#define AAGID_QOS_TC_INTERFACE_CHG_INDICATION	((ATMARP_GUID_ID)3)


typedef
NTSTATUS
(*PAA_WMI_QUERY_FUNCTION)(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
	);

typedef
NTSTATUS
(*PAA_WMI_SET_FUNCTION)(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						BytesNeeded
	);


typedef
VOID
(*PAA_WMI_ENABLE_EVENT_FUNCTION)(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
	);



//
//  Info about each supported GUID.
//
typedef struct _ATMARP_WMI_GUID
{
	ATMARP_GUID_ID					MyId;
	GUID							Guid;
	ULONG							Flags;
	PAA_WMI_QUERY_FUNCTION			QueryHandler;
	PAA_WMI_SET_FUNCTION			SetHandler;
	PAA_WMI_ENABLE_EVENT_FUNCTION	EnableEventHandler;

} ATMARP_WMI_GUID, *PATMARP_WMI_GUID;

//
//  Definitions of bits in Flags in ATMARP_WMI_GUID
//
#define AWGF_EVENT_ENABLED			((ULONG)0x00000001)
#define AWGF_EVENT_DISABLED			((ULONG)0x00000000)
#define AWGF_EVENT_MASK				((ULONG)0x00000001)


//
//  Per-interface WMI information.
//
typedef struct _ATMARP_IF_WMI_INFO
{
	NDIS_STRING						InstanceName;	// Instance name for all GUIDs
													// on this Interface.
	PDEVICE_OBJECT					pDeviceObject;
	ULONG							GuidCount;		// # elements in array below.
	ATMARP_WMI_GUID					GuidInfo[1];

} ATMARP_IF_WMI_INFO, *PATMARP_IF_WMI_INFO;



#endif _AA_WMI__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarp\utils.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	utils.c

Abstract:

	ATM ARP Admin Utility.

	Usage:

		atmarp 

Revision History:

	Who			When		What
	--------	--------	---------------------------------------------
	josephj 	06-10-1998	Created (adapted from atmlane admin utility).

Notes:

	Modelled after atmlane utility.

--*/

#include "common.h"

//
//  LoadMessageTable
//
//  Loads internationalizable strings into a table, replacing the default for
//  each. If an error occurs, the English language default is left in place.
//
//
VOID
LoadMessageTable(
	PMESSAGE_STRING	Table,
	UINT MessageCount
)
{
    LPTSTR string;
    DWORD count;

    //
    // for all messages in a MESSAGE_STRING table, load the string from this
    // module, replacing the default string in the table (only there in case
    // we get an error while loading the string, so we at least have English
    // to fall back on)
    //

    while (MessageCount--) {
        if (Table->Message != MSG_NO_MESSAGE) {

            //
            // we really want LoadString here, but LoadString doesn't indicate
            // how big the string is, so it doesn't give us an opportunity to
            // allocate exactly the right buffer size. FormatMessage does the
            // right thing
            //

            count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                  | FORMAT_MESSAGE_FROM_HMODULE,
                                  NULL, // use default hModule
                                  Table->Message,
                                  0,    // use default language
                                  (LPTSTR)&string,
                                  0,    // minimum size to allocate
                                  NULL  // no arguments for inclusion in strings
                                  );
            if (count) {

                //
                // Format message returned the string: replace the English
                // language default
                //

                Table->String = string;
            } else {

                //
                // this is ok if there is no string (e.g. just %0) in the .mc
                // file
                //

                Table->String = TEXT("");
            }
        }
        ++Table;
    }
}


VOID
DisplayMessage(
	IN	BOOLEAN			Tabbed,
	IN	DWORD			MessageId,
	...
)
{
	va_list		pArg;
	CHAR		MessageBuffer[2048];
	INT			Count;

	va_start(pArg, MessageId);

	Count = FormatMessage(
				FORMAT_MESSAGE_FROM_HMODULE,
				NULL,				// default hModule
				MessageId,
				0,					// default language
				MessageBuffer,
				sizeof(MessageBuffer),
				&pArg
				);

	va_end(pArg);

	if (Tabbed)
	{
		putchar('\t');
	}

	printf(MessageBuffer);
}

HANDLE
OpenDevice(
	CHAR	*pDeviceName
)
{
	DWORD	DesiredAccess;
	DWORD	ShareMode;
	LPSECURITY_ATTRIBUTES	lpSecurityAttributes = NULL;

	DWORD	CreationDistribution;
	DWORD	FlagsAndAttributes;
	HANDLE	TemplateFile;
	HANDLE	Handle;

	DesiredAccess = GENERIC_READ|GENERIC_WRITE;
	ShareMode = 0;
	CreationDistribution = OPEN_EXISTING;
	FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
	TemplateFile = (HANDLE)INVALID_HANDLE_VALUE;

	Handle = CreateFile(
				pDeviceName,
				DesiredAccess,
				ShareMode,
				lpSecurityAttributes,
				CreationDistribution,
				FlagsAndAttributes,
				TemplateFile
			);

	return (Handle);
}


VOID
CloseDevice(
	HANDLE		DeviceHandle
)
{
	CloseHandle(DeviceHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\adapter.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	adapter.c	- Adapter Interface routines.

Abstract:

	Handlers for adapter events are here. The only exception is the
	CoReceivePacket handler, which is in arppkt.c.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-12-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'PADA'

ULONG		MCastSendOk = 0;
ULONG		MCastSendFail = 0;
ULONG		MCastRcv = 0;


INT
AtmArpBindAdapterHandler(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					BindContext,
	IN	PNDIS_STRING				pDeviceName,
	IN	PVOID						SystemSpecific1,
	IN	PVOID						SystemSpecific2
)

/*++

Routine Description:

	This is called by NDIS when it has an adapter for which there is a
	binding to the ATMARP client.

	We first allocate an Adapter structure. Then we open our configuration
	section for this adapter and save the handle in the Adapter structure.
	Finally, we open the adapter.

	We don't do anything more for this adapter until NDIS notifies us of
	the presence of a Call manager (via our AfRegisterNotify handler).

Arguments:

	pStatus				- Place to return status of this call
	BindContext			- Not used, because we don't pend this call 
	pDeviceName			- The name of the adapter we are requested to bind to
	SystemSpecific1		- Opaque to us; to be used to access configuration info
	SystemSpecific2		- Opaque to us; not used.

Return Value:

	Always TRUE. We set *pStatus to an error code if something goes wrong before we
	call NdisOpenAdapter, otherwise NDIS_STATUS_PENDING.

--*/
{
	PATMARP_ADAPTER				pAdapter;			// Pointer to new adapter structure
	PATMARP_ADAPTER *			ppAdapter;			// Used in case we need to delink
	NDIS_STATUS					Status;
	NDIS_STATUS					OpenStatus;
	UINT						MediumIndex;
	ULONG						Length;
	PNDIS_STRING				pAdapterConfigString;
#ifdef ATMARP_WIN98
	PANSI_STRING				pAnsiConfigString;
	NDIS_STRING					UnicodeConfigString;
#endif

	AADEBUGP(AAD_LOUD,
		 ("BindAdapter: Context 0x%x, pDevName 0x%x, SS1 0x%x, SS2 0x%x\n",
					BindContext, pDeviceName, SystemSpecific1, SystemSpecific2));

#if DBG
	if (AaSkipAll)
	{
		AADEBUGP(AAD_ERROR, ("BindAdapter: aborting\n"));
		*pStatus = NDIS_STATUS_NOT_RECOGNIZED;
		return ((INT)TRUE);
	}
#endif // DBG

	//
	//  Initialize.
	//
	pAdapter = NULL_PATMARP_ADAPTER;
	Status = NDIS_STATUS_SUCCESS;
#ifdef ATMARP_WIN98
	UnicodeConfigString.Buffer = NULL;
#endif

	do
	{
#ifndef ATMARP_WIN98
		pAdapterConfigString = (PNDIS_STRING)SystemSpecific1;
#else
		//
		//  SS1 is a pointer to an ANSI string. Convert it to Unicode.
		//
		pAnsiConfigString = (PANSI_STRING)SystemSpecific1;
		AA_ALLOC_MEM(UnicodeConfigString.Buffer, WCHAR, sizeof(WCHAR)*(pAnsiConfigString->MaximumLength));
		if (UnicodeConfigString.Buffer == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		UnicodeConfigString.MaximumLength = sizeof(WCHAR) * (pAnsiConfigString->MaximumLength);
		UnicodeConfigString.Length = 0;
		NdisAnsiStringToUnicodeString(&UnicodeConfigString, pAnsiConfigString);
		pAdapterConfigString = &UnicodeConfigString;
#endif

		//
		//  Check if this is a device we have already bound to.
		//
		if (AtmArpIsDeviceAlreadyBound(pDeviceName))
		{
			Status = NDIS_STATUS_NOT_ACCEPTED;
			AADEBUGP(AAD_WARNING, ("BindAdapter: already bound to %Z\n", pDeviceName));
			break;
		}

		//
		//  Allocate an Adapter structure
		//
		Length = sizeof(ATMARP_ADAPTER) + pDeviceName->MaximumLength + sizeof(WCHAR) + pAdapterConfigString->MaximumLength;

		AA_ALLOC_MEM(pAdapter, ATMARP_ADAPTER, Length);
		if (pAdapter == NULL_PATMARP_ADAPTER)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Initialize the Adapter structure
		//
		AA_SET_MEM(pAdapter, 0, Length);
#if DBG
		pAdapter->aaa_sig = aaa_signature;
#endif // DBG
		AA_INIT_BLOCK_STRUCT(&(pAdapter->Block));

		pAdapter->SystemSpecific1 = SystemSpecific1;
		pAdapter->SystemSpecific2 = SystemSpecific2;
		pAdapter->BindContext = BindContext;

		pAdapter->DeviceName.MaximumLength = pDeviceName->MaximumLength;
		pAdapter->DeviceName.Length = pDeviceName->Length;
		pAdapter->DeviceName.Buffer = (PWCHAR)((PUCHAR)pAdapter + sizeof(ATMARP_ADAPTER));

		AA_COPY_MEM(pAdapter->DeviceName.Buffer,
					pDeviceName->Buffer,
					pDeviceName->Length);

		//
		//  Copy in the string to be used when we want to open our
		//  configuration key for this adapter.
		//
		pAdapter->ConfigString.MaximumLength = pAdapterConfigString->MaximumLength;
		pAdapter->ConfigString.Length = pAdapterConfigString->Length;
		pAdapter->ConfigString.Buffer = (PWCHAR)((PUCHAR)pAdapter + sizeof(ATMARP_ADAPTER)+ pDeviceName->MaximumLength) + sizeof(WCHAR);

		AA_COPY_MEM(pAdapter->ConfigString.Buffer,
					pAdapterConfigString->Buffer,
					pAdapterConfigString->Length);

		AA_INIT_BLOCK_STRUCT(&pAdapter->UnbindBlock);

		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		//
		//  Link this Adapter structure to the global list of adapters.
		//
		pAtmArpGlobalInfo->AdapterCount++;
		pAdapter->pNextAdapter = pAtmArpGlobalInfo->pAdapterList;
		pAtmArpGlobalInfo->pAdapterList = pAdapter;

		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);


		//
		//  Open the adapter
		//
		pAdapter->Medium = NdisMediumAtm;

		NdisOpenAdapter(
			&Status,
			&OpenStatus,
			&(pAdapter->NdisAdapterHandle),
			&(MediumIndex),						// place to return selected medium index
			&pAdapter->Medium,					// Array of medium types
			1,									// Size of Media list
			pAtmArpGlobalInfo->ProtocolHandle,
			(NDIS_HANDLE)pAdapter,				// our context for the adapter binding
			pDeviceName,
			0,									// Open options
			(PSTRING)NULL						// Addressing Info...
			);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpOpenAdapterCompleteHandler(
					(NDIS_HANDLE)pAdapter,
					Status,
					OpenStatus
					);
		}

		Status = NDIS_STATUS_PENDING;

		break;

	}
	while (FALSE);


	if (Status != NDIS_STATUS_PENDING)
	{
		//
		//  We didn't make it upto NdisOpenAdapter. Clean up.
		//
		AADEBUGP(AAD_WARNING, ("BindAdapter: failed with Status 0x%x\n", Status));

		if (pAdapter != NULL_PATMARP_ADAPTER)
		{
			//
			//  Free it. We know we haven't linked it to the global
			//  list of adapters.
			//
			AA_FREE_MEM(pAdapter);
		}
	}

#ifdef ATMARP_WIN98
	if (UnicodeConfigString.Buffer != NULL)
	{
		AA_FREE_MEM(UnicodeConfigString.Buffer);
	}
#endif // ATMARP_WIN98

	*pStatus = Status;

	AADEBUGP(AAD_INFO, ("BindAdapterHandler: returning Status 0x%x\n", Status));
	return ((INT)TRUE);
}



VOID
AtmArpUnbindAdapterHandler(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					UnbindContext
)
/*++

Routine Description:

	This routine is called by NDIS when it wants us to unbind
	from an adapter. Or, this may be called from within our Unload
	handler. We undo the sequence of operations we performed
	in our BindAdapter handler.

Arguments:

	pStatus					- Place to return status of this operation
	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.
	UnbindContext			- This is NULL if this routine is called from
							  within our Unload handler. Otherwise (i.e.
							  NDIS called us), we retain this for later use
							  when calling NdisCompleteUnbindAdapter.

Return Value:

	None. We set *pStatus to NDIS_STATUS_PENDING always.

--*/
{
	PATMARP_ADAPTER			pAdapter;
	PATMARP_INTERFACE		pInterface;
	PATMARP_INTERFACE		pNextInterface;
	NDIS_STATUS				Status;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

    

	AA_GET_ENTRY_IRQL(EntryIrq);

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
	AA_STRUCT_ASSERT(pAdapter, aaa);

	AADEBUGP(AAD_INFO, ("UnbindAdapterHandler: pAdapter 0x%x, UnbindContext 0x%x\n",
					pAdapter, UnbindContext));

	*pStatus = NDIS_STATUS_PENDING;

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Save the unbind context for a possible later call to
	//  NdisCompleteUnbindAdapter.
	//  
	pAdapter->UnbindContext = UnbindContext;
	pAdapter->Flags |= AA_ADAPTER_FLAGS_UNBINDING;

	//
	//  Wait for any AF register processing to finish.
	//
	while (pAdapter->Flags & AA_ADAPTER_FLAGS_PROCESSING_AF)
	{
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		AADEBUGP(AAD_FATAL, ("UnbindAdapter: pAdapter %x, Afregister going on!!!\n", pAdapter));
		Status = AA_WAIT_ON_BLOCK_STRUCT(&(pAdapter->UnbindBlock));
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  If there are no Interfaces on this adapter, we are done.
	//
	if (pAdapter->pInterfaceList == NULL_PATMARP_INTERFACE)
	{
		AtmArpCompleteUnbindAdapter(pAdapter);
		AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
		return;
	}

	//
	//  Mark all interfaces on this adapter.
	//
	for (pInterface = pAdapter->pInterfaceList;
		 pInterface != NULL_PATMARP_INTERFACE;
		 pInterface = pNextInterface)
	{
		pNextInterface = pInterface->pNextInterface;

		AA_ACQUIRE_IF_LOCK(pInterface);
		pInterface->AdminState = pInterface->State = IF_STATUS_DOWN;
		pInterface->LastChangeTime = GetTimeTicks();
		AA_RELEASE_IF_LOCK(pInterface);
	}

	//
	//  Now, bring down each of these interfaces. For each interface,
	//  we tear down the ARP table, and shut down the Call Manager
	//  interface. When this is complete, we will call IP's DelInterface
	//  entry point.
	//
	for (pInterface = pAdapter->pInterfaceList;
		 pInterface != NULL_PATMARP_INTERFACE;
		 pInterface = pNextInterface)
	{
		pNextInterface = pInterface->pNextInterface;

		AtmArpShutdownInterface(pInterface);
	}

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return;
}



VOID
AtmArpCompleteUnbindAdapter(
	IN	PATMARP_ADAPTER				pAdapter
)
/*++

Routine Description:

	Complete the process of adapter unbinding. All Interfaces on this
	adapter are assumed to have been removed.

	If we are unbinding from the adapter as a result of NDIS' call to
	our UnbindAdapter handler, we complete that here.

Arguments:

	pAdapter		- Pointer to the adapter being unbound.

Return Value:

	None

--*/
{
	NDIS_HANDLE			UnbindContext;
	PATMARP_ADAPTER *	ppAdapter;
	NDIS_STATUS			Status;

	UnbindContext = pAdapter->UnbindContext;

	AADEBUGP(AAD_INFO, ("CompleteUnbindAdapter: pAdapter 0x%x, UnbindContext 0x%x\n",
				pAdapter, UnbindContext));

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	if (pAdapter->Flags & AA_ADAPTER_FLAGS_CLOSING)
	{
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		return;
	}

	pAdapter->Flags |= AA_ADAPTER_FLAGS_CLOSING;

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

#if ATMOFFLOAD
	//
	// Disable offload if enabled...
	//
	AtmArpDisableOffload(pAdapter);
#endif // ATMOFFLOAD

	NdisCloseAdapter(
		&Status,
		pAdapter->NdisAdapterHandle
		);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmArpCloseAdapterCompleteHandler(
			(NDIS_HANDLE) pAdapter,
			Status
			);
	}

}


VOID
AtmArpOpenAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
)
/*++

Routine Description:

	This is called by NDIS when a previous call to NdisOpenAdapter
	that had pended has completed. We now complete the BindAdapter
	that lead to this.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.
	Status					- Status of OpenAdapter
	OpenErrorStatus			- Error code in case of failure.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER			pAdapter;
	PATMARP_ADAPTER *		ppAdapter;
	NDIS_HANDLE				BindAdapterContext;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;

	AA_STRUCT_ASSERT(pAdapter, aaa);

	BindAdapterContext = pAdapter->BindContext;

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  Remove the adapter from the global list.
		//
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		ppAdapter = &(pAtmArpGlobalInfo->pAdapterList);
		while (*ppAdapter != pAdapter)
		{
			ppAdapter = &((*ppAdapter)->pNextAdapter);
		}
		*ppAdapter = pAdapter->pNextAdapter;

		pAtmArpGlobalInfo->AdapterCount--;

		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		AA_FREE_MEM(pAdapter);
	}
#if ATMOFFLOAD
	else
	{
		//
		// Query and enable offloading
		//
		Status = AtmArpQueryAndEnableOffload(pAdapter);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			//
			// AtmArpQueryAndEnableOffload is not supposed to return unless
			// there's a fatal error -- we don't expect  this.
			//
			AA_ASSERT(FALSE);
		}
	}
#endif //ATMOFFLOAD

	AADEBUGP(AAD_INFO, ("OpenAdapterComplete: pAdapter 0x%x, Status 0x%x\n",
					pAdapter, Status));

	(*(pAtmArpGlobalInfo->pIPBindCompleteRtn))(
		Status,
		BindAdapterContext
		);

	return;
}



VOID
AtmArpCloseAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is called by NDIS when a previous call to NdisCloseAdapter
	that had pended has completed. The thread that called NdisCloseAdapter
	would have blocked itself, so we simply wake it up now.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.
	Status					- Status of CloseAdapter

Return Value:

	None

--*/
{
	PATMARP_ADAPTER			pAdapter;
	NDIS_HANDLE				UnbindContext;
	PATMARP_ADAPTER *	ppAdapter;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;

	AA_STRUCT_ASSERT(pAdapter, aaa);

	UnbindContext = pAdapter->UnbindContext;

	AADEBUGP(AAD_INFO, ("CloseAdapterCompleteHandler: pAdapter 0x%x, UnbindContext 0x%x\n",
				pAdapter, UnbindContext));

	pAdapter->NdisAdapterHandle = NULL;

	//
	//  Remove the adapter from the global list.
	//
	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	ppAdapter = &(pAtmArpGlobalInfo->pAdapterList);
	while (*ppAdapter != pAdapter)
	{
		ppAdapter = &((*ppAdapter)->pNextAdapter);
	}
	*ppAdapter = pAdapter->pNextAdapter;

	pAtmArpGlobalInfo->AdapterCount--;

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Free any structures attached to the adapter structure.
	//
	if (pAdapter->pDescrString != (PUCHAR)NULL)
	{
		AA_FREE_MEM(pAdapter->pDescrString);
	}
    if (pAdapter->IPConfigString.Buffer != NULL)
    {
        AA_FREE_MEM(pAdapter->IPConfigString.Buffer);
    }

	//
	//  Release the adapter structure.
	//
	AA_FREE_MEM(pAdapter);

	//
	//  If NDIS had requested us to Unbind, complete the
	//  request now.
	//
	if (UnbindContext != (NDIS_HANDLE)NULL)
	{
		NdisCompleteUnbindAdapter(
			UnbindContext,
			NDIS_STATUS_SUCCESS
			);
	}
	else
	{
		//
		//  We initiated the unbind from our Unload handler,
		//  which would have been waiting for us to complete.
		//  Wake up that thread now.
		//
		AA_SIGNAL_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block), NDIS_STATUS_SUCCESS);
	}

}



VOID
AtmArpSendCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is the Connection-less Send Complete handler, which signals
	completion of such a Send. Since we don't ever use this feature,
	we don't expect this routine to be called.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("SendCompleteHandler unexpected\n"));
	AA_ASSERT(FALSE);
}



VOID
AtmArpTransferDataCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status,
	IN	UINT						BytesTransferred
)
/*++

Routine Description:

	This is the Connection-less Transfer Data Complete handler, which
	signals completion of a call to NdisTransferData. Since we never
	call NdisTransferData, this routine should never get called.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("TransferDataComplete Handler unexpected!\n"));
	AA_ASSERT(FALSE);
}



VOID
AtmArpResetCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This routine is called when the miniport indicates that a Reset
	operation has just completed. We ignore this event.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.
	Status					- Status of the reset operation.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER			pAdapter;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
	AA_STRUCT_ASSERT(pAdapter, aaa);

	AADEBUGP(AAD_INFO, ("Reset Complete on Adapter 0x%x\n", pAdapter));
}



VOID
AtmArpRequestCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	This is called by NDIS when a previous call we made to NdisRequest() has
	completed. We would be blocked on our adapter structure, waiting for this
	to happen -- wake up the blocked thread.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter structure
	pNdisRequest			- The request that completed
	Status					- Status of the request.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER				pAdapter;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
	AA_STRUCT_ASSERT(pAdapter, aaa);

	AA_SIGNAL_BLOCK_STRUCT(&(pAdapter->Block), Status);
	return;
}



NDIS_STATUS
AtmArpReceiveHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN  NDIS_HANDLE             	MacReceiveContext,
	IN  PVOID                   	pHeaderBuffer,
	IN  UINT                    	HeaderBufferSize,
	IN  PVOID                   	pLookAheadBuffer,
	IN  UINT                    	LookaheadBufferSize,
	IN  UINT                    	PacketSize
)
/*++

Routine Description:

	This is our Connection-less receive handler. Since we only use
	Connection oriented services, this routine should never get called.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("Connectionless ReceiveHandler unexpected\n"));
	AA_ASSERT(FALSE);

	return(NDIS_STATUS_NOT_RECOGNIZED);
}



VOID
AtmArpReceiveCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
)
/*++

Routine Description:

	This is called by NDIS when the miniport is done with receiving
	a bunch of packets, meaning that it is now time to start processing
	them. We simply pass this on to IP (on all IF's configured on this
	adapter).

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER				pAdapter;
	PATMARP_INTERFACE			pInterface;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
	AA_STRUCT_ASSERT(pAdapter, aaa);

	for (pInterface = pAdapter->pInterfaceList;
		 pInterface != NULL_PATMARP_INTERFACE;
		 pInterface = pInterface->pNextInterface)
	{
		(*(pInterface->IPRcvCmpltHandler))();
	}
}




INT
AtmArpReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This is the Connectionless receive handler, which should never be
	called, since we only use Connection Oriented miniport services.

Arguments:

	<Ignored>

Return Value:

	Reference count on the received packet. We always return 0.

--*/
{
	AADEBUGP(AAD_ERROR, ("ReceivePacket Handler unexpected!\n"));
	AA_ASSERT(FALSE);

	return(0);
}



VOID
AtmArpStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
)
/*++

Routine Description:

	This routine is called when the miniport indicates an adapter-wide
	status change. We ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_INFO, ("Status Handler: Bind Ctx 0x%x, Status 0x%x\n",
					ProtocolBindingContext,
					GeneralStatus));
}



VOID
AtmArpStatusCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
)
/*++

Routine Description:

	This routine is called when the miniport wants to tell us about
	completion of a status change (?). Ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_INFO, ("Status Complete Handler: Bind Ctx 0x%x\n",
					ProtocolBindingContext));
}

VOID
AtmArpCoSendCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This routine is called by NDIS when the ATM miniport is finished
	with a packet we had previously sent via NdisCoSendPackets. We first
	check if this packet was generated by us (e.g. ATMARP protocol packet):
	if so, we free this here. Otherwise (packet sent by the IP layer), we
	first remove any header buffer that we had attached to the packet and
	free it, before calling IP's entry point for Transmit Complete.

Arguments:

	Status					- Status of the NdisCoSendPackets.
	ProtocolVcContext		- Our context for the VC on which the packet was sent
							  (i.e. pointer to ATMARP VC).
	pNdisPacket				- The packet whose "send" is being completed.

Return Value:

	None

--*/
{
	PATMARP_VC						pVc;
	PATMARP_INTERFACE				pInterface;
	PacketContext					*PC;			// IP/ARP Info about this packet
	PNDIS_BUFFER					pNdisBuffer;	// First Buffer in this packet
	UINT							TotalLength;
	AA_HEADER_TYPE					HdrType;
	ATMARP_VC_ENCAPSULATION_TYPE	Encapsulation;
	ULONG							rc;

	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

#ifdef VC_REFS_ON_SENDS

	AA_ACQUIRE_VC_LOCK(pVc);

	pInterface = pVc->pInterface;
	Encapsulation = pVc->FlowSpec.Encapsulation;

	rc = AtmArpDereferenceVc(pVc);		// SendComplete

	if (rc != 0)
	{
		pVc->OutstandingSends--;

		if (AA_IS_FLAG_SET(
				pVc->Flags,
				AA_VC_CLOSE_STATE_MASK,
				AA_VC_CLOSE_STATE_CLOSING) &&
			(pVc->OutstandingSends == 0))
		{
			AtmArpCloseCall(pVc);
			//
			//  VC lock is released above.
			//
		}
		else
		{
			AA_RELEASE_VC_LOCK(pVc);
		}
	}

#else

	pInterface = pVc->pInterface;
	Encapsulation = pVc->FlowSpec.Encapsulation;

#endif // VC_REFS_ON_SENDS

	AA_ASSERT(pNdisPacket->Private.Head != NULL);
#if DBG
#if DBG_CO_SEND
	{
		PULONG		pContext;
		extern 	ULONG	OutstandingSends;

		pContext = (PULONG)&(pNdisPacket->WrapperReserved[0]);;
		// Check for duplicate completion:
		AA_ASSERT(*pContext != 'BbBb');
		*pContext = 'BbBb';
		NdisInterlockedDecrement(&OutstandingSends);
	}
#endif // DBG_CO_SEND
#endif // DBG

	NdisQueryPacket(
			pNdisPacket,
			NULL,			// we don't need PhysicalBufferCount
			NULL,			// we don't need BufferCount
			NULL,			// we don't need FirstBuffer (yet)
			&TotalLength
			);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		AA_IF_STAT_ADD(pInterface, OutOctets, TotalLength);
	}
	else if (Status == NDIS_STATUS_RESOURCES)
	{
		AA_IF_STAT_INCR(pInterface, OutDiscards);
	}
	else if (Status != NDIS_STATUS_SUCCESS)
	{
		AA_IF_STAT_INCR(pInterface, OutErrors);
	}


	PC = (PacketContext *)pNdisPacket->ProtocolReserved;

	AADEBUGP(AAD_EXTRA_LOUD,
		("CoSend complete[%s]: VC 0x%x, Pkt 0x%x, Status 0x%x:\n",
				((PC->pc_common.pc_owner != PACKET_OWNER_LINK)? "IP": "ARP"),
				pVc, pNdisPacket, Status));

	//
	//  Check who generated this packet.
	//
	if (PC->pc_common.pc_owner != PACKET_OWNER_LINK)
	{
		//
		//  Belongs to IP. Check if we had prepended an LLC/SNAP header.
		//
		if (Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
		{
			PUCHAR		pPacket;
			UINT		Length;

#ifdef BACK_FILL
			NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
			AA_ASSERT(pNdisBuffer != NULL);
			NdisQueryBuffer(pNdisBuffer, &pPacket, &Length);

			//
			//  Commmon part first: find the header type, and update
			//  statistics.
			//
			if (pPacket[5] == LLC_SNAP_OUI2)
			{
				HdrType = AA_HEADER_TYPE_UNICAST;
				if (Status == NDIS_STATUS_SUCCESS)
				{
					AA_IF_STAT_INCR(pInterface, OutUnicastPkts);
				}
			}
			else
			{
				HdrType = AA_HEADER_TYPE_NUNICAST;
				if (Status == NDIS_STATUS_SUCCESS)
				{
					AA_IF_STAT_INCR(pInterface, OutNonUnicastPkts);
					INCR_STAT(MCastSendOk);
				}
				else
				{
					INCR_STAT(MCastSendFail);
				}
			}

			//
			//  Now check if we had attached a header buffer or not.
			//
			if (AtmArpDoBackFill && AA_BACK_FILL_POSSIBLE(pNdisBuffer))
			{
				ULONG		HeaderLength;

				//
				//  We would have back-filled IP's buffer with the LLC/SNAP
				//  header. Remove the back-fill.
				//
				HeaderLength = ((HdrType == AA_HEADER_TYPE_UNICAST)?
									sizeof(AtmArpLlcSnapHeader) :
#ifdef IPMCAST
									sizeof(AtmArpMcType1ShortHeader));
#else
									0);
#endif // IPMCAST
				(PUCHAR)pNdisBuffer->MappedSystemVa += HeaderLength;
				pNdisBuffer->ByteOffset += HeaderLength;
				pNdisBuffer->ByteCount -= HeaderLength;
			}
			else
			{
				//
				//  The first buffer would be our header buffer. Remove
				//  it from the packet and return to our pool.
				//
				NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
				AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
			}
#else
			//
			//  Free the LLC/SNAP header buffer.
			//
			NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
			AA_ASSERT(pNdisBuffer != NULL);
			NdisQueryBuffer(pNdisBuffer, &pPacket, &Length);
			if (pPacket[5] == LLC_SNAP_OUI2)
			{
				HdrType = AA_HEADER_TYPE_UNICAST;
				if (Status == NDIS_STATUS_SUCCESS)
				{
					AA_IF_STAT_INCR(pInterface, OutUnicastPkts);
				}
			}
			else
			{
				HdrType = AA_HEADER_TYPE_NUNICAST;
				if (Status == NDIS_STATUS_SUCCESS)
				{
					AA_IF_STAT_INCR(pInterface, OutNonUnicastPkts);
					INCR_STAT(MCastSendOk);
				}
				else
				{
					INCR_STAT(MCastSendFail);
				}
			}

			AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
#endif // BACK_FILL
		}

#ifdef PERF
		AadLogSendComplete(pNdisPacket);
#endif // PERF

		//
		//  Inform IP of send completion.
		//
		(*(pInterface->IPTxCmpltHandler))(
					pInterface->IPContext,
					pNdisPacket,
					Status
					);
	}
	else
	{
		//
		//  Packet generated by the ATMARP module. This would be an
		//  ATMARP protocol packet, so free the NDIS buffer now.
		//
		NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
		AA_ASSERT(pNdisBuffer != NULL);

#if DBG
		{
			ULONG	ArpPktLength;
			PUCHAR	ArpPktStart;

			NdisQueryBuffer(pNdisBuffer, (PVOID)&ArpPktStart, &ArpPktLength);
			AADEBUGPDUMP(AAD_EXTRA_LOUD+100, ArpPktStart, ArpPktLength);
		}
#endif // DBG

		AtmArpFreeProtoBuffer(pInterface, pNdisBuffer);
		AtmArpFreePacket(pInterface, pNdisPacket);
	}

	return;
}





VOID
AtmArpCoStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
)
/*++

Routine Description:

	This routine is called when the miniport indicates a status
	change, possibly on a VC. Ignore this.

Arguments:

	<Ignored>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_INFO, ("CoStatus Handler: Bind Ctx 0x%x, VC Ctx 0x%x, Status 0x%x\n",
					ProtocolBindingContext,
					ProtocolVcContext,
					GeneralStatus));
}


/*++
AtmArpCoReceivePacketHandler -- is in arppkt.c
--*/


#ifdef _PNP_POWER_


NDIS_STATUS
AtmArpPnPReconfigHandler(
	IN	PATMARP_ADAPTER				pAdapter OPTIONAL,
	IN	PNET_PNP_EVENT				pNetPnPEvent
)
/*++

Routine Description:

	Handle a reconfig message on the specified adapter. If no adapter
	is specified, it is a global parameter that has changed.

Arguments:

	pAdapter		-  Pointer to our adapter structure
	pNetPnPEvent	-  Pointer to reconfig event

Return Value:

	NDIS_STATUS_SUCCESS always, for now.

--*/
{
	ATMARPC_PNP_RECONFIG_REQUEST UNALIGNED *	pArpReconfigReq;
	PIP_PNP_RECONFIG_REQUEST				pIpReconfigReq;
	NDIS_STATUS								Status;

	pIpReconfigReq = (PIP_PNP_RECONFIG_REQUEST)pNetPnPEvent->Buffer;

	AA_ASSERT(pIpReconfigReq->arpConfigOffset != 0);

	pArpReconfigReq = (ATMARPC_PNP_RECONFIG_REQUEST UNALIGNED *)
						((PUCHAR)pIpReconfigReq + pIpReconfigReq->arpConfigOffset);
	
	AADEBUGP(AAD_WARNING, ("AtmArpPnPReconfig: pIpReconfig 0x%x, arpConfigOffset 0x%x\n",
				pIpReconfigReq, pIpReconfigReq->arpConfigOffset));


    do
    {
    	PATMARP_INTERFACE				pInterface;
    	PATMARP_INTERFACE				pNextInterface;
    	NDIS_STRING				        IPReconfigString;
    	//
    	// Locate the IP interface string passed in...
    	//
    	ULONG uOffset = pArpReconfigReq->IfKeyOffset;

    	if (uOffset == 0)
    	{
            Status = NDIS_STATUS_FAILURE;
            break;
    	}
    	else
    	{
    		//
    		//  ((PUCHAR)pArpReconfigReq + uOffset) points to a
    		// "counted unicode string", which means that it's an array
    		// of words, with the 1st word being the length in characters of
    		// the string (there is no terminating null) and the following
    		// <length> words being the string itself.
    		// We need to create an NDIS_STRING based on this buffer in order
    		// to compare it with each interface's config string.
    		//
        	PWCH pwc = (PWCH) ((PUCHAR)pArpReconfigReq + uOffset);
    		IPReconfigString.Length = sizeof(WCHAR)*pwc[0];
    		IPReconfigString.MaximumLength = IPReconfigString.Length;
    		IPReconfigString.Buffer = pwc+1;

    	}

        //
        //  Do we have a binding context?
        //
        if (pAdapter == NULL_PATMARP_ADAPTER)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }
      

		//
		// We wrap the search in a try-except clause because the passed-in
		// structure could be bogus. Note that we will only test at most
		// as many characters of the passed-in string as the lengths of
		// our internal set of interface config strings.
		//
		try
		{
			//
			// Find the interface associated with this request.
			//
			AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			for (pInterface = pAdapter->pInterfaceList;
 				pInterface != NULL_PATMARP_INTERFACE;
 				pInterface = pNextInterface)
			{
				BOOLEAN		IsEqual = FALSE;

				pNextInterface = pInterface->pNextInterface;
				AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		
				//
				// Compare the IPReconfigString
				// JJ TODO: NdisEqualUnicodeString must be called in PASSIVE level
				// 			we know that the reconfig call is done at passive level,
				//			but how to assert that fact here?
				//			AA_ASSERT(EntryIrq == PASSIVE_LEVEL);
				//
				IsEqual = NdisEqualUnicodeString(
							&IPReconfigString,
							&(pInterface->IPConfigString),
							TRUE							// case insensitive
							);

				AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
				if (IsEqual)
				{
					break;		// found it!
				}
			}
			AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		}
		except (EXCEPTION_EXECUTE_HANDLER)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}
    
    	//
    	// JJ We should find the interface if this adapter has any interfaces
    	// at all -- else it means that we're being sent bogus reconfig
    	// information.
    	//
    	AA_ASSERT(pInterface!= NULL || pAdapter->pInterfaceList==NULL);

        if (pInterface != NULL_PATMARP_INTERFACE)
        {

	        AA_ACQUIRE_IF_LOCK(pInterface);

            //
            // Set it's state to indicate that a reconfig is pending.
            // and save away pNetPnPEvent for completion later.
            //
            if (   pInterface->ReconfigState != RECONFIG_NOT_IN_PROGRESS
                || pInterface->pReconfigEvent != NULL)
            {
	            AA_RELEASE_IF_LOCK(pInterface);
                //
                // We should not get here because this means that
                // we were asked to reconfigure when there was a
                // pending reconfiguration, which is not supposed to happen.
                //
                Status = NDIS_STATUS_FAILURE;
			    AA_ASSERT(FALSE);
            }
            else
            {
                pInterface->ReconfigState = RECONFIG_SHUTDOWN_PENDING;
                pInterface->pReconfigEvent = pNetPnPEvent;
		        pInterface->AdminState = IF_STATUS_DOWN;
                AtmArpReferenceInterface(pInterface); // Reconfig

	            AA_RELEASE_IF_LOCK(pInterface);

                //
                // Initiate shutdown in preparation of a restart.
                // AtmArpShutdown is responsible for
                // completing the ndis reconfig request asynchronously.
                //
                AtmArpShutdownInterface(pInterface);
                Status = NDIS_STATUS_PENDING;
            }

        }
        else
        {

            //
            // We didn't find the interface, fail the request...
            //
        
            Status = NDIS_STATUS_FAILURE;
        }
    } while (FALSE);


	return (Status);
}


NDIS_STATUS
AtmArpPnPEventHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNET_PNP_EVENT				pNetPnPEvent
)
/*++

Routine Description:

	This is the NDIS entry point called when NDIS wants to inform
	us about a PNP/PM event happening on an adapter. If the event
	is for us, we consume it. Otherwise, we pass this event along
	to IP along the first Interface on this adapter.

	When IP is done with it, it will call our IfPnPEventComplete
	routine.

Arguments:

	ProtocolBindingContext	- Our context for this adapter binding, which
							  is a pointer to an ATMARP Adapter structure.

	pNetPnPEvent			- Pointer to the event.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER					pAdapter;
	PATMARP_INTERFACE				pInterface;
	NDIS_STATUS						Status;

	PIP_PNP_RECONFIG_REQUEST		pIpReconfigReq;
	ULONG							Length;

	pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;

#ifdef NT
	do
	{
		pIpReconfigReq = (PIP_PNP_RECONFIG_REQUEST)pNetPnPEvent->Buffer;
		Length = pNetPnPEvent->BufferLength;

		//
		//  Is this directed to us?
		//
		if (pNetPnPEvent->NetEvent == NetEventReconfigure)
		{
			if (Length < sizeof(IP_PNP_RECONFIG_REQUEST))
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			if (pIpReconfigReq->arpConfigOffset != 0)
			{
				Status = AtmArpPnPReconfigHandler(pAdapter, pNetPnPEvent);
				break;
			}
		}

		//
		//  This belongs to IP. Do we have a binding context?
		//
		if (pAdapter == NULL_PATMARP_ADAPTER)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		AA_STRUCT_ASSERT(pAdapter, aaa);
		pInterface = pAdapter->pInterfaceList;

		if ((pInterface != NULL_PATMARP_INTERFACE) &&
			(pInterface->IPContext != NULL))
		{
			AA_ASSERT(pInterface->IPPnPEventHandler != NULL);
			Status = (*pInterface->IPPnPEventHandler)(
						pInterface->IPContext,
						pNetPnPEvent
						);
		}
		else
		{
			Status = NDIS_STATUS_SUCCESS;
		}
		break;
	}
	while (FALSE);
#else
	Status = NDIS_STATUS_SUCCESS;
#endif // NT

	AADEBUGP(AAD_INFO,
			("PnPEventHandler: pIF 0x%x, pEvent 0x%x, Evt 0x%x, Status 0x%x\n",
				 pInterface, pNetPnPEvent, pNetPnPEvent->NetEvent, Status));

	return (Status);
}

#endif // _PNP_POWER_


NDIS_STATUS
AtmArpSendAdapterNdisRequest(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS Request to query an adapter for information.
	If the request pends, block on the ATMARP Adapter structure
	till it completes.

Arguments:

	pAdapter				- Points to ATMARP Adapter structure
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	The NDIS status of the request.

--*/
{
	NDIS_STATUS			Status;

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	AA_INIT_BLOCK_STRUCT(&(pAdapter->Block));

	NdisRequest(
		&Status,
		pAdapter->NdisAdapterHandle,
		pNdisRequest
		);

	if (Status == NDIS_STATUS_PENDING)
	{
		Status = AA_WAIT_ON_BLOCK_STRUCT(&(pAdapter->Block));
	}

	return (Status);
}





NDIS_STATUS
AtmArpGetAdapterInfo(
	IN	PATMARP_ADAPTER			pAdapter
)
/*++

Routine Description:

	Query an adapter for hardware-specific information that we need:
		- burnt in hardware address (ESI part)
		- Max packet size
		- line rate

Arguments:

	pAdapter		- Pointer to ATMARP adapter structure

Return Value:

	NDIS_STATUS_SUCCESS on success.
	Failure code on some non-ignorable failure (such as
	device doesn't support MTU >= 8196).

--*/
{
	NDIS_STATUS				Status;
	NDIS_REQUEST			NdisRequest;
	ULONG					Value;

	//
	//  Initialize.
	//
	AA_SET_MEM(pAdapter->MacAddress, 0, AA_ATM_ESI_LEN);


	do
	{
		//
		//  Description string: we first query this with a 0 length buffer
		//  length, so that we get the actual # of bytes needed. Then we
		//  allocate a buffer for the descriptor string, and use that to
		//  get the actual string.
		//
		Status = AtmArpSendAdapterNdisRequest(
							pAdapter,
							&NdisRequest,
							NdisRequestQueryInformation,
							OID_GEN_CO_VENDOR_DESCRIPTION,
							(PVOID)(pAdapter->pDescrString),
							0
							);
	
		if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
			(Status == NDIS_STATUS_BUFFER_TOO_SHORT))
		{
			//
			//  Now allocate a buffer of the right length.
			//
			pAdapter->DescrLength = NdisRequest.DATA.QUERY_INFORMATION.BytesNeeded;
			AA_ALLOC_MEM(pAdapter->pDescrString, UCHAR, pAdapter->DescrLength);
			if (pAdapter->pDescrString != (PUCHAR)NULL)
			{
				Status = AtmArpSendAdapterNdisRequest(
									pAdapter,
									&NdisRequest,
									NdisRequestQueryInformation,
									OID_GEN_CO_VENDOR_DESCRIPTION,
									(PVOID)(pAdapter->pDescrString),
									pAdapter->DescrLength
									);
			}
			else
			{
				pAdapter->DescrLength = 0;
			}
			AADEBUGP(AAD_LOUD, ("GetAdapterInfo: Query VENDOR Descr2 ret 0x%x, DescrLen %d\n",
 							Status, pAdapter->DescrLength));
		}
		else
		{
			AADEBUGP(AAD_LOUD, ("GetAdapterInfo: Query VENDOR Descr1 ret 0x%x\n", Status));
		}
	
	
		//
		//  MAC Address:
		//
		Status = AtmArpSendAdapterNdisRequest(
							pAdapter,
							&NdisRequest,
							NdisRequestQueryInformation,
							OID_ATM_HW_CURRENT_ADDRESS,
							(PVOID)(pAdapter->MacAddress),
							AA_ATM_ESI_LEN
							);
	
		//
		//  Max Frame Size:
		//
		Status = AtmArpSendAdapterNdisRequest(
							pAdapter,
							&NdisRequest,
							NdisRequestQueryInformation,
							OID_ATM_MAX_AAL5_PACKET_SIZE,
							(PVOID)(&(pAdapter->MaxPacketSize)),
							sizeof(ULONG)
							);
	
		if (Status != NDIS_STATUS_SUCCESS)
		{
			//
			//  Use the default.
			//
			pAdapter->MaxPacketSize = AA_DEF_ATM_MAX_PACKET_SIZE;
		}
	
		if (pAdapter->MaxPacketSize > AA_MAX_ATM_MAX_PACKET_SIZE)
		{
			pAdapter->MaxPacketSize = AA_MAX_ATM_MAX_PACKET_SIZE;
		}
	
		//
		// Check that the adapter support the minimum.
		//
		if (pAdapter->MaxPacketSize < AA_MIN_ATM_MAX_PACKET_SIZE)
		{
			AADEBUGP(AAD_FATAL,
 				("GetAdapterInfo: (FATAL) MaxPacketSize of (%lu) is too small.\n",
									pAdapter->MaxPacketSize));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
	
	
	
		//
		//  Link speed:
		//
		Status = AtmArpSendAdapterNdisRequest(
							pAdapter,
							&NdisRequest,
							NdisRequestQueryInformation,
							OID_GEN_CO_LINK_SPEED,
							(PVOID)(&(pAdapter->LineRate)),
							sizeof(pAdapter->LineRate)
							);
	
		if ((Status != NDIS_STATUS_SUCCESS) ||
			(pAdapter->LineRate.Inbound == 0) ||
			(pAdapter->LineRate.Outbound == 0))
		{
			//
			//  Use the default.
			//
			pAdapter->LineRate.Outbound = pAdapter->LineRate.Inbound = AA_DEF_ATM_LINE_RATE;
			AADEBUGP(AAD_LOUD, ("Using default line rate %d bytes/sec\n",
									AA_DEF_ATM_LINE_RATE));
		}
		else
		{
			//
			//  Convert from 100 bits/sec to bytes/sec
			//
			pAdapter->LineRate.Outbound = (pAdapter->LineRate.Outbound * 100)/8;
			pAdapter->LineRate.Inbound = (pAdapter->LineRate.Inbound * 100)/8;
			AADEBUGP(AAD_LOUD, ("Got line rates from miniport: In %d, Out %d bytes/sec\n",
						pAdapter->LineRate.Outbound,
						pAdapter->LineRate.Inbound));
		}

		Status = NDIS_STATUS_SUCCESS;

	} while(FALSE);

	return Status;
}




NDIS_STATUS
AtmArpSendNdisRequest(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS (non-Connection Oriented) request to the Miniport. We
	allocate an NDIS_REQUEST structure, link the supplied buffer to it,
	and send the request. If the request does not pend, we call our
	completion routine from here.

Arguments:

	pAdapter				- Pointer to our Adapter structure representing
							  the adapter to which the request is to be sent
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	Status of the NdisRequest.

--*/
{
	NDIS_STATUS			Status;

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	NdisRequest(
			&Status,
			pAdapter->NdisAdapterHandle,
			pNdisRequest);
		
	return (Status);
}



VOID
AtmArpShutdownInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Bring down the specified ARP interface.

	We tear down the ARP table, and shut down the Call Manager
	interface. When this is complete, we will call IP's DelInterface
	entry point.

Arguments:

	pInterface				- Points to the Interface to be shut down.

Return Value:

	None

--*/
{
	IP_STATUS				Status;
	INT						i;
	ULONG					rc;
	PATMARP_IP_ENTRY		pIpEntry;
	PATMARP_ATM_ENTRY		pAtmEntry;
	PATMARP_ATM_ENTRY		pNextAtmEntry;
	PATMARP_VC				pVc;
	PATMARP_VC				pNextVc;
	PATMARP_ADAPTER			pAdapter;
	BOOLEAN					WasRunning;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	pAdapter = pInterface->pAdapter;

	//
	//  Wait for any AF register processing to finish.
	//
	while (pAdapter->Flags & AA_ADAPTER_FLAGS_PROCESSING_AF)
	{
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		AADEBUGP(AAD_FATAL, ("ShutdownIf: IF %p, pAdapter %x, Afregister going on!!!\n",
				 pInterface, pAdapter));
		Status = AA_WAIT_ON_BLOCK_STRUCT(&(pAdapter->UnbindBlock));
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Stop any timer running on this interface
	//
	AA_ACQUIRE_IF_LOCK(pInterface);

	if (AtmArpStopTimer(&(pInterface->Timer), pInterface))
	{
		rc = AtmArpDereferenceInterface(pInterface);	// Timer ref
		AA_ASSERT(rc != 0);
	}
#ifdef IPMCAST
	//
	//  Stop any Multicast timer running on this interface
	//
	if (AtmArpStopTimer(&(pInterface->McTimer), pInterface))
	{
		rc = AtmArpDereferenceInterface(pInterface);	// Timer ref
		AA_ASSERT(rc != 0);
	}
#endif
	AA_RELEASE_IF_LOCK(pInterface);

	//
	//  Deregister all SAPs so that we don't get any more
	//  incoming calls.
	//
	AtmArpDeregisterSaps(pInterface);
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	//
	// We set the ARP Table state to "down" -- this will ensure that it
	// will not grow while we are shutting down.
	//
	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
	pInterface->ArpTableUp = FALSE;

	//
	//  Go through the ARP Table and abort all IP entries
	//
	for (i = 0; i < ATMARP_TABLE_SIZE; i++)
	{
		while (pInterface->pArpTable[i] != NULL_PATMARP_IP_ENTRY)
		{
			pIpEntry = pInterface->pArpTable[i];

			AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
			AA_REF_IE(pIpEntry, IE_REFTYPE_TMP);	// Shutdown Interface
			AA_RELEASE_IE_LOCK_DPC(pIpEntry);

		    AA_RELEASE_IF_TABLE_LOCK(pInterface);

			AA_ACQUIRE_IE_LOCK(pIpEntry);
			if (AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP))	// Shutdown Interface
			{
				AtmArpAbortIPEntry(pIpEntry);
				//
				//  IE Lock is released within the above.
				//
			}
			AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
		}
	}
	AA_RELEASE_IF_TABLE_LOCK(pInterface);

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

#ifdef IPMCAST
	//
	//  Delete all Join Entries
	//

	AA_ACQUIRE_IF_LOCK(pInterface);

	{
		PATMARP_IPMC_JOIN_ENTRY	pJoinEntry;
		PATMARP_IPMC_JOIN_ENTRY	pNextJoinEntry;

		for (pJoinEntry = pInterface->pJoinList;
 			pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY;
 			pJoinEntry = pNextJoinEntry)
		{
			WasRunning = AtmArpStopTimer(&(pJoinEntry->Timer), pInterface);
			pNextJoinEntry = pJoinEntry->pNextJoinEntry;

			if (WasRunning)
			{
				rc = AA_DEREF_JE(pJoinEntry);	// ShutdownIF: timer stopped
			}
			else
			{
				rc = pJoinEntry->RefCount;
			}

			if (rc != 0)
			{
				(VOID)AA_DEREF_JE(pJoinEntry);	// ShutdownIF: kill Join Entry
			}
		}

		pInterface->pJoinList = NULL_PATMARP_IPMC_JOIN_ENTRY;
	}

	AA_RELEASE_IF_LOCK(pInterface);

#endif

	//
	// We set the AtmEntry list state to "down" (this will ensure that it
	// will not grow while we are shutting down), then
	// go through the list of ATM Entries on this interface, and
	// abort all of them.
	//

	AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);
	pInterface->AtmEntryListUp = FALSE;

	pNextAtmEntry = pInterface->pAtmEntryList;

	if (pNextAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AA_ACQUIRE_AE_LOCK_DPC(pNextAtmEntry);
		AA_REF_AE(pNextAtmEntry, AE_REFTYPE_TMP);		// ShutdownInterface
		AA_RELEASE_AE_LOCK_DPC(pNextAtmEntry);
	}

	while (pNextAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		pAtmEntry = pNextAtmEntry;
		pNextAtmEntry = pAtmEntry->pNext;

		//
		// Note that we still have the lock to pInterface when
		// we aquire the lock to pAtmEntry below. This order of aquiring
		// locks must be strictly followed everywhere in order to prevent
		// a deadlock.
		//
		// We can't release the LIST_LOCK without first addrefing pAtmEntry,
		// otherwise while both locks are free someone else can delref and
		// possibly deallocate pAtmEntry.
		//
		if (pNextAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
			AA_ACQUIRE_AE_LOCK_DPC(pNextAtmEntry);
			AA_REF_AE(pNextAtmEntry, AE_REFTYPE_TMP);		// ShutdownInterface
			AA_RELEASE_AE_LOCK_DPC(pNextAtmEntry);
		}

		AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);

		AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		if (AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP) != 0)	// ShutdownInterface
		{
			AtmArpInvalidateAtmEntry(
				pAtmEntry,
				TRUE		// we ARE shutting down
				);
			//
			//  The ATM Entry lock is released within the above.
			//
		}

		AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
		AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);
	}
	AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	//
	//  Go through the list of unresolved VCs on this interface,
	//  and close all of them.
	//
	AA_ACQUIRE_IF_LOCK(pInterface);
	pVc = pInterface->pUnresolvedVcs;
	pInterface->pUnresolvedVcs = NULL_PATMARP_VC;

	while (pVc != NULL_PATMARP_VC)
	{
		pNextVc = pVc->pNextVc;

		AA_RELEASE_IF_LOCK(pInterface);

		AA_ACQUIRE_VC_LOCK(pVc);
		if (AtmArpDereferenceVc(pVc) != 0)	// Unresolved VC list entry
		{
			AtmArpCloseCall(pVc);
			//
			//  the VC lock is released within the above.
			//
		}
		
		pVc = pNextVc;
		AA_ACQUIRE_IF_LOCK(pInterface);
	}

	AA_RELEASE_IF_LOCK(pInterface);
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);


	//
	//  Close the Call Manager interface.
	//
	AtmArpCloseCallMgr(pInterface);

}




BOOLEAN
AtmArpIsDeviceAlreadyBound(
	IN	PNDIS_STRING				pDeviceName
)
/*++

Routine Description:

	Check if we have already bound to a device (adapter).

Arguments:

	pDeviceName		- Points to device name to be checked.

Return Value:

	TRUE iff we already have an Adapter structure representing
	this device.

--*/
{
	PATMARP_ADAPTER	pAdapter;
	BOOLEAN			bFound = FALSE;

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	for (pAdapter = pAtmArpGlobalInfo->pAdapterList;
		 pAdapter != NULL_PATMARP_ADAPTER;
		 pAdapter = pAdapter->pNextAdapter)
	{
		if ((pDeviceName->Length == pAdapter->DeviceName.Length) &&
			(AA_MEM_CMP(pDeviceName->Buffer,
						pAdapter->DeviceName.Buffer,
						pDeviceName->Length) == 0))
		{
			bFound = TRUE;
			break;
		}
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	return (bFound);
}

#if ATMOFFLOAD

NDIS_STATUS
AtmArpQueryAndEnableOffload(
	IN	PATMARP_ADAPTER				pAdapter
)
/*++

Routine Description:

	Query the capabilities of the adapter and set all recognized offload capabilities.
	Set pMaxOffLoadSize and pMinSegmentCount to the corresponding values, and
	also set pInterface->OffloadFlags to the set of enabled tasks.


Arguments:

	pAdapter		- The adapter on which to enable offloading.

Return Value:

	TRUE iff the operation was either succesful or no tasks were enabled. False
	if there was a fatal error.

--*/
{
	NDIS_STATUS 				Status 		= STATUS_BUFFER_OVERFLOW;
	PNDIS_TASK_OFFLOAD_HEADER 	pHeader		= NULL;

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	pAdapter->Offload.Flags 			= 0;
	pAdapter->Offload.MaxOffLoadSize	= 0;
	pAdapter->Offload.MinSegmentCount	= 0;
	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	do
	{
        PNDIS_TASK_OFFLOAD  		pTask;
		ULONG						Flags 			= 0;
		UINT 						MaxOffLoadSize	= 0;
		UINT 						MinSegmentCount	= 0;
		NDIS_TASK_IPSEC     		ipsecCaps;
		UINT						BufferSize		= 0;
		NDIS_REQUEST				NdisRequest;

		//
		// Query capabilities
		//
		{
			NDIS_TASK_OFFLOAD_HEADER Header;
			AA_SET_MEM(&Header, 0, sizeof(Header));
	
			Header.EncapsulationFormat.Flags.FixedHeaderSize = 1;
			Header.EncapsulationFormat.EncapsulationHeaderSize =
													AA_PKT_LLC_SNAP_HEADER_LENGTH;
			Header.EncapsulationFormat.Encapsulation = 
													LLC_SNAP_ROUTED_Encapsulation;
			Header.Version = NDIS_TASK_OFFLOAD_VERSION;
			Header.Size = sizeof(Header);
	
			AADEBUGP(AAD_INFO, ("Querying for Task offload\n"));
	
			Status =  AtmArpSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestQueryInformation,
						OID_TCP_TASK_OFFLOAD,
						&Header,
						sizeof(Header)
						);

			if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
				(Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {
	
				//
				// Alloc the proper-sized buffer and query a 2nd time...
				//

				BufferSize = NdisRequest.DATA.QUERY_INFORMATION.BytesNeeded;

				AA_ALLOC_MEM(pHeader, NDIS_TASK_OFFLOAD_HEADER, BufferSize);
	
				if (pHeader != NULL)
				{
					*pHeader = Header; // struct copy.

					Status =  AtmArpSendAdapterNdisRequest(
								pAdapter,
								&NdisRequest,
								NdisRequestQueryInformation,
								OID_TCP_TASK_OFFLOAD,
								pHeader,
								BufferSize
								);
				}
			}
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_INFO, ("Query Offload failed. Status=%x\n", Status));
			break;
		}

		if (	pHeader == NULL
		    ||	pHeader->OffsetFirstTask == 0)
		{
			AADEBUGP(AAD_INFO, ("No tasks to offload\n"));
			break;
		}

		AA_ASSERT(pHeader->OffsetFirstTask == sizeof(NDIS_TASK_OFFLOAD_HEADER));

		AADEBUGP(AAD_WARNING,
			("Something to Offload. Offload buffer size %x\n", BufferSize));

		//
        // Parse the buffer for Checksum and tcplargesend offload capabilities
		//
		for (
			pTask =  (NDIS_TASK_OFFLOAD *) ((UCHAR *)pHeader
											 + pHeader->OffsetFirstTask);
			1; // we break when done
			pTask = (PNDIS_TASK_OFFLOAD) ((PUCHAR)pTask + pTask->OffsetNextTask))
		{

			if (pTask->Task == TcpIpChecksumNdisTask)
			{
				//
				//this adapter supports checksum offload
				//check if tcp and/or  ip chksums bits are present
				//

				PNDIS_TASK_TCP_IP_CHECKSUM ChecksumInfo
						= (PNDIS_TASK_TCP_IP_CHECKSUM) pTask->TaskBuffer;

				// if (ChecksumInfo->V4Transmit.V4Checksum) (commented out in arpc.c)
				{

						AADEBUGP(AAD_INFO, ("V4 Checksum offload\n"));

						if (ChecksumInfo->V4Transmit.TcpChecksum) {
							Flags |= TCP_XMT_CHECKSUM_OFFLOAD;
							AADEBUGP(AAD_INFO, (" Tcp Checksum offload\n"));
						}

						if (ChecksumInfo->V4Transmit.IpChecksum) {
							Flags |= IP_XMT_CHECKSUM_OFFLOAD;
							AADEBUGP(AAD_INFO, (" IP xmt Checksum offload\n"));
						}

						if (ChecksumInfo->V4Receive.TcpChecksum) {
							Flags |= TCP_RCV_CHECKSUM_OFFLOAD;
							AADEBUGP(AAD_INFO, (" Tcp Rcv Checksum offload\n"));
						}

						if (ChecksumInfo->V4Receive.IpChecksum) {
							Flags |= IP_RCV_CHECKSUM_OFFLOAD;
							AADEBUGP(AAD_INFO, (" IP rcv  Checksum offload\n"));
						}
				}

			}
			else if (pTask->Task == TcpLargeSendNdisTask)
			{

				PNDIS_TASK_TCP_LARGE_SEND TcpLargeSend, in_LargeSend =
								(PNDIS_TASK_TCP_LARGE_SEND)pTask->TaskBuffer;

				Flags |= TCP_LARGE_SEND_OFFLOAD;

				MaxOffLoadSize = in_LargeSend->MaxOffLoadSize;
				MinSegmentCount = in_LargeSend->MinSegmentCount;

				AADEBUGP(AAD_INFO, (" Tcp large send!! \n"));

			}
			else if (pTask->Task == IpSecNdisTask)
			{
				PNDIS_TASK_IPSEC pIPSecCaps =
										(PNDIS_TASK_IPSEC) pTask->TaskBuffer;
				//
				// Save off the capabilities for setting them later.
				//
				ipsecCaps = *pIPSecCaps;


                //
                // CryptoOnly is assumed if we have IpSecNdisTask
                //
                Flags |= IPSEC_OFFLOAD_CRYPTO_ONLY;

                //
                // Do Support first
                //

                if (pIPSecCaps->Supported.AH_ESP_COMBINED) {
                       Flags |= IPSEC_OFFLOAD_AH_ESP;
                       AADEBUGP(AAD_INFO, ("AH_ESP\n"));
                }

                if (pIPSecCaps->Supported.TRANSPORT_TUNNEL_COMBINED) {
                       Flags |= IPSEC_OFFLOAD_TPT_TUNNEL;
                       AADEBUGP(AAD_INFO, ("TPT_TUNNEL\n"));
                }

                if (pIPSecCaps->Supported.V4_OPTIONS) {
                       Flags |= IPSEC_OFFLOAD_V4_OPTIONS;
                       AADEBUGP(AAD_INFO, ("V4_OPTIONS\n"));
                }

                if (pIPSecCaps->Supported.RESERVED) {
                       pIPSecCaps->Supported.RESERVED = 0;
                       //Flags |= IPSEC_OFFLOAD_QUERY_SPI;
                       AADEBUGP(AAD_INFO, ("QUERY_SPI\n"));
                }

                //
                // Do V4AH next
                //

                if (pIPSecCaps->V4AH.MD5) {
                       Flags |= IPSEC_OFFLOAD_AH_MD5;
                       AADEBUGP(AAD_INFO, ("MD5\n"));
                }

				if (pIPSecCaps->V4AH.SHA_1) {
					Flags |= IPSEC_OFFLOAD_AH_SHA_1;
					AADEBUGP(AAD_INFO, ("SHA\n"));
				}

				if (pIPSecCaps->V4AH.Transport) {
					Flags |= IPSEC_OFFLOAD_AH_TPT;
					AADEBUGP(AAD_INFO, ("AH_TRANSPORT\n"));
				}

				if (pIPSecCaps->V4AH.Tunnel) {
					Flags |= IPSEC_OFFLOAD_AH_TUNNEL;
					AADEBUGP(AAD_INFO, ("AH_TUNNEL\n"));
				}

				if (pIPSecCaps->V4AH.Send) {
					Flags |= IPSEC_OFFLOAD_AH_XMT;
					AADEBUGP(AAD_INFO, ("AH_XMT\n"));
				}

				if (pIPSecCaps->V4AH.Receive) {
					Flags |= IPSEC_OFFLOAD_AH_RCV;
					AADEBUGP(AAD_INFO, ("AH_RCV\n"));
				}

				//
				// Do V4ESP next
				//

				if (pIPSecCaps->V4ESP.DES) {
					Flags |= IPSEC_OFFLOAD_ESP_DES;
					AADEBUGP(AAD_INFO, ("ESP_DES\n"));
				}

				if (pIPSecCaps->V4ESP.RESERVED) {
				    pIPSecCaps->V4ESP.RESERVED = 0;
					//Flags |= IPSEC_OFFLOAD_ESP_DES_40;
					AADEBUGP(AAD_INFO, ("ESP_DES_40\n"));
				}

				if (pIPSecCaps->V4ESP.TRIPLE_DES) {
					Flags |= IPSEC_OFFLOAD_ESP_3_DES;
					AADEBUGP(AAD_INFO, ("ESP_3_DES\n"));
				}

				if (pIPSecCaps->V4ESP.NULL_ESP) {
					Flags |= IPSEC_OFFLOAD_ESP_NONE;
					AADEBUGP(AAD_INFO, ("ESP_NONE\n"));
				}

				if (pIPSecCaps->V4ESP.Transport) {
					Flags |= IPSEC_OFFLOAD_ESP_TPT;
					AADEBUGP(AAD_INFO, ("ESP_TRANSPORT\n"));
				}

				if (pIPSecCaps->V4ESP.Tunnel) {
					Flags |= IPSEC_OFFLOAD_ESP_TUNNEL;
					AADEBUGP(AAD_INFO, ("ESP_TUNNEL\n"));
				}

				if (pIPSecCaps->V4ESP.Send) {
					Flags |= IPSEC_OFFLOAD_ESP_XMT;
					AADEBUGP(AAD_INFO, ("ESP_XMT\n"));
				}

				if (pIPSecCaps->V4ESP.Receive) {
					Flags |= IPSEC_OFFLOAD_ESP_RCV;
					AADEBUGP(AAD_INFO, ("ESP_RCV\n"));
				}
			}

			if (pTask->OffsetNextTask == 0)
			{
				break; // No more tasks.
			}

		} // for

		//
		// Done parsing supported tasks.
        // Now construct the set of tasks we actually want to enable.
        //
        if (Flags)
        {
        	UINT *pPrevOffset = &pHeader->OffsetFirstTask;

			AADEBUGP(AAD_WARNING, ("Enabling H/W capabilities: %lx\n", Flags));

        	//
        	// Zero out the buffer beyond the task offload header structure
        	//
			AA_SET_MEM(pTask, 0, BufferSize-sizeof(*pHeader));
        	pHeader->OffsetFirstTask = 0;
        	pTask = (NDIS_TASK_OFFLOAD *) (pHeader+1);
	
			if ((Flags & TCP_XMT_CHECKSUM_OFFLOAD) ||
				(Flags & IP_XMT_CHECKSUM_OFFLOAD) ||
				(Flags & TCP_RCV_CHECKSUM_OFFLOAD) ||
				(Flags & IP_RCV_CHECKSUM_OFFLOAD))
			{
	
				PNDIS_TASK_TCP_IP_CHECKSUM ChksumBuf =
						 (PNDIS_TASK_TCP_IP_CHECKSUM)pTask->TaskBuffer;

				*pPrevOffset = (UINT) ((PUCHAR)pTask - (PUCHAR)pHeader);
				pPrevOffset  = &pTask->OffsetNextTask;

				pTask->Task = TcpIpChecksumNdisTask;
				pTask->TaskBufferLength = sizeof(NDIS_TASK_TCP_IP_CHECKSUM);
	
				if (Flags & TCP_XMT_CHECKSUM_OFFLOAD)
				{
					ChksumBuf->V4Transmit.TcpChecksum = 1;
					//ChksumBuf->V4Transmit.V4Checksum = 1;
				}
	
				if (Flags & IP_XMT_CHECKSUM_OFFLOAD)
				{
					ChksumBuf->V4Transmit.IpChecksum = 1;
					//ChksumBuf->V4Transmit.V4Checksum = 1;
				}
	
				if (Flags & TCP_RCV_CHECKSUM_OFFLOAD)
				{
					ChksumBuf->V4Receive.TcpChecksum = 1;
					//ChksumBuf->V4Receive.V4Checksum = 1;
				}
	
				if (Flags & IP_RCV_CHECKSUM_OFFLOAD)
				{
					ChksumBuf->V4Receive.IpChecksum = 1;
					//ChksumBuf->V4Receive.V4Checksum = 1;
				}
	
				//
				// Point to place where next task goes...
				//
				pTask = (PNDIS_TASK_OFFLOAD) (ChksumBuf+1);
	
			}
	
			if (Flags & TCP_LARGE_SEND_OFFLOAD)
			{
	
				PNDIS_TASK_TCP_LARGE_SEND out_LargeSend =
						 (PNDIS_TASK_TCP_LARGE_SEND)pTask->TaskBuffer;
	
				*pPrevOffset = (UINT) ((PUCHAR)pTask - (PUCHAR)pHeader);
				pPrevOffset  = &pTask->OffsetNextTask;

				pTask->Task = TcpLargeSendNdisTask;
				pTask->TaskBufferLength = sizeof(NDIS_TASK_TCP_LARGE_SEND);
	
				out_LargeSend->MaxOffLoadSize = MaxOffLoadSize;
				out_LargeSend->MinSegmentCount = MinSegmentCount;
	
				//
				// Point to place where next task goes...
				//
				pTask = (PNDIS_TASK_OFFLOAD) (out_LargeSend+1);
			}
	
			if ((Flags & (IPSEC_OFFLOAD_AH_XMT |
										IPSEC_OFFLOAD_AH_RCV |
										IPSEC_OFFLOAD_ESP_XMT |
										IPSEC_OFFLOAD_ESP_RCV)))
			{
	
				PNDIS_TASK_IPSEC pIPSecCaps =
							 (PNDIS_TASK_IPSEC)pTask->TaskBuffer;
	
				*pPrevOffset = (UINT) ((PUCHAR)pTask - (PUCHAR)pHeader);
				pPrevOffset  = &pTask->OffsetNextTask;

				//
				// plunk down the advertised capabilities
				//
	
				pTask->Task = IpSecNdisTask;
				pTask->TaskBufferLength = sizeof(NDIS_TASK_IPSEC);
	
				//
				// Point to place where next task goes...
				//
				pTask = (PNDIS_TASK_OFFLOAD) (pIPSecCaps+1);
			}
		}

		//
		// Having constructed the set of tasks to enable, we actually attempt
		// to enable them...
		//
		if (pHeader->OffsetFirstTask)
		{
			//
			//  At least one task to enable, let's enable ...
			//
			UINT SetBufferSize =  (UINT) ((PUCHAR)pTask - (PUCHAR)pHeader);

			AA_ASSERT(SetBufferSize <= BufferSize);
			AADEBUGP(AAD_WARNING,
			("Setting offload tasks: %x bytes. Miniport returned %x bytes\n",
			SetBufferSize, BufferSize));

			Status =  AtmArpSendAdapterNdisRequest(
						pAdapter,
						&NdisRequest,
						NdisRequestSetInformation,
						OID_TCP_TASK_OFFLOAD,
						pHeader,
						SetBufferSize
						);

			if (Status != NDIS_STATUS_SUCCESS)
			{
	
				AADEBUGP(AAD_WARNING,
					("ARP: Failed to set offload tasks: %lx, status: %lx\n",
					 Flags, Status));
			}
			else
			{
				AADEBUGP(AAD_WARNING,
					("ARP: Succeeded setting offload tasks: %lx:\n", Flags));

				AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
				pAdapter->Offload.Flags 			= Flags;
				pAdapter->Offload.MaxOffLoadSize	= MaxOffLoadSize;
				pAdapter->Offload.MinSegmentCount	= MinSegmentCount;
				AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			}
		}

    } while (FALSE);


	if (pHeader != NULL)
	{
		AA_FREE_MEM(pHeader);
	}

	//
	// We return success unless there was a fatal error and there was none...
	//

    return NDIS_STATUS_SUCCESS;
}


VOID
AtmArpDisableOffload(
	IN	PATMARP_ADAPTER			pAdapter
)
/*++

Routine Description:

	Disable offload capabilities, if enabled for this interface.

Arguments:

	pAdapter		- The adapter on which to disable offloading.

Return Value:

	TRUE iff the operation was either succesful or no tasks were enabled. False
	if there was a fatal error.

--*/
{
	ULONG Flags;
	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	Flags =  pAdapter->Offload.Flags;
	pAdapter->Offload.Flags = 0;
	pAdapter->Offload.MaxOffLoadSize	= 0;
	pAdapter->Offload.MinSegmentCount	= 0;

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	if (Flags)
	{
		NDIS_REQUEST				NdisRequest;
		NDIS_TASK_OFFLOAD_HEADER 	Header;
		AA_SET_MEM(&Header, 0, sizeof(Header));
	
		Header.EncapsulationFormat.Flags.FixedHeaderSize = 1;
		Header.EncapsulationFormat.EncapsulationHeaderSize = 2;
		Header.EncapsulationFormat.Encapsulation = 
												LLC_SNAP_ROUTED_Encapsulation;
		Header.Version = NDIS_TASK_OFFLOAD_VERSION;
		Header.Size = sizeof(Header);

		//
		// Header.OffsetFirstTask == 0 tells the miniport to disable all tasks.
		//
	
		AADEBUGP(AAD_WARNING, ("Disabling all offloaded tasks for this adapter\n"));
	
		AtmArpSendAdapterNdisRequest(
					pAdapter,
					&NdisRequest,
					NdisRequestSetInformation,
					OID_TCP_TASK_OFFLOAD,
					&Header,
					sizeof(Header)
					);
	}

}

#endif // ATMOFFLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\arppkt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arppkt.h

Abstract:

	Definitions for ATMARP packets

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-29-96    Created

Notes:

--*/

#ifndef _ARP_PKT__H
#define _ARP_PKT__H




//
//  Rounded-off size of generic Q.2931 IE header
//
#define ROUND_OFF(_size)		(((_size) + 3) & ~0x3)

#define SIZEOF_Q2931_IE	 ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE	ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE	ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE			ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE			ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE			ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))


//
//  Total space required for Information Elements in an outgoing call.
//
#define ATMARP_MAKE_CALL_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )

//
//  Total space required for Information Elements in an outgoing AddParty.
//
#define ATMARP_ADD_PARTY_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE )

#define AA_IPV4_ADDRESS_LENGTH		4

#define	CLASSA_MASK		0x000000ff
#define	CLASSB_MASK		0x0000ffff
#define	CLASSC_MASK		0x00ffffff
#define	CLASSD_MASK		0x000000e0
#define	CLASSE_MASK		0xffffffff

//
//  Standard values
//
#define AA_PKT_ATM_FORUM_AF			19
#define AA_PKT_PRO_IP				((USHORT)0x800)

//
//  Values for the LLC SNAP header
//
#define LLC_SNAP_LLC0				((UCHAR)0xAA)
#define LLC_SNAP_LLC1				((UCHAR)0xAA)
#define LLC_SNAP_LLC2				((UCHAR)0x03)
#define LLC_SNAP_OUI0				((UCHAR)0x00)
#define LLC_SNAP_OUI1				((UCHAR)0x00)
#define LLC_SNAP_OUI2				((UCHAR)0x00)


//
//  Values for EtherType
//
#define AA_PKT_ETHERTYPE_IP_NS		((USHORT)0x0008)
#define AA_PKT_ETHERTYPE_IP			((USHORT)0x800)
#define AA_PKT_ETHERTYPE_ARP		((USHORT)0x806)

#include <pshpack1.h>

//
//  LLC SNAP Header
//
typedef struct _AA_PKT_LLC_SNAP_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						EtherType;
} AA_PKT_LLC_SNAP_HEADER;

typedef AA_PKT_LLC_SNAP_HEADER UNALIGNED *PAA_PKT_LLC_SNAP_HEADER;


//
//  ATMARP Packet Common Header format
//
typedef struct _AA_ARP_PKT_HEADER
{
	AA_PKT_LLC_SNAP_HEADER		LLCSNAPHeader;
	USHORT						hrd;			// Hardware Type
	USHORT						pro;			// Protocol Type
	UCHAR						shtl;			// Source HW Addr Type+Length
	UCHAR						sstl;			// Source HW SubAddr Type+Length
	USHORT						op;				// Operation Code
	UCHAR						spln;			// Source Protocol Addr Length
	UCHAR						thtl;			// Target HW Addr Type+Length
	UCHAR						tstl;			// Target HW SubAddr Type+Length
	UCHAR						tpln;			// Target Protocol Addr Length
	UCHAR						Variable[1];	// Start of the variable part
} AA_ARP_PKT_HEADER;

typedef AA_ARP_PKT_HEADER UNALIGNED *PAA_ARP_PKT_HEADER;


#define AA_PKT_LLC_SNAP_HEADER_LENGTH		(sizeof(AA_PKT_LLC_SNAP_HEADER))
#define AA_ARP_PKT_HEADER_LENGTH			(sizeof(AA_ARP_PKT_HEADER)-1)

#include <poppack.h>

//
//  Values for fields in an ARP packet header
//
#define AA_PKT_HRD							((USHORT)0x0013)
#define AA_PKT_PRO							((USHORT)0x0800)
#define AA_PKT_OP_TYPE_ARP_REQUEST			((USHORT)1)
#define AA_PKT_OP_TYPE_ARP_REPLY			((USHORT)2)
#define AA_PKT_OP_TYPE_INARP_REQUEST		((USHORT)8)
#define AA_PKT_OP_TYPE_INARP_REPLY			((USHORT)9)
#define AA_PKT_OP_TYPE_ARP_NAK				((USHORT)10)

#define AA_PKT_ATM_ADDRESS_NSAP				((UCHAR)0x00)
#define AA_PKT_ATM_ADDRESS_E164				((UCHAR)0x40)
#define AA_PKT_ATM_ADDRESS_BIT				((UCHAR)0x40)


//
//  Internal representation of the contents of an
//  ARP packet:
//
typedef struct _AA_ARP_PKT_CONTENTS
{
	UCHAR						SrcAtmNumberTypeLen;
	UCHAR						SrcAtmSubaddrTypeLen;
	UCHAR						DstAtmNumberTypeLen;
	UCHAR						DstAtmSubaddrTypeLen;
	UCHAR UNALIGNED *			pSrcAtmNumber;
	UCHAR UNALIGNED *			pSrcAtmSubaddress;
	UCHAR UNALIGNED *			pDstAtmNumber;
	UCHAR UNALIGNED *			pDstAtmSubaddress;
	UCHAR UNALIGNED *			pSrcIPAddress;
	UCHAR UNALIGNED *			pDstIPAddress;
} AA_ARP_PKT_CONTENTS, *PAA_ARP_PKT_CONTENTS;



/*++
BOOLEAN
AA_PKT_LLC_SNAP_HEADER_OK(
	IN	PAA_PKT_LLC_SNAP_HEADER	pPktHeader
)
Check if a received LLC/SNAP header is valid.
--*/
#define AA_PKT_LLC_SNAP_HEADER_OK(pH)			\
			(((pH)->LLC[0] == LLC_SNAP_LLC0) &&	\
			 ((pH)->LLC[1] == LLC_SNAP_LLC1) && \
			 ((pH)->LLC[2] == LLC_SNAP_LLC2) && \
			 ((pH)->OUI[0] == LLC_SNAP_OUI0) && \
			 ((pH)->OUI[1] == LLC_SNAP_OUI1) && \
			 ((pH)->OUI[2] == LLC_SNAP_OUI2))


/*++
UCHAR
AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(
	IN	PATM_ADDRESS			pAtmAddress
)
Return a one-byte Type+Length field corresponding to an ATM Address
--*/
#define AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(pAtmAddress)							\
			((UCHAR)((pAtmAddress)->NumberOfDigits) |						\
				(((pAtmAddress)->AddressType == ATM_E164) ? 				\
						AA_PKT_ATM_ADDRESS_E164 : AA_PKT_ATM_ADDRESS_NSAP))


/*++
VOID
AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
	IN	UCHAR				TypeLen,
	IN	ATM_ADDRESSTYPE *	pAtmAddressType,
	IN	ULONG *				pAtmAddressLength
)
Convert a Type+Length field in an ATMARP packet to Type, Length
values in an ATM_ADDRESS structure
--*/
#define AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(TypeLen, pAtmType, pAtmLen)	\
		{															\
			*(pAtmType) = 											\
				((((TypeLen) & AA_PKT_ATM_ADDRESS_BIT) == 			\
					AA_PKT_ATM_ADDRESS_E164)? ATM_E164: ATM_NSAP);	\
			*(pAtmLen) =											\
					(ULONG)((TypeLen) & ~AA_PKT_ATM_ADDRESS_BIT);	\
		}

//
//  ATM Address ESI length, and offset from the beginning.
//
#define AA_ATM_ESI_LEN				6
#define AA_ATM_ESI_OFFSET			13


//
//  DHCP constants
//
#define AA_DEST_DHCP_PORT_OFFSET	2
#define AA_DHCP_SERVER_PORT			0x4300
#define AA_DHCP_CLIENT_PORT			0x4400
#define AA_DHCP_MIN_LENGTH			44
#define AA_DHCP_ESI_OFFSET			28


#endif // _ARP_PKT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\arpif.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arpif.c

Abstract:

	ARP Interface Entry points. These are called (indirectly) by the IP
	layer. All these entry points have the common prefix "AtmArpIf".

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-17-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'FIRA'


#if DBG_QRY
ULONG	AaIgnoreInstance = 0;
#endif

IP_MASK  AtmArpIPMaskTable[] =
{
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSC_MASK,
    CLASSC_MASK,
    CLASSD_MASK,
    CLASSE_MASK
};


VOID
AtmArpReStartInterface(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						IfContext
);


#ifndef NEWARP

NDIS_STATUS
AtmArpInitIPInterface(
	VOID
)
/*++

Routine Description:

	Initialize our interface with IP. This consists of querying IP for
	its "Add Interface" and "Delete Interface" entry points.

Arguments:

	None. It is assumed that the caller has a lock to the ATMARP Global
	Info structure.

Return Value:

	NDIS_STATUS_SUCCESS if initialization was successful
	NDIS_STATUS_XXX error code otherwise.

--*/
{
	NDIS_STATUS				Status;
#if !LINK_WITH_IP
    IP_GET_PNP_ARP_POINTERS IPInfo;
    UNICODE_STRING          IPDeviceName;
    PIRP                    pIrp;
    PFILE_OBJECT            pIpFileObject;
    PDEVICE_OBJECT          pIpDeviceObject;
    IO_STATUS_BLOCK         ioStatusBlock;

	//
	//  Initialize.
	//
	pIrp = (PIRP)NULL;
	pIpFileObject = (PFILE_OBJECT)NULL;
	pIpDeviceObject = (PDEVICE_OBJECT)NULL;


	do
	{
		NdisInitUnicodeString(&IPDeviceName, DD_IP_DEVICE_NAME);

		//
		// Get the file and device objects for the IP device.
		//
		Status = IoGetDeviceObjectPointer(
							&IPDeviceName,
							SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
							&pIpFileObject,
							&pIpDeviceObject);

		if ((Status != STATUS_SUCCESS) || (pIpDeviceObject == NULL))
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		// Reference the device object.
		//
		ObReferenceObject(pIpDeviceObject);

		pIrp = IoBuildDeviceIoControlRequest(IOCTL_IP_GET_PNP_ARP_POINTERS,
                                         pIpDeviceObject,
                                         NULL,
                                         0,
                                         &IPInfo,
                                         sizeof (IPInfo),
                                         FALSE,
                                         NULL,
                                         &ioStatusBlock);

		if (pIrp == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		Status = IoCallDriver(pIpDeviceObject, pIrp);

		if (Status != STATUS_SUCCESS)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

    	pAtmArpGlobalInfo->pIPAddInterfaceRtn = IPInfo.IPAddInterface;
    	pAtmArpGlobalInfo->pIPDelInterfaceRtn = IPInfo.IPDelInterface;

    	Status = NDIS_STATUS_SUCCESS;

	}
	while (FALSE);

	if (pIpFileObject != (PFILE_OBJECT)NULL)
	{
		//
		// Dereference the file object
		//
		ObDereferenceObject((PVOID)pIpFileObject);
	}

    if (pIpDeviceObject != (PDEVICE_OBJECT)NULL)
    {
		//
		// Close the device.
		//
		ObDereferenceObject((PVOID)pIpDeviceObject);
	}
#else

   	pAtmArpGlobalInfo->pIPAddInterfaceRtn = IPAddInterface;
   	pAtmArpGlobalInfo->pIPDelInterfaceRtn = (IPDelInterfacePtr)IPDelInterface;

   	Status = NDIS_STATUS_SUCCESS;

#endif // !LINK_WITH_IP

	AADEBUGP(AAD_INFO, ("Init IP Interface: returning Status 0x%x\n", Status));
    return (Status);
}



INT
AtmArpIfDynRegister(
	IN	PNDIS_STRING				pAdapterString,
	IN	PVOID						IPContext,
	IN	IPRcvRtn 					IPRcvHandler,
	IN	IPTxCmpltRtn				IPTxCmpltHandler,
	IN	IPStatusRtn					IPStatusHandler,
	IN	IPTDCmpltRtn				IPTDCmpltHandler,
	IN	IPRcvCmpltRtn				IPRcvCmpltHandler,
	IN	struct LLIPBindInfo			*pBindInfo,
	IN	UINT						NumIFBound
)
/*++

Routine Description:

	This routine is called from the IP layer when it wants to tell us,
	the ARP module, about its handlers for an Interface.

Arguments:

	pAdapterString		- Name of the logical adapter for this interface
	IPContext			- IP's context for this interface
	IPRcvHandler		- Up-call for receives
	IPTxCmpltHandler	- Up-call for transmit completes
	IPStatusHandler		- Up-call to indicate status changes
	IPTDCmpltHandler	- Up-call to indicate completion of Transfer-Data
	IPRcvCmpltHandler	- Up-call to indicate temporary completion of receives
	pBindInfo			- Pointer to bind info with our information
	NumIFBound			- Count for this interface

Return Value:

	(UINT)TRUE always.

--*/
{
	PATMARP_INTERFACE			pInterface;

	pInterface = (PATMARP_INTERFACE)(pBindInfo->lip_context);
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("IfDynRegister: pIf 0x%x\n", pInterface));

	pInterface->IPContext = IPContext;
	pInterface->IPRcvHandler = IPRcvHandler;
	pInterface->IPTxCmpltHandler = IPTxCmpltHandler;
	pInterface->IPStatusHandler = IPStatusHandler;
	pInterface->IPTDCmpltHandler = IPTDCmpltHandler;
	pInterface->IPRcvCmpltHandler = IPRcvCmpltHandler;
	pInterface->IFIndex = NumIFBound;

	return ((UINT)TRUE);
}

#else
// NEWARP

INT
AtmArpIfDynRegister(
	IN	PNDIS_STRING				pAdapterString,
	IN	PVOID						IPContext,
	IN	struct _IP_HANDLERS *		pIpHandlers,
	IN	struct LLIPBindInfo *		pBindInfo,
	IN	UINT						InterfaceNumber
)
/*++

Routine Description:

	This routine is called from the IP layer when it wants to tell us,
	the ARP module, about its handlers for an Interface.

Arguments:

	pAdapterString		- Name of the logical adapter for this interface
	IPContext			- IP's context for this interface
	pIpHandlers			- Points to struct containing the following handlers:
		IPRcvHandler		- Up-call for receives
		IPTxCmpltHandler	- Up-call for transmit completes
		IPStatusHandler		- Up-call to indicate status changes
		IPTDCmpltHandler	- Up-call to indicate completion of Transfer-Data
		IPRcvCmpltHandler	- Up-call to indicate temporary completion of receives
	pBindInfo			- Pointer to bind info with our information
	InterfaceNumber		- ID for this interface

Return Value:

	(UINT)TRUE always.

--*/
{
	PATMARP_INTERFACE			pInterface;

	pInterface = (PATMARP_INTERFACE)(pBindInfo->lip_context);
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("IfDynRegister: pIf 0x%x\n", pInterface));

	pInterface->IPContext = IPContext;
	pInterface->IPRcvHandler = pIpHandlers->IpRcvHandler;
	pInterface->IPTxCmpltHandler = pIpHandlers->IpTxCompleteHandler;
	pInterface->IPStatusHandler = pIpHandlers->IpStatusHandler;
	pInterface->IPTDCmpltHandler = pIpHandlers->IpTransferCompleteHandler;
	pInterface->IPRcvCmpltHandler = pIpHandlers->IpRcvCompleteHandler;
#ifdef _PNP_POWER_
	pInterface->IPPnPEventHandler = pIpHandlers->IpPnPHandler;
	pInterface->IPRcvPktHandler = pIpHandlers->IpRcvPktHandler;
#endif // _PNP_POWER_
	pInterface->IFIndex = InterfaceNumber;

	return ((UINT)TRUE);
}

#endif // !NEWARP


VOID
AtmArpIfOpen(
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called when IP is ready to use this interface.
	This is equivalent to setting AdminState to UP.

	We register our SAP with the Call Manager, thus allowing incoming
	calls to reach us. If atleast one local IP address has been set,
	and the ATM interface is ip, we start registering ourselves with
	the server.

Arguments:

	Context		- Actually a pointer to our ATMARP Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	NDIS_HANDLE				ProtocolSapContext;
	PNDIS_HANDLE			pNdisSapHandle;
	PCO_SAP					pSap;
	BOOLEAN					AtmInterfaceDown;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("IfOpen: pIf 0x%x\n", pInterface));

	AA_ACQUIRE_IF_LOCK(pInterface);

	AA_ASSERT(pInterface->NdisAfHandle != NULL);

	pInterface->AdminState = IF_STATUS_UP;
	AA_INIT_BLOCK_STRUCT(&(pInterface->Block));

	AtmInterfaceDown = !(pInterface->AtmInterfaceUp);

	AA_RELEASE_IF_LOCK(pInterface);

	//
	//  Get the local ATM address if we haven't got it yet.
	//
	if (AtmInterfaceDown)
	{
		AtmArpGetAtmAddress(pInterface);
	}
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	//
	//  Register our SAP(s) with the Call Manager.
	//
	AtmArpRegisterSaps(pInterface);
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);


#ifdef ATMARP_WMI
	//
	//  Make this interface a WMI provider.
	//
	AtmArpWmiInitInterface(pInterface, AtmArpGuidList, AtmArpGuidCount);

#endif // ATMARP_WMI

	AA_ACQUIRE_IF_LOCK(pInterface);

#ifdef IPMCAST
	//
	//  Start multicast registration with MARS.
	//
	AtmArpMcStartRegistration(pInterface);

	//
	//  IF lock is released within the above.
	//
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	AA_ACQUIRE_IF_LOCK(pInterface);
#endif // IPMCAST

	//
	//  All necessary pre-conditions are checked within
	//  AtmArpStartRegistration.
	//
	AtmArpStartRegistration(pInterface);

	//
	//  IF lock is released within the above.
	//

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return;
}




VOID
AtmArpIfClose(
	IN	PVOID						Context
)
/*++

Routine Description:

	IP wants to stop using this Interface. We assume that this is called
	in response to our Up-call to IP's DelInterface entry point.

	We simply dereference the interface, unless we are actually in the process
	of bringing it down and up due to a reconfigure notification.

Arguments:

	Context		- Actually a pointer to our ATMARP Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;			// Ref Count
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif
    BOOLEAN                 fQueueRestart = FALSE;
    PNDIS_WORK_ITEM         pWorkItem;
    NDIS_STATUS             NdisStatus;

	AA_GET_ENTRY_IRQL(EntryIrq);

	pInterface = (PATMARP_INTERFACE)Context;

	AA_STRUCT_ASSERT(pInterface, aai);

    AA_ACQUIRE_IF_LOCK(pInterface);

    //
    // Ensure that we won't send up an IPDelInterface on this
    // interface.
    //
    pInterface->IPContext = NULL;

    if (pInterface->ReconfigState==RECONFIG_SHUTDOWN_PENDING)
    {
        AA_ALLOC_MEM(pWorkItem, NDIS_WORK_ITEM, sizeof(NDIS_WORK_ITEM));
        if (pWorkItem == NULL)
        {
            AA_ASSERT(FALSE);
        }
        else
        {
            pInterface->ReconfigState=RECONFIG_RESTART_QUEUED;
            fQueueRestart = TRUE;
        }
    }
    else
    {
        AA_ASSERT(pInterface->ReconfigState==RECONFIG_NOT_IN_PROGRESS);
    }

    AA_RELEASE_IF_LOCK(pInterface);

#ifdef ATMARP_WMI

	//
	//  Deregister this Interface as a WMI provider.
	//	We do this even when bringing down the interface for a reconfig
	//  because certain IP information could potentially become stale.
	//
	AtmArpWmiShutdownInterface(pInterface);

#endif // ATMARP_WMI

    if (fQueueRestart)
    {
        //
        // We have a request to reconfigure this interface. So we will
        // keep this structure allocated and queue
        // a work item to bring this interface back up -- reading the latest
        // configuration paramters from the registry.
        //

        //
        // We do not strictly need to  reference the interface here because we
        // expect the interface to be still around. Nevertheless
        // we reference it here and dereference it when the work item fires.
        //
        AtmArpReferenceInterface(pInterface); // ReStart Work Item

        NdisInitializeWorkItem(
            pWorkItem,
            AtmArpReStartInterface,
            (PVOID)pInterface
            );

        NdisStatus = NdisScheduleWorkItem(pWorkItem);
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            //
            // Ouch, fall back to simply deleting the interface.
            //
			AA_FREE_MEM(pWorkItem);
			fQueueRestart = FALSE;
        }
    }


    if (!fQueueRestart)
    {

        AADEBUGP(AAD_INFO, ("IfClose: will deallocate pIf 0x%x, RefCount %d\n",
                     pInterface, pInterface->RefCount));
    
        AA_ACQUIRE_IF_LOCK(pInterface);
    
        rc = AtmArpDereferenceInterface(pInterface);
    
        if (rc != 0)
        {
            AA_RELEASE_IF_LOCK(pInterface);
        }
        //
        //  else the Interface is gone.
        //
    
        AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
    }

	return;
}



UINT
AtmArpIfAddAddress(
	IN	PVOID						Context,
	IN	UINT						AddressType,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
#ifndef BUILD_FOR_1381
	,
	IN	PVOID						Context2
#endif // BUILD_FOR_1381
)
/*++

Routine Description:

	The IP layer calls this when a new IP address (or block of IP addresses,
	as determined by AddressType) needs to be added to an Interface.

	We could see any of four address types: Local, Multicast, Broadcast
	and Proxy ARP. In the case of Proxy ARP, the address along with the mask
	can specify a block of contiguous IP addresses for which this host acts
	as a proxy. Currently, we only support the "Local", "Broadcast", and
	"Multicast" types.

	If we just added the only local address for this interface, and the
	ATM interface is up, and AdminState for this interface is UP, we initiate
	address registration with the ARP server.

Arguments:

	Context			- Actually a pointer to the ATMARP Interface structure
	AddressType		- Type of address(es) being added.
	IPAddress		- Address to be added.
	Mask			- For the above.
	Context2		- Additional context (for what?)

Return Value:

	(UINT)TRUE if successful, (UINT)FALSE otherwise.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PIP_ADDRESS_ENTRY		pIpAddressEntry;
	UINT					ReturnStatus;
	BOOLEAN					LockAcquired;

	ReturnStatus = (UINT)FALSE;	// Initialize to Failure

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);
	LockAcquired = TRUE;

	if (AddressType == LLIP_ADDR_LOCAL)
	{
		//
		//  Find a place to put this new address in.
		//
		if (pInterface->NumOfIPAddresses == 0)
		{
			pIpAddressEntry = &(pInterface->LocalIPAddress);
		}
		else
		{
			AA_ALLOC_MEM(pIpAddressEntry, IP_ADDRESS_ENTRY, sizeof(IP_ADDRESS_ENTRY));
			if (pIpAddressEntry != (PIP_ADDRESS_ENTRY)NULL)
			{
				pIpAddressEntry->pNext = pInterface->LocalIPAddress.pNext;
				pInterface->LocalIPAddress.pNext = pIpAddressEntry;
			}
		}

		if (pIpAddressEntry != (PIP_ADDRESS_ENTRY)NULL)
		{
			ReturnStatus = (UINT)TRUE;

			pIpAddressEntry->IPAddress = IPAddress;
			pIpAddressEntry->IPMask = Mask;
			pIpAddressEntry->IsRegistered = FALSE;
			pIpAddressEntry->IsFirstRegistration = TRUE;

			pInterface->NumOfIPAddresses++;
			if (pInterface->NumOfIPAddresses == 1)
			{
				AtmArpStartRegistration(pInterface);
				//
				//  IF Lock is released by above routine.
				//
				LockAcquired = FALSE;
			}
			else
			{
				if (AA_IS_FLAG_SET(
						pInterface->Flags,
						AA_IF_SERVER_STATE_MASK,
						AA_IF_SERVER_REGISTERED) &&
					(!pInterface->PVCOnly))
				{
					AA_RELEASE_IF_LOCK(pInterface);
					LockAcquired = FALSE;
					AtmArpSendARPRequest(
							pInterface,
							&IPAddress,
							&IPAddress
							);
				}
				//
				//  else either 
				//  (a) registration is in progress; at the end of it,
				//  we will register all unregistered IP addresses.
				//  	or
				//  (b) we are in a PVC only environment, no ARP server.
				//
			}
		}
		//
		//  else allocation failure -- fall thru
		//
	}
#ifdef IPMCAST
	else if ((AddressType == LLIP_ADDR_BCAST) || (AddressType == LLIP_ADDR_MCAST))
	{
		if (AddressType == LLIP_ADDR_BCAST)
		{
			pInterface->BroadcastAddress = IPAddress;
		}
		ReturnStatus = AtmArpMcAddAddress(pInterface, IPAddress, Mask);
		//
		// IF Lock is released within the above.
		//
		LockAcquired = FALSE;
	}
#else
	else if (AddressType == LLIP_ADDR_BCAST)
	{
		pInterface->BroadcastAddress = IPAddress;
		ReturnStatus = (UINT)TRUE;
	}
#endif // IPMCAST

	if (LockAcquired)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

#ifdef BUILD_FOR_1381
	AADEBUGP(AAD_INFO,
	 ("IfAddAddress: IF 0x%x, Type %d, Addr %d.%d.%d.%d, Mask 0x%x, Ret %d\n",
				pInterface,
				AddressType,
				((PUCHAR)(&IPAddress))[0],
				((PUCHAR)(&IPAddress))[1],
				((PUCHAR)(&IPAddress))[2],
				((PUCHAR)(&IPAddress))[3],
				Mask, ReturnStatus));
#else
	AADEBUGP(AAD_INFO,
	 ("IfAddAddress: IF 0x%x, Type %d, Addr %d.%d.%d.%d, Mask 0x%x, Ret %d, Ctx2 0x%x\n",
				pInterface,
				AddressType,
				((PUCHAR)(&IPAddress))[0],
				((PUCHAR)(&IPAddress))[1],
				((PUCHAR)(&IPAddress))[2],
				((PUCHAR)(&IPAddress))[3],
				Mask, ReturnStatus, Context2));
#endif // BUILD_FOR_1381


	return (ReturnStatus);
}



UINT
AtmArpIfDelAddress(
	IN	PVOID						Context,
	IN	UINT						AddressType,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
)
/*++

Routine Description:

	This is called from the IP layer when an address added via AtmArpIfAddAddress
	is to be deleted.

	Currently, only the "Local" Address type is supported.

	Assumption: the given address was successfully added earlier.

Arguments:

	Context			- Actually a pointer to the ATMARP Interface structure
	AddressType		- Type of address(es) being deleted.
	IPAddress		- Address to be deleted.
	Mask			- For the above.

Return Value:

	(UINT)TRUE if successful, (UINT)FALSE otherwise.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PIP_ADDRESS_ENTRY		pIpAddressEntry;
	PIP_ADDRESS_ENTRY		pPrevIpAddressEntry;
	PIP_ADDRESS_ENTRY		pTmpIpAddressEntry;
	UINT					ReturnValue;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	if (AddressType == LLIP_ADDR_LOCAL)
	{
		AA_ACQUIRE_IF_LOCK(pInterface);

		//
		//  Search for the entry to be deleted.
		//
		pPrevIpAddressEntry = (PIP_ADDRESS_ENTRY)NULL;
		pIpAddressEntry = &(pInterface->LocalIPAddress);
		while (!IP_ADDR_EQUAL(pIpAddressEntry->IPAddress, IPAddress))
		{
			pPrevIpAddressEntry = pIpAddressEntry;
			pIpAddressEntry = pIpAddressEntry->pNext;
			AA_ASSERT(pIpAddressEntry != (PIP_ADDRESS_ENTRY)NULL);
		}

		//
		//  If it was the only one in the list, there is nothing
		//  to be done. Otherwise, update the list.
		//
		if (pInterface->NumOfIPAddresses > 1)
		{
			//
			//  More than one entry existed. Check if we deleted the
			//  first one.
			//
			if (pPrevIpAddressEntry == (PIP_ADDRESS_ENTRY)NULL)
			{
				//
				//  Copy in the contents of the second entry
				//  into the head of the list, and delete the
				//  second entry.
				//
				AA_ASSERT(pIpAddressEntry == &(pInterface->LocalIPAddress));
				AA_ASSERT(pIpAddressEntry->pNext != (PIP_ADDRESS_ENTRY)NULL);

				pIpAddressEntry->IPAddress = pIpAddressEntry->pNext->IPAddress;
				pIpAddressEntry->IPMask = pIpAddressEntry->pNext->IPMask;
				pTmpIpAddressEntry = pIpAddressEntry->pNext;
				pIpAddressEntry->pNext = pIpAddressEntry->pNext->pNext;

				pIpAddressEntry = pTmpIpAddressEntry;
			}
			else
			{
				pPrevIpAddressEntry->pNext = pIpAddressEntry->pNext;
			}

			AA_FREE_MEM(pIpAddressEntry);
		}

		pInterface->NumOfIPAddresses--;

		AA_RELEASE_IF_LOCK(pInterface);

		ReturnValue = (UINT)TRUE;
	}
	else
#ifdef IPMCAST
	{
		if ((AddressType == LLIP_ADDR_BCAST) || (AddressType == LLIP_ADDR_MCAST))
		{
			AA_ACQUIRE_IF_LOCK(pInterface);
			ReturnValue = AtmArpMcDelAddress(pInterface, IPAddress, Mask);
		}
		else
		{
			ReturnValue = (UINT)FALSE;
		}
	}
#else
	{
		ReturnValue = (UINT)FALSE;
	}
#endif // IPMCAST

	AADEBUGP(AAD_INFO,
		("IfDelAddress: Ctxt 0x%x, Type 0x%x, IPAddr 0x%x, Mask 0x%x, Ret %d\n",
			Context, AddressType, IPAddress, Mask, ReturnValue));

	return (ReturnValue);
}


#ifdef NEWARP
NDIS_STATUS
AtmArpIfMultiTransmit(
	IN	PVOID						Context,
	IN	PNDIS_PACKET *				pNdisPacketArray,
	IN	UINT						NumberOfPackets,
	IN	IP_ADDRESS					Destination,
	IN	RouteCacheEntry *			pRCE		OPTIONAL
#if P2MP
	,
	IN  void *                  ArpCtxt
#endif
)
/*++

Routine Description:

	This is called from the IP layer when it has a sequence of datagrams,
	each in the form of an NDIS buffer chain, to send over an Interface.

Arguments:

	Context				- Actually a pointer to our Interface structure
	pNdisPacketArray	- Array of Packets to be sent on this Interface
	NumberOfPackets		- Length of array
	Destination			- IP address of next hop for this packet
	pRCE				- Optional pointer to Route Cache Entry structure.

Return Value:

	NDIS_STATUS_PENDING if all packets were queued for transmission.
	If one or more packets "failed", we set the packet status to reflect
	what happened to each, and return NDIS_STATUS_FAILURE.

--*/
{
	NDIS_STATUS			Status;
	PNDIS_PACKET *		ppNdisPacket;

	for (ppNdisPacket = pNdisPacketArray;
		 NumberOfPackets > 0;
		 NumberOfPackets--, ppNdisPacket++)
	{
		PNDIS_PACKET			pNdisPacket;

		pNdisPacket = *ppNdisPacket;
		NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_PENDING);
#if DBG
		AA_ASSERT(pNdisPacket->Private.Head != NULL);
#endif // DBG

		Status = AtmArpIfTransmit(
						Context,
						*ppNdisPacket,
						Destination,
						pRCE
					#if P2MP
						,NULL
					#endif
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			NDIS_SET_PACKET_STATUS(*ppNdisPacket, Status);
			break;
		}
	}

	return (Status);
}

#endif // NEWARP

NDIS_STATUS
AtmArpIfTransmit(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	IP_ADDRESS					Destination,
	IN	RouteCacheEntry *			pRCE		OPTIONAL
#if P2MP
	,
	IN  void *                  ArpCtxt
#endif
)
/*++

Routine Description:

	This is called from the IP layer when it has a datagram (in the form of
	an NDIS buffer chain) to send over an Interface.

	The destination IP address is passed to us in this routine, which may
	or may not be the final destination for the packet. 

	The Route Cache Entry is created by the IP layer, and is used to speed
	up our lookups. An RCE, if specified, uniquely identifies atleast the
	IP destination for this packet. The RCE contains space for the ARP layer
	to keep context information about this destination. When the first packet
	goes out to a Destination, our context info in the RCE will be NULL, and
	we search the ARP Table for the matching IP Entry. However, we then fill
	our context info (pointer to IP Entry) in the RCE, so that subsequent
	transmits aren't slowed down by an IP address lookup.

Arguments:

	Context				- Actually a pointer to our Interface structure
	pNdisPacket			- Packet to be sent on this Interface
	Destination			- IP address of next hop for this packet
	pRCE				- Optional pointer to Route Cache Entry structure.

Return Value:

	Status of the transmit: NDIS_STATUS_SUCCESS, NDIS_STATUS_PENDING, or
	a failure.

--*/
{
	PATMARP_INTERFACE			pInterface;
	PATMARP_IP_ENTRY			pIpEntry;		// IP Entry corresp to Destination
	PATMARP_ATM_ENTRY			pAtmEntry;		// ATM Entry for this destination
	PATMARP_RCE_CONTEXT			pRCEContext;	// Our context in the RCE

	PATMARP_FLOW_INFO			pFlowInfo;		// Flow to which this packet belongs
	PATMARP_FILTER_SPEC			pFilterSpec;	// Filter Spec for this packet
	PATMARP_FLOW_SPEC			pFlowSpec;		// Flow Spec for this packet

	PNDIS_BUFFER				pHeaderBuffer;	// NDIS Buffer for LLC/SNAP header
	PUCHAR						pHeader;		// Pointer to header area
	NDIS_STATUS					Status;			// Return value

	BOOLEAN						IsBroadcastAddress;
	BOOLEAN						CreateNewEntry;	// Should we create a new IP entry?
#ifdef IPMCAST
	BOOLEAN						NeedMcRevalidation;	// If Multicast, do we revalidate?
#endif // IPMCAST
	ULONG						rc;
#if DBG
	AA_IRQL						EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_EXTRA_LOUD,
		("IfTransmit: pIf 0x%x, Pkt 0x%x, Dst 0x%x, pRCE 0x%x\n",
			pInterface, pNdisPacket, Destination, pRCE));

#if DBG
	if (AaDataDebugLevel & (AAD_DATA_OUT|AAD_TRACK_BIG_SENDS))
	{
		ULONG			TotalLength;
		PNDIS_BUFFER	pNdisBuffer;

		NdisQueryPacket(
				pNdisPacket,
				NULL,
				NULL,
				NULL,
				&TotalLength
				);

		if (AaDataDebugLevel & AAD_DATA_OUT)
		{
			AADEBUGP(AAD_WARNING, ("%d (", TotalLength));
			for (pNdisBuffer = pNdisPacket->Private.Head;
 				pNdisBuffer != NULL;
 				pNdisBuffer = pNdisBuffer->Next)
 			{
 				INT	BufLength;

				NdisQueryBuffer(pNdisBuffer, NULL, &BufLength);
 				AADEBUGP(AAD_WARNING, (" %d", BufLength));
 			}
			AADEBUGP(AAD_WARNING, (") => %d.%d.%d.%d\n",
				(ULONG)(((PUCHAR)&Destination)[0]),
				(ULONG)(((PUCHAR)&Destination)[1]),
				(ULONG)(((PUCHAR)&Destination)[2]),
				(ULONG)(((PUCHAR)&Destination)[3])));
		}
		if ((AaDataDebugLevel & AAD_TRACK_BIG_SENDS) && ((INT)TotalLength > AadBigDataLength))
		{
			AADEBUGP(AAD_WARNING, ("%d => %d.%d.%d.%d\n",
				TotalLength,
				(ULONG)(((PUCHAR)&Destination)[0]),
				(ULONG)(((PUCHAR)&Destination)[1]),
				(ULONG)(((PUCHAR)&Destination)[2]),
				(ULONG)(((PUCHAR)&Destination)[3])));
			DbgBreakPoint();
		}
			
	}

#endif // DBG

#ifdef PERF
	AadLogSendStart(pNdisPacket, (ULONG)Destination, (PVOID)pRCE);
#endif // PERF

#ifdef IPMCAST
	NeedMcRevalidation = FALSE;
#endif // IPMCAST
		
	do
	{
		//
		//  Discard this packet if the AdminStatus for this interface
		//  is not UP.
		//
		if (pInterface->AdminState != IF_STATUS_UP)
		{
			Status = NDIS_STATUS_INTERFACE_DOWN;
			break;
		}

		//
		//  Get the filter and flow specs for this packet.
		//
		AA_GET_PACKET_SPECS(pInterface, pNdisPacket, &pFlowInfo, &pFlowSpec, &pFilterSpec);

#ifdef GPC_MAYBE
	//
	//  We may not do this stuff because there are things to be done
	//  (see multicast case below) with the IP entry that would be
	//  missed out if we do this.
	//
		pVc = AA_GET_VC_FOR_FLOW(pFlowInfo);

		if (pVc != NULL_PATMARP_VC)
		{
			AA_ACQUIRE_VC_LOCK(pVc);

			if ((pVc->FlowHandle == pFlowInfo) &&

				AA_IS_FLAG_SET(pVc->Flags,
							   AA_VC_CALL_STATE_MASK,
							   AA_VC_CALL_STATE_ACTIVE) &&

				!AA_IS_VC_GOING_DOWN(pVc)
			   )
			{
				AA_PREPARE_HEADER(pNdisPacket, pInterface, pFlowSpec, &Status);

				if (Status == NDIS_STATUS_SUCCESS)
				{
					AtmArpRefreshTimer(&(pVc->Timer));
					AtmArpReferenceVc(pVc);	// IfTransmit
					pVc->OutstandingSends++;	// IfTransmit

					NdisVcHandle = pVc->NdisVcHandle;

					AA_RELEASE_VC_LOCK(pVc);

					NDIS_CO_SEND(
							NdisVcHandle,
							&pNdisPacket,
							1
							);
					break;
				}
			}

			AA_RELEASE_VC_LOCK(pVc);
			//
			//  Fall through
			//
		}
#endif // GPC
		//
		//  Get the IP Entry for this destination: see if we have
		//  cached information that we can use.
		//
		if (pRCE != (RouteCacheEntry *)NULL)
		{
			pRCEContext = (PATMARP_RCE_CONTEXT)(pRCE->rce_context);

			AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

			pIpEntry = pRCEContext->pIpEntry;

			AADEBUGP(AAD_EXTRA_LOUD,
				("Transmit: Dst 0x%x, RCE 0x%x, RCECntxt 0x%x, IPEntry 0x%x\n",
						Destination, pRCE, pRCEContext, pIpEntry));

			if (pIpEntry != NULL_PATMARP_IP_ENTRY)
			{
				AA_STRUCT_ASSERT(pIpEntry, aip);
				AA_RELEASE_IF_TABLE_LOCK(pInterface);

				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

				if (IP_ADDR_EQUAL(pIpEntry->IPAddress, Destination))
				{
					//
					//  The Route Cache points to the right IP Entry.
					//  Either send this packet, or queue it, and get out.
					//

					//
					//  Check if this IP Address has been resolved to an ATM address,
					//  and is "clean" (not aged out).
					//
					if (AA_IS_FLAG_SET(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK, 
							AA_IP_ENTRY_RESOLVED))
					{
						ULONG		rc;

						AA_ASSERT(pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
						pAtmEntry = pIpEntry->pAtmEntry;

						AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
						AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: IfTransmit1
						AA_RELEASE_AE_LOCK_DPC(pAtmEntry);

#ifdef IPMCAST
						if (AA_IS_FLAG_SET(
								pIpEntry->Flags,
								AA_IP_ENTRY_MC_VALIDATE_MASK,
								AA_IP_ENTRY_MC_REVALIDATE))
						{
							AA_SET_FLAG(pIpEntry->Flags,
										AA_IP_ENTRY_MC_VALIDATE_MASK,
										AA_IP_ENTRY_MC_REVALIDATING);
							NeedMcRevalidation = TRUE;
						}
#endif // IPMCAST

						IsBroadcastAddress = AA_IS_FLAG_SET(pIpEntry->Flags,
															AA_IP_ENTRY_ADDR_TYPE_MASK,
															AA_IP_ENTRY_ADDR_TYPE_NUCAST);
						AA_RELEASE_IE_LOCK(pIpEntry);

						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						Status = AtmArpSendPacketOnAtmEntry(
											pInterface,
											pAtmEntry,
											pNdisPacket,
											pFlowSpec,
											pFilterSpec,
											pFlowInfo,
											IsBroadcastAddress
											);
						//
						//  The ATM Entry lock is released within the above.
						//  Get rid of the temp ref:
						//
						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: IfTransmit1
						if (rc != 0)
						{
							AA_RELEASE_AE_LOCK(pAtmEntry);
						}

						break;	// goto end of processing
					}
					else
					{
						//
						//  We don't have the ATM address yet, but we have an
						//  IP Entry for the Destination IP address. Queue this
						//  packet on the IP Entry, and start Address resolution
						//  if not already started.
						//
						//  But first, a check to avoid starting address resolution
						//  in a PVC-only environment.
						//
						if (pInterface->PVCOnly && (pIpEntry->pAtmEntry == NULL))
						{
							//
							//  This can happen if we had an active PVC and
							//  had learnt an IP address via InARP, and then
							//  the user had deleted the PVC. We would then be
							//  left with an IP entry, but no matching ATM entry.
							//  Abort this entry now.
							//
							AADEBUGP(AAD_FATAL,
								("IfTransmit (PVC 1): IPEntry %x, Ref %d, Flags %x has NULL ATM Entry\n",
									pIpEntry, pIpEntry->RefCount, pIpEntry->Flags));
				
				
							AtmArpAbortIPEntry(pIpEntry);
							//
							//  IP Entry lock is released above.
							//

							Status = NDIS_STATUS_SUCCESS;
							break;
						}

						Status = AtmArpQueuePacketOnIPEntry(
											pIpEntry,
											pNdisPacket
											);
						//
						//  The IP Entry lock is released within the above.
						//
						break;	// goto end of processing
					}
					// NOTREACHED
				}
				else
				{
					//
					//  The cache entry points to the wrong IP Entry. Invalidate
					//  the cache entry, and continue to the hard road.
					//
					AADEBUGP(AAD_INFO,
						("IfTransmit: RCE (0x%x) points to wrong IP Entry (0x%x: %d.%d.%d.%d)\n",
							pRCE,
							pIpEntry,
							((PUCHAR)(&(pIpEntry->IPAddress)))[0],
							((PUCHAR)(&(pIpEntry->IPAddress)))[1],
							((PUCHAR)(&(pIpEntry->IPAddress)))[2],
							((PUCHAR)(&(pIpEntry->IPAddress)))[3]
						));

					AADEBUGP(AAD_INFO,
						("RCE/IP Entry mismatch: Destn IP: %d.%d.%d.%d\n",
							((PUCHAR)&Destination)[0],
							((PUCHAR)&Destination)[1],
							((PUCHAR)&Destination)[2],
							((PUCHAR)&Destination)[3]
						));

					if (AtmArpUnlinkRCE(pRCE, pIpEntry))
					{
						ULONG		rc;	// Ref Count for IP Entry
	
						//
						//  The IP Entry did have this RCE in its list.
						//
						rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_RCE);	// RCE ref
						if (rc > 0)
						{
							AA_RELEASE_IE_LOCK(pIpEntry);
						}
						//  else the IP Entry is gone
					}
					else
					{
						//
						//  The IP Entry does not have this RCE in its list.
						//
						AA_RELEASE_IE_LOCK(pIpEntry);
					}

					//
					//  Continue processing below.
					//

				}	// else -- if (RCE points to the right IP Entry)
			}	// if (RCE points to non-NULL IP Entry)
			else
			{
				AA_RELEASE_IF_TABLE_LOCK(pInterface);
				//
				//  Continue processing below
				//
			}
		}

		AA_ACQUIRE_IF_LOCK(pInterface);
		IsBroadcastAddress = AtmArpIsBroadcastIPAddress(Destination, pInterface);
		AA_RELEASE_IF_LOCK(pInterface);

#if DHCP_OVER_ATM
		//
		//  Handle Broadcast packets separately.
		//
		if (IsBroadcastAddress)
		{
			Status = AtmArpSendBroadcast(
								pInterface,
								pNdisPacket,
								pFlowSpec,
								pFilterSpec
								);
			break;
		}
#endif // DHCP_OVER_ATM

#ifdef IPMCAST
		if (IsBroadcastAddress)
		{
			AAMCDEBUGP(AAD_EXTRA_LOUD,
				("IfTransmit: pIf 0x%x, to Broadcast addr: %d.%d.%d.%d\n",
						pInterface,
						((PUCHAR)&Destination)[0],
						((PUCHAR)&Destination)[1],
						((PUCHAR)&Destination)[2],
						((PUCHAR)&Destination)[3]));

			if (pInterface->MARSList.ListSize == 0)
			{
				//
				//  Drop this packet.
				//
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			//
			//  Make sure that we send all IP *broadcast* packets to
			//  the All 1's group.
			//
#ifdef MERGE_BROADCASTS
			Destination = pInterface->BroadcastAddress;
#else
			if (!CLASSD_ADDR(Destination))
			{
				Destination = pInterface->BroadcastAddress;
			}
#endif // MERGE_BROADCASTS
		}

#endif // IPMCAST

		//
		//  No Route Cache Entry: search for the IP Entry the hard way.
		//  NOTE: if we are running PVCs only, we won't create a new
		//  IP entry here: the only way a new IP Entry is created is
		//  when we learn the IP+ATM info of the station at the other
		//  end via InARP.
		//
		//  Note: AtmArpSearchForIPAddress addrefs pIpEntry.
		//
		CreateNewEntry = (pInterface->PVCOnly? FALSE: TRUE);

		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
		pIpEntry = AtmArpSearchForIPAddress(
								pInterface,
								&Destination,
								IE_REFTYPE_TMP,
								IsBroadcastAddress,
								CreateNewEntry
								);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		if (pIpEntry == NULL_PATMARP_IP_ENTRY)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

		if (pInterface->PVCOnly && (pIpEntry->pAtmEntry == NULL))
		{
			//
			//  This can happen if we had an active PVC and had learnt an IP address
			//  via InARP, and then the user had deleted the PVC. We would then be
			//  left with an IP entry, but no matching ATM entry. Abort this entry
			//  now.
			//
			AADEBUGP(AAD_FATAL,
				("IfTransmit (PVC 2): IPEntry %x, Ref %d, Flags %x has NULL ATM Entry\n",
					pIpEntry, pIpEntry->RefCount, pIpEntry->Flags));

			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);

			if (rc != 0)
			{
				AtmArpAbortIPEntry(pIpEntry);
				//
				//  IE Lock is released above.
				//
			}

			Status = NDIS_STATUS_SUCCESS;
			break;
		}

		//
		//  Keep a pointer to this IP Entry in the Route Cache Entry
		//  to speed things up for the next packet.
		//
		if (pRCE != (RouteCacheEntry *)NULL)
		{
			AtmArpLinkRCE(pRCE, pIpEntry);
		}

		//
		// Note: AtmArpSerchForIPAddress addrefd pIpEntry for us -- we don't
		// deref it right now because it could be a new entry! Instead,
		// we deref it once we're done with it..
		//

		//
		//  Check if this IP Address has been resolved to an ATM address,
		//  and is "clean" (not aged out).
		//
		if (AA_IS_FLAG_SET(
				pIpEntry->Flags,
				AA_IP_ENTRY_STATE_MASK, 
				AA_IP_ENTRY_RESOLVED))
		{
			AA_ASSERT(pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
			pAtmEntry = pIpEntry->pAtmEntry;

			AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
			AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: IfTransmit
			AA_RELEASE_AE_LOCK_DPC(pAtmEntry);

#ifdef IPMCAST
			if (AA_IS_FLAG_SET(
					pIpEntry->Flags,
					AA_IP_ENTRY_MC_VALIDATE_MASK,
					AA_IP_ENTRY_MC_REVALIDATE))
			{
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_MC_VALIDATE_MASK,
							AA_IP_ENTRY_MC_REVALIDATING);
				NeedMcRevalidation = TRUE;
			}
#endif // IPMCAST

			{
				//
				//  AtmArpSearchForIPAddress addref'd pIpEntry for us, so
				//	before heading out of here, we deref it...
				//
				ULONG rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);
				if (rc > 0)
				{
					AA_RELEASE_IE_LOCK(pIpEntry);
				}
				else
				{
					//
					// It's gone ...
					//
					pIpEntry = NULL_PATMARP_IP_ENTRY;
					AA_ASSERT(!NeedMcRevalidation);
					NeedMcRevalidation = FALSE;		// just to be safe.
				}
			}

			AA_ACQUIRE_AE_LOCK(pAtmEntry);

			Status = AtmArpSendPacketOnAtmEntry(
								pInterface,
								pAtmEntry,
								pNdisPacket,
								pFlowSpec,
								pFilterSpec,
								pFlowInfo,
								IsBroadcastAddress
								);
			//
			//  The ATM Entry lock is released within the above. Get rid of the
			//  temp ref:
			//
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			if (AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP) != 0) // Temp ref: IfTransmit
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
			}
			break;
		}


		//
		//  We don't have the ATM address yet, but we have an
		//  IP Entry for the Destination IP address. Queue this
		//  packet on the IP Entry, and start Address resolution
		//  if not already started.
		//
		//	SearchForIPAddress addrefd pIpEntry for us. We don't simply
		//  deref it here because it could be a brand new entry, with
		//  refcount == 1. So instead we simply decrement the refcount. Note
		//  that we do hold the lock on it at this time.
		// 
		AA_ASSERT(pIpEntry->RefCount > 0);
		AA_DEREF_IE_NO_DELETE(pIpEntry, IE_REFTYPE_TMP);

		Status = AtmArpQueuePacketOnIPEntry(
							pIpEntry,
							pNdisPacket
							);
		//
		//  The IP Entry lock is released within the above.
		//
		break;
	}
	while (FALSE);

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

#ifdef IPMCAST
	if (NeedMcRevalidation)
	{
		AAMCDEBUGP(AAD_LOUD,
			("IfTransmit(MC): Revalidating pIpEntry 0x%x/0x%x, Addr %d.%d.%d.%d\n",
				pIpEntry, pIpEntry->Flags,
				((PUCHAR)&(pIpEntry->IPAddress))[0],
				((PUCHAR)&(pIpEntry->IPAddress))[1],
				((PUCHAR)&(pIpEntry->IPAddress))[2],
				((PUCHAR)&(pIpEntry->IPAddress))[3]));

		AtmArpMcSendRequest(
					pInterface,
					&Destination
					);
	}
#endif // IPMCAST

#ifdef PERF
	if ((Status != NDIS_STATUS_SUCCESS) && (Status != NDIS_STATUS_PENDING))
	{
		AadLogSendAbort(pNdisPacket);
	}
#endif // PERF

	if (Status != NDIS_STATUS_PENDING)
	{
		Status = NDIS_STATUS_SUCCESS;
	}

	return (Status);

}



NDIS_STATUS
AtmArpIfTransfer(
	IN	PVOID						Context,
	IN	NDIS_HANDLE					Context1,
	IN	UINT						ArpHdrOffset,
	IN	UINT						ProtoOffset,
	IN	UINT						BytesWanted,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PUINT						pTransferCount
)
/*++

Routine Description:

	This routine is called from the IP layer in order to copy in the
	contents of a received packet that we indicated up earlier. The
	context we had passed up in the receive indication is given back to
	us, so that we can identify what it was that we passed up.

	We simply call NDIS to do the transfer.

Arguments:

	Context				- Actually a pointer to our Interface structure
	Context1			- Packet context we had passed up (pointer to NDIS packet)
	ArpHdrOffset		- Offset we had passed up in the receive indicate
	ProtoOffset			- The offset into higher layer protocol data to start copy from
	BytesWanted			- The amount of data to be copied
	pNdisPacket			- The packet to be copied into
	pTransferCount		- Where we return the actual #bytes copied

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{

	AADEBUGP(AAD_EXTRA_LOUD,
	 ("IfTransfer: Ctx 0x%x, Ctx1 0x%x, HdrOff %d, ProtOff %d, Wanted %d, Pkt 0x%x\n",
			Context,
			Context1,
			ArpHdrOffset,
			ProtoOffset,
			BytesWanted,
			pNdisPacket));

	NdisCopyFromPacketToPacket(
			pNdisPacket,
			0,
			BytesWanted,
			(PNDIS_PACKET)Context1,
			ArpHdrOffset+ProtoOffset,
			pTransferCount
			);

	return (NDIS_STATUS_SUCCESS);
}



VOID
AtmArpIfInvalidate(
	IN	PVOID						Context,
	IN	RouteCacheEntry *			pRCE
)
/*++

Routine Description:

	This routine is called from the IP layer to invalidate a Route Cache
	Entry. If this RCE is associated with one of our IP Entries, unlink
	it from the list of RCE's pointing to that IP entry.

Arguments:

	Context				- Actually a pointer to our Interface structure
	pRCE				- Pointer to Route Cache Entry being invalidated.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PATMARP_IP_ENTRY		pIpEntry;
	PATMARP_RCE_CONTEXT		pRCEContext;
	ULONG					rc;			// Ref Count for IP Entry
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	AA_ASSERT(pRCE != (RouteCacheEntry *)NULL);

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	pRCEContext = (PATMARP_RCE_CONTEXT)(&(pRCE->rce_context[0]));

	//
	//  Get the ATMARP IP Entry associated with this RCE.
	//
	pIpEntry = (PATMARP_IP_ENTRY)pRCEContext->pIpEntry;

	if (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AADEBUGP(AAD_LOUD, ("IfInvalidate: pIf 0x%x, pRCE 0x%x, pIpEntry 0x%x\n",
			pInterface, pRCE, pIpEntry));

		AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);

		if (AtmArpUnlinkRCE(pRCE, pIpEntry))
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_RCE); // RCE
			if (rc > 0)
			{
				AA_RELEASE_IE_LOCK_DPC(pIpEntry);
			}
			//
			//  else the IP Entry is gone.
			//
		}
		else
		{
			AA_RELEASE_IE_LOCK_DPC(pIpEntry);
		}
	}

	AA_SET_MEM((PUCHAR)(&(pRCE->rce_context[0])), 0, RCE_CONTEXT_SIZE);

	AA_RELEASE_IF_TABLE_LOCK(pInterface);

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return;
}




BOOLEAN
AtmArpUnlinkRCE(
	IN	RouteCacheEntry *			pRCE,
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Unlink an RCE from the list of RCE's associated with an IP Entry.
	It is assumed that the caller holds locks to the IF Table and
	to the IP Entry.

Arguments:

	pRCE					- RCE to be unlinked.
	pIpEntry				- ATMARP IP Entry from which the RCE is to be
							  removed.

Return Value:

	TRUE if the RCE was indeed in the list for the IP Entry, FALSE
	otherwise.

--*/
{
	BOOLEAN					Found;	// Did we find the RCE?
	RouteCacheEntry **		ppRCE;	// Used for walking the list of RCEs
	PATMARP_RCE_CONTEXT		pRCEContext;

	//
	//  Initialize
	//
	Found = FALSE;

	//
	//  Go down the list of RCEs attached to this IP Entry, and
	//  find this RCE's position. We remember a pointer to the
	//  place that keeps the address of this RCE (i.e. ppRCE),
	//  so that we can remove this RCE from the list quickly.
	//
	ppRCE = &(pIpEntry->pRCEList);
	while (*ppRCE != pRCE)
	{
		pRCEContext = (PATMARP_RCE_CONTEXT)(&((*ppRCE)->rce_context[0]));

		if (pRCEContext->pNextRCE == (RouteCacheEntry *)NULL)
		{
			//
			//  Allow for the RCE to be absent in the list?
			//
			AA_ASSERT(FALSE);	// REMOVELATER
			break;
		}
		else
		{
			//
			//  Walk down the list.
			//
			ppRCE = &(pRCEContext->pNextRCE);
		}
	}

	if (*ppRCE == pRCE)
	{
		//
		//  We found it. Make the predecessor point to the successor.
		//
		pRCEContext = (PATMARP_RCE_CONTEXT)(&(pRCE->rce_context[0]));
		*ppRCE = pRCEContext->pNextRCE;
		pRCEContext->pIpEntry = NULL_PATMARP_IP_ENTRY;
		Found = TRUE;
	}

	return (Found);

}


VOID
AtmArpLinkRCE(
	IN	RouteCacheEntry *			pRCE,
	IN	PATMARP_IP_ENTRY			pIpEntry	LOCKIN LOCKOUT
)
/*++

Routine Description:

	Link an RCE to an IP Entry's list of RCEs. Check if the RCE is already
	present - if so, ignore this.

	The caller is assumed to hold a lock to the IP Entry.

Arguments:

	pRCE					- RCE to be linked.
	pIpEntry				- ATMARP IP Entry to which the RCE is to be
							  linked.

Return Value:

	None

--*/
{
	RouteCacheEntry **		ppRCE;	// Used for walking the list of RCEs
	PATMARP_RCE_CONTEXT		pRCEContext;

	ppRCE = &(pIpEntry->pRCEList);

	//
	//  Check if the RCE is already present.
	//
	while (*ppRCE != NULL)
	{
		if (*ppRCE == pRCE)
		{
			//
			//  Found it.
			//
			break;
		}

		//
		//  Move to the next.
		//
		pRCEContext = (PATMARP_RCE_CONTEXT)(&((*ppRCE)->rce_context[0]));
		ppRCE = &(pRCEContext->pNextRCE);
	}


	if (*ppRCE == NULL)
	{
		//
		//  This RCE is not present in the IP Entry's list. Add it.
		//
		pRCEContext = (PATMARP_RCE_CONTEXT)&(pRCE->rce_context[0]);
		pRCEContext->pIpEntry = pIpEntry;
		pRCEContext->pNextRCE = pIpEntry->pRCEList;
		pIpEntry->pRCEList = pRCE;

		AA_REF_IE(pIpEntry, IE_REFTYPE_RCE);	// RCE ref
	}
	else
	{
		AADEBUGP(AAD_LOUD, ("AtmArpLinkRCE: RCE 0x%x already linked to IP Entry 0x%x\n",
								pRCE, pIpEntry));
	}
}




INT
AtmArpIfQueryInfo(
	IN		PVOID					Context,
	IN		TDIObjectID *			pID,
	IN		PNDIS_BUFFER			pNdisBuffer,
	IN OUT	PUINT					pBufferSize,
	IN		PVOID					QueryContext
)
/*++

Routine Description:

	This is called from the IP layer to query for statistics or other
	information about an interface.

Arguments:

	Context					- Actually a pointer to our ATMARP Interface
	pID						- Describes the object being queried
	pNdisBuffer				- Space for returning information
	pBufferSize				- Pointer to size of above. On return, we fill
							  it with the actual bytes copied.
	QueryContext			- Context value pertaining to the query.

Return Value:

	TDI Status code.

--*/
{
	PATMARP_INTERFACE		pInterface;
	UINT					EntityType;
	UINT					Instance;
	UINT					BufferSize;
	UINT					ByteOffset;
	UINT					BytesCopied;
	INT						ReturnStatus;
	BOOLEAN					DataLeft;
	BOOLEAN					ContextValid;

	UCHAR					InfoBuff[sizeof(IFEntry)];	// Temp space for return value
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
	ULONG					OldDebugLevel;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	EntityType = pID->toi_entity.tei_entity;
	Instance = pID->toi_entity.tei_instance;
	BufferSize = *pBufferSize;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

#if DBG
	OldDebugLevel = AaDebugLevel;
#endif

	AADEBUGP(AAD_LOUD,
		("IfQueryInfo: pIf 0x%x, pID 0x%x, pBuf 0x%x, Size %d, Ent %d, Inst %d\n",
			pInterface, pID, pNdisBuffer, BufferSize, EntityType, Instance));

	//
	//  Initialize
	//
	ByteOffset = 0;
	ReturnStatus = TDI_INVALID_PARAMETER;

	do
	{
		if (pInterface->AdminState == IF_STATUS_DOWN)
		{
			ReturnStatus = TDI_INVALID_REQUEST;
			break;
		}

		//
		//  Check the Entity and Instance values.
		//
		if ((EntityType != AT_ENTITY || Instance != pInterface->ATInstance) &&
			(EntityType != IF_ENTITY || Instance != pInterface->IFInstance))
		{
			AADEBUGP(AAD_VERY_LOUD,
				("Mismatch: Entity %d, AT_ENTITY %d, Inst %d, IF AT Inst %d, IF_ENTITY %d, IF IF Inst %d\n",
					EntityType,
					AT_ENTITY,
					Instance,
					pInterface->ATInstance,
					IF_ENTITY,
					pInterface->IFInstance
				));

#if DBG_QRY
			if (!AaIgnoreInstance)
			{
				ReturnStatus = TDI_INVALID_REQUEST;
				break;
			}
#else
#ifndef ATMARP_WIN98
			ReturnStatus = TDI_INVALID_REQUEST;
			break;
#endif // !ATMARP_WIN98
#endif // DBG_QRY
		}

		AADEBUGP(AAD_LOUD, ("QueryInfo: pID 0x%x, toi_type %d, toi_class %d, toi_id %d\n",
			pID, pID->toi_type, pID->toi_class, pID->toi_id));

		*pBufferSize = 0;

		if (pID->toi_type != INFO_TYPE_PROVIDER)
		{
			AADEBUGP(AAD_VERY_LOUD, ("toi_type %d != PROVIDER (%d)\n",
					pID->toi_type,
					INFO_TYPE_PROVIDER));

			ReturnStatus = TDI_INVALID_PARAMETER;
			break;
		}

		if (pID->toi_class == INFO_CLASS_GENERIC)
		{
			if (pID->toi_id == ENTITY_TYPE_ID)
			{
				if (BufferSize >= sizeof(UINT))
				{
					AADEBUGP(AAD_VERY_LOUD,
						("INFO GENERIC, ENTITY TYPE, BufferSize %d\n", BufferSize));

					*((PUINT)&(InfoBuff[0])) = ((EntityType == AT_ENTITY) ? AT_ARP: IF_MIB);
					if (AtmArpCopyToNdisBuffer(
							pNdisBuffer,
							InfoBuff,
							sizeof(UINT),
							&ByteOffset) != NULL)
					{

//						*pBufferSize = sizeof(UINT);
						ReturnStatus = TDI_SUCCESS;
					}
					else
					{
						ReturnStatus = TDI_NO_RESOURCES;
					}
				}
				else
				{
					ReturnStatus = TDI_BUFFER_TOO_SMALL;
				}
			}
			else
			{
				ReturnStatus = TDI_INVALID_PARAMETER;
			}

			break;
		}

		if (EntityType == AT_ENTITY)
		{
			//
			//  This query is for an Address Translation Object.
			//
			if (pID->toi_id == AT_MIB_ADDRXLAT_INFO_ID)
			{
				//
				//  Request for the number of entries in the address translation
				//  table, and the IF index.
				//
				AddrXlatInfo            *pAXI;

				AADEBUGP(AAD_VERY_LOUD, ("QueryInfo: AT Entity, for IF index, ATE size\n"));

				if (BufferSize >= sizeof(AddrXlatInfo))
				{
					*pBufferSize = sizeof(AddrXlatInfo);

					pAXI = (AddrXlatInfo *)InfoBuff;
					pAXI->axi_count = pInterface->NumOfArpEntries;
					pAXI->axi_index = pInterface->IFIndex;

					if (AtmArpCopyToNdisBuffer(
							pNdisBuffer,
							InfoBuff,
							sizeof(AddrXlatInfo),
							&ByteOffset) != NULL)
					{
						ReturnStatus = TDI_SUCCESS;
					}
					else
					{
						ReturnStatus = TDI_NO_RESOURCES;
					}
				}
				else
				{
					ReturnStatus = TDI_BUFFER_TOO_SMALL;
				}
				break;
			}

			if (pID->toi_id == AT_MIB_ADDRXLAT_ENTRY_ID)
			{
				//
				//  Request for reading the address translation table.
				//
				AADEBUGP(AAD_VERY_LOUD, ("QueryInfo: AT Entity, for reading ATE\n"));

				AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
				DataLeft = AtmArpValidateTableContext(
									QueryContext,
									pInterface,
									&ContextValid
									);
				if (!ContextValid)
				{
					AA_RELEASE_IF_TABLE_LOCK(pInterface);
					ReturnStatus = TDI_INVALID_PARAMETER;
					break;
				}

				BytesCopied = 0;
				ReturnStatus = TDI_SUCCESS;
				while (DataLeft)
				{
					if ((INT)BufferSize - (INT)BytesCopied >=
							sizeof(IPNetToMediaEntry))
					{
						//
						//  Space left in output buffer.
						//
						DataLeft = AtmArpReadNextTableEntry(
										QueryContext,
										pInterface,
										InfoBuff
										);

						BytesCopied += sizeof(IPNetToMediaEntry);
						pNdisBuffer = AtmArpCopyToNdisBuffer(
										pNdisBuffer,
										InfoBuff,
										sizeof(IPNetToMediaEntry),
										&ByteOffset
										);

						if (pNdisBuffer == NULL)
						{
							BytesCopied = 0;
							ReturnStatus = TDI_NO_RESOURCES;
							break;
						}
					}
					else
					{
						break;
					}
				}

				AA_RELEASE_IF_TABLE_LOCK(pInterface);

				*pBufferSize = BytesCopied;

				if (ReturnStatus == TDI_SUCCESS)
				{
					ReturnStatus = (!DataLeft? TDI_SUCCESS : TDI_BUFFER_OVERFLOW);
				}

				break;
			}

			ReturnStatus = TDI_INVALID_PARAMETER;
			break;
		}

		if (pID->toi_class != INFO_CLASS_PROTOCOL)
		{
			ReturnStatus = TDI_INVALID_PARAMETER;
			break;
		}

		if (pID->toi_id == IF_MIB_STATS_ID)
		{
			//
			//  Request for Interface level statistics.
			//
			IFEntry			*pIFEntry = (IFEntry *)InfoBuff;

			AADEBUGP(AAD_VERY_LOUD, ("QueryInfo: MIB statistics\n"));

			//
			//  Check if we have enough space.
			//
			if (BufferSize < IFE_FIXED_SIZE)
			{
				ReturnStatus = TDI_BUFFER_TOO_SMALL;
				break;
			}

			pIFEntry->if_index = pInterface->IFIndex;
			pIFEntry->if_mtu = pInterface->MTU;
			pIFEntry->if_type = IF_TYPE_OTHER;
			pIFEntry->if_speed = pInterface->Speed;
			pIFEntry->if_adminstatus = pInterface->AdminState;
			if (pInterface->State == IF_STATUS_UP)
			{
				pIFEntry->if_operstatus = IF_OPER_STATUS_OPERATIONAL;
			}
			else
			{
				pIFEntry->if_operstatus = IF_OPER_STATUS_NON_OPERATIONAL;
			}
			pIFEntry->if_lastchange = pInterface->LastChangeTime;
			pIFEntry->if_inoctets = pInterface->InOctets;
			pIFEntry->if_inucastpkts = pInterface->InUnicastPkts;
			pIFEntry->if_innucastpkts = pInterface->InNonUnicastPkts;
			pIFEntry->if_indiscards = pInterface->InDiscards;
			pIFEntry->if_inerrors = pInterface->InErrors;
			pIFEntry->if_inunknownprotos = pInterface->UnknownProtos;
			pIFEntry->if_outoctets = pInterface->OutOctets;
			pIFEntry->if_outucastpkts = pInterface->OutUnicastPkts;
			pIFEntry->if_outnucastpkts = pInterface->OutNonUnicastPkts;
			pIFEntry->if_outdiscards = pInterface->OutDiscards;
			pIFEntry->if_outerrors = pInterface->OutErrors;
			pIFEntry->if_outqlen = 0;
			pIFEntry->if_descrlen = pInterface->pAdapter->DescrLength;

#ifndef ATMARP_WIN98
			pIFEntry->if_physaddrlen = AA_ATM_PHYSADDR_LEN;
			AA_COPY_MEM(
					pIFEntry->if_physaddr,
					&(pInterface->pAdapter->MacAddress[0]),
					AA_ATM_ESI_LEN
					);
			pIFEntry->if_physaddr[AA_ATM_PHYSADDR_LEN-1] = (UCHAR)pInterface->SapSelector;
#else
			//
			//  Win98: winipcfg doesn't like 7 byte long physical address.
			//
			pIFEntry->if_physaddrlen = AA_ATM_ESI_LEN;
			AA_COPY_MEM(
					pIFEntry->if_physaddr,
					&(pInterface->pAdapter->MacAddress[0]),
					AA_ATM_ESI_LEN
					);

			//
			// Since w're only reporting 6 bytes, we need to make the reported
			// MAC address look different from what LANE reports (LANE reports
			// the MAC address). So we simply put the special value 0x0a 0xac
			// (for aac, or "atm arp client") in the 1st USHORTS.
			//
			pIFEntry->if_physaddr[0] = 0x0a;
			pIFEntry->if_physaddr[1] = 0xac;
#endif

			if (AtmArpCopyToNdisBuffer(
					pNdisBuffer,
					InfoBuff,
					IFE_FIXED_SIZE,
					&ByteOffset) == NULL)
			{
				*pBufferSize = 0;
				ReturnStatus = TDI_NO_RESOURCES;
				break;
			}

			if (BufferSize >= (IFE_FIXED_SIZE + pIFEntry->if_descrlen))
			{
				*pBufferSize = IFE_FIXED_SIZE + pIFEntry->if_descrlen;
				ReturnStatus = TDI_SUCCESS;

				if (pIFEntry->if_descrlen != 0)
				{
					if (AtmArpCopyToNdisBuffer(
							pNdisBuffer,
							pInterface->pAdapter->pDescrString,
							pIFEntry->if_descrlen,
							&ByteOffset) == NULL)
					{
						// Failed to copy descr string
						*pBufferSize = IFE_FIXED_SIZE;
						ReturnStatus = TDI_NO_RESOURCES;
					}
				}
			}
			else
			{
				*pBufferSize = IFE_FIXED_SIZE;
				ReturnStatus = TDI_BUFFER_OVERFLOW;
			}
			break;
		}
	}
	while (FALSE);

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	AADEBUGP(AAD_LOUD, ("QueryInfo: returning 0x%x (%s), BufferSize %d\n",
					ReturnStatus,
					((ReturnStatus == TDI_SUCCESS)? "SUCCESS": "FAILURE"),
					*pBufferSize
			));

#if DBG
	AaDebugLevel = OldDebugLevel;
#endif
	return (ReturnStatus);

}


INT
AtmArpIfSetInfo(
	IN		PVOID					Context,
	IN		TDIObjectID *			pID,
	IN		PVOID					pBuffer,
	IN		UINT					BufferSize
)
/*++

Routine Description:

	This is called from the IP layer to set the value of an object
	for an interface.

Arguments:
	Context					- Actually a pointer to our ATMARP Interface
	pID						- Describes the object being set
	pBuffer					- Value for the object
	BufferSize				- Size of above

Return Value:

	TDI Status code.

--*/
{
	AADEBUGP(AAD_ERROR, ("IfSetInfo: pIf 0x%x, Will return failure!\n",
					Context));

	return (TDI_INVALID_REQUEST);	// TBD: support Sets.
}



INT
AtmArpIfGetEList(
	IN		PVOID					Context,
	IN		TDIEntityID *			pEntityList,
	IN OUT	PUINT					pEntityListSize
)
/*++

Routine Description:

	This routine is called when the interface starts up, in order to
	assign all relevant Entity Instance numbers for an interface.
	The ATMARP module belongs to the "AT" and "IF" types. The entity
	list is a list of <Entity type, Instance number> tuples that have
	been filled in by other modules.

	For each of the entity types we support, we find the largest
	instance number in use (by walking thru the Entity list), and
	assign to ourselves the next larger number in each case. Using
	these numbers, we append our tuples to the end of the Entity list,
	if there is enough space.

	NT 5: we may find that our entries are already present, in which
	case we don't create new entries.

	It is assumed that this isn't reentered. If this assumption is
	false, we should acquire our Interface lock in here.

Arguments:

	Context					- Actually a pointer to our ATMARP Interface
	pEntityList				- Pointer to TDI Entity list
	pEntityListSize			- Pointer to length of above list. We update
							  this if we add our entries to the list.

Return Value:

	TRUE if successful, FALSE otherwise.

--*/
{
	PATMARP_INTERFACE	pInterface;
	UINT				EntityCount;	// Total elements in Entity list
	UINT				i;				// Iteration counter
	UINT				MyATInstance;	// "AT" Instance number we assign to ourselves
	UINT				MyIFInstance;	// "IF" Instance number we assign to ourselves
	INT					ReturnValue;
	TDIEntityID *		pATEntity;		// Points to our AT entry
	TDIEntityID *		pIFEntity;		// Points to our IF entry

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	EntityCount = *pEntityListSize;
	pATEntity = NULL;
	pIFEntity = NULL;
	MyATInstance = MyIFInstance = 0;

	AADEBUGP(AAD_INFO, ("IfGetEList: pIf 0x%x, pList 0x%x, Cnt %d\n",
			pInterface, pEntityList, EntityCount));

	do
	{
#ifdef OLD_ENTITY_LIST
		//
		//  We need space for 2 entries; see if this is available.
		//
		if (EntityCount + 2 > MAX_TDI_ENTITIES)
		{
			ReturnValue = FALSE;
			break;
		}

		//
		//  Search for the max used-up instance numbers for the "AT"
		//  and "IF" types.
		//
		MyATInstance = MyIFInstance = 0;
		for (i = 0; i < EntityCount; i++, pEntityList++)
		{
			if (pEntityList->tei_entity == AT_ENTITY)
			{
				MyATInstance = MAX(MyATInstance, pEntityList->tei_instance + 1);
			}
			else if (pEntityList->tei_entity == IF_ENTITY)
			{
				MyIFInstance = MAX(MyIFInstance, pEntityList->tei_instance + 1);
			}
		}

		//
		//  Save our instance numbers for later use.
		//
		pInterface->ATInstance = MyATInstance;
		pInterface->IFInstance = MyIFInstance;

		//
		//  Append our AT and IF entries to the Entity list.
		//  Recall that we just traversed the list fully, so we
		//  are pointing to the right place to add entries.
		//
		pEntityList->tei_entity = AT_ENTITY;
		pEntityList->tei_instance = MyATInstance;
		pEntityList++;
		pEntityList->tei_entity = IF_ENTITY;
		pEntityList->tei_instance = MyIFInstance;

		//
		//  Return the new list size.
		//
		*pEntityListSize += 2;

		ReturnValue = TRUE;
#else


		//
		//  Walk down the list, looking for AT/IF entries matching our
		//  instance values. Also remember the largest AT and IF instance
		//  values we see, so that we can allocate the next larger values
		//  for ourselves, in case we don't have instance values assigned.
		//
		for (i = 0; i < EntityCount; i++, pEntityList++)
		{
			//
			//  Skip invalid entries.
			//
			if (pEntityList->tei_instance == INVALID_ENTITY_INSTANCE)
			{
				continue;
			}

			if (pEntityList->tei_entity == AT_ENTITY)
			{
				if (pEntityList->tei_instance == pInterface->ATInstance)
				{
					//
					//  This is our AT entry.
					//
					pATEntity = pEntityList;
				}
				else
				{
					MyATInstance = MAX(MyATInstance, pEntityList->tei_instance + 1);
				}
			}
			else if (pEntityList->tei_entity == IF_ENTITY)
			{
				if (pEntityList->tei_instance == pInterface->IFInstance)
				{
					//
					//  This is our IF entry.
					//
					pIFEntity = pEntityList;
				}
				else
				{
					MyIFInstance = MAX(MyIFInstance, pEntityList->tei_instance + 1);
				}
			}
		}


		ReturnValue = TRUE;

		//
		//  Update or create our Address Translation entry.
		//
		if (pATEntity)
		{
			//
			//  We found our entry.
			//
			if (pInterface->AdminState == IF_STATUS_DOWN)
			{
				pATEntity->tei_instance = INVALID_ENTITY_INSTANCE;
			}
		}
		else
		{
			//
			//  Grab an entry for ourselves, unless we are shutting down.
			//
			if (pInterface->AdminState == IF_STATUS_DOWN)
			{
				break;
			}

			if (EntityCount >= MAX_TDI_ENTITIES)
			{
				ReturnValue = FALSE;
				break;
			}

			pEntityList->tei_entity = AT_ENTITY;
			pEntityList->tei_instance = MyATInstance;
			pInterface->ATInstance = MyATInstance;

			pEntityList++;
			(*pEntityListSize)++;
			EntityCount++;
		}

		//
		//  Update or create or IF entry.
		//
		if (pIFEntity)
		{
			//
			//  We found our entry.
			//
			if (pInterface->AdminState == IF_STATUS_DOWN)
			{
				pIFEntity->tei_instance = INVALID_ENTITY_INSTANCE;
			}
		}
		else
		{
			//
			//  Grab an entry for ourselves, unless we are shutting down.
			//
			if (pInterface->AdminState == IF_STATUS_DOWN)
			{
				break;
			}

			if (EntityCount >= MAX_TDI_ENTITIES)
			{
				ReturnValue = FALSE;
				break;
			}

			pEntityList->tei_entity = IF_ENTITY;
			pEntityList->tei_instance = MyIFInstance;
			pInterface->IFInstance = MyIFInstance;

			pEntityList++;
			(*pEntityListSize)++;
			EntityCount++;
		}
#endif // OLD_ENTITY_LIST
	}
	while (FALSE);


	AADEBUGP(AAD_INFO,
	 ("IfGetEList: returning %d, MyAT %d, MyIF %d, pList 0x%x, Size %d\n",
		ReturnValue, MyATInstance, MyIFInstance, pEntityList, *pEntityListSize));

	return (ReturnValue);
}



#ifdef _PNP_POWER_

VOID
AtmArpIfPnPComplete(
	IN	PVOID						Context,
	IN	NDIS_STATUS					Status,
	IN	PNET_PNP_EVENT				pNetPnPEvent
)
/*++

Routine Description:

	This routine is called by IP when it completes a previous call
	we made to its PnP event handler.

	If this is the last Interface on the adapter, we complete the
	NDIS PNP notification that lead to this. Otherwise, we indicate
	this same event to IP on the next Interface on the adapter.

Arguments:

	Context					- Actually a pointer to our ATMARP Interface
	Status					- Completion status from IP
	pNetPnPEvent			- The PNP event

Return Value:

	None

--*/
{
	PATMARP_INTERFACE			pInterface;

	pInterface = (PATMARP_INTERFACE)Context;

	AADEBUGP(AAD_INFO,
			("IfPnPComplete: IF 0x%x, Status 0x%x, Event 0x%x\n",
					pInterface, Status, pNetPnPEvent));

	if (pInterface != NULL_PATMARP_INTERFACE)
	{
		AA_STRUCT_ASSERT(pInterface, aai);
		if (pInterface->pNextInterface == NULL_PATMARP_INTERFACE)
		{
			NdisCompletePnPEvent(
					Status,
					pInterface->pAdapter->NdisAdapterHandle,
					pNetPnPEvent
					);
		}
		else
		{
			pInterface = pInterface->pNextInterface;
	
			(*pInterface->IPPnPEventHandler)(
					pInterface->IPContext,
					pNetPnPEvent
					);
		}
	}
	else
	{
		NdisCompletePnPEvent(
					Status,
					NULL,
					pNetPnPEvent
					);
	}

	return;
}

#endif // _PNP_POWER_


#ifdef PROMIS
EXTERN
NDIS_STATUS
AtmArpIfSetNdisRequest(
	IN	PVOID						Context,
	IN	NDIS_OID					Oid,
	IN	UINT						On
)
/*++

Routine Description:

    ARP Ndisrequest handler.
    Called by the upper driver to set the packet filter for the interface.

Arguments:

       Context     - Actually a pointer to our ATMARP Interface
       OID         - Object ID to set/unset
       On          - Set_if, clear_if or clear_card

Return Value:

	Status

--*/
{
    NDIS_STATUS         Status	    = NDIS_STATUS_SUCCESS;
	PATMARP_INTERFACE	pInterface  =  (PATMARP_INTERFACE)Context;

    AADEBUGP(AAD_INFO,("IfSetNdisRequest: pIF =0x%x; Oid=0x%x; On=%u\n",
                pInterface,
                Oid,
                On
                ));

    do
    {
        //
        //  We set IPAddress and mask to span the entire mcast address range...
        //
	    IP_ADDRESS					IPAddress	= IP_CLASSD_MIN; 
	    IP_MASK						Mask		= IP_CLASSD_MASK;
	    UINT						ReturnStatus = TRUE;
		NDIS_OID					PrevOidValue;

        if (Oid != NDIS_PACKET_TYPE_ALL_MULTICAST)
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        AA_STRUCT_ASSERT(pInterface, aai);
        AA_ACQUIRE_IF_LOCK(pInterface);

		PrevOidValue = pInterface->EnabledIPFilters & NDIS_PACKET_TYPE_ALL_MULTICAST;

        if (On)
        {
        	if (PrevOidValue == 0)
        	{
        		pInterface->EnabledIPFilters |= NDIS_PACKET_TYPE_ALL_MULTICAST;

		    	ReturnStatus = AtmArpMcAddAddress(pInterface, IPAddress, Mask);
				//
				// IF lock released above
				//
			}
			else
			{
            	AA_RELEASE_IF_LOCK(pInterface);
			}
        }
        else
        {
        	if (PrevOidValue != 0)
        	{
        		pInterface->EnabledIPFilters &= ~NDIS_PACKET_TYPE_ALL_MULTICAST;

            	ReturnStatus = AtmArpMcDelAddress(pInterface, IPAddress, Mask);
				//
				// IF lock released above
				//
			}
			else
			{
            	AA_RELEASE_IF_LOCK(pInterface);
			}
        }

        if (ReturnStatus != TRUE)
        {
        	//
        	// We've got to restore EnabledIPFilters to it's original value.
        	//
        	AA_ACQUIRE_IF_LOCK(pInterface);
			pInterface->EnabledIPFilters &= ~NDIS_PACKET_TYPE_ALL_MULTICAST;
			pInterface->EnabledIPFilters |= PrevOidValue;
            AA_RELEASE_IF_LOCK(pInterface);

            
			Status = NDIS_STATUS_FAILURE;
        }

    }
    while (FALSE);

    AADEBUGP(AAD_INFO, ("IfSetNdisRequest(pIF =0x%x) returns 0x%x\n",
            pInterface,
            Status
            ));

    return Status;
}
#endif // PROMIS


PNDIS_BUFFER		AtmArpFreeingBuffer = NULL;
PNDIS_PACKET		AtmArpFreeingPacket = NULL;
AA_HEADER_TYPE		AtmArpFreeingHdrType = 0;

VOID
AtmArpFreeSendPackets(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				PacketList,
	IN	BOOLEAN						HdrPresent
)
/*++

Routine Description:

	Free a list of packets that were queued to be sent, but have been
	"aborted". Each packet in this list is one of the following types:
	(a) Belonging to IP (b) Belonging to the ATMARP module. In the case
	of an IP packet, HdrPresent tells us whether or not we had prepended
	an LLC/SNAP header to this packet, and its type: we need this information
	because we need to reclaim such headers.

	Also, in the case of IP packets, we call IP's Transmit Complete up-call,
	to inform IP of a failed transmission.

Arguments:

	pInterface			- Pointer to ATMARP Interface on which these
						  packets would have been sent.
	PacketList			- Pointer to first packet in a list.
	HdrPresent			- Is an LLC/SNAP header present

Return Value:

	None

--*/
{
	PNDIS_PACKET		pNdisPacket;
	PNDIS_PACKET		pNextPacket;
	PNDIS_BUFFER		pNdisBuffer;
	ULONG				NumberOfDiscards;
	PacketContext		*PC;
	AA_HEADER_TYPE		HdrType;

	NumberOfDiscards = 0;

	pNdisPacket = PacketList;

	while (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		NumberOfDiscards++;
		pNextPacket = AA_GET_NEXT_PACKET(pNdisPacket);
		AA_SET_NEXT_PACKET(pNdisPacket, NULL);

		PC = (PacketContext *)pNdisPacket->ProtocolReserved;
		if (PC->pc_common.pc_owner != PACKET_OWNER_LINK)
		{
			//
			//  Belongs to IP.
			//
			if (HdrPresent)
			{
				PUCHAR			pData;
				UINT			Length;

#ifdef BACK_FILL
				NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
				AA_ASSERT(pNdisBuffer != NULL);

				NdisQueryBuffer(pNdisBuffer, &pData, &Length);

				if (pData[5] == LLC_SNAP_OUI2)
				{
					HdrType = AA_HEADER_TYPE_UNICAST;
				}
				else
				{
					HdrType = AA_HEADER_TYPE_NUNICAST;
				}

				//
				//  Now check if we had attached a header buffer or not.
				//
				if (AtmArpDoBackFill && AA_BACK_FILL_POSSIBLE(pNdisBuffer))
				{
					ULONG		HeaderLength;

					AADEBUGP(AAD_VERY_LOUD,
					    ("FreeSendPackets: IF %x, Pkt %x Buf %x has been backfilled\n",
					        pInterface, pNdisPacket, pNdisBuffer));

					//
					//  We would have back-filled IP's buffer with the LLC/SNAP
					//  header. Remove the back-fill.
					//
					HeaderLength = ((HdrType == AA_HEADER_TYPE_UNICAST)?
										sizeof(AtmArpLlcSnapHeader) :
#ifdef IPMCAST
										sizeof(AtmArpMcType1ShortHeader));
#else
										0);
#endif // IPMCAST
					(PUCHAR)pNdisBuffer->MappedSystemVa += HeaderLength;
					pNdisBuffer->ByteOffset += HeaderLength;
					pNdisBuffer->ByteCount -= HeaderLength;
				}
				else
				{
					//
					//  The first buffer would be our header buffer. Remove
					//  it from the packet and return to our pool.
					//
					NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);

					AtmArpFreeingBuffer = pNdisBuffer; // to help debugging
					AtmArpFreeingPacket = pNdisPacket; // to help debugging
					AtmArpFreeingHdrType = HdrType;

					AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
				}
#else	// BACK_FILL

				//
				//  Free the LLC/SNAP header buffer.
				//
				NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
				AA_ASSERT(pNdisBuffer != NULL);
				NdisQueryBuffer(pNdisBuffer, &pData, &Length);
				if (pData[5] == LLC_SNAP_OUI2)
				{
					HdrType = AA_HEADER_TYPE_UNICAST;
				}
				else
				{
					AA_ASSERT(pData[5] == MC_LLC_SNAP_OUI2);
					HdrType = AA_HEADER_TYPE_NUNICAST;
				}

				AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
#endif // BACK_FILL

			}

			//
			//  Inform IP of send completion.
			//
			(*(pInterface->IPTxCmpltHandler))(
						pInterface->IPContext,
						pNdisPacket,
						NDIS_STATUS_FAILURE
						);
		}
		else
		{
			//
			//  Belongs to us.
			//
			NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);

			AtmArpFreeProtoBuffer(pInterface, pNdisBuffer);
			AtmArpFreePacket(pInterface, pNdisPacket);
		}

		//
		//  Go to next packet in the list.
		//
		pNdisPacket = pNextPacket;
	}

	//
	//  Update IF statistics
	//
	AA_IF_STAT_ADD(pInterface, OutDiscards, NumberOfDiscards);

}


#define IPNetMask(a)	AtmArpIPMaskTable[(*(uchar *)&(a)) >> 4]

BOOLEAN
AtmArpIsBroadcastIPAddress(
	IN	IP_ADDRESS					Addr,
	IN	PATMARP_INTERFACE			pInterface		LOCKIN LOCKOUT
)
/*++

Routine Description:

	Check if the given IP address is a broadcast address for the
	interface.

	Copied from the LAN ARP module.

Arguments:

	Addr			- The IP Address to be checked
	pInterface		- Pointer to our Interface structure

Return Value:

	TRUE if the address is a broadcast address, FALSE otherwise.

--*/
{
	IP_ADDRESS				BCast;
	IP_MASK					Mask;
	PIP_ADDRESS_ENTRY		pIpAddressEntry;
	IP_ADDRESS				LocalAddr;

    // First get the interface broadcast address.
    BCast = pInterface->BroadcastAddress;

    // First check for global broadcast.
    if (IP_ADDR_EQUAL(BCast, Addr) || CLASSD_ADDR(Addr))
		return TRUE;

    // Now walk the local addresses, and check for net/subnet bcast on each
    // one.
	pIpAddressEntry = &(pInterface->LocalIPAddress);
	do {
		// See if this one is valid.
		LocalAddr = pIpAddressEntry->IPAddress;
		if (!IP_ADDR_EQUAL(LocalAddr, NULL_IP_ADDR)) {
			// He's valid.
			Mask = pIpAddressEntry->IPMask;

            // First check for subnet bcast.
            if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
				return TRUE;

            // Now check all nets broadcast.
            Mask = IPNetMask(LocalAddr);
            if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
				return TRUE;
		}

		pIpAddressEntry = pIpAddressEntry->pNext;

	} while (pIpAddressEntry != NULL);

	// If we're here, it's not a broadcast.
	return FALSE;
}


BOOLEAN
AtmArpValidateTableContext(
	IN	PVOID						QueryContext,
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN *					pIsValid
)
/*++

Routine Description:

	Check if a given ARP Table Query context is valid. It is valid if it
	is either NULL (looking for the first entry) or indicates a valid
	ARP Table Entry.

Arguments:

	QueryContext		- The context to be validated
	pInterface			- The IF on which the query is being performed
	pIsValid			- Where we return the validity of the Query Context.


Return Value:

	TRUE if the ARP Table has data to be read beyond the given context,
	FALSE otherwise.

--*/
{
	IPNMEContext        *pNMContext = (IPNMEContext *)QueryContext;
	PATMARP_IP_ENTRY	pIpEntry;
	PATMARP_IP_ENTRY	pTargetIpEntry;
	UINT				i;
	BOOLEAN				ReturnValue;

	i = pNMContext->inc_index;
	pTargetIpEntry = (PATMARP_IP_ENTRY)(pNMContext->inc_entry);

	//
	//  Check if we are starting at the beginning of the ARP Table.
	//
	if ((i == 0) && (pTargetIpEntry == NULL_PATMARP_IP_ENTRY))
	{
		//
		//  Yes, we are. Find the very first entry in the hash table.
		//
		*pIsValid = TRUE;
		do
		{
			if ((pIpEntry = pInterface->pArpTable[i]) != NULL_PATMARP_IP_ENTRY)
			{
				break;
			}
			i++;
		}
		while (i < ATMARP_TABLE_SIZE);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			pNMContext->inc_index = i;
			pNMContext->inc_entry = pIpEntry;
			ReturnValue = TRUE;
		}
		else
		{
			ReturnValue = FALSE;
		}
	}
	else
	{
		//
		//  We are given a context. Check if it is valid.
		//

		//
		//  Initialize.
		//
		*pIsValid = FALSE;
		ReturnValue = FALSE;

		if (i < ATMARP_TABLE_SIZE)
		{
			pIpEntry = pInterface->pArpTable[i];
			while (pIpEntry != NULL_PATMARP_IP_ENTRY)
			{
				if (pIpEntry == pTargetIpEntry)
				{
					*pIsValid = TRUE;
					ReturnValue = TRUE;
					break;
				}
				else
				{
					pIpEntry = pIpEntry->pNextEntry;
				}
			}
		}
	}

	return (ReturnValue);

}



BOOLEAN
AtmArpReadNextTableEntry(
	IN	PVOID						QueryContext,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR						pSpace
)
/*++

Routine Description:

	Read the next ARP Table Entry for the specified interface. The QueryContext
	tells us which entry is to be read.

Arguments:

	QueryContext		- Indicates the entry to be read.
	pInterface			- The IF on which the query is being performed
	pSpace				- where we copy in the desired table entry.

Return Value:

	TRUE if the ARP Table has entries beyond the indicated one, FALSE
	otherwise.

--*/
{
	IPNMEContext		*pNMContext;
	IPNetToMediaEntry	*pIPNMEntry;
	PATMARP_IP_ENTRY	pIpEntry;
	UINT				i;
	BOOLEAN				ReturnValue;

	pNMContext = (IPNMEContext *)QueryContext;
	pIPNMEntry = (IPNetToMediaEntry *)pSpace;

	pIpEntry = (PATMARP_IP_ENTRY)(pNMContext->inc_entry);
	AA_STRUCT_ASSERT(pIpEntry, aip);

	pIPNMEntry->inme_index = pInterface->IFIndex;

	pIPNMEntry->inme_addr = pIpEntry->IPAddress;
	if (AA_IS_FLAG_SET(pIpEntry->Flags, AA_IP_ENTRY_STATE_MASK, AA_IP_ENTRY_RESOLVED))
	{
		AADEBUGP(AAD_EXTRA_LOUD, ("ReadNext: found IP Entry 0x%x, Addr %d.%d.%d.%d\n",
					pIpEntry,
					((PUCHAR)(&(pIpEntry->IPAddress)))[0],
					((PUCHAR)(&(pIpEntry->IPAddress)))[1],
					((PUCHAR)(&(pIpEntry->IPAddress)))[2],
					((PUCHAR)(&(pIpEntry->IPAddress)))[3]
				));

		pIPNMEntry->inme_physaddrlen = AA_ATM_PHYSADDR_LEN;

		AA_ASSERT(pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
		AA_COPY_MEM(pIPNMEntry->inme_physaddr,
					&pIpEntry->pAtmEntry->ATMAddress.Address[AA_ATM_ESI_OFFSET],
					AA_ATM_PHYSADDR_LEN);

		if (pIpEntry->Flags & AA_IP_ENTRY_IS_STATIC)
		{
			pIPNMEntry->inme_type = INME_TYPE_STATIC;
		}
		else
		{
			pIPNMEntry->inme_type = INME_TYPE_DYNAMIC;
		}
	}
	else
	{
		pIPNMEntry->inme_physaddrlen = 0;
		pIPNMEntry->inme_type = INME_TYPE_INVALID;
	}

	//
	//  Update the context for the next entry.
	//
	if (pIpEntry->pNextEntry != NULL_PATMARP_IP_ENTRY)
	{
		pNMContext->inc_entry = pIpEntry->pNextEntry;
		ReturnValue = TRUE;
	}
	else
	{
		//
		//  Initialize.
		ReturnValue = FALSE;
		i = pNMContext->inc_index + 1;
		pNMContext->inc_index = 0;
		pNMContext->inc_entry = NULL;

		while (i < ATMARP_TABLE_SIZE)
		{
			if (pInterface->pArpTable[i] != NULL_PATMARP_IP_ENTRY)
			{
				pNMContext->inc_entry = pInterface->pArpTable[i];
				pNMContext->inc_index = i;
				ReturnValue = TRUE;
				break;
			}
			else
			{
				i++;
			}
		}
	}

	return (ReturnValue);


}

VOID
AtmArpReStartInterface(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						IfContext
)
/*++

Routine Description:

	Bring back up the IP interface.

Arguments:

    pWorkItem
	IfContextw			- The IF, which is expected to have reconfig
	                      state RECONFIG_QUEUED.

Return Value:

	None

--*/
{


	PATMARP_INTERFACE		pInterface;
	ULONG					rc;
	BOOLEAN                 fRestart = FALSE;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);
#if !BINARY_COMPATIBLE
	AA_ASSERT(EntryIrq == PASSIVE_LEVEL);
#endif

	pInterface = (PATMARP_INTERFACE)IfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_FREE_MEM(pWorkItem);

	AA_ACQUIRE_IF_LOCK(pInterface);

    if (pInterface->ReconfigState != RECONFIG_RESTART_QUEUED)
    {
        //
        // Shouldn't get here.
        //
        AA_ASSERT(FALSE);
    }
    else
    {
        pInterface->ReconfigState = RECONFIG_RESTART_PENDING;
	    fRestart = TRUE;
    }

    rc = AtmArpDereferenceInterface(pInterface); // Reconfig Work item

	AADEBUGP(AAD_WARNING, ("RestartIF: IF %x/%x, fRestart %d, rc %d\n",
			pInterface, pInterface->Flags, fRestart, rc));

	//
	// If we're restarting, there should be at least 2 references to the
	// pInterface -- 1- the old carryover and 2- the pending completion
	// completion of the reconfig event.
	//
    if (rc < 2 || !fRestart) 
    {
        //
        // Must be  at least 2 if we're in the middle of a reconfig!
        //
        AA_ASSERT(!fRestart);

        if (rc != 0)
        {
        	AA_RELEASE_IF_LOCK(pInterface);
        }
    }
    else
    {			
    	//
    	// At this point we know that we are doing a restart of the interface.
    	//
    	// We will extract the pointer to the adapter, the
    	// configuration string for the interface, and the pointer to the
		// pending netPnpEvent  (we'll need these later),
    	// and then do a FORCED DEALLOCATION of the interface.
    	// We will then allocate the interface. We go through this 
    	// deallocate-allocate sequence to make sure that the interface
    	// structure and all it's sub-structures are properly initialized.
    	//
    	// We could have tried to re-use the old interface, but if so we
    	// would have to write code to clean up the old interface. Given
    	// that we expect restarting of the interface to be an infrequent
    	// event, it is more important to conserve code size in this case.
    	//
		NDIS_STRING IPConfigString 		= pInterface->IPConfigString; // struct copy
		PATMARP_ADAPTER	pAdapter 		= pInterface->pAdapter;
		PNET_PNP_EVENT	pReconfigEvent	= pInterface->pReconfigEvent;
		NDIS_STATUS Status 				= NDIS_STATUS_SUCCESS;
	
		do
		{
			NDIS_HANDLE					LISConfigHandle;

			rc = AtmArpDereferenceInterface(pInterface);

			if (rc)
			{
				rc = AtmArpDereferenceInterface(pInterface);
			}

			if (rc != 0)
			{
				AA_RELEASE_IF_LOCK(pInterface);
			}

			pInterface = NULL;

			//
			//  Open the configuration section for this LIS.
			//
			LISConfigHandle = AtmArpCfgOpenLISConfigurationByName(
										pAdapter,
										&IPConfigString
										);
	
			if (LISConfigHandle == NULL)
			{
				//
				//  This is the normal termination condition, i.e.
				//  we reached the end of the LIS list for this
				//  adapter.
				//
				AADEBUGP(AAD_INFO, ("ReStartInterface: cannot open LIS\n"));
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			pInterface =  AtmArpAddInterfaceToAdapter (
							pAdapter,
							LISConfigHandle,
							&IPConfigString
							);

			//
			//  Close the configuration section for this LIS.
			//
			AtmArpCfgCloseLISConfiguration(LISConfigHandle);
			LISConfigHandle = NULL;

			if (pInterface == NULL_PATMARP_INTERFACE)
			{
				Status = NDIS_STATUS_FAILURE;
				break;
			}

		} while(FALSE);

#ifdef _PNP_POWER_
		//
		// Complete the pending PnPReconfig event, if any.
		//
		if (pReconfigEvent)
		{

			NdisCompletePnPEvent(
				Status,
				pAdapter->NdisAdapterHandle,
				pReconfigEvent
				);
			
			AADEBUGP( AAD_INFO,
				("ReStartInterface: IF 0x%x, Status 0x%x, Event 0x%x\n",
						pInterface, Status, pReconfigEvent));
		}
#else
		AA_ASSERT(!pReconfigEvent);
#endif

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\arpcfg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arpcfg.c - Configuration routines

Abstract:

	Routines to read in configuration information for the ATMARP client.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-09-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'GFCA'

//
//  Size of local temp buffer
//
#define WORK_BUF_SIZE		200


#define ASCII_TO_INT(val)		\
			( ( ((val) >= '0') && ('9' >= (val)) ) ? ((val) - '0') :	\
			  ( ((val) >= 'a') && ('z' >= (val)) ) ? ((val) - 'a' + 10) :	\
			  ( ((val) >= 'A') && ('Z' >= (val)) ) ? ((val) - 'A' + 10) :	\
			  0 )


//
//  Parameters for reading in a ULONG from configuration into an Interface
//  structure.
//
typedef struct _AA_READ_CONFIG_PARAMS
{
	ULONG			StructOffset;	// Offset of param from beginning of struct
	PWCHAR			ParameterName;	// Name in config database
	ULONG			DefaultValue;
} AA_READ_CONFIG_PARAMS, *PAA_READ_CONFIG_PARAMS;

#define AA_MAKE_RCP(Off, Name, Dflt)	\
		{ Off, Name, Dflt }

#define LIS_CONFIG_ENTRY(Field, Name, Dflt)	\
		AA_MAKE_RCP(FIELD_OFFSET(struct _ATMARP_INTERFACE, Field), Name, Dflt)

#define AA_BANDWIDTH_UNSPECIFIED		((ULONG)-1)
#define AA_PACKET_SIZE_UNSPECIFIED		((ULONG)-1)
#define AA_MTU_UNSPECIFIED				((ULONG)-1)
#define AA_SPEED_UNSPECIFIED			((ULONG)-1)

//
//  List of ULONG parameters for an LIS
//
AA_READ_CONFIG_PARAMS AtmArpLISConfigTable[] =
{
	LIS_CONFIG_ENTRY(SapSelector, L"SapSelector", AA_DEF_SELECTOR_VALUE),
	LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_UNICAST].MaxHeaderBufs, L"MaxHeaderBufs", AA_DEF_MAX_HEADER_BUFFERS),
	LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize, L"HeaderBufSize", AA_PKT_LLC_SNAP_HEADER_LENGTH),
#ifdef IPMCAST
	LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_NUNICAST].MaxHeaderBufs, L"McastMaxHeaderBufs", AA_DEF_MAX_HEADER_BUFFERS),
	LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize, L"McastHeaderBufSize", sizeof(AA_MC_PKT_TYPE1_SHORT_HEADER)),
#endif // IPMCAST
	LIS_CONFIG_ENTRY(ProtocolBufSize, L"ProtocolBufSize", AA_DEF_PROTOCOL_BUFFER_SIZE),
	LIS_CONFIG_ENTRY(MaxProtocolBufs, L"MaxProtocolBufs", AA_DEF_MAX_PROTOCOL_BUFFERS),
	LIS_CONFIG_ENTRY(MTU, L"MTU", AA_MTU_UNSPECIFIED),
	LIS_CONFIG_ENTRY(Speed, L"Speed", AA_SPEED_UNSPECIFIED),
	LIS_CONFIG_ENTRY(PVCOnly, L"PVCOnly", AA_DEF_PVC_ONLY_VALUE),
	LIS_CONFIG_ENTRY(ServerConnectInterval, L"ServerConnectInterval", AA_DEF_SERVER_CONNECT_INTERVAL),
	LIS_CONFIG_ENTRY(ServerRegistrationTimeout, L"ServerRegistrationTimeout", AA_DEF_SERVER_REGISTRATION_TIMEOUT),
	LIS_CONFIG_ENTRY(AddressResolutionTimeout, L"AddressResolutionTimeout", AA_DEF_ADDRESS_RESOLUTION_TIMEOUT),
	LIS_CONFIG_ENTRY(ARPEntryAgingTimeout, L"ARPEntryAgingTimeout", AA_DEF_ARP_ENTRY_AGING_TIMEOUT),
	LIS_CONFIG_ENTRY(InARPWaitTimeout, L"InARPWaitTimeout", AA_DEF_INARP_WAIT_TIMEOUT),
	LIS_CONFIG_ENTRY(ServerRefreshTimeout, L"ServerRefreshTimeout", AA_DEF_SERVER_REFRESH_INTERVAL),
	LIS_CONFIG_ENTRY(MinWaitAfterNak, L"MinWaitAfterNak", AA_DEF_MIN_WAIT_AFTER_NAK),
	LIS_CONFIG_ENTRY(MaxRegistrationAttempts, L"MaxRegistrationAttempts", AA_DEF_MAX_REGISTRATION_ATTEMPTS),
	LIS_CONFIG_ENTRY(MaxResolutionAttempts, L"MaxResolutionAttempts", AA_DEF_MAX_RESOLUTION_ATTEMPTS),

	LIS_CONFIG_ENTRY(DefaultFlowSpec.SendPeakBandwidth, L"DefaultSendBandwidth", AA_BANDWIDTH_UNSPECIFIED),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.ReceivePeakBandwidth, L"DefaultReceiveBandwidth", AA_BANDWIDTH_UNSPECIFIED),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.SendMaxSize, L"DefaultSendMaxSize", AA_PACKET_SIZE_UNSPECIFIED),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.ReceiveMaxSize, L"DefaultReceiveMaxSize", AA_PACKET_SIZE_UNSPECIFIED),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.SendServiceType, L"DefaultServiceType", AA_DEF_FLOWSPEC_SERVICETYPE),
	LIS_CONFIG_ENTRY(DefaultFlowSpec.AgingTime, L"DefaultVCAgingTimeout", AA_DEF_VC_AGING_TIMEOUT)
#ifdef IPMCAST
	,
	LIS_CONFIG_ENTRY(MARSConnectInterval, L"MARSConnectInterval", AA_DEF_SERVER_CONNECT_INTERVAL),
	LIS_CONFIG_ENTRY(MARSRegistrationTimeout, L"MARSRegistrationTimeout", AA_DEF_SERVER_REGISTRATION_TIMEOUT),
	LIS_CONFIG_ENTRY(MARSKeepAliveTimeout, L"MARSKeepAliveTimeout", AA_DEF_MARS_KEEPALIVE_TIMEOUT),
	LIS_CONFIG_ENTRY(JoinTimeout, L"JoinTimeout", AA_DEF_MARS_JOIN_TIMEOUT),
	LIS_CONFIG_ENTRY(LeaveTimeout, L"LeaveTimeout", AA_DEF_MARS_LEAVE_TIMEOUT),
	LIS_CONFIG_ENTRY(MaxDelayBetweenMULTIs, L"MaxDelayBetweenMULTIs", AA_DEF_MULTI_TIMEOUT),
	LIS_CONFIG_ENTRY(MulticastEntryAgingTimeout, L"MulticastEntryAgingTimeout", AA_DEF_MCAST_IP_ENTRY_AGING_TIMEOUT),
	LIS_CONFIG_ENTRY(MinRevalidationDelay, L"MinMulticastRevalidationDelay", AA_DEF_MIN_MCAST_REVALIDATION_DELAY),
	LIS_CONFIG_ENTRY(MaxRevalidationDelay, L"MaxMulticastRevalidationDelay", AA_DEF_MAX_MCAST_REVALIDATION_DELAY),
	LIS_CONFIG_ENTRY(MinPartyRetryDelay, L"MinMulticastPartyRetryDelay", AA_DEF_MIN_MCAST_PARTY_RETRY_DELAY),
	LIS_CONFIG_ENTRY(MaxPartyRetryDelay, L"MaxMulticastPartyRetryDelay", AA_DEF_MAX_MCAST_PARTY_RETRY_DELAY),
	LIS_CONFIG_ENTRY(MaxJoinOrLeaveAttempts, L"MaxJoinLeaveAttempts", AA_DEF_MAX_JOIN_LEAVE_ATTEMPTS)

#endif // IPMCAST
};


//
//  Size of above table.
//
#define LIS_CONFIG_ENTRIES	\
		sizeof(AtmArpLISConfigTable)/sizeof(AA_READ_CONFIG_PARAMS)


//
//  Names of LIS parameters and subkey names that don't appear
//  in the above table.
//

#define AA_LIS_IP_CONFIG_STRING					L"IPConfig"
#define AA_LIS_ATMARP_SERVER_LIST_KEY			L"ARPServerList"
#define AA_LIS_MARS_SERVER_LIST_KEY				L"MARServerList"
#define AA_LIS_ATMARP_SERVER_ADDRESS			L"AtmAddress"
#define AA_LIS_ATMARP_SERVER_SUBADDRESS			L"AtmSubaddress"

#define AA_LIS_STATIC_ARP_LIST					L"StaticArpList"

#ifdef DHCP_OVER_ATM
#define AA_LIS_DHCP_SERVER_ATM_ADDRESS			L"DhcpServerAtmAddress"
#endif // DHCP_OVER_ATM


#ifdef QOS_HEURISTICS

#define AA_LIS_FLOW_INFO_KEY					L"FlowInfo"
#define AA_LIS_FLOW_INFO_ENABLED				L"FlowInfoEnabled"

#define FLOW_CONFIG_ENTRY(Field, Name, Dflt)	\
		AA_MAKE_RCP(FIELD_OFFSET(struct _ATMARP_FLOW_INFO, Field), Name, Dflt)


AA_READ_CONFIG_PARAMS AtmArpFlowConfigTable[] =
{
	FLOW_CONFIG_ENTRY(PacketSizeLimit, L"PacketSizeLimit", AAF_DEF_LOWBW_SEND_THRESHOLD),
	FLOW_CONFIG_ENTRY(FlowSpec.SendPeakBandwidth, L"SendBandwidth", AAF_DEF_LOWBW_SEND_BANDWIDTH),
	FLOW_CONFIG_ENTRY(FlowSpec.ReceivePeakBandwidth, L"ReceiveBandwidth", AAF_DEF_LOWBW_RECV_BANDWIDTH),
	FLOW_CONFIG_ENTRY(FlowSpec.SendServiceType, L"ServiceType", AAF_DEF_LOWBW_SERVICETYPE),
	FLOW_CONFIG_ENTRY(FlowSpec.Encapsulation, L"Encapsulation", AAF_DEF_LOWBW_ENCAPSULATION),
	FLOW_CONFIG_ENTRY(FlowSpec.AgingTime, L"AgingTime", AAF_DEF_LOWBW_AGING_TIME),
};

#define AA_FLOW_INFO_ENTRIES		\
			(sizeof(AtmArpFlowConfigTable)/sizeof(AA_READ_CONFIG_PARAMS))


#endif // QOS_HEURISTICS



EXTERN
NDIS_STATUS
AtmArpCfgReadAdapterConfiguration(
	IN	PATMARP_ADAPTER				pAdapter
)
/*++

Routine Description:

	Reads the following adapter configuration information from the
	registry:
		* pAdapter->ConfigString (MultiSz list of LISs for this adapter).

Arguments:

	pAdapter				- Points to our adapter structure.

Return Value:

	NDIS Status code

--*/
{
	NDIS_HANDLE			ConfigHandle;
	NDIS_STATUS			Status;
	PNDIS_STRING		pConfigString = &pAdapter->ConfigString;

	NdisOpenProtocolConfiguration(
						&Status,
						&ConfigHandle,
						pConfigString
						);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		ConfigHandle = NULL;
	}
	else
	{
		//
		//  Read in the IPConfig string. If this is not present,
		//  fail this call.
		//
		NDIS_STRING						IPConfigName = NDIS_STRING_CONST("IPConfig");
		PNDIS_CONFIGURATION_PARAMETER	pParam;

		NdisReadConfiguration(
				&Status,
				&pParam,
				ConfigHandle,
				&IPConfigName,
				NdisParameterMultiString
				);

		if ((Status == NDIS_STATUS_SUCCESS) &&
			(pParam->ParameterType == NdisParameterMultiString))
		{
            NDIS_STRING *pSrcString   = &(pParam->ParameterData.StringData);
            NDIS_STRING *pDestString  = &(pAdapter->IPConfigString);
            PWSTR Buffer = NULL;
            
			AA_ALLOC_MEM(Buffer, WCHAR, pSrcString->Length*sizeof(*Buffer));

            if (Buffer == NULL)
            {
			    Status = NDIS_STATUS_RESOURCES;
            }
            else
            {
                AA_COPY_MEM(
                        Buffer,
                        pSrcString->Buffer,
                        pSrcString->Length
                        );
			    
                pDestString->Buffer = Buffer;
                pDestString->Length = pSrcString->Length;
                pDestString->MaximumLength = pSrcString->Length;
            }
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
		}

	}

	if (ConfigHandle != NULL)
	{
		NdisCloseConfiguration(ConfigHandle);
		ConfigHandle = NULL;
	}

	AADEBUGP(AAD_VERY_LOUD,
			 ("OpenAdapterConfig: pAdapter 0x%x, Status 0x%x\n",
					pAdapter, Status));

	return Status;
}




NDIS_HANDLE
AtmArpCfgOpenLISConfiguration(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	UINT						LISNumber
#ifdef NEWARP
	,
	OUT	PNDIS_STRING				pIPConfigString
#endif // NEWARP
)
/*++

Routine Description:

	Open and return a handle to the configuration section for the
	given LIS.

Arguments:

	pAdapter				- Points to our adapter context.
	LISNumber				- The zero-based index for the LIS.
	pIPConfigString			- Place where we return the IP Configuration
							  string for this interface.
Return Value:

	A valid handle if successful, NULL otherwise.

--*/
{
	NDIS_HANDLE				AdapterConfigHandle;
	NDIS_HANDLE				SubkeyHandle;
	NDIS_STATUS				Status;
	NDIS_STRING				KeyName;

#if DBG
	SubkeyHandle = NULL;
#endif // DBG

	do
	{
        NDIS_STRING			String;
        PWSTR				p;
		NDIS_HANDLE			InterfaceConfigHandle;
		NDIS_STRING			OurSectionName = ATMARP_NAME_STRING;
        ULONG				i;

        //
        //  Get the config string for the specified LIS.
        //
        for (i = 0, p = pAdapter->IPConfigString.Buffer;
             (*p != L'\0') && (i < LISNumber);
             i++)
        {
            NdisInitUnicodeString(&String, p);
            p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
        }

        if (*p == L'\0')
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        NdisInitUnicodeString(pIPConfigString, p);

		NdisOpenProtocolConfiguration(
						&Status,
						&InterfaceConfigHandle,
						pIPConfigString
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Get to our configuration section for this interface.
		//
		NdisOpenConfigurationKeyByName(
					&Status,
					InterfaceConfigHandle,
					&OurSectionName,
					&SubkeyHandle
					);

		//
		//  We don't need the main Interface section open anymore.
		//
		NdisCloseConfiguration(InterfaceConfigHandle);

		break;
	}
	while (FALSE);

	AADEBUGP(AAD_VERY_LOUD,
		("OpenLISConfiguration: LIS %d, Status 0x%x, subkey 0x%x\n",
			 LISNumber, Status, SubkeyHandle));


	if (Status == NDIS_STATUS_SUCCESS)
	{
		return (SubkeyHandle);
	}
	else
	{
		return (NULL);
	}
}


NDIS_HANDLE
AtmArpCfgOpenLISConfigurationByName(
	IN PATMARP_ADAPTER			pAdapter,
	IN PNDIS_STRING				pIPConfigString
)
/*++

Routine Description:

	Open and return a handle to the configuration section for the
	given LIS. Same functionality as AtmArpCfgOpenLISConfiguration, except
    that we look up the adapter based on the config string.

Arguments:

	pAdapter				- Points to our adapter context.
	pIPConfigString			- Specifies the configuration registry
							  key name.
Return Value:

	A valid handle if successful, NULL otherwise.

--*/
{
	NDIS_HANDLE				AdapterConfigHandle;
	NDIS_HANDLE				SubkeyHandle;
	NDIS_STATUS				Status;
	NDIS_STRING				KeyName;

#if DBG
	SubkeyHandle = NULL;
#endif // DBG

	do
	{
		NDIS_HANDLE			InterfaceConfigHandle;
		NDIS_STRING			OurSectionName = ATMARP_NAME_STRING;

		NdisOpenProtocolConfiguration(
						&Status,
						&InterfaceConfigHandle,
						pIPConfigString
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Get to our configuration section for this interface.
		//
		NdisOpenConfigurationKeyByName(
					&Status,
					InterfaceConfigHandle,
					&OurSectionName,
					&SubkeyHandle
					);

		//
		//  We don't need the main Interface section open anymore.
		//
		NdisCloseConfiguration(InterfaceConfigHandle);

		break;
	}
	while (FALSE);

	AADEBUGP(AAD_VERY_LOUD,
		("OpenLISConfigurationByName: Status 0x%x, subkey 0x%x\n",
			 Status, SubkeyHandle));

	if (Status == NDIS_STATUS_SUCCESS)
	{
		return (SubkeyHandle);
	}
	else
	{
		return (NULL);
	}
}



VOID
AtmArpCfgCloseLISConfiguration(
	NDIS_HANDLE						LISConfigHandle
)
/*++

Routine Description:

	Close a configuration handle for an LIS.

Arguments:

	LISConfigHandle			- Handle to the LIS configuration section.

Return Value:

	None

--*/
{
	NdisCloseConfiguration(LISConfigHandle);
}




NDIS_STATUS
AtmArpCfgReadLISConfiguration(
	IN	NDIS_HANDLE					LISConfigHandle,
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Get all configuration parameters for the specified LIS. We first
	fill in all configurable parameters with default values, and then
	overwrite them with values from the configuration database.

Arguments:

	LISComfigHandle		- the handle returned by AtmArpOpenLISConfiguration
	pInterface			- the ATMARP Interface structure for this LIS.

Return Value:

	NDIS_STATUS_SUCCESS if we were able to read in all config info.
	NDIS_STATUS_RESOURCES if we came across an allocation failure.
	NDIS_STATUS_FAILURE for any other kind of error.

--*/
{
	NDIS_STATUS				Status;
	PAA_READ_CONFIG_PARAMS	pParamEntry;
	ULONG					i;
	PATM_SAP				pAtmSap;
	PATM_ADDRESS			pAtmAddress;	// SAP address
	NDIS_STRING						ParameterName;
	PNDIS_CONFIGURATION_PARAMETER	pNdisConfigurationParameter;


	do
	{
		//
		//  Read in all the ULONGs first.
		//
		pParamEntry = AtmArpLISConfigTable;
		for (i = 0; i < LIS_CONFIG_ENTRIES; i++)
		{
			NdisInitUnicodeString(
							&ParameterName,
							pParamEntry->ParameterName
							);
			NdisReadConfiguration(
							&Status,
							&pNdisConfigurationParameter,
							LISConfigHandle,
							&ParameterName,
							NdisParameterInteger
							);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				//
				//  Error in accessing this parameter -- use the default.
				//
				*(ULONG *)((PUCHAR)pInterface + pParamEntry->StructOffset) =
 									pParamEntry->DefaultValue;
			}
			else
			{
				*(ULONG *)((PUCHAR)pInterface + pParamEntry->StructOffset) =
								pNdisConfigurationParameter->ParameterData.IntegerData;
			}

			pParamEntry++;
		}

		//
		//  Postprocessing. Sanity checks on some values.
		//  Round up some sizes to make them multiples of 4.
		//
		pInterface->ProtocolBufSize = ROUND_TO_8_BYTES(pInterface->ProtocolBufSize);
		pInterface->HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize = ROUND_UP(pInterface->HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize);
#ifdef IPMCAST
		pInterface->HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize = ROUND_UP(pInterface->HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize);
#endif // IPMCAST

		//
		//  More postprocessing: use the SAP Selector value to set up our
		//  "basic" listening SAP.
		//
		pInterface->SapList.pInterface = pInterface;
		pInterface->SapList.Flags = AA_SAP_REG_STATE_IDLE;
		pInterface->SapList.pInfo->SapType = SAP_TYPE_NSAP;
		pInterface->SapList.pInfo->SapLength = sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);
		pAtmSap = (PATM_SAP)(pInterface->SapList.pInfo->Sap);

		AA_COPY_MEM((PUCHAR)&(pAtmSap->Blli), &AtmArpDefaultBlli, sizeof(ATM_BLLI_IE));
		AA_COPY_MEM((PUCHAR)&(pAtmSap->Bhli), &AtmArpDefaultBhli, sizeof(ATM_BHLI_IE));

		pAtmSap->NumberOfAddresses = 1;

		pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
		pAtmAddress->AddressType = SAP_FIELD_ANY_AESA_REST;
		pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
		pAtmAddress->Address[ATM_ADDRESS_LENGTH-1] = (UCHAR)(pInterface->SapSelector);

		pInterface->NumberOfSaps = 1;

		//
		//  If the MTU wasn't specified, get it from the adapter.
		//
		if (pInterface->MTU == AA_MTU_UNSPECIFIED)
		{
			pInterface->MTU = pInterface->pAdapter->MaxPacketSize - AA_PKT_LLC_SNAP_HEADER_LENGTH;
		}
		else
		{
			//
			//  If the MTU value isn't within bounds, default to 9180 bytes.
			//
			if ((pInterface->MTU < 9180) || (pInterface->MTU > 65535 - 8))
			{
				pInterface->MTU = 9180;
			}
		}

		//
		//  If the I/F speed wasn't specified, get it from the adapter.
		//
		if (pInterface->Speed == AA_SPEED_UNSPECIFIED)
		{
			//
			//  Convert from bytes/sec to bits/sec
			//
			pInterface->Speed = (pInterface->pAdapter->LineRate.Outbound * 8);
		}
			
		//
		//  Set up default flow parameters, if not specified, from the values
		//  we got from the adapter.
		//
		if (pInterface->DefaultFlowSpec.SendPeakBandwidth == AA_BANDWIDTH_UNSPECIFIED)
		{
			pInterface->DefaultFlowSpec.SendPeakBandwidth = pInterface->pAdapter->LineRate.Outbound;
			pInterface->DefaultFlowSpec.SendAvgBandwidth = pInterface->pAdapter->LineRate.Outbound;
		}

		if (pInterface->DefaultFlowSpec.ReceivePeakBandwidth == AA_BANDWIDTH_UNSPECIFIED)
		{
			pInterface->DefaultFlowSpec.ReceivePeakBandwidth = pInterface->pAdapter->LineRate.Inbound;
			pInterface->DefaultFlowSpec.ReceiveAvgBandwidth = pInterface->pAdapter->LineRate.Inbound;
		}

		if (pInterface->DefaultFlowSpec.SendMaxSize == AA_PACKET_SIZE_UNSPECIFIED)
		{
			pInterface->DefaultFlowSpec.SendMaxSize = pInterface->MTU + AA_PKT_LLC_SNAP_HEADER_LENGTH;
		}

		if (pInterface->DefaultFlowSpec.ReceiveMaxSize == AA_PACKET_SIZE_UNSPECIFIED)
		{
			pInterface->DefaultFlowSpec.ReceiveMaxSize = pInterface->MTU + AA_PKT_LLC_SNAP_HEADER_LENGTH;
		}

		pInterface->DefaultFlowSpec.Encapsulation = AA_DEF_FLOWSPEC_ENCAPSULATION;
		pInterface->DefaultFlowSpec.SendServiceType =
		pInterface->DefaultFlowSpec.ReceiveServiceType = SERVICETYPE_BESTEFFORT;

#ifndef NEWARP

		//
		//  Get IP's ConfigName string for this interface.
		//
		NdisInitUnicodeString(&ParameterName, AA_LIS_IP_CONFIG_STRING);
		NdisReadConfiguration(
						&Status,
						&pNdisConfigurationParameter,
						LISConfigHandle,
						&ParameterName,
						NdisParameterString
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_ERROR,
					 ("Failed to read IP Config string, status 0x%x\n", Status));
			break;
		}

		//
		//  Copy the string into our IF structure.
		//
		pInterface->IPConfigString.Length = 
				pNdisConfigurationParameter->ParameterData.StringData.Length;

		AA_COPY_MEM(
				pInterface->IPConfigString.Buffer,
				pNdisConfigurationParameter->ParameterData.StringData.Buffer,
				pInterface->IPConfigString.Length);

#endif // !NEWARP

		//
		//  Get the list of ARP servers: go to the subkey containing the
		//  list.
		//
		if (!pInterface->PVCOnly)
		{
			AtmArpCfgReadAtmAddressList(
							&(pInterface->ArpServerList),
							AA_LIS_ATMARP_SERVER_LIST_KEY,
							LISConfigHandle
							);

			if (pInterface->ArpServerList.ListSize == 0)
			{
				//
				//  Assume PVC only environment.
				//
				pInterface->PVCOnly = TRUE;
				AADEBUGP(AAD_INFO, ("IF 0x%x set to PVC Only\n", pInterface));
			}

#ifdef IPMCAST
			if (!pInterface->PVCOnly)
			{
				AtmArpCfgReadAtmAddressList(
							&(pInterface->MARSList),
							AA_LIS_MARS_SERVER_LIST_KEY,
							LISConfigHandle
							);
			}
#endif // IPMCAST
		}

		//
		//  Get any additional SAPs we are configured with. It doesn't matter
		//  if none are configured.
		//
		(VOID) AtmArpCfgReadSAPList(
							pInterface,
							LISConfigHandle
							);

#ifdef DHCP_OVER_ATM
		//
		//  Get the ATM Address of the DHCP Server, if configured.
		//
		Status = AtmArpCfgReadAtmAddress(
							LISConfigHandle,
							&(pInterface->DhcpServerAddress),
							AA_LIS_DHCP_SERVER_ATM_ADDRESS
							);

		if (Status == NDIS_STATUS_SUCCESS)
		{
			pInterface->DhcpEnabled = TRUE;
		}
#endif // DHCP_OVER_ATM

#ifdef QOS_HEURISTICS
		//
		//  Read in QOS Heuristics, if present.
		//
		Status = AtmArpCfgReadQosHeuristics(
							LISConfigHandle,
							pInterface
							);
#endif // QOS_HEURISTICS


		//
		//  Read in static IP-ATM entries, if present.
		//
		AtmArpCfgReadStaticArpEntries(
							LISConfigHandle,
							pInterface
							);

		Status = NDIS_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	return (Status);
}



VOID
AtmArpCfgReadAtmAddressList(
	IN OUT	PATMARP_SERVER_LIST		pServerList,
	IN		PWCHAR					pListKeyName,
	IN		NDIS_HANDLE				LISConfigHandle
)
/*++

Routine Description:

	Read in a Server list for an LIS from the configuration database.

	Notes:

	In the first implementation, we had subkeys for everything. The
	layout was:
		ARPServerList\Server1\AtmAddress - REG_SZ
		ARPServerList\Server2\AtmAddress - REG_SZ
	and so on.

	To simplify, we are changing this to:
		ARPServerList - REG_MULTI_SZ, containing multiple
	    ATM Address strings.

Arguments:

	pServerList			- The list to be read into.
	pListKeyName		- Name of key under which the list is present.
	LISConfigHandle		- Handle to LIS configuration key.

Return Value:

	None.
	SIDE EFFECT: *pServerList is updated.

--*/
{
	NDIS_HANDLE				SubkeyHandle;	// Handle for Server list subkey
	NDIS_HANDLE				ServerEntryKeyHandle;
	NDIS_STATUS				Status;
	PATMARP_SERVER_ENTRY	pServerEntry;
	PATMARP_SERVER_ENTRY *	ppNext;			// Used for linking entries.
	NDIS_STRING				SubkeyName;
	INT						ReadCount;

	//
	//  Try the simplified (see Routine Description above) way first.
	//  Just open the given key name as a REG_MULTI_SZ.
	//
	do
	{
		PNDIS_CONFIGURATION_PARAMETER	pParam;
		NDIS_STRING						AddressListName;
		NDIS_STRING						AddressString;
		PWSTR							p;
		INT								i;

		ReadCount = 0;	// How many did we read here?

		//
		//  Read all server addresses configured. Stop only when there are
		//  no more addresses, or we have a resource failure.
		//
		//  First, go to the end of the existing list.
		//
		ppNext = &(pServerList->pList);
		while (*ppNext != NULL_PATMARP_SERVER_ENTRY)
		{
			ppNext = &((*ppNext)->pNext);
		}

		NdisInitUnicodeString(&AddressListName, pListKeyName);

		NdisReadConfiguration(
				&Status,
				&pParam,
				LISConfigHandle,
				&AddressListName,
				NdisParameterMultiString
				);

		if ((Status != NDIS_STATUS_SUCCESS) ||
			(pParam->ParameterType != NdisParameterMultiString))
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Go through the MULTI-string, each of which should be
		//  an ATM address. Allocate a server entry for each and
		//  link it to the list of servers.
		//
		for (p = pParam->ParameterData.StringData.Buffer, i = 0;
			 *p != L'\0';
			 i++)
		{
			NdisInitUnicodeString(&AddressString, p);
			p = (PWSTR)((PUCHAR)p + AddressString.Length + sizeof(WCHAR));

			AA_ALLOC_MEM(pServerEntry, ATMARP_SERVER_ENTRY, sizeof(ATMARP_SERVER_ENTRY));
			if (pServerEntry == NULL_PATMARP_SERVER_ENTRY)
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			AA_SET_MEM(pServerEntry, 0, sizeof(ATMARP_SERVER_ENTRY));

			NdisConvertStringToAtmAddress(
					&Status,
					&AddressString,
					&pServerEntry->ATMAddress
					);

			if (Status == NDIS_STATUS_SUCCESS)
			{
				//
				//  Link this entry to the list of ARP Server entries.
				//
				*ppNext = pServerEntry;
				ppNext = &(pServerEntry->pNext);

				pServerList->ListSize++;
				ReadCount++;
			}
			else
			{
				AA_FREE_MEM(pServerEntry);
			}

		}

		//
		//  Fix up the status so we know what to do next.
		//
		if (ReadCount != 0)
		{
			//
			//  Successfully read in atleast one.
			//
			Status = NDIS_STATUS_SUCCESS;
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
		}

		break;
	}
	while (FALSE);

	if (ReadCount != 0)
	{
		return;
	}

	//
	//  For backward compatibility, try the older method.
	//

	do
	{
		NdisInitUnicodeString(&SubkeyName, pListKeyName);
		NdisOpenConfigurationKeyByName(
					&Status,
					LISConfigHandle,
					&SubkeyName,
					&SubkeyHandle
					);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Read all server addresses configured. Stop only when there are
		//  no more addresses, or we have a resource failure.
		//
		//  First, go to the end of the existing list.
		//
		ppNext = &(pServerList->pList);
		while (*ppNext != NULL_PATMARP_SERVER_ENTRY)
		{
			ppNext = &((*ppNext)->pNext);
		}

		for (;;)
		{
			NdisOpenConfigurationKeyByIndex(
						&Status,
						SubkeyHandle,
						pServerList->ListSize,
						&SubkeyName,
						&ServerEntryKeyHandle
						);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				break;
			}

			AA_ALLOC_MEM(pServerEntry, ATMARP_SERVER_ENTRY, sizeof(ATMARP_SERVER_ENTRY));
			if (pServerEntry == NULL_PATMARP_SERVER_ENTRY)
			{
				NdisCloseConfiguration(ServerEntryKeyHandle);
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			AA_SET_MEM(pServerEntry, 0, sizeof(ATMARP_SERVER_ENTRY));
			Status = AtmArpCfgReadAtmAddress(
							ServerEntryKeyHandle,
							&(pServerEntry->ATMAddress),
							AA_LIS_ATMARP_SERVER_ADDRESS
							);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_ERROR,
					("ReadAtmAddressList: bad status 0x%x reading server entry %d\n",
						Status,
						pServerList->ListSize));

				NdisCloseConfiguration(ServerEntryKeyHandle);
				AA_FREE_MEM(pServerEntry);
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			Status = AtmArpCfgReadAtmAddress(
							ServerEntryKeyHandle,
							&(pServerEntry->ATMSubaddress),
							AA_LIS_ATMARP_SERVER_SUBADDRESS
							);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_ERROR,
					("ReadAtmAddressList: bad status 0x%x reading server entry %d\n",
						Status,
						pServerList->ListSize));

				NdisCloseConfiguration(ServerEntryKeyHandle);
				AA_FREE_MEM(pServerEntry);
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			//
			//  Link this entry to the list of ARP Server entries.
			//
			*ppNext = pServerEntry;
			ppNext = &(pServerEntry->pNext);

			pServerList->ListSize++;

			NdisCloseConfiguration(ServerEntryKeyHandle);
		}

		NdisCloseConfiguration(SubkeyHandle);

		break;
	}
	while (FALSE);

	return;
}



NDIS_STATUS
AtmArpCfgReadSAPList(
	IN	PATMARP_INTERFACE			pInterface,
	IN	NDIS_HANDLE					LISConfigHandle
)
/*++

Routine Description:

	Read in any additional SAPs we are configured to listen on. These are
	used to support additional services over the IP/ATM client, that may be
	accessible via SAP information that is different from the "basic" SAP
	we register on an interface. For example, "well-known" address.

Arguments:

	pInterface			- Pointer to ATMARP Interface structure for this LIS
	LISConfigHandle		- Handle to LIS configuration key.

Return Value:

	For now, NDIS_STATUS_SUCCESS always.

--*/
{
	NDIS_STATUS				Status;

	Status = NDIS_STATUS_SUCCESS;

	// TBD -- code AtmArpCfgReadSAPList
	return (Status);
}



//
//  Special characters in ATM address string stored in config database.
//
#define BLANK_CHAR			L' '
#define PUNCTUATION_CHAR	L'.'
#define E164_START_CHAR		L'+'


NDIS_STATUS
AtmArpCfgReadAtmAddress(
	IN	NDIS_HANDLE					ConfigHandle,
	IN	PATM_ADDRESS				pAtmAddress,
	IN	PWCHAR						pValueName
)
/*++

Routine Description:

	Read in an ATM Address from the configuration database.

Arguments:

	ConfigHandle				- Handle returned by NdisOpenProtoXXX
	pAtmAddress					- where to read in the ATM address
	pValueName					- Pointer to name of value key.

Return Value:

	NDIS_STATUS_SUCCESS if the value was read in successfully
	NDIS_STATUS_FILE_NOT_FOUND if the value was not found
	NDIS_STATUS_FAILURE on any other kind of failure

--*/
{

	NDIS_STRING						ParameterName;
	PNDIS_CONFIGURATION_PARAMETER	pNdisConfigurationParameter;
	NDIS_STATUS						Status;

	NdisInitUnicodeString(&ParameterName, pValueName);

	NdisReadConfiguration(
					&Status,
					&pNdisConfigurationParameter,
					ConfigHandle,
					&ParameterName,
					NdisParameterString
					);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		NdisConvertStringToAtmAddress(
					&Status,
					&(pNdisConfigurationParameter->ParameterData.StringData),
					pAtmAddress
					);
	}

	return (Status);
}



#ifdef QOS_HEURISTICS
NDIS_STATUS
AtmArpCfgReadQosHeuristics(
	IN	NDIS_HANDLE					LISConfigHandle,
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Read in QoS heuristics configured for this interface. If we do find
	these parameters configured, we turn on heuristics by setting the
	packet classification handlers in the Interface structure. If nothing
	is configured, the packet classification routines are NULLed out, and
	all data is "best effort".

Arguments:

	LISConfigHandle				- Handle returned by NdisOpenProtoXXX
	pInterface					- Interface being configured.

Return Value:

	NDIS_STATUS always, as of now.

--*/
{
	NDIS_STATUS				Status;
	NDIS_STRING				SubkeyName;
	NDIS_STRING				ParameterName;
	NDIS_HANDLE				FlowInfoHandle;		// "FlowInfo" under LIS
	NDIS_HANDLE				FlowHandle;			// For each Flow under "FlowInfo"
	INT						NumFlowsConfigured;
	PATMARP_FLOW_INFO		pFlowInfo;
	PATMARP_FLOW_INFO		*ppNextFlow;
	PAA_READ_CONFIG_PARAMS	pParamEntry;
	INT						i;

	PNDIS_CONFIGURATION_PARAMETER	pNdisConfigurationParameter;

	NumFlowsConfigured = 0;

	do
	{
		//
		//  Check if QoS heuristics are enabled.
		//
		NdisInitUnicodeString(
						&ParameterName,
						AA_LIS_FLOW_INFO_ENABLED
						);

		NdisReadConfiguration(
						&Status,
						&pNdisConfigurationParameter,
						LISConfigHandle,
						&ParameterName,
						NdisParameterInteger
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_INFO, ("IF 0x%x: could not read %ws\n",
						pInterface, AA_LIS_FLOW_INFO_ENABLED));
			break;
		}

		if (pNdisConfigurationParameter->ParameterData.IntegerData == 0)
		{
			AADEBUGP(AAD_INFO, ("IF 0x%x: Flow Info disabled\n", pInterface));
			break;
		}

		NdisInitUnicodeString(&SubkeyName, AA_LIS_FLOW_INFO_KEY);
		NdisOpenConfigurationKeyByName(
					&Status,
					LISConfigHandle,
					&SubkeyName,
					&FlowInfoHandle
					);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_INFO, ("IF 0x%x: No flows configured\n", pInterface));
			break;
		}

		//
		//  Read in all flows configured. Stop when there are no more
		//  configured flows, or we run out of memory.
		//
		for (;;)
		{
			//
			//  Open the next key under the Flow Info section.
			//
			AA_SET_MEM(&SubkeyName, 0, sizeof(SubkeyName));
			NdisOpenConfigurationKeyByIndex(
					&Status,
					FlowInfoHandle,
					NumFlowsConfigured,
					&SubkeyName,
					&FlowHandle
					);
	
			if (Status != NDIS_STATUS_SUCCESS)
			{
				break;
			}

			AA_ALLOC_MEM(pFlowInfo, ATMARP_FLOW_INFO, sizeof(ATMARP_FLOW_INFO));
			if (pFlowInfo == (PATMARP_FLOW_INFO)NULL)
			{
				NdisCloseConfiguration(FlowHandle);
				break;
			}

			//
			//  Initialize with defaults.
			//
			AA_COPY_MEM(pFlowInfo, &AtmArpDefaultFlowInfo, sizeof(ATMARP_FLOW_INFO));
			pFlowInfo->FlowSpec.SendMaxSize =
			pFlowInfo->FlowSpec.ReceiveMaxSize = pInterface->pAdapter->MaxPacketSize;

			//
			//  Read in configured values.
			//
			pParamEntry = AtmArpFlowConfigTable;
			for (i = 0; i < AA_FLOW_INFO_ENTRIES; i++)
			{
				NdisInitUnicodeString(
								&ParameterName,
								pParamEntry->ParameterName
								);
				NdisReadConfiguration(
								&Status,
								&pNdisConfigurationParameter,
								FlowHandle,
								&ParameterName,
								NdisParameterInteger
								);
	
				if (Status != NDIS_STATUS_SUCCESS)
				{
					//
					//  Error in accessing this parameter -- use the default.
					//
					*(ULONG *)((PUCHAR)pFlowInfo + pParamEntry->StructOffset) =
										pParamEntry->DefaultValue;
				}
				else
				{
					*(ULONG *)((PUCHAR)pFlowInfo + pParamEntry->StructOffset) =
									pNdisConfigurationParameter->ParameterData.IntegerData;
					AADEBUGP(AAD_LOUD,
						("Flow Info #%d: %ws = %d\n",
								NumFlowsConfigured,
								pParamEntry->ParameterName,
								pNdisConfigurationParameter->ParameterData.IntegerData));
				}
	
				pParamEntry++;
			}

			NdisCloseConfiguration(FlowHandle);

			//
			//  Link this in the appropriate point in the list of flows.
			//  We keep the list sorted in ascending order of PacketSizeLimit.
			//
			ppNextFlow = &(pInterface->pFlowInfoList);
			while (*ppNextFlow != (PATMARP_FLOW_INFO)NULL)
			{
				if (pFlowInfo->PacketSizeLimit < (*ppNextFlow)->PacketSizeLimit)
				{
					//
					//  Found the place.
					//
					break;
				}
				else
				{
					ppNextFlow = &((*ppNextFlow)->pNextFlow);
				}
			}
			//
			//  Insert the new Flow at its designated place.
			//
			pFlowInfo->pNextFlow = *ppNextFlow;
			*ppNextFlow = pFlowInfo;

			NumFlowsConfigured ++;
		}

		NdisCloseConfiguration(FlowInfoHandle);
	}
	while (FALSE);

#ifdef GPC
	if (pAtmArpGlobalInfo->GpcClientHandle != NULL)
#else
	if (NumFlowsConfigured > 0)
#endif // GPC
	{
		//
		//  Set the packet classification handlers.
		//
		pInterface->pGetPacketSpecFunc = AtmArpQosGetPacketSpecs;
		pInterface->pFlowMatchFunc = AtmArpQosDoFlowsMatch;
#ifndef GPC
		//
		//  We don't want to look at patterns within the packet.
		//  Let the GPC do it for us.
		//
		pInterface->pFilterMatchFunc = AtmArpQosDoFiltersMatch;
#endif // GPC
	}

	return (NDIS_STATUS_SUCCESS);
}


#endif // QOS_HEURISTICS


VOID
AtmArpCfgReadStaticArpEntries(
	IN		NDIS_HANDLE				LISConfigHandle,
	IN		PATMARP_INTERFACE		pInterface
)
/*++

Routine Description:

	Read in a list of IP-ATM mappings for this interface.

	This information is in a Multi-string in the following format:

	"<IPaddress1>-<ATMaddress1>
	 <IPaddress2>-<ATMaddress2>
	 ...."
	
	NOTE: we don't support subaddress for now.

Arguments:

	LISConfigHandle		- Handle to LIS configuration key.
	pInterface			- Pointer to interface

Return Value:

	None.

--*/
{
	NDIS_STATUS						Status;
	PNDIS_CONFIGURATION_PARAMETER	pParam;
	NDIS_STRING						ArpListKeyName;
	NDIS_STRING						AddressString;
	ATM_ADDRESS						ATMAddress;
	IP_ADDRESS						IPAddress;
	PWSTR							p, q;
	INT								i, j;

	do
	{
		NdisInitUnicodeString(&ArpListKeyName, AA_LIS_STATIC_ARP_LIST);

		NdisReadConfiguration(
				&Status,
				&pParam,
				LISConfigHandle,
				&ArpListKeyName,
				NdisParameterMultiString
				);

		if ((Status != NDIS_STATUS_SUCCESS) ||
			(pParam->ParameterType != NdisParameterMultiString))
		{
			break;
		}

		//
		//  Go through the MULTI-string, each of which should be
		//  an <IP, ATM> tuple. Create a static mapping for each
		//  one successfully read in. Skip invalid entries.
		//
		for (p = pParam->ParameterData.StringData.Buffer, i = 0;
			 *p != L'\0';
			 i++)
		{
			NdisInitUnicodeString(&AddressString, p);

			q = p;

			//
			//  Prepare early for the next iteration in case we
			//  skip this entry and continue on.
			//
			p = (PWSTR)((PUCHAR)p + AddressString.Length + sizeof(WCHAR));

			//
			//  Find the '-' and replace it with a NULL char.
			//
			for (j = 0; j < AddressString.Length; j++, q++)
			{
				if (*q == L'-')
				{
					*q++ = L'\0';

					//
					//  q now points to the character following the hyphen.
					//

					break;
				}
			}

			if (j == AddressString.Length)
			{
				AADEBUGP(AAD_WARNING, ("CfgReadStatic..: did not find - in string: %ws\n",
								AddressString.Buffer));
				continue;
			}

			//
			//  Parse the IP address first.
			//
			if (!AtmArpConvertStringToIPAddress(
					AddressString.Buffer,
					&IPAddress))
			{
				AADEBUGP(AAD_WARNING, ("CfgReadStatic..: bad IP addr string: %ws\n",
											AddressString.Buffer));
				continue;
			}

			//
			//  Convert to net-endian for the call to AtmArpLearnIPToAtm.
			//
			IPAddress = HOST_TO_NET_LONG(IPAddress);

			//
			//  Now parse the ATM Address.
			//
			NdisInitUnicodeString(&AddressString, q);

			NdisConvertStringToAtmAddress(
				&Status,
				&AddressString,
				&ATMAddress
				);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_WARNING, ("CfgReadStatic...: Status %x, bad ATM addr string(%d): %ws\n",
											Status, AddressString.Length, AddressString.Buffer));
				continue;
			}

			//
			//  Got a pair - enter them in the ARP table.
			//
			AADEBUGPMAP(AAD_VERY_LOUD,
				"Static", &IPAddress, &ATMAddress);

			(VOID)AtmArpLearnIPToAtm(
						pInterface,
						&IPAddress,
						(UCHAR)AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&ATMAddress),
						(PUCHAR)&ATMAddress.Address[0],
						(UCHAR)0,	// no subaddress
						(PUCHAR)NULL,
						TRUE	// Static Entry
						);

		}
	}
	while (FALSE);

	return;

}



#define	IP_ADDRESS_STRING_LENGTH	(16+2)	// +2 for double NULL on MULTI_SZ

BOOLEAN
AtmArpConvertStringToIPAddress(
    IN		PWCHAR				AddressString,
	OUT		PULONG				IpAddress
)
/*++

Routine Description

    This function converts an Internet standard 4-octet dotted decimal
	IP address string into a numeric IP address. Unlike inet_addr(), this
	routine does not support address strings of less than 4 octets nor does
	it support octal and hexadecimal octets.

	Copied from tcpip\ip\ntip.c

Arguments

    AddressString    - IP address in dotted decimal notation
	IpAddress        - Pointer to a variable to hold the resulting address

Return Value:

	TRUE if the address string was converted. FALSE otherwise.

--*/
{
    UNICODE_STRING  unicodeString;
	STRING          aString;
	UCHAR           dataBuffer[IP_ADDRESS_STRING_LENGTH];
	NTSTATUS        status;
	PUCHAR          addressPtr, cp, startPointer, endPointer;
	ULONG           digit, multiplier;
	INT             i;

    aString.Length = 0;
	aString.MaximumLength = IP_ADDRESS_STRING_LENGTH;
	aString.Buffer = dataBuffer;

	NdisInitUnicodeString(&unicodeString, AddressString);

	status = NdisUnicodeStringToAnsiString(
	             &aString,
				 &unicodeString
				 );

    if (status != NDIS_STATUS_SUCCESS)
    {
	    return(FALSE);
	}

    *IpAddress = 0;
	addressPtr = (PUCHAR) IpAddress;
	startPointer = dataBuffer;
	endPointer = dataBuffer;
	i = 3;

    while (i >= 0)
	{
        //
		// Collect the characters up to a '.' or the end of the string.
		//
		while ((*endPointer != '.') && (*endPointer != '\0')) {
			endPointer++;
		}

		if (startPointer == endPointer) {
			return(FALSE);
		}

		//
		// Convert the number.
		//

        for ( cp = (endPointer - 1), multiplier = 1, digit = 0;
			  cp >= startPointer;
			  cp--, multiplier *= 10
			) {

			if ((*cp < '0') || (*cp > '9') || (multiplier > 100)) {
				return(FALSE);
			}

			digit += (multiplier * ((ULONG) (*cp - '0')));
		}

		if (digit > 255) {
			return(FALSE);
		}

        addressPtr[i] = (UCHAR) digit;

		//
		// We are finished if we have found and converted 4 octets and have
		// no other characters left in the string.
		//
	    if ( (i-- == 0) &&
			 ((*endPointer == '\0') || (*endPointer == ' '))
		   ) {
			return(TRUE);
		}

        if (*endPointer == '\0') {
			return(FALSE);
		}

		startPointer = ++endPointer;
	}

	return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\arppkt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arppkt.c	- ATMARP Packet Routines.

Abstract:

	Routines that build and parse ARP packets.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-29-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'TKPA'


VOID
AtmArpSendPacketOnVc(
	IN	PATMARP_VC					pVc		LOCKIN	NOLOCKOUT,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Send a packet on the specified VC. Apart from calling NDIS to do
	the job, we refresh the aging timer on this VC.

Arguments:

	pVc					- Pointer to ATMARP VC
	pNdisPacket			- Pointer to packet to be sent.

Return Value:

	None

--*/
{
	NDIS_HANDLE			NdisVcHandle;

	if (AA_IS_FLAG_SET(
				pVc->Flags,
				AA_VC_CALL_STATE_MASK,
				AA_VC_CALL_STATE_ACTIVE) &&
		!AA_IS_VC_GOING_DOWN(pVc))
	{
		//
		//  A call is active on this VC, so send the packet.
		//
		AtmArpRefreshTimer(&(pVc->Timer));
		NdisVcHandle = pVc->NdisVcHandle;

#ifdef VC_REFS_ON_SENDS
		AtmArpReferenceVc(pVc);	// SendPacketOnVc
#endif // VC_REFS_ON_SENDS

		pVc->OutstandingSends++;	// SendPacketOnVc

		AA_RELEASE_VC_LOCK(pVc);

		AADEBUGP(AAD_EXTRA_LOUD+50,
			("SendPacketOnVc: pVc 0x%x, Pkt 0x%x, VcHandle 0x%x\n",
					pVc, pNdisPacket, NdisVcHandle));

#ifdef PERF
		AadLogSendUpdate(pNdisPacket);
#endif // PERF
		NDIS_CO_SEND_PACKETS(
				NdisVcHandle,
				&pNdisPacket,
				1
				);
	}
	else
	{
		if (!AA_IS_VC_GOING_DOWN(pVc))
		{
			//
			//  Call must be in progress. Queue this packet; it will
			//  be sent as soon as the call is fully set up.
			//
			AtmArpQueuePacketOnVc(pVc, pNdisPacket);
			AA_RELEASE_VC_LOCK(pVc);
		}
		else
		{
			//
			//  This VC is going down. Complete the send with a failure.
			//
#ifdef VC_REFS_ON_SENDS
			AtmArpReferenceVc(pVc);	// SendPacketOnVc2
#endif // VC_REFS_ON_SENDS

			pVc->OutstandingSends++;	// SendPacketOnVc - failure completion

			AA_RELEASE_VC_LOCK(pVc);

#if DBG
#if DBG_CO_SEND
			{
				PULONG		pContext;
				pContext = (PULONG)&(pNdisPacket->WrapperReserved[0]);;
				*pContext = 'AaAa';
			}
#endif
#endif
			AtmArpCoSendCompleteHandler(
					NDIS_STATUS_FAILURE,
					(NDIS_HANDLE)pVc,
					pNdisPacket
					);
		}
	}
	return;
}




PNDIS_PACKET
AtmArpBuildARPPacket(
	IN	USHORT						OperationType,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR *					ppArpPacket,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Build a generic ARP packet with the given attributes.

Arguments:

	OperationType					- Op type (e.g. ARP Request, ARP Reply)
	pInterface						- Pointer to ATMARP Interface
	ppArpPacket						- Pointer to place to return start of packet
	pArpContents					- Pointer to structure describing contents

Return Value:

	Pointer to NDIS packet if successful, NULL otherwise. If successful,
	we also set *ppArpPacket to point to the first byte in the constructed
	ARP packet.

--*/
{
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					BufferLength;	// Length of ARP packet
	ULONG					Length;			// Temp length
	PUCHAR					pPkt;			// Start of allocated packet
	PUCHAR					pBuf;			// Used to walk the packet
	PAA_ARP_PKT_HEADER		pArpHeader;		// ARP packet header

	//
	//  Calculate the length of what we're about to build
	//
	BufferLength = AA_ARP_PKT_HEADER_LENGTH +
					(pArpContents->SrcAtmNumberTypeLen & ~AA_PKT_ATM_ADDRESS_BIT) +
					(pArpContents->SrcAtmSubaddrTypeLen & ~AA_PKT_ATM_ADDRESS_BIT) +
					(pArpContents->DstAtmNumberTypeLen & ~AA_PKT_ATM_ADDRESS_BIT) +
					(pArpContents->DstAtmSubaddrTypeLen & ~AA_PKT_ATM_ADDRESS_BIT) +
					0;

	if (pArpContents->pSrcIPAddress != (PUCHAR)NULL)
	{
		BufferLength += AA_IPV4_ADDRESS_LENGTH;
	}

	if (pArpContents->pDstIPAddress != (PUCHAR)NULL)
	{
		BufferLength += AA_IPV4_ADDRESS_LENGTH;
	}

	pNdisPacket = AtmArpAllocatePacket(pInterface);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		pNdisBuffer = AtmArpAllocateProtoBuffer(
									pInterface,
									BufferLength,
									&(pPkt)
									);

		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			//
			//  Return value:
			//
			*ppArpPacket = pPkt;

			//
			//  Initialize packet with all 0's
			//
			AA_SET_MEM(pPkt, 0, BufferLength);

			pArpHeader = (PAA_ARP_PKT_HEADER)pPkt;

			//
			//  Fixed-location fields:
			//
			pArpHeader->LLCSNAPHeader = AtmArpLlcSnapHeader;
			pArpHeader->LLCSNAPHeader.EtherType = NET_SHORT(AA_PKT_ETHERTYPE_ARP);
			pArpHeader->hrd = NET_SHORT(AA_PKT_ATM_FORUM_AF);
			pArpHeader->pro = NET_SHORT(AA_PKT_PRO_IP);
			pArpHeader->op  = NET_SHORT(OperationType);

			//
			//  Now fill in the variable length fields
			//
			pBuf = pArpHeader->Variable;

			//
			//  Source ATM Number
			//
			Length = (pArpContents->SrcAtmNumberTypeLen & ~AA_PKT_ATM_ADDRESS_BIT);
			if (Length > 0)
			{
				pArpHeader->shtl = pArpContents->SrcAtmNumberTypeLen;
				AA_COPY_MEM(pBuf, pArpContents->pSrcAtmNumber, Length);
				pBuf += Length;
			}

			//
			//  Source ATM subaddress
			//
			Length = (pArpContents->SrcAtmSubaddrTypeLen & ~AA_PKT_ATM_ADDRESS_BIT);
			if (Length > 0)
			{
				pArpHeader->shtl = pArpContents->SrcAtmSubaddrTypeLen;
				AA_COPY_MEM(pBuf, pArpContents->pSrcAtmSubaddress, Length);
				pBuf += Length;
			}

			//
			//  Source Protocol (IP) address
			//
			if (pArpContents->pSrcIPAddress != (PUCHAR)NULL)
			{
				pArpHeader->spln = AA_IPV4_ADDRESS_LENGTH;
				AA_COPY_MEM(pBuf, pArpContents->pSrcIPAddress, AA_IPV4_ADDRESS_LENGTH);

				pBuf += AA_IPV4_ADDRESS_LENGTH;
			}

			//
			//  Target ATM Number
			//
			Length = (pArpContents->DstAtmNumberTypeLen & ~AA_PKT_ATM_ADDRESS_BIT);
			if (Length > 0)
			{
				pArpHeader->thtl = pArpContents->DstAtmNumberTypeLen;
				AA_COPY_MEM(pBuf, pArpContents->pDstAtmNumber, Length);
				pBuf += Length;
			}

			//
			//  Target ATM subaddress
			//
			Length = (pArpContents->DstAtmSubaddrTypeLen & ~AA_PKT_ATM_ADDRESS_BIT);
			if (Length > 0)
			{
				pArpHeader->thtl = pArpContents->DstAtmSubaddrTypeLen;
				AA_COPY_MEM(pBuf, pArpContents->pDstAtmSubaddress, Length);
				pBuf += Length;
			}

			//
			//  Target Protocol (IP) address
			//
			if (pArpContents->pDstIPAddress != (PUCHAR)NULL)
			{
				pArpHeader->tpln = AA_IPV4_ADDRESS_LENGTH;
				AA_COPY_MEM(pBuf, pArpContents->pDstIPAddress, AA_IPV4_ADDRESS_LENGTH);

				pBuf += AA_IPV4_ADDRESS_LENGTH;
			}

			NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
		}
		else
		{
			AtmArpFreePacket(pInterface, pNdisPacket);
			pNdisPacket = (PNDIS_PACKET)NULL;
		}
	}

	AADEBUGP(AAD_EXTRA_LOUD, ("BldArpPkt: pIf 0x%x, Op %d, NdisPkt 0x%x, NdisBuf 0x%x\n",
				pInterface, OperationType, pNdisPacket, pNdisBuffer));

	return (pNdisPacket);
}





VOID
AtmArpSendARPRequest(
	PATMARP_INTERFACE				pInterface,
	IP_ADDRESS UNALIGNED *			pSrcIPAddress,
	IP_ADDRESS UNALIGNED *			pDstIPAddress
)
/*++

Routine Description:

	Send an ARP Request to the server, for the given interface.

	Preconditions: the ATM interface is UP, and the AdminState
	for the interface is IF_STATUS_UP.

	We first build an ARP Request with the given parameters. Then,
	if a Best Effort VC to the server's ATM address exists, the packet
	is sent on this. Other possibilities:
		- the Best Effort VC to the server is being set up: queue it
  		  on the VC
		- No Best Effort VC to the server exists: Create a new VC on this
  		  ATM Entry, make a call with Best Effort flow specs, and queue
  		  the request on this VC.
	
Arguments:

	pInterface				- Pointer to ATMARP Interface structure
	pSrcIPAddress			- Pointer to Source IP Address
	pDstIPAddress			- Pointer to Destination IP Address (to be
							  resolved)

Return Value:

	None

--*/
{
	PATMARP_ATM_ENTRY		pAtmEntry;	// Entry for the server's ATM address
	PATMARP_VC				pVc;		// VC to the server
	PNDIS_PACKET			pNdisPacket;
	PATMARP_FLOW_SPEC		pFlowSpec;
	PUCHAR                  pArpPacket;	// Pointer to ARP packet being constructed

	AA_ARP_PKT_CONTENTS		ArpContents;// Describes the packet we want to build

	NDIS_STATUS				Status;

	AADEBUGP(AAD_INFO,
				("Sending ARP Request on IF 0x%x for IP Addr: %d.%d.%d.%d\n",
					pInterface,
					((PUCHAR)pDstIPAddress)[0],
					((PUCHAR)pDstIPAddress)[1],
					((PUCHAR)pDstIPAddress)[2],
					((PUCHAR)pDstIPAddress)[3]
				));

	AA_ASSERT(pInterface->pCurrentServer != NULL_PATMARP_SERVER_ENTRY);
	AA_ASSERT(pInterface->pCurrentServer->pAtmEntry != NULL_PATMARP_ATM_ENTRY);

	//
	//  Prepare the ARP packet contents structure
	//
	AA_SET_MEM((PUCHAR)&ArpContents, 0, sizeof(AA_ARP_PKT_CONTENTS));
	
	//
	//  Source ATM Number
	//
	ArpContents.pSrcAtmNumber = pInterface->LocalAtmAddress.Address;
	ArpContents.SrcAtmNumberTypeLen =
			AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));

	//
	//  Source IP Address
	//
	ArpContents.pSrcIPAddress = (PUCHAR)pSrcIPAddress;

	//
	//  Target IP Address
	//
	ArpContents.pDstIPAddress = (PUCHAR)pDstIPAddress;

	//
	//  Build the ARP Request
	//
	pNdisPacket = AtmArpBuildARPPacket(
							AA_PKT_OP_TYPE_ARP_REQUEST,
							pInterface,
							&pArpPacket,
							&ArpContents
							);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Find the ATM Entry for the in-use ATMARP Server:
		//
		AA_ACQUIRE_IF_LOCK(pInterface);
		pAtmEntry = pInterface->pCurrentServer->pAtmEntry;
		AA_RELEASE_IF_LOCK(pInterface);

		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		//
		//  Get at the Best Effort VC going to this ATM address:
		//
		pVc = pAtmEntry->pBestEffortVc;

		if (pVc != NULL_PATMARP_VC)
		{
			ULONG		rc;

			AA_ACQUIRE_VC_LOCK_DPC(pVc);
			AtmArpReferenceVc(pVc);		// temp ref
			AA_RELEASE_VC_LOCK_DPC(pVc);

			AA_RELEASE_AE_LOCK(pAtmEntry);	// Not needed anymore

			//
			//  A VC to the server exists; send this packet on the VC
			//
			AA_ACQUIRE_VC_LOCK(pVc);

			rc = AtmArpDereferenceVc(pVc);	// temp ref

			if (rc != 0)
			{
				AtmArpSendPacketOnVc(pVc, pNdisPacket);
				//
				//  The VC lock is released in SendPacketOnVc
				//
			}
			else
			{
				//
				//  The VC has been deref'ed away! Set up pVc for the
				//  check coming up.
				//
				pVc = NULL_PATMARP_VC;
				AA_ACQUIRE_AE_LOCK(pAtmEntry);
			}

		}

		if (pVc == NULL_PATMARP_VC)
		{
			//
			//  We don't have an appropriate VC to the server, so create
			//  one, and queue this packet for transmission as soon as
			//  the call is made.
			//
			//  AtmArpMakeCall needs the caller to hold the ATM Entry lock.
			//
			AA_GET_CONTROL_PACKET_SPECS(pInterface, &pFlowSpec);
			Status = AtmArpMakeCall(
							pInterface,
							pAtmEntry,
							pFlowSpec,
							pNdisPacket
							);
			//
			//  The AE lock is released within the above.
			//
		}
	}

}





VOID
AtmArpSendInARPRequest(
	IN	PATMARP_VC					pVc
)
/*++

Routine Description:

	Send an InATMARP Request on a VC.

Arguments:

	pVc						- Pointer to ATMARP VC on which we send the request

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PNDIS_PACKET			pNdisPacket;
	PUCHAR                  pArpPacket;	// Pointer to ARP packet being constructed

	AA_ARP_PKT_CONTENTS		ArpContents;// Describes the packet we want to build

	//
	//  Prepare the ARP packet contents structure
	//
	AA_SET_MEM((PUCHAR)&ArpContents, 0, sizeof(AA_ARP_PKT_CONTENTS));

	pInterface = pVc->pInterface;

	//
	//  Source IP Address
	//
	ArpContents.pSrcIPAddress = (PUCHAR)&(pInterface->LocalIPAddress.IPAddress);

	//
	//  Source ATM number
	//
	ArpContents.pSrcAtmNumber = pInterface->LocalAtmAddress.Address;
	ArpContents.SrcAtmNumberTypeLen =
			AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));

	//
	//  Build the InATMARP Request packet
	//
	pNdisPacket = AtmArpBuildARPPacket(
							AA_PKT_OP_TYPE_INARP_REQUEST,
							pInterface,
							&pArpPacket,
							&ArpContents
							);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
#ifndef VC_REFS_ON_SENDS
		AA_ACQUIRE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS

		AtmArpSendPacketOnVc(pVc, pNdisPacket);
		//
		//  The VC lock is released by SendPacketOnVc
		//
	}
	else
	{
#ifdef VC_REFS_ON_SENDS
		AA_RELEASE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS
	}
}






UINT
AtmArpCoReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This is routine is called when a packet is received on a VC owned
	by the ATMARP module. If it is an ARP packet, we consume it ourselves.
	Otherwise, we pass it up to IP.

	In any case, we refresh the VC aging timer on this VC.

Arguments:

	ProtocolBindingContext		- Actually a pointer to our Adapter structure
	ProtocolVcContext			- Actually a pointer to our VC structure
	pNdisPacket					- NDIS packet being received.

Return Value:

	0 always, because we don't hold on to ARP packets, and we assume
	IP doesn't either.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PATMARP_VC				pVc;
	UINT					TotalLength;	// Total bytes in packet
	PNDIS_BUFFER			pNdisBuffer;	// Pointer to first buffer
	UINT					BufferLength;
	UINT					IsNonUnicast;	// Is this to a non-unicast destn MAC addr?
	BOOLEAN					Discarded;		// Are we discarding this packet?

	PAA_PKT_LLC_SNAP_HEADER	pPktHeader;		// LLC/SNAP header
	UINT					ReturnCount = 0;

#if DBG
	pPktHeader = NULL;
#endif
	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

	pInterface = pVc->pInterface;

	Discarded = FALSE;
	IsNonUnicast = (UINT)FALSE;

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		//
		//  Refresh VC aging on this VC
		//
		AA_ACQUIRE_VC_LOCK(pVc);
		AtmArpRefreshTimer(&(pVc->Timer));
		AA_RELEASE_VC_LOCK(pVc);

		NdisQueryPacket(
					pNdisPacket,
					NULL,
					NULL,
					&pNdisBuffer,
					&TotalLength
					);

		//
		//  We expect atleast the LLC/SNAP header to be present
		//  Note: this precludes Null encapsulation.
		//
		if (TotalLength >= AA_PKT_LLC_SNAP_HEADER_LENGTH)
		{
			AA_IF_STAT_ADD(pInterface, InOctets, TotalLength);

			NdisQueryBuffer(
					pNdisBuffer,
					(PVOID *)&pPktHeader,
					&BufferLength
					);

			AADEBUGP(AAD_EXTRA_LOUD,
		 ("Rcv: VC 0x%x, NDISpkt 0x%x, NDISbuf 0x%x, Buflen %d, Totlen %d, Pkthdr 0x%x\n",
						pVc,
						pNdisPacket,
						pNdisBuffer,
						BufferLength,
						TotalLength,
						pPktHeader));

			AADEBUGPDUMP(AAD_EXTRA_LOUD+20, pPktHeader, BufferLength);

			AA_ASSERT(BufferLength >= AA_PKT_LLC_SNAP_HEADER_LENGTH);

			if (AA_PKT_LLC_SNAP_HEADER_OK(pPktHeader))
			{
				//
				//  If the EtherType is IP, pass up this packet to
				//  the IP layer
				//
				if (pPktHeader->EtherType == NET_SHORT(AA_PKT_ETHERTYPE_IP))
				{
					AADEBUGP(AAD_EXTRA_LOUD,
						("Rcv: VC 0x%x, NDISpkt 0x%x: EtherType is IP, passing up\n"));

#if DBG
					if (AaDataDebugLevel & AAD_DATA_IN)
					{
						IP_ADDRESS			IPAddress;

						if ((pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
							(pVc->pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY))
						{
							IPAddress = pVc->pAtmEntry->pIpEntryList->IPAddress;
						}
						else
						{
							IPAddress = 0;
						}

						AADEBUGP(AAD_WARNING,
							("%d <= %d.%d.%d.%d\n",
								TotalLength,
								((PUCHAR)&IPAddress)[0],
								((PUCHAR)&IPAddress)[1],
								((PUCHAR)&IPAddress)[2],
								((PUCHAR)&IPAddress)[3]));
					}
#endif // DBG
					if (IsNonUnicast)
					{
						AA_IF_STAT_INCR(pInterface, InNonUnicastPkts);
					}
					else
					{
						AA_IF_STAT_INCR(pInterface, InUnicastPkts);
					}

#ifdef _PNP_POWER_
					if (NDIS_GET_PACKET_STATUS(pNdisPacket) != NDIS_STATUS_RESOURCES)
					{
						UINT	HeaderSize;
						UINT	DataSize;
						#define ATMARP_MIN_1ST_RECV_BUFSIZE 512

						HeaderSize = NDIS_GET_PACKET_HEADER_SIZE(pNdisPacket);

						//
						// 2/8/1998 JosephJ
						//		We set DataSize to the total payload size,
						//		unless the first buffer is too small to
						//		hold the IP header. In the latter case,
						//		we set DataSize to be the size of the 1st buffer
						//		(minus the LLS/SNAP header size).
						//
						//		This is to work around a bug in tcpip.
						//
						// 2/25/1998 JosephJ
						//		Unfortunately we have to back out YET AGAIN
						//		because large pings (eg ping -l 4000) doesn't
						//		work -- bug#297784
						//		Hence the "0" in "0 && DataSize" below.
						//		Take out the "0" to put back the per fix.
						//
						DataSize = BufferLength - sizeof(AA_PKT_LLC_SNAP_HEADER);
						if (0 && DataSize >= ATMARP_MIN_1ST_RECV_BUFSIZE)
						{
							DataSize = TotalLength - sizeof(AA_PKT_LLC_SNAP_HEADER);
						}

						(pInterface->IPRcvPktHandler)(
							pInterface->IPContext,
							(PVOID)((PUCHAR)pPktHeader+sizeof(AA_PKT_LLC_SNAP_HEADER)),
							DataSize,
							TotalLength,
							(NDIS_HANDLE)pNdisPacket,
							sizeof(AA_PKT_LLC_SNAP_HEADER),
							IsNonUnicast,
							0,
							pNdisBuffer,
							&ReturnCount
						#if P2MP
							,NULL
						#endif //P2MP
							);
					}
					else
					{
						(pInterface->IPRcvHandler)(
							pInterface->IPContext,
							(PVOID)((PUCHAR)pPktHeader+sizeof(AA_PKT_LLC_SNAP_HEADER)),
							BufferLength - sizeof(AA_PKT_LLC_SNAP_HEADER),
							TotalLength - sizeof(AA_PKT_LLC_SNAP_HEADER),
							(NDIS_HANDLE)pNdisPacket,
							sizeof(AA_PKT_LLC_SNAP_HEADER),
							IsNonUnicast
						#if P2MP
							,NULL
						#endif //P2MP
							);
					}
#else
                    // For Win98:
                    (pInterface->IPRcvHandler)(
                        pInterface->IPContext,
                        (PVOID)((PUCHAR)pPktHeader+sizeof(AA_PKT_LLC_SNAP_HEADER)),
                        BufferLength - sizeof(AA_PKT_LLC_SNAP_HEADER),
                        TotalLength - sizeof(AA_PKT_LLC_SNAP_HEADER),
                        (NDIS_HANDLE)pNdisPacket,
                        sizeof(AA_PKT_LLC_SNAP_HEADER),
                        IsNonUnicast
                    #if P2MP
                        ,NULL
                    #endif //P2MP
                        );

#endif // _PNP_POWER_
				}
				else if (pPktHeader->EtherType == NET_SHORT(AA_PKT_ETHERTYPE_ARP))
				{
					//
					//  An ARP packet: we handle it ourselves
					//
					AA_ASSERT(BufferLength == TotalLength);
					AA_IF_STAT_INCR(pInterface, InUnicastPkts);
					AtmArpHandleARPPacket(
							pVc,
							pPktHeader,
							BufferLength
							);
				}
				else
				{
					//
					//  Discard packet -- bad EtherType
					//
					AADEBUGP(AAD_WARNING, ("VC: 0x%x, Pkt hdr 0x%x, bad EtherType 0x%x\n",
								pVc, pPktHeader, (ULONG)pPktHeader->EtherType));
					Discarded = TRUE;
					AA_IF_STAT_INCR(pInterface, UnknownProtos);
				}
			}
			else
			{
#ifdef IPMCAST
				Discarded = AtmArpMcProcessPacket(
								pVc,
								pNdisPacket,
								pNdisBuffer,
								pPktHeader,
								TotalLength,
								BufferLength
								);
#else
				//
				//  Discard packet -- bad LLC/SNAP
				//
				AADEBUGP(AAD_WARNING, ("VC: 0x%x, Pkt hdr 0x%x, bad LLC/SNAP\n",
								pVc, pPktHeader));
				Discarded = TRUE;
#endif // IPMCAST
			}
		}
		else
		{
			//
			//  Discard packet -- too short
			//
			AADEBUGP(AAD_WARNING, ("VC: 0x%x, Pkt hdr 0x%x, too short: %d\n",
								pVc, pPktHeader, TotalLength));
			Discarded = TRUE;
		}
	}
	else
	{
		//
		//  Discard packet -- IF down
		//
		AADEBUGP(AAD_WARNING, ("pInterface: 0x%x is down, discarding NDIS pkt 0x%x\n",
					pInterface, pNdisPacket));
		Discarded = TRUE;
	}

	if (Discarded)
	{
		AA_IF_STAT_INCR(pInterface, InDiscards);
	}

	return (ReturnCount);
}




VOID
AtmArpHandleARPPacket(
	IN	PATMARP_VC					pVc,
	IN	PAA_PKT_LLC_SNAP_HEADER		pPktHeader,
	IN	ULONG						PacketLength
)
/*++

Routine Description:

	Process a received ARP packet. We complete most of the packet checks
	here, and then branch off to do different things based on the Op type
	in the packet.

	We do not hang on to the packet, i.e. when we return from here,
	the packet is free.

Arguments:

	pVc					- Pointer to ATMARP VC on which packet arrived
	pPktHeader			- Pointer to start of packet (including LLC/SNAP)
	PacketLength		- Length including LLC/SNAP header

Return Value:

	None

--*/
{
	PATMARP_INTERFACE				pInterface;
	PAA_ARP_PKT_HEADER				pArpHeader;
	NDIS_STATUS						Status;

	//
	//  For walking down the packet
	//
	UCHAR UNALIGNED *				pPacket;

	//
	//  For storing pointers to the packet contents. We'll need this
	//  if we have to send a reply packet.
	//
	AA_ARP_PKT_CONTENTS				ArpContents;

	BOOLEAN							SrcAtmBelongsToUs;
	BOOLEAN							SrcIPBelongsToUs;

	//
	//  Initialize (Important: don't remove the zeroing of ArpContents)
	//
	AA_SET_MEM((PUCHAR)&ArpContents, 0, sizeof(AA_ARP_PKT_CONTENTS));
	Status = NDIS_STATUS_SUCCESS;
	pInterface = pVc->pInterface;

	pArpHeader = STRUCT_OF(AA_ARP_PKT_HEADER, pPktHeader, LLCSNAPHeader);

	AADEBUGP(AAD_EXTRA_LOUD+10,
		("HandleARPPkt: VC 0x%x, IF 0x%x, pPktHdr 0x%x, Len %d\n",
				pVc,
				pInterface,
				pPktHeader,
				PacketLength));

	do
	{
		if (PacketLength < AA_ARP_PKT_HEADER_LENGTH)
		{
			AADEBUGP(AAD_WARNING, ("HandleARPPkt: IF 0x%x, PacketLength %d < HdrLen %d\n",
					pInterface, PacketLength, AA_ARP_PKT_HEADER_LENGTH));

			Status = NDIS_STATUS_BUFFER_TOO_SHORT;
			break;
		}

		if ((pArpHeader->hrd != NET_SHORT(AA_PKT_HRD)) ||
			(pArpHeader->pro != NET_SHORT(AA_PKT_PRO)))
		{
			AADEBUGP(AAD_WARNING,
			 ("HandleARPPkt: IF 0x%x, Bad hdr (%d != %d) or pro (%d != %d)\n",
					pInterface,
					pArpHeader->hrd,
					AA_PKT_HRD,
					pArpHeader->pro,
					AA_PKT_PRO));

			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		//
		//  Get at the variable part of the packet, and get pointers
		//  to all addresses.
		//
		//  TBD: add more checks on ATM address lengths and combinations
		//	Note: we check for packet length later.
		//
		pPacket = pArpHeader->Variable;

		//
		//  Source ATM Number
		//
		if (pArpHeader->shtl != 0)
		{
			ArpContents.SrcAtmNumberTypeLen = pArpHeader->shtl;
			ArpContents.pSrcAtmNumber = pPacket;
			pPacket += (pArpHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT);
		}

		//
		//  Source ATM Subaddress
		//
		if (pArpHeader->sstl != 0)
		{
			ArpContents.SrcAtmSubaddrTypeLen = pArpHeader->sstl;
			ArpContents.pSrcAtmSubaddress = pPacket;
			pPacket += (pArpHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT);
		}

		//
		//  Source IP Address. Older 1577 implementations may send an
		//  IP address field filled with all 0's to denote an unspecified
		//  IP address.
		//
		if (pArpHeader->spln != 0)
		{
			if (pArpHeader->spln != AA_IPV4_ADDRESS_LENGTH)
			{
				AADEBUGP(AAD_WARNING,
					("HandleARPPkt: IF 0x%x, bad spln %d != %d\n",
							pInterface,
							pArpHeader->spln,
							AA_IPV4_ADDRESS_LENGTH));

				Status = NDIS_STATUS_INVALID_ADDRESS;
				break;
			}

			if (!AtmArpIsZeroIPAddress(pPacket))
			{
				ArpContents.pSrcIPAddress = pPacket;
			}
			pPacket += AA_IPV4_ADDRESS_LENGTH;
		}

		//
		//  Target ATM Number
		//
		if (pArpHeader->thtl != 0)
		{
			ArpContents.DstAtmNumberTypeLen = pArpHeader->thtl;
			ArpContents.pDstAtmNumber = pPacket;
			pPacket += (pArpHeader->thtl & ~AA_PKT_ATM_ADDRESS_BIT);
		}

		//
		//  Target ATM Subaddress
		//
		if (pArpHeader->tstl != 0)
		{
			ArpContents.DstAtmSubaddrTypeLen = pArpHeader->tstl;
			ArpContents.pDstAtmSubaddress = pPacket;
			pPacket += (pArpHeader->tstl & ~AA_PKT_ATM_ADDRESS_BIT);
		}

		//
		//  Target IP Address [see comments for Source IP Address]
		//
		if (pArpHeader->tpln != 0)
		{
			if (pArpHeader->tpln != AA_IPV4_ADDRESS_LENGTH)
			{
				AADEBUGP(AAD_WARNING,
					("HandleARPPkt: IF 0x%x, bad tpln %d != %d\n",
							pInterface,
							pArpHeader->tpln,
							AA_IPV4_ADDRESS_LENGTH));

				Status = NDIS_STATUS_INVALID_ADDRESS;
				break;
			}

			if (!AtmArpIsZeroIPAddress(pPacket))
			{
				ArpContents.pDstIPAddress = pPacket;
			}
			pPacket += AA_IPV4_ADDRESS_LENGTH;
		}

		//
		//
		//
		if ((ULONG)(pPacket - (PUCHAR)pArpHeader) >  PacketLength)
		{
				AADEBUGP(AAD_WARNING,
					("HandleARPPkt: IF 0x%x, pPktHdr 0x%x. Length %d TOO SMALL (want %d)\n",
							pInterface,
							pArpHeader,
							PacketLength,
							(pPacket - (PUCHAR)pArpHeader)));

				Status = NDIS_STATUS_BUFFER_TOO_SHORT;
				break;
		}

		//
		//  If this is an ARP NAK packet, swap Source and Target
		//  addresses, in preparation for what follows. This is
		//  because, unlike any other Reply packet where the Source
		//  and Target addresses get swapped, the ARP NAK
		//  packet is a copy of the ARP Request, with only the
		//  Op code changed.
		//
		if (NET_SHORT(pArpHeader->op) == AA_PKT_OP_TYPE_ARP_NAK)
		{
			UCHAR				TypeLen;
			UCHAR UNALIGNED *	pAddress;

			//
			//  IP Addresses:
			//
			pAddress = ArpContents.pSrcIPAddress;
			ArpContents.pSrcIPAddress = ArpContents.pDstIPAddress;
			ArpContents.pDstIPAddress = pAddress;

			//
			//  ATM Number:
			//
			TypeLen = ArpContents.SrcAtmNumberTypeLen;
			ArpContents.SrcAtmNumberTypeLen = ArpContents.DstAtmNumberTypeLen;
			ArpContents.DstAtmNumberTypeLen = TypeLen;
			pAddress = ArpContents.pSrcAtmNumber;
			ArpContents.pSrcAtmNumber = ArpContents.pDstAtmNumber;
			ArpContents.pDstAtmNumber = pAddress;

			//
			//  ATM Subaddress:
			//
			TypeLen = ArpContents.SrcAtmSubaddrTypeLen;
			ArpContents.SrcAtmSubaddrTypeLen = ArpContents.DstAtmSubaddrTypeLen;
			ArpContents.DstAtmSubaddrTypeLen = TypeLen;
			pAddress = ArpContents.pSrcAtmSubaddress;
			ArpContents.pSrcAtmSubaddress = ArpContents.pDstAtmSubaddress;
			ArpContents.pDstAtmSubaddress = pAddress;
		}


		SrcIPBelongsToUs = AtmArpIsLocalIPAddress(
									pInterface,
									ArpContents.pSrcIPAddress
									);

		SrcAtmBelongsToUs = AtmArpIsLocalAtmAddress(
									pInterface,
									ArpContents.pSrcAtmNumber,
									ArpContents.SrcAtmNumberTypeLen
									);

		//
		//  Check if someone else is claiming to be the owner
		//  of "our" IP address:
		//
		if (SrcIPBelongsToUs && !SrcAtmBelongsToUs)
		{
			AADEBUGP(AAD_ERROR,
				 ("Pkt 0x%x: src IP is ours, src ATM is bad!\n", pPktHeader));
			AA_ACQUIRE_IF_LOCK(pInterface);
			pInterface->State = IF_STATUS_DOWN;
			pInterface->LastChangeTime = GetTimeTicks();
			AA_RELEASE_IF_LOCK(pInterface);

			AtmArpStartRegistration(pInterface);

			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		//
		//  See if this is directed to someone else: if so, drop it.
		//

		//
		//  Check if the Target IP address is ours. A null IP address is
		//  acceptable (e.g. [In]ARP Request).
		//
		if ((ArpContents.pDstIPAddress != (PUCHAR)NULL) &&
			!AtmArpIsLocalIPAddress(pInterface, ArpContents.pDstIPAddress))
		{
			//
			//  A target IP address is present, and it is not ours
			//
			AADEBUGP(AAD_WARNING,
			("ArpPkt 0x%x has unknown target IP addr (%d.%d.%d.%d)\n",
					 pPktHeader,
					 ArpContents.pDstIPAddress[0],
					 ArpContents.pDstIPAddress[1],
					 ArpContents.pDstIPAddress[2],
					 ArpContents.pDstIPAddress[3]));
			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		//
		//  If there is a Target ATM Number, check to see if it is ours.
		//
		if ((ArpContents.pDstAtmNumber != (PUCHAR)NULL) &&
			(!AtmArpIsLocalAtmAddress(
						pInterface,
						ArpContents.pDstAtmNumber,
						ArpContents.DstAtmNumberTypeLen))
		   )
		{
			//
			//  A target ATM number is present, and it is not ours
			//
			AADEBUGP(AAD_WARNING,
					("ArpPkt 0x%x has unknown target ATM addr (0x%x, 0x%x)\n",
					 pPktHeader,
					 ArpContents.DstAtmNumberTypeLen, 
					 ArpContents.pDstAtmNumber));

			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}


		//
		//  Handle the various Op types
		//
		switch (NET_SHORT(pArpHeader->op))
		{
			case AA_PKT_OP_TYPE_ARP_REQUEST:
				AtmArpHandleARPRequest(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents
						);
				break;

			case AA_PKT_OP_TYPE_ARP_REPLY:
				AtmArpHandleARPReply(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents,
						SrcIPBelongsToUs,
						SrcAtmBelongsToUs
						);
				break;

			case AA_PKT_OP_TYPE_ARP_NAK:
				AtmArpHandleARPNAK(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents
						);
				break;

			case AA_PKT_OP_TYPE_INARP_REQUEST:
				AtmArpHandleInARPRequest(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents
						);
				break;

			case AA_PKT_OP_TYPE_INARP_REPLY:
				AtmArpHandleInARPReply(
						pVc,
						pInterface,
						pArpHeader,
						&ArpContents
						);
				break;

			default:
				AADEBUGP(AAD_WARNING,
					("HandleARPPkt: IF 0x%x, pArpHdr 0x%x, Op %d not known\n",
							pInterface, pArpHeader, NET_SHORT(pArpHeader->op)));

				Status = NDIS_STATUS_NOT_RECOGNIZED;
				break;
		}
		
	}
	while (FALSE);

	return;
}




VOID
AtmArpHandleARPRequest(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Process a received ATMARP Request. All we need to do is send
	an ATMARP Reply, since the calling routine has already verified
	that the Target IP address is ours.

Arguments:

	pVc					- Pointer to VC on which the request arrived
	pInterface			- Pointer to ATMARP Interface containing this VC
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet

Return Value:

	None

--*/
{
	//
	//  Temp locations used for swapping fields
	//
	UCHAR UNALIGNED *			pAddress;
	UCHAR						Length;
	//
	//  ARP Reply packet
	//
	PNDIS_PACKET				pNdisPacket;
	PUCHAR                      pArpPacket;

	//
	//  Swap source and target addresses, and fill in our ATM info
	//  in the source ATM addresses fields.
	//

	//
	//  IP Addresses
	//
	pAddress = pArpContents->pSrcIPAddress;
	pArpContents->pSrcIPAddress = pArpContents->pDstIPAddress;
	pArpContents->pDstIPAddress = pAddress;

	//
	//  ATM Numbers: set the target ATM number to the source ATM
	//  number, but set the source ATM number to the local ATM
	//  address.
	//
	pArpContents->pDstAtmNumber = pArpContents->pSrcAtmNumber;
	pArpContents->DstAtmNumberTypeLen = pArpContents->SrcAtmNumberTypeLen;
	pArpContents->pSrcAtmNumber = (pInterface->LocalAtmAddress.Address);
	pArpContents->SrcAtmNumberTypeLen =
				 AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));

	//
	//  ATM Subaddresses
	//
	pArpContents->pDstAtmSubaddress = pArpContents->pSrcAtmSubaddress;
	pArpContents->DstAtmSubaddrTypeLen = pArpContents->SrcAtmSubaddrTypeLen;
	pArpContents->pSrcAtmSubaddress = NULL;
	pArpContents->SrcAtmSubaddrTypeLen = 0;

	//
	//  Build the ARP Reply packet
	//
	pNdisPacket = AtmArpBuildARPPacket(
							AA_PKT_OP_TYPE_ARP_REPLY,
							pInterface,
							&pArpPacket,
							pArpContents
							);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  And send it off. Since we are in the context of a receive
		//  indication on this VC, we can safely access the VC now.
		//
		AA_ACQUIRE_VC_LOCK(pVc);

		AtmArpSendPacketOnVc(pVc, pNdisPacket);
		//
		//  The VC lock is released by SendPacketOnVc
		//
	}
}



VOID
AtmArpHandleARPReply(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents,
	IN	BOOLEAN						SrcIPAddressIsOurs,
	IN	BOOLEAN						SrcAtmAddressIsOurs
)
/*++

Routine Description:

	Process a received ATMARP Reply packet. There are two major
	cases here:
		(1) We were trying to register one of our IP addresses with
		    the server.
		(2) We were trying to resolve a remote IP address.

	In case (1), if we just registered the first of possibly many
	IP addresses assigned to this interface, we register all the other
	IP addresses.

	In case (2), we set up an IP to ATM mapping and initiate a connection
	if necessary.

Arguments:

	pVc					- Pointer to VC on which the reply arrived
	pInterface			- Pointer to ATMARP Interface containing this VC
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet
	SrcIPAddressIsOurs	- The source IP address is one of ours
	SrcAtmAddressIsOurs	- The source ATM info is ours.

Return Value:

	None

--*/
{
	BOOLEAN				TimerWasRunning;
	BOOLEAN				IsFirstRegistration;
	PIP_ADDRESS_ENTRY	pIPAddressEntry;
	ULONG				rc;		// Ref Count

	AADEBUGP(AAD_LOUD,
		("Handle ARP Reply: pVc 0x%x, pIf 0x%x, IF Flags 0x%x, OurIP %d, OurATM %d\n",
			pVc, pInterface, pInterface->Flags, SrcIPAddressIsOurs, SrcAtmAddressIsOurs));

	AA_ACQUIRE_IF_LOCK(pInterface);

	if (AA_IS_FLAG_SET(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_REGISTERING))
	{
		//
		//  We just completed registering with the server. Since we don't
		//  send ARP requests to resolve any other addresses while we
		//  are registering, the Source IP address must be ours.
		//

		//
		//  Stop the Registration timer
		//
		TimerWasRunning = AtmArpStopTimer(&(pInterface->Timer), pInterface);
		AA_ASSERT(TimerWasRunning == TRUE);
		if (TimerWasRunning)
		{
			rc = AtmArpDereferenceInterface(pInterface);	// Timer reference
			AA_ASSERT(rc > 0);
		}
		//
		//  We have already verified that the Target addresses are ours.
		//  Check that the source addresses are ours, too.
		//
		if (!SrcIPAddressIsOurs || !SrcAtmAddressIsOurs)
		{
			//
			//  Registration failure. Start recovery.
			//
			AtmArpHandleServerRegistrationFailure(pInterface, pVc);
			//
			//  IF lock is released within the above.
			//
		}
		else
		{
			//
			//  We registered an IP address successfully!
			//
			//  Find the entry for the IP Address that we have registered,
			//  and mark it as registered.
			//
			pIPAddressEntry = &(pInterface->LocalIPAddress);
			while (*((IP_ADDRESS UNALIGNED *)(pArpContents->pSrcIPAddress))
						!= pIPAddressEntry->IPAddress)
			{
				AA_ASSERT(pIPAddressEntry->pNext != (PIP_ADDRESS_ENTRY)NULL);
				pIPAddressEntry = pIPAddressEntry->pNext;
			}
			pIPAddressEntry->IsRegistered = TRUE;

			IsFirstRegistration = pIPAddressEntry->IsFirstRegistration;
			pIPAddressEntry->IsFirstRegistration = FALSE;

			AADEBUGP(AAD_INFO,
				("**** Registered IP Addr: %d.%d.%d.%d on IF 0x%x\n",
					((PUCHAR)&(pIPAddressEntry->IPAddress))[0],
					((PUCHAR)&(pIPAddressEntry->IPAddress))[1],
					((PUCHAR)&(pIPAddressEntry->IPAddress))[2],
					((PUCHAR)&(pIPAddressEntry->IPAddress))[3],
					pInterface));

			AA_SET_FLAG(
					pInterface->Flags,
					AA_IF_SERVER_STATE_MASK,
					AA_IF_SERVER_REGISTERED);

			pInterface->State = IF_STATUS_UP;
			pInterface->LastChangeTime = GetTimeTicks();

			//
			//  Start the Server refresh timer so that we send our ARP info
			//  to the server every so often (default = 15 minutes).
			//
			AtmArpStartTimer(
					pInterface,
					&(pInterface->Timer),
					AtmArpServerRefreshTimeout,
					pInterface->ServerRefreshTimeout,
					(PVOID)pInterface		// Context
					);

			AtmArpReferenceInterface(pInterface);	// Timer reference

			//
			//  If we have any more addresses to register, do so now.
			//
			AtmArpRegisterOtherIPAddresses(pInterface);
			//
			//  IF Lock is freed in the above
			//
#ifdef ATMARP_WMI
			if (IsFirstRegistration)
			{
				//
				//  Send a WMI event, which carries the list of IP Addresses
				//  registered on this IF. We do this only if this is a new
				//  IP address.
				//
				AtmArpWmiSendTCIfIndication(
					pInterface,
                    AAGID_QOS_TC_INTERFACE_UP_INDICATION,
					0
					);
			}
#endif
		}
	}
	else
	{
		//
		//  Resolved an IP to ATM address
		//
		AADEBUGP(AAD_INFO,
			("ARP Reply: Resolved IP Addr: %d.%d.%d.%d\n",
				((PUCHAR)(pArpContents->pSrcIPAddress))[0],
				((PUCHAR)(pArpContents->pSrcIPAddress))[1],
				((PUCHAR)(pArpContents->pSrcIPAddress))[2],
				((PUCHAR)(pArpContents->pSrcIPAddress))[3]
			));

		AA_RELEASE_IF_LOCK(pInterface);

		(VOID)AtmArpLearnIPToAtm(
				pInterface,
				(IP_ADDRESS *)pArpContents->pSrcIPAddress,
				pArpContents->SrcAtmNumberTypeLen,
				pArpContents->pSrcAtmNumber,
				pArpContents->SrcAtmSubaddrTypeLen,
				pArpContents->pSrcAtmSubaddress,
				FALSE		// Not a static entry
				);

	}

	return;
}




VOID
AtmArpHandleARPNAK(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Process a received ARP-NAK packet. If this is in response to
	an ARP Request we had sent to register ourselves, then we close
	the VC to this ARP server, and try the next server in our list of
	servers, after waiting for a while.

	If we were trying to resolve a remote IP address, then we mark
	the ARP IP entry corresponding to this IP address as having
	received a NAK, and free any packets queued on this. We also make
	a timestamp on the Entry so that we don't send another ARP Request
	for the same IP address very soon.

Arguments:
	pVc					- Pointer to VC on which the NAK arrived
	pInterface			- Pointer to ATMARP Interface containing this VC
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet

Return Value:

	None

--*/
{
	BOOLEAN				TimerWasRunning;
	ULONG				rc;				// Ref Count
	PATMARP_IP_ENTRY	pIpEntry;
	PNDIS_PACKET		PacketList;	// Packets queued for sending
#if !BINARY_COMPATIBLE
#ifdef CUBDD
	SINGLE_LIST_ENTRY	PendingIrpList;
#endif // CUBDD
#endif // !BINARY_COMPATIBLE

	AA_ACQUIRE_IF_LOCK(pInterface);

	if (AA_IS_FLAG_SET(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_REGISTERING))
	{
		AADEBUGP(AAD_WARNING,
				("Rcvd ARP NAK while registering: pIf 0x%x\n", pInterface));

		//
		//  Registration was in progress, and it failed. Start recovery.
		//
		AtmArpHandleServerRegistrationFailure(pInterface, pVc);
		//
		//  IF lock is released within the above.
		//
	}
	else
	{
		//
		//  We were trying to resolve an IP address. Get the Address
		//  IP Entry corresponding to this IP address.
		//
		AA_RELEASE_IF_LOCK(pInterface);

		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
		pIpEntry = AtmArpSearchForIPAddress(
							pInterface,
							(IP_ADDRESS *)pArpContents->pSrcIPAddress,
							IE_REFTYPE_TMP,
							FALSE,	// this isn't multicast/broadcast
							FALSE	// Don't create a new one
							);
		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			AADEBUGP(AAD_INFO,
				("Rcvd ARP NAK: pIf 0x%x, IP addr %d:%d:%d:%d\n",
						pInterface,
						((PUCHAR)(&(pIpEntry->IPAddress)))[0],
						((PUCHAR)(&(pIpEntry->IPAddress)))[1],
						((PUCHAR)(&(pIpEntry->IPAddress)))[2],
						((PUCHAR)(&(pIpEntry->IPAddress)))[3]));

			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			//
			// AtmArpSerchForIPAddress addrefd pIpEntry for us -- we deref it
			// here now that we've locked it.
			//
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);

			if (rc > 0)
			{
#if !BINARY_COMPATIBLE
#ifdef CUBDD
				//
				//  Take out the list of pending IRPs on this IP Entry.
				//
				PendingIrpList = pIpEntry->PendingIrpList;
				pIpEntry->PendingIrpList.Next = (PSINGLE_LIST_ENTRY)NULL;
#endif // CUBDD
#endif // !BINARY_COMPATIBLE
	
				//
				//  Take out all packets queued on this entry
				//
				PacketList = pIpEntry->PacketList;
				pIpEntry->PacketList = (PNDIS_PACKET)NULL;
	
				//
				//  The Address resolution timer must be running on this Entry;
				//  stop it.
				//
				TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
	
				if (TimerWasRunning)
				{
					rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer reference
				}
				else
				{
					rc = pIpEntry->RefCount;
				}
			}

			//
			//  Continue only if the IP Entry hasn't gone away
			//
			if (rc > 0)
			{
				//
				//  Set the IP entry's state so that we don't send any
				//  address resolution traffic for this IP address for
				//  some time.
				//
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_SEEN_NAK);

				//
				//  Start a NAK Delay timer: until this expires, we won't
				//  send any ARP requests for this IP address. This makes
				//  sure that we don't keep pounding on the server with
				//  an unresolvable IP address.
				//
				AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpNakDelayTimeout,
							pInterface->MinWaitAfterNak,
							(PVOID)pIpEntry		// Context
							);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref

				AA_RELEASE_IE_LOCK(pIpEntry);
			}
			// else the IP Entry lock would have been released.


			//
			//  Free any packets that were queued up.
			//
			if (PacketList != (PNDIS_PACKET)NULL)
			{
				AtmArpFreeSendPackets(
							pInterface,
							PacketList,
							FALSE			// No headers on these
							);
			}
#if !BINARY_COMPATIBLE
#ifdef CUBDD
			AtmArpCompleteArpIrpList(
							PendingIrpList,
							(PATM_ADDRESS)NULL
							);
#endif // CUBDD
#endif // !BINARY_COMPATIBLE
		}
		else
		{
			//
			//  No IP Address Entry matching the IP address being
			//  ARP'ed for. Nothing to be done in this case.
			//

		}
	}

	return;

}




VOID
AtmArpHandleInARPRequest(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Process an InARP Request. We send back an InARP Reply packet
	with our address information.

	In case this is a PVC we were trying to resolve, it is possible
	that we are waiting for an InARP Reply ourselves, and the remote
	station came up only now. To speed up the resolution process,
	we restart the InARP Wait timeout so that it expires soon, causing
	another InARP Request to be sent.

Arguments:

	pVc					- Pointer to VC on which the request arrived
	pInterface			- Pointer to ATMARP Interface containing this VC
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet

Return Value:

	None

--*/
{
	//
	//  Temp locations used for swapping fields
	//
	UCHAR UNALIGNED *			pAddress;
	UCHAR						Length;
	//
	//  ARP Reply packet
	//
	PNDIS_PACKET				pNdisPacket;
	PUCHAR                      pArpPacket;

	//
	//  Copy the Source address (IP+ATM) info into the Target address
	//  fields, and fill in the Source info fields with our IP+ATM info.
	//

	//
	//  IP Addresses:
	//
	pArpContents->pDstIPAddress = pArpContents->pSrcIPAddress;
	pArpContents->pSrcIPAddress = (PUCHAR)&(pInterface->LocalIPAddress.IPAddress);

	//
	//  ATM Numbers: set the target ATM number to the source ATM
	//  number, but set the source ATM number to the local ATM
	//  address.
	//
	pArpContents->pDstAtmNumber = pArpContents->pSrcAtmNumber;
	pArpContents->DstAtmNumberTypeLen = pArpContents->SrcAtmNumberTypeLen;
	pArpContents->pSrcAtmNumber = (pInterface->LocalAtmAddress.Address);
	pArpContents->SrcAtmNumberTypeLen =
				 AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));

	//
	//  ATM Subaddresses
	//
	pArpContents->pDstAtmSubaddress = pArpContents->pSrcAtmSubaddress;
	pArpContents->DstAtmSubaddrTypeLen = pArpContents->SrcAtmSubaddrTypeLen;
	pArpContents->pSrcAtmSubaddress = NULL;
	pArpContents->SrcAtmSubaddrTypeLen = 0;

	//
	//  Build the InARP Reply packet
	//
	pNdisPacket = AtmArpBuildARPPacket(
							AA_PKT_OP_TYPE_INARP_REPLY,
							pInterface,
							&pArpPacket,
							pArpContents
							);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Before we send it off, check if this is a PVC being InARP'ed.
		//  If so, restart the InARP Wait timer so that it expires soon.
		//
		//  It is also possible that this PVC was once resolved, but
		//  the remote end had gone away long enough for us to age out
		//  the corresponding IP entry. This packet might be due to the
		//  remote end coming back up. Start off an Inverse ARP operation
		//  to get our end of the PVC re-resolved.
		//
		AA_ACQUIRE_VC_LOCK(pVc);

		if (AA_IS_FLAG_SET(
					pVc->Flags,
					AA_VC_TYPE_MASK,
					AA_VC_TYPE_PVC) &&

			(AA_IS_FLAG_SET(
					pVc->Flags,
					AA_VC_ARP_STATE_MASK,
					AA_VC_INARP_IN_PROGRESS) ||

			 ((pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
			  (pVc->pAtmEntry->pIpEntryList == NULL_PATMARP_IP_ENTRY))))
		{
			BOOLEAN		TimerWasRunning;

#if DBG
			if ((pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
			  	(pVc->pAtmEntry->pIpEntryList == NULL_PATMARP_IP_ENTRY))
			{
				AADEBUGP(AAD_LOUD,
					("InARPReq: PVC %p, AtmEntry %p has NULL IP Entry, will InARP again!\n",
						pVc, pVc->pAtmEntry));
			}
#endif
			AA_SET_FLAG(pVc->Flags,
						AA_VC_ARP_STATE_MASK,
						AA_VC_INARP_IN_PROGRESS);

			//
			//  Stop the currently running InARP Wait timer
			//
			TimerWasRunning = AtmArpStopTimer(&(pVc->Timer), pInterface);

			//
			//  Start it again, to fire in 1 second
			//
			AtmArpStartTimer(
						pInterface,
						&(pVc->Timer),
						AtmArpPVCInARPWaitTimeout,
						1,
						(PVOID)pVc		// Context
						);

			if (!TimerWasRunning)
			{
				AtmArpReferenceVc(pVc);		// Timer reference
			}
		}

		AtmArpSendPacketOnVc(pVc, pNdisPacket);
		//
		//  The VC lock is released by SendPacketOnVc
		//
	}
}




VOID
AtmArpHandleInARPReply(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
)
/*++

Routine Description:

	Process an InARP Reply packet, which should be a response to an InARP
	Request we sent earlier.

	There are two circumstances under which we send InARP Requests:
	(1) To obtain the addresses at the other end of a PVC.
	(2) In the process of revalidating an IP Address, if we aren't able
	    to contact the server AND a VC exists to this IP address, we send
	    an InARP Request to revalidate the IP entry.

	In Case (1), we link the PVC to an ATM Address Entry. In Case (2),
	we mark the IP entry for this VC as being "resolved", and start
	data transfer to this IP address.

Arguments:

	pVc					- Pointer to ATMARP VC on which this packet arrived
	pInterface			- Pointer to ATMARP Interface
	pArpHeader			- Pointer to ARP Header for this packet
	pArpContents		- Parsed contents of received ARP Request packet

Return Value:

	None

--*/
{
	PATMARP_ATM_ENTRY		pAtmEntry;	// ATM entry to which this VC is linked
	PATMARP_IP_ENTRY		pIpEntry;		// IP address entry
	BOOLEAN					TimerWasRunning;
	PATMARP_VC *			ppVc;		// Used to unlink VC from unresolved list
	ULONG					rc;			// Ref Count
	PNDIS_PACKET			PacketList;	// Packets queued for sending
	BOOLEAN					IsBroadcast;	// Is the IP Addr a broadcast/Class D addr?


	if (pArpContents->pSrcIPAddress == NULL)
	{
		AADEBUGP(AAD_WARNING,
			("HandleInARPReply: IF %x, Null source address, discarding pkt\n", pInterface));
		return;
	}

	AADEBUGP(AAD_INFO,
			("HandleInARPReply: IF %x, IP addr %d.%d.%d.%d\n",
					pInterface,
					((PUCHAR)pArpContents->pSrcIPAddress)[0],
					((PUCHAR)pArpContents->pSrcIPAddress)[1],
					((PUCHAR)pArpContents->pSrcIPAddress)[2],
					((PUCHAR)pArpContents->pSrcIPAddress)[3]));

	//
	//  Update our ARP cache with this information (regardless of whether
	//  this is a PVC or SVC).
	//
	pIpEntry = AtmArpLearnIPToAtm(
					pInterface,
					(PIP_ADDRESS)pArpContents->pSrcIPAddress,
					pArpContents->SrcAtmNumberTypeLen,
					pArpContents->pSrcAtmNumber,
					pArpContents->SrcAtmSubaddrTypeLen,
					pArpContents->pSrcAtmSubaddress,
					FALSE		// Not a static entry
					);

	//
	//  Acquire the locks that we need, in an ordered fashion...
	//
	AA_ACQUIRE_IF_LOCK(pInterface);

	if (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
		
		pAtmEntry = pIpEntry->pAtmEntry;
		if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
			AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
		}
	}
	else
	{
		pAtmEntry = NULL_PATMARP_ATM_ENTRY;
	}

	AA_ACQUIRE_VC_LOCK_DPC(pVc);

	if (AA_IS_FLAG_SET(
					pVc->Flags,
					AA_VC_TYPE_MASK,
					AA_VC_TYPE_PVC)  &&
		(pVc->pAtmEntry == NULL_PATMARP_ATM_ENTRY) )
	{
		//
		//  This is an unresolved PVC, whose remote address info
		//  we were trying to InARP for.
		//

		//
		//  Stop the InARP Wait timer running on this VC
		//
		TimerWasRunning = AtmArpStopTimer(&(pVc->Timer), pInterface);
		AA_ASSERT(TimerWasRunning == TRUE);

		if (TimerWasRunning)
		{
			rc = AtmArpDereferenceVc(pVc);	// Timer reference
		}
		else
		{
			rc = pVc->RefCount;
		}

		//
		//  Do the rest only if the VC hasn't gone away.
		//
		if (rc != 0)
		{
			AA_SET_FLAG(
					pVc->Flags,
					AA_VC_ARP_STATE_MASK,
					AA_VC_ARP_STATE_IDLE);

			if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
			{
				//
				//  We are all set now. Take the VC out of the list of
				//  unresolved VCs on this Interface, and put it in the
				//  list of VCs attached to this ATM Entry.
				//
				//  NOTE: we don't dereference the VC because we are just
				//  moving it from one list (Unresolved VCs) to another
				//  (ATM Entry's VC list).
				//
				ppVc = &(pInterface->pUnresolvedVcs);
				while (*ppVc != pVc)
				{
					AA_ASSERT(*ppVc != NULL_PATMARP_VC);
					ppVc = &((*ppVc)->pNextVc);
				}
				*ppVc = pVc->pNextVc;

				AtmArpLinkVcToAtmEntry(pVc, pAtmEntry);
			}
			else
			{
				//
				//  No matching ATM Entry.
				//
				//  We are really low on resources if we are here.
				//  Start the InARP Wait timer; when it fires, we'll try to
				//  send another InARP Request to resolve this VC.
				//
				AADEBUGP(AAD_FATAL,
					("HandleInARPReply: no matching ATM entry: pInterface %x, pVc %x, pIpEntry %x\n",
							pInterface,
							pVc,
							pIpEntry));

				AA_ASSERT(FALSE);

				AtmArpStartTimer(
						pInterface,
						&(pVc->Timer),
						AtmArpPVCInARPWaitTimeout,
						pInterface->InARPWaitTimeout,
						(PVOID)pVc		// Context
						);
				
				AtmArpReferenceVc(pVc);		//  InARP Timer ref

			}

			AA_RELEASE_VC_LOCK_DPC(pVc);

		}
		else
		{
			//
			//  The VC went away while we were InARPing
			//
		}

		//
		//  Release any locks that we still hold.
		//
		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
			{
				AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
			}
			AA_RELEASE_IE_LOCK_DPC(pIpEntry);
		}

		AA_RELEASE_IF_LOCK(pInterface);
	}
	else
	{
		//
		//  Revalidating on a PVC/SVC: case (2) in Routine Description
		//
		AA_SET_FLAG(
				pVc->Flags,
				AA_VC_ARP_STATE_MASK,
				AA_VC_ARP_STATE_IDLE);
		
		//
		//  Stop the INARP timer, if it is running.
		//
		TimerWasRunning = AtmArpStopTimer(&pVc->Timer, pInterface);

		if (TimerWasRunning)
		{
			rc = AtmArpDereferenceVc(pVc);	// InARP reply: stop InARP timer
		}
		else
		{
			rc = pVc->RefCount;
		}

		if (rc != 0)
		{
			AA_RELEASE_VC_LOCK_DPC(pVc);
		}

		//
		//  Update the IP Entry we were revaldating.
		//

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			//
			//  Stop the InARP timer running here
			//
			TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
			if (TimerWasRunning)
			{
				rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// timer ref
			}
			else
			{
				rc = pIpEntry->RefCount;
			}

			//
			//  Continue only if the IP Entry hasn't gone away.
			//
			if (rc > 0)
			{
				//
				//  Update its state
				//
				AA_SET_FLAG(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_RESOLVED
							);

				AADEBUGP(AAD_INFO,
					("InARP Reply: Revalidated pIpEntry 0x%x, IP Addr: %d.%d.%d.%d\n",
							pIpEntry,
							((PUCHAR)(&(pIpEntry->IPAddress)))[0],
							((PUCHAR)(&(pIpEntry->IPAddress)))[1],
							((PUCHAR)(&(pIpEntry->IPAddress)))[2],
							((PUCHAR)(&(pIpEntry->IPAddress)))[3]
							));

				AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);

				//
				//  Start the Aging timer.
				//
				AtmArpStartTimer(
					pInterface,
					&(pIpEntry->Timer),
					AtmArpIPEntryAgingTimeout,
					pInterface->ARPEntryAgingTimeout,
					(PVOID)pIpEntry
					);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref

				//
				//  Take out the list of pending packets on this Entry
				//
				PacketList = pIpEntry->PacketList;
				pIpEntry->PacketList = (PNDIS_PACKET)NULL;

				IsBroadcast = AA_IS_FLAG_SET(pIpEntry->Flags,
											 AA_IP_ENTRY_ADDR_TYPE_MASK,
											 AA_IP_ENTRY_ADDR_TYPE_NUCAST);

				AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
				AA_RELEASE_IE_LOCK_DPC(pIpEntry);
				AA_RELEASE_IF_LOCK(pInterface);

				//
				//  Send out all these packets
				//
				AtmArpSendPacketListOnAtmEntry(
							pInterface,
							pAtmEntry,
							PacketList,
							IsBroadcast
							);
			}
			else
			{
				//
				//  the IP Entry is gone
				//
				AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
				AA_RELEASE_IF_LOCK(pInterface);
			}
		}
		else
		{
			//
			//  No matching IP Entry
			//
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\arpproc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arpproc.c	- ARP Procedures

Abstract:

	All Client protocol operations related to IP over ATM are here:
	- Registration with an ARP server
	- Resolving an IP address
	- Maintaining the ARP cache

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-17-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'PPRA'


VOID
AtmArpStartRegistration(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Start registering ourselves with the ARP server, on the specified
	interface. The caller is assume to have a lock for the Interface,
	and we release it here.

	We first check if all pre-conditions are satisfied, i.e.:

	1. The Admin State for the interface is UP
	2. The ATM interface is ready
	3. Atleast one IP Address has been configured for the interface
	4. We know the address of atleast one ARP server (SVC environment)

Arguments:

	pInterface		- Pointer to ATMARP Interface structure

Return Value:

	None

--*/
{
	PIP_ADDRESS				pIPAddress;
	BOOLEAN					WasRunning;

	pIPAddress = &pInterface->LocalIPAddress.IPAddress;

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if (pInterface->PVCOnly)
		{
			//
			//  PVCs only: no registration required
			//
			pInterface->State = IF_STATUS_UP;
			pInterface->LastChangeTime = GetTimeTicks();

			AA_SET_FLAG(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_REGISTERED);

			AA_RELEASE_IF_LOCK(pInterface);
#ifdef ATMARP_WMI
			AtmArpWmiSendTCIfIndication(
				pInterface,
                AAGID_QOS_TC_INTERFACE_UP_INDICATION,
				0
				);
#endif
		}
		else
		{
			//
			//  We use SVCs; start registering if we know the
			//  address of atleast one ARP server, and we have
			//  atleast one local IP address to register, and
			//  we haven't registered yet, and we are not in
			//  the process of registering currently.
			//
			if ((pInterface->AtmInterfaceUp) &&
				(pInterface->ArpServerList.ListSize > 0) &&
				(pInterface->NumOfIPAddresses > 0) &&
				(AA_IS_FLAG_SET(
						pInterface->Flags,
						AA_IF_SERVER_STATE_MASK,
						AA_IF_SERVER_NO_CONTACT))
			   )
			{
				AADEBUGP(AAD_INFO, ("Starting registration on IF 0x%x\n", pInterface));
		
				AA_SET_FLAG(
						pInterface->Flags,
						AA_IF_SERVER_STATE_MASK,
						AA_IF_SERVER_REGISTERING);
		
				//
				//  Just in case we have left a timer running, stop it.
				//
				WasRunning = AtmArpStopTimer(
									&(pInterface->Timer),
									pInterface
									);

				AtmArpStartTimer(
						pInterface,
						&(pInterface->Timer),
						AtmArpRegistrationTimeout,
						pInterface->ServerRegistrationTimeout,
						(PVOID)pInterface	// Context
						);

				if (!WasRunning)
				{
					AtmArpReferenceInterface(pInterface);	// Timer ref
				}

				AA_RELEASE_IF_LOCK(pInterface);

				AtmArpSendARPRequest(
						pInterface,
						pIPAddress,		// Source IP is ours
						pIPAddress		// Target IP is ours
						);
			}
			else
			{
				//
				//  We don't have all necessary preconditions for
				//  starting registration.
				//
				AA_RELEASE_IF_LOCK(pInterface);
			}
		}
	}
	else
	{
		//
		//  The Interface is down
		//
		AA_RELEASE_IF_LOCK(pInterface);
	}
}



VOID
AtmArpRegisterOtherIPAddresses(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Register all unregistered IP addresses with the ARP server. The caller
	is assumed to hold a lock for the Interface structure, which will be
	released here.

Arguments:

	pInterface				- Pointer to ARMARP Interface

Return Value:

	None

--*/
{
	PIP_ADDRESS_ENTRY		pIPAddressEntry;
	PIP_ADDRESS				pIPAddressList;	// List of addresses we want to register
	INT						AddressCount;	// Size of above list
	PIP_ADDRESS				pIPAddress; 	// Temp, to walk thru lists


	if (pInterface->NumOfIPAddresses > 1)
	{
		//
		//  First make a copy of all addresses we want to register,
		//  while we hold a lock to the Interface.
		//
		AA_ALLOC_MEM(
				pIPAddressList,
				IP_ADDRESS,
				(pInterface->NumOfIPAddresses)*sizeof(IP_ADDRESS));
	
	
		AddressCount = 0;
		if (pIPAddressList != (PIP_ADDRESS)NULL)
		{
			pIPAddress = pIPAddressList;

			pIPAddressEntry = &(pInterface->LocalIPAddress);
			while (pIPAddressEntry != (PIP_ADDRESS_ENTRY)NULL)
			{
				if (!(pIPAddressEntry->IsRegistered))
				{
					//
					//  This one's not registered yet: copy it into our list.
					//
					AA_COPY_MEM(
						(PUCHAR)pIPAddress,
						(PUCHAR)&(pIPAddressEntry->IPAddress),
						sizeof(IP_ADDRESS));
					pIPAddress++;
					AddressCount++;
				}
				pIPAddressEntry = pIPAddressEntry->pNext;
			}

		}

		AA_RELEASE_IF_LOCK(pInterface);

		pIPAddress = pIPAddressList;
		while (AddressCount-- > 0)
		{
			AADEBUGP(AAD_INFO, ("Registering Other IP Address on IF 0x%x: %d.%d.%d.%d\n",
						pInterface,
						((PUCHAR)pIPAddress)[0],
						((PUCHAR)pIPAddress)[1],
						((PUCHAR)pIPAddress)[2],
						((PUCHAR)pIPAddress)[3]));

			AtmArpSendARPRequest(
						pInterface,
						pIPAddress,		// Source IP is ours
						pIPAddress		// Target IP is ours
						);
			pIPAddress++;
		}

		if (pIPAddressList != (PIP_ADDRESS)NULL)
		{
			AA_FREE_MEM(pIPAddressList);
		}

	}
	else
	{
		//
		//  No additional addresses to register.
		//
		AA_RELEASE_IF_LOCK(pInterface);
	}

}



VOID
AtmArpRetryServerRegistration(
	IN	PATMARP_INTERFACE			pInterface		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Retry server registration. This is called because of a failure to
	register with the server (connection failure, or no response or
    NAK response or invalid response to our registration ARP Request).

    If we have tried this server enough times, we move to the next
    ARP server in our list. Wait for a while before retrying.

Arguments:

	pInterface				- Pointer to ARMARP Interface

Return Value:

	None

--*/
{
	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if (pInterface->RetriesLeft > 0)
		{
			//
			//  We still have retries on this server.
			//
			pInterface->RetriesLeft--;
		}
		else
		{
			//
			//  Out of retries on this server. Pick up the next timer in the
			//  list.
			//
			if (pInterface->pCurrentServer->pNext != (PATMARP_SERVER_ENTRY)NULL)
			{
				pInterface->pCurrentServer = pInterface->pCurrentServer->pNext;
			}
			else
			{
				pInterface->pCurrentServer = pInterface->ArpServerList.pList;
			}

			pInterface->RetriesLeft = pInterface->MaxRegistrationAttempts - 1;
		}

		AA_SET_FLAG(
			pInterface->Flags,
			AA_IF_SERVER_STATE_MASK,
			AA_IF_SERVER_NO_CONTACT);


		//
		//  Wait for a while before initiating another
		//  connection to the server. When the timer elapses,
		//  we will try again.
		//
		AtmArpStartTimer(
					pInterface,
					&(pInterface->Timer),
					AtmArpServerConnectTimeout,
					pInterface->ServerConnectInterval,
					(PVOID)pInterface
					);

		AtmArpReferenceInterface(pInterface);	// Timer ref
	}
	//
	//  else the Interface is going down -- do nothing.
	//

	AA_RELEASE_IF_LOCK(pInterface);
}


VOID
AtmArpHandleServerRegistrationFailure(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT,
	IN	PATMARP_VC					pVc			OPTIONAL
)
/*++

Routine Description:

	Handle a failure in the Registration process. We close the VC to the
	ARP server, if one exists, and wait for a while before starting the
	registration process again.

Arguments:

	pInterface			- Pointer to ATMARP interface
	pVc					- (Optional) pointer to VC to ARP Server.

Return Value:

	None

--*/
{
	BOOLEAN		TimerWasRunning;
	ULONG		rc;			// Ref Count on Interface.

	TimerWasRunning = AtmArpStopTimer(&(pInterface->Timer), pInterface);

	if (TimerWasRunning)
	{
		rc = AtmArpDereferenceInterface(pInterface);	// Timer reference
		AA_ASSERT(rc > 0);
	}

	AtmArpRetryServerRegistration(pInterface);
	//
	//  The IF lock is released within the above.
	//

	if (pVc != NULL_PATMARP_VC)
	{
		//
		//  Tear down this VC (to an ARP server).
		//
		//  NOTE: We do this now even though we called RetryServerRegistration
		//  above because we have the knowledge that the routine above
		//  doesn't really start registration: it only starts a timer
		//  on whose expiry we start registration.
		//
		//  First unlink this VC from the ATM Entry it's linked to.
		//
		AA_ACQUIRE_VC_LOCK(pVc);

		//
		//  Now close the call
		//
		AtmArpCloseCall(pVc);
		//
		//  the VC lock is released above
		//
	}
}



BOOLEAN
AtmArpIsZeroIPAddress(
	IN	UCHAR UNALIGNED *			pIPAddress
)
/*++

Routine Description:

	Check if the given IP address is all zeros.

Arguments:

	pIPAddress					- Pointer to IP address in question

Return Value:

	TRUE if the address is all 0's, FALSE otherwise.

--*/
{
	IP_ADDRESS UNALIGNED *			pIPAddrStruct;

	pIPAddrStruct = (IP_ADDRESS UNALIGNED *)pIPAddress;
	return (BOOLEAN)(*pIPAddrStruct == (IP_ADDRESS)0);
}



BOOLEAN
AtmArpIsLocalIPAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	UCHAR UNALIGNED *			pIPAddress
)
/*++

Routine Description:

	Check if the given IP address is one of those assigned to this
	interface.

Arguments:

	pInterface				- Pointer to Interface structure
	pIPAddress				- Pointer to IP address in question

Return Value:

	TRUE if the IP address is one of ours, FALSE otherwise.

--*/
{
	PIP_ADDRESS_ENTRY				pIPAddrEntry;
	IP_ADDRESS UNALIGNED *			pIPAddrStruct;
	BOOLEAN							IsLocal;

	if (pIPAddress != (PUCHAR)NULL)
	{
		pIPAddrStruct = (IP_ADDRESS UNALIGNED *)pIPAddress;

		AA_ACQUIRE_IF_LOCK(pInterface);

		pIPAddrEntry = &(pInterface->LocalIPAddress);

		IsLocal = FALSE;
		do
		{
			if (pIPAddrEntry->IPAddress == *pIPAddrStruct)
			{
				IsLocal = TRUE;
				break;
			}
			else
			{
				pIPAddrEntry = pIPAddrEntry->pNext;
			}
		}
		while (pIPAddrEntry != (PIP_ADDRESS_ENTRY)NULL);

		AA_RELEASE_IF_LOCK(pInterface);
	}
	else
	{
		IsLocal = FALSE;
	}

	AADEBUGP(AAD_VERY_LOUD, ("IsLocalIP(%d:%d:%d:%d): returning %d\n",
					(IsLocal? pIPAddress[0] : 0),
					(IsLocal? pIPAddress[1] : 0),
					(IsLocal? pIPAddress[2] : 0),
					(IsLocal? pIPAddress[3] : 0),
					IsLocal));
	return (IsLocal);
}



BOOLEAN
AtmArpIsLocalAtmAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR						pAtmAddrString,
	IN	UCHAR						AtmAddrTypeLen
)
/*++

Routine Description:

	Check if the given ATM address (in "packet" format) is the same as
	our local ATM address.

Arguments:

	pInterface		- Pointer to Interface structure for which the check
					  is being made.
	pAtmAddrString	- String of bytes representing an ATM address
	AtmAddrTypeLen	- Type and Length (ARP packet format) of ATM address

Return Value:

	TRUE if the given address matches the local ATM address for the
	specified interface, FALSE otherwise.

--*/
{
	ATM_ADDRESSTYPE	AddressType;
	ULONG			AddressLength;

	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(AtmAddrTypeLen, &AddressType, &AddressLength);

	if ((AddressType == pInterface->LocalAtmAddress.AddressType) &&
		(AddressLength == pInterface->LocalAtmAddress.NumberOfDigits) &&
		(AA_MEM_CMP(
				pAtmAddrString,
				pInterface->LocalAtmAddress.Address,
				AddressLength) == 0)
	   )
	{
		return (TRUE);
	}
	else
	{
		return (FALSE);
	}
}




NDIS_STATUS
AtmArpSendPacketOnAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec	OPTIONAL,
	IN	PATMARP_FLOW_INFO			pFlowInfo	OPTIONAL,
	IN	BOOLEAN						IsBroadcast
)
/*++

Routine Description:

	Send a packet with the specified Filter-Spec and Flow-Spec to
	the ATM address denoted by the ATM Entry. We look for a VC that
	matches the given Specs, and send/queue this packet on the VC.
	If no such VC exists, we make a call with this Flow-Spec.

	NOTE: The caller is assumed to hold a lock to the ATM Entry, which
	we will release here.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	pAtmEntry				- Pointer to ATM Entry on which this packet
							  should be sent
	pNdisPacket				- Packet to be sent
	pFlowSpec				- Flow-Spec for this packet.
	pFilterSpec				- Filter-Spec for this packet.
	pFlowInfo				- Flow to which this packet belongs.
	IsBroadcast				- Is this to a Class-D or broadcast address?

Locks on entry:

Locks on exit:

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;			// VC to send this packet on
	PNDIS_BUFFER			pHeaderBuffer;	// For LLC/SNAP header
	PNDIS_BUFFER			pNdisBuffer;	// First buffer in the IP packet
	NDIS_HANDLE				NdisVcHandle;
	NDIS_STATUS				Status;
	PUCHAR					pHeader;
	AA_HEADER_TYPE			HdrType;

	do
	{
		Status = NDIS_STATUS_SUCCESS;

		//
		// TODO -- the atm entry may not be ACTIVE at this time,
		// you may want to check for this and if so fail the call and free
		// the packet (call AtmArpFreeSendPackets) here itself.
		// As it happens we go on and make a call if possible, etc.
		//

		//  Prepend an LLC/SNAP header if required.
		//
		if (pFlowSpec->Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
		{
			HdrType = (IsBroadcast? AA_HEADER_TYPE_NUNICAST: AA_HEADER_TYPE_UNICAST);

#ifdef BACK_FILL
			//
			//  We look at the first buffer in the IP packet, to see whether
			//  it has space reserved for low-layer headers. If so, we just
			//  use it up. Otherwise, we allocate a header buffer of our own.
			//
			NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
			AA_ASSERT(pNdisBuffer != NULL);
			if (AtmArpDoBackFill && AA_BACK_FILL_POSSIBLE(pNdisBuffer))
			{
				PUCHAR	pArpHeader;
				ULONG	ArpHeaderLength;

				AtmArpBackFillCount++;
				if (HdrType == AA_HEADER_TYPE_UNICAST)
				{
					pArpHeader = (PUCHAR)&AtmArpLlcSnapHeader;
					ArpHeaderLength = sizeof(AtmArpLlcSnapHeader);
				}
#ifdef IPMCAST
				else
				{
					pArpHeader = (PUCHAR)&AtmArpMcType1ShortHeader;
					ArpHeaderLength = sizeof(AtmArpMcType1ShortHeader);
				}
#endif // IPMCAST
				(PUCHAR)pNdisBuffer->MappedSystemVa -= ArpHeaderLength;
				pNdisBuffer->ByteOffset -= ArpHeaderLength;
				pNdisBuffer->ByteCount += ArpHeaderLength;
				pHeader = pNdisBuffer->MappedSystemVa;
				AA_COPY_MEM(pHeader,
							pArpHeader,
							ArpHeaderLength);
			}
			else
			{
				pHeaderBuffer = AtmArpAllocateHeader(pInterface, HdrType, &pHeader);
				if (pHeaderBuffer != (PNDIS_BUFFER)NULL)
				{
					NdisChainBufferAtFront(pNdisPacket, pHeaderBuffer);
				}
				else
				{
					pHeader = NULL;
				}
			}

			if (pHeader != NULL)
			{
#else
			pHeaderBuffer = AtmArpAllocateHeader(pInterface, HdrType, &pHeader);
			if (pHeaderBuffer != (PNDIS_BUFFER)NULL)
			{
				NdisChainBufferAtFront(pNdisPacket, pHeaderBuffer);
#endif // BACK_FILL
#ifdef IPMCAST
				if (HdrType == AA_HEADER_TYPE_NUNICAST)
				{
					PAA_MC_PKT_TYPE1_SHORT_HEADER	pDataHeader;

					//
					//  Fill in our Cluster Member ID
					//
					AAMCDEBUGP(AAD_EXTRA_LOUD+10,
						("(MC)SendPkt: pAtmEntry 0x%x, pHeaderBuffer 0x%x, pHeader 0x%x\n",
								pAtmEntry, pHeaderBuffer, pHeader));

					pDataHeader = (PAA_MC_PKT_TYPE1_SHORT_HEADER)pHeader;
					pDataHeader->cmi = (USHORT)(pInterface->ClusterMemberId);
				}
#endif // IPMCAST
			}
			else
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
				AADEBUGP(AAD_WARNING, ("FAILED TO ALLOCATE HEADER ON IF 0x%x\n",
							pInterface));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}


		//
		//  Search for a VC that has matching flow/filter specs.
		//
		for (pVc = pAtmEntry->pVcList;
			 pVc != NULL_PATMARP_VC;
			 pVc = pVc->pNextVc)
		{
#ifdef GPC
			PVOID		VcFlowHandle;

			VcFlowHandle = pVc->FlowHandle;
#endif // GPC

			if ((!AA_IS_VC_GOING_DOWN(pVc)) &&
				(pVc->FlowSpec.SendPeakBandwidth > 0))
			{
#ifdef GPC
				if (VcFlowHandle == (PVOID)pFlowInfo)
				{
					//
					//  This VC was made for this flow.
					//
					break;
				}

				if (IsBroadcast)
				{
					//
					//  We don't support multiple VCs to a multicast IP
					//  destination. So, stop at the first available VC.
					//
					break;
				}

				//
				//  If this VC is associated with a flow already, don't
				//  send traffic belonging to another flow (explicit or
				//  unclassified best effort) on it.
				//
				if (VcFlowHandle != NULL)
				{
					continue;
				}
#endif // GPC
				if ((pFilterSpec == (PATMARP_FILTER_SPEC)NULL) ||
						AA_FILTER_SPEC_MATCH(pInterface, pFilterSpec, &(pVc->FilterSpec)))
				{
					if (AA_FLOW_SPEC_MATCH(pInterface, pFlowSpec, &(pVc->FlowSpec)))
					{
						break;
					}
				}
			}

			AADEBUGP(AAD_LOUD,
				("pVc %x did not match pkt, Vc has VcHandle %x, SendPeak %d, SendMaxSize %d\n",
						pVc,
						pVc->NdisVcHandle,
						pVc->FlowSpec.SendPeakBandwidth,
						pVc->FlowSpec.SendMaxSize));

			AADEBUGP(AAD_LOUD,
				("Target FlowSpec %x has SendPeak %d, SendMaxSize %d\n",
					pFlowSpec,
					pFlowSpec->SendPeakBandwidth,
					pFlowSpec->SendMaxSize));
		}

		if (pVc != NULL_PATMARP_VC)
		{
			//
			//  Found a VC that matches this packet's requirements.
			//
			AA_ACQUIRE_VC_LOCK_DPC(pVc);

#ifdef GPC
			//
			//  See if the VC and the Flow are unassociated. If so, link
			//  together the VC and the Flow, to speed up future packets.
			//  Take care not to reassociate a VC that's just been unlinked
			//  from a flow.
			//
			if ((pFlowInfo != NULL) &&
				(pVc->FlowHandle == NULL) &&
				(!AA_IS_FLAG_SET(
							pVc->Flags,
							AA_VC_GPC_MASK,
							AA_VC_GPC_IS_UNLINKED_FROM_FLOW))
			   )
			{
				if (NULL == InterlockedCompareExchangePointer(
										&(pFlowInfo->VcContext),
										pVc,
										NULL
										))
				{
					AADEBUGP( AAD_LOUD,
						 ("SendPktOnAtmEntry: linking VC x%x and FlowInfo x%x\n",
							pVc, pFlowInfo));
					pVc->FlowHandle = (PVOID)pFlowInfo;
					AtmArpReferenceVc(pVc);	// GPC FlowInfo ref
				}
				else
				{
					//
					// We couldn't associate the vc with the flow, so we need
					// to enable the ageing timer for this vc, because we'll
					// never get notified when the flow is removed/modified.
					//
					if (!AA_IS_TIMER_ACTIVE(&(pVc->Timer)))
					{
						AADEBUGP( AAD_INFO,
						 ("SendPktOnAtmEntry: Enabling ageing timer on VC x%x "
						  "because we could not associate with FlowInfo x%x\n",
							pVc, pFlowInfo));
						AtmArpStartTimer(
								pVc->pInterface,
								&(pVc->Timer),
								AtmArpVcAgingTimeout,
								pInterface->DefaultFlowSpec.AgingTime,
								(PVOID)pVc
								);
		
						AtmArpReferenceVc(pVc);	// GPC Flow remove decay timer ref
					}
				}
			}
#endif // GPC

			if (AA_IS_FLAG_SET(
						pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE))
			{
#ifdef VC_REFS_ON_SENDS
				AtmArpReferenceVc(pVc);	// SendPacketOnAtmEntry
#endif // VC_REFS_ON_SENDS

				pVc->OutstandingSends++;	// SendPacketOnAtmEntry

				NdisVcHandle = pVc->NdisVcHandle;
				AtmArpRefreshTimer(&(pVc->Timer));
			}
			else
			{
				AtmArpQueuePacketOnVc(pVc, pNdisPacket);
				NdisVcHandle = NULL;	// to signify we are queueing this packet
			}

			AA_RELEASE_VC_LOCK_DPC(pVc);

			AA_RELEASE_AE_LOCK(pAtmEntry);

			if (NdisVcHandle != NULL)
			{
				//
				//  A call is active on this VC, so send the packet.
				//
#if DBG
				if (AaDataDebugLevel & (AAD_DATA_OUT))
				{
					AADEBUGP(AAD_FATAL,
						("Will send Pkt %x on VC %x, Handle %x, sendBW %d, sendMax %d\n",
								pNdisPacket,
								pVc,
								NdisVcHandle,
								pVc->FlowSpec.SendPeakBandwidth,
								pVc->FlowSpec.SendMaxSize));
				}
#endif

				AADEBUGP(AAD_EXTRA_LOUD+50,
					("SendPktOnAtmEntry: will send Pkt 0x%x on VC 0x%x, VcHandle 0x%x\n",
						pNdisPacket,
						pVc,
						NdisVcHandle));

#ifdef PERF
				AadLogSendUpdate(pNdisPacket);
#endif // PERF
				NDIS_CO_SEND_PACKETS(
						NdisVcHandle,
						&pNdisPacket,
						1
						);
			}
			else
			{
				//
				//  The packet would have been queued.
				//
			}

			Status = NDIS_STATUS_PENDING;
		}
		else
		{
			//
			//  No matching VC exists; create a new one.
			//
#ifdef IPMCAST
			if (AA_IS_FLAG_SET(pAtmEntry->Flags,
								AA_ATM_ENTRY_TYPE_MASK,
								AA_ATM_ENTRY_TYPE_UCAST))
			{
				Status = AtmArpMakeCall(
									pInterface,
									pAtmEntry,
									pFlowSpec,
									pNdisPacket
									);
				//
				//  AE lock is released within the above.
				//
			}
			else
			{
				//
				//  Multicast ATM Entry: we shouldn't be here, ideally..
				//
				AA_RELEASE_AE_LOCK(pAtmEntry);

				AAMCDEBUGP(AAD_WARNING,
					("SendPacket: pAtmEntry 0x%x, Flags 0x%x, dropping pkt 0x%x\n",
								pAtmEntry, pAtmEntry->Flags, pNdisPacket));

				AA_SET_NEXT_PACKET(pNdisPacket, NULL);
				AtmArpFreeSendPackets(
								pInterface,
								pNdisPacket,
								TRUE		// header present
								);
			}
#else
			Status = AtmArpMakeCall(
								pInterface,
								pAtmEntry,
								pFlowSpec,
								pNdisPacket
								);
			//
			//  The ATM Entry lock is released within the above.
			//
#endif // IPMCAST
			Status = NDIS_STATUS_PENDING;
		}
		break;
	}
	while (FALSE);

	return (Status);
}




VOID
AtmArpQueuePacketOnVc(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Queue a packet on the VC's transmit queue.

Arguments:

	pVc					- Pointer to ATMARP VC
	pNdisPacket			- The packet to be queued.

Return Value:

	None

--*/
{
	PNDIS_PACKET		pPrevPacket;

	AADEBUGP(AAD_EXTRA_LOUD, ("Queueing Pkt 0x%x on VC 0x%x\n",
				pNdisPacket, pVc));

	if (pVc->PacketList == (PNDIS_PACKET)NULL)
	{
		//
		//  No packets on this VC.
		//
		pVc->PacketList = pNdisPacket;
	}
	else
	{
		//
		//  Go to the end of the packet list on this VC.
		//
		pPrevPacket = pVc->PacketList;
		while (AA_GET_NEXT_PACKET(pPrevPacket) != (PNDIS_PACKET)NULL)
		{
			pPrevPacket = AA_GET_NEXT_PACKET(pPrevPacket);
		}

		//
		//  Found the last packet in the list. Chain this packet
		//  to it.
		//
		AA_SET_NEXT_PACKET(pPrevPacket, pNdisPacket);
	}

	AA_SET_NEXT_PACKET(pNdisPacket, NULL);
}


VOID
AtmArpStartSendsOnVc(
	IN	PATMARP_VC					pVc		LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Send all packets queued on a VC. It is assumed that there is
	a call active on the VC, and the Interface state is OK.

Arguments:

	pVc						- Pointer to ATMARP VC

Locks on entry:

	VC Lock.

Locks on exit:

	None

Return Value:

	None

--*/
{
	PNDIS_PACKET			pNdisPacket;
	PNDIS_PACKET			pNextNdisPacket;
	NDIS_HANDLE				NdisVcHandle;
	ULONG					rc;				// Ref Count to VC

	//
	//  Remove the entire list of packets queued on the VC.
	//
	pNdisPacket = pVc->PacketList;
	pVc->PacketList = (PNDIS_PACKET)NULL;


#ifdef VC_REFS_ON_SENDS
	//
	//  Reference the VC for all these packets.
	//
	{
		PNDIS_PACKET		pPacket;
		
		for (pPacket = pNdisPacket;
			 pPacket != NULL;
			 pPacket = AA_GET_NEXT_PACKET(pPacket))
		{
			AtmArpReferenceVc(pVc);	// StartSendsOnVc
			pVc->OutstandingSends++;// StartSendsOnVc
		}
	}
#else

	{
		PNDIS_PACKET		pPacket;
		
		for (pPacket = pNdisPacket;
			 pPacket != NULL;
			 pPacket = AA_GET_NEXT_PACKET(pPacket))
		{
			pVc->OutstandingSends++;// StartSendsOnVc (!VC_REFS_ON_SENDS)
		}
	}
#endif // VC_REFS_ON_SENDS

	AtmArpRefreshTimer(&(pVc->Timer));

	NdisVcHandle = pVc->NdisVcHandle;

	//
	//  We have got all that we need from the VC.
	//
	AA_RELEASE_VC_LOCK(pVc);

	while (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		pNextNdisPacket = AA_GET_NEXT_PACKET(pNdisPacket);
		AA_SET_NEXT_PACKET(pNdisPacket, NULL);

		AADEBUGP(AAD_EXTRA_LOUD+10, ("StartSendsOnVc: pVc 0x%x, Pkt 0x%x\n",
						pVc, pNdisPacket));

#ifdef PERF
		AadLogSendUpdate(pNdisPacket);
#endif // PERF
		NDIS_CO_SEND_PACKETS(
				NdisVcHandle,
				&pNdisPacket,
				1
				);
		
		pNdisPacket = pNextNdisPacket;
	}
}



VOID
AtmArpSendPacketListOnAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PNDIS_PACKET				pPacketList,
	IN	BOOLEAN						IsBroadcast
)
/*++

Routine Description:

	Send a list of packets towards a destination identified by an
	ATM Entry.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	pAtmEntry				- ATM Entry on which the packets are to be sent
	pPacketList				- List of packets to be sent.
	IsBroadcast				- Are these directed to Class D/broadcast addresses?

Return Value:

	None

--*/
{
	PATMARP_FLOW_INFO			pFlowInfo;
	PATMARP_FLOW_SPEC			pFlowSpec;
	PATMARP_FILTER_SPEC			pFilterSpec;
	PNDIS_PACKET				pNdisPacket;
	PNDIS_PACKET				pNextNdisPacket;
	NDIS_STATUS					Status;


	for (pNdisPacket = pPacketList;
			pNdisPacket != (PNDIS_PACKET)NULL;
			pNdisPacket = pNextNdisPacket)
	{
		pNextNdisPacket = AA_GET_NEXT_PACKET(pNdisPacket);
		AA_SET_NEXT_PACKET(pNdisPacket, NULL);

		//
		//  Get the Filter and Flow specs for this packet
		//
		AA_GET_PACKET_SPECS(pInterface, pNdisPacket, &pFlowInfo, &pFlowSpec, &pFilterSpec);

		AADEBUGP(AAD_EXTRA_LOUD+10, ("PktListOnAtmEntry: AtmEntry 0x%x, Pkt 0x%x\n",
					pAtmEntry, pNdisPacket));

		//
		//  Send it off
		//
		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		Status = AtmArpSendPacketOnAtmEntry(
							pInterface,
							pAtmEntry,
							pNdisPacket,
							pFlowSpec,
							pFilterSpec,
							pFlowInfo,
							IsBroadcast
							);
		//
		//  AE lock is released within the above.
		//
		if ((Status != NDIS_STATUS_PENDING) &&
			(Status != NDIS_STATUS_SUCCESS))
		{
			AADEBUGP(AAD_INFO, ("PktListOnAtmEntry: pIf %x, Pkt %x, Send failure %x\n",
						pInterface, pNdisPacket, Status));
			AtmArpFreeSendPackets(pInterface, pNdisPacket, FALSE);
		}
	}

	return;
}


PATMARP_IP_ENTRY
AtmArpLearnIPToAtm(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS UNALIGNED *		pIPAddress,
	IN	UCHAR						AtmAddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmAddress,
	IN	UCHAR						AtmSubaddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmSubaddress,
	IN	BOOLEAN						IsStaticEntry
)
/*++

Routine Description:

	Learn an IP address to ATM address mapping. This is normally
	called when we receive an ARP reply from the ARP server.
	It may also be called to set up a static mapping.

	We take care of the case where either the IP address or the
	ATM address (or both) may already exist in the ARP Table: we
	only create the entries that are not present. For example, it
	is possible for multiple IP addresses to map to the same ATM
	address -- in this case, we might find an existing ATM entry
	for a new IP entry.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	pIPAddress				- IP address
	AtmAddressTypeLength	- Type+Length (ARP packet format) for ATM address
	pAtmAddress				- ATM Number
	AtmSubaddressTypeLength	- Type+Length (ARP packet format) for ATM subaddress
	pAtmSubaddress			- ATM Subaddress
	IsStaticEntry			- Is this a static mapping?

Return Value:

	A pointer to the IP Entry that was learned/refreshed.

--*/
{
	PATMARP_IP_ENTRY			pIpEntry;	// Entry for this IP Address
	PATMARP_ATM_ENTRY			pAtmEntry;	// Entry for this ATM Address
	NDIS_STATUS					Status;
	BOOLEAN						TimerWasRunning;	// Was a timer running on IP Entry?
	ULONG						rc;			// Ref Count
	PNDIS_PACKET				pPacketList;// List of queued packets, if any
	BOOLEAN						IsBroadcast;// Is the IP address broadcast/multicast?
#ifdef CUBDD
	SINGLE_LIST_ENTRY			PendingIrpList;
	PATM_ADDRESS				pResolvedAddress;
#endif // CUBDD

	AADEBUGP(AAD_LOUD, ("LearnIPToAtm: pIf 0x%x, IP Addr: %d:%d:%d:%d, ATM Addr:\n",
						pInterface,
						*((PUCHAR)pIPAddress),
						*((PUCHAR)pIPAddress+1),
						*((PUCHAR)pIPAddress+2),
						*((PUCHAR)pIPAddress+3)));

	AADEBUGPDUMP(AAD_LOUD, pAtmAddress, (AtmAddressTypeLength & ~AA_PKT_ATM_ADDRESS_BIT));

	//
	//  Initialize
	//
	Status = NDIS_STATUS_SUCCESS;
	pPacketList = (PNDIS_PACKET)NULL;
	IsBroadcast = FALSE;
	pIpEntry = NULL_PATMARP_IP_ENTRY;
#ifdef CUBDD
	PendingIrpList.Next = (PSINGLE_LIST_ENTRY)NULL;
#endif // CUBDD

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	//
	//  Get an ATM Entry. AtmArpSearchForAtmAddress addrefs
	//  the entry, so be sure to dereference it if
	//  we're not going to be using it.
	//
	pAtmEntry = AtmArpSearchForAtmAddress(
							pInterface,
							AtmAddressTypeLength,
							pAtmAddress,
							AtmSubaddressTypeLength,
							pAtmSubaddress,
							AE_REFTYPE_IE,
							TRUE		// Create new entry if not found
							);

	if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AADEBUGPMAP(AAD_INFO, "Learnt", pIPAddress, &pAtmEntry->ATMAddress);

		//
		//  Now get an IP Address Entry. AtmArpSeachForIPAddress addrefs
		//  the entry, so be sure to deref it if we're not going to be
		// 	using it.
		//
		pIpEntry = AtmArpSearchForIPAddress(
							pInterface,
							pIPAddress,
							IE_REFTYPE_AE,
							FALSE,		// this isn't multicast/broadcast
							TRUE		// Create new entry if not found
							);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			//
			//  Got both entries.
			//
			//  Check for conflict: if the IP Entry existed before, see if
			//  it is linked to a different ATM Entry. If so, we have a new
			//  mapping that violates an existing mapping. We discard this
			//  new information.
			//
			if (pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY)
			{
				if (pIpEntry->pAtmEntry != pAtmEntry)
				{
					AADEBUGP(AAD_ERROR,
					("IP Entry 0x%x linked to ATM Entry 0x%x, new ATM Entry 0x%x\n",
							pIpEntry, pIpEntry->pAtmEntry, pAtmEntry));
	
					Status = NDIS_STATUS_FAILURE;
				}
				else
				{
					//
					//  An existing mapping has been reconfirmed.
					//
					AADEBUGP(AAD_INFO,
						("Revalidated IP Entry 0x%x, Addr: %d.%d.%d.%d, PktList 0x%x\n",
							pIpEntry,
							((PUCHAR)pIPAddress)[0],
							((PUCHAR)pIPAddress)[1],
							((PUCHAR)pIPAddress)[2],
							((PUCHAR)pIPAddress)[3],
							pIpEntry->PacketList
						));

#ifdef CUBDD
					//
					//  Remove the list of IRPs pending on this IP Entry, if any.
					//
					PendingIrpList = pIpEntry->PendingIrpList;
					pIpEntry->PendingIrpList.Next = (PSINGLE_LIST_ENTRY)NULL;
#endif // CUBDD
					//
					//  Update IP Entry state.
					//
					AA_SET_FLAG(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_RESOLVED);
					
					//
					//  Remove the list of packets queued on this entry.
					//
					pPacketList = pIpEntry->PacketList;
					pIpEntry->PacketList = (PNDIS_PACKET)NULL;


					if (pPacketList)
					{
						//
						// We'll be sending out these packets on the
						// atm entry, so better put a tempref on the atm
						// entry now. It is derefed when the packet
						// list is finished being sent on the atm entry.
						//
						AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
						AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: Pkt list.
						AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
					}

					//
					//  We will start the IP Entry aging timer on this
					//  entry.
					//

					//
					//  Stop the Address resolution timer running here
					//
					TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);

					if (TimerWasRunning)
					{
						rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER); // timer ref.
						AA_ASSERT(rc != 0);
					}

					//
					//  Start the Aging timer.
					//
					AtmArpStartTimer(
						pInterface,
						&(pIpEntry->Timer),
						AtmArpIPEntryAgingTimeout,
						pInterface->ARPEntryAgingTimeout,
						(PVOID)pIpEntry
						);

					//
					// Altough we got the initial ref in SearchForIPAddress
					// for IE_REFTYPE_AE, we're actually using it for
					// the timer reference. So we need to switch the reftype
					// here...
					//
					// This reftype stuff is just for tracking purposes.
					//
					AA_SWITCH_IE_REFTYPE(
						pIpEntry,
						IE_REFTYPE_AE,
					 	IE_REFTYPE_TIMER
						);

				}
			}
			else
			{
				//
				//  This IP Entry wasn't mapped to an ATM Entry previously.
				//  Link entries together: first, make the IP entry point
				//  to this ATM Entry.
				//
				AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);

				//
				// Check if this is still a valid entry....
				//
				if (AA_IS_FLAG_SET(
							pAtmEntry->Flags,
							AA_ATM_ENTRY_STATE_MASK,
							AA_ATM_ENTRY_CLOSING))
				{
					AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
					Status = NDIS_STATUS_FAILURE;
				}
				else
				{

					pIpEntry->pAtmEntry = pAtmEntry;
	
					AA_SET_FLAG(
							pAtmEntry->Flags,
							AA_ATM_ENTRY_STATE_MASK,
							AA_ATM_ENTRY_ACTIVE);
	
					//
					//  Add the IP Entry to the ATM Entry's list of IP Entries
					//  (multiple IP entries could point to the same ATM Entry).
					//
					pIpEntry->pNextToAtm = pAtmEntry->pIpEntryList;
					pAtmEntry->pIpEntryList = pIpEntry;

					//
					//  Remove the list of packets queued on this IP entry.
					//
					pPacketList = pIpEntry->PacketList;
					pIpEntry->PacketList = (PNDIS_PACKET)NULL;

					if (pPacketList)
					{
						AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);// Temp ref: Pkt list.
					}
	
					AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
	
	
					//
					//  Update IP Entry state.
					//
					AA_SET_FLAG(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_RESOLVED);
	
					TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
					if (TimerWasRunning)
					{
						ULONG		rc;
						rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer reference
						AA_ASSERT(rc > 0);
					}
	
	
					IsBroadcast = AA_IS_FLAG_SET(pIpEntry->Flags,
 												AA_IP_ENTRY_ADDR_TYPE_MASK,
 												AA_IP_ENTRY_ADDR_TYPE_NUCAST);
	#ifdef CUBDD
					//
					//  Remove the list of IRPs pending on this IP Entry, if any.
					//
					PendingIrpList = pIpEntry->PendingIrpList;
					pIpEntry->PendingIrpList.Next = (PSINGLE_LIST_ENTRY)NULL;
	#endif // CUBDD
	
					if (IsStaticEntry)
					{
						pIpEntry->Flags |= AA_IP_ENTRY_IS_STATIC;
	
					}
					else
					{
						//
						//  Start the aging timer on this IP Entry.
						//
						AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpIPEntryAgingTimeout,
							pInterface->ARPEntryAgingTimeout,
							(PVOID)pIpEntry
							);

						AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer reference
	
					}
				}
			}

			AA_RELEASE_IE_LOCK_DPC(pIpEntry);
		}
		else
		{
			//
			//  Failed to locate/allocate IP Entry
			//
			Status = NDIS_STATUS_RESOURCES;
		}
	}
	else
	{
		//
		//  Failed to locate/allocate ATM Entry
		//
		Status = NDIS_STATUS_RESOURCES;
	}

	AA_RELEASE_IF_TABLE_LOCK(pInterface);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		//
		//  If we have any queued packets to send, send them now.
		//
		if (pPacketList != (PNDIS_PACKET)NULL)
		{
			AtmArpSendPacketListOnAtmEntry(
					pInterface,
					pAtmEntry,
					pPacketList,
					IsBroadcast
					);
			
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP); // Send pkt list.
			if (rc>0)
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
			}
		}
	}
	else
	{
		if (pIpEntry)
		{
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // LearnIPAtm
			if (rc>0)
			{
				AA_RELEASE_IE_LOCK(pIpEntry);
			}
		}

		if (pAtmEntry)
		{
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_IE); // LearnIPAtm
			if (rc>0)
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
			}
		}

		//
		//  Prepare the return value.
		//
		pIpEntry = NULL_PATMARP_IP_ENTRY;
	}

#if !BINARY_COMPATIBLE
#ifdef CUBDD
	if (PendingIrpList.Next != (PSINGLE_LIST_ENTRY)NULL)
	{
		AA_ALLOC_MEM(pResolvedAddress, ATM_ADDRESS, sizeof(ATM_ADDRESS));
		if (pResolvedAddress != (PATM_ADDRESS)NULL)
		{
			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
					AtmAddressTypeLength,
					&(pResolvedAddress->AddressType),
					&(pResolvedAddress->NumberOfDigits));
			AA_COPY_MEM(
					pResolvedAddress->Address,
					pAtmAddress,
					ATM_ADDRESS_LENGTH);
		}

		AtmArpCompleteArpIrpList(
					PendingIrpList,
					pResolvedAddress
					);
	}
#endif // CUBDD
#endif // !BINARY_COMPATIBLE

	return (pIpEntry);
}



NDIS_STATUS
AtmArpQueuePacketOnIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Queue a packet on an unresolved IP Entry, unless one of the following
	conditions holds:

	- We recently got an ARP NAK while trying to resolve this entry. In this
	  case, there is no point in queueing up this packet and sending another
	  ARP Request, because we might immediately get back another NAK.

	If we did queue this packet, we check if address resolution is in progress
	on this entry. If not, start it.

Arguments:

	pIpEntry					- Pointer to ATMARP IP Entry
	pNdisPacket					- Packet to be queued

Locks on entry:

	IP Entry

Locks on exit:

	None

Return Value:

	NDIS_STATUS_PENDING if we did queue the packet, NDIS_STATUS_FAILURE
	otherwise.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PNDIS_PACKET			pPrevPacket;	// For queueing this packet
	NDIS_STATUS				Status;			// Return value
	IP_ADDRESS				SrcIPAddress;	// For ARP Request, if required
	IP_ADDRESS				DstIPAddress;	// For ARP Request, if required


	pInterface = pIpEntry->pInterface;

	//
	//  Check if this IP address has experienced an ARP NAK recently.
	//  If not, we queue this packet, else we discard it.
	//
	//  We also make sure that the ip entry is in ARP table (it had better be,
	//  but it's possible that we enter this code path just after the ip
	// entry has been).
	//
	if (!AA_IS_FLAG_SET(pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_SEEN_NAK)
		&& AA_IE_IS_ALIVE(pIpEntry))
	{
		//
		//  Queue the packet.
		//
		if (pIpEntry->PacketList == (PNDIS_PACKET)NULL)
		{
			//
			//  No packets on this IP Entry.
			//
			pIpEntry->PacketList = pNdisPacket;
		}
		else
		{
			//
			//  Go to the end of the packet list on this IP Entry.
			//
			pPrevPacket = pIpEntry->PacketList;
			while (AA_GET_NEXT_PACKET(pPrevPacket) != (PNDIS_PACKET)NULL)
			{
				pPrevPacket = AA_GET_NEXT_PACKET(pPrevPacket);
			}
	
			//
			//  Found the last packet in the list. Chain this packet
			//  to it.
			//
			AA_SET_NEXT_PACKET(pPrevPacket, pNdisPacket);
		}
		AA_SET_NEXT_PACKET(pNdisPacket, NULL);

		Status = NDIS_STATUS_PENDING;

		//
		//  If needed, start resolving this IP address.
		//
		AtmArpResolveIpEntry(pIpEntry);
		//
		//  The IE Lock is released within the above.
		//
	}
	else
	{
		//
		//  We have seen an ARP NAK for this IP address recently, or
		//  this pIpEntry is not alive.
		//  Drop this packet.
		//
		AA_RELEASE_IE_LOCK(pIpEntry);
		Status = NDIS_STATUS_FAILURE;
	}

	return (Status);
}

BOOLEAN
AtmArpAtmEntryIsReallyClosing(
	PATMARP_ATM_ENTRY			pAtmEntry
)
{
	BOOLEAN fRet = FALSE;

	if (AA_IS_FLAG_SET(
				pAtmEntry->Flags,
				AA_ATM_ENTRY_STATE_MASK,
				AA_ATM_ENTRY_CLOSING))
	{
		AADEBUGP(AAD_INFO, ("IsReallyClosing -- ENTRY (0x%08lx) is CLOSING\n",
			pAtmEntry));

		//
		// Decide whether we want to clear the CLOSING state here..
		// We clear the closing state because we saw a case where the
		// entry was permanently in the closing state (a ref count problem).
		// So we will clear this state if it is basically an idle entry,
		// so that it may be reused.
		//

		if (   pAtmEntry->pIpEntryList == NULL
			&& pAtmEntry->pVcList == NULL
			&& (   pAtmEntry->pMcAtmInfo == NULL
			    || pAtmEntry->pMcAtmInfo->pMcAtmMigrateList == NULL))
		{
			AADEBUGP(AAD_INFO,
 			("IsReallyClosing -- ENTRY (0x%08lx) CLEARING CLOSING STATE\n",
			pAtmEntry));
			AA_SET_FLAG(
					pAtmEntry->Flags,
					AA_ATM_ENTRY_STATE_MASK,
					AA_ATM_ENTRY_ACTIVE);
		}
		else
		{
			fRet = TRUE;
		}
	}

	return fRet;
}

PATMARP_ATM_ENTRY
AtmArpSearchForAtmAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	UCHAR						AtmAddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmAddress,
	IN	UCHAR						AtmSubaddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmSubaddress,
	IN	AE_REFTYPE					RefType,
	IN	BOOLEAN						CreateNew
)
/*++

Routine Description:

	Search for an ATM Entry that matches the given ATM number+subaddress.
	Optionally, create one if there is no match.

	The caller is assumed to hold a lock to the IF Table.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	AtmAddressTypeLength	- Type+Length (ARP packet format) for the ATM number
	pAtmAddress				- ATM Number
	AtmSubaddressTypeLength	- Type+Length (ARP packet format) for the ATM subaddress
	pAtmSubaddress			- ATM Subaddress
	CreateNew				- Do we create a new entry if we don't find one?
	RefType					- Type of reference

Return Value:

	Pointer to a matching ATM Entry if found (or created anew).

--*/
{
	PATMARP_ATM_ENTRY			pAtmEntry;
	BOOLEAN						Found;

	ATM_ADDRESSTYPE				AddressType;
	ULONG						AddressLen;
	ATM_ADDRESSTYPE				SubaddressType;
	ULONG						SubaddressLen;


	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(AtmAddressTypeLength, &AddressType, &AddressLen);
	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(AtmSubaddressTypeLength, &SubaddressType, &SubaddressLen);

	AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);


	//
	//  Go through the list of ATM Entries on this interface, provided the
	//  list is "up." The list is not up when shutting down the interface.
	//

	Found = FALSE;

	if (pInterface->AtmEntryListUp)
	{
		pAtmEntry = pInterface->pAtmEntryList;
	}
	else
	{
		pAtmEntry = NULL;
	}

	for (; pAtmEntry != NULL_PATMARP_ATM_ENTRY; pAtmEntry = pAtmEntry->pNext)
	{
		//
		//  Compare the ATM Addresses
		//
		if ((AddressType == pAtmEntry->ATMAddress.AddressType) &&
			(AddressLen == pAtmEntry->ATMAddress.NumberOfDigits) &&
			(AA_MEM_CMP(pAtmAddress, pAtmEntry->ATMAddress.Address, AddressLen) == 0))
		{
			//
			//  Compare the Subaddress parts
			//
			if ((SubaddressType == pAtmEntry->ATMSubaddress.AddressType) &&
				(SubaddressLen == pAtmEntry->ATMSubaddress.NumberOfDigits) &&
				(AA_MEM_CMP(pAtmSubaddress, pAtmEntry->ATMSubaddress.Address, SubaddressLen) == 0))
			{
				Found = TRUE;

				//
				// WARNING: AtmArpAtmEntryIsReallyClosing may clear the
				// CLOSING state (if the entry is basically idle) --
				// see comments in that function.
				//
				if (AtmArpAtmEntryIsReallyClosing(pAtmEntry))
				{
					//
					// We don't allow creating a new entry in this case...
					//
					CreateNew = FALSE;
					pAtmEntry = NULL;
					Found = FALSE;
				}


				break;
			}
		}
	}

	if (!Found && CreateNew && pInterface->AtmEntryListUp)
	{
		pAtmEntry = AtmArpAllocateAtmEntry(
							pInterface,
							FALSE		// Not multicast
							);

		if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
			//
			//  Fill in this new entry.
			//
			pAtmEntry->Flags = AA_ATM_ENTRY_ACTIVE;

			//
			//  The ATM Address.
			//
			pAtmEntry->ATMAddress.AddressType = AddressType;
			pAtmEntry->ATMAddress.NumberOfDigits = AddressLen;
			AA_COPY_MEM(pAtmEntry->ATMAddress.Address,
						pAtmAddress,
						AddressLen);
			
			//
			//  The ATM Subaddress.
			//
			pAtmEntry->ATMSubaddress.AddressType = SubaddressType;
			pAtmEntry->ATMSubaddress.NumberOfDigits = SubaddressLen;
			AA_COPY_MEM(pAtmEntry->ATMSubaddress.Address,
						pAtmSubaddress,
						SubaddressLen);

			//
			//  Link in this entry to the Interface
			//
			pAtmEntry->pNext = pInterface->pAtmEntryList;
			pInterface->pAtmEntryList = pAtmEntry;
		}
	}

	if (pAtmEntry)
	{
		AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
		AA_REF_AE(pAtmEntry,RefType);	//  AtmArpSearchForAtmAddress
		AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
	}

	AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);

	AADEBUGP(AAD_VERY_LOUD, ("SearchForAtm: returning (%s) ATM Entry 0x%x for addr:\n",
				(Found? "Old": "New"), pAtmEntry));
	AADEBUGPDUMP(AAD_VERY_LOUD, pAtmAddress, AddressLen);
	return (pAtmEntry);
}



PATMARP_IP_ENTRY
AtmArpSearchForIPAddress(
	PATMARP_INTERFACE				pInterface,
	IP_ADDRESS UNALIGNED *			pIPAddress,
	IE_REFTYPE						RefType,
	BOOLEAN							IsMulticast,
	BOOLEAN							CreateNew
)
/*++

Routine Description:

	Search for an IP Address in the ARP Table. Optionally, create one
	if a match is not found.

	The caller is assumed to hold a lock to the IF Table.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	pIPAddress				- what we are looking for
	IsMulticast				- Is this IP address broadcast or multicast?
	RefType					- Type of reference to use when we addref the entry.
	CreateNew				- Should a new entry be created if no match?

Return Value:

	Pointer to a matching IP Entry if found (or created anew).

--*/
{
	ULONG					HashIndex;
	PATMARP_IP_ENTRY		pIpEntry;
	BOOLEAN					Found;
#ifdef IPMCAST
	PATMARP_ATM_ENTRY		pAtmEntry;
	IP_ADDRESS				IPAddressValue;
	PATMARP_IP_ENTRY *		ppIpEntry;
#endif // IPMCAST

	HashIndex = ATMARP_HASH(*pIPAddress);
	Found = FALSE;

	pIpEntry = pInterface->pArpTable[HashIndex];

	//
	//  Go through the addresses in this hash list.
	//
	while (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		if (IP_ADDR_EQUAL(pIpEntry->IPAddress, *pIPAddress))
		{
			Found = TRUE;
			break;
		}
		pIpEntry = pIpEntry->pNextEntry;
	}

	if (!Found && CreateNew && pInterface->ArpTableUp)
	{
		do
		{
			pIpEntry = AtmArpAllocateIPEntry(pInterface);

			if (pIpEntry == NULL_PATMARP_IP_ENTRY)
			{
				break;
			}
#ifdef IPMCAST
			if (IsMulticast)
			{
				AAMCDEBUGP(AAD_INFO,
				("SearchForIpAddr: Creating new MC IP Entry 0x%x for Addr %d.%d.%d.%d\n",
							pIpEntry,
							((PUCHAR)pIPAddress)[0],
							((PUCHAR)pIPAddress)[1],
							((PUCHAR)pIPAddress)[2],
							((PUCHAR)pIPAddress)[3]));

				pIpEntry->Flags |= AA_IP_ENTRY_ADDR_TYPE_NUCAST;


				//
				//  Also link this IP Entry into the per-Interface list
				//  of multicast addresses. This is sorted in ascending
				//  order of "IP Address value", to help processing
				//  <Min, Max> pairs of addresses in JOIN/LEAVE messages.
				//
				IPAddressValue = NET_LONG(*pIPAddress);

				//
				//  Find the place to insert this entry at.
				//
				for (ppIpEntry = &(pInterface->pMcSendList);
 					 *ppIpEntry != NULL_PATMARP_IP_ENTRY;
 					 ppIpEntry = &((*ppIpEntry)->pNextMcEntry))
				{
					if (NET_LONG((*ppIpEntry)->IPAddress) > IPAddressValue)
					{
						//
						//  Found it.
						//
						break;
					}
				}
				pIpEntry->pNextMcEntry = *ppIpEntry;
				*ppIpEntry = pIpEntry;
			}
			else
			{
				AAMCDEBUGP(AAD_INFO,
				("SearchForIpAddr: Creating new UNI IP Entry 0x%x for Addr %d.%d.%d.%d\n",
							pIpEntry,
							((PUCHAR)pIPAddress)[0],
							((PUCHAR)pIPAddress)[1],
							((PUCHAR)pIPAddress)[2],
							((PUCHAR)pIPAddress)[3]));
			}

#endif // IPMCAST
			//
			//  Fill in the rest of the IP entry.
			//
			pIpEntry->IPAddress = *pIPAddress;

			//
			// This signifies that it is in the arp table.
			//
			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_IDLE2);

			AA_REF_IE(pIpEntry, IE_REFTYPE_TABLE);		// ARP Table linkage

			//
			//  Link it to the hash table.
			//
			pIpEntry->pNextEntry = pInterface->pArpTable[HashIndex];
			pInterface->pArpTable[HashIndex] = pIpEntry;
			pInterface->NumOfArpEntries++;

			break;
		}
		while (FALSE);

	} // if creating new

	if (pIpEntry)
	{
		AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
		AA_REF_IE(pIpEntry, RefType);	 // AtmArpSearchForIPAddress
		AA_RELEASE_IE_LOCK_DPC(pIpEntry);
	}

	AADEBUGP(AAD_LOUD,
		 ("Search for IP Addr: %d.%d.%d.%d, hash ind %d, Found %d, IPEnt 0x%x\n",
					((PUCHAR)pIPAddress)[0],
					((PUCHAR)pIPAddress)[1],
					((PUCHAR)pIPAddress)[2],
					((PUCHAR)pIPAddress)[3],
					HashIndex, Found, pIpEntry));

	return (pIpEntry);
	
}


VOID
AtmArpAbortIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Clean up and delete an IP entry. This is called when we invalidate
	an ARP mapping.

	NOTE: The caller is assumed to hold a lock to the IP Entry,
	which will be released here.

Arguments:

	pIpEntry		- Pointer to IP Entry to be deleted.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE	pInterface;
	PATMARP_IP_ENTRY *	ppNextIpEntry;
	PATMARP_ATM_ENTRY	pAtmEntry;
	RouteCacheEntry *	pRCE;
	PNDIS_PACKET		PacketList;
	ULONG				rc;				// Ref Count on IP Entry.
	BOOLEAN				IsMulticastIpEntry;
	BOOLEAN				Found;
	BOOLEAN				TimerWasRunning;
	BOOLEAN				IfTableLockReleased;

	ULONG				HashIndex;		// For this IP Entry in ARP Table

	AADEBUGP(AAD_INFO,
		 ("Abort IP entry 0x%x, Flags 0x%x, ATM Entry 0x%x, IP Addr %d:%d:%d:%d\n",
						 pIpEntry,
						 pIpEntry->Flags,
						 pIpEntry->pAtmEntry,
						 ((PUCHAR)&(pIpEntry->IPAddress))[0],
						 ((PUCHAR)&(pIpEntry->IPAddress))[1],
						 ((PUCHAR)&(pIpEntry->IPAddress))[2],
						 ((PUCHAR)&(pIpEntry->IPAddress))[3]
						));

	//
	//  Initialize.
	//
	rc = pIpEntry->RefCount;
	pInterface = pIpEntry->pInterface;
#ifdef IPMCAST
	IsMulticastIpEntry = (AA_IS_FLAG_SET(pIpEntry->Flags,
							AA_IP_ENTRY_ADDR_TYPE_MASK,
							AA_IP_ENTRY_ADDR_TYPE_NUCAST));
#endif
	IfTableLockReleased = FALSE;

	//
	//  Reacquire the desired locks in the right order.
	//
	AA_RELEASE_IE_LOCK(pIpEntry);
	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	//
	//  Remove any packets queued on this IP Entry.
	//
	PacketList = pIpEntry->PacketList;
	pIpEntry->PacketList = (PNDIS_PACKET)NULL;

	do
	{
#ifdef IPMCAST
		//
		//  If this is a Non-unicast entry, unlink it from the list
		//  of Multicast IP Entries on this Interface.
		//
		if (IsMulticastIpEntry)
		{
			for (ppNextIpEntry = &(pInterface->pMcSendList);
 				 *ppNextIpEntry != NULL_PATMARP_IP_ENTRY;
 				 ppNextIpEntry = &((*ppNextIpEntry)->pNextMcEntry))
 			{
 				if (*ppNextIpEntry == pIpEntry)
 				{
 					//
 					//  Unlink it.
 					//
 					*ppNextIpEntry = pIpEntry->pNextMcEntry;
 					break;
 				}
 			}

 			AAMCDEBUGP(AAD_VERY_LOUD,
 				("AbortIPEntry (MC): pIpEntry 0x%x: unlinked from MC list\n", pIpEntry));
		}
#endif // IPMCAST

		//
		//  Unlink this IP Entry from all Route Cache Entries
		//  that point to it.
		//
		pRCE = pIpEntry->pRCEList;
		while (pRCE != (RouteCacheEntry *)NULL)
		{
			Found = AtmArpUnlinkRCE(pRCE, pIpEntry);
			AA_ASSERT(Found);

			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_RCE);	// RCE linkage ref
			if (rc > 0)
			{
				pRCE = pIpEntry->pRCEList;
			}
			else
			{
				pRCE = (RouteCacheEntry *)NULL;
			}
		}

		if (rc == 0)
		{
			//  The IP Entry is gone.
			break;
		}

		//
		//  Stop any timer running on the IP Entry.
		//
		TimerWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);

		if (TimerWasRunning)
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref
			if (rc == 0)
			{
				break;
			}
		}

		//
		//  Unlink this IP Entry from the ARP Table, if needed.
		//
		Found = FALSE;

		HashIndex = ATMARP_HASH(pIpEntry->IPAddress);
		ppNextIpEntry = &(pInterface->pArpTable[HashIndex]);
		while (*ppNextIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			if (*ppNextIpEntry == pIpEntry)
			{
				//
				//  Make the predecessor point to the next
				//  in the list.
				//
				*ppNextIpEntry = pIpEntry->pNextEntry;
				Found = TRUE;
				pInterface->NumOfArpEntries--;

				//
				// Once it's off the arp table, we set the flag to IDLE.
				//
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_IDLE);
				break;
			}
			else
			{
				ppNextIpEntry = &((*ppNextIpEntry)->pNextEntry);
			}
		}

		if (Found)
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TABLE);	// ARP Table ref
			if (rc == 0)
			{
				break;
			}
		}

		//
		//  Do this last:
		//  ------------
		//  If this IP Entry is linked to an ATM Entry, unlink it.
		//  If this is a multicast ATM entry, shut down the ATM Entry, too.
		//
		pAtmEntry = pIpEntry->pAtmEntry;
		if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
#ifdef IPMCAST
			BOOLEAN			IsMulticastAtmEntry;

			pIpEntry->pAtmEntry = NULL;

			AA_ACQUIRE_AE_LOCK(pAtmEntry);

			IsMulticastAtmEntry = AA_IS_FLAG_SET(pAtmEntry->Flags,
												 AA_ATM_ENTRY_TYPE_MASK,
												 AA_ATM_ENTRY_TYPE_NUCAST);
			if (IsMulticastAtmEntry)
			{
				//
				//  We do this because we'll access the ATM
				//  Entry below, but only for the PMP case.
				//
				AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref: Abort IP Entry
			}
#else
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
#endif // IPMCAST
		
			//
			//  Locate the position of this IP Entry in the ATM Entry's list.
			//


			ppNextIpEntry = &(pAtmEntry->pIpEntryList);
		
			while (*ppNextIpEntry != NULL && *ppNextIpEntry != pIpEntry)
			{
				ppNextIpEntry = &((*ppNextIpEntry)->pNextToAtm);
			}
		
			if (*ppNextIpEntry == pIpEntry)
			{
				//
				//  Make the predecessor point to the next entry.
				//
				*ppNextIpEntry = pIpEntry->pNextToAtm;
			
				rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_IE);	// IP Entry ref
	
				if (rc != 0)
				{
					AA_RELEASE_AE_LOCK(pAtmEntry);
				}

				rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE);	// ATM Entry linkage ref
				if (rc != 0)
				{
					AA_ASSERT (FALSE);	// we expect rc to be 0, but could be a  tmp ref.
					AA_RELEASE_IE_LOCK(pIpEntry);
				}
			}
			else
			{
				//
				// We didn't find this IP entry in the atm entry list!
				// Presumably the linkage has been broken by some other
				// path (probably AtmArpInvalidateAtmEntry) while we were
				// in this function.
				//
				// We don't deref here because these two are now not linked.
				//
				//
				AA_RELEASE_AE_LOCK(pAtmEntry);
				AA_RELEASE_IE_LOCK(pIpEntry);
			}

			//
			//  IE Lock would have been released above.
			//
			AA_RELEASE_IF_TABLE_LOCK(pInterface);
			IfTableLockReleased = TRUE;

#ifdef IPMCAST
			//
			//  If this was a multicast entry, shut down the ATM Entry
			//
			if (IsMulticastAtmEntry)
			{
				AA_ACQUIRE_AE_LOCK(pAtmEntry);
				rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref: Abort IP Entry
				if (rc != 0)
				{
					AtmArpInvalidateAtmEntry(pAtmEntry, FALSE);
					//
					//  AE Lock is released within the above.
					//
				}
			}
#endif // IPMCAST

		}
		else
		{
			//
			//  No ATM entry linked to this IP entry.
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
			break;
		}

		break;
	}
	while (FALSE);


	if (!IfTableLockReleased)
	{
		AA_RELEASE_IF_TABLE_LOCK(pInterface);
	}

	//
	//  Free all packets that were queued on the IP Entry.
	//
	AtmArpFreeSendPackets(
				pInterface,
				PacketList,
				FALSE			// No LLC/SNAP header on these
				);

	return;
}



VOID
AtmArpInvalidateAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ShuttingDown
)
/*++

Routine Description:

	Invalidate an ATM Entry by unlinking it from IP entries.

	Typical situation:

	A non-normal communication problem has been detected on a Vc going to
	this ATM destination. The RFC says that we need to invalidate all IP
	entries for this destination, and let them get re-resolved before sending
	any traffic to them. We implement this by unlinking this ATM entry from
	all IP entries it is linked to. Each such IP entry will get re-resolved
	if+when we try to send a packet to it.

	The only exceptions are IP Entries that have been statically mapped
	to this ATM Entry: we don't unlink these, unless we are shutting down
	now, as indicated by "ShuttingDown".

	If we end up with no IP Entries pointing to this ATM Entry, we close all
	SVCs linked to the ATM Entry. If ShuttingDown is TRUE, we close all PVCs
	as well.

Arguments:

	pAtmEntry		- The ATM Entry needing invalidating.
	ShuttingDown	- TRUE iff the interface is being shut down.

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;
	PATMARP_IP_ENTRY		pNextIpEntry;
	ULONG					rc;			// Ref Count of ATM Entry
	INT						IPEntriesUnlinked;
	PATMARP_IP_ENTRY		pStaticIpEntryList;	// List of static IP Entries

	AA_STRUCT_ASSERT(pAtmEntry, aae);

	AADEBUGP(AAD_INFO,
		("InvalidateAtmEntry: pAtmEntry 0x%x, Flags 0x%x, ShutDown %d, pIpEntryList 0x%x\n",
				pAtmEntry,
				pAtmEntry->Flags,
				ShuttingDown,
				pAtmEntry->pIpEntryList));

#ifndef PROTECT_ATM_ENTRY_IN_CLOSE_CALL
	//
	//  Check if we are already closing this ATM Entry. If so,
	//  we don't do anything here.
	//
	if (AA_IS_FLAG_SET(
				pAtmEntry->Flags,
				AA_ATM_ENTRY_STATE_MASK,
				AA_ATM_ENTRY_CLOSING))
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
		return;
	}

	//
	//  Mark this ATM Entry so that we don't use it anymore.
	//
	AA_SET_FLAG(pAtmEntry->Flags,
				AA_ATM_ENTRY_STATE_MASK,
				AA_ATM_ENTRY_CLOSING);

#endif // PROTECT_ATM_ENTRY_IN_CLOSE_CALL

	//
	//  Initialize.
	//
	pStaticIpEntryList = NULL_PATMARP_IP_ENTRY;
	IPEntriesUnlinked = 0;

	//
	//  Take the IP Entry list out of the ATM Entry.
	//
	pIpEntry = pAtmEntry->pIpEntryList;
	pAtmEntry->pIpEntryList = NULL_PATMARP_IP_ENTRY;

#ifdef IPMCAST
	//
	//  Delete the Migrate list, if any.
	//
	if (AA_IS_FLAG_SET(pAtmEntry->Flags,
						AA_ATM_ENTRY_TYPE_MASK,
						AA_ATM_ENTRY_TYPE_NUCAST))
	{
		PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
		PATMARP_IPMC_ATM_ENTRY		pNextMcAtmEntry;

		for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmMigrateList;
			 pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
			 pMcAtmEntry = pNextMcAtmEntry)
		{
			pNextMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;
			AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pMcAtmEntry->Timer));
			AA_CHECK_TIMER_IN_ACTIVE_LIST(&pMcAtmEntry->Timer, pAtmEntry->pInterface, pMcAtmEntry, "MC ATM Entry");
			AA_FREE_MEM(pMcAtmEntry);
		}

		pAtmEntry->pMcAtmInfo->pMcAtmMigrateList = NULL_PATMARP_IPMC_ATM_ENTRY;
	}
#endif // IPMCAST

	//
	//  We let go of the ATM Entry lock here because we'll need
	//  to lock each IP Entry in the above list, and we need to make
	//  sure that we don't deadlock.
	//
	//  However, we make sure that the ATM Entry doesn't go away
	//  by adding a reference to it.
	//
	AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref
	AA_RELEASE_AE_LOCK(pAtmEntry);

	//
	//  Now, unlink all IP entries that are "dynamic", and filter
	//  out a list of static mappings.
	//
	while (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
		pNextIpEntry = pIpEntry->pNextToAtm;

		if (ShuttingDown || (!AA_IS_FLAG_SET(pIpEntry->Flags,
								AA_IP_ENTRY_TYPE_MASK,
								AA_IP_ENTRY_IS_STATIC)))
		{

			AADEBUGP(AAD_INFO,
		 ("InvalidateATMEntry: Unlinking IP entry 0x%x, Flags 0x%x, ATM Entry 0x%x, IP Addr %d:%d:%d:%d; rc=%lu\n",
						 pIpEntry,
						 pIpEntry->Flags,
						 pIpEntry->pAtmEntry,
						 ((PUCHAR)&(pIpEntry->IPAddress))[0],
						 ((PUCHAR)&(pIpEntry->IPAddress))[1],
						 ((PUCHAR)&(pIpEntry->IPAddress))[2],
						 ((PUCHAR)&(pIpEntry->IPAddress))[3],
						 pIpEntry->RefCount
						));

			//
			//  Remove the mapping.
			//
			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_IDLE2);

			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_MC_RESOLVE_MASK,
						AA_IP_ENTRY_MC_IDLE);
			pIpEntry->pAtmEntry = NULL_PATMARP_ATM_ENTRY;
			pIpEntry->pNextToAtm = NULL_PATMARP_IP_ENTRY;

			//
			//  Stop any active timer on the IP entry now that we have clobbered
			//  its state.
			//
			if (AtmArpStopTimer(&pIpEntry->Timer, pIpEntry->pInterface))
			{
				ULONG	IpEntryRc;

				IpEntryRc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);
				AA_ASSERT(IpEntryRc != 0);
			}

			//
			//  Remove the ATM Entry linkage reference.
			//
			if (AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE) != 0)
			{
				AA_RELEASE_IE_LOCK(pIpEntry);
			}
			//
			//  else the IP Entry is gone
			//

			IPEntriesUnlinked++;
		}
		else
		{
			//
			//  Static ARP entry, retain it.
			//
			pIpEntry->pNextToAtm = pStaticIpEntryList;
			pStaticIpEntryList = pIpEntry;
			AA_RELEASE_IE_LOCK(pIpEntry);
		}
		pIpEntry = pNextIpEntry;
	}

	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	//
	//  Put back the static IP entries on the ATM Entry.
	//
	AA_ASSERT(pAtmEntry->pIpEntryList == NULL_PATMARP_IP_ENTRY);
	pAtmEntry->pIpEntryList = pStaticIpEntryList;

	//
	//  Now dereference the ATM Entry as many times as we unlinked
	//  IP Entries from it.
	//
	rc = pAtmEntry->RefCount;
	while (IPEntriesUnlinked-- > 0)
	{
		rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_IE);	// IP Entry ref
	}
	AA_ASSERT(rc != 0);

	//
	//  Take out the reference we added at the beginning of
	//  this routine.
	//
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref

	//
	//  Now, the only IP Entries pointing at this ATM Entry would be
	//  static entries. If there are no such IP entries, close all SVCs
	//  attached to the ATM Entry. But do all this only if the ATM Entry
	//  hasn't been dereferenced away already.
	//
	if (rc != 0)
	{
		//
		//  The ATM Entry still exists.
		//

		AADEBUGP(AAD_LOUD,
		 ("InvalidateAtmEntry: nonzero rc on exit.\n"
		  "\t pAE=0x%x; rc=%lu; pIpList=0x%x\n",
		  pAtmEntry,
		  pAtmEntry->RefCount,
		  pAtmEntry->pIpEntryList
		  ));

		if (pAtmEntry->pIpEntryList == NULL_PATMARP_IP_ENTRY)
		{
			//
			//  No IP Entries pointing to this ATM Entry.
			//
			AtmArpCloseVCsOnAtmEntry(pAtmEntry, ShuttingDown);
			//
			//  The ATM Entry lock is released within the above.
			//
		}
		else
		{
			AADEBUGP(AAD_LOUD,
				("InvalidateAtmEnt: AtmEnt %x has nonempty IP list %x, reactivating\n",
					pAtmEntry, pAtmEntry->pIpEntryList));

			AA_SET_FLAG(
					pAtmEntry->Flags,
					AA_ATM_ENTRY_STATE_MASK,
					AA_ATM_ENTRY_ACTIVE);

			AA_RELEASE_AE_LOCK(pAtmEntry);
		}
	}
	//
	//  else the ATM Entry is gone
	//

	return;
}



VOID
AtmArpCloseVCsOnAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry		LOCKIN NOLOCKOUT,
	IN	BOOLEAN						ShuttingDown
)
/*++

Routine Description:

	Go through the list of VCs chained to an ATM Entry, and close all
	VCs that are SVCs. If the interface is being shut down, close all
	PVCs as well.

	NOTE: the caller is assumed to hold a lock to the ATM Entry,
	which will be released here.

Arguments:

	pAtmEntry			- Pointer to ATM Entry on which we want to close SVCs.
	ShuttingDown		- TRUE iff the interface is being shut down.

Return Value:

	None

--*/
{
	PATMARP_VC		pVc;		// Used to walk the list of VCs on the ATM Entry
	PATMARP_VC		pCloseVcList;	// List of VCs on the ATM Entry to be closed
	PATMARP_VC		*ppNextVc;
	PATMARP_VC		pNextVc;
	ULONG			rc;			// Ref count on ATM Entry


	do
	{
		//
		//  Reference the ATM Entry so that it cannot go away.
		//
		AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref: InvalidateAtmEntry

#ifdef PROTECT_ATM_ENTRY_IN_CLOSE_CALL
		//
		//  Check if we are already closing this ATM Entry. If so,
		//  we don't do anything here.
		//
		if (AA_IS_FLAG_SET(
					pAtmEntry->Flags,
					AA_ATM_ENTRY_STATE_MASK,
					AA_ATM_ENTRY_CLOSING))
		{
			break;
		}

		//
		//  Mark this ATM Entry so that we don't use it anymore.
		//
		AA_SET_FLAG(pAtmEntry->Flags,
					AA_ATM_ENTRY_STATE_MASK,
					AA_ATM_ENTRY_CLOSING);

#endif // PROTECT_ATM_ENTRY_IN_CLOSE_CALL

		//
		//  Go through the list of VCs on this ATM Entry,
		//  close all SVCs, and if we are shutting down,
		//  all PVCs, too.
		//

		if (pAtmEntry->pVcList != NULL_PATMARP_VC)
		{
			pVc = pAtmEntry->pVcList;
			AA_ACQUIRE_VC_LOCK_DPC(pVc);
			AtmArpReferenceVc(pVc);	// temp: CloseVCsOnAtmEntry
			AA_RELEASE_VC_LOCK_DPC(pVc);
		}

		for (pVc = pAtmEntry->pVcList;
			 pVc != NULL_PATMARP_VC;
			 pVc = pNextVc)
		{
			pNextVc = pVc->pNextVc;

			//
			//  Make sure we do not follow a stale link after
			//  we are done with the current VC.
			//
			if (pNextVc != NULL_PATMARP_VC)
			{
				AA_ACQUIRE_VC_LOCK_DPC(pNextVc);
				AtmArpReferenceVc(pNextVc);     // temp: CloseVCsOnAtmEntry
				AA_RELEASE_VC_LOCK_DPC(pNextVc);
			}

			if (ShuttingDown || (AA_IS_FLAG_SET(pVc->Flags,
										AA_VC_TYPE_MASK,
										AA_VC_TYPE_SVC)))
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
	
				AA_ACQUIRE_VC_LOCK(pVc);

				if (AtmArpDereferenceVc(pVc) != 0)
				{
					AtmArpCloseCall(pVc);
					//
					//  The VC Lock is released within the above.
					//
                }

			}
			else
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);

				AA_ACQUIRE_VC_LOCK(pVc);
				if (AtmArpDereferenceVc(pVc) != 0)
				{
					AA_RELEASE_VC_LOCK(pVc);
				}
			}

			AA_ACQUIRE_AE_LOCK(pAtmEntry);

		}
		break;
	}
	while (FALSE);

	//
	//  Remove the temp reference
	//
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// Temp ref: InvalidateAtmEntry

	if (rc != 0)
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}
	//
	//  else the ATM Entry is gone.
	//

	return;
}


VOID
AtmArpResolveIpEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Trigger off address resolution of an IP entry, unless it's already
	going on. Based on the IP address class, we either go to the ARP
	server or to MARS.

	NOTE: The caller is assumed to hold a lock to the IP Entry, and it
	will be released here.

Arguments:

	pIpEntry		- IP Entry on which we want to start resolution.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	IP_ADDRESS				DstIPAddress;
	IP_ADDRESS				SrcIPAddress;
	BOOLEAN					WasRunning;
	ULONG					Flags;			// From IP Entry

	Flags = pIpEntry->Flags;

	if (!AA_IS_FLAG_SET(
				Flags,
				AA_IP_ENTRY_STATE_MASK,
				AA_IP_ENTRY_ARPING)     &&
		!AA_IS_FLAG_SET(
				Flags,
				AA_IP_ENTRY_STATE_MASK,
				AA_IP_ENTRY_INARPING) &&
		AA_IE_IS_ALIVE(pIpEntry))
	{

		pInterface = pIpEntry->pInterface;

		//
		//  Get the source and destination IP addresses for
		//  the ARP Request.
		//
		DstIPAddress = pIpEntry->IPAddress;
		SrcIPAddress = pInterface->LocalIPAddress.IPAddress;

		//
		//  An aging timer might be running on this IP Entry.
		//  [We start one in the NakDelayTimeout routine].
		//  Stop it.
		//
		WasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);

		//
		//  Start an ARP Wait timer.
		//
		AtmArpStartTimer(
				pInterface,
				&(pIpEntry->Timer),
				AtmArpAddressResolutionTimeout,
				pInterface->AddressResolutionTimeout,
				(PVOID)pIpEntry
				);


		if (!WasRunning)
		{
			AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// timer ref
		}

		pIpEntry->RetriesLeft = pInterface->MaxResolutionAttempts - 1;

		//
		//  Update the state on this IP Entry.
		//
		AA_SET_FLAG(
				pIpEntry->Flags,
				AA_IP_ENTRY_STATE_MASK,
				AA_IP_ENTRY_ARPING);

		AA_RELEASE_IE_LOCK(pIpEntry);

#ifdef IPMCAST
		if (AA_IS_FLAG_SET(Flags,
							AA_IP_ENTRY_ADDR_TYPE_MASK,
							AA_IP_ENTRY_ADDR_TYPE_UCAST))
		{
			//
			//  Unicast address: send out an ARP Request
			//
			AtmArpSendARPRequest(
					pInterface,
					&SrcIPAddress,
					&DstIPAddress
					);
		}
		else
		{
			//
			//  Multicast/broadcast address: send a MARS Request
			//
			AtmArpMcSendRequest(
					pInterface,
					&DstIPAddress
					);
		}
#else
		//
		//  Now send out the ARP Request
		//
		AtmArpSendARPRequest(
				pInterface,
				&SrcIPAddress,
				&DstIPAddress
				);
#endif // IPMCAST
	}
	else
	{
		//
		//  The IP Address is either not alived or being resolved.
		//  No more action needed
		//  here.
		//
		AA_RELEASE_IE_LOCK(pIpEntry);
	}

	return;
}


EXTERN
VOID
AtmArpCleanupArpTable(
	IN PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Go through the ARP Table, deleting all multicast IP entries that
	are stale (currently defined as having no link to an AtmEntry).
	These IP entries stay around because mulicast entries don't have ageing timers.

Arguments:

	pInterface	

Return Value:

	None

--*/
{

	BOOLEAN	fTableLockWasReleased;

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	do
	{
		PATMARP_IP_ENTRY 			pIpEntry;

		fTableLockWasReleased = FALSE;

		for (pIpEntry =  pInterface->pMcSendList;
			 pIpEntry != NULL;
			 pIpEntry = pIpEntry->pNextMcEntry)
		{
			//
			// NOTE: by design, we don't claim the ip entry lock when checking
			// whether we should abort the entry or not.
			//
			if (	pIpEntry->pAtmEntry == NULL
				&&  !AA_IS_FLAG_SET(
						pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_ARPING))
			{
				//
				// Get locks in the right order.
				//
				AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
				AA_REF_IE(pIpEntry, IE_REFTYPE_TMP);	// TmpRef
				AA_RELEASE_IE_LOCK_DPC(pIpEntry);
				AA_RELEASE_IF_TABLE_LOCK(pInterface);
				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

				if (AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP)) // TmpRef
				{
					AADEBUGP(AAD_WARNING,
						("CleanupArpTable: Aborting stale IP %d:%d:%d:%d\n",
						((PUCHAR)&(pIpEntry->IPAddress))[0],
						((PUCHAR)&(pIpEntry->IPAddress))[1],
						((PUCHAR)&(pIpEntry->IPAddress))[2],
						((PUCHAR)&(pIpEntry->IPAddress))[3]
						));
					AtmArpAbortIPEntry(pIpEntry);

					//
					//  IE Lock is released within the above.
					//
				}

				//
				// Since we let go of the table lock, we must re-start our search
				// through pMcSendList.
				//
				fTableLockWasReleased = TRUE;
				AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
				break;
			}
		}

	} while (fTableLockWasReleased);

	AA_RELEASE_IF_TABLE_LOCK(pInterface);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\arpwmi.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	arpwmi.c

Abstract:

	WMI Support for ATMARP Client. One Device Object is created for each
	IP Interface, and a bunch of GUIDs are supported on each. The static
	instance name for each interface is derived from the friendly name
	of the adapter below.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     12-16-97    Created

Notes:

--*/

#undef BINARY_COMPATIBLE

#define BINARY_COMPATIBLE	0

#include <precomp.h>

#define _FILENUMBER 'IMWA'

#define NEWQOS 1

#ifdef ATMARP_WMI


//
//  Private macros
//
#define	AA_WMI_BUFFER_TOO_SMALL(_BufferSize, _Wnode, _WnodeSize, _pStatus)		\
{																				\
	if ((_BufferSize) < sizeof(WNODE_TOO_SMALL))								\
	{																			\
		*(_pStatus) = STATUS_BUFFER_TOO_SMALL;									\
	}																			\
	else																		\
	{																			\
		(_Wnode)->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);				\
		(_Wnode)->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;					\
		((PWNODE_TOO_SMALL)(_Wnode))->SizeNeeded = (_WnodeSize);				\
																				\
		*(_pStatus) = STATUS_SUCCESS;											\
	}																			\
}


//
//  Provider Id in WMI structures
//
typedef ULONG_PTR					PROV_ID_TYPE;



PATMARP_WMI_GUID
AtmArpWmiFindGuid(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	OUT	PULONG						pGuidDataSize
)
/*++

Routine Description:

	Locate and return a pointer to the GUID info structure
	for the specified GUID. The caller is assumed to have
	locked the IF structure. Also return the data size for
	the GUID instance.

Arguments:

	pInterface		- Pointer to our Interface structure
	pGuid			- Pointer to GUID being searched for
	pGuidDataSize	- Place to return data size for GUID instance

Return Value:

	Pointer to GUID info structure if found, else NULL.

--*/
{
	PATMARP_IF_WMI_INFO		pIfWmiInfo;
	PATMARP_WMI_GUID		pArpGuid;
	ULONG					i;
	UCHAR					OutputBuffer[1];
	ULONG					BytesReturned;
	NTSTATUS				NtStatus;

	do
	{
		pIfWmiInfo = pInterface->pIfWmiInfo;
		AA_ASSERT(pIfWmiInfo != NULL);

		for (i = 0, pArpGuid = &pIfWmiInfo->GuidInfo[0];
			 i < pIfWmiInfo->GuidCount;
			 i++, pArpGuid++)
		{
			if (AA_MEM_CMP(&pArpGuid->Guid, pGuid, sizeof(GUID)) == 0)
			{
				break;
			}
		}

		if (i == pIfWmiInfo->GuidCount)
		{
			pArpGuid = NULL;
			break;
		}

		//
		//  Found the GUID. Do a dummy query of its value to get
		//  the value size.
		//
		if (pArpGuid->QueryHandler == NULL)
		{
			//
			//  No query handler!
			//
			AA_ASSERT(!"No query handler!");
			pArpGuid = NULL;
			break;
		}

		NtStatus = (*pArpGuid->QueryHandler)(
						pInterface,
						pArpGuid->MyId,
						&OutputBuffer,
						0,					// output BufferLength
						&BytesReturned,
						pGuidDataSize
						);
		
		AA_ASSERT(NtStatus == STATUS_INSUFFICIENT_RESOURCES);
		break;
	}
	while (FALSE);

	return (pArpGuid);
}


NTSTATUS
AtmArpWmiRegister(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						RegistrationType,
	IN	PWMIREGINFO					pWmiRegInfo,
	IN	ULONG						WmiRegInfoSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to process an IRP_MN_REGINFO. If the registration type
	is WMIREGISTER, we return a list of GUIDs supported on this interface.

Arguments:

	pInterface		- Pointer to our Interface structure
	RegistrationType- WMIREGISTER or WMIUPDATE. We only handle WMIREGISTER.
	pWmiRegInfo		- Points to structure to be filled in with info about
					  supported GUIDs on this interface.
	WmiRegInfoSize	- Length of the above
	pReturnSize		- What we filled up.

Return Value:

	STATUS_SUCCESS if successful, STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	ULONG						BytesNeeded;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpWmiGuid;
	PWMIREGGUID					pWmiRegGuid;
	ULONG						InstanceOffset;
	PUCHAR						pDst;
	ULONG						c;

	Status = STATUS_SUCCESS;

	do
	{
		if (RegistrationType != WMIREGISTER)
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		BytesNeeded = sizeof(WMIREGINFO)
					  		+
					  //
					  //  One WMIREGGUID structure for each supported GUID.
					  //
					  (pIfWmiInfo->GuidCount * sizeof(WMIREGGUID))
					  		+
					  //
					  //  Counted unicode string containing the instance name
					  //  for all GUIDs on this interface. Looks like:
					  //  <USHORT Length> <String of WCHAR>
					  //
					  (sizeof(USHORT) + pIfWmiInfo->InstanceName.Length)
#ifdef PATHS_REQD
					  		+
					  //
					  //  Counted unicode string containing the driver registry
					  //  path. Looks like: <USHORT Length> <String of WCHAR>
					  //
					  (sizeof(USHORT) + sizeof(ATMARP_REGISTRY_PATH) - sizeof(WCHAR))
					  		+
					  //
					  //  Counted unicode string containing the MOF resource
					  //  name: <USHORT length> <String of WCHAR>
					  //
					  (sizeof(USHORT) + sizeof(ATMARP_MOF_RESOURCE_NAME) - sizeof(WCHAR))
#endif // PATHS_REQD
					  		;
 
 		if (WmiRegInfoSize < BytesNeeded)
 		{
 			//
 			//  Insufficient space for GUID info.
 			//

 			*((ULONG UNALIGNED *)pWmiRegInfo) = BytesNeeded;
 			*pReturnSize = sizeof(ULONG);
 			Status = STATUS_SUCCESS;

 			AADEBUGP(AAD_INFO, ("WmiRegister: Bytes needed %d, Reginfo size %d\n",
 						BytesNeeded, WmiRegInfoSize));

 			break;
 		}

		//
		//  Done with all validations.
		//
		*pReturnSize = BytesNeeded;

		AA_SET_MEM(pWmiRegInfo, 0, BytesNeeded);

		pWmiRegInfo->BufferSize = BytesNeeded;
		pWmiRegInfo->NextWmiRegInfo = 0;
		pWmiRegInfo->GuidCount = pIfWmiInfo->GuidCount;

		//
		//  Calculate the offset at which we place the instance name.
		//
		InstanceOffset = sizeof(WMIREGINFO) + (pIfWmiInfo->GuidCount * sizeof(WMIREGGUID));

		//
		//  Fill in the GUID list. All GUIDs for this interface refer to
		//  the same Instance name.
		//
		pWmiRegGuid = &pWmiRegInfo->WmiRegGuid[0];
		pArpWmiGuid = &pIfWmiInfo->GuidInfo[0];

		for (c = 0;
			 c < pIfWmiInfo->GuidCount;
			 c++, pWmiRegGuid++, pArpWmiGuid++)
		{
			AA_COPY_MEM(&pWmiRegGuid->Guid, &pArpWmiGuid->Guid, sizeof(GUID));

			pWmiRegGuid->Flags = WMIREG_FLAG_INSTANCE_LIST;
			pWmiRegGuid->InstanceCount = 1;
			pWmiRegGuid->InstanceInfo = InstanceOffset;
		}


		//
		//  Fill in the instance name.
		//
		pDst = (PUCHAR)pWmiRegGuid;

		*((USHORT UNALIGNED *)pDst) = pIfWmiInfo->InstanceName.Length;
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst,
					pIfWmiInfo->InstanceName.Buffer,
					pIfWmiInfo->InstanceName.Length);

		pDst += pIfWmiInfo->InstanceName.Length;

#ifdef PATHS_REQD

		//
		//  Fill in the Driver registry path.
		//
		pWmiRegInfo->RegistryPath = (ULONG)(pDst - (PUCHAR)pWmiRegInfo);

		*((USHORT UNALIGNED *)pDst) = sizeof(ATMARP_REGISTRY_PATH) - sizeof(WCHAR);
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst,
					(PUCHAR)ATMARP_REGISTRY_PATH,
					sizeof(ATMARP_REGISTRY_PATH) - sizeof(WCHAR));

		pDst += sizeof(ATMARP_REGISTRY_PATH) - sizeof(WCHAR);


		//
		//  Fill in the MOF resource name.
		//
		pWmiRegInfo->MofResourceName = (ULONG)(pDst - (PUCHAR)pWmiRegInfo);
		*((USHORT UNALIGNED *)pDst) = sizeof(ATMARP_MOF_RESOURCE_NAME) - sizeof(WCHAR);
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst,
					(PUCHAR)ATMARP_MOF_RESOURCE_NAME,
					sizeof(ATMARP_MOF_RESOURCE_NAME) - sizeof(WCHAR));

#endif // PATHS_REQD

		break;
	}
	while (FALSE);

	AADEBUGP(AAD_INFO,
		("WmiRegister: IF x%x, pWmiRegInfo x%x, Size %d, Ret size %d, status x%x\n",
			pInterface, pWmiRegInfo, WmiRegInfoSize, *pReturnSize, Status));

	return (Status);
}


NTSTATUS
AtmArpWmiQueryAllData(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	IN	PWNODE_ALL_DATA				pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to process an IRP_MN_QUERY_ALL_DATA, which is used
	to query all instances of a GUID on this interface.

	For now, we only have single instances of any GUID on an interface.

Arguments:

	pInterface		- Pointer to our Interface structure
	pGuid			- GUID of data block being queried.
	pWnode			- The structure to be filled up.
	BufferSize		- Total space for the WNODE_ALL_DATA, beginning at pWnode.
	pReturnSize		- What we filled up.

Return Value:

	STATUS_SUCCESS if we know this GUID and successfully filled up the
	WNODE_ALL_DATA, STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	ULONG						BytesNeeded;
	ULONG						WnodeSize;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpGuid;
	ULONG						GuidDataSize;
	ULONG						GuidDataBytesReturned;
	ULONG						GuidDataBytesNeeded;
	PUCHAR						pDst;
	BOOLEAN						bIfLockAcquired = FALSE;

	do
	{
		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//
		//  Locate the GUID.
		//
		bIfLockAcquired = TRUE;
		AA_ACQUIRE_IF_WMI_LOCK(pInterface);

		pArpGuid = AtmArpWmiFindGuid(pInterface, pGuid, &GuidDataSize);

		if (pArpGuid == NULL)
		{
			Status = STATUS_WMI_GUID_NOT_FOUND;
			break;
		}

		WnodeSize = ROUND_TO_8_BYTES(sizeof(WNODE_ALL_DATA));

		//
		//  Compute the total size of the reply WNODE_ALL_DATA. Since
		//  we only have a single instance of each GUID on an interface,
		//  we use the "Fixed Instance Size" format.
		//
		BytesNeeded =  WnodeSize +
						//
						//  The data itself
						//
					   GuidDataSize +
						//
						//  A ULONG to store the instance name offset
						//
					   sizeof(ULONG) +
					    //
					    //  A USHORT to store the length of the instance name
					    //  (Counted Unicode string)
					    //
					   sizeof(USHORT) +
					   	//
					   	//  The instance name
					   	//
					   pIfWmiInfo->InstanceName.Length;

		//
		//  Is there sufficient space in the buffer handed down to us?
		//
		if (BufferSize < BytesNeeded)
		{
			AA_WMI_BUFFER_TOO_SMALL(BufferSize, pWnode, WnodeSize, &Status);
			break;
		}

		//
		//  Initialize the WNODE_ALL_DATA.
		//
		pWnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(pIfWmiInfo->pDeviceObject);
		pWnode->WnodeHeader.Version = ATMARP_WMI_VERSION;

		NdisGetCurrentSystemTime(&pWnode->WnodeHeader.TimeStamp);

		pWnode->WnodeHeader.Flags |= WNODE_FLAG_FIXED_INSTANCE_SIZE;
		pWnode->WnodeHeader.BufferSize = BytesNeeded;

		pWnode->InstanceCount = 1;

		//
		//  The data follows the WNODE_ALL_DATA.
		//
		pWnode->DataBlockOffset = WnodeSize;

		//
		//  The instance name ensemble follows the data.
		//
		pWnode->OffsetInstanceNameOffsets = WnodeSize + GuidDataSize;
		pWnode->FixedInstanceSize = GuidDataSize;

		//
		//  Get the data.
		//
		Status = (*pArpGuid->QueryHandler)(
					pInterface,
					pArpGuid->MyId,
					(PVOID)((PUCHAR)pWnode + pWnode->DataBlockOffset),
					GuidDataSize,
					&GuidDataBytesReturned,
					&GuidDataBytesNeeded);
		
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		//
		//  Jump to the location where we must fill in the instance name
		//  ensemble, which consists of:
		//
		//  	ULONG	Offset from start of WNODE to counted Unicode string
		//				representing Instance name (below).
		//		USHORT	Number of WCHARs in instance name.
		//		WCHAR[]	Array of WCHARs making up the instance name.
		//
		pDst = (PUCHAR)((PUCHAR)pWnode + pWnode->OffsetInstanceNameOffsets);

		//
		//  Fill in the offset to the instance name at this spot, and move on.
		//
		*(ULONG UNALIGNED *)pDst = pWnode->OffsetInstanceNameOffsets + sizeof(ULONG);
		pDst += sizeof(ULONG);

		//
		//  Fill in the instance name as a counted Unicode string.
		//
		*(PUSHORT)pDst = (USHORT)pIfWmiInfo->InstanceName.Length;
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst,
					pIfWmiInfo->InstanceName.Buffer,
					pIfWmiInfo->InstanceName.Length);

		AA_ASSERT(NT_SUCCESS(Status));
		break;
	}
	while (FALSE);

	if (bIfLockAcquired)
	{
		AA_RELEASE_IF_WMI_LOCK(pInterface);
	}

	if (NT_SUCCESS(Status))
	{
		*pReturnSize = pWnode->WnodeHeader.BufferSize;
	}

	AADEBUGP(AAD_INFO,
		("WmiQueryAllData: IF x%x, pWnode x%x, Size %d, Ret size %d, status x%x\n",
			pInterface, pWnode, BufferSize, *pReturnSize, Status));

	return (Status);
}


NTSTATUS
AtmArpWmiQuerySingleInstance(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_INSTANCE		pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to process an IRP_MN_QUERY_SINGLE_INSTANCE, which is used
	to query a single instance of a GUID on this interface.

Arguments:

	pInterface		- Pointer to our Interface structure
	pWnode			- The structure to be filled up.
	BufferSize		- Total space for the WNODE_SINGLE_INSTANCE, beginning at pWnode.
	pReturnSize		- What we filled up.

Return Value:

	STATUS_SUCCESS if we know this GUID and successfully filled up the
	WNODE_SINGLE_INSTANCE, STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	ULONG						BytesNeeded;
	ULONG						WnodeSize;
	LPGUID						pGuid;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpGuid;
	PUCHAR						pDst;
	ULONG						GuidDataSize;
	ULONG						GuidDataBytesNeeded;
	BOOLEAN						bIfLockAcquired = FALSE;

	do
	{
		AA_ASSERT((pWnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) != 0);

		{
			NDIS_STRING				InstanceName;
	
			InstanceName.Length = *(PUSHORT)((PUCHAR)pWnode
									+ pWnode-> OffsetInstanceName);
			InstanceName.Buffer = (PWSTR)((PUCHAR)pWnode + pWnode->OffsetInstanceName
											+ sizeof(USHORT));
			AADEBUGP(AAD_INFO,
						("QuerySingleInstance: InstanceName=%Z\n", &InstanceName));
		}

		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//
		//  Locate the GUID.
		//
		pGuid = &pWnode->WnodeHeader.Guid;

		bIfLockAcquired = TRUE;
		AA_ACQUIRE_IF_WMI_LOCK(pInterface);

		pArpGuid = AtmArpWmiFindGuid(pInterface, pGuid, &GuidDataSize);

		if (pArpGuid == NULL)
		{
			Status = STATUS_WMI_GUID_NOT_FOUND;
			break;
		}

		WnodeSize = ROUND_TO_8_BYTES(sizeof(WNODE_SINGLE_INSTANCE));

		//
		//  Compute the total size of the reply WNODE_SINGLE_INSTANCE.
		//
		BytesNeeded =  pWnode->DataBlockOffset + GuidDataSize;

		if (BufferSize < BytesNeeded)
		{
			AA_WMI_BUFFER_TOO_SMALL(BufferSize, pWnode, WnodeSize, &Status);
			break;
		}
			
		//
		//  Fill in the WNODE_SINGLE_INSTANCE.
		//
		pWnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(pIfWmiInfo->pDeviceObject);
		pWnode->WnodeHeader.Version = ATMARP_WMI_VERSION;

		NdisGetCurrentSystemTime(&pWnode->WnodeHeader.TimeStamp);

		pWnode->WnodeHeader.BufferSize = BytesNeeded;
		pWnode->SizeDataBlock = GuidDataSize;

		//
		//  Get the GUID Data.
		//
		Status = (*pArpGuid->QueryHandler)(
					pInterface,
					pArpGuid->MyId,
					(PUCHAR)pWnode + pWnode->DataBlockOffset,	// start of output buf
					BufferSize - pWnode->DataBlockOffset,	// total length available
					&pWnode->SizeDataBlock,	// bytes written
					&GuidDataBytesNeeded
					);

		if (!NT_SUCCESS(Status))
		{
			break;
		}

		*pReturnSize = BytesNeeded;

		Status = STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	if (bIfLockAcquired)
	{
		AA_RELEASE_IF_WMI_LOCK(pInterface);
	}

	AADEBUGP(AAD_INFO,
		("WmiQuerySingleInst: IF x%x, pWnode x%x, Size %d, Ret size %d, status x%x\n",
			pInterface, pWnode, BufferSize, *pReturnSize, Status));

	return (Status);
}


NTSTATUS
AtmArpWmiChangeSingleInstance(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_INSTANCE		pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to process an IRP_MN_CHANGE_SINGLE_INSTANCE, which is used
	to change the value of a single instance of a GUID on this interface.

Arguments:

	pInterface		- Pointer to our Interface structure
	pWnode			- The structure containing the new value for the GUID instance.
	BufferSize		- Total space for the WNODE_SINGLE_INSTANCE, beginning at pWnode.
	pReturnSize		- Not used.

Return Value:

	STATUS_SUCCESS if we know this GUID and successfully changed its value,
	STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	ULONG						BytesNeeded;
	ULONG						WnodeSize;
	LPGUID						pGuid;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpGuid;
	PUCHAR						pGuidData;
	ULONG						GuidDataSize;
	ULONG						GuidDataBytesWritten;
	ULONG						GuidDataBytesNeeded;
	BOOLEAN						bIfLockAcquired = FALSE;

	do
	{
		AA_ASSERT((pWnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) != 0);

		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//
		//  Locate the GUID.
		//
		pGuid = &pWnode->WnodeHeader.Guid;

		bIfLockAcquired = TRUE;
		AA_ACQUIRE_IF_WMI_LOCK(pInterface);

		pArpGuid = AtmArpWmiFindGuid(pInterface, pGuid, &GuidDataSize);

		if (pArpGuid == NULL)
		{
			Status = STATUS_WMI_GUID_NOT_FOUND;
			break;
		}

		//
		//  Check if the GUID can be set.
		//
		if (pArpGuid->SetHandler == NULL)
		{
			Status = STATUS_NOT_SUPPORTED;
			break;
		}

		//
		//  Get the start and size of the data block.
		//
		pGuidData = (PUCHAR)pWnode + pWnode->DataBlockOffset;
		GuidDataSize = pWnode->SizeDataBlock;

		if (GuidDataSize == 0)
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		//
		//  Try to set the value of the GUID instance.
		//
		Status = (*pArpGuid->SetHandler)(
					pInterface,
					pArpGuid->MyId,
					pGuidData,
					GuidDataSize,
					&GuidDataBytesWritten,
					&GuidDataBytesNeeded
					);

		break;
	}
	while (FALSE);

	if (bIfLockAcquired)
	{
		AA_RELEASE_IF_WMI_LOCK(pInterface);
	}

	return (Status);
}


NTSTATUS
AtmArpWmiChangeSingleItem(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_ITEM			pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
)
/*++

Routine Description:

	This is called to change a single item within the data block for a GUID
	instance (e.g. field in a struct). We don't need this for now.

Arguments:


Return Value:

	STATUS_NOT_SUPPORTED

--*/
{
	return (STATUS_NOT_SUPPORTED);
}



NTSTATUS
AtmArpWmiSetEventStatus(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	IN	BOOLEAN						bEnabled
)
/*++

Routine Description:

	This is called to enable/disable event generation on the specified GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	pGuid			- affected GUID
	bEnabled		- TRUE iff events are to be enabled.

Return Value:

	STATUS_SUCCESS if we successfully enabled/disabled event generation,
	STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS					Status;
	PATMARP_IF_WMI_INFO			pIfWmiInfo;
	PATMARP_WMI_GUID			pArpGuid;
	ULONG						GuidDataSize;
	BOOLEAN						bIfLockAcquired = FALSE;

	do
	{
		pIfWmiInfo = pInterface->pIfWmiInfo;

		if ((pIfWmiInfo == NULL) ||
			(pIfWmiInfo->GuidCount == 0))
		{
			//
			//  No GUIDs on this Interface.
			//
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		bIfLockAcquired = TRUE;
		AA_ACQUIRE_IF_WMI_LOCK(pInterface);

		pArpGuid = AtmArpWmiFindGuid(pInterface, pGuid, &GuidDataSize);

		if (pArpGuid == NULL)
		{
			Status = STATUS_WMI_GUID_NOT_FOUND;
			break;
		}

		AADEBUGP(AAD_INFO, ("WmiSetEventStatus: IF x%x, pArpGuid x%x, MyId %d, enable: %d\n",
					pInterface, pArpGuid, pArpGuid->MyId, bEnabled));

		//
		//  Check if we generate events on this GUID.
		//
		if (pArpGuid->EnableEventHandler == NULL)
		{
			Status = STATUS_NOT_SUPPORTED;
			break;
		}

		//
		//  Go ahead and enable events.
		//
		if (bEnabled)
		{
			AA_SET_FLAG(pArpGuid->Flags, AWGF_EVENT_MASK, AWGF_EVENT_ENABLED);
		}
		else
		{
			AA_SET_FLAG(pArpGuid->Flags, AWGF_EVENT_MASK, AWGF_EVENT_DISABLED);
		}

		(*pArpGuid->EnableEventHandler)(
			pInterface,
			pArpGuid->MyId,
			bEnabled
			);
		
		Status = STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	if (bIfLockAcquired)
	{
		AA_RELEASE_IF_WMI_LOCK(pInterface);
	}

	return (Status);
}


NTSTATUS
AtmArpWmiDispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
)
/*++

Routine Description:

	System dispatch function for handling IRP_MJ_SYSTEM_CONTROL IRPs from WMI.

Arguments:

	pDeviceObject	- Pointer to device object. The device extension field
					  contains a pointer to the Interface 

	pIrp			- Pointer to IRP.

Return Value:

	NT status code.

--*/
{
	PIO_STACK_LOCATION		pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    PVOID					DataPath = pIrpSp->Parameters.WMI.DataPath;
    ULONG					BufferSize = pIrpSp->Parameters.WMI.BufferSize;
    PVOID					pBuffer = pIrpSp->Parameters.WMI.Buffer;
    NTSTATUS				Status;
    ULONG					ReturnSize;
    PATMARP_INTERFACE		pInterface;

    pInterface = AA_PDO_TO_INTERFACE(pDeviceObject);

    AA_STRUCT_ASSERT(pInterface, aai);

	ReturnSize = 0;

    switch (pIrpSp->MinorFunction)
    {
    	case IRP_MN_REGINFO:

    		Status = AtmArpWmiRegister(
    					pInterface,
    					PtrToUlong(DataPath),
    					pBuffer,
    					BufferSize,
    					&ReturnSize
    					);
    		break;
    	
    	case IRP_MN_QUERY_ALL_DATA:

    		Status = AtmArpWmiQueryAllData(
    					pInterface,
    					(LPGUID)DataPath,
    					(PWNODE_ALL_DATA)pBuffer,
    					BufferSize,
    					&ReturnSize
    					);
    		break;
    	
    	case IRP_MN_QUERY_SINGLE_INSTANCE:

    		Status = AtmArpWmiQuerySingleInstance(
    					pInterface,
    					pBuffer,
    					BufferSize,
    					&ReturnSize
    					);
    		
    		break;

		case IRP_MN_CHANGE_SINGLE_INSTANCE:

			Status = AtmArpWmiChangeSingleInstance(
						pInterface,
						pBuffer,
						BufferSize,
						&ReturnSize
						);
			break;

		case IRP_MN_CHANGE_SINGLE_ITEM:

			Status = AtmArpWmiChangeSingleItem(
						pInterface,
						pBuffer,
						BufferSize,
						&ReturnSize
						);
			break;

		case IRP_MN_ENABLE_EVENTS:

			Status = AtmArpWmiSetEventStatus(
						pInterface,
						(LPGUID)DataPath,
						TRUE				// Enable
						);
			break;

		case IRP_MN_DISABLE_EVENTS:

			Status = AtmArpWmiSetEventStatus(
						pInterface,
						(LPGUID)DataPath,
						FALSE				// Disable
						);
			break;

		case IRP_MN_ENABLE_COLLECTION:
		case IRP_MN_DISABLE_COLLECTION:
		default:
		
			Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	pIrp->IoStatus.Status = Status;
	pIrp->IoStatus.Information = (NT_SUCCESS(Status) ? ReturnSize: 0);

	AADEBUGP(AAD_INFO,
		("WmiDispatch done: IF x%x, MinorFn %d, Status x%x, ReturnInfo %d\n",
				pInterface, pIrpSp->MinorFunction, Status, pIrp->IoStatus.Information));

	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return (Status);
}



VOID
AtmArpWmiInitInterface(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_WMI_GUID			GuidList,
	IN	ULONG						NumberOfGuids
)
/*++

Routine Description:

	Set up the given IP Interface as a WMI provider.

Arguments:

	pInterface		- Pointer to our Interface structure
	GuidList		- List of GUIDs
	NumberOfGuids	- Size of above list

Return Value:

	None. If the interface is successfully set up, we reference it.

--*/
{
	PATMARP_IF_WMI_INFO		pIfWmiInfo;
	NDIS_STRING				DeviceName;

	NDIS_STRING				AdapterName;
	NDIS_STRING				HyphenString = NDIS_STRING_CONST(" - ");
#define MAX_IF_NUMBER_STRING_LEN		6	// 5 Digits plus terminator
	NDIS_STRING				IfNumberString;

	ULONG					TotalIfWmiLength;
	USHORT					NameLength;
	NDIS_STATUS				Status;
	NTSTATUS				NtStatus;

	AA_ASSERT(NumberOfGuids > 0);
	AA_ASSERT(GuidList != NULL);

	//
	//  Initialize.
	//
	AdapterName.Buffer = NULL;
	IfNumberString.Buffer = NULL;

	pIfWmiInfo = NULL;

	Status = NDIS_STATUS_SUCCESS;

	do
	{
		AA_INIT_IF_WMI_LOCK(pInterface);

		//
		//  Query the friendly name for the adapter beneath
		//  this Interface.
		//
		Status = NdisQueryAdapterInstanceName(
					&AdapterName,
					pInterface->NdisAdapterHandle
					);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AdapterName.Buffer = NULL;
			break;
		}

		AADEBUGP(AAD_INFO,
			 ("WmiInitIF: IF x%x, Adapter Name: <%Z>\n", pInterface, &AdapterName));

		//
		//  Prepare an instance name for all GUIDs on this Interface.
		//
		//  This is constructed by appending a string of the form "- <Num>"
		//  to the adapter's friendly name. <Num> is the value of the SEL
		//  byte used to identify this interface.
		//

		//
		//  Allocate space for the IF Number string - 5 digits should
		//  be more than enough.
		//
		AA_ASSERT(pInterface->SapSelector <= 99999);

		AA_ALLOC_MEM(IfNumberString.Buffer, WCHAR, MAX_IF_NUMBER_STRING_LEN * sizeof(WCHAR));

		if (IfNumberString.Buffer == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		IfNumberString.MaximumLength = MAX_IF_NUMBER_STRING_LEN;
		IfNumberString.Length = 0;

		//
		//  Prepare the IF Number string.
		//
		Status = RtlIntegerToUnicodeString(
					pInterface->SapSelector,
					10,	// Decimal
					&IfNumberString
					);
		
		AA_ASSERT(NT_SUCCESS(Status));

		//
		//  Compute the total length of the Interface instance name.
		//
		NameLength = AdapterName.Length + HyphenString.Length + IfNumberString.Length + sizeof(WCHAR);

		//
		//  Allocate space for WMI Info for this interface. We allocate one
		//  chunk of memory for all the following:
		//
		//  1. IF WMI Info structure
		//  2. IF Instance name string
		//  3. GUID list
		//
		TotalIfWmiLength = sizeof(ATMARP_IF_WMI_INFO) +
						   //
						   //  IF Instance name:
						   //
						   NameLength +
						   //
						   //  GUID list (-1 because ATMARP_IF_WMI_INFO
						   //  has space for one of these).
						   //
						   ((NumberOfGuids - 1) * sizeof(ATMARP_WMI_GUID));
		
		AA_ALLOC_MEM(pIfWmiInfo, ATMARP_IF_WMI_INFO, TotalIfWmiLength);

		if (pIfWmiInfo == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		AA_SET_MEM(pIfWmiInfo, 0, TotalIfWmiLength);

		pIfWmiInfo->GuidCount = NumberOfGuids;

		AA_COPY_MEM(&pIfWmiInfo->GuidInfo[0],
					GuidList,
					NumberOfGuids * sizeof(ATMARP_WMI_GUID));

		pIfWmiInfo->InstanceName.Buffer = (PWCHAR)
											((PUCHAR)pIfWmiInfo +
											 FIELD_OFFSET(ATMARP_IF_WMI_INFO, GuidInfo) +
											 (NumberOfGuids * sizeof(ATMARP_WMI_GUID)));

		pIfWmiInfo->InstanceName.MaximumLength = NameLength;

		//
		//  Concatenate the three parts of the IF Instance name.
		//
		RtlCopyUnicodeString(&pIfWmiInfo->InstanceName, &AdapterName);

		NtStatus = RtlAppendUnicodeStringToString(&pIfWmiInfo->InstanceName, &HyphenString);
		AA_ASSERT(NT_SUCCESS(NtStatus));

		NtStatus = RtlAppendUnicodeStringToString(&pIfWmiInfo->InstanceName, &IfNumberString);
		AA_ASSERT(NT_SUCCESS(NtStatus));


		AADEBUGP(AAD_INFO,
			("WmiInitIF: IF x%x, InstanceName: <%Z>\n", pInterface, &pIfWmiInfo->InstanceName));
		//
		//  Create a device object for this interface. A pointer's worth
		//  of space is required in the device extension.
		//
#define ATMARP_DEVICE_NAME1		L"\\Device\\ATMARPC1"
		NdisInitUnicodeString(&DeviceName, ATMARP_DEVICE_NAME1);

		NtStatus = IoCreateDevice(
					pAtmArpGlobalInfo->pDriverObject,
					sizeof(PATMARP_INTERFACE),
					NULL,	// &DeviceName
					FILE_DEVICE_NETWORK,
					0,		// Device Characteristics
					FALSE,	// Exclusive?
					&pIfWmiInfo->pDeviceObject
					);
		
		if (!NT_SUCCESS(NtStatus))
		{
			AADEBUGP(AAD_INFO,
				("WmiInitIF: IoCreateDevice (%Z) failed: x%x\n", &DeviceName, NtStatus));

			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Set up the device extension.
		//
		*((PATMARP_INTERFACE *)pIfWmiInfo->pDeviceObject->DeviceExtension) = pInterface;

		//
		//  Prepare to register with WMI.
		//
		pInterface->pIfWmiInfo = pIfWmiInfo;

		NtStatus = IoWMIRegistrationControl(
						pIfWmiInfo->pDeviceObject,
						WMIREG_ACTION_REGISTER);

		if (!NT_SUCCESS(NtStatus))
		{
			pInterface->pIfWmiInfo = NULL;

			IoDeleteDevice(pIfWmiInfo->pDeviceObject);

			Status = NDIS_STATUS_FAILURE;
			break;
		}

		AA_ASSERT(Status == NDIS_STATUS_SUCCESS);
		break;
	}
	while (FALSE);

	//
	//  Clean up.
	//
	if (IfNumberString.Buffer != NULL)
	{
		AA_FREE_MEM(IfNumberString.Buffer);
	}

	if (AdapterName.Buffer != NULL)
	{
		//
		//  This was allocated by NDIS.
		//
		NdisFreeString(AdapterName);
	}

	if (Status != NDIS_STATUS_SUCCESS)
	{
		AA_ASSERT(pInterface->pIfWmiInfo == NULL);

		if (pIfWmiInfo != NULL)
		{
			AA_FREE_MEM(pIfWmiInfo);
		}
	}

	AADEBUGP(AAD_INFO, ("WmiInitIF: IF x%x, WMI Info x%x, Status x%x\n",
				pInterface, pIfWmiInfo, Status));

	return;
}



VOID
AtmArpWmiShutdownInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Shuts down the given IP Interface as a WMI provider.

Arguments:

	pInterface		- Pointer to our Interface structure

Return Value:

	None. If the interface was originally set up and we shut it down
	successfully, we dereference it.

--*/
{
	PATMARP_IF_WMI_INFO		pIfWmiInfo;

	do
	{
		//
		//  Check if we had successfully set up this interface for WMI.
		//
		pIfWmiInfo = pInterface->pIfWmiInfo;

		if (pIfWmiInfo == NULL)
		{
			break;
		}

		pInterface->pIfWmiInfo = NULL;

		//
		//  Deregister this device object with WMI.
		//
		IoWMIRegistrationControl(pIfWmiInfo->pDeviceObject, WMIREG_ACTION_DEREGISTER);

		//
		//  Delete the device object.
		//
		IoDeleteDevice(pIfWmiInfo->pDeviceObject);

		AA_FREE_IF_WMI_LOCK(pInterface);

		break;
	}
	while (FALSE);

	if (pIfWmiInfo)
	{
		AA_FREE_MEM(pIfWmiInfo);
	}

	return;
}



NTSTATUS
AtmArpWmiSetTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Set function for the TC_SUPPORTED GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pInputBuffer	- Points to data value
	BufferLength	- Length of the above
	pBytesWritten	- Place to return how much was written
	pBytesNeeded	- If insufficient data, place to return expected data size

Return Value:

	STATUS_NOT_SUPPORTED. We don't allow setting the value of this GUID.

--*/
{
	*pBytesWritten = 0;

	return (STATUS_NOT_SUPPORTED);
}


NTSTATUS
AtmArpWmiQueryTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Query function for the TC_SUPPORTED GUID. The value of this GUID is
	the list of IP Addresses assigned to this interface. This is returned
	using an ADDRESS_LIST_DESCRIPTOR data structure.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pOutputBuffer	- Start of Buffer to be filled up
	BufferLength	- Length of the above
	pBytesReturned	- Place to return how much was returned
	pBytesNeeded	- If insufficient space, place to return expected data size

Return Value:

	STATUS_SUCCESS if we successfully filled in the address list,
	STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS	NtStatus;

#if NEWQOS
	PTC_SUPPORTED_INFO_BUFFER
				pInfo 		= (PTC_SUPPORTED_INFO_BUFFER)pOutputBuffer;
    UINT		HeaderSize  = FIELD_OFFSET(
								TC_SUPPORTED_INFO_BUFFER, 
								AddrListDesc
								);
	BOOLEAN 	CopiedHeader= FALSE;
#endif // NEWQOS

	do
	{

#if NEWQOS
		// address list
		if (BufferLength >= HeaderSize)
		{
			NDIS_STRING  DeviceGUID;
			//
			// Reserve space for the portion of SUPPORTED_INFO_BUFFER before
			// AddrListDesc, and fill it out
			//

			AA_ACQUIRE_IF_LOCK(pInterface);

			pOutputBuffer = &pInfo->AddrListDesc;
			BufferLength -= HeaderSize;
	
			DeviceGUID = pInterface->pAdapter->DeviceName; // struct copy.

			//
			// Need to skip past the "\\DEVICE\\" part of name.
			//
			if (DeviceGUID.Length > sizeof(L"\\DEVICE\\"))
			{
				DeviceGUID.Length -= sizeof(L"\\DEVICE\\");
				DeviceGUID.Buffer += sizeof(L"\\DEVICE\\")/sizeof(WCHAR);
			}

			if (sizeof(pInfo->InstanceID) < DeviceGUID.Length)
			{
				AA_ASSERT(FALSE);
				NtStatus =  STATUS_INVALID_PARAMETER;
				AA_RELEASE_IF_LOCK(pInterface);
				break;
			}

			pInfo->InstanceIDLength  = DeviceGUID.Length;
			AA_COPY_MEM(pInfo->InstanceID, DeviceGUID.Buffer, DeviceGUID.Length);
	
			CopiedHeader = TRUE;

			AA_RELEASE_IF_LOCK(pInterface);
		}
		else
		{
			BufferLength  = 0;
		}

#endif // NEWQOS
	
		NtStatus = AtmArpWmiGetAddressList(
					pInterface,
					pOutputBuffer,
					BufferLength,
					pBytesReturned,
					pBytesNeeded);
	
#if NEWQOS
		*pBytesNeeded	+= HeaderSize;
	
		if (CopiedHeader)
		{
			*pBytesReturned += HeaderSize;
		}
#endif // NEWQOS
	
	} while(FALSE);

	return (NtStatus);
}



NTSTATUS
AtmArpWmiGetAddressList(
	IN	PATMARP_INTERFACE			pInterface,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Prepare an address descriptor list out of the IP Addresses assigned
	to the specified interface. Use the buffer supplied for this.

Arguments:

	pInterface		- Pointer to our Interface structure
	pOutputBuffer	- Start of Buffer to be filled up
	BufferLength	- Length of the above
	pBytesReturned	- Place to return how much was returned
	pBytesNeeded	- If insufficient space, place to return expected data size

Return Value:

	STATUS_SUCCESS if we successfully filled in the address list,
	STATUS_XXX error code otherwise.

--*/
{
	NTSTATUS							NtStatus;
	ULONG								BytesNeeded;
	ULONG								NumberOfIPAddresses;
	ADDRESS_LIST_DESCRIPTOR UNALIGNED *	pAddrListDescr;
	NETWORK_ADDRESS UNALIGNED *			pNwAddr;
	PIP_ADDRESS_ENTRY					pIPAddrEntry;

	NtStatus = STATUS_SUCCESS;

	AA_ACQUIRE_IF_LOCK(pInterface);

	do
	{
		*pBytesReturned = 0;
		NumberOfIPAddresses = pInterface->NumOfIPAddresses;

		//
		//  Compute the space needed.
		//
		BytesNeeded = (sizeof(ADDRESS_LIST_DESCRIPTOR) - sizeof(NETWORK_ADDRESS)) +

					  (NumberOfIPAddresses *
						(FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IP)));

		*pBytesNeeded = BytesNeeded;

		if (BytesNeeded > BufferLength)
		{
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pAddrListDescr = (PADDRESS_LIST_DESCRIPTOR)pOutputBuffer;

		pAddrListDescr->MediaType = NdisMediumAtm;
		pAddrListDescr->AddressList.AddressCount = NumberOfIPAddresses;
		pAddrListDescr->AddressList.AddressType = NDIS_PROTOCOL_ID_TCP_IP;

		//
		//  Copy in the IP addresses assigned to this Interface.
		//
		pIPAddrEntry = &pInterface->LocalIPAddress;
		pNwAddr = &pAddrListDescr->AddressList.Address[0];

		while (NumberOfIPAddresses--)
		{
			UNALIGNED NETWORK_ADDRESS_IP *pNetIPAddr =
				(NETWORK_ADDRESS_IP UNALIGNED *)&pNwAddr->Address[0];
			pNwAddr->AddressLength = sizeof(NETWORK_ADDRESS_IP);
			pNwAddr->AddressType = NDIS_PROTOCOL_ID_TCP_IP;

			//
			// Each *pNetIPAddr struct has the following fields, of which
			// only in_addr is used. We set the rest to zero.
			//
			// USHORT		sin_port;
			// ULONG		in_addr;
			// UCHAR		sin_zero[8];
			//
			AA_SET_MEM(pNetIPAddr, sizeof(*pNetIPAddr), 0);
			pNetIPAddr->in_addr = pIPAddrEntry->IPAddress;


			pIPAddrEntry = pIPAddrEntry->pNext;

			pNwAddr = (NETWORK_ADDRESS UNALIGNED *)
						((PUCHAR)pNwAddr + FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(IP_ADDRESS));
		}

		*pBytesReturned = BytesNeeded;
		AA_ASSERT(NT_SUCCESS(NtStatus));
		break;
	}
	while (FALSE);

	AA_RELEASE_IF_LOCK(pInterface);

	AADEBUGP(AAD_INFO,
		("WmiGetAddrList: IF x%x, OutBuf x%x, Len x%x, BytesRet %d, Needed %d, Sts x%x\n",
			pInterface, pOutputBuffer, BufferLength, *pBytesReturned, *pBytesNeeded, NtStatus));

	return (NtStatus);
}


VOID
AtmArpWmiEnableEventTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
)
/*++

Routine Description:

	Turns on/off event generation on the TC_SUPPORTED GUID. Since we don't
	generate events on this GUID, this is ignored.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	bEnable			- if true, enable events on this GUID, else disable.

Return Value:

	None

--*/
{
	return;
}



NTSTATUS
AtmArpWmiSetTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Set function for the TC_INTERFACE_INDICATION GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pInputBuffer	- Points to data value
	BufferLength	- Length of the above
	pBytesWritten	- Place to return how much was written
	pBytesNeeded	- If insufficient data, place to return expected data size

Return Value:

	STATUS_NOT_SUPPORTED. We don't allow setting the value of this GUID.

--*/
{
	*pBytesWritten = 0;

	return (STATUS_NOT_SUPPORTED);
}


NTSTATUS
AtmArpWmiQueryTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Query function for the TC_INTERFACE_INDICATION GUID. The
	value of this GUID is the list of IP Addresses assigned to
	this interface. This is returned using a TC_INDICATION_BUFFER
	data structure.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pOutputBuffer	- Start of Buffer to be filled up
	BufferLength	- Length of the above
	pBytesReturned	- Place to return how much was returned
	pBytesNeeded	- If insufficient space, place to return expected data size

Return Value:

	STATUS_SUCCESS if we successfully filled in the address list,
	STATUS_XXX error code otherwise.

--*/
{
	PTC_INDICATION_BUFFER				pTcIndicationBuffer;
	NTSTATUS							NtStatus;
	ULONG								BytesReturned, BytesNeeded;
	PVOID								pAddrListBuffer;
	ULONG								AddrListBufferSize;
	ULONG								AddrListDescriptorOffset;

	pTcIndicationBuffer = (PTC_INDICATION_BUFFER)pOutputBuffer;

	pAddrListBuffer = (PVOID) &(pTcIndicationBuffer->InfoBuffer.AddrListDesc);
	AddrListDescriptorOffset = (ULONG)
						((PUCHAR) pAddrListBuffer - (PUCHAR) pOutputBuffer);

	AddrListBufferSize = ((BufferLength >= AddrListDescriptorOffset) ?
								 (BufferLength - AddrListDescriptorOffset): 0);

	NtStatus = AtmArpWmiGetAddressList(
				pInterface,
				pAddrListBuffer,
				AddrListBufferSize,
				&BytesReturned,
				&BytesNeeded);

	if (NT_SUCCESS(NtStatus))
	{
		pTcIndicationBuffer->SubCode = 0;
		*pBytesReturned = BytesReturned + AddrListDescriptorOffset;
	}
	else
	{
		*pBytesReturned = 0;
	}

	*pBytesNeeded = BytesNeeded + AddrListDescriptorOffset;

	return (NtStatus);
}


VOID
AtmArpWmiEnableEventTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
)
/*++

Routine Description:

	Turns on/off event generation on the TC_INTERFACE_INDICATION GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	bEnable			- if true, enable events on this GUID, else disable.

Return Value:

	None

--*/
{
	// CODE EnableEventTCIfIndication
	return;
}



VOID
AtmArpWmiSendTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						IndicationCode,
	IN	ULONG						IndicationSubCode
)
/*++

Routine Description:

	If event generation is allowed on TC_INTERFACE_INDICATION, send
	a WMI event now.

Arguments:

	pInterface		- Pointer to our Interface structure
	IndicationCode	- To be used in the event

Return Value:

	None

--*/
{
	PATMARP_IF_WMI_INFO				pIfWmiInfo;
	PATMARP_WMI_GUID				pArpGuid;
	ULONG							AddrBufferLength;
	ULONG							BytesReturned;
	UCHAR							DummyBuffer;
	PUCHAR							pOutputBuffer;
#ifndef NEWQOS
	PUCHAR							pDst;
#endif // !NEWQOS
	PWNODE_SINGLE_INSTANCE			pWnode;
	ULONG							WnodeSize;
	ULONG							TotalSize;
	NTSTATUS						NtStatus;

	pWnode = NULL;

	AA_ACQUIRE_IF_WMI_LOCK(pInterface);

	do
	{
		pIfWmiInfo = pInterface->pIfWmiInfo;

		if (pInterface->pIfWmiInfo == NULL)
		{
			//
			//  Haven't registered this interface with WMI.
			//
			break;
		}

		pArpGuid = &pIfWmiInfo->GuidInfo[IndicationCode];

		//
		//  Are we allowed to generate events on this GUID instance?
		//
		if (AA_IS_FLAG_SET(pArpGuid->Flags,
						   AWGF_EVENT_MASK,
						   AWGF_EVENT_DISABLED))
		{
			break;
		}

	#if NEWQOS
		//
		// Check if our instance name will fit into INFO_BUFFER.InstanceID
		//
		if (	pIfWmiInfo->InstanceName.Length
			 >  sizeof ((TC_SUPPORTED_INFO_BUFFER*)NULL)->InstanceID)
		{
			AA_ASSERT(FALSE);
			break;
		}
	#endif // NEWQOS

		//
		//  Find out how much space is needed for the data block.
		//
		pOutputBuffer = &DummyBuffer;
		AddrBufferLength = 0;

		NtStatus = AtmArpWmiGetAddressList(
					pInterface,
					pOutputBuffer,
					AddrBufferLength,
					&BytesReturned,
					&AddrBufferLength);

		AA_ASSERT(NtStatus == STATUS_INSUFFICIENT_RESOURCES);

		//
		//  Compute the total space for the WMI Event.
		//
		WnodeSize = ROUND_TO_8_BYTES(sizeof(WNODE_SINGLE_INSTANCE));

	#if NEWQOS
		TotalSize = WnodeSize 			+
					FIELD_OFFSET(					//  Indication upto info buf.
						TC_INDICATION_BUFFER,
						InfoBuffer)		+
					FIELD_OFFSET(					// info-buf upto AddrListDesc
						TC_SUPPORTED_INFO_BUFFER,
						AddrListDesc) 	+
					AddrBufferLength;					// AddrListDesc plus data.
	#else // !NEWQOS
		TotalSize = WnodeSize +
					//
					//  Counted Unicode string for the instance name:
					//
					sizeof(USHORT) +
					pIfWmiInfo->InstanceName.Length +
					//
					//  The actual data
					//
					AddrBufferLength;
	#endif // !NEWQOS

		//
		//  Allocate space for the entire lot. Since WMI will free
		//  it back to pool later, we don't use the usual allocation
		//  routine.
		//
		AA_ALLOC_FROM_POOL(pWnode, WNODE_SINGLE_INSTANCE, TotalSize);

		if (pWnode == NULL)
		{
			break;
		}

		AA_SET_MEM(pWnode, 0, TotalSize);

		pWnode->WnodeHeader.BufferSize = TotalSize;
		pWnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(pIfWmiInfo->pDeviceObject);
		pWnode->WnodeHeader.Version = ATMARP_WMI_VERSION;

		NdisGetCurrentSystemTime(&pWnode->WnodeHeader.TimeStamp);

		pWnode->WnodeHeader.Flags = WNODE_FLAG_EVENT_ITEM |
									 WNODE_FLAG_SINGLE_INSTANCE;


	#if NEWQOS

		{
			
			PTC_INDICATION_BUFFER pIndication
							= (PTC_INDICATION_BUFFER) ((PUCHAR)pWnode + WnodeSize);

			pIndication->SubCode = 0;  // Unused, must be 0.

			pIndication->InfoBuffer.InstanceIDLength
												= pIfWmiInfo->InstanceName.Length;
	
			//
			// We checked earlier if InstanceName will fit into InstanceID, so
			// the copy is safe.
			//
			AA_COPY_MEM(
				pIndication->InfoBuffer.InstanceID,
				pIfWmiInfo->InstanceName.Buffer,
				pIfWmiInfo->InstanceName.Length
				);
	
			//
			//  Get the address list.
			//
			NtStatus = AtmArpWmiGetAddressList(
						pInterface,
						&(pIndication->InfoBuffer.AddrListDesc),
						AddrBufferLength,
						&BytesReturned,
						&AddrBufferLength
						);
		}

	#else

		pDst = (PUCHAR)pWnode + WnodeSize;

		//
		//  Copy in the instance name.
		//
		*((PUSHORT)pDst) = pIfWmiInfo->InstanceName.Length;
		pDst += sizeof(USHORT);

		AA_COPY_MEM(pDst, pIfWmiInfo->InstanceName.Buffer, pIfWmiInfo->InstanceName.Length);

		pDst += pIfWmiInfo->InstanceName.Length;

		//
		//  Get the data.
		//
		NtStatus = AtmArpWmiGetAddressList(
					pInterface,
					pDst,
					AddrBufferLength,
					&BytesReturned,
					&AddrBufferLength);
	#endif // !NEWQOS


		AA_ASSERT(NtStatus == STATUS_SUCCESS);
		break;
	}
	while (FALSE);


	AA_RELEASE_IF_WMI_LOCK(pInterface);

	//
	//  Send off the event if OK. WMI will take care of freeing the
	//  entire structure back to pool.
	//
	if (pWnode)
	{
		NtStatus = IoWMIWriteEvent(pWnode);
		AADEBUGP(AAD_INFO, ("WmiSendTCIFInd: IF x%x, WMIWriteEv status x%x\n",
						pInterface, NtStatus));
		if (NtStatus!= STATUS_SUCCESS)
		{
			// Docs don't list pending as a possible return value.
			//
			ASSERT(NtStatus != STATUS_PENDING);
			AA_FREE_TO_POOL(pWnode);
		}
	}

	return;
}

NTSTATUS
AtmArpWmiQueryStatisticsBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Query function for the STATISTICS_BUFFER GUID.
	This function is unimplemented.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pOutputBuffer	- Start of Buffer to be filled up
	BufferLength	- Length of the above
	pBytesReturned	- Place to return how much was returned
	pBytesNeeded	- If insufficient space, place to return expected data size

Return Value:

	STATUS_SUCCESS if we successfully filled in the address list,
	STATUS_XXX error code otherwise.

--*/
{
	return GPC_STATUS_RESOURCES;
}


NTSTATUS
AtmArpWmiSetStatisticsBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
)
/*++

Routine Description:

	Set function for the  STATISTICS_BUFFER GUID.

Arguments:

	pInterface		- Pointer to our Interface structure
	MyId			- Local ID for this GUID
	pInputBuffer	- Points to data value
	BufferLength	- Length of the above
	pBytesWritten	- Place to return how much was written
	pBytesNeeded	- If insufficient data, place to return expected data size

Return Value:

	STATUS_NOT_SUPPORTED. We don't allow setting the value of this GUID.

--*/
{
	*pBytesWritten = 0;

	return (STATUS_NOT_SUPPORTED);
}


PATMARP_INTERFACE
AtmArpWmiGetIfByName(
	IN	PWSTR						pIfName,
	IN	USHORT						IfNameLength
)
/*++

Routine Description:

	Given a name, locate and return the Interface whose instance name
	matches it. A temporary reference to the interface is added -- the caller
	is expected to deref the interface when done with it.

Arguments:

	pIfName			- Points to name to be searched for
	IfNameLength	- length of above

Return Value:

	Pointer to ATMARP interface if found, NULL otherwise.

--*/
{
	PATMARP_ADAPTER			pAdapter;
	PATMARP_INTERFACE		pInterface;

	pInterface = NULL_PATMARP_INTERFACE;

	//
	//  Knock off the terminating NULL WCHAR.
	//
	if (IfNameLength > sizeof(WCHAR))
	{
		IfNameLength -= sizeof(WCHAR);
	}

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	for (pAdapter = pAtmArpGlobalInfo->pAdapterList;
		 pAdapter != NULL_PATMARP_ADAPTER;
		 pAdapter = pAdapter->pNextAdapter)
	{
		for (pInterface = pAdapter->pInterfaceList;
			 pInterface != NULL_PATMARP_INTERFACE;
			 pInterface = pInterface->pNextInterface)
		{
#if DBG
			AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			if (pInterface->pIfWmiInfo)
			{
				AADEBUGP(AAD_WARNING,
					("Given len %d, string %ws\n", IfNameLength, pIfName));

				AADEBUGP(AAD_WARNING,
					("   IF len %d, string %ws\n",
						pInterface->pIfWmiInfo->InstanceName.Length,
						pInterface->pIfWmiInfo->InstanceName.Buffer));
			}
			AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
#endif // DBG
					
			if ((pInterface->pIfWmiInfo != NULL) &&
				(pInterface->pIfWmiInfo->InstanceName.Length == IfNameLength) &&
				(AA_MEM_CMP(pInterface->pIfWmiInfo->InstanceName.Buffer,
							pIfName,
							IfNameLength) == 0))
			{
				//
				//  Found it.
				//

				AA_ACQUIRE_IF_LOCK(pInterface);
				AtmArpReferenceInterface(pInterface); // WMI: Tmp ref.
				AA_RELEASE_IF_LOCK(pInterface);

				break;
			}
		}

		if (pInterface != NULL_PATMARP_INTERFACE)
		{
			break;
		}
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	return (pInterface);
}

#endif // ATMARP_WMI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		06-13-96	Created

Notes:

--*/


#include <precomp.h>
#include "ntddk.h"
#include <cxport.h>
#include "ndis.h"


#include "debug.h"

#if DBG

#ifdef ATMARP_WIN98
INT	AaDebugLevel=AAD_WARNING;
INT	AaMcDebugLevel=AAD_WARNING;
#else
INT	AaDebugLevel=AAD_WARNING;
INT	AaMcDebugLevel=AAD_WARNING;
#endif
INT	AaDataDebugLevel=0;
INT	AadBigDataLength=8000;
INT	AaSkipAll = 0;

PAAD_ALLOCATION	AadMemoryHead = (PAAD_ALLOCATION)NULL;
PAAD_ALLOCATION	AadMemoryTail = (PAAD_ALLOCATION)NULL;
ULONG				AadAllocCount = 0;	// how many allocated so far (unfreed)

NDIS_SPIN_LOCK		AadMemoryLock;
BOOLEAN				AadInitDone = FALSE;


PVOID
AaAuditAllocMem(
	PVOID	pPointer,
	ULONG	Size,
	ULONG	FileNumber,
	ULONG	LineNumber
)
{
	PVOID				pBuffer;
	PAAD_ALLOCATION	pAllocInfo;

	if (!AadInitDone)
	{
		NdisAllocateSpinLock(&(AadMemoryLock));
		AadInitDone = TRUE;
	}

	NdisAllocateMemoryWithTag(
		(PVOID *)&pAllocInfo,
		Size+FIELD_OFFSET(AAD_ALLOCATION, UserData),
		(ULONG)'CPRA'
	);

	if (pAllocInfo == (PAAD_ALLOCATION)NULL)
	{
		AADEBUGP(AAD_VERY_LOUD+50,
			("AaAuditAllocMem: file %d, line %d, Size %d failed!\n",
				FileNumber, LineNumber, Size));
		pBuffer = NULL;
	}
	else
	{
		pBuffer = (PVOID)&(pAllocInfo->UserData);
		AA_SET_MEM(pBuffer, 0xaf, Size);
		pAllocInfo->Signature = AAD_MEMORY_SIGNATURE;
		pAllocInfo->FileNumber = FileNumber;
		pAllocInfo->LineNumber = LineNumber;
		pAllocInfo->Size = Size;
		pAllocInfo->Location = pPointer;
		pAllocInfo->Next = (PAAD_ALLOCATION)NULL;

		NdisAcquireSpinLock(&(AadMemoryLock));

		pAllocInfo->Prev = AadMemoryTail;
		if (AadMemoryTail == (PAAD_ALLOCATION)NULL)
		{
			// empty list
			AadMemoryHead = AadMemoryTail = pAllocInfo;
		}
		else
		{
			AadMemoryTail->Next = pAllocInfo;
		}
		AadMemoryTail = pAllocInfo;
		
		AadAllocCount++;
		NdisReleaseSpinLock(&(AadMemoryLock));
	}

	AADEBUGP(AAD_VERY_LOUD+100,
	 ("AaAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x%x] <- 0x%x\n",
	 			(CHAR)(FileNumber & 0xff),
	 			(CHAR)((FileNumber >> 8) & 0xff),
	 			(CHAR)((FileNumber >> 16) & 0xff),
	 			(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber, Size, pPointer, pBuffer));

	return (pBuffer);

}


VOID
AaAuditFreeMem(
	PVOID	Pointer
)
{
	PAAD_ALLOCATION	pAllocInfo;

	pAllocInfo = STRUCT_OF(AAD_ALLOCATION, Pointer, UserData);

	if (pAllocInfo->Signature != AAD_MEMORY_SIGNATURE)
	{
		AADEBUGP(AAD_ERROR,
		 ("AaAuditFreeMem: unknown buffer 0x%x!\n", Pointer));
#ifdef DBG
		DbgBreakPoint();
#endif
		return;
	}

	NdisAcquireSpinLock(&(AadMemoryLock));
	pAllocInfo->Signature = (ULONG)'DEAD';
	if (pAllocInfo->Prev != (PAAD_ALLOCATION)NULL)
	{
		pAllocInfo->Prev->Next = pAllocInfo->Next;
	}
	else
	{
		AadMemoryHead = pAllocInfo->Next;
	}
	if (pAllocInfo->Next != (PAAD_ALLOCATION)NULL)
	{
		pAllocInfo->Next->Prev = pAllocInfo->Prev;
	}
	else
	{
		AadMemoryTail = pAllocInfo->Prev;
	}
	AadAllocCount--;
	NdisReleaseSpinLock(&(AadMemoryLock));

	NdisFreeMemory(pAllocInfo, 0, 0);
}


VOID
AaAuditShutdown(
	VOID
)
{
	if (AadInitDone)
	{
		if (AadAllocCount != 0)
		{
			AADEBUGP(AAD_ERROR, ("AuditShutdown: unfreed memory, %d blocks!\n",
					AadAllocCount));
			AADEBUGP(AAD_ERROR, ("MemoryHead: 0x%x, MemoryTail: 0x%x\n",
					AadMemoryHead, AadMemoryTail));
			DbgBreakPoint();
			{
				PAAD_ALLOCATION		pAllocInfo;

				while (AadMemoryHead != (PAAD_ALLOCATION)NULL)
				{
					pAllocInfo = AadMemoryHead;
					AADEBUGP(AAD_INFO, ("AuditShutdown: will free 0x%x\n", pAllocInfo));
					AaAuditFreeMem(&(pAllocInfo->UserData));
				}
			}
		}
		AadInitDone = FALSE;
	}
}

#define MAX_HD_LENGTH		128

VOID
DbgPrintHexDump(
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
)
/*++

Routine Description:

	Print a hex dump of the given contiguous buffer. If the length
	is too long, we truncate it.

Arguments:

	pBuffer			- Points to start of data to be dumped
	Length			- Length of above.

Return Value:

	None

--*/
{
	ULONG		i;

	if (Length > MAX_HD_LENGTH)
	{
		Length = MAX_HD_LENGTH;
	}

	for (i = 0; i < Length; i++)
	{
		//
		//  Check if we are at the end of a line
		//
		if ((i > 0) && ((i & 0xf) == 0))
		{
			DbgPrint("\n");
		}

		//
		//  Print addr if we are at start of a new line
		//
		if ((i & 0xf) == 0)
		{
			DbgPrint("%08x ", pBuffer);
		}

		DbgPrint(" %02x", *pBuffer++);
	}

	//
	//  Terminate the last line.
	//
	if (Length > 0)
	{
		DbgPrint("\n");
	}
}


VOID
DbgPrintAtmAddr(
	IN	PCHAR					pString,
	IN	ATM_ADDRESS UNALIGNED *	pAddr
)
{
	ULONG			i;
	ULONG			NumOfDigits;
	PUCHAR			pSrc, pDst;
	UCHAR			AddrString[(ATM_ADDRESS_LENGTH*2) + 1];

	//
	// Prepare the Address string in ASCII
	//
	if ((NumOfDigits = pAddr->NumberOfDigits) > ATM_ADDRESS_LENGTH)
	{
		NumOfDigits = ATM_ADDRESS_LENGTH;
	}

	pSrc = pAddr->Address;
	pDst = AddrString;
	for (i = 0; i < NumOfDigits; i++, pSrc++)
	{
		*pDst = ((*pSrc) >> 4);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
		*pDst = ((*pSrc) & 0x0F);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
	}

	*pDst = '\0';

	DbgPrint("%s%s\n", pString, AddrString);
}



VOID
DbgPrintMapping(
	IN	PCHAR					pString,
	IN	UCHAR UNALIGNED *		pIpAddr,
	IN	ATM_ADDRESS UNALIGNED *	pAtmAddr
)
{
	DbgPrint("ATMARPC: %s %d.%d.%d.%d -> ",
				pString,
				((PUCHAR)pIpAddr)[0],
				((PUCHAR)pIpAddr)[1],
				((PUCHAR)pIpAddr)[2],
				((PUCHAR)pIpAddr)[3]
			);

	DbgPrintAtmAddr("", pAtmAddr);
}


ULONG	OutstandingSends = 0;


VOID
AaCoSendPackets(
	IN	NDIS_HANDLE				NdisVcHandle,
	IN	PNDIS_PACKET *			PacketArray,
	IN	UINT					PacketCount
)
{
	PNDIS_PACKET		pNdisPacket;
	UINT				c;
	NDIS_STATUS			Status;
	PNDIS_BUFFER		pNdisBuffer;
	PULONG				pContext;

	for (c = 0; c < PacketCount; c++)
	{
		pNdisPacket = PacketArray[c];

		AA_ASSERT(pNdisPacket->Private.Head != NULL);

		Status = NDIS_GET_PACKET_STATUS(pNdisPacket);
		AA_ASSERT(Status != NDIS_STATUS_FAILURE);

		pContext = (PULONG)&(pNdisPacket->WrapperReserved[0]);
		*pContext = 'AaAa';
	}

	NdisInterlockedIncrement(&OutstandingSends);
	NdisCoSendPackets(NdisVcHandle, PacketArray, PacketCount);
}

#endif // DBG


#if DBG_SPIN_LOCK
ULONG	AadSpinLockInitDone = 0;
NDIS_SPIN_LOCK	AadLockLock;

VOID
AtmArpAllocateSpinLock(
	IN	PATMARP_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	if (AadSpinLockInitDone == 0)
	{
		AadSpinLockInitDone = 1;
		NdisAllocateSpinLock(&(AadLockLock));
	}

	NdisAcquireSpinLock(&(AadLockLock));
	pLock->Signature = AAL_SIG;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired = 0;
	pLock->OwnerThread = 0;
	NdisAllocateSpinLock(&(pLock->NdisLock));
	NdisReleaseSpinLock(&(AadLockLock));
}


VOID
AtmArpAcquireSpinLock(
	IN	PATMARP_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	PKTHREAD		pThread;

	pThread = KeGetCurrentThread();
	NdisAcquireSpinLock(&(AadLockLock));
	if (pLock->Signature != AAL_SIG)
	{
		DbgPrint("Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired != 0)
	{
		if (pLock->OwnerThread == pThread)
		{
			DbgPrint("Detected multiple locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
			DbgPrint("pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(pLock->TouchedByFileNumber & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 8) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 16) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 24) & 0xff),
				pLock->TouchedInLineNumber);
			DbgBreakPoint();
		}
	}

	pLock->IsAcquired++;

	NdisReleaseSpinLock(&(AadLockLock));
	NdisAcquireSpinLock(&(pLock->NdisLock));

	//
	//  Mark this lock.
	//
	pLock->OwnerThread = pThread;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
}


VOID
AtmArpReleaseSpinLock(
	IN	PATMARP_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	NdisDprAcquireSpinLock(&(AadLockLock));
	if (pLock->Signature != AAL_SIG)
	{
		DbgPrint("Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired == 0)
	{
		DbgPrint("Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired--;
	pLock->OwnerThread = 0;
	NdisDprReleaseSpinLock(&(AadLockLock));

	NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DBG_SPIN_LOCK


#ifdef PERF


#define MAX_SEND_LOG_ENTRIES		100

LARGE_INTEGER		TimeFrequency;
BOOLEAN				SendLogInitDone = FALSE;
BOOLEAN				SendLogUpdate = TRUE;
NDIS_SPIN_LOCK		SendLogLock;

AAD_SEND_LOG_ENTRY	SendLog[MAX_SEND_LOG_ENTRIES];
ULONG				SendLogIndex = 0;
PAAD_SEND_LOG_ENTRY	pSendLog = SendLog;

ULONG				MaxSendTime;

#define TIME_TO_ULONG(_pTime)	 *((PULONG)_pTime)

VOID
AadLogSendStart(
	IN	PNDIS_PACKET	pNdisPacket,
	IN	ULONG			Destination,
	IN	PVOID			pRCE
)
{
	ULONG		Length;

	if (SendLogInitDone == FALSE)
	{
		SendLogInitDone = TRUE;
		(VOID)KeQueryPerformanceCounter(&TimeFrequency);
		MaxSendTime = (TIME_TO_ULONG(&TimeFrequency) * 2)/3;
		NdisAllocateSpinLock(&SendLogLock);
	}

	NdisQueryPacket(
			pNdisPacket,
			NULL,
			NULL,
			NULL,
			&Length
			);

	NdisAcquireSpinLock(&SendLogLock);
	pSendLog->Flags = AAD_SEND_FLAG_WAITING_COMPLETION;
	if (pRCE != NULL)
	{
		pSendLog->Flags |= AAD_SEND_FLAG_RCE_GIVEN;
	}
	pSendLog->pNdisPacket = pNdisPacket;
	pSendLog->Destination = Destination;
	pSendLog->Length = Length;
	pSendLog->SendTime = KeQueryPerformanceCounter(&TimeFrequency);

	pSendLog++;
	SendLogIndex++;
	if (SendLogIndex == MAX_SEND_LOG_ENTRIES)
	{
		SendLogIndex = 0;
		pSendLog = SendLog;
	}

	NdisReleaseSpinLock(&SendLogLock);
}



VOID
AadLogSendUpdate(
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PAAD_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;

	if (!SendLogUpdate)
	{
		return;
	}

	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & AAD_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->SendTime = KeQueryPerformanceCounter(&TimeFrequency);
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}



VOID
AadLogSendComplete(
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PAAD_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;

	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & AAD_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->Flags &= ~AAD_SEND_FLAG_WAITING_COMPLETION;
			pEntry->Flags |= AAD_SEND_FLAG_COMPLETED;
			pEntry->SendCompleteTime = KeQueryPerformanceCounter(&TimeFrequency);

			if (((pEntry->Flags & AAD_SEND_FLAG_RCE_GIVEN) != 0) &&
				((SendTime = TIME_TO_ULONG(&pEntry->SendCompleteTime) -
							TIME_TO_ULONG(&pEntry->SendTime)) > MaxSendTime))
			{
				DbgPrint("Dest %d.%d.%d.%d, Pkt 0x%x, Len %d, Flags 0x%x, Took Long %d (0x%x)\n",
						((PUCHAR)&pEntry->Destination)[0],
						((PUCHAR)&pEntry->Destination)[1],
						((PUCHAR)&pEntry->Destination)[2],
						((PUCHAR)&pEntry->Destination)[3],
						pNdisPacket, pEntry->Length, pEntry->Flags, SendTime, SendTime);
			}
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}


VOID
AadLogSendAbort(
	IN	PNDIS_PACKET		pNdisPacket
)
{
	PAAD_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;


	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & AAD_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->Flags = 0;
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}

#endif // PERF


#if DBG

extern
VOID
AtmArpReferenceAtmEntryEx(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	AE_REFTYPE 						RefType
)
{
	AA_ASSERT(RefType>=0 && RefType < AE_REFTYPE_COUNT);
	pAtmEntry->Refs[RefType]++;
	// AA_ASSERT(pAtmEntry->Refs[RefType] < 128);
	AtmArpReferenceAtmEntry(pAtmEntry);

}

extern
ULONG
AtmArpDereferenceAtmEntryEx(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	AE_REFTYPE 					RefType,
	IN	BOOLEAN						fOkToDelete
)
{
	AA_ASSERT(RefType>=0 && RefType < AE_REFTYPE_COUNT);
	// AA_ASSERT(pAtmEntry->Refs[RefType]);
	pAtmEntry->Refs[RefType]--;

	if (fOkToDelete)
	{
		return AtmArpDereferenceAtmEntry(pAtmEntry);
	}
	else
	{
		AA_ASSERT(pAtmEntry->RefCount);
		return --(pAtmEntry->RefCount);
	}
}


extern
VOID
AtmArpReferenceIPEntryEx(
	IN PATMARP_IP_ENTRY				pIpEntry,
	IN IE_REFTYPE 					RefType
)
{
	AA_ASSERT(RefType>=0 && RefType < IE_REFTYPE_COUNT);
	pIpEntry->Refs[RefType]++;
	// AA_ASSERT(pIpEntry->Refs[RefType] < 128);
	AtmArpReferenceIPEntry(pIpEntry);
}

extern
ULONG
AtmArpDereferenceIPEntryEx(
	IN	PATMARP_IP_ENTRY			pIpEntry,
	IN	IE_REFTYPE 					RefType,
	IN	BOOLEAN						fOkToDelete
)
{
	AA_ASSERT(RefType>=0 && RefType < IE_REFTYPE_COUNT);
	// AA_ASSERT(pIpEntry->Refs[RefType]);
	pIpEntry->Refs[RefType]--;
	if (fOkToDelete)
	{
		return AtmArpDereferenceIPEntry(pIpEntry);
	}
	else
	{
		AA_ASSERT(pIpEntry->RefCount);
		return --(pIpEntry->RefCount);
	}
}



VOID
AtmArpReferenceJoinEntryEx(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry,
	IN	ULONG						RefInfo
)
{
	AA_STRUCT_ASSERT(pJoinEntry, aamj);

	pJoinEntry->LastIncrRef = RefInfo;
	AtmArpReferenceJoinEntry(pJoinEntry);
}


ULONG
AtmArpDereferenceJoinEntryEx(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry,
	IN	ULONG						RefInfo
)
{
	AA_STRUCT_ASSERT(pJoinEntry, aamj);

	pJoinEntry->LastDecrRef = RefInfo;
	return (AtmArpDereferenceJoinEntry(pJoinEntry));
}


#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\callmgr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	callmgr.c	- Call Manager Interface routines.

Abstract:

	Call Manager Interface routines for the ATMARP Client, including
	NDIS entry points for that interface.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     02-15-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'RGMC'


VOID
AtmArpCoAfRegisterNotifyHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
)
/*++

Routine Description:

	This routine is called by NDIS when a Call manager registers its support
	for an Address Family over an adapter. If this is the Address Family we
	are interested in (UNI 3.1), then we start up all LIS' configured on
	this adapter.

Arguments:

	ProtocolBindingContext	- our context passed in NdisOpenAdapter, which is
							  a pointer to our Adapter structure.
	pAddressFamily			- points to a structure describing the Address Family
							  being registered by a Call Manager.

Return Value:

	None

--*/
{
	PATMARP_ADAPTER				pAdapter;
	PATMARP_INTERFACE			pInterface;			// Pointer to new ATMARP Interface
	ULONG						NumIFConfigured;	// # of LIS' over this adapter
	ULONG						NumIFActivated;		// # activated successfully here

	NDIS_STATUS					Status;
	NDIS_HANDLE					LISConfigHandle;	// Handle to per-LIS config

	struct LLIPBindInfo			BindInfo;
	BOOLEAN						bProcessingAf;

	//
	//  Initialize.
	//
	Status = NDIS_STATUS_SUCCESS;
	pAdapter = NULL_PATMARP_ADAPTER;
	LISConfigHandle = NULL;
	NumIFActivated = 0;
	bProcessingAf = FALSE;

	do
	{
		//
		//  Check if this AF is interesting to us.
		//
		if ((pAddressFamily->AddressFamily != CO_ADDRESS_FAMILY_Q2931) ||
			(pAddressFamily->MajorVersion != 3) ||
			(pAddressFamily->MinorVersion != 1))
		{
			AADEBUGP(AAD_LOUD, 
			("CoAfRegisterNotifyHandler: uninteresting AF %d or MajVer %d or MinVer %d\n",
				pAddressFamily->AddressFamily,
				pAddressFamily->MajorVersion,
				pAddressFamily->MinorVersion));
			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		pAdapter = (PATMARP_ADAPTER)ProtocolBindingContext;
		AA_STRUCT_ASSERT(pAdapter, aaa);

		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		if (pAdapter->Flags & AA_ADAPTER_FLAGS_UNBINDING)
		{
			AADEBUGP(AAD_INFO,
				("CoAfRegisterNotify: Adapter %x is unbinding, bailing out\n", pAdapter));

    		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  If we have already created LIS' on this adapter, we don't want
		//  to open this Call Manager (multiple Call Managers supporting the
		//  same AF on the same adapter?)
		//
		if (pAdapter->pInterfaceList != NULL_PATMARP_INTERFACE)
		{
			AADEBUGP(AAD_WARNING,
				("CoAfRegisterNotifyHandler: pAdapter 0x%x, IFs (%x) already created!\n",
				pAdapter, pAdapter->pInterfaceList));
    		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		if (pAdapter->Flags & AA_ADAPTER_FLAGS_PROCESSING_AF)
		{
			AADEBUGP(AAD_WARNING,
				("CoAfRegisterNotifyHandler: pAdapter 0x%x, Already processing AF!\n",
				pAdapter));
    		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Make sure that we don't let an UnbindAdapter thread preempt us.
		//
		AA_INIT_BLOCK_STRUCT(&pAdapter->UnbindBlock);
		pAdapter->Flags |= AA_ADAPTER_FLAGS_PROCESSING_AF;
		bProcessingAf = TRUE;

		if (pAdapter->Flags & AA_ADAPTER_FLAGS_AF_NOTIFIED)
		{
			//
			// This can happen when resuming from suspend/hibernate, since
			// we do not get unbound from the adapter. All IFs go away,
			// but the adapter remains.
			//
			// So we skip the one-time init stuff (see below), but go ahead
			// and process the AF and create IFs now.
			//
			AADEBUGP(AAD_WARNING,
				("CoAfRegisterNotify: Adapter %x seen AF notify already, Flags %x\n",
					pAdapter, pAdapter->Flags));
    		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		}
		else
		{
			//
			// Do one-time init stuff for this adapter.
			//

			pAdapter->Flags |= AA_ADAPTER_FLAGS_AF_NOTIFIED;
			AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);


			//
			//  Query the adapter (miniport) for information about the adapter
			//  we are bound to.
			//
			Status = AtmArpGetAdapterInfo(pAdapter);
			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_WARNING,
							("CoAfRegisterNotifyHandler: Failed to get adapter info.\n"));
				break;
			}
	
			//
			// Read the adapter's configuration information from the registry.
			//
			Status =  AtmArpCfgReadAdapterConfiguration(pAdapter);
			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_WARNING,
							("CoAfRegisterNotifyHandler: Failed to open adapter configuration\n"));
				break;
			}
		}

		AADEBUGP(AAD_WARNING,
			("CoAfRegisterNotify: Adapter %x/%x, starting up\n", pAdapter, pAdapter->Flags));

		//
		//  Initialize some variables so that we know if we failed
		//  somewhere in the following loop.
		//
		LISConfigHandle = NULL;
		pInterface = NULL_PATMARP_INTERFACE;

		//
		//  Set up IP and NDIS interfaces for each LIS configured
		//  for this adapter. Loop while there are more LIS'.
		//
		for (NumIFConfigured = 0;
				;					// Stop only on error or no more LIS
			 NumIFConfigured++)
		{
#ifdef NEWARP
			//
			//  TCP/IP's Configuration section for this interface.
			//
			NDIS_STRING			IPConfigString;
#endif // NEWARP

			//
			//  Process LIS # NumIFConfigured.
			//

			//  Open the configuration section for this LIS. We use
			//  "NumIFConfigured" as the index of the LIS to be opened.
			//
			LISConfigHandle = AtmArpCfgOpenLISConfiguration(
										pAdapter,
										NumIFConfigured
#ifdef NEWARP
										,
										&IPConfigString
#endif // NEWARP
										);

			if (LISConfigHandle == NULL)
			{
				//
				//  This is the normal termination condition, i.e.
				//  we reached the end of the LIS list for this
				//  adapter.
				//
				AADEBUGP(AAD_INFO, ("NotifyRegAfHandler: cannot open LIS %d\n",
							NumIFConfigured));
				Status = NDIS_STATUS_SUCCESS;
				break; // out of for loop
			}


			pInterface =  AtmArpAddInterfaceToAdapter (
							pAdapter,
							LISConfigHandle,
							&IPConfigString
							);

			//
			//  Close the configuration section for this LIS.
			//
			AtmArpCfgCloseLISConfiguration(LISConfigHandle);
			LISConfigHandle = NULL;

			if (pInterface == NULL_PATMARP_INTERFACE)
			{
				Status = NDIS_STATUS_FAILURE;
				break;
			}


		}	// for

	}
	while (FALSE);


	if (NumIFActivated > 0)
	{
		//
		//  We managed to activate atleast one Logical IP Subnet
		//  on this adapter.
		//
		pAdapter->InterfaceCount = NumIFActivated;
	}

	if (bProcessingAf)
	{
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		pAdapter->Flags &= ~AA_ADAPTER_FLAGS_PROCESSING_AF;
		AA_SIGNAL_BLOCK_STRUCT(&pAdapter->UnbindBlock, NDIS_STATUS_SUCCESS);
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	}

	return;

}


NDIS_STATUS
AtmArpOpenCallMgr(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Start access to the Call Manager on the specified Interface,
	by doing the following:
		- Open Address Family

	For all of these, we wait for completion in case they pend.

	It is assumed that the Interface structure is locked.

Arguments:

	pInterface	- pointer to the ATMARP interface

Return Value:

	NDIS status.

--*/
{
	PCO_ADDRESS_FAMILY		pAddressFamily;
	NDIS_STATUS				Status;
	ULONG					RequestSize;

	pAddressFamily = (PCO_ADDRESS_FAMILY)NULL;
	Status = NDIS_STATUS_SUCCESS;


	do {

		//
		//  Allocate everything we need
		//
		RequestSize = sizeof(CO_ADDRESS_FAMILY)+
						sizeof(CO_SAP)+
						sizeof(ATM_SAP)+
						sizeof(ATM_ADDRESS);
		AA_ALLOC_MEM(
						pAddressFamily,
						CO_ADDRESS_FAMILY,
						RequestSize
					);

		if (pAddressFamily == (PCO_ADDRESS_FAMILY)NULL)
		{
			AADEBUGP(AAD_ERROR, ("OpenCallMgr: alloc failed!\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  DONT remove the following
		//
		AA_SET_MEM((PUCHAR)pAddressFamily, 0, RequestSize);
	
		//
		//  The Address Family we are interested in is Q.2931 (UNI 3.1)
		//
		pAddressFamily->AddressFamily = CO_ADDRESS_FAMILY_Q2931;
		pAddressFamily->MajorVersion = 3;
		pAddressFamily->MinorVersion = 1;

		AA_INIT_BLOCK_STRUCT(&(pInterface->Block));
		Status = NdisClOpenAddressFamily(
					pInterface->NdisAdapterHandle,
					pAddressFamily,
					(NDIS_HANDLE)pInterface,
					&AtmArpClientCharacteristics,
					sizeof(AtmArpClientCharacteristics),
					&(pInterface->NdisAfHandle)
				);

		if (Status == NDIS_STATUS_PENDING)
		{
			//
			//  Wait for completion
			//
			Status = AA_WAIT_ON_BLOCK_STRUCT(&(pInterface->Block));
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_ERROR, ("Open Af returned error: 0x%x\n", Status));
			break;
		}

		AADEBUGP(AAD_INFO, ("Interface: 0x%x, Got NdisAfHandle: 0x%x\n",
						pInterface, pInterface->NdisAfHandle));

		break;
	}
	while (FALSE);

	if (pAddressFamily != (PCO_ADDRESS_FAMILY)NULL)
	{
		AA_FREE_MEM(pAddressFamily);
	}

	AADEBUGP(AAD_LOUD, ("Open Call Mgr returning 0x%x\n", Status));

	return (Status);

}



VOID
AtmArpCloseCallMgr(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Halt access to the Call Manager on the specified interface. It is
	assumed that all VCs and SAPs pertaining to the "Address Family Open"
	have been released.

Arguments:

	pInterface	- pointer to the ATMARP interface

Return Value:

	None

--*/
{
	NDIS_STATUS		Status;
	NDIS_HANDLE		NdisAfHandle;

	NdisAfHandle = pInterface->NdisAfHandle;
	pInterface->NdisAfHandle = NULL;

	AADEBUGP(AAD_INFO,
		 ("Closing Call Mgr on Interface: 0x%x, AfH: 0x%x\n",
			 pInterface, NdisAfHandle));

	if (NdisAfHandle != (NDIS_HANDLE)NULL)
	{
		Status = NdisClCloseAddressFamily(NdisAfHandle);

		AADEBUGP(AAD_INFO, ("NdisClCloseAF on IF 0x%x returned 0x%x\n",
			 pInterface, Status));

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpCloseAfCompleteHandler(
					Status,
					(NDIS_HANDLE)pInterface
					);
		}
	}
}




VOID
AtmArpRegisterSaps(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Register all SAPs configured on the given ATMARP interface.
	Atleast one SAP must be present in the list of SAPs on the
	interface.

	We just issue the NdisClRegisterSap requests for all SAPs.
	We don't wait for completion.

Arguments:

	pInterface			- Pointer to ATMARP Interface

Return Value:

	None

--*/
{
	PATMARP_SAP					pAtmArpSap;
	PATMARP_SAP					pNextSap;
	PCO_SAP						pSapInfo;
	NDIS_STATUS					Status;
	NDIS_HANDLE					NdisAfHandle;
	ULONG						rc;				// Ref count on Interface

	AA_ACQUIRE_IF_LOCK(pInterface);

	AA_ASSERT(pInterface->NumberOfSaps > 0);

	//
	//  Initialize
	//
	pAtmArpSap = &(pInterface->SapList);
	NdisAfHandle = pInterface->NdisAfHandle;

	//
	//  Make sure that the Interface doesn't go away.
	//
	AtmArpReferenceInterface(pInterface);
	AA_RELEASE_IF_LOCK(pInterface);

	do
	{
		pSapInfo = pAtmArpSap->pInfo;
		pAtmArpSap->NdisSapHandle = NULL;
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_REG_STATE_MASK,
					AA_SAP_REG_STATE_REGISTERING);

		pNextSap = pAtmArpSap->pNextSap;

		//
		//  The ATMARP SAP structure itself won't go away as long as
		//  the Interface structure lives.
		//
		Status = NdisClRegisterSap(
						NdisAfHandle,
						(NDIS_HANDLE)pAtmArpSap,		// ProtocolSapContext
						pSapInfo,
						&(pAtmArpSap->NdisSapHandle)
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpRegisterSapCompleteHandler(
						Status,
						(NDIS_HANDLE)pAtmArpSap,
						pSapInfo,
						pAtmArpSap->NdisSapHandle
						);
		}

		pAtmArpSap = pNextSap;
	}
	while (pAtmArpSap != NULL_PATMARP_SAP);

	//
	//  Remove the reference we added earlier to the Interface.
	//
	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);
	if (rc > 0)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
	//
	//  else the Interface is gone!

}


VOID
AtmArpDeregisterSaps(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Deregister all SAPs on an ATMARP Interface. We issue NdisClDeregisterSap
	calls on all SAPs we have currently registered.

Arguments:

	pInterface			- Pointer to ATMARP Interface

Return Value:

	None

--*/
{
	NDIS_HANDLE					NdisSapHandle;
	ULONG						rc;				// Reference count on Interface
	PATMARP_SAP					pAtmArpSap;
	PATMARP_SAP					pNextSap;
	NDIS_STATUS					Status;

	AA_ACQUIRE_IF_LOCK(pInterface);

	//
	//  Initialize
	//
	pAtmArpSap = &(pInterface->SapList);

	//
	//  Make sure the Interface structure doesn't go away.
	//
	AtmArpReferenceInterface(pInterface);

	AA_RELEASE_IF_LOCK(pInterface);

	do
	{
		NdisSapHandle = pAtmArpSap->NdisSapHandle;
		pNextSap = pAtmArpSap->pNextSap;

		if (NdisSapHandle != NULL)
		{
			Status = NdisClDeregisterSap(NdisSapHandle);
			if (Status != NDIS_STATUS_PENDING)
			{
				AtmArpDeregisterSapCompleteHandler(
						Status,
						(NDIS_HANDLE)pAtmArpSap
						);
			}
		}

		pAtmArpSap = pNextSap;
	}
	while (pAtmArpSap != NULL_PATMARP_SAP);

	//
	//  Remove the reference we added earlier to the Interface.
	//
	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);
	if (rc > 0)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
	//
	//  else the interface is gone
	//
}



NDIS_STATUS
AtmArpMakeCall(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PNDIS_PACKET				pPacketToBeQueued	OPTIONAL
)
/*++

Routine Description:

	Place a call to the given destination. Map the specified flow
	specs to ATM QoS/Traffic parameters.

	NOTE: The caller is assumed to hold a lock for the ATM Entry,
	which will be released here. The reason we do it this way is so that
	nobody else can come in and try to make another call (of the same kind)
	to this ATM Entry -- once we get a new VC into the ATM Entry's list,
	we can release its lock.

	SIDE EFFECT: If the NDIS call doesn't pend, then we call our
	MakeCall completion handler from here, and return NDIS_STATUS_PENDING
	to the caller.


Arguments:

	pInterface			- the ARP Interface originating this call
	pAtmEntry			- Pointer to ATM Address Entry corresponding to the
						  called address.
	pFlowSpec			- pointer to a Flow Spec structure containing parameters
						  for the call
	pPacketToBeQueued	- Optionally, a packet to be queued for transmission when
						  the call is established.

Return Value:

	If there is an immediate failure (e.g. allocation failure), we return
	NDIS_STATUS_XXX denoting that failure.

	If we made it to the call to NdisClMakeCall(), we return NDIS_STATUS_PENDING.
	However, if NDIS returns other than NDIS_STATUS_PENDING, we'd also
	call our MakeCall completion handler.

--*/
{

	//
	//  New VC structure to be allocated for this call
	//
	PATMARP_VC								pVc;

	NDIS_HANDLE								NdisVcHandle;
	NDIS_HANDLE								ProtocolVcContext;
	NDIS_HANDLE								ProtocolPartyContext;
	PNDIS_HANDLE							pNdisPartyHandle;
	NDIS_STATUS								Status;
	BOOLEAN									IsPMP;
	PATM_ADDRESS							pCalledAddress;

	//
	//  Set of parameters for a MakeCall
	//
	PCO_CALL_PARAMETERS						pCallParameters;
	PCO_CALL_MANAGER_PARAMETERS				pCallMgrParameters;

	PQ2931_CALLMGR_PARAMETERS				pAtmCallMgrParameters;

	//
	//  All Info Elements that we need to fill:
	//
	Q2931_IE UNALIGNED *								pIe;
	AAL_PARAMETERS_IE UNALIGNED *						pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *				pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *		pBbc;
	ATM_BLLI_IE UNALIGNED *								pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *						pQos;

	//
	//  Total space requirements for the MakeCall
	//
	ULONG									RequestSize;

	//
	//  Did we queue the given packet?
	//
	BOOLEAN									PacketWasQueued = FALSE;


	AA_STRUCT_ASSERT(pInterface, aai);
	AA_STRUCT_ASSERT(pAtmEntry, aae);

	AA_ASSERT(pInterface->AdminState == IF_STATUS_UP);


	do
	{
		if (pPacketToBeQueued != (PNDIS_PACKET)NULL)
		{
			//
			// Make this a list of exactly one packet.
			//
			AA_SET_NEXT_PACKET(pPacketToBeQueued, NULL);
		}

		//
		// Fail makecall if atmentry state is really closing.
		//

		if (AA_IS_FLAG_SET(
								pAtmEntry->Flags,
								AA_ATM_ENTRY_STATE_MASK,
								AA_ATM_ENTRY_CLOSING))
		{
			BOOLEAN ReallyClosing = TRUE;

			//
			// This may be a harmless close -- if the interface is not shutting
			// down we check if it's a harmless close, else (if the interface
			// is shutting down) we fail the call anyway. Note that we don't
			// claim the interface list lock (which is used to guard access
			// to AtmEntryListUp) -- we don't do this because we currently
			// hold the lock to pAtmEntry (and don't want to release it), so if
			// AtmEntryListUp is in the
			// process of being set to FALSE, when we read it's value here,
			// in the worst case we'll read it's value as TRUE and conclude that
			// the atm entry is not really closing and go ahead and make the call.
			// However in this case, the shutdown routine will invalidate the call.
			//
			if (pInterface->AtmEntryListUp)
			{
				//
				// WARNING: AtmArpAtmEntryIsReallyClosing may clear the
				// CLOSING state (if the entry is basically idle) --
				// see comments in that function.
				//
				ReallyClosing =  AtmArpAtmEntryIsReallyClosing(pAtmEntry);
			}

			if (ReallyClosing)
			{
				AADEBUGP(AAD_FATAL,
			 ("AtmArpMakeCall -- failing because AE 0x%lx is really closing.\n",
			 	pAtmEntry));
				Status = NDIS_STATUS_FAILURE;
				break;
			}
		}

		//
		//  Some initialization.
		//


		if (AA_IS_FLAG_SET(pAtmEntry->Flags,
							AA_ATM_ENTRY_TYPE_MASK,
							AA_ATM_ENTRY_TYPE_UCAST))
		{
			IsPMP = FALSE;
			ProtocolPartyContext = NULL;
			pNdisPartyHandle = NULL;
			pCalledAddress = &(pAtmEntry->ATMAddress);
		}
#ifdef IPMCAST
		else
		{
			IsPMP = TRUE;
			ProtocolPartyContext = (NDIS_HANDLE)(pAtmEntry->pMcAtmInfo->pMcAtmEntryList);
			pNdisPartyHandle = &(pAtmEntry->pMcAtmInfo->pMcAtmEntryList->NdisPartyHandle);
			pCalledAddress = &(pAtmEntry->pMcAtmInfo->pMcAtmEntryList->ATMAddress);
		}
#else
		else
		{
			AA_ASSERT(FALSE);
		}
#endif // IPMCAST

		//
		//  Compute all the space needed for the MakeCall, and allocate it
		//  in one big block.
		//
		RequestSize = 	sizeof(CO_CALL_PARAMETERS) +
						sizeof(CO_CALL_MANAGER_PARAMETERS) +
						sizeof(Q2931_CALLMGR_PARAMETERS) +
						ATMARP_MAKE_CALL_IE_SPACE +
						0;

		AA_ALLOC_MEM(pCallParameters, CO_CALL_PARAMETERS, RequestSize);

		if (pCallParameters == (PCO_CALL_PARAMETERS)NULL)
		{
			AADEBUGP(AAD_WARNING, ("Make Call: alloc (%d) failed\n", RequestSize));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Allocate a VC structure for the call
		//
		pVc = AtmArpAllocateVc(pInterface);

		if (pVc == NULL_PATMARP_VC)
		{
			AADEBUGP(AAD_WARNING, ("Make Call: failed to allocate VC\n"));
			AA_FREE_MEM(pCallParameters);
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  For a later call to MakeCallComplete
		//
		ProtocolVcContext = (NDIS_HANDLE)pVc;

		//
		//  Get an NDIS handle for this VC
		//
		NdisVcHandle = (NDIS_HANDLE)NULL;
		Status = NdisCoCreateVc(
						pInterface->NdisAdapterHandle,
						pInterface->NdisAfHandle,
						ProtocolVcContext,
						&NdisVcHandle
						);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AA_ASSERT(Status != NDIS_STATUS_PENDING);

			AADEBUGP(AAD_WARNING, ("Make Call: NdisCoCreateVc failed: 0x%x\n", Status));
			AA_FREE_MEM(pCallParameters);
			AtmArpDeallocateVc(pVc);
			break;
		}

		AADEBUGP(AAD_VERY_LOUD,
			("Make Call: pAtmEntry 0x%x, pVc 0x%x, got NdisVcHandle 0x%x\n",
				pAtmEntry,
				pVc,
				NdisVcHandle));

		AtmArpReferenceVc(pVc);	// CreateVC reference

		//
		//  At this point, we are sure that we will call NdisClMakeCall.
		//

		//
		//  Now fill in the rest of the VC structure. We don't need a lock
		//  for the VC until it gets linked to the ATM Entry structure.
		//
		pVc->NdisVcHandle = NdisVcHandle;
		pVc->Flags = 	AA_VC_TYPE_SVC |
						AA_VC_OWNER_IS_ATMARP |
						AA_VC_CALL_STATE_OUTGOING_IN_PROGRESS;
		if (IsPMP)
		{
			pVc->Flags |= AA_VC_CONN_TYPE_PMP;
		}
		else
		{
			pVc->Flags |= AA_VC_CONN_TYPE_P2P;
		}
		pVc->FlowSpec = *pFlowSpec;

		//
		//  Make sure that the packet sizes are within the miniport's range.
		//
		if (pVc->FlowSpec.SendMaxSize > pInterface->pAdapter->MaxPacketSize)
		{
			pVc->FlowSpec.SendMaxSize = pInterface->pAdapter->MaxPacketSize;
		}
		if (pVc->FlowSpec.ReceiveMaxSize > pInterface->pAdapter->MaxPacketSize)
		{
			pVc->FlowSpec.ReceiveMaxSize = pInterface->pAdapter->MaxPacketSize;
		}

		if (pPacketToBeQueued != (PNDIS_PACKET)NULL)
		{
			pVc->PacketList = pPacketToBeQueued;
			PacketWasQueued = TRUE;
		}

#ifdef IPMCAST
		AtmArpFillCallParameters(
				pCallParameters,
				RequestSize,
				pCalledAddress,
				&(pInterface->LocalAtmAddress),	// Calling address
				&(pVc->FlowSpec),
				IsPMP,
				TRUE	// IsMakeCall?
				);
#else
		//
		//  Zero out everything
		//
		AA_SET_MEM((PUCHAR)pCallParameters, 0, RequestSize);

		//
		//  Distribute space amongst the various structures
		//
		pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
								((PUCHAR)pCallParameters +
									 sizeof(CO_CALL_PARAMETERS));


		//
		//  Set pointers to link the above structures together
		//
		pCallParameters->CallMgrParameters = pCallMgrParameters;
		pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;

		pCallMgrParameters->CallMgrSpecific.ParamType = 0;
		pCallMgrParameters->CallMgrSpecific.Length = 
							sizeof(Q2931_CALLMGR_PARAMETERS) +
							ATMARP_CALL_IE_SPACE;

		pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
									pCallMgrParameters->CallMgrSpecific.Parameters;


		//
		//  Call Manager generic flow parameters:
		//
		pCallMgrParameters->Transmit.TokenRate = (pFlowSpec->SendAvgBandwidth);
		pCallMgrParameters->Transmit.TokenBucketSize = (pFlowSpec->SendMaxSize);
		pCallMgrParameters->Transmit.MaxSduSize = pFlowSpec->SendMaxSize;
		pCallMgrParameters->Transmit.PeakBandwidth = (pFlowSpec->SendPeakBandwidth);
		pCallMgrParameters->Transmit.ServiceType = pFlowSpec->SendServiceType;

		pCallMgrParameters->Receive.TokenRate = (pFlowSpec->ReceiveAvgBandwidth);
		pCallMgrParameters->Receive.TokenBucketSize = pFlowSpec->ReceiveMaxSize;
		pCallMgrParameters->Receive.MaxSduSize = pFlowSpec->ReceiveMaxSize;
		pCallMgrParameters->Receive.PeakBandwidth = (pFlowSpec->ReceivePeakBandwidth);
		pCallMgrParameters->Receive.ServiceType = pFlowSpec->ReceiveServiceType;

		//
		//  Q2931 Call Manager Parameters:
		//

		//
		//  Called address:
		//
		//  TBD: Add Called Subaddress IE in outgoing call.
		//
		AA_COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CalledParty),
					  (PUCHAR)&(pAtmEntry->ATMAddress),
					  sizeof(ATM_ADDRESS));

		//
		//  Calling address:
		//
		AA_COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CallingParty),
					  (PUCHAR)&(pInterface->LocalAtmAddress),
					  sizeof(ATM_ADDRESS));


		//
		//  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
		//  SETUP message, so fill them all.
		//
		//      AAL Parameters
		//      Traffic Descriptor
		//      Broadband Bearer Capability
		//      Broadband Low Layer Info
		//      QoS
		//

		//
		//  Initialize the Info Element list
		//
		pAtmCallMgrParameters->InfoElementCount = 0;
		pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


		//
		//  AAL Parameters:
		//

		{
			UNALIGNED AAL5_PARAMETERS	*pAal5;

			pIe->IEType = IE_AALParameters;
			pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
			pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
			pAalIe->AALType = AAL_TYPE_AAL5;
			pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
			pAal5->ForwardMaxCPCSSDUSize = pFlowSpec->SendMaxSize;
			pAal5->BackwardMaxCPCSSDUSize = pFlowSpec->ReceiveMaxSize;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


		//
		//  Traffic Descriptor:
		//

		pIe->IEType = IE_TrafficDescriptor;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
		pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendPeakBandwidth);
			pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 = 
									BYTES_TO_CELLS(pFlowSpec->ReceivePeakBandwidth);
			pTrafficDescriptor->BestEffort = TRUE;
		}
		else
		{
			//  Predictive/Guaranteed service (we map this to CBR, see BBC below)
				pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendPeakBandwidth);
				pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->ReceivePeakBandwidth);
			pTrafficDescriptor->BestEffort = FALSE;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


		//
		//  Broadband Bearer Capability
		//

		pIe->IEType = IE_BroadbandBearerCapability;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
		pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;

		pBbc->BearerClass = BCOB_X;
		pBbc->UserPlaneConnectionConfig = UP_P2P;
		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pBbc->TrafficType = TT_NOIND;
			pBbc->TimingRequirements = TR_NOIND;
			pBbc->ClippingSusceptability = CLIP_NOT;
		}
		else
		{
			pBbc->TrafficType = TT_CBR;
			pBbc->TimingRequirements = TR_END_TO_END;
			pBbc->ClippingSusceptability = CLIP_SUS;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


		//
		//  Broadband Lower Layer Information
		//

		pIe->IEType = IE_BLLI;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
		pBlli = (PATM_BLLI_IE)pIe->IE;
		AA_COPY_MEM((PUCHAR)pBlli,
					  (PUCHAR)&AtmArpDefaultBlli,
					  sizeof(ATM_BLLI_IE));

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


		//
		//  QoS
		//

		pIe->IEType = IE_QOSClass;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
		pQos = (PATM_QOS_CLASS_IE)pIe->IE;
		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 0;
		}
		else
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 1;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
#endif // IPMCAST

		//
		//  We add the Call reference and ATM Entry Link reference
		//  right here
		//
		AtmArpReferenceVc(pVc);	// Call reference (MakeCall coming up)
		AtmArpReferenceVc(pVc);	// ATM Entry link reference (coming up below)

#ifdef IPMCAST
		if (IsPMP)
		{
			pAtmEntry->pMcAtmInfo->TransientLeaves++;
		}
#endif // IPMCAST

		//
		//  We are ready to make the call. Before we do so, we need to
		//  link the VC structure to the ATM Entry, and release the
		//  ATM Entry lock
		//
		AtmArpLinkVcToAtmEntry(pVc, pAtmEntry);
		AA_RELEASE_AE_LOCK(pAtmEntry);	// acquired by caller

		//
		//  Make the Call now
		//
		Status = NdisClMakeCall(
						NdisVcHandle,
						pCallParameters,
						ProtocolPartyContext,
						pNdisPartyHandle
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			NDIS_HANDLE			NdisPartyHandle;

			NdisPartyHandle = ((pNdisPartyHandle != NULL)?
								*pNdisPartyHandle : NULL);

			AtmArpMakeCallCompleteHandler(
						Status,
						ProtocolVcContext,
						NdisPartyHandle,
						pCallParameters
						);
			Status = NDIS_STATUS_PENDING;
		}
		//
		//  else the MakeCall complete handler will be called
		//  later
		//

	} while (FALSE);

	if (Status != NDIS_STATUS_PENDING)
	{
		ULONG		Flags;
		//
		//  Something failed within this routine.
		//  Recovery:
		//  - Release the ATM Entry lock
		//  - If we were given a packet for queueing, and we didn't do so,
		//    then free it
		//
		Flags = pAtmEntry->Flags;
		AA_RELEASE_AE_LOCK(pAtmEntry);	// acquired by caller
		if ((pPacketToBeQueued != (PNDIS_PACKET)NULL) && (!PacketWasQueued))
		{
			AA_HEADER_TYPE		HdrType;
			BOOLEAN				HdrPresent;

			if (pFlowSpec->Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
			{
				HdrPresent = TRUE;
				if (AA_IS_FLAG_SET(Flags,
									AA_ATM_ENTRY_TYPE_MASK,
									AA_ATM_ENTRY_TYPE_UCAST))
				{
					HdrType = AA_HEADER_TYPE_UNICAST;
				}
				else
				{
					HdrType = AA_HEADER_TYPE_NUNICAST;
				}
			}
			else
			{
				HdrPresent = FALSE;
				HdrType = AA_HEADER_TYPE_NONE;
			}

			AtmArpFreeSendPackets(
					pInterface,
					pPacketToBeQueued,
					HdrPresent
					);
		}
	}

	AADEBUGP(AAD_VERY_LOUD, ("Make Call: VC: 0x%x, returning status 0x%x\n",
						pVc, Status));

	return Status;
}




VOID
AtmArpFillCallParameters(
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN	ULONG						ParametersSize,
	IN	PATM_ADDRESS				pCalledAddress,
	IN	PATM_ADDRESS				pCallingAddress,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	BOOLEAN						IsPMP,
	IN	BOOLEAN						IsMakeCall
)
/*++

Routine Description:

	Fill in a Call Parameters structure with the given information,
	thus making it ready for use in an NdisClMakeCall/NdisClAddParty
	call.

Arguments:

	pCallParameters			- points to structure to be filled in.
	ParametersSize			- size of the above
	pCalledAddress			- points to called ATM address
	pCallingAddress			- points to calling ATM address
	pFlowSpec				- points to Flow spec for this connection
	IsPMP					- Is this a point to multipoint connection?
	IsMakeCall				- Is this for MakeCall (FALSE => AddParty)

Return Value:

	None

--*/
{
	PCO_CALL_MANAGER_PARAMETERS				pCallMgrParameters;

	PQ2931_CALLMGR_PARAMETERS				pAtmCallMgrParameters;

	//
	//  All Info Elements that we need to fill:
	//
	Q2931_IE UNALIGNED *								pIe;
	AAL_PARAMETERS_IE UNALIGNED *						pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *				pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *		pBbc;
	ATM_BLLI_IE UNALIGNED *								pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *						pQos;

	//
	//  Zero out everything. Don't remove this!
	//
	AA_SET_MEM((PUCHAR)pCallParameters, 0, ParametersSize);

	//
	//  Distribute space amongst the various structures
	//
	pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
							((PUCHAR)pCallParameters +
 								sizeof(CO_CALL_PARAMETERS));


	//
	//  Set pointers to link the above structures together
	//
	pCallParameters->CallMgrParameters = pCallMgrParameters;
	pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;


	pCallMgrParameters->CallMgrSpecific.ParamType = 0;
	pCallMgrParameters->CallMgrSpecific.Length = 
						sizeof(Q2931_CALLMGR_PARAMETERS) +
						(IsMakeCall? ATMARP_MAKE_CALL_IE_SPACE: ATMARP_ADD_PARTY_IE_SPACE);

	pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
								pCallMgrParameters->CallMgrSpecific.Parameters;

	if (IsPMP)
	{
		pCallParameters->Flags |= MULTIPOINT_VC;
	}

	//
	//  Call Manager generic flow parameters:
	//
	pCallMgrParameters->Transmit.TokenRate = (pFlowSpec->SendAvgBandwidth);
	pCallMgrParameters->Transmit.TokenBucketSize = (pFlowSpec->SendMaxSize);
	pCallMgrParameters->Transmit.MaxSduSize = pFlowSpec->SendMaxSize;
	pCallMgrParameters->Transmit.PeakBandwidth = (pFlowSpec->SendPeakBandwidth);
	pCallMgrParameters->Transmit.ServiceType = pFlowSpec->SendServiceType;

	if ((!IsPMP) && (IsMakeCall))
	{
		pCallMgrParameters->Receive.TokenRate = (pFlowSpec->ReceiveAvgBandwidth);
		pCallMgrParameters->Receive.TokenBucketSize = pFlowSpec->ReceiveMaxSize;
		pCallMgrParameters->Receive.MaxSduSize = pFlowSpec->ReceiveMaxSize;
		pCallMgrParameters->Receive.PeakBandwidth = (pFlowSpec->ReceivePeakBandwidth);
		pCallMgrParameters->Receive.ServiceType = pFlowSpec->ReceiveServiceType;
	}
	else
	{
		//
		//  else receive side values are 0's.
		//
		pCallMgrParameters->Receive.ServiceType = SERVICETYPE_NOTRAFFIC;
	}
	
	//
	//  Q2931 Call Manager Parameters:
	//

	//
	//  Called address:
	//
	//  TBD: Add Called Subaddress IE in outgoing call.
	//
	AA_COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CalledParty),
  				(PUCHAR)pCalledAddress,
  				sizeof(ATM_ADDRESS));

	//
	//  Calling address:
	//
	AA_COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CallingParty),
  				(PUCHAR)pCallingAddress,
  				sizeof(ATM_ADDRESS));


	//
	//  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
	//  SETUP message, so fill them all.
	//
	//      AAL Parameters
	//      Traffic Descriptor (only for MakeCall)
	//      Broadband Bearer Capability (only for MakeCall)
	//      Broadband Low Layer Info
	//      QoS (only for MakeCall)
	//

	//
	//  Initialize the Info Element list
	//
	pAtmCallMgrParameters->InfoElementCount = 0;
	pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


	//
	//  AAL Parameters:
	//

	{
		UNALIGNED AAL5_PARAMETERS	*pAal5;

		pIe->IEType = IE_AALParameters;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
		pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
		pAalIe->AALType = AAL_TYPE_AAL5;
		pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
		pAal5->ForwardMaxCPCSSDUSize = pFlowSpec->SendMaxSize;
		pAal5->BackwardMaxCPCSSDUSize = pFlowSpec->ReceiveMaxSize;
	}

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


#ifdef PREPARE_IES_OURSELVES
	//
	//  Let the Call Manager convert from generic flow spec to Traffic Descr,
	//  Broadband Bearer Cap, and QoS.
	//

	//
	//  Traffic Descriptor:
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_TrafficDescriptor;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
		pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendPeakBandwidth);
			if (!IsPMP)
			{
				pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 = 
									BYTES_TO_CELLS(pFlowSpec->ReceivePeakBandwidth);
			}
			//
			//  else we have zero'ed out everything, which is what we want.
			//
			pTrafficDescriptor->BestEffort = TRUE;
		}
		else
		{
			//  Predictive/Guaranteed service (we map this to CBR, see BBC below)
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendPeakBandwidth);
			if (!IsPMP)
			{
				pTrafficDescriptor->BackwardTD.PeakCellRateCLP01 =
										BYTES_TO_CELLS(pFlowSpec->ReceivePeakBandwidth);
			}
			//
			//  else we have zero'ed out everything, which is what we want.
			//
			pTrafficDescriptor->BestEffort = FALSE;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}


	//
	//  Broadband Bearer Capability
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_BroadbandBearerCapability;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
		pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;

		pBbc->BearerClass = BCOB_X;
		pBbc->UserPlaneConnectionConfig = (IsPMP ? UP_P2MP: UP_P2P);
		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pBbc->TrafficType = TT_NOIND;
			pBbc->TimingRequirements = TR_NOIND;
			pBbc->ClippingSusceptability = CLIP_NOT;
		}
		else
		{
			pBbc->TrafficType = TT_CBR;
			pBbc->TimingRequirements = TR_END_TO_END;
			pBbc->ClippingSusceptability = CLIP_SUS;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}

#endif // PREPARE_IES_OURSELVES

	//
	//  Broadband Lower Layer Information
	//

	pIe->IEType = IE_BLLI;
	pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
	pBlli = (PATM_BLLI_IE)pIe->IE;
	AA_COPY_MEM((PUCHAR)pBlli,
  				(PUCHAR)&AtmArpDefaultBlli,
  				sizeof(ATM_BLLI_IE));

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


#ifdef PREPARE_IES_OURSELVES
	//
	//  QoS
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_QOSClass;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
		pQos = (PATM_QOS_CLASS_IE)pIe->IE;
		if (pFlowSpec->SendServiceType == SERVICETYPE_BESTEFFORT)
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 0;
		}
		else
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 1;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}

#endif // PREPARE_IES_OURSELVES

}



#ifdef IPMCAST

BOOLEAN
AtmArpMcPrepareAtmEntryForClose(
	IN	PATMARP_ATM_ENTRY			pAtmEntry		LOCKIN	LOCKOUT
)
/*++

Routine Description:

	Prepare an ATM Entry that has an outgoing PMP call on it, for Close Call.
	This means that we drop all but the last leaf on this PMP call.

	NOTE: The caller is assumed to hold the ATM Entry lock

Arguments:

	pAtmEntry	- Points to ATM Entry representing a PMP call

Return Value:

	TRUE iff the connection on this ATM Entry is ready for CloseCall.

--*/
{
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_IPMC_ATM_ENTRY		pNextMcAtmEntry;
	PATMARP_INTERFACE			pInterface;
	NDIS_HANDLE					NdisPartyHandle;
	NDIS_STATUS					Status;

	AA_ASSERT(pAtmEntry->pMcAtmInfo->TransientLeaves == 0);
	AA_ASSERT(pAtmEntry->pVcList != NULL_PATMARP_VC);

	pInterface = pAtmEntry->pInterface;

	AAMCDEBUGP(AAD_EXTRA_LOUD,
		("McPrepareAtmEntryForClose: pAtmEntry 0x%x, McList 0x%x, ActiveLeaves %d\n",
			pAtmEntry,
			pAtmEntry->pMcAtmInfo->pMcAtmEntryList,
			pAtmEntry->pMcAtmInfo->ActiveLeaves));


	//
	//  First, prune all members that aren't connected.
	//
	for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
		 pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
		 pMcAtmEntry = pNextMcAtmEntry)
	{
		pNextMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

		//
		//  Stop any timer running here.
		//
		(VOID)AtmArpStopTimer(&(pMcAtmEntry->Timer), pInterface);

		if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_DISCONNECTED))
		{
			AtmArpMcUnlinkAtmMember(
					pAtmEntry,
					pMcAtmEntry
					);
		}
	}


	//
	//  Next, send drop party requests for all but one member.
	//
	while (pAtmEntry->pMcAtmInfo->ActiveLeaves > 1)
	{
		for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
			 /* NONE */;
			 pMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry)
		{
			AA_ASSERT(pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY);
			if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
								AA_IPMC_AE_CONN_STATE_MASK,
								AA_IPMC_AE_CONN_ACTIVE))
			{
				break;
			}
		}

		NdisPartyHandle = pMcAtmEntry->NdisPartyHandle;

		AAMCDEBUGP(AAD_INFO,
		 ("PrepareAtmEntry: pAtmEntry 0x%x, will DropPty, McAtmEnt 0x%x, PtyHnd 0x%x\n",
		 		pAtmEntry, pMcAtmEntry, NdisPartyHandle));

		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_WACK_DROP_PARTY);

		pAtmEntry->pMcAtmInfo->ActiveLeaves--;

		AA_RELEASE_AE_LOCK(pAtmEntry);

		Status = NdisClDropParty(
					NdisPartyHandle,
					NULL,		// Buffer
					(UINT)0		// Size
					);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpDropPartyCompleteHandler(
					Status,
					(NDIS_HANDLE)pMcAtmEntry
					);
		}

		AA_ACQUIRE_AE_LOCK(pAtmEntry);
	}

	//
	//  Now, if we have exactly one ATM member in the list of
	//  leaves for this PMP, we can CloseCall.
	//
	if (pAtmEntry->pMcAtmInfo->pMcAtmEntryList->pNextMcAtmEntry ==
			NULL_PATMARP_IPMC_ATM_ENTRY)
	{
		return (TRUE);
	}
	else
	{
		return (FALSE);
	}
}

#endif // IPMCAST
	



VOID
AtmArpCloseCall(
	IN	PATMARP_VC					pVc		LOCKIN	NOLOCKOUT
)
/*++

Routine Description:

	Closes an existing call on a VC. It is assumed that a call exists
	on the VC.

	NOTE: The caller is assumed to hold a lock to the VC structure,
	and it will be released here.

	SIDE EFFECT: If the NDIS call returns other than NDIS_STATUS_PENDING,
	we call our CloseCall Complete handler from here.

Arguments:

	pVc			- Pointer to ATMARP VC structure.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PATMARP_ATM_ENTRY		pAtmEntry;

	NDIS_HANDLE				NdisVcHandle;
	NDIS_HANDLE				ProtocolVcContext;
#ifdef IPMCAST
	NDIS_HANDLE				NdisPartyHandle;
#endif
	NDIS_STATUS				Status;
	PNDIS_PACKET			PacketList;		// Packets queued on this VC
	AA_HEADER_TYPE			HdrType;		// for queued packets
	BOOLEAN					HdrPresent;		// for queued packets
	BOOLEAN					WasRunning;		// Was a timer running on this VC?
	BOOLEAN					IsPMP;			// Is this a PMP call?
	ULONG					rc;				// Ref Count on this VC.

	AA_STRUCT_ASSERT(pVc, avc);

	NdisVcHandle = pVc->NdisVcHandle;
	ProtocolVcContext = (NDIS_HANDLE)pVc;
	pInterface = pVc->pInterface;
	IsPMP = AA_IS_FLAG_SET(pVc->Flags,
							AA_VC_CONN_TYPE_MASK,
							AA_VC_CONN_TYPE_PMP);

	AADEBUGP(AAD_INFO,
		("Closing call on VC 0x%x, VC Flags 0x%x, Ref %d, NdisVcHandle 0x%x\n",
					pVc, pVc->Flags, pVc->RefCount, NdisVcHandle));

	//
	//  Remove the list of packets queued on this VC.
	//
	PacketList = pVc->PacketList;
	pVc->PacketList = (PNDIS_PACKET)NULL;
	if (pVc->FlowSpec.Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
	{
		HdrType = (IsPMP ? AA_HEADER_TYPE_NUNICAST: AA_HEADER_TYPE_UNICAST);
		HdrPresent = TRUE;
	}
	else
	{
		HdrType = AA_HEADER_TYPE_NONE;
		HdrPresent = FALSE;
	}


	//
	//  Stop any timer running on this VC.
	//
	WasRunning = AtmArpStopTimer(&(pVc->Timer), pInterface);

	if (WasRunning)
	{
		//
		//  Remove the timer reference on this VC.
		//
		rc = AtmArpDereferenceVc(pVc);
	}
	else
	{
		rc = pVc->RefCount;
	}

#ifdef GPC
	//
	//  If this VC is associated with a Flow, unlink them.
	//
	if (rc != 0)
	{
		if (pVc->FlowHandle != NULL)
		{
			PATMARP_FLOW_INFO		pFlowInfo = (PATMARP_FLOW_INFO)pVc->FlowHandle;

			if ((PVOID)pVc == InterlockedCompareExchangePointer(
									&(pFlowInfo->VcContext),
									NULL,
									pVc
							  		))
			{
				pVc->FlowHandle = NULL;
				rc = AtmArpDereferenceVc(pVc);	// Unlink from GPC Flow
			}
		}
	}
#endif // GPC


	if (rc != 0)
	{
		//
		//  Check the call state on this VC. If the call is active and
		//  we have no sends going on, then we close the call.
		//  Otherwise, simply mark the VC as closing. We will continue
		//  this process when the current operation on the VC completes.
		//

		if (AA_IS_FLAG_SET(pVc->Flags,
							AA_VC_CALL_STATE_MASK,
							AA_VC_CALL_STATE_ACTIVE) &&
			(pVc->OutstandingSends == 0))
		{
			//
			//  Set VC call state to "Close Call in progress" so that we don't
			//  reenter here.
			//
			AA_SET_FLAG(
					pVc->Flags,
					AA_VC_CALL_STATE_MASK,
					AA_VC_CALL_STATE_CLOSE_IN_PROGRESS);

#ifdef IPMCAST
			if (IsPMP)
			{
				PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;	// last leaf

				pAtmEntry = pVc->pAtmEntry;

				AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);
				AA_ASSERT(pAtmEntry->pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);

				if (pAtmEntry->pMcAtmInfo->TransientLeaves == 0)
				{
					//
					//  No AddParty in progress.
					//
					AA_RELEASE_VC_LOCK(pVc);

					AA_ACQUIRE_AE_LOCK(pAtmEntry);
					if (AtmArpMcPrepareAtmEntryForClose(pAtmEntry))
					{
						//
						//  The entry is ready for CloseCall.
						//
						AAMCDEBUGP(AAD_LOUD,
						("CloseCall (MC): pAtmEntry 0x%x, ready for close\n", pAtmEntry));

						//
						//  Get the party handle of the last leaf, and unlink
						//  it from the PMP structure.
						//
						AA_ASSERT(pAtmEntry->pMcAtmInfo->pMcAtmEntryList != 
								NULL_PATMARP_IPMC_ATM_ENTRY);

						pMcAtmEntry = pVc->pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
						NdisPartyHandle = pMcAtmEntry->NdisPartyHandle;

						AA_SET_FLAG(pMcAtmEntry->Flags,
									AA_IPMC_AE_CONN_STATE_MASK,
									AA_IPMC_AE_CONN_WACK_DROP_PARTY);

						pAtmEntry->pMcAtmInfo->ActiveLeaves--;
						AA_ASSERT(pAtmEntry->pMcAtmInfo->ActiveLeaves == 0);

						AA_RELEASE_AE_LOCK(pAtmEntry);
						AA_ACQUIRE_VC_LOCK(pVc);
					}
					else
					{
						AA_RELEASE_AE_LOCK(pAtmEntry);
						AA_ACQUIRE_VC_LOCK(pVc);
						//

						//  There are pending DropParty calls. Mark this VC
						//  so that we trigger a CloseCall when all DropParty
						//  calls complete.
						//
						AA_SET_FLAG(pVc->Flags,
									AA_VC_CLOSE_STATE_MASK,
									AA_VC_CLOSE_STATE_CLOSING);

						NdisVcHandle = NULL;	// Don't close call now
					}

				}
				else
				{
					//
					//  There are pending AddParty calls. Mark this VC
					//  so that we trigger a CloseCall when all AddParty
					//  calls complete.
					//
					AA_SET_FLAG(pVc->Flags,
								AA_VC_CLOSE_STATE_MASK,
								AA_VC_CLOSE_STATE_CLOSING);

					NdisVcHandle = NULL;	// Don't close call now
				}
			}
			else
			{
				NdisPartyHandle = NULL;
			}

			if (NdisVcHandle != NULL)
			{
				AA_RELEASE_VC_LOCK(pVc);

				Status = NdisClCloseCall(
							NdisVcHandle,
							NdisPartyHandle,
							(PVOID)NULL,		// No Buffer
							(UINT)0				// Size of above
						);

				if (Status != NDIS_STATUS_PENDING)
				{
					AtmArpCloseCallCompleteHandler(
							Status,
							ProtocolVcContext,
							(NDIS_HANDLE)NULL
							);
				}
			}
			else
			{
				//
				//  Set the call state back to what it was.
				//
				AA_SET_FLAG(
						pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE);

				AA_RELEASE_VC_LOCK(pVc);
			}
#else
			AA_RELEASE_VC_LOCK(pVc);
			Status = NdisClCloseCall(
						NdisVcHandle,
						NULL,				// NdisPartyHandle
						(PVOID)NULL,		// No Buffer
						(UINT)0				// Size of above
						);
			if (Status != NDIS_STATUS_PENDING)
			{
				AtmArpCloseCallCompleteHandler(
						Status,
						ProtocolVcContext,
						(NDIS_HANDLE)NULL
						);
			}
#endif // IPMCAST

		}
		else
		{
			//
			//  Some operation is going on here (call setup/close/send). Mark this
			//  VC so that we know what to do when this operation completes.
			//
			AA_SET_FLAG(
					pVc->Flags,
					AA_VC_CLOSE_STATE_MASK,
					AA_VC_CLOSE_STATE_CLOSING);

			AA_RELEASE_VC_LOCK(pVc);
		}
	}
	//
	//  else the VC is gone.
	//

	//
	//  Free any packets queued on this VC
	//
	if (PacketList != (PNDIS_PACKET)NULL)
	{
		AtmArpFreeSendPackets(
					pInterface,
					PacketList,
					HdrPresent
					);
	}

}




NDIS_STATUS
AtmArpCreateVcHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
)
/*++

Routine Description:

	Entry point called by NDIS when the Call Manager wants to create
	a new endpoint (VC). We allocate a new ATMARP VC structure, and
	return a pointer to it as our VC context.

Arguments:

	ProtocolAfContext	- Actually a pointer to the ATMARP Interface structure
	NdisVcHandle		- Handle for this VC for all future references
	pProtocolVcContext	- Place where we (protocol) return our context for the VC

Return Value:

	NDIS_STATUS_SUCCESS if we could create a VC
	NDIS_STATUS_RESOURCES otherwise

--*/
{
	PATMARP_INTERFACE	pInterface;
	PATMARP_VC			pVc;
	NDIS_STATUS			Status;

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;

	pVc = AtmArpAllocateVc(pInterface);
	if (pVc != NULL_PATMARP_VC)
	{
		*pProtocolVcContext = (NDIS_HANDLE)pVc;
		pVc->NdisVcHandle = NdisVcHandle;
		pVc->Flags = AA_VC_OWNER_IS_CALLMGR;
		AtmArpReferenceVc(pVc);	// Create VC ref

		Status = NDIS_STATUS_SUCCESS;
	}
	else
	{
		Status = NDIS_STATUS_RESOURCES;
	}

	AADEBUGP(AAD_INFO, ("Create Vc Handler: pVc 0x%x, Status 0x%x\n", pVc, Status));

	return (Status);

}



NDIS_STATUS
AtmArpDeleteVcHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
)
/*++

Routine Description:

	Our Delete VC handler. This VC would have been allocated as a result
	of a previous entry into our CreateVcHandler, and possibly used for
	an incoming call.

	At this time, this VC structure should be free of any calls, and we
	simply free this.

Arguments:

	ProtocolVcContext	- pointer to our VC structure

Return Value:

	NDIS_STATUS_SUCCESS always

--*/
{
	PATMARP_VC			pVc;
	ULONG				rc;		// Ref count on the VC

	pVc = (PATMARP_VC)ProtocolVcContext;

	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT((pVc->Flags & AA_VC_OWNER_MASK) == AA_VC_OWNER_IS_CALLMGR);

	AA_ACQUIRE_VC_LOCK(pVc);
	rc = AtmArpDereferenceVc(pVc);
	if (rc > 0)
	{
		//
		//  This can happen if there is a timer still running
		//  on this VC. When the timer elapses, the VC will be
		//  freed.
		//
		AADEBUGP(AAD_WARNING, ("Delete VC handler: pVc 0x%x, Flags 0x%x, refcount %d, pAtmEntry %x\n",
					pVc, pVc->Flags, rc, pVc->pAtmEntry));
		AA_RELEASE_VC_LOCK(pVc);
	}
	//
	//  else the VC is gone.
	//

	AADEBUGP(AAD_LOUD, ("Delete Vc Handler: 0x%x: done\n", pVc));

	return (NDIS_STATUS_SUCCESS);
}




NDIS_STATUS
AtmArpIncomingCallHandler(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS 	pCallParameters
)
/*++

Routine Description:

	This handler is called when there is an incoming call matching our
	SAP. This could be either an SVC or a PVC. In either case, we store
	FlowSpec information from the incoming call in the VC structure, making
	sure that the MTU for the interface is not violated.

	For an SVC, we expect a Calling Address to be present in the call,
	otherwise we reject the call. If an ATM Entry with this address exists,
	this VC is linked to that entry, otherwise a new entry with this address
	is created.

	In the case of a PVC, we ignore any Calling Address information, and
	depend on InATMARP to resolve the ATM Address as well as the IP address
	of the other end.

Arguments:

	ProtocolSapContext		- Pointer to ATMARP Interface structure
	ProtocolVcContext		- Pointer to ATMARP VC structure
	pCallParameters			- Call parameters

Return Value:

	NDIS_STATUS_SUCCESS if we accept this call
	NDIS_STATUS_FAILURE if we reject it.

--*/
{
	PATMARP_VC										pVc;
	PATMARP_ATM_ENTRY								pAtmEntry;
	PATMARP_INTERFACE								pInterface;

	CO_CALL_MANAGER_PARAMETERS UNALIGNED *			pCallMgrParameters;
	Q2931_CALLMGR_PARAMETERS UNALIGNED *			pAtmCallMgrParameters;

	//
	//  To traverse the list of Info Elements
	//
	Q2931_IE UNALIGNED *							pIe;
	ULONG											InfoElementCount;

	//
	//  Info Elements in the incoming call, that are of interest to us.
	//  Initialize these to <not present>.
	//
	ATM_ADDRESS UNALIGNED *							pCallingAddress = NULL;
	ATM_CALLING_PARTY_SUBADDRESS_IE UNALIGNED *		pCallingSubaddressIe = NULL;
	ATM_ADDRESS UNALIGNED *							pCallingSubaddress = NULL;
	AAL_PARAMETERS_IE UNALIGNED *					pAal = NULL;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *			pTrafficDescriptor = NULL;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *	pBbc = NULL;
	ATM_BLLI_IE UNALIGNED *							pBlli = NULL;
	ATM_QOS_CLASS_IE UNALIGNED *					pQos = NULL;

	AAL5_PARAMETERS UNALIGNED *						pAal5;
	UCHAR											AddrTypeLen;
	UCHAR											SubaddrTypeLen;
	PUCHAR											pAtmSubaddress;
	NDIS_STATUS										Status;
	
	pVc = (PATMARP_VC)ProtocolVcContext;

	AA_STRUCT_ASSERT(pVc, avc);

	AA_ASSERT((pVc->Flags & AA_VC_TYPE_MASK) == AA_VC_TYPE_UNUSED);
	AA_ASSERT((pVc->Flags & AA_VC_OWNER_MASK) == AA_VC_OWNER_IS_CALLMGR);
	AA_ASSERT((pVc->Flags & AA_VC_CALL_STATE_MASK) == AA_VC_CALL_STATE_IDLE);

	pInterface = pVc->pInterface;
	AADEBUGP(AAD_LOUD, ("Incoming Call: IF 0x%x, VC 0x%x, pCallParams 0x%x\n",
				pInterface, pVc, pCallParameters));

	do
	{
		if (pInterface->AdminState != IF_STATUS_UP)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Get the following info from the Incoming call:
		//		Calling Address
		//		AAL Parameters
		//		Traffic Descriptor
		//		Broadband Bearer Capability
		//		QoS
		//
		pCallMgrParameters = pCallParameters->CallMgrParameters;
		pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
					pCallParameters->CallMgrParameters->CallMgrSpecific.Parameters;

		pCallingAddress = &(pAtmCallMgrParameters->CallingParty);
		InfoElementCount = pAtmCallMgrParameters->InfoElementCount;
		pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);

		while (InfoElementCount--)
		{
			switch (pIe->IEType)
			{
				case IE_AALParameters:
					pAal = (PAAL_PARAMETERS_IE)(pIe->IE);
					break;
				case IE_TrafficDescriptor:
					pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)(pIe->IE);
					break;
				case IE_BroadbandBearerCapability:
					pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)(pIe->IE);
					break;
				case IE_QOSClass:
					pQos = (PATM_QOS_CLASS_IE)(pIe->IE);
					break;
				case IE_CallingPartySubaddress:
					pCallingSubaddressIe = (ATM_CALLING_PARTY_SUBADDRESS_IE *)(pIe->IE);
					pCallingSubaddress = pCallingSubaddressIe; 
					break;
				default:
					break;
			}
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
		}

		if ((pCallParameters->Flags & PERMANENT_VC) == 0)
		{
			//
			//  This is an SVC.
			//

			//
			//  Make sure all mandatory IEs are present. If not, reject the call
			//
			if ((pAal == (PAAL_PARAMETERS_IE)NULL) ||
				(pTrafficDescriptor == (PATM_TRAFFIC_DESCRIPTOR_IE)NULL) ||
				(pBbc == (PATM_BROADBAND_BEARER_CAPABILITY_IE)NULL) ||
				(pQos == (PATM_QOS_CLASS_IE)NULL))
			{
				AADEBUGP(AAD_WARNING,
					("In call: IE missing: AAL 0x%x, TRAF 0x%x, BBC 0x%x, QOS 0x%x",
						pAal,
						pTrafficDescriptor,
						pBbc,
						pQos));
				Status = NDIS_STATUS_AAL_PARAMS_UNSUPPORTED;
				break;
			}

			//
			//  We insist on the Calling Address
			//  being present, as well
			//
			if (pCallingAddress->NumberOfDigits == 0)
			{
				AADEBUGP(AAD_WARNING, ("In call: calling address missing for SVC\n"));
				Status = NDIS_STATUS_INVALID_ADDRESS;
				break;
			}
		}

		if (pAal != NULL)
		{
			//
			//  Make sure that the requested MTU values aren't beyond our
			//  capabilities:
			//
			pAal5 = &(pAal->AALSpecificParameters.AAL5Parameters);
			if (pAal5->ForwardMaxCPCSSDUSize > pInterface->pAdapter->MaxPacketSize)
			{
				pAal5->ForwardMaxCPCSSDUSize = pInterface->pAdapter->MaxPacketSize;
			}

			if (pAal5->BackwardMaxCPCSSDUSize > pInterface->pAdapter->MaxPacketSize)
			{
				pAal5->BackwardMaxCPCSSDUSize = pInterface->pAdapter->MaxPacketSize;
			}
		}

#ifdef PREPARE_IES_OURSELVES
		//
		//  Get the Flow Specs for this VC from the ATM Info Elements
		//
		pVc->FlowSpec.SendPeakBandwidth =
					CELLS_TO_BYTES(pTrafficDescriptor->ForwardTD.PeakCellRateCLP01);
		pVc->FlowSpec.SendMaxSize = pAal5->ForwardMaxCPCSSDUSize;
		pVc->FlowSpec.ReceivePeakBandwidth =
					CELLS_TO_BYTES(pTrafficDescriptor->BackwardTD.PeakCellRateCLP01);
		pVc->FlowSpec.ReceiveMaxSize = pAal5->BackwardMaxCPCSSDUSize;
		if ((pQos->QOSClassForward == 0) || (pQos->QOSClassBackward == 0))
		{
			pVc->FlowSpec.SendServiceType = SERVICETYPE_BESTEFFORT;
		}
		else
		{
			pVc->FlowSpec.SendServiceType = SERVICETYPE_GUARANTEED;
		}
#else
		//
		//  Get the Flow Specs for this VC
		//
		pVc->FlowSpec.SendPeakBandwidth = pCallMgrParameters->Transmit.PeakBandwidth;
		pVc->FlowSpec.SendAvgBandwidth = pCallMgrParameters->Transmit.TokenRate;
		pVc->FlowSpec.SendMaxSize = pCallMgrParameters->Transmit.MaxSduSize;
		pVc->FlowSpec.SendServiceType = pCallMgrParameters->Transmit.ServiceType;

		pVc->FlowSpec.ReceivePeakBandwidth = pCallMgrParameters->Receive.PeakBandwidth;
		pVc->FlowSpec.ReceiveAvgBandwidth = pCallMgrParameters->Receive.TokenRate;
		pVc->FlowSpec.ReceiveMaxSize = pCallMgrParameters->Receive.MaxSduSize;
		pVc->FlowSpec.ReceiveServiceType = pCallMgrParameters->Receive.ServiceType;

#endif // PREPARE_IES_OURSELVES

		AADEBUGP(AAD_LOUD, ("InCall: VC 0x%x: Type %s, Calling Addr:\n",
					pVc,
					(((pCallParameters->Flags & PERMANENT_VC) == 0)? "SVC": "PVC")
				));
		AADEBUGPDUMP(AAD_LOUD, pCallingAddress->Address, pCallingAddress->NumberOfDigits);
		AADEBUGP(AAD_LOUD,
				("InCall: VC 0x%x: SendBW: %d, RcvBW: %d, SendSz %d, RcvSz %d\n",
					pVc,
					pVc->FlowSpec.SendPeakBandwidth,
					pVc->FlowSpec.ReceivePeakBandwidth,
					pVc->FlowSpec.SendMaxSize,
					pVc->FlowSpec.ReceiveMaxSize));

#if DBG
		if (pCallParameters->Flags & MULTIPOINT_VC)
		{
			AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "Incoming PMP call from :", pCallingAddress);
		}
#endif // DBG

		//
		//  If this is a PVC, we are done. Accept the call.
		//
		if ((pCallParameters->Flags & PERMANENT_VC) != 0)
		{
			pVc->Flags |= (AA_VC_TYPE_PVC|AA_VC_CALL_STATE_INCOMING_IN_PROGRESS);
			Status = NDIS_STATUS_SUCCESS;
			break;
		}

		//
		//  Here if SVC. Check if an ATM Entry for this Calling address exists.
		//  If an entry exists, link this VC to the entry; otherwise, create a new
		//  ATM entry and link this VC to it.
		//
		AddrTypeLen = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(pCallingAddress);
		if (pCallingSubaddress != (PATM_ADDRESS)NULL)
		{
			SubaddrTypeLen = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(pCallingSubaddress);
			pAtmSubaddress = pCallingSubaddress->Address;
		}
		else
		{
			SubaddrTypeLen = 0;
			pAtmSubaddress = (PUCHAR)NULL;
		}

		pAtmEntry = AtmArpSearchForAtmAddress(
							pInterface,
							AddrTypeLen,
							pCallingAddress->Address,
							SubaddrTypeLen,
							pAtmSubaddress,
							AE_REFTYPE_TMP,
							TRUE		// Create one if no match found
							);

		if (pAtmEntry == NULL_PATMARP_ATM_ENTRY)
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Link this VC to the ATM Entry, and accept this call.
		//
		AA_ACQUIRE_AE_LOCK(pAtmEntry);
		{
			ULONG rc;
			AtmArpLinkVcToAtmEntry(pVc, pAtmEntry);

			//
			// AtmArpSearchForAtmAddress addrefd pAtmEntry for us -- we deref it
			// here (AFTER calling AtmArpLinkVcToAtmEntry).
			//
			rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);
			if (rc == 0)
			{
				//
				// We shouldn't get here because AtmArpLinkVcToAtmEntry
				// should have added a reference tp pAtmEntry.
				//
				AA_ASSERT(FALSE);
				Status = NDIS_STATUS_FAILURE;
				break;
			}
		}
		AA_RELEASE_AE_LOCK(pAtmEntry);
		//

		//  All checks for an incoming SVC are complete.
		//
		pVc->Flags |= (AA_VC_TYPE_SVC|AA_VC_CALL_STATE_INCOMING_IN_PROGRESS);


		AtmArpReferenceVc(pVc);	// ATM Entry reference

		Status = NDIS_STATUS_SUCCESS;
		break;

	}
	while (FALSE);

	AADEBUGP(AAD_VERY_LOUD, ("Incoming call: VC 0x%x, Status 0x%x\n", pVc, Status));
	return Status;
}




VOID
AtmArpCallConnectedHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
)
/*++

Routine Description:

	This handler is called as the final step in an incoming call, to inform
	us that the call is fully setup.

	For a PVC, we link the ATMARP VC structure in the list of unresolved PVCs,
	and use InATMARP to resolve both the IP and ATM addresses of the other
	end.

	For an SVC, we send off any packets queued on the VC while we were waiting
	for the Call Connected.

Arguments:

	ProtocolVcContext		- Pointer to ATMARP VC structure

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;
	PATMARP_INTERFACE		pInterface;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);


	pVc = (PATMARP_VC)ProtocolVcContext;
	
	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT((pVc->Flags & AA_VC_CALL_STATE_MASK)
						 == AA_VC_CALL_STATE_INCOMING_IN_PROGRESS);

	AA_ACQUIRE_VC_LOCK(pVc);

	//
	//  Note down that a call is active on this VC.
	//
	AA_SET_FLAG(
			pVc->Flags,
			AA_VC_CALL_STATE_MASK,
			AA_VC_CALL_STATE_ACTIVE
			);

	AtmArpReferenceVc(pVc);		// Incoming call reference

	AADEBUGP(AAD_INFO, ("Call Connected: VC: 0x%x, Flags: 0x%x, ATM Entry: 0x%x\n",
					pVc, pVc->Flags, pVc->pAtmEntry));

	pInterface = pVc->pInterface;
	AA_STRUCT_ASSERT(pInterface, aai);

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if ((pVc->Flags & AA_VC_TYPE_PVC) != 0)
		{
			//
			//  This is a PVC, link it to the list of unresolved PVCs, and
			//  send an InATMARP request on it.
			//
			pVc->pNextVc = pInterface->pUnresolvedVcs;
			pInterface->pUnresolvedVcs = pVc;

			AA_SET_FLAG(pVc->Flags,
						AA_VC_ARP_STATE_MASK,
						AA_VC_INARP_IN_PROGRESS);
			//
			//  Start an InARP wait timer while we hold a lock for
			//  the Interface
			//
			AtmArpStartTimer(
						pInterface,
						&(pVc->Timer),
						AtmArpPVCInARPWaitTimeout,
						pInterface->InARPWaitTimeout,
						(PVOID)pVc
						);


			AtmArpReferenceVc(pVc);		// Timer ref

			AtmArpReferenceVc(pVc);		// Unresolved VCs Link reference


			AADEBUGP(AAD_LOUD, ("PVC Call Connected: VC 0x%x\n", pVc));

#ifndef VC_REFS_ON_SENDS
			AA_RELEASE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS
			AtmArpSendInARPRequest(pVc);

			AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
		}
		else
		{
			AADEBUGP(AAD_LOUD, ("SVC Call Connected: VC 0x%x\n", pVc));

			AtmArpStartSendsOnVc(pVc);
	
			//
			//  The VC lock is released within StartSendsOnVc()
			//
			AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
		}
	}
	else
	{
		//
		//  The interface is marked as down. Close this call.
		//

		AtmArpCloseCall(pVc);

		//
		//  The VC lock is released within the above
		//
	}

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return;
}




VOID
AtmArpIncomingCloseHandler(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
)
/*++

Routine Description:

	This handler is called when a call is closed, either by the network
	or by the remote peer.

Arguments:

	CloseStatus			- Reason for the call clearing
	ProtocolVcContext	- Actually a pointer to the ATMARP VC structure
	pCloseData			- Additional info about the close
	Size				- Length of above

Return Value:

	None

--*/
{
	PATMARP_VC			pVc;
	PATMARP_ATM_ENTRY	pAtmEntry;
	PATMARP_INTERFACE	pInterface;
	ULONG				rc;				// Ref Count
	BOOLEAN				VcAbnormalTermination;
	BOOLEAN				IsPVC;
	BOOLEAN				Found;
	PATM_CAUSE_IE		pCauseIe;

	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

	AADEBUGP(AAD_INFO, ("Incoming Close: pVc 0x%x, Status 0x%x\n", pVc, CloseStatus));
	pCauseIe = (PATM_CAUSE_IE)pCloseData;

#if DBG
	if (pCauseIe != (PATM_CAUSE_IE)NULL)
	{
		AADEBUGP(AAD_INFO, ("Incoming Close: pVc 0x%x, Locn 0x%x, Cause 0x%x\n",
					pVc, pCauseIe->Location, pCauseIe->Cause));
	}
#endif // DBG

	AA_ACQUIRE_VC_LOCK(pVc);
	IsPVC = AA_IS_FLAG_SET(pVc->Flags, AA_VC_TYPE_MASK, AA_VC_TYPE_PVC);
	pInterface = pVc->pInterface;

	//
	//  Stop any timer (e.g. VC aging) running on this VC
	//
	if (AtmArpStopTimer(&(pVc->Timer), pVc->pInterface))
	{
		//
		//  A timer WAS running
		//
		rc = AtmArpDereferenceVc(pVc);	// Timer reference
		AA_ASSERT(rc > 0);
	}

	if ((CloseStatus == NDIS_STATUS_DEST_OUT_OF_ORDER) || IsPVC)
	{
		//
		//  This is an abnormal close, note down the fact
		//
		VcAbnormalTermination = TRUE;
	}
	else
	{
		VcAbnormalTermination = FALSE;
	}

	if (AA_IS_FLAG_SET(pVc->Flags,
					AA_VC_CALL_STATE_MASK,
					AA_VC_CALL_STATE_INCOMING_IN_PROGRESS))
	{
			AADEBUGP(AAD_WARNING,
	("Incoming close: VC 0x%x state is INCOMING_IN_PROGRESS; changing to ACTIVE\n",
						pVc));
			//
			// We're getting a close call for an incoming call that is  not yet
			// in the connected state. Since we won't get any further notifications
			// for this call, this call is effectively in the active state.
			// So we set the state to active, and then close the VC.
			// Note: we will not go down the InvalidateAtmEntryPath even
			// if CloseStatus == NDIS_STATUS_DEST_OUT_OF_ORDER;
			// we instead simply close the vc. (If the client is truly out of order,
			// and we want to send to it, well separately try to make an OUTGOING
			// call to the destination, which should fail with "DEST_OUT_OF_ORDER",
			// and we'll end up eventually invalidating the atm entry.
			//
			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE);
			AtmArpReferenceVc(pVc);		// Incoming call reference

			VcAbnormalTermination = FALSE;
	}

	if (VcAbnormalTermination && 
		(pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY))
	{
		pAtmEntry = pVc->pAtmEntry;

		AADEBUGP(AAD_INFO,
			("IncomingClose: will invalidate ATM entry %x/%x - IP Entry %x, VC %x/%x\n",
				pAtmEntry, pAtmEntry->Flags,
				pAtmEntry->pIpEntryList,
				pVc, pVc->Flags));

		AA_RELEASE_VC_LOCK(pVc);
		AA_ACQUIRE_AE_LOCK(pAtmEntry);
		AtmArpInvalidateAtmEntry(
					pAtmEntry,
					FALSE	// Not shutting down
					);
		//
		//  AE Lock is released within the above.
		//

		if (IsPVC)
		{
			//
			//  Start a CloseCall right here because InvalidateAtmEntry doesn't.
			//
			AA_ACQUIRE_VC_LOCK(pVc);

			AtmArpCloseCall(pVc);
			//
			//  VC lock is released above
		}
	}
	else
	{
		AtmArpCloseCall(pVc);
	}

	AADEBUGP(AAD_LOUD, ("Leaving Incoming Close handler, VC: 0x%x\n", pVc));
	return;
}


#ifdef IPMCAST

VOID
AtmArpAddParty(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
)
/*++

Routine Description:

	Add a party to an existing PMP connection. The ATM Entry contains
	all address information for the connection, and the Multicast ATM
	Entry represents one of the leaves, the one to be added.

	NOTE: The caller is assumed to hold a lock for the ATM Entry,
	which is released here.

Arguments:

	pAtmEntry				- Pointer to ATM Entry on which to add the leaf (party).
	pMcAtmEntry				- Points to ATM Multicast Entry representing the leaf.

Return Value:

	None

--*/
{
	PATMARP_VC			pVc;				// The VC structure for the connection
	NDIS_HANDLE			NdisVcHandle;
	PCO_CALL_PARAMETERS	pCallParameters;
	ULONG				RequestSize;
	NDIS_STATUS			Status;

	AA_ASSERT(pAtmEntry->pVcList != NULL_PATMARP_VC);
	pVc = pAtmEntry->pVcList;

	NdisVcHandle = pVc->NdisVcHandle;

	//
	//  Allocate all the space we need.
	//
	RequestSize = 	sizeof(CO_CALL_PARAMETERS) +
					sizeof(CO_CALL_MANAGER_PARAMETERS) +
					sizeof(Q2931_CALLMGR_PARAMETERS) +
					ATMARP_ADD_PARTY_IE_SPACE +
					0;

	AA_ALLOC_MEM(pCallParameters, CO_CALL_PARAMETERS, RequestSize);

	if (pCallParameters != (PCO_CALL_PARAMETERS)NULL)
	{
		//
		//  Fill in Call Parameters.
		//
		AtmArpFillCallParameters(
				pCallParameters,
				RequestSize,
				&(pMcAtmEntry->ATMAddress),		// Called address
				&(pAtmEntry->pInterface->LocalAtmAddress),	// Calling address
				&(pVc->FlowSpec),
				TRUE,	// IsPMP
				FALSE	// IsMakeCall?
				);
	}

	AA_SET_FLAG(pMcAtmEntry->Flags,
				AA_IPMC_AE_CONN_STATE_MASK,
				AA_IPMC_AE_CONN_WACK_ADD_PARTY);

	pAtmEntry->pMcAtmInfo->TransientLeaves++;
	AA_RELEASE_AE_LOCK(pAtmEntry);

	if (pCallParameters != (PCO_CALL_PARAMETERS)NULL)
	{
		Status = NdisClAddParty(
						NdisVcHandle,
						(NDIS_HANDLE)pMcAtmEntry,
						pCallParameters,
						&(pMcAtmEntry->NdisPartyHandle)
						);
	}
	else
	{
		Status = NDIS_STATUS_RESOURCES;
	}

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmArpAddPartyCompleteHandler(
			Status,
			(NDIS_HANDLE)pMcAtmEntry,
			pMcAtmEntry->NdisPartyHandle,
			pCallParameters
			);
	}

}




VOID
AtmArpMcTerminateMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
)
/*++

Routine Description:

	Terminate the specified member of a multicast group. If it is
	currently a leaf in the point-to-multipoint connection to the
	group, then we drop it. If it is the LAST leaf, then we close
	the entire connection.

	NOTE: the caller is assumed to hold the ATM Entry lock, which
	will be released here.

Arguments:

	pAtmEntry				- Pointer to ATM Entry
	pMcAtmEntry				- Points to ATM Multicast Entry representing the leaf to
							  be terminated.

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_INFO		pMcAtmInfo;
	PATMARP_VC					pVc;
	NDIS_HANDLE					NdisPartyHandle;
	NDIS_STATUS					Status;

	pMcAtmInfo = pAtmEntry->pMcAtmInfo;
	pVc = pAtmEntry->pVcList;
	NdisPartyHandle = pMcAtmEntry->NdisPartyHandle;

	AAMCDEBUGP(AAD_VERY_LOUD,
	  ("TerminateMember: pAtmEntry 0x%x, pMcAtmEntry 0x%x, pVc 0x%x, NdisPtyHnd 0x%x\n",
		pAtmEntry, pMcAtmEntry, pVc, NdisPartyHandle));

#if DBG
	{
		PATMARP_IP_ENTRY		pIpEntry = pAtmEntry->pIpEntryList;

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			AAMCDEBUGPMAP(AAD_INFO, "Terminating ",
						&pIpEntry->IPAddress,
						&pMcAtmEntry->ATMAddress);
		}
	}
#endif // DBG

	if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
						AA_IPMC_AE_GEN_STATE_MASK,
						AA_IPMC_AE_TERMINATING))
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
		return;
	}

	AA_SET_FLAG(pMcAtmEntry->Flags,
				AA_IPMC_AE_GEN_STATE_MASK,
				AA_IPMC_AE_TERMINATING);

	if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
   					AA_IPMC_AE_CONN_STATE_MASK,
   					AA_IPMC_AE_CONN_ACTIVE))
	{
		if (pMcAtmInfo->ActiveLeaves == 1)
		{
			//
			//  This is the last active leaf in this connection. Close the call.
			//
			AA_RELEASE_AE_LOCK(pAtmEntry);

			AA_ASSERT(pVc != NULL_PATMARP_VC);
			AA_ACQUIRE_VC_LOCK(pVc);
			AtmArpCloseCall(pVc);
			//
			//  VC lock is released within the above.
			//
		}
		else
		{
			//
			//  This isn't the only leaf in this connection. Drop this party.
			//
			pAtmEntry->pMcAtmInfo->ActiveLeaves--;

			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_WACK_DROP_PARTY);
			AA_RELEASE_AE_LOCK(pAtmEntry);

			Status = NdisClDropParty(
						NdisPartyHandle,
						NULL,		// Buffer
						(UINT)0		// Size
						);

			if (Status != NDIS_STATUS_PENDING)
			{
				AtmArpDropPartyCompleteHandler(
						Status,
						(NDIS_HANDLE)pMcAtmEntry
						);
			}
		}
	}
	else if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
   					AA_IPMC_AE_CONN_STATE_MASK,
   					AA_IPMC_AE_CONN_DISCONNECTED))
	{
		//
		//  Simply unlink this entry.
		//
		UINT rc;
		AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);					// temp ref
		AtmArpMcUnlinkAtmMember(pAtmEntry, pMcAtmEntry);
		rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);			// temp ref
		if (rc!=0)
		{
			AA_RELEASE_AE_LOCK(pAtmEntry);
		}
	}
	else
	{
		//
		//  This party is in a transient state. Let it finish its current
		//  operation.
		//
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}

}

#endif // IPMCAST


VOID
AtmArpIncomingDropPartyHandler(
	IN	NDIS_STATUS					DropStatus,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
)
/*++

Routine Description:

	This handler is called if the network (or remote peer) drops
	a leaf node from a point-to-multipoint call rooted at us.

	See Section 5.1.5.1 in RFC 2022: we delete the member from
	the multicast group it belongs to. And we start a timer at
	the end of which we mark the multicast group as needing
	revalidation.

Arguments:

	DropStatus				- Leaf drop status
	ProtocolPartyContext	- Pointer to our Multicast ATM Entry structure
	pCloseData				- Optional additional info (ignored)
	Size					- of the above (ignored)

Return Value:

	None

--*/
{
#ifdef IPMCAST
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_ATM_ENTRY			pAtmEntry;
	PATMARP_IP_ENTRY			pIpEntry;
	PATMARP_INTERFACE			pInterface;
	NDIS_HANDLE					NdisPartyHandle;
	NDIS_STATUS					Status;

	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)ProtocolPartyContext;
	AA_STRUCT_ASSERT(pMcAtmEntry, ame);

	AA_ASSERT(pMcAtmEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
	AA_ASSERT(pMcAtmEntry->pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY);

	pAtmEntry = pMcAtmEntry->pAtmEntry;

	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	NdisPartyHandle = pMcAtmEntry->NdisPartyHandle;
	pIpEntry = pAtmEntry->pIpEntryList;
	pInterface = pAtmEntry->pInterface;

	AADEBUGP(AAD_INFO,
		("Incoming Drop: pMcAtmEntry 0x%x, PtyHnd 0x%x, pAtmEntry 0x%x, IP Addr: %d.%d.%d.%d\n",
			pMcAtmEntry,
			NdisPartyHandle,
			pAtmEntry,
			((PUCHAR)&(pIpEntry->IPAddress))[0],
			((PUCHAR)&(pIpEntry->IPAddress))[1],
			((PUCHAR)&(pIpEntry->IPAddress))[2],
			((PUCHAR)&(pIpEntry->IPAddress))[3]));

	pAtmEntry->pMcAtmInfo->ActiveLeaves--;

	AA_SET_FLAG(pMcAtmEntry->Flags,
				AA_IPMC_AE_CONN_STATE_MASK,
				AA_IPMC_AE_CONN_RCV_DROP_PARTY);

	AA_RELEASE_AE_LOCK(pAtmEntry);

	//
	//  We need to revalidate this multicast group after a random
	//  delay. Start a random delay timer.
	//
	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	if (!AA_IS_TIMER_ACTIVE(&(pIpEntry->Timer)) &&
		AA_IS_FLAG_SET(pIpEntry->Flags,
						AA_IP_ENTRY_MC_RESOLVE_MASK,
						AA_IP_ENTRY_MC_RESOLVED))
	{
		ULONG	RandomDelay;

		RandomDelay =  AA_GET_RANDOM(
							pInterface->MinRevalidationDelay,
							pInterface->MaxRevalidationDelay);
		AtmArpStartTimer(
			pInterface,
			&(pIpEntry->Timer),
			AtmArpMcRevalidationDelayTimeout,
			RandomDelay,
			(PVOID)pIpEntry
			);

		AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref
	}

	AA_RELEASE_IE_LOCK(pIpEntry);

	//
	//  Complete the DropParty handshake.
	//
	Status = NdisClDropParty(
				NdisPartyHandle,
				NULL,
				0
				);

	if (Status != NDIS_STATUS_PENDING)
	{
		AtmArpDropPartyCompleteHandler(
				Status,
				(NDIS_HANDLE)pMcAtmEntry
				);
	}
#endif // IPMCAST
	return;
}



VOID
AtmArpQosChangeHandler(
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This handler is called if the remote peer modifies call parameters
	"on the fly", i.e. after the call is established and running.

	This isn't supported by existing ATM signalling, and shouldn't happen,
	but we'll allow this.

	FUTURE: The FlowSpecs associated with the call are affected by this.

Arguments:

	ProtocolVcContext		- Pointer to our ATMARP VC structure
	pCallParameters			- updated call parameters.

Return Value:

	None

--*/
{
	PATMARP_VC		pVc;

	pVc = (PATMARP_VC)ProtocolVcContext;

	AADEBUGP(AAD_WARNING, ("Ignoring Qos Change, VC: 0x%x\n", pVc));

	return;
}




VOID
AtmArpOpenAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
)
/*++

Routine Description:

	This handler is called to indicate completion of a previous call
	to NdisClOpenAddressFamily. We would have blocked the thread that
	called this. Wake it up now.

	By the way, if the call was successful, store the NDIS AF handle
	in our Interface structure.

	We don't need to acquire locks here because the thread that called
	OpenAddressFamily would have blocked with a lock acquired.

Arguments:

	Status					- Status of the Open AF
	ProtocolAfContext		- Pointer to our ATMARP Interface structure
	NdisAfHandle			- NDIS handle to the AF association

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("Open AF Complete: IF 0x%x, Status 0x%x, AF Handle 0x%x\n",
				pInterface, Status, NdisAfHandle));


	if (Status == NDIS_STATUS_SUCCESS)
	{
		pInterface->NdisAfHandle = NdisAfHandle;
	}

	//
	//  Wake up the blocked thread
	//
	AA_SIGNAL_BLOCK_STRUCT(&(pInterface->Block), Status);
}




VOID
AtmArpSendIPDelInterface(
	IN	PNDIS_WORK_ITEM				pWorkItem,
	IN	PVOID						IfContext
)
{
	PATMARP_INTERFACE		pInterface;
	PVOID					IPContext;
	ULONG					rc;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);
#if !BINARY_COMPATIBLE
	AA_ASSERT(EntryIrq == PASSIVE_LEVEL);
#endif

	pInterface = (PATMARP_INTERFACE)IfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_FREE_MEM(pWorkItem);

	AA_ACQUIRE_IF_LOCK(pInterface);

	IPContext = pInterface->IPContext;
	pInterface->IPContext = NULL;

	AA_RELEASE_IF_LOCK(pInterface);

	AADEBUGP(AAD_INFO, ("SendIPDelInterface: IF 0x%x, IPContext 0x%x\n",
				pInterface, IPContext));

	if (IPContext != NULL)
	{
		(*(pAtmArpGlobalInfo->pIPDelInterfaceRtn))(
					IPContext
#if IFCHANGE1
#ifndef  ATMARP_WIN98
					,0	// DeleteIndex (unused) --  See 10/14/1998 entry
						// in notes.txt
#endif
#endif // IFCHANGE1
					);
	}
	else
	{
		AADEBUGP(AAD_INFO, ("SendIPDelInterface: NO IPContext"));
	}

	AA_ACQUIRE_IF_LOCK(pInterface);

	rc = AtmArpDereferenceInterface(pInterface);	// Work Item: Del Interface

	if (rc != 0)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
	//
	//  else the Interface is gone.
	//

}


VOID
AtmArpCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
)
/*++

Routine Description:

	This routine is called to indicate completion of a call to
	NdisClCloseAddressFamily. Tell IP to Delete this Interface now.

Arguments:

	Status					- Status of the Close AF (ignored here)
	ProtocolAfContext		- Pointer to ATMARP Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PNDIS_WORK_ITEM			pWorkItem;
	NDIS_STATUS				NdisStatus;
	BOOLEAN					bUnloading;
#if 0
	PVOID					IPContext;
#endif
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);
#if !BINARY_COMPATIBLE
	AA_ASSERT(EntryIrq == PASSIVE_LEVEL);
#endif

	AA_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;

	AADEBUGP(AAD_INFO, ("CloseAfComplete: If 0x%x, Status 0x%x\n",
			pInterface, Status));

	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);

	pInterface->NdisAfHandle = NULL;
	bUnloading = pAtmArpGlobalInfo->bUnloading;

	if (pInterface->IPContext != NULL)
	{
		//
		//  We haven't seen an IfClose yet.
		//
		AA_ALLOC_MEM(pWorkItem, NDIS_WORK_ITEM, sizeof(NDIS_WORK_ITEM));
		if (pWorkItem == NULL)
		{
			AA_ASSERT(FALSE);
			AA_RELEASE_IF_LOCK(pInterface);
			return;
		}

#if 0
		IPContext = (PVOID)pInterface->IPContext;
		pInterface->IPContext = NULL;
#endif
		AtmArpReferenceInterface(pInterface);	// Work Item

		AA_RELEASE_IF_LOCK(pInterface);

		if (bUnloading)
		{
			AtmArpSendIPDelInterface(pWorkItem, (PVOID)pInterface);
		}
		else
		{
			//
			//  Queue a work item so that (a) things unravel easier,
			//  (b) we are at passive level when we call IPDelInterface.
			//
			NdisInitializeWorkItem(
				pWorkItem,
				AtmArpSendIPDelInterface,
				(PVOID)pInterface
				);
	
			NdisStatus = NdisScheduleWorkItem(pWorkItem);

			AA_ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
		}
	}
	else
	{
		AADEBUGP(AAD_WARNING, ("CloseAfComplete: NO IPContext"));
		AA_RELEASE_IF_LOCK(pInterface);
	}

	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

}




VOID
AtmArpRegisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext,
	IN	PCO_SAP						pSap,
	IN	NDIS_HANDLE					NdisSapHandle
)
/*++

Routine Description:

	This routine is called to indicate completion of a call to
	NdisClRegisterSap. If the call was successful, save the
	allocated NdisSapHandle in our SAP structure.

Arguments:

	Status						- Status of Register SAP
	ProtocolSapContext			- Pointer to our ATMARP Interface structure
	pSap						- SAP information we'd passed in the call
	NdisSapHandle				- SAP Handle

Return Value:

	None

--*/
{
	PATMARP_SAP					pAtmArpSap;

	pAtmArpSap = (PATMARP_SAP)ProtocolSapContext;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAtmArpSap->NdisSapHandle = NdisSapHandle;
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_REG_STATE_MASK,
					AA_SAP_REG_STATE_REGISTERED);
	}
	else
	{
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_REG_STATE_MASK,
					AA_SAP_REG_STATE_IDLE);
	}
}




VOID
AtmArpDeregisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext
)
/*++

Routine Description:

	This routine is called when a previous call to NdisClDeregisterSap
	has completed. If it was successful, we update the state of the ATMARP
	SAP structure representing the Sap.

Arguments:

	Status						- Status of the Deregister SAP request
	ProtocolSapContext			- Pointer to our ATMARP SAP structure

Return Value:

	None

--*/
{

	PATMARP_INTERFACE			pInterface;
	PATMARP_SAP					pAtmArpSap;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAtmArpSap = (PATMARP_SAP)ProtocolSapContext;

		AA_STRUCT_ASSERT(pAtmArpSap, aas);
		pInterface = pAtmArpSap->pInterface;

		AA_ACQUIRE_IF_LOCK(pInterface);

		pAtmArpSap->NdisSapHandle = NULL;

		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_REG_STATE_MASK,
					AA_SAP_REG_STATE_IDLE);
		
		AA_RELEASE_IF_LOCK(pInterface);
	}

	return;
}




VOID
AtmArpMakeCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called when an outgoing call request (NdisClMakeCall)
	has completed. The "Status" parameter indicates whether the call was
	successful or not.

	If the call was successful, we send any packets queued for transmission
	on this VC.

	If the call failed, we free any packets queued on this VC and unlink it
	from the ATM Address Entry it was linked to. If this was an attempt to
	connect to the ATMARP server, delay for a while before attempting to
	connect again.

Arguments:

	Status						- Result of the NdisClMakeCall
	ProtocolVcContext			- Pointer to ATMARP VC structure
	NdisPartyHandle				- Not used (no point-to-multipoint calls)
	pCallParameters				- Pointer to call parameters

Return Value:

	None

--*/
{
	PATMARP_VC					pVc;
	PATMARP_INTERFACE			pInterface;
	ULONG						rc;				// ref count
	BOOLEAN						IsServerVc;		// Is this the VC to the ATMARP server?
	BOOLEAN						IsPMP;
	PNDIS_PACKET				PacketList;		// List of packets waiting to be sent
	AA_HEADER_TYPE				HdrType;		// header types for the above
	BOOLEAN						HdrPresent;
	NDIS_HANDLE					NdisVcHandle;

	PATMARP_ATM_ENTRY			pAtmEntry;		// ATM Entry to which this VC is linked

	Q2931_CALLMGR_PARAMETERS UNALIGNED *	pCallMgrSpecific;
	Q2931_IE UNALIGNED *					pIe;
	ULONG									InfoElementCount;

	//
	//  Initialize
	//
	PacketList = (PNDIS_PACKET)NULL;

	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

	AADEBUGP(AAD_INFO, ("MakeCall Complete: Status 0x%x, VC 0x%x, pAtmEntry 0x%x\n",
				Status, pVc, pVc->pAtmEntry));

	AA_ACQUIRE_VC_LOCK(pVc);

	IsPMP = AA_IS_FLAG_SET(pVc->Flags,
							AA_VC_CONN_TYPE_MASK,
							AA_VC_CONN_TYPE_PMP);

	pAtmEntry = pVc->pAtmEntry;
	AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);

	if (pVc->FlowSpec.Encapsulation == ENCAPSULATION_TYPE_LLCSNAP)
	{
		HdrType = (IsPMP? AA_HEADER_TYPE_NUNICAST: AA_HEADER_TYPE_UNICAST);
		HdrPresent = TRUE;
	}
	else
	{
		HdrType = AA_HEADER_TYPE_NONE;
		HdrPresent = FALSE;
	}

	pInterface = pVc->pInterface;

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if (Status == NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_LOUD, ("Make Call Successful on VC 0x%x\n", pVc));
			//
			//  Update the call state on this VC, and send queued packets.
			//  If this happens to be the VC to the ATMARP Server, we expect
			//  to see our initial ARP Request (to register with the server)
			//  in this queue.
			//
			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE);

			//
			//  Locate the AAL parameters Info Element, and get the updated
			//  packet sizes.
			//
			pCallMgrSpecific = (PQ2931_CALLMGR_PARAMETERS)&pCallParameters->CallMgrParameters->CallMgrSpecific.Parameters[0];
			pIe = (PQ2931_IE)&pCallMgrSpecific->InfoElements[0];

			for (InfoElementCount = 0;
				 InfoElementCount < pCallMgrSpecific->InfoElementCount;
				 InfoElementCount++)
			{
				if (pIe->IEType == IE_AALParameters)
				{
					AAL_PARAMETERS_IE UNALIGNED *	pAalIe;
					UNALIGNED AAL5_PARAMETERS *		pAal5;

					pAalIe = (PAAL_PARAMETERS_IE)&pIe->IE[0];
					AA_ASSERT(pAalIe->AALType == AAL_TYPE_AAL5);
					pAal5 = &pAalIe->AALSpecificParameters.AAL5Parameters;

#if DBG
					if (pVc->FlowSpec.SendMaxSize != pAal5->ForwardMaxCPCSSDUSize)
					{
						AADEBUGP(AAD_INFO,
							("CallComplete: Send size changed (%d->%d)\n",
								pVc->FlowSpec.SendMaxSize,
								pAal5->ForwardMaxCPCSSDUSize));
					}
					if (pVc->FlowSpec.ReceiveMaxSize != pAal5->BackwardMaxCPCSSDUSize)
					{
						AADEBUGP(AAD_INFO,
							("CallComplete: Receive size changed (%d->%d)\n",
								pVc->FlowSpec.ReceiveMaxSize,
								pAal5->BackwardMaxCPCSSDUSize));
					}
#endif // DBG
					pVc->FlowSpec.SendMaxSize = pAal5->ForwardMaxCPCSSDUSize;
					pVc->FlowSpec.ReceiveMaxSize = pAal5->BackwardMaxCPCSSDUSize;
					break;
				}
				pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
			}

			AA_ASSERT(InfoElementCount != pCallMgrSpecific->InfoElementCount);
				

			//
			//  Update the call type on this VC. If this is an SVC, start
			//  the VC aging timer.
			//
			if (pCallParameters->Flags & PERMANENT_VC)
			{
				AA_SET_FLAG(pVc->Flags,
							AA_VC_TYPE_MASK,
							AA_VC_TYPE_PVC);
			}
			else
			{
				ULONG		AgingTime;

				AA_SET_FLAG(pVc->Flags,
							AA_VC_TYPE_MASK,
							AA_VC_TYPE_SVC);

#ifdef IPMCAST
				if (IsPMP)
				{
					AgingTime = pInterface->MulticastEntryAgingTimeout;
				}
				else
				{
					AgingTime = pVc->FlowSpec.AgingTime;
				}
#else
				AgingTime = pVc->FlowSpec.AgingTime;
#endif // IPMCAST

				//
				//  Start VC aging timer on this SVC.
				//
				if (AgingTime != 0)
				{
					AtmArpStartTimer(
						pInterface,
						&(pVc->Timer),
						AtmArpVcAgingTimeout,
						AgingTime,
						(PVOID)pVc
						);

					AtmArpReferenceVc(pVc);	// Timer ref
				}
			}

			AtmArpStartSendsOnVc(pVc);
	
			//
			//  The VC lock is released within StartSendsOnVc()
			//

#ifdef IPMCAST
			if (IsPMP)
			{
				AtmArpMcMakeCallComplete(
						pAtmEntry,
						NdisPartyHandle,
						Status
						);
			}
#endif // IPMCAST

		}
		else
		{
			//
			//  The call failed.
			//

			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_IDLE);

			//
			//  Delete the Call reference
			//
			rc = AtmArpDereferenceVc(pVc);
			AA_ASSERT(rc > 0);

			//
			//  Remove all packets queued on this VC
			//
			PacketList = pVc->PacketList;
			pVc->PacketList = (PNDIS_PACKET)NULL;

			//
			//  Was this a call to the ATMARP server?
			//
			if (pInterface->pCurrentServer != NULL)
			{
				IsServerVc = (pVc->pAtmEntry == pInterface->pCurrentServer->pAtmEntry);
			}
			else
			{
				IsServerVc = FALSE;
			}

			AADEBUGP(AAD_INFO,
				 ("Make Call FAILED on VC 0x%x IsPMP=%lu IsServer=%lu\n",
				  pVc,
				  IsPMP,
				  IsServerVc
				  ));

	#ifdef GPC
			//
			// Unlink this VC from the flow, if linked...
			//
			if (pVc->FlowHandle != NULL)
			{
				PATMARP_FLOW_INFO	pFlowInfo = (PATMARP_FLOW_INFO)pVc->FlowHandle;
				if ((PVOID)pVc == InterlockedCompareExchangePointer(
										&(pFlowInfo->VcContext),
										NULL,
										pVc
										))
				{
					pVc->FlowHandle = NULL;
					rc = AtmArpDereferenceVc(pVc);	// Unlink from GPC Flow
					AA_ASSERT(rc > 0);
				}
			}
	#endif // GPC


			//
			//  Unlink this VC from the ATM Entry it belonged to, if any
			//
			AA_ASSERT(pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
			AtmArpUnlinkVcFromAtmEntry(pVc, FALSE);

			//
			//  Delete the ATM Entry reference
			//
			rc = AtmArpDereferenceVc(pVc); // ATM Entry ref
			AA_ASSERT(rc > 0);

			//
			//  Delete the CreateVc reference
			//
			NdisVcHandle = pVc->NdisVcHandle;
			rc =  AtmArpDereferenceVc(pVc);	// Create Vc ref

			if (rc != 0)
			{
				AA_RELEASE_VC_LOCK(pVc);
			}

#ifndef VC_REFS_ON_SENDS
			//
			//  Delete the NDIS association
			//
			(VOID)NdisCoDeleteVc(NdisVcHandle);
#endif // VC_REFS_ON_SENDS
			AADEBUGP(AAD_LOUD, ("Deleted NDIS VC on pVc 0x%x: NdisVcHandle 0x%x\n",
						pVc, NdisVcHandle));

			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_VC);	// Unlink Vc - make call

			if (rc != 0)
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
#ifdef IPMCAST
				if (IsPMP)
				{
					AtmArpMcMakeCallComplete(
						pAtmEntry,
						NdisPartyHandle,
						Status
						);
				}
				else
				{
#endif // IPMCAST
					if (!AA_IS_TRANSIENT_FAILURE(Status))
					{
						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						AtmArpInvalidateAtmEntry(pAtmEntry, FALSE);	// MakeCall failure
						//
						//  AE Lock is released within the above.
						//
					}
#ifdef IPMCAST
				}
#endif // IPMCAST
			}
			//
			//  else the ATM Entry is gone
			//

			if (IsServerVc)
			{
				BOOLEAN		WasRunning;

				AA_ACQUIRE_IF_LOCK(pInterface);

				//
				//  If we were in the process of registering (or refreshing)
				//  ourselves with the server, then retry after a while.
				//
				if (AA_IS_FLAG_SET(
						pInterface->Flags,
						AA_IF_SERVER_STATE_MASK,
						AA_IF_SERVER_REGISTERING))
				{
					AA_SET_FLAG(pInterface->Flags,
							AA_IF_SERVER_STATE_MASK,
							AA_IF_SERVER_NO_CONTACT);

					//
					//  The server registration timer would have been
					//  started -- stop it first.
					//
					WasRunning = AtmArpStopTimer(&(pInterface->Timer), pInterface);
					if (WasRunning)
					{
						rc = AtmArpDereferenceInterface(pInterface);
					}
					else
					{
						rc = pInterface->RefCount;
					}
	
					if (rc > 0)
					{
						AtmArpRetryServerRegistration(pInterface);
						//
						//  The IF lock is released within the above.
						//
					}
					//
					//  else the IF is gone!
					//
				}
				else
				{
					//
					//  We might have been trying to set up the server VC
					//  because of other reasons:
					//  - to resolve an unknown IP address
					//  - the server ATM address might be shared with other
					//    services (e.g. DHCP server)
					//
					//  We don't have to retry registration in these cases.
					//
					AA_RELEASE_IF_LOCK(pInterface);
				}
			}
		}
	}
	else
	{
		//
		//  The Interface is going down: clean up everything first.
		//

		if (Status == NDIS_STATUS_SUCCESS)
		{
			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_ACTIVE);

			//
			//  The call had been set up successfully, so close it.
			//  AtmArpCloseCall also frees any queued packets on the VC.
			//
			AtmArpCloseCall(pVc);
			//
			//  The VC lock is released by CloseCall
			//
		}
		else
		{
			//  MakeCall had failed. (And the IF is going down)

			AA_SET_FLAG(pVc->Flags,
						AA_VC_CALL_STATE_MASK,
						AA_VC_CALL_STATE_IDLE);

			//
			//  Remove all packets queued on this VC
			//
			PacketList = pVc->PacketList;
			pVc->PacketList = (PNDIS_PACKET)NULL;
	
			NdisVcHandle = pVc->NdisVcHandle;

			AtmArpUnlinkVcFromAtmEntry(pVc, TRUE);

			//
			//  Delete the ATM Entry reference
			//
			rc = AtmArpDereferenceVc(pVc);  // ATM Entry ref

			//
			//  Delete the Call reference
			//
			rc = AtmArpDereferenceVc(pVc);
			AA_ASSERT(rc > 0);

			//
			//  Delete the CreateVc reference
			//
			rc =  AtmArpDereferenceVc(pVc);	// Create Vc ref

			if (rc != 0)
			{
				AA_RELEASE_VC_LOCK(pVc);
			}

#ifndef VC_REFS_ON_SENDS
			//
			//  Delete the NDIS association
			//
			(VOID)NdisCoDeleteVc(NdisVcHandle);
			AADEBUGP(AAD_LOUD,
				("MakeCall Fail: Deleted NDIS VC on pVc 0x%x: NdisVcHandle 0x%x\n",
						pVc, NdisVcHandle));
#endif // !VC_REFS_ON_SENDS
		}
	}

	//
	//  If there was a failure in making the call, or we aborted
	//  it for some reason, free all packets that were queued
	//  on the VC.
	//
	if (PacketList != (PNDIS_PACKET)NULL)
	{
		AtmArpFreeSendPackets(
					pInterface,
					PacketList,
					HdrPresent
					);
	}

	//
	//  We would have allocated the Call Parameters in MakeCall().
	//  We don't need it anymore.
	//
	AA_FREE_MEM(pCallParameters);
	return;

}



#ifdef IPMCAST

VOID
AtmArpMcMakeCallComplete(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	NDIS_STATUS					Status
)
/*++

Routine Description:

	Post-processing of a PMP MakeCall completion.

Arguments:

	pAtmEntry					- Represents the multicast group to which
								  the call was made.
	NdisPartyHandle				- Returned from the MakeCall.
	Status						- Result of the MakeCall

Return Value:

	None

--*/
{

	PATMARP_IPMC_ATM_ENTRY			pMcAtmEntry;
	PATMARP_IPMC_ATM_ENTRY *		ppMcAtmEntry;
	PATMARP_IPMC_ATM_INFO			pMcAtmInfo;
	PATMARP_IP_ENTRY				pIpEntry;
	PATMARP_INTERFACE				pInterface;
	//
	//  Do we need to update the PMP connection as a result
	//  of this event?
	//
	BOOLEAN							bWantConnUpdate;
	ULONG							DelayBeforeRetry;
	BOOLEAN							bAtmEntryLockAcquired;

	bAtmEntryLockAcquired = TRUE;
	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	AA_ASSERT(pAtmEntry->pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);
	AA_ASSERT(pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY);

	pIpEntry = pAtmEntry->pIpEntryList;
	pMcAtmInfo = pAtmEntry->pMcAtmInfo;
	pInterface = pAtmEntry->pInterface;

	bWantConnUpdate = FALSE;

	pMcAtmInfo->TransientLeaves--;

	//
	//  Locate the MC ATM Entry representing the first party.
	//
	for (pMcAtmEntry = pMcAtmInfo->pMcAtmEntryList;
		 /* NONE */;
		 pMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry)
	{
		AA_ASSERT(pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY);
		if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_WACK_ADD_PARTY))
		{
			break;
		}
	}

	AAMCDEBUGP(AAD_INFO,
			("McMakeCallComplete: pAtmEntry 0x%x, pMcAtmEntry 0x%x, Status 0x%x\n",
					pAtmEntry, pMcAtmEntry, Status));

	AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "McMakeCall Addr: ", &pMcAtmEntry->ATMAddress);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pMcAtmInfo->ActiveLeaves++;

		//
		//  Update Multicast state
		//
		AA_SET_FLAG(pMcAtmInfo->Flags,
					AA_IPMC_AI_CONN_STATE_MASK,
					AA_IPMC_AI_CONN_ACTIVE);

		//
		//  Update state of "first party"
		//
		pMcAtmEntry->NdisPartyHandle = NdisPartyHandle;
		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_ACTIVE);

		bWantConnUpdate = TRUE;

		//
		//  If we had decided to terminate this member when the
		//  MakeCall was going on, then we now mark this as Invalid.
		//  When we next update this PMP connection, this member will
		//  be removed.
		//
		if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_TERMINATING))
		{
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_GEN_STATE_MASK,
						AA_IPMC_AE_INVALID);
		}
	}
	else
	{
		//
		//  A PMP call failed. If the failure is not "transient",
		//  we remove the member we were trying to connect to
		//  from the list. If there is atleast one more member
		//  that hasn't been attempted yet, try to connect to that.
		//

		AAMCDEBUGP(AAD_INFO, ("McMakeCall failed: pAtmEntry 0x%x, pMcAtmEntry 0x%x, Status 0x%x ",
					pAtmEntry, pMcAtmEntry, Status));
		AAMCDEBUGPATMADDR(AAD_INFO, " Addr: ", &pMcAtmEntry->ATMAddress);

		//
		//  Update PMP connection state
		//
		AA_SET_FLAG(pAtmEntry->pMcAtmInfo->Flags,
					AA_IPMC_AI_CONN_STATE_MASK,
					AA_IPMC_AI_CONN_NONE);


		if (AA_IS_TRANSIENT_FAILURE(Status))
		{
			//
			//  Update first party state.
			//
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_TEMP_FAILURE);

			DelayBeforeRetry = AA_GET_TIMER_DURATION(&(pMcAtmEntry->Timer));
			if (DelayBeforeRetry == 0)
			{
				//
				//  First time we're doing this.
				//
				DelayBeforeRetry = AA_GET_RANDOM(
										pInterface->MinPartyRetryDelay,
										pInterface->MaxPartyRetryDelay);
			}
			else
			{
				DelayBeforeRetry = 2*DelayBeforeRetry;
			}

			AtmArpStartTimer(
				pInterface,
				&(pMcAtmEntry->Timer),
				AtmArpMcPartyRetryDelayTimeout,
				DelayBeforeRetry,
				(PVOID)pMcAtmEntry
				);
		}
		else
		{
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_DISCONNECTED);

			AtmArpMcUnlinkAtmMember(
					pAtmEntry,
					pMcAtmEntry
					);

		}

		//
		//  Look for a member that we haven't tried to connect to.
		//
		for (ppMcAtmEntry = &(pMcAtmInfo->pMcAtmEntryList);
			 *ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
			 ppMcAtmEntry = &((*ppMcAtmEntry)->pNextMcAtmEntry))
		{
			if (AA_IS_FLAG_SET((*ppMcAtmEntry)->Flags,
								AA_IPMC_AE_CONN_STATE_MASK,
								AA_IPMC_AE_CONN_DISCONNECTED))
			{
				//
				//  Found one.
				//
				break;
			}
		}

		if (*ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
		{
			pMcAtmEntry = *ppMcAtmEntry;

			//
			//  Move this member to the top of the list.
			//  First, unlink from current position.
			//
			*ppMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

			//
			//  Now insert this at top of list.
			//
			pMcAtmEntry->pNextMcAtmEntry = pMcAtmInfo->pMcAtmEntryList;
			pMcAtmInfo->pMcAtmEntryList = pMcAtmEntry;

			bWantConnUpdate = TRUE;
		}
		else
		{
			//
			//  There is no ATM member that we haven't tried to connect to.
			//
			if (pMcAtmInfo->pMcAtmEntryList == NULL_PATMARP_IPMC_ATM_ENTRY)
			{
				//
				//  The list of ATM Members is empty.
				//
				AA_RELEASE_AE_LOCK(pAtmEntry);

				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
				AtmArpAbortIPEntry(pIpEntry);
				//
				//  IE Lock is released within the above.
				//

				bAtmEntryLockAcquired = FALSE;
			}
		}
	}


	if (bWantConnUpdate)
	{
		AA_ASSERT(bAtmEntryLockAcquired == TRUE);
		AtmArpMcUpdateConnection(pAtmEntry);
		//
		//  AE Lock is released within the above.
		//
	}
	else
	{
		if (bAtmEntryLockAcquired)
		{
			AA_RELEASE_AE_LOCK(pAtmEntry);
		}
	}
}

#endif // IPMCAST


VOID
AtmArpCloseCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext OPTIONAL
)
/*++

Routine Description:

	This routine handles completion of a previous NdisClCloseCall.
	It is assumed that Status is always NDIS_STATUS_SUCCESS.

	We delete the VC on which the call was just closed.

	Special case: if we just finished closing a PMP call for a multicast
	group that has been told to migrate to a (possibly) new set of
	addresses, start off a new connection now.

Arguments:

	Status					- Status of the Close Call.
	ProtocolVcContext		- Pointer to ATMARP VC structure.
	ProtocolPartyContext	- Not used.

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;
	PATMARP_VC *			ppVc;
	PATMARP_ATM_ENTRY		pAtmEntry;
	PATMARP_INTERFACE		pInterface;
#ifdef IPMCAST
	PATMARP_IPMC_ATM_ENTRY	pMcAtmEntry;	// represents the last leaf
	PATMARP_IPMC_ATM_INFO	pMcAtmInfo;
#endif // IPMCAST
	ULONG					rc;			// Ref Count
	NDIS_HANDLE				NdisVcHandle;
	BOOLEAN					UpdatePMPConnection;
	BOOLEAN					AtmEntryIsClosing;
	BOOLEAN					IsMarsProblem;
	BOOLEAN					IsPVC;
	BOOLEAN					Found;

	pVc = (PATMARP_VC)ProtocolVcContext;
	AA_STRUCT_ASSERT(pVc, avc);

	AADEBUGP(AAD_VERY_LOUD, ("CloseCallComplete: pVc 0x%x, Flags 0x%x, RefCount %d\n",
					pVc, pVc->Flags, pVc->RefCount));

	IsPVC = AA_IS_FLAG_SET(pVc->Flags, AA_VC_TYPE_MASK, AA_VC_TYPE_PVC);

	//
	//  This VC may not be linked to an ATM Entry, e.g. for an unresolved
	//  Incoming PVC.
	//
	pAtmEntry = pVc->pAtmEntry;

	if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AtmEntryIsClosing = AA_IS_FLAG_SET(pAtmEntry->Flags,
											AA_ATM_ENTRY_STATE_MASK,
											AA_ATM_ENTRY_CLOSING);
	}
	else
	{
		AtmEntryIsClosing = FALSE;
	}

	pInterface = pVc->pInterface;

	if (IsPVC)
	{
		//
		//  Take the PVC out of the unresolved VC list, if it
		//  exists there.
		//
		Found = FALSE;

		AA_ACQUIRE_IF_LOCK(pInterface);

		ppVc = &(pInterface->pUnresolvedVcs);
		while (*ppVc != NULL_PATMARP_VC)
		{
			if (*ppVc == pVc)
			{
				*ppVc = pVc->pNextVc;
				Found = TRUE;
				break;
			}
			ppVc = &((*ppVc)->pNextVc);
		}

		AA_RELEASE_IF_LOCK(pInterface);

		AA_ACQUIRE_VC_LOCK(pVc);

		if (Found)
		{
			AADEBUGP(AAD_FATAL,
				("CloseCallComplete: took VC (PVC) %x out of IF %x\n",
						pVc, pInterface));

			rc = AtmArpDereferenceVc(pVc);	// Unresolved VC list
		}
		else
		{
			rc = pVc->RefCount;
		}

		if (rc == 0)
		{
			//
			//  The VC is gone!
			//
			AADEBUGP(AAD_WARNING,
				("CloseCallComplete: VC (PVC) %x derefed away, IF %x\n",
						pVc, pInterface));
			return;
		}
		else
		{
			AA_RELEASE_VC_LOCK(pVc);
		}
	}

#ifdef IPMCAST

	//
	//  We have lost our connection to the MARS if this was the last
	//  VC going to that address. We should atleast be a party on
	//  ClusterControlVc.
	//
	IsMarsProblem = FALSE;

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
		{
			if (pAtmEntry->pVcList->pNextVc == NULL_PATMARP_VC)
			{
				if (pInterface->pCurrentMARS &&
					(pInterface->pCurrentMARS->pAtmEntry == pAtmEntry))
				{
					IsMarsProblem = TRUE;
					AA_ACQUIRE_IF_LOCK(pInterface);
					AtmArpReferenceInterface(pInterface);
					AA_RELEASE_IF_LOCK(pInterface);
				}
			}
		}
	}
	
	UpdatePMPConnection = FALSE;

	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)ProtocolPartyContext;

	//
	//  If this is a point-to-multipoint connection that was closed,
	//  handle unlinking the last leaf.
	//
	if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
	{
		//
		//  This is a PMP connection.
		//
		AAMCDEBUGP(AAD_LOUD, ("CloseCallComplete (MC): pAtmEntry 0x%x/0x%x\n",
			pAtmEntry, pAtmEntry->Flags));

		AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);

		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_DISCONNECTED);

		AtmArpMcUnlinkAtmMember(pAtmEntry, pMcAtmEntry);

		pMcAtmInfo = pAtmEntry->pMcAtmInfo;
		AA_ASSERT(pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);

		//
		//  Make the new list of ATM stations (the "Migrate to" list)
		//  the current list. This might be NULL.
		//
		pMcAtmInfo->pMcAtmEntryList = pMcAtmInfo->pMcAtmMigrateList;
		pMcAtmInfo->pMcAtmMigrateList = NULL_PATMARP_IPMC_ATM_ENTRY;

		//
		//  If there is a non-empty migrate list, then we have
		//  to make a fresh PMP connection.
		//
		UpdatePMPConnection =
			(pMcAtmInfo->pMcAtmEntryList != NULL_PATMARP_IPMC_ATM_ENTRY);

		AA_SET_FLAG(pMcAtmInfo->Flags,
					AA_IPMC_AI_CONN_STATE_MASK,
					AA_IPMC_AI_CONN_NONE);

		AA_RELEASE_AE_LOCK(pAtmEntry);
	}
#endif // IPMCAST

	AA_ACQUIRE_VC_LOCK(pVc);

	if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AtmArpUnlinkVcFromAtmEntry(pVc, TRUE);
		rc = AtmArpDereferenceVc(pVc);  // ATM Entry ref
		AA_ASSERT(rc != 0);
	}

	rc = AtmArpDereferenceVc(pVc);	// Call reference
	AA_ASSERT(rc != 0);	// CreateVc reference remains
	AA_SET_FLAG(pVc->Flags,
				AA_VC_CALL_STATE_MASK,
				AA_VC_CALL_STATE_IDLE);

	AA_ASSERT(pVc->PacketList == NULL);

	//
	//  If this VC belongs to us, delete it.
	//
	if (AA_IS_FLAG_SET(pVc->Flags,
						AA_VC_OWNER_MASK,
						AA_VC_OWNER_IS_ATMARP))
	{
		NdisVcHandle = pVc->NdisVcHandle;
		rc =  AtmArpDereferenceVc(pVc);	// Create Vc ref
		if (rc != 0)
		{
			// Could still be temp refs...
			AA_RELEASE_VC_LOCK(pVc);
		}
		else
		{
			// The VC has been deallocated, and lock released
		}

#ifndef VC_REFS_ON_SENDS
		//
		//  Delete the NDIS association
		//
		(VOID)NdisCoDeleteVc(NdisVcHandle);
#endif // VC_REFS_ON_SENDS
		AADEBUGP(AAD_LOUD, 
			("CloseCallComplete: deleted NDIS VC on pVc 0x%x: NdisVcHandle 0x%x\n",
				pVc, NdisVcHandle));
	}
	else
	{
		//
		//  VC belongs to the Call Manager -- take it back to the
		//  state it was when it was just created (via our CreateVcHandler).
		//  The Call Manager can either re-use it or delete it.
		//
		pVc->Flags = AA_VC_OWNER_IS_CALLMGR;
		AA_RELEASE_VC_LOCK(pVc);
	}

#ifdef IPMCAST
	if (UpdatePMPConnection)
	{
		AAMCDEBUGP(AAD_INFO,
			("CloseCallComplete: pVc 0x%x, starting update on pAtmEntry 0x%x\n",
					pVc, pAtmEntry));

		AA_ACQUIRE_AE_LOCK(pAtmEntry);
		AtmArpMcUpdateConnection(pAtmEntry);
		//
		//  AE Lock is released within the above.
		//
	}
	else
	{
		//
		//  If this was a PMP connection, handle the case
		//  of a remote-initiated CloseCall: we need to
		//  unlink the ATM Entry from the IP Entry.
		//
		if ((pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY) &&
			!AtmEntryIsClosing)
		{
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
			AtmArpInvalidateAtmEntry(pAtmEntry, FALSE);	// CloseCallComplete
		}
	}

	if (IsMarsProblem)
	{
		AA_ACQUIRE_IF_LOCK(pInterface);
		rc = AtmArpDereferenceInterface(pInterface);
		if (rc != 0)
		{
			AA_RELEASE_IF_LOCK(pInterface);
			AtmArpMcHandleMARSFailure(pInterface, FALSE);
		}
		//
		//  else the interface is gone.
		//
	}
#endif
	return;
}



#ifdef IPMCAST


VOID
AtmArpAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClAddParty. Since we don't use point-to-multipoint connections,
	this should never get called.

	If the AddParty was successful, we just update state and exit. If it
	failed, we check the failure code. If this indicates a transient
	failure condition, we start a timer so that we reattempt to add this
	party later. Otherwise ("hard" failure), this multicast entry is deleted.

Arguments:

	Status					- Status of the AddParty
	ProtocolPartyContext	- Pointer to an IPMC_ATM_ENTRY structure
	NdisPartyHandle			- NDIS' handle for this party
	pCallParameters			- what we had passed to NdisClAddParty

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_ENTRY			pMcAtmEntry;
	PATMARP_ATM_ENTRY				pAtmEntry;
	PATMARP_IP_ENTRY				pIpEntry;
	PATMARP_VC						pVc;
	ULONG							VcFlags;
	PATMARP_INTERFACE				pInterface;
	ULONG							DelayBeforeRetry;
	BOOLEAN							ClearToSend;

	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)(ProtocolPartyContext);
	AA_STRUCT_ASSERT(pMcAtmEntry, ame);

	pAtmEntry = pMcAtmEntry->pAtmEntry;
	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	pAtmEntry->pMcAtmInfo->TransientLeaves--;

	pVc = pAtmEntry->pVcList;
	VcFlags = pVc->Flags;
	pInterface = pAtmEntry->pInterface;

	AAMCDEBUGP(AAD_LOUD,
	 ("AddPartyComplete: Status 0x%x, pAtmEntry 0x%x, pMcAtmEntry 0x%x, pVc 0x%x\n",
	 	Status, pAtmEntry, pMcAtmEntry, pVc));

	AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "AddParty Addr: ", &pMcAtmEntry->ATMAddress);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_ACTIVE);

		//
		//  If we had decided to terminate this member when the
		//  AddParty was going on, then we now mark this as Invalid.
		//  When we next update this PMP connection, this member will
		//  be removed.
		//
		if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_TERMINATING))
		{
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_GEN_STATE_MASK,
						AA_IPMC_AE_INVALID);
		}

		pMcAtmEntry->NdisPartyHandle = NdisPartyHandle;
		pAtmEntry->pMcAtmInfo->ActiveLeaves++;
	}
	else
	{
		AAMCDEBUGP(AAD_INFO,
			("AddPartyComplete: Status 0x%x, pAtmEntry 0x%x, to ", Status, pAtmEntry));
		AAMCDEBUGPATMADDR(AAD_INFO, "", &pMcAtmEntry->ATMAddress);

		//
		//  Check if the failure was due to a transient
		//  condition.
		//
		if (AA_IS_TRANSIENT_FAILURE(Status))
		{
			//
			//  We'll fire a timer, so that we reattempt to
			//  connect to this one later. If we had already
			//  done this (i.e. time out on failure), then
			//  we include a back-off time in the delay.
			//
			DelayBeforeRetry = AA_GET_TIMER_DURATION(&(pMcAtmEntry->Timer));
			if (DelayBeforeRetry == 0)
			{
				//
				//  First time we're doing this.
				//
				DelayBeforeRetry = AA_GET_RANDOM(
										pInterface->MinPartyRetryDelay,
										pInterface->MaxPartyRetryDelay);
			}
			else
			{
				DelayBeforeRetry = 2*DelayBeforeRetry;
			}

			AtmArpStartTimer(
				pInterface,
				&(pMcAtmEntry->Timer),
				AtmArpMcPartyRetryDelayTimeout,
				DelayBeforeRetry,
				(PVOID)pMcAtmEntry
				);

			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_TEMP_FAILURE);
			
		}
		else
		{
			//
			//  Not a transient failure. Delete this member.
			//
			AA_SET_FLAG(pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_DISCONNECTED);

			AtmArpMcUnlinkAtmMember(
					pAtmEntry,
					pMcAtmEntry
					);
		}
	}

	ClearToSend = ((pAtmEntry->pMcAtmInfo->TransientLeaves == 0) &&
				   (AA_IS_FLAG_SET(pAtmEntry->pMcAtmInfo->Flags,
					   				   AA_IPMC_AI_CONN_STATE_MASK,
					   				   AA_IPMC_AI_CONN_ACTIVE)));

	pIpEntry = pAtmEntry->pIpEntryList;


	AA_RELEASE_AE_LOCK(pAtmEntry);
			
	if (pCallParameters != (PCO_CALL_PARAMETERS)NULL)
	{
		AA_FREE_MEM(pCallParameters);
	}

	//
	//  Check if the VC is closing, and we had held back because
	//  this AddParty was in progress. If so, try to continue the
	//  CloseCall process.
	//
	AA_ACQUIRE_VC_LOCK(pVc);
	if (AA_IS_FLAG_SET(pVc->Flags,
						AA_VC_CLOSE_STATE_MASK,
						AA_VC_CLOSE_STATE_CLOSING))
	{
		AtmArpCloseCall(pVc);
		//
		//  VC Lock is released within the above.
		//
	}
	else
	{
		PNDIS_PACKET	pPacketList;

		AA_RELEASE_VC_LOCK(pVc);

		if (ClearToSend && pIpEntry)
		{
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			pPacketList = pIpEntry->PacketList;
			pIpEntry->PacketList = (PNDIS_PACKET)NULL;
			AA_RELEASE_IE_LOCK(pIpEntry);

			if (pPacketList != (PNDIS_PACKET)NULL)
			{
				AAMCDEBUGP(AAD_INFO, ("AddPtyCompl: pAtmEntry 0x%x, sending pktlist 0x%x\n",
					pAtmEntry, pPacketList));

				AtmArpSendPacketListOnAtmEntry(
						pInterface,
						pAtmEntry,
						pPacketList,
						TRUE	// IsBroadcast
						);
			}
		}
	}
}


#else

VOID
AtmArpAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClAddParty. Since we don't use point-to-multipoint connections,
	this should never get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("Add Party Complete unexpectedly called\n"));
	AA_ASSERT(FALSE);
}

#endif // IPMCAST



VOID
AtmArpDropPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClDropParty. We unlink our party structure and free it.

Arguments:

	Status						- Final result of the Drop Party
	ProtocolPartyContext		- Pointer to the MC ATM Entry we used
								  to represent the party.

Return Value:

	None

--*/
{
#ifdef IPMCAST
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_ATM_ENTRY			pAtmEntry;
	PATMARP_IP_ENTRY			pIpEntry;
	ULONG						rc;
	BOOLEAN						LockReleased;

	AAMCDEBUGP(AAD_LOUD, ("DropPartyComplete: Status 0x%x, Context 0x%x\n",
				Status, ProtocolPartyContext));

	AA_ASSERT(Status == NDIS_STATUS_SUCCESS);


	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)ProtocolPartyContext;
	AA_STRUCT_ASSERT(pMcAtmEntry, ame);

	pAtmEntry = pMcAtmEntry->pAtmEntry;
	AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);
	AA_STRUCT_ASSERT(pAtmEntry, aae);

	AA_ACQUIRE_AE_LOCK(pAtmEntry);
	AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// temp ref

	AA_SET_FLAG(pMcAtmEntry->Flags,
				AA_IPMC_AE_CONN_STATE_MASK,
				AA_IPMC_AE_CONN_DISCONNECTED);

	AtmArpMcUnlinkAtmMember(pAtmEntry, pMcAtmEntry);

	//
	//  If we are in the processing of closing this PMP call,
	//  and this event signifies that all preliminary DropParty's
	//  are complete, then close the call itself.
	//
	LockReleased = FALSE;
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// temp ref

	if (rc != 0)
	{
		PATMARP_VC		pVc;

		pVc = pAtmEntry->pVcList;
		if (pVc != NULL_PATMARP_VC)
		{
			if (AA_IS_FLAG_SET(pVc->Flags,
							AA_VC_CLOSE_STATE_MASK,
							AA_VC_CLOSE_STATE_CLOSING) &&
				(pAtmEntry->pMcAtmInfo->NumOfEntries == 1))
			{
				AA_RELEASE_AE_LOCK(pAtmEntry);
				AA_ACQUIRE_VC_LOCK(pVc);

				AtmArpCloseCall(pVc);
				//
				//  VC lock is released within the above.
				//
				LockReleased = TRUE;
			}
		}
	}
				

	if (!LockReleased)
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}

#endif // IPMCAST
}



VOID
AtmArpModifyQosCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
)
/*++

Routine Description:

	This routine is called on completion of a previous call to
	NdisClModifyCallQoS. Since we don't call this, this should never
	get called.

Arguments:

	<Don't care>

Return Value:

	None

--*/
{
	AADEBUGP(AAD_ERROR, ("Modify QOS Complete unexpectedly called\n"));
	AA_ASSERT(FALSE);
}


#ifndef OID_CO_AF_CLOSE
#define OID_CO_AF_CLOSE				0xFE00000A
#endif


NDIS_STATUS
AtmArpCoRequestHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
)
/*++

Routine Description:

	This routine is called by NDIS when our Call Manager sends us an
	NDIS Request. NDIS Requests that are of significance to us are:
	- OID_CO_ADDRESS_CHANGE
		The set of addresses registered with the switch has changed,
		i.e. address registration is complete. We issue an NDIS Request
		ourselves to get the list of addresses registered.
	- OID_CO_SIGNALING_ENABLED
		We ignore this as of now.
	- OID_CO_SIGNALING_DISABLED
		We ignore this for now.
	- OID_CO_AF_CLOSE
		The Call Manager wants us to shut down this Interface.

	We ignore all other OIDs.

Arguments:

	ProtocolAfContext			- Our context for the Address Family binding,
								  which is a pointer to the ATMARP Interface.
	ProtocolVcContext			- Our context for a VC, which is a pointer to
								  an ATMARP VC structure.
	ProtocolPartyContext		- Our context for a Party. Since we don't do
								  PMP, this is ignored (must be NULL).
	pNdisRequest				- Pointer to the NDIS Request.

Return Value:

	NDIS_STATUS_SUCCESS if we recognized the OID
	NDIS_STATUS_NOT_RECOGNIZED if we didn't.

--*/
{
	PATMARP_INTERFACE			pInterface;
	NDIS_STATUS					Status;

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	//
	//  Initialize
	//
	Status = NDIS_STATUS_NOT_RECOGNIZED;

	if (pNdisRequest->RequestType == NdisRequestSetInformation)
	{
		switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
		{
			case OID_CO_ADDRESS_CHANGE:
				//
				//  The Call Manager says that the list of addresses
				//  registered on this interface has changed. Get the
				//  (potentially) new ATM address for this interface.
				//
				AA_ACQUIRE_IF_LOCK(pInterface);
				pInterface->AtmInterfaceUp = FALSE;
				AA_RELEASE_IF_LOCK(pInterface);

				AtmArpGetAtmAddress(pInterface);
				Status = NDIS_STATUS_SUCCESS;
				break;
			
			case OID_CO_SIGNALING_ENABLED:	// FALLTHRU
			case OID_CO_SIGNALING_DISABLED:
				// Ignored for now
				Status = NDIS_STATUS_SUCCESS;
				break;

			case OID_CO_AF_CLOSE:
				AA_ACQUIRE_IF_LOCK(pInterface);
				pInterface->AdminState = pInterface->State = IF_STATUS_DOWN;
				pInterface->LastChangeTime = GetTimeTicks();
				AA_RELEASE_IF_LOCK(pInterface);
				AtmArpShutdownInterface(pInterface);
				Status = NDIS_STATUS_SUCCESS;
				break;

			default:
				break;
		}
	}

	return (Status);
}



VOID
AtmArpCoRequestCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This routine is called by NDIS when a previous call to NdisCoRequest
	that had pended, is complete. We handle this based on the request
	we had sent, which has to be one of:
	- OID_CO_GET_ADDRESSES
		Get all addresses registered on the specified AF binding.

Arguments:

	Status						- Status of the Request.
	ProtocolAfContext			- Our context for the Address Family binding,
								  which is a pointer to the ATMARP Interface.
	ProtocolVcContext			- Our context for a VC, which is a pointer to
								  an ATMARP VC structure.
	ProtocolPartyContext		- Our context for a Party. Since we don't do
								  PMP, this is ignored (must be NULL).
	pNdisRequest				- Pointer to the NDIS Request.


Return Value:

	None

--*/
{
	PATMARP_INTERFACE			pInterface;
	ULONG						Oid;

	pInterface = (PATMARP_INTERFACE)ProtocolAfContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	if (pNdisRequest->RequestType == NdisRequestQueryInformation)
	{
		switch (pNdisRequest->DATA.QUERY_INFORMATION.Oid)
		{
			case OID_CO_GET_ADDRESSES:
				AtmArpHandleGetAddressesComplete(
							Status,
							pInterface,
							pNdisRequest
							);
				break;

			default:
				AADEBUGP(AAD_ERROR,
					 ("CoRequestComplete: pNdisReq 0x%x, unknown Query Oid 0x%x\n",
					 		pNdisRequest,
					 		pNdisRequest->DATA.QUERY_INFORMATION.Oid));
				AA_ASSERT(FALSE);
				break;
		}
	}
	else
	{
		Oid = pNdisRequest->DATA.QUERY_INFORMATION.Oid;
		switch (Oid)
		{
			case OID_CO_ADD_ADDRESS:	// FALLTHRU
			case OID_CO_DELETE_ADDRESS:
				AtmArpHandleModAddressComplete(
							Status,
							pInterface,
							pNdisRequest,
							Oid
							);
				break;

			default:
				AADEBUGP(AAD_ERROR,
					 ("CoRequestComplete: pNdisReq 0x%x, unknown Set Oid 0x%x\n",
					 		pNdisRequest, Oid));
				AA_ASSERT(FALSE);
				break;
		}
	}

	AA_FREE_MEM(pNdisRequest);
}



VOID
AtmArpGetAtmAddress(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Send a request to the Call Manager to retrieve the ATM address
	registered with the switch on the given interface.

	This is called when the Call Manager tells us that there has been
	a change in its list of addresses registered with the switch.
	Normally, this happens when we start up our signalling stack (i.e.
	initial address registration), but it might happen during runtime,
	for example, if the link goes down and up, or we get physically
	connected to a different switch...

	In any case, we issue an NDIS Request to the Call Manager to retrieve
	the first address it has registered. Action then continues in
	AtmArpHandleGetAddressesComplete.

Arguments:

	pInterface				- Interface structure for which this event occurred.

Return Value:

	None

--*/
{
	PNDIS_REQUEST				pNdisRequest;
	NDIS_HANDLE					NdisAfHandle;
	NDIS_HANDLE					NdisAdapterHandle;
	NDIS_STATUS					Status;

	PCO_ADDRESS_LIST			pAddressList;
	ULONG						RequestSize;

	AADEBUGP(AAD_INFO, ("GetAtmAddress: pIf 0x%x\n", pInterface));

	AA_ACQUIRE_IF_LOCK(pInterface);

	NdisAfHandle = pInterface->NdisAfHandle;
	NdisAdapterHandle = pInterface->NdisAdapterHandle;

	AA_RELEASE_IF_LOCK(pInterface);

	RequestSize = sizeof(CO_ADDRESS_LIST) + sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);

	//
	//  Allocate all that we need.
	//
	AA_ALLOC_MEM(pNdisRequest, NDIS_REQUEST, sizeof(NDIS_REQUEST)+RequestSize);
	if (pNdisRequest != (PNDIS_REQUEST)NULL)
	{
		pAddressList = (PCO_ADDRESS_LIST)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

		AA_SET_MEM(pAddressList, 0, sizeof(CO_ADDRESS_LIST));

		Status = AtmArpSendNdisCoRequest(
						NdisAdapterHandle,
						NdisAfHandle,
						pNdisRequest,
						NdisRequestQueryInformation,
						OID_CO_GET_ADDRESSES,
						(PVOID)pAddressList,
						RequestSize
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			AtmArpCoRequestCompleteHandler(
						Status,
						(NDIS_HANDLE)pInterface,	// ProtocolAfContext
						NULL,			// Vc Context
						NULL,			// Party Context
						pNdisRequest
						);
		}
	}

}


VOID
AtmArpHandleGetAddressesComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_REQUEST				pNdisRequest
)
/*++

Routine Description:

	This is called when we have a reply to our previous call to
	NdisCoRequest(OID_CO_GET_ADDRESSES). Check if we got any addresses
	back: if we did, store the address as our Local ATM Address, and
	if conditions are ripe, start registering ourselves with the ARP
	server.

	Since we allocated the NDIS request, free it here.

Arguments:

	Status					- result of the request
	pInterface				- ATMARP interface on which the request was issued
	pNdisRequest			- the request itself. This will also contain the
							  returned address.

Return Value:

	None

--*/
{
	PCO_ADDRESS_LIST		pAddressList;
	ATM_ADDRESS UNALIGNED *	pAtmAddress;

	AADEBUGP(AAD_LOUD, ("GetAddr complete: pIf 0x%x, Status 0x%x\n",
				pInterface, Status));

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAddressList = (PCO_ADDRESS_LIST)
						pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;

		AADEBUGP(AAD_LOUD, ("GetAddr complete: pIf 0x%x, Count %d\n",
					pInterface, pAddressList->NumberOfAddresses));

		if (pAddressList->NumberOfAddresses > 0)
		{
			//
			//  We have atleast one address here. Copy it in.
			//
			AA_ACQUIRE_IF_LOCK(pInterface);

			pAtmAddress = (ATM_ADDRESS UNALIGNED *)(pAddressList->AddressList.Address);
			AA_COPY_MEM((PUCHAR)&(pInterface->LocalAtmAddress),
						(PUCHAR)pAtmAddress,
						sizeof(ATM_ADDRESS));

			//
			//  Patch the selector byte with whatever is configured for
			//  this LIS.
			//
			pInterface->LocalAtmAddress.Address[ATM_ADDRESS_LENGTH-1] = 
							(UCHAR)(pInterface->SapSelector);

			pInterface->AtmInterfaceUp = TRUE;

			//
			//  To force registration:
			//
			AA_SET_FLAG(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_NO_CONTACT);

			AtmArpStartRegistration(pInterface);
			//
			//  The IF lock is released within the above.
			//

#ifdef IPMCAST
			//
			//  Attempt to start our Multicast side, too.
			//
			AA_ACQUIRE_IF_LOCK(pInterface);
			AtmArpMcStartRegistration(pInterface);
			//
			//  IF Lock is released within the above.
			//
#endif // IPMCAST

			//
			//  Add any (additional) addresses we want to register with
			//  the switch now.
			//
			AtmArpUpdateAddresses(
						pInterface,
						TRUE			// Add them
						);
		}
		//
		//  else no address is registered currently.
		//
	}
	//
	//  else our request failed! Wait for another ADDRESS_CHANGE.
	//

	return;

}



VOID
AtmArpUpdateAddresses(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						AddThem
)
/*++

Routine Description:

	Update the list of addresses we want the Call manager to register
	with the switch: either add addresses or delete them. We do this
	only if we are running in an SVC environment.

Arguments:

	pInterface				- Pointer to ATMARP Interface
	AddThem					- TRUE if caller wants us to add addresses,
							  FALSE if caller wats us to delete them.
Return Value:

	None

--*/
{
	PATMARP_SAP			pAtmArpSap;
	PATMARP_SAP			pNextSap;
	PATM_SAP			pAtmSap;
	PATM_ADDRESS		pAtmAddress;
	PCO_ADDRESS			pCoAddress;
	PNDIS_REQUEST		pNdisRequest;
	NDIS_HANDLE			NdisAfHandle;
	NDIS_HANDLE			NdisAdapterHandle;
	NDIS_OID			Oid;
	ULONG				BufferLength;
	NDIS_STATUS			Status;
	BOOLEAN				StateIsOkay;	// Does the current state allow this request
	ULONG				rc;				// Ref count

	StateIsOkay = TRUE;

	BufferLength = sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);

	AA_ACQUIRE_IF_LOCK(pInterface);
	NdisAfHandle = pInterface->NdisAfHandle;
	NdisAdapterHandle = pInterface->NdisAdapterHandle;

	if (AddThem)
	{
		Oid = OID_CO_ADD_ADDRESS;
		//
		//  This is allowed only if the AdminState for the interface
		//  is UP.
		//
		if (pInterface->AdminState != IF_STATUS_UP)
		{
			StateIsOkay = FALSE;
		}
	}
	else
	{
		Oid = OID_CO_DELETE_ADDRESS;
	}

	//
	//  Check all pre-conditions before progressing.
	//
	if (!(pInterface->PVCOnly) &&
		 (StateIsOkay) &&
		 (pInterface->AtmInterfaceUp) &&
		 (pInterface->NumberOfSaps > 1))
	{
		AA_ASSERT(pInterface->SapList.pNextSap != NULL_PATMARP_SAP);

		//
		//  Reference the Interface so that it doesn't go away.
		//
		AtmArpReferenceInterface(pInterface);
		pAtmArpSap = pInterface->SapList.pNextSap;

		AA_RELEASE_IF_LOCK(pInterface);

		do
		{
			if (AA_IS_FLAG_SET(
					pAtmArpSap->Flags,
					AA_SAP_ADDRTYPE_MASK,
					AA_SAP_ADDRTYPE_NEED_ADD))
			{
				//
				//  This SAP is of the type that needs to be added/deleted
				//  via ILMI
				//
				AA_ALLOC_MEM(
						pNdisRequest,
						NDIS_REQUEST,
						sizeof(NDIS_REQUEST)+
							sizeof(CO_ADDRESS)+
							sizeof(ATM_ADDRESS)
					);
		
				if (pNdisRequest != (PNDIS_REQUEST)NULL)
				{
					AA_SET_MEM(pNdisRequest, 0, sizeof(NDIS_REQUEST));
					//
					//  Stuff in our context for this request, which is a pointer
					//  to this ATMARP SAP, into the ProtocolReserved part of
					//  this request, so that we can handle completion easily.
					//
					*((PVOID *)(pNdisRequest->ProtocolReserved)) = (PVOID)pAtmArpSap;
	
					pCoAddress = (PCO_ADDRESS)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));
					pCoAddress->AddressSize = sizeof(ATM_ADDRESS);
					BufferLength = sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);
	
					//
					//  Save a pointer to the next SAP
					//
					pNextSap = pAtmArpSap->pNextSap;
	
					//
					//  Get at the ATM address in this SAP.
					//
					pAtmSap = (PATM_SAP)(pAtmArpSap->pInfo->Sap);
					AA_ASSERT(pAtmSap->NumberOfAddresses > 0);
					pAtmAddress = (PATM_ADDRESS)(pAtmSap->Addresses);
	
					AA_COPY_MEM(pCoAddress->Address, pAtmAddress, sizeof(ATM_ADDRESS));
					Status = AtmArpSendNdisCoRequest(
									NdisAdapterHandle,
									NdisAfHandle,
									pNdisRequest,
									NdisRequestSetInformation,
									Oid,
									(PVOID)pCoAddress,
									BufferLength
									);
	
					//
					//  Go to the next SAP in the list.
					//
					pAtmArpSap = pNextSap;
				}
				else
				{
					//
					// Out of resources.
					//
					break;
				}
			}
		}
		while (pAtmArpSap != NULL_PATMARP_SAP);

		//
		//  Remove the reference we added earlier on.
		//
		AA_ACQUIRE_IF_LOCK(pInterface);
		rc = AtmArpDereferenceInterface(pInterface);
		if (rc > 0)
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
		//
		//  else the Interface is gone!
	}
	else
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

}


VOID
AtmArpHandleModAddressComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	ULONG						Oid
)
/*++

Routine Description:

	This is called when we have a reply to our previous call to
	NdisCoRequest(OID_CO_ADD_ADDRESS or OID_CO_DELETE_ADDRESS).
	All we do now is to update the state on the ATMARP SAP.

Arguments:

	Status			- the result of our request.
	pInterface		- ATMARP interface pointer.
	pNdisRequest	- the request we had sent.
	Oid				- CO_OID_ADD_ADDRESS or CO_OID_DELETE_ADDRESS

Return Value:

	None

--*/
{
	PATMARP_SAP				pAtmArpSap;

	pAtmArpSap = (PATMARP_SAP)(*((PVOID *)(pNdisRequest->ProtocolReserved)));
	AA_STRUCT_ASSERT(pAtmArpSap, aas);

	AA_ACQUIRE_IF_LOCK(pInterface);

	//
	//  Update the state on this ATMARP SAP.
	//
	if ((Oid == OID_CO_ADD_ADDRESS) && (Status == NDIS_STATUS_SUCCESS))
	{
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_ILMI_STATE_MASK,
					AA_SAP_ILMI_STATE_ADDED);
	}
	else
	{
		AA_SET_FLAG(pAtmArpSap->Flags,
					AA_SAP_ILMI_STATE_MASK,
					AA_SAP_ILMI_STATE_IDLE);
	}

	AA_RELEASE_IF_LOCK(pInterface);
}




NDIS_STATUS
AtmArpSendNdisCoRequest(
	IN	NDIS_HANDLE					NdisAdapterHandle,
	IN	NDIS_HANDLE					NdisAfHandle,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
)
/*++

Routine Description:

	Send an NDIS Connection Oriented request to the Call Manager. We
	allocate an NDIS_REQUEST structure, link the supplied buffer to it,
	and send the request. If the request does not pend, we call our
	completion routine from here.

Arguments:

	NdisAdapterHandle		- Binding Handle to be used in the request
	NdisAfHandle			- AF Handle value to be used in the request
	pNdisRequest			- Pointer to NDIS request structure
	RequestType				- Set/Query information
	Oid						- OID to be passed in the request
	pBuffer					- place for value(s)
	BufferLength			- length of above

Return Value:

	Status of the NdisCoRequest.

--*/
{
	NDIS_STATUS			Status;

	//
	//  Fill in the NDIS Request structure
	//
	pNdisRequest->RequestType = RequestType;
	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
	}

	Status = NdisCoRequest(
				NdisAdapterHandle,
				NdisAfHandle,
				NULL,			// No VC handle
				NULL,			// No Party Handle
				pNdisRequest);
		
	return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\cubdd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	cubdd.h

Abstract:

	All CUB-DD related defines are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     09-16-96    Created

Notes:

--*/

#ifndef _ATMARPC__CUBDD_H
#define _ATMARPC__CUBDD_H


#ifdef CUBDD

//
//  Request to resolve an IP address to an ATM address.
//
typedef struct _ATMARP_REQUEST
{
	ULONG			IpAddress;
	ULONG			HwAddressLength;
	UCHAR			HwAddress[20];
}
ATMARP_REQUEST, *PATMARP_REQUEST;

//
//  The Address resolution IOCTL command code.
//
#define IOCTL_ATMARP_REQUEST   0x00000001


#endif // CUBDD

#endif // _ATMARPC__CUBDD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\cmddk.h ===
/*

Copyright (c) 1990-1996  Microsoft Corporation

Module Name:

    cmddk.h

Abstract:

    This module defines the structures, macros, and functions missing from 
    ndis.h when you specify BINARY_COMPATIBLE=1 but do not include ntddk.h
    

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	alid     	10-14-96    Created

--*/

#ifndef _CMDDK_INCLUDED_
#define _CMDDK_INCLUDED_

//
// needed by cxport.h taken from ntddk.h
//

typedef
VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );
    
typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );


//
// Spin Lock
//

// typedef ULONG KSPIN_LOCK;  // winnt ntndis

// typedef KSPIN_LOCK *PKSPIN_LOCK;


#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList


NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#if defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLockAtDpcLevel(a)      KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a)    KefReleaseSpinLockFromDpcLevel(a)

#else

NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#endif



#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || (defined(_X86_) && !defined(_NTHAL_))

//  begin_wdm

#if defined(_X86_)

__declspec(dllimport)
KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

__declspec(dllimport)
VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

__declspec(dllimport)
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

#else

__declspec(dllimport)
KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

__declspec(dllimport)
VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif

//  end_wdm

#else

#if defined(_X86_)

KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

#else

KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

KIRQL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif

#endif


#if defined(NT_UP) && !DBG && !defined(_NTDDK_) && !defined(_NTIFS_)

#if !defined(_NTDRIVER_)
#define ExAcquireSpinLock(Lock, OldIrql) (*OldIrql) = KeRaiseIrqlToDpcLevel();
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#else
#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#endif
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)

#else

//  begin_wdm

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm

#endif


NTKERNELAPI
KIRQL
KfRaiseIrqlToDpcLevel (
    VOID
    );

#define KeRaiseIrqlToDpcLevel(OldIrql) (*(OldIrql) = KfRaiseIrqlToDpcLevel())

NTKERNELAPI
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );

// end_nthal end_wdm

#if defined(NT_UP) && !defined(_NTDDK_) && !defined(_NTIFS_)
#define ExAcquireSpinLock(Lock, OldIrql) KeRaiseIrqlToDpcLevel((OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)
#else

//  begin_wdm

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

//  end_wdm

#endif



//
// Event type
//

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
    } EVENT_TYPE;



#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

//  begin_wdm

NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );

NTKERNELAPI
VOID
KeClearEvent (
    IN PRKEVENT Event
    );

//  end_wdm

#else

#define KeInitializeEvent(_Event, _Type, _State)            \
    (_Event)->Header.Type = (UCHAR)_Type;                   \
    (_Event)->Header.Size =  sizeof(KEVENT) / sizeof(LONG); \
    (_Event)->Header.SignalState = _State;                  \
    InitializeListHead(&(_Event)->Header.WaitListHead)

#define KeClearEvent(Event) (Event)->Header.SignalState = 0

#endif


LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    );


#ifndef ATMARP_WIN98
NTSYSAPI
ULONG
NTAPI
RtlCompareMemory (
    PVOID Source1,
    PVOID Source2,
    ULONG Length
    );
#endif

NTKERNELAPI
PVOID
ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );
    

#endif // _CMDDK_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\atmarp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    atmarp.h

Abstract:

	Structure definitions and function templates for the ATM ARP module.

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    arvindm     05-17-96    created

Notes:


--*/
#ifndef __ATMARP_H_INCLUDED
#define __ATMARP_H_INCLUDED

#include <ipexport.h>
#include "aaqos.h"

typedef IPAddr	IP_ADDRESS, *PIP_ADDRESS;
typedef IPMask	IP_MASK, *PIP_MASK;

#define IP_LOCAL_BCST	0xFFFFFFFF		// The local broadcast IP address
#define IP_CLASSD_MIN   0xE0			// Min class D address (NETWORK byte order)
#define IP_CLASSD_MASK  0xFFFFFF0F		// Mask representing the entire class D
										// range (NETWORK byte order).
        								//  (0xE0|0xFFFFFF0F) = 0xFFFFFFEF =
										//   239.255.255.255 in network byte order.

//
//  IP address list entry. Used to prepare a list of local IP addresses.
//
typedef struct _IP_ADDRESS_ENTRY
{
	struct _IP_ADDRESS_ENTRY *		pNext;			// Next in list
	IP_ADDRESS						IPAddress;		// The Address
	IP_MASK							IPMask;			// Mask for the above.
	BOOLEAN							IsRegistered;	// Registered with ARP Server?
	BOOLEAN							IsFirstRegistration;	// Is this the first time
															// this is being regd?

} IP_ADDRESS_ENTRY, *PIP_ADDRESS_ENTRY;


//
//  Proxy IP address list entry. Used to prepare a list of IP addresses for
//  which we act as an ARP proxy.
//
typedef struct _PROXY_ARP_ENTRY
{
	struct _PROXY_ARP_ENTRY *		pNext;			// Next in list
	IP_ADDRESS						IPAddress;		// The Address
	IP_MASK							IPMask;

} PROXY_ARP_ENTRY, *PPROXY_ARP_ENTRY;


//
//  Forward references
//
struct _ATMARP_VC ;
struct _ATMARP_IP_ENTRY ;
struct _ATMARP_ATM_ENTRY ;
#ifdef IPMCAST
struct _ATMARP_IPMC_JOIN_ENTRY ;
struct _ATMARP_IPMC_ATM_ENTRY ;
struct _ATMARP_IPMC_ATM_INFO ;
#endif // IPMCAST
struct _ATMARP_INTERFACE ;
struct _ATMARP_ADAPTER ;

#ifdef ATMARP_WMI
struct _ATMARP_IF_WMI_INFO ;
#endif


//
//  Server address list entry. Used to prepare a list of ARP/MARS servers
//  that we try to connect to.
//
typedef struct _ATMARP_SERVER_ENTRY
{
	struct _ATMARP_SERVER_ENTRY *	pNext;			// Next in list
	ATM_ADDRESS						ATMAddress;		// Address of the server
	ATM_ADDRESS						ATMSubaddress;	// Used only if ATMAddress is E.164
	struct _ATMARP_ATM_ENTRY *		pAtmEntry;		// Info about this ATM destination
	ULONG							Flags;			// State information (see below)

} ATMARP_SERVER_ENTRY, *PATMARP_SERVER_ENTRY;

#define NULL_PATMARP_SERVER_ENTRY		((PATMARP_SERVER_ENTRY)NULL)


//
//  Server list.
//
typedef struct _ATMARP_SERVER_LIST
{
	PATMARP_SERVER_ENTRY			pList;			// List of servers
	ULONG							ListSize;		// Size of above list

} ATMARP_SERVER_LIST, *PATMARP_SERVER_LIST;

#define NULL_PATMARP_SERVER_LIST		((PATMARP_SERVER_LIST)NULL)



//
//  ------------------------ Timer Management ------------------------
//

struct _ATMARP_TIMER ;
struct _ATMARP_TIMER_LIST ;

//
//  Timeout Handler prototype
//
typedef
VOID
(*ATMARP_TIMEOUT_HANDLER)(
	IN	struct _ATMARP_TIMER *		pTimer,
	IN	PVOID						Context
);

//
//  An ATMARP_TIMER structure is used to keep track of each timer
//  in the ATMARP module.
//
typedef struct _ATMARP_TIMER
{
	struct _ATMARP_TIMER *			pNextTimer;
	struct _ATMARP_TIMER *			pPrevTimer;
	struct _ATMARP_TIMER *			pNextExpiredTimer;	// Used to chain expired timers
	struct _ATMARP_TIMER_LIST *		pTimerList;			// NULL iff this timer is inactive
	ULONG							Duration;			// In seconds
	ULONG							LastRefreshTime;
	ATMARP_TIMEOUT_HANDLER			TimeoutHandler;
	PVOID							Context;			// To be passed to timeout handler
	ULONG							State;

} ATMARP_TIMER, *PATMARP_TIMER;

//
//  NULL pointer to ATMARP Timer
//
#define NULL_PATMARP_TIMER	((PATMARP_TIMER)NULL)

#define ATMARP_TIMER_STATE_IDLE		'ELDI'
#define ATMARP_TIMER_STATE_RUNNING	' NUR'
#define ATMARP_TIMER_STATE_EXPIRING	'GPXE'
#define ATMARP_TIMER_STATE_EXPIRED	'DPXE'


//
//  Control structure for a timer wheel. This contains all information
//  about the class of timers that it implements.
//
typedef struct _ATMARP_TIMER_LIST
{
#if DBG
	ULONG							atl_sig;
#endif // DBG
	PATMARP_TIMER					pTimers;		// List of timers
	ULONG							TimerListSize;	// Length of above
	ULONG							CurrentTick;	// Index into above
	ULONG							TimerCount;		// Number of running timers
	ULONG							MaxTimer;		// Max timeout value for this
	NDIS_TIMER						NdisTimer;		// System support
	UINT							TimerPeriod;	// Interval between ticks
	PVOID							ListContext;	// Used as a back pointer to the
													// Interface structure

} ATMARP_TIMER_LIST, *PATMARP_TIMER_LIST;

#if DBG
#define atl_signature		'ATL '
#endif // DBG

//
//  Timer Classes
//
typedef enum
{
	AAT_CLASS_SHORT_DURATION,
	AAT_CLASS_LONG_DURATION,
	AAT_CLASS_MAX

} ATMARP_TIMER_CLASS;





//
//  ----------------------- ATM Address Entry -----------------------------
//
//  All information about an ATM destination, and VCs to it. This is used
//  for both Unicast destinations (a single ATM endstation) and for Multicast
//  destinations (multiple ATM endstations).
// 
//  Unicast:
//  -------
//  There could be more than one VC going to this ATM destination, because
//  of use of different QoS on each. In the case of unicast destinations,
//  one or more ARP Table Entries (see below) could point to this entry,
//  because more than one IP address could map to this ATM address.
//
//  Multicast:
//  ---------
//  For simplicity, we restrict the number of ARP Table Entries pointing to
//  this entry to atmost 1 in the multicast case. Also, this entry would be
//  linked to a single VC, of type SVC-PMP-Outgoing.
//
//  Reference Count: we add One to the RefCount for each of the following:
//  - Each VC on its VcList
//  - Each ARP IP Entry that points to it
//  - Each Packet queued on its packet list
//  - For the duration another structure (e.g. ARP Server Entry) points to it
//

typedef enum 
{
	AE_REFTYPE_TMP,
	AE_REFTYPE_MCAE,
	AE_REFTYPE_IE,
	AE_REFTYPE_VC,
	AE_REFTYPE_IF,
	AE_REFTYPE_COUNT	// Must be last

} AE_REFTYPE;

typedef struct _ATMARP_ATM_ENTRY
{
#if DBG
	ULONG							aae_sig;		// Signature for debugging
#endif
	struct _ATMARP_ATM_ENTRY *		pNext;			// Next Entry on this Interface
	ULONG							RefCount;		// References to this struct
	ULONG							Flags;			// State and Type information
	ATMARP_LOCK						Lock;
	struct _ATMARP_INTERFACE *		pInterface;		// Back pointer
	struct _ATMARP_VC *				pVcList;		// List of VCs to this ATM address
	struct _ATMARP_VC *				pBestEffortVc;	// One of the Best Effort VCs here
	struct _ATMARP_IP_ENTRY *		pIpEntryList;	// List of IP entries that
													// point to this entry
	//
	//  The following two are used in the case of a unicast destination
	//
	ATM_ADDRESS						ATMAddress;		// "ATM Number" in the RFC
	ATM_ADDRESS						ATMSubaddress;	// Used only if ATMAddress is E.164
#ifdef IPMCAST
	//
	//  If this is a multicast destination, the following points to additional
	//  information.
	//
	struct _ATMARP_IPMC_ATM_INFO *	pMcAtmInfo;		// Additional info for multicast
#endif // IPMCAST

#if DBG
	UCHAR Refs[AE_REFTYPE_COUNT];
#endif //DBG

} ATMARP_ATM_ENTRY, *PATMARP_ATM_ENTRY;

#if DBG
// ATM Address Entry
#define aae_signature	'AAAE'
#endif

//
//  NULL pointer to ATMARP ATM Entry
//
#define NULL_PATMARP_ATM_ENTRY		((PATMARP_ATM_ENTRY)NULL)


//
//  Definitions for Flags in ATMARP ATM ENTRY
//
#define AA_ATM_ENTRY_STATE_MASK		0x00000003
#define AA_ATM_ENTRY_IDLE			0x00000000		// Just created
#define AA_ATM_ENTRY_ACTIVE			0x00000001		// Installed into the database
#define AA_ATM_ENTRY_CLOSING		0x00000002

#define AA_ATM_ENTRY_TYPE_MASK		0x00000010
#define AA_ATM_ENTRY_TYPE_UCAST		0x00000000		// Unicast
#define AA_ATM_ENTRY_TYPE_NUCAST	0x00000010		// Non-unicast



#ifdef IPMCAST

//
//  ---------------------- ATM-PMP Info for an ATM Entry ---------------------
//
//  This contains additional information specific to a multi-point ATM destination,
//  and is attached to an ATM Entry.
//
typedef struct _ATMARP_IPMC_ATM_INFO
{
	ULONG							Flags;			// State info
	struct _ATMARP_IPMC_ATM_ENTRY *	pMcAtmEntryList;// List of ATM endstations (multicast)
	struct _ATMARP_IPMC_ATM_ENTRY *	pMcAtmMigrateList;// List being migrated to
	ULONG							NumOfEntries;	// Size of above list
	ULONG							ActiveLeaves;	// <= NumOfMcEntries
	ULONG							TransientLeaves;// < NumOfMcEntries

} ATMARP_IPMC_ATM_INFO, *PATMARP_IPMC_ATM_INFO;

#define NULL_PATMARP_IPMC_ATM_INFO	((PATMARP_IPMC_ATM_INFO)NULL)

#define AA_IPMC_AI_CONN_STATE_MASK		0x0000000f
#define AA_IPMC_AI_CONN_NONE			0x00000000	// No connection/VC exists
#define AA_IPMC_AI_CONN_WACK_MAKE_CALL	0x00000001	// Outgoing call in progress
#define AA_IPMC_AI_CONN_ACTIVE			0x00000002	// Outgoing PMP call established
#define AA_IPMC_AI_CONN_TEMP_FAILURE	0x00000004	// Transient failure seen on MakeCall

#define AA_IPMC_AI_CONN_UPDATE_MASK		0x000000f0
#define AA_IPMC_AI_NO_UPDATE			0x00000000	// No connection update pending
#define AA_IPMC_AI_WANT_UPDATE			0x00000010	// Connection needs update
#define AA_IPMC_AI_BEING_UPDATED		0x00000020	// Connection is being updated


//
//
//  ---------------------- ATM Entry for a Multicast leaf --------------------
//
//  This contains information about a single element in the list of ATM endstations
//  that a Class D IP Address resolves to. This participates as a leaf in the PMP
//  connection we set up for packets sent to this multicast group.
//
typedef struct _ATMARP_IPMC_ATM_ENTRY
{
#if DBG
	ULONG							ame_sig;		// Signature for debugging
#endif // DBG
	struct _ATMARP_IPMC_ATM_ENTRY *	pNextMcAtmEntry;// Next member of multicast group
	ULONG							Flags;			// State and other info
	NDIS_HANDLE						NdisPartyHandle;// NDIS handle for this leaf
	struct _ATMARP_ATM_ENTRY *		pAtmEntry;		// Back pointer
	ATM_ADDRESS						ATMAddress;		// "ATM Number" in the RFC
	ATM_ADDRESS						ATMSubaddress;	// Used only if ATMAddress is E.164
	ATMARP_TIMER					Timer;			// Used to retry connecting

} ATMARP_IPMC_ATM_ENTRY, *PATMARP_IPMC_ATM_ENTRY;

#if DBG
#define ame_signature	'AAME'
#endif // DBG

//
//  NULL pointer to a Multicast ATM Entry
//
#define NULL_PATMARP_IPMC_ATM_ENTRY	((PATMARP_IPMC_ATM_ENTRY)NULL)

//
//  Definitions for Flags in Multicast ATM Entry
//
#define AA_IPMC_AE_GEN_STATE_MASK		0x0000000f
#define AA_IPMC_AE_VALID				0x00000000	// This leaf is valid
#define AA_IPMC_AE_INVALID				0x00000001	// Will be trimmed unless revalidated
#define AA_IPMC_AE_TERMINATING			0x00000002	// This leaf being terminated

#define AA_IPMC_AE_CONN_STATE_MASK		0x00000ff0
#define AA_IPMC_AE_CONN_DISCONNECTED	0x00000000
#define AA_IPMC_AE_CONN_WACK_ADD_PARTY	0x00000010	// Waiting for AddParty to complete
#define AA_IPMC_AE_CONN_ACTIVE			0x00000020	// Active leaf of PMP connection
#define AA_IPMC_AE_CONN_WACK_DROP_PARTY	0x00000040	// Waiting for DropParty to complete
#define AA_IPMC_AE_CONN_TEMP_FAILURE	0x00000080	// AddParty failed, will try later
#define AA_IPMC_AE_CONN_RCV_DROP_PARTY	0x00000100	// Incoming Drop Party seen


//
//  ----------------- ATMARP IP Multicast Join Entry -----------------
//
//  One of these structures is maintained for each Class D IP address
//  that has been "AddAddress"ed by the IP layer, i.e., each multicast
//  group that we have Joined. This can be considered as the "receive
//  side" data structure for a Class D IP address. We have different
//  structures for the transmit and receive sides of a Multicast group
//  because this host can participate exclusively on one or the other,
//  and the information needed is very different. Transmit side
//  information is maintained in an ATMARP_IP_ENTRY and associated
//  structures.
//
typedef struct _ATMARP_IPMC_JOIN_ENTRY
{
#if DBG
	ULONG							aamj_sig;
#endif // DBG
	struct _ATMARP_IPMC_JOIN_ENTRY *pNextJoinEntry;	// Next IP Address Joined on this IF
	ULONG							Flags;			// State info (see below)
	ULONG							RefCount;
	ULONG							JoinRefCount;	// # of AddAddress - # of DelAddress
	struct _ATMARP_INTERFACE *		pInterface;		// Back pointer
	IP_ADDRESS						IPAddress;		// Class D IP address we've joined
	IP_MASK							Mask;			// Defines range of this join entry.
	ATMARP_TIMER					Timer;			// Waiting for Join/Leave completion
	ULONG							RetriesLeft;	// For Joining/Leaving
#if DBG
	ULONG							LastIncrRef;	// For debugging
	ULONG							LastDecrRef;
#endif

} ATMARP_IPMC_JOIN_ENTRY, *PATMARP_IPMC_JOIN_ENTRY;

#if DBG
#define aamj_signature	'AAMJ'
#endif // DBG
//
//  NULL pointer to IPMC Join Entry
//
#define NULL_PATMARP_IPMC_JOIN_ENTRY	((PATMARP_IPMC_JOIN_ENTRY)NULL)


//
//  Definitions for Flags in a Join Entry
//
#define AA_IPMC_JE_STATE_MASK		0x000000FF
#define AA_IPMC_JE_STATE_UNUSED		0x00000000
#define AA_IPMC_JE_STATE_PENDING	0x00000001	// Waiting for a CMI to be assigned to us
#define AA_IPMC_JE_STATE_JOINING	0x00000002	// Have sent MARS_JOIN
#define AA_IPMC_JE_STATE_JOINED		0x00000004	// Seen copy of MARS_JOIN (== ack)
#define AA_IPMC_JE_STATE_LEAVING	0x00000008	// Have sent MARS_LEAVE

#endif // IPMCAST



//
//  ---------------------------- ARP Table (IP) Entry ------------------------
//
//  Contains information about one remote IP address.
//
//  There is atmost one ARP Table entry for a given IP address.
//
//  The IP Entry participates in two lists:
//  (1) A list of all entries that hash to the same bucket in the ARP Table
//  (2) A list of all entries that resolve to the same ATM Address -- this
//      is only if the IP address is unicast.
//
//  A pointer to this structure is also used as our context value in the
//  Route Cache Entry prepared by the higher layer protocol(s).
//
//  Reference Count: We add one to its ref count for each of the following:
//	 - Each Route Cache entry that points to this entry
//   - For the duration an active timer exists on this Entry
//   - For the duration the entry belongs to the list of IP entries linked
//     to an ATM Entry.
//

typedef enum 
{
	IE_REFTYPE_TMP,
	IE_REFTYPE_RCE,
	IE_REFTYPE_TIMER,
	IE_REFTYPE_AE,
	IE_REFTYPE_TABLE,
	IE_REFTYPE_COUNT	// Must be last

} IE_REFTYPE;

typedef struct _ATMARP_IP_ENTRY
{
#if DBG
	ULONG							aip_sig;		// Signature for debugging
#endif
	IP_ADDRESS						IPAddress;		// IP Address
	struct _ATMARP_IP_ENTRY *		pNextEntry;		// Next in hash list
	struct _ATMARP_IP_ENTRY *		pNextToAtm;		// List of entries pointing to
													// the same ATM Entry
	ULONG							Flags;			// State and Type information
	ULONG							RefCount;		// References to this struct
	ATMARP_LOCK						Lock;
	struct _ATMARP_INTERFACE *		pInterface;		// Back pointer
	PATMARP_ATM_ENTRY				pAtmEntry;		// Pointer to all ATM info
#ifdef IPMCAST
	struct _ATMARP_IP_ENTRY *		pNextMcEntry;	// Next "higher" Multicast IP Entry
	USHORT							NextMultiSeq;	// Sequence Number expected
													// in the next MULTI
	USHORT							Filler;
#endif // IPMCAST
	ATMARP_TIMER					Timer;			// Timers are: (all exclusive)
													// - Aging timer
													// - Waiting for ARP reply
													// - Waiting for InARP reply
													// - Delay after NAK
													// - Waiting for MARS MULTI
													// - Delay before marking for reval
	ULONG							RetriesLeft;
	PNDIS_PACKET					PacketList;		// List of packets waiting to be sent

	RouteCacheEntry *				pRCEList;		// List of Route Cache Entries
													// associated with this entry.
#ifdef CUBDD
	SINGLE_LIST_ENTRY				PendingIrpList;	// List of IRP's waiting for
													// this IP address to be resolved.
#endif // CUBDD

#if DBG
	UCHAR Refs[IE_REFTYPE_COUNT];
#endif // DBG

} ATMARP_IP_ENTRY, *PATMARP_IP_ENTRY;

#if DBG
// ATM ARP IP Entry
#define aip_signature	'AAIP'
#endif

//
//  NULL pointer to ATMARP IP Entry
//
#define NULL_PATMARP_IP_ENTRY		((PATMARP_IP_ENTRY)NULL)


//
//  Definitions for Flags in ATMARP IP ENTRY
//
//  A pre-condition for sending data to a destination governed by a
//  table entry is: (Flags & AA_IP_ENTRY_STATE_MASK) == AA_IP_ENTRY_RESOLVED
//
#define AA_IP_ENTRY_STATE_MASK			0x0000000f
#define AA_IP_ENTRY_IDLE				0x00000000	// Just created/ ok to del
#define AA_IP_ENTRY_IDLE2				0x00000001	// In arp table but unused.
#define AA_IP_ENTRY_ARPING				0x00000002	// Waiting for ARP reply
#define AA_IP_ENTRY_INARPING			0x00000003	// Waiting for InARP reply
#define AA_IP_ENTRY_RESOLVED			0x00000004	// Resolved IP -> ATM Address
#define AA_IP_ENTRY_COMM_ERROR			0x00000005	// Seen abnormal close on attached VC
#define AA_IP_ENTRY_ABORTING			0x00000006	// Abort in progress
#define AA_IP_ENTRY_AGED_OUT			0x00000007	// Has aged out
#define AA_IP_ENTRY_SEEN_NAK			0x00000008	// NAK delay timer started

#ifdef IPMCAST
#define AA_IP_ENTRY_MC_VALIDATE_MASK	0x00000600
#define AA_IP_ENTRY_MC_NO_REVALIDATION	0x00000000	// No revalidation in progress/needed
#define AA_IP_ENTRY_MC_REVALIDATE		0x00000200	// Marked as needing Revalidation
#define AA_IP_ENTRY_MC_REVALIDATING		0x00000400	// Revalidation in progress

#define AA_IP_ENTRY_MC_RESOLVE_MASK		0x00003800
#define AA_IP_ENTRY_MC_IDLE				0x00000000
#define AA_IP_ENTRY_MC_AWAIT_MULTI		0x00000800	// Awaiting more MARS_MULTI replies
#define AA_IP_ENTRY_MC_DISCARDING_MULTI	0x00001000	// Discard mode because of error
#define AA_IP_ENTRY_MC_RESOLVED			0x00002000	// All MARS_MULTIs received

#define AA_IP_ENTRY_ADDR_TYPE_MASK		0x00004000
#define AA_IP_ENTRY_ADDR_TYPE_UCAST		0x00000000	// Unicast
#define AA_IP_ENTRY_ADDR_TYPE_NUCAST	0x00004000	// Non-unicast (e.g. Class D)
#endif // IPMCAST

#define AA_IP_ENTRY_TYPE_MASK			0x20000000
#define AA_IP_ENTRY_IS_STATIC			0x20000000	// Static entry (no aging on this)


#define ATMARP_TABLE_SIZE			127





//
//  --------------------- ATMARP Virtual Circuit (VC) ---------------------
//
//  One of these is used for each call terminated at the IP/ATM client.
//  Creation and deletion of this structure is linked to NdisCoCreateVc and
//  NdisCoDeleteVc.
//
//  An ATMARP_VC structure becomes linked to an ATMARP_ATM_ENTRY when (and only
//  when) we determine the ATM address(es) of the remote ATM endstation.
//  For outgoing calls, we would have determined this before making the call,
//  and for incoming calls, we learn this either through the Calling Address
//  (for SVCs) or via InATMARP (for PVCs). "Incoming" PVCs are kept in the
//  "Unresolved VC" list in the Interface structure, until the ATM address
//  of the other end is resolved.
//
//  The FilterSpec and FlowSpec hooks are for support of multiple VCs of
//  varying QoS between (possibly the same pair of) IP stations. Only IP
//  packets that match the FilterSpec will be transmitted on this VC.
//
//  Reference Count: we add One to the RefCount for each of the following:
//  - For the duration this VC is linked to an ATM entry (or Unresolved VC list)
//  - For the duration this VC is an NDIS VC (not DeleteVc'ed)
//  - For the duration a call exists (in progress/active) on this VC
//	- For the duration an active timer exists on this VC
//

typedef struct _ATMARP_VC
{
#if DBG
	ULONG							avc_sig;
#endif
	struct _ATMARP_VC *				pNextVc;		// Next VC in list
	ULONG							RefCount;		// References to this struct
	ULONG							Flags;			// State and Type information
	ULONG							OutstandingSends;// Sent packets awaiting completion
	ATMARP_LOCK						Lock;
	NDIS_HANDLE						NdisVcHandle;	// For NDIS calls
	struct _ATMARP_INTERFACE *		pInterface;		// Back pointer to ARP Interface
	PATMARP_ATM_ENTRY				pAtmEntry;		// Back pointer to ATM Entry
	PNDIS_PACKET					PacketList;		// List of packets waiting to be sent
	ATMARP_TIMER					Timer;			// VC Timers are (exclusive):
													// - Waiting for InARP reply
													// - Aging
	ULONG							RetriesLeft;	// In case the timer runs out
#ifdef GPC
	PVOID							FlowHandle;		// Points to Flow Info struct
#endif // GPC
	ATMARP_FILTER_SPEC				FilterSpec;		// Filter Spec (Protocol, port)
	ATMARP_FLOW_SPEC				FlowSpec;		// Flow Spec (QoS etc) for this conn

} ATMARP_VC, *PATMARP_VC;

#if DBG
// ATM ARP VC
#define avc_signature	'AAVC'
#endif

//
//  NULL pointer to ATMARP VC
//
#define NULL_PATMARP_VC		((PATMARP_VC)NULL)

//
//  Definitions for ATMARP VC flags. The following information is kept
//  here:
//		- Is this VC an SVC or PVC
//  	- Is this created (owned) by the ATMARP module or the Call Manager
//  	- Call State: Incoming in progress, Outgoing in progress, Active,
//    	  Close in progress, or Idle
//

//  Bits 0 and 1 for "Type"
#define AA_VC_TYPE_MASK								0x00000003
#define AA_VC_TYPE_UNUSED							0x00000000
#define AA_VC_TYPE_SVC								0x00000001
#define AA_VC_TYPE_PVC								0x00000002

//  Bits 2 and 3 for "Owner"
#define AA_VC_OWNER_MASK							0x0000000C
#define AA_VC_OWNER_IS_UNKNOWN						0x00000000
#define AA_VC_OWNER_IS_ATMARP						0x00000004	// NdisClCreateVc done
#define AA_VC_OWNER_IS_CALLMGR						0x00000008	// CreateVcHandler done

// Bits 4, 5, 6, 7 for Call State
#define AA_VC_CALL_STATE_MASK						0x000000F0
#define AA_VC_CALL_STATE_IDLE						0x00000000
#define AA_VC_CALL_STATE_INCOMING_IN_PROGRESS		0x00000010	// Wait for CallConnected
#define AA_VC_CALL_STATE_OUTGOING_IN_PROGRESS		0x00000020	// Wait for MakeCallCmpl
#define AA_VC_CALL_STATE_ACTIVE						0x00000040
#define AA_VC_CALL_STATE_CLOSE_IN_PROGRESS			0x00000080	// Wait for CloseCallCmpl

// Bit 8 for Aging
#define AA_VC_AGING_MASK							0x00000100
#define AA_VC_NOT_AGED_OUT							0x00000000
#define AA_VC_AGED_OUT								0x00000100

// Bit 9 to indicate whether an abnormal Close has happened
#define AA_VC_CLOSE_TYPE_MASK						0x00000200
#define AA_VC_CLOSE_NORMAL							0x00000000
#define AA_VC_CLOSE_ABNORMAL						0x00000200

// Bits 10 and 11 to indicate any ARP operation in progress
#define AA_VC_ARP_STATE_MASK						0x00000C00
#define AA_VC_ARP_STATE_IDLE						0x00000000
#define AA_VC_INARP_IN_PROGRESS						0x00000400

// Bits 12 and 13 to indicate whether we are closing this VC, or if we need to
#define AA_VC_CLOSE_STATE_MASK						0x00003000
#define AA_VC_CLOSE_STATE_CLOSING					0x00001000

// Bit 14 to indicate VC Connection type (point to point or point to
// multi-point)
#define AA_VC_CONN_TYPE_MASK						0x00004000
#define AA_VC_CONN_TYPE_P2P							0x00000000	// Point to Point
#define AA_VC_CONN_TYPE_PMP							0x00004000	// Point to Multipoint

// Bit 15 to indicate if this VC has been unlinked from a GPC QOS CFINFO
#define AA_VC_GPC_MASK								0x00008000
#define AA_VC_GPC_IS_UNLINKED_FROM_FLOW				0x00008000


//
//  ---- ATMARP Buffer Tracker ----
//
//  Keeps track of allocation information for a pool of buffers. A list
//  of these structures is used to maintain info about a dynamically
//  growable pool of buffers (e.g. for ARP header buffers)
//

typedef struct _ATMARP_BUFFER_TRACKER
{
	struct _ATMARP_BUFFER_TRACKER *	pNext;		// in a list of trackers
	NDIS_HANDLE						NdisHandle;	// for Buffer Pool
	PUCHAR							pPoolStart;	// start of memory chunk allocated
												// from the system
} ATMARP_BUFFER_TRACKER, *PATMARP_BUFFER_TRACKER;

//
//  NULL pointer to ATMARP Buffer tracker structure
//
#define NULL_PATMARP_BUFFER_TRACKER	((PATMARP_BUFFER_TRACKER)NULL)


//
//  ---- ATMARP Header Pool -----
//
//  Keeps track of allocation information for a pool of Header buffers.
//  Header buffers are used to tack on LLC/SNAP headers to transmitted
//  IP packets. Each Header pool contains a number of fixed-size buffers.
//  We use one header pool for IP Unicast headers, and one for IP Multicast
//  headers.
//
typedef struct _ATMARP_HEADER_POOL
{
	SLIST_HEADER				HeaderBufList;		// Free list of header buffers
	ULONG						HeaderBufSize;		// Size of each header buffer
	ULONG						MaxHeaderBufs;		// Max header buffers we can allocate
	ULONG						CurHeaderBufs;		// Current header buffers allocated
	PATMARP_BUFFER_TRACKER		pHeaderTrkList;		// Info about allocated header buffers

} ATMARP_HEADER_POOL, *PATMARP_HEADER_POOL;

#define NULL_PATMARP_HEADER_POOL	((PATMARP_HEADER_POOL)NULL)


//
//  Packet header types.
//
//  IMPORTANT: Keep _MAX and _NONE at the end of this list!
//
typedef enum
{
	AA_HEADER_TYPE_UNICAST,
	AA_HEADER_TYPE_NUNICAST,
	AA_HEADER_TYPE_MAX,
	AA_HEADER_TYPE_NONE

} AA_HEADER_TYPE;


//
//  ------------------------ ATMARP SAP --------------------------------
//
//  Each of these structures maintains information about a SAP attached
//  to an LIS. Normally the ATMARP client would register just one SAP
//  with the Call manager, with BLLI fields set so that all IP/ATM calls
//  are directed to this client. However, we may support services (e.g.
//  DHCP) over IP/ATM that are assigned well-known ATM addresses, i.e.
//  addresses other than the one registered with the switch. These form
//  additional SAPs we register with the Call Manager. In addition to
//  registering these addresses as SAPs, we also request the Call Manager
//  to register them via ILMI with the switch, so that the network
//  directs calls to these addresses to us.
//
typedef struct _ATMARP_SAP
{
#if DBG
	ULONG							aas_sig;
#endif
	struct _ATMARP_SAP *			pNextSap;	// in list of SAPs
	struct _ATMARP_INTERFACE *		pInterface;	// back pointer
	NDIS_HANDLE						NdisSapHandle;
	ULONG							Flags;		// state information
	PCO_SAP							pInfo;		// SAP characteristics.

} ATMARP_SAP, *PATMARP_SAP;

#if DBG
#define aas_signature			'AAS '
#endif // DBG

//
//  NULL pointer to ATMARP SAP
//
#define NULL_PATMARP_SAP			((PATMARP_SAP)NULL)

//
//  Definitions for Flags in ATMARP SAP
//
//
//  Bits 0 to 3 contain the SAP-registration state.
//
#define AA_SAP_REG_STATE_MASK					0x0000000f
#define AA_SAP_REG_STATE_IDLE					0x00000000
#define AA_SAP_REG_STATE_REGISTERING			0x00000001		// Sent RegisterSap
#define AA_SAP_REG_STATE_REGISTERED				0x00000002		// RegisterSap completed
#define AA_SAP_REG_STATE_DEREGISTERING			0x00000004		// Sent DeregisterSap
//
//  Bits 4 to 7 contain the ILMI-registration state.
//
#define AA_SAP_ILMI_STATE_MASK					0x000000f0
#define AA_SAP_ILMI_STATE_IDLE					0x00000000
#define AA_SAP_ILMI_STATE_ADDING				0x00000010		// Sent ADD_ADDRESS
#define AA_SAP_ILMI_STATE_ADDED					0x00000020		// ADD_ADDRESS completed
#define AA_SAP_ILMI_STATE_DELETING				0x00000040		// Sent DELETE_ADDRESS

//
//  Bit 8 tells us whether this Address should be "ADDED" to the Call Manager,
//  i.e. ILMI-registered with the switch.
//
#define AA_SAP_ADDRTYPE_MASK					0x00000100
#define AA_SAP_ADDRTYPE_BUILT_IN				0x00000000
#define AA_SAP_ADDRTYPE_NEED_ADD				0x00000100




//
//  ------------------------ ATMARP Interface ------------------------
//
//  One of these structures is maintained for each LIS that this system is
//  a member of.
//
//  The Interface structure has the following sections:
//
//		Adapter		  -	Information pertaining to the ATM miniport to which
//						this LIS is bound
//		Buffer Mgmt	  -	NDIS Packet pool, NDIS Buffer pool, and two types of
//						buffers: Header buffers (LLC/SNAP) and Protocol buffers
//						(for ARP/InARP packets)
//		IP 			  -	Information related to the IP layer (context, IP addr lists)
//		Client		  -	Information relating to IP/ATM client operation
//
//  Reference Count: we add One to the interface RefCount for each of:
//  - Adapter reference (between NdisOpenAdapter and NdisCloseAdapter-Complete)
//  - Call Manager reference (between OpenAf and CloseAf-Complete)
//  - Each new ATMARP Table entry in the ARP Table
//  - An active Interface timer
//

typedef struct _ATMARP_INTERFACE
{
#if DBG
	ULONG						aai_sig;			// Signature
#endif
	struct _ATMARP_INTERFACE *	pNextInterface;		// in list of ATMARP interfaces
	ATMARP_LOCK					InterfaceLock;		// Mutex for Interface structure
	ATMARP_BLOCK				Block;				// For blocking calling thread
	ULONG						RefCount;			// References to this interface
	ULONG						AdminState;			// Desired state of this interface
	ULONG						State;				// (Actual) State of this interface
    enum
    {
        RECONFIG_NOT_IN_PROGRESS,
        RECONFIG_SHUTDOWN_PENDING,
        RECONFIG_RESTART_QUEUED,
        RECONFIG_RESTART_PENDING

    }                           ReconfigState;
	PNET_PNP_EVENT			    pReconfigEvent;     // Our own PnP event pending
                                                    // completion.

	ULONG						Flags;				// Misc state information
	ULONG						LastChangeTime;		// Time of last state change
	ULONG						MTU;				// Max Transmision Unit (bytes)
	ULONG						Speed;				// That we report to IP


	//
	//  ----- Adapter related ----
	//  More than one ATMARP interface could be associated with
	//  a single adapter.
	//
#if DBG
	ULONG						aaim_sig;			// Signature to help debugging
#endif
	struct _ATMARP_ADAPTER *	pAdapter;			// Pointer to Adapter info
	NDIS_HANDLE					NdisAdapterHandle;	// to Adapter
	NDIS_HANDLE					NdisAfHandle;		// AF handle to Call Manager
	NDIS_HANDLE					NdisSapHandle;		// SAP handle to Call Manager
	PCO_SAP						pSap;				// SAP info for this interface
	ULONG						SapSelector;		// SEL byte for this interface's SAP

	ATMARP_SAP					SapList;			// Each SAP registered with CallMgr
	ULONG						NumberOfSaps;		// Size of above list (> 1)

	//
	//  ----- Buffer Management: Header buffers and Protocol buffers ----
	//
	NDIS_SPIN_LOCK				BufferLock;			// Mutex for buffers
#if 1
	ATMARP_HEADER_POOL			HeaderPool[AA_HEADER_TYPE_MAX];
#else
	SLIST_HEADER				HeaderBufList;		// Free list of header buffers
	ULONG						HeaderBufSize;		// Size of each header buffer
	ULONG						MaxHeaderBufs;		// Max header buffers we can allocate
	ULONG						CurHeaderBufs;		// Current header buffers allocated
	PATMARP_BUFFER_TRACKER		pHeaderTrkList;		// Info about allocated header buffers
#endif // 1 ( IPMCAST )
	NDIS_HANDLE					ProtocolPacketPool;	// Handle for Packet pool
	NDIS_HANDLE					ProtocolBufferPool;	// Handle for Buffer pool
	PUCHAR						ProtocolBufList;	// Free list of protocol buffers (for
													// ARP packets)
	PUCHAR						ProtocolBufTracker;	// Start of chunk of memory used for
													// the above.
	ULONG						ProtocolBufSize;	// Size of each protocol buffer
	ULONG						MaxProtocolBufs;	// Number of protocol buffers

	//
	//  ----- IP/ARP interface related ----
	//
#if DBG
	ULONG						aaia_sig;			// Signature to help debugging
#endif
	PVOID						IPContext;			// Use in calls to IP
	IP_ADDRESS_ENTRY			LocalIPAddress;		// List of local IP addresses. There
													// should be atleast one.
	ULONG						NumOfIPAddresses;	// Size of above list.
	PPROXY_ARP_ENTRY			pProxyList;			// List of proxy addresses
	IP_ADDRESS					BroadcastAddress;	// IP Broadcast address for this IF
	IP_ADDRESS					BroadcastMask;		// Broadcast Mask for this interface
	IPRcvRtn					IPRcvHandler;		// Indicate Receive
	IPTxCmpltRtn				IPTxCmpltHandler;	// Transmit Complete
	IPStatusRtn					IPStatusHandler;
	IPTDCmpltRtn				IPTDCmpltHandler;	// Transfer Data Complete
	IPRcvCmpltRtn				IPRcvCmpltHandler;	// Receive Complete
#ifdef _PNP_POWER_
	IPRcvPktRtn					IPRcvPktHandler;	// Indicate Receive Packet
	IP_PNP						IPPnPEventHandler;
#endif // _PNP_POWER_
	UINT						ATInstance;			// Instance # for this AT Entity
	UINT						IFInstance;			// Instance # for this IF Entity
	NDIS_STRING					IPConfigString;		// Config info for IP for this LIS
#ifdef PROMIS
	NDIS_OID					EnabledIPFilters; // Set of enabled oids -- 
													// set/cleared using 
													//  AtmArpIfSetNdisRequest.

#endif // PROMIS

	//
	//  ----- IP/ATM operation related ----
	//
#if DBG
	ULONG						aait_sig;			// Signature to help debugging
#endif
	PATMARP_IP_ENTRY *			pArpTable;			// The ARP table
	ULONG						NumOfArpEntries;	// Entries in the above
	ATMARP_LOCK					ArpTableLock;		// Mutex for ARP Table
	BOOLEAN						ArpTableUp;			// Status for arp table.

	ATMARP_SERVER_LIST			ArpServerList;		// List of ARP servers
	PATMARP_SERVER_ENTRY		pCurrentServer;		// ARP server in use
	PATMARP_VC					pUnresolvedVcs;		// VCs whose ATM addrs aren't resolved
	PATMARP_ATM_ENTRY			pAtmEntryList;		// List of all ATM Entries
	ATMARP_LOCK					AtmEntryListLock;	// Mutex for above list
	BOOLEAN						AtmEntryListUp;		// Status of atm entry list.

	ULONG						PVCOnly;			// Only PVCs on this interface
	ULONG						AtmInterfaceUp;		// The ATM interface is considered
													// "up" after ILMI addr regn is over
	ATM_ADDRESS					LocalAtmAddress;	// Our ATM (HW) Address

	ATMARP_TIMER				Timer;				// Interface timers are: (exclusive)
													// - Server Connect Interval
													// - Server Registration
													// - Server Refresh
	ULONG						RetriesLeft;		// For above timer

	//
	//  All timeout values are stored in terms of seconds.
	//
	ULONG						ServerConnectInterval;		// 3 to 60 seconds
	ULONG						ServerRegistrationTimeout;	// 1 to 60 seconds
	ULONG						AddressResolutionTimeout;	// 1 to 60 seconds
	ULONG						ARPEntryAgingTimeout;		// 1 to 15 minutes
	ULONG						VCAgingTimeout;				// 1 to 15 minutes
	ULONG						InARPWaitTimeout;			// 1 to 60 seconds
	ULONG						ServerRefreshTimeout;		// 1 to 15 minutes
	ULONG						MinWaitAfterNak;			// 1 to 60 seconds
	ULONG						MaxRegistrationAttempts;	// 0 means infinity
	ULONG						MaxResolutionAttempts;		// 0 means infinity
	ATMARP_TIMER_LIST			TimerList[AAT_CLASS_MAX];
	ATMARP_LOCK					TimerLock;			// Mutex for timer structures

#ifdef IPMCAST
	//
	//  ---- IP Multicast over ATM stuff ----
	//
#if DBG
	ULONG						aaic_sig;			// Signature for debugging
#endif // DBG
	ULONG						IpMcState;			// State of IP Multicast/ATM
	ULONG						HostSeqNumber;		// Latest # seen on ClusterControlVc
	USHORT						ClusterMemberId;	// ID Assigned to us by MARS
	PATMARP_IPMC_JOIN_ENTRY		pJoinList;			// List of MC groups we have Joined
	PATMARP_IP_ENTRY			pMcSendList;		// Sorted list of MC groups we send to
	ATMARP_SERVER_LIST			MARSList;			// List of MARS (servers)
	PATMARP_SERVER_ENTRY		pCurrentMARS;		// MARS in use

	ATMARP_TIMER				McTimer;			// Interface timers for Multicast:
													// - MARS Connect Interval
													// - MARS Registration
													// - MARS Refresh
	ULONG						McRetriesLeft;		// For above timer
	//
	//  All timeout values are stored in terms of seconds.
	//
	ULONG						MARSConnectInterval;
	ULONG						MARSRegistrationTimeout;
	ULONG						MARSKeepAliveTimeout;
	ULONG						JoinTimeout;
	ULONG						LeaveTimeout;
	ULONG						MulticastEntryAgingTimeout;
	ULONG						MaxDelayBetweenMULTIs;
	ULONG						MinRevalidationDelay;
	ULONG						MaxRevalidationDelay;
	ULONG						MinPartyRetryDelay;
	ULONG						MaxPartyRetryDelay;
	ULONG						MaxJoinOrLeaveAttempts;
	

#endif // IPMCAST

	//
	//  ---- QoS stuff ----
	//
	PAA_GET_PACKET_SPEC_FUNC	pGetPacketSpecFunc;	// Routine to extract packet specs
	PAA_FILTER_SPEC_MATCH_FUNC	pFilterMatchFunc;	// Routine to match filter specs
	PAA_FLOW_SPEC_MATCH_FUNC	pFlowMatchFunc;		// Routine to match flow specs
	ATMARP_FLOW_SPEC			DefaultFlowSpec;	// The default flow specs for all
													// (best effort) calls on this IF
	ATMARP_FILTER_SPEC			DefaultFilterSpec;	// The default filter specs for all
													// (best effort) packets
	PATMARP_FLOW_INFO			pFlowInfoList;		// List of configured flows

#ifdef DHCP_OVER_ATM
	BOOLEAN						DhcpEnabled;
	ATM_ADDRESS					DhcpServerAddress;
	PATMARP_ATM_ENTRY			pDhcpServerAtmEntry;
#endif // DHCP_OVER_ATM

	//
	//  ---- MIB objects: counters, descriptions etc ---
	//
#if DBG
	ULONG						aaio_sig;			// Signature to help debugging
#endif
	ULONG						IFIndex;			// Interface number
	ULONG						InOctets;			// Input octets
	ULONG						InUnicastPkts;		// Input Unicast packets
	ULONG						InNonUnicastPkts;	// Input Non-unicast packets
	ULONG						OutOctets;			// Output octets
	ULONG						OutUnicastPkts;		// Output Unicast packets
	ULONG						OutNonUnicastPkts;	// Output Non-unicast packets
	ULONG						InDiscards;
	ULONG						InErrors;
	ULONG						UnknownProtos;
	ULONG						OutDiscards;
	ULONG						OutErrors;

	//
	//  ---- WMI Information ---
	//
#if ATMARP_WMI
#if DBG
	ULONG						aaiw_sig;			// Signature to help debugging
#endif
	struct _ATMARP_IF_WMI_INFO *pIfWmiInfo;
	ATMARP_LOCK					WmiLock;
#endif

} ATMARP_INTERFACE, *PATMARP_INTERFACE;

#if DBG
// ATM ARP Interface:
#define aai_signature	'AAIF'

//  Sections within the ATM ARP Interface:
#define aaim_signature	'AAIM'
#define aaia_signature	'AAIA'
#define aait_signature	'AAIT'
#define aaio_signature	'AAIO'
#define aaic_signature	'AAIC'
#define aaiw_signature	'AAIW'
#endif

//
//  NULL Pointer to ATMARP Interface
//
#define NULL_PATMARP_INTERFACE	((PATMARP_INTERFACE)NULL)

//
//  Definitions for Interface Flags: the following information is kept
//  here:
//		- ARP Server registration state
//		- MARS registration state
//

#define AA_IF_SERVER_STATE_MASK				((ULONG)0x00000003)
#define AA_IF_SERVER_NO_CONTACT				((ULONG)0x00000000)
#define AA_IF_SERVER_REGISTERING			((ULONG)0x00000001)
#define AA_IF_SERVER_REGISTERED				((ULONG)0x00000002)

#ifdef IPMCAST
#define AAMC_IF_STATE_MASK					((ULONG)0x00000F00)
#define AAMC_IF_STATE_NOT_REGISTERED		((ULONG)0x00000000)
#define AAMC_IF_STATE_REGISTERING			((ULONG)0x00000100)
#define AAMC_IF_STATE_REGISTERED			((ULONG)0x00000200)
#define AAMC_IF_STATE_DELAY_B4_REGISTERING	((ULONG)0x00000400)

#define AAMC_IF_MARS_FAILURE_MASK			((ULONG)0x0000F000)
#define AAMC_IF_MARS_FAILURE_NONE			((ULONG)0x00000000)
#define AAMC_IF_MARS_FAILURE_FIRST_RESP		((ULONG)0x00001000)
#define AAMC_IF_MARS_FAILURE_SECOND_RESP	((ULONG)0x00002000)
#endif // IPMCAST



//
//  ---- ATMARP Adapter Information ----
//
//  One of these structures is used to maintain information about
//  each adapter to which the ATMARP module is bound. One or more
//  ATMARP Interface structures point to this structure, and the
//  reference count reflects that.
//
typedef struct _ATMARP_ADAPTER
{
#if DBG
	ULONG						aaa_sig;			// signature for debugging
#endif
	struct _ATMARP_ADAPTER *	pNextAdapter;		// Next adapter on this system
	PATMARP_INTERFACE			pInterfaceList;		// List of ATMARP IF's on this adapter
	ULONG						InterfaceCount;		// Size of above list
	NDIS_HANDLE					NdisAdapterHandle;	// From NdisOpenAdapter
	NDIS_HANDLE					BindContext;		// BindContext to our Bind handler
	NDIS_HANDLE					SystemSpecific1;	// SystemSpecific1 to our Bind handler
	NDIS_HANDLE					SystemSpecific2;	// SystemSpecific2 to our Bind handler
	NDIS_STRING				    IPConfigString;	    // Points to multi-sz, one string
													// per logical interface (LIS)
	NDIS_HANDLE					UnbindContext;		// Passed to our Unbind handler
	NDIS_MEDIUM					Medium;				// Should be NdisMediumAtm
	ULONG						Flags;				// State information
	NDIS_CO_LINK_SPEED			LineRate;			// Supported by adapter
	ULONG						MaxPacketSize;		// Supported by adapter
	UCHAR						MacAddress[AA_ATM_ESI_LEN];
													// Address burnt into adapter
	ULONG						DescrLength;		// Length of descriptor string, below
	PUCHAR						pDescrString;

	NDIS_STRING					DeviceName;			// Passed to BindAdapter handler
	NDIS_STRING					ConfigString;		// Used for per-adapter registry

	ATMARP_BLOCK				Block;				// For blocking calling thread
	ATMARP_BLOCK				UnbindBlock;		// For blocking UnbindAdapter

#if ATMOFFLOAD
	//
	// Task Offload Information
	//
	struct
	{
		ULONG 					Flags;				// Enabled tasks
		UINT					MaxOffLoadSize;		// Maximum send size supported
		UINT					MinSegmentCount;	// Minimum segments required 
													// to do large sends.
	} Offload;
#endif // ATMOFFLOAD

} ATMARP_ADAPTER, *PATMARP_ADAPTER;

#if DBG
#define aaa_signature	'AAAD'
#endif

//
//  NULL Pointer to ATMARP Adapter
//
#define NULL_PATMARP_ADAPTER	((PATMARP_ADAPTER)NULL)

//
//  Definitions for Adapter Flags: the following information is kept
//  here:
//		- Are we unbinding now?
//		- Are we processing an AF register notify?
//		- Have we initiated NdisCloseAdapter?
//
#define AA_ADAPTER_FLAGS_UNBINDING		0x00000001
#define AA_ADAPTER_FLAGS_PROCESSING_AF	0x00000002
#define AA_ADAPTER_FLAGS_AF_NOTIFIED	0x00000004
#define AA_ADAPTER_FLAGS_CLOSING		0x00000008


	
//
//  ---- ATMARP Global Information ----
//
//  One of these structures is maintained for the entire system.
//

typedef struct _ATMARP_GLOBALS
{
#if DBG
	ULONG						aag_sig;			// signature
#endif
	ATMARP_LOCK					Lock;				// mutex
	NDIS_HANDLE					ProtocolHandle;		// returned by NdisRegisterProtocol
	PVOID						pDriverObject;		// handle to Driver Object for ATMARP
	PVOID						pDeviceObject;		// handle to Device Object for ATMARP

	PATMARP_ADAPTER				pAdapterList;		// list of all adapters bound to us
	ULONG						AdapterCount;		// size of above list
	BOOLEAN						bUnloading;

#ifdef NEWARP
	HANDLE						ARPRegisterHandle;	// From IPRegisterARP
	IP_ADD_INTERFACE			pIPAddInterfaceRtn;	// call into IP to add an interface
	IP_DEL_INTERFACE			pIPDelInterfaceRtn;	// call into IP to delete an interface
	IP_BIND_COMPLETE			pIPBindCompleteRtn;	// call into IP to inform of bind cmpl
#if P2MP
	IP_ADD_LINK 				pIPAddLinkRtn;
	IP_DELETE_LINK 				pIpDeleteLinkRtn;
#endif // P2MP
#else
	IPAddInterfacePtr			pIPAddInterfaceRtn;	// call into IP to add an interface
	IPDelInterfacePtr			pIPDelInterfaceRtn;	// call into IP to delete an interface
#endif // NEWARP

	ATMARP_BLOCK				Block;				// For blocking calling thread

#ifdef GPC
#if DBG
	ULONG						aaq_sig;			// additional signature
#endif
	PATMARP_FLOW_INFO			pFlowInfoList;		// List of configured flows
	GPC_HANDLE					GpcClientHandle;	// From GpcRegisterClient()
	BOOLEAN						bGpcInitialized;	// Did we register successfully?
	GPC_EXPORTED_CALLS			GpcCalls;			// All GPC API entry points
#endif // GPC

} ATMARP_GLOBALS, *PATMARP_GLOBALS;

#if DBG
// ATM ARP Global info
#define aag_signature	'AAGL'
#define aaq_signature	'AAGQ'
#endif

//
//  NULL pointer to ATMARP Globals structure
//
#define NULL_PATMARP_GLOBALS		((PATMARP_GLOBALS)NULL)



//
//  ATMARP module's context info in IP's Route Cache Entry
//
typedef struct _ATMARP_RCE_CONTEXT
{
	RouteCacheEntry *				pNextRCE;		// Next to same IP destination
	ATMARP_IP_ENTRY *				pIpEntry;		// Info about this IP destination

} ATMARP_RCE_CONTEXT, *PATMARP_RCE_CONTEXT;
 
//
//  A NULL pointer to RCE context info
//
#define NULL_PATMARP_RCE_CONTEXT		((PATMARP_RCE_CONTEXT)NULL)


#ifndef AA_MAX
// Private macro
#define AA_MAX(_a, _b)	((_a) > (_b) ? (_a) : (_b))
#endif


//
//  Physical address as reported to IP is the ESI part plus SEL byte.
//
#define AA_ATM_PHYSADDR_LEN				(AA_ATM_ESI_LEN+1)

//
//  Defaults for ATM adapter parameters
//
#define AA_DEF_ATM_LINE_RATE			  (ATM_USER_DATA_RATE_SONET_155*100/8)
#define AA_DEF_ATM_MAX_PACKET_SIZE				 (9188+8)		// Bytes

// Max and min (for ip/atm) permissible max-packet size.
//
#define AA_MAX_ATM_MAX_PACKET_SIZE				    65535		// With AAL5
#define AA_MIN_ATM_MAX_PACKET_SIZE				 AA_DEF_ATM_MAX_PACKET_SIZE

//
//  Defaults for configurable parameters
//
#define AA_DEF_MAX_HEADER_BUFFERS					3000
#define AA_DEF_HDRBUF_GROW_SIZE						  50
#define AA_DEF_MAX_PROTOCOL_BUFFERS					 100
#define AA_MAX_1577_CONTROL_PACKET_SIZE					\
					(AA_ARP_PKT_HEADER_LENGTH +			\
					 (4 * ATM_ADDRESS_LENGTH) +			\
					 (2 * sizeof(IP_ADDRESS)))

#ifdef IPMCAST
#define AA_MAX_2022_CONTROL_PACKET_SIZE					\
			AA_MAX(sizeof(AA_MARS_JOIN_LEAVE_HEADER), sizeof(AA_MARS_REQ_NAK_HEADER)) + \
					(2 * ATM_ADDRESS_LENGTH) +			\
					(2 * sizeof(IP_ADDRESS))

#else
#define AA_MAX_2022_CONTROL_PACKET_SIZE					0
#endif


#define AA_DEF_PROTOCOL_BUFFER_SIZE						\
			AA_MAX(AA_MAX_1577_CONTROL_PACKET_SIZE, AA_MAX_2022_CONTROL_PACKET_SIZE)

#define AA_DEF_PVC_ONLY_VALUE					((ULONG)FALSE)
#define AA_DEF_SELECTOR_VALUE						0x00

#define AA_DEF_SERVER_CONNECT_INTERVAL				   5		// Seconds
#define AA_DEF_SERVER_REGISTRATION_TIMEOUT			   3		// Seconds
#define AA_DEF_ADDRESS_RESOLUTION_TIMEOUT			   3		// Seconds
#define AA_DEF_ARP_ENTRY_AGING_TIMEOUT				 900		// Seconds (15 mins)
#define AA_DEF_VC_AGING_TIMEOUT						  60		// Seconds (1 min)
#define AA_DEF_INARP_WAIT_TIMEOUT					   5		// Seconds
#define AA_DEF_SERVER_REFRESH_INTERVAL				 900		// Seconds (15 mins)
#define AA_DEF_MIN_WAIT_AFTER_NAK				      10		// Seconds
#define AA_DEF_MAX_REGISTRATION_ATTEMPTS			   5
#define AA_DEF_MAX_RESOLUTION_ATTEMPTS				   4

#define AA_DEF_FLOWSPEC_SERVICETYPE		SERVICETYPE_BESTEFFORT
#define AA_DEF_FLOWSPEC_ENCAPSULATION	ENCAPSULATION_TYPE_LLCSNAP

#ifdef IPMCAST
#define AA_DEF_MARS_KEEPALIVE_TIMEOUT			     240		// Seconds (4 mins)
#define AA_DEF_MARS_JOIN_TIMEOUT					  10		// Seconds
#define AA_DEF_MARS_LEAVE_TIMEOUT					  10		// Seconds
#define AA_DEF_MULTI_TIMEOUT						  10		// Seconds
#define AA_DEF_MCAST_IP_ENTRY_AGING_TIMEOUT			1200		// Seconds (20 mins)
#define AA_DEF_MIN_MCAST_REVALIDATION_DELAY			   1		// Seconds
#define AA_DEF_MAX_MCAST_REVALIDATION_DELAY			  10		// Seconds
#define AA_DEF_MIN_MCAST_PARTY_RETRY_DELAY			   5		// Seconds
#define AA_DEF_MAX_MCAST_PARTY_RETRY_DELAY			  10		// Seconds
#define AA_DEF_MAX_JOIN_LEAVE_ATTEMPTS				   5
#endif // IPMCAST

//
//  Structure passed in as context in a QueryInfo for the ARP Table
//
typedef struct IPNMEContext {
	UINT				inc_index;
	PATMARP_IP_ENTRY	inc_entry;
} IPNMEContext;

#endif // __ATMARP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for the ATM/ARP module

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		06-13-96	created based on Call Manager debug.h

Notes:

--*/

#ifndef _AADEBUG__H
#define _AADEBUG__H

//
// Message verbosity: lower values indicate higher urgency
//
#define AAD_EXTRA_LOUD		20
#define AAD_VERY_LOUD		10
#define AAD_LOUD			 8
#define AAD_INFO			 6
#define AAD_WARNING		 	 4
#define AAD_ERROR			 2
#define AAD_FATAL			 0

//
//  Data traffic debug message flags
//
#define AAD_DATA_IN			0x01
#define AAD_DATA_OUT		0x02
#define AAD_TRACK_BIG_SENDS	0x04

#ifdef PERF

typedef struct _AAD_SEND_LOG_ENTRY
{
	ULONG				Flags;
	PNDIS_PACKET		pNdisPacket;
	ULONG				Destination;
	ULONG				Length;
	LARGE_INTEGER		SendTime;
	LARGE_INTEGER		SendCompleteTime;
} AAD_SEND_LOG_ENTRY, *PAAD_SEND_LOG_ENTRY;

#define AAD_SEND_FLAG_UNUSED					0x00000000
#define AAD_SEND_FLAG_WAITING_COMPLETION		0x00000001
#define AAD_SEND_FLAG_COMPLETED					0x00000002
#define AAD_SEND_FLAG_RCE_GIVEN					0x00000100


extern VOID
AadLogSendStart(
	IN	PNDIS_PACKET	pNdisPacket,
	IN	ULONG			Destination,
	IN	PVOID			pRCE
);

extern VOID
AadLogSendUpdate(
	IN	PNDIS_PACKET	pNdisPacket
);

extern VOID
AadLogSendComplete(
	IN	PNDIS_PACKET	pNdisPacket
);

extern VOID
AadLogSendAbort(
	IN	PNDIS_PACKET	pNdisPacket
);

extern LARGE_INTEGER	TimeFrequency;


#endif // PERF

#if DBG_SPIN_LOCK

typedef struct _ATMARP_LOCK
{
	ULONG					Signature;
	ULONG					IsAcquired;
	PKTHREAD				OwnerThread;
	ULONG					TouchedByFileNumber;
	ULONG					TouchedInLineNumber;
	NDIS_SPIN_LOCK			NdisLock;
} ATMARP_LOCK, *PATMARP_LOCK;

#define AAL_SIG	'KCOL'

extern
VOID
AtmArpAllocateSpinLock(
    IN  PATMARP_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
AtmArpAcquireSpinLock(
    IN  PATMARP_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
AtmArpReleaseSpinLock(
    IN  PATMARP_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);


#define CHECK_LOCK_COUNT(Count)		\
			{								\
				if ((INT)(Count) < 0)		\
				{							\
					DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",	\
						Count, __FILE__, __LINE__);		\
					DbgBreakPoint();					\
				}							\
			}
#else
#define CHECK_LOCK_COUNT(Count)

#define ATMARP_LOCK		NDIS_SPIN_LOCK
#define PATMARP_LOCK	PNDIS_SPIN_LOCK

#endif	// DBG_SPIN_LOCK

#if DBG

extern INT	AaDebugLevel;	// the value here defines what the user wants to see
							// all messages with this urgency and higher are enabled
extern INT	AaMcDebugLevel;
extern INT	AaDataDebugLevel;
extern INT	AadBigDataLength;

#define AADEBUGP(lev, stmt)	\
		{ if ((lev) <= AaDebugLevel) { DbgPrint("AtmArpC: "); DbgPrint stmt; }}

#define AADEBUGPDUMP(lev, pBuf, Len)	\
		{ if ((lev) <= AaDebugLevel) { DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len)); }}

#define AADEBUGPATMADDR(lev, pString, pAddr)		\
		{ if ((lev) <= AaDebugLevel) { DbgPrintAtmAddr(pString, pAddr); } }

#define AADEBUGPMAP(lev, pString, pIpAddr, pAtmAddr)		\
		{ if ((lev) <= AaDebugLevel) { DbgPrintMapping(pString, (PUCHAR)pIpAddr, pAtmAddr); } }

#define AAMCDEBUGP(lev, stmt)	\
		{ if ((lev) <= AaMcDebugLevel) { DbgPrint("AtmArpC: "); DbgPrint stmt; }}

#define AAMCDEBUGPDUMP(lev, pBuf, Len)	\
		{ if ((lev) <= AaMcDebugLevel) { DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len)); }}

#define AAMCDEBUGPATMADDR(lev, pString, pAddr)		\
		{ if ((lev) <= AaMcDebugLevel) { DbgPrintAtmAddr(pString, pAddr); } }

#define AAMCDEBUGPMAP(lev, pString, pIpAddr, pAtmAddr)		\
		{ if ((lev) <= AaMcDebugLevel) { DbgPrintMapping(pString, (PUCHAR)pIpAddr, pAtmAddr); } }

#define AA_ASSERT(exp)	\
		{ if (!(exp)) { DbgPrint("ATMARPC: assert " #exp " failed in file %s, line %d\n", __FILE__, __LINE__); DbgBreakPoint(); } }

#define AA_STRUCT_ASSERT(s, t)\
				if ((s)->t##_sig != t##_signature) {\
					DbgPrint("Structure assertion failure for type " #t " in file %s, line %d\n", __FILE__, __LINE__);	\
					DbgBreakPoint();	\
				}

#if DBG_CO_SEND

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			AaCoSendPackets(_VcHandle, _PktArray, _Count)

#else

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			NdisCoSendPackets(_VcHandle, _PktArray, _Count)

#endif // DBG_CO_SEND

extern INT	AaSkipAll;		// Used as an emergency exit mechanism!

//
// Memory Allocation/Freeing Audit:
//

//
// The AAD_ALLOCATION structure stores all info about one allocation
//
typedef struct _AAD_ALLOCATION {

		ULONG					Signature;
		struct _AAD_ALLOCATION	*Next;
		struct _AAD_ALLOCATION *Prev;
		ULONG					FileNumber;
		ULONG					LineNumber;
		ULONG					Size;
		PVOID					Location;	// where the returned pointer was put
		union
		{
			ULONGLONG			Alignment;
			UCHAR				UserData;
		};

} AAD_ALLOCATION, *PAAD_ALLOCATION;

#define AAD_MEMORY_SIGNATURE	(ULONG)'CSII'

extern
PVOID
AaAuditAllocMem (
	PVOID		pPointer,
	ULONG		Size,
	ULONG		FileNumber,
	ULONG		LineNumber
);

extern
VOID
AaAuditFreeMem(
	PVOID		Pointer
);

extern
VOID
AaAuditShutdown(
	VOID
);

extern
VOID
DbgPrintHexDump(
	PUCHAR		pBuffer,
	ULONG		Length
);

extern
VOID
DbgPrintAtmAddr(
	PCHAR			pString,
	ATM_ADDRESS UNALIGNED *	pAddr
);

extern
VOID
DbgPrintMapping(
	PCHAR			pString,
	UCHAR UNALIGNED *	pIpAddr,
	ATM_ADDRESS UNALIGNED *	pAddr
);


extern
VOID
AaCoSendPackets(
	IN	NDIS_HANDLE			NdisVcHandle,
	IN	PNDIS_PACKET *		PacketArray,
	IN	UINT				PacketCount
);

#else
//
// No debug
//
#define AADEBUGP(lev, stmt)
#define AADEBUGPDUMP(lev, pBuf, Len)
#define AADEBUGPATMADDR(lev, pString, pAddr)
#define AADEBUGPMAP(lev, pString, pIpAddr, pAtmAddr)
#define AAMCDEBUGP(lev, stmt)
#define AAMCDEBUGPDUMP(lev, pBuf, Len)
#define AAMCDEBUGPATMADDR(lev, pString, pAddr)
#define AAMCDEBUGPMAP(lev, pString, pIpAddr, pAtmAddr)
#define AA_ASSERT(exp)
#define AA_STRUCT_ASSERT(s, t)

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			NdisCoSendPackets(_VcHandle, _PktArray, _Count)

#endif	// DBG




#if DBG

	#define AA_REF_AE(_pAE, _RefType) \
		AtmArpReferenceAtmEntryEx(_pAE, _RefType)
	
	#define AA_DEREF_AE(_pAE, _RefType) \
		AtmArpDereferenceAtmEntryEx(_pAE, _RefType, TRUE)
	
	#define AA_DEREF_AE_NO_DELETE(_pAE, _RefType) \
		AtmArpDereferenceAtmEntryEx(_pAE, _RefType, FALSE)
	
	#define AA_REF_IE(_pIE, _RefType) \
		AtmArpReferenceIPEntryEx(_pIE, _RefType)
	
	#define AA_DEREF_IE(_pIE, _RefType) \
		AtmArpDereferenceIPEntryEx(_pIE, _RefType, TRUE)
	
	#define AA_DEREF_IE_NO_DELETE(_pIE, _RefType) \
		AtmArpDereferenceIPEntryEx(_pIE, _RefType, FALSE)

	#define AA_SWITCH_IE_REFTYPE(_pIE, _FromRefType, _ToRefType) \
		( AtmArpReferenceIPEntryEx(_pIE, _ToRefType) \
		 ,AtmArpDereferenceIPEntryEx(_pIE, _FromRefType, FALSE))

	#define AA_REF_JE(_pJE)	\
		AtmArpReferenceJoinEntryEx(_pJE, (_FILENUMBER << 16) | __LINE__)
	
	#define AA_DEREF_JE(_pJE)	\
		AtmArpDereferenceJoinEntryEx(_pJE, (_FILENUMBER << 16) | __LINE__)

#else  // !DBG

	#define AA_REF_AE(_pAE, _RefType) \
		AtmArpReferenceAtmEntry(_pAE)
	
	#define AA_DEREF_AE(_pAE, _RefType) \
		AtmArpDereferenceAtmEntry(_pAE)
	
	#define AA_DEREF_AE_NO_DELETE(_pAE, _RefType) \
		((_pAE)->RefCount--)

	#define AA_REF_IE(_pIE, _RefType) \
		AtmArpReferenceIPEntry(_pIE)
	
	#define AA_DEREF_IE(_pIE, _RefType) \
		AtmArpDereferenceIPEntry(_pIE)
	
	#define AA_DEREF_IE_NO_DELETE(_pIE, _RefType) \
		((_pIE)->RefCount--)
	
	#define AA_SWITCH_IE_REFTYPE(_pIE, _FromRefType, _ToRefType) \
			((void)(0))

	#define AA_REF_JE(_pJE)	\
		AtmArpReferenceJoinEntry(_pJE)
	
	#define AA_DEREF_JE(_pJE)	\
		AtmArpDereferenceJoinEntry(_pJE)


#endif // !DBG


#if DBG

#define AA_CHECK_TIMER_IN_ACTIVE_LIST(_pTimer, _pIf, _pStruct, _pName)	\
	AtmArpCheckIfTimerIsInActiveList(									\
		_pTimer,														\
		_pIf,															\
		_pStruct,														\
		_pName															\
		)

#else

#define AA_CHECK_TIMER_IN_ACTIVE_LIST(_pTimer, _pIf, _pStruct, _pName)

#endif // DBG

#endif // _AADEBUG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\externs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	externs.h -- Extern declarations.

Abstract:

	All external declarations for ATMARP client modules (functions,
	variables) are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-09-96    Created

Notes:

--*/

#ifndef _ATMARP_EXTERNS__H
#define _ATMARP_EXTERNS__H

#ifndef EXTERN
#define EXTERN extern
#endif // EXTERN

//
//  --------------- From adapter.c ----------------------------
//



EXTERN
INT
AtmArpBindAdapterHandler(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					BindContext,
	IN	PNDIS_STRING				pDeviceName,
	IN	PVOID						SystemSpecific1,
	IN	PVOID						SystemSpecific2
);

EXTERN
VOID
AtmArpUnbindAdapterHandler(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					UnbindContext
);

EXTERN
VOID
AtmArpCompleteUnbindAdapter(
	IN	PATMARP_ADAPTER				pAdapter
);

EXTERN
VOID
AtmArpOpenAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
);

EXTERN
VOID
AtmArpCloseAdapterCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmArpSendCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmArpTransferDataCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status,
	IN	UINT						BytesTransferred
);

EXTERN
VOID
AtmArpResetCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
);

EXTERN
VOID
AtmArpRequestCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
);

EXTERN
NDIS_STATUS
AtmArpReceiveHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN  NDIS_HANDLE             	MacReceiveContext,
	IN  PVOID                   	pHeaderBuffer,
	IN  UINT                    	HeaderBufferSize,
	IN  PVOID                   	pLookAheadBuffer,
	IN  UINT                    	LookaheadBufferSize,
	IN  UINT                    	PacketSize
);

EXTERN
VOID
AtmArpReceiveCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
);

EXTERN
INT
AtmArpReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmArpStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
);

EXTERN
VOID
AtmArpStatusCompleteHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext
);

EXTERN
VOID
AtmArpCoSendCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
);


EXTERN
VOID
AtmArpCoStatusHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						pStatusBuffer,
	IN	UINT						StatusBufferSize
);

#ifdef _PNP_POWER_
EXTERN
NDIS_STATUS
AtmArpPnPReconfigHandler(
	IN	PATMARP_ADAPTER				pAdapter OPTIONAL,
	IN	PNET_PNP_EVENT				pNetPnPEvent
);

EXTERN
NDIS_STATUS
AtmArpPnPEventHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNET_PNP_EVENT				pNetPnPEvent
);
#endif // _PNP_POWER_

EXTERN
NDIS_STATUS
AtmArpSendAdapterNdisRequest(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);

EXTERN
NDIS_STATUS
AtmArpGetAdapterInfo(
	IN	PATMARP_ADAPTER			pAdapter
);


EXTERN
NDIS_STATUS
AtmArpSendNdisRequest(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);

EXTERN
VOID
AtmArpShutdownInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
BOOLEAN
AtmArpIsDeviceAlreadyBound(
	IN	PNDIS_STRING				pDeviceName
);

#if ATMOFFLOAD

NDIS_STATUS
AtmArpQueryAndEnableOffload(
	IN	PATMARP_ADAPTER				pAdapter
);

VOID
AtmArpDisableOffload(
	IN	PATMARP_ADAPTER				pAdapter
);

#endif // ATMOFFLOAD

//
//  --------------- From arpcfg.c ----------------------------
//


EXTERN
NDIS_STATUS
AtmArpCfgReadAdapterConfiguration(
	IN	PATMARP_ADAPTER				pAdapter
);

EXTERN
NDIS_HANDLE
AtmArpCfgOpenLISConfiguration(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	UINT						LISNumber,
	OUT	PNDIS_STRING				pIPConfigString
);

EXTERN
NDIS_HANDLE
AtmArpCfgOpenLISConfigurationByName(
	IN	PATMARP_ADAPTER				pAdapter,
	IN	PNDIS_STRING				pIPConfigString
);


EXTERN
VOID
AtmArpCfgCloseLISConfiguration(
	NDIS_HANDLE						LISConfigHandle
);

EXTERN
NDIS_STATUS
AtmArpCfgReadLISConfiguration(
	IN	NDIS_HANDLE					LISConfigHandle,
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpCfgReadAtmAddressList(
	IN OUT	PATMARP_SERVER_LIST		pServerList,
	IN		PWCHAR					pListKeyName,
	IN		NDIS_HANDLE				LISConfigHandle
);

EXTERN
NDIS_STATUS
AtmArpCfgReadSAPList(
	IN	PATMARP_INTERFACE			pInterface,
	IN	NDIS_HANDLE					LISConfigHandle
);

EXTERN
NDIS_STATUS
AtmArpCfgReadAtmAddress(
	IN	NDIS_HANDLE					ConfigHandle,
	IN	PATM_ADDRESS				pAtmAddress,
	IN	PWCHAR						pValueName
);

EXTERN
NDIS_STATUS
AtmArpCfgReadQosHeuristics(
	IN	NDIS_HANDLE					LISConfigHandle,
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpCfgReadStaticArpEntries(
	IN		NDIS_HANDLE				LISConfigHandle,
	IN		PATMARP_INTERFACE		pInterface
);

EXTERN
BOOLEAN
AtmArpConvertStringToIPAddress(
    IN		PWCHAR				AddressString,
	OUT		PULONG				IpAddress
);

//
//  --------------- From arpif.c ----------------------------
//

EXTERN IP_MASK  AtmArpIPMaskTable[];


INT
AtmArpIfDynRegister(
	IN	PNDIS_STRING				pAdapterString,
	IN	PVOID						IPContext,
	IN	struct _IP_HANDLERS *		pIpHandlers,
	IN	struct LLIPBindInfo *		pBindInfo,
	IN	UINT						InterfaceNumber
);


EXTERN
VOID
AtmArpIfOpen(
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpIfClose(
	IN	PVOID						Context
);


EXTERN
UINT
AtmArpIfAddAddress(
	IN	PVOID						Context,
	IN	UINT						AddressType,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
#ifndef BUILD_FOR_1381
	,
	IN	PVOID						Context2
#endif // BUILD_FOR_1381
);


EXTERN
UINT
AtmArpIfDelAddress(
	IN	PVOID						Context,
	IN	UINT						AddressType,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
);


NDIS_STATUS
AtmArpIfMultiTransmit(
	IN	PVOID						Context,
	IN	PNDIS_PACKET *				pNdisPacketArray,
	IN	UINT						NumberOfPackets,
	IN	IP_ADDRESS					Destination,
	IN	RouteCacheEntry *			pRCE		OPTIONAL
#if P2MP
	,
	IN  void *                  ArpCtxt
#endif
);


EXTERN
NDIS_STATUS
AtmArpIfTransmit(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	IP_ADDRESS					Destination,
	IN	RouteCacheEntry *			pRCE		OPTIONAL
#if P2MP
	,
	IN  void *                  ArpCtxt
#endif
);

EXTERN
NDIS_STATUS
AtmArpIfTransfer(
	IN	PVOID						Context,
	IN	NDIS_HANDLE					Context1,
	IN	UINT						ArpHdrOffset,
	IN	UINT						ProtoOffset,
	IN	UINT						BytesWanted,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PUINT						pTransferCount
);

EXTERN
VOID
AtmArpIfInvalidate(
	IN	PVOID						Context,
	IN	RouteCacheEntry *			pRCE
);


EXTERN
BOOLEAN
AtmArpUnlinkRCE(
	IN	RouteCacheEntry *			pRCE,
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
VOID
AtmArpLinkRCE(
	IN	RouteCacheEntry *			pRCE,
	IN	PATMARP_IP_ENTRY			pIpEntry	LOCKIN LOCKOUT
);

EXTERN
INT
AtmArpIfQueryInfo(
	IN		PVOID					Context,
	IN		TDIObjectID *			pID,
	IN		PNDIS_BUFFER			pNdisBuffer,
	IN OUT	PUINT					pBufferSize,
	IN		PVOID					QueryContext
);


EXTERN
INT
AtmArpIfSetInfo(
	IN		PVOID					Context,
	IN		TDIObjectID *			pID,
	IN		PVOID					pBuffer,
	IN		UINT					BufferSize
);


EXTERN
INT
AtmArpIfGetEList(
	IN		PVOID					Context,
	IN		TDIEntityID *			pEntityList,
	IN OUT	PUINT					pEntityListSize
);

#ifdef _PNP_POWER_
EXTERN
VOID
AtmArpIfPnPComplete(
	IN	PVOID						Context,
	IN	NDIS_STATUS					Status,
	IN	PNET_PNP_EVENT				pNetPnPEvent
);
#endif // _PNP_POWER_


#ifdef PROMIS
EXTERN
NDIS_STATUS
AtmArpIfSetNdisRequest(
	IN	PVOID						Context,
	IN	NDIS_OID					Oid,
	IN	UINT						On
);
#endif // PROMIS

EXTERN
VOID
AtmArpFreeSendPackets(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				PacketList,
	IN	BOOLEAN						HdrPresent
);

EXTERN
NDIS_STATUS
AtmArpSendBroadcast(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec
);

EXTERN
BOOLEAN
AtmArpIsBroadcastIPAddress(
	IN	IP_ADDRESS					Address,
	IN	PATMARP_INTERFACE			pInterface		LOCKIN LOCKOUT
);

EXTERN
BOOLEAN
AtmArpValidateTableContext(
	IN	PVOID						QueryContext,
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN *					pIsValid
);

EXTERN
BOOLEAN
AtmArpReadNextTableEntry(
	IN	PVOID						QueryContext,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR						pSpace
);

//
//  --------------- From arppkt.c ----------------------------
//

EXTERN
VOID
AtmArpSendPacketOnVc(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
PNDIS_PACKET
AtmArpBuildARPPacket(
	IN	USHORT						OperationType,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR *					ppArpPacket,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);

EXTERN
VOID
AtmArpSendARPRequest(
	PATMARP_INTERFACE				pInterface,
	IP_ADDRESS UNALIGNED *			pSrcIPAddress,
	IP_ADDRESS UNALIGNED *			pDstIPAddress
);

EXTERN
VOID
AtmArpSendInARPRequest(
	IN	PATMARP_VC					pVc
);

EXTERN
UINT
AtmArpCoReceivePacketHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmArpHandleARPPacket(
	IN	PATMARP_VC					pVc,
	IN	PAA_PKT_LLC_SNAP_HEADER		pPktHeader,
	IN	ULONG						PacketLength
);

EXTERN
VOID
AtmArpHandleARPRequest(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);

EXTERN
VOID
AtmArpHandleARPReply(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents,
	IN	BOOLEAN						SrcIPAddressIsOurs,
	IN	BOOLEAN						SrcAtmAddressIsOurs
);

EXTERN
VOID
AtmArpHandleARPNAK(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);

EXTERN
VOID
AtmArpHandleInARPRequest(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);

EXTERN
VOID
AtmArpHandleInARPReply(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PAA_ARP_PKT_HEADER			pArpHeader,
	IN	PAA_ARP_PKT_CONTENTS		pArpContents
);


//
//  --------------- From arpproc.c ----------------------------
//
EXTERN
VOID
AtmArpStartRegistration(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
void
AtmArpRegisterOtherIPAddresses(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpRetryServerRegistration(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpHandleServerRegistrationFailure(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_VC					pVc			OPTIONAL
);

EXTERN
BOOLEAN
AtmArpIsZeroIPAddress(
	IN	UCHAR UNALIGNED *			pIPAddress
);

EXTERN
BOOLEAN
AtmArpIsLocalIPAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	UCHAR UNALIGNED *			pIPAddress
);

EXTERN
BOOLEAN
AtmArpIsLocalAtmAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PUCHAR						pAtmAddrString,
	IN	UCHAR						AtmAddrTypeLen
);

EXTERN
NDIS_STATUS
AtmArpSendPacketOnAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec	OPTIONAL,
	IN	PATMARP_FLOW_INFO			pFlowInfo	OPTIONAL,
	IN	BOOLEAN						IsBroadcast
);

EXTERN
VOID
AtmArpQueuePacketOnVc(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmArpStartSendsOnVc(
	IN	PATMARP_VC					pVc
);

EXTERN
VOID
AtmArpSendPacketListOnAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PNDIS_PACKET				pPacketList,
	IN	BOOLEAN						IsBroadcast
);

EXTERN
PATMARP_IP_ENTRY
AtmArpLearnIPToAtm(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS UNALIGNED *		pIPAddress,
	IN	UCHAR						AtmAddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmAddress,
	IN	UCHAR						AtmSubaddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmSubaddress,
	IN	BOOLEAN						IsStaticEntry
);

EXTERN
NDIS_STATUS
AtmArpQueuePacketOnIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry,
	IN	PNDIS_PACKET				pNdisPacket
);

BOOLEAN
AtmArpAtmEntryIsReallyClosing(
	IN PATMARP_ATM_ENTRY		pAtmEntry
);

EXTERN
PATMARP_ATM_ENTRY
AtmArpSearchForAtmAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	UCHAR						AtmAddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmAddress,
	IN	UCHAR						AtmSubaddressTypeLength,
	IN	UCHAR UNALIGNED *			pAtmSubaddress,
	IN	AE_REFTYPE					RefType,
	IN	BOOLEAN						CreateNew
);

EXTERN
PATMARP_IP_ENTRY
AtmArpSearchForIPAddress(
	IN PATMARP_INTERFACE			pInterface,
	IN IP_ADDRESS UNALIGNED *		pIPAddress,
	IN IE_REFTYPE					RefType,
	IN BOOLEAN						IsBroadcast,
	IN BOOLEAN						CreateNew
);

EXTERN
VOID
AtmArpAbortIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
VOID
AtmArpInvalidateAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ShuttingDown
);

EXTERN
VOID
AtmArpCloseVCsOnAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ShuttingDown
);

EXTERN
VOID
AtmArpResolveIpEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmArpCleanupArpTable(
	IN PATMARP_INTERFACE			pInterface
);

//
//  --------------- from arpwmi.c -----------------------------
//
#ifdef ATMARP_WMI

EXTERN
PATMARP_WMI_GUID
AtmArpWmiFindGuid(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	OUT	PULONG						pGuidDataSize
);

EXTERN
NTSTATUS
AtmArpWmiRegister(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						RegistrationType,
	IN	PWMIREGINFO					pWmiRegInfo,
	IN	ULONG						WmiRegInfoSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiQueryAllData(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	IN	PWNODE_ALL_DATA				pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiQuerySingleInstance(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_INSTANCE		pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiChangeSingleInstance(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_INSTANCE		pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiChangeSingleItem(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PWNODE_SINGLE_ITEM			pWnode,
	IN	ULONG						BufferSize,
	OUT	PULONG						pReturnSize
);

EXTERN
NTSTATUS
AtmArpWmiSetEventStatus(
	IN	PATMARP_INTERFACE			pInterface,
	IN	LPGUID						pGuid,
	IN	BOOLEAN						bEnabled
);

EXTERN
NTSTATUS
AtmArpWmiDispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
);

EXTERN
VOID
AtmArpWmiInitInterface(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_WMI_GUID			GuidList,
	IN	ULONG						NumberOfGuids
);

EXTERN
VOID
AtmArpWmiShutdownInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
NTSTATUS
AtmArpWmiSetTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
);

EXTERN
NTSTATUS
AtmArpWmiQueryTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
);

NTSTATUS
AtmArpWmiGetAddressList(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN	LOCKOUT,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
);

EXTERN
VOID
AtmArpWmiEnableEventTCSupported(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
);

EXTERN
NTSTATUS
AtmArpWmiSetTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
);

EXTERN
NTSTATUS
AtmArpWmiQueryTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
);

EXTERN
VOID
AtmArpWmiEnableEventTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	BOOLEAN						bEnable
);

EXTERN
VOID
AtmArpWmiSendTCIfIndication(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						IndicationCode,
	IN	ULONG						IndicationSubCode
);

EXTERN
NTSTATUS
AtmArpWmiSetStatisticsBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	IN	PVOID						pInputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesWritten,
	OUT	PULONG						pBytesNeeded
);

EXTERN
NTSTATUS
AtmArpWmiQueryStatisticsBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ATMARP_GUID_ID				MyId,
	OUT	PVOID						pOutputBuffer,
	IN	ULONG						BufferLength,
	OUT	PULONG						pBytesReturned,
	OUT	PULONG						pBytesNeeded
);

EXTERN
PATMARP_INTERFACE
AtmArpWmiGetIfByName(
	IN	PWSTR						pIfName,
	IN	USHORT						IfNameLength
);

#endif // ATMARP_WMI

//
//  --------------- from callmgr.c ----------------------------
//
EXTERN
VOID
AtmArpCoAfRegisterNotifyHandler(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
);

EXTERN
NDIS_STATUS
AtmArpOpenCallMgr(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpCloseCallMgr(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpRegisterSaps(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpDeregisterSaps(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
NDIS_STATUS
AtmArpMakeCall(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PNDIS_PACKET				pPacketToBeQueued	OPTIONAL
);

EXTERN
VOID
AtmArpFillCallParameters(
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN	ULONG						ParametersSize,
	IN	PATM_ADDRESS				pCalledAddress,
	IN	PATM_ADDRESS				pCallingAddress,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	BOOLEAN						IsPMP,
	IN	BOOLEAN						IsMakeCall
);

EXTERN
VOID
AtmArpCloseCall(
	IN	PATMARP_VC					pVc
);

EXTERN
NDIS_STATUS
AtmArpCreateVcHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
);

EXTERN
NDIS_STATUS
AtmArpDeleteVcHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
);

EXTERN
NDIS_STATUS
AtmArpIncomingCallHandler(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS 	pCallParameters
);

EXTERN
VOID
AtmArpCallConnectedHandler(
	IN	NDIS_HANDLE					ProtocolVcContext
);

EXTERN
VOID
AtmArpIncomingCloseHandler(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
);

#ifdef IPMCAST

EXTERN
VOID
AtmArpAddParty(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
);

EXTERN
VOID
AtmArpMcTerminateMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
);

#endif // IPMCAST

EXTERN
VOID
AtmArpIncomingDropPartyHandler(
	IN	NDIS_STATUS					DropStatus,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	PVOID						pCloseData	OPTIONAL,
	IN	UINT						Size		OPTIONAL
);

EXTERN
VOID
AtmArpQosChangeHandler(
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmArpOpenAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
);

EXTERN
VOID
AtmArpCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
);

EXTERN
VOID
AtmArpRegisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext,
	IN	PCO_SAP						pSap,
	IN	NDIS_HANDLE					NdisSapHandle
);

EXTERN
VOID
AtmArpDeregisterSapCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolSapContext
);

EXTERN
VOID
AtmArpMakeCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

#ifdef IPMCAST

EXTERN
VOID
AtmArpMcMakeCallComplete(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	NDIS_STATUS					Status
);

#endif // IPMCAST

EXTERN
VOID
AtmArpCloseAfCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext
);

EXTERN
VOID
AtmArpCloseCallCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext OPTIONAL
);

EXTERN
VOID
AtmArpAddPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
VOID
AtmArpDropPartyCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
);

EXTERN
VOID
AtmArpModifyQosCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
);

EXTERN
NDIS_STATUS
AtmArpCoRequestHandler(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
);

EXTERN
VOID
AtmArpCoRequestCompleteHandler(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					ProtocolVcContext	OPTIONAL,
	IN	NDIS_HANDLE					ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
);

EXTERN
VOID
AtmArpGetAtmAddress(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpHandleGetAddressesComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_REQUEST				pNdisRequest
);

EXTERN
VOID
AtmArpUpdateAddresses(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						AddThem
);

EXTERN
VOID
AtmArpHandleModAddressComplete(
	IN	NDIS_STATUS					Status,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	ULONG						Oid
);

EXTERN
NDIS_STATUS
AtmArpSendNdisCoRequest(
	IN	NDIS_HANDLE					NdisAdapterHandle,
	IN	NDIS_HANDLE					NdisAfHandle,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
);


//
//  --------------- from init.c ----------------------------
//
//

EXTERN
VOID
AtmArpInitGlobals(
);

EXTERN
NDIS_STATUS
AtmArpInitIpOverAtm(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpUnloadProtocol(
	VOID
);

//
//  --------------- from ioctl.c ------------------------------
//
//
#if !BINARY_COMPATIBLE
#ifdef CUBDD

EXTERN
NTSTATUS
AtmArpInternalDeviceControl(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
);

EXTERN
NTSTATUS
AtmArpIoctlArpRequest(
	IN	PATMARP_INTERFACE			pInterface	OPTIONAL,
	IN	PIRP						pIrp
);

EXTERN
VOID
AtmArpCompleteArpIrpList(
	IN	SINGLE_LIST_ENTRY			ListHead,
	IN	PATM_ADDRESS				pAtmAddress	OPTIONAL
);
#endif // CUBDD
#endif // !BINARY_COMPATIBLE

//
//  --------------- from ipmcast.c ----------------------------
//
//

#ifdef DHCP_OVER_ATM

EXTERN
NDIS_STATUS
AtmArpSendBroadcast(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec
);

EXTERN
NDIS_STATUS
AtmArpSendToDHCPServer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec
);

EXTERN
NDIS_STATUS
AtmArpSendToDHCPClient(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FILTER_SPEC			pFilterSpec
);

#endif // DHCP_OVER_ATM

#ifdef IPMCAST

EXTERN
UINT
AtmArpMcAddAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
);

EXTERN
UINT
AtmArpMcDelAddress(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
);

EXTERN
VOID
AtmArpMcHandleJoinOrLeaveCompletion(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask,
	IN	BOOLEAN						IsJoin
);

EXTERN
VOID
AtmArpMcStartRegistration(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmArpMcSendPendingJoins(
	IN	PATMARP_INTERFACE			pInterface		LOCKIN NOLOCKOUT
);

EXTERN
VOID
AtmArpMcRevalidateAll(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpMcHandleMARSFailure(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						IsRegnFailure
);

EXTERN
VOID
AtmArpMcSendToMARS(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket
);

EXTERN
VOID
AtmArpMcSendJoinOrLeave(
	IN	PATMARP_INTERFACE			pInterface,
	IN	USHORT						OpCode,
	IN	PIP_ADDRESS					pIPAddress 	OPTIONAL,
	IN	IP_ADDRESS					Mask
);

EXTERN
VOID
AtmArpMcSendRequest(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PIP_ADDRESS					pIPAddress
);

EXTERN
PATMARP_IPMC_ATM_ENTRY
AtmArpMcLookupAtmMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY *	ppMcAtmList,
	IN	PUCHAR						pAtmNumber,
	IN	ULONG						AtmNumberLength,
	IN	ATM_ADDRESSTYPE				AtmNumberType,
	IN	PUCHAR						pAtmSubaddress,
	IN	ULONG						AtmSubaddressLength,
	IN	BOOLEAN						CreateNew
);

EXTERN
VOID
AtmArpMcUnlinkAtmMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,	LOCKIN LOCKOUT
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
);

EXTERN
VOID
AtmArpMcUpdateConnection(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

#endif // IPMCAST

//
//  --------------- from marspkt.c ----------------------------
//
//

#ifdef IPMCAST

EXTERN
PUCHAR
AtmArpMcMakePacketCopy(
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	ULONG						TotalLength
);

EXTERN
BOOLEAN
AtmArpMcProcessPacket(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	PAA_PKT_LLC_SNAP_HEADER		pPktHeader,
	IN	ULONG						TotalLength,
	IN	ULONG						FirstBufferLength
);

EXTERN
BOOLEAN
AtmArpMcPreprocess(
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	OUT	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleMulti(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleMigrate(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleJoinOrLeave(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleNak(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleGroupListReply(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);

EXTERN
VOID
AtmArpMcHandleRedirectMap(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
);


#endif // IPMCAST

//
//  --------------- from ntentry.c ----------------------------
//
//

EXTERN
NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT				pDriverObject,
	IN	PUNICODE_STRING				pRegistryPath
);

#if !BINARY_COMPATIBLE

EXTERN
NTSTATUS
Dispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
);

NTSTATUS
AtmArpHandleIoctlRequest(
	IN	PIRP					pIrp,
	IN	PIO_STACK_LOCATION		pIrpSp
);

#endif // !BINARY_COMPATIBLE

EXTERN
VOID
Unload(
	IN	PDRIVER_OBJECT				pDriverObject
);


//
//  --------------- from qos.c ------------------------------
//
//
EXTERN
VOID
AtmArpQosGetPacketSpecs(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PATMARP_FLOW_INFO			*ppFlowInfo,
	OUT	PATMARP_FLOW_SPEC			*ppFlowSpec,
	OUT	PATMARP_FILTER_SPEC			*ppFilterSpec
);

EXTERN
BOOLEAN
AtmArpQosDoFlowsMatch(
	IN	PVOID						Context,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FLOW_SPEC			pTargetFlowSpec
);

EXTERN
BOOLEAN
AtmArpQosDoFiltersMatch(
	IN	PVOID						Context,
	IN	PATMARP_FILTER_SPEC			pFilterSpec,
	IN	PATMARP_FILTER_SPEC			pTargetFilterSpec
);

#ifdef GPC

EXTERN
VOID
AtmArpGpcInitialize(
	VOID
);

EXTERN
VOID
AtmArpGpcShutdown(
	VOID
);


EXTERN
VOID
AtmArpGpcAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
);

EXTERN
GPC_STATUS
AtmArpGpcAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_HANDLE					GpcCfInfoHandle,
	IN	ULONG						CfInfoSize,
	IN	PVOID						pCfInfo,
	OUT	PGPC_CLIENT_HANDLE			pClientCfInfoContext
);

EXTERN
VOID
AtmArpGpcModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
);

EXTERN
GPC_STATUS
AtmArpGpcModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	ULONG						CfInfoSize,
	IN	PVOID						pNewCfInfo
);

EXTERN
VOID
AtmArpGpcRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
);

EXTERN
GPC_STATUS
AtmArpGpcRemoveCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext
);

EXTERN
GPC_STATUS
AtmArpGpcValidateCfInfo(
	IN	PVOID						pCfInfo,
	IN	ULONG						CfInfoSize
);

EXTERN
GPC_STATUS
AtmArpGpcGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       	ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING        InstanceName
);

#endif // GPC

//
//  --------------- from space.c ----------------------------
//
//
EXTERN ATMARP_GLOBALS		AtmArpGlobalInfo;
EXTERN PATMARP_GLOBALS		pAtmArpGlobalInfo;
EXTERN NDIS_PROTOCOL_CHARACTERISTICS AtmArpProtocolCharacteristics;
EXTERN NDIS_CLIENT_CHARACTERISTICS AtmArpClientCharacteristics;
EXTERN ATM_BLLI_IE AtmArpDefaultBlli;
EXTERN ATM_BHLI_IE AtmArpDefaultBhli;
EXTERN AA_PKT_LLC_SNAP_HEADER AtmArpLlcSnapHeader;
#ifdef QOS_HEURISTICS
EXTERN ATMARP_FLOW_INFO	AtmArpDefaultFlowInfo;
#endif // QOS_HEURISTICS
#ifdef GPC
EXTERN GPC_CLASSIFY_PACKET_HANDLER AtmArpGpcClassifyPacketHandler;
EXTERN GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER AtmArpGpcGetCfInfoClientContextHandler;
#endif
#ifdef IPMCAST
EXTERN AA_MC_PKT_TYPE1_SHORT_HEADER AtmArpMcType1ShortHeader;
EXTERN AA_MARS_PKT_FIXED_HEADER	AtmArpMcMARSFixedHeader;
#endif // IPMCAST

EXTERN ULONG	AtmArpMaxTimerValue[];
EXTERN ULONG	AtmArpTimerListSize[];
EXTERN ULONG	AtmArpTimerPeriod[];

#ifdef ATMARP_WMI

EXTERN ATMARP_WMI_GUID		AtmArpGuidList[];
EXTERN ULONG				AtmArpGuidCount;

#endif // ATMARP_WMI

#ifdef BACK_FILL
EXTERN  ULONG	AtmArpDoBackFill;
EXTERN  ULONG	AtmArpBackFillCount;
#endif // BACK_FILL


//
//  --------------- from timeouts.c ----------------------------
//
//
EXTERN
VOID
AtmArpServerConnectTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpRegistrationTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpServerRefreshTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpAddressResolutionTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpIPEntryInARPWaitTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpPVCInARPWaitTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpIPEntryAgingTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpVcAgingTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpNakDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

#ifdef IPMCAST

EXTERN
VOID
AtmArpMcMARSRegistrationTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcMARSReconnectTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcMARSKeepAliveTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcJoinOrLeaveTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcRevalidationDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);

EXTERN
VOID
AtmArpMcPartyRetryDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
);


#endif // IPMCAST

//
//  --------------- from utils.c ----------------------------
//
//

EXTERN
VOID
AtmArpSetMemory(
	IN	PUCHAR						pStart,
	IN	UCHAR						Value,
	IN	ULONG						NumberOfBytes
);

EXTERN
ULONG
AtmArpMemCmp(
	IN	PUCHAR						pString1,
	IN	PUCHAR						pString2,
	IN	ULONG						Length
);

EXTERN
LONG
AtmArpRandomNumber(
	VOID
);

EXTERN
VOID
AtmArpCheckIfTimerIsInActiveList(
	IN	PATMARP_TIMER				pTimerToCheck,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PVOID						pStruct,
	IN	PCHAR						pStructName
	);

EXTERN
PATMARP_VC
AtmArpAllocateVc(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpDeallocateVc(
	IN	PATMARP_VC					pVc
);

EXTERN
VOID
AtmArpReferenceVc(
	IN	PATMARP_VC					pVc
);

EXTERN
ULONG
AtmArpDereferenceVc(
	IN	PATMARP_VC					pVc
);

EXTERN
PATMARP_ATM_ENTRY
AtmArpAllocateAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						IsMulticast
);

EXTERN
VOID
AtmArpDeallocateAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

EXTERN
VOID
AtmArpReferenceAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

EXTERN
ULONG
AtmArpDereferenceAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

EXTERN
PATMARP_IP_ENTRY
AtmArpAllocateIPEntry(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpDeallocateIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
VOID
AtmArpReferenceIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
ULONG
AtmArpDereferenceIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);


EXTERN
PATMARP_INTERFACE
AtmArpAllocateInterface(
	IN	PATMARP_ADAPTER				pAdapter
);

EXTERN
VOID
AtmArpDeallocateInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpReferenceInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
ULONG
AtmArpDereferenceInterface(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpReferenceJoinEntry(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry
);

EXTERN
ULONG
AtmArpDereferenceJoinEntry(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry
);

EXTERN
VOID
AtmArpStartTimer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_TIMER				pTimer,
	IN	ATMARP_TIMEOUT_HANDLER		TimeoutHandler,
	IN	ULONG						SecondsToGo,
	IN	PVOID						Context
);

EXTERN
BOOLEAN
AtmArpStopTimer(
	IN	PATMARP_TIMER				pTimer,
	IN	PATMARP_INTERFACE			pInterface
);

#ifdef NO_TIMER_MACRO

EXTERN
VOID
AtmArpRefreshTimer(
	IN	PATMARP_TIMER				pTimer
);

#endif // NO_TIMER_MACRO

EXTERN
VOID
AtmArpTickHandler(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						Context,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
);

EXTERN
PNDIS_PACKET
AtmArpAllocatePacket(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpFreePacket(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pPacket
);

EXTERN
PNDIS_BUFFER
AtmArpGrowHeaders(
	IN	PATMARP_INTERFACE			pInterface,
	IN	AA_HEADER_TYPE				HdrType
);

EXTERN
PNDIS_BUFFER
AtmArpAllocateHeader(
	IN	PATMARP_INTERFACE			pInterface,
	IN	AA_HEADER_TYPE				HdrType,
	OUT	PUCHAR *					pBufferAddress
);

EXTERN
VOID
AtmArpFreeHeader(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	AA_HEADER_TYPE				HdrType
);

EXTERN
VOID
AtmArpDeallocateHeaderBuffers(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
PNDIS_BUFFER
AtmArpAllocateProtoBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						Length,
	OUT	PUCHAR *					pBufferAddress
);

EXTERN
VOID
AtmArpFreeProtoBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_BUFFER				pNdisBuffer
);

EXTERN
NDIS_STATUS
AtmArpInitProtoBuffers(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpDeallocateProtoBuffers(
	IN	PATMARP_INTERFACE			pInterface
);

EXTERN
VOID
AtmArpLinkVcToAtmEntry(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_ATM_ENTRY			pAtmEntry
);

EXTERN
VOID
AtmArpUnlinkVcFromAtmEntry(
	IN	PATMARP_VC					pVc,
	IN	BOOLEAN						bDerefAtmEntry
);


EXTERN
VOID
AtmArpUnlinkIpEntryFromAtmEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
);

EXTERN
PNDIS_BUFFER
AtmArpCopyToNdisBuffer(
	IN	PNDIS_BUFFER				pDestBuffer,
	IN	PUCHAR						pDataSrc,
	IN	UINT						LenToCopy,
	IN OUT	PUINT					pOffsetInBuffer
);

PATMARP_INTERFACE
AtmArpAddInterfaceToAdapter (
	IN	PATMARP_ADAPTER				pAdapter,
	IN	NDIS_HANDLE					LISConfigHandle, // Handle to per-LIS config
	IN	NDIS_STRING					*pIPConfigString
	);

#if DBG

//
// Following are versions of addref/deref which tracks referenc types.
//

EXTERN
VOID
AtmArpReferenceAtmEntryEx(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	AE_REFTYPE 					RefType
);

EXTERN
ULONG
AtmArpDereferenceAtmEntryEx(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	AE_REFTYPE 					RefType,
	IN	BOOLEAN						fOkToDelete
);


EXTERN
VOID
AtmArpReferenceIPEntryEx(
	IN 	PATMARP_IP_ENTRY			pIpEntry,
	IN	IE_REFTYPE 					RefType
);

EXTERN
ULONG
AtmArpDereferenceIPEntryEx(
	IN	PATMARP_IP_ENTRY			pIpEntry,
	IN 	IE_REFTYPE 					RefType,
	IN	BOOLEAN						fOkToDelete
);

EXTERN
VOID
AtmArpReferenceJoinEntryEx(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry,
	IN	ULONG						RefInfo
);

EXTERN
ULONG
AtmArpDereferenceJoinEntryEx(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry,
	IN	ULONG						RefInfo
);

#endif // DBG

#endif	// _ATMARP_EXTERNS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	init.c 

Abstract:

	Initialization and Termination routines for the ATMARP client.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-09-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'TINI'

VOID
AtmArpInitGlobals(
)
/*++

Routine Description:

	Initialize all our global data structures.

Arguments:

	None

Return Value:

	None

--*/
{

	AA_SET_MEM(pAtmArpGlobalInfo, 0, sizeof(ATMARP_GLOBALS));

#if DBG
	pAtmArpGlobalInfo->aag_sig = aag_signature;
#ifdef GPC
	pAtmArpGlobalInfo->aaq_sig = aaq_signature;
#endif // GPC
#endif // DBG

	AA_INIT_GLOBAL_LOCK(pAtmArpGlobalInfo);
	AA_INIT_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block));

}



NDIS_STATUS
AtmArpInitIpOverAtm(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Initialize IP/ATM data structures for the given interface.
	It is assumed that the configuration information for the interface
	has been read in.

	We allocate ATM Entries for the ARP servers, and the DHCP server,
	if configured.

Arguments:

	pInterface			- Pointer to ATMARP interface

Return Value:

	NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_RESOURCES if we
	aren't able to do the allocation necessary.

--*/
{
	PATMARP_SERVER_ENTRY	pServerEntry;
	NDIS_STATUS				Status;
	PATMARP_SERVER_LIST		pServerList;

	//
	//  Initialize.
	//
	Status = NDIS_STATUS_SUCCESS;

	do
	{
#ifdef IPMCAST
		if (pInterface->ArpServerList.ListSize != 0)
		{
			//
			//  Set the current ARP server to the first one in the list.
			//
			pInterface->pCurrentServer = pInterface->ArpServerList.pList;
		}

		if (pInterface->MARSList.ListSize != 0)
		{
			//
			//  Set the current MARS server to the first one in the list.
			//
			pInterface->pCurrentMARS = pInterface->MARSList.pList;
		}
	
		for (pServerList = &(pInterface->ArpServerList);
			 pServerList != NULL_PATMARP_SERVER_LIST;
			 /* NONE -- see end of for loop */
			 )
		{
			for (pServerEntry = pServerList->pList;
 				pServerEntry != NULL_PATMARP_SERVER_ENTRY;
 				pServerEntry = pServerEntry->pNext)
			{
				UCHAR	AddrTypeLen;
				UCHAR	SubaddrTypeLen;

				AddrTypeLen =
						AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pServerEntry->ATMAddress));
				if (pServerEntry->ATMSubaddress.NumberOfDigits > 0)
				{
					SubaddrTypeLen =
						AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pServerEntry->ATMSubaddress));
				}
				else
				{
					SubaddrTypeLen = 0;
				}

				pServerEntry->pAtmEntry =
					 AtmArpSearchForAtmAddress(
						pInterface,
						AddrTypeLen,
						pServerEntry->ATMAddress.Address,
						SubaddrTypeLen,
						pServerEntry->ATMSubaddress.Address,
						AE_REFTYPE_IF,
						TRUE	// Create new one if not found
						);

				if (pServerEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					//
					//  Must be a resource failure.
					//
					Status = NDIS_STATUS_RESOURCES;
					break;
				}
				else
				{
					//
					//  NOTE: AtmArpSearchForAtmAddress has alreaddy addrefd
					//  the pAtmEntry for us.
					//
				}
			}

			//
			//  Move to the next list of servers, if any.
			//
			if (pServerList == &(pInterface->MARSList))
			{
				//
				//  We are done.
				//
				pServerList = NULL_PATMARP_SERVER_LIST;
			}
			else
			{
				//
				//  We just finished with the ARP Server list. Now process
				//  the MARS list.
				//
				pServerList = &(pInterface->MARSList);
			}
		}
#else
		if (pInterface->ArpServerList.ListSize > 0)
		{
			//
			//  Set the current ARP server to the first one in the list.
			//
			pInterface->pCurrentServer = pInterface->ArpServerList.pList;
	
			for (pServerEntry = pInterface->ArpServerList.pList;
 				pServerEntry != NULL_PATMARP_SERVER_ENTRY;
 				pServerEntry = pServerEntry->pNext)
			{
				UCHAR	AddrTypeLen;
				UCHAR	SubaddrTypeLen;

				AddrTypeLen =
						AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pServerEntry->ATMAddress));
				if (pServerEntry->ATMSubaddress.NumberOfDigits > 0)
				{
					SubaddrTypeLen =
						AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pServerEntry->ATMSubaddress));
				}
				else
				{
					SubaddrTypeLen = 0;
				}

				pServerEntry->pAtmEntry =
					 AtmArpSearchForAtmAddress(
						pInterface,
						AddrTypeLen,
						pServerEntry->ATMAddress.Address,
						SubaddrTypeLen,
						pServerEntry->ATMSubaddress.Address,
						AE_REFTYPE_IF,			
						TRUE	// Create new one if not found
						);

				if (pServerEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					//
					//  Must be a resource failure.
					//
					Status = NDIS_STATUS_RESOURCES;
					break;
				}
				else
				{
					//
					//  NOTE: AtmArpSearchForAtmAddress has alreaddy addrefd
					//  the pAtmEntry for us.
					//
				}
			}
		}
#endif // IPMCAST

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

#ifdef DHCP_OVER_ATM
		if (pInterface->DhcpEnabled)
		{
			UCHAR		AddrTypeLen;

			AddrTypeLen = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->DhcpServerAddress));

			pInterface->pDhcpServerAtmEntry =
					 AtmArpSearchForAtmAddress(
						pInterface,
						AddrTypeLen,
						pInterface->DhcpServerAddress.Address,
						0,					// Subaddress type+len
						(PUCHAR)NULL,		// Subaddress
						AE_REFTYPE_IF,
						TRUE				// Create new one if not found
						);

			if (pInterface->pDhcpServerAtmEntry == NULL_PATMARP_ATM_ENTRY)
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
			else
			{
				//
				//  NOTE: AtmArpSearchForAtmAddress has alreaddy addrefd
				//  the pAtmEntry for us.
				//
			}
		}
#endif // DHCP_OVER_ATM
		break;
	}
	while (FALSE);

	return (Status);
}


VOID
AtmArpUnloadProtocol(
	VOID
)
/*++

Routine Description:

	Unloads the ATMARP protocol module. We unbind from all adapters,
	and deregister from NDIS as a protocol.

Arguments:

	None.

Return Value:

	None

--*/
{
	NDIS_STATUS			Status;
	PATMARP_ADAPTER		pAdapter;

#if DBG
	AADEBUGP(AAD_INFO, ("AtmArpUnloadProtocol entered\n"));
#endif // DBG

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	if (pAtmArpGlobalInfo->bUnloading)
	{
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);
		return;
	}

	pAtmArpGlobalInfo->bUnloading = TRUE;

#if 0
	//
	//  Commented this out because we don't need to handle
	//  the case of unclosed bindings ourselves. If there
	//  are any at this time, then NDIS will call our Unbind
	//  handlers for such bindings in response to our call
	//  to NdisDeregisterProtocol below.
	//
	while (pAtmArpGlobalInfo->pAdapterList != NULL_PATMARP_ADAPTER)
	{
		pAdapter = pAtmArpGlobalInfo->pAdapterList;
		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		AADEBUGP(AAD_INFO, ("UnloadProtocol: Will unbind adapter 0x%x\n", pAdapter));

		AtmArpUnbindAdapterHandler(
				&Status,
				(NDIS_HANDLE)pAdapter,
				(NDIS_HANDLE)NULL		// No UnbindContext ==> Don't complete NdisUnbind
			);

		if (Status == NDIS_STATUS_PENDING)
		{
			//
			//  Wait for the unbind to complete
			//
			(VOID)AA_WAIT_ON_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block));
		}

		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	}

#endif // 0

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	NdisDeregisterProtocol(
		&Status,
		pAtmArpGlobalInfo->ProtocolHandle
		);


	AA_FREE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	AA_FREE_BLOCK_STRUCT(&(pAtmArpGlobalInfo->Block));

#ifdef GPC
	AtmArpGpcShutdown();
#endif // GPC

#if DBG
	AaAuditShutdown();
#endif // DBG

	AADEBUGP(AAD_LOUD,
		 ("UnloadProtocol: will deregister protocol now, ProtHandle 0x%x\n",
			pAtmArpGlobalInfo->ProtocolHandle));

	AA_ASSERT(Status == NDIS_STATUS_SUCCESS);

	AADEBUGP(AAD_LOUD, ("UnloadProtocol done\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\ioctl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    This file contains the ioctl declarations for the atmarp client.

Environment:

    Kernel mode

Revision History:

	8/14/1998 JosephJ Created

--*/

#ifndef	_IOCTL_
#define	_IOCTL_

#define	ARP_CLIENT_DOS_DEVICE_NAME		L"\\\\.\\ATMARPC"

#define	ARPC_IOCTL_QUERY_VERSION		CTL_CODE(FILE_DEVICE_NETWORK, 100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_QUERY_INTERFACES		CTL_CODE(FILE_DEVICE_NETWORK, 101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_QUERY_INTERFACE		CTL_CODE(FILE_DEVICE_NETWORK, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_QUERY_IPENTRY		CTL_CODE(FILE_DEVICE_NETWORK, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_QUERY_ATMENTR		CTL_CODE(FILE_DEVICE_NETWORK, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPC_IOCTL_ADD_ARPENTRY			CTL_CODE(FILE_DEVICE_NETWORK, 105, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define ARPC_IOCTL_VERSION 0x0

//
// Sames as COUNTED_STRING defined in  sdk\inc\ntfsprop.h
//
typedef struct
{
	USHORT Length;
	WCHAR Text[1];
} ATMARPC_INTERFACE_NAME, *PATMARPC_INTERFACE_NAME;

//
// All Ptrs are represented by offsets from the beginning of the structures.
//
typedef	UNICODE_STRING	INTERFACE_NAME, *PINTERFACE_NAME;

typedef struct
{
	ATM_ADDRESS Addr;
	ATM_ADDRESS SubAddr;
} ATM_ADDRESS_PAIR;


typedef struct
{
	UINT			NumberOfInterfaces;
	ATMARPC_INTERFACE_NAME	Interfaces; // The interfaces are strung together.
} ATMARPC_INTERFACES, *PATMARPC_INTERFACES;


typedef struct
{
	enum
	{
		SIG_ATMARPC_INTERFACE_INFO,
		SIG_ATMARPC_IP_INFO,
		SIG_ATMARPC_ATM_INFO
	} Sig;
	UINT TotalSize;
	UINT NeededSize;
	UINT InterfaceNameOffset;
} ATMARPC_IOCTL_HEADER;

typedef struct
{
	ATMARPC_IOCTL_HEADER 	Hdr;
	ULONG					State;
	UINT					NumLocalIPAddrs;
	UINT 					LocalIPAddrsOffset;
	UINT					NumDestIPAddrs;
	UINT					DestIPAddrsOffset;
	UINT					NumDestAtmAddrs;
	UINT					DestAtmAddrsOffset;
} ATMARPC_INTERFACE_INFO;

#define ATMARPC_GET_LOCAL_IP_LIST(_pInterfaceInfo) 					\
		((IPAddr*)  (  ((BYTE*)(_pInterfaceInfo))					\
						  + (_pInterfaceInfo)->LocalIPAddrsOffset))

#define ATMARPC_GET_DEST_IP_LIST(_pInterfaceInfo) 					\
		((IPAddr*)  (  ((BYTE*)(_pInterfaceInfo))					\
						  + (_pInterfaceInfo)->DestIPAddrsOffset))

#define ATMARPC_GET_DEST_ATM_LIST(_pInterfaceInfo)					\
		((ATM_ADDRESS_PAIR*)  (  ((BYTE*)(_pInterfaceInfo))			\
						  + (_pInterfaceInfo)->DestAtmAddrsOffset))

typedef struct
{
	ATMARPC_IOCTL_HEADER 	Hdr;
	IPAddr 			   	IPAddress;
	ULONG					State;
	UINT 				   	NumAtmEntries;
	UINT					AtmAddrsOffset;
} ATMARPC_DEST_IP_INFO;

#define ATMARPC_GET_DEST_ATM_LIST_FOR_IP(_pIPInfo)					\
		((ATM_ADDRESS_PAIR*)  (  ((BYTE*)(_pIPInfo))				\
						  + (_pIPInfo)->AtmAddrsOffset))

typedef struct
{
	ATMARPC_IOCTL_HEADER 	Hdr;
	ULONG					State;
	ATM_ADDRESS_PAIR		AtmAddress;
	UINT					NumIPEntries;
	UINT					IPAddrsOffset;
} ATMARPC_DEST_ATM_INFO;

#define ATMARPC_GET_DEST_IP_LIST_FOR_ATM(_pAtmInfo)					\
		((IPAddr*)  (  ((BYTE*)(_pAtmInfo))						\
						  + (_pAtmInfo)->IPAddrsOffset))

typedef struct
{
	ATMARPC_IOCTL_HEADER 	Hdr;
	IPAddr					IPAddress;
	ATM_ADDRESS_PAIR 		AtmAddress;
} ATMARPC_ARP_COMMAND;

#endif	// _IOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\ipmcast.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ipmcast.c

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-27-96    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'CMPI'



#ifdef IPMCAST

UINT
AtmArpMcAddAddress(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN	NOLOCKOUT,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
)
/*++

Routine Description:

	The IP layer wants us to start receiving packets directed to this
	IP Multicast address. This translates to sending a MARS_JOIN message
	to MARS, if conditions are fine.

	NOTE: For now, we support a non-zero Mask value (see below) only
	      for the special case of multicast promiscuous mode.

	NOTE: The caller is assumed to have acquired the IF lock, and it
	willl be released here.

Arguments:
	pInterface				- Pointer to ATMARP Interface on which to receive
							  multicast packets.
	IPAddress				- Identifies the multicast group to "Join"
	Mask					- 0 if a single address is being specified, otherwise
							  a mask that denotes a block of addresses being joined.

Return Value:

	(UINT)TRUE if the address was added successfully, (UINT)FALSE otherwise.

--*/
{
	BOOLEAN						ReturnValue;
	BOOLEAN						LockReleased;
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;

	//
	//  Initialize.
	//
	ReturnValue = (UINT)TRUE;
	LockReleased = TRUE;
	pJoinEntry = NULL_PATMARP_IPMC_JOIN_ENTRY;

	do
	{
		//
		//  We don't support "block join" yet, i.e. we allow only single
		//  IP addresses to be joined. Special exception: promiscuous mode
		//  multicast, or "join everything", indicated by the special values
		//  of IPAddress and Mask checked for below.
		//
		if (Mask != 0)
		{
	        if (IPAddress != IP_CLASSD_MIN || Mask != IP_CLASSD_MASK)
	        {
                ReturnValue = (UINT)FALSE;
                LockReleased = FALSE;
                break;
            }
		}

		//
		//  Fail this if the interface is going down.
		//
		if (pInterface->ArpTableUp == FALSE)
		{
			ReturnValue = (UINT)FALSE;
			LockReleased = FALSE;
			break;
		}

		//
		//  Check if this IP address range has been added before. If so,
		//  all we need to do is to bump up its ref count.
		//
		for (pJoinEntry = pInterface->pJoinList;
			 pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY;
			 pJoinEntry = pJoinEntry->pNextJoinEntry)
		{
			if (   pJoinEntry->IPAddress == IPAddress
				&& pJoinEntry->Mask == Mask)
			{
				break;
			}
		}

		if (pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			//
			//  This address is already added. Just add a reference to it.
			//
			pJoinEntry->JoinRefCount++;
			ReturnValue = (UINT)TRUE;
			LockReleased = FALSE;
			break;
		}


		//
		//  Allocate an entry for this IP address.
		//
		AA_ALLOC_MEM(pJoinEntry, ATMARP_IPMC_JOIN_ENTRY, sizeof(ATMARP_IPMC_JOIN_ENTRY));
		if (pJoinEntry == NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			ReturnValue = (UINT)FALSE;
			LockReleased = FALSE;
			break;
		}

		//
		//  Fill in this new entry, and add it to the multicast address list.
		//
		AA_SET_MEM(pJoinEntry, 0, sizeof(ATMARP_IPMC_JOIN_ENTRY));
#if DBG
		pJoinEntry->aamj_sig = aamj_signature;
#endif // DBG
		pJoinEntry->IPAddress = IPAddress;
		pJoinEntry->Mask = Mask;
		pJoinEntry->pInterface = pInterface;
		pJoinEntry->JoinRefCount = 1;
		pJoinEntry->RefCount = 1;

		pJoinEntry->pNextJoinEntry = pInterface->pJoinList;
		pInterface->pJoinList = pJoinEntry;

		//
		//  We proceed to send a Join only if we have completed registering with
		//  the MARS. This is because we need to have a Cluster Member Id before
		//  we can Join multicast groups. When registration completes, the
		//  Join operation will be triggered off.
		//
		if (AAMC_IF_STATE(pInterface) == AAMC_IF_STATE_REGISTERED)
		{
			AA_SET_FLAG(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_JOINING);


			//
			//  Start the "Wait For Join completion" timer.
			//
			AtmArpStartTimer(
				pInterface,
				&(pJoinEntry->Timer),
				AtmArpMcJoinOrLeaveTimeout,
				pInterface->JoinTimeout,
				(PVOID)pJoinEntry
				);
			
			AA_REF_JE(pJoinEntry);	// McAddAddr: Wait for Join timer
			
			pJoinEntry->RetriesLeft = pInterface->MaxJoinOrLeaveAttempts - 1;

			//
			//  Send off a MARS_JOIN for this IP address.
			//
			AtmArpMcSendJoinOrLeave(
				pInterface,
				AA_MARS_OP_TYPE_JOIN,
				&IPAddress,
				Mask
				);

			//
			//  IF lock is released within the above.
			//
		}
		else
		{
			pJoinEntry->Flags = AA_IPMC_JE_STATE_PENDING;
			AtmArpMcStartRegistration(
				pInterface
				);
			//
			//  IF lock is released within the above.
			//
		}
		break;

	}
	while (FALSE);

	if (!LockReleased)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

	AAMCDEBUGP(AAD_LOUD,
		("AtmArpMcAddAddress: pIf 0x%x, Addr 0x%x, Mask 0x%x, JoinEnt 0x%x, Ret %d\n",
				pInterface, IPAddress, Mask, pJoinEntry, ReturnValue));
			
	return (ReturnValue);
}



UINT
AtmArpMcDelAddress(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN	NOLOCKOUT,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask
)
/*++

Routine Description:

	Delete membership of the given multicast IP address group, on the specified
	interface. If this is the last surviving reference to this multicast group,
	we send off a MARS_LEAVE message to MARS, indicating that we don't want to
	receive packets directed to this address anymore.

	NOTE: The "Mask" parameter could theoretically be used to identify a block
	of IP addresses. We support it for the specific case of stopping promiscuous
	multicast receive mode.

	NOTE: The caller is assumed to have acquired the IF Lock, which will
	be released here.

Arguments:

	pInterface				- Pointer to ATMARP Interface on which to remove
							  multicast group membership.
	IPAddress				- Identifies the multicast group to "Leave"
	Mask					- 0 if a single address is being specified, otherwise
							  a mask that denotes a block of addresses being "leave"d.

Return Value:

	(UINT)TRUE if the given address was deleted successfully, (UINT)FALSE
	otherwise.

--*/
{
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;
	PATMARP_IPMC_JOIN_ENTRY		*ppNextJoinEntry;
	UINT						ReturnValue;
	BOOLEAN						LockAcquired;
	BOOLEAN						WasRunning;
	ULONG						rc;
	
	//
	//  Initialize.
	//
	ReturnValue = (UINT)TRUE;
	pJoinEntry = NULL_PATMARP_IPMC_JOIN_ENTRY;
	LockAcquired = TRUE;

	do
	{
		//
		//  Get the entry corresponding to this IP address and mask.
		//
		ppNextJoinEntry = &(pInterface->pJoinList);
		while (*ppNextJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			if (   (*ppNextJoinEntry)->IPAddress == IPAddress
				&& (*ppNextJoinEntry)->Mask == Mask)
			{
				pJoinEntry = *ppNextJoinEntry;
				break;
			}
			ppNextJoinEntry = &((*ppNextJoinEntry)->pNextJoinEntry);
		}

		if (pJoinEntry == NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			//
			//  No entry for the given IP address!
			//
			ReturnValue = (UINT)TRUE;
			break;
		}

		//
		//  If we reached here, this call is successful.
		//
		ReturnValue = (UINT)TRUE;

		pJoinEntry->JoinRefCount--;

		if ((pJoinEntry->JoinRefCount == 0)		&&
		    (AA_IS_FLAG_SET(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_JOINED)))
		{
			//
			//  We just removed the last "Join" reference to this multicast group.
			//  If we are currently registered with MARS, send a MARS_LEAVE.
			//

			//
			//  First, stop any timer running on this entry.
			//
			WasRunning = AtmArpStopTimer(
							&(pJoinEntry->Timer),
							pInterface
							);

			if (AAMC_IF_STATE(pInterface) == AAMC_IF_STATE_REGISTERED)
			{
				//
				//  Start the "Wait for Leave completion" timer on this entry.
				//
				AtmArpStartTimer(
					pInterface,
					&(pJoinEntry->Timer),
					AtmArpMcJoinOrLeaveTimeout,
					pInterface->LeaveTimeout,
					(PVOID)pJoinEntry
					);
				
				if (!WasRunning)
				{
					AA_REF_JE(pJoinEntry);	// Started Wait for Leave timer
				}

				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_LEAVING);

				pJoinEntry->RetriesLeft = pInterface->MaxJoinOrLeaveAttempts - 1;

				//
				//  Send off a MARS_LEAVE for this IP address.
				//
				AtmArpMcSendJoinOrLeave(
					pInterface,
					AA_MARS_OP_TYPE_LEAVE,
					&IPAddress,
					Mask
					);
				//
				//  IF Lock is released within the above.
				//
				LockAcquired = FALSE;
			}
			else
			{
				//
				//  We are not registered with MARS, meaning that
				//  (re)-registration is in progress. Since all Joins
				//  are invalidated and re-created at the end of registration,
				//  we don't have to send a LEAVE explicitly for this address.
				//

				//
				//  Remove this entry from the Join list, and free it.
				//
				*ppNextJoinEntry = pJoinEntry->pNextJoinEntry;

				AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pJoinEntry->Timer));

				if (WasRunning)
				{
					rc = AA_DEREF_JE(pJoinEntry);	// McDelAddr: Timer stopped
				}
				else
				{
					rc = pJoinEntry->RefCount;
				}

				if (rc != 0)
				{
					rc = AA_DEREF_JE(pJoinEntry);	// McDelAddr: get rid of entry
				}
				else
				{
					AA_ASSERT(FALSE);
				}

			}

		}
		//
		//  else this IP address has some references outstanding.
		//  Leave it as is.
		//

		break;
	}
	while (FALSE);

	if (LockAcquired)
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

	return (ReturnValue);

}


VOID
AtmArpMcHandleJoinOrLeaveCompletion(
	IN	PATMARP_INTERFACE			pInterface,
	IN	IP_ADDRESS					IPAddress,
	IN	IP_MASK						Mask,
	IN	BOOLEAN						IsJoin
)
/*++

Routine Description:

	This is called when we receive a JOIN or LEAVE that acknowledges
	one that we sent earlier.

Arguments:

	pInterface			- Pointer to Interface
	IPAddress			- The group being joined/left
	IsJoin				- Is this a Join completion?

Return Value:

	None

--*/
{
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;
	PATMARP_IPMC_JOIN_ENTRY		*ppNextJoinEntry;
	ULONG						NewFlags;			// For Join Entry
	BOOLEAN						SendJoinOrLeave;
	ULONG						rc;

	//
	//  Find the JOIN Entry for this address
	//
	AA_ACQUIRE_IF_LOCK(pInterface);
	SendJoinOrLeave = FALSE;

	pJoinEntry = NULL_PATMARP_IPMC_JOIN_ENTRY;
	ppNextJoinEntry = &(pInterface->pJoinList);
	while (*ppNextJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
	{
		if (  (*ppNextJoinEntry)->IPAddress == IPAddress
			&&(*ppNextJoinEntry)->Mask == Mask)
		{
			pJoinEntry = *ppNextJoinEntry;
			break;
		}
		ppNextJoinEntry = &((*ppNextJoinEntry)->pNextJoinEntry);
	}

	if (pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
	{
		BOOLEAN		WasRunning;

		WasRunning = AtmArpStopTimer(&(pJoinEntry->Timer), pInterface);

		if (WasRunning)
		{
			rc = AA_DEREF_JE(pJoinEntry);	// Join Complete, stopped timer
			AA_ASSERT(rc != 0);
		}

		if (IsJoin)
		{
			AAMCDEBUGP(AAD_INFO,
				("JOINed %d.%d.%d.%d, pJoinEntry 0x%x, Flags 0x%x, JoinRefCount %d\n",
					((PUCHAR)&IPAddress)[0],
					((PUCHAR)&IPAddress)[1],
					((PUCHAR)&IPAddress)[2],
					((PUCHAR)&IPAddress)[3],
					pJoinEntry, pJoinEntry->Flags, pJoinEntry->JoinRefCount
				));

			AA_SET_FLAG(pJoinEntry->Flags,
						AA_IPMC_JE_STATE_MASK,
						AA_IPMC_JE_STATE_JOINED);

			//
			//  Check if IP had deleted this address while we
			//  were joining it.
			//
			if (pJoinEntry->JoinRefCount == 0)
			{
				//
				//  Send a Leave.
				//
				SendJoinOrLeave = TRUE;
				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_LEAVING);
			}

		}
		else
		{
			//
			//  This signifies completion of a LEAVE process.
			//
			AAMCDEBUGP(AAD_INFO,
				("LEFT %d.%d.%d.%d, pJoinEntry 0x%x, Flags 0x%x, RefCount %d\n",
					((PUCHAR)&IPAddress)[0],
					((PUCHAR)&IPAddress)[1],
					((PUCHAR)&IPAddress)[2],
					((PUCHAR)&IPAddress)[3],
					pJoinEntry, pJoinEntry->Flags, pJoinEntry->JoinRefCount
				));

			//
			//  IP might have re-joined this address while we were
			//  waiting for completion of leave.
			//
			if (pJoinEntry->JoinRefCount != 0)
			{
				//
				//  Send a Join.
				//
				SendJoinOrLeave = TRUE;
				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_JOINING);
			}
			else
			{
				//
				//  Unlink Join Entry from list.
				//
				*ppNextJoinEntry = pJoinEntry->pNextJoinEntry;
			
				//
				//  And free it.
				//
				AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pJoinEntry->Timer));
				rc = AA_DEREF_JE(pJoinEntry);	// Leave Complete - get rid of entry
				AA_ASSERT(SendJoinOrLeave == FALSE);
			}
		}
	}

	if (SendJoinOrLeave)
	{
		USHORT		Opcode;

		//
		//  Start the "Wait for Leave completion" timer on this entry.
		//
		AtmArpStartTimer(
			pInterface,
			&(pJoinEntry->Timer),
			AtmArpMcJoinOrLeaveTimeout,
			pInterface->LeaveTimeout,
			(PVOID)pJoinEntry
			);
		
		AA_REF_JE(pJoinEntry);	// Wait for Join/Leave completion

		pJoinEntry->RetriesLeft = pInterface->MaxJoinOrLeaveAttempts - 1;

		Opcode = (IsJoin? AA_MARS_OP_TYPE_LEAVE: AA_MARS_OP_TYPE_JOIN);
		AtmArpMcSendJoinOrLeave(
			pInterface,
			Opcode,
			&IPAddress,
			Mask
			);
		//
		//  IF Lock is released within the above.
		//
	}
	else
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
}



VOID
AtmArpMcStartRegistration(
	IN	PATMARP_INTERFACE			pInterface	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Start registration with the MARS, if all pre-conditions are met:
	0. AdminState for this Interface is UP
	1. Registration isn't done or in progress
	2. The ATM Interface is up
	3. Atleast one MARS ATM address is known (configured).

	NOTE: The caller is assumed to have locked the Interface structure,
	and the lock will be released here.

Arguments:

	pInterface			- Interface on which MARS registration is to be done.

Return Value:

	None

--*/
{
	BOOLEAN		WasRunning;

	AAMCDEBUGP(AAD_LOUD,
		 ("McStartReg: IF 0x%x, AdminState %d, AtmIfUp %d, Marslist size %d\n",
			pInterface,
			pInterface->AdminState,
			pInterface->AtmInterfaceUp,
			pInterface->MARSList.ListSize));

	if ((!pInterface->PVCOnly) &&
		(pInterface->AdminState == IF_STATUS_UP) &&
		(AAMC_IF_STATE(pInterface) == AAMC_IF_STATE_NOT_REGISTERED) &&
		(pInterface->AtmInterfaceUp) &&
		(pInterface->MARSList.ListSize > 0))
	{
		AAMCDEBUGP(AAD_INFO, ("Starting MARS registration on IF 0x%x\n", pInterface));

		AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_REGISTERING);

		//
		//  Stop any running timer.
		//
		WasRunning = AtmArpStopTimer(
							&(pInterface->McTimer),
							pInterface
							);

		//
		//  Start a timer to police completion of MARS registration.
		//
		AtmArpStartTimer(
				pInterface,
				&(pInterface->McTimer),
				AtmArpMcMARSRegistrationTimeout,
				pInterface->MARSRegistrationTimeout,
				(PVOID)pInterface
			);

		if (!WasRunning)
		{
			AtmArpReferenceInterface(pInterface);	// MARS Reg timer ref
		}

		pInterface->McRetriesLeft = pInterface->MaxRegistrationAttempts - 1;

		//
		//  Send a MARS_JOIN
		//
		AtmArpMcSendJoinOrLeave(
			pInterface,
			AA_MARS_OP_TYPE_JOIN,
			NULL,		// Not Joining any specific Multicast group (=> registration)
			0			// Mask (don't care)
			);
		//
		//  IF Lock is released within the above
		//
	}
	else
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}

}



VOID
AtmArpMcSendPendingJoins(
	IN	PATMARP_INTERFACE			pInterface		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Send MARS_JOIN on behalf of all Joins pending initial registration.

	NOTE: The caller is assumed to have a lock for the Interface,
	which will be released here.

Arguments:

	pInterface			- Interface on which pending Joins are to be sent.

Return Value:

	None

--*/
{
	typedef struct 
	{
		IP_ADDRESS			IPAddress;
		IP_MASK				Mask;
	} AA_IP_MASK_PAIR;

	PATMARP_IPMC_JOIN_ENTRY	pJoinEntry;
	PATMARP_IPMC_JOIN_ENTRY	pNextJoinEntry;
	UINT					NumEntries;
	AA_IP_MASK_PAIR 		*DestArray;

	//
	// Count the entries which need to be sent.
	//
	for (pJoinEntry = pInterface->pJoinList, NumEntries=0;
 		 pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY;
 		 pJoinEntry = pJoinEntry->pNextJoinEntry)
	{
		if (AA_IS_FLAG_SET(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_PENDING))
		{
			NumEntries++;
		}
	}

	if (NumEntries)
	{
		//
		// Allocate temporary space to hold their ip addresses and masks.
		//
		AA_ALLOC_MEM(
			DestArray,
			AA_IP_MASK_PAIR,
			NumEntries*sizeof(AA_IP_MASK_PAIR)
			);
	}
	else
	{
		DestArray = NULL;
	}
	
	if (DestArray!=NULL)
	{
		AA_IP_MASK_PAIR *pPair 		= DestArray;
		AA_IP_MASK_PAIR *pPairEnd 	= DestArray + NumEntries;

		//
		// Now go through the list again, setting the state of the entries
		// appropriately, and picking up the ipaddresses&masks.
		// Note that we continue to hold the interface lock, to the
		// join entry list can't grow or shrink, nor any join entry
		// change state. Neverthless, we check for these cases.
		//

		for (pJoinEntry = pInterface->pJoinList;
 			pJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY;
 		 	pJoinEntry = pJoinEntry->pNextJoinEntry)
		{
			if (AA_IS_FLAG_SET(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_PENDING))
			{
				PIP_ADDRESS				pIpAddress;

				if (pPair >= pPairEnd)
				{
					//
					// This means there are now more join entries in
					// this state then when we counted just above!
					// We deal with it by breaking out early, but really
					// this is an assert and if we hit it neet to determine
					// why the state of join entries are changing elsewhere
					// when we have the interface lock.
					//
					AA_ASSERT(FALSE);
					break;
				}

				pPair->IPAddress = pJoinEntry->IPAddress;
				pPair->Mask = pJoinEntry->Mask;

				pIpAddress = &(pJoinEntry->IPAddress);
	
				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_JOINING);
	
				//
				//  Send off a MARS_JOIN for this IP address.
				//
				AAMCDEBUGP(AAD_INFO,
					("Sending Pended Join: pIf 0x%x, pJoinEntry 0x%x, Addr: %d.%d.%d.%d\n",
							pInterface,
							pJoinEntry,
							((PUCHAR)pIpAddress)[0],
							((PUCHAR)pIpAddress)[1],
							((PUCHAR)pIpAddress)[2],
							((PUCHAR)pIpAddress)[3]));
	
				//
				//  Start the "Wait For Join completion" timer.
				//
				AtmArpStartTimer(
					pInterface,
					&(pJoinEntry->Timer),
					AtmArpMcJoinOrLeaveTimeout,
					pInterface->JoinTimeout,
					(PVOID)pJoinEntry
					);
				
				AA_REF_JE(pJoinEntry);	// Wait for Join completion - pended join
	
				pJoinEntry->RetriesLeft = pInterface->MaxJoinOrLeaveAttempts - 1;
			

				pPair++;
			}
		}

		AA_ASSERT(pPair == pPairEnd);

		//
		// But just in case  ....
		//
		if (pPair < pPairEnd)
		{
			//
			// Only send joins for as many as we've copied over.
			//
			pPairEnd = pPair;
		}

		//
		// Now actually send the JOIN entries. Note that the interface
		// lock is released/reacquired once per iteration.
		//
		for (pPair = DestArray;
 			 pPair < pPairEnd;
 			 pPair++)

		{
				AtmArpMcSendJoinOrLeave(
					pInterface,
					AA_MARS_OP_TYPE_JOIN,
					&(pPair->IPAddress),
					pPair->Mask
					);
				//
				//  IF Lock is released within the above.
				//
	
				AA_ACQUIRE_IF_LOCK(pInterface);
		}

		AA_FREE_MEM(DestArray);
		DestArray = NULL;
	}


	AA_RELEASE_IF_LOCK(pInterface);

}


VOID
AtmArpMcRevalidateAll(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	An event has happened that needs us to revalidate all group information.
	The RFC says that we should set the REVALIDATE flag on all groups at a
	random time between 1 and 10 seconds. We implement this by starting
	"random" timers on all groups.

Arguments:

	pInterface			- Interface on which revalidation is to be done

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;

	AAMCDEBUGP(AAD_INFO, ("McRevalidateAll on IF 0x%x\n", pInterface));

	AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

	//
	//  Go through the list of IP Entries representing multicast addresses
	//  that we send to.
	//
	for (pIpEntry = pInterface->pMcSendList;
 		 pIpEntry != NULL_PATMARP_IP_ENTRY;
 		 pIpEntry = pIpEntry->pNextMcEntry)
	{
		AA_ASSERT(AA_IS_FLAG_SET(pIpEntry->Flags,
							AA_IP_ENTRY_ADDR_TYPE_MASK,
							AA_IP_ENTRY_ADDR_TYPE_NUCAST));
		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

		if (AA_IS_FLAG_SET(pIpEntry->Flags,
							AA_IP_ENTRY_MC_RESOLVE_MASK,
							AA_IP_ENTRY_MC_RESOLVED))
		{
			ULONG	RandomDelay;
			BOOLEAN	WasRunning;

			WasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);

			RandomDelay =  AA_GET_RANDOM(
								pInterface->MinRevalidationDelay,
								pInterface->MaxRevalidationDelay);
			AAMCDEBUGP(AAD_LOUD,
				("McRevalidateAll: pIpEntry 0x%x/0x%x, Addr: %d.%d.%d.%d, pAtmEntry 0x%x\n",
					pIpEntry, pIpEntry->Flags,
					((PUCHAR)&(pIpEntry->IPAddress))[0],
					((PUCHAR)&(pIpEntry->IPAddress))[1],
					((PUCHAR)&(pIpEntry->IPAddress))[2],
					((PUCHAR)&(pIpEntry->IPAddress))[3],
					pIpEntry->pAtmEntry));

			AtmArpStartTimer(
				pInterface,
				&(pIpEntry->Timer),
				AtmArpMcRevalidationDelayTimeout,
				RandomDelay,
				(PVOID)pIpEntry
				);

			if (!WasRunning)
			{
				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref
			}
		}

		AA_RELEASE_IE_LOCK(pIpEntry);
	}

	AA_RELEASE_IF_TABLE_LOCK(pInterface);


}


VOID
AtmArpMcHandleMARSFailure(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						IsRegnFailure
)
/*++

Routine Description:

	Handle a MARS failure, as per Section 5.4.1 etc in RFC 2022.
	On seeing the first failure, we assume that there is a transient
	problem with the MARS, so we try to re-register. If we fail to do
	so, we pick up the next MARS in our configured list. If no such
	MARS exists, then we wait for a while before retrying registration.

Arguments:

	pInterface			- Interface on which MARS failure has been detected.
	IsRegnFailure		- Is this a failure in registering?

Return Value:

	None

--*/
{
	BOOLEAN						WasRunning;
	ULONG						rc;
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;
	PATMARP_IPMC_JOIN_ENTRY *	ppJoinEntry;

	AAMCDEBUGP(AAD_INFO, ("HandleMARSFailure: pIf 0x%x, Flags 0x%x, RegnFailure=%d\n",
			pInterface, pInterface->Flags, IsRegnFailure));

	AA_ACQUIRE_IF_LOCK(pInterface);

	//
	//  Stop the MC timer running on this Interface.
	//
	WasRunning = AtmArpStopTimer(&(pInterface->McTimer), pInterface);
	if (WasRunning)
	{
		rc = AtmArpDereferenceInterface(pInterface);	// MC Timer ref
		AA_ASSERT(rc != 0);
	}

	if (AA_IS_FLAG_SET(pInterface->Flags,
						AAMC_IF_MARS_FAILURE_MASK,
						AAMC_IF_MARS_FAILURE_NONE))
	{
		//
		//  First failure. Do some housekeeping, and re-register with
		//  the MARS.
		//
		AA_SET_FLAG(pInterface->Flags,
					AAMC_IF_MARS_FAILURE_MASK,
					AAMC_IF_MARS_FAILURE_FIRST_RESP);

		//
		//  Clean up all our JOIN Entries.
		//
		ppJoinEntry = &(pInterface->pJoinList);
		while (*ppJoinEntry != NULL_PATMARP_IPMC_JOIN_ENTRY)
		{
			pJoinEntry = *ppJoinEntry;
			WasRunning = AtmArpStopTimer(&(pJoinEntry->Timer), pInterface);

			if (WasRunning)
			{
				rc = AA_DEREF_JE(pJoinEntry);	// MARS failure; stopped timer
				AA_ASSERT(rc != 0);
			}

			if (AA_IS_FLAG_SET(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_LEAVING))
			{
				//
				//  Delete this because it is leaving.
				//
				*ppJoinEntry = pJoinEntry->pNextJoinEntry;
				AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pJoinEntry->Timer));
				AA_DEREF_JE(pJoinEntry);	// MARS Failure; get rid of leaving entry
			}
			else
			{
				//
				//  Mark this as "pending" so that we will re-join
				//  this group as soon as we complete re-registration.
				//
				AA_SET_FLAG(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_PENDING);

				ppJoinEntry = &(pJoinEntry->pNextJoinEntry);
			}
		}

		//
		//  Prime the IF state so that registration can happen.
		//
		AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_NOT_REGISTERED);

		AtmArpMcStartRegistration(pInterface);
		//
		//  IF Lock is released within the above.
		//
					
	}
	else if  (pInterface->AdminState == IF_STATUS_UP)
	{
		//
		//  Check if this is a failure to re-register.
		//
		if (AA_IS_FLAG_SET(pInterface->Flags,
					AAMC_IF_MARS_FAILURE_MASK,
					AAMC_IF_MARS_FAILURE_FIRST_RESP) ||
			IsRegnFailure)
		{
			//
			//  Absolutely no hope for this MARS. If we have more entries in
			//  the MARS list, move to the next one. In any case, delay for
			//  atleast 1 minute before re-registering.
			//
			if (pInterface->pCurrentMARS->pNext != (PATMARP_SERVER_ENTRY)NULL)
			{
				pInterface->pCurrentMARS = pInterface->pCurrentMARS->pNext;
			}
			else
			{
				pInterface->pCurrentMARS = pInterface->MARSList.pList;
			}
		}

		AA_SET_FLAG(pInterface->Flags,
					AAMC_IF_MARS_FAILURE_MASK,
					AAMC_IF_MARS_FAILURE_SECOND_RESP);

		AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_DELAY_B4_REGISTERING);

		AtmArpStartTimer(
			pInterface,
			&(pInterface->McTimer),
			AtmArpMcMARSReconnectTimeout,
			pInterface->MARSConnectInterval,
			(PVOID)pInterface
			);

		AtmArpReferenceInterface(pInterface);	// MC Timer ref

		AA_RELEASE_IF_LOCK(pInterface);
	}
	else
	{
		//
		// AdminStatus is not UP -- don't try to re-register.
		//
		AA_RELEASE_IF_LOCK(pInterface);
	}

}



VOID
AtmArpMcSendToMARS(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	Send the given packet to MARS on the specified interface.

	NOTE: The caller is assumed to have acquired the Interface lock, which
	will be released here.

Arguments:

	pInterface			- Interface on which the MARS message is to be sent.
	pNdisPacket			- Points to packet to be sent. This is assumed to be
						  allocated by ourselves.

Return Value:

	None

--*/
{
	PATMARP_ATM_ENTRY		pAtmEntry;
	PATMARP_VC				pVc;
	PATMARP_FLOW_SPEC		pFlowSpec;
	NDIS_STATUS				Status;
	ULONG					rc;

	AA_ASSERT(pInterface->pCurrentMARS != NULL_PATMARP_SERVER_ENTRY);
	pAtmEntry = pInterface->pCurrentMARS->pAtmEntry;

	AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);

	AAMCDEBUGP(AAD_EXTRA_LOUD,
		("SendToMars: pIf 0x%x, NdisPkt 0x%x, MARS ATM Entry 0x%x\n",
				pInterface, pNdisPacket, pAtmEntry));

	AA_RELEASE_IF_LOCK(pInterface);
	AA_ACQUIRE_AE_LOCK(pAtmEntry);

	//
	//  Get at the best effort VC going to this address
	//

	pVc = pAtmEntry->pBestEffortVc;

	if (pVc != NULL_PATMARP_VC)
	{
		//
		//  Nail down the VC.
		//
		AA_ACQUIRE_VC_LOCK_DPC(pVc);
		AtmArpReferenceVc(pVc);	// temp ref
		AA_RELEASE_VC_LOCK_DPC(pVc);

		AA_RELEASE_AE_LOCK(pAtmEntry);	// Not needed anymore

		//
		//  We found a VC to MARS. Make sure it is still around, and send the
		//  packet on it.
		//
		AA_ACQUIRE_VC_LOCK(pVc);

		rc = AtmArpDereferenceVc(pVc);	// temp ref

		if (rc != 0)
		{
			AtmArpSendPacketOnVc(pVc, pNdisPacket);
			//
			//  The VC lock is released in SendPacketOnVc
			//
		}
		else
		{
			//
			//  The VC has been deref'ed away! Set up "pVc" for the check
			//  coming up.
			//
			pVc = NULL_PATMARP_VC;
			AA_ACQUIRE_AE_LOCK(pAtmEntry);
		}
	}

	if (pVc == NULL_PATMARP_VC)
	{
		//
		//  We don't have an appropriate VC to the MARS, so create
		//  one, and queue this packet for transmission as soon as
		//  the call is made.
		//
		//  AtmArpMakeCall needs the caller to hold the ATM Entry lock.
		//
		AA_GET_CONTROL_PACKET_SPECS(pInterface, &pFlowSpec);
		Status = AtmArpMakeCall(
						pInterface,
						pAtmEntry,
						pFlowSpec,
						pNdisPacket
						);
		//
		//  The AE lock is released within the above.
		//
	}


}

VOID
AtmArpMcSendJoinOrLeave(
	IN	PATMARP_INTERFACE			pInterface,
	IN	USHORT						OpCode,
	IN	PIP_ADDRESS					pIpAddress 	OPTIONAL,
	IN	IP_ADDRESS					Mask
)
/*++

Routine Description:

	Send a MARS_JOIN or MARS_LEAVE to the MARS on the specified interface.
	If no IP address is given, then this message is being sent to (de)-register
	ourselves with the MARS. Otherwise, we are Joining/Leaving the multicast
	group(s) indicated by the IP address and mask.

	NOTE: The caller is assumed to have acquired the Interface lock, which
	will be released here.

Arguments:

	pInterface			- Interface on which the MARS message is to be sent.
	OpCode				- JOIN or LEAVE
	pIpAddress			- Optional pointer to first IP address in block
						  of Class D IP addresses being Joined/Left. NULL if
						  the JOIN/LEAVE message is being sent in order to
						 (de)register.
	Mask				- Defines the block [*pIpAddress to (*pIpAddress | Mask)]
						  of IP addresses being Joined/Left, if pIpAddress isn't
						  NULL.

Return Value:

	None

--*/
{
	PNDIS_PACKET				pNdisPacket;
	PNDIS_BUFFER				pNdisBuffer;
	ULONG						BufferLength;
	PAA_MARS_JOIN_LEAVE_HEADER	pPkt;
	PUCHAR						pNextToFill;	// Next field to fill in packet
	IP_ADDRESS					MaxIPAddress;	// being joined

	BufferLength = sizeof(AA_MARS_JOIN_LEAVE_HEADER) +
						 pInterface->LocalAtmAddress.NumberOfDigits;

	AA_RELEASE_IF_LOCK(pInterface);

#if DBG
	if (pIpAddress != (PIP_ADDRESS)NULL)
	{
		AAMCDEBUGP(AAD_VERY_LOUD,
			("SendJoinOrLeave: pIf 0x%x, Op %d, IP Address: %d.%d.%d.%d\n",
					pInterface, OpCode,
					((PUCHAR)pIpAddress)[0],
					((PUCHAR)pIpAddress)[1],
					((PUCHAR)pIpAddress)[2],
					((PUCHAR)pIpAddress)[3]));
	}
	else
	{
		AAMCDEBUGP(AAD_VERY_LOUD,
			("SendJoinOrLeave: pIf 0x%x, Op %d, No IP Address\n",
					pInterface, OpCode));
	}
#endif // DBG

	if (pIpAddress != (PIP_ADDRESS)NULL)
	{
		BufferLength += (2 * AA_IPV4_ADDRESS_LENGTH);
	}

	//
	//  Allocate packet
	//
	pNdisPacket = AtmArpAllocatePacket(pInterface);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Allocate buffer
		//
		pNdisBuffer = AtmArpAllocateProtoBuffer(
							pInterface,
							BufferLength,
							(PUCHAR *)&pPkt
							);

		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

			AA_SET_MEM((PUCHAR)pPkt, 0, BufferLength);

			//
			//  Fill in fixed fields first.
			//
			AA_COPY_MEM((PUCHAR)pPkt,
						(PUCHAR)&AtmArpMcMARSFixedHeader,
						sizeof(AtmArpMcMARSFixedHeader));

			pPkt->op = NET_SHORT(OpCode);
			pPkt->shtl = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));
			if (pIpAddress != (PIP_ADDRESS)NULL)
			{
				pPkt->tpln = AA_IPV4_ADDRESS_LENGTH;
			}

			//
			//  The only addresses we fill in are Source ATM Number and
			//  Target multicast group address.
			//
			pNextToFill = (PUCHAR)pPkt + sizeof(AA_MARS_JOIN_LEAVE_HEADER);

			//
			//  Source ATM Number:
			//
			AA_COPY_MEM(pNextToFill,
						(pInterface->LocalAtmAddress.Address),
						pInterface->LocalAtmAddress.NumberOfDigits);

			pNextToFill += pInterface->LocalAtmAddress.NumberOfDigits;

			//
			//  Target Multicast Group Address:
			//
			if (pIpAddress != (PIP_ADDRESS)NULL)
			{
				//
				//  Joining a layer 3 group
				//
				pPkt->pnum = HOST_TO_NET_SHORT(1);
				pPkt->flags |= AA_MARS_JL_FLAG_LAYER3_GROUP;

				//
				//  Fill in one <Min, Max> pair: "Min" value first:
				//
				AA_COPY_MEM(pNextToFill,
							pIpAddress,
							AA_IPV4_ADDRESS_LENGTH);
				pNextToFill += AA_IPV4_ADDRESS_LENGTH;

				//
				//  Compute the "Max" value, and fill it in.
				//
				MaxIPAddress = *pIpAddress | Mask;
				AA_COPY_MEM(pNextToFill,
							&(MaxIPAddress),
							AA_IPV4_ADDRESS_LENGTH);
			}
			else
			{
				//
				//  Registering as a Cluster Member
				//
				pPkt->flags |= AA_MARS_JL_FLAG_REGISTER;
			}

			AA_ACQUIRE_IF_LOCK(pInterface);

			AtmArpMcSendToMARS(
				pInterface,
				pNdisPacket
				);
			//
			//  IF Lock is released within the above.
			//
		}
		else
		{
			AtmArpFreePacket(pInterface, pNdisPacket);
		}
	}

}



VOID
AtmArpMcSendRequest(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PIP_ADDRESS					pIpAddress
)
/*++

Routine Description:

	Send a MARS Request to resolve a multicast group address, on the specified
	interface.


Arguments:

	pInterface			- Interface on which the MARS message is to be sent.
	pIpAddress			- Pointer to Address to be resolved.

Return Value:

	None

--*/
{
	PNDIS_PACKET			pNdisPacket;
	PNDIS_BUFFER			pNdisBuffer;
	ULONG					BufferLength;
	PAA_MARS_REQ_NAK_HEADER	pPkt;

	AAMCDEBUGP(AAD_LOUD,
		("McSendRequest: pIf 0x%x, IP Address: %d.%d.%d.%d\n",
				pInterface,
				((PUCHAR)pIpAddress)[0],
				((PUCHAR)pIpAddress)[1],
				((PUCHAR)pIpAddress)[2],
				((PUCHAR)pIpAddress)[3]));

	BufferLength = sizeof(AA_MARS_REQ_NAK_HEADER) +
						 pInterface->LocalAtmAddress.NumberOfDigits +
						 AA_IPV4_ADDRESS_LENGTH;

	//
	//  Allocate packet
	//
	pNdisPacket = AtmArpAllocatePacket(pInterface);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Allocate buffer
		//
		pNdisBuffer = AtmArpAllocateProtoBuffer(
							pInterface,
							BufferLength,
							(PUCHAR *)&pPkt
							);

		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

			AA_SET_MEM((PUCHAR)pPkt, 0, BufferLength);

			//
			//  Fill in fixed fields first.
			//
			AA_COPY_MEM((PUCHAR)pPkt,
						(PUCHAR)&AtmArpMcMARSFixedHeader,
						sizeof(AtmArpMcMARSFixedHeader));

			pPkt->op = NET_SHORT(AA_MARS_OP_TYPE_REQUEST);
			pPkt->shtl = AA_PKT_ATM_ADDRESS_TO_TYPE_LEN(&(pInterface->LocalAtmAddress));
			pPkt->tpln = AA_IPV4_ADDRESS_LENGTH;

			//
			//  The only addresses we fill in are Source ATM Number and
			//  Target multicast group address.
			//

			//
			//  Source ATM Number:
			//
			AA_COPY_MEM((PUCHAR)pPkt + sizeof(AA_MARS_REQ_NAK_HEADER),
						(pInterface->LocalAtmAddress.Address),
						pInterface->LocalAtmAddress.NumberOfDigits);
			
			//
			//  Target Multicast Group Address:
			//
			AA_COPY_MEM((PUCHAR)pPkt + sizeof(AA_MARS_REQ_NAK_HEADER) +
							pInterface->LocalAtmAddress.NumberOfDigits,
						pIpAddress,
						AA_IPV4_ADDRESS_LENGTH);


			AA_ACQUIRE_IF_LOCK(pInterface);

			AtmArpMcSendToMARS(
				pInterface,
				pNdisPacket
				);
			//
			//  IF Lock is released within the above.
			//
		}
		else
		{
			AtmArpFreePacket(pInterface, pNdisPacket);
		}
	}

}



PATMARP_IPMC_ATM_ENTRY
AtmArpMcLookupAtmMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY *	ppMcAtmList,
	IN	PUCHAR						pAtmNumber,
	IN	ULONG						AtmNumberLength,
	IN	ATM_ADDRESSTYPE				AtmNumberType,
	IN	PUCHAR						pAtmSubaddress,
	IN	ULONG						AtmSubaddressLength,
	IN	BOOLEAN						CreateNew
)
/*++

Routine Description:

	Check if the specified ATM endstation is a member of the list of
	ATM addresses associated with a Multicast entry. If so, return
	a pointer to the entry for this endstation. If not, create a new
	entry conditionally and return a pointer to this.

	NOTE: the ATM Entry is assumed to be locked by the caller.

Arguments:

	pAtmEntry			- ATM Entry to which the member will be added
	ppMcAtmList			- Points to start of list to search in.
	pAtmNumber			- Pointer to ATM address for this endstation
	AtmNumberLength		- Length of above
	AtmNumberType		- Type of above
	pAtmSubaddress		- Pointer to ATM Subaddress for this endstation
	AtmSubaddressLength	- Length of above
	CreateNew			- Should we create a new entry if not found?

Return Value:

	Pointer to the (possibly new) ATM MC Entry for the specified leaf.

--*/
{
	PATMARP_IPMC_ATM_ENTRY	pMcAtmEntry;
	BOOLEAN					Found;

	Found = FALSE;

	for (pMcAtmEntry = *ppMcAtmList;
		 pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
		 pMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry)
	{
		//
		//  Compare ATM Numbers
		//
		if ((pMcAtmEntry->ATMAddress.NumberOfDigits == AtmNumberLength) &&
			(pMcAtmEntry->ATMAddress.AddressType == AtmNumberType) &&
			(AA_MEM_CMP(pMcAtmEntry->ATMAddress.Address, pAtmNumber, AtmNumberLength) == 0))
		{
			//
			//  Compare subaddresses
			//
			if ((pMcAtmEntry->ATMSubaddress.NumberOfDigits == AtmSubaddressLength) &&
				(AA_MEM_CMP(pMcAtmEntry->ATMSubaddress.Address,
							pAtmSubaddress,
							AtmSubaddressLength) == 0))
			{
				Found = TRUE;
				break;
			}
		}
	}

	if ((!Found) && CreateNew)
	{
		AA_ALLOC_MEM(pMcAtmEntry, ATMARP_IPMC_ATM_ENTRY, sizeof(ATMARP_IPMC_ATM_ENTRY));
		if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
		{
			AA_SET_MEM(pMcAtmEntry, 0, sizeof(ATMARP_IPMC_ATM_ENTRY));

			//
			//  Fill in all that we know.
			//
#if DBG
			pMcAtmEntry->ame_sig = ame_signature;
#endif
			pMcAtmEntry->pAtmEntry = pAtmEntry;

			//
			//  The ATM Address
			//
			pMcAtmEntry->ATMAddress.NumberOfDigits = AtmNumberLength;
			pMcAtmEntry->ATMAddress.AddressType = AtmNumberType;
			AA_COPY_MEM(pMcAtmEntry->ATMAddress.Address, pAtmNumber, AtmNumberLength);

			//
			//  ATM Subaddress
			//
			pMcAtmEntry->ATMSubaddress.NumberOfDigits = AtmSubaddressLength;
			pMcAtmEntry->ATMSubaddress.AddressType = ATM_NSAP;
			AA_COPY_MEM(pMcAtmEntry->ATMSubaddress.Address, pAtmSubaddress, AtmSubaddressLength);

			//
			//  Link it to the list
			//
			pMcAtmEntry->pNextMcAtmEntry = *ppMcAtmList;
			*ppMcAtmList = pMcAtmEntry;
			pAtmEntry->pMcAtmInfo->NumOfEntries++;

			//
			//  Bump up ref count on this ATM Entry
			//
			AA_REF_AE(pAtmEntry, AE_REFTYPE_MCAE);	// New McAtmEntry added
		}
	}

	AAMCDEBUGP(AAD_VERY_LOUD,
		("McLookupAtmMember: pAtmEntry 0x%x, %s pMcAtmEntry 0x%x\n",
			pAtmEntry, (!Found)? "New": "Old", pMcAtmEntry));

#if DBG
	if (pMcAtmEntry && (pAtmEntry->pIpEntryList))
	{
		AAMCDEBUGPMAP(AAD_INFO, ((!Found)? "Added " : "Found "),
					&pAtmEntry->pIpEntryList->IPAddress,
					&pMcAtmEntry->ATMAddress);
	}
#endif // DBG

	return (pMcAtmEntry);
}


VOID
AtmArpMcUnlinkAtmMember(
	IN	PATMARP_ATM_ENTRY			pAtmEntry,
	IN	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry
)
/*++

Routine Description:

	Delete an ATM destination from the list of members of a multicast group.
	We stop the timer (if running) associated with this Multicast entry and delink the entry
	from the list of destinations, and free the structure.

	NOTE: the caller is assumed to hold a lock to the ATM Entry.

Arguments:

	pAtmEntry			- ATM Entry from which to delete the member
	pMcAtmEntry			- The entry to be deleted

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_ENTRY *	ppMcAtmEntry;
	ULONG						rc;

	AA_ASSERT(pAtmEntry->pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);

	AA_ASSERT(AA_IS_FLAG_SET(pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_DISCONNECTED));

	AAMCDEBUGP(AAD_LOUD, ("UnlinkAtmMember: pAtmEntry 0x%x, pMcAtmEntry 0x%x\n",
					pAtmEntry, pMcAtmEntry));

	//
	//  Stop any timer running here.
	//
	if (AA_IS_TIMER_ACTIVE(&(pMcAtmEntry->Timer)))
	{
		(VOID)AtmArpStopTimer(&(pMcAtmEntry->Timer), pAtmEntry->pInterface);
	}
		
	for (ppMcAtmEntry = &(pAtmEntry->pMcAtmInfo->pMcAtmEntryList);
		 *ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
		 ppMcAtmEntry = &((*ppMcAtmEntry)->pNextMcAtmEntry))
	{
		if (*ppMcAtmEntry == pMcAtmEntry)
		{
			//
			//  Delink now.
			//
			*ppMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;
			break;
		}

		AA_ASSERT(*ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY);
	}

	AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pMcAtmEntry->Timer));
	AA_CHECK_TIMER_IN_ACTIVE_LIST(&pMcAtmEntry->Timer, pAtmEntry->pInterface, pMcAtmEntry, "MC ATM Entry");
	AA_FREE_MEM(pMcAtmEntry);

	pAtmEntry->pMcAtmInfo->NumOfEntries--;
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_MCAE);	// Unlink MC ATM Entry
	AA_ASSERT(rc!=0);// We always expect caller will retain a reference to pAtmEntry.
}


VOID
AtmArpMcUpdateConnection(
	IN	PATMARP_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Update our outgoing Point to Multipoint connection for the multicast
	group represented by the given IP Entry.

	If no call exists, and there is atleast one valid entry in the list
	of remote ATM addresses for this group, then we place an outgoing call.

	If an outgoing call exists, then we go through the list of remote
	ATM addresses. Each address that isn't participating in the call,
	and is Valid gets added as a leaf to the call. Each address that has
	been invalidated gets deleted.

	NOTE: The caller is assumed to have acquired the ATM_ENTRY lock;
	it will be released here.

Arguments:

	pAtmEntry			- ATM Entry representing multicast group on which
						  to update the PMP connection.

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_INFO		pMcAtmInfo;
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_IPMC_ATM_ENTRY		pNextMcAtmEntry;
	ULONG						rc;

	PATMARP_IP_ENTRY			pIpEntry;
	PATMARP_INTERFACE			pInterface;
	PATMARP_FLOW_INFO			pFlowInfo;
	PATMARP_FLOW_SPEC			pFlowSpec;
	PATMARP_FILTER_SPEC			pFilterSpec;
	PNDIS_PACKET				pNdisPacket;
	BOOLEAN						Closing = FALSE;

	AAMCDEBUGP(AAD_LOUD,
		("McUpdateConn: pAtmEntry 0x%x/0x%x, pMcAtmInfo 0x%x/0x%x\n",
			pAtmEntry, pAtmEntry->Flags,
			pAtmEntry->pMcAtmInfo, pAtmEntry->pMcAtmInfo->Flags));
		
	pMcAtmInfo = pAtmEntry->pMcAtmInfo;
	AA_ASSERT(pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);
	AA_ASSERT(pMcAtmInfo->pMcAtmEntryList != NULL_PATMARP_IPMC_ATM_ENTRY);
	AA_ASSERT(AA_IS_FLAG_SET(pAtmEntry->Flags,
							 AA_ATM_ENTRY_TYPE_MASK,
							 AA_ATM_ENTRY_TYPE_NUCAST));

	//
	//  Add a temp reference to the ATM Entry so that it can't go
	//  away for the duration of this routine.
	//
	AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);	// temp ref

	do
	{
		if (pAtmEntry->pVcList && AA_IS_FLAG_SET(pAtmEntry->pVcList->Flags,
									AA_VC_CLOSE_STATE_MASK,
									AA_VC_CLOSE_STATE_CLOSING))
		{
			//
			// Bail out.
			//
			pMcAtmInfo->Flags &= ~AA_IPMC_AI_WANT_UPDATE;
			Closing = TRUE;
			break;
		}


		//
		//  Mark this entry as needing a connection update.
		//
		pMcAtmInfo->Flags |= AA_IPMC_AI_WANT_UPDATE;

		//
		//  If a connection update is in progress, don't do
		//  anything more. The thread that's doing the update
		//  will see that another update is needed, and do it.
		//
		if (pMcAtmInfo->Flags & AA_IPMC_AI_BEING_UPDATED)
		{
			break;
		}

		//
		//  Mark this entry so that we don't have more than one
		//  thread proceeding beyond here.
		//
		pMcAtmInfo->Flags |= AA_IPMC_AI_BEING_UPDATED;

		while (pMcAtmInfo->Flags & AA_IPMC_AI_WANT_UPDATE)
		{
			pMcAtmInfo->Flags &= ~AA_IPMC_AI_WANT_UPDATE;

			if (AA_IS_FLAG_SET(
						pMcAtmInfo->Flags,
						AA_IPMC_AI_CONN_STATE_MASK,
						AA_IPMC_AI_CONN_NONE))
			{
				PATMARP_IPMC_ATM_ENTRY *	ppMcAtmEntry;

				//
				//  No connection exists; create one.
				//

				//
				//  First, find an MC ATM Entry that is valid and disconnected.
				//  We are mainly concerned with avoiding entries that are running
				//  a party-retry delay timer.
				//
				for (ppMcAtmEntry = &pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
 					*ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
 					ppMcAtmEntry = &((*ppMcAtmEntry)->pNextMcAtmEntry))
				{
					pMcAtmEntry = *ppMcAtmEntry;

					if (AA_IS_FLAG_SET(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_VALID) &&
						AA_IS_FLAG_SET(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_DISCONNECTED))
					{
						break;
					}
				}

				//
				//  Bail out if we don't find one.
				//
				if (*ppMcAtmEntry == NULL_PATMARP_IPMC_ATM_ENTRY)
				{
					AAMCDEBUGP(AAD_INFO,
						("McUpdateConn: pAtmEntry %x, pMcAtmInfo %x, no valid MC ATM Entry to make call on!\n",
							pAtmEntry, pMcAtmInfo));
					break;
				}

				//
				//  We found one. Remove it from its current position and
				//  move it to the top of the list. This is for the benefit
				//  of AtmArpMakeCall, which picks up the first MC ATM Entry
				//  as the party context for the call.
				//

				//
				//  Unlink from current position.
				//
				*ppMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

				//
				//  Insert at top of list.
				//
				pMcAtmEntry->pNextMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
				pAtmEntry->pMcAtmInfo->pMcAtmEntryList = pMcAtmEntry;

				AAMCDEBUGP(AAD_VERY_LOUD,
				 ("McUpdateConn: No conn exists: pIpEnt 0x%x, pMcAtmInfo 0x%x\n",
							pAtmEntry->pIpEntryList, pMcAtmInfo));

				AA_ASSERT(pAtmEntry->pVcList == NULL_PATMARP_VC);

				AA_SET_FLAG(
						pMcAtmInfo->Flags,
						AA_IPMC_AI_CONN_STATE_MASK,
						AA_IPMC_AI_CONN_WACK_MAKE_CALL);

				AA_SET_FLAG(
						pMcAtmEntry->Flags,
						AA_IPMC_AE_CONN_STATE_MASK,
						AA_IPMC_AE_CONN_WACK_ADD_PARTY);

				//
				//  Get the flow spec for this call from one of the packets
				//  queued on the IP entry.
				//
				pInterface = pAtmEntry->pInterface;
				pIpEntry = pAtmEntry->pIpEntryList;

				if (pIpEntry != NULL_PATMARP_IP_ENTRY)
				{
					pNdisPacket = pIpEntry->PacketList;
					if (pNdisPacket != NULL)
					{
						AA_GET_PACKET_SPECS(pInterface,
											pNdisPacket, 
											&pFlowInfo,
											&pFlowSpec,
											&pFilterSpec);
					}
					else
					{
						pFlowSpec = &(pInterface->DefaultFlowSpec);
					}
				}
				else
				{
					pFlowSpec = &(pInterface->DefaultFlowSpec);
				}

				AtmArpMakeCall(
						pInterface,
						pAtmEntry,
						pFlowSpec,
						(PNDIS_PACKET)NULL
						);
				//
				//  the ATM Entry lock is released within the above.
				//
				AA_ACQUIRE_AE_LOCK(pAtmEntry);
				break;
			}
			else if (AA_IS_FLAG_SET(
						pMcAtmInfo->Flags,
						AA_IPMC_AI_CONN_STATE_MASK,
						AA_IPMC_AI_CONN_WACK_MAKE_CALL))
			{
				//
				//  Don't do anything till the first connection
				//  is established.
				//
				break;
			}
			else if (AA_IS_FLAG_SET(
						pMcAtmInfo->Flags,
						AA_IPMC_AI_CONN_STATE_MASK,
						AA_IPMC_AI_CONN_ACTIVE))
			{
				//
				//  The PMP connection exists. Go through the list
				//  of ATM MC Entries, and:
				//  1 - Add valid ones which aren't leaves yet
				//  2 - Delete invalid ones
				//

				// #1: add validated leaves

				for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
 					pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
 					pMcAtmEntry = pNextMcAtmEntry)
				{
					pNextMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

					if (AA_IS_FLAG_SET(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_VALID) &&
						AA_IS_FLAG_SET(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_CONN_STATE_MASK,
							AA_IPMC_AE_CONN_DISCONNECTED))
					{
						AAMCDEBUGP(AAD_VERY_LOUD, ("McUpdateConn: pAtmEnt 0x%x, Adding Pty pMcAtmEnt 0x%x\n",
								pAtmEntry, pMcAtmEntry));

						AtmArpAddParty(
							pAtmEntry,
							pMcAtmEntry
							);
						//
						//  ATM Entry lock is released within the above.
						//
						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						pMcAtmInfo->Flags |= AA_IPMC_AI_WANT_UPDATE;
						break;
					}

				} // for

				// #2: delete invalid leaves

				for (pMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
 					pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY;
 					pMcAtmEntry = pNextMcAtmEntry)
				{
					pNextMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

					if (AA_IS_FLAG_SET(
							pMcAtmEntry->Flags, 
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_INVALID))
					{
						AAMCDEBUGP(AAD_VERY_LOUD, ("McUpdateConn: pAtmEnt 0x%x, Terminating 0x%x\n",
							pAtmEntry, pMcAtmEntry));

						AAMCDEBUGPMAP(AAD_INFO,
							"Deleting ", &pAtmEntry->pIpEntryList->IPAddress,
							&pMcAtmEntry->ATMAddress);

						AtmArpMcTerminateMember(
							pAtmEntry,
							pMcAtmEntry
							);
						//
						//  ATM Entry lock is released within the above.
						//
						AA_ACQUIRE_AE_LOCK(pAtmEntry);
						pMcAtmInfo->Flags |= AA_IPMC_AI_WANT_UPDATE;
						break;
					}

				} // for

			} // if Connection is active
			//
			//  else we may be waiting for a while after seeing
			//  a transient connection failure on the first MakeCall.
			//

		} // while more connection updates needed

		AA_SET_FLAG(pMcAtmInfo->Flags,
					AA_IPMC_AI_CONN_UPDATE_MASK,
					AA_IPMC_AI_NO_UPDATE);

		break;

	}
	while (FALSE);


	//
	//  Remove the temp reference on the ATM Entry:
	//
	rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);	// temp ref

	if (rc != 0)
	{
		BOOLEAN				ClearToSend;
		PATMARP_IP_ENTRY	pIpEntry;
		PATMARP_INTERFACE	pInterface;
		PNDIS_PACKET		pPacketList;

		ClearToSend = ((pMcAtmInfo->TransientLeaves == 0) &&
					   !Closing							  &&
					   (AA_IS_FLAG_SET(pMcAtmInfo->Flags,
					   				   AA_IPMC_AI_CONN_STATE_MASK,
					   				   AA_IPMC_AI_CONN_ACTIVE)));

		pIpEntry = pAtmEntry->pIpEntryList;
		pInterface = pAtmEntry->pInterface;
		AA_RELEASE_AE_LOCK(pAtmEntry);

		if (ClearToSend && pIpEntry)
		{
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			pPacketList = pIpEntry->PacketList;
			pIpEntry->PacketList = (PNDIS_PACKET)NULL;
			AA_RELEASE_IE_LOCK(pIpEntry);

			if (pPacketList != (PNDIS_PACKET)NULL)
			{
				AAMCDEBUGP(AAD_INFO, ("UpdateConn: pAtmEntry 0x%x, sending pktlist 0x%x\n",
						pAtmEntry, pPacketList));

				AtmArpSendPacketListOnAtmEntry(
						pInterface,
						pAtmEntry,
						pPacketList,
						TRUE	// IsBroadcast
						);
			}
		}

	}
	//
	//  else the ATM Entry is gone.
	//

}



#endif // IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\macros.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    macros.h

Abstract:

	Macros for the ATMARP module

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    arvindm     05-20-96    created

Notes:


--*/
#ifndef __ATMARP_MACROS_H_INCLUDED
#define __ATMARP_MACROS_H_INCLUDED

#include "atmarp.h"

#define INCR_STAT(_x)	NdisInterlockedIncrement(&(_x))

#ifndef MAX

/*++
OPAQUE
MAX(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MAX(Fred, Shred)		(((Fred) > (Shred)) ? (Fred) : (Shred))

#endif // MAX


#ifndef MIN

/*++
OPAQUE
MIN(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MIN(Fred, Shred)		(((Fred) < (Shred)) ? (Fred) : (Shred))

#endif // MIN


/*++
ULONG
ATMARP_HASH(
	IN	IP_ADDRESS	IpAddress
)
--*/
#define ATMARP_HASH(IpAddress)	\
			(((ULONG)(IpAddress)) % ATMARP_TABLE_SIZE)


/*++
VOID
AA_SET_FLAG(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define AA_SET_FLAG(Flags, Mask, Val)	\
			(Flags) = ((Flags) & ~(Mask)) | (Val)


/*++
BOOLEAN
AA_IS_FLAG_SET(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define AA_IS_FLAG_SET(Flags, Mask, Val)	\
			(((Flags) & (Mask)) == (Val))

#ifdef IPMCAST

/*++
VOID
AAMC_SET_IF_STATE(
	IN	PATMARP_INTERFACE	_pIf,
	IN	ULONG				_NewState
)
Set the Multicast state for the specified Interface to the given value.
--*/
#define AAMC_SET_IF_STATE(_pIf, _NewState)	\
			AA_SET_FLAG((_pIf)->Flags, AAMC_IF_STATE_MASK, (_NewState))


/*++
ULONG
AAMC_IF_STATE(
	IN	PATMARP_INTERFACE	_pIf
)
Get the Multicast state for the specified Interface.
--*/
#define AAMC_IF_STATE(_pIf)	((_pIf)->Flags & AAMC_IF_STATE_MASK)



#endif // IPMCAST

/*++
VOID
AA_INIT_BLOCK_STRUCT(
	IN	ATMARP_BLOCK	*pBlock
)
--*/
#define AA_INIT_BLOCK_STRUCT(pBlock)		NdisInitializeEvent(&((pBlock)->Event))


/*++
NDIS_STATUS
AA_WAIT_ON_BLOCK_STRUCT(
	IN	ATMARP_BLOCK	*pBlock
)
--*/
#define AA_WAIT_ON_BLOCK_STRUCT(pBlock)		\
			(NdisWaitEvent(&((pBlock)->Event), 0), (pBlock)->Status)


/*++
VOID
AA_SIGNAL_BLOCK_STRUCT(
	IN	ATMARP_BLOCK	*pBlock,
	IN	UINT			Status
)
--*/
#define AA_SIGNAL_BLOCK_STRUCT(pBlock, _Status)	\
			{ (pBlock)->Status = _Status; NdisSetEvent(&((pBlock)->Event)); }


/*++
VOID
AA_FREE_BLOCK_STRUCT(
	IN	ATMARP_BLOCK	*pBlock
)
--*/
#define AA_FREE_BLOCK_STRUCT(pBlock)		// Nothing to be done here


/*++
VOID
AA_INIT_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_INIT_LOCK(pLock)	\
				AtmArpAllocateSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_INIT_LOCK(pLock)	\
				NdisAllocateSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_ACQUIRE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_ACQUIRE_LOCK(pLock)	\
				AtmArpAcquireSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_ACQUIRE_LOCK(pLock)	\
				NdisAcquireSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_ACQUIRE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_ACQUIRE_LOCK_DPC(pLock)	\
				AtmArpAcquireSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_ACQUIRE_LOCK_DPC(pLock)	\
				NdisDprAcquireSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_RELEASE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_RELEASE_LOCK(pLock)		\
				AtmArpReleaseSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_RELEASE_LOCK(pLock)		\
				NdisReleaseSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_RELEASE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define AA_RELEASE_LOCK_DPC(pLock)		\
				AtmArpReleaseSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define AA_RELEASE_LOCK_DPC(pLock)		\
				NdisDprReleaseSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
AA_FREE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#define AA_FREE_LOCK(pLock)			\
				NdisFreeSpinLock(pLock)


/*++
VOID
AA_INIT_IF_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->InterfaceLock))

/*++
VOID
AA_ACQUIRE_IF_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->InterfaceLock))


/*++
VOID
AA_ACQUIRE_IF_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->InterfaceLock))


/*++
VOID
AA_RELEASE_IF_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->InterfaceLock))


/*++
VOID
AA_RELEASE_IF_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->InterfaceLock))


/*++
VOID
AA_FREE_IF_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->InterfaceLock))


/*++
VOID
AA_INIT_IF_TABLE_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_TABLE_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->ArpTableLock))

/*++
VOID
AA_ACQUIRE_IF_TABLE_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_TABLE_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->ArpTableLock))

/*++
VOID
AA_ACQUIRE_IF_TABLE_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_TABLE_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->ArpTableLock))


/*++
VOID
AA_RELEASE_IF_TABLE_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_TABLE_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->ArpTableLock))

/*++
VOID
AA_RELEASE_IF_TABLE_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_TABLE_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->ArpTableLock))


/*++
VOID
AA_FREE_IF_TABLE_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_TABLE_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->ArpTableLock))


/*++
VOID
AA_INIT_IF_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_ATM_LIST_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->AtmEntryListLock))

/*++
VOID
AA_ACQUIRE_IF_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_ATM_LIST_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->AtmEntryListLock))

/*++
VOID
AA_ACQUIRE_IF_ATM_LIST_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_ATM_LIST_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->AtmEntryListLock))


/*++
VOID
AA_RELEASE_IF_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_ATM_LIST_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->AtmEntryListLock))

/*++
VOID
AA_RELEASE_IF_ATM_LIST_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_ATM_LIST_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->AtmEntryListLock))


/*++
VOID
AA_FREE_IF_ATM_LIST_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_ATM_LIST_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->AtmEntryListLock))

/*++
VOID
AA_INIT_IF_TIMER_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_TIMER_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->TimerLock))

/*++
VOID
AA_ACQUIRE_IF_TIMER_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_TIMER_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->TimerLock))

/*++
VOID
AA_ACQUIRE_IF_TIMER_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_TIMER_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->TimerLock))

/*++
VOID
AA_RELEASE_IF_TIMER_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_TIMER_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->TimerLock))

/*++
VOID
AA_RELEASE_IF_TIMER_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_TIMER_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->TimerLock))


/*++
VOID
AA_FREE_IF_TIMER_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_TIMER_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->TimerLock))


/*++
VOID
AA_INIT_VC_LOCK(
	IN PATMARP_VC	pVc
)
--*/
#define AA_INIT_VC_LOCK(pVc)		\
				AA_INIT_LOCK(&((pVc)->Lock))

/*++
VOID
AA_ACQUIRE_VC_LOCK(
	IN PATMARP_VC	pVc
)
--*/
#define AA_ACQUIRE_VC_LOCK(pVc)		\
				AA_ACQUIRE_LOCK(&((pVc)->Lock))

/*++
VOID
AA_ACQUIRE_VC_LOCK_DPC(
	IN PATMARP_VC	pVc
)
--*/
#define AA_ACQUIRE_VC_LOCK_DPC(pVc)		\
				AA_ACQUIRE_LOCK_DPC(&((pVc)->Lock))

/*++
VOID
AA_RELEASE_VC_LOCK(
	IN PATMARP_VC	pVc
)
--*/
#define AA_RELEASE_VC_LOCK(pVc)		\
				AA_RELEASE_LOCK(&((pVc)->Lock))


/*++
VOID
AA_RELEASE_VC_LOCK_DPC(
	IN PATMARP_VC	pVc
)
--*/
#define AA_RELEASE_VC_LOCK_DPC(pVc)		\
				AA_RELEASE_LOCK_DPC(&((pVc)->Lock))

/*++
VOID
AA_FREE_VC_LOCK(
	IN PATMARP_VC	pVc
)
--*/
#define AA_FREE_VC_LOCK(pVc)		\
				AA_FREE_LOCK(&((pVc)->Lock))


/*++
VOID
AA_INIT_AE_LOCK(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_INIT_AE_LOCK(pAtmEntry)		\
				AA_INIT_LOCK(&((pAtmEntry)->Lock))

/*++
VOID
AA_ACQUIRE_AE_LOCK(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_ACQUIRE_AE_LOCK(pAtmEntry)		\
				AA_ACQUIRE_LOCK(&((pAtmEntry)->Lock))

/*++
VOID
AA_ACQUIRE_AE_LOCK_DPC(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry)		\
				AA_ACQUIRE_LOCK_DPC(&((pAtmEntry)->Lock))

/*++
VOID
AA_RELEASE_AE_LOCK(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_RELEASE_AE_LOCK(pAtmEntry)		\
				AA_RELEASE_LOCK(&((pAtmEntry)->Lock))

/*++
VOID
AA_RELEASE_AE_LOCK_DPC(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_RELEASE_AE_LOCK_DPC(pAtmEntry)		\
				AA_RELEASE_LOCK_DPC(&((pAtmEntry)->Lock))

/*++
VOID
AA_FREE_AE_LOCK(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_FREE_AE_LOCK(pAtmEntry)		\
				AA_FREE_LOCK(&((pAtmEntry)->Lock))

/*++
VOID
AA_INIT_IE_LOCK(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_INIT_IE_LOCK(pIpEntry)		\
				AA_INIT_LOCK(&((pIpEntry)->Lock))


/*++
VOID
AA_ACQUIRE_IE_LOCK(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_ACQUIRE_IE_LOCK(pIpEntry)		\
				AA_ACQUIRE_LOCK(&((pIpEntry)->Lock))


/*++
VOID
AA_ACQUIRE_IE_LOCK_DPC(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_ACQUIRE_IE_LOCK_DPC(pIpEntry)		\
				AA_ACQUIRE_LOCK_DPC(&((pIpEntry)->Lock))

/*++
VOID
AA_RELEASE_IE_LOCK(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_RELEASE_IE_LOCK(pIpEntry)		\
				AA_RELEASE_LOCK(&((pIpEntry)->Lock))


/*++
VOID
AA_RELEASE_IE_LOCK_DPC(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_RELEASE_IE_LOCK_DPC(pIpEntry)		\
				AA_RELEASE_LOCK_DPC(&((pIpEntry)->Lock))

/*++
VOID
AA_FREE_IE_LOCK(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_FREE_IE_LOCK(pIpEntry)		\
				AA_FREE_LOCK(&((pIpEntry)->Lock))


/*++
VOID
AA_INIT_GLOBAL_LOCK(
	IN PATMARP_GLOBALS	pGlob
)
--*/
#define AA_INIT_GLOBAL_LOCK(pGlob)		\
				AA_INIT_LOCK(&((pGlob)->Lock))


/*++
VOID
AA_ACQUIRE_GLOBAL_LOCK(
	IN PATMARP_GLOBALS	pGlob
)
--*/
#define AA_ACQUIRE_GLOBAL_LOCK(pGlob)		\
				AA_ACQUIRE_LOCK(&((pGlob)->Lock))


/*++
VOID
AA_RELEASE_GLOBAL_LOCK(
	IN PATMARP_GLOBALS	pGlob
)
--*/
#define AA_RELEASE_GLOBAL_LOCK(pGlob)		\
				AA_RELEASE_LOCK(&((pGlob)->Lock))

/*++
VOID
AA_FREE_GLOBAL_LOCK(
	IN PATMARP_GLOBALS	pGlob
)
--*/
#define AA_FREE_GLOBAL_LOCK(pGlob)		\
				AA_FREE_LOCK(&((pGlob)->Lock))


#ifdef ATMARP_WMI

/*++
VOID
AA_INIT_IF_WMI_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_INIT_IF_WMI_LOCK(pIf)		\
				AA_INIT_LOCK(&((pIf)->WmiLock))

/*++
VOID
AA_ACQUIRE_IF_WMI_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_WMI_LOCK(pIf)		\
				AA_ACQUIRE_LOCK(&((pIf)->WmiLock))


/*++
VOID
AA_ACQUIRE_IF_WMI_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_ACQUIRE_IF_WMI_LOCK_DPC(pIf)		\
				AA_ACQUIRE_LOCK_DPC(&((pIf)->WmiLock))


/*++
VOID
AA_RELEASE_IF_WMI_LOCK(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_WMI_LOCK(pIf)		\
				AA_RELEASE_LOCK(&((pIf)->WmiLock))


/*++
VOID
AA_RELEASE_IF_WMI_LOCK_DPC(
	IN PATMARP_INTERFACE	pIf
)
--*/
#define AA_RELEASE_IF_WMI_LOCK_DPC(pIf)		\
				AA_RELEASE_LOCK_DPC(&((pIf)->WmiLock))


/*++
VOID
AA_FREE_IF_WMI_LOCK(
	IN	PATMARP_INTERFACE	pIf
)
--*/
#define AA_FREE_IF_WMI_LOCK(pIf)	\
				AA_FREE_LOCK(&((pIf)->WmiLock))

#endif // ATMARP_WMI

/*++
BOOLEAN
AA_IS_VC_GOING_DOWN(
	IN	PATMARP_VC		pVc
)
Is the VC being closed, or marked for closing?
--*/
#define AA_IS_VC_GOING_DOWN(_pVc)		\
				(((_pVc)->Flags & (AA_VC_CLOSE_STATE_CLOSING|AA_VC_CALL_STATE_CLOSE_IN_PROGRESS)) != 0)


#if !BINARY_COMPATIBLE

#define AA_ALLOC_FROM_POOL(_pVar, _StructType, _Size)	\
			(_pVar) = (_StructType *)ExAllocatePoolWithTag(NonPagedPool,	\
														 (_Size),		\
														 'CPRA')

#define AA_FREE_TO_POOL(_pMem)		ExFreePool((PVOID)(_pMem))

#endif
	
/*++
VOID
AA_ALLOC_MEM(
	IN	POPAQUE		pVar,
	IN	OPAQUE		StructureType,
	IN	ULONG		SizeOfStructure
)
--*/
#if DBG
#define AA_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			pVar = (StructureType *)AaAuditAllocMem(				\
										(PVOID)(&(pVar)),			\
										(ULONG)(SizeOfStructure),	\
										_FILENUMBER,				\
										__LINE__					\
									);
#else
#define AA_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			NdisAllocateMemoryWithTag((PVOID *)(&pVar), (ULONG)(SizeOfStructure), (ULONG)'CPRA');
#endif // DBG


/*++
VOID
AA_FREE_MEM(
	IN	POPAQUE		pMem
)
--*/
#if DBG
#define AA_FREE_MEM(pMem)	AaAuditFreeMem((PVOID)(pMem));
#else
#define AA_FREE_MEM(pMem)	NdisFreeMemory((PVOID)(pMem), 0, 0);
#endif // DBG


/*++
VOID
AA_SET_MEM(
	IN	POPAQUE		pMem,
	IN	UCHAR		bValue,
	IN	ULONG		NumberOfBytes
)
--*/
#define AA_SET_MEM(pMem, bValue, NumberOfBytes)	\
			AtmArpSetMemory((PUCHAR)(pMem), (bValue), (NumberOfBytes));



/*++
VOID
AA_COPY_MEM(
	IN	POPAQUE		pDst,
	IN	POPAQUE		pSrc,
	IN	ULONG		NumberOfBytes
)
--*/
#define AA_COPY_MEM(pDst, pSrc, NumberOfBytes)	\
			NdisMoveMemory((PVOID)(pDst), (PVOID)(pSrc), NumberOfBytes);


/*++
ULONG
AA_MEM_CMP(
	IN	PVOID		pString1,
	IN	PVOID		pString2,
	IN	ULONG		Length
)
--*/
#define AA_MEM_CMP(pString1, pString2, Length)	\
			AtmArpMemCmp((PUCHAR)(pString1), (PUCHAR)(pString2), (ULONG)(Length))



/*++
VOID
AA_INIT_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	PNDIS_TIMER_FUNCTON	pFunc,
	IN	PVOID				Context
)
--*/
#define AA_INIT_SYSTEM_TIMER(pTimer, pFunc, Context)	\
			NdisInitializeTimer(pTimer, (PNDIS_TIMER_FUNCTION)(pFunc), (PVOID)Context)



/*++
VOID
AA_START_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	UINT				PeriodInSeconds
)
--*/
#define AA_START_SYSTEM_TIMER(pTimer, PeriodInSeconds)	\
			NdisSetTimer(pTimer, (UINT)(PeriodInSeconds * 1000))


/*++
VOID
AA_STOP_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer
)
--*/
#define AA_STOP_SYSTEM_TIMER(pTimer)						\
			{												\
				BOOLEAN		WasCancelled;					\
				NdisCancelTimer(pTimer, &WasCancelled);		\
			}

/*++
BOOLEAN
AA_IS_TIMER_ACTIVE(
	IN	PATMARP_TIMER		pArpTimer
)
--*/
#define AA_IS_TIMER_ACTIVE(pTmr)	((pTmr)->pTimerList != (PATMARP_TIMER_LIST)NULL)


/*++
ULONG
AA_GET_TIMER_DURATION(
	IN	PATMARP_TIMER		pTimer
)
--*/
#define AA_GET_TIMER_DURATION(pTmr)	((pTmr)->Duration)


#ifndef NO_TIMER_MACRO

/*++
VOID
AtmArpRefreshTimer(
	IN	PATMARP_TIMER		pTimer
)
--*/
#define AtmArpRefreshTimer(_pTmr)												\
{																				\
	PATMARP_TIMER_LIST	_pTimerList;											\
																				\
	if ((_pTimerList = (_pTmr)->pTimerList) != (PATMARP_TIMER_LIST)NULL)		\
	{																			\
		(_pTmr)->LastRefreshTime = _pTimerList->CurrentTick;					\
	}																			\
}

#endif // !NO_TIMER_MACRO

/*++
ULONG
SECONDS_TO_LONG_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "long duration timer ticks"
--*/
#define SECONDS_TO_LONG_TICKS(Seconds)		((Seconds)/10)


/*++
ULONG
SECONDS_TO_SHORT_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "short duration timer ticks"
--*/
#define SECONDS_TO_SHORT_TICKS(Seconds)		(Seconds)


/*++
ULONG
CELLS_TO_BYTES(
	IN	ULONG				NumberOfCells
)
Convert from cell count to byte count
--*/
#define CELLS_TO_BYTES(NumberOfCells)	((NumberOfCells) * 48)


/*++
ULONG
BYTES_TO_CELLS(
	IN	ULONG				ByteCount
)
Convert from byte count to cell count
--*/
#define BYTES_TO_CELLS(ByteCount)		((ByteCount) / 48)



/*++
VOID
AA_IF_STAT_INCR(
	IN	PATMARP_INTERFACE	pInterface,
	IN	OPAQUE				StatsCounter
)
Increment the specified StatsCounter on an Interface by 1.
--*/
#define AA_IF_STAT_INCR(pInterface, StatsCounter)	\
			NdisInterlockedIncrement(&(pInterface->StatsCounter))


/*++
VOID
AA_IF_STAT_ADD_LOCK(
	IN	PATMARP_INTERFACE	pInterface,
	IN	OPAQUE				StatsCounter,
	IN	ULONG				IncrValue
)
Increment the specified StatsCounter on an Interface by the specified IncrValue.
Take a lock on the interface to do so.
--*/
#if DBG_SPIN_LOCK
#define AA_IF_STAT_ADD_LOCK(pInterface, StatsCounter, IncrValue)	\
			NdisInterlockedAddUlong(&(pInterface->StatsCounter), IncrValue, &(pInterface->InterfaceLock.NdisLock))
#else
#define AA_IF_STAT_ADD_LOCK(pInterface, StatsCounter, IncrValue)	\
			NdisInterlockedAddUlong(&(pInterface->StatsCounter), IncrValue, &(pInterface->InterfaceLock))
#endif // DBG_SPIN_LOCK

/*++
VOID
AA_IF_STAT_ADD(
	IN	PATMARP_INTERFACE	pInterface,
	IN	OPAQUE				StatsCounter,
	IN	ULONG				IncrValue
)
Add to the specified StatsCounter on an Interface by the specified IncrValue.
Use the more efficient InterlockedEcxhangeAdd instruction.
--*/
#if  BINARY_COMPATIBLE

	#define AA_IF_STAT_ADD(pInterface, StatsCounter, IncrValue)	\
				AA_IF_STAT_ADD_LOCK(pInterface, StatsCounter, IncrValue)

#else // !BINARY_COMPATIBLE

	#define AA_IF_STAT_ADD(pInterface, StatsCounter, IncrValue)	\
				InterlockedExchangeAdd(&(pInterface->StatsCounter), IncrValue)
	
			//((pInterface)->StatsCounter+=(IncrValue))
#endif // !BINARY_COMPATIBLE

/*++
BOOLEAN
AA_IS_BCAST_IP_ADDRESS(
	IN	IP_ADDRESS			Destination,
	IN	PATMARP_INTERFACE	pIf
)
Check if the given Destination is a broadcast IP address on the
given Interface. Currently, we only check if the destination is
the same as the (limited) broadcast address for the interface.

TBD: extend this when we support addition of broadcast addresses
to an interface.
--*/
#define AA_IS_BCAST_IP_ADDRESS(Destn, pIf)	\
		(IP_ADDR_EQUAL((pIf)->BroadcastAddress, Destn))



/*++
BOOLEAN
AA_FILTER_SPEC_MATCH(
	IN	PATMARP_INTERFACE	pInterface,
	IN	PATMARP_FILTER_SPEC	pSrc,
	IN	PATMARP_FILTER_SPEC	pDst
)
Check if the given filter spec matches a target filter spec, for the
specified interface.
--*/
#define AA_FILTER_SPEC_MATCH(pIf, pSrc, pDst)	\
			( ((pIf)->pFilterMatchFunc == NULL_PAA_FILTER_SPEC_MATCH_FUNC) ?	\
					TRUE:													\
					(*((pIf)->pFilterMatchFunc))((PVOID)pIf, pSrc, pDst))


/*++
BOOLEAN
AA_FLOW_SPEC_MATCH(
	IN	PATMARP_INTERFACE	pInterface,
	IN	PATMARP_FLOW_SPEC	pSrc,
	IN	PATMARP_FLOW_SPEC	pDst
)
Check if the given flow spec matches a target flow spec, for the
specified interface.
--*/
#define AA_FLOW_SPEC_MATCH(pIf, pSrc, pDst)	\
			( ((pIf)->pFlowMatchFunc == NULL_PAA_FLOW_SPEC_MATCH_FUNC) ?	\
					TRUE:													\
					(*((pIf)->pFlowMatchFunc))((PVOID)pIf, pSrc, pDst))


/*++
VOID
AA_GET_PACKET_SPECS(
	IN	PATMARP_INTERFACE		pInterface,
	IN	PNDIS_PACKET			pNdisPacket,
	OUT	PATMARP_FLOW_INFO		*ppFlowInfo,
	OUT	PATMARP_FLOW_SPEC		*ppFlowSpec,
	OUT	PATMARP_FILTER_SPEC		*ppFilterSpec
)
Get the flow and filter specs for the given packet
--*/
#define AA_GET_PACKET_SPECS(pIf, pPkt, ppFlowInfo, ppFlow, ppFilt)	\
			{																	\
				if ((pIf)->pGetPacketSpecFunc != NULL_PAA_GET_PACKET_SPEC_FUNC)	\
				{																\
					(*((pIf)->pGetPacketSpecFunc))								\
							((PVOID)(pIf), pPkt, ppFlowInfo, ppFlow, ppFilt);	\
				}																\
				else															\
				{																\
					*(ppFlowInfo) = NULL;										\
					*(ppFlow) = &((pIf)->DefaultFlowSpec);						\
					*(ppFilt) = &((pIf)->DefaultFilterSpec);					\
				}																\
			}																	\



/*++
VOID
AA_GET_CONTROL_PACKET_SPECS(
	IN	PATMARP_INTERFACE		pInterface,
	OUT	PATMARP_FLOW_SPEC		*ppFlowSpec
)
--*/
#define AA_GET_CONTROL_PACKET_SPECS(pIf, ppFlow)	\
			*(ppFlow) = &((pIf)->DefaultFlowSpec);


/*++
BOOLEAN
AA_IS_BEST_EFFORT_FLOW(
	IN	PATMARP_FLOW_SPEC		pFlowSpec
)
--*/
#define AA_IS_BEST_EFFORT_FLOW(pFlowSpec)	\
			(((pFlowSpec)->SendServiceType == SERVICETYPE_BESTEFFORT) &&			\
			 ((pFlowSpec)->SendPeakBandwidth > 0))




/*++
VOID
AA_SET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket,
	IN	PNDIS_PACKET		pNextPacket
)
--*/
#define AA_SET_NEXT_PACKET(pPkt, pNext)		\
			*((PNDIS_PACKET *)((pPkt)->MiniportReserved)) = (pNext);



/*++
PNDIS_PACKET
AA_GET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket
)
--*/
#define AA_GET_NEXT_PACKET(pPkt)			\
			(*((PNDIS_PACKET *)((pPkt)->MiniportReserved)))



/*++
ULONG
ROUND_UP(
	IN	ULONG	Val
)
Round up a value so that it becomes a multiple of 4.
--*/
#define ROUND_UP(Val)	(((Val) + 3) & ~0x3)


/*++
ULONG
ROUND_TO_8_BYTES(
	IN	ULONG	Val
)
Round up a value so that it becomes a multiple of 8.
--*/
#define ROUND_TO_8_BYTES(_Val)	(((_Val) + 7) & ~7)


#ifndef NET_SHORT

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define NET_SHORT(_x) _byteswap_ushort((USHORT)(_x))
#else
/*++
USHORT
NET_SHORT(
	IN	USHORT	Val
)
--*/
#define NET_SHORT(Val)	\
				((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))
#endif

#define NET_TO_HOST_SHORT(Val)	NET_SHORT(Val)
#define HOST_TO_NET_SHORT(Val)	NET_SHORT(Val)

#endif // NET_SHORT


#ifndef NET_LONG

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define NET_LONG(_x) _byteswap_ulong((ULONG)(_x))
#else
/*++
ULONG
NET_LONG(
	IN	ULONG	Val
)
--*/
#define NET_LONG(Val)	\
				((((Val) & 0x000000ff) << 24)	|	\
				 (((Val) & 0x0000ff00) << 8)	|	\
				 (((Val) & 0x00ff0000) >> 8)	|	\
				 (((Val) & 0xff000000) >> 24) )
#endif

#define NET_TO_HOST_LONG(Val)	NET_LONG(Val)
#define HOST_TO_NET_LONG(Val)	NET_LONG(Val)

#endif // NET_LONG


/*++
BOOLEAN
AA_IS_TRANSIENT_FAILURE(
	IN NDIS_STATUS		Status
)
	Return TRUE if the given Status indicates a transient connection
	failure, otherwise return FALSE.
--*/
#define AA_IS_TRANSIENT_FAILURE(_Status)	\
			((_Status == NDIS_STATUS_RESOURCES) ||					\
			 (_Status == NDIS_STATUS_CELLRATE_NOT_AVAILABLE) ||		\
			 (_Status == NDIS_STATUS_INCOMPATABLE_QOS))


/*++
LONG
AA_GET_RANDOM(
	IN LONG			min,
	IN LONG			max
)
--*/
#define AA_GET_RANDOM(min, max)	\
			(((LONG)AtmArpRandomNumber() % (LONG)(((max+1) - (min))) + (min)))


#define AA_LOG_ERROR()		// Nothing

/*++
BOOLEAN
AA_AE_IS_ALIVE(
	IN PATMARP_ATM_ENTRY	pAtmEntry
)
--*/
#define AA_AE_IS_ALIVE(pAtmEntry)				\
				(!AA_IS_FLAG_SET(				\
						(pAtmEntry)->Flags, 	\
						AA_ATM_ENTRY_STATE_MASK, \
						AA_ATM_ENTRY_IDLE))

/*++
BOOLEAN
AA_IE_ALIVE(
	IN PATMARP_IP_ENTRY	pIpEntry
)
--*/
#define AA_IE_IS_ALIVE(pIpEntry)				\
				(!AA_IS_FLAG_SET(				\
						(pIpEntry)->Flags, 		\
						AA_IP_ENTRY_STATE_MASK, \
						AA_IP_ENTRY_IDLE))


#endif // __ATMARP_MACROS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\marspkt.c ===
/*++

	Copyright (c) 1996  Microsoft Corporation

Module Name:

	mars.c

Abstract:

	Routines that build and parse MARS packets.


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     12-12-96    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'TKPM'



#ifdef IPMCAST

PUCHAR
AtmArpMcMakePacketCopy(
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	ULONG						TotalLength
)
/*++

Routine Description:

	Make a copy of the contents of the given NDIS packet. Allocate
	a contiguous piece of memory for this.

Arguments:

	pNdisPacket				- Pointer to the NDIS packet structure
	pNdisBuffer				- Pointer to the first NDIS Buffer in the packet
	TotalLength				- Total Length of the packet

Return Value:

	Pointer to the copy, if allocation was successful. Otherwise NULL.

--*/
{
	PUCHAR				pCopyBuffer;
	PUCHAR				pCopyDestination;
	PUCHAR				pNdisData;
	ULONG				BufferLength;

	AA_ALLOC_MEM(pCopyBuffer, UCHAR, TotalLength);
	if (pCopyBuffer != (PUCHAR)NULL)
	{
		pCopyDestination = pCopyBuffer;

		while (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NdisQueryBuffer(
				pNdisBuffer,
				&pNdisData,
				&BufferLength
				);

			AA_COPY_MEM(pCopyDestination, pNdisData, BufferLength);
			pCopyDestination += BufferLength;

			pNdisBuffer = NDIS_BUFFER_LINKAGE(pNdisBuffer);
		}
	}

	return (pCopyBuffer);
}


BOOLEAN
AtmArpMcProcessPacket(
	IN	PATMARP_VC					pVc,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	PAA_PKT_LLC_SNAP_HEADER		pPktHeader,
	IN	ULONG						TotalLength,
	IN	ULONG						FirstBufferLength
)
/*++

Routine Description:

	Process a received packet, which is potentially a MARS control or
	multicast data packet. If it is a data packet, pass it up to IP.
	Otherwise, process it here.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pNdisPacket				- Pointer to the NDIS packet structure
	pNdisBuffer				- Pointer to the first NDIS Buffer in the packet
	pPktHeader				- Pointer to the start of the packet contents
	TotalLength				- Total packet length
	FirstBufferLength		- Length of first NDIS buffer in packet.

Return Value:

	TRUE if we decide to discard this packet, FALSE if it is a valid packet.

--*/
{
	PATMARP_INTERFACE				pInterface;
	ULONG							HeaderLength;
	PAA_MC_PKT_TYPE1_SHORT_HEADER	pType1Header;
	PAA_MC_PKT_TYPE2_SHORT_HEADER	pType2Header;
	PAA_MARS_PKT_FIXED_HEADER		pControlHeader;
	BOOLEAN							IsIPPacket;		// Is this an IP packet?
	BOOLEAN							DiscardThis;	// Should we discard this?
	BOOLEAN							MadeACopy;		// Did we make a copy of this?
	AA_MARS_TLV_LIST				TlvList;
	
	//
	//  Initialize
	//
	IsIPPacket = TRUE;
	DiscardThis = FALSE;
	MadeACopy = FALSE;
	pInterface = pVc->pInterface;

	AA_SET_MEM(&TlvList, 0, sizeof(TlvList));

	do
	{
		//
		//  Check if we have a multicast data packet. Since we only
		//  support IPv4, we only expect to see short form headers.
		//
		pType1Header = (PAA_MC_PKT_TYPE1_SHORT_HEADER)pPktHeader;
		if (AAMC_PKT_IS_TYPE1_DATA(pType1Header))
		{
			AAMCDEBUGP(AAD_EXTRA_LOUD,
				("McProcessPacket: pVc 0x%x, Pkt 0x%x, Type 1, %d bytes, CMI %d\n",
						pVc, pNdisPacket, TotalLength, pType1Header->cmi));
	
			AAMCDEBUGPDUMP(AAD_EXTRA_LOUD+500, pPktHeader, MIN(FirstBufferLength, 96));
#if DBG
			if (AaDataDebugLevel & AAD_DATA_IN)
			{
				IP_ADDRESS			IPAddress;

				if ((pVc->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
					(pVc->pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY))
				{
					IPAddress = pVc->pAtmEntry->pIpEntryList->IPAddress;
				}
				else
				{
					IPAddress = 0;
				}

				AADEBUGP(AAD_WARNING,
					("%d <= %d.%d.%d.%d\n",
						TotalLength,
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));
			}
#endif // DBG

#if 0
	//
	//  Bug #138261: Local clients can never receive multicast packets
	//  sent out by a local application because of this.
	//
			if (pType1Header->cmi == pInterface->ClusterMemberId)
			{
				//
				//  This is a copy of a packet we sent out.
				//
				DiscardThis = TRUE;
				break;
			}

#endif // 0
			HeaderLength = sizeof(AA_MC_PKT_TYPE1_SHORT_HEADER); 
		}
		else
		{
			pType2Header = (PAA_MC_PKT_TYPE2_SHORT_HEADER)pPktHeader;
	
			if (AAMC_PKT_IS_TYPE2_DATA(pType2Header))
			{
		
				AAMCDEBUGP(AAD_EXTRA_LOUD,
					("McProcessPacket: pVc 0x%x, pNdisPacket 0x%x, Type 2 data\n",
							pVc, pNdisPacket));
		
				HeaderLength = sizeof(AA_MC_PKT_TYPE2_SHORT_HEADER);
			}
			else
			{
				IsIPPacket = FALSE;
			}
		}


		if (IsIPPacket)
		{
			AA_IF_STAT_INCR(pInterface, InNonUnicastPkts);

			//
			//  Send this up to IP. HeaderLength now contains the number
			//  of header bytes we need to strip off.
			//
			(pInterface->IPRcvHandler)(
					pInterface->IPContext,
					(PVOID)((PUCHAR)pPktHeader+HeaderLength),
					FirstBufferLength - HeaderLength,
					TotalLength - HeaderLength,
					(NDIS_HANDLE)pNdisPacket,
					HeaderLength,
					(UINT)TRUE		// Is NON Unicast
				#if P2MP
					,NULL
				#endif //P2MP
					);

			break;
		}

		//
		//  Check if this is a valid MARS control packet.
		//
		pControlHeader = (PAA_MARS_PKT_FIXED_HEADER)pPktHeader;
		if (AAMC_PKT_IS_CONTROL(pControlHeader))
		{
			//
			//  We ignore the checksum (the RFC allows us to do so).
			//
			AAMCDEBUGP(AAD_EXTRA_LOUD+10,
				("McProcessPacket: pControlHeader 0x%x, Op 0x%x, TotalLen %d\n",
						pControlHeader, pControlHeader->op, TotalLength));

			//
			//  If the entire MARS packet isn't in the first NDIS buffer,
			//  we make a copy into a single contiguous chunk of memory,
			//  to ease parsing.
			//
			if (FirstBufferLength == TotalLength)
			{
				MadeACopy = FALSE;
			}
			else
			{
				pControlHeader = (PAA_MARS_PKT_FIXED_HEADER)
									AtmArpMcMakePacketCopy(
										pNdisPacket,
										pNdisBuffer,
										TotalLength
										);

				if (pControlHeader == (PAA_MARS_PKT_FIXED_HEADER)NULL)
				{
					//
					//  Allocation failed. Discard this packet.
					//
					DiscardThis = TRUE;
					break;
				}
				else
				{
					MadeACopy = TRUE;
				}
			}

			if (!AtmArpMcPreprocess(pControlHeader, TotalLength, &TlvList))
			{
				AAMCDEBUGP(AAD_INFO,
					("McProcessPacket: PreProcess failed: pHdr 0x%x, TotalLength %d\n",
						pControlHeader, TotalLength));

				DiscardThis = TRUE;
				break;
			}

			switch (NET_TO_HOST_SHORT(pControlHeader->op))
			{
				case AA_MARS_OP_TYPE_MULTI:
					AtmArpMcHandleMulti(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;

				case AA_MARS_OP_TYPE_JOIN:
				case AA_MARS_OP_TYPE_LEAVE:
					AtmArpMcHandleJoinOrLeave(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				case AA_MARS_OP_TYPE_NAK:
					AtmArpMcHandleNak(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				case AA_MARS_OP_TYPE_GROUPLIST_REPLY:
					AtmArpMcHandleGroupListReply(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				case AA_MARS_OP_TYPE_REDIRECT_MAP:
					AtmArpMcHandleRedirectMap(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				case AA_MARS_OP_TYPE_MIGRATE:
					AtmArpMcHandleMigrate(
							pVc,
							pControlHeader,
							TotalLength,
							&TlvList
							);
					break;
				default:
					AAMCDEBUGP(AAD_WARNING,
					("pVc 0x%x, pNdisPacket 0x%x, pHdr 0x%x, bad/unknown op 0x%x\n",
							pVc, pNdisPacket, pControlHeader, pControlHeader->op));
					AA_ASSERT(FALSE);
					break;

			} // switch (op)

		} // if Control packet
		break;

	}
	while (FALSE);

	if (MadeACopy)
	{
		AA_FREE_MEM(pControlHeader);
	}

	return (DiscardThis);
}



BOOLEAN
AtmArpMcPreprocess(
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	OUT	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Do preliminary checks on a received MARS control packet.
	Go through any TLVs, and make sure we can either handle or
	safely ignore them. Be prepared to receive complete garbage in this packet.



	Update *pTlvList with information about all valid TLVs that we see.

Arguments:

	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.

Return Value:

	TRUE if the packet passed all checks, FALSE otherwise.

--*/
{
	ULONG				ExtensionOffset;
	PAA_MARS_TLV_HDR	pTlv;
	ULONG				TlvSpaceLeft;	// in packet
	ULONG				TlvLength;
	ULONG				TlvType;
	ULONG				TlvAction;
	BOOLEAN				Passed;
	BOOLEAN				TlvOk;

	Passed = TRUE;

	do
	{
		//
		//	The USHORT casts below and in obtaining TlvLengths are important
		//  in order to ensure that these values are less than 2^16.
		//	Since they are less than 2^16, any sums involving them will not overflow.
		//
		ExtensionOffset = (USHORT)NET_TO_HOST_SHORT(pControlHeader->extoff);


		if (ExtensionOffset != 0)
		{
			AAMCDEBUGP(AAD_EXTRA_LOUD+20,
				("McPreprocess: pControlHdr 0x%x, ExtOff %d, TotalLength %d\n",
					pControlHeader, ExtensionOffset, TotalLength));

			//
			//  Is there space for atleast one TLV?
			//
			if ((ExtensionOffset
				  + sizeof(AA_PKT_LLC_SNAP_HEADER) + sizeof(AA_MARS_TLV_HDR))
				 > TotalLength)
			{
				Passed = FALSE;
				break;
			}

			pTlv = (PAA_MARS_TLV_HDR)((PUCHAR)pControlHeader +
									 ExtensionOffset + sizeof(AA_PKT_LLC_SNAP_HEADER));

			TlvSpaceLeft = (TotalLength - ExtensionOffset - sizeof(AA_PKT_LLC_SNAP_HEADER));

			do
			{
				TlvType = AAMC_GET_TLV_TYPE(pTlv->Type);
				TlvAction = AAMC_GET_TLV_ACTION(pTlv->Type);

				//
				//  Get the rounded-off TLV length
				//
				TlvLength = (USHORT) NET_TO_HOST_SHORT(pTlv->Length);
				TlvLength = AAMC_GET_TLV_TOTAL_LENGTH(TlvLength);

				if (TlvLength > TlvSpaceLeft)
				{
					AAMCDEBUGP(AAD_WARNING,
						("McPreprocess: Hdr 0x%x, pTlv 0x%x: TlvLength %d > TlvSpaceLeft %d\n",
							pControlHeader, pTlv, TlvLength, TlvSpaceLeft));
					Passed = FALSE;
					break;
				}

				TlvOk = FALSE;

				switch (TlvType)
				{
					case AAMC_TLVT_MULTI_IS_MCS:
						if (TlvLength == sizeof(AA_MARS_TLV_MULTI_IS_MCS))
						{
							TlvOk = TRUE;
							pTlvList->MultiIsMCSPresent =
							pTlvList->MultiIsMCSValue = TRUE;
						}
						break;
					case AAMC_TLVT_NULL:
						if (TlvLength == 0)
						{
							TlvOk = TRUE;
						}
						break;
					default:
						break;
				}

				if (!TlvOk)
				{
					if (TlvAction == AA_MARS_TLV_TA_STOP_SILENT)
					{
						Passed = FALSE;
						break;
					}

					if (TlvAction == AA_MARS_TLV_TA_STOP_LOG)
					{
						AA_LOG_ERROR();
						Passed = FALSE;
						break;
					}
				}

				pTlv = (PAA_MARS_TLV_HDR)((PUCHAR)pTlv + TlvLength);
				TlvSpaceLeft -= TlvLength;
			}
			while (TlvSpaceLeft >= sizeof(AA_MARS_TLV_HDR));

			if (TlvSpaceLeft != 0)
			{
				//
				//  Improperly formed TLV at the end of the packet.
				//
				AAMCDEBUGP(AAD_LOUD,
					("McPreprocess: residual space left at end of Pkt 0x%x: %d bytes\n",
						pControlHeader, TlvSpaceLeft));

				Passed = FALSE;
			}
		}

		break;

	}
	while (FALSE);

	return (Passed);
}



VOID
AtmArpMcHandleMulti(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_MULTI message. We first look up the IP Entry
	for the group address being resolved/revalidated. If we aren't
	in "Discard mode" on this entry and the MULTI sequence number is ok,
	then we add all ATM endstations returned in this MULTI (that aren't
	present already) to the ATM Entry for this multicast group.

	If this is the last MULTI for the multicast group, we initiate/update
	our point-to-multipoint connection for sending data to the group.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	pTlvList				- All TLVs seen in this packet

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PAA_MARS_MULTI_HEADER	pMultiHeader;
	PATMARP_IP_ENTRY		pIpEntry;		// Entry for IP address being resolved
	PATMARP_IPMC_ATM_ENTRY	pMcAtmEntry;
	ULONG					MarsSeqNumber;	// MSN received in this packet
	ULONG					HostSeqNumber;	// Our MSN
	ULONG					SeqDiff;		// Difference between MSN and the HSN
	USHORT					SequenceNoY;	// MULTI sequence number
	BOOLEAN					IsLastMulti;	// Is this the final MULTI response?
	BOOLEAN					bWasRunning;	// Was a timer running?
	IP_ADDRESS				IPAddress;		// the address being queried
	PNDIS_PACKET			pPacketList;
	BOOLEAN					IsUnicastResolution;	// Did we resolve to a single MCS?

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;
	SeqDiff = 0;

	pMultiHeader = (PAA_MARS_MULTI_HEADER)pControlHeader;

	do
	{
		ULONG		rc;
		//
		//  Get the sequence number of this MARS MULTI.
		//
		SequenceNoY = NET_TO_HOST_SHORT(pMultiHeader->seqxy);
		IsLastMulti =  ((SequenceNoY & AA_MARS_X_MASK) != 0);
		SequenceNoY = (SequenceNoY & AA_MARS_Y_MASK);

		//
		//  Get the MARS Sequence Number in this message.
		//
		MarsSeqNumber = NET_TO_HOST_LONG(pMultiHeader->msn);

		//
		//  If this is the last MULTI in reply to our REQUEST,
		//  calculate the Seq # difference.
		//
		if (IsLastMulti)
		{
			AA_ACQUIRE_IF_LOCK(pInterface);
			HostSeqNumber = pInterface->HostSeqNumber;	// save the old value
			pInterface->HostSeqNumber = MarsSeqNumber;	// and update
			AA_RELEASE_IF_LOCK(pInterface);

			SeqDiff = MarsSeqNumber - HostSeqNumber;
		}

		//
		//  Get the group address being responded to.
		//
		IPAddress = *(IP_ADDRESS UNALIGNED *)(
						(PUCHAR)pMultiHeader +
						sizeof(AA_MARS_MULTI_HEADER) +
						(pMultiHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pMultiHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pMultiHeader->spln)
						);

		AAMCDEBUGP(AAD_LOUD,
		 ("McHandleMulti: 0x%x, IP %d.%d.%d.%d, MSN %d, HSN %d, Last %d, Y %d, tnum %d\n",
						pMultiHeader,
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3],
						MarsSeqNumber,
						HostSeqNumber,
						(ULONG)IsLastMulti,
						(ULONG)SequenceNoY,
						NET_TO_HOST_SHORT(pMultiHeader->tnum)
						));
					

		//
		//  Get the IP Entry for this address.
		//
		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		pIpEntry = AtmArpSearchForIPAddress(
						pInterface,
						&IPAddress,
						IE_REFTYPE_AE,
						TRUE,		// this is a multicast/broadcast address
						FALSE		// don't create a new entry if the address isn't found
						);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		//
		// AtmArpSearchForIPAddress addreffs pIpEntry for us ...
		//

		if (pIpEntry == NULL_PATMARP_IP_ENTRY)
		{

			AAMCDEBUGP(AAD_INFO, ("McHandleMulti: No IP Entry for %d.%d.%d.%d\n",
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));
			break;
		}


		AA_ACQUIRE_IE_LOCK(pIpEntry);
		AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

		//
		//  A resolution timer may be running here - stop it.
		//

		bWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
		if (bWasRunning)
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER); // Timer ref
			AA_ASSERT(rc != 0);
		}

		IsUnicastResolution = (IsLastMulti &&
								(NET_TO_HOST_SHORT(pMultiHeader->tnum) == 1) &&
								(pTlvList->MultiIsMCSValue == TRUE));


		//
		// Check if the multi request is compatible with the existing atm
		// entry (if any) associated with the ip entry. If they are not,
		// then we must abort the IP entry and get out of here, because
		// there was possibly a switch in status of this IP group address from
		// being vc-mesh served to mcs served, or vice versa.
		//
		if (pIpEntry->pAtmEntry)
		{
			if (	(IsUnicastResolution && pIpEntry->pAtmEntry->pMcAtmInfo != NULL)
				||  (!IsUnicastResolution && pIpEntry->pAtmEntry->pMcAtmInfo ==NULL))
			{
				AAMCDEBUGP(AAD_WARNING,
					("HandleMulti: Type Mismatch! %s pIpEntry 0x%x/%x (%d.%d.%d.%d) linked to ATMEntry 0x%x\n",
							((IsUnicastResolution) ? "MCS" : "VC-Mesh"),
							pIpEntry, pIpEntry->Flags,
							((PUCHAR)&(pIpEntry->IPAddress))[0],
							((PUCHAR)&(pIpEntry->IPAddress))[1],
							((PUCHAR)&(pIpEntry->IPAddress))[2],
							((PUCHAR)&(pIpEntry->IPAddress))[3],
							pIpEntry->pAtmEntry));
				
				//
				// Remove the AE_REF implicitly added by AtmArpMcLookupAtmMember
				// above...
				//
				rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // Tmp ref
				if (rc!=0)
				{
					AtmArpAbortIPEntry(pIpEntry);
					//
					//  IE lock is released within the above.
					//
				}

				break;
			}
		}


		//
		//  Check if we are in discard mode, or this MULTI has a bad
		//  sequence number. In either case, discard this MULTI, otherwise
		//  process it.
		//
		if (!AA_IS_FLAG_SET(
					pIpEntry->Flags,
					AA_IP_ENTRY_MC_RESOLVE_MASK,
					AA_IP_ENTRY_MC_DISCARDING_MULTI
					) &&
			(SequenceNoY == pIpEntry->NextMultiSeq))
		{
			PATMARP_ATM_ENTRY	pAtmEntry;
			//
			//  Total entries in this MULTI
			//
			ULONG				NumberOfEntries;
			//
			//  All info about one ATM (leaf) entry:
			//
			PUCHAR				pAtmNumber;
			ULONG				AtmNumberLength;
			ATM_ADDRESSTYPE		AtmNumberType;
			PUCHAR				pAtmSubaddress;
			ULONG				AtmSubaddressLength;
			ATM_ADDRESSTYPE		AtmSubaddressType;

			//
			//  Process this MARS MULTI.
			//
			pIpEntry->NextMultiSeq++;

			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
				pMultiHeader->thtl,
				&AtmNumberType,
				&AtmNumberLength);

			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
				pMultiHeader->tstl,
				&AtmSubaddressType,
				&AtmSubaddressLength);

			pAtmNumber = ((PUCHAR)pMultiHeader +
							sizeof(AA_MARS_MULTI_HEADER) +
							(pMultiHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
							(pMultiHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
							(pMultiHeader->spln) +
							(pMultiHeader->tpln));

			if (IsUnicastResolution)
			{

				//
				//  This IP address has resolved to a single ATM address. Search
				//  for (or allocate a new) ATM Entry for this address.
				//
				AAMCDEBUGP(AAD_LOUD, ("McHandleMulti: Unicast res for %d.%d.%d.%d\n",
							((PUCHAR)&IPAddress)[0],
							((PUCHAR)&IPAddress)[1],
							((PUCHAR)&IPAddress)[2],
							((PUCHAR)&IPAddress)[3]));

				AA_RELEASE_IE_LOCK(pIpEntry);
				AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
				pAtmEntry = AtmArpSearchForAtmAddress(
									pInterface,
									pMultiHeader->thtl,
									pAtmNumber,
									pMultiHeader->tstl,
									(PUCHAR)pAtmNumber + AtmNumberLength,
									AE_REFTYPE_IE,
									TRUE
									);
				AA_RELEASE_IF_TABLE_LOCK(pInterface);
				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));


				if (	pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					AAMCDEBUGP(AAD_INFO,
						("McHandleMulti: pIpEntry 0x%x, failed to alloc AtmEntry\n",
							pIpEntry));

					rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // Tmp ref
					if (rc!=0)
					{
						AtmArpAbortIPEntry(pIpEntry);
						//
						//  IE lock is released within the above.
						//
					}
					break;	// go to end of processing
				}

				AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);

				//
				// AtmArpSearchForAtmAddress addrefs pAtmEntry for us..
				//

				if (pIpEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					//
					//  Link the ATM Entry to this IP Entry.
					//

					pIpEntry->pAtmEntry = pAtmEntry;

					AA_SET_FLAG(pAtmEntry->Flags,
								AA_ATM_ENTRY_STATE_MASK,
								AA_ATM_ENTRY_ACTIVE);

					//
					//  Add the IP Entry to the ATM Entry's list of IP Entries
					//  (multiple IP entries could point to the same ATM Entry).
					//
					pIpEntry->pNextToAtm = pAtmEntry->pIpEntryList;
					pAtmEntry->pIpEntryList = pIpEntry;

					AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
				}
				else
				{
					//
					// There is already a linkage -- deref the
					// references implicitly added for us in the
					// SearchForXXX calls above...
					//

					rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_IE); // IP
					{
						if (rc != 0)
						{
							AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
						}
					}
					rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // AE
					if (rc==0)
					{
						//
						// IpEntry gone away...
						//
						break;
					}

				}

				//
				// At this point we have a lock on pIpEntry, but none
				// on pAtmEntry, and we don't have any "extra" refs on
				// either.
				//

				if (pIpEntry->pAtmEntry == pAtmEntry)
				{
					//
					//  Either a fresh IP->ATM resolution, or
					//  reconfirmation of an existing resolution.
					//
					AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "MULTI: Unicast Addr: ", &pAtmEntry->ATMAddress);

					//
					//  Update IP Entry state.
					//
					AA_SET_FLAG(pIpEntry->Flags,
								AA_IP_ENTRY_MC_RESOLVE_MASK,
								AA_IP_ENTRY_MC_RESOLVED);
					AA_SET_FLAG(pIpEntry->Flags,
								AA_IP_ENTRY_MC_VALIDATE_MASK,
								AA_IP_ENTRY_MC_NO_REVALIDATION);
					AA_SET_FLAG(pIpEntry->Flags,
								AA_IP_ENTRY_STATE_MASK,
								AA_IP_ENTRY_RESOLVED);
					pIpEntry->NextMultiSeq = AA_MARS_INITIAL_Y;

#ifdef AGE_MCAST_IP_ENTRIES
	//
	//  Feb 26, 97: we don't need to age out IP multicast entries:
	//  VC aging timer is sufficient.
	// 
					//
					//  Start off IP Aging timeout
					//
					AtmArpStartTimer(
								pInterface,
								&(pIpEntry->Timer),
								AtmArpIPEntryAgingTimeout,
								pInterface->MulticastEntryAgingTimeout,
								(PVOID)pIpEntry
								);

					AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// timer ref

#endif // AGE_MCAST_IP_ENTRIES

					//
					//  Remove the packet list queued on this IP Entry,
					//  if any.
					//
					pPacketList = pIpEntry->PacketList;
					pIpEntry->PacketList = (PNDIS_PACKET)NULL;

					AA_RELEASE_IE_LOCK(pIpEntry);
					if (pPacketList != (PNDIS_PACKET)NULL)
					{
						//
						//  The following will trigger off MakeCall.
						//
						AtmArpSendPacketListOnAtmEntry(
									pInterface,
									pAtmEntry,
									pPacketList,
									TRUE
									);
					}
				}
				else
				{
					AAMCDEBUGP(AAD_WARNING,
						("HandleMulti: pIpEntry 0x%x/%x (%d.%d.%d.%d) linked to ATMEntry 0x%x, resolves to 0x%x\n",
								pIpEntry, pIpEntry->Flags,
								((PUCHAR)&(pIpEntry->IPAddress))[0],
								((PUCHAR)&(pIpEntry->IPAddress))[1],
								((PUCHAR)&(pIpEntry->IPAddress))[2],
								((PUCHAR)&(pIpEntry->IPAddress))[3],
								pIpEntry->pAtmEntry,
								pAtmEntry));

					AA_STRUCT_ASSERT(pIpEntry->pAtmEntry, aae);

					AtmArpAbortIPEntry(pIpEntry);
					//
					//  IE lock is released within the above.
					//
				}

				break;	// go to end of processing

			} // Unicast resolution

			//
			//  IP Address resolved to multiple ATM addresses.
			//
			pAtmEntry = pIpEntry->pAtmEntry;
			if (pAtmEntry == NULL_PATMARP_ATM_ENTRY)
			{
				//
				//  Allocate an ATM Entry and link to this IP Entry.
				//
				pAtmEntry = AtmArpAllocateAtmEntry(pInterface, TRUE);

				if (pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{

					// Let's deref the implicit addref for pIpEntry...
					// Warning -- we should now not release our lock on
					// pIpEntry until we're completely done with it
					// (unless we first addref it).
					//
					rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // Tmp ref
					if (rc!=0)
					{
						AtmArpAbortIPEntry(pIpEntry);
						//
						//  IE lock is released within the above.
						//
					}
					break;	// go to end of processing
				}

				//
				//  Link them together.
				//
				pIpEntry->pAtmEntry = pAtmEntry;
				pAtmEntry->pIpEntryList = pIpEntry;

				AAMCDEBUGP(AAD_EXTRA_LOUD,
					("McHandleMulti: Multicast: linked pIpEntry 0x%x, pAtmEntry 0x%x\n",
							pIpEntry, pAtmEntry));

				AA_REF_AE(pAtmEntry, AE_REFTYPE_IE);	// IP Entry linkage
				//
				//  Link the ATM entry to this Interface
				//
				AA_RELEASE_IE_LOCK(pIpEntry);
				AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);
				if (pInterface->AtmEntryListUp)
				{
					pAtmEntry->pNext = pInterface->pAtmEntryList;
					pInterface->pAtmEntryList = pAtmEntry;
				}
				AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);
				AA_ACQUIRE_IE_LOCK(pIpEntry);
				AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
				
			}
			else
			{
				//
				// IP already has an atm entry...
				//
				// Let's deref the implicit addref for pIpEntry...
				// Warning -- we should now not release our lock on
				// pIpEntry until we're completely done with it
				// (unless we first addref it).
				//
				rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_AE); // Tmp ref
				if (rc==0)
				{
					//
					// IpEntry gone away...
					//
					break;
				}
			}


			AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);

			for (NumberOfEntries = NET_TO_HOST_SHORT(pMultiHeader->tnum);
				 NumberOfEntries != 0;
				 NumberOfEntries--)
			{
				pAtmSubaddress = ((PUCHAR)pAtmNumber + AtmNumberLength);

				pMcAtmEntry = AtmArpMcLookupAtmMember(
								pAtmEntry,
								&(pAtmEntry->pMcAtmInfo->pMcAtmEntryList),
								pAtmNumber,
								AtmNumberLength,
								AtmNumberType,
								pAtmSubaddress,
								AtmSubaddressLength,
								TRUE	// Create new entry if not found
								);

				if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
				{
					//
					//  Mark this member "valid".
					//
					AA_SET_FLAG(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_VALID);

					AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD, "MULTI Addr: ", &pMcAtmEntry->ATMAddress);
				}
				else
				{
					//
					//  Resource problems! No point in continuing.
					//
					break;
				}

				pAtmNumber = (PUCHAR)pAtmNumber + AtmNumberLength;

			} // for

			AA_RELEASE_AE_LOCK_DPC(pAtmEntry);

			if (IsLastMulti)
			{
				//
				//  We have successfully resolved this Multicast IP Address.
				//
				AAMCDEBUGP(AAD_INFO,
						("### HandleMulti: pIpEntry 0x%x, resolved %d.%d.%d.%d\n",
							pIpEntry,
							((PUCHAR)(&IPAddress))[0],
							((PUCHAR)(&IPAddress))[1],
							((PUCHAR)(&IPAddress))[2],
							((PUCHAR)(&IPAddress))[3]));

				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_MC_RESOLVE_MASK,
							AA_IP_ENTRY_MC_RESOLVED);
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_MC_VALIDATE_MASK,
							AA_IP_ENTRY_MC_NO_REVALIDATION);
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_RESOLVED);

				pIpEntry->NextMultiSeq = AA_MARS_INITIAL_Y;

				//
				//  Remove the packet list queued on this IP Entry,
				//  if any.
				//
				pPacketList = pIpEntry->PacketList;
				pIpEntry->PacketList = (PNDIS_PACKET)NULL;

#ifdef AGE_MCAST_IP_ENTRIES
				//
				//  Start off IP Aging timeout
				//
				AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpIPEntryAgingTimeout,
							pInterface->MulticastEntryAgingTimeout,
							(PVOID)pIpEntry
							);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// timer ref

#endif // AGE_MCAST_IP_ENTRIES

				AA_RELEASE_IE_LOCK(pIpEntry);

				AA_ACQUIRE_AE_LOCK(pAtmEntry);

				AA_REF_AE(pAtmEntry, AE_REFTYPE_TMP);

				AtmArpMcUpdateConnection(pAtmEntry);
				//
				//  AE Lock is released within the above.
				//
					
				if (pPacketList != (PNDIS_PACKET)NULL)
				{
					AtmArpSendPacketListOnAtmEntry(
								pInterface,
								pAtmEntry,
								pPacketList,
								TRUE
								);
				}

				AA_ACQUIRE_AE_LOCK(pAtmEntry);

				rc = AA_DEREF_AE(pAtmEntry, AE_REFTYPE_TMP);

				if (rc != 0)
				{
					AA_RELEASE_AE_LOCK(pAtmEntry);
				}

			}
			else
			{
				//
				//  Restart the address resolution timer on this entry,
				//  but for a duration equal to the max delay between
				//  MULTI messages.
				//
				AtmArpStartTimer(
						pInterface,
						&(pIpEntry->Timer),
						AtmArpAddressResolutionTimeout,
						pInterface->MaxDelayBetweenMULTIs,
						(PVOID)pIpEntry
						);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Delay b/w MULTI timer ref

				AA_RELEASE_IE_LOCK(pIpEntry);
			}

		}
		else
		{
			AAMCDEBUGP(AAD_WARNING,
				("HandleMULTI: fail condition: pIpEntry 0x%x/0x%x, Addr %d.%d.%d.%d, SeqY %d, NextMultiSeq %d, IsLastMulti %d\n",
					pIpEntry,
					pIpEntry->Flags,
					((PUCHAR)&(pIpEntry->IPAddress))[0],
					((PUCHAR)&(pIpEntry->IPAddress))[1],
					((PUCHAR)&(pIpEntry->IPAddress))[2],
					((PUCHAR)&(pIpEntry->IPAddress))[3],
					SequenceNoY,
					pIpEntry->NextMultiSeq,
					IsLastMulti
				));

			//
			//  A "failure condition" with this MULTI.
			//
			if (IsLastMulti)
			{
				//
				//  This is the last MULTI of a failed address resolution
				//  sequence. Start off address resolution afresh.
				//
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_IDLE2);

				AtmArpResolveIpEntry(pIpEntry);
				//
				//  IE Lock is released within the above.
				//
			}
			else
			{
				//
				//  Discard all future MULTIs
				//
				AA_SET_FLAG(pIpEntry->Flags,
							AA_IP_ENTRY_MC_RESOLVE_MASK,
							AA_IP_ENTRY_MC_DISCARDING_MULTI);

				AA_RELEASE_IE_LOCK(pIpEntry);
			}
		}

		break;
	}
	while (FALSE);


	//
	//  Finally (according to Section 5.1.4.2 of RFC 2022), check
	//  if we just had a jump in the MSN.
	//
	if ((SeqDiff != 1) && (SeqDiff != 0))
	{
		AAMCDEBUGP(AAD_INFO,
			("HandleMulti: IF 0x%x: Bad seq diff %d, MSN 0x%x, HSN 0x%x\n",
				pInterface, SeqDiff, MarsSeqNumber, HostSeqNumber));
		AtmArpMcRevalidateAll(pInterface);
	}

}



VOID
AtmArpMcHandleMigrate(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PAA_MARS_MIGRATE_HEADER	pMigrateHeader;
	PATMARP_IP_ENTRY		pIpEntry;		// Entry for IP address being resolved
	PATMARP_IPMC_ATM_ENTRY	pMcAtmEntry;
	PATMARP_ATM_ENTRY		pAtmEntry;
	ULONG					MarsSeqNumber;	// MSN received in this packet
	ULONG					HostSeqNumber;	// Our MSN
	ULONG					SeqDiff;		// Difference between MSN and the HSN
	BOOLEAN					bWasRunning;	// Was a timer running?
	IP_ADDRESS				IPAddress;		// the address being queried

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;
	SeqDiff = 0;

	pMigrateHeader = (PAA_MARS_MIGRATE_HEADER)pControlHeader;

	do
	{
		//
		//  Get the MARS Sequence Number in this message.
		//
		MarsSeqNumber = NET_TO_HOST_LONG(pMigrateHeader->msn);

		//
		//  Calculate the Seq # difference.
		//
		AA_ACQUIRE_IF_LOCK(pInterface);
		HostSeqNumber = pInterface->HostSeqNumber;	// save the old value
		pInterface->HostSeqNumber = MarsSeqNumber;	// and update
		AA_RELEASE_IF_LOCK(pInterface);

		SeqDiff = MarsSeqNumber - HostSeqNumber;

		//
		//  Get the group address being migrated.
		//
		IPAddress = *(IP_ADDRESS UNALIGNED *)(
						(PUCHAR)pMigrateHeader +
						sizeof(AA_MARS_MIGRATE_HEADER) +
						(pMigrateHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pMigrateHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pMigrateHeader->spln)
						);

		AAMCDEBUGP(AAD_LOUD,
		 ("McHandleMigrate: 0x%x, IP %d.%d.%d.%d, MSN %d, HSN %d\n",
						pMigrateHeader,
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3],
						MarsSeqNumber,
						HostSeqNumber));
					

		//
		//  Get the IP Entry for this address.
		//
		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		pIpEntry = AtmArpSearchForIPAddress(
						pInterface,
						&IPAddress,
						IE_REFTYPE_TMP,
						TRUE,		// this is a multicast/broadcast address
						FALSE		// don't create a new entry if the address isn't found
						);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			//
			// AtmArpSearchForIPAddress addrefs pIpEntry for us ...
			//
			ULONG		rc;
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);
			if (rc == 0)
			{
				// Oops, IP address has gone away...
				pIpEntry = NULL_PATMARP_IP_ENTRY;
			}
		}

		if (pIpEntry == NULL_PATMARP_IP_ENTRY)
		{

			AAMCDEBUGP(AAD_INFO, ("McHandleMigrate: No IP Entry for %d.%d.%d.%d\n",
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));
			break;
		}

		if (pIpEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
		{
			//
			// This IP address is being resolved.
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
			break;
		}

		pAtmEntry = pIpEntry->pAtmEntry;

		if (AA_IS_FLAG_SET(
					pAtmEntry->Flags,
					AA_ATM_ENTRY_TYPE_MASK,
					AA_ATM_ENTRY_TYPE_UCAST))
		{
			AAMCDEBUGP(AAD_INFO,
			("McHandleMigrate: IP Addr %d.%d.%d.%d was unicast, aborting pIpEntry 0x%x\n",
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3],
						pIpEntry));

			AtmArpAbortIPEntry(pIpEntry);
			//
			//  IE Lock is released within the above.
			//
			break;
		}

		//
		//  Check if we are in discard mode.
		//
		if (!AA_IS_FLAG_SET(
					pIpEntry->Flags,
					AA_IP_ENTRY_MC_RESOLVE_MASK,
					AA_IP_ENTRY_MC_DISCARDING_MULTI))
		{
			//
			//  Total entries in this MULTI
			//
			ULONG				NumberOfEntries;
			//
			//  All info about one ATM (leaf) entry:
			//
			PUCHAR				pAtmNumber;
			ULONG				AtmNumberLength;
			ATM_ADDRESSTYPE		AtmNumberType;
			PUCHAR				pAtmSubaddress;
			ULONG				AtmSubaddressLength;
			ATM_ADDRESSTYPE		AtmSubaddressType;

			//
			//  Process this MARS MIGRATE fully.
			//

			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
				pMigrateHeader->thtl,
				&AtmNumberType,
				&AtmNumberLength);

			AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
				pMigrateHeader->tstl,
				&AtmSubaddressType,
				&AtmSubaddressLength);

			pAtmNumber = ((PUCHAR)pMigrateHeader +
							sizeof(AA_MARS_MIGRATE_HEADER) +
							(pMigrateHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
							(pMigrateHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
							(pMigrateHeader->spln) +
							(pMigrateHeader->tpln));

			AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);

			for (NumberOfEntries = pMigrateHeader->tnum;
				 NumberOfEntries != 0;
				 NumberOfEntries--)
			{
				pAtmSubaddress = ((PUCHAR)pAtmNumber + AtmNumberLength);

				pMcAtmEntry = AtmArpMcLookupAtmMember(
								pAtmEntry,
								&(pAtmEntry->pMcAtmInfo->pMcAtmMigrateList),
								pAtmNumber,
								AtmNumberLength,
								AtmNumberType,
								pAtmSubaddress,
								AtmSubaddressLength,
								TRUE	// Create new entry if not found
								);

				if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
				{
					//
					//  Mark this member "valid".
					//
					AA_SET_FLAG(
							pMcAtmEntry->Flags,
							AA_IPMC_AE_GEN_STATE_MASK,
							AA_IPMC_AE_VALID);
				}
				else
				{
					//
					//  Resource problems! No point in continuing.
					//
					break;
				}

				pAtmNumber = (PUCHAR)pAtmNumber + AtmNumberLength;

			} // for

			AA_RELEASE_AE_LOCK_DPC(pAtmEntry);

			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_MC_RESOLVE_MASK,
						AA_IP_ENTRY_MC_RESOLVED);
			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_MC_VALIDATE_MASK,
						AA_IP_ENTRY_MC_NO_REVALIDATION);
			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_RESOLVED);

			pIpEntry->NextMultiSeq = AA_MARS_INITIAL_Y;

			//
			//  Now close the PMP VC for this group, if one exists.
			//  If we don't have a VC, start a connection.
			//
			pVc = pIpEntry->pAtmEntry->pVcList;
			AA_RELEASE_IE_LOCK(pIpEntry);

			if (pVc != (PATMARP_VC)NULL)
			{
				AA_ACQUIRE_VC_LOCK(pVc);
				//
				//  When the call is closed, we start a new
				//  PMP connection, using the migrate list.
				//
				AtmArpCloseCall(pVc);
			}
			else
			{
				AA_ACQUIRE_AE_LOCK(pAtmEntry);
				AtmArpMcUpdateConnection(pAtmEntry);
				//
				//  AE Lock is released within the above.
				//
			}

		}
		else
		{
			//
			//  Discard this MIGRATE
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
		}

		break;
	}
	while (FALSE);


	//
	//  Finally (according to Section 5.1.4.2 of RFC 2022), check
	//  if we just had a jump in the MSN.
	//
	if ((SeqDiff != 1) && (SeqDiff != 0))
	{
		AAMCDEBUGP(AAD_INFO,
			("HandleMigrate: IF 0x%x: Bad seq diff %d, MSN 0x%x, HSN 0x%x\n",
				pInterface, SeqDiff, MarsSeqNumber, HostSeqNumber));
		AtmArpMcRevalidateAll(pInterface);
	}

}



VOID
AtmArpMcHandleJoinOrLeave(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_JOIN/MARS_LEAVE message. If this is a copy of a
	message that we had sent, then there are two cases: (1) we are registering with
	MARS, in which case we send MARS_JOINs for all pending Joins (2) we were
	Joining a multicast group, in which case the Join operation is complete.

	If this is not a copy of a MARS_JOIN originated from us, then we check if
	the multicast group being joined is one to which we are sending. If so,
	and if the station joining is not already a member of that group, we add it.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	pTlvList				- All TLVs seen in this packet

Return Value:

	None

--*/
{
	PAA_MARS_JOIN_LEAVE_HEADER	pJoinHeader;
	PATMARP_INTERFACE			pInterface;		// IF on which this packet arrived
	ULONG						IfState;		// State of the interface
	IP_ADDRESS					IPAddress;
	PATMARP_IP_ENTRY			pIpEntry;		// Our entry for the group being joined
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_ATM_ENTRY			pAtmEntry;
	ULONG						MarsSeqNumber;	// MSN received in this packet
	ULONG						HostSeqNumber;	// Our MSN
	ULONG						SeqDiff;		// Difference between MSN and the HSN
	USHORT						Flags;			// From the JOIN packet
	BOOLEAN						bLayer3Group;	// Is a Layer 3 explicitly Joining?
	BOOLEAN						bCopyBitSet;	// Is the COPY bit set?
	BOOLEAN						bRegister;		// Is this a cluster member registering?
	BOOLEAN						bPunched;		// Is the Punched bit set?
	PUCHAR						pSrcAtmNumber;
	PUCHAR						pSrcAtmSubaddress;
	BOOLEAN						bIsAtmNumberOurs;	// Is the source ATM Number ours?
	ATM_ADDRESSTYPE				AtmNumberType;
	ULONG						AtmNumberLength;
	ATM_ADDRESSTYPE				AtmSubaddressType;
	ULONG						AtmSubaddressLength;
	IP_ADDRESS UNALIGNED *		pMinIPAddress;
	IP_ADDRESS UNALIGNED *		pMaxIPAddress;
	IP_ADDRESS					MinIPAddress;
	IP_ADDRESS					MaxIPAddress;
	BOOLEAN						IsJoin;			// Is this a JOIN?
	BOOLEAN						ProcessMcSendList = TRUE;

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;
	SeqDiff = 0;

	pJoinHeader = (PAA_MARS_JOIN_LEAVE_HEADER)pControlHeader;

	IsJoin = (pJoinHeader->op == NET_SHORT(AA_MARS_OP_TYPE_JOIN));

	//
	//  Get the MARS Sequence Number in this message.
	//
	MarsSeqNumber = NET_TO_HOST_LONG(pJoinHeader->msn);

	AA_ACQUIRE_IF_LOCK(pInterface);
	HostSeqNumber = pInterface->HostSeqNumber;	// save the old value
	pInterface->HostSeqNumber = MarsSeqNumber;	// and update
	IfState = AAMC_IF_STATE(pInterface);
	AA_RELEASE_IF_LOCK(pInterface);

	SeqDiff = MarsSeqNumber - HostSeqNumber;

	//
	//  Get all "flag" values:
	//
	Flags = pJoinHeader->flags;
	bLayer3Group = ((Flags & AA_MARS_JL_FLAG_LAYER3_GROUP) != 0);
	bCopyBitSet = ((Flags & AA_MARS_JL_FLAG_COPY) != 0);
	bRegister = ((Flags & AA_MARS_JL_FLAG_REGISTER) != 0);
	bPunched = ((Flags & AA_MARS_JL_FLAG_PUNCHED) != 0);

	//
	//  Get at the source ATM number
	//
	pSrcAtmNumber = ((PUCHAR)pJoinHeader +
 					sizeof(AA_MARS_JOIN_LEAVE_HEADER));

	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
		pJoinHeader->shtl,
		&AtmNumberType,
		&AtmNumberLength);

	//
	//  Get at the source ATM subaddress
	//
	pSrcAtmSubaddress = ((PUCHAR)pSrcAtmNumber + AtmNumberLength);
						
	AA_PKT_TYPE_LEN_TO_ATM_ADDRESS(
		pJoinHeader->sstl,
		&AtmSubaddressType,
		&AtmSubaddressLength);

	bIsAtmNumberOurs = ((AtmNumberType == pInterface->LocalAtmAddress.AddressType) &&
						(AtmNumberLength == pInterface->LocalAtmAddress.NumberOfDigits) &&
						(AA_MEM_CMP(pSrcAtmNumber,
									pInterface->LocalAtmAddress.Address,
									AtmNumberLength) == 0));


	pMinIPAddress = (PIP_ADDRESS)((PUCHAR)pJoinHeader +
 							sizeof(AA_MARS_JOIN_LEAVE_HEADER)+
 							AtmNumberLength +
 							AtmSubaddressLength +
 							(pJoinHeader->spln & ~AA_PKT_ATM_ADDRESS_BIT));

	pMaxIPAddress = (PIP_ADDRESS)((PUCHAR)pMinIPAddress +
							(pJoinHeader->tpln & ~AA_PKT_ATM_ADDRESS_BIT));

	AAMCDEBUGP(AAD_LOUD,
		("Handle %s: Flags 0x%x, OurAtmNum %d, Punch %d, Copy %d, pnum %d, IFState 0x%x\n",
			(IsJoin? "JOIN": "LEAVE"),
			Flags,
			(ULONG)bIsAtmNumberOurs,
			(ULONG)bPunched,
			(ULONG)bCopyBitSet,
			pJoinHeader->pnum,
			AAMC_IF_STATE(pInterface)
		));

	AAMCDEBUGP(AAD_LOUD,
		("Handle %s: Min %d.%d.%d.%d, Max %d.%d.%d.%d\n",
			(IsJoin? "JOIN": "LEAVE"),
			((PUCHAR)pMinIPAddress)[0], ((PUCHAR)pMinIPAddress)[1],
			((PUCHAR)pMinIPAddress)[2], ((PUCHAR)pMinIPAddress)[3],
			((PUCHAR)pMaxIPAddress)[0], ((PUCHAR)pMaxIPAddress)[1],
			((PUCHAR)pMaxIPAddress)[2], ((PUCHAR)pMaxIPAddress)[3]));

	if (bIsAtmNumberOurs && (!bPunched) && bCopyBitSet)
	{
		//
		//  Potentially sent by us
		//

		ProcessMcSendList = FALSE; // we may set it back  to true -- see below.

		if (IfState == AAMC_IF_STATE_REGISTERING)
		{
			if (IsJoin &&
				bRegister &&
				(pJoinHeader->pnum == 0))
			{
				BOOLEAN		WasRunning;

				//
				//  Registration complete. Get our Cluster Member ID.
				//  We store this in network order so that we can
				//  use it to fill packets directly.
				//
				AA_ACQUIRE_IF_LOCK(pInterface);

				pInterface->ClusterMemberId = pJoinHeader->cmi;

				AAMCDEBUGP(AAD_INFO,
					("==== HandleJoin: pIf 0x%x, registered with MARS, CMI %d!\n",
						 pInterface, pInterface->ClusterMemberId));

				AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_REGISTERED);

				//
				//  Stop the MARS Registration timer.
				//
				WasRunning = AtmArpStopTimer(&(pInterface->McTimer), pInterface);
				AA_ASSERT(WasRunning);

				//
				//  Start MARS wait-for-keepalive timer.
				//
				AtmArpStartTimer(
						pInterface,
						&(pInterface->McTimer),
						AtmArpMcMARSKeepAliveTimeout,
						pInterface->MARSKeepAliveTimeout,
						(PVOID)pInterface
					);

				//
				//  If we are recovering from a MARS failure,
				//  then we need to initiate revalidation of all
				//  groups we send to.
				//
				if (!AA_IS_FLAG_SET(pInterface->Flags,
									AAMC_IF_MARS_FAILURE_MASK,
									AAMC_IF_MARS_FAILURE_NONE))
				{
					AA_SET_FLAG(pInterface->Flags,
								AAMC_IF_MARS_FAILURE_MASK,
								AAMC_IF_MARS_FAILURE_NONE);

					SeqDiff = 2;	// a dirty way of triggering the above
				}

				//
				//  Send any JOINs we have pended waiting for registration
				//  to be over.
				//
				//  TBDMC: Section 5.4.1 recommends that if we are doing this
				//  after a failure recovery, then a random delay should be
				//  inserted between JOINs...
				//
				AtmArpMcSendPendingJoins(pInterface);
				//
				// IF Lock is released within the above.
				//
			}
			//
			//  else Discard: we aren't interested in this packet
			//
		}
		else
		{
			//
			//  Potentially a Join/Leave sent by us for a multicast group
			//
			if (pJoinHeader->pnum == HOST_TO_NET_SHORT(1))
			{

				//
				// Check if this came on the cluster control vc (or rather,  we cheat
				// and simply check if this is an incoming vc) -- if
				// so we want to also process the McSendList to see if
				// we need to add/remove ourselves to any mc ip send entries.
				//
				if (AA_IS_FLAG_SET(
						pVc->Flags,
						AA_VC_OWNER_MASK,
						AA_VC_OWNER_IS_CALLMGR))
				{
					ProcessMcSendList = TRUE;
				}

				//
				//  Get the IP address range of group being joined/left.
				//

				IPAddress =  *pMinIPAddress;

				AtmArpMcHandleJoinOrLeaveCompletion(
					pInterface,
					IPAddress,
					IPAddress ^ *pMaxIPAddress,
 					IsJoin);

			}
			//
			//  else Discard: bad pnum
			//
		}
	}

	if (ProcessMcSendList)
	{
		//
		//  Not sent by us, or punched, or it was sent by us but it came on the
		//  cluster control vc. For each <Min, Max> pair in this message,
		//  check if the pair overlaps any of the MC addresses to which
		//  we send packets. For each such IP entry, we find the MC ATM
		//  Entry corresponding to the host that is joining/leaving,
		//  and if necessary, mark it as needing a connection update.
		//
		//  Then, we go thru the list of MC IP Entries, and start a
		//  connection update on all marked entries.
		//

		BOOLEAN		bWorkDone;
		USHORT		MinMaxPairs;

		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		MinMaxPairs = NET_TO_HOST_SHORT(pJoinHeader->pnum);
		pIpEntry = pInterface->pMcSendList;

		while (MinMaxPairs--)
		{
			MinIPAddress = NET_LONG(*pMinIPAddress);
			MaxIPAddress = NET_LONG(*pMaxIPAddress);

			while (pIpEntry != NULL_PATMARP_IP_ENTRY)
			{
				IPAddress = NET_LONG(pIpEntry->IPAddress);

				if (IPAddress <= MaxIPAddress)
				{
					if (IPAddress >= MinIPAddress)
					{
						//
						//  This is an IP Entry that might be affected.
						//

						AA_ACQUIRE_IE_LOCK_DPC(pIpEntry);
						AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
						do
						{
							BOOLEAN				bNeedToUpdateConnection;
			
							if (pIpEntry->pAtmEntry == NULL_PATMARP_ATM_ENTRY)
							{
								//
								//  Skip this because it hasn't been resolved.
								//
								break;
							}
		
							pAtmEntry = pIpEntry->pAtmEntry;

							if (AA_IS_FLAG_SET(pAtmEntry->Flags,
												AA_ATM_ENTRY_TYPE_MASK,
												AA_ATM_ENTRY_TYPE_UCAST))
							{
								if ((AtmNumberType != pAtmEntry->ATMAddress.AddressType) ||
									(AtmNumberLength != pAtmEntry->ATMAddress.NumberOfDigits) ||
									(AA_MEM_CMP(pSrcAtmNumber,
											    pAtmEntry->ATMAddress.Address,
											    AtmNumberLength) != 0))
								{
									//
									//  Addresses don't match; if this is a new JOIN,
									//  then this IP Entry needs updating.
									//
									bNeedToUpdateConnection = (IsJoin);
								}
								else
								{
									bNeedToUpdateConnection = !(IsJoin);
								}
								 
								if (bNeedToUpdateConnection)
								{
									//
									//  Mark this entry so that we abort it below.
									//
									AA_SET_FLAG(pIpEntry->Flags,
												AA_IP_ENTRY_STATE_MASK,
												AA_IP_ENTRY_ABORTING);
								}

								break;	// end of Unicast ATM Entry case
							}

							//
							//  Multicast IP Entry.
							//
							pMcAtmEntry = AtmArpMcLookupAtmMember(
												pIpEntry->pAtmEntry,
												&(pAtmEntry->pMcAtmInfo->pMcAtmEntryList),
												pSrcAtmNumber,
												AtmNumberLength,
												AtmNumberType,
												pSrcAtmSubaddress,
												AtmSubaddressLength,
												IsJoin
												);
			
							if (pMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY)
							{
								AAMCDEBUGPATMADDR(AAD_EXTRA_LOUD,
									(IsJoin? "Join Addr: ": "Leave Addr"),
									&pMcAtmEntry->ATMAddress);

								if (!IsJoin)
								{
									//
									//  Mark this entry so that it will be dropped from
									//  our connection to this multicast group.
									//
									if (AA_IS_FLAG_SET(pMcAtmEntry->Flags,
														AA_IPMC_AE_GEN_STATE_MASK,
														AA_IPMC_AE_VALID))
									{
										AA_SET_FLAG(pMcAtmEntry->Flags,
													AA_IPMC_AE_GEN_STATE_MASK,
													AA_IPMC_AE_INVALID);
			
										bNeedToUpdateConnection = TRUE;
									}
								}
								else
								{
									bNeedToUpdateConnection =
										(AA_IS_FLAG_SET(pMcAtmEntry->Flags,
														AA_IPMC_AE_CONN_STATE_MASK,
														AA_IPMC_AE_CONN_DISCONNECTED));
								}
			
								if (bNeedToUpdateConnection)
								{
									//
									//  Mark this ATM MC entry as wanting a connection
									//  update.
									//
									pIpEntry->pAtmEntry->pMcAtmInfo->Flags |=
												AA_IPMC_AI_WANT_UPDATE;
								}
							}
							break;
						}
						while (FALSE);
									
						AA_RELEASE_IE_LOCK_DPC(pIpEntry);
					}

					pIpEntry = pIpEntry->pNextMcEntry;
				}
				else
				{
					//
					//  This IP Address lies beyond this <Min, Max> pair.
					//  Go to the next pair.
					//
					break;
				}
			}

			if (pIpEntry == NULL_PATMARP_IP_ENTRY)
			{
				break;
			}

			pMinIPAddress = (PIP_ADDRESS)((PUCHAR)pMaxIPAddress +
								(pJoinHeader->tpln & ~AA_PKT_ATM_ADDRESS_BIT));

		} // while loop processing all <Min, Max> pairs

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		//
		//  Now, for each ATM MC entry that we marked in the previous
		//  step, start a connection update.
		//
		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		//
		// We keep running through the McSendList, stopping when no work is done.
		// This is because in order to "do work" we must release the table lock,
		// in which case the McSendList may be modified by someone else.
		//
		do
		{
			bWorkDone = FALSE;

			for (pIpEntry = pInterface->pMcSendList;
 				 pIpEntry != NULL_PATMARP_IP_ENTRY;
 				 pIpEntry = pIpEntry->pNextMcEntry)
			{
				ULONG		Flags;

				pAtmEntry = pIpEntry->pAtmEntry;

				if (pAtmEntry == NULL_PATMARP_ATM_ENTRY)
				{
					//
					//  Not yet resolved. Skip this one.
					//
					continue;
				}

				if (AA_IS_FLAG_SET(pIpEntry->Flags,
									AA_IP_ENTRY_STATE_MASK,
									AA_IP_ENTRY_ABORTING))
				{
					//
					//  Must be a unicast entry that we marked above.
					//
					AA_RELEASE_IF_TABLE_LOCK(pInterface);
					
					bWorkDone = TRUE;
					AA_ACQUIRE_IE_LOCK(pIpEntry);
					AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

					AtmArpAbortIPEntry(pIpEntry);
					//
					//  IE lock is released within the above.
					//

					AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
					break;
				}

				//
				//  If this is a unicast ATM Entry, there is nothing
				//  more to be done. If this needed revalidation, 
				//  we would have aborted it above.
				//
				if (AA_IS_FLAG_SET(pAtmEntry->Flags,
									AA_ATM_ENTRY_TYPE_MASK,
									AA_ATM_ENTRY_TYPE_UCAST))
				{
					continue;
				}

				AA_ASSERT(pAtmEntry->pMcAtmInfo != NULL_PATMARP_IPMC_ATM_INFO);

				Flags = pAtmEntry->pMcAtmInfo->Flags;

				if (Flags & AA_IPMC_AI_BEING_UPDATED)
				{
					//
					//  Nothing to be done on this one.
					//
					continue;
				}

				if (Flags & AA_IPMC_AI_WANT_UPDATE) 
				{
					//
					//  Needs a connection update.
					//

					AA_RELEASE_IF_TABLE_LOCK(pInterface);

					bWorkDone = TRUE;
					AA_ACQUIRE_AE_LOCK(pAtmEntry);
					AtmArpMcUpdateConnection(pAtmEntry);
					//
					//  AE Lock is released within the above.
					//

					AA_ACQUIRE_IF_TABLE_LOCK(pInterface);
					break;
				}
			}
		}
		while (bWorkDone);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

	} // else (Packet not a copy of ours)


	//
	//  Finally (according to Section 5.1.4.2 of RFC 2022), check
	//  if we just had a jump in the MSN.
	//
	if ((SeqDiff != 1) && (SeqDiff != 0))
	{
		AAMCDEBUGP(AAD_INFO,
			("HandleJoin+Leave: IF 0x%x: Bad seq diff %d, MSN 0x%x, HSN 0x%x\n",
				pInterface, SeqDiff, MarsSeqNumber, HostSeqNumber));
		AtmArpMcRevalidateAll(pInterface);
	}
}





VOID
AtmArpMcHandleNak(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_NAK message. We mark the IP Entry corresponding
	to the IP Address being resolved as having seen a NAK. This is so that
	we don't send another MARS Request for this IP address too soon. We also
	start a timer at the end of which we unmark this IP Entry, so that
	we may try to resolve it again.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	IN	PAA_MARS_TLV_LIST			pTlvList

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PAA_MARS_REQ_NAK_HEADER	pNakHeader;
	PATMARP_IP_ENTRY		pIpEntry;		// Entry for IP address being resolved
	PATMARP_ATM_ENTRY		pAtmEntry;		// Corresponding ATM Entry
	IP_ADDRESS				IPAddress;		// the address being queried
	BOOLEAN					bWasRunning;	// Was a timer running?
	PNDIS_PACKET			PacketList;		// Packets queued for sending
	ULONG					rc;

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;

	pNakHeader = (PAA_MARS_REQ_NAK_HEADER)pControlHeader;

	do
	{

		//
		//  Get the group address being responded to.
		//
		IPAddress = *(IP_ADDRESS UNALIGNED *)(
						(PUCHAR)pNakHeader +
						sizeof(AA_MARS_REQ_NAK_HEADER) +
						(pNakHeader->shtl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pNakHeader->sstl & ~AA_PKT_ATM_ADDRESS_BIT) +
						(pNakHeader->spln)
						);

		AAMCDEBUGP(AAD_LOUD,
		 ("McHandleNak: 0x%x, IP %d.%d.%d.%d\n",
						pNakHeader,
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));

		//
		//  Get the IP Entry for this address.
		//
		AA_ACQUIRE_IF_TABLE_LOCK(pInterface);

		pIpEntry = AtmArpSearchForIPAddress(
						pInterface,
						&IPAddress,
						IE_REFTYPE_TMP,
						TRUE,		// this is a multicast/broadcast address
						FALSE		// don't create a new entry if the address isn't found
						);

		AA_RELEASE_IF_TABLE_LOCK(pInterface);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{
			//
			// AtmArpSearchForIPAddress addreffs pIpEntry for us ...
			//
			ULONG		rc;
			AA_ACQUIRE_IE_LOCK(pIpEntry);
			AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TMP);
			if (rc == 0)
			{
				// Oops, IP address has gone away...
				pIpEntry = NULL_PATMARP_IP_ENTRY;
			}
		}

		if (pIpEntry == NULL_PATMARP_IP_ENTRY)
		{

			AAMCDEBUGP(AAD_INFO, ("McHandleNak: No IP Entry for %d.%d.%d.%d\n",
						((PUCHAR)&IPAddress)[0],
						((PUCHAR)&IPAddress)[1],
						((PUCHAR)&IPAddress)[2],
						((PUCHAR)&IPAddress)[3]));
			break;
		}

		bWasRunning = AtmArpStopTimer(&(pIpEntry->Timer), pInterface);
		if (bWasRunning)
		{
			rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER); // Timer ref
			AA_ASSERT(rc != 0);
		}
		else
		{
			AAMCDEBUGP(AAD_WARNING,
 			("McHandleNak: 0x%x, IP %d.%d.%d.%d NO TIMER RUNNING\n",
							pNakHeader,
							((PUCHAR)&IPAddress)[0],
							((PUCHAR)&IPAddress)[1],
							((PUCHAR)&IPAddress)[2],
							((PUCHAR)&IPAddress)[3]));
		}

		//
		//  Take out all packets queued on this entry
		//
		PacketList = pIpEntry->PacketList;
		pIpEntry->PacketList = (PNDIS_PACKET)NULL;

		//
		//  Mark this IP Entry as being resolved, but seen NAK.
		//
		AA_SET_FLAG(pIpEntry->Flags,
					AA_IP_ENTRY_MC_RESOLVE_MASK,
					AA_IP_ENTRY_MC_RESOLVED);
		AA_SET_FLAG(pIpEntry->Flags,
					AA_IP_ENTRY_MC_VALIDATE_MASK,
					AA_IP_ENTRY_MC_NO_REVALIDATION);
		AA_SET_FLAG(pIpEntry->Flags,
					AA_IP_ENTRY_STATE_MASK,
					AA_IP_ENTRY_SEEN_NAK);
		
		
		AtmArpStartTimer(
					pInterface,
					&(pIpEntry->Timer),
					AtmArpNakDelayTimeout,
					pInterface->MinWaitAfterNak,
					(PVOID)pIpEntry		// Context
					);

		AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref

		AA_RELEASE_IE_LOCK(pIpEntry);

		//
		//  Free any packets that were queued up.
		//
		if (PacketList != (PNDIS_PACKET)NULL)
		{
			AtmArpFreeSendPackets(
						pInterface,
						PacketList,
						FALSE	// No headers on these
						);
		}

		break;
	}
	while (FALSE);

}


VOID
AtmArpMcHandleGroupListReply(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_GROUPLIST_REPLY message.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	IN	PAA_MARS_TLV_LIST			pTlvList

Return Value:

	None

--*/
{
	AAMCDEBUGP(AAD_WARNING, ("GroupListReply unexpected\n"));
	AA_ASSERT(FALSE);
}


VOID
AtmArpMcHandleRedirectMap(
	IN	PATMARP_VC					pVc,
	IN	PAA_MARS_PKT_FIXED_HEADER	pControlHeader,
	IN	ULONG						TotalLength,
	IN	PAA_MARS_TLV_LIST			pTlvList
)
/*++

Routine Description:

	Process a received MARS_REDIRECT_MAP message. For now, we simply
	refresh the MARS Keepalive timer.

	TBDMC: Parse fully, and update MARS list, and migrate if necessary.

Arguments:

	pVc						- Pointer to our VC structure on which the packet
							  arrived.
	pControlHeader			- Pointer to the start of the packet contents
	TotalLength				- Total length of this packet.
	IN	PAA_MARS_TLV_LIST			pTlvList

Return Value:

	None

--*/
{
	PATMARP_INTERFACE				pInterface;
	PAA_MARS_REDIRECT_MAP_HEADER	pRedirectHeader;
	ULONG							MarsSeqNumber;
	ULONG							HostSeqNumber;
	ULONG							SeqDiff;

	//
	//  Initialize
	//
	pInterface = pVc->pInterface;
	SeqDiff = 0;

	AAMCDEBUGP(AAD_VERY_LOUD, ("### REDIRECT MAP 0x%x on VC 0x%x, IF 0x%x/0x%x\n",
				pControlHeader, pVc, pInterface, pInterface->Flags));

	pRedirectHeader = (PAA_MARS_REDIRECT_MAP_HEADER)pControlHeader;

	AA_ACQUIRE_IF_LOCK(pInterface);

	if ((AAMC_IF_STATE(pInterface) == AAMC_IF_STATE_REGISTERED) &&
		(AA_IS_FLAG_SET(pInterface->Flags,
						AAMC_IF_MARS_FAILURE_MASK,
						AAMC_IF_MARS_FAILURE_NONE)))
	{
		//
		//  Get the MARS Sequence Number in this message.
		//
		MarsSeqNumber = NET_TO_HOST_LONG(pRedirectHeader->msn);

		HostSeqNumber = pInterface->HostSeqNumber;	// save the old value
		pInterface->HostSeqNumber = MarsSeqNumber;	// and update

		SeqDiff = MarsSeqNumber - HostSeqNumber;

		//
		//  The MC Timer running on the IF must be MARS Keepalive
		//
		AA_ASSERT(pInterface->McTimer.TimeoutHandler == AtmArpMcMARSKeepAliveTimeout);

		AAMCDEBUGP(AAD_EXTRA_LOUD,
			 ("Redirect MAP: refreshing keepalive on IF 0x%x, new HSN %d\n",
				pInterface, pInterface->HostSeqNumber));

		AtmArpRefreshTimer(&(pInterface->McTimer));
	}

	AA_RELEASE_IF_LOCK(pInterface);

	//
	//  Finally (according to Section 5.1.4.2 of RFC 2022), check
	//  if we just had a jump in the MSN.
	//
	if ((SeqDiff != 1) && (SeqDiff != 0))
	{
		AAMCDEBUGP(AAD_INFO,
			("HandleRedirectMap: IF 0x%x: Bad seq diff %d, MSN 0x%x, HSN 0x%x\n",
				pInterface, SeqDiff, MarsSeqNumber, HostSeqNumber));
		AtmArpMcRevalidateAll(pInterface);
	}

	return;
}

#endif // IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ioctl.c

Abstract:

	Handler routines for Internal IOCTLs, including IOCTL_ATMARP_REQUEST
	to resolve an IP address to an ATM address.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     09-16-96    Created

Notes:

--*/

#include <precomp.h>
#include "ioctl.h"

#define _FILENUMBER 'TCOI'


#if !BINARY_COMPATIBLE
#ifdef CUBDD

NTSTATUS
AtmArpInternalDeviceControl(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
)
/*++

Routine Description:

	This entry point is called by the System when somebody sends an
	"Internal" IOCTL to us.

Arguments:

	pDeviceObject		- Pointer to device object we created for ourselves.
	pIrp				- Pointer to IRP to be processed.

Return Value:

	None

--*/
{
	NTSTATUS				Status;				// Return value
	PIO_STACK_LOCATION		pIrpStack;
	ULONG					OutputBufferLength;	// Space for output values
	ULONG					IoControlCode;		// Operation to be performed

	PATMARP_INTERFACE		pInterface;			// IF to which this op is directed

	//
	//  Initialize
	//
	Status = STATUS_UNSUCCESSFUL;
	pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
	pIrp->IoStatus.Information = 0;

	//
	//  Get all information in the IRP
	//
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	OutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

	IoControlCode = pIrpStack->MinorFunction;

	IoMarkIrpPending(pIrp);
	pInterface = (PATMARP_INTERFACE)pIrpStack->FileObject->FsContext;

	AADEBUGP(AAD_VERY_LOUD,
		("Internal Ctl: IF 0x%x, Code 0x%x, pIrp 0x%x, UserBuf 0x%x\n",
				pInterface, IoControlCode, pIrp, pIrp->UserBuffer));

	switch (IoControlCode)
	{
		case IOCTL_ATMARP_REQUEST:
			Status = AtmArpIoctlArpRequest(
							pInterface,
							pIrp
							);
			break;
		
		default:
			Status = STATUS_UNSUCCESSFUL;
			break;
	}

	if (Status != NDIS_STATUS_PENDING)
	{
		pIrpStack->Control &= ~SL_PENDING_RETURNED;
		pIrp->IoStatus.Status = Status;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	}

	return (Status);
}



NTSTATUS
AtmArpIoctlArpRequest(
	IN	PATMARP_INTERFACE			pInterface	OPTIONAL,
	IN	PIRP						pIrp
)
/*++

Routine Description:

	Handle an ARP request from CUB-DD to resolve an IP address to an
	ATM address on the given Interface. If we already have a mapping in
	the ARP table, we return the corresponding ATM address. Otherwise,
	we initiate Address Resolution, unless the process is already going
	on.

	A special case is a NULL value of pInterface, meaning search for
	the IP address on all available Interfaces. This special case is not
	supported.

Arguments:

	pInterface			- Pointer to ATMARP Interface, if known.
	pIrp				- Pointer to IRP carrying the request.

Return Value:

	STATUS_SUCCESS if we found a match (we copy in the ATM address
	into the UserBuffer if so).
	STATUS_PENDING if we didn't find a match, but address resolution is
	in progress.
	STATUS_UNSUCCESSFUL if we didn't find a match, and couldn't start
	address resolution for the IP address.

--*/
{
	PIO_STACK_LOCATION	pIrpStack;
	NTSTATUS			Status;
	PATMARP_IP_ENTRY	pIpEntry;
	PATMARP_ATM_ENTRY	pAtmEntry;
	PATMARP_REQUEST		pRequest;
	IP_ADDRESS			IPAddress;
	BOOLEAN				IsBroadcast;	// Is the requested address broadcast/multicast?
	ATMARP_REQUEST		Request;

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	Status = STATUS_SUCCESS;

	do
	{
		if (pInterface == NULL_PATMARP_INTERFACE)
		{
			AADEBUGP(AAD_WARNING, ("IoctlArpRequest: NULL IF: failing request\n"));
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		if (pIrpStack->Parameters.Read.Length < sizeof(ATMARP_REQUEST))
		{
			AADEBUGP(AAD_WARNING, ("IoctlArpRequest: Length %d too small\n",
						pIrpStack->Parameters.Read.Length));
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		AA_STRUCT_ASSERT(pInterface, aai);

		try
		{
			AA_COPY_MEM(&Request, pIrp->UserBuffer, sizeof(ATMARP_REQUEST));
		}
		except (EXCEPTION_EXECUTE_HANDLER)
		{
			Status = STATUS_UNSUCCESSFUL;
		}

		if (Status != STATUS_SUCCESS)
		{
			break;
		}

		pRequest = &Request;

		AA_ACQUIRE_IF_LOCK(pInterface);
		IsBroadcast = AtmArpIsBroadcastIPAddress(pRequest->IpAddress, pInterface);
		pIpEntry = AtmArpSearchForIPAddress(
						pInterface,
						(PIP_ADDRESS)&(pRequest->IpAddress),
						IE_REFTYPE_TMP,
						IsBroadcast,
						TRUE
						);
		AA_RELEASE_IF_LOCK(pInterface);

		if (pIpEntry != NULL_PATMARP_IP_ENTRY)
		{

			AA_ACQUIRE_IE_LOCK(pIpEntry);

			//
			// AtmArpSearchForIPAddress addreffs pIpEntry for us ...
			// Since this could be a new entry (ref count == 1), we
			// don't call AA_DEREF_IE -- instead we
			// simply decrement the ref count.
			//
			AA_ASSERT(pIpEntry->RefCount > 0);
			AA_DEREF_IE_NO_DELETE(pIpEntry, IE_REFTYPE_TMP);


			if (AA_IS_FLAG_SET(pIpEntry->Flags,
								AA_IP_ENTRY_STATE_MASK,
								AA_IP_ENTRY_RESOLVED))
			{
				AA_ASSERT(pIpEntry->RefCount > 0);
				AA_ASSERT(pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY);
				pAtmEntry = pIpEntry->pAtmEntry;
				pRequest->HwAddressLength = pAtmEntry->ATMAddress.NumberOfDigits;
				AA_COPY_MEM(pRequest->HwAddress,
							pAtmEntry->ATMAddress.Address,
							ATM_ADDRESS_LENGTH);

				AA_RELEASE_IE_LOCK(pIpEntry);

				Status = STATUS_SUCCESS;

				//
				//  Copy this back.
				//
				try
				{
					AA_COPY_MEM(&Request, pIrp->UserBuffer, sizeof(ATMARP_REQUEST));
				}
				except (EXCEPTION_EXECUTE_HANDLER)
				{
					Status = STATUS_UNSUCCESSFUL;
				}
			}
			else
			{
				//
				//  Queue this IRP pending Address Resolution.
				//
				PushEntryList(&(pIpEntry->PendingIrpList),
								(PSINGLE_LIST_ENTRY)&(pIrp->Tail.Overlay.ListEntry));


				//
				//  Start resolving this IP address, if not already resolving.
				//
				AtmArpResolveIpEntry(pIpEntry);

				//
				//  IE Lock is released within the above.
				//
				Status = STATUS_PENDING;
			}
		}
		else
		{
			//
			//  Couldn't find a matching IP Entry, and couldn't create
			//  a new one either.
			//
			Status = STATUS_UNSUCCESSFUL;
		}
		break;
	}
	while (FALSE);

	if (Status == STATUS_SUCCESS)
	{
		pIrp->IoStatus.Information = 0;
	}

	return (Status);
}



VOID
AtmArpCompleteArpIrpList(
	IN	SINGLE_LIST_ENTRY			ListHead,
	IN	PATM_ADDRESS				pAtmAddress	OPTIONAL
)
/*++

Routine Description:

	Complete a list of pended IRPs waiting for an IP address to be resolved
	to an ATM address. If resolution was successful, pAtmAddress is non-NULL,
	and points to the ATM address corresponding to the queried IP address.

	We copy in this ATM address into the IRP buffer, if successful. In any
	case, we complete all IRPs in the list.

	NOTE: we free the ATM Address structure here.

Arguments:

	ListHead	- Head of a list of pending IRPs.
	pAtmAddress	- Pointer to ATM address if address resolution was successful.

Return Value:

	None

--*/
{
	PSINGLE_LIST_ENTRY		pEntry;
	PATMARP_REQUEST			pRequest;
	PIRP					pIrp;
	NTSTATUS				Status;

	if (pAtmAddress != (PATM_ADDRESS)NULL)
	{
		Status = STATUS_SUCCESS;
	}
	else
	{
		Status = STATUS_UNSUCCESSFUL;
	}

	for (;;)
	{
		pEntry = PopEntryList(&ListHead);
		if (pEntry == (PSINGLE_LIST_ENTRY)NULL)
		{
			break;
		}
		pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);

		pRequest = (PATMARP_REQUEST)(pIrp->UserBuffer);

		try
		{
			if (pAtmAddress != (PATM_ADDRESS)NULL)
			{
				AA_COPY_MEM(pRequest->HwAddress,
							pAtmAddress->Address,
							ATM_ADDRESS_LENGTH);
				pRequest->HwAddressLength = pAtmAddress->NumberOfDigits;
			}
		}
		except (EXCEPTION_EXECUTE_HANDLER)
		{
			Status = STATUS_UNSUCCESSFUL;
		}
			
		AA_COMPLETE_IRP(pIrp, Status, 0);
	}

	if (pAtmAddress != (PATM_ADDRESS)NULL)
	{
		AA_FREE_MEM(pAtmAddress);
	}

	return;
}
#endif // CUBDD


NTSTATUS
AtmArpHandleIoctlRequest(
	IN	PIRP					pIrp,
	IN	PIO_STACK_LOCATION		pIrpSp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS			Status = STATUS_SUCCESS;

	PUCHAR				pBuf;  
	UINT				BufLen;
	// PINTF				pIntF	= NULL;

	pIrp->IoStatus.Information = 0;
	pBuf = pIrp->AssociatedIrp.SystemBuffer;
	BufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

	AADEBUGP(AAD_INFO,
		 ("AtmArpHandleIoctlRequest: Code = 0x%lx\n",
			pIrpSp->Parameters.DeviceIoControl.IoControlCode));
					
	
	return Status;
}

#endif // !BINARY_COMPATIBLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\marspkt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	marspkt.h

Abstract:

	Definitions for MARS packets.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     12-12-96    Created

Notes:

--*/


#ifndef _MARS_PKT__H
#define _MARS_PKT__H

#include "arppkt.h"


#include <pshpack1.h>

//
//  LLC and OUI values for all (control and data) Multicast packets.
//
#define MC_LLC_SNAP_LLC0					((UCHAR)0xAA)
#define MC_LLC_SNAP_LLC1					((UCHAR)0xAA)
#define MC_LLC_SNAP_LLC2					((UCHAR)0x03)
#define MC_LLC_SNAP_OUI0					((UCHAR)0x00)
#define MC_LLC_SNAP_OUI1					((UCHAR)0x00)
#define MC_LLC_SNAP_OUI2					((UCHAR)0x5E)


//
//  "EtherType" (i.e. PID) values for MARS control and multicast data
//
#define AA_PKT_ETHERTYPE_MARS_CONTROL		((USHORT)0x003)
#define AA_PKT_ETHERTYPE_MARS_CONTROL_NS	((USHORT)0x0300)
#define AA_PKT_ETHERTYPE_MC_TYPE1			((USHORT)0x001)		// Type #1 data
#define AA_PKT_ETHERTYPE_MC_TYPE1_NS		((USHORT)0x0100)		// Type #1 data (Net format)
#define AA_PKT_ETHERTYPE_MC_TYPE2			((USHORT)0x004)		// Type #2 data

//
//  Address Family value for MARS control packets.
//
#define AA_MC_MARS_HEADER_AFN				((USHORT)0x000F)
#define AA_MC_MARS_HEADER_AFN_NS			((USHORT)0x0F00)

//
//  Common preamble for all packets: control, type #1 data and type #2 data.
//  This is the same as for ATMARP packets. The OUI bytes dictate whether
//  a packet is destined to a Unicast IP/ATM entity or to the Multicast IP/ATM
//  entity.
//
typedef AA_PKT_LLC_SNAP_HEADER AA_MC_MARS_PKT_HEADER;

typedef AA_MC_MARS_PKT_HEADER UNALIGNED *PAA_MC_MARS_PKT_HEADER;



//
//  Short form encapsulation for Type #1 Multicast data packets.
//
typedef struct _AA_MC_PKT_TYPE1_SHORT_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x001
	USHORT						cmi;			// Cluster Member ID
	USHORT						pro;			// Protocol type
} AA_MC_PKT_TYPE1_SHORT_HEADER;

typedef AA_MC_PKT_TYPE1_SHORT_HEADER UNALIGNED *PAA_MC_PKT_TYPE1_SHORT_HEADER;


//
//  Long form encapsulation for Type #1 Multicast data packets.
//
typedef struct _AA_MC_PKT_TYPE1_LONG_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x001
	USHORT						cmi;			// Cluster Member ID
	USHORT						pro;			// Protocol type
	UCHAR						snap[5];
	UCHAR						padding[3];

} AA_MC_PKT_TYPE1_LONG_HEADER;

typedef AA_MC_PKT_TYPE1_LONG_HEADER UNALIGNED *PAA_MC_PKT_TYPE1_LONG_HEADER;


//
//  Short form encapsulation for Type #2 Multicast data packets.
//
typedef struct _AA_MC_PKT_TYPE2_SHORT_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x004
	UCHAR						sourceID[8];	// Ignored
	USHORT						pro;			// Protocol type
	UCHAR						padding[2];
} AA_MC_PKT_TYPE2_SHORT_HEADER;

typedef AA_MC_PKT_TYPE2_SHORT_HEADER UNALIGNED *PAA_MC_PKT_TYPE2_SHORT_HEADER;


//
//  Long form encapsulation for Type #2 Multicast data packets.
//
typedef struct _AA_MC_PKT_TYPE2_LONG_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x004
	UCHAR						sourceID[8];	// Ignored
	USHORT						pro;			// Protocol type
	UCHAR						snap[5];
	UCHAR						padding[1];
} AA_MC_PKT_TYPE2_LONG_HEADER;

typedef AA_MC_PKT_TYPE2_LONG_HEADER UNALIGNED *PAA_MC_PKT_TYPE2_LONG_HEADER;



//
//  The Fixed header part of every MARS control packet.
//
typedef struct _AA_MARS_PKT_FIXED_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
} AA_MARS_PKT_FIXED_HEADER;

typedef AA_MARS_PKT_FIXED_HEADER UNALIGNED *PAA_MARS_PKT_FIXED_HEADER;



//
//  MARS control packet types
//
#define AA_MARS_OP_TYPE_REQUEST				((USHORT)1)
#define AA_MARS_OP_TYPE_MULTI				((USHORT)2)
#define AA_MARS_OP_TYPE_JOIN				((USHORT)4)
#define AA_MARS_OP_TYPE_LEAVE				((USHORT)5)
#define AA_MARS_OP_TYPE_NAK					((USHORT)6)
#define AA_MARS_OP_TYPE_GROUPLIST_REQUEST	((USHORT)10)
#define AA_MARS_OP_TYPE_GROUPLIST_REPLY		((USHORT)11)
#define AA_MARS_OP_TYPE_REDIRECT_MAP		((USHORT)12)
#define AA_MARS_OP_TYPE_MIGRATE				((USHORT)13)


//
//  Format of MARS JOIN and LEAVE message headers.
//
typedef struct _AA_MARS_JOIN_LEAVE_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (JOIN/LEAVE)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						tpln;			// Length of group address
	USHORT						pnum;			// Number of group address pairs
	USHORT						flags;			// LAYER3GRP, COPY and REGISTER bits
	USHORT						cmi;			// Cluster Member ID
	ULONG						msn;			// MARS Sequence Number
} AA_MARS_JOIN_LEAVE_HEADER;

typedef AA_MARS_JOIN_LEAVE_HEADER UNALIGNED *PAA_MARS_JOIN_LEAVE_HEADER;


//
//  Bit definitions for flags in JOIN/LEAVE messages
//
#define AA_MARS_JL_FLAG_LAYER3_GROUP			NET_SHORT((USHORT)0x8000)
#define AA_MARS_JL_FLAG_COPY					NET_SHORT((USHORT)0x4000)
#define AA_MARS_JL_FLAG_REGISTER				NET_SHORT((USHORT)0x2000)
#define AA_MARS_JL_FLAG_PUNCHED					NET_SHORT((USHORT)0x1000)
#define AA_MARS_JL_FLAG_SEQUENCE_MASK			NET_SHORT((USHORT)0x00ff)

//
//  Format of MARS REQUEST and MARS NAK message header.
//
typedef struct _AA_MARS_REQ_NAK_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (REQUEST/NAK)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						thtl;			// Type & Length of target ATM number
	UCHAR						tstl;			// Type & Length of target ATM subaddress
	UCHAR						tpln;			// Length of target group address
	UCHAR						pad[8];
} AA_MARS_REQ_NAK_HEADER;

typedef AA_MARS_REQ_NAK_HEADER UNALIGNED *PAA_MARS_REQ_NAK_HEADER;


//
//  Format of MARS MULTI message header.
//
typedef struct _AA_MARS_MULTI_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (MULTI)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						thtl;			// Type & Length of target ATM number
	UCHAR						tstl;			// Type & Length of target ATM subaddress
	UCHAR						tpln;			// Length of target group address
	USHORT						tnum;			// Number of target ATM addresses returned
	USHORT						seqxy;			// Boolean X and sequence number Y
	ULONG						msn;			// MARS Sequence Number

} AA_MARS_MULTI_HEADER;

typedef AA_MARS_MULTI_HEADER UNALIGNED *PAA_MARS_MULTI_HEADER;


//
//  Format of MARS MIGRATE message header.
//
typedef struct _AA_MARS_MIGRATE_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (MIGRATE)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						thtl;			// Type & Length of target ATM number
	UCHAR						tstl;			// Type & Length of target ATM subaddress
	UCHAR						tpln;			// Length of target group address
	USHORT						tnum;			// Number of Target ATM addresses returned
	USHORT						resv;			// Reserved
	ULONG						msn;			// MARS Sequence Number
} AA_MARS_MIGRATE_HEADER;

typedef AA_MARS_MIGRATE_HEADER UNALIGNED *PAA_MARS_MIGRATE_HEADER;



//
//  Format of MARS REDIRECT MAP message header.
//
typedef struct _AA_MARS_REDIRECT_MAP_HEADER
{
	UCHAR						LLC[3];
	UCHAR						OUI[3];
	USHORT						PID;			// 0x003
	USHORT						afn;			// Address Family (0x000F)
	UCHAR						pro[7];			// Protocol Identification
	UCHAR						hdrrsv[3];		// Reserved.
	USHORT						chksum;			// Checksum across entire MARS message
	USHORT						extoff;			// Extensions offset
	USHORT						op;				// Operation code (REDIRECT MAP)
	UCHAR						shtl;			// Type & Length of source ATM number
	UCHAR						sstl;			// Type & Length of source ATM subaddress
	UCHAR						spln;			// Source protocol address length
	UCHAR						thtl;			// Type & Length of target ATM number
	UCHAR						tstl;			// Type & Length of target ATM subaddress
	UCHAR						redirf;			// Flag controlling redirect behaviour
	USHORT						tnum;			// Number of MARS addresses returned
	USHORT						seqxy;			// Boolean flag x and seq number y
	ULONG						msn;			// MARS Sequence Number
} AA_MARS_REDIRECT_MAP_HEADER;


typedef AA_MARS_REDIRECT_MAP_HEADER UNALIGNED *PAA_MARS_REDIRECT_MAP_HEADER;


//
//  Bit assignments for Boolean flag X and sequence number Y in
//  "seqxy" fields in MARS messages.
//
#define AA_MARS_X_MASK			((USHORT)0x8000)
#define AA_MARS_Y_MASK			((USHORT)0x7fff)


//
//  Initial value for sequence number Y
//
#define AA_MARS_INITIAL_Y		((USHORT)1)


//
//  Structure of a MARS packet extension element (TLV = Type, Length, Value)
//
typedef struct _AA_MARS_TLV_HDR
{
	USHORT						Type;
	USHORT						Length;		// Number of significant octets in Value

} AA_MARS_TLV_HDR;

typedef AA_MARS_TLV_HDR UNALIGNED *PAA_MARS_TLV_HDR;

//
//  Our experimental TLV that we use in MARS MULTI messages to
//  indicate that the returned target address is that of an MCS.
//
typedef struct _AA_MARS_TLV_MULTI_IS_MCS
{
	AA_MARS_TLV_HDR;

} AA_MARS_TLV_MULTI_IS_MCS;

typedef AA_MARS_TLV_MULTI_IS_MCS UNALIGNED *PAA_MARS_TLV_MULTI_IS_MCS;

#define AAMC_TLVT_MULTI_IS_MCS			((USHORT)0x3a00)

//
//  Type of a NULL TLV
//
#define AAMC_TLVT_NULL					((USHORT)0x0000)

//
//  Bit definitions for the Type field in a MARS TLV.
//
//
//  The Least significant 14 bits indicate the actual type.
//
#define AA_MARS_TLV_TYPE_MASK			((USHORT)0x3fff)

//
//  The most significant 2 bits define the action to be taken
//  when we receive a TLV type that we don't recognize.
//
#define AA_MARS_TLV_ACTION_MASK			((USHORT)0xc000)
#define AA_MARS_TLV_TA_SKIP				((USHORT)0x0000)
#define AA_MARS_TLV_TA_STOP_SILENT		((USHORT)0x1000)
#define AA_MARS_TLV_TA_STOP_LOG			((USHORT)0x2000)
#define AA_MARS_TLV_TA_RESERVED			((USHORT)0x3000)



#include <poppack.h>


//
//  TLV List, internal representation. This stores information about
//  all TLVs sent/received in a packet. For each TLV, there is a
//  BOOLEAN that says whether it is present or not.
//
typedef struct _AA_MARS_TLV_LIST
{
	//
	//  MULTI_IS_MCS TLV:
	//
	BOOLEAN						MultiIsMCSPresent;
	BOOLEAN						MultiIsMCSValue;

	//
	//  Add other TLVs...
	//

} AA_MARS_TLV_LIST, *PAA_MARS_TLV_LIST;



/*++
BOOLEAN
AAMC_PKT_IS_TYPE1_DATA(
	IN	PAA_MC_PKT_TYPE1_SHORT_HEADER		pH
)
--*/
#define AAMC_PKT_IS_TYPE1_DATA(pH)	\
			(((pH)->LLC[0] == MC_LLC_SNAP_LLC0) && \
			 ((pH)->LLC[1] == MC_LLC_SNAP_LLC1) && \
			 ((pH)->LLC[2] == MC_LLC_SNAP_LLC2) && \
			 ((pH)->OUI[0] == MC_LLC_SNAP_OUI0) && \
			 ((pH)->OUI[1] == MC_LLC_SNAP_OUI1) && \
			 ((pH)->OUI[2] == MC_LLC_SNAP_OUI2) && \
			 ((pH)->PID == NET_SHORT(AA_PKT_ETHERTYPE_MC_TYPE1)) && \
			 ((pH)->pro == NET_SHORT(AA_PKT_ETHERTYPE_IP)))

/*++
BOOLEAN
AAMC_PKT_IS_TYPE2_DATA(
	IN	PAA_MC_PKT_TYPE2_SHORT_HEADER		pH
)
--*/
#define AAMC_PKT_IS_TYPE2_DATA(pH)	\
			(((pH)->LLC[0] == MC_LLC_SNAP_LLC0) && \
			 ((pH)->LLC[1] == MC_LLC_SNAP_LLC1) && \
			 ((pH)->LLC[2] == MC_LLC_SNAP_LLC2) && \
			 ((pH)->OUI[0] == MC_LLC_SNAP_OUI0) && \
			 ((pH)->OUI[1] == MC_LLC_SNAP_OUI1) && \
			 ((pH)->OUI[2] == MC_LLC_SNAP_OUI2) && \
			 ((pH)->PID == NET_SHORT(AA_PKT_ETHERTYPE_MC_TYPE2)) && \
			 ((pH)->pro == NET_SHORT(AA_PKT_ETHERTYPE_IP)))


/*++
BOOLEAN
AAMC_PKT_IS_CONTROL(
	IN	PAA_MARS_PKT_FIXED_HEADER			pH
)
--*/
#define AAMC_PKT_IS_CONTROL(pH)	\
			(((pH)->LLC[0] == MC_LLC_SNAP_LLC0) && \
			 ((pH)->LLC[1] == MC_LLC_SNAP_LLC1) && \
			 ((pH)->LLC[2] == MC_LLC_SNAP_LLC2) && \
			 ((pH)->OUI[0] == MC_LLC_SNAP_OUI0) && \
			 ((pH)->OUI[1] == MC_LLC_SNAP_OUI1) && \
			 ((pH)->OUI[2] == MC_LLC_SNAP_OUI2) && \
			 ((pH)->PID == NET_SHORT(AA_PKT_ETHERTYPE_MARS_CONTROL)))


/*++
USHORT
AAMC_GET_TLV_TYPE(
	IN	USHORT								_Type
)
--*/
#define AAMC_GET_TLV_TYPE(_Type)		NET_TO_HOST_SHORT((_Type) & AA_MARS_TLV_TYPE_MASK)


/*++
USHORT
AAMC_GET_TLV_ACTION(
	IN	USHORT								_Type
)
--*/
#define AAMC_GET_TLV_ACTION(_Type)		NET_TO_HOST_SHORT((_Type) & AA_MARS_TLV_ACTION_MASK)


/*++
SHORT
AAMC_GET_TLV_TOTAL_LENGTH(
	IN	SHORT								_TlvLength
)
Given the value stored in the Length field of a TLV, return
the total (rounded-off) length of the TLV. This is just the
length of the TLV header plus the given length rounded off
to the nearest multiple of 4.
--*/
#define AAMC_GET_TLV_TOTAL_LENGTH(_TlvLength)	\
			(sizeof(AA_MARS_TLV_HDR) +			\
			 (_TlvLength) +						\
			 ((4 - ((_TlvLength) & 3)) % 4))


/*++
BOOLEAN
AAMC_IS_NULL_TLV(
	IN	PAA_MARS_TLV_HDR					_pTlv
)
Return TRUE iff the given TLV is a NULL TLV, meaning end of list.
--*/
#define AAMC_IS_NULL_TLV(_pTlv)					\
			(((_pTlv)->Type == 0x0000) && ((_pTlv)->Length == 0x0000))

#endif _MARS_PKT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\ntentry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ntentry.c

Abstract:

	NT System entry points for ATMARP.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-08-96    Created

Notes:

--*/

#ifdef ATMARP_WIN98

#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 0

#endif // ATMARP_WIN98

#include <precomp.h>

#define _FILENUMBER 'NETN'

//
//  The INIT code is discardable
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#endif // ALLOC_PRAGMA





NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT				pDriverObject,
	IN	PUNICODE_STRING				pRegistryPath
)
/*++

Routine Description:

	This is the "init" routine, called by the system when the ATMARP
	module is loaded. We initialize all our global objects, fill in our
	Dispatch and Unload routine addresses in the driver object, and create
	a device object for receiving I/O requests on (IOCTLs).

Arguments:

	pDriverObject	- Pointer to the driver object created by the system.
	pRegistryPath	- Pointer to our global registry path. This is ignored.

Return Value:

	NT Status code: STATUS_SUCCESS if successful, error code otherwise.

--*/
{
	NTSTATUS				Status;
	PDEVICE_OBJECT			pDeviceObject;
	UNICODE_STRING			DeviceName;
	INT						i;

	AADEBUGP(AAD_INFO, ("DriverEntry: entered, pAtmArpGlobal 0x%x\n", pAtmArpGlobalInfo));
	AADEBUGP(AAD_FATAL, ("&AaDebugLevel: 0x%x, AaDebugLevel now is %d\n",
				&AaDebugLevel, AaDebugLevel));
	AADEBUGP(AAD_FATAL, ("&AaDataDebugLevel: 0x%x, AaDataDebugLevel now is %d\n",
				&AaDataDebugLevel, AaDataDebugLevel));
#ifdef IPMCAST
	AAMCDEBUGP(AAD_FATAL, ("&AaMcDebugLevel: 0x%x, AaMcDebugLevel now is %d\n",
				&AaMcDebugLevel, AaMcDebugLevel));
#endif
#if DBG
	AADEBUGP(AAD_FATAL, ("To skip everything set AaSkipAll at 0x%x to 1\n",
				&AaSkipAll));
	if (AaSkipAll)
	{
		AADEBUGP(AAD_ERROR, ("Aborting DriverEntry\n"));
		return (STATUS_UNSUCCESSFUL);
	}
#endif

	//
	//  Initialize our globals.
	//
	AtmArpInitGlobals();

#ifdef GPC
    //
    // Init GPC
    //
	AtmArpGpcInitialize();
#endif // GPC

#if !BINARY_COMPATIBLE
	//
	//  Initialize the Driver Object.
	//
	pDriverObject->DriverUnload = Unload;
	pDriverObject->FastIoDispatch = NULL;
	for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		pDriverObject->MajorFunction[i] = Dispatch;
	}

#ifdef CUBDD
	pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
					 AtmArpInternalDeviceControl;
#endif // CUBDD

#ifdef ATMARP_WMI

	pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = AtmArpWmiDispatch;

#endif // ATMARP_WMI

	pAtmArpGlobalInfo->pDriverObject = (PVOID)pDriverObject;

	//
	//  Create a device object for the ATMARP module.
	//
	RtlInitUnicodeString(&DeviceName, ATMARP_DEVICE_NAME);

	Status = IoCreateDevice(
				pDriverObject,
				0,
				&DeviceName,
				FILE_DEVICE_NETWORK,
				0,
				FALSE,
				&pDeviceObject
				);

	if (NT_SUCCESS(Status))
	{

		//
		// Set up a symbolic name for interaction with the user-mode
		// admin application.
		//
		#define	ATMARP_SYMBOLIC_NAME		L"\\DosDevices\\ATMARPC"
		UNICODE_STRING	SymbolicName;
		RtlInitUnicodeString(&SymbolicName, ATMARP_SYMBOLIC_NAME);
		IoCreateSymbolicLink(&SymbolicName, &DeviceName);

		//
		//  Initialize the Device Object.
		//
		pDeviceObject->Flags |= DO_DIRECT_IO;

		//
		//  Retain the device object pointer -- we'll need this
		//  if/when we are asked to unload ourselves.
		//
		pAtmArpGlobalInfo->pDeviceObject = (PVOID)pDeviceObject;

	}
	else
	{
		pDeviceObject = NULL;
	}

#endif // !BINARY_COMPATIBLE

	//
	//  Fill in our Protocol and Client characteristics structures.
	//
	AA_SET_MEM(&AtmArpProtocolCharacteristics, 0, sizeof(AtmArpProtocolCharacteristics));
	AtmArpProtocolCharacteristics.MajorNdisVersion = ATMARP_NDIS_MAJOR_VERSION;
	AtmArpProtocolCharacteristics.MinorNdisVersion = ATMARP_NDIS_MINOR_VERSION;
	AtmArpProtocolCharacteristics.OpenAdapterCompleteHandler = AtmArpOpenAdapterCompleteHandler;
	AtmArpProtocolCharacteristics.CloseAdapterCompleteHandler = AtmArpCloseAdapterCompleteHandler;
	AtmArpProtocolCharacteristics.SendCompleteHandler = AtmArpSendCompleteHandler;
	AtmArpProtocolCharacteristics.TransferDataCompleteHandler = AtmArpTransferDataCompleteHandler;
	AtmArpProtocolCharacteristics.ResetCompleteHandler = AtmArpResetCompleteHandler;
	AtmArpProtocolCharacteristics.RequestCompleteHandler = AtmArpRequestCompleteHandler;
	AtmArpProtocolCharacteristics.ReceiveHandler = AtmArpReceiveHandler;
	AtmArpProtocolCharacteristics.ReceiveCompleteHandler = AtmArpReceiveCompleteHandler;
	AtmArpProtocolCharacteristics.StatusHandler = AtmArpStatusHandler;
	AtmArpProtocolCharacteristics.StatusCompleteHandler = AtmArpStatusCompleteHandler;
	NdisInitUnicodeString(
		&AtmArpProtocolCharacteristics.Name,
		ATMARP_LL_NAME
	);
	AtmArpProtocolCharacteristics.ReceivePacketHandler = AtmArpReceivePacketHandler;
	AtmArpProtocolCharacteristics.BindAdapterHandler = AtmArpBindAdapterHandler;
	AtmArpProtocolCharacteristics.UnbindAdapterHandler = AtmArpUnbindAdapterHandler;
	AtmArpProtocolCharacteristics.UnloadHandler = (UNLOAD_PROTOCOL_HANDLER)AtmArpUnloadProtocol;
#ifdef _PNP_POWER_
	AtmArpProtocolCharacteristics.PnPEventHandler = AtmArpPnPEventHandler;
#endif // _PNP_POWER_
	AtmArpProtocolCharacteristics.CoSendCompleteHandler = AtmArpCoSendCompleteHandler;
	AtmArpProtocolCharacteristics.CoStatusHandler = AtmArpCoStatusHandler;
	AtmArpProtocolCharacteristics.CoReceivePacketHandler = AtmArpCoReceivePacketHandler;
	AtmArpProtocolCharacteristics.CoAfRegisterNotifyHandler = AtmArpCoAfRegisterNotifyHandler;

	AA_SET_MEM(&AtmArpClientCharacteristics, 0, sizeof(AtmArpClientCharacteristics));
	AtmArpClientCharacteristics.MajorVersion = ATMARP_NDIS_MAJOR_VERSION;
	AtmArpClientCharacteristics.MinorVersion = ATMARP_NDIS_MINOR_VERSION;
	AtmArpClientCharacteristics.ClCreateVcHandler = AtmArpCreateVcHandler;
	AtmArpClientCharacteristics.ClDeleteVcHandler = AtmArpDeleteVcHandler;
	AtmArpClientCharacteristics.ClRequestHandler = AtmArpCoRequestHandler;
	AtmArpClientCharacteristics.ClRequestCompleteHandler = AtmArpCoRequestCompleteHandler;
	AtmArpClientCharacteristics.ClOpenAfCompleteHandler = AtmArpOpenAfCompleteHandler;
	AtmArpClientCharacteristics.ClCloseAfCompleteHandler = AtmArpCloseAfCompleteHandler;
	AtmArpClientCharacteristics.ClRegisterSapCompleteHandler = AtmArpRegisterSapCompleteHandler;
	AtmArpClientCharacteristics.ClDeregisterSapCompleteHandler = AtmArpDeregisterSapCompleteHandler;
	AtmArpClientCharacteristics.ClMakeCallCompleteHandler = AtmArpMakeCallCompleteHandler;
	AtmArpClientCharacteristics.ClModifyCallQoSCompleteHandler = AtmArpModifyQosCompleteHandler;
	AtmArpClientCharacteristics.ClCloseCallCompleteHandler = AtmArpCloseCallCompleteHandler;
	AtmArpClientCharacteristics.ClAddPartyCompleteHandler = AtmArpAddPartyCompleteHandler;
	AtmArpClientCharacteristics.ClDropPartyCompleteHandler = AtmArpDropPartyCompleteHandler;
	AtmArpClientCharacteristics.ClIncomingCallHandler = AtmArpIncomingCallHandler;
	AtmArpClientCharacteristics.ClIncomingCallQoSChangeHandler = (CL_INCOMING_CALL_QOS_CHANGE_HANDLER)NULL;
	AtmArpClientCharacteristics.ClIncomingCloseCallHandler = AtmArpIncomingCloseHandler;
	AtmArpClientCharacteristics.ClIncomingDropPartyHandler = AtmArpIncomingDropPartyHandler;
	AtmArpClientCharacteristics.ClCallConnectedHandler = AtmArpCallConnectedHandler;
	
	do
	{
		//
		//  Register ourselves as a protocol with NDIS.
		//
		NdisRegisterProtocol(
				&Status,
				&(pAtmArpGlobalInfo->ProtocolHandle),
				&AtmArpProtocolCharacteristics,
				sizeof(AtmArpProtocolCharacteristics)
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_FATAL,
				("NdisRegisterProtocol failed: %x\n", Status));
			pAtmArpGlobalInfo->ProtocolHandle = NULL;
			break;
		}

#ifdef NEWARP
		//
		//  Register ourselves as an ARP Module with IP.
		//
		{
			NDIS_STRING		AtmArpName;

			#if IFCHANGE1
			#ifndef ATMARP_WIN98
			IP_CHANGE_INDEX        IpChangeIndex;
			IP_RESERVE_INDEX       IpReserveIndex;
			IP_DERESERVE_INDEX     IpDereserveIndex;
			#endif
			#endif // IFCHANGE1

			NdisInitUnicodeString(&AtmArpName, ATMARP_UL_NAME);

			Status = IPRegisterARP(
						&AtmArpName,
						IP_ARP_BIND_VERSION,
						AtmArpBindAdapterHandler,
						&(pAtmArpGlobalInfo->pIPAddInterfaceRtn),
						&(pAtmArpGlobalInfo->pIPDelInterfaceRtn),
						&(pAtmArpGlobalInfo->pIPBindCompleteRtn),
					#if P2MP
						&(pAtmArpGlobalInfo->pIPAddLinkRtn),
						&(pAtmArpGlobalInfo->pIpDeleteLinkRtn),
					#endif // P2MP
					#if IFCHANGE1
					#ifndef ATMARP_WIN98
						//
						// Following 3 are placeholders -- we don't use this information.
						// See 10/14/1998 entry in notes.txt
						//
						&IpChangeIndex,
						&IpReserveIndex,
						&IpDereserveIndex,
					#endif // ATMARP_WIN98
					#endif // IFCHANGE1
						&(pAtmArpGlobalInfo->ARPRegisterHandle)
						);

			if (!NT_SUCCESS(Status))
			{

				AADEBUGP(AAD_FATAL, ("DriverEntry: IPRegisterARP FAILS. Status = 0x%08lx\n", Status));
				pAtmArpGlobalInfo->ARPRegisterHandle = NULL;
				break;
			}
		
		}
#endif // NEWARP

		break;
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		NDIS_STATUS		CleanupStatus;

		//
		//  Clean up.
		//

#if !BINARY_COMPATIBLE
		if (pDeviceObject != NULL)
		{
			UNICODE_STRING	SymbolicName;
			RtlInitUnicodeString(&SymbolicName, ATMARP_SYMBOLIC_NAME);
			IoDeleteSymbolicLink(&SymbolicName);
			IoDeleteDevice(pDeviceObject);
			pDeviceObject = NULL;
		}
#endif // !BINARY_COMPATIBLE

		if (pAtmArpGlobalInfo->ProtocolHandle)
		{
			NdisDeregisterProtocol(
				&CleanupStatus,
				pAtmArpGlobalInfo->ProtocolHandle
				);
			
			pAtmArpGlobalInfo->ProtocolHandle = NULL;
		}

		if (pAtmArpGlobalInfo->ARPRegisterHandle != NULL)
		{
			CleanupStatus = IPDeregisterARP(pAtmArpGlobalInfo->ARPRegisterHandle);
			AA_ASSERT(CleanupStatus == NDIS_STATUS_SUCCESS);

			pAtmArpGlobalInfo->ARPRegisterHandle = NULL;
		}

    #ifdef GPC
        //
        // DeInit GPC
        //
        AtmArpGpcShutdown();
    #endif // GPC

	}

	return (Status);
}


#if !BINARY_COMPATIBLE

NTSTATUS
Dispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
)
/*++

Routine Description:

	This routine is called by the system when there is an IRP
	to be processed.

Arguments:

	pDeviceObject		- Pointer to device object we created for ourselves.
	pIrp				- Pointer to IRP to be processed.

Return Value:

	NT Status code.

--*/
{
	NTSTATUS				Status;				// Return value
	PIO_STACK_LOCATION		pIrpStack;
	PVOID					pIoBuffer;			// Values in/out
	ULONG					InputBufferLength;	// Length of input parameters
	ULONG					OutputBufferLength;	// Space for output values

	//
	//  Initialize
	//
	Status = (NTSTATUS)NDIS_STATUS_SUCCESS;
	pIrp->IoStatus.Status = (NTSTATUS)NDIS_STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;

	//
	//  Get all information in the IRP
	//
	pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	InputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	OutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

	switch (pIrpStack->MajorFunction)
	{
		case IRP_MJ_CREATE:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP_MJ_CREATE\n"));
			//
			//  Return a pointer to the first ATMARP interface available, as the
			//  FsContext.
			//
			pIrpStack->FileObject->FsContext = NULL;	// Initialize
			if (pAtmArpGlobalInfo->pAdapterList != (PATMARP_ADAPTER)NULL)
			{
				pIrpStack->FileObject->FsContext =
					(PVOID)(pAtmArpGlobalInfo->pAdapterList->pInterfaceList);
			}
			break;

		case IRP_MJ_CLOSE:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP_MJ_CLOSE\n"));
			break;

		case IRP_MJ_CLEANUP:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP_MJ_CLEANUP\n"));
			break;

		case IRP_MJ_DEVICE_CONTROL:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP_MJ_DEVICE_CONTROL\n"));

#ifndef ATMARP_WIN98
			Status =  AtmArpHandleIoctlRequest(pIrp, pIrpStack);
#endif // ATMARP_WIN98
			break;

		default:
			AADEBUGP(AAD_INFO, ("Dispatch: IRP: Unknown major function 0x%x\n",
						pIrpStack->MajorFunction));
			break;
	}

	if (Status != (NTSTATUS)NDIS_STATUS_PENDING)
	{
		pIrp->IoStatus.Status = Status;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	}

	return (Status);

}

#endif // !BINARY_COMPATIBLE


VOID
Unload(
	IN	PDRIVER_OBJECT				pDriverObject
)
/*++

Routine Description:

	This routine is called by the system prior to unloading us.
	Currently, we just undo everything we did in DriverEntry,
	that is, de-register ourselves as an NDIS protocol, and delete
	the device object we had created.

Arguments:

	pDriverObject	- Pointer to the driver object created by the system.

Return Value:

	None

--*/
{
	NDIS_STATUS				Status;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	AADEBUGP(AAD_INFO, ("Unload Entered!\n"));

	if (pAtmArpGlobalInfo->ARPRegisterHandle != NULL)
	{
		Status = IPDeregisterARP(pAtmArpGlobalInfo->ARPRegisterHandle);
		AA_ASSERT(Status == NDIS_STATUS_SUCCESS);
	}

	AtmArpUnloadProtocol();

	//
	//  Delay for a while.
	//
	AADEBUGP(AAD_INFO, ("Unload: will delay for a while...\n"));

	NdisInitializeEvent(&pAtmArpGlobalInfo->Block.Event);

	NdisWaitEvent(&pAtmArpGlobalInfo->Block.Event, 250);

#if !BINARY_COMPATIBLE
	{
		UNICODE_STRING	SymbolicName;
		RtlInitUnicodeString(&SymbolicName, ATMARP_SYMBOLIC_NAME);
		IoDeleteSymbolicLink(&SymbolicName);

		//
		//  Delete our device object.
		//
		IoDeleteDevice((PDEVICE_OBJECT)pAtmArpGlobalInfo->pDeviceObject);
	}
#endif // !BINARY_COMPATIBLE

	AADEBUGP(AAD_INFO, ("Unload done!\n"));
	AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\precomp.h ===
#include <ndis.h>

#include <atm.h>
#include <cxport.h>
#include <ip.h>
#include <arpinfo.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <llinfo.h>

#ifndef ATMARP_WIN98
#include <tdistat.h>
#include <ipifcons.h>
#endif

#include <atmarpif.h>

#ifdef NEWARP

#ifdef _PNP_POWER_
#include <ntddip.h>
#include <llipif.h>
#else

#ifdef ATMARP_WIN98
#define _PNP_POWER_ 1
#endif

#include <ntddip.h>

#ifdef ATMARP_WIN98
#undef _PNP_POWER_
#undef NT
#include <tdistat.h>
#endif

#include <llipif.h>

#ifdef ATMARP_WIN98
#define NT 1
#endif

#endif // _PNP_POWER_

#else

#include <llipif0.h>

#endif // NEWARP

#include <ntddip.h>

#include "system.h"
#include "debug.h"

#ifdef GPC
#include "gpcifc.h"
#include "traffic.h"
#include "ntddtc.h"
#endif // GPC

#include "aaqos.h"
#include "arppkt.h"
#ifdef IPMCAST
#include "marspkt.h"
#endif // IPMCAST
#include "atmarp.h"
#include "cubdd.h"
#include "macros.h"

#ifdef ATMARP_WMI
#include <wmistr.h>
#include "aawmi.h"
#endif // ATMARP_WMI

#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\space.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	space.c

Abstract:

	All globals and tunable variables are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-08-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'CAPS'

//
//  The Global Info structure is initialized in our DriverEntry.
// 
ATMARP_GLOBALS		AtmArpGlobalInfo;
PATMARP_GLOBALS		pAtmArpGlobalInfo = &AtmArpGlobalInfo;

//
//  Generic NDIS protocol characteristics structure: this defines
//  our handler routines for various common protocol functions.
//  We pass this to NDIS when we register ourselves as a protocol.
//
NDIS_PROTOCOL_CHARACTERISTICS AtmArpProtocolCharacteristics;


//
//  Connection Oriented Client specific NDIS characteristics structure.
//  This contains our handlers for Connection-Oriented functions. We pass
//  this structure to NDIS when we open the Q.2931 Address Family.
//
NDIS_CLIENT_CHARACTERISTICS AtmArpClientCharacteristics;


#ifdef OLDSAP

ATM_BLLI_IE AtmArpDefaultBlli =
						{
							(ULONG)BLLI_L2_LLC,  // Layer2Protocol
							(UCHAR)0x00,         // Layer2Mode
							(UCHAR)0x00,         // Layer2WindowSize
							(ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
							(ULONG)BLLI_L3_ISO_TR9577,  // Layer3Protocol
							(UCHAR)0x01,         // Layer3Mode
							(UCHAR)0x00,         // Layer3DefaultPacketSize
							(UCHAR)0x00,         // Layer3PacketWindowSize
							(ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
							(ULONG)BLLI_L3_IPI_IP,  // Layer3IPI,
							(UCHAR)0x00,         // SnapID[5]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};

#else

ATM_BLLI_IE AtmArpDefaultBlli =
						{
							(ULONG)BLLI_L2_LLC,  // Layer2Protocol
							(UCHAR)0x00,         // Layer2Mode
							(UCHAR)0x00,         // Layer2WindowSize
							(ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
							(ULONG)SAP_FIELD_ABSENT,  // Layer3Protocol
							(UCHAR)0x00,         // Layer3Mode
							(UCHAR)0x00,         // Layer3DefaultPacketSize
							(UCHAR)0x00,         // Layer3PacketWindowSize
							(ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
							(ULONG)0x00000000,   // Layer3IPI,
							(UCHAR)0x00,         // SnapID[5]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};

#endif


ATM_BHLI_IE AtmArpDefaultBhli =
						{
							(ULONG)SAP_FIELD_ABSENT,   // HighLayerInfoType
							(ULONG)0x00000000,   // HighLayerInfoLength
							(UCHAR)0x00,         // HighLayerInfo[8]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};


AA_PKT_LLC_SNAP_HEADER AtmArpLlcSnapHeader =
						{
							(UCHAR)0xAA,
							(UCHAR)0xAA,
							(UCHAR)0x03,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(USHORT)AA_PKT_ETHERTYPE_IP_NS
						};

#ifdef IPMCAST
AA_MC_PKT_TYPE1_SHORT_HEADER AtmArpMcType1ShortHeader =
						{
							(UCHAR)MC_LLC_SNAP_LLC0,
							(UCHAR)MC_LLC_SNAP_LLC1,
							(UCHAR)MC_LLC_SNAP_LLC2,
							(UCHAR)MC_LLC_SNAP_OUI0,
							(UCHAR)MC_LLC_SNAP_OUI1,
							(UCHAR)MC_LLC_SNAP_OUI2,
							(USHORT)AA_PKT_ETHERTYPE_MC_TYPE1_NS,
							(USHORT)0x0,				// CMI
							(USHORT)AA_PKT_ETHERTYPE_IP_NS
						};

AA_MARS_PKT_FIXED_HEADER	AtmArpMcMARSFixedHeader =
						{
							(UCHAR)MC_LLC_SNAP_LLC0,
							(UCHAR)MC_LLC_SNAP_LLC1,
							(UCHAR)MC_LLC_SNAP_LLC2,
							(UCHAR)MC_LLC_SNAP_OUI0,
							(UCHAR)MC_LLC_SNAP_OUI1,
							(UCHAR)MC_LLC_SNAP_OUI2,
							(USHORT)AA_PKT_ETHERTYPE_MARS_CONTROL_NS,
							(USHORT)AA_MC_MARS_HEADER_AFN_NS,
							(UCHAR)0x08,	// this and the next == 0x800 (IPv4)
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,	// hdrrsv[0]
							(UCHAR)0x00,	// hdrrsv[1]
							(UCHAR)0x00,	// hdrrsv[2]
							(USHORT)0x0000,	// check-sum
							(USHORT)0x0000,	// extensions offset
							(USHORT)0x0000,	// Op code
							(UCHAR)0x00,	// Source ATM Number type+len
							(UCHAR)0x00		// Source ATM Subaddress type+len
						};

#endif // IPMCAST
#ifdef QOS_HEURISTICS

ATMARP_FLOW_INFO	AtmArpDefaultFlowInfo =
						{
							(PATMARP_FLOW_INFO)NULL,				// pNextFlow
							(PATMARP_FLOW_INFO)NULL,				// pPrevFlow
#ifdef GPC
							(PVOID)0,								// VcContext
							(GPC_HANDLE)NULL,						// CfInfoHandle
							{0},									// FlowInstanceName
#endif // GPC
							(ULONG)AAF_DEF_LOWBW_SEND_THRESHOLD,	// Max Send Size
							{		// Filter Spec:
								(ULONG)-1,							// DestinationPort
							},
							{		// Flow Spec:
								(ULONG)AAF_DEF_LOWBW_SEND_BANDWIDTH,
								(ULONG)65535,
								(ULONG)AAF_DEF_LOWBW_RECV_BANDWIDTH,
								(ULONG)65535,
								ENCAPSULATION_TYPE_LLCSNAP,
								AAF_DEF_LOWBW_AGING_TIME
							}
						};


#endif // QOS_HEURISTICS

#ifdef GPC
GPC_CLASSIFY_PACKET_HANDLER                 AtmArpGpcClassifyPacketHandler;
GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER 		AtmArpGpcGetCfInfoClientContextHandler;
#endif // GPC

//
//  Timer configuration.
//

#define AAT_MAX_TIMER_SHORT_DURATION            60      // Seconds
#define AAT_MAX_TIMER_LONG_DURATION         (30*60)     // Seconds

#define AAT_SHORT_DURATION_TIMER_PERIOD			 1		// Second
#define AAT_LONG_DURATION_TIMER_PERIOD			10		// Seconds

//
//  Max timeout value (in seconds) for each class.
//
ULONG	AtmArpMaxTimerValue[AAT_CLASS_MAX] =
						{
							AAT_MAX_TIMER_SHORT_DURATION,
							AAT_MAX_TIMER_LONG_DURATION
						};

//
//  Size of each timer wheel.
//
ULONG	AtmArpTimerListSize[AAT_CLASS_MAX] =
						{
							SECONDS_TO_SHORT_TICKS(AAT_MAX_TIMER_SHORT_DURATION),
							SECONDS_TO_LONG_TICKS(AAT_MAX_TIMER_LONG_DURATION)
						};
//
//  Interval between ticks, in seconds, for each class.
//
ULONG	AtmArpTimerPeriod[AAT_CLASS_MAX] =
						{
							AAT_SHORT_DURATION_TIMER_PERIOD,
							AAT_LONG_DURATION_TIMER_PERIOD
						};


#ifdef ATMARP_WMI

ATMARP_WMI_GUID		AtmArpGuidList[] = {
		{
			0,						// MyId
			//
			//  GUID_QOS_TC_SUPPORTED:
			//
			{0xe40056dcL,0x40c8,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x59,0x15},
			0,						// Flags
			AtmArpWmiQueryTCSupported,
			AtmArpWmiSetTCSupported,
			AtmArpWmiEnableEventTCSupported
		},

		{
			1,
			//
			//  GUID_QOS_TC_INTERFACE_UP_INDICATION:
			//
			{0x0ca13af0L,0x46c4,0x11d1,0x78,0xac,0x00,0x80,0x5f,0x68,0x35,0x1e},
			AWGF_EVENT_ENABLED,						// Flags
			AtmArpWmiQueryTCIfIndication,
			AtmArpWmiSetTCIfIndication,
			AtmArpWmiEnableEventTCIfIndication
		},

		{
			2,
			//
			//  GUID_QOS_TC_INTERFACE_DOWN_INDICATION:
			//
			{0xaf5315e4L,0xce61,0x11d1,0x7c,0x8a,0x00,0xc0,0x4f,0xc9,0xb5,0x7c},
			AWGF_EVENT_ENABLED,						// Flags
			AtmArpWmiQueryTCIfIndication,
			AtmArpWmiSetTCIfIndication,
			AtmArpWmiEnableEventTCIfIndication
		},

		{
			3,
			//
			//  GUID_QOS_TC_INTERFACE_CHANGE_INDICATION:
			//
			{0xda76a254L,0xce61,0x11d1,0x7c,0x8a,0x00,0xc0,0x4f,0xc9,0xb5,0x7c},
			AWGF_EVENT_ENABLED,						// Flags
			AtmArpWmiQueryTCIfIndication,
			AtmArpWmiSetTCIfIndication,
			AtmArpWmiEnableEventTCIfIndication
		}

#if 0
		,
		{
			4,
			//
			//   GUID_QOS_STATISTICS_BUFFER:
			//
			{0xbb2c0980L,0xe900,0x11d1,0xb0,0x7e,0x00,0x80,0xc7,0x13,0x82,0xbf},
			0,						// Flags
			AtmArpWmiQueryStatisticsBuffer,
			AtmArpWmiSetStatisticsBuffer,
			NULL
		}
#endif // 0

	};

ULONG				AtmArpGuidCount = sizeof(AtmArpGuidList) / sizeof(ATMARP_WMI_GUID);

#ifdef BACK_FILL
#ifdef ATMARP_WIN98
ULONG	AtmArpDoBackFill = 0;
#else
ULONG	AtmArpDoBackFill = 0;
#endif
ULONG	AtmArpBackFillCount = 0;
#endif // BACK_FILL

#endif // ATMARP_WMI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\system.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	system.h

Abstract:

	ATMARP Client versions of system objects/definitions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-28-96    Created

Notes:

--*/

#ifndef __ATMARPC_SYSTEM__H
#define __ATMARPC_SYSTEM__H


#define ATMARP_NDIS_MAJOR_VERSION		5
#define ATMARP_NDIS_MINOR_VERSION		0


#define ATMARP_UL_NAME			L"ATMARPC"
#define ATMARP_LL_NAME			L"TCPIP_ATMARPC"
//
//  4/3/1998 JosephJ The UL version above is presented to TCPIP and the
//                   LL version is presented to NDIS, so that NDIS will
//                   find us when a "TCPIP" reconfiguration is sent to it
//                   (NDIS will first look for an exact match and then for
//                    a proper prefix match.)
//


#define ATMARP_NAME_STRING	NDIS_STRING_CONST("ATMARPC")
#define ATMARP_DEVICE_NAME	L"\\Device\\ATMARPC"
#define ATMARP_REGISTRY_PATH	L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\AtmArpC"

#define MAX_IP_CONFIG_STRING_LEN		200

#define LOCKIN
#define LOCKOUT
#define NOLOCKOUT

#ifndef APIENTRY
#define APIENTRY
#endif

typedef struct _ATMARP_BLOCK
{
	NDIS_EVENT			Event;
	NDIS_STATUS			Status;

} ATMARP_BLOCK, *PATMARP_BLOCK;


//
//  List manipulation stuff
//

typedef SINGLE_LIST_ENTRY AA_SINGLE_LIST_ENTRY, *PAA_SINGLE_LIST_ENTRY;

#define NULL_PAA_SINGLE_LIST_ENTRY	((PAA_SINGLE_LIST_ENTRY)NULL)

#define AA_POP_FROM_SLIST	ExInterlockedPopEntrySList
#define AA_PUSH_TO_SLIST	ExInterlockedPushEntrySList
#define AA_INIT_SLIST		ExInitializeSListHead

#if !BINARY_COMPATIBLE

/*++
VOID
AA_COMPLETE_IRP(
	IN	PIRP			pIrp,
	IN	NTSTATUS		Status,
	IN	ULONG			Length
)
Complete a pending IRP.
--*/
#define AA_COMPLETE_IRP(_pIrp, _Status, _Length)				\
			{													\
				(_pIrp)->IoStatus.Status = (_Status);			\
				(_pIrp)->IoStatus.Information = (_Length);		\
				IoCompleteRequest((_pIrp), IO_NO_INCREMENT);	\
			}

#define AA_IRQL			KIRQL


#if DBG
#define AA_GET_ENTRY_IRQL(Irql)	\
			Irql = KeGetCurrentIrql()
#define AA_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)	\
		{										\
			ExitIrql = KeGetCurrentIrql();		\
			if (ExitIrql != EntryIrql)			\
			{									\
				DbgPrint("File %s, Line %d, Exit IRQ %d != Entry IRQ %d\n",	\
						__FILE__, __LINE__, ExitIrql, EntryIrql);			\
				DbgBreakPoint();				\
			}									\
		}
#else
#define AA_GET_ENTRY_IRQL(Irql)
#define AA_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)
#endif // DBG

#endif // !BINARY_COMPATIBLE


#if BINARY_COMPATIBLE
#define AA_GET_ENTRY_IRQL(Irql)
#define AA_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)

#define AA_IRQL			ULONG

#endif // BINARY_COMPATIBLE


#ifdef BACK_FILL

/*++
BOOLEAN
AA_BACK_FILL_POSSIBLE(
	IN	PNDIS_BUFFER		pNdisBuffer
)
Check if we can back-fill the specified NDIS buffer with Low-layer headers.
--*/
#define AA_BACK_FILL_POSSIBLE(_pBuf)	\
				(((_pBuf)->MdlFlags & MDL_NETWORK_HEADER) != 0)

#endif // BACK_FILL

#endif // __ATMARPC_SYSTEM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\timeouts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	timeouts.c		- Timeout handlers.

Abstract:

	All timeout handlers for the ATMARP client.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     08-01-96    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'EMIT'



VOID
AtmArpServerConnectTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This timeout indicates that enough time has passed since a previous
	failed attempt at connecting to the ARP server. Try again now.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;			// Ref Count

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// Timer ref

	//
	//  Continue only if the Interface is still alive
	//
	if (rc > 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AADEBUGP(AAD_INFO, ("Server Connect timeout on IF 0x%x\n", pInterface));

			//
			//  Restart registration
			//
			AtmArpStartRegistration(pInterface);
			//
			//  IF lock is released by the above routine.
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}
	// else the Interface is gone!

	return;
}




VOID
AtmArpRegistrationTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called if we timed out waiting for registration to a server
	to complete. If we have retries left for this server, we send another
	ARP Request to register ourselves. Otherwise, we close all VCs to this
	server, move to the next server in the server list, and wait for a while
	before initiating registration to this new server.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;			// Ref Count

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("Registration timeout: pIf 0x%x, IF Flags 0x%x\n",
				pInterface, pInterface->Flags));

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// Timer ref

	//
	//  Continue only if the Interface is still alive
	//
	if (rc > 0)
	{
		AtmArpRetryServerRegistration(pInterface);
		//
		//  The IF lock is released within the above.
		//
	}
	//
	//  else the Interface is gone.
	//

	return;

}



VOID
AtmArpServerRefreshTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is periodically invoked so that we can refresh our
	IP address+ATM address info with the ARP server. We do so by registering
	the first of our local IP addresses. We mark all the other IP addresses
	configured on this interface as "not registered", so that, when the first
	one completes, we register all the rest.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	PIP_ADDRESS_ENTRY		pIPAddressEntry;
	ULONG					rc;			// Ref Count

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("Server Refresh timeout: IF 0x%x\n", pInterface));

	//
	// We also use this opportunity to clean out orphan entries in the
	// Arp Table.
	//
	AtmArpCleanupArpTable(pInterface);

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// Timer ref

	//
	//  Continue only if the Interface is still alive
	//
	if (rc > 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			//
			//  Mark all local addresses as not registered.
			//
			pIPAddressEntry = &(pInterface->LocalIPAddress);
			while (pIPAddressEntry != (PIP_ADDRESS_ENTRY)NULL)
			{
				pIPAddressEntry->IsRegistered = FALSE;
				pIPAddressEntry = pIPAddressEntry->pNext;
			}

			//
			//  Start registering the first one.
			//
			pInterface->RetriesLeft = pInterface->MaxRegistrationAttempts - 1;

			AA_SET_FLAG(
				pInterface->Flags,
				AA_IF_SERVER_STATE_MASK,
				AA_IF_SERVER_NO_CONTACT);

			AtmArpStartRegistration(pInterface);
			//
			//  The IF lock is released in the above routine.
			//
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}
	//
	// else the Interface is gone!
	//

	return;
}



VOID
AtmArpAddressResolutionTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response to an ARP Request
	we had sent ages ago in order to resolve/refresh an IP entry.

	First, check if the IP address got resolved anyway (e.g. an InARP Reply
	on a PVC). If so, we don't have to do anything. Otherwise, check if we
	have tried enough times. If we have retries left, send another ARP
	Request.

	If we have run out of retries, delete the IP entry, and any VCs going to it.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;		// IP Entry being ARP'ed for.
	ULONG					Flags;			// On IP Entry
	PATMARP_VC				pVc;			// VC to this IP destination
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;				// Ref Count on IP Entry
	IP_ADDRESS				DstIPAddress;	// Address being resolved
	IP_ADDRESS UNALIGNED *	pSrcIPAddress;	// Our IP address
#ifdef IPMCAST
	BOOLEAN					IsMARSProblem;
#endif

#ifdef IPMCAST
	IsMARSProblem = FALSE;
#endif

	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
	Flags = pIpEntry->Flags;

	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer reference

	//
	//  Continue only if the IP Entry still exists
	//
	if (rc > 0)
	{
		AADEBUGP(AAD_INFO,
			("Addr Resolution timeout: pIpEntry 0x%x, Flags 0x%x, IP Addr: %d.%d.%d.%d\n",
					pIpEntry,
					pIpEntry->Flags,
					((PUCHAR)&(pIpEntry->IPAddress))[0],
					((PUCHAR)&(pIpEntry->IPAddress))[1],
					((PUCHAR)&(pIpEntry->IPAddress))[2],
					((PUCHAR)&(pIpEntry->IPAddress))[3]
			));

		//
		//  Check if the entry got resolved somehow.
		//
		if (!AA_IS_FLAG_SET(
						Flags,
						AA_IP_ENTRY_STATE_MASK,
						AA_IP_ENTRY_RESOLVED))
		{
			//
			// We are still trying to resolve this. See if we have
			// retries left.
			//
			pInterface = pIpEntry->pInterface;

			if (pIpEntry->RetriesLeft != 0)
			{
				pIpEntry->RetriesLeft--;

				//
				// Try again: start addr resolution timer, send ARP Request.
				//
				pSrcIPAddress = &(pInterface->LocalIPAddress.IPAddress);
				DstIPAddress = pIpEntry->IPAddress;

				AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpAddressResolutionTimeout,
							pInterface->AddressResolutionTimeout,
							(PVOID)pIpEntry
							);

				AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer reference

				AA_RELEASE_IE_LOCK(pIpEntry);

#ifdef IPMCAST
				if (AA_IS_FLAG_SET(Flags,
									AA_IP_ENTRY_ADDR_TYPE_MASK,
									AA_IP_ENTRY_ADDR_TYPE_UCAST))
				{
					AtmArpSendARPRequest(
								pInterface,
								pSrcIPAddress,
								&DstIPAddress
								);
				}
				else
				{
					AtmArpMcSendRequest(
								pInterface,
								&DstIPAddress
								);
				}
#else
				AtmArpSendARPRequest(
							pInterface,
							pSrcIPAddress,
							&DstIPAddress
							);
#endif // IPMCAST
			}
			else
			{
				//
				//  We are out of retries. Check if we were REvalidating
				//  an entry that was aged out. If so, try revalidating
				//  using InARP on a VC attached to it -- if no such VC
				//  exists, delete the IP Entry.
				//
				if ((pIpEntry->pAtmEntry != NULL_PATMARP_ATM_ENTRY) &&
#ifdef IPMCAST
					(AA_IS_FLAG_SET(Flags,
									AA_IP_ENTRY_ADDR_TYPE_MASK,
									AA_IP_ENTRY_ADDR_TYPE_UCAST)) &&
#endif // IPMCAST
					(pIpEntry->pAtmEntry->pVcList != NULL_PATMARP_VC))
				{
					pVc = pIpEntry->pAtmEntry->pVcList;

					//
					//  Try revalidating now via InARP.
					//
					AA_SET_FLAG(
							pIpEntry->Flags,
							AA_IP_ENTRY_STATE_MASK,
							AA_IP_ENTRY_INARPING
							);

					AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpIPEntryInARPWaitTimeout,
							pInterface->InARPWaitTimeout,
							(PVOID)pIpEntry
							);

					AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer reference

					AA_RELEASE_IE_LOCK(pIpEntry);
#ifdef VC_REFS_ON_SENDS
					AA_ACQUIRE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS
					AtmArpSendInARPRequest(pVc);
				}
				else
				{
					AtmArpAbortIPEntry(pIpEntry);
					//
					//  The IP Entry lock is released in the above routine.
					//
#ifdef IPMCAST
					IsMARSProblem = AA_IS_FLAG_SET(Flags,
												AA_IP_ENTRY_ADDR_TYPE_MASK,
												AA_IP_ENTRY_ADDR_TYPE_NUCAST);
#endif // IPMCAST
				}
			}
		}
		else
		{
			//
			//  The IP Entry must have got resolved.
			//  Nothing more to be done.
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
		}
	}
	// else the IP Entry is gone

#ifdef IPMCAST
	if (IsMARSProblem)
	{
		AtmArpMcHandleMARSFailure(pInterface, FALSE);
	}
#endif // IPMCAST
	return;
}



VOID
AtmArpIPEntryInARPWaitTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This timeout happens if we don't receive an InARP Reply in response
	to an InARP Request sent in order to revalidate an IP Entry. Delete
	the entry.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;
	ULONG					rc;			// Ref Count on IP Entry

	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));
	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);

	if (rc > 0)
	{
		AtmArpAbortIPEntry(pIpEntry);
		//
		//  The IP Entry lock is released in the above routine.
		//
	}
	//
	//  else the entry is gone.
	//
}





VOID
AtmArpPVCInARPWaitTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This timeout happens if we don't receive a reply to an InARP Request
	we had sent in order to resolve a PVC. We send another InARP Request,
	and restart this timer, but to fire after a longer delay.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP VC structure

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;		// Ref Count on VC

	pVc = (PATMARP_VC)Context;
	AA_STRUCT_ASSERT(pVc, avc);

	AA_ACQUIRE_VC_LOCK(pVc);
	rc = AtmArpDereferenceVc(pVc);	// Timer ref

	if (rc > 0)
	{
		AA_ASSERT(AA_IS_FLAG_SET(
					pVc->Flags,
					AA_VC_ARP_STATE_MASK,
					AA_VC_INARP_IN_PROGRESS));

		pInterface = pVc->pInterface;


		AtmArpStartTimer(
					pInterface,
					&(pVc->Timer),
					AtmArpPVCInARPWaitTimeout,
					(2 * pInterface->InARPWaitTimeout),
					(PVOID)pVc
					);


		AtmArpReferenceVc(pVc);	// Timer ref

#ifndef VC_REFS_ON_SENDS
		AA_RELEASE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS

		//
		//  Send another InARP Request on the PVC
		//
		AtmArpSendInARPRequest(pVc);
	}
	//
	//  else the VC is gone
	//
}




VOID
AtmArpIPEntryAgingTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called if some time has passed (~15 minutes) since an
	IP entry was last resolved/refreshed.

	If there is no VC attached to this IP entry, we delete it. Otherwise,
	revalidate the entry:
	- Mark this entry so that packets are temporarily queued rather
	  than sent.
	- If "the VC attached to this entry" is a PVC, send an InARP Request
	  to validate the entry, otherwise, send an ARP Request to the server
	  to validate.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;	// IP Entry that has aged out
	ULONG					rc;			// Ref count on IP Entry
	PATMARP_VC				pVc;		// VC going to this IP Entry
	ULONG					VcFlags;	// Flags on above VC
	PATMARP_INTERFACE		pInterface;
	IP_ADDRESS				DstIPAddress;	// IP Address on this Entry


	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);
	VcFlags = 0;

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer ref

	//
	//  Continue only if the entry hasn't gone away.
	//
	if (rc != 0)
	{
		//
		//  Continue only if the Interface is not going down
		//
		pInterface = pIpEntry->pInterface;

		if (pInterface->AdminState == IF_STATUS_UP)
		{
			PATMARP_ATM_ENTRY		pAtmEntry;

			pAtmEntry = pIpEntry->pAtmEntry;
			if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
			{
				AA_ACQUIRE_AE_LOCK_DPC(pAtmEntry);
				pVc = pAtmEntry->pVcList;
				if (pVc != NULL_PATMARP_VC)
				{
					VcFlags = pVc->Flags;
				}
				AA_RELEASE_AE_LOCK_DPC(pAtmEntry);
			}
			else
			{
				pVc = NULL_PATMARP_VC;
			}

			AADEBUGP(AAD_INFO,
 				("Aged out IP Entry 0x%x, Flags 0x%x, IP Addr: %d.%d.%d.%d, VC: 0x%x\n",
						pIpEntry,
						pIpEntry->Flags,
						((PUCHAR)(&(pIpEntry->IPAddress)))[0],
						((PUCHAR)(&(pIpEntry->IPAddress)))[1],
						((PUCHAR)(&(pIpEntry->IPAddress)))[2],
						((PUCHAR)(&(pIpEntry->IPAddress)))[3],
						pVc
 				)	);

#ifdef IPMCAST
			if ((pVc != NULL_PATMARP_VC) &&
				(AA_IS_FLAG_SET(pIpEntry->Flags,
								AA_IP_ENTRY_ADDR_TYPE_MASK,
								AA_IP_ENTRY_ADDR_TYPE_UCAST)))
#else
			if (pVc != NULL_PATMARP_VC)
#endif // IPMCAST
			{
				//
				//  There is atleast one VC going to this IP Address.
				//  So we try to revalidate this IP entry: use InARP
				//  if the VC is a PVC, otherwise use ARP.
				//

				//
				//  First mark this entry so that we don't send packets
				//  to this destination till it is revalidated.
				//
				pIpEntry->Flags |= AA_IP_ENTRY_AGED_OUT;

				if (AA_IS_FLAG_SET(VcFlags, AA_VC_TYPE_MASK, AA_VC_TYPE_PVC))
				{
					//
					//  PVC; send InARP Request: actually, we fire off a timer
					//  at whose expiry we send the InARP Request.
					//
					AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpIPEntryInARPWaitTimeout,
							pInterface->InARPWaitTimeout,
							(PVOID)pIpEntry
							);

					AA_SET_FLAG(pIpEntry->Flags, AA_IP_ENTRY_STATE_MASK, AA_IP_ENTRY_INARPING);
					AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer ref
					AA_RELEASE_IE_LOCK(pIpEntry);

#ifdef VC_REFS_ON_SENDS
					AA_ACQUIRE_VC_LOCK(pVc);
#endif // VC_REFS_ON_SENDS
					AtmArpSendInARPRequest(pVc);
				}
				else
				{
					//
					//  SVC; send ARP Request
					//

					AtmArpStartTimer(
							pInterface,
							&(pIpEntry->Timer),
							AtmArpAddressResolutionTimeout,
							pInterface->AddressResolutionTimeout,
							(PVOID)pIpEntry
							);

					pIpEntry->RetriesLeft = 0;
					AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer ref
					AA_SET_FLAG(pIpEntry->Flags, AA_IP_ENTRY_STATE_MASK, AA_IP_ENTRY_ARPING);
					DstIPAddress = pIpEntry->IPAddress;

					AA_RELEASE_IE_LOCK(pIpEntry);

					AtmArpSendARPRequest(
							pInterface,
							&(pInterface->LocalIPAddress.IPAddress),
							&DstIPAddress
							);
				}
			}
			else
			{
				//
				//  No VCs attached to this IP Entry; Delete it.
				//

				AtmArpAbortIPEntry(pIpEntry);
				//
				//  The IP Entry lock is released in the above routine.
				//
			}
		}
		else
		{
			//
			//  The Interface is going down.
			//
			AA_RELEASE_IE_LOCK(pIpEntry);
		}
	}
	//
	//  else the IP Entry is gone
	//
	return;		

}





VOID
AtmArpVcAgingTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called if there hasn't been traffic on a VC for
	some time. We should be running this timer on a VC only if it is
	an SVC.

	Close the VC.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP VC

Return Value:

	None

--*/
{
	PATMARP_VC				pVc;			// VC that has aged out
	ULONG					rc;				// Ref Count on the VC
	PATMARP_INTERFACE		pInterface;


	pVc = (PATMARP_VC)Context;
	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT(AA_IS_FLAG_SET(pVc->Flags, AA_VC_TYPE_MASK, AA_VC_TYPE_SVC));

	AADEBUGP(AAD_INFO, ("Aged out VC %x, Flags %x, ATMEntry %x\n",
					pVc, pVc->Flags, pVc->pAtmEntry));
#if DBG
	if (pVc->pAtmEntry)
	{
		AADEBUGPATMADDR(AAD_INFO, "To ATM Addr:", &pVc->pAtmEntry->ATMAddress);
	}
#endif

	AA_ACQUIRE_VC_LOCK(pVc);
	rc = AtmArpDereferenceVc(pVc);	// Timer ref

	//
	//  Continue only if the VC hasn't gone away in the meantime.
	//
	if (rc > 0)
	{
		//
		//  Continue only if the Interface isn't going down.
		//
		pInterface = pVc->pInterface;

		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AADEBUGP(AAD_INFO,
				("Aged out VC 0x%x, RefCount %d, Flags 0x%x, pAtmEntry 0x%x\n",
					pVc, pVc->RefCount, pVc->Flags, pVc->pAtmEntry));

			AtmArpCloseCall(pVc);
		}
		else
		{
			//
			//  The interface is going down.
			//
			AA_RELEASE_VC_LOCK(pVc);
		}
	}
	//
	//  else the VC is gone
	//

	return;

}




VOID
AtmArpNakDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called if sufficient time has elapsed since we last
	received a NAK for an IP address. This means that we can try again
	(if necessary) to resolve this IP address.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;

	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);
	AA_ASSERT(AA_IS_FLAG_SET(pIpEntry->Flags,
							 AA_IP_ENTRY_STATE_MASK, 
							 AA_IP_ENTRY_SEEN_NAK));

	AADEBUGP(AAD_INFO, ("NakDelay timeout: pIpEntry 0x%x, IP Addr: %d.%d.%d.%d\n",
					pIpEntry,
					((PUCHAR)(&(pIpEntry->IPAddress)))[0],
					((PUCHAR)(&(pIpEntry->IPAddress)))[1],
					((PUCHAR)(&(pIpEntry->IPAddress)))[2],
					((PUCHAR)(&(pIpEntry->IPAddress)))[3]
					));

	pInterface = pIpEntry->pInterface;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);
	if (rc > 0)
	{
		AA_SET_FLAG(pIpEntry->Flags,
					AA_IP_ENTRY_STATE_MASK,
					AA_IP_ENTRY_IDLE2);

		AtmArpStartTimer(
					pInterface,
					&(pIpEntry->Timer),
					AtmArpIPEntryAgingTimeout,
					pInterface->ARPEntryAgingTimeout,
					(PVOID)pIpEntry
					);

		AA_REF_IE(pIpEntry, IE_REFTYPE_TIMER);	// Timer ref
		AA_RELEASE_IE_LOCK(pIpEntry);
	}
	//
	//  else the IP Entry is gone.
	//


	return;
}


#ifdef IPMCAST

VOID
AtmArpMcMARSRegistrationTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	We haven't received acknowledgement of registering with the MARS.
	If we have retries left for this, try registering again. Otherwise,
	process this as a MARS failure.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMARP Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE		pInterface;
	ULONG					rc;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_INFO, ("MARS Registration timeout: pIf 0x%x, IF Flags 0x%x\n",
				pInterface, pInterface->Flags));

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// Timer ref

	//
	//  Continue only if the Interface is still alive
	//
	if (rc != 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			if (pInterface->McRetriesLeft != 0)
			{
				pInterface->McRetriesLeft--;

				AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_NOT_REGISTERED);
	
				AtmArpMcStartRegistration(pInterface);
				//
				//  IF Lock is released within the above.
				//
			}
			else
			{
				//
				//  Out of retries: problems with this MARS
				//
				AA_RELEASE_IF_LOCK(pInterface);
				AtmArpMcHandleMARSFailure(pInterface, TRUE);
			}
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}
}



VOID
AtmArpMcMARSReconnectTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is the end of a delay before we retry registering with MARS.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE			pInterface;
	ULONG						rc;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// MARS Reconnect timer deref
	if (rc != 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AAMCDEBUGP(AAD_INFO, ("MARS Reconnect timeout: pIf 0x%x, Flags 0x%x\n",
					pInterface, pInterface->Flags));

			AAMC_SET_IF_STATE(pInterface, AAMC_IF_STATE_NOT_REGISTERED);

			AA_SET_FLAG(pInterface->Flags,
						AAMC_IF_MARS_FAILURE_MASK,
						AAMC_IF_MARS_FAILURE_NONE);

			AtmArpMcStartRegistration(pInterface);
			//
			//  IF Lock is released within the above.
			//
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}
	//
	//  else the IF is gone.
	//
}



VOID
AtmArpMcMARSKeepAliveTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called if "MARSKeepAliveTimeout" seconds have passed since
	we last received a MARS_REDIRECT message.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our Interface structure

Return Value:

	None

--*/
{
	PATMARP_INTERFACE			pInterface;
	ULONG						rc;

	pInterface = (PATMARP_INTERFACE)Context;
	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ACQUIRE_IF_LOCK(pInterface);
	rc = AtmArpDereferenceInterface(pInterface);	// MARS Keepalive timer deref
	if (rc != 0)
	{
		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AAMCDEBUGP(AAD_INFO, ("MARS Keepalive timeout: pIf 0x%x, Flags 0x%x\n",
					pInterface, pInterface->Flags));

			AA_RELEASE_IF_LOCK(pInterface);

			AtmArpMcHandleMARSFailure(pInterface, FALSE);
		}
		else
		{
			AA_RELEASE_IF_LOCK(pInterface);
		}
	}

}



VOID
AtmArpMcJoinOrLeaveTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	We timed out waiting for an acknowledgement for a MARS_JOIN/MARS_LEAVE.

	If we have retries left for this JOIN/LEAVE, resend the JOIN. Otherwise,
	declare a MARS failure.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our JOIN Entry structure

Return Value:

	None

--*/
{
	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry;
	PATMARP_INTERFACE			pInterface;
	PIP_ADDRESS					pIpAddress;
	IP_MASK						IpMask;
	USHORT						OpType;

	pJoinEntry = (PATMARP_IPMC_JOIN_ENTRY)Context;
	AA_STRUCT_ASSERT(pJoinEntry, aamj);

	pInterface = pJoinEntry->pInterface;

	AAMCDEBUGP(AAD_VERY_LOUD,
		("McJoinTimeout: pJoinEntry 0x%x, RetriesLeft %d, IP Addr: %d.%d.%d.%d\n",
				pJoinEntry,
				pJoinEntry->RetriesLeft,
				((PUCHAR)&(pJoinEntry->IPAddress))[0],
				((PUCHAR)&(pJoinEntry->IPAddress))[1],
				((PUCHAR)&(pJoinEntry->IPAddress))[2],
				((PUCHAR)&(pJoinEntry->IPAddress))[3]));

	AA_ACQUIRE_IF_LOCK(pInterface);
	if (pInterface->AdminState == IF_STATUS_UP)
	{
		pJoinEntry->RetriesLeft--;
		if (pJoinEntry->RetriesLeft != 0)
		{
			pIpAddress = &(pJoinEntry->IPAddress);
			IpMask = pJoinEntry->Mask;

			if (AA_IS_FLAG_SET(pJoinEntry->Flags,
							AA_IPMC_JE_STATE_MASK,
							AA_IPMC_JE_STATE_LEAVING))
			{
				OpType = AA_MARS_OP_TYPE_LEAVE;
			}
			else
			{
				OpType = AA_MARS_OP_TYPE_JOIN;

				//
				// State could've been "pending"
				//
				AA_SET_FLAG(pJoinEntry->Flags,
								AA_IPMC_JE_STATE_MASK,
								AA_IPMC_JE_STATE_JOINING);
			}

			//
			//  Restart the "Wait For Join completion" timer.
			//
			AtmArpStartTimer(
				pInterface,
				&(pJoinEntry->Timer),
				AtmArpMcJoinOrLeaveTimeout,
				pInterface->JoinTimeout,
				(PVOID)pJoinEntry
				);
			
			//
			//  Resend the Join or Leave
			//
			AAMCDEBUGP(AAD_INFO,
				("Resending Join/Leave: pIf 0x%x, pJoinEntry 0x%x, Addr: %d.%d.%d.%d\n",
						pInterface,
						pJoinEntry,
						((PUCHAR)pIpAddress)[0],
						((PUCHAR)pIpAddress)[1],
						((PUCHAR)pIpAddress)[2],
						((PUCHAR)pIpAddress)[3]));

			AtmArpMcSendJoinOrLeave(
				pInterface,
				OpType,
				pIpAddress,
				IpMask
				);
			//
			//  IF Lock is released within the above.
			//
		}
		else
		{
			//
			//  Out of retries: problems with this MARS.
			//
			AA_RELEASE_IF_LOCK(pInterface);
			AtmArpMcHandleMARSFailure(pInterface, FALSE);
		}
	}
	else
	{
		AA_RELEASE_IF_LOCK(pInterface);
	}
}




VOID
AtmArpMcRevalidationDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	It's time to mark an IP Entry representing a Multicast group as
	needing revalidation.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our IP Entry structure

Return Value:

	None

--*/
{
	PATMARP_IP_ENTRY			pIpEntry;
	PATMARP_INTERFACE			pInterface;
	ULONG						rc;
	PNDIS_PACKET				PacketList;

	pIpEntry = (PATMARP_IP_ENTRY)Context;
	AA_STRUCT_ASSERT(pIpEntry, aip);
	PacketList = NULL;

	AA_ACQUIRE_IE_LOCK(pIpEntry);
	AA_ASSERT(AA_IE_IS_ALIVE(pIpEntry));

	rc = AA_DEREF_IE(pIpEntry, IE_REFTYPE_TIMER);		// Timer ref

	//
	//  Continue only if the entry hasn't gone away.
	//
	if (rc != 0)
	{
		//
		//  Remove any packets queued on this IP Entry.
		//
		PacketList = pIpEntry->PacketList;
		pIpEntry->PacketList = (PNDIS_PACKET)NULL;

		//
		//  Continue only if the state is OK.
		//
		pInterface = pIpEntry->pInterface;

		if (pInterface->AdminState == IF_STATUS_UP)
		{
			AAMCDEBUGP(AAD_LOUD,
					("Marking Revalidate: pIpEntry 0x%x/0x%x, pAtmEntry 0x%x, Addr: %d.%d.%d.%d\n",
							pIpEntry,
							pIpEntry->Flags,
							pIpEntry->pAtmEntry,
							((PUCHAR)&(pIpEntry->IPAddress))[0],
							((PUCHAR)&(pIpEntry->IPAddress))[1],
							((PUCHAR)&(pIpEntry->IPAddress))[2],
							((PUCHAR)&(pIpEntry->IPAddress))[3]));

			AA_SET_FLAG(pIpEntry->Flags,
						AA_IP_ENTRY_MC_VALIDATE_MASK,
						AA_IP_ENTRY_MC_REVALIDATE);
		}

		AA_RELEASE_IE_LOCK(pIpEntry);
	}
	//
	//  else the IP Entry is gone.
	//

	if (PacketList != NULL)
	{
		//
		//  Free all packets that were queued on the IP Entry.
		//
		AtmArpFreeSendPackets(
					pInterface,
					PacketList,
					FALSE       // No LLC/SNAP header on these
					);
	}
}


VOID
AtmArpMcPartyRetryDelayTimeout(
	IN	PATMARP_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	End of a delay after failing to connect or add-party a member of
	a multicast group. Unmark this member, and attempt to add it.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our MC ATM Entry structure

Return Value:

	None

--*/
{
	PATMARP_IPMC_ATM_ENTRY		pMcAtmEntry;
	PATMARP_IPMC_ATM_ENTRY *	ppMcAtmEntry;
	PATMARP_ATM_ENTRY			pAtmEntry;
	PATMARP_IP_ENTRY			pIpEntry;

	pMcAtmEntry = (PATMARP_IPMC_ATM_ENTRY)Context;
	AA_STRUCT_ASSERT(pMcAtmEntry, ame);

	pAtmEntry = pMcAtmEntry->pAtmEntry;
	AA_STRUCT_ASSERT(pAtmEntry, aae);

	AAMCDEBUGP(AAD_LOUD,
		("PartyRetryDelay timeout: pMcAtmEntry 0x%x, pAtmEntry 0x%x\n",
				pMcAtmEntry, pAtmEntry));

	AA_ACQUIRE_AE_LOCK(pAtmEntry);
	AA_ASSERT(pAtmEntry->pIpEntryList != NULL_PATMARP_IP_ENTRY);

	if (pAtmEntry->pInterface->AdminState == IF_STATUS_UP)
	{
		AA_SET_FLAG(pMcAtmEntry->Flags,
					AA_IPMC_AE_CONN_STATE_MASK,
					AA_IPMC_AE_CONN_DISCONNECTED);
		
		//
		//  Move this MC ATM Entry to the top of the list it belongs to.
		//
		//  Find the predecessor for this MC ATM Entry:
		//
		for (ppMcAtmEntry = &(pAtmEntry->pMcAtmInfo->pMcAtmEntryList);
			 *ppMcAtmEntry != pMcAtmEntry;
			 ppMcAtmEntry = &((*ppMcAtmEntry)->pNextMcAtmEntry))
		{
			AA_ASSERT(*ppMcAtmEntry != NULL_PATMARP_IPMC_ATM_ENTRY);
		}

		//
		//  Unlink the MC ATM Entry from its current position
		//
		*ppMcAtmEntry = pMcAtmEntry->pNextMcAtmEntry;

		//
		//  And insert at the top of the list.
		//
		pMcAtmEntry->pNextMcAtmEntry = pAtmEntry->pMcAtmInfo->pMcAtmEntryList;
		pAtmEntry->pMcAtmInfo->pMcAtmEntryList = pMcAtmEntry;

		AtmArpMcUpdateConnection(pAtmEntry);
		//
		//  AE Lock is released within the above.
		//
	}
	else
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}
	
}


#endif // IPMCAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\qos.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	qos.c

Abstract:

	Quality Of Service support routines. These are a collection of
	heuristics that allow configuration of different types of VCs
	between two IP endstations.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     09-27-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER	' SOQ'


#ifdef QOS_HEURISTICS


VOID
AtmArpQosGetPacketSpecs(
	IN	PVOID						Context,
	IN	PNDIS_PACKET				pNdisPacket,
	OUT	PATMARP_FLOW_INFO			*ppFlowInfo,
	OUT	PATMARP_FLOW_SPEC			*ppFlowSpec,
	OUT	PATMARP_FILTER_SPEC			*ppFilterSpec
)
/*++

Routine Description:

	Given a packet to be transmitted over an Interface, return the
	flow and filter specs for the packet.

	We go through the list of configured Flow Info structures on the
	specified interface, and find the Flow Info that comes closest
	to matching this packet.

	For now, the algorithm is: search thru the list of Flow Info structures
	configured on the interface -- a match is found when we find a Flow
	Info structure that has a PacketSizeLimit greater than or equal to the
	packet size (the flow info list is arranged in ascending order of
	PacketSizeLimit).

	GPC enhancement: if we couldn't find a matching flow on the Interface,
	ask the GPC to classify the packet for us.

	NOTE: This packet must not have any headers (LLC/SNAP) pre-pended to it.

Arguments:

	Context				- Actually a pointer to an Interface structure
	pNdisPacket			- Pointer to the packet to be classified
	ppFlowInfo			- where we return a pointer to the packet's flow info
	ppFlowSpec			- where we return a pointer to the packet's flow spec
	ppFilterSpec		- where we return a pointer to the packet's filter spec

Return Value:

	None. See Arguments above.

--*/
{
	PATMARP_INTERFACE			pInterface;
	PATMARP_FLOW_INFO			pFlowInfo;
	UINT						TotalLength;
#if DBG
	AA_IRQL					EntryIrq, ExitIrq;
#endif

	AA_GET_ENTRY_IRQL(EntryIrq);

	pInterface = (PATMARP_INTERFACE)Context;

	//
	//  Get the packet's total length.
	//
	NdisQueryPacket(
			pNdisPacket,
			NULL,		// Phys buffer count
			NULL,		// Buffer count
			NULL,		// First Buffer
			&TotalLength
			);

	//
	// Note that we test for pInterface->pFlowInfoList BEFORE grabbing
	// the interface lock -- this so that for the most common case of not
	// having these preconfigured flows, we don't take the drastic action
	// of taking the interface lock for each send packet! There is
	// no harm in doing this check, as long as the pFlowInfo pointer we actually
	// use is got AFTER taking the lock.
	//
	// TODO: perhaps get rid of this code altogether -- along with other code
	// dealing with preconfigured flows.
	//

	pFlowInfo  = pInterface->pFlowInfoList;

	if (pFlowInfo)
	{
		AA_ACQUIRE_IF_LOCK(pInterface);
	
		//
		// Remember to reload pFlowInfo once we have the the lock.
		//
		for (pFlowInfo = pInterface->pFlowInfoList;
 			pFlowInfo != (PATMARP_FLOW_INFO)NULL;
 			pFlowInfo = pFlowInfo->pNextFlow)
		{
			if (TotalLength <= pFlowInfo->PacketSizeLimit)
			{
				break;
			}
		}
	
		AA_RELEASE_IF_LOCK(pInterface);
	}

	if (pFlowInfo != (PATMARP_FLOW_INFO)NULL)
	{
		*ppFlowInfo = pFlowInfo;
		*ppFlowSpec = &(pFlowInfo->FlowSpec);
		*ppFilterSpec = &(pFlowInfo->FilterSpec);
	}
	else
	{
#ifdef GPC
		CLASSIFICATION_HANDLE		ClassificationHandle;

        ClassificationHandle = (CLASSIFICATION_HANDLE)
        	PtrToUlong(
            NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, 
                                             ClassificationHandlePacketInfo));
        *ppFlowInfo = NULL;

        if (ClassificationHandle){
            GPC_STATUS					GpcStatus;

            AA_ASSERT(GpcGetCfInfoClientContext);
            GpcStatus = GpcGetCfInfoClientContext(pAtmArpGlobalInfo->GpcClientHandle,
                                                  ClassificationHandle,
                                                  ppFlowInfo);
            
        }
        else{

#if 0
            //
            // THIS CODE HAS BEEN COMMENTED OUT SINCE
            // WE ASSUME THAT CLASSIFICATION IS DONE IN
            // TCP. IF WE DON'T GET A CH - THERE'S NOT MUCH POINT
            // IN CALLING THE GPC AGAIN...
            //

            GPC_STATUS					GpcStatus;
            TC_INTERFACE_ID				InterfaceId;
            
            InterfaceId.InterfaceId = 0;
            InterfaceId.LinkId = 0;

            AA_ASSERT(GpcClassifyPacket);
            GpcStatus = GpcClassifyPacket(
							pAtmArpGlobalInfo->GpcClientHandle,
                            GPC_PROTOCOL_TEMPLATE_IP,
                            pNdisPacket,
                            0,				// TransportHeaderOffset
                            &InterfaceId,
                            (PGPC_CLIENT_HANDLE)ppFlowInfo,
                            &ClassificationHandle
                            );
#endif
        }

		AA_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

		if (*ppFlowInfo != NULL)
		{
			AA_ASSERT(*ppFlowInfo != NULL);
			*ppFlowSpec = &((*ppFlowInfo)->FlowSpec);
			*ppFilterSpec = &((*ppFlowInfo)->FilterSpec);

			AADEBUGP(AAD_LOUD,
					("ClassifyPacket: Pkt %x: pFlowInfo %x, pFlowSpec %x, SendBW %d, ServType %d\n",
						pNdisPacket,
						*ppFlowInfo,
						*ppFlowSpec,
						(*ppFlowSpec)->SendAvgBandwidth,
						(*ppFlowSpec)->SendServiceType));
		}
		else
		{
			//*ppFlowInfo = NULL;
			*ppFlowSpec = &(pInterface->DefaultFlowSpec);
			*ppFilterSpec = &(pInterface->DefaultFilterSpec);
		}
#else
		*ppFlowInfo = NULL;
		*ppFlowSpec = &(pInterface->DefaultFlowSpec);
		*ppFilterSpec = &(pInterface->DefaultFilterSpec);
#endif // GPC
	}

	return;
}


BOOLEAN
AtmArpQosDoFlowsMatch(
	IN	PVOID						Context,
	IN	PATMARP_FLOW_SPEC			pFlowSpec,
	IN	PATMARP_FLOW_SPEC			pTargetFlowSpec
)
/*++

Routine Description:

	Check if a target flow spec supports the given flow spec. Currently,
	we check only the bandwidth: if the target flow spec has a send bandwidth
	greater than or equal to that of the given flow spec, we declare a match.

Arguments:

	Context				- Actually a pointer to an Interface structure
	pFlowSpec			- The given flow spec which we are trying to satisfy
	pTargetFlowSpec		- The candidate flow spec

Return Value:

	TRUE iff the target flow spec matches the given flow spec.

--*/
{
	return (
			(pFlowSpec->SendServiceType == pTargetFlowSpec->SendServiceType)
				 &&
			(pFlowSpec->SendPeakBandwidth <= pTargetFlowSpec->SendPeakBandwidth)
		   );
}



BOOLEAN
AtmArpQosDoFiltersMatch(
	IN	PVOID						Context,
	IN	PATMARP_FILTER_SPEC			pFilterSpec,
	IN	PATMARP_FILTER_SPEC			pTargetFilterSpec
)
/*++

Routine Description:

	Check if a target filter spec matches the given filter spec. Currently,
	we always return TRUE.

Arguments:

	Context				- Actually a pointer to an Interface structure
	pFilterSpec			- The given filter spec which we are trying to satisfy
	pTargetFilterSpec	- The candidate filter spec

Return Value:

	TRUE always.

--*/
{
	return (TRUE);
}


#endif // QOS_HEURISTICS


#ifdef GPC

#define AA_GPC_COPY_FLOW_PARAMS(_pFlowInfo, _pQosInfo)							\
		{																		\
			(_pFlowInfo)->FlowSpec.SendAvgBandwidth = 							\
						(_pQosInfo)->GenFlow.SendingFlowspec.TokenRate;					\
			(_pFlowInfo)->FlowSpec.SendPeakBandwidth = 							\
						(_pQosInfo)->GenFlow.SendingFlowspec.PeakBandwidth;				\
			(_pFlowInfo)->FlowSpec.SendMaxSize =								\
					MAX((_pQosInfo)->GenFlow.SendingFlowspec.TokenBucketSize,			\
						(_pQosInfo)->GenFlow.SendingFlowspec.MaxSduSize);				\
			(_pFlowInfo)->PacketSizeLimit = (_pFlowInfo)->FlowSpec.SendMaxSize;	\
			(_pFlowInfo)->FlowSpec.ReceiveAvgBandwidth = 						\
					(_pQosInfo)->GenFlow.ReceivingFlowspec.TokenRate;					\
			(_pFlowInfo)->FlowSpec.ReceivePeakBandwidth =						\
						(_pQosInfo)->GenFlow.ReceivingFlowspec.PeakBandwidth;			\
			(_pFlowInfo)->FlowSpec.ReceiveMaxSize =								\
					MAX((_pQosInfo)->GenFlow.ReceivingFlowspec.TokenBucketSize,			\
						(_pQosInfo)->GenFlow.ReceivingFlowspec.MaxSduSize);				\
			(_pFlowInfo)->FlowSpec.Encapsulation = ENCAPSULATION_TYPE_LLCSNAP;	\
			(_pFlowInfo)->FlowSpec.AgingTime = 0;								\
			(_pFlowInfo)->FlowSpec.SendServiceType = 							\
						(_pQosInfo)->GenFlow.SendingFlowspec.ServiceType;				\
			(_pFlowInfo)->FlowSpec.ReceiveServiceType = 						\
						(_pQosInfo)->GenFlow.ReceivingFlowspec.ServiceType;				\
		}


VOID
AtmArpGpcInitialize(
	VOID
)
/*++

Routine Description:

	Initialize with the Generic Packet Classifier. The GPC informs us of
	newly created flows (e.g. via RSVP) and of flows being torn down.
	For each flow, we keep context (ATMARP_FLOW_INFO) that keeps track of
	the QoS needed for the flow. Each IP packet given to us for transmission
	is classified into a flow, and we use this flow info to make VCs with
	the appropriate characteristics.

Arguments:

	None

Return Value:

	None

--*/
{
	GPC_STATUS					GpcStatus;
	ULONG						ClassificationFamilyId;
	ULONG						Flags;
	ULONG						ProtocolTemplate;
	ULONG						MaxPriorities;
	GPC_CLIENT_FUNC_LIST		AtmArpFuncList;
	GPC_CLIENT_HANDLE			ClientContext;

	//
	//  Initialize the GPC.
	//
	GpcStatus = GpcInitialize(&pAtmArpGlobalInfo->GpcCalls);

	if (GpcStatus != GPC_STATUS_SUCCESS)
	{
		AADEBUGP(AAD_WARNING, ("GpcInitialize failed, status 0x%x\n", GpcStatus));
		pAtmArpGlobalInfo->bGpcInitialized = FALSE;
		return;
	}

	pAtmArpGlobalInfo->bGpcInitialized = TRUE;

	AtmArpGpcClassifyPacketHandler = pAtmArpGlobalInfo->GpcCalls.GpcClassifyPacketHandler;
    AtmArpGpcGetCfInfoClientContextHandler = pAtmArpGlobalInfo->GpcCalls.GpcGetCfInfoClientContextHandler;

	ClassificationFamilyId = GPC_CF_QOS;
	Flags = 0;
	ProtocolTemplate = GPC_PROTOCOL_TEMPLATE_IP;
	MaxPriorities = 1;

	AA_SET_MEM(&AtmArpFuncList, 0, sizeof(AtmArpFuncList));

	AtmArpFuncList.ClAddCfInfoCompleteHandler = AtmArpGpcAddCfInfoComplete;
	AtmArpFuncList.ClAddCfInfoNotifyHandler = AtmArpGpcAddCfInfoNotify;
	AtmArpFuncList.ClModifyCfInfoCompleteHandler = AtmArpGpcModifyCfInfoComplete;
	AtmArpFuncList.ClModifyCfInfoNotifyHandler = AtmArpGpcModifyCfInfoNotify;
	AtmArpFuncList.ClRemoveCfInfoCompleteHandler = AtmArpGpcRemoveCfInfoComplete;
	AtmArpFuncList.ClGetCfInfoName = AtmArpGpcGetCfInfoName;
	AtmArpFuncList.ClRemoveCfInfoNotifyHandler = AtmArpGpcRemoveCfInfoNotify;

	ClientContext = (GPC_CLIENT_HANDLE)pAtmArpGlobalInfo;

	GpcStatus = GpcRegisterClient(
						ClassificationFamilyId,
						Flags,
						MaxPriorities,
						&AtmArpFuncList,
						ClientContext,
						&(pAtmArpGlobalInfo->GpcClientHandle)
						);

	AADEBUGP(AAD_INFO,
			("GpcRegisterClient status 0x%x, GpcClientHandle 0x%x\n",
				GpcStatus, pAtmArpGlobalInfo->GpcClientHandle));

	if(GpcStatus != GPC_STATUS_SUCCESS)
    {
        AA_ASSERT(FALSE);
	    pAtmArpGlobalInfo->bGpcInitialized = FALSE;
    }
}




VOID
AtmArpGpcShutdown(
	VOID
)
/*++

Routine Description:

	Shuts down our GPC interface.

Arguments:

	None

Return Value:

	None

--*/
{
	GPC_STATUS		GpcStatus;

	if (pAtmArpGlobalInfo->bGpcInitialized)
	{
		GpcStatus = GpcDeregisterClient(pAtmArpGlobalInfo->GpcClientHandle);

		AA_ASSERT(GpcStatus == GPC_STATUS_SUCCESS);
	}
}




VOID
AtmArpGpcAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
)
/*++

Routine Description:

	This is the entry point called by GPC when a pended call to
	GpcAddCfInfo() has completed. Since we never call GpcAddCfInfo,
	we should never be called here.

Arguments:

	<Not used>

Return Value:

	None

--*/
{
	AA_ASSERT(FALSE);
}





GPC_STATUS
AtmArpGpcAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_HANDLE					GpcCfInfoHandle,
	IN	ULONG						CfInfoSize,
	IN	PVOID						pCfInfo,
	OUT	PGPC_CLIENT_HANDLE			pClientCfInfoContext
)
/*++

Routine Description:

	This is the entry point called by GPC to notify us of creation of
	a new INFO block of type QOS. We allocate a FLOW_INFO structure,
	fill it with what we need, and return a pointer to it as our context.

Arguments:

	ClientContext		- Pointer to our global info struct
	GpcCfInfoHandle		- GPC Handle to use in all GPC APIs for this INFO block
	CfInfoSize			- Length of the following block
	pCfInfo				- Pointer to the newly created INFO block
	pClientCfInfoContext- Place where we return our context for this block

Return Value:

	GPC_STATUS_SUCCESS if we were able to allocate a new FLOW_INFO structure,
	GPC_STATUS_RESOURCES otherwise.

--*/
{
	PATMARP_FLOW_INFO		pFlowInfo;
	GPC_STATUS				GpcStatus;
	PCF_INFO_QOS			pQosInfo;

	pQosInfo = (PCF_INFO_QOS)pCfInfo;

	//
	//  Initialize.
	//
	*pClientCfInfoContext = NULL;

	do
	{
		GpcStatus = AtmArpGpcValidateCfInfo(pCfInfo, CfInfoSize);

		if (GpcStatus != GPC_STATUS_SUCCESS)
		{
			break;
		}

		AA_ALLOC_MEM(pFlowInfo, ATMARP_FLOW_INFO, sizeof(ATMARP_FLOW_INFO));

		if (pFlowInfo == NULL)
		{
			GpcStatus = GPC_STATUS_RESOURCES;
			break;
		}

		AA_SET_MEM(pFlowInfo, 0, sizeof(ATMARP_FLOW_INFO));

		pFlowInfo->CfInfoHandle = GpcCfInfoHandle;

		//
		//  Copy in flow parameters
		//
		AA_GPC_COPY_FLOW_PARAMS(pFlowInfo, pQosInfo);

		//
		// Generate Unique Name for this flow.
		// This name is based on the template, AA_FLOW_INSTANCE_TEMPLATE.
		// The flow number part is based on a static variable which is
		// InterlockIncremented each time a flowinfo is created.
		//
		{
			static		ULONG FlowCount = 0;
			ULONG 		ThisFlow =  NdisInterlockedIncrement(&FlowCount);
			WCHAR		*pwc;

			AA_ASSERT(sizeof(pFlowInfo->FlowInstanceName)
					  == sizeof(AA_FLOW_INSTANCE_NAME_TEMPLATE)-sizeof(WCHAR));

			AA_COPY_MEM(
					pFlowInfo->FlowInstanceName,
					AA_FLOW_INSTANCE_NAME_TEMPLATE,
					sizeof(pFlowInfo->FlowInstanceName)
					);

			//
			// We fill in the "flow number" field of the template, which
			// is the 1st 8 characters, with the hex representation of
			// ThisFlow. The LS digit is at offset 7.
			//
			pwc = pFlowInfo->FlowInstanceName+7;
			AA_ASSERT(2*sizeof(ThisFlow) == 8);
			while (ThisFlow)
			{
				ULONG u = ThisFlow & 0xf;
				*pwc--  =  (WCHAR) ((u < 10) ? (u + '0') : u + 'A' - 10);
				ThisFlow >>= 4;
			}
		}

		//
		//  Link it to the global flow list.
		//
		AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		pFlowInfo->pPrevFlow = NULL;
		pFlowInfo->pNextFlow = pAtmArpGlobalInfo->pFlowInfoList;

		if (pAtmArpGlobalInfo->pFlowInfoList != NULL)
		{
			pAtmArpGlobalInfo->pFlowInfoList->pPrevFlow = pFlowInfo;
		}

		pAtmArpGlobalInfo->pFlowInfoList = pFlowInfo;

		AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

		//
		//  Return our context for this flow.
		//
		*pClientCfInfoContext = (GPC_CLIENT_HANDLE)pFlowInfo;
		GpcStatus = GPC_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	AADEBUGP(AAD_INFO, ("AddCfInfoNotify: pCfInfo x%x, ClientCtx x%x, ret x%x\n",
						pCfInfo, *pClientCfInfoContext, GpcStatus));
#if DBG
	if (GpcStatus == GPC_STATUS_SUCCESS)
	{
		AADEBUGP(AAD_INFO, ("               : SendPeak %d, SendAvg %d, SendPktSize %d, ServType %d\n",
						pFlowInfo->FlowSpec.SendPeakBandwidth,
						pFlowInfo->FlowSpec.SendAvgBandwidth,
						pFlowInfo->FlowSpec.SendMaxSize,
						pFlowInfo->FlowSpec.SendServiceType));
		AADEBUGP(AAD_INFO, ("               : RecvPeak %d, RecvAvg %d, RecvPktSize %d, ServType %d\n",
						pFlowInfo->FlowSpec.ReceivePeakBandwidth,
						pFlowInfo->FlowSpec.ReceiveAvgBandwidth,
						pFlowInfo->FlowSpec.ReceiveMaxSize,
						pFlowInfo->FlowSpec.ReceiveServiceType));
	}
#endif
						

	return (GpcStatus);
}




VOID
AtmArpGpcModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
)
/*++

Routine Description:

	This is the entry point called by GPC when a pended call to
	GpcModifyCfInfo() has completed. Since we never call GpcModifyCfInfo,
	we should never be called here.

	Addendum: Apparently this is called even if another client calls
	GpcModifyCfInfo, just to notify this client that the modify operation
	finished.

Arguments:

	<Not used>

Return Value:

	None

--*/
{
	return;
}




GPC_STATUS
AtmArpGpcModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	ULONG						CfInfoSize,
	IN	PVOID						pNewCfInfo
)
/*++

Routine Description:

	This is the entry point called by GPC when an existing flow has
	been modified.

	If the flow info for this flow is linked with a VC, we unlink it,
	and start an aging timeout on the VC. We update the flow info structure
	with this new information. The next packet that falls into this
	classification will cause a new VC with updated QoS to be created.

Arguments:

	ClientContext		- Pointer to our global context
	ClientCfInfoContext	- Pointer to our FLOW INFO structure
	CfInfoSize			- Length of the following
	pNewCfInfo			- Updated flow info

Return Value:

	GPC_STATUS_SUCCESS always.

--*/
{
	PATMARP_FLOW_INFO		pFlowInfo;
	PATMARP_VC				pVc;
	GPC_STATUS				GpcStatus;
	PCF_INFO_QOS			pQosInfo;
	ULONG					rc;

	pQosInfo = (PCF_INFO_QOS)pNewCfInfo;

	pFlowInfo = (PATMARP_FLOW_INFO)ClientCfInfoContext;

	GpcStatus = GPC_STATUS_SUCCESS;

	do
	{
		GpcStatus = AtmArpGpcValidateCfInfo(pNewCfInfo, CfInfoSize);

		if (GpcStatus != GPC_STATUS_SUCCESS)
		{
			break;
		}

		pVc = (PATMARP_VC) InterlockedExchangePointer(
								&(pFlowInfo->VcContext),
								NULL
								);

		if (pVc == NULL_PATMARP_VC)
		{
			//
			//  This flow isn't associated with a VC.
			//
			break;
		}


		//
		//  Unlink the flow from the VC.
		//

		AA_ACQUIRE_VC_LOCK(pVc);

		AA_ASSERT(pVc->FlowHandle == (PVOID)pFlowInfo);

		pVc->FlowHandle = NULL;
		rc = AtmArpDereferenceVc(pVc);	// GPC Unlink flow info (modify)

		if (rc != 0)
		{
			AA_SET_FLAG(pVc->Flags,
						AA_VC_GPC_MASK,
						AA_VC_GPC_IS_UNLINKED_FROM_FLOW);

			//
			//  Age out this VC if it isn't aging out yet.
			//
			if (!AA_IS_TIMER_ACTIVE(&(pVc->Timer)))
			{
				AtmArpStartTimer(
						pVc->pInterface,
						&(pVc->Timer),
						AtmArpVcAgingTimeout,
						1,			// Age out in 1 second
						(PVOID)pVc
						);

				AtmArpReferenceVc(pVc);	// GPC Flow remove decay timer ref
			}

			AA_RELEASE_VC_LOCK(pVc);
		}
		//
		//  else the VC is gone.
		//

		//
		//  Update the flow info.
		//
		AA_GPC_COPY_FLOW_PARAMS(pFlowInfo, pQosInfo);
		break;
	}
	while (FALSE);

	AADEBUGP(AAD_INFO, ("ModCfInfo: pFlowInfo x%x, VC x%x, New SendBW %d, SendPktSz %d\n",
				pFlowInfo,
				pFlowInfo->VcContext,
				pFlowInfo->FlowSpec.SendAvgBandwidth,
				pFlowInfo->FlowSpec.SendMaxSize));

	return (GpcStatus);
}




VOID
AtmArpGpcRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext,
	IN	GPC_STATUS					GpcStatus
)
/*++

Routine Description:

	This is the entry point called by GPC when a pended call to
	GpcRemoveCfInfo() has completed. Since we never call GpcRemoveCfInfo,
	we should never be called here.

Arguments:

	<Not used>

Return Value:

	None

--*/
{
	AA_ASSERT(FALSE);
}




GPC_STATUS
AtmArpGpcRemoveCfInfoNotify(
	IN	GPC_CLIENT_HANDLE			ClientContext,
	IN	GPC_CLIENT_HANDLE			ClientCfInfoContext
)
/*++

Routine Description:

	This is the entry point called by GPC to notify us that a flow
	is being removed. We locate our context for the flow, unlink
	it from the ATM VC that carries the flow, and start aging
Arguments:

	ClientContext		- Pointer to our global context
	ClientCfInfoContext	- Pointer to our FLOW INFO structure

Return Value:

	GPC_STATUS_SUCCESS always.

--*/
{
	PATMARP_FLOW_INFO		pFlowInfo;
	PATMARP_VC				pVc;
	GPC_STATUS				GpcStatus;
	ULONG					rc;

	pFlowInfo = (PATMARP_FLOW_INFO)ClientCfInfoContext;

	AADEBUGP(AAD_INFO, ("RemCfInfo: pFlowInfo x%x, VC x%x, SendBW %d, SendPktSz %d\n",
				pFlowInfo,
				pFlowInfo->VcContext,
				pFlowInfo->FlowSpec.SendAvgBandwidth,
				pFlowInfo->FlowSpec.SendMaxSize));

	GpcStatus = GPC_STATUS_SUCCESS;

	do
	{
		pVc = (PATMARP_VC) InterlockedExchangePointer(
								&(pFlowInfo->VcContext),
								NULL
								);

		if (pVc == NULL_PATMARP_VC)
		{
			//
			//  This flow isn't associated with a VC.
			//
			break;
		}


		//
		//  Unlink the flow from the VC.
		//

		AA_ACQUIRE_VC_LOCK(pVc);

		AA_ASSERT(pVc->FlowHandle == (PVOID)pFlowInfo);

		pVc->FlowHandle = NULL;
		rc = AtmArpDereferenceVc(pVc);	// GPC Unlink flow info (modify)

		if (rc != 0)
		{
			AA_SET_FLAG(pVc->Flags,
						AA_VC_GPC_MASK,
						AA_VC_GPC_IS_UNLINKED_FROM_FLOW);

			//
			//  Age out this VC if it isn't aging out yet.
			//
			if (!AA_IS_TIMER_ACTIVE(&(pVc->Timer)))
			{
				AtmArpStartTimer(
						pVc->pInterface,
						&(pVc->Timer),
						AtmArpVcAgingTimeout,
						1,			// Age out in 1 second
						(PVOID)pVc
						);

				AtmArpReferenceVc(pVc);	// GPC Flow remove decay timer ref
			}

			AA_RELEASE_VC_LOCK(pVc);
		}
		//
		//  else the VC is gone.
		//

		break;
	}
	while (FALSE);


	//
	//  Unlink this flow from the global list.
	//

	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	if (pFlowInfo->pNextFlow != NULL)
	{
		pFlowInfo->pNextFlow->pPrevFlow = pFlowInfo->pPrevFlow;
	}

	if (pFlowInfo->pPrevFlow != NULL)
	{
		pFlowInfo->pPrevFlow->pNextFlow = pFlowInfo->pNextFlow;
	}
	else
	{
		pAtmArpGlobalInfo->pFlowInfoList = pFlowInfo->pNextFlow;
	}

	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Delete this flow info structure.
	//
	AA_FREE_MEM(pFlowInfo);

	return (GpcStatus);
}

GPC_STATUS
AtmArpValidateFlowSpec(
	IN	PATMARP_INTERFACE	pInterface,	 LOCKIN LOCKOUT
	IN	FLOWSPEC *			pFS,
	IN 	BOOLEAN				fSending
)
/*++

Routine Description:

	Check the contents of a CF INFO structure that's been given to us.

Arguments:

	pFS				- The FLOWSPEC struct to check.
	pInterface		- Pointer to the interface (assumed to be locked).
	fSending		- if TRUE this is a sending flow otherwise it is a receiving
					  flow.

Return Value:

	GPC_STATUS_SUCCESS if the structure is OK, error code otherwise.

--*/
{

	/*
		Here is the validation plan for the
		fields of FLOWSPEC:
	
			Ignored fields:
				Latency
				DelayVariation
			
			If ServiceType == NO_TRAFFIC, we ignore all other fields.

			Default handling
				MinimumPolicedSize: ignored
				TokenRate: BE:line-rate; GS:invalid   CLS: invalid
				TokenBucketSize: MTU
				PeakBandwidth: line-rate
				ServiceType:BE
				MaxSduSize: MTU
			
			Valid ranges
				MinimumPolicedSize <= MTU
				0<TokenRate	<= LineRate
				0<TokenBucketSize
				0<TokenRate	<= PeakBandwidth
				ServiceType: valid type
				0<MaxSduSize <= MTU
				MaxSduSize <= TokenBucketSize
	*/


	GPC_STATUS Status = GPC_STATUS_SUCCESS;

	do
	{
		ULONG MTU      = pInterface->pAdapter->MaxPacketSize;
		UINT  LineRate = (fSending)
						? pInterface->pAdapter->LineRate.Outbound
						: pInterface->pAdapter->LineRate.Inbound;
					
		//
		// Check service types.
		//
		switch(pFS->ServiceType)
		{

		case SERVICETYPE_GUARANTEED: 		// fall through
		case SERVICETYPE_CONTROLLEDLOAD:
			if  (pFS->TokenRate == QOS_NOT_SPECIFIED)
			{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: Token rate U for ST G/CL. ST=0x%lx\n",
				pFS->ServiceType));
				Status = QOS_STATUS_INVALID_TOKEN_RATE;
				// Status = GPC_STATUS_INVALID_PARAMETER;
			}
			break;

		case SERVICETYPE_NOTRAFFIC:			// fall through
		case SERVICETYPE_BESTEFFORT:		// fall through
		case QOS_NOT_SPECIFIED:
			break;

		default:
			// Status = GPC_STATUS_INVALID_PARAMETER;
			Status = QOS_STATUS_INVALID_SERVICE_TYPE;
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: Unknown ST 0x%lx\n", pFS->ServiceType));
			break;
			
		}
		
		if (Status != GPC_STATUS_SUCCESS)
		{
			break;
		}

		//
		// If service type is notraffic, we ignore all other parameters...
		//
		if (pFS->ServiceType == SERVICETYPE_NOTRAFFIC)
		{
			break;
		}

		//
		// Check that non-default values fall into valid ranges...
		//
		#define EXCEEDSMAX(_value,_max) \
					((_value) != QOS_NOT_SPECIFIED && (_value) > (_max))

		if (EXCEEDSMAX(pFS->MinimumPolicedSize, MTU))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: MinPolSz(%lu)>MTU(%lu)\n",
				pFS->MinimumPolicedSize,
				MTU));
			Status = GPC_STATUS_RESOURCES;
			break;
		}

		if (EXCEEDSMAX(pFS->TokenRate, LineRate))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: TokRt(%lu)>LineRt(%lu)\n",
				pFS->TokenRate,
				LineRate));
			Status = QOS_STATUS_INVALID_TOKEN_RATE;
			// Status = GPC_STATUS_RESOURCES;
			break;
		}

		if (EXCEEDSMAX(pFS->TokenRate, pFS->PeakBandwidth))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: TokRt(%lu)>PkBw(%lu)\n",
				pFS->TokenRate,
				pFS->PeakBandwidth));
			//
			// 3/15/1999 JosephJ: According	 to EricEil, in this condition
			//				we should return INVALID_PEAK_RATE, not 
			//				INVALID_TOKEN_RATE
			//
			Status = QOS_STATUS_INVALID_PEAK_RATE;
			break;
		}

		if (EXCEEDSMAX(pFS->MaxSduSize, MTU))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: MaxSduSz(%lu)>MTU(%lu)\n",
				pFS->MaxSduSize,
				MTU));
			Status = GPC_STATUS_RESOURCES;
			break;
		}

		if (EXCEEDSMAX(pFS->MaxSduSize, pFS->TokenBucketSize))
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: MaxSduSz(%lu)>TokBktSz(%lu)\n",
				pFS->MaxSduSize,
				pFS->TokenBucketSize));
			Status = GPC_STATUS_INVALID_PARAMETER;
			break;
		}

		if (
				pFS->TokenRate==0
			||  pFS->TokenBucketSize==0
			||  pFS->MaxSduSize==0)
		{
			AADEBUGP(AAD_INFO,
				("GpcValidateCfInfo: FAIL: !TokRt || !TokBktSz || !MaxSduSz\n"));
			if (pFS->TokenRate == 0)
			{
				Status = QOS_STATUS_INVALID_TOKEN_RATE;
			}
			else
			{
				Status = GPC_STATUS_INVALID_PARAMETER;
			}
			break;
		}

	} while (FALSE);

	return Status;
}


GPC_STATUS
AtmArpGpcValidateCfInfo(
	IN	PVOID						pCfInfo,
	IN	ULONG						CfInfoSize
)
/*++

Routine Description:

	Check the contents of a CF INFO structure that's been given to us.

Arguments:

	pCfInfo				- Pointer to the newly created INFO block
	CfInfoSize			- Length of the above

Return Value:

	GPC_STATUS_SUCCESS if the structure is OK, error code otherwise.

--*/
{
	GPC_STATUS			GpcStatus;
	PCF_INFO_QOS		pQosInfo;
	PATMARP_INTERFACE	pInterface;

	pQosInfo = (PCF_INFO_QOS)pCfInfo;
	GpcStatus = GPC_STATUS_SUCCESS;

	do
	{
		if(CfInfoSize < (FIELD_OFFSET(CF_INFO_QOS, GenFlow) +
		                 FIELD_OFFSET(TC_GEN_FLOW, TcObjects)))
		{
			GpcStatus = GPC_STATUS_INVALID_PARAMETER;
			break;
		}


#ifdef ATMARP_WMI

		//
		// Check that both recv and send servicetypes are not both notraffic
		//
		if (   pQosInfo->GenFlow.ReceivingFlowspec.ServiceType==SERVICETYPE_NOTRAFFIC
		    && pQosInfo->GenFlow.SendingFlowspec.ServiceType==SERVICETYPE_NOTRAFFIC)
		{
			GpcStatus = GPC_STATUS_INVALID_PARAMETER;
			break;
		}

		//
		//  Check if this notification is actually for us.
		//
		pInterface = AtmArpWmiGetIfByName(
						(PWSTR)&pQosInfo->InstanceName[0],
						pQosInfo->InstanceNameLength
						);

		if (pInterface != NULL_PATMARP_INTERFACE)
		{
			AA_ACQUIRE_IF_LOCK(pInterface);

			if (pInterface->AdminState != IF_STATUS_UP)
			{
				//
				// Oh oh -- interface is not up and about....
				//
				AtmArpDereferenceInterface(pInterface); // WMI: Tmp ref.
				AA_RELEASE_IF_LOCK(pInterface);
				pInterface = NULL;
			}
		}

		if (pInterface == NULL_PATMARP_INTERFACE)
		{
			AADEBUGP(AAD_WARNING,
				("GpcValidateCfInfo: pQosInfo 0x%x, unknown instance name %ws\n",
					pQosInfo, pQosInfo->InstanceName));

			GpcStatus = GPC_STATUS_IGNORED;
			break;
		}

		//
		// We have the interface lock -- don't break without releasing it first!
		//

		GpcStatus = AtmArpValidateFlowSpec(
						pInterface,
						&(pQosInfo->GenFlow.ReceivingFlowspec),
						FALSE
						);

		if (GpcStatus == GPC_STATUS_SUCCESS)
		{
			GpcStatus = AtmArpValidateFlowSpec(
						pInterface,
						&(pQosInfo->GenFlow.SendingFlowspec),
						TRUE
						);
		}

		AtmArpDereferenceInterface(pInterface); // WMI: Tmp ref.
		AA_RELEASE_IF_LOCK(pInterface);

#endif // ATMARP_WMI

		break;
	}
	while (FALSE);

	return (GpcStatus);
}


EXTERN
GPC_STATUS
AtmArpGpcGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       	ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING        InstanceName
)
/*++

Routine Description:

    
    The GPC can issue this call to get from us the WMI manageable
    InstanceName which Ndis created for the flow associated with
    the CfInfo struct.

    We guarantee to keep the string buffer around until the CfInfo
    structure is removed.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   Client's CfInfo context
    InstanceName -          We return a pointer to our string.

Return Value:

    Status

--*/

{
	PATMARP_FLOW_INFO		pFlowInfo = (PATMARP_FLOW_INFO)ClientCfInfoContext;
	InstanceName->Buffer = pFlowInfo->FlowInstanceName;
	InstanceName->Length = sizeof(pFlowInfo->FlowInstanceName);
	InstanceName->MaximumLength = sizeof(pFlowInfo->FlowInstanceName);

	return NDIS_STATUS_SUCCESS;

}

#endif // GPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\arp.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    arp.h

Abstract:

    This file contains the definitions and data declarations for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

//
// Definition for an IP address
//
typedef ULONG		IPADDR;     // An IP address

//
// OpCodes - Define these in network byte order
//
#define	ATMARP_Request			0x0100
#define	ATMARP_Reply			0x0200
#define	InATMARP_Request		0x0800
#define	InATMARP_Reply			0x0900
#define	ATMARP_Nak				0x0A00

#define	ATM_HWTYPE				0x1300			// ATM Forum assigned - in network byte order
#define	IP_PROTOCOL_TYPE		0x0008			// In network byte order
#define	IP_ADDR_LEN				sizeof(IPADDR)

//
// the offset into the 20 byte ATM address where the ESI starts
//
#define	ESI_START_OFFSET		13

//
// Structure of a Q2931 ARP header.
//
//
// Encoding of the TL, ATM Number and ATM Sub-address encoding
//
typedef UCHAR					ATM_ADDR_TL;

#define	TL_LEN(_x_)				((_x_) & 0x3F)			// Low 6 bits
														// range is from 0-ATM_ADDRESS_LENGTH
#define	TL_TYPE(_x_)			(((_x_) & 0x40) >> 6)	// Bit # 7, 0 - ATM Forum NSAP, 1 - E164
#define	TL_RESERVED(_x_)		(((_x_) & 0x80) >> 7)	// Bit # 8 - Must be 0
#define	TL(_type_, _len_)		(((UCHAR)(_type_) << 6) + (UCHAR)(_len_))

#define	ADDR_TYPE_NSAP			0
#define	ADDR_TYPE_E164			1

#if	(ADDR_TYPE_NSAP != ATM_NSAP)
#error "Atm address type mismatch"
#endif
#if (ADDR_TYPE_E164 != ATM_E164)
#error "Atm address type mismatch"
#endif

//
// the structure for the LLC/SNAP encapsulation header on the IP packets for Q2931
//
typedef struct
{
	UCHAR			LLC[3];
	UCHAR			OUI[3];
	USHORT			EtherType;
} LLC_SNAP_HDR, *PLLC_SNAP_HDR;

//
// On the wire format for Atm ARP request
//
typedef struct _ARPS_HEADER
{
	LLC_SNAP_HDR				LlcSnapHdr;			// LLC SNAP Header
	USHORT						HwType;				// Hardware address space.
	USHORT						Protocol;			// Protocol address space.
	ATM_ADDR_TL					SrcAddressTL;		// Src ATM number type & length
	ATM_ADDR_TL					SrcSubAddrTL;		// Src ATM subaddr type & length
	USHORT						Opcode;				// Opcode.
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	ATM_ADDR_TL					DstAddressTL;		// Dest ATM number type & length
	ATM_ADDR_TL					DstSubAddrTL;		// Dest ATM subaddr type & length
	UCHAR						DstProtoAddrLen;	// Dest protocol addr length

	//
	// This is followed by variable length fields and is dictated by the value of fields above.
	//
} ARPS_HEADER, *PARPS_HEADER;

//
// The following structure is used ONLY to allocate space for the packet.
// It represents the maximum space needed for an arp request/reply.
//
typedef struct
{
	UCHAR						SrcHwAddr[ATM_ADDRESS_LENGTH];	 // Source HW address.
	UCHAR						SrcHwSubAddr[ATM_ADDRESS_LENGTH];// Source HW sub-address.
	IPADDR						SrcProtoAddr;					 // Source protocol address.
	UCHAR						DstHwAddr[ATM_ADDRESS_LENGTH];	 // Destination HW address.
	UCHAR						DstHwSubAddr[ATM_ADDRESS_LENGTH];// Destination HW sub-address.
	IPADDR						DstProtoAddr;					 // Destination protocol address.
} ARPS_VAR_HDR, *PARPS_VAR_HDR;

//
// Get a short (16-bits) from on-the-wire format (big-endian)
// to a short in the host format (either big or little endian)
//
#define GETSHORT2SHORT(_D_, _S_)											\
		*(PUSHORT)(_D_) = ((*((PUCHAR)(_S_)+0) << 8) + (*((PUCHAR)(_S_)+1)))

//
// Copy a short (16-bits) from the host format (either big or little endian)
// to a short in the on-the-wire format (big-endian)
//
#define PUTSHORT2SHORT(_D_, _S_)											\
		*((PUCHAR)(_D_)+0) = (UCHAR)((USHORT)(_S_) >> 8),					\
		*((PUCHAR)(_D_)+1) = (UCHAR)(_S_)

//
// Get a ULONG from on-the-wire format to a ULONG in the host format
//
#define GETULONG2ULONG(DstPtr, SrcPtr)   \
		*(PULONG)(DstPtr) = ((*((PUCHAR)(SrcPtr)+0) << 24) +				\
							  (*((PUCHAR)(SrcPtr)+1) << 16) +				\
							  (*((PUCHAR)(SrcPtr)+2) << 8)  +				\
							  (*((PUCHAR)(SrcPtr)+3)	))

//
// Put a ULONG from the host format to a ULONG to on-the-wire format
//
#define PUTULONG2ULONG(DstPtr, Src)											\
		*((PUCHAR)(DstPtr)+0) = (UCHAR) ((ULONG)(Src) >> 24),				\
		*((PUCHAR)(DstPtr)+1) = (UCHAR) ((ULONG)(Src) >> 16),				\
		*((PUCHAR)(DstPtr)+2) = (UCHAR) ((ULONG)(Src) >>  8),				\
		*((PUCHAR)(DstPtr)+3) = (UCHAR) (Src)


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarpc\utils.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	utils.c		- Utility functions.

Abstract:

   Internal utility functions for ATMARP:

	- Allocation and deallocation of various structures
	- Timer management
	- Buffer/Packet management
	- Linking/unlinking ATMARP structures
	- Copy support functions


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     07-15-96    Created

Notes:

--*/


#include <precomp.h>

#define _FILENUMBER 'LITU'

//
// AtmArpValidateTimerList and AtmArpValidateTimer are used in the checked
// build to validate the state of a timerlist and timer, respectively.
// They are not defined and used in the free build.
//

#if  DBG
void
AtmArpValidateTimerList(
	PATMARP_TIMER_LIST		pTimerList
	);

void
AtmArpValidateTimer(
	PATMARP_TIMER_LIST		pTimerList,
	PATMARP_TIMER			pTimer
	);

//
// AtmArpValidateTimerList is overkill for general use (even default
// free build) -- because it goes through the entire timer list --
// so disable it by default
//
#if 0
#define AA_VALIDATE_TIMER_LIST(_ptl) 	AtmArpValidateTimerList(_ptl)
#else
#define AA_VALIDATE_TIMER_LIST(_ptl) 	((void) 0)
#endif

#define AA_VALIDATE_TIMER(_ptl,_pt) 	AtmArpValidateTimer(_ptl,_pt)

#else // !DBG

#define AA_VALIDATE_TIMER_LIST(_ptl) 	((void) 0)
#define AA_VALIDATE_TIMER(_ptl,_pt) 	((void) 0)

#endif // !DBG




VOID
AtmArpSetMemory(
	IN	PUCHAR						pStart,
	IN	UCHAR						Value,
	IN	ULONG						NumberOfBytes
)
/*++

Routine Description:

	Set "NumberOfBytes" bytes starting from "pStart" to "Value".

Arguments:

	pStart			- where to start filling.
	Value			- the value to put everywhere
	NumberOfBytes	- how many bytes to fill in

Return Value:

	None

--*/
{
	while (NumberOfBytes--)
	{
		*pStart++ = Value;
	}
}



ULONG
AtmArpMemCmp(
	IN	PUCHAR						pString1,
	IN	PUCHAR						pString2,
	IN	ULONG						Length
)
/*++

Routine Description:

	Compare two byte strings.

Arguments:

	pString1		- Start of first string
	pString2		- Start of second string
	Length			- Length to compare

Return Value:

	0 if both are equal, -1 if string 1 is "smaller", +1 if string 1 is "larger".

--*/
{
	while (Length--)
	{
		if (*pString1 != *pString2)
		{
			return ((*pString1 > *pString2)? (ULONG)1 : (ULONG)-1);
		}
		pString1++;
		pString2++;
	}

	return (0);
}



LONG
AtmArpRandomNumber(
	VOID
)
/*++

Routine Description:

	Generate a positive pseudo-random number; simple linear congruential
	algorithm. ANSI C "rand()" function. Courtesy JameelH.

Arguments:

	None

Return Value:

	a random number.

--*/
{
	LARGE_INTEGER		Li;
	static LONG			seed = 0;

	if (seed == 0)
	{
		NdisGetCurrentSystemTime(&Li);
        seed = Li.LowPart;
	}

	seed *= (0x41C64E6D + 0x3039);
	return (seed & 0x7FFFFFFF);
}




VOID
AtmArpCheckIfTimerIsInActiveList(
	IN	PATMARP_TIMER				pTimerToCheck,
	IN	PATMARP_INTERFACE			pInterface,
	IN	PVOID						pStruct,
	IN	PCHAR						pStructName
	)
/*
	Instrumentation to catch a bug that causes the timer list to
	contain a pointer to an element that's been freed.
*/
{
	PATMARP_TIMER_LIST	pTimerList;
	PATMARP_TIMER		pTimer;
	ULONG				i, j;

	do
	{
		if (pInterface == NULL)
		{
			break;
		}

		if (pTimerToCheck->State == ATMARP_TIMER_STATE_RUNNING ||
			pTimerToCheck->State == ATMARP_TIMER_STATE_EXPIRING)
		{
			DbgPrint("ATMARPC: %s at %x contains timer %x still active on IF %x\n",
				pStructName,
				pStruct,
				pTimerToCheck,
				pInterface);

			DbgBreakPoint();
		}

		AA_STRUCT_ASSERT(pInterface, aai);

		AA_ACQUIRE_IF_TIMER_LOCK(pInterface);

		for (i = 0; i < AAT_CLASS_MAX; i++)
		{
			pTimerList = &pInterface->TimerList[i];

			for (j = 0; j < pTimerList->TimerListSize; j++)
			{
				for (pTimer = pTimerList->pTimers[j].pNextTimer;
					 pTimer != NULL_PATMARP_TIMER;
					 pTimer = pTimer->pNextTimer)
				{
					if (pTimer == pTimerToCheck)
					{
						DbgPrint("ATMARPC: %s at %x contains timer %x still active on IF %x, Head of list %x\n",
							pStructName,
							pStruct,
							pTimerToCheck,
							pInterface,
							&pTimerList->pTimers[j]);
						DbgBreakPoint();
					}
				}
			}
		}

		AA_RELEASE_IF_TIMER_LOCK(pInterface);
		break;
	}
	while (FALSE);

}



PATMARP_VC
AtmArpAllocateVc(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Allocate an ATMARP VC structure, initialize it, and return it.

Arguments:

	pInterface		- Interface for which this VC is created.

Return Value:

	Pointer to VC if allocated, NULL otherwise.

--*/
{
	PATMARP_VC			pVc;

	AA_STRUCT_ASSERT(pInterface, aai);

	AA_ALLOC_MEM(pVc, ATMARP_VC, sizeof(ATMARP_VC));

	if (pVc != NULL_PATMARP_VC)
	{
		AA_SET_MEM(pVc, 0, sizeof(ATMARP_VC));
#if DBG
		pVc->avc_sig = avc_signature;
#endif // DBG
		pVc->pInterface = pInterface;
		AA_INIT_VC_LOCK(pVc);
	}

	AADEBUGP(AAD_LOUD, ("Allocated Vc 0x%x\n", pVc));

	return (pVc);
}



VOID
AtmArpDeallocateVc(
	IN	PATMARP_VC					pVc
)
/*++

Routine Description:

	Deallocate an ATMARP VC structure. It is assumed that all references
	to this VC have gone, so there is no need to acquire a lock to the VC.

Arguments:

	pVc			- Pointer to the VC to be deallocated

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT(pVc->RefCount == 0);
	AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pVc->Timer));

	AA_CHECK_TIMER_IN_ACTIVE_LIST(&pVc->Timer, pVc->pInterface, pVc, "VC");

#if DBG
	pVc->avc_sig++;
#endif
	AA_FREE_VC_LOCK(pVc);
	AA_FREE_MEM(pVc);

	AADEBUGP(AAD_LOUD, ("Deallocated Vc 0x%x\n", pVc));

}




VOID
AtmArpReferenceVc(
	IN	PATMARP_VC					pVc
)
/*++

Routine Description:

	Add a reference to the specified ATMARP VC.
	NOTE: The caller is assumed to possess a lock for the VC.

Arguments:

	pVc			- Pointer to the VC to be referenced

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pVc, avc);

	pVc->RefCount++;

	AADEBUGP(AAD_VERY_LOUD, ("Referencing Vc 0x%x, new count %d\n",
			 pVc, pVc->RefCount));
}




ULONG
AtmArpDereferenceVc(
	IN	PATMARP_VC					pVc
)
/*++

Routine Description:

	Subtract a reference from the specified ATMARP VC. If the VC's
	reference count becomes zero, deallocate it.

	NOTE: The caller is assumed to possess a lock for the VC.
	SIDE EFFECT: See Return Value below

Arguments:

	pVc			- Pointer to the VC to be dereferenced.

Return Value:

	Is the new reference count.
	[IMPORTANT] If the VC's reference count became zero, the VC will be
	deallocated -- the VC lock is, obviously, released in this case.

--*/
{
	ULONG		rv;
	NDIS_HANDLE	NdisVcHandle;
	BOOLEAN		bVcOwnerIsAtmArp;
	NDIS_STATUS	Status;

	AA_STRUCT_ASSERT(pVc, avc);
	AA_ASSERT(pVc->RefCount > 0);

	rv = --(pVc->RefCount);
	if (rv == 0)
	{
#ifdef VC_REFS_ON_SENDS
		NdisVcHandle = pVc->NdisVcHandle;
		bVcOwnerIsAtmArp = AA_IS_FLAG_SET(pVc->Flags,
										  AA_VC_OWNER_MASK,
										  AA_VC_OWNER_IS_ATMARP);
#endif // VC_REFS_ON_SENDS

		AA_RELEASE_VC_LOCK(pVc);
		AtmArpDeallocateVc(pVc);

#ifdef VC_REFS_ON_SENDS
		if ((NdisVcHandle != NULL) &&
			(bVcOwnerIsAtmArp))
		{
			Status = NdisCoDeleteVc(NdisVcHandle);
			AA_ASSERT(Status == NDIS_STATUS_SUCCESS);
			AADEBUGP(AAD_LOUD, ("DereferenceVc 0x%x, deleted NdisVcHandle 0x%x\n",
							pVc, NdisVcHandle));
		}
#endif // VC_REFS_ON_SENDS
	}

	AADEBUGP(AAD_VERY_LOUD, ("Dereference Vc 0x%x, New RefCount %d\n", pVc, rv));

	return (rv);
}




PATMARP_ATM_ENTRY
AtmArpAllocateAtmEntry(
	IN	PATMARP_INTERFACE			pInterface,
	IN	BOOLEAN						IsMulticast
)
/*++

Routine Description:

	Allocate an ATM Entry structure, initialize it, and return it.

Arguments:

	pInterface		- Pointer to ATMARP interface on which the entry is allocated
	IsMulticast		- Is this a Multicast entry?

Return Value:

	Pointer to allocated ATM Entry structure if successful, NULL otherwise.

--*/
{
	PATMARP_ATM_ENTRY			pAtmEntry;
	ULONG						Size;

	AA_STRUCT_ASSERT(pInterface, aai);

	Size = sizeof(ATMARP_ATM_ENTRY)
#ifdef IPMCAST
			 	+ (IsMulticast? sizeof(ATMARP_IPMC_ATM_INFO): 0);
#else
				;
#endif

	AA_ALLOC_MEM(pAtmEntry, ATMARP_ATM_ENTRY, Size);
	if (pAtmEntry != NULL_PATMARP_ATM_ENTRY)
	{
		AA_SET_MEM(pAtmEntry, 0, Size);
#if DBG
		pAtmEntry->aae_sig = aae_signature;
#endif
		pAtmEntry->Flags = AA_ATM_ENTRY_IDLE;
#ifdef IPMCAST
		if (IsMulticast)
		{
			pAtmEntry->Flags |= AA_ATM_ENTRY_TYPE_NUCAST;
			pAtmEntry->pMcAtmInfo = (PATMARP_IPMC_ATM_INFO)
										((PUCHAR)pAtmEntry + sizeof(ATMARP_ATM_ENTRY));
		}
#endif // IPMCAST
		AA_INIT_AE_LOCK(pAtmEntry);
		pAtmEntry->pInterface = pInterface;

	}

	AADEBUGP(AAD_INFO, ("Allocated ATM Entry: IF 0x%x, Entry 0x%x\n",
				pInterface, pAtmEntry));

	return (pAtmEntry);
}



VOID
AtmArpDeallocateAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Free an ATMARP ATM Entry structure. It is assumed that all references
	to the structure have gone. We don't need any locks here.

Arguments:

	pAtmEntry		- Pointer to ATMARP ATM Entry to be freed.

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pAtmEntry, aae);
	AA_ASSERT(pAtmEntry->RefCount == 0);
	AA_ASSERT(pAtmEntry->pVcList == NULL_PATMARP_VC);
	AA_ASSERT(!AA_AE_IS_ALIVE(pAtmEntry));


#if DBG
	pAtmEntry->aae_sig++;
#endif

	AA_FREE_AE_LOCK(pAtmEntry);
	AA_FREE_MEM(pAtmEntry);

	AADEBUGP(AAD_INFO, ("Deallocated ATM Entry: 0x%x\n", pAtmEntry));
}




VOID
AtmArpReferenceAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Add a reference to the specified ATMARP Entry.
	NOTE: The caller is assumed to possess a lock for the Entry.

Arguments:

	pAtmEntry			- Pointer to the Entry to be referenced

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pAtmEntry, aae);

	pAtmEntry->RefCount++;

	AADEBUGP(AAD_VERY_LOUD, ("Referencing AtmEntry 0x%x, new count %d\n",
			 pAtmEntry, pAtmEntry->RefCount));
}




ULONG
AtmArpDereferenceAtmEntry(
	IN	PATMARP_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Subtract a reference from the specified ATM Entry. If the Entry's
	reference count becomes zero, deallocate it.

	NOTE: The caller is assumed to possess a lock for the Entry.
	SIDE EFFECT: See Return Value below

Arguments:

	pAtmEntry			- Pointer to the Entry to be dereferenced.

Return Value:

	Is the new reference count.
	[IMPORTANT] If the Entry's reference count became zero, the Entry will be
	deallocated -- the Entry lock is, obviously, released in this case.

--*/
{
	ULONG					rc;
	PATMARP_INTERFACE		pInterface;

	AA_STRUCT_ASSERT(pAtmEntry, aae);
	AA_ASSERT(pAtmEntry->RefCount > 0);

	rc = --(pAtmEntry->RefCount);
	if (rc == 0)
	{
		PATMARP_ATM_ENTRY *	ppAtmEntry;

		//
		// We are most likely going to delete this entry...
		//
		// We must observe the protocol of 1st locking the list lock then
		// the pAtmEntry's lock, so this requires us to do the
		// release/lock/lock sequence below.
		//
		// Temporarly addref it again, to make sure that when we
		// release the lock below someone else doesn't get confused.
		//
		pAtmEntry->RefCount++;

		pInterface = pAtmEntry->pInterface;
		AA_STRUCT_ASSERT(pInterface, aai);
		AA_RELEASE_AE_LOCK(pAtmEntry);

		//
		// No locks held at this time!
		//

		//
		// Acquire locks in the correct order...
		//
		AA_ACQUIRE_IF_ATM_LIST_LOCK(pInterface);
		AA_ACQUIRE_AE_LOCK(pAtmEntry);

		AA_ASSERT(pAtmEntry->RefCount > 0);
		rc = --(pAtmEntry->RefCount);

		//
		// We can't assume that the ref count is still zero -- in principle
		// someone may have addrefd this pAtmEntry while both locks
		// were released above...
		//
		if (rc == 0)
		{
			//
			//  Unlink this entry from the Interface's list of ATM Entries.
			//

			ppAtmEntry = &(pInterface->pAtmEntryList);
			while (*ppAtmEntry != pAtmEntry)
			{
				AA_ASSERT(*ppAtmEntry != NULL_PATMARP_ATM_ENTRY);
				ppAtmEntry = &((*ppAtmEntry)->pNext);
			}
	
			*ppAtmEntry = pAtmEntry->pNext;

			//
			// Set state back to idle -- AtmArpDeallocate checks this...
			//
			AA_SET_FLAG(
				pAtmEntry->Flags,
				AA_ATM_ENTRY_STATE_MASK,
				AA_ATM_ENTRY_IDLE
				);
		}
		AA_RELEASE_AE_LOCK(pAtmEntry);
		AA_RELEASE_IF_ATM_LIST_LOCK(pInterface);

		if (rc == 0)
		{
			AtmArpDeallocateAtmEntry(pAtmEntry);
		}
		else
		{
			//
			// Caller expects to still hold the lock on pAtmEntry!
			// if we return nonzero rc ...
			// We can't simply re-acquire the lock because the caller expects
			// the that lock was never released.
			// So, since the ref count had gone to zero, as far as the caller
			// is concerned this structure has gone away and so we lie
			// and return 0 here...
			//
			rc = 0;
		}
	}

	AADEBUGP(AAD_VERY_LOUD,
		 ("Dereference AtmEntry 0x%x, New RefCount %d\n", pAtmEntry, rc));

	return (rc);
}



PATMARP_IP_ENTRY
AtmArpAllocateIPEntry(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Allocate an ATMARP IP Entry structure, initialize it, and
	return it.

Arguments:

	pInterface		- Pointer to ATMARP Interface on which this IP
					  Entry is allocated.

Return Value:

	Pointer to allocated IP Entry structure if successful,
	NULL otherwise.

--*/
{
	PATMARP_IP_ENTRY		pIpEntry;

	AA_ALLOC_MEM(pIpEntry, ATMARP_IP_ENTRY, sizeof(ATMARP_IP_ENTRY));

	if (pIpEntry != NULL_PATMARP_IP_ENTRY)
	{
		AA_SET_MEM(pIpEntry, 0, sizeof(ATMARP_IP_ENTRY));
#if DBG
		pIpEntry->aip_sig = aip_signature;
#endif // DBG
		pIpEntry->pInterface = pInterface;
		pIpEntry->Flags = AA_IP_ENTRY_IDLE;
#ifdef IPMCAST
		pIpEntry->NextMultiSeq = AA_MARS_INITIAL_Y;	// Init on allocation
#endif
		AA_INIT_IE_LOCK(pIpEntry);
	}

	AADEBUGP(AAD_VERY_LOUD, ("Allocated IP Entry 0x%x\n", pIpEntry));
	return (pIpEntry);
}




VOID
AtmArpDeallocateIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Deallocate an ATMARP IP Entry. It is assumed that all references
	to this IP Entry have gone, so there is no need to acquire its
	lock.

Arguments:

	pIpEntry			- Pointer to the IP Entry to be deallocated.

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pIpEntry, aip);
	AA_ASSERT(pIpEntry->RefCount == 0);
	AA_ASSERT(!AA_IE_IS_ALIVE(pIpEntry));
	AA_ASSERT(!AA_IS_TIMER_ACTIVE(&pIpEntry->Timer));

	AA_CHECK_TIMER_IN_ACTIVE_LIST(&pIpEntry->Timer, pIpEntry->pInterface, pIpEntry, "IP Entry");

#if DBG
	pIpEntry->aip_sig = ~(pIpEntry->aip_sig);
#endif // DBG

	AA_FREE_IE_LOCK(pIpEntry);
	AA_FREE_MEM(pIpEntry);

	AADEBUGP(AAD_LOUD, ("Deallocated IP Entry 0x%x\n", pIpEntry));

}




VOID
AtmArpReferenceIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Add a reference to an ATMARP IP Entry.
	NOTE: The caller is assumed to possess a lock for the IP Entry.

Arguments:

	pIpEntry			- Pointer to an ATMARP IP Entry.

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pIpEntry, aip);

	pIpEntry->RefCount++;

	AADEBUGP(AAD_VERY_LOUD, ("Referenced IP Entry 0x%x, new count %d\n",
			pIpEntry, pIpEntry->RefCount));
}



ULONG
AtmArpDereferenceIPEntry(
	IN	PATMARP_IP_ENTRY			pIpEntry
)
/*++

Routine Description:

	Subtract a reference from an ATMARP IP Entry. If the reference
	count becomes zero, deallocate it.
	NOTE: It is assumed that the caller holds a lock to the IP Entry.
	See SIDE EFFECT below.

Arguments:

	pIpEntry			- Pointer to ATMARP IP Entry

Return Value:

	The resulting reference count. If this is zero, then there are two
	SIDE EFFECTS: (1) the IP Entry lock is released (2) the structure
	is freed.

--*/
{
	ULONG		rc;

	AA_STRUCT_ASSERT(pIpEntry, aip);

	rc = --(pIpEntry->RefCount);

	if (rc == 0)
	{
		AA_RELEASE_IE_LOCK(pIpEntry);
		AtmArpDeallocateIPEntry(pIpEntry);
	}

	AADEBUGP(AAD_VERY_LOUD, ("Dereference IP Entry 0x%x: new count %d\n",
			pIpEntry, rc));

	return (rc);
}




PATMARP_INTERFACE
AtmArpAllocateInterface(
	IN	PATMARP_ADAPTER				pAdapter
)
/*++

Routine Description:

	Allocate an ATMARP interface structure, initialize it, link it to
	the given adapter structure, and return it.

Arguments:

	None.

Return Value:

	Pointer to ATMARP interface structure, if successful, else NULL.

--*/
{
	PATMARP_INTERFACE		pInterface;
	PATMARP_IP_ENTRY *		pArpTable;
	PATMARP_TIMER_LIST		pTimerList;
	NDIS_STATUS				Status;
	PCO_SAP					pIfSap;
	ULONG					SapSize;
	PWSTR					pIPConfigBuffer;
	USHORT					ConfigBufferSize;
	INT						i;

	//
	//  Initialize
	//
	Status = NDIS_STATUS_SUCCESS;
	pInterface = NULL_PATMARP_INTERFACE;
	pArpTable = (PATMARP_IP_ENTRY *)NULL;
	pIfSap = (PCO_SAP)NULL;
	pIPConfigBuffer = (PWSTR)NULL;

	SapSize = sizeof(CO_SAP)+sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);
	ConfigBufferSize = MAX_IP_CONFIG_STRING_LEN * sizeof(WCHAR);

	do
	{
		//
		//  Allocate everything.
		//
		AA_ALLOC_MEM(pInterface, ATMARP_INTERFACE, sizeof(ATMARP_INTERFACE));
		AA_ALLOC_MEM(pArpTable, PATMARP_IP_ENTRY, ATMARP_TABLE_SIZE*sizeof(PATMARP_IP_ENTRY));
		AA_ALLOC_MEM(pIfSap, CO_SAP, SapSize);

		if ((pInterface == NULL_PATMARP_INTERFACE) ||
			(pArpTable == (PATMARP_IP_ENTRY *)NULL) ||
			(pIfSap == (PCO_SAP)NULL))
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Got (almost) everything allocated. Initialize the main IF structure
		//  first. IMPORTANT: Keep this SET_MEM right here! Otherwise, we will
		//  trash the timer list allocation coming right up.
		//
		AA_SET_MEM(pInterface, 0, sizeof(ATMARP_INTERFACE));

		//
		// Set up the Buffer pool quadword-aligned slist pointers.
		//
		{
			for (i=0;i<AA_HEADER_TYPE_MAX;i++)
			{
				//
				// Verify that HeaderBufList is 8-byte aligned...
				// (we fully expect it to be because HeaderBufList is of type
				// SLIST_HEADER which has longlong alignment) -- so that
				// if the INTERFACE structure in which it is embedded in is
				// 8-byte aligned, so will  HeaderBufList...).
				//
				ASSERT((((ULONG_PTR)&(pInterface->HeaderPool[i].HeaderBufList))
						& 0x7) == 0);

				//
				// Spec says you gotta init it...
				//
				AA_INIT_SLIST(&(pInterface->HeaderPool[i].HeaderBufList));
			}
		}

		//
		//  Allocate timer structures
		//
		for (i = 0; i < AAT_CLASS_MAX; i++)
		{
			pTimerList = &(pInterface->TimerList[i]);
#if DBG
			pTimerList->atl_sig = atl_signature;
#endif // DBG
			AA_ALLOC_MEM(
					pTimerList->pTimers,
					ATMARP_TIMER, 
					sizeof(ATMARP_TIMER) * AtmArpTimerListSize[i]
					);
			if (pTimerList->pTimers == NULL_PATMARP_TIMER)
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}
		
		//
		//  Continue initializing the IF structure.
		//
#if DBG
		//
		//  Signatures, for debugging.
		//
		pInterface->aai_sig =  aai_signature;
		pInterface->aaim_sig = aaim_signature;
		pInterface->aaia_sig = aaia_signature;
		pInterface->aait_sig =  aait_signature;
		pInterface->aaio_sig = aaio_signature;
		pInterface->aaic_sig = aaic_signature;

		pInterface->SapList.aas_sig = aas_signature;
#if ATMARP_WMI
		pInterface->aaiw_sig = aaiw_signature;
#endif
#endif // DBG


		//
		//  Initialize state fields.
		//
		pInterface->AdminState = IF_STATUS_DOWN;
		pInterface->State = IF_STATUS_DOWN;
		pInterface->LastChangeTime = GetTimeTicks();
		pInterface->ReconfigState = RECONFIG_NOT_IN_PROGRESS;

		//
		//  Initialize IP interface fields.
		//
		pInterface->BroadcastMask = 0;
		pInterface->BroadcastAddress = IP_LOCAL_BCST;
#ifndef OLD_ENTITY_LIST
		pInterface->ATInstance = INVALID_ENTITY_INSTANCE;
		pInterface->IFInstance = INVALID_ENTITY_INSTANCE;
#endif // OLD_ENTITY_LIST

		//
		//  Initialize spinlocks.
		//
		AA_INIT_IF_LOCK(pInterface);
		AA_INIT_IF_TABLE_LOCK(pInterface);
		AA_INIT_IF_ATM_LIST_LOCK(pInterface);
		AA_INIT_IF_TIMER_LOCK(pInterface);
		AA_INIT_BLOCK_STRUCT(&(pInterface->Block));
		NdisAllocateSpinLock(&(pInterface->BufferLock));

		//
		// Initialize list and table status
		//
		pInterface->AtmEntryListUp 	= TRUE;
		pInterface->ArpTableUp 		= TRUE;

		//
		//  Initialize timer wheels.
		//
		for (i = 0; i < AAT_CLASS_MAX; i++)
		{
			pTimerList = &(pInterface->TimerList[i]);
			AA_SET_MEM(
				pTimerList->pTimers,
				0,
				sizeof(ATMARP_TIMER) * AtmArpTimerListSize[i]
				);
			pTimerList->MaxTimer = AtmArpMaxTimerValue[i];
			pTimerList->TimerPeriod = AtmArpTimerPeriod[i];
			pTimerList->ListContext = (PVOID)pInterface;
			pTimerList->TimerListSize = AtmArpTimerListSize[i];

			AA_INIT_SYSTEM_TIMER(
						&(pTimerList->NdisTimer),
						AtmArpTickHandler,
						(PVOID)pTimerList
						);
		}


		//
		//  Initialize all sub-components.
		//
		AA_SET_MEM(pArpTable, 0, ATMARP_TABLE_SIZE*sizeof(PATMARP_IP_ENTRY));
		AA_SET_MEM(pIfSap, 0, SapSize);

		//
		//  Link all sub-components to the Interface structure.
		//
		pInterface->pArpTable = pArpTable;
		pInterface->SapList.pInfo = pIfSap;

		//
		//  Link the Interface to the Adapter.
		//
		pInterface->pAdapter = pAdapter;
		pInterface->pNextInterface = pAdapter->pInterfaceList;
		pAdapter->pInterfaceList = pInterface;

		//
		//  Cache the adapter handle.
		//
		pInterface->NdisAdapterHandle = pAdapter->NdisAdapterHandle;


		Status = NDIS_STATUS_SUCCESS;
		break;
	}
	while (FALSE);


	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  Failed to allocate atleast one component. Free the other(s).
		//
		if (pInterface != NULL_PATMARP_INTERFACE)
		{
			for (i = 0; i < AAT_CLASS_MAX; i++)
			{
				pTimerList = &(pInterface->TimerList[i]);
	
				if (pTimerList->pTimers != NULL_PATMARP_TIMER)
				{
					AA_FREE_MEM(pTimerList->pTimers);
					pTimerList->pTimers = NULL_PATMARP_TIMER;
				}
			}
	
			AA_FREE_MEM(pInterface);
			pInterface = NULL_PATMARP_INTERFACE;	// return value
		}

		if (pArpTable != (PATMARP_IP_ENTRY *)NULL)
		{
			AA_FREE_MEM(pArpTable);
		}

		if (pIfSap != (PCO_SAP)NULL)
		{
			AA_FREE_MEM(pIfSap);
		}
	}

	AADEBUGP(AAD_VERY_LOUD, ("Allocated ATMARP Interface 0x%x\n", pInterface));

	return (pInterface);

}




VOID
AtmArpDeallocateInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Deallocate an ATMARP Interface structure. It is assumed that all
	references to this structure have gone, so it is not necessary
	to acquire a lock to it.

	Also delink this from the adapter structure it's linked to.

Arguments:

	pInterface		- Pointer to Interface structure to be deallocated.

Return Value:

	None

--*/
{
	PATMARP_INTERFACE	*	ppInterface;
	PATMARP_ADAPTER			pAdapter;
	PATMARP_SAP				pAtmArpSap;
	PIP_ADDRESS_ENTRY		pIpEntry;
	PATMARP_SERVER_ENTRY	pServerEntry;
	PPROXY_ARP_ENTRY		pProxyEntry;
	PATMARP_ATM_ENTRY		pAtmEntry;
	PATMARP_VC				pVc;
	INT						i;

	PVOID					pNext;		// Catch-all for all list traversals

	AA_STRUCT_ASSERT(pInterface, aai);
	AA_ASSERT(pInterface->RefCount == 0);

	AADEBUGP(AAD_INFO, ("Deallocate Interface 0x%x\n", pInterface));

#if DBG
	pInterface->aai_sig =  ~(pInterface->aai_sig);
#endif // DBG

	//
	//  Unlink from Adapter structure
	//
	AA_ACQUIRE_GLOBAL_LOCK(pAtmArpGlobalInfo);
	pAdapter = pInterface->pAdapter;
	if (pAdapter != NULL_PATMARP_ADAPTER)
	{
		ppInterface = &(pAdapter->pInterfaceList);
		while (*ppInterface != NULL_PATMARP_INTERFACE)
		{
			if (*ppInterface == pInterface)
			{
				*ppInterface = pInterface->pNextInterface;
				break;
			}
			else
			{
				ppInterface = &((*ppInterface)->pNextInterface);
			}
		}
	}
	AA_RELEASE_GLOBAL_LOCK(pAtmArpGlobalInfo);

	//
	//  Free all subcomponents
	//

	//
	//  ARP Table
	//
	if (pInterface->pArpTable != (PATMARP_IP_ENTRY *)NULL)
	{
		AA_FREE_MEM(pInterface->pArpTable);
		pInterface->pArpTable = (PATMARP_IP_ENTRY *)NULL;
	}

	//
	//  Local SAP list
	//
	for (pAtmArpSap = pInterface->SapList.pNextSap;
		 pAtmArpSap != NULL_PATMARP_SAP;
		 pAtmArpSap = (PATMARP_SAP)pNext)
	{
		pNext = (PVOID)(pAtmArpSap->pNextSap);
		if (pAtmArpSap->pInfo != (PCO_SAP)NULL)
		{
			AA_FREE_MEM(pAtmArpSap->pInfo);
		}
		AA_FREE_MEM(pAtmArpSap);
	}
	if (pInterface->SapList.pInfo != (PCO_SAP)NULL)
	{
		AA_FREE_MEM(pInterface->SapList.pInfo);
	}
	pInterface->SapList.pNextSap = NULL_PATMARP_SAP;


	//
	//  List of local IP addresses
	//
	for (pIpEntry = pInterface->LocalIPAddress.pNext;
		 pIpEntry != (PIP_ADDRESS_ENTRY)NULL;
		 pIpEntry = (PIP_ADDRESS_ENTRY)pNext)
	{
		pNext = (PVOID)pIpEntry->pNext;
		AA_FREE_MEM(pIpEntry);
	}


	//
	//  List of proxy ARP addresses
	//
	for (pProxyEntry = pInterface->pProxyList;
		 pProxyEntry != (PPROXY_ARP_ENTRY)NULL;
		 pProxyEntry = (PPROXY_ARP_ENTRY)pNext)
	{
		pNext = (PVOID)pProxyEntry->pNext;
		AA_FREE_MEM(pProxyEntry);
	}
	pInterface->pProxyList = (PPROXY_ARP_ENTRY)NULL;

	//
	//  List of ARP Server addresses
	//
	for (pServerEntry = pInterface->ArpServerList.pList;
		 pServerEntry != NULL_PATMARP_SERVER_ENTRY;
		 pServerEntry = (PATMARP_SERVER_ENTRY)pNext)
	{
		pNext = (PVOID)pServerEntry->pNext;
		AA_FREE_MEM(pServerEntry);
	}
	pInterface->ArpServerList.pList = NULL_PATMARP_SERVER_ENTRY;

#ifdef IPMCAST
	//
	//  List of MARS Server addresses
	//
	for (pServerEntry = pInterface->MARSList.pList;
		 pServerEntry != NULL_PATMARP_SERVER_ENTRY;
		 pServerEntry = (PATMARP_SERVER_ENTRY)pNext)
	{
		pNext = (PVOID)pServerEntry->pNext;
		AA_FREE_MEM(pServerEntry);
	}
	pInterface->MARSList.pList = NULL_PATMARP_SERVER_ENTRY;
#endif // IPMCAST

	//
	//  ARP Table
	//
	if (pInterface->pArpTable != (PATMARP_IP_ENTRY *)NULL)
	{
		AA_FREE_MEM(pInterface->pArpTable);
		pInterface->pArpTable = (PATMARP_IP_ENTRY *)NULL;
	}

	//
	//  ATM Entry List
	//
	for (pAtmEntry = pInterface->pAtmEntryList;
		 pAtmEntry != NULL_PATMARP_ATM_ENTRY;
		 pAtmEntry = (PATMARP_ATM_ENTRY)pNext)
	{
		pNext = (PVOID)pAtmEntry->pNext;
		AA_FREE_MEM(pAtmEntry);
	}
	pInterface->pAtmEntryList = NULL_PATMARP_ATM_ENTRY;

	//
	//  Unresolved VC list
	//
	for (pVc = pInterface->pUnresolvedVcs;
		 pVc != NULL_PATMARP_VC;
		 pVc = (PATMARP_VC)pNext)
	{
		pNext = (PVOID)pVc->pNextVc;
		AA_FREE_MEM(pVc);
	}
	pInterface->pUnresolvedVcs = (PATMARP_VC)NULL;

	//
	//  Timers
	//
	for (i = 0; i < AAT_CLASS_MAX; i++)
	{
		PATMARP_TIMER_LIST	pTimerList = &(pInterface->TimerList[i]);

		if (pTimerList->pTimers != NULL_PATMARP_TIMER)
		{
			AA_FREE_MEM(pTimerList->pTimers);
			pTimerList->pTimers = NULL_PATMARP_TIMER;
		}
	}

	//
	//  ProtocolPacketPool
	//  ProtocolBufferPool
	//  ProtocolBufList
	//
	AtmArpDeallocateProtoBuffers(pInterface);

	//
	//  HeaderBufList
	//  pHeaderTrkList
	//
	AtmArpDeallocateHeaderBuffers(pInterface);

	//
	//  Free all Interface locks.
	//
	AA_FREE_IF_LOCK(pInterface);
	AA_FREE_IF_TABLE_LOCK(pInterface);
	AA_FREE_IF_ATM_LIST_LOCK(pInterface);
	AA_FREE_IF_TIMER_LOCK(pInterface);
	AA_FREE_BLOCK_STRUCT(&(pInterface->Block));
	NdisFreeSpinLock(&(pInterface->BufferLock));

	//
	//  Free the Interface structure now
	//
	AA_FREE_MEM(pInterface);

	//
	//  If we just freed the last Interface structure on this
	//  adapter, and an Unbind operation was in progress, complete
	//  it now.
	//
	if ((pAdapter->pInterfaceList == NULL_PATMARP_INTERFACE) &&
		(pAdapter->Flags & AA_ADAPTER_FLAGS_UNBINDING))
	{
		AtmArpCompleteUnbindAdapter(pAdapter);
	}
}




VOID
AtmArpReferenceInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Add a reference to an Interface structure.
	NOTE: The caller is assumed to possess a lock for the interface
	structure.

Arguments:

	pInterface		- Pointer to the ATMARP interface

Return Value:

	None

--*/
{
	AA_STRUCT_ASSERT(pInterface, aai);

	pInterface->RefCount++;

	AADEBUGP(AAD_VERY_LOUD, ("Reference Interface 0x%x, new count %d\n",
			pInterface, pInterface->RefCount));
}




ULONG
AtmArpDereferenceInterface(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Subtract a reference from an ATMARP Interface. If the reference
	count becomes zero, deallocate it.
	NOTE: It is assumed that the caller holds a lock to the Interface
	structure. See SIDE EFFECT below.

Arguments:

	pInterface		- Pointer to the ATMARP interface

Return Value:

	The resulting reference count. If this is zero, then there are two
	SIDE EFFECTS: (1) the Interface lock is released (2) the structure
	is freed.

--*/
{
	ULONG		rc;

	AA_STRUCT_ASSERT(pInterface, aai);
	AA_ASSERT(pInterface->RefCount > 0);

	rc = --(pInterface->RefCount);

	AADEBUGP(AAD_VERY_LOUD, ("Dereference Interface 0x%x, new count %d\n",
			pInterface, rc));

	if (rc == 0)
	{
		AA_RELEASE_IF_LOCK(pInterface);
		AtmArpDeallocateInterface(pInterface);
	}


	return (rc);
}



VOID
AtmArpReferenceJoinEntry(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry
)
/*++

Routine Description:

	Add a reference to a Join Entry.

Arguments:

	pJoinEntry		- Pointer to Join Entry

Return Value:

	None

--*/
{
	NdisInterlockedIncrement(&pJoinEntry->RefCount);
}


ULONG
AtmArpDereferenceJoinEntry(
	IN	PATMARP_IPMC_JOIN_ENTRY		pJoinEntry
)
/*++

Routine Description:

	Decrements the ref count on a Join Entry. If it goes down to zero,
	deallocates it.

Arguments:

	pJoinEntry		- Pointer to the Join Entry

Return Value:

	The final ref count

--*/
{
	ULONG		rc;

	rc = NdisInterlockedDecrement(&pJoinEntry->RefCount);

	if (rc == 0)
	{
		AA_CHECK_TIMER_IN_ACTIVE_LIST(&pJoinEntry->Timer, pJoinEntry->pInterface, pJoinEntry, "Join Entry");
		AA_FREE_MEM(pJoinEntry);
	}

	return (rc);
}


VOID
AtmArpStartTimer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PATMARP_TIMER				pTimer,
	IN	ATMARP_TIMEOUT_HANDLER		TimeoutHandler,
	IN	ULONG						SecondsToGo,
	IN	PVOID						Context
)
/*++

Routine Description:

	Start an ATMARP timer. Based on the length (SecondsToGo) of the
	timer, we decide on whether to insert it in the short duration
	timer list or in the long duration timer list in the Interface
	structure.

	NOTE: the caller is assumed to either hold a lock to the structure
	that contains the timer, or ensure that it is safe to access the
	timer structure.

Arguments:

	pInterface		- Pointer to the ATMARP Interface
	pTimer			- Pointer to ATMARP Timer structure
	TimeoutHandler	- Handler function to be called if this timer expires
	SecondsToGo		- When does this timer go off?
	Context			- To be passed to timeout handler if this timer expires

Return Value:

	None

--*/
{
	PATMARP_TIMER_LIST	pTimerList;		// List to which this timer goes
	PATMARP_TIMER		pTimerListHead; // Head of above list
	ULONG				Index;			// Into timer wheel
	ULONG				TicksToGo;
	INT					i;

	AA_STRUCT_ASSERT(pInterface, aai);


 	AADEBUGP(AAD_EXTRA_LOUD,
 	 ("StartTimer: pIf 0x%x, Secs %d, Handler 0x%x, Ctxt 0x%x, pTimer 0x%x\n",
 	 			pInterface, SecondsToGo, TimeoutHandler, Context, pTimer));


	if (AA_IS_TIMER_ACTIVE(pTimer))
	{
		AADEBUGP(AAD_ERROR,
			("Start timer: pTimer 0x%x: is active (list 0x%x, hnd 0x%x), stopping it\n",
				pTimer, pTimer->pTimerList, pTimer->TimeoutHandler));

		AtmArpStopTimer(pTimer, pInterface);
	}

	AA_ACQUIRE_IF_TIMER_LOCK(pInterface);
	AA_ASSERT(!AA_IS_TIMER_ACTIVE(pTimer));

	//
	//  Find the list to which this timer should go, and the
	//  offset (TicksToGo)
	//
	for (i = 0; i < AAT_CLASS_MAX; i++)
	{
		pTimerList = &(pInterface->TimerList[i]);
		if (SecondsToGo < pTimerList->MaxTimer)
		{
			//
			//  Found it.
			//
			TicksToGo = SecondsToGo / (pTimerList->TimerPeriod);
			break;
		}
	}
	
	AA_ASSERT(i < AAT_CLASS_MAX);

	AA_VALIDATE_TIMER_LIST(pTimerList);
	//
	//  Find the position in the list for this timer
	//
	Index = pTimerList->CurrentTick + TicksToGo;
	if (Index >= pTimerList->TimerListSize)
	{
		Index -= pTimerList->TimerListSize;
	}
	AA_ASSERT(Index < pTimerList->TimerListSize);

	pTimerListHead = &(pTimerList->pTimers[Index]);

	//
	//  Fill in the timer
	//
	pTimer->pTimerList = pTimerList;
	pTimer->LastRefreshTime = pTimerList->CurrentTick;
	pTimer->Duration = TicksToGo;
	pTimer->TimeoutHandler = TimeoutHandler;
	pTimer->Context = Context;
	pTimer->State = ATMARP_TIMER_STATE_RUNNING;
 
 	//
 	//  Insert this timer in the "ticking" list
 	//
 	pTimer->pPrevTimer = pTimerListHead;
 	pTimer->pNextTimer = pTimerListHead->pNextTimer;
 	if (pTimer->pNextTimer != NULL_PATMARP_TIMER)
 	{
 		pTimer->pNextTimer->pPrevTimer = pTimer;
 	}
 	pTimerListHead->pNextTimer = pTimer;

	//
	//  Start off the system tick timer if necessary.
	//
	pTimerList->TimerCount++;
	if (pTimerList->TimerCount == 1)
	{
		AADEBUGP(AAD_LOUD,
			 ("StartTimer: Starting system timer 0x%x, class %d on IF 0x%x\n",
					&(pTimerList->NdisTimer), i, pInterface));

		AA_START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
	}
	AA_VALIDATE_TIMER_LIST(pTimerList);
	AA_VALIDATE_TIMER(pTimerList, pTimer);

	AA_RELEASE_IF_TIMER_LOCK(pInterface);

	//
	//  We're done
	//
	AADEBUGP(AAD_LOUD,
		 ("Started timer 0x%x, IF 0x%x, Secs %d, Index %d, Head 0x%x\n",
				pTimer,
				pInterface,
				SecondsToGo,
				Index,
				pTimerListHead));

	return;
}




BOOLEAN
AtmArpStopTimer(
	IN	PATMARP_TIMER				pTimer,
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Stop an ATMARP timer, if it is running. We remove this timer from
	the active timer list and mark it so that we know it's not running.

	NOTE: the caller is assumed to either hold a lock to the structure
	that contains the timer, or ensure that it is safe to access the
	timer structure.

	SIDE EFFECT: If we happen to stop the last timer (of this "duration") on
	the Interface, we also stop the appropriate Tick function.

Arguments:

	pTimer			- Pointer to ATMARP Timer structure
	pInterface		- Pointer to interface to which the timer belongs

Return Value:

	TRUE if the timer was running, FALSE otherwise.

--*/
{
	PATMARP_TIMER_LIST	pTimerList;			// Timer List to which this timer belongs
	BOOLEAN				WasRunning;

	AADEBUGP(AAD_LOUD,
		 ("Stopping Timer 0x%x, IF 0x%x, List 0x%x, Prev 0x%x, Next 0x%x\n",
					pTimer,
					pInterface,
					pTimer->pTimerList,
					pTimer->pPrevTimer,
					pTimer->pNextTimer));

	AA_ACQUIRE_IF_TIMER_LOCK(pInterface);


	if (AA_IS_TIMER_ACTIVE(pTimer))
	{
		WasRunning = TRUE;

		AA_VALIDATE_TIMER_LIST(pTimer->pTimerList);
		AA_VALIDATE_TIMER(NULL, pTimer);

		//
		//  Unlink timer from the list
		//
		AA_ASSERT(pTimer->pPrevTimer);	// the list head always exists

		pTimer->pPrevTimer->pNextTimer = pTimer->pNextTimer;
		if (pTimer->pNextTimer)
		{
			pTimer->pNextTimer->pPrevTimer = pTimer->pPrevTimer;
		}

		pTimer->pNextTimer = pTimer->pPrevTimer = NULL_PATMARP_TIMER;

		//
		//  Update timer count on Interface, for this class of timers
		//
		pTimerList = pTimer->pTimerList;
		pTimerList->TimerCount--;

		//
		//  If all timers of this class are gone, stop the system tick timer
		//  for this class
		//
		if (pTimerList->TimerCount == 0)
		{
			AADEBUGP(AAD_LOUD, ("Stopping system timer 0x%x, List 0x%x, IF 0x%x\n",
						&(pTimerList->NdisTimer),
						pTimerList,
						pInterface));

			pTimerList->CurrentTick = 0;
			AA_STOP_SYSTEM_TIMER(&(pTimerList->NdisTimer));
		}

		//
		//  Mark stopped timer as not active
		//
		pTimer->pTimerList = (PATMARP_TIMER_LIST)NULL;

		pTimer->State = ATMARP_TIMER_STATE_IDLE;

		AA_VALIDATE_TIMER_LIST(pTimerList);

	}
	else
	{
		WasRunning = FALSE;
	}

	AA_RELEASE_IF_TIMER_LOCK(pInterface);

	return (WasRunning);
}




#ifdef NO_TIMER_MACRO

VOID
AtmArpRefreshTimer(
	IN	PATMARP_TIMER				pTimer
)
/*++

Routine Description:

	Refresh a timer that is already running.

	NOTE: The caller is assumed to possess a lock protecting the
	timer structure (i.e. to the structure containing the timer).

	NOTE: We don't acquire the IF Timer Lock here, to optimize
	the refresh operation. So, _within_ the confines of this routine,
	the tick handler may fire, and expire this timer. The only care
	that we take here is to make sure that we don't crash if the
	timer expires while we access the Timer list.

Arguments:

	pTimer		- Pointer to ATMARP_TIMER structure

Return Value:

	None

--*/
{
	PATMARP_TIMER_LIST	pTimerList;

	if ((pTimerList = pTimer->pTimerList) != (PATMARP_TIMER_LIST)NULL)
	{
		pTimer->LastRefreshTime = pTimerList->CurrentTick;
	}
	else
	{
		AADEBUGP(AAD_VERY_LOUD,
			 ("RefreshTimer: pTimer 0x%x not active: Hnd 0x%x, Cntxt 0x%x\n",
			 	pTimer,
			 	pTimer->TimeoutHandler,
			 	pTimer->Context
			 ));
	}

	AADEBUGP(AAD_LOUD,
		 ("Refreshed timer 0x%x, List 0x%x, hnd 0x%x, Cntxt 0x%x, LastRefresh %d\n",
				pTimer,
				pTimer->pTimerList,
				pTimer->TimeoutHandler,
				pTimer->Context,
				pTimer->LastRefreshTime));
}


#endif // NO_TIMER_MACRO


VOID
AtmArpTickHandler(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						Context,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
)
/*++

Routine Description:

	This is the handler we register with the system for processing each
	Timer List. This is called every "tick" seconds, where "tick" is
	determined by the granularity of the timer type.

Arguments:

	Context				- Actually a pointer to a Timer List structure
	SystemSpecific[1-3]	- Not used

Return Value:

	None

--*/
{

	PATMARP_INTERFACE		pInterface;
	PATMARP_TIMER_LIST		pTimerList;

	PATMARP_TIMER			pExpiredTimer;		// Start of list of expired timers
	PATMARP_TIMER			pNextTimer;			// for walking above list
	PATMARP_TIMER			pTimer;				// temp, for walking timer list
	PATMARP_TIMER			pPrevExpiredTimer;	// for creating expired timer list

	ULONG					Index;			// into the timer wheel
	ULONG					NewIndex;		// for refreshed timers


	pTimerList = (PATMARP_TIMER_LIST)Context;
	AA_STRUCT_ASSERT(pTimerList, atl);

	pInterface = (PATMARP_INTERFACE)pTimerList->ListContext;
	AA_STRUCT_ASSERT(pInterface, aai);

	AADEBUGP(AAD_VERY_LOUD, ("Tick: pIf 0x%x, List 0x%x, Count %d\n",
				pInterface, pTimerList, pTimerList->TimerCount));

	pExpiredTimer = NULL_PATMARP_TIMER;

	AA_ACQUIRE_IF_TIMER_LOCK(pInterface);

	AA_VALIDATE_TIMER_LIST(pTimerList);

	if (pInterface->AdminState == IF_STATUS_UP)
	{
		//
		//  Pick up the list of timers scheduled to have expired at the
		//  current tick. Some of these might have been refreshed.
		//
		Index = pTimerList->CurrentTick;
		pExpiredTimer = (pTimerList->pTimers[Index]).pNextTimer;
		(pTimerList->pTimers[Index]).pNextTimer = NULL_PATMARP_TIMER;

		//
		//  Go through the list of timers scheduled to expire at this tick.
		//  Prepare a list of expired timers, using the pNextExpiredTimer
		//  link to chain them together.
		//
		//  Some timers may have been refreshed, in which case we reinsert
		//  them in the active timer list.
		//
		pPrevExpiredTimer = NULL_PATMARP_TIMER;

		for (pTimer = pExpiredTimer;
			 pTimer != NULL_PATMARP_TIMER;
			 pTimer = pNextTimer)
		{
			//
			// Save a pointer to the next timer, for the next iteration.
			//
			pNextTimer = pTimer->pNextTimer;

			AADEBUGP(AAD_EXTRA_LOUD, 
				("Tick Handler: pIf 0x%x, looking at timer 0x%x, next 0x%x\n",
					pInterface, pTimer, pNextTimer));

			//
			//  Find out when this timer should actually expire.
			//
			NewIndex = pTimer->LastRefreshTime + pTimer->Duration;
			if (NewIndex >= pTimerList->TimerListSize)
			{
				NewIndex -= pTimerList->TimerListSize;
			}

			//
			//  Check if we are currently at the point of expiry.
			//
			if (NewIndex != Index)
			{
				//
				//  This timer still has some way to go, so put it back.
				//
				AADEBUGP(AAD_LOUD,
				("Tick: Reinserting Timer 0x%x: Hnd 0x%x, Durn %d, Ind %d, NewInd %d\n",
					pTimer, pTimer->TimeoutHandler, pTimer->Duration, Index, NewIndex));

				//
				//  Remove it from the expired timer list. Note that we only
				//  need to update the forward (pNextExpiredTimer) links.
				//
				if (pPrevExpiredTimer == NULL_PATMARP_TIMER)
				{
					pExpiredTimer = pNextTimer;
				}
				else
				{
					pPrevExpiredTimer->pNextExpiredTimer = pNextTimer;
				}

				//
				//  And insert it back into the running timer list.
				//
				pTimer->pNextTimer = (pTimerList->pTimers[NewIndex]).pNextTimer;
				if (pTimer->pNextTimer != NULL_PATMARP_TIMER)
				{
					pTimer->pNextTimer->pPrevTimer = pTimer;
				}
				pTimer->pPrevTimer = &(pTimerList->pTimers[NewIndex]);
				(pTimerList->pTimers[NewIndex]).pNextTimer = pTimer;
			}
			else
			{
				//
				//  This one has expired. Keep it in the expired timer list.
				//
				pTimer->pNextExpiredTimer = pNextTimer;
				if (pPrevExpiredTimer == NULL_PATMARP_TIMER)
				{
					pExpiredTimer = pTimer;
				}
				pPrevExpiredTimer = pTimer;

				//
				//  Mark it as inactive.
				//
				AA_ASSERT(pTimer->pTimerList == pTimerList);
				pTimer->pTimerList = (PATMARP_TIMER_LIST)NULL;

				pTimer->State = ATMARP_TIMER_STATE_EXPIRING;

				//
				//  Update the active timer count.
				//
				pTimerList->TimerCount--;
			}
		}

		//
		//  Update current tick index in readiness for the next tick.
		//
		if (++Index == pTimerList->TimerListSize)
		{
			pTimerList->CurrentTick = 0;
		}
		else
		{
			pTimerList->CurrentTick = Index;
		}

		if (pTimerList->TimerCount > 0)
		{
			//
			//  Re-arm the tick handler
			//
			AADEBUGP(AAD_LOUD, ("Tick[%d]: Starting system timer 0x%x, on IF 0x%x\n",
						pTimerList->CurrentTick, &(pTimerList->NdisTimer), pInterface));
			
			AA_START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
		}
		else
		{
			pTimerList->CurrentTick = 0;
		}

	}

	AA_RELEASE_IF_TIMER_LOCK(pInterface);

	//
	//  Now pExpiredTimer is a list of expired timers.
	//  Walk through the list and call the timeout handlers
	//  for each timer.
	//
	while (pExpiredTimer != NULL_PATMARP_TIMER)
	{
		pNextTimer = pExpiredTimer->pNextExpiredTimer;

		AADEBUGP(AAD_LOUD, ("Expired timer 0x%x: handler 0x%x, next 0x%x\n",
					pExpiredTimer, pExpiredTimer->TimeoutHandler, pNextTimer));

		pExpiredTimer->State = ATMARP_TIMER_STATE_EXPIRED;
		(*(pExpiredTimer->TimeoutHandler))(
				pExpiredTimer,
				pExpiredTimer->Context
			);

		pExpiredTimer = pNextTimer;
	}

}




PNDIS_PACKET
AtmArpAllocatePacket(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Allocate an NDIS packet for the specified Interface.
	Currently just a wrapper for the corresponding NDIS function.

Arguments:

	pInterface		- Pointer to ATMARP Interface structure

Return Value:

	Pointer to NDIS packet if allocated, NULL otherwise.

--*/
{
	NDIS_STATUS				Status;
	PNDIS_PACKET			pNdisPacket;
	struct PacketContext	*PC;

	NdisAllocatePacket(
			&Status,
			&pNdisPacket,
			pInterface->ProtocolPacketPool
		);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		PC = (struct PacketContext *)pNdisPacket->ProtocolReserved;
		PC->pc_common.pc_owner = PACKET_OWNER_LINK;
	}

	AADEBUGP(AAD_EXTRA_LOUD, ("Allocate Packet: IF 0x%x, Status 0x%x, Packet 0x%x\n",
				pInterface,
				Status,
				pNdisPacket));

	return (pNdisPacket);
}



VOID
AtmArpFreePacket(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_PACKET				pPacket
)
/*++

Routine Description:

	Deallocate an NDIS packet on the specified Interface.
	Currently just a wrapper around the corresponding NDIS function.

Arguments:

	pInterface		- Pointer to ATMARP Interface structure
	pPacket			- Pointer to packet being freed.

Return Value:

	None

--*/
{
	NdisFreePacket(pPacket);

	AADEBUGP(AAD_EXTRA_LOUD, ("Free Packet: IF 0x%x, Packet 0x%x\n",
				pInterface,
				pPacket));
}




PNDIS_BUFFER
AtmArpGrowHeaders(
	IN	PATMARP_INTERFACE			pInterface,
	IN	AA_HEADER_TYPE				HdrType
)
/*++

Routine Description:

	Allocate a bunch of header buffers on the specified ATMARP interface.
	Return one of them.

	We allocate a new Buffer tracker structure, a new NDIS Buffer pool, and
	finally a chunk of system memory that we break down into header buffers.
	These header buffers are then attached to NDIS Buffers before they are
	inserted into the list of free header buffers for this Interface.

Arguments:

	pInterface		- Pointer to ATMARP Interface structure
	HdrType			- Unicast or Nonunicast

Return Value:

	Pointer to allocated NDIS buffer if successful, NULL otherwise.

--*/
{
	PATMARP_BUFFER_TRACKER		pTracker;		// for new set of buffers
	PUCHAR						pSpace;
	PNDIS_BUFFER				pNdisBuffer;
	PNDIS_BUFFER				pReturnBuffer;
	PNDIS_BUFFER				pBufferList;	// allocated list
	INT							i;				// iteration counter
	NDIS_STATUS					Status;

	AA_ASSERT(HdrType < AA_HEADER_TYPE_MAX);

	//
	//  Initialize
	//
	pTracker = NULL_PATMARP_BUFFER_TRACKER;
	pReturnBuffer = (PNDIS_BUFFER)NULL;


	NdisAcquireSpinLock(&pInterface->BufferLock);

	do
	{
		if (pInterface->HeaderPool[HdrType].CurHeaderBufs >= 
					pInterface->HeaderPool[HdrType].MaxHeaderBufs)
		{
			AADEBUGP(AAD_WARNING,
				("Grow Hdrs: IF 0x%x, Type %d, CurHdrBufs %d > MaxHdrBufs %d\n",
						pInterface,
						HdrType,
						pInterface->HeaderPool[HdrType].CurHeaderBufs,
						pInterface->HeaderPool[HdrType].MaxHeaderBufs));
			break;
		}

		//
		//  Allocate and initialize Buffer tracker
		//
		AA_ALLOC_MEM(pTracker, ATMARP_BUFFER_TRACKER, sizeof(ATMARP_BUFFER_TRACKER));
		if (pTracker == NULL_PATMARP_BUFFER_TRACKER)
		{
			AADEBUGP(AAD_WARNING, ("Grow Hdrs: IF 0x%x, alloc failed for tracker\n",
					pInterface));
			break;
		}

		AA_SET_MEM(pTracker, 0, sizeof(ATMARP_BUFFER_TRACKER));

		//
		//  Get the NDIS Buffer pool
		//
		NdisAllocateBufferPool(
				&Status,
				&(pTracker->NdisHandle),
				AA_DEF_HDRBUF_GROW_SIZE
			);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING,
				 ("Grow Hdrs: IF 0x%x, NdisAllocateBufferPool err status 0x%x\n",
					pInterface, Status));
			break;
		}

		//
		//  Allocate system space for a bunch of header buffers
		//
		AA_ALLOC_MEM(pTracker->pPoolStart, 
					 UCHAR,
					 pInterface->HeaderPool[HdrType].HeaderBufSize *
						 AA_DEF_HDRBUF_GROW_SIZE);

		if (pTracker->pPoolStart == (PUCHAR)NULL)
		{
			AADEBUGP(AAD_WARNING,
				 ("Grow Hdrs: IF 0x%x, could not alloc buf space %d bytes\n",
					pInterface,
			 		pInterface->HeaderPool[HdrType].HeaderBufSize *
						 AA_DEF_HDRBUF_GROW_SIZE));
			break;
		}

		//
		//  Make NDIS buffers out of the allocated space, and put them
		//  into the free header buffer list. Retain one for returning
		//  to caller.
		//
		//  We also fill in the contents of the buffers right away, so
		//  that we don't have to prepare them afresh for each transmit.
		//
		pBufferList = (PNDIS_BUFFER)NULL;
		pSpace = pTracker->pPoolStart;
		for (i = 0; i < AA_DEF_HDRBUF_GROW_SIZE; i++)
		{
			if (HdrType == AA_HEADER_TYPE_UNICAST)
			{
				//
				//  Fill in the (Unicast) LLC/SNAP header
				//
				AA_COPY_MEM(pSpace,
							&AtmArpLlcSnapHeader,
							pInterface->HeaderPool[HdrType].HeaderBufSize);
			}
			else
			{
				AA_ASSERT(HdrType == AA_HEADER_TYPE_NUNICAST);
				//
				//  Fill in the (Multicast) Type 1 short form header
				//
#ifdef IPMCAST
				AA_COPY_MEM(pSpace,
							&AtmArpMcType1ShortHeader,
							pInterface->HeaderPool[HdrType].HeaderBufSize);
#else
				AA_ASSERT(FALSE);
#endif // IPMCAST
			}


			NdisAllocateBuffer(
					&Status,
					&pNdisBuffer,
					pTracker->NdisHandle,
					pSpace,
					pInterface->HeaderPool[HdrType].HeaderBufSize
				);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				AADEBUGP(AAD_WARNING,
					 ("Grow Hdrs: NdisAllocateBuffer failed: IF 0x%x, status 0x%x\n",
							pInterface, Status));
				break;
			}

			if (i == 0)
			{
				pReturnBuffer = pNdisBuffer;
			}
			else
			{
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = pBufferList;
				pBufferList = pNdisBuffer;
			}
			pSpace += pInterface->HeaderPool[HdrType].HeaderBufSize;
		}

		if (i > 0)
		{
			//
			//  Successfully allocated atleast one more header buffer
			//
			pTracker->pNext = pInterface->HeaderPool[HdrType].pHeaderTrkList;
			pInterface->HeaderPool[HdrType].pHeaderTrkList = pTracker;
			pInterface->HeaderPool[HdrType].CurHeaderBufs += i;

			NdisReleaseSpinLock(&pInterface->BufferLock);

			pNdisBuffer = pBufferList;
			while (pNdisBuffer != (PNDIS_BUFFER)NULL)
			{
				pBufferList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
				AtmArpFreeHeader(pInterface, pNdisBuffer, HdrType);
				pNdisBuffer = pBufferList;
			}
		}

	} while (FALSE);

	if (pReturnBuffer == (PNDIS_BUFFER)NULL)
	{
		//
		//  Failed to allocate. Undo all.
		//
		NdisReleaseSpinLock(&pInterface->BufferLock);

		if (pTracker != NULL_PATMARP_BUFFER_TRACKER)
		{
			if (pTracker->pPoolStart != (PUCHAR)NULL)
			{
				AA_FREE_MEM(pTracker->pPoolStart);
			}
			if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
			{
				NdisFreeBufferPool(pTracker->NdisHandle);
			}
			AA_FREE_MEM(pTracker);
		}
	}

	AADEBUGP(AAD_INFO, ("Grow ARP Headers: IF 0x%x, RetBuf 0x%x, New Tracker 0x%x\n",
				pInterface, pReturnBuffer, pTracker));

	return (pReturnBuffer);

}




PNDIS_BUFFER
AtmArpAllocateHeader(
	IN	PATMARP_INTERFACE			pInterface,
	IN	AA_HEADER_TYPE				HdrType,
	OUT	PUCHAR *					pBufferAddress
)
/*++

Routine Description:

	Allocate an NDIS Buffer to be used as an LLC/SNAP header prepended
	to an IP packet. We pick up the buffer at the top of the pre-allocated
	buffer list, if one exists. Otherwise, we try to grow this list and
	allocate.

Arguments:

	pInterface		- Pointer to ATMARP Interface
	HdrType			- Unicast or Nonunicast
	pBufferAddress	- Place to return virtual address of allocated buffer

Return Value:

	Pointer to NDIS buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;
	ULONG					Length;
	PAA_SINGLE_LIST_ENTRY	pListEntry;

	pListEntry = AA_POP_FROM_SLIST(
						&(pInterface->HeaderPool[HdrType].HeaderBufList),
						&(pInterface->BufferLock.SpinLock)
					);
	if (pListEntry != NULL_PAA_SINGLE_LIST_ENTRY)
	{
		pNdisBuffer = STRUCT_OF(NDIS_BUFFER, pListEntry, Next);
		NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
		*pBufferAddress = NdisBufferVirtualAddress(pNdisBuffer);
	}
	else
	{
		pNdisBuffer = AtmArpGrowHeaders(pInterface, HdrType);
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
			AADEBUGP(AAD_INFO,
				("After growing hdrs: Type %d, returning pNdisBuf 0x%x, Start 0x%x, Len %d\n",
					HdrType, pNdisBuffer, *pBufferAddress, Length));
		}
	}

	AADEBUGP(AAD_VERY_LOUD, ("Allocated Header Buffer: 0x%x, IF: 0x%x\n",
					pNdisBuffer, pInterface));
	return (pNdisBuffer);
}




VOID
AtmArpFreeHeader(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	AA_HEADER_TYPE				HdrType
)
/*++

Routine Description:

	Deallocate a header buffer.

Arguments:

	pInterface		- Pointer to ATMARP interface from which the buffer came
	pNdisBuffer		- Pointer to NDIS buffer being freed
	HdrType			- Unicast or Nonunicast

Return Value:

	None

--*/
{
	AA_PUSH_TO_SLIST(
			&(pInterface->HeaderPool[HdrType].HeaderBufList),
			STRUCT_OF(AA_SINGLE_LIST_ENTRY, &(pNdisBuffer->Next), Next),
			&(pInterface->BufferLock.SpinLock)
		);

	AADEBUGP(AAD_VERY_LOUD, ("Freed Header Buffer: 0x%x, IF: 0x%x, HdrType %d\n",
					pNdisBuffer, pInterface, HdrType));
}



VOID
AtmArpDeallocateHeaderBuffers(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Deallocate everything pertaining to header buffers on an Interface.

Arguments:

	pInterface			- Pointer to ATMARP Interface

Return Value:

	None

--*/
{
	PNDIS_BUFFER				pNdisBuffer;
	NDIS_STATUS					Status;
	PAA_SINGLE_LIST_ENTRY		pListEntry;
	PATMARP_BUFFER_TRACKER		pTracker;
	PATMARP_BUFFER_TRACKER		pNextTracker;
	AA_HEADER_TYPE				HdrType;

	for (HdrType = 0; HdrType < AA_HEADER_TYPE_MAX; HdrType++)
	{
		//
		//  Free all NDIS buffers in the header buffer list.
		//
		do
		{
			pListEntry = AA_POP_FROM_SLIST(
								&(pInterface->HeaderPool[HdrType].HeaderBufList),
								&(pInterface->BufferLock.SpinLock)
							);
			if (pListEntry != NULL_PAA_SINGLE_LIST_ENTRY)
			{
				pNdisBuffer = STRUCT_OF(NDIS_BUFFER, pListEntry, Next);
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
				NdisFreeBuffer(pNdisBuffer);
			}
			else
			{
				//
				//  No more NDIS buffers.
				//
				break;
			}
		}
		while (TRUE);

		//
		//  Now free all the buffer trackers.
		//
		pTracker = pInterface->HeaderPool[HdrType].pHeaderTrkList;

		while (pTracker != NULL_PATMARP_BUFFER_TRACKER)
		{
			pNextTracker = pTracker->pNext;
			if (pTracker->pPoolStart != (PUCHAR)NULL)
			{
				AA_FREE_MEM(pTracker->pPoolStart);
				pTracker->pPoolStart = (PUCHAR)NULL;
			}
			if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
			{
				NdisFreeBufferPool(pTracker->NdisHandle);
				pTracker->NdisHandle = (NDIS_HANDLE)NULL;
			}
			AA_FREE_MEM(pTracker);
			pTracker = pNextTracker;
		}

	} // for
}




PNDIS_BUFFER
AtmArpAllocateProtoBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	ULONG						Length,
	OUT	PUCHAR *					pBufferAddress
)
/*++

Routine Description:

	Allocate a buffer to be used for an ATM ARP protocol message. Attach
	it to an NDIS_BUFFER structure and return a pointer to this.

Arguments:

	pInterface		- Pointer to ATMARP Interface
	Length			- Length, in bytes, of the buffer.
	pBufferAddress	- Place to return virtual address of allocated buffer.

Return Value:

	Pointer to NDIS Buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER		pNdisBuffer;
	NDIS_STATUS			Status;

	//
	//  Initialize
	//
	pNdisBuffer = NULL;

	AA_ASSERT(Length <= pInterface->ProtocolBufSize);

	NdisAcquireSpinLock(&pInterface->BufferLock);

	*pBufferAddress = pInterface->ProtocolBufList;
	if (*pBufferAddress != (PUCHAR)NULL)
	{
		NdisAllocateBuffer(
				&Status,
				&pNdisBuffer,
				pInterface->ProtocolBufferPool,
				*pBufferAddress,
				Length
			);

		if (Status == NDIS_STATUS_SUCCESS)
		{
			pInterface->ProtocolBufList = *((PUCHAR *)*pBufferAddress);
		}
	}

	NdisReleaseSpinLock(&pInterface->BufferLock);

	AADEBUGP(AAD_LOUD,
		("Allocated protocol buffer: IF 0x%x, pNdisBuffer 0x%x, Length %d, Loc 0x%x\n",
				pInterface, pNdisBuffer, Length, *pBufferAddress));

	return (pNdisBuffer);
}



VOID
AtmArpFreeProtoBuffer(
	IN	PATMARP_INTERFACE			pInterface,
	IN	PNDIS_BUFFER				pNdisBuffer
)
/*++

Routine Description:

	Free an NDIS buffer (and associated memory) used for a protocol
	packet. We return the associated memory to the ProtocolBufList
	in the interface structure, and the NDIS buffer to NDIS.

Arguments:

	pInterface		- Pointer to ATMARP interface structure
	pNdisBuffer		- Pointer to NDIS buffer to be freed

Return Value:

	None

--*/
{
	PUCHAR *		pBufferLinkage;
	ULONG			Length;

	NdisQueryBuffer(pNdisBuffer, (PVOID)&pBufferLinkage, &Length);

	NdisAcquireSpinLock(&pInterface->BufferLock);

	*pBufferLinkage = pInterface->ProtocolBufList;
	pInterface->ProtocolBufList = (PUCHAR)pBufferLinkage;

	NdisReleaseSpinLock(&pInterface->BufferLock);

	NdisFreeBuffer(pNdisBuffer);

	AADEBUGP(AAD_LOUD, ("Freed Protocol Buf: IF 0x%x, pNdisBuffer 0x%x, Loc 0x%x\n",
			pInterface, pNdisBuffer, pBufferLinkage));

}



NDIS_STATUS
AtmArpInitProtoBuffers(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Initialize the protocol buffer pool for an interface.

	Allocate a chunk of memory to be used for ATMARP protocol messages.
	We prepare a linked list of protocol buffers, and attach it to the
	Interface structure.

Arguments:

	pInterface		- Pointer to Interface on which we need to allocate
					  protocol buffers.
Return Value:

	NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_RESOURCES if we run
	into a resource failure.

--*/
{
	NDIS_STATUS			Status;
	PUCHAR				pSpace;
	ULONG				i;

	do
	{
		NdisAllocatePacketPool(
				&Status,
				&(pInterface->ProtocolPacketPool),
				pInterface->MaxProtocolBufs,
				sizeof(struct PCCommon)
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NdisAllocateBufferPool(
				&Status,
				&(pInterface->ProtocolBufferPool),
				pInterface->MaxProtocolBufs
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Allocate a big chunk of system memory that we can divide up into
		//  protocol buffers.
		//
		AA_ALLOC_MEM(
				pInterface->ProtocolBufTracker,
				UCHAR,
				(pInterface->ProtocolBufSize * pInterface->MaxProtocolBufs)
				);

		if (pInterface->ProtocolBufTracker == (PUCHAR)NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		Status = NDIS_STATUS_SUCCESS;

		//
		//  Make all protocol buffers free.
		//
		pSpace = pInterface->ProtocolBufTracker;
		{
			PUCHAR	LinkPtr;

			LinkPtr = (PUCHAR)NULL;
			for (i = 0; i < pInterface->MaxProtocolBufs; i++)
			{
				*((PUCHAR *)pSpace) = LinkPtr;
				LinkPtr = pSpace;
				pSpace += pInterface->ProtocolBufSize;
			}
			pSpace -= pInterface->ProtocolBufSize;
			pInterface->ProtocolBufList = pSpace;
		}
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  Undo everything.
		//
		AtmArpDeallocateProtoBuffers(pInterface);
	}


	return (Status);
}



VOID
AtmArpDeallocateProtoBuffers(
	IN	PATMARP_INTERFACE			pInterface
)
/*++

Routine Description:

	Free the protocol buffer pool for an interface.

Arguments:

	pInterface		- Pointer to ATMARP interface structure

Return Value:

	None

--*/
{
	if (pInterface->ProtocolPacketPool != (NDIS_HANDLE)NULL)
	{
		NdisFreePacketPool(pInterface->ProtocolPacketPool);
		pInterface->ProtocolPacketPool = NULL;
	}

	if (pInterface->ProtocolBufferPool != (NDIS_HANDLE)NULL)
	{
		NdisFreeBufferPool(pInterface->ProtocolBufferPool);
		pInterface->ProtocolBufferPool = NULL;
	}

	if (pInterface->ProtocolBufTracker != (PUCHAR)NULL)
	{
		AA_FREE_MEM(pInterface->ProtocolBufTracker);
		pInterface->ProtocolBufTracker = (PUCHAR)NULL;
	}
}


VOID
AtmArpLinkVcToAtmEntry(
	IN	PATMARP_VC					pVc,
	IN	PATMARP_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Link an ATMARP VC to an ATM Entry. The caller is assumed to
	hold locks to both structures.

	If this VC is a "best effort" VC, and there is no "best effort"
	VC linked to the ATM Entry, we make this as the "best effort VC"
	on this ATM Entry.

Arguments:

	pVc					- Pointer to ATMARP VC structure
	pAtmEntry			- Pointer to ATMARP ATM Entry structure

Return Value:

	None

--*/
{
	PATMARP_VC		*ppNext;
	ULONG			SendBandwidth;

	AADEBUGP(AAD_EXTRA_LOUD, ("Link VC: 0x%x to AtmEntry 0x%x\n",
			pVc, pAtmEntry));

	//
	//  Back pointer from VC to ATM Entry.
	//
	pVc->pAtmEntry = pAtmEntry;

	//
	//  Find the position in which this VC should appear in the ATM Entry's
	//  VC list. We maintain this list in descending order of send bandwidth,
	//  so that the largest bandwidth VC to a destination appears first.
	//
	SendBandwidth = pVc->FlowSpec.SendPeakBandwidth;
	ppNext = &(pAtmEntry->pVcList);
	while (*ppNext != NULL_PATMARP_VC)
	{
		if (SendBandwidth >= (*ppNext)->FlowSpec.SendPeakBandwidth)
		{
			break;
		}
		else
		{
			ppNext = &((*ppNext)->pNextVc);
		}
	}

	//
	//  Found the place we were looking for. Insert the VC here.
	//
	pVc->pNextVc = *ppNext;
	*ppNext = pVc;

	if ((pAtmEntry->pBestEffortVc == NULL_PATMARP_VC) &&
			AA_IS_BEST_EFFORT_FLOW(&(pVc->FlowSpec)))
	{
		pAtmEntry->pBestEffortVc = pVc;
	}

	AA_REF_AE(pAtmEntry, AE_REFTYPE_VC);	// VC reference
}




VOID
AtmArpUnlinkVcFromAtmEntry(
	IN	PATMARP_VC					pVc,
	IN	BOOLEAN						bDerefAtmEntry
)
/*++

Routine Description:

	Unlink an ATMARP VC from the ATM Entry it is linked to.
	The caller is assumed to hold a lock for the VC structure.

Arguments:

	pVc				- Pointer to ATMARP VC structure
	bDerefAtmEntry	- Should we deref the ATM entry or not.

Return Value:

	None

--*/
{
	PATMARP_ATM_ENTRY			pAtmEntry;
	PATMARP_VC *				ppVc;

	AADEBUGP(AAD_EXTRA_LOUD, ("Unlink VC: 0x%x from AtmEntry 0x%x\n",
			pVc, pVc->pAtmEntry));

	pAtmEntry = pVc->pAtmEntry;
	AA_ASSERT(pAtmEntry != NULL_PATMARP_ATM_ENTRY);
	pVc->pAtmEntry = NULL_PATMARP_ATM_ENTRY;

	//
	//  Reacquire locks in the right order.
	//
	AA_RELEASE_VC_LOCK(pVc);

	AA_ACQUIRE_AE_LOCK(pAtmEntry);
	AA_ACQUIRE_VC_LOCK_DPC(pVc);

	//
	//  Search for the position of this VC in the ATM Entry's VC list
	//
	ppVc = &(pAtmEntry->pVcList);
	while (*ppVc != pVc)
	{
		AA_ASSERT(*ppVc != NULL_PATMARP_VC);
		ppVc = &((*ppVc)->pNextVc);
	}

	//
	//  Make the predecessor point to the next VC in the list.
	//
	*ppVc = pVc->pNextVc;

	AA_RELEASE_VC_LOCK_DPC(pVc);

	//
	//  If this was the Best Effort VC for this ATM Entry, try
	//  to find a replacement
	//
	if (pAtmEntry->pBestEffortVc == pVc)
	{
		//
		//  Yes, it was. Walk through the list of remaining VCs,
		//  if we find another Best Effort VC, make that the
		//  BestEffortVc for this ATM Entry
		//
		pAtmEntry->pBestEffortVc = NULL_PATMARP_VC;

		ppVc = &(pAtmEntry->pVcList);
		while (*ppVc != NULL_PATMARP_VC)
		{
			if (AA_IS_BEST_EFFORT_FLOW(&((*ppVc)->FlowSpec)))
			{
				pAtmEntry->pBestEffortVc = *ppVc;
				break;
			}
			else
			{
				ppVc = &((*ppVc)->pNextVc);
			}
		}
		AADEBUGP(AAD_LOUD, ("Atm Entry 0x%x, new Best Effort VC: 0x%x\n",
				pAtmEntry, pAtmEntry->pBestEffortVc));
	}

	if (bDerefAtmEntry)
	{
		if (AA_DEREF_AE(pAtmEntry, AE_REFTYPE_VC) != 0)
		{
			AA_RELEASE_AE_LOCK(pAtmEntry);
		}
	}
	else
	{
		AA_RELEASE_AE_LOCK(pAtmEntry);
	}

	//
	//  Acquire the VC lock again for the caller's sake
	//
	AA_ACQUIRE_VC_LOCK(pVc);
}



PNDIS_BUFFER
AtmArpCopyToNdisBuffer(
	IN	PNDIS_BUFFER				pDestBuffer,
	IN	PUCHAR						pDataSrc,
	IN	UINT						LenToCopy,
	IN OUT	PUINT					pOffsetInBuffer
)
/*++

Routine Description:

	Copy data into an NDIS buffer chain. Use up as much of the given
	NDIS chain as needed for "LenToCopy" bytes. After copying is over,
	return a pointer to the first NDIS buffer that has space for writing
	into (for the next Copy operation), and the offset within this from
	which to start writing.

Arguments:

	pDestBuffer		- First NDIS buffer in a chain of buffers
	pDataSrc		- Where to copy data from
	LenToCopy		- How much data to copy
	pOffsetInBuffer	- Offset in pDestBuffer where we can start copying into.

Return Value:

	The NDIS buffer in the chain where the next Copy can be done. We also
	set *pOffsetInBuffer to the write offset in the returned NDIS buffer.

	Note: if we are low on memory and run into a failure, we return NULL.

--*/
{
	//
	//  Size and destination for individual (contiguous) copy operations
	//
	UINT			CopySize;
	PUCHAR			pDataDst;

	//
	//  Start Virtual address for each NDIS buffer in chain.
	//
	PUCHAR			VirtualAddress;

	//
	//  Offset within pDestBuffer
	//
	UINT			OffsetInBuffer = *pOffsetInBuffer;

	//
	//  Bytes remaining in current buffer
	//
	UINT			DestSize;

	//
	//  Total Buffer Length
	//
	UINT			BufferLength;


	AA_ASSERT(pDestBuffer != (PNDIS_BUFFER)NULL);
	AA_ASSERT(pDataSrc != NULL);

#ifdef ATMARP_WIN98
	NdisQueryBuffer(
			pDestBuffer,
			&VirtualAddress,
			&BufferLength
			);
#else
	NdisQueryBufferSafe(
			pDestBuffer,
			&VirtualAddress,
			&BufferLength,
			NormalPagePriority
			);

	if (VirtualAddress == NULL)
	{
		return (NULL);
	}
#endif // ATMARP_WIN98
	
	AA_ASSERT(BufferLength >= OffsetInBuffer);

	pDataDst = VirtualAddress + OffsetInBuffer;
	DestSize = BufferLength - OffsetInBuffer;

	for (;;)
	{
		CopySize = MIN(LenToCopy, DestSize);
		AA_COPY_MEM(pDataDst, pDataSrc, CopySize);

		pDataDst += CopySize;
		pDataSrc += CopySize;

		LenToCopy -= CopySize;
		if (LenToCopy == 0)
		{
			break;
		}

		DestSize -= CopySize;

		if (DestSize == 0)
		{
			//
			//  Out of space in the current buffer. Move to the next.
			//
			pDestBuffer = NDIS_BUFFER_LINKAGE(pDestBuffer);
			AA_ASSERT(pDestBuffer != (PNDIS_BUFFER)NULL);
#ifdef ATMARP_WIN98
			NdisQueryBuffer(
					pDestBuffer,
					&VirtualAddress,
					&BufferLength
					);
#else
			NdisQueryBufferSafe(
					pDestBuffer,
					&VirtualAddress,
					&BufferLength,
					NormalPagePriority
					);

			if (VirtualAddress == NULL)
			{
				return (NULL);
			}
#endif // ATMARP_WIN98

			pDataDst = VirtualAddress;
			DestSize = BufferLength;
		}
	}

	*pOffsetInBuffer = (UINT) (pDataDst - VirtualAddress);

	return (pDestBuffer);
}


PATMARP_INTERFACE
AtmArpAddInterfaceToAdapter (
	IN	PATMARP_ADAPTER				pAdapter,
	IN	NDIS_HANDLE					LISConfigHandle, // Handle to per-LIS config
	IN	NDIS_STRING					*pIPConfigString
	)
{
	NDIS_STATUS					Status;
	struct LLIPBindInfo			BindInfo;
	PATMARP_INTERFACE			pInterface;
#ifdef ATMARP_WIN98
	ANSI_STRING					AnsiConfigString;
#endif

	do
	{
		//
		//  Create an ATMARP Interface structure to represent this LIS.
		//
		pInterface = AtmArpAllocateInterface(pAdapter);
		if (pInterface == NULL_PATMARP_INTERFACE)
		{
			AADEBUGP(AAD_WARNING, ("NotifyRegAfHandler: could not allocate Interface\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Adapter Binding Reference:
		//
		AtmArpReferenceInterface(pInterface);

		//
		//  Get all configuration information for this LIS.
		//
		Status = AtmArpCfgReadLISConfiguration(
									LISConfigHandle,
									pInterface
									);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING, ("AddInterfaceToAdapter: bad status (0x%x) reading LIS cfg\n",
						Status));
			break;
		}

#ifndef ATMARP_WIN98
		pInterface->IPConfigString = *pIPConfigString; // struct copy.
#else
		//
		//  Win98: Convert IPConfig string from Unicode to ANSI.
		//
		AnsiConfigString.MaximumLength = pIPConfigString->MaximumLength / sizeof(WCHAR) + sizeof(CHAR);
		AA_ALLOC_MEM(AnsiConfigString.Buffer, CHAR, AnsiConfigString.MaximumLength);
		if (AnsiConfigString.Buffer == NULL)
		{
			AADEBUGP(AAD_WARNING, ("NotifyRegAfHandler: couldn't alloc Ansi string (%d)\n",
				AnsiConfigString.MaximumLength));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		AnsiConfigString.Length = 0;
		NdisUnicodeStringToAnsiString(&AnsiConfigString, pIPConfigString);
		AnsiConfigString.Buffer[AnsiConfigString.Length] = '\0';
#endif // !ATMARP_WIN98

		//
		//  Allocate protocol buffers for this LIS.
		//
		Status = AtmArpInitProtoBuffers(pInterface);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING, ("AddInterfaceToAdapter: bad status (0x%x) from InitBufs\n",
						Status));
			break;
		}

		//
		//  Initialize IP/ATM data structures for this LIS.
		//
		Status = AtmArpInitIpOverAtm(pInterface);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING, ("AddInterfaceToAdapter: bad status (0x%x) from InitIP/ATM\n",
						Status));
			break;
		}

		//
		//  Initialize the Call Manager interface for this LIS.
		//
		Status = AtmArpOpenCallMgr(pInterface);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			AADEBUGP(AAD_WARNING, ("AddInterfaceToAdapter: bad status (0x%x) from OpenCallMgr\n",
						Status));
			break;
		}

		//
		//  Announce this new interface to IP, along with our BindInfo
		//  structure.
		//
		AA_SET_MEM(&BindInfo, 0, sizeof(BindInfo));

#if ATMOFFLOAD
		//
		// Query and set NIC offload capabilities.
		//
		BindInfo.lip_OffloadFlags 	= pAdapter->Offload.Flags;
		BindInfo.lip_MaxOffLoadSize = pAdapter->Offload.MaxOffLoadSize;
		BindInfo.lip_MaxSegments 	= pAdapter->Offload.MinSegmentCount;
#endif // ATMOFFLOAD

		BindInfo.lip_context = (PVOID)pInterface;
#ifdef ATMARP_WIN98
		BindInfo.lip_transmit = AtmArpIfTransmit;
#else
		BindInfo.lip_transmit = AtmArpIfMultiTransmit;
#endif
		BindInfo.lip_transfer = AtmArpIfTransfer;
		BindInfo.lip_close = AtmArpIfClose;
		BindInfo.lip_addaddr = AtmArpIfAddAddress;
		BindInfo.lip_deladdr = AtmArpIfDelAddress;
		BindInfo.lip_invalidate = AtmArpIfInvalidate;
		BindInfo.lip_open = AtmArpIfOpen;
		BindInfo.lip_qinfo = AtmArpIfQueryInfo;
		BindInfo.lip_setinfo = AtmArpIfSetInfo;
		BindInfo.lip_getelist = AtmArpIfGetEList;
		BindInfo.lip_mss = pInterface->MTU;
		BindInfo.lip_speed = pInterface->Speed;
		//
		//  Set LIP_COPY_FLAG to avoid having TransferData
		//  called all the time.
		//
		BindInfo.lip_flags = LIP_COPY_FLAG;
		BindInfo.lip_addrlen = AA_ATM_PHYSADDR_LEN;
		BindInfo.lip_addr = &(pInterface->LocalAtmAddress.Address[AA_ATM_ESI_OFFSET]);
#ifdef _PNP_POWER_
		BindInfo.lip_pnpcomplete = AtmArpIfPnPComplete;
#endif // _PNP_POWER_

#ifdef PROMIS
		BindInfo.lip_setndisrequest = AtmArpIfSetNdisRequest;
#endif // PROMIS

#ifdef ATMARP_WIN98
#if DBG
		AADEBUGP(AAD_FATAL, ("Will call AddIF: DeviceName [%ws]\n",
							&(pInterface->pAdapter->DeviceName.Buffer)));
		AADEBUGP(AAD_FATAL, ("And ConfigString: [%s]\n", AnsiConfigString.Buffer));
#endif
#endif // ATMARP_WIN98

		Status = (*(pAtmArpGlobalInfo->pIPAddInterfaceRtn))(
							&(pInterface->pAdapter->DeviceName),

#ifndef ATMARP_WIN98
#if IFCHANGE1
							NULL, // IfName (unused) --  See 10/14/1998 entry
								  // in notes.txt
#endif // IFCHANGE1
							pIPConfigString,
						
#else
							(PNDIS_STRING)&AnsiConfigString,
#endif
							pAdapter->SystemSpecific2,
							(PVOID)pInterface,
							AtmArpIfDynRegister,
							&BindInfo
#if IFCHANGE1
#ifndef ATMARP_WIN98
							,0,	// RequestedIndex (unused) --  See 10/14/1998 entry
								// in notes.txt

                            IF_TYPE_IPOVER_ATM,
                            IF_ACCESS_BROADCAST,
                            IF_CONNECTION_DEDICATED
#endif
#endif // IFCHANGE1
							);

		if (Status == IP_SUCCESS)
		{
			Status = NDIS_STATUS_SUCCESS;
		}
		else
		{
			AADEBUGP(AAD_ERROR, ("AddInterface: IPAddInterface ret 0x%x\n",
						Status));

			Status = NDIS_STATUS_FAILURE;
		}
		break;
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  There was a failure in processing this LIS.
		//
		if (pInterface != NULL_PATMARP_INTERFACE)
		{
			if (pInterface->NdisAfHandle != NULL)
			{
				(VOID)AtmArpCloseCallMgr(pInterface);
			}

			pInterface->RefCount = 0;
			AtmArpDeallocateInterface(pInterface);

			pInterface = NULL_PATMARP_INTERFACE;
		}
	}

	return pInterface;

}

#if DBG

void
AtmArpValidateTimerList(
	PATMARP_TIMER_LIST		pTimerList
	)
/*++

Routine Description:


Arguments:

	pTimerList		- Timer list 

Return Value:

	None -- will assert if timer is not valid.

--*/

{
	PATMARP_TIMER			pTimer;
	UINT u;
	UINT cTimers=0;

	AA_ASSERT(pTimerList->atl_sig == atl_signature);
	AA_ASSERT(pTimerList->CurrentTick < pTimerList->TimerListSize);

	for (u=0;u<pTimerList->TimerListSize;u++)
	{
		for ( 	pTimer = pTimerList->pTimers[u].pNextTimer;
  				pTimer;
  				pTimer = pTimer->pNextTimer)
		{
			AtmArpValidateTimer(pTimerList, pTimer);
			cTimers++;
		}
	}

	AA_ASSERT(pTimerList->TimerCount == cTimers);

}

void
AtmArpValidateTimer(
	PATMARP_TIMER_LIST		pTimerList, // OPTIONAL
	PATMARP_TIMER			pTimer
	)
/*++

Routine Description:


Arguments:

	pTimer			- Timer

Return Value:

	None -- will assert if timer is not valid.

--*/

{
	if (pTimerList)
	{
		AA_ASSERT(pTimerList == pTimer->pTimerList);
	}

	if (pTimer->pPrevTimer)
	{
		AA_ASSERT(pTimer->pPrevTimer->pNextTimer == pTimer);
	}

	if (pTimer->pNextTimer)
	{
		AA_ASSERT(pTimer->pNextTimer->pPrevTimer == pTimer);
	}
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\data.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This file contains the data declarations for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_DATA

PDRIVER_OBJECT	ArpSDriverObject = NULL;
PDEVICE_OBJECT	ArpSDeviceObject = NULL;
NDIS_HANDLE		ArpSProtocolHandle = NULL;
NDIS_HANDLE		ArpSPktPoolHandle = NULL;
NDIS_HANDLE		ArpSBufPoolHandle = NULL;
NDIS_HANDLE		MarsPktPoolHandle = NULL;
NDIS_HANDLE		MarsBufPoolHandle = NULL;
PINTF			ArpSIfList = NULL;
ULONG			ArpSIfListSize = 0;
KSPIN_LOCK		ArpSIfListLock = { 0 };
KQUEUE			ArpSReqQueue = {0};
KQUEUE			MarsReqQueue = {0};
LIST_ENTRY		ArpSEntryOfDeath = {0};
KEVENT			ArpSReqThreadEvent = {0};
SLIST_HEADER	ArpSPktList = {0};
KSPIN_LOCK		ArpSPktListLock = { 0 };
UINT			ArpSBuffers = NUM_ARPS_DESC;
UINT			MarsPackets = NUM_MARS_DESC;
PVOID			ArpSBufferSpace = NULL;
USHORT			ArpSFlushTime = FLUSH_TIME;
USHORT			ArpSNumEntriesInBlock[ARP_BLOCK_TYPES] =
		{
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(ARP_ENTRY) + 0),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(ARP_ENTRY) + sizeof(ATM_ADDRESS)),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(GROUP_MEMBER) + 0),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(CLUSTER_MEMBER) + 0),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(CLUSTER_MEMBER) + sizeof(ATM_ADDRESS)),
			(BLOCK_ALLOC_SIZE - sizeof(ARP_BLOCK))/(sizeof(MARS_ENTRY) + 0)
		};

USHORT			ArpSEntrySize[ARP_BLOCK_TYPES] =
		{
			sizeof(ARP_ENTRY),
			sizeof(ARP_ENTRY) + sizeof(ATM_ADDRESS),
			sizeof(GROUP_MEMBER),
			sizeof(CLUSTER_MEMBER),
			sizeof(CLUSTER_MEMBER) + sizeof(ATM_ADDRESS),
			sizeof(MARS_ENTRY) + 0
		};

BOOLEAN			ArpSBlockIsPaged[ARP_BLOCK_TYPES] =
		{
			TRUE,
			TRUE,
			FALSE,
			FALSE,
			FALSE,
			FALSE
		};

#ifdef OLDSAP

ATM_BLLI_IE 	ArpSDefaultBlli =
						{
							(ULONG)BLLI_L2_LLC,  // Layer2Protocol
							(UCHAR)0x00,		 // Layer2Mode
							(UCHAR)0x00,		 // Layer2WindowSize
							(ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
							(ULONG)BLLI_L3_ISO_TR9577,  // Layer3Protocol
							(UCHAR)0x01,		 // Layer3Mode
							(UCHAR)0x00,		 // Layer3DefaultPacketSize
							(UCHAR)0x00,		 // Layer3PacketWindowSize
							(ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
							(ULONG)BLLI_L3_IPI_IP,  // Layer3IPI,
							(UCHAR)0x00,		 // SnapID[5]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};

#else

ATM_BLLI_IE 	ArpSDefaultBlli =
						{
							(ULONG)BLLI_L2_LLC,  // Layer2Protocol
							(UCHAR)0x00,		 // Layer2Mode
							(UCHAR)0x00,		 // Layer2WindowSize
							(ULONG)0x00000000,   // Layer2UserSpecifiedProtocol
							(ULONG)SAP_FIELD_ABSENT,  // Layer3Protocol
							(UCHAR)0x00,		 // Layer3Mode
							(UCHAR)0x00,		 // Layer3DefaultPacketSize
							(UCHAR)0x00,		 // Layer3PacketWindowSize
							(ULONG)0x00000000,   // Layer3UserSpecifiedProtocol
							(ULONG)0x00000000,   // Layer3IPI,
							(UCHAR)0x00,		 // SnapID[5]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};

#endif // OLDSAP

ATM_BHLI_IE		ArpSDefaultBhli =
						{
							(ULONG)SAP_FIELD_ABSENT,   // HighLayerInfoType
							(ULONG)0x00000000,   // HighLayerInfoLength
							(UCHAR)0x00,         // HighLayerInfo[8]
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00,
							(UCHAR)0x00
						};
LLC_SNAP_HDR	ArpSLlcSnapHdr = { { 0xAA, 0xAA, 0x03 }, { 0x00, 0x00, 0x00 }, { 0x0608 } };
LLC_SNAP_HDR	MarsCntrlLlcSnapHdr = { { 0xAA, 0xAA, 0x03 }, { 0x00, 0x00, 0x5E }, { 0x0300 } };
LLC_SNAP_HDR	MarsData1LlcSnapHdr = { { 0xAA, 0xAA, 0x03 }, { 0x00, 0x00, 0x5E }, { 0x0100 } };
LLC_SNAP_HDR	MarsData2LlcSnapHdr = { { 0xAA, 0xAA, 0x03 }, { 0x00, 0x00, 0x5E }, { 0x0400 } };

MARS_HEADER		MarsCntrlHdr =
						{ { { 0xAA, 0xAA, 0x03 } ,  { 0x00, 0x00, 0x5E } , 0x0300 },
						  // { 0x00, 0x0f },	// HwType or AFN
						  0x0f00,
						  // { 0x08, 0x00 },	// Pro.Type
						  0x0008,
						  { 0x00, 0x00, 0x00, 0x00, 0x00 },	// ProtocolSnap[]
						  { 0x00, 0x00, 0x00 },	// Reserved[]
						  // { 0x00, 0x00 },	// Checksum
						  0x0000,
						  // { 0x00, 0x00 },	// Extension offset
						  0x0000,
						  // { 0x00, 0x00 },	// OpCode
						  0x0000,
						  0x00,				// SrcAddressTL
						  0x00				// SrcSubAddrTL
						};

MARS_FLOW_SPEC		DefaultCCFlowSpec =
						{
							DEFAULT_SEND_BANDWIDTH,
							DEFAULT_MAX_PACKET_SIZE,
							0,		// ReceiveBandwidth for PMP is zero
							0,		// ReceiveMaxSize for PMP is zero
							SERVICETYPE_BESTEFFORT
						};

MARS_TLV_MULTI_IS_MCS	MultiIsMcsTLV =
						{
							MARS_TLVT_MULTI_IS_MCS,
							0x0000		// TLV variable part Length
						};

MARS_TLV_NULL		NullTLV =
						{
							0x0000,
							0x0000
						};
#if	DBG
ULONG		ArpSDebugLevel = DBG_LEVEL_ERROR;
ULONG		MarsDebugLevel = DBG_LEVEL_ERROR;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\debug.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains the macros for debugging.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_DEBUG_
#define	_DEBUG_

#define	FILENUM_ARPS			0x010000
#define	FILENUM_MARS			0x020000
#define	FILENUM_NDIS			0x040000
#define	FILENUM_TIMER			0x080000
#define	FILENUM_DATA			0x100000
#define	FILENUM_REGISTRY		0x200000
#define	FILENUM_IOCTL			0x400000
#define	FILENUM_UTIL			0x800000

#define	DBG_LEVEL_LOUD			0x0000
#define	DBG_LEVEL_INFO			0x1000
#define DBG_LEVEL_NOTICE		0x2000
#define	DBG_LEVEL_WARN			0x3000
#define	DBG_LEVEL_ERROR			0x4000
#define	DBG_LEVEL_FATAL			0x4000
#define	DBG_NO_HDR				0x0001

#if	DBG
extern	ULONG		ArpSDebugLevel;
extern	ULONG		MarsDebugLevel;

#define ARPS_PAGED_CODE()											\
		if (KeGetCurrentIrql() > APC_LEVEL)							\
		{															\
			DbgPrint("Pageable code called at IRQL %d, file %s, line %d\n",	\
				KeGetCurrentIrql(), __FILE__, __LINE__);			\
		}

#define ARPS_GET_IRQL(_pIrql)	*(_pIrql) = KeGetCurrentIrql();

#define ARPS_CHECK_IRQL(_Irql)										\
		{															\
			KIRQL	NowIrql = KeGetCurrentIrql();					\
			if (_Irql != NowIrql)									\
			{														\
				DbgPrint("***ATMARPS***: old irq %d != new irq %d!\n",	\
					_Irql, NowIrql);								\
				DbgPrint("File: %s, line %d\n", __FILE__, __LINE__);\
				DbgBreakPoint();									\
			}														\
		}

#define DBGPRINT(Level, Fmt)										\
		{															\
			if ((Level) >= ArpSDebugLevel)							\
			{														\
				if (((Level) & DBG_NO_HDR) == 0)						\
					DbgPrint("***ATMARPS*** ");						\
				DbgPrint Fmt;										\
			}														\
		}

#define MARSDBGPRINT(Level, Fmt)									\
		{															\
			if ((Level) >= MarsDebugLevel)							\
			{														\
				if (((Level) & DBG_NO_HDR) == 0)						\
					DbgPrint("MARS:  ");							\
				DbgPrint Fmt;										\
			}														\
		}

#define MARSDUMPIPADDR(Level, Addr, Str)							\
		{															\
			if ((Level) >= MarsDebugLevel)							\
			{														\
				MarsDumpIpAddr(Addr, Str);							\
			}														\
		}

#define MARSDUMPATMADDR(Level, Addr, Str)							\
		{															\
			if ((Level) >= MarsDebugLevel)							\
			{														\
				MarsDumpAtmAddr(Addr, Str);							\
			}														\
		}

#define MARSDUMPMAP(Level, Str, IpAddr, pAtmAddr)					\
				{													\
						if ((Level) >= MarsDebugLevel)				\
						{											\
							MarsDumpMap(Str, IpAddr, pAtmAddr);		\
						}											\
				}

#define DBGBRK(Level)												\
		{															\
			if ((Level) >= ArpSDebugLevel)							\
				DbgBreakPoint();									\
		}

#define	LOG_ERROR(_s)	DBGPRINT(DBG_LEVEL_ERROR,					\
						("***ATMARPS*** ErrLog (%lx)@ %s (%ld)\n",	\
							_s, __FILE__, __LINE__));

#define ARPS_ASSERT(exp)											\
		{															\
			if (!(exp))												\
			{														\
				DbgPrint("***ATMARPS*** Assert " #exp " failed: file %s, line %d\n",	\
						__FILE__, __LINE__);						\
				DbgBreakPoint();									\
			}														\
		}

#else

#define ARPS_PAGED_CODE()
#define ARPS_GET_IRQL(_pIrql)
#define ARPS_CHECK_IRQL(Irql)
#define DBGPRINT(Level, Fmt)
#define MARSDBGPRINT(Level, Fmt)
#define MARSDUMPIPADDR(Level, Addr, Str)
#define MARSDUMPATMADDR(Level, Addr, Str)
#define MARSDUMPMAP(Level, Str, IpAddr, pAtmAddr)
#define DBGBRK(Level)
#define	LOG_ERROR(s)

#define ARPS_ASSERT(exp)

#endif	// DBG

#endif	// _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\file.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    file.h

Abstract:

    This file contains the data declarations for the disk format of arp cache.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_FILE_
#define	_FILE_

#define	DISK_HDR_SIGNATURE	'SprA'
#define	DISK_HDR_VERSION	0x00010000		// 1.0
#define	DISK_BUFFER_SIZE	4096			// Amount read or written at a time

//
// The file consists of a header, followed by individual entries.
//
typedef struct
{
	ULONG		Signature;
	ULONG		Version;
	ULONG		TimeStamp;				// Time written
	ULONG		NumberOfArpEntries;
} DISK_HEADER, *PDISK_HEADER;

typedef	struct
{
	UCHAR		AddrType;
	UCHAR		AddrLen;
	UCHAR		SubAddrType;
	UCHAR		SubAddrLen;
	UCHAR		Address[ATM_ADDRESS_LENGTH];
	//
	// This is followed by SubAddress if one is present
	//
	// UCHAR	SubAddress[ATM_ADDRESS_LENGTH];
} DISK_ATMADDR;

typedef	struct
{
	IPADDR			IpAddr;
	DISK_ATMADDR	AtmAddr;
} DISK_ENTRY, *PDISK_ENTRY;

#define	SIZE_4N(_x_)	(((_x_) + 3) & ~3)

#define	LinkDoubleAtHead(_pHead, _p)			\
	{											\
		(_p)->Next = (_pHead);					\
		(_p)->Prev = &(_pHead);					\
		if ((_pHead) != NULL)					\
			(_pHead)->Prev = &(_p)->Next;		\
		(_pHead) = (_p);						\
	}

#define	LinkDoubleAtEnd(_pThis, _pLast)			\
	{											\
		(_pLast)->Next = (_pThis);				\
		(_pThis)->Prev = &(_pLast)->Next;		\
		(_pThis)->Next = NULL;					\
	}

#define	UnlinkDouble(_p)						\
	{											\
		*((_p)->Prev) = (_p)->Next;				\
		if ((_p)->Next != NULL)					\
			(_p)->Next->Prev = (_p)->Prev;		\
	}

#endif	//	_FILE_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\data.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    data.h

Abstract:

    This file contains the data declarations for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_DATA_
#define	_DATA_

extern	PDRIVER_OBJECT	ArpSDriverObject;
extern	PDEVICE_OBJECT	ArpSDeviceObject;
extern	NDIS_HANDLE		ArpSProtocolHandle;
extern	NDIS_HANDLE		ArpSPktPoolHandle;
extern	NDIS_HANDLE		ArpSBufPoolHandle;
extern	NDIS_HANDLE		MarsPktPoolHandle;
extern	NDIS_HANDLE		MarsBufPoolHandle;
extern  PINTF			ArpSIfList;
extern  ULONG			ArpSIfListSize;
extern  KSPIN_LOCK		ArpSIfListLock;
extern	KQUEUE			ArpSReqQueue;
extern	KQUEUE			MarsReqQueue;
extern	LIST_ENTRY		ArpSEntryOfDeath;
extern	KEVENT			ArpSReqThreadEvent;
extern	SLIST_HEADER	ArpSPktList;
extern	KSPIN_LOCK		ArpSPktListLock;
extern	UINT			ArpSBuffers;
extern	UINT			MarsPackets;
extern	PVOID			ArpSBufferSpace;
extern	USHORT			ArpSFlushTime;
extern	USHORT			ArpSNumEntriesInBlock[ARP_BLOCK_TYPES];
extern	USHORT			ArpSEntrySize[ARP_BLOCK_TYPES];
extern	BOOLEAN			ArpSBlockIsPaged[ARP_BLOCK_TYPES];

extern	ATM_BLLI_IE 	ArpSDefaultBlli;
extern	ATM_BHLI_IE 	ArpSDefaultBhli;
extern	LLC_SNAP_HDR	ArpSLlcSnapHdr;
extern	LLC_SNAP_HDR	MarsCntrlLlcSnapHdr;
extern  LLC_SNAP_HDR	MarsData1LlcSnapHdr;
extern  LLC_SNAP_HDR	MarsData2LlcSnapHdr;
extern	MARS_HEADER		MarsCntrlHdr;
extern	MARS_FLOW_SPEC	DefaultCCFlowSpec;
extern	MARS_TLV_MULTI_IS_MCS	MultiIsMcsTLV;
extern	MARS_TLV_NULL	NullTLV;

extern	ULONG			ArpSDebugLevel;
extern	ULONG			MarsDebugLevel;

#endif	// _DATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\arps.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

	arps.c

Abstract:

	This file contains the code to implement the initialization
	functions for the atmarp server.

Author:

	Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

	Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_ARPS

ULONG	MCastDiscards = 0;

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT			DriverObject,
	IN	PUNICODE_STRING			RegistryPath
	)
/*++

Routine Description:

	IP/ATM Arp Server driver entry point.

Arguments:

	DriverObject - Pointer to the driver object created by the system.
	RegistryPath - Pointer to the registry section where the parameters reside.

Return Value:

	Return value from IoCreateDevice

--*/
{
	NTSTATUS		Status;
	UNICODE_STRING	DeviceName, GlobalPath, SymbolicName;
	HANDLE			ThreadHandle = NULL;
	INT				i;

#if DBG
	DbgPrint("AtmArpS: ArpSDebugLevel @ %p, MarsDebugLevel @ %p\n",
				&ArpSDebugLevel, &MarsDebugLevel);
#endif // DBG
	InitializeListHead(&ArpSEntryOfDeath);
	KeInitializeEvent(&ArpSReqThreadEvent, NotificationEvent, FALSE);
	KeInitializeQueue(&ArpSReqQueue, 0);
	KeInitializeQueue(&MarsReqQueue, 0);
	INITIALIZE_SPIN_LOCK(&ArpSIfListLock);

	ASSERT (ADDR_TYPE_NSAP == ATM_NSAP);
	ASSERT (ADDR_TYPE_E164 == ATM_E164);
	//
	// Create an NON-EXCLUSIVE device object
	//
	RtlInitUnicodeString(&DeviceName,
						 ARP_SERVER_DEVICE_NAME);
	RtlInitUnicodeString(&SymbolicName, ARP_SERVER_SYMBOLIC_NAME);

	Status = IoCreateDevice(DriverObject,
							0,
							&DeviceName,
							FILE_DEVICE_NETWORK,
							FILE_DEVICE_SECURE_OPEN,
							FALSE,
							&ArpSDeviceObject);

	if (!NT_SUCCESS(Status))
	{
		DBGPRINT(DBG_LEVEL_INFO, ("DriverEntry: IoCreateDevice failed %lx\n", Status));
	}

	else do
	{
		IoCreateSymbolicLink(&SymbolicName, &DeviceName);
		IoRegisterShutdownNotification(ArpSDeviceObject);

		ArpSDriverObject = DriverObject;

		//
		// Initialize the driver object
		//
		DriverObject->DriverUnload = ArpSUnload;
		DriverObject->FastIoDispatch = NULL;

		for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
			DriverObject->MajorFunction[i] = ArpSDispatch;

		RtlInitUnicodeString(&GlobalPath, L"AtmArpS\\Parameters");
		Status = ArpSReadGlobalConfiguration(&GlobalPath);

		if (!NT_SUCCESS(Status))
		{
			break;
		}

		//
		// Now create a thread to handle the Arp requests.
		// We do this so that the arp cache can be allocated
		// out of paged memory. Do this prior to initializing
		// the NDIS interface.
		//
		Status = PsCreateSystemThread(&ThreadHandle,
									  THREAD_ALL_ACCESS,
									  NULL,
									  NtCurrentProcess(),
									  NULL,
									  ArpSReqThread,
									  (PVOID)NULL);
		if (!NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("DriverEntry: Cannot create request thread %lx\n", Status));
			LOG_ERROR(Status);
			break;
		}
		else
		{
			//
			// Close the handle to the thread so that it goes away when the
			// thread terminates
			//
			NtClose(ThreadHandle);

			Status = PsCreateSystemThread(&ThreadHandle,
										  THREAD_ALL_ACCESS,
										  NULL,
										  NtCurrentProcess(),
										  NULL,
										  MarsReqThread,
										  (PVOID)NULL);
			if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_LEVEL_ERROR,
						("DriverEntry: Cannot create MARS thread %lx\n", Status));
				LOG_ERROR(Status);
			}
			else
			{
				//
				// Close the handle to the thread so that it goes away when the
				// thread terminates
				//
				NtClose(ThreadHandle);
			}
		}

		//
		// Finally initialize the NDIS interface
		//

		if(NT_SUCCESS(Status))
		{
			Status = ArpSInitializeNdis();
		}

		if(!NT_SUCCESS(Status))
		{
			NTSTATUS	Sts;

			DBGPRINT(DBG_LEVEL_INFO, ("DriverEntry: Error initializing NDIS\n"));

			//
			// Ask the request thread to die
			//
			KeInsertQueue(&ArpSReqQueue, &ArpSEntryOfDeath);

			//
			// Wait for it to die
			//
			WAIT_FOR_OBJECT(Sts, &ArpSReqThreadEvent, NULL);

			ArpSSleep(500);
			KeRundownQueue(&ArpSReqQueue);

			break;
		}
	} while (FALSE);

	if (!NT_SUCCESS(Status))
	{
		if (ArpSDeviceObject != NULL)
		{

			IoUnregisterShutdownNotification(ArpSDeviceObject);
		    IoDeleteSymbolicLink(&SymbolicName);
			IoDeleteDevice(ArpSDeviceObject);
		}

		//
		// De-initialize the NDIS interface
		//
		ArpSDeinitializeNdis();

		ArpSFreeGlobalData();
	}

	return Status;
}


VOID
ArpSUnload(
	IN	PDRIVER_OBJECT			DriverObject
	)
/*++

Routine Description:

	Called by the IO system to unload. This is a synchronous call and we block here till
	we finish all the cleanup before we unload.

Arguments:

	DriverObject - The arp-server's driver object.

Return Value:

	None

--*/
{
	ArpSShutDown();

	//
	// Finally delete the device
	//
	{
		UNICODE_STRING	SymbolicName;

		RtlInitUnicodeString(&SymbolicName, ARP_SERVER_SYMBOLIC_NAME);
		IoUnregisterShutdownNotification(ArpSDeviceObject);
		IoDeleteSymbolicLink(&SymbolicName);
		IoDeleteDevice(ArpSDeviceObject);
	}
}


VOID
ArpSShutDown(
	VOID
	)
/*++

Routine Description:

	Called by the IO system when the system is being shutdown.

Arguments:

	None

Return Value:

	None

--*/
{
	NTSTATUS		Status;

	//
	// Take care of the NDIS layer. NDIS will tear down any existing
	// bindings when we deregister as a protocol.
	//
	ArpSDeinitializeNdis();

	//
	// Ask the request thread to quit and wait for its demise.
	//
	KeInsertQueue(&ArpSReqQueue, &ArpSEntryOfDeath);

	WAIT_FOR_OBJECT(Status, &ArpSReqThreadEvent, NULL);
	ArpSSleep(500);
	KeRundownQueue(&ArpSReqQueue);

	//
	// Ask the MARS thread to quit and wait for its demise.
	//
	KeInsertQueue(&MarsReqQueue, &ArpSEntryOfDeath);

	KeInitializeEvent(&ArpSReqThreadEvent, NotificationEvent, FALSE);
	WAIT_FOR_OBJECT(Status, &ArpSReqThreadEvent, NULL);
	ArpSSleep(500);
	KeRundownQueue(&MarsReqQueue);

	//
	// Now cleanup global data structures
	//
	ArpSFreeGlobalData();
}

PINTF
ArpSCreateIntF(
	IN	PNDIS_STRING			DeviceName,
	IN	PNDIS_STRING			ConfigString,
	IN  NDIS_HANDLE				BindingContext
	)
/*++

Routine Description:

Arguments:


Return Value:

--*/
{
	NTSTATUS		Status;
	HANDLE			ThreadHandle;
	PINTF			pIntF;
	UINT			Size;
	UNICODE_STRING	DevPrefix;
	UNICODE_STRING	FilePrefix;
	UNICODE_STRING	FileSuffix;
	UNICODE_STRING	BaseName;
	NDIS_STRING	    AdapterFriendlyName;

	ARPS_PAGED_CODE( );

	//
	// Get the friendly name of the adapter we are bound to.
	//
	if (NdisQueryBindInstanceName(&AdapterFriendlyName, BindingContext) != NDIS_STATUS_SUCCESS)
	{
		return (NULL);
	}

	//
	// Extract the base-name of the device we are bound to
	//
	RtlInitUnicodeString(&DevPrefix, L"\\Device\\");
	RtlInitUnicodeString(&FilePrefix, L"\\SYSTEMROOT\\SYSTEM32\\");
	RtlInitUnicodeString(&FileSuffix, L".ARP");

	BaseName.Buffer = (PWSTR)((PUCHAR)DeviceName->Buffer + DevPrefix.Length);
    BaseName.Length = DeviceName->Length - DevPrefix.Length;
    BaseName.MaximumLength = DeviceName->MaximumLength - DevPrefix.Length;

	//
	// Start off by allocating an IntF block
	//
	Size =  sizeof(INTF) + FilePrefix.Length + BaseName.Length + FileSuffix.Length + sizeof(WCHAR) +
			BaseName.Length + sizeof(WCHAR) +
			AdapterFriendlyName.MaximumLength + sizeof(WCHAR);
	Size += ConfigString->MaximumLength + sizeof(WCHAR);
	pIntF = (PINTF)ALLOC_NP_MEM(Size, POOL_TAG_INTF);
	if (pIntF != NULL)
	{
		ZERO_MEM(pIntF, Size);

		//
		// Fill in some defaults.
		//
		pIntF->MaxPacketSize = DEFAULT_MAX_PACKET_SIZE;
		pIntF->LinkSpeed.Inbound = pIntF->LinkSpeed.Outbound = DEFAULT_SEND_BANDWIDTH;
		pIntF->CCFlowSpec = DefaultCCFlowSpec;

	
		//
		// Start off with a refcount of 1 for the interface and one for the timer thread.
		// The timer thread derefs when asked to quit and the last reference
		// is removed when the interface is closed (ArpSCloseAdapterComplete).
		//
		pIntF->RefCount = 2;
		pIntF->LastVcId = 1;		// Start off with 1 and wrap-around to 1. 0 and -1 are invalid
		pIntF->SupportedMedium = NdisMediumAtm;
		pIntF->CSN = 1;

		INITIALIZE_MUTEX(&pIntF->ArpCacheMutex);
		KeInitializeEvent(&pIntF->TimerThreadEvent, NotificationEvent, FALSE);
		InitializeListHead(&pIntF->InactiveVcHead);
		InitializeListHead(&pIntF->ActiveVcHead);
		InitializeListHead(&pIntF->CCPacketQueue);
		ArpSTimerInitialize(&pIntF->FlushTimer, ArpSWriteArpCache, ArpSFlushTime);

		ArpSTimerInitialize(&pIntF->MarsRedirectTimer, MarsSendRedirect, REDIRECT_INTERVAL);

		pIntF->InterfaceName.Buffer = (PWSTR)((PUCHAR)pIntF + sizeof(INTF));
		pIntF->InterfaceName.Length = 0;
		pIntF->InterfaceName.MaximumLength = BaseName.Length;

		pIntF->FileName.Buffer = (PWSTR)((PUCHAR)pIntF->InterfaceName.Buffer + BaseName.Length + sizeof(WCHAR));
		pIntF->FileName.Length = 0;
		pIntF->FileName.MaximumLength = FilePrefix.Length + BaseName.Length + FileSuffix.Length + sizeof(WCHAR);

		RtlUpcaseUnicodeString(&pIntF->InterfaceName,
							   &BaseName,
							   FALSE);

		RtlCopyUnicodeString(&pIntF->FileName, &FilePrefix);
		RtlAppendUnicodeStringToString(&pIntF->FileName, &pIntF->InterfaceName);
		RtlAppendUnicodeStringToString(&pIntF->FileName, &FileSuffix);

		//
		// Copy in the config string used to access registry for this interface.
		//
		pIntF->ConfigString.Buffer = (PWSTR)((ULONG_PTR)pIntF->FileName.Buffer + pIntF->FileName.MaximumLength);
		pIntF->ConfigString.Length = 0;
		pIntF->ConfigString.MaximumLength = ConfigString->MaximumLength;
		RtlCopyUnicodeString(&pIntF->ConfigString, ConfigString);

		//
		// Copy in the friendly name.
		//
		pIntF->FriendlyName.Buffer = (PWSTR)((ULONG_PTR)pIntF->ConfigString.Buffer + pIntF->ConfigString.MaximumLength);
		pIntF->FriendlyName.Length = 0;
		pIntF->FriendlyName.MaximumLength = AdapterFriendlyName.MaximumLength + sizeof(WCHAR);
		RtlCopyUnicodeString(&pIntF->FriendlyName, &AdapterFriendlyName);
		*(PWCHAR)((ULONG_PTR)pIntF->FriendlyName.Buffer + AdapterFriendlyName.MaximumLength) = L'\0';
		pIntF->FriendlyName.Length += sizeof(WCHAR);
		NdisFreeString(AdapterFriendlyName);

		//
		// Initialize the start timestamp value -- used for statistics reporting.
		//
 		NdisGetCurrentSystemTime(&(pIntF->StatisticsStartTimeStamp));

		//
		// Create a timer-thread now.
		//
		Status = PsCreateSystemThread(&ThreadHandle,
									  THREAD_ALL_ACCESS,
									  NULL,
									  NtCurrentProcess(),
									  NULL,
									  ArpSTimerThread,
									  (PVOID)pIntF);
		if (!NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("ArpSCreateIntF: Cannot create timer thread %lx for device %Z\n",
					Status, DeviceName));
			LOG_ERROR(Status);
			FREE_MEM(pIntF);
			pIntF = NULL;
		}
		else
		{
			//
			// Close the handle to the thread so that it goes away when the
			// thread terminates
			//
			NtClose(ThreadHandle);

			DBGPRINT(DBG_LEVEL_INFO,
					("ArpSCreateIntF: Device name %Z, InterfaceName %Z, FileName %Z, ConfigString %Z\n",
					DeviceName, &pIntF->InterfaceName, &pIntF->FileName, &pIntF->ConfigString));
			if (ArpSFlushTime != 0)
				ArpSTimerEnqueue(pIntF, &pIntF->FlushTimer);
			ArpSTimerEnqueue(pIntF, &pIntF->MarsRedirectTimer);
		}
	}

	return pIntF;
}


VOID
ArpSReqThread(
	IN	PVOID					Context
	)
/*++

Routine Description:

	Handle all arp requests here.

Arguments:

	None

Return Value:

	None
--*/
{
	PARPS_HEADER		Header;
	PARP_ENTRY			ArpEntry;
	PNDIS_PACKET		Pkt;
	PPROTOCOL_RESD		Resd;
	PARP_VC				Vc;
	PINTF				pIntF;
	UINT				PktLen;
	PLIST_ENTRY			List;
	IPADDR				SrcIpAddr, DstIpAddr;
	NTSTATUS			Status;
	HW_ADDR				SrcHwAddr, DstHwAddr;
	ATM_ADDRESS			SrcSubAddr, DstSubAddr;
	PUCHAR				p;
	BOOLEAN				SendReply;
	BOOLEAN				SendNAK = FALSE;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSReqThread: Came to life\n"));

	do
	{
		List = KeRemoveQueue(&ArpSReqQueue, KernelMode, NULL);
		if (List == &ArpSEntryOfDeath)
		{
			//
			// Asked to terminate, do so.
			//
			break;
		}

		SendReply = FALSE;
		Resd = CONTAINING_RECORD(List, PROTOCOL_RESD, ReqList);
		Vc = Resd->Vc;

		Pkt = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);
		pIntF = Vc->IntF;
	
		NdisQueryBuffer(Pkt->Private.Head, &Header, &PktLen);

		ASSERT (PktLen <= PKT_SPACE);
		p = (PUCHAR)Header + sizeof(ARPS_HEADER);
	
		//
		// Process arp request now. Since the Pkt is owned by us, we know that
		// the buffer that the packet points is contiguous and the integrity of
		// the packet has already been verified. There is also sufficient space
		// in the packet for the max. size reply that we can send.
		//
		//	!!!!!!!!!! ALGORITHM FROM RFC 1577 !!!!!!!!!!
		//
		// Here is the algorithm for handling ARP requests from the RFC
		//
		//  if (SrcIpAddr == DstIpAddr)
		//  {
		//  	if ((ArpEntry(SrcIpAddr) != NULL) &&
		//  		(SrcAtmAddress != ArpEntry->AtmAddress) &&
		//  		(ArpEnrty->Vc != NULL) && (ArpEntry->Vc != Vc))
		//  	{
		//  		Respond with the information from the ArpEntry;
		//  	}
		//  	else if ((ArpEntry(SrcIpAddr) == NULL) ||
		//  			 (ArpEntry->Vc == NULL) ||
		//  			 (ArpEntry->Vc == Vc))
		//  	{
		//  		if (ArpEntry(SrcIpAddr) == NULL))
		//  		{
		//  			Create an arp entry for this IpAddr;
		//  		}
		//  		Update the arp entry with info from the request;
		//
		//  		Respond with the information from the ArpEntry;
		//  	}
		//  }
		//  else // if (SrcIpAddr != DstIpAddr)
		//  {
		//  	if (ArpEntry(DstIpAddr) != NULL)
		//  	{
		//  		Respond with the information from the ArpEntry;
		//  	}
		//  	else
		//  	{
		//  		Respond with a NAK
		//  	}
		//
		//  	if (ArpEntry(SrcIpAddr) == NULL)
		//  	{
		//  		Create a new ArpEntry for the (SrcIpAddr, ArcAtmAddress) pair
		//  	}
		//  	else if ((ArpEntry->AtmAddress == SrcAtmAddress) &&
		//  			 (ArpEntry->AtmAddress == Vc->AtmAddress))
		//  	{
		//  		Reset timer on this ArpEntry;
		//  	}
		//  }
		//
		//	!!!!!!!!!! ALGORITHM FROM RFC 1577 !!!!!!!!!!
		//

		//
		// Start off by extracting fields from the header
		// First the source hw address (incl. the sub-addr if any)
		//
		SrcHwAddr.Address.NumberOfDigits = TL_LEN(Header->SrcAddressTL);
		if (SrcHwAddr.Address.NumberOfDigits > 0)
		{
			SrcHwAddr.Address.AddressType = TL_TYPE(Header->SrcAddressTL);
			COPY_MEM(SrcHwAddr.Address.Address, p, SrcHwAddr.Address.NumberOfDigits);
			p += SrcHwAddr.Address.NumberOfDigits;
		}
		SrcHwAddr.SubAddress = NULL;
		if (TL_LEN(Header->SrcSubAddrTL) > 0)
		{
			SrcHwAddr.SubAddress = &SrcSubAddr;
            SrcSubAddr.NumberOfDigits = TL_LEN(Header->SrcSubAddrTL);
            SrcSubAddr.AddressType = TL_TYPE(Header->SrcSubAddrTL);
			COPY_MEM(&SrcSubAddr.Address, p, SrcSubAddr.NumberOfDigits);
			p += SrcSubAddr.NumberOfDigits;
		}

		//
		// Next get the source IP address
		//
		SrcIpAddr = 0;
		if (Header->SrcProtoAddrLen == IP_ADDR_LEN)
		{
			SrcIpAddr = *(UNALIGNED IPADDR *)p;
			p += IP_ADDR_LEN;
		}
		ArpSDumpAddress(SrcIpAddr, &SrcHwAddr, "Source");

		//
		// Now the destination hw address (incl. the sub-addr if any)
		//
		DstHwAddr.Address.NumberOfDigits = TL_LEN(Header->DstAddressTL);
		if (DstHwAddr.Address.NumberOfDigits > 0)
		{
			DstHwAddr.Address.AddressType = TL_TYPE(Header->DstAddressTL);
			COPY_MEM(DstHwAddr.Address.Address, p, DstHwAddr.Address.NumberOfDigits);
			p += DstHwAddr.Address.NumberOfDigits;
		}
		DstHwAddr.SubAddress = NULL;
		if (TL_LEN(Header->DstSubAddrTL) > 0)
		{
			DstHwAddr.SubAddress = &DstSubAddr;
            DstSubAddr.NumberOfDigits = TL_LEN(Header->DstSubAddrTL);
            DstSubAddr.AddressType = TL_TYPE(Header->DstSubAddrTL);
			COPY_MEM(&DstSubAddr.Address, p, DstSubAddr.NumberOfDigits);
			p += DstSubAddr.NumberOfDigits;
		}

		//	
		// Finally the destination IP address
		//
		DstIpAddr = 0;
		if (Header->DstProtoAddrLen == IP_ADDR_LEN)
		{
			DstIpAddr = *(UNALIGNED IPADDR *)p;
			// p += IP_ADDR_LEN;
		}
		ArpSDumpAddress(DstIpAddr, &DstHwAddr, "Destination");

		do
		{
			//
			// Validate that the source and destination Ip addresses are not 0.0.0.0
			// NOTE: We can also check if they are within the same LIS (should we ?).
			//
			if ((SrcIpAddr == 0) || (DstIpAddr == 0))
			{
				DBGPRINT(DBG_LEVEL_ERROR,
						("ArpSReqThread: Null IpAddress Src(%lx), Dst(%lx)\n",
						SrcIpAddr, DstIpAddr));
	
				SendReply = FALSE;
				break;
			}
	
			//
			// Take the lock on the Arp Cache now.
			//
			WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);
			ASSERT (Status == STATUS_SUCCESS);
	
			if (SrcIpAddr == DstIpAddr)
			{
				//
				// Try to map the address to an arp cache entry
				//
				ArpEntry = ArpSLookupEntryByIpAddr(pIntF, SrcIpAddr);
				if ((ArpEntry != NULL) &&
					!COMP_HW_ADDR(&SrcHwAddr, &ArpEntry->HwAddr) &&
					(ArpEntry->Vc != NULL) && (ArpEntry->Vc != Vc))
				{
					//
					// Respond with the information from the ArpEntry
					// We have encountered a duplicate address.
					//
					ArpSBuildArpReply(pIntF, ArpEntry, Header, Pkt);
					SendReply = TRUE;
					LOG_ERROR(NDIS_STATUS_ALREADY_MAPPED);
				}
				else if ((ArpEntry == NULL)	|| (ArpEntry->Vc == NULL) || (ArpEntry->Vc == Vc))
				{
					if (ArpEntry == NULL)
					{
						//
						// Create an arp entry for this IpAddr
						//
						ArpEntry = ArpSAddArpEntry(pIntF, SrcIpAddr, &SrcHwAddr.Address, SrcHwAddr.SubAddress, Vc);
					}
					else
					{
						//
						// Update the arp entry with info from the request;
						//
						ArpSUpdateArpEntry(pIntF, ArpEntry, SrcIpAddr, &SrcHwAddr, Vc);
					}
			
					if (ArpEntry != NULL)
					{
						//
						// Respond with the information from the ArpEntry
						//
						ArpSBuildArpReply(pIntF, ArpEntry, Header, Pkt);
						SendReply = TRUE;
					}
					else
					{
						//
						// Failed to allocate an ARP entry
						//
						SendNAK = TRUE;
						SendReply = TRUE;
					}
				}
				else
				{
					DbgPrint("ATMARPS: pkt on wrong VC: ArpEntry %p, ArpEntry->Vc %p, Vc %p\n",
								ArpEntry,
								((ArpEntry)? ArpEntry->Vc: NULL),
								Vc);
				}
			}
			else // i.e. (SrcIpAddr != DstIpAddr)
			{
				//
				// Try to map the dst address to an arp cache entry
				//
				ArpEntry = ArpSLookupEntryByIpAddr(pIntF, DstIpAddr);
	
				if (ArpEntry != NULL)
				{
					//
					// Respond with the information from the ArpEntry
					// for the destination IP Address
					//
					ArpSBuildArpReply(pIntF, ArpEntry, Header, Pkt);
					SendReply = TRUE;
				}
				else
				{
					//
					// Respond with a NAK
					//
					// ArpSBuildNakReply(pIntF, ArpEntry, Header, Pkt);
					DBGPRINT(DBG_LEVEL_INFO,
							("ArpSThread: Naking for "));
					ArpSDumpIpAddr(DstIpAddr, "\n");
					Header->Opcode = ATMARP_Nak;
					SendReply = TRUE;
					SendNAK = TRUE; // for stats
				}
			
				//
				// Try to map the src address to an arp cache entry
				//
				ArpEntry = ArpSLookupEntryByIpAddr(pIntF, SrcIpAddr);
				if (ArpEntry == NULL)
				{
					//
					// Create a new ArpEntry for the (SrcIpAddr, ArcAtmAddress) pair
					//
					ArpEntry = ArpSAddArpEntry(pIntF, SrcIpAddr, &SrcHwAddr.Address, SrcHwAddr.SubAddress, Vc);
				}
				else if (COMP_HW_ADDR(&ArpEntry->HwAddr, &SrcHwAddr) &&
						 COMP_HW_ADDR(&ArpEntry->HwAddr, &Vc->HwAddr))
				{
					//
					// Reset timer on this ArpEntry
					//
					ArpSTimerCancel(&ArpEntry->Timer);
					ArpEntry->Age = ARP_AGE;
					ArpSTimerEnqueue(pIntF, &ArpEntry->Timer);
				}
			}
	
			RELEASE_MUTEX(&pIntF->ArpCacheMutex);
		} while (FALSE);

		if (SendReply && (Vc->NdisVcHandle != NULL))
		{
			if (SendNAK)
			{
				pIntF->ArpStats.Naks++;
			}
			else
			{
				pIntF->ArpStats.Acks++;
			}
			
			NDIS_SET_PACKET_STATUS(Pkt, NDIS_STATUS_SUCCESS);
			NdisCoSendPackets(Vc->NdisVcHandle, &Pkt, 1);
		}
		else
		{
			pIntF->ArpStats.DiscardedRecvPkts++;
		
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
			ArpSDereferenceVc(Vc, FALSE, TRUE);
		}
	} while (TRUE);

	KeSetEvent(&ArpSReqThreadEvent, 0, FALSE);

	DBGPRINT(DBG_LEVEL_WARN,
			("ArpSReqThread: Terminating\n"));
}


UINT
ArpSHandleArpRequest(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Handle an incoming arp request from the network. Do minimal checks,
	make a copy of the packet and queue it up.

Arguments:

	ProtocolBindingContext	Pointer to the INTF
	ProtocolVcContext		Pointer to the Vc
	Packet					Pointer to the packet

Return Value:

	Ref count on this received packet. This is 0 if we are done with
	the packet here, and 1 if we hang on to it (as for Multicast data
	that is forwarded).

--*/
{
	PARP_VC				Vc = (PARP_VC)ProtocolVcContext;
	PINTF				pIntF = (PINTF)ProtocolBindingContext;
	PARPS_HEADER		Header;
	PMARS_HEADER		MHdr;
	PNDIS_PACKET		Pkt;
	PPROTOCOL_RESD		Resd;
	UINT				PktLen, Tmp;
	BOOLEAN				ValidPkt, Mars;
	PSINGLE_LIST_ENTRY	List;
	UINT				ReturnValue;

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSHandleArpRequest: Request on Vc %lx, Id %lx\n", Vc, Vc->VcId));


	ReturnValue = 0;

	do
	{
		//
		// Verify minimum packet length
		//
		NdisQueryPacket(Packet, NULL, NULL, NULL, &PktLen);
		if (PktLen < sizeof(ARPS_HEADER))
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("ArpSHandleArpRequest: Invalid PktLen %d for received packet %lx\n",
					PktLen, Packet));

			//
			// For statistics purposes, we consider these to be discarded multicast data
			// packets.
			//
			pIntF->MarsStats.TotalMCDataPkts++;
			pIntF->MarsStats.DiscardedMCDataPkts++;
			break;
		}

		//
		// Check if this is Multicast data. If so, forward it
		// and quit.
		//
		NdisQueryBuffer(Packet->Private.Head, &Header, &Tmp);
			
		if (COMP_MEM(&Header->LlcSnapHdr, &MarsData1LlcSnapHdr, sizeof(LLC_SNAP_HDR)))
		{
			PNDIS_PACKET		pNewPacket;
			pIntF->MarsStats.TotalMCDataPkts++;
			//
			// Check if the miniport wants this packet back immediately.
			// If so, don't reuse it.
			//
			if (NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_RESOURCES)
			{
				ReturnValue = 0;

				pIntF->MarsStats.DiscardedMCDataPkts++;
				
				break;
			}

			pNewPacket = MarsAllocPacketHdrCopy(Packet);
			if (pNewPacket != (PNDIS_PACKET)NULL)
			{
				pIntF->MarsStats.ReflectedMCDataPkts++;
				MarsSendOnClusterControlVc(pIntF, pNewPacket);
				ReturnValue = 1;
			}
			break;
		}

		//
		// This must be an ARP or MARS control packet. We make a copy and queue
		// this to the appropriate thread (ARPS or MARS).
		// 

		pIntF->ArpStats.TotalRecvPkts++;
		//
		// Make sure that a larger packet wil not trash local packet after copy
		//
		if (PktLen > PKT_SPACE)
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("ArpSHandleArpRequest: Incoming packet too large, truncating - %d, Vc %lx\n",
					PktLen, Vc));
			PktLen = PKT_SPACE;
		}

		//
		// Allocate a packet from our free pool. The contents from the packet from the adapter is copied into
		// this after verification and queued to the thread. If we fail to allocate, we simply drop the request.
		//
		List = ExInterlockedPopEntrySList(&ArpSPktList, &ArpSPktListLock);
		if (List == NULL)
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("ArpSHandleArpRequest: Out of packets - interface %lx, Vc %lx\n",
					pIntF, Vc));
			pIntF->ArpStats.DiscardedRecvPkts++;
			break;
		}
	
		Resd = CONTAINING_RECORD(List, PROTOCOL_RESD, FreeList);
		Resd->Flags = 0;
		Pkt = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);

		//
		// Adjust Length of packet to reflect the size of the received packet.
		// We adjust it again to size when we reply.
		//
		NdisAdjustBufferLength(Pkt->Private.Head, PktLen);
		Pkt->Private.ValidCounts = FALSE;
		NdisCopyFromPacketToPacket(Pkt,
								   0,
								   PktLen,
								   Packet,
								   0,
								   &Tmp);
		ASSERT(Tmp == PktLen);
		ASSERT( PktLen < 65536);
		Resd->PktLen = (USHORT) PktLen;

		//
		// The incoming packet is now copied to our packet.
		// Examine and sanity check before queuing it.
		//
		NdisQueryBuffer(Pkt->Private.Head, &Header, &Tmp);
		Resd->PacketStart = (PUCHAR)Header;
		MHdr = (PMARS_HEADER)Header;

		do
		{
			ValidPkt = FALSE;		// Assume the worst

			//
			// Check for the LLC SNAP Header
			//
			if (COMP_MEM(&Header->LlcSnapHdr, &ArpSLlcSnapHdr, sizeof(LLC_SNAP_HDR)))
			{
				Mars = FALSE;
			}
			else if	(COMP_MEM(&Header->LlcSnapHdr, &MarsCntrlLlcSnapHdr, sizeof(LLC_SNAP_HDR)))
			{
				if ((MHdr->HwType == MARS_HWTYPE)			&&
					(MHdr->Protocol == IP_PROTOCOL_TYPE)	&&
					ArpSReferenceVc(Vc, TRUE))
				{
					Mars = TRUE;
					ValidPkt = TRUE;
				}
				break;
			}
			else
			{
				DBGPRINT(DBG_LEVEL_ERROR,
						("ArpSHandleArpRequest: Invalid Llc Snap Hdr\n"));
				break;
			}

			Tmp = sizeof(ARPS_HEADER) +
					Header->SrcProtoAddrLen + TL_LEN(Header->SrcAddressTL) + TL_LEN(Header->SrcSubAddrTL) +
					Header->DstProtoAddrLen + TL_LEN(Header->DstAddressTL) + TL_LEN(Header->DstSubAddrTL);

			//
			// Make sure the address and sub-address formats are consistent.
			// The valid ones from the RFC:
			//
			//					Adress				Sub-Address
			//					------				-----------
			// 
			// Structure 1		ATM Forum NSAP		Null
			// Structure 2		E.164				Null
			// Structure 3		E.164				ATM Forum NSAP
			//
			if (TL_LEN(Header->SrcSubAddrTL) > 0)
			{
				//
				// Sub-address is present. Make sure that the Address is E.164 and Sub-Address is NSAP
				//
				if ((TL_TYPE(Header->SrcAddressTL) == ADDR_TYPE_NSAP) ||
                    (TL_TYPE(Header->SrcSubAddrTL) == ADDR_TYPE_E164))
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Src Address is NSAP and Src Sub Addr is E164\n"));
					break;
				}
			}

			if (TL_LEN(Header->DstSubAddrTL) > 0)
			{
				//
				// Sub-address is present. Make sure that the Address is E.164 and Sub-Address is NSAP
				//
				if ((TL_TYPE(Header->DstAddressTL) == ADDR_TYPE_NSAP) ||
                    (TL_TYPE(Header->DstSubAddrTL) == ADDR_TYPE_E164))
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Dst Address is NSAP and Dst Sub Addr is E164\n"));
					break;
				}
			}

			if ((Header->Opcode == ATMARP_Request)		&&
				(Header->HwType == ATM_HWTYPE)			&&
				(Header->Protocol == IP_PROTOCOL_TYPE)	&&
				(PktLen >= Tmp)							&&
				ArpSReferenceVc(Vc, TRUE))
			{
				ValidPkt = TRUE;
				break;
			}
#if DBG
			else
			{
				if (Header->Opcode != ATMARP_Request)
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Invalid OpCode %x\n", Header->Opcode));
				}
				else if (Header->HwType != ATM_HWTYPE)
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Invalid HwType %x\n", Header->HwType));
				}
				else if (Header->Protocol == IP_PROTOCOL_TYPE)
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Invalid Protocol %x\n", Header->Protocol));
				}
				else if (PktLen < Tmp)
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Invalid Length %x - %x\n", PktLen, Tmp));
				}
				else
				{
					DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSHandleArpRequest: Cannot reference Vc\n"));
				}
			}
#endif
		} while (FALSE);

		if (ValidPkt)
		{
			Resd->Vc = Vc;
			if (Mars)
			{
				Resd->Flags |= RESD_FLAG_MARS;
				KeInsertQueue(&MarsReqQueue, &Resd->ReqList);
			}
			else
			{
				Resd->Flags &= ~RESD_FLAG_MARS;
				KeInsertQueue(&ArpSReqQueue, &Resd->ReqList);
			}
		}
		else
		{
			//
			// Either a mal-formed packet or the Vc is closing
			//
			pIntF->ArpStats.DiscardedRecvPkts++;
			ArpSDumpPacket((PUCHAR)Header, PktLen);

			//
			// Move the packet back into the free list
			//
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
		
		}
	} while (FALSE);

	return ReturnValue;
}


PARP_ENTRY
ArpSLookupEntryByIpAddr(
	IN	PINTF					pIntF,
	IN	IPADDR					IpAddr
	)
/*++

Routine Description:

	Lookup the Arp table for the specified IP address. Called with the ArpCache mutex held.

Arguments:

	pIntF	Pointer to the IntF structure
	IpAddr	IP address to look for

Return Value:

	ArpEntry if found or NULL.
--*/
{
	PARP_ENTRY	ArpEntry;
	UINT		Hash = ARP_HASH(IpAddr);

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSLookupArpEntry: Lookup entry for IpAddr: "));
	ArpSDumpIpAddr(IpAddr, " ..... ");

	for (ArpEntry = pIntF->ArpCache[Hash];
		 ArpEntry != NULL;
		 ArpEntry = ArpEntry->Next)
	{
		if (ArpEntry->IpAddr == IpAddr)
			break;
		if (ArpEntry->IpAddr > IpAddr)
		{
			ArpEntry = NULL;
			break;
		}
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
			("%sFound\n", (ArpEntry != NULL) ? "" : "Not"));

	if (ArpEntry != NULL)
	{
		//
		// Cleanup this entry if the Vc is no-longer active
		//
		CLEANUP_DEAD_VC(ArpEntry);
	}

	return ArpEntry;
}


PARP_ENTRY
ArpSLookupEntryByAtmAddr(
	IN	PINTF					pIntF,
	IN	PATM_ADDRESS			Address,
	IN	PATM_ADDRESS			SubAddress	OPTIONAL
	)
/*++

Routine Description:

	Lookup the Arp table for the specified IP address. Called with the ArpCache mutex held.

Arguments:

	pIntF	Pointer to the IntF structure
	IpAddr	IP address to look for

Return Value:

	ArpEntry if found or NULL.
--*/
{
	PARP_ENTRY	ArpEntry;
	UINT		i;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSLookupArpEntry: Lookup entry for "));
	ArpSDumpAtmAddr(Address, " ..... ");
	if (SubAddress != NULL)
	{
		ArpSDumpAtmAddr(SubAddress, "\t Sub ");
	}
	for (i =0; i < ARP_TABLE_SIZE; i++)
	{
		for (ArpEntry = pIntF->ArpCache[i];
			 ArpEntry != NULL;
			 ArpEntry = ArpEntry->Next)
		{
			if (COMP_ATM_ADDR(Address, &ArpEntry->HwAddr.Address))
			{
				if (((SubAddress == NULL) && (ArpEntry->HwAddr.SubAddress == NULL)) ||
					(((SubAddress != NULL) && (ArpEntry->HwAddr.SubAddress != NULL)) &&
					 COMP_ATM_ADDR(SubAddress, ArpEntry->HwAddr.SubAddress)))
				{
					break;
				}
			}
		}
		if (ArpEntry != NULL)
		{
			//
			// Cleanup this entry if the Vc is no-longer active
			//
			CLEANUP_DEAD_VC(ArpEntry);
			break;
		}
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
			("ArpSLookupArpEntry: %sFound\n", (ArpEntry != NULL) ? "" : "Not"));

	return ArpEntry;
}


PARP_ENTRY
ArpSAddArpEntry(
	IN	PINTF					pIntF,
	IN	IPADDR					IpAddr,
	IN	PATM_ADDRESS			Address,
	IN	PATM_ADDRESS			SubAddress	OPTIONAL,
	IN	PARP_VC					Vc			OPTIONAL
	)
/*++

Routine Description:

	Add the Arp table for the specified IP address. Called with the ArpCache mutex held.

Arguments:

	pIntF		Pointer to the IntF structure
	IpAddr		IP address to add
	Address &
	SubAddress	Supplies the atm address and the sub-address
	Vc			The Vc associated with this ArpEntry, if any

Return Value:

	ArpEntry if added successfully or NULL.
--*/
{
	PARP_ENTRY	ArpEntry, *ppEntry;
	UINT		Hash = ARP_HASH(IpAddr);
	ENTRY_TYPE	EntryType;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSAddArpEntry: Adding entry for IpAddr: "));
	ArpSDumpIpAddr(IpAddr, " ..... ");

	//
	// Start off by allocating an arp-entry structure
	//
    EntryType = (SubAddress != NULL) ? ARP_BLOCK_SUBADDR : ARP_BLOCK_VANILA;
	ArpEntry = (PARP_ENTRY)ArpSAllocBlock(pIntF, EntryType);
	if (ArpEntry == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
	}
	else
	{
		if (++(pIntF->ArpStats.CurrentArpEntries) > pIntF->ArpStats.MaxArpEntries)
		{
			pIntF->ArpStats.MaxArpEntries = pIntF->ArpStats.CurrentArpEntries; 
		}
		
		ArpSTimerInitialize(&ArpEntry->Timer, ArpSAgeEntry, ARP_AGE);
		ArpEntry->IpAddr = IpAddr;
		COPY_ATM_ADDR(&ArpEntry->HwAddr.Address, Address);
		if (SubAddress != NULL)
			COPY_ATM_ADDR(ArpEntry->HwAddr.SubAddress, SubAddress);
		if (ARGUMENT_PRESENT(Vc) && ArpSReferenceVc(Vc, FALSE))
		{
			ArpEntry->Vc = Vc;
			Vc->ArpEntry = ArpEntry;
		}
		ArpEntry->Age = ARP_AGE;

		//
		// Keep the overflow list sorted in ascending order of Ip addresses
		//
		for (ppEntry = &pIntF->ArpCache[Hash];
			 *ppEntry != NULL;
			 ppEntry = (PARP_ENTRY *)(&(*ppEntry)->Next))
		{
			ASSERT ((*ppEntry)->IpAddr != IpAddr);
			if ((*ppEntry)->IpAddr > IpAddr)
				break;
		}

		ArpEntry->Next = *ppEntry;
		ArpEntry->Prev = ppEntry;
		if (*ppEntry != NULL)
		{
			(*ppEntry)->Prev = &ArpEntry->Next;
		}
		*ppEntry = ArpEntry;
		pIntF->NumCacheEntries ++;

		ArpSTimerEnqueue(pIntF, &ArpEntry->Timer);
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("%lx\n", ArpEntry));

	return ArpEntry;
}


PARP_ENTRY
ArpSAddArpEntryFromDisk(
	IN	PINTF					pIntF,
	IN	PDISK_ENTRY				pDskEntry
	)
/*++

Routine Description:

	Add the Arp table for the specified IP address. Called during intialization.

Arguments:

	pIntF		Pointer to the IntF structure
	DiskEntry	
	

Return Value:

	ArpEntry if found or NULL.
--*/
{
	PARP_ENTRY	ArpEntry, *ppEntry;
	UINT		Hash = ARP_HASH(pDskEntry->IpAddr);
	ENTRY_TYPE	EntryType;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSAddArpEntryFromDisk: Adding entry for IpAddr: "));
	ArpSDumpIpAddr(pDskEntry->IpAddr, " ..... ");

	//
	// Start off by allocating an arp-entry structure
	//
    EntryType = (pDskEntry->AtmAddr.SubAddrLen != 0) ? ARP_BLOCK_SUBADDR : ARP_BLOCK_VANILA;
	ArpEntry = (PARP_ENTRY)ArpSAllocBlock(pIntF, EntryType);
	if (ArpEntry == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
	}
	else
	{
		ArpSTimerInitialize(&ArpEntry->Timer, ArpSAgeEntry, ARP_AGE);
		ArpEntry->Age = ARP_AGE;
		ArpEntry->IpAddr = pDskEntry->IpAddr;
		ArpEntry->Vc = NULL;

		//
		// COPY_ATM_ADDR();
		//
		ArpEntry->HwAddr.Address.AddressType = pDskEntry->AtmAddr.AddrType;
		ArpEntry->HwAddr.Address.NumberOfDigits = pDskEntry->AtmAddr.AddrLen;
		COPY_MEM(ArpEntry->HwAddr.Address.Address, pDskEntry->AtmAddr.Address, pDskEntry->AtmAddr.AddrLen);

		if (pDskEntry->AtmAddr.SubAddrLen != 0)
		{
			//
			// COPY_ATM_ADDR();
			//
			ArpEntry->HwAddr.SubAddress->AddressType = pDskEntry->AtmAddr.SubAddrType;
			ArpEntry->HwAddr.SubAddress->NumberOfDigits = pDskEntry->AtmAddr.SubAddrLen;
			COPY_MEM(ArpEntry->HwAddr.SubAddress->Address,
					 (PUCHAR)pDskEntry + sizeof(DISK_ENTRY),
					 pDskEntry->AtmAddr.SubAddrLen);
		}

		//
		// Keep the overflow list sorted in ascending order of Ip addresses
		//
		for (ppEntry = &pIntF->ArpCache[Hash];
			 *ppEntry != NULL;
			 ppEntry = (PARP_ENTRY *)(&(*ppEntry)->Next))
		{
			ASSERT ((*ppEntry)->IpAddr != pDskEntry->IpAddr);
			if ((*ppEntry)->IpAddr > pDskEntry->IpAddr)
				break;
		}

		ArpEntry->Next = *ppEntry;
		ArpEntry->Prev = ppEntry;
		if (*ppEntry != NULL)
		{
			(*ppEntry)->Prev = &ArpEntry->Next;
		}
		*ppEntry = ArpEntry;
		pIntF->NumCacheEntries ++;

		ArpSTimerEnqueue(pIntF, &ArpEntry->Timer);
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("%lx\n", ArpEntry));

	return ArpEntry;
}


VOID
ArpSUpdateArpEntry(
	IN	PINTF					pIntF,
	IN	PARP_ENTRY				ArpEntry,
	IN	IPADDR					IpAddr,
	IN	PHW_ADDR				HwAddr,
	IN	PARP_VC					Vc
	)
/*++

Routine Description:

	Update the ArpEntry with possibly new values.

Arguments:

	ArpEntry		ArpEntry to be updated
	IpAddr			IP Address
	HwAddr			Hw address (Atm Address and optionally Atm SubAddress)
	Vc				Vc associated with this entry

Return Value:

	None

--*/
{
	KIRQL	OldIrql;

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSUpdateArpEntry: Adding entry for IpAddr: "));
	ArpSDumpIpAddr(IpAddr, " ..... ");

	ASSERT ((ArpEntry->Vc == NULL) || (ArpEntry->Vc == Vc));
	ASSERT (ArpEntry->IpAddr == IpAddr);

	//
	// If the Hw address changed, make sure that there is enough space there to copy the new address
	//
	if ((HwAddr->SubAddress != NULL) ^ (ArpEntry->HwAddr.SubAddress != NULL))
	{
		PARP_ENTRY	*ppEntry, ArpEntryNew;

		//
		// Need to allocate a new ArpEntry. First de-queue the current
		// entry from the list and cancel the timer.
		//
		ArpSTimerCancel(&ArpEntry->Timer);
		*(ArpEntry->Prev) = ArpEntry->Next;
		if (ArpEntry->Next != NULL)
			((PENTRY_HDR)(ArpEntry->Next))->Prev = ArpEntry->Prev;
		pIntF->NumCacheEntries --;

		//
		// We create the new ArpEntry with a NULL Vc and then update it. This is to avoid
		// de-ref and ref of the Vc again.
		//
		ArpEntryNew = ArpSAddArpEntry(pIntF, IpAddr, &HwAddr->Address, HwAddr->SubAddress, NULL);

		if (ArpEntryNew == NULL)
		{
			//
			// Allocation failure, link back the old entry and bail out.
			//
			if (ArpEntry->Next != NULL)
			{
				((PENTRY_HDR)(ArpEntry->Next))->Prev = &ArpEntry;
			}

			*(ArpEntry->Prev) = ArpEntry;

			ArpSTimerInitialize(&ArpEntry->Timer, ArpSAgeEntry, ARP_AGE);

			pIntF->NumCacheEntries ++;

			return;
		}

        //
        // Update with the existing Vc for now.
        //
        ArpEntryNew->Vc = ArpEntry->Vc;

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

		ASSERT((Vc->ArpEntry == ArpEntry) || (Vc->ArpEntry == NULL));
		if (Vc->Flags & ARPVC_ACTIVE)
		{
			Vc->ArpEntry = ArpEntryNew;
		}

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		ArpSFreeBlock(ArpEntry);

		ArpEntry = ArpEntryNew;
	}
	else
	{
		ArpEntry->Age = ARP_AGE;
	}

	if (ArpEntry->Vc != Vc)
	{
		ASSERT(ArpEntry->Vc == NULL);
		if (ArpSReferenceVc(Vc, FALSE))
		{
			ArpEntry->Vc = Vc;
		}
	}

	COPY_HW_ADDR(&ArpEntry->HwAddr, HwAddr);
}


VOID
ArpSBuildArpReply(
	IN	PINTF					pIntF,
	IN	PARP_ENTRY				ArpEntry,
	IN	PARPS_HEADER			Header,
	IN	PNDIS_PACKET			Pkt
	)
/*++

Routine Description:


Arguments:


Return Value:

	None

--*/
{
	PUCHAR	pSrc, pDst, pDstOld;
	UINT	Tmp, SrcLenOld, SrcLenNew, DstLenNew;

	//
	// Most of the fields are already valid (or else we will not be here)
	//
	Header->Opcode = ATMARP_Reply;

	pSrc = (PUCHAR)Header + sizeof(ARPS_HEADER);
	SrcLenOld = DstLenNew = IP_ADDR_LEN + TL_LEN(Header->SrcAddressTL) + TL_LEN(Header->SrcSubAddrTL);

	SrcLenNew = IP_ADDR_LEN + ArpEntry->HwAddr.Address.NumberOfDigits;
	if (ArpEntry->HwAddr.SubAddress != NULL)
		SrcLenNew += ArpEntry->HwAddr.SubAddress->NumberOfDigits;
	pDst = pSrc + SrcLenNew;

	//
	// Fill in the new destination fields from the source fields of the request
	//
	Header->DstAddressTL = Header->SrcAddressTL;
	Header->DstSubAddrTL = Header->SrcSubAddrTL;
	Header->DstProtoAddrLen = Header->SrcProtoAddrLen;
	MOVE_MEM(pDst, pSrc, DstLenNew);

	//
	// Fill in the destination fields
	//
	Header->DstAddressTL = TL(ArpEntry->HwAddr.Address.AddressType, ArpEntry->HwAddr.Address.NumberOfDigits);
	Header->DstSubAddrTL = 0;
	if (ArpEntry->HwAddr.SubAddress != NULL)
	{
		Header->DstSubAddrTL =
					TL(ArpEntry->HwAddr.SubAddress->AddressType, ArpEntry->HwAddr.SubAddress->NumberOfDigits);
	}
	Header->DstProtoAddrLen = IP_ADDR_LEN;

	Tmp = ArpEntry->HwAddr.Address.NumberOfDigits;
	COPY_MEM(pSrc, ArpEntry->HwAddr.Address.Address, Tmp);
	if (ArpEntry->HwAddr.SubAddress != NULL)
	{
		COPY_MEM(pSrc + Tmp,
				 ArpEntry->HwAddr.SubAddress->Address,
				 ArpEntry->HwAddr.SubAddress->NumberOfDigits);
		Tmp += ArpEntry->HwAddr.SubAddress->NumberOfDigits;
	}

	*(UNALIGNED IPADDR *)(pSrc + Tmp) = ArpEntry->IpAddr;

	DBGPRINT(DBG_LEVEL_INFO,
	 ("BuildReply: Pkt=0x%lx MDL=0x%lx: sz=%lu bc=%lu bo=%lu new bc=%lu\n",
	 Pkt,
	 Pkt->Private.Head,
	 Pkt->Private.Head->Size,
	 Pkt->Private.Head->ByteCount,
	 Pkt->Private.Head->ByteOffset,
	 SrcLenNew + DstLenNew + sizeof(ARPS_HEADER)));

	//
	// Finally set the Pkt length correctly
	//
	NdisAdjustBufferLength(Pkt->Private.Head, SrcLenNew + DstLenNew + sizeof(ARPS_HEADER));
	Pkt->Private.ValidCounts = FALSE;
}


BOOLEAN
ArpSAgeEntry(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	)
/*++

Routine Description:

	Check this ARP entry and if it ages out, free it.

Arguments:

Return Value:


--*/
{
	PARP_ENTRY	ArpEntry;
	BOOLEAN		rc;

	ArpEntry = CONTAINING_RECORD(Timer, ARP_ENTRY, Timer);

	ArpEntry->Age --;
	if (TimerShuttingDown || (ArpEntry->Age == 0))
	{
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSAgeEntry: Aging out entry for IpAddr %lx\n", ArpEntry->IpAddr));

		pIntF->ArpStats.CurrentArpEntries--;
		
		if (ArpEntry->Next != NULL)
		{
			((PENTRY_HDR)(ArpEntry->Next))->Prev = ArpEntry->Prev;
		}
		*(ArpEntry->Prev) = ArpEntry->Next;
		pIntF->NumCacheEntries --;
	
		//
		// if there is an open Vc, make sure it is not pointing to this arpentry
		//
		CLEANUP_DEAD_VC(ArpEntry);
		ArpSFreeBlock(ArpEntry);
		rc = FALSE;
	}
	else
	{
		//
		// Cleanup dead vcs
		//
		CLEANUP_DEAD_VC(ArpEntry);
		rc = TRUE;
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSAgeEntry: IpAddr %lx age %02d:%02d\n",
				ArpEntry->IpAddr, ArpEntry->Age/4, (ArpEntry->Age % 4) * 15));
	}

	return rc;
}

BOOLEAN
ArpSDeleteIntFAddresses(
	IN	PINTF					pIntF,
	IN	INT						NumAddresses,
	IN	PATM_ADDRESS			AddrList
	)
//
// Return TRUE IFF the  NdisCoRequest has been called EXACTLY NumAddresses times.
//
{
	PNDIS_REQUEST		NdisRequest;
	NDIS_STATUS			Status;
	PCO_ADDRESS			pCoAddr;

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSDeleteIntFAddresses: pIntF %p: %Z, NumAddr %d\n", pIntF, &pIntF->InterfaceName, NumAddresses));

	while (NumAddresses--)
	{
		NdisRequest = ALLOC_NP_MEM(sizeof(NDIS_REQUEST) + sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS), POOL_TAG_REQ);
		if (NdisRequest == NULL)
		{
			LOG_ERROR(NDIS_STATUS_RESOURCES);
			return FALSE;
		}

		ZERO_MEM(NdisRequest, sizeof(NDIS_REQUEST) + sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS));
		NdisRequest->RequestType = NdisRequestSetInformation;
		NdisRequest->DATA.SET_INFORMATION.Oid = OID_CO_DELETE_ADDRESS;
		NdisRequest->DATA.SET_INFORMATION.InformationBuffer = (PUCHAR)NdisRequest + sizeof(NDIS_REQUEST);
		NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);

		//
		// Copy the address into the request
		//
        pCoAddr = NdisRequest->DATA.SET_INFORMATION.InformationBuffer;
		pCoAddr->AddressSize = sizeof(ATM_ADDRESS);
		*(PATM_ADDRESS)(pCoAddr->Address) = *AddrList++;

		Status = NdisCoRequest(pIntF->NdisBindingHandle,
							   pIntF->NdisAfHandle,
							   NULL,
							   NULL,
							   NdisRequest);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCoRequestComplete(Status, pIntF, NULL, NULL, NdisRequest);
		}
	}

	return TRUE;
		
}


VOID
ArpSQueryAndSetAddresses(
	IN	PINTF					pIntF
	)
{
	PNDIS_REQUEST		NdisRequest;
	PCO_ADDRESS			pCoAddr;
	NDIS_STATUS			Status;
	UINT				Size;

	DBGPRINT(DBG_LEVEL_INFO, ("Querying current address\n"));

	//
	// Allocate a request to query the configured address
	//
	Size = sizeof(NDIS_REQUEST) + sizeof(CO_ADDRESS_LIST) + sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);
	NdisRequest = ALLOC_NP_MEM(Size, POOL_TAG_REQ);
	if (NdisRequest == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
		return;
	}

	ZERO_MEM(NdisRequest, Size);
	NdisRequest->RequestType = NdisRequestQueryInformation;
	NdisRequest->DATA.QUERY_INFORMATION.Oid = OID_CO_GET_ADDRESSES;
	NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = ((PUCHAR)NdisRequest + sizeof(NDIS_REQUEST));
	NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = Size - sizeof(NDIS_REQUEST);

	Status = NdisCoRequest(pIntF->NdisBindingHandle,
						   pIntF->NdisAfHandle,
						   NULL,
						   NULL,
						   NdisRequest);
	if (Status != NDIS_STATUS_PENDING)
	{
		ArpSCoRequestComplete(Status, pIntF, NULL, NULL, NdisRequest);
	}
}


VOID
ArpSValidateAndSetRegdAddresses(
	IN	PINTF			pIntF,	// LOCKIN NOLOCKOUT
	IN	KIRQL			OldIrql
	)
/*++
	Initiate the 1st step of the following operations, which complete asynchronously
	and in order:
	   - Validate 1st address to be registered (by making a call to the dest - if
	   	 it fails we consider the address validated).
	   - (on successful validation) Register the address with the call manager.
	   - Validate the 2nd address
	   - (on successful validation) Register the 2nd address
	   - etc..
--*/
{
	PNDIS_REQUEST		NdisRequest;
	PCO_ADDRESS			pCoAddr;
	UINT				Size;
	INT					fLockReleased;
	PREG_ADDR_CTXT		pRegAddrCtxt;

	DBGPRINT(DBG_LEVEL_INFO, ("Validating and setting regd. addresses\n"));

	pRegAddrCtxt 	= NULL;
	fLockReleased 	= FALSE;

	do
	{
		//
		// The state on the ongoing validation and registration process is
		// maintained in pIntF->pRegAddrCtxt, which we allocate and initialize
		// here.
		//

		if (pIntF->pRegAddrCtxt != NULL)
		{
			//
			//  There is ongoing work relating to registering already!
            //  This could happen if we get an  OID_CO_ADDRESS_CHANGE when we are
            //  either processing an earlier one, or are in the process of
            //  initializing. We get these cases during pnp stress
            // ( 1c_reset script against an Olicom 616X) -- Whistler bug#102805
			//
			break;
		}

		if (pIntF->NumAddressesRegd >= pIntF->NumAllocedRegdAddresses)
		{
			ASSERT(pIntF->NumAddressesRegd == pIntF->NumAllocedRegdAddresses);

			//
			// No addresses to register.
			//
			DBGPRINT(DBG_LEVEL_INFO, ("ValAndSet: No addresses to register.\n"));
			break;
		}
		
		pRegAddrCtxt = ALLOC_NP_MEM(sizeof(*pRegAddrCtxt), POOL_TAG_REQ);

		if (pRegAddrCtxt == NULL)
		{
			LOG_ERROR(NDIS_STATUS_RESOURCES);
			break;
		}

		ZERO_MEM(pRegAddrCtxt, sizeof(*pRegAddrCtxt));

		//
		// Attach the context to the IF and add a reference.
		// (Can't have the lock when adding the reference)
		//

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		if (!ArpSReferenceIntF(pIntF))
		{
			DBGPRINT(DBG_LEVEL_INFO, ("ValAndSet: ERROR: Couldn't ref IntF. .\n"));
			//  Couldn't reference the IF. Fail.
			//
			fLockReleased = TRUE;
			break;
		}
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

		if (pIntF->pRegAddrCtxt != NULL)
		{
			//
			//  Someone snuck in while we unlocked the IF above!
			//  We bail out.
			//
			ASSERT(FALSE);
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			ArpSDereferenceIntF(pIntF);
			fLockReleased = TRUE;
			break;
		}

		pIntF->pRegAddrCtxt = pRegAddrCtxt;
		pRegAddrCtxt->pIntF = pIntF;
		pRegAddrCtxt = NULL; // so that it is not deallocated in this function.

		// Initiate the validation and registration of the first address.
		//
		ArpSValidateOneRegdAddress(pIntF, OldIrql);
		//
		// (Lock released by above call.)
		fLockReleased = TRUE;

		//
		// The remainder of the validation and registration process happens 
		// asynchronously.
		//

	} while (FALSE);

	if (pRegAddrCtxt != NULL)
	{
		FREE_MEM(pRegAddrCtxt);
	}

	if (!fLockReleased)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}
}


VOID
ArpSValidateOneRegdAddress(
	IN	PINTF			pIntF,	// LOCKIN NOLOCKOUT
	IN	KIRQL			OldIrql
	)
/*++

Routine Description:

	Initiates the validation and registration of a single address.
	"Initiate" consists of creating a vc and making a call to the address. The
	next step in the process happens after the make call completes
	(see  05/14/1999 notes.txt entry ("Rogue ARP server detection contd."))
	for more details.

	One more thing: If there are no addresses to be validated, then
	this function will DEREF pIntF and FREE pIntF->pRegAddrCtxt (which
	MUST be NON-NULL).

Arguments:

	pIntF		Pointer to the interface block.
	OldIrql		Irql before pIntF was locked.

--*/
{
	NDIS_STATUS Status;
	INT			fLockReleased = FALSE;
	INT			fFreeContext  = TRUE;

	DBGPRINT(
		DBG_LEVEL_INFO,
		 ("==>ValidateOneRegAddress(pIntF=0x%p; pCtxt=0x%p).\n",
		 	pIntF,
			pIntF->pRegAddrCtxt));

	do
	{
		PREG_ADDR_CTXT		pRegAddrCtxt;
		PATM_ADDRESS		pDestAtmAddress;
		pRegAddrCtxt = pIntF->pRegAddrCtxt;

		// We expect to be called only if there is a valid pRegAddrCtxt.
		//
		if (pRegAddrCtxt == NULL)
		{
			ASSERT(FALSE);
			fFreeContext = FALSE;
			break;
		}

		if (pIntF->Flags & INTF_STOPPING)
		{
			DBGPRINT(DBG_LEVEL_INFO, ("ValOneRA: IF stopping, quitting.\n"));
			// Nothing left to do.
			//
			break;
		}

		if (pIntF->NumAddressesRegd >= pIntF->NumAllocedRegdAddresses)
		{
			DBGPRINT(DBG_LEVEL_INFO, ("ValOneRA: nothing left to do.\n"));
			// Nothing left to do.
			//
			break;
		}

		if (pIntF->NumAddressesRegd > pRegAddrCtxt->RegAddrIndex)
		{
			// This should never happen.
			//
			ASSERT(FALSE);
			break;
		}

		if (pIntF->NumAllocedRegdAddresses <= pRegAddrCtxt->RegAddrIndex)
		{
			ASSERT(pIntF->NumAllocedRegdAddresses == pRegAddrCtxt->RegAddrIndex);

			DBGPRINT(DBG_LEVEL_INFO, ("ValOneRA: nothing left to do.\n"));

			// Nothing left to do.
			//
			break;
		}

		if (pRegAddrCtxt->NdisVcHandle != NULL)
		{
			// We shouldn't be called with a non-null VcHandle.
			//
			fFreeContext = FALSE;
			ASSERT(FALSE);
			break;
		}

		// TODO: use the Flags field.
		
		//
		// There is at least one address to try to validate & register. It
		// is pIntF->RegAddresses[pRegAddrCtxt->RegAddrIndex].
		//
		
		// Create VC
		//
		Status = NdisCoCreateVc(
					pIntF->NdisBindingHandle,
					pIntF->NdisAfHandle,
					(NDIS_HANDLE)pRegAddrCtxt,
					&pRegAddrCtxt->NdisVcHandle
					);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			pRegAddrCtxt->NdisVcHandle = NULL;
			break;
		}

		// Set the VC type.
		//
		pRegAddrCtxt->VcType =  VC_TYPE_CHECK_REGADDR;

		// Setup call params
		//
		pDestAtmAddress = &(pIntF->RegAddresses[pRegAddrCtxt->RegAddrIndex]);
		ArpSSetupValidationCallParams(pRegAddrCtxt, pDestAtmAddress);
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	
		fLockReleased = TRUE;
		fFreeContext = FALSE;

		DBGPRINT(
			DBG_LEVEL_INFO,
 			("ValOneRA: Going to make call. pCallParams=0x%p\n",
				&pRegAddrCtxt->CallParams));
		//
		// Make Call (in call complete handler we move on to the next step --
		// see  05/14/1999 notes.txt entry for details.)
		//
		Status = NdisClMakeCall(
						pRegAddrCtxt->NdisVcHandle,
						&pRegAddrCtxt->CallParams,
						NULL,
						NULL
						);
		
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSMakeRegAddrCallComplete(
						Status,
						pRegAddrCtxt
						);
			Status = NDIS_STATUS_PENDING;
		}
		
	} while (FALSE);
	
	if (fFreeContext)
	{
		ASSERT(!fLockReleased);

		//
		// If there is nothing more to be done, unlink the context.
		//
		ArpSUnlinkRegAddrCtxt(pIntF, OldIrql);
		//
		// IntF lock released in above call.
		fLockReleased = TRUE;
	}

	if (!fLockReleased)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	DBGPRINT(DBG_LEVEL_INFO, ("<==ValidateOneRegAddress.\n"));
}


BOOLEAN
ArpSReferenceIntF(
	IN	PINTF		pIntF
	)
/*++

Routine Description:

	Reference the Interface object.

Arguments:

	pIntF	Pointer to the interface block.

Return Value:

	TRUE	Referenced
	FALSE	Interface is closing, cannot reference.

--*/
{
	KIRQL	OldIrql;
	BOOLEAN	rc = TRUE;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);	

	if (pIntF->Flags & INTF_CLOSING)
	{
		rc = FALSE;
	}
	else
	{
		pIntF->RefCount ++;
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

	return rc;
}


PINTF
ArpSReferenceIntFByName(
	IN	PINTERFACE_NAME			pInterface
	)
/*++

Routine Description:

	Reference the Interface object by base-name.

Arguments:

	pIntF	Pointer to the interface block.

Return Value:

	TRUE	Referenced
	FALSE	Interface is closing, cannot reference.

--*/
{
	PINTF	pIntF;
	KIRQL	OldIrql;
	BOOLEAN	Found = FALSE, ref = FALSE;
	ULONG	IfIndex;

	ACQUIRE_SPIN_LOCK(&ArpSIfListLock, &OldIrql);

	for (pIntF = ArpSIfList, IfIndex = 1;
		 pIntF != NULL;
		 pIntF = pIntF->Next, IfIndex++)
	{
		if (IfIndex > ArpSIfListSize)
		{
			DbgPrint("ATMARPS: RefIntByName: IF list at %p not consistent with list size %d\n",
				ArpSIfList, ArpSIfListSize);
			DbgBreakPoint();
			break;
		}

		ACQUIRE_SPIN_LOCK_DPC(&pIntF->Lock);	

		if ((pIntF->FriendlyName.Length == pInterface->Length) &&
			COMP_MEM(pIntF->FriendlyName.Buffer, pInterface->Buffer, pInterface->Length))
		{
			Found = TRUE;
			if ((pIntF->Flags & INTF_CLOSING) == 0)
			{
				pIntF->RefCount ++;
				ref = TRUE;
			}
		}

		RELEASE_SPIN_LOCK_DPC(&pIntF->Lock);	

		if (Found)
			break;
	}

	if (!ref)
	{
		pIntF = NULL;
	}

	RELEASE_SPIN_LOCK(&ArpSIfListLock, OldIrql);

	DBGPRINT(DBG_LEVEL_INFO, ("ATMARPS: RefIntfByName:[%ws]: pIntF %p\n",
		pInterface->Buffer, pIntF));

	return pIntF;
}


VOID
ArpSDereferenceIntF(
	IN	PINTF					pIntF
	)
{
	KIRQL	OldIrql;
	PINTF *	ppIntF;
	KIRQL	EntryIrql;

	ARPS_GET_IRQL(&EntryIrql);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);	

	ASSERT (pIntF->RefCount > 0);
	pIntF->RefCount --;

	if (pIntF->RefCount == 0)
	{
		BOOLEAN  bFreeIntF = FALSE;
		ASSERT (pIntF->Flags & INTF_CLOSING);


		//
		// We need to release and reacquire the lock to get the locks
		// in the right order. In the meantime, we need to keep the
		// refcount nonzero.
		//
		pIntF->RefCount = 1;
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

		ACQUIRE_SPIN_LOCK(&ArpSIfListLock, &OldIrql);
		ACQUIRE_SPIN_LOCK_DPC(&pIntF->Lock);

		pIntF->RefCount--; // Remove tmp ref added just before.

		if (pIntF->RefCount == 0)
		{
			//
			// As expected, refcount is now back to zero. Also we have
			// both list and IF lock held, so we can complete the deinit safely.
			//

			bFreeIntF = TRUE;

			//
			// Remove this Interface from the global list IF it is in the list.
			//
			for (ppIntF = &ArpSIfList; *ppIntF != NULL; ppIntF = &((*ppIntF)->Next))
			{
				if (*ppIntF == pIntF)
				{
					*ppIntF = pIntF->Next;
					ArpSIfListSize--;
					break;
				}
			}
	
			//
			// Signal anyone waiting for this to happen
			//
			if (pIntF->CleanupEvent != NULL)
			{
				KeSetEvent(pIntF->CleanupEvent, IO_NETWORK_INCREMENT, FALSE);
			}
		}
		else
		{
			//
			// Some other thread has snuck in and referenced the IF. We
			// don't do anything here.
			//
		}

		RELEASE_SPIN_LOCK_DPC(&pIntF->Lock);
		RELEASE_SPIN_LOCK(&ArpSIfListLock, OldIrql);

		if (bFreeIntF)
		{
			FREE_MEM(pIntF);
		}
	}
	else
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	
	}

	ARPS_CHECK_IRQL(EntryIrql);
}


BOOLEAN
ArpSReferenceVc(
	IN	PARP_VC					Vc,
	IN	BOOLEAN					bSendRef
	)
/*++

Routine Description:

	Reference the VC.

Arguments:

	Vc			Pointer to the VC.
	bSendRef	Is this a "pending send" reference?

Return Value:

	TRUE	Referenced
	FALSE	Interface or VC is closing, cannot reference.

--*/
{
	PINTF	pIntF = Vc->IntF;
	KIRQL	OldIrql;
	BOOLEAN	rc = TRUE;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);	

	if ((Vc->Flags & (ARPVC_CLOSING | ARPVC_CLOSE_PENDING)) != 0)
	{
		rc = FALSE;
	}
	else
	{
		Vc->RefCount ++;
		if (bSendRef)
		{
			Vc->PendingSends ++;
		}
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

	return rc;
}


VOID
ArpSDereferenceVc(
	IN	PARP_VC					Vc,
	IN	BOOLEAN					KillArpEntry,
	IN	BOOLEAN					bSendComplete
	)
{
	PINTF	pIntF = Vc->IntF;
	KIRQL	OldIrql;
	BOOLEAN	bInitiateClose = FALSE;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);	

	if (bSendComplete)
	{
		Vc->PendingSends--;
	}

	ASSERT (Vc->RefCount > 0);
	Vc->RefCount --;

	if (Vc->RefCount == 0)
	{
		PINTF	pIntF;

		ASSERT ((Vc->Flags & ARPVC_ACTIVE) == 0);
		ASSERT (Vc->ArpEntry == NULL);

		//
		// Do other cleanup here
		//
		pIntF = Vc->IntF;

		RemoveEntryList(&Vc->List);

		FREE_MEM(Vc);

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	
		ArpSDereferenceIntF(pIntF);
	}
	else
	{
		if (KillArpEntry)
		{
			DBGPRINT(DBG_LEVEL_WARN,
					("Cleaning dead vc from vc %lx, arpentry %lx\n", Vc, Vc->ArpEntry));
			Vc->ArpEntry = NULL;
		}

		if ((Vc->PendingSends == 0) &&
			(Vc->Flags & ARPVC_CLOSE_PENDING))
		{
			bInitiateClose = TRUE;
			Vc->Flags |= ARPVC_CLOSING;
		}

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

		if (bInitiateClose)
		{
			ArpSInitiateCloseCall(Vc);
		}
	}
}


VOID
ArpSSleep(
	IN	UINT				TimeInMs
	)
{
#define	NUM_100ns_PER_ms	-10000L
	KTIMER			SleepTimer;
	LARGE_INTEGER	TimerValue;
	NTSTATUS		Status;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_WARN,
			("=>ArpSSleep(%d)\n", TimeInMs));

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	KeInitializeTimer(&SleepTimer);

	TimerValue.QuadPart = Int32x32To64(TimeInMs, NUM_100ns_PER_ms);
	KeSetTimer(&SleepTimer,
			   TimerValue,
			   NULL);

	WAIT_FOR_OBJECT(Status, &SleepTimer, NULL);

	DBGPRINT(DBG_LEVEL_WARN,
			("ArpSSleep: woken up, Status 0x%x\n", Status));

//	ASSERT (Status == STATUS_TIMEOUT);
}


VOID
ArpSFreeGlobalData(
	VOID
	)
{
}


#if	DBG

VOID
ArpSDumpPacket(
	IN	PUCHAR					Packet,
	IN	UINT					PktLen
	)
{
	UINT	i;

	DBGPRINT(DBG_LEVEL_INFO, (" PacketDump: "));
	for (i = 0; i < PktLen; i++)
	{
		DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
				("%02x ", Packet[i]));
	}

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("\n"));
}

VOID
ArpSDumpAddress(
	IN	IPADDR					IpAddr,
	IN	PHW_ADDR				HwAddr,
	IN	PCHAR					String
	)
{
	UINT	i;

	DBGPRINT(DBG_LEVEL_INFO,
			(" %s IpAddr: ", String));
	ArpSDumpIpAddr(IpAddr, "");
	ArpSDumpAtmAddr(&HwAddr->Address, ", ");

	if (HwAddr->SubAddress != NULL)
	{
		ArpSDumpAtmAddr(HwAddr->SubAddress, "\tSub ");
	}
}

VOID
ArpSDumpIpAddr(
	IN	IPADDR					IpAddr,
	IN	PCHAR					String
	)
{
	PUCHAR	p = (PUCHAR)&IpAddr;

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
			("%d.%d.%d.%d%s", p[0], p[1], p[2], p[3], String));
}

VOID
ArpSDumpAtmAddr(
	IN	PATM_ADDRESS			AtmAddr,
	IN	PCHAR					String
	)
{
	UINT	i;

	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("%sAtmAddr (%s, %d): ",
			String,
			(AtmAddr->AddressType == ATM_E164) ? "E164" : "NSAP",
			AtmAddr->NumberOfDigits));
	for (i = 0; i < AtmAddr->NumberOfDigits; i++)
	{
		DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
				("%02x ", AtmAddr->Address[i]));
	}
	DBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("\n"));
}


#endif


VOID
ArpSSetupValidationCallParams(
		PREG_ADDR_CTXT  pRegAddrCtxt, // LOCKIN LOCKOUT (pIntF lock)
		PATM_ADDRESS 	pAtmAddr
		)
/*++

Routine Description:

	Sets up the call parameters for a validation call (call to verify that
	another server with the same address doesn't exist.).

Arguments:

	pRegAddrCtxt	Pointer to the context used to validate and register the address.
					pRegAddrCtxt->CallParams is filled with the call params.
	pAtmAddr		Destination address.

--*/
{
	NDIS_STATUS								Status;
	PINTF									pIntF;

	//
	//  Set of parameters for a MakeCall
	//
	PCO_CALL_PARAMETERS						pCallParameters;
	PCO_CALL_MANAGER_PARAMETERS				pCallMgrParameters;
	PQ2931_CALLMGR_PARAMETERS				pAtmCallMgrParameters;

	//
	//  All Info Elements that we need to fill:
	//
	Q2931_IE UNALIGNED *								pIe;
	AAL_PARAMETERS_IE UNALIGNED *						pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *				pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *		pBbc;
	ATM_BLLI_IE UNALIGNED *								pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *						pQos;

	//
	//  Total space requirements for the MakeCall
	//
	ULONG									RequestSize;

	pIntF = pRegAddrCtxt->pIntF;
	ASSERT(pIntF->pRegAddrCtxt == pRegAddrCtxt);

	//
	//  Zero out call params. Don't remove this!
	//
	ZERO_MEM(&pRegAddrCtxt->CallParams, sizeof(pRegAddrCtxt->CallParams));
	ZERO_MEM(&pRegAddrCtxt->Buffer, sizeof(pRegAddrCtxt->Buffer));

	//
	//  Distribute space amongst the various structures
	//
	pCallParameters	   = &pRegAddrCtxt->CallParams;
	pCallMgrParameters = &pRegAddrCtxt->CmParams;

	//
	//  Set pointers to link the above structures together
	//
	pCallParameters->CallMgrParameters = pCallMgrParameters;
	pCallParameters->MediaParameters = NULL;


	pCallMgrParameters->CallMgrSpecific.ParamType = 0;
	pCallMgrParameters->CallMgrSpecific.Length = 
						sizeof(Q2931_CALLMGR_PARAMETERS) +
						REGADDR_MAKE_CALL_IE_SPACE;

	pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
								pCallMgrParameters->CallMgrSpecific.Parameters;

	//
	//  Call Manager generic flow parameters:
	//
	pCallMgrParameters->Transmit.TokenRate = QOS_NOT_SPECIFIED;
	pCallMgrParameters->Transmit.TokenBucketSize = 9188;
	pCallMgrParameters->Transmit.MaxSduSize = 9188;
	pCallMgrParameters->Transmit.PeakBandwidth = QOS_NOT_SPECIFIED;
	pCallMgrParameters->Transmit.ServiceType =  SERVICETYPE_BESTEFFORT;

	pCallMgrParameters->Receive.TokenRate = QOS_NOT_SPECIFIED;
	pCallMgrParameters->Receive.TokenBucketSize = 9188;
	pCallMgrParameters->Receive.MaxSduSize = 9188;
	pCallMgrParameters->Receive.PeakBandwidth = QOS_NOT_SPECIFIED;
	pCallMgrParameters->Receive.ServiceType =  SERVICETYPE_BESTEFFORT;

	//
	//  Q2931 Call Manager Parameters:
	//

	//
	//  Called address:
	//
	COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CalledParty),
  				(PUCHAR)pAtmAddr,
  				sizeof(ATM_ADDRESS));

	//
	//  Calling address:
	//
	COPY_MEM((PUCHAR)&(pAtmCallMgrParameters->CallingParty),
  				(PUCHAR)&pIntF->ConfiguredAddress,
  				sizeof(ATM_ADDRESS));


	//
	//  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
	//  SETUP message, so fill them all.
	//
	//      AAL Parameters
	//      Traffic Descriptor (only for MakeCall)
	//      Broadband Bearer Capability (only for MakeCall)
	//      Broadband Low Layer Info
	//      QoS (only for MakeCall)
	//

	//
	//  Initialize the Info Element list
	//
	pAtmCallMgrParameters->InfoElementCount = 0;
	pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


	//
	//  AAL Parameters:
	//

	{
		UNALIGNED AAL5_PARAMETERS	*pAal5;

		pIe->IEType = IE_AALParameters;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
		pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
		pAalIe->AALType = AAL_TYPE_AAL5;
		pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
		pAal5->ForwardMaxCPCSSDUSize = 9188;
		pAal5->BackwardMaxCPCSSDUSize = 9188;
	}

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


	//
	//  Broadband Lower Layer Information
	//

	pIe->IEType = IE_BLLI;
	pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
	pBlli = (PATM_BLLI_IE)pIe->IE;
	COPY_MEM((PUCHAR)pBlli,
  				(PUCHAR)&ArpSDefaultBlli,
  				sizeof(ATM_BLLI_IE));

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

}


VOID
ArpSMakeRegAddrCallComplete(
	NDIS_STATUS Status,
	PREG_ADDR_CTXT  pRegAddrCtxt
	)
/*++

Routine Description:

	Completion handler for the validation call. On success we drop the call and
	and move on to the next address. On failure we go on to register this address
	with the switch. See  05/14/1999 notes.txt entry for the larger context.

Arguments:

	Status			MakeCall Completion status.
	pRegAddrCtxt	Pointer to the context used to validate and register the address.

--*/
{
	PINTF				pIntF;
	KIRQL 				OldIrql;

	pIntF = pRegAddrCtxt->pIntF;
	ASSERT(pIntF->pRegAddrCtxt == pRegAddrCtxt);

	DBGPRINT(DBG_LEVEL_INFO,
		 ("==>ArpSMakeRegAddrCallComplete. Status=0x%lx, pIntF=0x%p, pCtxt=0x%p\n",
		 	Status,
			pRegAddrCtxt->pIntF,
			pRegAddrCtxt
		));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(DBG_LEVEL_ERROR,
		 ("MakeRegAddrCallComplete: Successful call == failed validation; dropping call.\n"));

		if (pIntF->Flags & INTF_STOPPING)
		{
			//
			// When the IF is stopping, we can't rely on 
			// pIntF->RegAddresses to be still around...
			//
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		}
		else
		{
			ATM_ADDRESS AtmAddress;
			//
			// A successful make call is failed validation!
			// We log the event, drop the call. The drop call complete handler will
			// do the next thing, which is to move on to validating the next address.
			//
			AtmAddress =  pIntF->RegAddresses[pRegAddrCtxt->RegAddrIndex]; // struct copy
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			ArpSLogFailedRegistration(&AtmAddress);
		}


		Status = NdisClCloseCall(pRegAddrCtxt->NdisVcHandle, NULL, NULL, 0);
	
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseRegAddrCallComplete(Status, pRegAddrCtxt);
		}
	}
	else
	{
		//
		// A failed make call is considered a successful validation!
		// Delete VC and initiate registration of the address.
		//
		PNDIS_REQUEST		pNdisRequest;
		NDIS_HANDLE			NdisVcHandle;
		PATM_ADDRESS		pValidatedAddress;
		PCO_ADDRESS			pCoAddr;
	
		DBGPRINT(DBG_LEVEL_ERROR,
		 ("MakeRegAddrCallComplete: Failed call == successful validation; Adding address.\n"));

		ASSERT(pRegAddrCtxt->NdisVcHandle != NULL);
		NdisVcHandle =  pRegAddrCtxt->NdisVcHandle;
		pRegAddrCtxt->NdisVcHandle = NULL;
	
		if (pIntF->Flags & INTF_STOPPING)
		{
			// Oh oh, the IF is stopping -- we clean up the VC and call
			// ArpSValidateOneRegdAddress -- it will free  pRegAddrCtxt.
			// 
			//
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		
			if (NdisVcHandle != NULL)
			{
				(VOID)NdisCoDeleteVc(NdisVcHandle);
			}

			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		
			ArpSValidateOneRegdAddress(
					pIntF,
					OldIrql
					);
		}
		else
		{
			ASSERT(pRegAddrCtxt->RegAddrIndex < pIntF->NumAllocedRegdAddresses);
			pValidatedAddress = &(pIntF->RegAddresses[pRegAddrCtxt->RegAddrIndex]);
			pRegAddrCtxt->RegAddrIndex++;
	
			pNdisRequest = &pRegAddrCtxt->Request.NdisRequest;
			pNdisRequest->RequestType = NdisRequestSetInformation;
			pNdisRequest->DATA.SET_INFORMATION.Oid = OID_CO_ADD_ADDRESS;
			pNdisRequest->DATA.SET_INFORMATION.InformationBuffer
 										= (PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST);
			pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength
 										= sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS);
		
			//
			// Copy the address into the request
			//
			pCoAddr = pNdisRequest->DATA.SET_INFORMATION.InformationBuffer;
			pCoAddr->AddressSize = sizeof(ATM_ADDRESS);
			*(PATM_ADDRESS)(pCoAddr->Address) = *pValidatedAddress;
		
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		
			if (NdisVcHandle != NULL)
			{
				(VOID)NdisCoDeleteVc(NdisVcHandle);
			}
		
			Status = NdisCoRequest(pIntF->NdisBindingHandle,
								pIntF->NdisAfHandle,
								NULL,
								NULL,
								pNdisRequest);
			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSCoRequestComplete(Status, pIntF, NULL, NULL, pNdisRequest);
			}
		}
		
	}

	DBGPRINT(DBG_LEVEL_INFO,
		 ("<==ArpSMakeRegAddrCallComplete.\n"));
}


VOID
ArpSCloseRegAddrCallComplete(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	)
/*++

Routine Description:


	Completion handler for the NdisClCloseCall of validation call. Since this
	is a failed validation, we move on to validating/registration of the next
	address. See  05/14/1999 notes.txt entry for the larger context.

Arguments:

	Status			CloseCall Completion status (ignored).
	pRegAddrCtxt	Pointer to the context used to validate and register the address.

--*/
{
	KIRQL OldIrql;
	PINTF pIntF;
	NDIS_HANDLE		NdisVcHandle;

	DBGPRINT(DBG_LEVEL_INFO,
		 ("==>ArpSCloseRegAddrCallComplete. pIntF=0x%p, pCtxt=0x%p\n",
			pRegAddrCtxt->pIntF,
			pRegAddrCtxt
		));

	pIntF =  pRegAddrCtxt->pIntF;
	ASSERT(pIntF->pRegAddrCtxt == pRegAddrCtxt);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

    if (!(pIntF->Flags & INTF_STOPPING))
    {
        ASSERT(pRegAddrCtxt->RegAddrIndex < pIntF->NumAllocedRegdAddresses);
        pRegAddrCtxt->RegAddrIndex++;
    }

	ASSERT(pRegAddrCtxt->NdisVcHandle != NULL);
	NdisVcHandle =  pRegAddrCtxt->NdisVcHandle;
	pRegAddrCtxt->NdisVcHandle = NULL;
	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	if (NdisVcHandle != NULL)
	{
		(VOID)NdisCoDeleteVc(NdisVcHandle);
	}
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	ArpSValidateOneRegdAddress(
			pIntF,
			OldIrql
			);
	//
	// Lock released above.

	DBGPRINT(DBG_LEVEL_INFO, ("<==ArpSCloseRegAddrCallComplete\n"));
}


VOID
ArpSUnlinkRegAddrCtxt(
	PINTF			pIntF, 		// LOCKIN NOLOCKOUT
	KIRQL			OldIrql
	)
/*++

Routine Description:

	Deref pIntF, remove reference to pRegAddrCtxt = pIntF->pRegAddrCtxt, and
	free pIntF->pRegAddrCtxt. See  05/14/1999 notes.txt entry for the larger context.
	
	Must only be called AFTER all async activity relating to pRegAddrCtxt is
	over and  pRegAddrCtxt->NdisVcHandle is NULL.

Arguments:

	Status			CloseCall Completion status (ignored).
	pRegAddrCtxt	Pointer to the context used to validate and register the address.

--*/
{
	PREG_ADDR_CTXT		pRegAddrCtxt;
	DBGPRINT(DBG_LEVEL_INFO, ("==>ArpSUnlinkRegAddrCtxt\n"));

	pRegAddrCtxt = pIntF->pRegAddrCtxt;
	ASSERT(pRegAddrCtxt != NULL);
	ASSERT(pRegAddrCtxt->pIntF == pIntF);
	ASSERT(pRegAddrCtxt->NdisVcHandle == NULL);
	// TODO: -- flags.
	FREE_MEM(pRegAddrCtxt);
	pIntF->pRegAddrCtxt = NULL;

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);	

	ArpSDereferenceIntF(pIntF); // pRegAddrCtxt;

	DBGPRINT(DBG_LEVEL_INFO, ("<==ArpSUnlinkRegAddrCtxt\n"));
}


VOID
ArpSIncomingRegAddrCloseCall(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	)
/*++

Routine Description:

	Incoming close call handler for the validation call. Currently we do nothing
	with this. I don't see the need to do anything, because we don't keep
	the call up for an arbitrary length of time.

	However, if/when we decide to keep the call up so that we can try to
	re-validate after the call goes away, we'll need to do something here.

Arguments:

	Status			CloseCall Completion status (ignored).
	pRegAddrCtxt	Pointer to the context used to validate and register the address.

--*/
{
	DBGPRINT(DBG_LEVEL_INFO, ("<==>ArpSIncomingRegAddrCloseCall\n"));
}


VOID
ArpSLogFailedRegistration(
		PATM_ADDRESS pAtmAddress
	)
{
	WCHAR TxtAddress[2*ATM_ADDRESS_LENGTH+1];	// 2 chars per address byte plus null
	WCHAR *StringList[1];
	static ULONG SequenceId;

	//
	// Convert atm address to unicode...
	//
	{
		static PWSTR 	WHexChars = L"0123456789ABCDEF";
		PWSTR 			StrBuf;
		ULONG			Index;
		PWSTR			pWStr;
		PUCHAR			pAddr;
		UINT			Max;

		Max = pAtmAddress->NumberOfDigits;

		if (Max > ATM_ADDRESS_LENGTH)
		{
			Max = ATM_ADDRESS_LENGTH;
		}
	
		for (Index = 0, pWStr = TxtAddress, pAddr = pAtmAddress->Address;
			Index < Max;
			Index++, pAddr++)
		{
			*pWStr++ = WHexChars[(*pAddr)>>4];
			*pWStr++ = WHexChars[(*pAddr)&0xf];
		}

		*pWStr = L'\0';
	}

	StringList[0] = TxtAddress;

	(VOID) NdisWriteEventLogEntry(
				ArpSDriverObject,
				EVENT_ATMARPS_ADDRESS_ALREADY_EXISTS,
				SequenceId,				// Sequence
				1, 						// NumStrings
				&StringList,			// String list
				0,						// DataSize
				NULL					// Data
				);

	NdisInterlockedIncrement(&SequenceId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\intf.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    intf.h

Abstract:

    This file contains the per-adapter (LIS) interface definition.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_INTF_
#define	_INTF_

#define	SERVICE_NAME				L"AtmArpS"

#define	NUM_ARPS_DESC		128
#define	NUM_MARS_DESC		128
#define	MAX_DESC_MULTIPLE	10
#define	ARP_TABLE_SIZE		64		// Keep this as a power of 2. The ARP_HASH macro relies on it.
#define	MARS_TABLE_SIZE		32		// Keep this as a power of 2. The MARS_HASH macro relies on it.

#define	ARP_HASH(_ipaddr)			((((PUCHAR)&(_ipaddr))[3]) & (ARP_TABLE_SIZE - 1))
#define	MARS_HASH(_ipaddr)			((((PUCHAR)&(_ipaddr))[3]) & (MARS_TABLE_SIZE - 1))

typedef	struct _ArpVc		ARP_VC, *PARP_VC;
typedef	struct _REG_ADDR_CTXT	REG_ADDR_CTXT, *PREG_ADDR_CTXT;

//
// The protocol reserved area in the ndis packets.
//
typedef struct
{
	LIST_ENTRY			ReqList;	// For queuing the packet into the KQUEUE
	SINGLE_LIST_ENTRY	FreeList;	// For queuing the packet into the SLIST
	PARP_VC				Vc;			// Owning Vc in case of queued packet
	USHORT				Flags;		// Misc. other information
	USHORT				PktLen;		// Length of incoming packet
	union {
		PNDIS_PACKET	OriginalPkt;// When a packet is forwarded by the MARS
		PUCHAR			PacketStart;// For MARS Control packets
	};
} PROTOCOL_RESD, *PPROTOCOL_RESD;

#define	RESD_FLAG_MARS		0x0001	// Indicates that the packet is to be processed by MARS
#define	RESD_FLAG_MARS_PKT	0x0002	// Indicates that the packet is from the MARS pool
#define	RESD_FLAG_FREEBUF	0x0004	// Indicates that the buffer and associated memory must be
									// freed upon completion of the send.
#define RESD_FLAG_KILL_CCVC	0x0010	// This isn't part of a packet. This is used
									// to queue a request to abort ClusterControlVc.
#define	RESD_FROM_PKT(_Pkt)		(PPROTOCOL_RESD)((_Pkt)->ProtocolReserved)

typedef	UCHAR	ATM_ADDR_TYPE;

typedef struct _HwAddr
{
	ATM_ADDRESS			Address;
	PATM_ADDRESS		SubAddress;
} HW_ADDR, *PHW_ADDR;

#define	COMP_ATM_ADDR(_a1_, _a2_)	(((_a1_)->AddressType == (_a2_)->AddressType) &&						\
									 ((_a1_)->NumberOfDigits == (_a2_)->NumberOfDigits) &&					\
									 COMP_MEM((_a1_)->Address,												\
											  (_a2_)->Address,												\
											  (_a1_)->NumberOfDigits))

#define	COPY_ATM_ADDR(_d_, _s_)																				\
	{																										\
		(_d_)->AddressType = (_s_)->AddressType;															\
		(_d_)->NumberOfDigits = (_s_)->NumberOfDigits;														\
		COPY_MEM((_d_)->Address, (_s_)->Address, (_s_)->NumberOfDigits);									\
	}

#define	COMP_HW_ADDR(_a1_, _a2_)	(((_a1_)->Address.AddressType == (_a2_)->Address.AddressType) &&		\
									 ((_a1_)->Address.NumberOfDigits == (_a2_)->Address.NumberOfDigits) &&	\
									 COMP_MEM((_a1_)->Address.Address,										\
											  (_a2_)->Address.Address,										\
											  (_a1_)->Address.NumberOfDigits) && 							\
									 ((((_a1_)->SubAddress == NULL) && ((_a2_)->SubAddress == NULL)) ||		\
									  ((((_a1_)->SubAddress != NULL) && ((_a2_)->SubAddress != NULL)) &&	\
									   ((_a1_)->SubAddress->AddressType == (_a2_)->SubAddress->AddressType) &&\
									   ((_a1_)->SubAddress->NumberOfDigits == (_a2_)->SubAddress->NumberOfDigits) &&\
									   COMP_MEM((_a1_)->SubAddress->Address,								\
											    (_a2_)->SubAddress->Address,								\
											    (_a1_)->SubAddress->NumberOfDigits))))						\

#define	COPY_HW_ADDR(_d_, _s_)																				\
	{																										\
		(_d_)->Address.AddressType = (_s_)->Address.AddressType;											\
		(_d_)->Address.NumberOfDigits = (_s_)->Address.NumberOfDigits;										\
		COPY_MEM((_d_)->Address.Address, (_s_)->Address.Address, (_s_)->Address.NumberOfDigits);			\
		if ((_s_)->SubAddress != NULL)																		\
		{																									\
			(_d_)->SubAddress->AddressType = (_s_)->SubAddress->AddressType;								\
			(_d_)->SubAddress->NumberOfDigits = (_s_)->SubAddress->NumberOfDigits;							\
			COPY_MEM((_d_)->SubAddress->Address, (_s_)->SubAddress->Address, (_s_)->SubAddress->NumberOfDigits);\
		}																									\
	}

typedef struct _ENTRY_HDR
{
	VOID				*		Next;
	VOID				**		Prev;
} ENTRY_HDR, *PENTRY_HDR;

typedef	struct _ArpEntry
{
	ENTRY_HDR;
	HW_ADDR						HwAddr;				// HWADDR MUST FOLLOW ENTRY_HDR
	TIMER						Timer;
	IPADDR						IpAddr;
	PARP_VC						Vc;					// Pointer to the Vc (if active)
	UINT						Age;
} ARP_ENTRY, *PARP_ENTRY;

#define	FLUSH_TIME				60*MULTIPLIER		// 60 minutes in 15s units
#define	ARP_AGE					20*MULTIPLIER		// 20 minutes in 15s units
#define REDIRECT_INTERVAL		1*MULTIPLIER		// 1 minute

#define	ARP_BLOCK_VANILA		(ENTRY_TYPE)0
#define	ARP_BLOCK_SUBADDR		(ENTRY_TYPE)1
#define	MARS_CLUSTER_VANILA		(ENTRY_TYPE)2
#define	MARS_CLUSTER_SUBADDR	(ENTRY_TYPE)3
#define	MARS_GROUP				(ENTRY_TYPE)4
#define	MARS_BLOCK_ENTRY		(ENTRY_TYPE)5

#define	ARP_BLOCK_TYPES			(ENTRY_TYPE)6
#define	BLOCK_ALLOC_SIZE		PAGE_SIZE

typedef	UINT	ENTRY_TYPE;

typedef	struct _ArpBlock
{
	struct _ArpBlock *			Next;				// Link to next
	struct _ArpBlock **			Prev;				// Link to previous
	struct _IntF *				IntF;				// Back pointer to the interface
	ENTRY_TYPE					EntryType;			// ARP_BLOCK_XXX
	UINT						NumFree;			// # of free ArpEntries in this block
	PENTRY_HDR					FreeHead;			// Head of the list of free Arp Entries
} ARP_BLOCK, *PARP_BLOCK;


//
// Forward declaration
//
typedef struct _MARS_ENTRY	MARS_ENTRY, *PMARS_ENTRY;
typedef struct _MARS_VC MARS_VC, *PMARS_VC;
typedef struct _MARS_FLOW_SPEC MARS_FLOW_SPEC, *PMARS_FLOW_SPEC;
typedef struct _CLUSTER_MEMBER CLUSTER_MEMBER, *PCLUSTER_MEMBER;
typedef struct _MCS_ENTRY MCS_ENTRY, *PMCS_ENTRY;

//
// Flow Specifications for an ATM Connection. The structure
// represents a bidirectional flow.
//
typedef struct _MARS_FLOW_SPEC
{
	ULONG						SendBandwidth;		// Bytes/Sec
	ULONG						SendMaxSize;		// Bytes
	ULONG						ReceiveBandwidth;	// Bytes/Sec
	ULONG						ReceiveMaxSize;		// Bytes
	SERVICETYPE					ServiceType;

} MARS_FLOW_SPEC, *PMARS_FLOW_SPEC;
 


typedef struct _IntF
{
	struct _IntF *				Next;

	LONG						RefCount;
	ULONG						Flags;

	UNICODE_STRING				InterfaceName;		// Name of device bound to
	UNICODE_STRING				FriendlyName;		// Descriptive name of above
	UNICODE_STRING				FileName;			// Name of file where arp entries are stored
	UNICODE_STRING				ConfigString;		// Used to access registry

	//
	// Fields relating to NDIS.
	//
	NDIS_MEDIUM					SupportedMedium;	// For use in NdisOpenAdapter
	NDIS_HANDLE					NdisBindingHandle;	// Handle to the binding
	NDIS_HANDLE					NdisAfHandle;		// Handle to the registered Address Family
	union
	{
		NDIS_HANDLE				NdisSapHandle;		// Handle to the registered Sap
		NDIS_HANDLE				NdisBindContext;	// Valid only during BindAdapter call
	};

	CO_ADDRESS_FAMILY			AddrFamily;			// For use by NdisClOpenAddressFamily
	PCO_SAP						Sap;				// For use by NdisClRegisterSap

	LIST_ENTRY					InactiveVcHead;		// Created Vcs go here.
	LIST_ENTRY					ActiveVcHead;		// Vcs with active calls go here.
#if	DBG
	LIST_ENTRY					FreeVcHead;			// Freed Vcs go here - fo Debugging.
#endif
	UCHAR						SelByte;			// Read as part of the configuration
	USHORT						NumAllocedRegdAddresses;	// # of registered atm addresses on this i/f
	USHORT						NumAddressesRegd;	// # of atm addresses successfully registered on this i/f
	ATM_ADDRESS					ConfiguredAddress;	// Configured address for this port
	UINT						NumPendingDelAddresses; // Number of address pending deletion.
	PATM_ADDRESS				RegAddresses;		// Array of h/w addresses
	PREG_ADDR_CTXT				pRegAddrCtxt;		// Context used when registering
													// addresses.

	UINT						NumCacheEntries;
	PARP_ENTRY					ArpCache[ARP_TABLE_SIZE];
											// The list of arp entries that we know about
	ULONG						LastVcId;			// A server created id assigned to each incoming vc
	PTIMER						ArpTimer;			// Head of the timer-list for this interface
	KMUTEX						ArpCacheMutex;		// Protects the ArpCache and the ArpTimer
	KEVENT						TimerThreadEvent;	// Signal this to kill the timer thread

	TIMER						FlushTimer;			// Used to flush arp-cache to disk
	TIMER						BlockTimer;			// Used to age-out arp blocks
	PKEVENT						CleanupEvent;		// signalling when IntF is freed
	PKEVENT						DelAddressesEvent;	// signalling when addresses are deleted

	PARP_BLOCK					PartialArpBlocks[ARP_BLOCK_TYPES];
	PARP_BLOCK					UsedArpBlocks[ARP_BLOCK_TYPES];
	ARP_SERVER_STATISTICS		ArpStats;

	LARGE_INTEGER 				StatisticsStartTimeStamp;

	//
	// Fields used by MARS
	//
	PMARS_ENTRY					MarsCache[MARS_TABLE_SIZE];
	MARS_SERVER_STATISTICS		MarsStats;
	PCLUSTER_MEMBER				ClusterMembers;		// List of Cluster members
	ULONG						NumClusterMembers;	// Size of above list
	PMCS_ENTRY					pMcsList;			// MCS configuration
	PMARS_VC					ClusterControlVc;	// Outgoing PMP for MARS control
													// and MCS data
	INT							CCActiveParties;	// Number of connected members
	INT							CCAddingParties;	// Number of AddParty()'s pending
	INT							CCDroppingParties;	// Number of DropParty()'s pending
	LIST_ENTRY					CCPacketQueue;		// Packets queued for sending on
													// the above VC.
	ULONG						CSN;				// ClusterSequenceNumber
	USHORT						CMI;				// ClusterMemberId
	ULONG						MaxPacketSize;		// Supported by miniport
	NDIS_CO_LINK_SPEED			LinkSpeed;			// Supported by miniport
	struct _MARS_FLOW_SPEC		CCFlowSpec;			// Flow params for ClusterControlVc
	TIMER						MarsRedirectTimer;	// For periodic MARS_REDIRECT

	KSPIN_LOCK					Lock;
} INTF, *PINTF;

#define	INTF_ADAPTER_OPENED		0x00000001	// Set after OpenAdapterComplete runs
#define	INTF_AF_OPENED			0x00000002	// Set after OpenAfComplete runs
#define	INTF_SAP_REGISTERED		0x00000008	// Set after RegisterSapComplete runs
#define	INTF_ADDRESS_VALID		0x00000010	// Set after OID_CO_ADDRESS_CHANGE is notified

#define INTF_SENDING_ON_CC_VC	0x00001000	// Send in progress on ClusterControlVc
#define INTF_STOPPING			0x40000000	// StopInterface in progress
#define	INTF_CLOSING			0x80000000	// Set after CloseAdapterComplete runs

typedef	struct _ArpVc
{
	ULONG						VcType;		// Must be the first field in struct
	LIST_ENTRY					List;
	USHORT						RefCount;
	USHORT						Flags;
	ULONG						PendingSends;
	ULONG						VcId;
	NDIS_HANDLE					NdisVcHandle;
	PINTF						IntF;
	ULONG						MaxSendSize;// From AAL parameters
	PARP_ENTRY					ArpEntry;
	HW_ADDR						HwAddr;		// From CallingPartyAddress
} ARP_VC, *PARP_VC;

#define	ARPVC_ACTIVE				0x0001
#define	ARPVC_CALLPROCESSING		0x0002
#define ARPVC_CLOSE_PENDING			0x4000
#define	ARPVC_CLOSING				0x8000

//
// VC types:
// 
#define VC_TYPE_INCOMING			((ULONG)0)
#define VC_TYPE_MARS_CC				((ULONG)1)	// ClusterControlVc
#define VC_TYPE_CHECK_REGADDR		((ULONG)2)	// Transient vc to validate
												// a registered address.


#define	CLEANUP_DEAD_VC(_ArpEntry)														\
	{																					\
		if (((_ArpEntry)->Vc != NULL) && (((_ArpEntry)->Vc->Flags & ARPVC_ACTIVE) == 0))\
		{																				\
			PARP_VC	Vc = (_ArpEntry)->Vc;												\
																						\
			ArpSDereferenceVc(Vc, TRUE, FALSE);											\
			(_ArpEntry)->Vc = NULL;														\
		}																				\
	}


//
//  Rounded-off size of generic Q.2931 IE header
//
#define ROUND_OFF(_size)		(((_size) + 3) & ~0x4)

#define SIZEOF_Q2931_IE	 ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE	ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE	ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE			ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE			ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE			ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))


//
//  Total space required for Information Elements in an outgoing call.
//
#define REGADDR_MAKE_CALL_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )


// REG_ADDR_CTXT stores context relating to validating and registering the
// list of addresses that need to be explicitly registered. "Validating" consists
// of making a call to the address *before* registering, to make sure that
// no one *else* has registered the same address.
// See 05/14/1999 notes.txt entry for details.
//
typedef struct _REG_ADDR_CTXT
{
	ULONG				VcType;		// Must be the first field in struct
	NDIS_HANDLE			NdisVcHandle;	// NDIS VC handle used for makeing a call
										// to verify that the address is unused.

	ULONG				Flags;		// One or more of the following flags.
	#define	REGADDRCTXT_RESTART					0x0001
	#define	REGADDRCTXT_ABORT					0x0002
	#define	REGADDRCTXT_MAKECALL_PENDING		0x0004
	#define	REGADDRCTXT_CLOSECALL_PENDING		0x0008
	// TODO/WARNING -- the above flags are currently UNUSED.

	UINT				RegAddrIndex;	// Index of the address being registered.
	PINTF				pIntF;

	// Request is for setting up an ndis request to add (register) a local address.
	//
	struct
	{
		NDIS_REQUEST		NdisRequest;
		CO_ADDRESS			CoAddress;
		ATM_ADDRESS			AtmAddress;
	} Request;

	// CallParams and the following union are for setting up the validation call.
	//
	CO_CALL_PARAMETERS		CallParams;

	// Call manager parameters, plus extra space for the ATM-specific stuff...
	//
	union
	{
		CO_CALL_MANAGER_PARAMETERS 					CmParams;
		UCHAR	Buffer[	sizeof(CO_CALL_MANAGER_PARAMETERS)
			  + sizeof(Q2931_CALLMGR_PARAMETERS) +
			    REGADDR_MAKE_CALL_IE_SPACE];
	};

} REG_ADDR_CTXT, *PREG_ADDR_CTXT;


//
//  Temp structure used to store information read from the registry.
//
typedef struct _ATMARPS_CONFIG
{
	UCHAR						SelByte;			// Selector Byte
	USHORT						NumAllocedRegdAddresses;
	PATM_ADDRESS				RegAddresses;
	PMCS_ENTRY					pMcsList;			// MCS configuration

} ATMARPS_CONFIG, *PATMARPS_CONFIG;

//
// Some defaults
//
#define DEFAULT_SEND_BANDWIDTH		(ATM_USER_DATA_RATE_SONET_155*100/8)	// Bytes/sec
#define DEFAULT_MAX_PACKET_SIZE		9180	// Bytes

// Minimum tolerated MAX_PACKET_SIZE
//
#define ARPS_MIN_MAX_PKT_SIZE 9180	// Bytes


#endif	// _INTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\ioctl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

	ioctl.c

Abstract:

	This file contains the code to implement the IOCTL interface to the atmarp server.

Author:

	Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

	Kernel mode

Revision History:

--*/


#include <precomp.h>
#define	_FILENUM_		FILENUM_IOCTL

NTSTATUS
ArpSDispatch(
	IN	PDEVICE_OBJECT			pDeviceObject,
	IN	PIRP					pIrp
	)
/*++

Routine Description:

	Handler for the ioctl interface - not implemented yet.

Arguments:

	pDeviceObject	ARP Server device object
	pIrp			IRP

Return Value:

	STATUS_NOT_IMPLEMENTED currently
--*/
{
	PIO_STACK_LOCATION	pIrpSp;
	NTSTATUS			Status;
	static ULONG		OpenCount = 0;

	ARPS_PAGED_CODE( );

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0;

	switch (pIrpSp->MajorFunction)
	{
	  case IRP_MJ_CREATE:
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSDispatch: Open Handle\n"));

		InterlockedIncrement(&OpenCount);
		Status = STATUS_SUCCESS;
		break;

	  case IRP_MJ_CLOSE:
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSDispatch: Close Handle\n"));
		Status = STATUS_SUCCESS;
		break;

	  case IRP_MJ_DEVICE_CONTROL:
		Status =  ArpSHandleIoctlRequest(pIrp, pIrpSp);
		break;

	  case IRP_MJ_FILE_SYSTEM_CONTROL:
		Status = STATUS_NOT_IMPLEMENTED;
		break;

	  case IRP_MJ_CLEANUP:
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSDispatch: Cleanup Handle\n"));
		Status = STATUS_SUCCESS;
		InterlockedDecrement(&OpenCount);
		break;

	  case IRP_MJ_SHUTDOWN:
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSDispatch: Shutdown\n"));
		ArpSShutDown();
		Status = STATUS_SUCCESS;
		break;

	  default:
		Status = STATUS_NOT_IMPLEMENTED;
		break;
	}

	ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

	if (Status != STATUS_PENDING)
	{
		pIrp->IoStatus.Status = Status;
		IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
	}
	else
	{
		IoMarkIrpPending(pIrp);
	}

	return Status;
}


NTSTATUS
ArpSHandleIoctlRequest(
	IN	PIRP					pIrp,
	IN	PIO_STACK_LOCATION		pIrpSp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS			Status = STATUS_SUCCESS;
	PUCHAR				pBuf;  
	UINT				BufLen;
	PINTF				pIntF	= NULL;

	pIrp->IoStatus.Information = 0;
	pBuf = pIrp->AssociatedIrp.SystemBuffer;
	BufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

	switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
	{
	  case ARPS_IOCTL_FLUSH_ARPCACHE:
	  case ARPS_IOCTL_QUERY_ARPCACHE:
	  case ARPS_IOCTL_ADD_ARPENTRY:
	  case ARPS_IOCTL_QUERY_IP_FROM_ATM:
	  case ARPS_IOCTL_QUERY_ATM_FROM_IP:
	  case ARPS_IOCTL_QUERY_ARP_STATISTICS:
	  case ARPS_IOCTL_QUERY_MARSCACHE:
	  case ARPS_IOCTL_QUERY_MARS_STATISTICS:
	  case ARPS_IOCTL_RESET_STATISTICS:
		{
			INTERFACE_NAME		RawName;
			UINT				Offset;

			if (pIrpSp->Parameters.DeviceIoControl.IoControlCode == ARPS_IOCTL_QUERY_ARPCACHE)
			{
				Offset = FIELD_OFFSET(IOCTL_QUERY_CACHE, Name);
			}
			else if (pIrpSp->Parameters.DeviceIoControl.IoControlCode == ARPS_IOCTL_QUERY_MARSCACHE)
			{
				Offset = FIELD_OFFSET(IOCTL_QUERY_MARS_CACHE, Name);
			}
			else
			{
				Offset = 0;
			}

			if (BufLen < sizeof(INTERFACE_NAME) + Offset)
			{
				return STATUS_INVALID_PARAMETER;
			}

			RawName = *(PINTERFACE_NAME)((PUCHAR)pBuf + Offset);
			RawName.Buffer = (PWSTR)(pBuf + Offset + (ULONG_PTR)RawName.Buffer); // fixup ptr

			//
			// Probe away...
			//
			if ( 	(PUCHAR)RawName.Buffer < (pBuf+sizeof(INTERFACE_NAME))
				||	(PUCHAR)RawName.Buffer >= (pBuf+BufLen)
				||	((PUCHAR)RawName.Buffer + RawName.Length) > (pBuf+BufLen))
			{
				return STATUS_INVALID_PARAMETER;
			}
	
			pIntF = ArpSReferenceIntFByName(&RawName);

			if (pIntF == NULL)
			{
				return STATUS_NOT_FOUND;
			}

		}
		break;
	}
	
	switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
	{
	  case ARPS_IOCTL_QUERY_INTERFACES:
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_INTERFACES\n"));
		pIrp->IoStatus.Information = BufLen;
		Status = ArpSEnumerateInterfaces(pBuf, &pIrp->IoStatus.Information);
		break;
	
	  case ARPS_IOCTL_FLUSH_ARPCACHE:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
					("ArpSHandleIoctlRequest: FLUSH_ARPCACHE on %Z\n",
 					 &pIntF->FriendlyName));
		Status = ArpSFlushArpCache(pIntF);
		pIrp->IoStatus.Information = 0;
		break;
	
	  case ARPS_IOCTL_QUERY_ARPCACHE:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_ARPCACHE on %Z\n",
				 &pIntF->FriendlyName));
		pIrp->IoStatus.Information = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
		Status = ArpSQueryArpCache(pIntF, pBuf, &pIrp->IoStatus.Information);
		break;

#if 0
	//
	//  These need more work - commented out as they aren't critical.
	//
	  case ARPS_IOCTL_ADD_ARPENTRY:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_ADD_ARPENTRY on %Z\n",
				 &pIntF->FriendlyName));

		Status = ArpSQueryOrAddArpEntry(pIntF, (PIOCTL_QA_ENTRY)pBuf, ADD_ARP_ENTRY);
		break;
	
	  case ARPS_IOCTL_QUERY_IP_FROM_ATM:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_IP_ADDR on %Z\n",
				  &pIntF->FriendlyName));

		Status = ArpSQueryOrAddArpEntry(pIntF, (PIOCTL_QA_ENTRY)pBuf, QUERY_IP_FROM_ATM);
		if (Status == STATUS_SUCCESS)
		{
			pIrp->IoStatus.Information = sizeof(IOCTL_QA_ENTRY);
		}
		break;
	
	  case ARPS_IOCTL_QUERY_ATM_FROM_IP:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_ATM_ADDR on %Z\n",
				 pIntF->FriendlyName));
		Status = ArpSQueryOrAddArpEntry( pIntF, (PIOCTL_QA_ENTRY)pBuf, QUERY_ATM_FROM_IP );
		if (Status == STATUS_SUCCESS)
		{
			pIrp->IoStatus.Information = sizeof(IOCTL_QA_ENTRY);
		}
		break;
#endif // 0

	  case ARPS_IOCTL_QUERY_ARP_STATISTICS:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_ARP_STATS on %Z\n",
				 pIntF->FriendlyName));

		if (BufLen<sizeof(ARP_SERVER_STATISTICS))
		{
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = ArpSQueryArpStats( pIntF, (PARP_SERVER_STATISTICS)pBuf);
		if (Status == STATUS_SUCCESS)
		{
			pIrp->IoStatus.Information = sizeof(ARP_SERVER_STATISTICS);
		}
	  	break;

	  case ARPS_IOCTL_QUERY_MARSCACHE:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_MARSCACHE on %Z\n",
				 &pIntF->FriendlyName));
		pIrp->IoStatus.Information = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
		Status = ArpSQueryMarsCache(pIntF, pBuf, &pIrp->IoStatus.Information);
		break;

	  case ARPS_IOCTL_QUERY_MARS_STATISTICS:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: QUERY_MARS_STATS on %Z\n",
				 pIntF->FriendlyName));

		if (BufLen<sizeof(MARS_SERVER_STATISTICS))
		{
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = ArpSQueryMarsStats( pIntF, (PMARS_SERVER_STATISTICS)pBuf);
		if (Status == STATUS_SUCCESS)
		{
			pIrp->IoStatus.Information = sizeof(MARS_SERVER_STATISTICS);
		}
	  	break;
	
	  case ARPS_IOCTL_RESET_STATISTICS:
		ASSERT (pIntF);
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: RESET_STATISTICS on %Z\n",
				 pIntF->FriendlyName));

		ArpSResetStats(pIntF);
		pIrp->IoStatus.Information = 0;
	  	break;

	  default:
		Status = STATUS_NOT_SUPPORTED;
		DBGPRINT(DBG_LEVEL_NOTICE,
				("ArpSHandleIoctlRequest: Unknown request %lx\n",
				  pIrpSp->Parameters.DeviceIoControl.IoControlCode));
		break;
	}

	if (pIntF != NULL)
	{
		ArpSDereferenceIntF(pIntF);
	}
	
	return Status;
}

NTSTATUS
ArpSEnumerateInterfaces(
	IN		PUCHAR				pBuffer,
	IN OUT	PULONG_PTR			pSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTERFACES		pInterfaces = (PINTERFACES)pBuffer;
	PINTERFACE_NAME	pInterface;
	NTSTATUS		Status = STATUS_SUCCESS;
	PINTF			pIntF;
	KIRQL			OldIrql;
	UINT			Size, Total, Remaining;
	PUCHAR			pBuf;
	UINT			InputSize = (UINT) *pSize;
	ULONG			IfIndex;

	if (InputSize < sizeof(INTERFACES))
	{
		return STATUS_BUFFER_TOO_SMALL;
	}

	pInterfaces->NumberOfInterfaces = 0;
	pBuf = (PUCHAR)pInterfaces + InputSize;

	ACQUIRE_SPIN_LOCK(&ArpSIfListLock, &OldIrql);

	pInterface = &pInterfaces->Interfaces[0];
	for (pIntF = ArpSIfList, Total = 0, Remaining = InputSize, IfIndex = 1;
		 pIntF != NULL;
		 pIntF = pIntF->Next, pInterface++, IfIndex++)
	{
		if (IfIndex > ArpSIfListSize)
		{
			DbgPrint("ATMARPS: EnumInt: IF list at %p not consistent with list size %d\n",
				ArpSIfList, ArpSIfListSize);
			DbgBreakPoint();
			break;
		}

		Size = sizeof(INTERFACE_NAME) + pIntF->FriendlyName.Length;
		if (Size > Remaining)
		{
			Status = STATUS_BUFFER_OVERFLOW;
			break;
		}
		pInterfaces->NumberOfInterfaces ++;
		pInterface->MaximumLength = pInterface->Length = pIntF->FriendlyName.Length;
		pInterface->Buffer = (PWSTR)(pBuf - pIntF->FriendlyName.Length);
		COPY_MEM(pInterface->Buffer, pIntF->FriendlyName.Buffer, pIntF->FriendlyName.Length);
		pBuf -= pIntF->FriendlyName.Length;
		Total += Size;
		Remaining -= Size;

		//
		// Convert the ptr now to an offset
		//
		pInterface->Buffer = (PWSTR)((ULONG_PTR)pInterface->Buffer - (ULONG_PTR)pInterface);
	}

	RELEASE_SPIN_LOCK(&ArpSIfListLock, OldIrql);

	//
	// Note: leave *pSize as is, because we write at the end of the
	// passed-in buffer.
	//

	return Status;
}


NTSTATUS
ArpSFlushArpCache(
	IN	 PINTF					pIntF
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PARP_ENTRY		ArpEntry, NextArpEntry;
	KIRQL			OldIrql;
	UINT			i;

	//
	// Acquire the ArpCache mutex now.
	//
	WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);
	ASSERT (Status == STATUS_SUCCESS);

	for (i = 0; i < ARP_TABLE_SIZE; i++)
	{
		for (ArpEntry = pIntF->ArpCache[i];
 			ArpEntry != NULL;
 			ArpEntry = NextArpEntry)
		{
			NextArpEntry = ArpEntry->Next;

			if (ArpEntry->Vc != NULL)
			{
				ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

				ArpEntry->Vc->ArpEntry = NULL;

				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			}

			if (ArpEntry->Next != NULL)
			{
				((PENTRY_HDR)(ArpEntry->Next))->Prev = ArpEntry->Prev;
			}
			*(ArpEntry->Prev) = ArpEntry->Next;
			ArpSFreeBlock(ArpEntry);
			pIntF->NumCacheEntries --;
		}
	}

	RELEASE_MUTEX(&pIntF->ArpCacheMutex);

	return Status;
}


NTSTATUS
ArpSQueryOrAddArpEntry(
	IN	 PINTF						pIntF,
	IN	OUT	PIOCTL_QA_ENTRY			pQaBuf,
	IN	OPERATION					Operation
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PARP_ENTRY		ArpEntry;

	//
	// Acquire the ArpCache mutex now.
	//
	WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);
	ASSERT (Status == STATUS_SUCCESS);

	switch (Operation)
	{
  	case QUERY_IP_FROM_ATM:

		if (   !ArpSValidAtmAddress(&pQaBuf->ArpEntry.AtmAddress, 0) // TODO
			|| !ArpSValidAtmAddress(&pQaBuf->ArpEntry.SubAddress, 0)) // TODO
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("QueryIpAddress: Invalid address or subaddress\n"));
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		DBGPRINT(DBG_LEVEL_NOTICE,
				("QueryIpAddress for "));

		ArpSDumpAtmAddr(&pQaBuf->ArpEntry.AtmAddress, "");
		if (pQaBuf->ArpEntry.SubAddress.NumberOfDigits != 0)
			ArpSDumpAtmAddr(&pQaBuf->ArpEntry.SubAddress, "\tSub");
		ArpEntry = ArpSLookupEntryByAtmAddr(pIntF,
											&pQaBuf->ArpEntry.AtmAddress,
											(pQaBuf->ArpEntry.SubAddress.NumberOfDigits != 0) ?
												&pQaBuf->ArpEntry.SubAddress : NULL);
		Status = STATUS_NOT_FOUND;
		if (ArpEntry != NULL)
		{
			pQaBuf->ArpEntry.IpAddr = ArpEntry->IpAddr;
			Status = STATUS_SUCCESS;
		}
		break;

  	case QUERY_ATM_FROM_IP:
		DBGPRINT(DBG_LEVEL_NOTICE,
				("QueryAtmAddress for "));
		ArpSDumpIpAddr(pQaBuf->ArpEntry.IpAddr, "");
		ArpEntry = ArpSLookupEntryByIpAddr(pIntF, pQaBuf->ArpEntry.IpAddr);
		Status = STATUS_NOT_FOUND;
		if (ArpEntry != NULL)
		{
			COPY_ATM_ADDR(&pQaBuf->ArpEntry.AtmAddress, &ArpEntry->HwAddr.Address);
			Status = STATUS_SUCCESS;
		}
		break;

#if 0
  	case ADD_ARP_ENTRY:

		if (   !ArpSValidAtmAddress(&pQaBuf->ArpEntry.AtmAddress, 0) // TODO
			|| !ArpSValidAtmAddress(&pQaBuf->ArpEntry.SubAddress, 0)) // TODO
		{
			DBGPRINT(DBG_LEVEL_ERROR,
					("AddArpEntry: Invalid address or subaddress\n"));
			Status = STATUS_INVALID_PARAMETER;
			break;
		}

		DBGPRINT(DBG_LEVEL_NOTICE, ("AddArpEntry:  IpAddr "));
		ArpSDumpIpAddr(pQaBuf->ArpEntry.IpAddr, "");
		ArpSDumpAtmAddr(&pQaBuf->ArpEntry.AtmAddress, "");
		if (pQaBuf->ArpEntry.SubAddress.NumberOfDigits != 0)
			ArpSDumpAtmAddr(&pQaBuf->ArpEntry.SubAddress, "\tSub");
		ArpEntry = ArpSAddArpEntry(pIntF,
   								pQaBuf->ArpEntry.IpAddr,
   								&pQaBuf->ArpEntry.AtmAddress,
   								(pQaBuf->ArpEntry.SubAddress.NumberOfDigits != 0) ?
										&pQaBuf->ArpEntry.SubAddress : NULL,
   								NULL);
#endif // 0
		break;

  	default:
		Status = STATUS_NOT_SUPPORTED;
		break;
	}

	RELEASE_MUTEX(&pIntF->ArpCacheMutex);

	return Status;
}


NTSTATUS
ArpSQueryArpCache(
	IN	PINTF					pIntF,
	IN	PUCHAR					pBuf,
	IN OUT PULONG_PTR			pSize
	)
{
	NTSTATUS			Status = STATUS_SUCCESS;
    PIOCTL_QUERY_CACHE	pQCache = (PIOCTL_QUERY_CACHE)pBuf;
	PARP_ENTRY			ArpEntry;
	PARPENTRY			Entry;
	UINT				i, Total, Remaining;
	UINT				InputSize = (UINT) *pSize;
	UINT				StartIndex;

	#define HEADERSIZE  (UINT)FIELD_OFFSET(IOCTL_QUERY_CACHE, Entries.Entries)

	if (InputSize < HEADERSIZE)
	{
		//
		// We don't even have enough space to store the
		// IOCTL_QUERY_CACHE.Entries structure!
		//
		return STATUS_BUFFER_TOO_SMALL;
	}

	//
	// Acquire the ArpCache mutex now.
	//
	WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);
	ASSERT (Status == STATUS_SUCCESS);

	StartIndex = pQCache->StartEntryIndex;
	pQCache->Entries.TotalNumberOfEntries = pIntF->NumCacheEntries;
	pQCache->Entries.NumberOfEntriesInBuffer = 0;
	Entry = &pQCache->Entries.Entries[0];

	for (i = 0, Total = 0, Remaining = InputSize - HEADERSIZE;
		 i < ARP_TABLE_SIZE;
		 i++)
	{
		for (ArpEntry = pIntF->ArpCache[i];
 			ArpEntry != NULL;
 			ArpEntry = ArpEntry->Next)
		{
			//
			// Skip entries until we reach entry # StartIndex
			//
			if (StartIndex != 0)
			{
				StartIndex--;
				continue;
			}

			if (sizeof(*Entry) > Remaining)
			{
				break;
			}
			Remaining -= sizeof(ARPENTRY);
			Entry->IpAddr = ArpEntry->IpAddr;
			Entry->AtmAddress = ArpEntry->HwAddr.Address;
			Entry->SubAddress.NumberOfDigits = 0;
			if (ArpEntry->HwAddr.SubAddress != NULL)
				Entry->SubAddress = *ArpEntry->HwAddr.SubAddress;
			pQCache->Entries.NumberOfEntriesInBuffer ++;
			Entry ++;
		}
		if (Status == STATUS_BUFFER_OVERFLOW)
			break;
	}

	RELEASE_MUTEX(&pIntF->ArpCacheMutex);

	return Status;
}


NTSTATUS
ArpSQueryMarsCache(
	IN	PINTF					pIntF,
	IN	PUCHAR					pBuf,
	IN OUT PULONG_PTR			pSize
	)
/*++

Routine Description:

	Dump the mars cache into pBuf. The structure is QUERY_MARS_CACHE.MarsCache.
	The atm addresses are all placed together at the end of the supplied buffer,
	so the full size, *pSize, is used.

Arguments:

	pIntF	- The interface on which the MARS_REQUEST arrived
	Vc		- The VC on which the packet arrived
	Header	- Points to the request packet
	Packet	- Packet where the incoming information is copied

Return Value:

	None


--*/
{
	NTSTATUS			Status = STATUS_SUCCESS;
	PMARS_ENTRY		pMarsEntry;
	PMARSENTRY		pEntry;
	UINT			i, Total, Remaining;
	KIRQL			OldIrql;
	ATM_ADDRESS 	*pAtmAddr;
	UINT		    InputSize;
	UINT			StartIndex;

    PIOCTL_QUERY_MARS_CACHE	pQCache = (PIOCTL_QUERY_MARS_CACHE)pBuf;

	#define MCHEADERSIZE \
			 ((UINT)FIELD_OFFSET(IOCTL_QUERY_MARS_CACHE, MarsCache.Entries))

	//
	// Since we put stuff at the end of the buffer, let's force the
	// size to be a multiple of ULONG_PTR size.
	//
	InputSize = (UINT)(*pSize) & ~ ((UINT) (sizeof(ULONG_PTR)-1));

	DBGPRINT(DBG_LEVEL_NOTICE,
			("QueryMarsCache: pBuf=0x%lx Size=%lu. pBuf+Size=0x%lx\n",
			pBuf,
			InputSize,
			pBuf+InputSize
			));


	if (InputSize < MCHEADERSIZE)
	{
		DBGPRINT(DBG_LEVEL_NOTICE,
				("QueryMarsCache: Size %lu too small. Want %lu\n",
				InputSize,
				MCHEADERSIZE
				));
		//
		// We don't even have enough space to store the
		// IOCTL_QUERY_CACHE.Entries structure!
		//
		return STATUS_BUFFER_TOO_SMALL;
	}

	StartIndex = pQCache->StartEntryIndex;

	// Acquire the lock on the interface now
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);


	pQCache->MarsCache.TotalNumberOfEntries = 0;
	pQCache->MarsCache.Sig = SIG_MARSENTRY;
	pQCache->MarsCache.NumberOfEntriesInBuffer = 0;
	pEntry = &pQCache->MarsCache.Entries[0];

	//
	// We'll go through the entire cache, but only pick up as many
	// as we have space for. pAtmAddr contains the next location to
	// put an atm address -- it starts out at the end of the buffer and
	// works it's way backwards. Meanwhile, the mars entries are growing
	// forward, starting with pQCache->MarseCache.Entries[1].
	// Needless to say, we must keep track of how much space is left.
	//
	pAtmAddr = ((PATM_ADDRESS) (pBuf + InputSize));


	for (i = 0, Total = 0, Remaining = InputSize-MCHEADERSIZE;
		 i < MARS_TABLE_SIZE &&  Status == STATUS_SUCCESS;
		 i++)
	{
		for (pMarsEntry = pIntF->MarsCache[i];
			pMarsEntry != NULL &&  Status == STATUS_SUCCESS;
			pMarsEntry = pMarsEntry->Next)
		{
			PGROUP_MEMBER pGroup;
			UINT		  NumMembersPickedUp=0;

			//
			// Skip entries until we reach entry # StartIndex
			//
			if (StartIndex != 0)
			{
				StartIndex--;
				continue;
			}

			if (sizeof(*pEntry) > Remaining)
			{
				DBGPRINT(
					DBG_LEVEL_NOTICE,
				("QueryMarsCache: \tOut of space. Remaining=%lu\n", Remaining));
				break;
			}


			DBGPRINT(
				DBG_LEVEL_NOTICE,
			("QueryMarsCache: \tPicking up Group 0x%x. IP=0x%08lx NumAddr=%lu pE=0x%x Remaining=%lu\n",
					pMarsEntry,
					pMarsEntry->IPAddress,
					pMarsEntry->NumMembers,
					pEntry,
					Remaining));


			Remaining -= sizeof(*pEntry);

			pQCache->MarsCache.NumberOfEntriesInBuffer ++;
			GETULONG2ULONG(&(pEntry->IpAddr), &(pMarsEntry->IPAddress));
			pEntry->Flags				= 0;
			pEntry->NumAtmAddresses		=  pMarsEntry->NumMembers;
			pEntry->OffsetAtmAddresses	= 0;

			if (MarsIsAddressMcsServed(pIntF, pMarsEntry->IPAddress))
			{
				pEntry->Flags |=  MARSENTRY_MCS_SERVED;
			}

			//
			// Pick up the HW addresses of all the members of this group.
			// (TODO: We don't pick up the subaddress).
			//
			for (
				pGroup = pMarsEntry->pMembers, NumMembersPickedUp=0;
				pGroup != NULL;
				pGroup = pGroup->Next, NumMembersPickedUp++)
			{
				ARPS_ASSERT(pGroup != NULL_PGROUP_MEMBER);

				//
				// Check that we have enough space.
				//
				if (Remaining < sizeof(*pAtmAddr))
				{
					//
					// If there is not enough space to store all atm addresses
					// of a particular group, we return none, this is indicated
					// by setting pEntry->OffsetAtmAdresses to 0.
					//
				DBGPRINT(
					DBG_LEVEL_NOTICE,
					("QueryMarsCache: \t\tOut of space adding addreses. Remaining=%lu\n", Remaining));
					Status = STATUS_BUFFER_OVERFLOW;
					break;
				}
				ARPS_ASSERT( (PUCHAR)(pAtmAddr-1) >= (PUCHAR)(pEntry+1));

				//
				// Copy over the atm address
				//
				DBGPRINT(
					DBG_LEVEL_NOTICE,
			("QueryMarsCache: \t\tPicking up Addr. pDestAddr=%x. Remaining=%lu\n",
					pAtmAddr-1,
					Remaining));
				*--pAtmAddr = pGroup->pClusterMember->HwAddr.Address;
				Remaining -= sizeof(*pAtmAddr);

			}

			if (Status == STATUS_SUCCESS && NumMembersPickedUp)
			{
				//
				// There are non-zero members of this entry and they were
				// all copied successfully. Let's set the offset to these
				// addresses.
				//
				pEntry->OffsetAtmAddresses = 
									(UINT) ((PUCHAR)pAtmAddr - (PUCHAR) pEntry);

				//
				// We expect NumMembersPickedUp to be equal to
				// pMarsEntry->NumMembers.
				//
				ARPS_ASSERT(pMarsEntry->NumMembers == NumMembersPickedUp);

				if (pMarsEntry->NumMembers != NumMembersPickedUp)
				{
					pEntry->NumAtmAddresses	=  NumMembersPickedUp;
				}

				DBGPRINT(
					DBG_LEVEL_NOTICE,
			("QueryMarsCache: \t Picked up all addresses. OffsetAtmAddresses = %lu\n",
					 pEntry->OffsetAtmAddresses));

				pEntry++;

			}

		}

	}
	pQCache->MarsCache.TotalNumberOfEntries = 
		pQCache->MarsCache.NumberOfEntriesInBuffer; // TODO

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return Status;
}

UINT
ArpSElapsedSeconds(
	IN	PLARGE_INTEGER 			pStatisticsStartTimeStamp
	)
/*++

Routine Description:

	Return the elapsed time, in seconds, relative to *pStatisticsStartTimeStamp

Arguments:

	pStatisticsStartTimeStamp	ptr to the start time.

Return Value:

	None

--*/
{
	UINT Ret;
	LARGE_INTEGER	Current;
 	NdisGetCurrentSystemTime(&Current);

	//
	// Current is in units of 100-nanoseconds so we must convert the difference
	// to seconds. Note we use implicit large-arithmetic operators here.
	//
	Ret = (UINT) ((Current.QuadPart - pStatisticsStartTimeStamp->QuadPart)/10000000);

	return Ret;
}

extern
NTSTATUS
ArpSQueryArpStats(
	IN	PINTF					pIntF,
	OUT	PARP_SERVER_STATISTICS 	pArpStats
	)
/*++

Routine Description:

	Fill in the current arp statistics. Also set the ElapsedSeconds field
	to the time in seconds since statistics computation started.

Arguments:

	pIntF		- The interface applicable to the request
	pArpStats	- Arp statistics to fill out

Return Value:

	STATUS_SUCCESS	

--*/
{
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	*pArpStats = pIntF->ArpStats; // big structure copy.

	pArpStats->ElapsedSeconds = ArpSElapsedSeconds(
										&(pIntF->StatisticsStartTimeStamp)
										);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return STATUS_SUCCESS;
}

extern
NTSTATUS
ArpSQueryMarsStats(
	IN	PINTF					pIntF,
	OUT	PMARS_SERVER_STATISTICS pMarsStats
	)
/*++

Routine Description:

	Fill in the current mars statistics. Also set the ElapsedSeconds field
	to the time in seconds since statistics computation started.

Arguments:

	pIntF		- The interface applicable to the request
	pMarsStats	- Mars statistics to fill out.

Return Value:

	STATUS_SUCCESS	

--*/
{
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	*pMarsStats = pIntF->MarsStats; // big structure copy.

	pMarsStats->ElapsedSeconds = ArpSElapsedSeconds(
										&(pIntF->StatisticsStartTimeStamp)
										);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return STATUS_SUCCESS;
}

extern
VOID
ArpSResetStats(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Reset all arp and mars statistics. Update the statistics start timestamp.

Arguments:

	pIntF	- The interface on which the MARS_REQUEST arrived

Return Value:

	None

--*/
{
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	ZERO_MEM(&(pIntF->ArpStats), sizeof(pIntF->ArpStats));
	ZERO_MEM(&(pIntF->MarsStats), sizeof(pIntF->MarsStats));

	NdisGetCurrentSystemTime(&(pIntF->StatisticsStartTimeStamp));

	//
	// Now recompute the "current" and "max" values...
	//

	//
	// Arp cache entries
	//
	pIntF->ArpStats.CurrentArpEntries
	= pIntF->ArpStats.MaxArpEntries
	= pIntF->NumCacheEntries;

	//
	// Cluster member count
	//
	{
		pIntF->MarsStats.CurrentClusterMembers
		= pIntF->MarsStats.MaxClusterMembers
		= pIntF->NumClusterMembers;
	}

	//
	// MCast group count and max group-size - we have to go through the entire
	// mars cache to get this information.
	//
	{
		UINT u;
		UINT MaxGroupSize;
		UINT NumGroups;
	
		for (u = 0, MaxGroupSize = 0, NumGroups = 0;
			u < MARS_TABLE_SIZE;
			u++)
		{
			PMARS_ENTRY		pMarsEntry;

			for (pMarsEntry = pIntF->MarsCache[u];
				pMarsEntry != NULL;
				pMarsEntry = pMarsEntry->Next)
			{
				if (MaxGroupSize < pMarsEntry->NumMembers)
				{
					MaxGroupSize = pMarsEntry->NumMembers;
				}
				NumGroups++;
			}
		}

		pIntF->MarsStats.CurrentGroups
		= pIntF->MarsStats.MaxGroups
		= NumGroups;

		pIntF->MarsStats.MaxAddressesPerGroup = MaxGroupSize;

	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\mars.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

	mars.c

Abstract:

	This file contains the code to implement the functionality of
	Multicast Address Resolution Server (MARS), and a minimal
	MultiCast Server (MCS).

	Reference: RFC 2022

Author:

	Jameel Hyder (jameelh@microsoft.com)	January 1997

Environment:

	Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_MARS


#define MARS_CO_SEND_PACKETS(_Vc, _PktArray, _PktCount)							\
{																				\
	ULONG			_Count;														\
	NDIS_HANDLE		_NdisVcHandle = (_Vc)->NdisVcHandle;						\
																				\
	if (_NdisVcHandle != NULL)													\
	{																			\
		NdisCoSendPackets(_NdisVcHandle, _PktArray, _PktCount);					\
	}																			\
	else																		\
	{																			\
		for (_Count = 0; _Count < _PktCount; _Count++)							\
		{																		\
			ArpSCoSendComplete(NDIS_STATUS_FAILURE, _Vc, _PktArray[_Count]);	\
		}																		\
	}																			\
}

VOID
MarsReqThread(
	IN	PVOID					Context
	)
/*++

Routine Description:

	Handle all MARS requests here.

Arguments:

	None

Return Value:

	None
--*/
{
	PMARS_HEADER		Header;
	PLIST_ENTRY			List;
	PNDIS_PACKET		Pkt;
	PPROTOCOL_RESD		Resd;
	PARP_VC				Vc;
	UINT				PktLen;
	PINTF				pIntF;

	ARPS_PAGED_CODE( );

	MARSDBGPRINT(DBG_LEVEL_INFO,
			("MarsReqThread: Came to life\n"));

	do
	{
		List = KeRemoveQueue(&MarsReqQueue, KernelMode, NULL);
		if (List == &ArpSEntryOfDeath)
		{
			//
			// Asked to terminate, do so.
			//
			break;
		}

		Resd = CONTAINING_RECORD(List, PROTOCOL_RESD, ReqList);
		if (Resd->Flags & RESD_FLAG_KILL_CCVC)
		{
			pIntF = (PINTF)Resd->Vc;
			MARSDBGPRINT(DBG_LEVEL_NOTICE,
				("MARS Thread: will kill CCVC on pIntF %x\n", pIntF));
			FREE_MEM(Resd);
			MarsAbortAllMembers(pIntF);
			continue;
		}


		Pkt = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);
		Vc = Resd->Vc;
		pIntF = Vc->IntF;

		pIntF->MarsStats.TotalRecvPkts++;

		if (pIntF->Flags & INTF_STOPPING)
		{
			MARSDBGPRINT(DBG_LEVEL_WARN,
				("MARS Thread: pIntF %x is stopping, dropping pkt %x\n", pIntF, Pkt));

			pIntF->MarsStats.DiscardedRecvPkts++;
			ArpSDereferenceVc(Vc, FALSE, TRUE);
			Resd->Vc = NULL;
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
			continue;
		}
	
		NdisQueryBuffer(Pkt->Private.Head, &Header, &PktLen);

		MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MARS Thread: Resd %x, Pkt %x, PktLen %x, Header %x, Op %x, Vc %x, IntF %x\n",
					Resd, Pkt, PktLen, Header, Header->Opcode, Vc, pIntF));

		ARPS_ASSERT (PktLen <= PKT_SPACE);

		switch(Header->Opcode)
		{
		  case OP_MARS_REQUEST:
			MarsHandleRequest(pIntF, Vc, Header, Pkt);
			break;

		  case OP_MARS_JOIN:
			MarsHandleJoin(pIntF, Vc, Header, Pkt);
			break;

		  case OP_MARS_LEAVE:
			MarsHandleLeave(pIntF, Vc, Header, Pkt);
			break;
		  default:
		  	MARSDBGPRINT(DBG_LEVEL_FATAL,
		  			("MarsReqThread: Opcode %x unknown\n", Header->Opcode));
			pIntF->MarsStats.DiscardedRecvPkts++;

		  	ArpSDereferenceVc(Vc, FALSE, TRUE);
			Resd->Vc = NULL;
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);

		  	break;
		}

	} while (TRUE);

	KeSetEvent(&ArpSReqThreadEvent, 0, FALSE);

	MARSDBGPRINT(DBG_LEVEL_WARN,
			("MarsReqThread: Terminating\n"));
}


VOID
MarsHandleRequest(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Handle MARS_REQUEST. If the sender is a valid registered Cluster member,
	lookup the desired target group address in the MARS cache. If found, send
	a sequence of one or more MARS MULTIs. Include the addresses  of members
	who are monitoring the entire class-D address space.

Arguments:

	pIntF	- The interface on which the MARS_REQUEST arrived
	Vc		- The VC on which the packet arrived
	Header	- Points to the request packet
	Packet	- Packet where the incoming information is copied

Return Value:

	None

--*/
{
	HW_ADDR					SrcAddr;
	HW_ADDR **				pPromisHWAddrArray;
	HW_ADDR **				ppPromisHWAddr;
	ATM_ADDRESS				SrcSubAddr;
	IPADDR					GrpAddr;
	PCLUSTER_MEMBER			pMember;
	PGROUP_MEMBER			pGroup;
	PMARS_ENTRY				pMarsEntry;
	NDIS_STATUS				Status;
	PMARS_REQUEST			RHdr;
	PUCHAR					p;
	PPROTOCOL_RESD			Resd, MultiResd;
	ULONG					SeqY;
	ULONG					Length;
	ULONG					CopyLength;
	ULONG					PacketLength;

	PNDIS_PACKET			MultiPacket;
	PNDIS_PACKET			HeadMultiList;
	PNDIS_PACKET *			pTailMultiList;
	ULONG					AddrCountThisPacket;
	ULONG					AddrPerPacket;
	INT						AddrRem;
	INT			 			NumUniquePromisEntries;
	PMARS_MULTI				MHdr;

	KIRQL					OldIrql;
	BOOLEAN					LockAcquired;
	BOOLEAN					SendNak;
	BOOLEAN					Discarded=TRUE;

	RHdr = (PMARS_REQUEST)Header;
	Resd = RESD_FROM_PKT(Packet);
	LockAcquired = FALSE;
	SendNak = FALSE;

	do
	{
		pIntF->MarsStats.TotalRequests++;
	
		//
		// Check if we have enough to even parse this.
		//
		if (Resd->PktLen < sizeof(MARS_REQUEST))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleRequest: Packet Length too small: %x\n", Resd->PktLen));
			break;
		}

		Length = sizeof(MARS_REQUEST) + RHdr->SrcProtoAddrLen +
				 TL_LEN(RHdr->SrcAddressTL) +
				 TL_LEN(RHdr->SrcSubAddrTL) +
				 RHdr->TgtGroupAddrLen;
	
		//
		// Validate length of packet - it should have what it purports to have
		//
		if (Length > Resd->PktLen)
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleRequest: Invalid packet length %x < %x\n",
					Resd->PktLen, Length));
			break;
		}

		//
		// Expect NULL target ATM address/subaddress
		//
		if ((RHdr->TgtAddressTL != 0) ||
			(RHdr->TgtSubAddrTL != 0))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleRequest: Non-null target HW address %x or %x\n",
						RHdr->TgtAddressTL,
						RHdr->TgtSubAddrTL));
			break;
		}

		//
		// Go to the variable length part, consisting of:
		// Source ATM Number (mandatory)
		// Source ATM Subaddress (optional)
		// Source protocol address (optional)
		// Target group address (mandatory)
		//
		p = (PUCHAR)(RHdr + 1);

		SrcAddr.Address.NumberOfDigits = TL_LEN(Header->SrcAddressTL);
		if (SrcAddr.Address.NumberOfDigits > 0)
		{
			SrcAddr.Address.AddressType = TL_TYPE(Header->SrcAddressTL);
			COPY_MEM(SrcAddr.Address.Address, p, SrcAddr.Address.NumberOfDigits);
			p += SrcAddr.Address.NumberOfDigits;
		}

		SrcAddr.SubAddress = NULL;
		if (TL_LEN(Header->SrcSubAddrTL) > 0)
		{
			SrcAddr.SubAddress = &SrcSubAddr;
			SrcSubAddr.NumberOfDigits = TL_LEN(Header->SrcSubAddrTL);
			SrcSubAddr.AddressType = TL_TYPE(Header->SrcSubAddrTL);
			COPY_MEM(&SrcSubAddr.Address, p, SrcSubAddr.NumberOfDigits);
			p += SrcSubAddr.NumberOfDigits;
		}

		//
		// NOTE:
		//
		// We only support full length Source ATM Number,
		// and zero-length Source ATM Subaddress.
		//
		if ((SrcAddr.Address.NumberOfDigits != ATM_ADDRESS_LENGTH) ||
			(SrcAddr.SubAddress != NULL))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleReq: unsupported ATM Number len %x or non-zero subaddr\n",
							SrcAddr.Address.NumberOfDigits));
			break;
		}

		if ((RHdr->SrcProtoAddrLen != 0) && 
			(RHdr->SrcProtoAddrLen != IP_ADDR_LEN))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleReq: bad src proto addr len %x\n", RHdr->SrcProtoAddrLen));
			break;
		}

		p += RHdr->SrcProtoAddrLen;


		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		LockAcquired = TRUE;
		
		//
		// We honor this REQUEST only if it has come from a legitimate
		// Cluster Member.
		//
		pMember = MarsLookupClusterMember(pIntF, &SrcAddr);
		if ((pMember == NULL_PCLUSTER_MEMBER) ||
			(MARS_GET_CM_CONN_STATE(pMember) != CM_CONN_ACTIVE))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleReq: from unconnected cluster member: "));
			MARSDUMPATMADDR(DBG_LEVEL_ERROR, &SrcAddr.Address, "");
			break;
		}
		Discarded = FALSE;	// For stats.


		//
		// Target Group address being resolved.
		//
		MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsHandleReq: Request from pMember %x for Addr ", pMember));
		MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, "\n");

		GETULONG2ULONG(&GrpAddr, p);

		//
		// Fill in our Seq number just in case we decide to send a NAK
		// using this packet
		//
		PUTULONG2ULONG(&(RHdr->SequenceNumber), pIntF->CSN);

		//
		// Check if we are the MCS serving the desired group address.
		//
		if (MarsIsAddressMcsServed(pIntF, GrpAddr))
		{
			PATM_ADDRESS	pAtmAddr = &(pIntF->ConfiguredAddress);

			MARSDBGPRINT(DBG_LEVEL_INFO,
					("MarsHandleReq: sending MULTI with MCS for "));
			MARSDUMPIPADDR(DBG_LEVEL_INFO, *(UNALIGNED IPADDR *)p, "\n");

			//
			// Prepare a MARS MULTI with our address and return it.
			//
			PacketLength = Length + pAtmAddr->NumberOfDigits +
							sizeof(MARS_TLV_MULTI_IS_MCS) +
							sizeof(MARS_TLV_NULL);

			MultiPacket = MarsAllocControlPacket(pIntF, PacketLength, (PUCHAR *)&MHdr);
			if (MultiPacket != (PNDIS_PACKET)NULL)
			{
				ULONG		ExtOff;

				COPY_MEM(MHdr, RHdr, Length);

				MHdr->Opcode = OP_MARS_MULTI;
				MHdr->TgtAddressTL = TL(pAtmAddr->AddressType, pAtmAddr->NumberOfDigits);

				PUTULONG2ULONG(&(MHdr->SequenceNumber), pIntF->CSN);
				PUTSHORT2SHORT(&(MHdr->NumTgtGroupAddr), 1);
				SeqY = LAST_MULTI_FLAG | 1;
				PUTSHORT2SHORT(&(MHdr->FlagSeq), SeqY);

				p = (PUCHAR)MHdr + Length;
				COPY_MEM(p, pAtmAddr->Address, pAtmAddr->NumberOfDigits);
				p += pAtmAddr->NumberOfDigits;

				//
				// Calculate and fill in the extensions offset. This is the
				// offset, calculated from the HwType (afn) field, where
				// we put in the "MULTI is MCS" TLV.
				//
				ExtOff = (ULONG) (p - (PUCHAR)MHdr - sizeof(LLC_SNAP_HDR));
				PUTSHORT2SHORT(&MHdr->ExtensionOffset, ExtOff);

				//
				// Fill in the MULTI is MCS TLV
				//
				COPY_MEM(p, &MultiIsMcsTLV, sizeof(MultiIsMcsTLV));
				p += sizeof(MultiIsMcsTLV);

				//
				// Fill in a NULL (terminating) TLV
				//
				COPY_MEM(p, &NullTLV, sizeof(NullTLV));

				pIntF->MarsStats.MCSAcks++;


				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
				LockAcquired = FALSE;

				MARS_CO_SEND_PACKETS(Vc, &MultiPacket, 1);

			}

			break;
		}

		pMarsEntry = MarsLookupMarsEntry(pIntF, GrpAddr, FALSE);
		if (pMarsEntry!=NULL && pMarsEntry->NumMembers==0)
		{
			pMarsEntry=NULL; // just to simplify tests later on.
		}

		//
		// Pick up the h/w address of all members that are members
		// of the entire class-D address space  (promiscuous members),
		// but which are not monitoring
		// the specific group address requested here. Pointers to these h/w addresses
		// are saved in ALLOC_NP_MEM allocated array pPromisHWAddrArray.
		// NumUniquePromisEntries is the count of these addresses.
		//
		{
			PMARS_ENTRY				pPromisMarsEntry;
			INT						TotPromisEntries;
			PGROUP_MEMBER			pPromisGroup;

			NumUniquePromisEntries = 0;

			//
			// Get total count of promiscuous members.
			//
			TotPromisEntries	   = 0;
			pPromisMarsEntry = MarsLookupMarsEntry(pIntF,  IPADDR_FULL_RANGE, FALSE);
			if (pPromisMarsEntry != NULL_PMARS_ENTRY)
			{
				TotPromisEntries = pPromisMarsEntry->NumMembers;
			}
	
			//
			// Allocate space to hold the hw addresses of all of them.
			//
			pPromisHWAddrArray = NULL;
			if (TotPromisEntries != 0)
			{
				pPromisHWAddrArray = (HW_ADDR **) ALLOC_NP_MEM(
												TotPromisEntries*sizeof(HW_ADDR *),
												POOL_TAG_MARS
												);
				if (pPromisHWAddrArray == NULL)
				{
					//
					// On alloc failure, simply ignore promiscuous members.
					//
					TotPromisEntries = 0;
				}
			}

			//
			// Now only pick up the hw addresses of those members who
			// are not also members of the specific group requested.
			//
			if (TotPromisEntries!=0)
			{
				PGROUP_MEMBER			pGroupStart = NULL;
				if (pMarsEntry!=NULL)
				{
					pGroupStart = pMarsEntry->pMembers;
				}

				for(
					pPromisGroup = pPromisMarsEntry->pMembers;
					TotPromisEntries!=0 && pPromisGroup!=NULL;
					TotPromisEntries--, pPromisGroup = pPromisGroup->Next)
				{
					for (pGroup = pGroupStart;
 						pGroup!=NULL;
 						pGroup = pGroup->Next)
					{
						if (pPromisGroup->pClusterMember ==  pGroup->pClusterMember)
						{
							break;
						}
					}
	
					if (pGroup == NULL)
					{
						//
						// pPromisGroup->pClusterMember is a promiscuous member
						// who is not also a member of the specific group
						// GrpAddr, so we save a pointer to its hw address
						// in our array.
						//
						pPromisHWAddrArray[NumUniquePromisEntries++] =
								&(pPromisGroup->pClusterMember->HwAddr);
					}
				}
			}

			if (NumUniquePromisEntries == 0 && TotPromisEntries != 0)
			{
				FREE_MEM(pPromisHWAddrArray);
				pPromisHWAddrArray = NULL;
				TotPromisEntries = 0;
			}
		}


		//
		// Total addresses equals number of members of the specific group (if any)
		// plus NumUniquePromisEntries
		//
		AddrRem = NumUniquePromisEntries;
		if (pMarsEntry != NULL_PMARS_ENTRY)
		{
			AddrRem += pMarsEntry->NumMembers;
		}

		if (AddrRem == 0)
		{
			RHdr->Opcode = OP_MARS_NAK;
			SendNak = TRUE;
			pIntF->MarsStats.Naks++;

			break;
		}


		// We've computed the total number of hw address we're going to
		// send: AddrRem. This consistes of the addresses of all the
		// members of the specific group GrpAddr, as well as any
		// members of the entire class D space which are not members of
		// the specific group.
		//
		// We'll now create MARS_MULTI send pkts for
		// all these hw addresses, starting with the
		// the addresses of the specific group, and then tacking on
		// the class-D members.
		//

		//
		// Each MARS_MULTI will begin with a copy of the MARS_REQUEST.
		//
		CopyLength = Length;

		AddrPerPacket = (Vc->MaxSendSize - CopyLength)/ATM_ADDRESS_LENGTH;

		HeadMultiList = NULL;
		pTailMultiList = &HeadMultiList;
		SeqY = 1;

		if (pMarsEntry != NULL)
		{
			pGroup = pMarsEntry->pMembers;
		}
		else
		{
			pGroup = NULL;
		}
		ppPromisHWAddr = pPromisHWAddrArray;


		for (; AddrRem != 0; SeqY++)
		{
			AddrCountThisPacket = MIN(AddrRem, (INT)AddrPerPacket);
			AddrRem -= AddrCountThisPacket;

			PacketLength = CopyLength + (AddrCountThisPacket * ATM_ADDRESS_LENGTH);
			MultiPacket = MarsAllocControlPacket(pIntF, PacketLength, (PUCHAR *)&MHdr);
			if (MultiPacket != (PNDIS_PACKET)NULL)
			{
				COPY_MEM(MHdr, RHdr, Length);

				MHdr->Opcode = OP_MARS_MULTI;
				MHdr->TgtAddressTL = ATM_ADDRESS_LENGTH;
				MHdr->TgtSubAddrTL = 0;

				PUTULONG2ULONG(&(MHdr->SequenceNumber), pIntF->CSN);
				PUTSHORT2SHORT(&(MHdr->NumTgtGroupAddr), AddrCountThisPacket);

#if 0
				p = (PUCHAR)(MHdr + 1);
#else
				p = (PUCHAR)MHdr + CopyLength;
#endif
				while (AddrCountThisPacket-- != 0)
				{
					HW_ADDR *pHWAddr;

					if (pGroup != NULL)
					{
						pHWAddr =  &(pGroup->pClusterMember->HwAddr);
						pGroup = pGroup->Next;
					}
					else
					{
						ARPS_ASSERT(  ppPromisHWAddr
								    < (pPromisHWAddrArray + NumUniquePromisEntries));
						pHWAddr = *(ppPromisHWAddr++);
					}

					COPY_MEM( p,
						pHWAddr->Address.Address,
						pHWAddr->Address.NumberOfDigits);

					p += pHWAddr->Address.NumberOfDigits;

				}

				if (AddrRem == 0)
				{
					SeqY |= LAST_MULTI_FLAG;
				}

				PUTSHORT2SHORT(&(MHdr->FlagSeq), SeqY);

				//
				// Link to tail of list of MULTIs.
				//
				*pTailMultiList = MultiPacket;
				MultiResd = RESD_FROM_PKT(MultiPacket);
				pTailMultiList = (PNDIS_PACKET *)&(MultiResd->ReqList.Flink);
				MultiResd->ReqList.Flink = NULL;
			}
			else
			{
				//
				// Failed to allocate MULTI: free all packets allocated so far
				//
				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
				LockAcquired = FALSE;

				while (HeadMultiList != NULL)
				{
					MultiPacket = HeadMultiList;
					MultiResd = RESD_FROM_PKT(MultiPacket);
					HeadMultiList = (PNDIS_PACKET)MultiResd->ReqList.Flink;

					MarsFreePacket(MultiPacket);
				}

				break;
			}
		}

		//
		// Unless there was an allocation failure (HeadMultiList == NULL),
		// we had better have gone through all the hw addresses...
		//
		ARPS_ASSERT(
			HeadMultiList == NULL
			|| (pGroup == NULL
		   	    && (ppPromisHWAddr == (pPromisHWAddrArray+NumUniquePromisEntries))));

		//
		// We're done with the temporary array of pointers to unique
		// promiscuous hw members.
		//
		if (pPromisHWAddrArray != NULL)
		{
			FREE_MEM(pPromisHWAddrArray);
		}

		if (HeadMultiList != NULL)
		{
			pIntF->MarsStats.VCMeshAcks++;
		}
		
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		LockAcquired = FALSE;

		if (HeadMultiList != NULL)
		{
			//
			// Send all MULTIs.
			//
			do
			{
				MultiPacket = HeadMultiList;
				MultiResd = RESD_FROM_PKT(MultiPacket);
				HeadMultiList = (PNDIS_PACKET)MultiResd->ReqList.Flink;
	
				MARS_CO_SEND_PACKETS(Vc, &MultiPacket, 1);
			}
			while (HeadMultiList != NULL);
		}

		break;
	}
	while (FALSE);

	//
	//	Update stats (we may not have the IF lock, but we don't care)...
	//
	if (Discarded)
	{
		pIntF->MarsStats.DiscardedRecvPkts++;
	}

	if (LockAcquired)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	//
	// Free the MARS_REQUEST copy if we didn't reuse it.
	//
	if (SendNak)
	{
		//
		// Send MARS_NAK back
		//
		NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);
		MARS_CO_SEND_PACKETS(Vc, &Packet, 1);
	}
	else
	{
		ArpSDereferenceVc(Vc, FALSE, TRUE);
		Resd->Vc = NULL;
		ExInterlockedPushEntrySList(&ArpSPktList,
									&Resd->FreeList,
									&ArpSPktListLock);
	}

}


VOID
MarsHandleJoin(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Handle MARS_JOIN.

	This is issued as part of register (Flags register bit is set and no group addresses
	are specified) or to join a group address range.

Arguments:

	pIntF	- The interface on which the MARS_JOIN arrived
	Vc		- The VC on which the packet arrived
	Header	- Points to the request packet
	Packet	- Packet where the incoming information is copied

Return Value:

	None
--*/
{
	NDIS_STATUS			Status;
	PMARS_JOIN_LEAVE	JHdr;
	PPROTOCOL_RESD		Resd;
	HW_ADDR				SrcAddr;
	ATM_ADDRESS			SrcSubAddr;
	MCAST_ADDR_PAIR		GrpAddrRange;
	UINT				Length;
	USHORT				Flags, AddrPairs, CMI;
	PUCHAR				p;
	BOOLEAN				bSendReply = FALSE, NewMember = FALSE;
	PCLUSTER_MEMBER		pMember;
	PNDIS_PACKET		ClusterPacket;	// Reply packet to be sent on ClusterControlVc
	KIRQL				OldIrql;
	BOOLEAN				LockAcquired;
	BOOLEAN				Discarded=TRUE, JoinFailed=FALSE, RegistrationFailed=FALSE;


	JHdr = (PMARS_JOIN_LEAVE)Header;
	Resd = RESD_FROM_PKT(Packet);
	ClusterPacket = (PNDIS_PACKET)NULL;
	LockAcquired = FALSE;

	do
	{
		//
		// Check if we have enough to even parse this.
		//
		if (Resd->PktLen < sizeof(MARS_JOIN_LEAVE))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Packet Length too small: %x\n", Resd->PktLen));
			break;
		}

		GETSHORT2SHORT(&Flags, &JHdr->Flags);
		GETSHORT2SHORT(&AddrPairs, &JHdr->NumGrpAddrPairs);
		GETSHORT2SHORT(&CMI, &JHdr->ClusterMemberId);

		MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsHandleJoin: Pkt %x, Flags %x, AddrPairs %x, CMI %x\n",
					Packet, Flags, AddrPairs, CMI));

		if (Flags & JL_FLAGS_REGISTER)
		{
			RegistrationFailed = TRUE;	// For stats. Assume failure.
			pIntF->MarsStats.RegistrationRequests++;
		}
		else
		{
			JoinFailed = TRUE;	// For stats. Assume failure.
			pIntF->MarsStats.TotalJoins++;
		}
		
		Length = sizeof(MARS_JOIN_LEAVE) + JHdr->SrcProtoAddrLen +
				 TL_LEN(Header->SrcAddressTL) +
				 2*AddrPairs*(JHdr->GrpProtoAddrLen);

		//
		// Validate length of packet - it should have what it purports to have
		//
		if (Length > Resd->PktLen)
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Invalid packet length %x < %x\n",
					Resd->PktLen, Length));
			break;
		}

		if (Flags & JL_FLAGS_COPY)
		{
			MARSDBGPRINT(DBG_LEVEL_WARN,
					("MarsHandleJoin: dropping pkt %x with COPY set\n", Packet));
			break;
		}

		if (((Flags & JL_FLAGS_REGISTER) == 0) && (JHdr->GrpProtoAddrLen != IP_ADDR_LEN))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Invalid Grp address length %x\n",
					JHdr->GrpProtoAddrLen));
			break;
		}
	
		if (((AddrPairs == 0) && ((Flags & JL_FLAGS_REGISTER) == 0)) ||
			((Flags & JL_FLAGS_REGISTER) && (AddrPairs != 0)))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Invalid flags/addr pair combination - %x.%x\n",
					Flags, AddrPairs));
			break;
		}

		p = (PUCHAR)(JHdr + 1);
		SrcAddr.Address.NumberOfDigits = TL_LEN(Header->SrcAddressTL);
		if (SrcAddr.Address.NumberOfDigits > 0)
		{
			SrcAddr.Address.AddressType = TL_TYPE(Header->SrcAddressTL);
			COPY_MEM(SrcAddr.Address.Address, p, SrcAddr.Address.NumberOfDigits);
			p += SrcAddr.Address.NumberOfDigits;
		}
		SrcAddr.SubAddress = NULL;
		if (TL_LEN(Header->SrcSubAddrTL) > 0)
		{
			SrcAddr.SubAddress = &SrcSubAddr;
			SrcSubAddr.NumberOfDigits = TL_LEN(Header->SrcSubAddrTL);
			SrcSubAddr.AddressType = TL_TYPE(Header->SrcSubAddrTL);
			COPY_MEM(&SrcSubAddr.Address, p, SrcSubAddr.NumberOfDigits);
			p += SrcSubAddr.NumberOfDigits;
		}

		//
		// We only support full length Source ATM Number,
		// and zero-length Source ATM Subaddress.
		//
		// This is because it is not easy to prepare MARS_MULTI
		// messages when you have an arbitrary mix of ATM Number and
		// ATM Subaddress lengths in the member list for a group.
		//
		if ((SrcAddr.Address.NumberOfDigits != ATM_ADDRESS_LENGTH) ||
			(SrcAddr.SubAddress != NULL))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: unsupported ATM Number len %x or non-zero subaddr\n",
							SrcAddr.Address.NumberOfDigits));
			break;
		}

		//
		// We do not care about the Src Ip Addr
		//
		p += JHdr->SrcProtoAddrLen;

		//
		// Atmost one Address Pair can be present in a JOIN
		//
		if (AddrPairs > 1)
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleJoin: Too many address pairs: %x\n", AddrPairs));
			break;
		}

		//
		// Get the group addr pair, if present
		//
		if (AddrPairs != 0)
		{
			MARSDBGPRINT(DBG_LEVEL_LOUD,
					("MarsHandleJoin: Group Min: "));
			MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, ", Group Max ");
			GETULONG2ULONG(&GrpAddrRange.MinAddr, p);
			p += IP_ADDR_LEN;

			MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, "\n");
			GETULONG2ULONG(&GrpAddrRange.MaxAddr, p);
			p += IP_ADDR_LEN;

			//
			// We only support two kinds of JOIN: single group JOIN, or
			// JOIN for the entire Class D space. If this is any other
			// kind, dump it.
			//
			if ((GrpAddrRange.MinAddr != GrpAddrRange.MaxAddr) 			&&
				((GrpAddrRange.MinAddr != MIN_CLASSD_IPADDR_VALUE) ||
				 (GrpAddrRange.MaxAddr != MAX_CLASSD_IPADDR_VALUE)))
			{
				MARSDBGPRINT(DBG_LEVEL_ERROR,
						("MarsHandleJoin: invalid pair %x - %x\n",
							GrpAddrRange.MinAddr, GrpAddrRange.MaxAddr));
				break;
			}
		}

		//
		// Set the COPY bit right here in case we send this packet
		// back. Also fill in the MARS Seq Number.
		//
		Flags |= JL_FLAGS_COPY;
		PUTSHORT2SHORT(&JHdr->Flags, Flags);
		PUTULONG2ULONG(&(JHdr->MarsSequenceNumber), pIntF->CSN);
		Discarded = FALSE; // for stats.
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		LockAcquired = TRUE;

		//
		// Search for this (potential) cluster member in our database.
		//
		pMember = MarsLookupClusterMember(pIntF, &SrcAddr);

		if (Flags & JL_FLAGS_REGISTER)
		{
			//
			// A cluster member attempting to register.
			//

			//
			// No groups expected in Registration Join.
			//
			if (AddrPairs != 0)
			{

				break;	// discard
			}

			//
			// Create a new entry if we need to.
			//
			if (pMember == NULL_PCLUSTER_MEMBER)
			{
				//
				// If the ClusterControlVc is closing, discard this: we
				// are in no shape to handle this now.
				//
				if ((pIntF->ClusterControlVc != NULL_PMARS_VC)		&&
					MARS_GET_VC_CONN_STATE(pIntF->ClusterControlVc) == MVC_CONN_CLOSING)
				{
					break;
				}

				pMember = MarsCreateClusterMember(pIntF, &SrcAddr);
				if (pMember != NULL_PCLUSTER_MEMBER)
				{
					NewMember = TRUE;
				}
			}

			if (pMember != NULL_PCLUSTER_MEMBER)
			{
				//
				// Successfully registered this Cluster member. Reflect the
				// JOIN message back to it with COPY bit set and PUNCHED bit
				// reset.
				//
				Flags &= ~JL_FLAGS_PUNCHED;
				PUTSHORT2SHORT(&JHdr->Flags, Flags);
				PUTSHORT2SHORT(&JHdr->ClusterMemberId, pMember->CMI);
				PUTULONG2ULONG(&JHdr->MarsSequenceNumber, pIntF->CSN);
				bSendReply = TRUE;
				RegistrationFailed = FALSE;
			}
		}
		else
		{
			//
			// A cluster member Joining one or more multicast groups.
			// Allow this only if the cluster member has been
			// successfully added to ClusterControlVc AND it is in a position to add groups to it.
			//
			if ((pMember != NULL_PCLUSTER_MEMBER) &&
				(MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_ACTIVE) &&
				(MARS_GET_CM_GROUP_STATE(pMember) == CM_GROUP_ACTIVE))
			{
				if (AddrPairs != 0)
				{
					if (MarsAddClusterMemberToGroups(
										pIntF,
										pMember,
										&GrpAddrRange,
										Packet,
										JHdr,
										Length,
										&ClusterPacket
										))
					{
						JoinFailed = FALSE;	// For stats.
						bSendReply = TRUE;
					}
					else if (ClusterPacket!=NULL)
					{
						JoinFailed = FALSE; // For stats.
					}
				}
				//
				// else discard: no groups specified.
				//
			}
			//
			// else discard: unknown member or member not added to ClusterControlVc
			//
		}

	
	} while (FALSE);

	//
	//	Update stats (we may not have the IF lock, but we don't care)...
	//
	if (RegistrationFailed)
	{
		pIntF->MarsStats.FailedRegistrations++; // this includes failures due to bad pkts.
	}
	if (JoinFailed)
	{
		pIntF->MarsStats.FailedJoins++;	// this include failures due to bad pkts.
	}
	if (Discarded)
	{
		pIntF->MarsStats.DiscardedRecvPkts++;
	}
					
	if (LockAcquired)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	//
	// Follow up actions:
	//
	// - We may send a reply on the VC this packet came on
	// - We may initiate AddParty to add a new member to ClusterControlVc
	// - We may send a reply packet on ClusterControlVc
	//

	if (bSendReply)
	{
		//
		// Send this back on the VC we received the JOIN from
		//
		NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);
		MARS_CO_SEND_PACKETS(Vc, &Packet, 1);
	}
	else
	{
		if (ClusterPacket != Packet)
		{
			ArpSDereferenceVc(Vc, FALSE, TRUE);
			Resd->Vc = NULL;
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
		}
		//
		// else we're sending Packet on CC VC
		//
	}

	if (NewMember)
	{
		MarsAddMemberToClusterControlVc(pIntF, pMember);
	}

	if (ClusterPacket != (PNDIS_PACKET)NULL)
	{
		//
		//  Send this packet on ClusterControlVc.
		//
		MarsSendOnClusterControlVc(pIntF, ClusterPacket);
	}
}


VOID
MarsHandleLeave(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Handle MARS_LEAVE.

Arguments:

	pIntF	- The interface on which the MARS_LEAVE arrived
	Vc		- The VC on which the packet arrived
	Header	- Points to the request packet
	Packet	- Packet where the incoming information is copied

Return Value:

	None
--*/
{
	NDIS_STATUS			Status;
	PMARS_JOIN_LEAVE	LHdr;
	PPROTOCOL_RESD		Resd;
	HW_ADDR				SrcAddr;
	ATM_ADDRESS			SrcSubAddr;
	MCAST_ADDR_PAIR		GrpAddrRange;
	UINT				Length;
	USHORT				Flags, AddrPairs, CMI;
	PUCHAR				p;
	BOOLEAN				bSendReply = FALSE, Deregistered = FALSE;
	PCLUSTER_MEMBER		pMember;
	PNDIS_PACKET		ClusterPacket;	// Reply packet to be sent on ClusterControlVc
	KIRQL				OldIrql;
	BOOLEAN				LockAcquired;
	BOOLEAN				Discarded=TRUE, LeaveFailed=FALSE;


	LHdr = (PMARS_JOIN_LEAVE)Header;
	Resd = RESD_FROM_PKT(Packet);
	ClusterPacket = (PNDIS_PACKET)NULL;
	LockAcquired = FALSE;

	do
	{
		//
		// Check if we have enough to even parse this.
		//
		if (Resd->PktLen < sizeof(MARS_JOIN_LEAVE))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleLeave: Packet Length too small: %x\n", Resd->PktLen));
			break;
		}

		GETSHORT2SHORT(&Flags, &LHdr->Flags);
		GETSHORT2SHORT(&AddrPairs, &LHdr->NumGrpAddrPairs);
		GETSHORT2SHORT(&CMI, &LHdr->ClusterMemberId);
	
		MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsHandleLeave: Pkt %x, Flags %x, AddrPairs %x, CMI %x\n",
					Packet, Flags, AddrPairs, CMI));

		Length = sizeof(MARS_JOIN_LEAVE) + LHdr->SrcProtoAddrLen +
				 TL_LEN(Header->SrcAddressTL) +
				 2*AddrPairs*(LHdr->GrpProtoAddrLen);

		if (Flags & JL_FLAGS_REGISTER)
		{
			// We don't track de-registrations.
		}
		else
		{
			LeaveFailed = TRUE;	// For stats. Assume failure.
			pIntF->MarsStats.TotalLeaves++;
		}
		//
		// Validate length of packet - it should have what it purports to have
		//
		if (Length > Resd->PktLen)
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleLeave: Invalid packet length %x < %x\n",
					Resd->PktLen, Length));
			break;
		}

		if (Flags & JL_FLAGS_COPY)
		{
			MARSDBGPRINT(DBG_LEVEL_INFO,
					("MarsHandleLeave: dropping pkt %x with COPY set\n", Packet));
			break;
		}

		if (((Flags & JL_FLAGS_REGISTER) == 0) && (LHdr->GrpProtoAddrLen != IP_ADDR_LEN))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleLeave: Invalid Grp address length %x\n",
					LHdr->GrpProtoAddrLen));
			break;
		}
	
		if (((AddrPairs == 0) && ((Flags & JL_FLAGS_REGISTER) == 0)) ||
			((Flags & JL_FLAGS_REGISTER) && (AddrPairs != 0)))
		{
			MARSDBGPRINT(DBG_LEVEL_ERROR,
					("MarsHandleLeave: Invalid flags/addr pair combination - %x.%x\n",
					Flags, AddrPairs));
			break;
		}

		p = (PUCHAR)(LHdr + 1);
		SrcAddr.Address.NumberOfDigits = TL_LEN(Header->SrcAddressTL);
		if (SrcAddr.Address.NumberOfDigits > 0)
		{
			SrcAddr.Address.AddressType = TL_TYPE(Header->SrcAddressTL);
			COPY_MEM(SrcAddr.Address.Address, p, SrcAddr.Address.NumberOfDigits);
			p += SrcAddr.Address.NumberOfDigits;
		}
		SrcAddr.SubAddress = NULL;
		if (TL_LEN(Header->SrcSubAddrTL) > 0)
		{
			SrcAddr.SubAddress = &SrcSubAddr;
			SrcSubAddr.NumberOfDigits = TL_LEN(Header->SrcSubAddrTL);
			SrcSubAddr.AddressType = TL_TYPE(Header->SrcSubAddrTL);
			COPY_MEM(&SrcSubAddr.Address, p, SrcSubAddr.NumberOfDigits);
			p += SrcSubAddr.NumberOfDigits;
		}

		//
		// We do not care about the Src Ip Addr
		//
		p += LHdr->SrcProtoAddrLen;

		//
		// Atmost one Address Pair can be present in a LEAVE
		//
		if (AddrPairs > 1)
		{
			break;
		}

		//
		// Get the group addr pair, if present
		//
		if (AddrPairs != 0)
		{
			MARSDBGPRINT(DBG_LEVEL_LOUD,
					("HandleLeave: Group Min: "));
			MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, ", Group Max ");
			GETULONG2ULONG(&GrpAddrRange.MinAddr, p);
			p += IP_ADDR_LEN;

			MARSDUMPIPADDR(DBG_LEVEL_LOUD, *(UNALIGNED IPADDR *)p, "\n");
			GETULONG2ULONG(&GrpAddrRange.MaxAddr, p);
			p += IP_ADDR_LEN;

			//
			// We only support two kinds of non-deregistration LEAVE:
			// single group LEAVE, or LEAVE for the entire Class D space.
			// If this is any other kind, dump it.
			//
			if ((GrpAddrRange.MinAddr != GrpAddrRange.MaxAddr) 			&&
				((GrpAddrRange.MinAddr != MIN_CLASSD_IPADDR_VALUE) ||
				 (GrpAddrRange.MaxAddr != MAX_CLASSD_IPADDR_VALUE)))
			{
				break;
			}
		}

		//
		// Set the COPY bit right here in case we send this packet
		// back. Also fill in the MARS Seq Number.
		//
		Flags |= JL_FLAGS_COPY;
		PUTSHORT2SHORT(&LHdr->Flags, Flags);
		PUTULONG2ULONG(&(LHdr->MarsSequenceNumber), pIntF->CSN);

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		LockAcquired = TRUE;
		Discarded = FALSE; // For stats.
		//
		// Search for this (potential) cluster member in our database.
		//
		pMember = MarsLookupClusterMember(pIntF, &SrcAddr);

		if (Flags & JL_FLAGS_REGISTER)
		{
			//
			// A cluster member attempting to de-register.
			//

			if (AddrPairs == 0)
			{
				if (pMember != NULL_PCLUSTER_MEMBER)
				{
					//
					// Unlink all Group structures from the Cluster member,
					// AND disable further groups from being added.
					//
					MarsUnlinkAllGroupsOnClusterMember(pIntF, pMember);
					Deregistered = TRUE;
					//
					// Successfully de-registered this Cluster member. Reflect the
					// LEAVE message back to it with COPY bit set and PUNCHED bit
					// reset.
					//
					Flags &= ~JL_FLAGS_PUNCHED;
					PUTSHORT2SHORT(&LHdr->Flags, Flags);
					PUTULONG2ULONG(&LHdr->MarsSequenceNumber, pIntF->CSN);
					bSendReply = TRUE;
				}
			}
			//
			// else discard: no groups expected in DeRegistration Leave
			//
		}
		else
		{
			//
			//  A cluster member Leaving one or more multicast groups.
			//
			if (AddrPairs != 0)
			{
				if (MarsDelClusterMemberFromGroups(
									pIntF,
									pMember,
									&GrpAddrRange,
									Packet,
									LHdr,
									Length,
									&ClusterPacket
									))
				{
					bSendReply = TRUE;
					LeaveFailed = FALSE;
				}
			}
			//
			// else discard: no groups specified.
			//
		}

	
	} while (FALSE);

	//
	//	Update stats (we may not have the IF lock, but we don't care)...
	//
	if (LeaveFailed)
	{
		pIntF->MarsStats.FailedLeaves++;	// this includes failures due to bad pkts.
	}
	if (Discarded)
	{
		pIntF->MarsStats.DiscardedRecvPkts++;
	}
					
	if (LockAcquired)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	//
	// Follow up actions:
	//
	// - We may send a reply on the VC this packet came on
	// - We may initiate DropParty to delete a member from ClusterControlVc
	// - We may send a reply packet on ClusterControlVc
	//

	if (bSendReply)
	{
		//
		//  Send this back on the VC we received the JOIN from
		//
		NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);
		MARS_CO_SEND_PACKETS(Vc, &Packet, 1);
	}
	else
	{
		if (ClusterPacket != Packet)
		{
			ArpSDereferenceVc(Vc, FALSE, TRUE);
			Resd->Vc = NULL;
			ExInterlockedPushEntrySList(&ArpSPktList,
										&Resd->FreeList,
										&ArpSPktListLock);
		}
		//
		// else we're sending this packet on CC VC
		//
	}

	if (Deregistered)
	{
		BOOLEAN fLocked =
			  MarsDelMemberFromClusterControlVc(pIntF, pMember, FALSE, 0);
		ASSERT(!fLocked);
	}

	if (ClusterPacket != NULL)
	{
		//
		//  Send this packet on ClusterControlVc.
		//
		MarsSendOnClusterControlVc(pIntF, ClusterPacket);
	}
}




PCLUSTER_MEMBER
MarsLookupClusterMember(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr
	)
/*++

Routine Description:

	Given the Hardware address of a cluster member, search our list
	of cluster members for an entry that matches this.

	It is assumed that the caller has acquired the IntF lock.

Arguments:

	pIntF			- Ptr to Interface to search in
	pHwAddr			- Ptr to ATM address and subaddress

Return Value:

	Pointer to Cluster member structure if found, else NULL.

--*/
{
	PCLUSTER_MEMBER	pMember;

	for (pMember = pIntF->ClusterMembers;
		 pMember != NULL;
		 pMember = pMember->Next)
	{
		if (COMP_HW_ADDR(pHwAddr, &pMember->HwAddr))
		{
			break;
		}
	}

	return (pMember);
}


PCLUSTER_MEMBER
MarsCreateClusterMember(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr
	)
/*++

Routine Description:

	Allocate and initialize a Cluster Member structure, and link it
	to the list of members on the specified Interface.

	It is assumed that the caller has acquired the IntF spin lock.

Arguments:

	pIntF			- Ptr to Interface on which this member has joined
	pHwAddr			- ATM address and subaddress for this new member

Return Value:

	Pointer to Cluster member structure if successful, else NULL.

--*/
{
	PCLUSTER_MEMBER pMember;
	ENTRY_TYPE		EntryType;
	ULONG			Length;

	Length =  sizeof(CLUSTER_MEMBER) +
							((pHwAddr->SubAddress != NULL) ? sizeof(ATM_ADDRESS) : 0);
	pMember = ALLOC_NP_MEM(Length, POOL_TAG_MARS);

	if (pMember == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
	}
	else
	{

		if (++(pIntF->MarsStats.CurrentClusterMembers) > pIntF->MarsStats.MaxClusterMembers)
		{
			pIntF->MarsStats.MaxClusterMembers = pIntF->MarsStats.CurrentClusterMembers;
		}
		
		ZERO_MEM(pMember, Length);

		COPY_ATM_ADDR(&pMember->HwAddr.Address, &pHwAddr->Address);
		if (pHwAddr->SubAddress != NULL)
		{
			pMember->HwAddr.SubAddress = (PATM_ADDRESS)(pMember + 1);
			COPY_ATM_ADDR(pMember->HwAddr.SubAddress, pHwAddr->SubAddress);
		}

		pMember->pIntF = pIntF;

		//
		// Link it to the list of Cluster Members on this Interface.
		//
#if 0
		{
			PCLUSTER_MEMBER *	pPrev;

			for (pPrev= &(pIntF->ClusterMembers);
				 *pPrev != NULL;
				 pPrev = &(PCLUSTER_MEMBER)((*pPrev)->Next) )
			{
				// Nothing
			}
			pMember->Next = NULL;
			pMember->Prev = pPrev;
			*pPrev = (PCLUSTER_MEMBER)pMember;
		}
#else
		pMember->Next = pIntF->ClusterMembers;
		pMember->Prev = &(pIntF->ClusterMembers);
		if (pIntF->ClusterMembers != NULL_PCLUSTER_MEMBER)
		{
			pIntF->ClusterMembers->Prev = &(pMember->Next);
		}
		pIntF->ClusterMembers = pMember;
#endif

		pIntF->NumClusterMembers++;

		//
		//  Assign it a CMI
		//
		pMember->CMI = pIntF->CMI++;

	}

	MARSDBGPRINT(DBG_LEVEL_INFO,
			("New Cluster Member 0x%x, pIntF %x, CMI %x, Prev %x, Next %x, ATM Addr:",
				 pMember, pIntF, pMember->CMI, pMember->Prev, pMember->Next));
	MARSDUMPATMADDR(DBG_LEVEL_INFO, &pHwAddr->Address, "");

	return (pMember);
}




VOID
MarsDeleteClusterMember(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	)
/*++

Routine Description:

	Remove Cluster member from the list of Cluster members, and free it.

Arguments:

	pIntF			- Ptr to Interface
	pMember			- Cluster member to be freed

Return Value:

	None

--*/
{
	ARPS_ASSERT(pMember->pGroupList == NULL_PGROUP_MEMBER);
	MARSDBGPRINT(DBG_LEVEL_INFO,
			("MarsDeleteClusterMember: pIntF %x, pMember %x, Next %x, Prev %x\n",
				pIntF, pMember, pMember->Next, pMember->Prev));
				
	pIntF->MarsStats.CurrentClusterMembers--;
	//
	// De-link this Cluster Member from the list on IntF.
	//
	*(pMember->Prev) = pMember->Next;
	if (pMember->Next != NULL)
	{
		((PENTRY_HDR)pMember->Next)->Prev = pMember->Prev;
	}
	pIntF->NumClusterMembers--;

	FREE_MEM(pMember);

}



PMARS_ENTRY
MarsLookupMarsEntry(
	IN	PINTF					pIntF,
	IN	IPADDR					GrpAddr,
	IN	BOOLEAN					bCreateNew
	)
/*++

Routine Description:

	Look up the MARS_ENTRY for the given Group Address on the specified
	Interface. Optionally create a new one if not found.

	The caller is assumed to hold the IntF lock.

Arguments:

	pIntF			- Ptr to Interface
	GrpAddr			- The address to look for
	bCreateNew		- Should we create a new entry if one isn't present?

Return Value:

	Pointer to MARS entry if found/created, else NULL.

--*/
{
	PMARS_ENTRY *	ppMarsEntry;
	PMARS_ENTRY		pMarsEntry = NULL_PMARS_ENTRY;
	UINT			Hash = MARS_HASH(GrpAddr);

	MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsLookupMarsEntry: for IP Addr: "));

	MARSDUMPIPADDR(DBG_LEVEL_LOUD, GrpAddr, "...");

	for (ppMarsEntry = &pIntF->MarsCache[Hash];
		 *ppMarsEntry != NULL;
		 ppMarsEntry = (PMARS_ENTRY *)(&(*ppMarsEntry)->Next))
	{
		if ((*ppMarsEntry)->IPAddress == GrpAddr)
		{
			pMarsEntry = *ppMarsEntry;
			break;
		}

		if ((*ppMarsEntry)->IPAddress > GrpAddr)
		{
			//
			// No chance of finding this.
			//
			break;
		}
	}

	MARSDBGPRINT(DBG_LEVEL_LOUD+DBG_NO_HDR,
			("%sFound\n", ((pMarsEntry != NULL_PMARS_ENTRY)? "" : "Not ")));

	if ((pMarsEntry == NULL_PMARS_ENTRY) && bCreateNew)
	{
		pMarsEntry = (PMARS_ENTRY)ArpSAllocBlock(pIntF, MARS_BLOCK_ENTRY);
		if (pMarsEntry == NULL_PMARS_ENTRY)
		{
			LOG_ERROR(NDIS_STATUS_RESOURCES);
		}
		else
		{
			//
			// Fill in the new entry.
			//
			pMarsEntry->IPAddress = GrpAddr;
			pMarsEntry->pIntF = pIntF;

			//
			// ppMarsEntry points to the Next field of the predecessor of this new entry
			//
			pMarsEntry->Next = *ppMarsEntry;
			pMarsEntry->Prev = ppMarsEntry;
			if (*ppMarsEntry != NULL_PMARS_ENTRY)
			{
				(*ppMarsEntry)->Prev = &(pMarsEntry->Next);
			}
			*ppMarsEntry = pMarsEntry;

			MARSDBGPRINT(DBG_LEVEL_INFO,
					("MarsLookupMarsEntry: new entry %x for IP Addr:", pMarsEntry));
			MARSDUMPIPADDR(DBG_LEVEL_INFO, GrpAddr, "\n");
			if (++(pIntF->MarsStats.CurrentGroups) > pIntF->MarsStats.MaxGroups)
			{
				pIntF->MarsStats.MaxGroups = pIntF->MarsStats.CurrentGroups;
			}
		}
	}

	return (pMarsEntry);
}



BOOLEAN
MarsIsAddressMcsServed(
	IN	PINTF					pIntF,
	IN	IPADDR					IPAddress
	)
/*++

Routine Description:

	Check if the given IP Address is one that is served by MCS.

Arguments:

	pIntF			- Ptr to Interface
	IPAddress		- Address to check

Return Value:

	TRUE if we are the MCS serving IPAddress, else FALSE.

--*/
{
	PMCS_ENTRY		pMcsEntry;

	for (pMcsEntry = pIntF->pMcsList;
		 pMcsEntry != NULL_PMCS_ENTRY;
		 pMcsEntry = (PMCS_ENTRY)pMcsEntry->Next)
	{
		if ((IPAddress >= pMcsEntry->GrpAddrPair.MinAddr) &&
			(IPAddress <= pMcsEntry->GrpAddrPair.MaxAddr))
		{
			return TRUE;
		}
	}

	return FALSE;
}


VOID
MarsPunchHoles(
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PGROUP_MEMBER			pGroupList,
	IN	PINTF					pIntF,
	IN	IPADDR UNALIGNED *		pOutBuf					OPTIONAL,
	OUT	PUSHORT					pMinMaxCount,
	OUT	BOOLEAN *				pAnyHolesPunched
	)
/*++

Routine Description:

	Punch holes in the given IP Address range, according to RFC 2022.
	These holes correspond to:
	1. IP Addresses that are MCS-supported
	2. IP Addresses that are present in the given Group Member list

	Optionally, fill in an output buffer (reflected JOIN/LEAVE) with the
	resulting <min, max> list.

	This routine gets called twice when processing any JOIN or LEAVE message,
	once to get the MinMaxCount and AnyHolesPunched info, and then again,
	after space has been allocated for MinMaxCount pairs, to fill in
	a retransmitted JOIN or LEAVE.

Arguments:

	pGrpAddrRange	- The range to punch holes in
	pGroupList		- #2 in Routine Description above
	pIntF			- Ptr to Interface
	pOutBuf			- If not NULL, place to write <min, max> pairs to.
	pMinMaxCount	- The number of discrete, non-contiguous IP address ranges
					  remaining after hole-punching.
	pAnyHolesPunched- Where we return TRUE iff we punched atleast one hole.

Return Value:

	None. See OUT parameters above.

--*/
{
	PGROUP_MEMBER			pGroup;
	PMCS_ENTRY				pMcsEntry;
	IPADDR					StartOfThisRange;
	IPADDR					IPAddress;
	UNALIGNED IPADDR *		pIPAddress;
	BOOLEAN					InHole;				// are we in a hole now?
	BOOLEAN					HolePunched;		// any holes punched so far?
	BOOLEAN					InGroupList;
	BOOLEAN					InMcsList;

	*pMinMaxCount = 0;

	StartOfThisRange = pGrpAddrRange->MinAddr;
	pGroup = pGroupList;
	pMcsEntry = pIntF->pMcsList;

	InHole = FALSE;
	HolePunched = FALSE;
	pIPAddress = (UNALIGNED IPADDR *)pOutBuf;

	for (IPAddress = pGrpAddrRange->MinAddr;
 		 IPAddress <= pGrpAddrRange->MaxAddr;
 		 IPAddress++)
	{
		//
		// Check if IPAddress is covered by the Group Member list.
		//
		while ((pGroup != NULL) && 
   			(pGroup->pMarsEntry->IPAddress < IPAddress))
		{
			pGroup = (PGROUP_MEMBER)pGroup->pNextGroup;
		}

		if ((pGroup != NULL) &&
   			(pGroup->pMarsEntry->IPAddress == IPAddress))
		{
			InGroupList = TRUE;
		}
		else
		{
			InGroupList = FALSE;
		}

		//
		// Check if IPAddress is served by MCS.
		//
		while ((pMcsEntry != NULL) &&
   			(pMcsEntry->GrpAddrPair.MaxAddr < IPAddress))
		{
			pMcsEntry = (PMCS_ENTRY)pMcsEntry->Next;
		}

		if ((pMcsEntry != NULL) &&
   			((pMcsEntry->GrpAddrPair.MinAddr <= IPAddress) &&
				(pMcsEntry->GrpAddrPair.MaxAddr >= IPAddress)))
		{
			InMcsList = TRUE;
		}
		else
		{
			InMcsList = FALSE;
		}

		if (InHole)
		{
			if (!InGroupList && !InMcsList)
			{
				//
				//  Out of the hole with this IPAddress
				//
				InHole = FALSE;
				StartOfThisRange = IPAddress;
			}
			else
			{
				//
				// A hole right next to the one we were previously in..
				// Jump to the end of this hole...
				// (If we're not in an mcs-served range then we're already
				//  at the end of the single-address hole and so don't do anything).
				//
				if (InMcsList)
				{
					IPAddress = pMcsEntry->GrpAddrPair.MaxAddr;
 		 			if (IPAddress > pGrpAddrRange->MaxAddr)
 		 			{
 		 				IPAddress = pGrpAddrRange->MaxAddr;
 		 			}
				}
			}
		}
		else
		{
			if (InGroupList || InMcsList)
			{
				//
				//  Entering a hole that includes IPAddress
				//
				InHole = TRUE;
				HolePunched = TRUE;
				if (IPAddress > StartOfThisRange)
				{
					(*pMinMaxCount)++;

					if (pIPAddress)
					{
						//
						//  Write out a pair: <StartOfThisRange to IPAddress-1>
						//
						PUTULONG2ULONG(pIPAddress, StartOfThisRange);
						pIPAddress++;
						IPAddress--;
						PUTULONG2ULONG(pIPAddress, IPAddress);
						pIPAddress++;
						IPAddress++;
					}
				}

				//
				// Jump to the end of this hole...
				// (If we're not in an mcs-served range then we're already
				//  at the end of the single-address hole and so don't do anything).
				//
				if (InMcsList)
				{
					IPAddress = pMcsEntry->GrpAddrPair.MaxAddr;
 		 			if (IPAddress > pGrpAddrRange->MaxAddr)
 		 			{
 		 				IPAddress = pGrpAddrRange->MaxAddr;
 		 			}
				}
			}
			else
			{
				//
				// We're not in a hole -- skip to just before the next hole...
				//

				//
				// Since we're not in a hole, the following 2 assertions hold.
				//
				ARPS_ASSERT(pGroup==NULL || pGroup->pMarsEntry->IPAddress > IPAddress);
				ARPS_ASSERT(pMcsEntry==NULL || pMcsEntry->GrpAddrPair.MinAddr > IPAddress);

				//
				// We now pick the skip to just before the next hole which is either
				// a group address or a mcs-served range, whichever comes first.
				// Note that either entry could be NULL.
				//

				if (pGroup != NULL)
				{
					IPAddress = pGroup->pMarsEntry->IPAddress-1;
				}

				if (    (pMcsEntry != NULL)
					 && (   (pGroup == NULL)
					     || (pMcsEntry->GrpAddrPair.MinAddr <= IPAddress)))
				{
					IPAddress =  pMcsEntry->GrpAddrPair.MinAddr-1;
				}

				//
				// Truncate back to the end of the GrpAddrRange
				//
				if (IPAddress > pGrpAddrRange->MaxAddr)
				{
					IPAddress = pGrpAddrRange->MaxAddr;
				}
			}
		}

		//
		// Corner case: Handle IPAddress 255.255.255.255
		// 				(because adding 1 to it causes rollover)
		//
		if (IPAddress == IP_BROADCAST_ADDR_VALUE)
		{
			break;
		}
	}

	if (!InHole)
	{
		(*pMinMaxCount)++;

		if (pIPAddress)
		{
			//
			//  Write out a pair: <StartOfThisRange to IPAddress-1>
			//
			PUTULONG2ULONG(pIPAddress, StartOfThisRange);
			pIPAddress++;
			IPAddress--;
			PUTULONG2ULONG(pIPAddress, IPAddress);
			pIPAddress++;
		}
	}

	*pAnyHolesPunched = HolePunched;

	return;

}


BOOLEAN
MarsAddClusterMemberToGroups(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PNDIS_PACKET			Packet,
	IN	PMARS_JOIN_LEAVE		JHdr,
	IN	UINT					Length,
	OUT	PNDIS_PACKET *			ppClusterPacket
	)
/*++

Routine Description:

	This is called when processing a non-registration JOIN.
	Add a Cluster member to the multicast groups in the given range
	(could be just one). Create all necessary data structures and
	linkages for this.

	It is assumed that the caller has acquired the IntF spin lock.

Arguments:

	pIntF			- Ptr to Interface on which this member has joined
	pMember			- Ptr to Cluster member
	pGrpAddrRange	- Min, Max IP addresses being Joined
	Packet			- Ptr to NDIS packet containing the JOIN
	JHdr			- Ptr to incoming JOIN
	Length			- of incoming JOIN
	ppClusterPacket	- Optionally, a packet to be sent out on ClusterControlVc.

Return Value:

	TRUE if the member was added successfully to the indicated groups,
	FALSE otherwise. If we returned TRUE, we also set *pClusterPacket optionally
	to a packet to be sent out on ClusterControlVc.

--*/
{
	PGROUP_MEMBER		pGroup;
	PGROUP_MEMBER *		ppGroup;
	PMARS_ENTRY			pMarsEntry;
	PMARS_JOIN_LEAVE	pCopyHdr;
	IPADDR				IPAddress;
	USHORT				MinMaxCount;
	BOOLEAN				ReflectJoin;
	BOOLEAN				HolePunched;
	BOOLEAN				RetransmitOnCCVC;
	USHORT				Flags;
	UNALIGNED IPADDR *	pIPAddress;
	ULONG				JoinCopyLength;

	*ppClusterPacket = (PNDIS_PACKET)NULL;
	ReflectJoin = FALSE;
	RetransmitOnCCVC = FALSE;

	GETSHORT2SHORT(&Flags, &JHdr->Flags);

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("MarsAddClusterMemberToGroups: pMember %x, Min ", pMember));
	MARSDUMPIPADDR(DBG_LEVEL_LOUD, pGrpAddrRange->MinAddr, ", Max ");
	MARSDUMPIPADDR(DBG_LEVEL_LOUD, pGrpAddrRange->MaxAddr, "\n");

	MARSDUMPMAP(DBG_LEVEL_NOTICE,
			"MARS: Join ", pGrpAddrRange->MinAddr, &pMember->HwAddr.Address);
	do
	{
		//
		// Possible cases:
		//
		// 1. Joining a single group
		// 2. Joining the entire Class D space.
		//
		if ((pGrpAddrRange->MinAddr == MIN_CLASSD_IPADDR_VALUE) &&
			(pGrpAddrRange->MaxAddr == MAX_CLASSD_IPADDR_VALUE))
		{
			IPAddress = IPADDR_FULL_RANGE; // key for entry representing entire range
		}
		else
		{
			IPAddress = pGrpAddrRange->MinAddr;
		}

		//
		// Check if this is a duplicate join of the entire class-D range.
		// The special value, IPADDR_FULL_RANGE is smaller than any valid
		// IP address, so if present it's always the first in
		// pMember->pGroupList
		//
		if (	IPAddress == IPADDR_FULL_RANGE
			&&	pMember->pGroupList != NULL
			&&	pMember->pGroupList->pMarsEntry->IPAddress == IPAddress)
		{
			//
			// Yes it is a duplicate join of the entire class-D address space.
			//
			MinMaxCount = 0;
		}
		else
		{
			MarsPunchHoles(
				pGrpAddrRange,
				pMember->pGroupList,
				pIntF,
				NULL,
				&MinMaxCount,
				&HolePunched
				);
		}


		//
		// Check whether the JOIN is a complete duplicate.
		//
		if (MinMaxCount == 0)
		{
			//
			// Duplicate JOIN. Retransmit JOIN back on the VC
			// on which it was received.
			//
			ReflectJoin = TRUE;
			pIntF->MarsStats.DuplicateJoins++;

			//
			// Set PUNCHED to 0 in the received JOIN.
			//
			Flags &= ~JL_FLAGS_PUNCHED;
			PUTSHORT2SHORT(&JHdr->Flags, Flags);

			break;
		}

		


		// First access the MARS entry representing the
		// Multicast group being joined.
		//
		pMarsEntry = MarsLookupMarsEntry(pIntF, IPAddress, TRUE);
		if (pMarsEntry == NULL_PMARS_ENTRY)
		{
			break;
		}

		pGroup = ALLOC_NP_MEM(sizeof(GROUP_MEMBER), POOL_TAG_MARS);
		if (pGroup == NULL_PGROUP_MEMBER)
		{
			break;
		}

		//
		// stats...
		//
		pIntF->MarsStats.SuccessfulVCMeshJoins++;
		if (IPAddress == IPADDR_FULL_RANGE)
		{
			if (++(pIntF->MarsStats.CurrentPromiscuous) > pIntF->MarsStats.MaxPromiscuous)
			{
				pIntF->MarsStats.MaxPromiscuous = pIntF->MarsStats.CurrentPromiscuous;
			}
		}
		
		//
		// Fill in the basics for this GROUP_MEMBER.
		//
		pGroup->pMarsEntry = pMarsEntry;
		pGroup->pClusterMember = pMember;

		//
		// Link this GROUP_MEMBER to the MARS Entry.
		//
		pGroup->Prev = &(pMarsEntry->pMembers);
		pGroup->Next = pMarsEntry->pMembers;
		if (pMarsEntry->pMembers != NULL_PGROUP_MEMBER)
		{
			((PENTRY_HDR)(pGroup->Next))->Prev = &(pGroup->Next);
		}
		pMarsEntry->pMembers = pGroup;
		pMarsEntry->NumMembers++;

		//
		// Stats...
		//
		if ((UINT)pMarsEntry->NumMembers > pIntF->MarsStats.MaxAddressesPerGroup)
		{
			pIntF->MarsStats.MaxAddressesPerGroup = pMarsEntry->NumMembers;
		}

		//
		// Link this GROUP_MEMBER to the CLUSTER_MEMBER. The list
		// is sorted in ascending order of IPAddress.
		// NOTE: This function must not be called if pMember's GROUP_STATE is not ACTIVE.
		//
		ASSERT((MARS_GET_CM_GROUP_STATE(pMember) == CM_GROUP_ACTIVE));
		for (ppGroup = &(pMember->pGroupList);
			 *ppGroup != NULL_PGROUP_MEMBER;
			 ppGroup = &(*ppGroup)->pNextGroup)
		{
			if ((*ppGroup)->pMarsEntry->IPAddress > IPAddress)
			{
				break;
			}
		}

		pGroup->pNextGroup = *ppGroup;
		*ppGroup = pGroup;
		pMember->NumGroups++;

		//
		// If a single group was being joined, retransmit the JOIN
		// on ClusterControlVc.
		//
		if (pGrpAddrRange->MinAddr == pGrpAddrRange->MaxAddr)
		{
			//
			// Set PUNCHED to 0 in the received JOIN.
			//
			Flags &= ~JL_FLAGS_PUNCHED;
			PUTSHORT2SHORT(&JHdr->Flags, Flags);

			RetransmitOnCCVC = TRUE;
			break;
		}

		//
		// A range of groups were joined. Check whether any holes
		// were punched, i.e., are there any addresses in this
		// range that the member had already joined, or any addresses
		// that are MCS-served.
		//
		if (!HolePunched)
		{
			//
			// All new Join, and no addresses were MCS-served.
			// Retransmit the original JOIN on ClusterControlVc.
			//
			RetransmitOnCCVC = TRUE;
			break;
		}

		//
		// A copy of the JOIN, with the hole-punched list, is to be
		// sent on ClusterControlVc.
		//
		// The copy will contain (MinMaxCount - 1) _additional_ address
		// pairs.
		//
		JoinCopyLength = Length + ((2 * sizeof(IPADDR))*(MinMaxCount - 1));
		*ppClusterPacket = MarsAllocControlPacket(
								pIntF,
								JoinCopyLength,
								(PUCHAR *)&pCopyHdr
								);

		if (*ppClusterPacket == (PNDIS_PACKET)NULL)
		{
			break;
		}

		COPY_MEM((PUCHAR)pCopyHdr, (PUCHAR)JHdr, Length);

		pIPAddress = (UNALIGNED IPADDR *)((PUCHAR)pCopyHdr + Length - (2 * sizeof(IPADDR)));
		MarsPunchHoles(
			pGrpAddrRange,
			pMember->pGroupList,
			pIntF,
			pIPAddress,
			&MinMaxCount,
			&HolePunched
			);


		//
		// Update the JOIN _copy_ that will go on ClusterControlVc.
		//
		PUTSHORT2SHORT(&pCopyHdr->NumGrpAddrPairs, MinMaxCount);
		Flags |= JL_FLAGS_PUNCHED;
		PUTSHORT2SHORT(&pCopyHdr->Flags, Flags);

		//
		// Retransmit the received JOIN on the VC it arrived on, with
		// Hole-punched reset.
		//
		Flags &= ~JL_FLAGS_PUNCHED;
		PUTSHORT2SHORT(&JHdr->Flags, Flags);
		ReflectJoin = TRUE;

		break;
	}
	while (FALSE);

	if (RetransmitOnCCVC)
	{
		ARPS_ASSERT(!ReflectJoin);
#if 0
		*ppClusterPacket = MarsAllocPacketHdrCopy(Packet);
#else
		*ppClusterPacket = Packet;
#endif
	}

	MARSDBGPRINT(DBG_LEVEL_LOUD,
		("MarsAddClusterMemberToGroups: ClusterPkt %x, RetransmitOnCCVC %d, Reflect %d\n",
		 *ppClusterPacket, RetransmitOnCCVC, ReflectJoin));

	return (ReflectJoin);
}



VOID
MarsUnlinkAllGroupsOnClusterMember(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	)
/*++

Routine Description:

	Unlink and free all Group structures attached to a Cluster Member.
	ALSO: disable any more groups from being added.

	It is assumed that the caller has acquired the IntF spin lock.

Arguments:

	pIntF			- Ptr to Interface from which this member is to be deleted
	pMember			- Ptr to Cluster member

Return Value:

	None

--*/
{
	PGROUP_MEMBER			pGroup;
	PGROUP_MEMBER			pNextGroup;


	MARSDBGPRINT(DBG_LEVEL_NOTICE,
		("MarsUnlinkAllGroupsOnClusterMember: pMember %x, GroupList %x\n",
			pMember, pMember->pGroupList));

	//
	// Save for later.
	//
	pGroup = pMember->pGroupList;
	pMember->pGroupList = NULL_PGROUP_MEMBER;

	//
	// Make sure more groups can't be added later.
	//
	MARS_SET_CM_GROUP_STATE(pMember,  CM_GROUP_DISABLED);

	//
	// De-link and free all Group structures associated with
	// this cluster member.
	//
	for (NOTHING;
		 pGroup != NULL_PGROUP_MEMBER;
		 pGroup = pNextGroup)
	{
		pNextGroup = pGroup->pNextGroup;

		//
		// Unlink from MARS cache.
		//
		*(pGroup->Prev) = pGroup->Next;
		if (pGroup->Next != NULL)
		{
			((PENTRY_HDR)(pGroup->Next))->Prev = pGroup->Prev;
		}

		pGroup->pMarsEntry->NumMembers--;

		pMember->NumGroups--;

		FREE_MEM(pGroup);
	}

}



BOOLEAN
MarsDelClusterMemberFromGroups(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PNDIS_PACKET			Packet,
	IN	PMARS_JOIN_LEAVE		LHdr,
	IN	UINT					Length,
	OUT	PNDIS_PACKET *			ppClusterPacket
	)
/*++

Routine Description:

	Delete a Cluster Member from membership of the indicated group (or
	group range). This is called on processing a non-deregistration
	LEAVE message.

	It is assumed that the caller has acquired the IntF spin lock.

Arguments:

	pIntF			- Ptr to Interface
	pMember			- Ptr to Cluster member
	pGrpAddrRange	- Min, Max IP addresses being Left
	Packet			- NDIS packet containing the LEAVE
	LHdr			- Ptr to incoming LEAVE
	Length			- of incoming LEAVE
	ppClusterPacket	- Optionally, a packet to be sent out on ClusterControlVc.

Return Value:

	TRUE if the member was deleted successfully from the indicated groups,
	FALSE otherwise. If we returned TRUE, we also set *pClusterPacket optionally
	to a packet to be sent out on ClusterControlVc.

--*/
{
	PGROUP_MEMBER		pGroup;
	PGROUP_MEMBER *		ppGroup, * ppDelGroup;
	PMCS_ENTRY			pMcsEntry;
	PMARS_JOIN_LEAVE	pCopyHdr;
	IPADDR				IPAddress;
	USHORT				MinMaxCount;
	BOOLEAN				ReflectLeave;
	BOOLEAN				HolePunched;
	BOOLEAN				RetransmitOnCCVC;
	BOOLEAN				WasBlockJoined;
	BOOLEAN				IsMcsServed;
	USHORT				Flags;
	UNALIGNED IPADDR *	pIPAddress;
	ULONG				LeaveCopyLength;

	*ppClusterPacket = NULL;
	RetransmitOnCCVC = FALSE;
	ReflectLeave = FALSE;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("MarsDelClusterMemberFromGroups: pMember %x, Min ", pMember));
	MARSDUMPIPADDR(DBG_LEVEL_LOUD, pGrpAddrRange->MinAddr, ", Max ");
	MARSDUMPIPADDR(DBG_LEVEL_LOUD, pGrpAddrRange->MaxAddr, "\n");

	do
	{
		if (pMember == NULL)
		{
			ReflectLeave = TRUE;
			break;
		}

		GETSHORT2SHORT(&Flags, &LHdr->Flags);

		pMcsEntry = pIntF->pMcsList;

		if ((pGrpAddrRange->MinAddr == MIN_CLASSD_IPADDR_VALUE) &&
			(pGrpAddrRange->MaxAddr == MAX_CLASSD_IPADDR_VALUE))
		{
			IPAddress = IPADDR_FULL_RANGE; // key for entry representing entire range
		}
		else
		{
			IPAddress = pGrpAddrRange->MinAddr;
		}

		//
		// Gather some information:
		// 1. Locate the Group member structure for this IP Address.
		// 2. Check if this Cluster member has Block-Joined the entire multicast range
		//
		ppDelGroup = NULL;
		WasBlockJoined = FALSE;

		for (ppGroup = &(pMember->pGroupList);
			 *ppGroup != NULL_PGROUP_MEMBER;
			 ppGroup = &((*ppGroup)->pNextGroup))
		{
			//
			// Is this the GROUP_MEMBER to be deleted?
			//
			if ((*ppGroup)->pMarsEntry->IPAddress == IPAddress)
			{
				ppDelGroup = ppGroup;
			}

			//
			// Does this GROUP_MEMBER indicate that the Cluster member
			// has block-joined the entire multicast range?
			//
			if ((*ppGroup)->pMarsEntry->IPAddress == IPADDR_FULL_RANGE)
			{
				WasBlockJoined = TRUE;
			}

			//
			// Do we have all that we are looking for?
			//
			if (ppDelGroup && WasBlockJoined)
			{
				break;
			}
		}

		if (ppDelGroup != NULL)
		{
			PMARS_ENTRY pMarsEntry;
			pGroup = *ppDelGroup;

			//
			// Unlink this GROUP_MEMBER from the CLUSTER_MEMBER.
			//
			*ppDelGroup = (*ppDelGroup)->pNextGroup;
			pMember->NumGroups--;

			//
			// Unlink this GROUP_MEMBER from the MARS_ENTRY.
			//
			*(pGroup->Prev) = pGroup->Next;
			if (pGroup->Next != NULL)
			{
				((PENTRY_HDR)pGroup->Next)->Prev = pGroup->Prev;
			}
			pMarsEntry = pGroup->pMarsEntry;
			pGroup->pMarsEntry = NULL;
			pMarsEntry->NumMembers--;

			if (pMarsEntry->pMembers == NULL)
			{
				PMARS_ENTRY pNextEntry = (PMARS_ENTRY) pMarsEntry->Next;
				//
				// This mars entry has no more members -- remove it from the
				//	hash table and delete it.
				//
				ARPS_ASSERT(pMarsEntry->NumMembers==0);
				pIntF->MarsStats.CurrentGroups--;

#if 1
				MARSDBGPRINT(DBG_LEVEL_INFO,
				("MarsLookupMarsEntry: deleting entry %x for IP Addr:", pMarsEntry));
					MARSDUMPIPADDR(DBG_LEVEL_INFO, pMarsEntry->IPAddress, "\n");


				ARPS_ASSERT(*(pMarsEntry->Prev) == pMarsEntry);
				*(pMarsEntry->Prev) = pNextEntry;
				if (pNextEntry != NULL_PMARS_ENTRY)
				{
					ARPS_ASSERT(pNextEntry->Prev == &(pMarsEntry->Next));
					pNextEntry->Prev = pMarsEntry->Prev;
				}
				ArpSFreeBlock(pMarsEntry);
#endif // 0

			}

			//
			// TODO: Delete group
			//
			#if 1
			FREE_MEM(pGroup);
			#endif 

			
			
			MARSDUMPMAP(DBG_LEVEL_NOTICE,
				"MARS: Leave ", pGrpAddrRange->MinAddr, &pMember->HwAddr.Address);

		}

		//
		// Check if the range/group being Left is MCS-served.
		//
		IsMcsServed = FALSE;
		for (pMcsEntry = pIntF->pMcsList;
			 pMcsEntry != NULL_PMCS_ENTRY;
			 pMcsEntry = pMcsEntry->Next)
		{
			if ((pMcsEntry->GrpAddrPair.MinAddr <= pGrpAddrRange->MinAddr) &&
				(pMcsEntry->GrpAddrPair.MaxAddr >= pGrpAddrRange->MaxAddr))
			{
				IsMcsServed = TRUE;
				break;
			}
		}

		

		if (IPAddress == IPADDR_FULL_RANGE)
		{
			if (!WasBlockJoined)
			{
				//
				// This is an attempt to leave the entire class-D
				// space when in fact it has not joined it (perhaps this is
				// a retransmit of an earlier LEAVE). Reflect it privately.
				//

				ARPS_ASSERT(!ppDelGroup);

				//
				// Reset PUNCHED to 0.
				//
				Flags &= ~JL_FLAGS_PUNCHED;
				PUTSHORT2SHORT(&LHdr->Flags, Flags);
	
				//
				// Retransmit privately on VC.
				//
				ReflectLeave = TRUE;

				break;
			}
			else
			{
				//
				//	This member is truly leaving the entire class-D space.
				//
				pIntF->MarsStats.CurrentPromiscuous--;
			}
		}
		else
		{
			//
			// Single group Leave. Check if this Cluster Member is still
			// block-joined (to the entire Class D range), or if the group
			// being left is served by MCS. In either case, we retransmit
			// the LEAVE privately.
			//
			if (WasBlockJoined || IsMcsServed)
			{
				//
				// Reset PUNCHED to 0.
				//
				Flags &= ~JL_FLAGS_PUNCHED;
				PUTSHORT2SHORT(&LHdr->Flags, Flags);
	
				//
				// Retransmit privately on VC.
				//
				ReflectLeave = TRUE;
			}
			else
			{
				//
				// Retransmit LEAVE on ClusterControlVc.
				//
				ReflectLeave = FALSE;
				RetransmitOnCCVC = TRUE;

			}
			break;
		}


		//
		// Block Leave: can be only for the "entire Class D space" range.
		// Punch holes: for each group that this Cluster member still has
		// "single joins" to, and for each group that is MCS-served.
		//
		MarsPunchHoles(
			pGrpAddrRange,
			pMember->pGroupList,
			pIntF,
			NULL,
			&MinMaxCount,
			&HolePunched
			);

		if (!HolePunched)
		{
			//
			// No holes were punched, meaning that the Cluster member
			// isn't member anymore of any groups in the LEAVE range,
			// and none of the groups in the range is MCS-served.
			// To propagate this information to all hosts in the Cluster,
			// retransmit the LEAVE on ClusterControlVc.
			//

			RetransmitOnCCVC = TRUE;
			break;
		}

		//
		// One or more holes were punched. The original LEAVE
		// should be transmitted back on the VC it came on, with
		// PUNCHED reset to 0.
		//
		Flags &= ~JL_FLAGS_PUNCHED;
		PUTSHORT2SHORT(&LHdr->Flags, Flags);
		ReflectLeave = TRUE;

		if (MinMaxCount == 0)
		{
			//
			// The holes didn't leave anything left, so there is nothing
			// more to do.
			//
			break;
		}

		//
		// A copy of the LEAVE, with the hole-punched list, is to be
		// sent on ClusterControlVc.
		//
		// The copy will contain (MinMaxCount - 1) _additional_ address
		// pairs.
		//
		LeaveCopyLength = Length + ((2 * sizeof(IPADDR))*(MinMaxCount - 1));
		*ppClusterPacket = MarsAllocControlPacket(
								pIntF,
								LeaveCopyLength,
								(PUCHAR *)&pCopyHdr
								);

		if (*ppClusterPacket == (PNDIS_PACKET)NULL)
		{
			break;
		}

		COPY_MEM((PUCHAR)pCopyHdr, (PUCHAR)LHdr, Length);

		pIPAddress = (UNALIGNED IPADDR *)((PUCHAR)pCopyHdr + Length - (2 * sizeof(IPADDR)));
		MarsPunchHoles(
			pGrpAddrRange,
			pMember->pGroupList,
			pIntF,
			pIPAddress,
			&MinMaxCount,
			&HolePunched
			);

		//
		// Update the LEAVE copy.
		//
		PUTSHORT2SHORT(&pCopyHdr->NumGrpAddrPairs, MinMaxCount);
		Flags |= JL_FLAGS_PUNCHED;
		PUTSHORT2SHORT(&pCopyHdr->Flags, Flags);

		break;
	}
	while (FALSE);

	if (RetransmitOnCCVC)
	{
		ARPS_ASSERT(!ReflectLeave);
		*ppClusterPacket = Packet;
	}

	MARSDBGPRINT(DBG_LEVEL_LOUD,
		("MarsDelClusterMemberFromGroups: ClusterPkt %x, RetransmitOnCCVC %d, Reflect %d\n",
		 *ppClusterPacket, RetransmitOnCCVC, ReflectLeave));

	return (ReflectLeave);
}



PNDIS_PACKET
MarsAllocControlPacket(
	IN	PINTF					pIntF,
	IN	ULONG					PacketLength,
	OUT	PUCHAR *				pPacketStart
	)
/*++

Routine Description:

	Allocate and return a packet that can be used to send a MARS control packet.

Arguments:

	pIntF			- Ptr to Interface on which to allocate the packet
	PacketLength	- Total length in bytes
	pPacketStart	- Place to return pointer to start of allocated packet.

Return Value:

	Pointer to NDIS packet if successful, NULL otherwise. If successful, we
	also set *pPacketStart to the start of the allocated (contiguous) memory.

--*/
{
	PNDIS_PACKET		Packet;
	PUCHAR				pBuffer;
	PNDIS_BUFFER		NdisBuffer;
	NDIS_STATUS			Status;
	PPROTOCOL_RESD		Resd;		// ProtocolReserved part of NDIS packet

	*pPacketStart = NULL;
	Packet = NULL;
	NdisBuffer = NULL;

	do
	{
		//
		// Allocate space for the packet.
		//
		pBuffer = (PUCHAR)ALLOC_NP_MEM(PacketLength, POOL_TAG_MARS);
		if (pBuffer == (PUCHAR)NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		// Make this an NDIS buffer.
		//
		NdisAllocateBuffer(&Status,
						   &NdisBuffer,
						   MarsBufPoolHandle,
						   pBuffer,
						   PacketLength);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		// Allocate an NDIS PACKET.
		//
		NdisAllocatePacket(&Status, &Packet, MarsPktPoolHandle);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NdisChainBufferAtFront(Packet, NdisBuffer);
 
 		//
 		// Fill in the Protocol reserved fields properly:
 		//
 		Resd = RESD_FROM_PKT(Packet);
 		ZERO_MEM(Resd, sizeof(PROTOCOL_RESD));
 		Resd->Flags = (RESD_FLAG_MARS_PKT | RESD_FLAG_FREEBUF);
 		Resd->PacketStart = pBuffer;

 		break;
 	}
 	while (FALSE);

 	if (Status == NDIS_STATUS_SUCCESS)
 	{
 		*pPacketStart = pBuffer;
 	}
 	else
 	{
 		//
 		// Undo all that we have done so far.
 		//
 		if (NdisBuffer != NULL)
 		{
 			NdisFreeBuffer(NdisBuffer);
 		}

 		if (pBuffer != (PUCHAR)NULL)
 		{
 			FREE_MEM(pBuffer);
 		}
 	}

	if (Packet == NULL)
	{
		MARSDBGPRINT(DBG_LEVEL_ERROR,
				("MarsAllocControlPacket: FAILED"));
	}

 	return(Packet);
}



VOID
MarsFreePacket(
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Free a packet and any associated buffers. Three kinds of packets
	are handled here:

	1. Copy of a received control packet that has been forwarded. We might
	   have queued this for sending on CC VC, but later decided to abort.
	2. Packet generated by MARS (e.g. MARS_MULTI, hole-punched MARS_JOIN).
	3. Received multicast data packet that has been forwarded.

Arguments:

	Packet			- Packet to be freed

Return Value:

	None

--*/
{
	PPROTOCOL_RESD		Resd;	// ProtocolReserved part of NDIS packet
	PNDIS_BUFFER		NdisBuffer;
	PUCHAR				pBuffer;
	ULONG				BufferLength, TotalLength;

	Resd = RESD_FROM_PKT(Packet);

	//
	// 1. Is this a copy of a received MARS control packet?
	//
	if ((Resd->Flags & RESD_FLAG_MARS_PKT) == 0)
	{
		ExInterlockedPushEntrySList(&ArpSPktList,
									&Resd->FreeList,
									&ArpSPktListLock);

		ArpSDereferenceVc(Resd->Vc, FALSE, TRUE);
	}
	else
	//
	// 2. Is this a packet generated by MARS?
	//
	if (Resd->Flags & RESD_FLAG_FREEBUF)
	{
		//
		// Type 1 in Routine Description: everything belongs to MARS
		//
		NdisGetFirstBufferFromPacket(
				Packet,
				&NdisBuffer,
				(PVOID *)&pBuffer,
				&BufferLength,
				&TotalLength
				);

		ARPS_ASSERT(BufferLength == TotalLength);

		FREE_MEM(pBuffer);

		NdisFreeBuffer(NdisBuffer);

	}
	else
	//
	// 3. This must be Multicast data that we forwarded
	//
	{
		//
		// Type 2 in Routine Description: only the first packet header
		// belongs to MARS. The protocol reserved part contains a pointer
		// to the original packet.
		//
		PNDIS_PACKET		OriginalPacket;

		OriginalPacket = Resd->OriginalPkt;
		ARPS_ASSERT(OriginalPacket != NULL);

		NdisReturnPackets(&OriginalPacket, 1);
	}

	NdisFreePacket(Packet);
}



PNDIS_PACKET
MarsAllocPacketHdrCopy(
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Given an NDIS packet, allocate a new NDIS_PACKET structure, and make
	this new packet point to the buffer chain in the old one.

Arguments:

	Packet			- Packet to make a linked copy of.

Return Value:

	Pointer to the newly allocated and initialized packet if successful,
	else NULL.

--*/
{
	PNDIS_PACKET		PacketCopy;
	NDIS_STATUS			Status;
	PPROTOCOL_RESD		Resd;

	//
	// Allocate an NDIS PACKET.
	//
	NdisAllocatePacket(&Status, &PacketCopy, MarsPktPoolHandle);
	if (Status == NDIS_STATUS_SUCCESS)
	{
		//
		// Make this new packet point to the buffer chain in the old one.
		//
		PacketCopy->Private.Head = Packet->Private.Head;
		PacketCopy->Private.Tail = Packet->Private.Tail;
		PacketCopy->Private.ValidCounts = FALSE;

		//
		// Fill in the ProtocolReserved part with all information
		// we need when we free this packet later.
		//
		Resd = RESD_FROM_PKT(PacketCopy);
		ZERO_MEM(Resd, sizeof(PROTOCOL_RESD));

		Resd->Flags = RESD_FLAG_MARS_PKT;
		Resd->OriginalPkt = Packet;
	}
	else
	{
		PacketCopy = (PNDIS_PACKET)NULL;
	}

	return (PacketCopy);
}


VOID
MarsSendOnClusterControlVc(
	IN	PINTF					pIntF,
	IN	PNDIS_PACKET			Packet	OPTIONAL
	)
/*++

Routine Description:

	Start sends on ClusterControlVc, if we have the connection active,
	and we have tried to AddParty all cluster members. Otherwise, enqueue
	the (optional) Packet on the Cluster Control Packet queue.

	TBD: Protect this from reentrancy!

Arguments:

	pIntF			- Interface on which this packet is to be sent
	Packet			- Packet to be sent

Return Value:

	None

--*/
{
	KIRQL				OldIrql;
	NDIS_HANDLE			NdisVcHandle;
	PPROTOCOL_RESD		Resd;

	PLIST_ENTRY			pEntry;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
				("MarsSendOnCC: pIntF %x/%x, Pkt %x\n", pIntF, pIntF->Flags, Packet));


	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	if (Packet != (PNDIS_PACKET)NULL)
	{
		if (pIntF->NumClusterMembers == 0)
		{
			//
			//  No point in queueing this packet.
			//
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			MarsFreePacket(Packet);
			return;
		}

		//
		// Queue this packet.
		//
		Resd = RESD_FROM_PKT(Packet);
		InsertTailList(&pIntF->CCPacketQueue, &Resd->ReqList);
	}

	//
	// Make sure not more than one thread enters here.
	//
	if (pIntF->Flags & INTF_SENDING_ON_CC_VC)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		return;
	}

	pIntF->Flags |= INTF_SENDING_ON_CC_VC;

	//
	// Send now if the PMP connection is made, and we have tried to AddParty
	// all Cluster Members.
	//
	if ((pIntF->ClusterControlVc != NULL_PMARS_VC) &&
		(MARS_GET_VC_CONN_STATE(pIntF->ClusterControlVc) == MVC_CONN_ACTIVE) &&
		(pIntF->CCAddingParties == 0))
	{
		NdisVcHandle = pIntF->ClusterControlVc->NdisVcHandle;

		ARPS_ASSERT(NdisVcHandle != NULL);

		//
		// Send all packets.
		//
		while (!IsListEmpty(&pIntF->CCPacketQueue))
		{
			pEntry = RemoveHeadList(&pIntF->CCPacketQueue);
			ARPS_ASSERT (pEntry != (PLIST_ENTRY)NULL);
			{
				Resd = CONTAINING_RECORD(pEntry, PROTOCOL_RESD, ReqList);
				Packet = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);

				//
				// If this is a MARS Control packet, fill in CSN, and
				// update our Cluster Sequence Number.
				//
				if ((Resd->Flags & RESD_FLAG_FREEBUF) ||	// Locally generated MARS CTL
					((Resd->Flags & RESD_FLAG_MARS_PKT) == 0)) // Forwarded MARS CTL
				{
					PULONG	pCSN;

					pCSN = (PULONG)(Resd->PacketStart + FIELD_OFFSET(MARS_JOIN_LEAVE, MarsSequenceNumber));
					PUTULONG2ULONG(pCSN, pIntF->CSN);
					pIntF->CSN++;
				}

				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

				NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);

				NdisCoSendPackets(NdisVcHandle, &Packet, 1);

				ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
			}
		}
	}

	pIntF->Flags &= ~INTF_SENDING_ON_CC_VC;

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

}



VOID
MarsFreePacketsQueuedForClusterControlVc(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Free any packets queued for sending on ClusterControlVc.

Arguments:

	pIntF			- Ptr to Interface

Return Value:

	None

--*/
{
	KIRQL				OldIrql;
	PPROTOCOL_RESD		Resd;
	PLIST_ENTRY			pEntry;
	PNDIS_PACKET		Packet;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	while (!IsListEmpty(&pIntF->CCPacketQueue))
	{
		pEntry = RemoveHeadList(&pIntF->CCPacketQueue);
		ARPS_ASSERT (pEntry != (PLIST_ENTRY)NULL);

		Resd = CONTAINING_RECORD(pEntry, PROTOCOL_RESD, ReqList);
		Packet = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		MarsFreePacket(Packet);

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
}



BOOLEAN
MarsDelMemberFromClusterControlVc(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	BOOLEAN					fIfLockedOnEntry,
	IN	KIRQL					OldIrql			OPTIONAL
	)
/*++

Routine Description:

	Drop a Cluster Member from ClusterControlVc. Handle all three
	possibilities:
	(a) Not connected to ClusterControlVc
	(b) Connection setup (MakeCall or AddParty) in progress
	(c) Connected to ClusterControlVc

Arguments:

	pIntF			- Ptr to Interface
	pMember			- Ptr to Cluster Member to be deleted
	fIfLockedOnEntry- If TRUE, IF is locked on entry, else IF is unlocked on entry.

	OldIrql			-- Required IFF fIfLockedOnEntry is TRUE. This is the
					 Irql to return to.

Return Value:

	TRUE IFF IF lock was NEVER released and continues to be held.
	FALSE IFF IF lock WAS release AND and is released on exit  AND
	there was some change of state that is NOT idempotent.

	Thus, if IF lock is ever released in this function, it MUST be released on on
	exit and the return value MUST be false, AND this must only be done in a 
	situation which changes the state of pMember in a non-idempotent way (so calling
	it over and over again will not result in endlessly returning FALSE).

	Why these complexities? To make it safe to call this function while enumerating
	over all members -- check out  MarsAbortAllMembers.

--*/
{
	NDIS_STATUS		Status;
	NDIS_HANDLE		NdisVcHandle;
	NDIS_HANDLE		NdisPartyHandle;
	BOOLEAN			LockReleased;

	MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("MarsDelMemberFromCCVC: pIntF %x, pMember %x, ConnSt %x, PartyHandle %x\n",
			pIntF, pMember, MARS_GET_CM_CONN_STATE(pMember), pMember->NdisPartyHandle));

	LockReleased = FALSE;

	if (!fIfLockedOnEntry)
	{
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	}

	if (!MarsIsValidClusterMember(pIntF, pMember))
	{
		//
		// Oops, the member has gone away in the
		// mean time. We silently return.
		//
		MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("MarsDelMemberFromCCVC: pIntF %x, pMember %x: pMember INVALID!\n",
			pIntF, pMember));
		if (!fIfLockedOnEntry)
		{
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			return FALSE; 							// ***** EARLY RETURN *******
		}
		else
		{
			//
			// We shouldn't have an invalid member if the lock is held on entry!
			//
			ARPS_ASSERT(!"INVALID MEMBER WHEN LOCK IS HELD!");
			return TRUE;						    // ***** EARLY RETURN *******
		}
	}

	switch (MARS_GET_CM_CONN_STATE(pMember))
	{
		case CM_CONN_ACTIVE:
			NdisPartyHandle = pMember->NdisPartyHandle;
			ARPS_ASSERT(NdisPartyHandle != NULL);

			if (pIntF->CCActiveParties + pIntF->CCAddingParties > 1)
			{
				MARS_SET_CM_CONN_STATE(pMember, CM_CONN_CLOSING);

				pIntF->CCActiveParties--;
				pIntF->CCDroppingParties++;
				RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
				LockReleased = TRUE;

				Status = NdisClDropParty(NdisPartyHandle, NULL, 0);
				if (Status != NDIS_STATUS_PENDING)
				{
					ArpSDropPartyComplete(Status, (NDIS_HANDLE)pMember);
				}
			}
			else
			{
				//
				// This is the last active party. Check if any DropParty()'s are
				// yet to finish.
				//
#if 0
				if ((pIntF->CCDroppingParties != 0) &&
					(MARS_GET_VC_CONN_STATE(pIntF->ClusterControlVc) !=
						MVC_CONN_CLOSE_RECEIVED))
#else
				if (pIntF->CCDroppingParties != 0)
#endif
				{
					//
					// This member will have to wait till all DropParty()s are
					// complete. Mark the ClusterControlVc so that we send
					// a CloseCall() when all DropParty()s are done.
					//
					MARS_SET_VC_CONN_STATE(pIntF->ClusterControlVc, MVC_CONN_NEED_CLOSE);
				}
				else
				{
					//
					// Last active party, and no DropParty pending.
					//
					NdisVcHandle = pIntF->ClusterControlVc->NdisVcHandle;
					MARS_SET_VC_CONN_STATE(pIntF->ClusterControlVc, MVC_CONN_CLOSING);

					MARS_SET_CM_CONN_STATE(pMember, CM_CONN_CLOSING);
					pIntF->CCActiveParties--;
					pIntF->CCDroppingParties++;

					RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
					LockReleased = TRUE;

					Status = NdisClCloseCall(
									NdisVcHandle,
									NdisPartyHandle,
									NULL,
									0
									);

					if (Status != NDIS_STATUS_PENDING)
					{
						ArpSCloseCallComplete(
									Status,
									(NDIS_HANDLE)(pIntF->ClusterControlVc),
									(NDIS_HANDLE)pMember
									);
					}
				}
			}
			break;

		case CM_CONN_SETUP_IN_PROGRESS:
			//
			// Mark it so that we'll delete it when the AddParty/MakeCall
			// completes.
			//
			pMember->Flags |= CM_INVALID;
			break;
		
		case CM_CONN_CLOSING:
			NOTHING;
			break;

		case CM_CONN_IDLE:
			//
			// No connection. Just unlink this from the IntF and free it.
			//
			MarsDeleteClusterMember(pIntF, pMember);
			break;

		default:
			ARPS_ASSERT(FALSE);
			break;
	}

	if (LockReleased)
	{
		return FALSE;
	}
	else
	{
		if (fIfLockedOnEntry)
		{
			return TRUE;
		}
		else
		{
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			return FALSE;
		}
	}
}



VOID
MarsAddMemberToClusterControlVc(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	)
/*++

Routine Description:

	Add a Cluster Member as a party to ClusterControlVc. If this is the
	only (or first) Cluster Member known to us, then place a call to
	this cluster member.

Arguments:

	pIntF			- Ptr to Interface
	pMember			- Ptr to Cluster Member to be deleted

Return Value:

	None

--*/
{
	KIRQL					OldIrql;
	PMARS_VC				pVc=NULL;
	PCO_CALL_PARAMETERS		pCallParameters;
	BOOLEAN					LockReleased;
	NDIS_HANDLE				NdisVcHandle;
	NDIS_HANDLE				NdisPartyHandle;
	NDIS_HANDLE				ProtocolVcContext;
	NDIS_HANDLE				ProtocolPartyContext;
	NDIS_STATUS				Status;

	LockReleased = FALSE;
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);


	do
	{
		if (MARS_GET_CM_CONN_STATE(pMember) != CM_CONN_IDLE)
		{
			// Get out of here.
			//
			MARSDBGPRINT(DBG_LEVEL_WARN,
				("AddMemberToCC: pVc %x, pMember %x, Member ConnState %x NOT IDLE\n",
						pVc, pMember,  MARS_GET_CM_CONN_STATE(pMember)));
			break;
		}

		pVc = pIntF->ClusterControlVc;
	
		if (pVc == NULL_PMARS_VC)
		{
			pVc = pIntF->ClusterControlVc = ALLOC_NP_MEM(sizeof(MARS_VC), POOL_TAG_MARS);
			if (pVc == NULL_PMARS_VC)
			{
				MARSDBGPRINT(DBG_LEVEL_FATAL,
						("AddMemberToCC: Cannot allocate CC Vc!\n"));
				break;
			}
			ZERO_MEM(pVc, sizeof(MARS_VC));
			pVc->pIntF = pIntF;
			pVc->VcType = VC_TYPE_MARS_CC;
		}
	
		MARSDBGPRINT(DBG_LEVEL_INFO,
				("AddMemberToCC: pVc %x, pMember %x, ConnState %x\n",
						pVc, pMember, MARS_GET_VC_CONN_STATE(pVc)));
	
		ProtocolVcContext = (NDIS_HANDLE)pVc;
		ProtocolPartyContext = (NDIS_HANDLE)pMember;


		NdisVcHandle = pVc->NdisVcHandle;

		if (MARS_GET_VC_CONN_STATE(pVc) == MVC_CONN_IDLE)
		{
			if (pVc->NdisVcHandle == NULL)
			{
				Status = NdisCoCreateVc(
							pIntF->NdisBindingHandle,
							pIntF->NdisAfHandle,
							(NDIS_HANDLE)pVc,
							&pVc->NdisVcHandle
							);

				if (Status != NDIS_STATUS_SUCCESS)
				{
					break;
				}

				NdisVcHandle = pVc->NdisVcHandle;
				MARSDBGPRINT(DBG_LEVEL_LOUD,
						("AddMemberToCC: Created VC, CCVC %x, NdisVcHandle %x\n",
								pVc, pVc->NdisVcHandle));
			}

			pCallParameters = MarsPrepareCallParameters(pIntF, &pMember->HwAddr, TRUE);
			if (pCallParameters == (PCO_CALL_PARAMETERS)NULL)
			{
				break;
			}

			MARS_SET_VC_CONN_STATE(pVc, MVC_CONN_SETUP_IN_PROGRESS);

			MARS_SET_CM_CONN_STATE(pMember, CM_CONN_SETUP_IN_PROGRESS);

			pIntF->CCAddingParties++;
			pIntF->MarsStats.TotalCCVCAddParties++;

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			LockReleased = TRUE;

			Status = NdisClMakeCall(
							NdisVcHandle,
							pCallParameters,
							ProtocolPartyContext,
							&pMember->NdisPartyHandle
							);

			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSMakeCallComplete(
							Status,
							ProtocolVcContext,
							pMember->NdisPartyHandle,
							pCallParameters
							);
			}

		}
		else if (MARS_GET_VC_CONN_STATE(pVc) == MVC_CONN_ACTIVE)
		{
			pCallParameters = MarsPrepareCallParameters(pIntF, &pMember->HwAddr, FALSE);
			if (pCallParameters == (PCO_CALL_PARAMETERS)NULL)
			{
				break;
			}

			MARS_SET_CM_CONN_STATE(pMember, CM_CONN_SETUP_IN_PROGRESS);

			pIntF->CCAddingParties++;
			pIntF->MarsStats.TotalCCVCAddParties++;

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			LockReleased = TRUE;

			Status = NdisClAddParty(
							NdisVcHandle,
							ProtocolPartyContext,
							pCallParameters,
							&pMember->NdisPartyHandle
							);

			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSAddPartyComplete(
							Status,
							ProtocolPartyContext,
							pMember->NdisPartyHandle,
							pCallParameters
							);
			}
		}
		else
		{
			//
			// First call in progress.
			//
			NOTHING;
		}
		break;
	}
	while (FALSE);

	if (!LockReleased)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}
}



PCO_CALL_PARAMETERS
MarsPrepareCallParameters(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr,
	IN	BOOLEAN					IsMakeCall
	)
/*++

Routine Description:

	Allocate and fill in call parameters for use in a MakeCall(PMP)
	or AddParty.

Arguments:

	pIntF			- Ptr to Interface
	pHwAddr			- Points to the Called ATM address and subaddress

Return Value:

	None

--*/
{
	PMARS_FLOW_SPEC							pFlowSpec;
	PCO_CALL_PARAMETERS						pCallParameters;
	PCO_CALL_MANAGER_PARAMETERS				pCallMgrParameters;

	PQ2931_CALLMGR_PARAMETERS				pAtmCallMgrParameters;

	//
	//  All Info Elements that we need to fill:
	//
	Q2931_IE UNALIGNED *								pIe;
	AAL_PARAMETERS_IE UNALIGNED *						pAalIe;
	ATM_TRAFFIC_DESCRIPTOR_IE UNALIGNED *				pTrafficDescriptor;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *		pBbc;
	ATM_BLLI_IE UNALIGNED *								pBlli;
	ATM_QOS_CLASS_IE UNALIGNED *						pQos;

	ULONG									RequestSize;

	RequestSize = 	sizeof(CO_CALL_PARAMETERS) +
					sizeof(CO_CALL_MANAGER_PARAMETERS) +
					sizeof(Q2931_CALLMGR_PARAMETERS) +
					(IsMakeCall? MARS_MAKE_CALL_IE_SPACE : MARS_ADD_PARTY_IE_SPACE) +
					0;

	pCallParameters = (PCO_CALL_PARAMETERS)ALLOC_NP_MEM(RequestSize, POOL_TAG_MARS);

	if (pCallParameters == (PCO_CALL_PARAMETERS)NULL)
	{
		return (pCallParameters);
	}

	pFlowSpec = &(pIntF->CCFlowSpec);

	//
	//  Zero out everything
	//
	ZERO_MEM((PUCHAR)pCallParameters, RequestSize);

	//
	//  Distribute space amongst the various structures
	//
	pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
							((PUCHAR)pCallParameters +
 								sizeof(CO_CALL_PARAMETERS));


	//
	//  Set pointers to link the above structures together
	//
	pCallParameters->CallMgrParameters = pCallMgrParameters;
	pCallParameters->MediaParameters = (PCO_MEDIA_PARAMETERS)NULL;


	pCallMgrParameters->CallMgrSpecific.ParamType = 0;
	pCallMgrParameters->CallMgrSpecific.Length = 
						sizeof(Q2931_CALLMGR_PARAMETERS) +
						(IsMakeCall? MARS_MAKE_CALL_IE_SPACE : MARS_ADD_PARTY_IE_SPACE);

	pAtmCallMgrParameters = (PQ2931_CALLMGR_PARAMETERS)
								pCallMgrParameters->CallMgrSpecific.Parameters;

	pCallParameters->Flags |= MULTIPOINT_VC;

	//
	//  Call Manager generic flow parameters:
	//
	pCallMgrParameters->Transmit.TokenRate = (pFlowSpec->SendBandwidth);
	pCallMgrParameters->Transmit.TokenBucketSize = (pFlowSpec->SendMaxSize);
	pCallMgrParameters->Transmit.MaxSduSize = pFlowSpec->SendMaxSize;
	pCallMgrParameters->Transmit.PeakBandwidth = (pFlowSpec->SendBandwidth);
	pCallMgrParameters->Transmit.ServiceType = pFlowSpec->ServiceType;

	//
	// For PMP calls, receive side values are 0's.
	//
	pCallMgrParameters->Receive.ServiceType = pFlowSpec->ServiceType;
	
	//
	//  Q2931 Call Manager Parameters:
	//

	//
	//  Called address:
	//
	//  TBD: Add Called Subaddress IE in outgoing call.
	//
	pAtmCallMgrParameters->CalledParty = pHwAddr->Address;

	//
	//  Calling address:
	//
	pAtmCallMgrParameters->CallingParty = pIntF->ConfiguredAddress;


	//
	//  RFC 1755 (Sec 5) says that the following IEs MUST be present in the
	//  SETUP message, so fill them all.
	//
	//      AAL Parameters
	//      Traffic Descriptor (MakeCall only)
	//      Broadband Bearer Capability (MakeCall only)
	//      Broadband Low Layer Info
	//      QoS (MakeCall only)
	//

	//
	//  Initialize the Info Element list
	//
	pAtmCallMgrParameters->InfoElementCount = 0;
	pIe = (PQ2931_IE)(pAtmCallMgrParameters->InfoElements);


	//
	//  AAL Parameters:
	//

	{
		UNALIGNED AAL5_PARAMETERS	*pAal5;

		pIe->IEType = IE_AALParameters;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE;
		pAalIe = (PAAL_PARAMETERS_IE)pIe->IE;
		pAalIe->AALType = AAL_TYPE_AAL5;
		pAal5 = &(pAalIe->AALSpecificParameters.AAL5Parameters);
		pAal5->ForwardMaxCPCSSDUSize = pFlowSpec->SendMaxSize;
		pAal5->BackwardMaxCPCSSDUSize = pFlowSpec->ReceiveMaxSize;
	}

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


	//
	//  Traffic Descriptor:
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_TrafficDescriptor;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE;
		pTrafficDescriptor = (PATM_TRAFFIC_DESCRIPTOR_IE)pIe->IE;

		if (pFlowSpec->ServiceType == SERVICETYPE_BESTEFFORT)
		{
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendBandwidth);
			pTrafficDescriptor->BestEffort = TRUE;
		}
		else
		{
			//  Predictive/Guaranteed service (we map this to CBR, see BBC below)
			pTrafficDescriptor->ForwardTD.PeakCellRateCLP01 =
									BYTES_TO_CELLS(pFlowSpec->SendBandwidth);
			pTrafficDescriptor->BestEffort = FALSE;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}


	//
	//  Broadband Bearer Capability
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_BroadbandBearerCapability;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE;
		pBbc = (PATM_BROADBAND_BEARER_CAPABILITY_IE)pIe->IE;

		pBbc->BearerClass = BCOB_X;
		pBbc->UserPlaneConnectionConfig = UP_P2P;
		if (pFlowSpec->ServiceType == SERVICETYPE_BESTEFFORT)
		{
			pBbc->TrafficType = TT_NOIND;
			pBbc->TimingRequirements = TR_NOIND;
			pBbc->ClippingSusceptability = CLIP_NOT;
		}
		else
		{
			pBbc->TrafficType = TT_CBR;
			pBbc->TimingRequirements = TR_END_TO_END;
			pBbc->ClippingSusceptability = CLIP_SUS;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}


	//
	//  Broadband Lower Layer Information
	//

	pIe->IEType = IE_BLLI;
	pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE;
	pBlli = (PATM_BLLI_IE)pIe->IE;
	COPY_MEM((PUCHAR)pBlli,
  				(PUCHAR)&ArpSDefaultBlli,
  				sizeof(ATM_BLLI_IE));

	pAtmCallMgrParameters->InfoElementCount++;
	pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);


	//
	//  QoS
	//

	if (IsMakeCall)
	{
		pIe->IEType = IE_QOSClass;
		pIe->IELength = SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE;
		pQos = (PATM_QOS_CLASS_IE)pIe->IE;
		if (pFlowSpec->ServiceType == SERVICETYPE_BESTEFFORT)
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 0;
		}
		else
		{
			pQos->QOSClassForward = pQos->QOSClassBackward = 1;
		}

		pAtmCallMgrParameters->InfoElementCount++;
		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}

	return (pCallParameters);

}


BOOLEAN
MarsSendRedirect(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	)
/*++

Routine Description:

	Send a MARS_REDIRECT on ClusterControlVc, as part of a periodic keepalive
	for Cluster members, unless we are shutting down.

Arguments:

	pIntF				- Ptr to Interface
	Timer				- Ptr to timer that went off
	TimerShuttingDown	- Indicates whether we are shutting down

Return Value:

	TRUE iff TimerShuttingDown is FALSE.

--*/
{
	ULONG				PacketLength;
	PNDIS_PACKET		RedirPacket;
	PMARS_REDIRECT_MAP	RHdr;
	PATM_ADDRESS		pAtmAddress;
	KIRQL				OldIrql;
	PUCHAR				p;
	INT					i;
	BOOLEAN					LockAcquired;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("MarsSendRedirect: pIntF %x, Timer %x, ShuttingDown %x\n",
			 pIntF, Timer, TimerShuttingDown));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	LockAcquired = TRUE;

	if (pIntF->NumAddressesRegd > pIntF->NumAllocedRegdAddresses)
	{
		//
		// 12/22/1998 JosephJ: We shouldn't get here, but we have in the past, hence this assert.
		// I made a change to ArpSCoRequestComplete -- see 12/22/1998 note there -- which should
		// make us never get here.
		ASSERT(!"Redirect: NumRegd>NumAlloced");

		// If somehow we do, we fix up NumAddresesRegd
		//
		pIntF->NumAddressesRegd = pIntF->NumAllocedRegdAddresses;
	}
	
	if (!TimerShuttingDown)
	{
		PacketLength = sizeof(MARS_REDIRECT_MAP) +
						//
						// Source ATM Address
						//
						pIntF->ConfiguredAddress.NumberOfDigits +
						//
						// List of MARS ATM Addresses =
						// Our configured address + registered addresses
						//
						pIntF->ConfiguredAddress.NumberOfDigits +
						(ATM_ADDRESS_LENGTH * pIntF->NumAddressesRegd);

		ARPS_ASSERT(PacketLength <= pIntF->MaxPacketSize);

		RedirPacket = MarsAllocControlPacket(pIntF, PacketLength, (PUCHAR *)&RHdr);

		if (RedirPacket != (PNDIS_PACKET)NULL)
		{
			ZERO_MEM(RHdr, PacketLength);

			//
			// Fill in the packet.
			//
			COPY_MEM(RHdr, &MarsCntrlHdr, sizeof(MarsCntrlHdr));
			RHdr->Opcode = OP_MARS_REDIRECT_MAP;
			RHdr->TgtAddressTL = ATM_ADDRESS_LENGTH;
			PUTSHORT2SHORT(&(RHdr->NumTgtAddr), 1 + pIntF->NumAddressesRegd);

			p = (PUCHAR)(RHdr + 1);

			//
			// Source ATM Number
			//
			COPY_MEM(p, pIntF->ConfiguredAddress.Address, pIntF->ConfiguredAddress.NumberOfDigits);

			p += pIntF->ConfiguredAddress.NumberOfDigits;

			pAtmAddress = pIntF->RegAddresses;
			for (i = pIntF->NumAddressesRegd;
				 i != 0;
				 i--)
			{
				ARPS_ASSERT(pAtmAddress->NumberOfDigits <= 20);
				COPY_MEM(p, pAtmAddress->Address, pAtmAddress->NumberOfDigits);
				p += pAtmAddress->NumberOfDigits;
				pAtmAddress++;
			}

			PacketLength = (ULONG)(p - (PUCHAR)RHdr);

			NdisAdjustBufferLength(RedirPacket->Private.Head, PacketLength);
			RedirPacket->Private.ValidCounts = FALSE;

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
			LockAcquired = FALSE;
			MarsSendOnClusterControlVc(pIntF, RedirPacket);
		}
	}

	if (LockAcquired)
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

	return (!TimerShuttingDown);
}


VOID
MarsAbortAllMembers(
	IN	PINTF					pIntF
	)

/*++

Routine Description:

	Abort all Cluster Members on the specified Interface, by removing
	all their group memberships, and dropping them off ClusterControlVc.

Arguments:

	pIntF				- Ptr to Interface

Return Value:

	None

--*/
{
	PCLUSTER_MEMBER			pMember = NULL;
	PCLUSTER_MEMBER			pNextMember;
	KIRQL					OldIrql;
	BOOLEAN					fLockPreserved;
	UINT					uInitialMembersEnumerated;
	UINT					uTotalMembersEnumerated;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	// 
	// TODO: disable more members from being added.
	//

	//
	// First with the IntF lock held, we go through unlinking groups from
	// all cluster members.
	//
	uInitialMembersEnumerated = 0;
	for (pMember = pIntF->ClusterMembers;
		pMember != NULL_PCLUSTER_MEMBER;
		pMember =  (PCLUSTER_MEMBER)pMember->Next)
	{
		uInitialMembersEnumerated++;

		MARSDBGPRINT(DBG_LEVEL_NOTICE,
		   ("MarsAbortAllMembers: pIntF %x, Unlinking groups on Cluster Member %x\n",
			pIntF, pMember));

		//
		// Delete all groups from this member
		// AND disable further groups from being added.
		//
		MarsUnlinkAllGroupsOnClusterMember(pIntF, pMember);
	}

	//
	// Then we initiate the deletion of each cluster member.
	//
	uTotalMembersEnumerated = 0;
	do
	{
		fLockPreserved = TRUE;

		if (uTotalMembersEnumerated >
			 (uInitialMembersEnumerated*uInitialMembersEnumerated))
		{
			//
			// This really shouldn't happen. In the worst case, we expect
			// total enumerations to be around N*(N-1)/2, where N is
			// uInitialMembersEnumerated.
			// NOTE: the squaring above could theoretically result in an overflow.
			// But we're really not shooting to support 65536 cluster members!
			// If we where, our O(N^2) algorithms will breakdown anyway!
			//
			ASSERT(!"Not making progress deleting members.");
			break;
		}

		for (pMember = pIntF->ClusterMembers;
 			pMember != NULL_PCLUSTER_MEMBER;
			pMember =  pNextMember)
		{
		    pNextMember = (PCLUSTER_MEMBER)pMember->Next;
			uTotalMembersEnumerated++;
	
			MARSDBGPRINT(DBG_LEVEL_NOTICE,
					("MarsAbortAllMembers: pIntF %x, Deleting Cluster Member %x\n",
						pIntF, pMember));
	
			fLockPreserved = MarsDelMemberFromClusterControlVc(
								pIntF,
								pMember,
								TRUE,
								OldIrql
								);
	
			if (!fLockPreserved)
			{
				//
				// This means that MarsDelMemberFromClusterControlVc has
				// made some non-idempotent change to pMember which has
				// required it to release the pIntF lock.
				//
				// We will re-acquire the lock and start enumeration from scratch.
				//
				ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
				break;
			}
		}

	} while (!fLockPreserved);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
}



VOID
MarsStopInterface(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Shut down all MARS activity on the specified Interface.

	1. Free any packets queued for transmission on ClusterControlVc.
	2. Delete all Cluster Members, and drop them from ClusterControlVc.
	3. Clean up the MARS cache.

Arguments:

	pIntF				- Ptr to Interface

Return Value:

	None

--*/
{
	PMARS_ENTRY				pMarsEntry;
	PMARS_ENTRY				pNextMarsEntry;
	ULONG					i;
	KIRQL					OldIrql;

	MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("=>MarsStopInterface: pIntF %x, Flags %x, Ref %x\n",
				pIntF, pIntF->Flags, pIntF->RefCount));

	MarsFreePacketsQueuedForClusterControlVc(pIntF);

	//
	// Delete all cluster members.
	//
	MarsAbortAllMembers(pIntF);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	if (pIntF->pMcsList != NULL)
	{
		FREE_MEM(pIntF->pMcsList);
		pIntF->pMcsList = NULL;
	}

	//
	// Clean up the MARS cache.
	//
	for (i = 0; i < MARS_TABLE_SIZE; i++)
	{
		// Remove the list at pIntF->MarsCache[i] and nuke all items in it.
		// Be sure to set pIntF->MarsCache[i] to NULL so no one else tries to
		// get to these entries in the mean time.
		//
		pMarsEntry = pIntF->MarsCache[i];
		pIntF->MarsCache[i] = NULL;

		for (;
			 pMarsEntry != NULL_PMARS_ENTRY;
			 pMarsEntry = pNextMarsEntry)
		{
			pNextMarsEntry = (PMARS_ENTRY)pMarsEntry->Next;

			MARSDBGPRINT(DBG_LEVEL_INFO,
					("MarsStopIntf: pIntF %x, Freeing MARS Entry %x, IP Addr: ",
						pIntF, pMarsEntry));
			MARSDUMPIPADDR(DBG_LEVEL_INFO, pMarsEntry->IPAddress, "\n");

			ARPS_ASSERT(pMarsEntry->pMembers == NULL_PGROUP_MEMBER);
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			ArpSFreeBlock(pMarsEntry);

			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		}
	}

	MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("<=MarsStopInterface: pIntF %x, Flags %x, Ref %x\n",
				pIntF, pIntF->Flags, pIntF->RefCount));

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return;
}


#if DBG

VOID
MarsDumpPacket(
	IN	PUCHAR					Packet,
	IN	UINT					PktLen
	)
{
	UINT	i;

	MARSDBGPRINT(DBG_LEVEL_INFO, (" PacketDump: "));
	for (i = 0; i < PktLen; i++)
	{
		MARSDBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR,
				("%02x ", Packet[i]));
	}

	MARSDBGPRINT(DBG_LEVEL_INFO+DBG_NO_HDR, ("\n"));
}

VOID
MarsDumpIpAddr(
	IN	IPADDR					IpAddr,
	IN	PCHAR					String
	)
{
	PUCHAR	p = (PUCHAR)&IpAddr;

	DbgPrint("%d.%d.%d.%d%s", p[0], p[1], p[2], p[3], String);
}

VOID
MarsDumpAtmAddr(
	IN	PATM_ADDRESS			AtmAddr,
	IN	PCHAR					String
	)
{
	ULONG			i;
	ULONG			NumOfDigits;
	PUCHAR			pSrc, pDst;
	UCHAR			AddrString[(ATM_ADDRESS_LENGTH*2) + 1];

	//
	// Prepare the Address string in ASCII
	//
	if ((NumOfDigits = AtmAddr->NumberOfDigits) > ATM_ADDRESS_LENGTH)
	{
		NumOfDigits = ATM_ADDRESS_LENGTH;
	}

	pSrc = AtmAddr->Address;
	pDst = AddrString;
	for (i = 0; i < NumOfDigits; i++, pSrc++)
	{
		*pDst = ((*pSrc) >> 4);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
		*pDst = ((*pSrc) & 0x0F);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
	}

	*pDst = '\0';

	DbgPrint("%s(%s, %d): %s\n",
					String,
					(AtmAddr->AddressType == ATM_E164) ? "E164" : "NSAP",
					AtmAddr->NumberOfDigits,
					AddrString);
}

VOID
MarsDumpMap(
	IN	PCHAR					String,
	IN	IPADDR					IpAddr,
	IN	PATM_ADDRESS			AtmAddr
	)
{
	PUCHAR		pIpAddrVal = (PUCHAR)&IpAddr;

	DbgPrint("MARS: %s %d.%d.%d.%d : ",
				String,
				((PUCHAR)pIpAddrVal)[3],
				((PUCHAR)pIpAddrVal)[2],
				((PUCHAR)pIpAddrVal)[1],
				((PUCHAR)pIpAddrVal)[0]
			);

	MarsDumpAtmAddr(AtmAddr, "");
}

#endif // DBG


BOOLEAN
MarsIsValidClusterMember(
	PINTF				pIntF,
	PCLUSTER_MEMBER		pPossibleMember
	)
/*++

Routine Description:

	Verify that pPossibleMember is a valid member,
	by checking if it is in the list of members.
	pMember COULD be an invalid pointer.

	The interface lock is expected to be held and is not released.

Arguments:

	pIntF			- Ptr to Interface
	pPossibleMember	- Ptr to Cluster Member to be validated.

Return Value:

	TRUE IFF pMember is in the cluster member list.

--*/
{
	PCLUSTER_MEMBER		pMember;

	for (pMember = pIntF->ClusterMembers;
		pMember != NULL_PCLUSTER_MEMBER;
		pMember =  (PCLUSTER_MEMBER)pMember->Next)
	{
		if (pMember == pPossibleMember)
		{
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\mars.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mars.h

Abstract:

    This file contains the definitions for Multicast Address Resolution Server (MARS).

Author:

	Jameel Hyder (jameelh@microsoft.com)	January 1997

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_MARS_
#define	_MARS_

//
// IP Address values that can be used in comparisons:
//
#define MIN_CLASSD_IPADDR_VALUE		((IPADDR)0xE0000000)	// 224.0.0.0
#define MAX_CLASSD_IPADDR_VALUE		((IPADDR)0xEFFFFFFF)	// 239.255.255.255
#define IP_BROADCAST_ADDR_VALUE		((IPADDR)0xFFFFFFFF)	// 255.255.255.255

//
// IP Address value we use to represent the "full multicast+broadcast range"
//
#define IPADDR_FULL_RANGE			((IPADDR)0x00000000)


//
// MARS_OP - Define these in network byte order
//
#define	OP_MARS_REQUEST				0x0100
#define	OP_MARS_MULTI				0x0200 
#define	OP_MARS_MSERV				0x0300 
#define	OP_MARS_JOIN				0x0400 
#define	OP_MARS_LEAVE				0x0500 
#define	OP_MARS_NAK					0x0600 
#define	OP_MARS_UNSERV				0x0700 
#define	OP_MARS_SJOIN				0x0800 
#define	OP_MARS_SLEAVE				0x0900 
#define	OP_MARS_MIGRATE				0x0D00 
#define	OP_MARS_GROUPLIST_REQUEST	0x0000
#define	OP_MARS_GROUPLIST_REPLY		0x0000
#define	OP_MARS_REDIRECT_MAP		0x0C00

#define	MARS_HWTYPE					0x0F00

#define LAST_MULTI_FLAG				0x8000

//
// The layout of a MARS_JOIN and MARS_LEAVE request packets
//
typedef struct _MARS_HDR
{
	LLC_SNAP_HDR				LlcSnapHdr;			// LLC SNAP Header
	USHORT						HwType;				// Must be 0x0F00 (0x000F on the wire)
	USHORT						Protocol;			// 16 bits
	UCHAR						ProtocolSnap[5];	// 40 bits
	UCHAR						Reserved[3];		// 24-bits
	USHORT						CheckSum;
	USHORT						ExtensionOffset;
	USHORT						Opcode;				// MARS_XXX above
	ATM_ADDR_TL					SrcAddressTL;
	ATM_ADDR_TL					SrcSubAddrTL;
	//
	// This is followed by variable length fields and is dictated by the value of Opcode.
	// The structures below define fixed part of individual MARS_XXX messages. The variable
	// part of each of these depends on the TL fields.
	//
} MARS_HEADER, *PMARS_HEADER;


//
// Defines the structure of the MARS_REQUEST, MARS_MULTI, MARS_MIGRATE and MARS_NAK messages
//
typedef struct _MARS_REQUEST
{
	MARS_HEADER;
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	ATM_ADDR_TL					TgtAddressTL;
	ATM_ADDR_TL					TgtSubAddrTL;
	UCHAR						TgtGroupAddrLen;	// Target protocol addr length
	union
	{
		UCHAR					Padding[8];			// For MARS_REQUEST and MARS_NAK
		struct
		{											// For MARS_MULTI and MARS_MIGRATE
			USHORT				NumTgtGroupAddr;	// Should be converted to wire-format
			union
			{
				USHORT			FlagSeq;			// Should be converted to wire-format
				USHORT			Reservedx;			// For MARS_MIGRATE
			
			};
			ULONG				SequenceNumber;		// Should be converted to wire-format
		};
	};
} MARS_REQUEST, MARS_MULTI, MARS_NAK, *PMARS_REQUEST, *PMARS_MULTI, *PMARS_NAK;

typedef struct _MCAST_ADDR_PAIR
{
	IPADDR						MinAddr;
	IPADDR						MaxAddr;
} MCAST_ADDR_PAIR, *PMCAST_ADDR_PAIR;

//
// Defines the structure of the MARS_JOIN and MARS_LEAVE messages
//
typedef struct _MARS_JOIN_LEAVE
{
	MARS_HEADER;
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	UCHAR						GrpProtoAddrLen;	// Grp protocol addr length
	USHORT						NumGrpAddrPairs;	// # of group address pairs
													// Should be converted to wire-format
	USHORT						Flags;				// layer 3 frp copy & register flags
													// Should be converted to wire-format
	USHORT						ClusterMemberId;	// Should be converted to wire-format
	ULONG						MarsSequenceNumber;	// Should be converted to wire-format
	//
	// This is followed by Src ATM address/sub-address, src protocol address and N pairs of multicast addresses
	//
} MARS_JOIN_LEAVE, *PMARS_JOIN_LEAVE;

//
// Definitions of flags masks
//
#define	JL_FLAGS_L3GRP			0x8000
#define	JL_FLAGS_COPY			0x4000
#define	JL_FLAGS_REGISTER		0x2000
#define	JL_FLAGS_PUNCHED		0x1000
#define	JL_FLAGS_RESERVED		0x0F00
#define	JL_FLAGS_SEQUENCE		0x00FF

//
// Defines the structure of the MARS_GROUPLIST_REQUEST and MARS_GROUPLIST_REPLY messages
//
typedef struct _MARS_GROUPLIST_REPLY
{
	MARS_HEADER;
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	UCHAR						Reserved1;
	UCHAR						Reserved2;
	UCHAR						TgtGroupAddrLen;	// Target protocol addr length
	USHORT						NumTgtGroupAddr;	// Should be converted to wire-format
	USHORT						FlagSeq;			// Should be converted to wire-format
	ULONG						SequenceNumber;		// Should be converted to wire-format
} MARS_GROUPLIST_REPLY, *PMARS_GROUPLIST_REPLY;

//
// Defines the structure of the MARS_REDIRECT_MAP messages
//
typedef struct _MARS_REDIRECT_MAP
{
	MARS_HEADER;
	UCHAR						SrcProtoAddrLen;	// Src protocol addr length
	ATM_ADDR_TL					TgtAddressTL;
	ATM_ADDR_TL					TgtSubAddrTL;
	UCHAR						Flags;
	USHORT						NumTgtAddr;			// Should be converted to wire-format
	USHORT						FlagSeq;			// Should be converted to wire-format
	ULONG						SequenceNumber;		// Should be converted to wire-format
} MARS_REDIRECT_MAP, *PMARS_REDIRECT_MAP;


//
// Defines the structure of a MARS TLV header
//
typedef struct _MARS_TLV_HEADER
{
	USHORT						Type;
	USHORT						Length;
} MARS_TLV_HEADER;

typedef MARS_TLV_HEADER UNALIGNED * PMARS_TLV_HEADER;


//
// Defines the structure of a MARS MULTI is MCS header. This TLV is appended
// to any MULTI message we send out with our address as the MCS address.
//
typedef struct _MARS_TLV_MULTI_IS_MCS
{
	MARS_TLV_HEADER;
} MARS_TLV_MULTI_IS_MCS;

typedef MARS_TLV_MULTI_IS_MCS UNALIGNED * PMARS_TLV_MULTI_IS_MCS;

//
// TLV Type value for MULTI is MCS TLV.
//
#define MARS_TLVT_MULTI_IS_MCS		0x003a	// on-the-wire form


//
// Defines the structure of a NULL TLV, which is used to terminate
// a list of TLVs.
//
typedef struct _MARS_TLV_NULL
{
	MARS_TLV_HEADER;
} MARS_TLV_NULL;

typedef MARS_TLV_NULL UNALIGNED * PMARS_TLV_NULL;


//
// Forward references
//
struct _CLUSTER_MEMBER ;
struct _GROUP_MEMBER ;
struct _MARS_ENTRY ;
struct _MCS_ENTRY ;
struct _MARS_VC ;


//
// This represents a cluster-member, or an endstation that has registered
// with MARS. A single cluster-member can be associated with many groups.
//
typedef struct _CLUSTER_MEMBER
{
	ENTRY_HDR;										// Must be the first entry
	HW_ADDR						HwAddr;				// HWADDR MUST FOLLOW ENTRY_HDR
	PINTF						pIntF;				// Back pointer to the interface
	USHORT						Flags;
	USHORT						CMI;				// Cluster-Member-Id
	NDIS_HANDLE					NdisPartyHandle;	// Leaf-node for ClusterControlVc
	struct _GROUP_MEMBER *		pGroupList;			// List of groups this CM has JOINed
													// This is sorted in ascending order
													// of Group Address
	INT							NumGroups;			// Size of above list
} CLUSTER_MEMBER, *PCLUSTER_MEMBER;

#define NULL_PCLUSTER_MEMBER	((PCLUSTER_MEMBER)NULL)

#define CM_CONN_FLAGS				0x000f
#define CM_CONN_IDLE				0x0000	// No connection
#define CM_CONN_SETUP_IN_PROGRESS	0x0001	// Sent MakeCall/AddParty
#define CM_CONN_ACTIVE				0x0002	// Participating in ClusterControlVc
#define CM_CONN_CLOSING				0x0004	// Sent CloseCall/DropParty
#define CM_INVALID					0x8000	// Invalidated entry

#define CM_GROUP_FLAGS				0x0010
#define CM_GROUP_ACTIVE				0x0000	// Ok to add groups
#define CM_GROUP_DISABLED			0x0010	// Don't add any more groups.



//
// This represents a member of a multicast address. There is one
// of this for every node that joins a class-D address. That is,
// this structure represents a <MulticastGroup, ClusterMember> relation.
//
typedef struct _GROUP_MEMBER
{
	ENTRY_HDR;										// Must be the first entry
	struct _MARS_ENTRY *		pMarsEntry;			// Pointer to group info
	PCLUSTER_MEMBER				pClusterMember;		// Cluster Member Joining this group
	struct _GROUP_MEMBER *		pNextGroup;			// Next group this CM has JOINed
	ULONG						Flags;
} GROUP_MEMBER, *PGROUP_MEMBER;

#define NULL_PGROUP_MEMBER		((PGROUP_MEMBER)NULL)


//
// This represents a multi-cast IP address. These are linked to the IntF.
// It contains a list of all cluster members who have Joined the group
// identified by the address.
//
// A special entry is one with IPAddress set to 0. This entry is used to
// represent the "All multicast and broadcast" range. Cluster Members who
// Join this range are linked here.
//
typedef struct _MARS_ENTRY
{
	ENTRY_HDR;										// Must be the first entry
    IPADDR						IPAddress;			// Class D IP Addr (0 means entire
    												// multicast+broadcast range)
	PGROUP_MEMBER				pMembers;			// List of group-members (Join list)
	UINT						NumMembers;			// Size of above list
	PINTF						pIntF;				// Back pointer to the interface
} MARS_ENTRY, *PMARS_ENTRY;

#define NULL_PMARS_ENTRY		((PMARS_ENTRY)NULL)


//
// This is used to represent an address range served by MCS. These
// structures are linked to the IntF.
//
typedef struct _MCS_ENTRY
{
	ENTRY_HDR;										// Must be the first entry
	MCAST_ADDR_PAIR				GrpAddrPair;		// The range served by MCS
	PINTF						pIntF;				// Back pointer to the interface
} MCS_ENTRY, *PMCS_ENTRY;

#define NULL_PMCS_ENTRY			((PMCS_ENTRY)NULL)



//
// This represents a PMP uni-directional VC. MARS creates one for
// ClusterControl and one for ServerControl (if and when external MCS'
// are supported).
//
typedef struct _MARS_VC
{
	ULONG						VcType;
	ULONG						Flags;
	LONG						RefCount;
	NDIS_HANDLE					NdisVcHandle;
	UINT						NumParties;
	PINTF						pIntF;

} MARS_VC, *PMARS_VC;

#define NULL_PMARS_VC			((PMARS_VC)NULL)

#define MVC_CONN_FLAGS				0x0000000f
#define MVC_CONN_IDLE				0x00000000
#define MVC_CONN_SETUP_IN_PROGRESS	0x00000001	// Sent MakeCall
#define MVC_CONN_ACTIVE				0x00000002	// MakeCall success
#define MVC_CONN_NEED_CLOSE			0x00000004	// Need to CloseCall when the penultimate
												// party is gone
#define MVC_CONN_CLOSING			0x00000008	// Sent CloseCall
#define MVC_CONN_CLOSE_RECEIVED		0x00000010	// Seen IncomingCloseCall





#ifndef MAX
#define	MAX(a, b)	(((a) > (b)) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a, b)	(((a) > (b)) ? (b) : (a))
#endif


//
// Be a little generous and use 256 as space for incoming requests
//
#if 0
#define	PKT_SPACE	MAX(sizeof(ARPS_HEADER) + sizeof(ARPS_VAR_HDR), \
						sizeof(MARS_REQUEST) + sizeof(ARPS_VAR_HDR))
#else
#define	PKT_SPACE	256

#endif


#define BYTES_TO_CELLS(_b)	((_b)/48)

//
//  Rounded-off size of generic Q.2931 IE header
//
#define ROUND_OFF(_size)		(((_size) + 3) & ~0x4)

#define SIZEOF_Q2931_IE	 ROUND_OFF(sizeof(Q2931_IE))
#define SIZEOF_AAL_PARAMETERS_IE	ROUND_OFF(sizeof(AAL_PARAMETERS_IE))
#define SIZEOF_ATM_TRAFFIC_DESCR_IE	ROUND_OFF(sizeof(ATM_TRAFFIC_DESCRIPTOR_IE))
#define SIZEOF_ATM_BBC_IE			ROUND_OFF(sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE))
#define SIZEOF_ATM_BLLI_IE			ROUND_OFF(sizeof(ATM_BLLI_IE))
#define SIZEOF_ATM_QOS_IE			ROUND_OFF(sizeof(ATM_QOS_CLASS_IE))


//
//  Total space required for Information Elements in an outgoing call.
//
#define MARS_MAKE_CALL_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_TRAFFIC_DESCR_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BBC_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE + \
						SIZEOF_Q2931_IE + SIZEOF_ATM_QOS_IE )


//
//  Total space required for Information Elements in an outgoing AddParty.
//
#define MARS_ADD_PARTY_IE_SPACE (	\
						SIZEOF_Q2931_IE + SIZEOF_AAL_PARAMETERS_IE +	\
						SIZEOF_Q2931_IE + SIZEOF_ATM_BLLI_IE )


//
// Some macros to set/get state
//
#define MARS_GET_CM_CONN_STATE(_pCm)		((_pCm)->Flags & CM_CONN_FLAGS)

#define MARS_SET_CM_CONN_STATE(_pCm, _St)	\
			{ (_pCm)->Flags = ((_pCm)->Flags & ~CM_CONN_FLAGS) | (_St); }

#define MARS_GET_CM_GROUP_STATE(_pCm)		((_pCm)->Flags & CM_GROUP_FLAGS)

#define MARS_SET_CM_GROUP_STATE(_pCm, _St)	\
			{ (_pCm)->Flags = ((_pCm)->Flags & ~CM_GROUP_FLAGS) | (_St); }

#define MARS_GET_VC_CONN_STATE(_pVc)		((_pVc)->Flags & MVC_CONN_FLAGS)

#define MARS_SET_VC_CONN_STATE(_pVc, _St)	\
			{ (_pVc)->Flags = ((_pVc)->Flags & ~MVC_CONN_FLAGS) | (_St); }



#endif	// _MARS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\precomp.h ===
#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <atm.h>

#include "arp.h"
#include "timer.h"
#include "ioctl.h"
#include "intf.h"
#include "mars.h"
#include "file.h"
#include "protos.h"
#include "data.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\ioctl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    This file contains the ioctl declarations for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef	_IOCTL_
#define	_IOCTL_

#define	ARP_SERVER_DEVICE_NAME			L"\\Device\\AtmArpServer"
#define	ARP_SERVER_DOS_DEVICE_NAME		L"\\\\.\\AtmArpServer"
#define	ARP_SERVER_SYMBOLIC_NAME		L"\\DosDevices\\AtmArpServer"

#define	ARPS_IOCTL_QUERY_INTERFACES		CTL_CODE(FILE_DEVICE_NETWORK, 100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_FLUSH_ARPCACHE		CTL_CODE(FILE_DEVICE_NETWORK, 101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_ARPCACHE		CTL_CODE(FILE_DEVICE_NETWORK, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_ADD_ARPENTRY			CTL_CODE(FILE_DEVICE_NETWORK, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_IP_FROM_ATM	CTL_CODE(FILE_DEVICE_NETWORK, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_ATM_FROM_IP	CTL_CODE(FILE_DEVICE_NETWORK, 105, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define	ARPS_IOCTL_QUERY_ARP_STATISTICS	CTL_CODE(FILE_DEVICE_NETWORK, 106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_MARSCACHE		CTL_CODE(FILE_DEVICE_NETWORK, 110, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_QUERY_MARS_STATISTICS CTL_CODE(FILE_DEVICE_NETWORK, 111, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define	ARPS_IOCTL_RESET_STATISTICS 	CTL_CODE(FILE_DEVICE_NETWORK, 112, METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef enum
{
	QUERY_IP_FROM_ATM,
    QUERY_ATM_FROM_IP,
    ADD_ARP_ENTRY
} OPERATION;

//
// All Ptrs are represented by offsets from the beginning of the structures.
//
typedef	UNICODE_STRING	INTERFACE_NAME, *PINTERFACE_NAME;

typedef struct
{
	IPADDR		IpAddr;
	ATM_ADDRESS	AtmAddress;
	ATM_ADDRESS	SubAddress;
} ARPENTRY, *PARPENTRY;


typedef struct
{
	UINT			NumberOfInterfaces;
	INTERFACE_NAME	Interfaces[1];
} INTERFACES, *PINTERFACES;

typedef union
{
	INTERFACE_NAME			Name;
	ARPENTRY				ArpEntry;
} IOCTL_QA_ENTRY, *PIOCTL_QA_ENTRY;

typedef	union
{
	struct QUERY_ARP_CACHE_INPUT_PARAMS
	{
		UINT				StartEntryIndex;
		INTERFACE_NAME		Name;
	};
	struct QUERY_ARP_CACHE_OUTPUT_PARAMS
	{
		UINT				TotalNumberOfEntries;
		UINT				NumberOfEntriesInBuffer;
		ARPENTRY			Entries[1];
	} Entries;
} IOCTL_QUERY_CACHE, *PIOCTL_QUERY_CACHE;


typedef struct
{
	UINT	ElapsedSeconds;
	UINT	TotalRecvPkts;
	UINT	DiscardedRecvPkts;

	UINT	CurrentArpEntries;
	UINT	MaxArpEntries;
	UINT	Acks;
	UINT	Naks;
	UINT	CurrentClientVCs;
	UINT	MaxClientVCs;
	UINT	TotalActiveVCs;
	UINT	TotalIncomingCalls;		// for both arps and mars
	UINT	FailedIncomingCalls;	// for both arps and mars

} ARP_SERVER_STATISTICS, *PARP_SERVER_STATISTICS;

	
typedef struct
{
	UINT	ElapsedSeconds;
	UINT	TotalRecvPkts;
	UINT	DiscardedRecvPkts;

	UINT	TotalMCDataPkts;
	UINT	DiscardedMCDataPkts;
	UINT	ReflectedMCDataPkts;

	UINT	CurrentClusterMembers;
	UINT	MaxClusterMembers;
	UINT	TotalCCVCAddParties;
	UINT	FailedCCVCAddParties;

	UINT	RegistrationRequests;
	UINT	FailedRegistrations;

	UINT	TotalJoins;
	UINT	FailedJoins;
	UINT	DuplicateJoins;
	UINT 	SuccessfulVCMeshJoins;
	UINT	TotalLeaves;
	UINT	FailedLeaves;

	UINT	TotalRequests;
	UINT	Naks;
	UINT	VCMeshAcks;
	UINT	MCSAcks;

	UINT	CurrentGroups; 	// vc-mesh
	UINT	MaxGroups; 		// vc-mesh
	UINT	CurrentPromiscuous;
	UINT	MaxPromiscuous;
	UINT	MaxAddressesPerGroup;

} MARS_SERVER_STATISTICS, *PMARS_SERVER_STATISTICS;

//
//		MARS-specific entries.
//

typedef struct
{
	IPADDR	  IpAddr;
	ULONG	  Flags;     				// One or more MARSENTRY_* flags below
	ULONG	  NumAtmAddresses;
	ULONG	  OffsetAtmAddresses;		// From the start of THIS structure.
										// NOTE: we do not report subaddresses
										// Will be 0 if there are no addresses
										// present in the buffer (typically
										// because there is not enough space
										// to store them all).

} MARSENTRY, *PMARSENTRY;

#define MARSENTRY_MCS_SERVED	0x1			// Group is MCS served

#define	SIG_MARSENTRY 0xf69052f5

typedef	union
{
	struct QUERY_MARS_CACHE_INPUT_PARAMS
	{
		UINT				StartEntryIndex;
		INTERFACE_NAME		Name;
	};

	struct QUERY_MARS_CACHE_OUTPUT_PARAMS
	{
		ULONG				Sig;		// Set to SIG_MARSENTRY
		UINT				TotalNumberOfEntries;
		UINT				NumberOfEntriesInBuffer;
		MARSENTRY			Entries[1];

	} MarsCache;

} IOCTL_QUERY_MARS_CACHE, *PIOCTL_QUERY_MARS_CACHE;

#endif	// _IOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\ndis.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ndis.c

Abstract:

    This file contains the code to implement the initialization
	functions for the atmarp server.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_NDIS

NTSTATUS
ArpSInitializeNdis(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NDIS_STATUS						Status;
	NDIS_PROTOCOL_CHARACTERISTICS	Chars;
	UINT							i, j;
	PUCHAR							pTmp;

	do
	{
		INITIALIZE_SPIN_LOCK(&ArpSPktListLock);
		ExInitializeSListHead(&ArpSPktList);

		//
		// Start off by allocating packets, mdls and buffer space
		// 
		NdisAllocatePacketPoolEx(&Status,
								 &ArpSPktPoolHandle,
								 ArpSBuffers,
								 ArpSBuffers * (MAX_DESC_MULTIPLE-1),
								 sizeof(PROTOCOL_RESD));
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
	#if 0
		{
			INT SkipAll = 0;
			
			DBGPRINT(DBG_LEVEL_ERROR, ("SkipAll = 0x%p.\n", &SkipAll));
			DbgBreakPoint();

			if (SkipAll)
			{
				DBGPRINT(DBG_LEVEL_ERROR, ("ABORTING ATMARPS\n"));
				Status = STATUS_UNSUCCESSFUL;
				break;
			}
		}
	#endif // 0

		NdisAllocateBufferPool(&Status,
							   &ArpSBufPoolHandle,
							   ArpSBuffers);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
		NdisAllocatePacketPoolEx(&Status,
								 &MarsPktPoolHandle,
								 MarsPackets,
								 MarsPackets * (MAX_DESC_MULTIPLE-1),
								 sizeof(PROTOCOL_RESD));
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NdisAllocateBufferPool(&Status,
							   &MarsBufPoolHandle,
							   ArpSBuffers);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}
	
		ArpSBufferSpace = ALLOC_NP_MEM(ArpSBuffers*PKT_SPACE, POOL_TAG_BUF);
		if (ArpSBufferSpace == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		// Now that we have the packets and the buffer descriptors, allocate memory for the each of the packets
		// and queue them up in the global list. Fail only if no packets initialized.
		//
		for (i = 0, pTmp = ArpSBufferSpace;
			 i < ArpSBuffers;
			 i++, pTmp += PKT_SPACE)
		{
			PNDIS_PACKET	Pkt;
			PNDIS_BUFFER	Buf;
			PPROTOCOL_RESD	Resd;
	
			//
			// The packet pool is already allocated. NdisAllocatePacket cannot fail.
			//
			NdisAllocatePacket(&Status, &Pkt, ArpSPktPoolHandle);
			ASSERT (Status == NDIS_STATUS_SUCCESS);

			Resd = RESD_FROM_PKT(Pkt);
			InitializeListHead(&Resd->ReqList);
			NdisAllocateBuffer(&Status,
							   &Buf,
							   ArpSBufPoolHandle,
							   pTmp,
							   PKT_SPACE);
			if (Status == NDIS_STATUS_SUCCESS)
			{
				NdisChainBufferAtFront(Pkt, Buf);
				ExInterlockedPushEntrySList(&ArpSPktList,
											&Resd->FreeList,
											&ArpSPktListLock);
			}
			else
			{
				NdisFreePacket(Pkt);
				break;
			}
		}
	
		if (i == 0)
		{
			//
			// We could not initialize even one packet, quit.
			//
			break;
		}

		//
		// Now register with NDIS as a protocol. We do this last since we
		// must be ready to accept incoming bind notifications
		// 
		RtlZeroMemory(&Chars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
		Chars.MajorNdisVersion = 5;
		Chars.MinorNdisVersion = 0;
		Chars.OpenAdapterCompleteHandler = ArpSOpenAdapterComplete;
		Chars.CloseAdapterCompleteHandler = ArpSCloseAdapterComplete;
		Chars.StatusHandler = ArpSStatus;
		Chars.RequestCompleteHandler = ArpSRequestComplete;
		Chars.ReceiveCompleteHandler = ArpSReceiveComplete;
		Chars.StatusCompleteHandler = ArpSStatusComplete;
		Chars.BindAdapterHandler = ArpSBindAdapter;
		Chars.UnbindAdapterHandler = ArpSUnbindAdapter;
		Chars.PnPEventHandler = ArpSPnPEventHandler;
	
		Chars.CoSendCompleteHandler = ArpSCoSendComplete;
		Chars.CoStatusHandler = ArpSCoStatus;
		Chars.CoReceivePacketHandler = ArpSHandleArpRequest;
		Chars.CoAfRegisterNotifyHandler = ArpSCoAfRegisterNotify;
	
		RtlInitUnicodeString(&Chars.Name, SERVICE_NAME);
	
		NdisRegisterProtocol(&Status, &ArpSProtocolHandle, &Chars, sizeof(Chars));
	} while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		ArpSDeinitializeNdis();
	}

	return Status;
}


VOID
ArpSDeinitializeNdis(
	VOID
	)
{
	NDIS_STATUS				Status;
	PNDIS_PACKET			Packet;
	PSINGLE_LIST_ENTRY		Entry;
	PPROTOCOL_RESD			Resd;

	if (ArpSProtocolHandle != NULL)
	{
		NdisDeregisterProtocol(&Status, ArpSProtocolHandle);
		ArpSProtocolHandle = NULL;
	}

	while ((Entry = ExInterlockedPopEntrySList(&ArpSPktList, &ArpSPktListLock)) != NULL)
	{
		Resd = CONTAINING_RECORD(Entry, PROTOCOL_RESD, FreeList);
		Packet = CONTAINING_RECORD(Resd, NDIS_PACKET, ProtocolReserved);
		NdisFreeBuffer(Packet->Private.Head);
		NdisFreePacket(Packet);
	}

	if (ArpSBufPoolHandle != NULL)
	{
		NdisFreeBufferPool(ArpSBufPoolHandle);
		ArpSBufPoolHandle = NULL;
	}

	if (ArpSPktPoolHandle != NULL)
	{
		NdisFreePacketPool(ArpSPktPoolHandle);
		ArpSPktPoolHandle = NULL;
	}

	if (MarsBufPoolHandle != NULL)
	{
		NdisFreeBufferPool(MarsBufPoolHandle);
		MarsBufPoolHandle = NULL;
	}

	if (MarsPktPoolHandle != NULL)
	{
		NdisFreePacketPool(MarsPktPoolHandle);
		MarsPktPoolHandle = NULL;
	}

	if (ArpSBufferSpace != NULL)
	{
		FREE_MEM(ArpSBufferSpace);
        ArpSBufferSpace = NULL;
	}
}


VOID
ArpSBindAdapter(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			DeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
	)
/*++

Routine Description:

	Handle incoming bind requests here. Open the adapter, read the per-adapter registry and
	initialize the binding.

Arguments:

	Status			Placeholder for returning status
	BindContext		Opaque blob to call NdisBindAdapterComplete if we pend this
	DeviceName		The adapter name which we should bind to
	SystemSpecific1	To be used with NdisOpenProtocolConfiguration, if the per-adapter
					configuration information is stored with the adapter
	SystemSpecific2	Not currently used.

Return Value:

	Status of the per-adapter initialization

--*/
{
	PINTF		pIntF;
	NDIS_STATUS	OpenErrorStatus;
	UINT		SelectedMedium;
	NDIS_MEDIUM	SupportedMedium = NdisMediumAtm;
	KIRQL		EntryIrql;

	ARPS_GET_IRQL(&EntryIrql);

	//
	// Allocate an Interface block and initialize it
	//
	pIntF = ArpSCreateIntF(DeviceName, (PNDIS_STRING)SystemSpecific1, BindContext);
	if (pIntF != NULL)
	{
		//
		// Save the binding context
		//
		pIntF->NdisBindContext = BindContext;

		*Status = ArpSReadAdapterConfiguration(pIntF);

		if (*Status == NDIS_STATUS_SUCCESS)
		{
			//
			// Read the Arp cache in now. We prime the arp table to start off.
			//
			if (ArpSFlushTime != 0)
			{
				ArpSReadArpCache(pIntF);
			}

			//
			// Open the adapter and see if it is interesting to us (mediatype should be atm)
			//
			NdisOpenAdapter(Status,
							&OpenErrorStatus,
							&pIntF->NdisBindingHandle,
							&SelectedMedium,
							&pIntF->SupportedMedium,
							sizeof(NDIS_MEDIUM),
							ArpSProtocolHandle,
							pIntF,
							DeviceName,
							0,
							NULL);

			ARPS_CHECK_IRQL(EntryIrql);
			if (*Status != NDIS_STATUS_PENDING)
			{
				ArpSOpenAdapterComplete(pIntF, *Status, OpenErrorStatus);
			}
			ARPS_CHECK_IRQL(EntryIrql);

			*Status = NDIS_STATUS_PENDING;
		}
		else
		{
			//
			// Could not read per-adapter registry. Use defaults.
			//
			LOG_ERROR(*Status);
		}
	}
	else
	{
		*Status = NDIS_STATUS_RESOURCES;
		LOG_ERROR(Status);
	}
}


VOID
ArpSOpenAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status,
	IN	NDIS_STATUS				OpenErrorStatus
	)
/*++

Routine Description:

	Upcall from NDIS to signal completion of a NdisOpenAdapter() call.

Arguments:

	ProtocolBindingContext		Pointer to the pIntF
	Status						Status of NdisOpenAdapter
	OpenErrorStatus				Adapter's code

Return Value:


--*/
{
	PINTF						pIntF = (PINTF)ProtocolBindingContext;

	//
	// First complete the pending bind call.
	//
	NdisCompleteBindAdapter(pIntF->NdisBindContext, Status, OpenErrorStatus);
	pIntF->NdisBindContext = NULL;	// We do not need this anymore

    if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		// NdisOpenAdapter() failed - log an error and exit
		//
		LOG_ERROR(Status);
		ArpSCloseAdapterComplete(pIntF, Status);
	}
	else
	{
		pIntF->Flags |= INTF_ADAPTER_OPENED;
		ArpSQueryAdapter(pIntF);
	}
}


VOID
ArpSCoAfRegisterNotify(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY		AddressFamily
	)
/*++

Routine Description:


Arguments:


Return Value:

	None.

--*/
{
	PINTF						pIntF = (PINTF)ProtocolBindingContext;
	NDIS_STATUS					Status;
	NDIS_CLIENT_CHARACTERISTICS	Chars;
	KIRQL						EntryIrql;

	ARPS_GET_IRQL(&EntryIrql);

	if ((AddressFamily->AddressFamily == CO_ADDRESS_FAMILY_Q2931)	&&
		(AddressFamily->MajorVersion == 3)							&&
        (AddressFamily->MinorVersion == 1)							&&
		(pIntF->NdisAfHandle == NULL) )
	{
		DBGPRINT(DBG_LEVEL_NOTICE,
			("AfNotify: IntF %x, Name %Z\n", pIntF, &pIntF->InterfaceName));

		if (ArpSReferenceIntF(pIntF))
		{
			//
			// We successfully opened the adapter. Now open the address-family
			//
			pIntF->AddrFamily.AddressFamily = CO_ADDRESS_FAMILY_Q2931;
			pIntF->AddrFamily.MajorVersion = 3;
			pIntF->AddrFamily.MinorVersion = 1;
			
			ZERO_MEM(&Chars, sizeof(NDIS_CLIENT_CHARACTERISTICS));
			Chars.MajorVersion = 5;
			Chars.MinorVersion = 0;
			Chars.ClCreateVcHandler = ArpSCreateVc;
			Chars.ClDeleteVcHandler = ArpSDeleteVc;
			Chars.ClRequestHandler = ArpSCoRequest;
			Chars.ClRequestCompleteHandler = ArpSCoRequestComplete;
			Chars.ClOpenAfCompleteHandler = ArpSOpenAfComplete;
			Chars.ClCloseAfCompleteHandler = ArpSCloseAfComplete;
			Chars.ClRegisterSapCompleteHandler = ArpSRegisterSapComplete;
			Chars.ClDeregisterSapCompleteHandler = ArpSDeregisterSapComplete;
			Chars.ClMakeCallCompleteHandler = ArpSMakeCallComplete;
			Chars.ClModifyCallQoSCompleteHandler = NULL;
			Chars.ClCloseCallCompleteHandler = ArpSCloseCallComplete;
			Chars.ClAddPartyCompleteHandler = ArpSAddPartyComplete;
			Chars.ClDropPartyCompleteHandler = ArpSDropPartyComplete;
			Chars.ClIncomingCallHandler = ArpSIncomingCall;
			Chars.ClIncomingCallQoSChangeHandler = ArpSIncomingCallQoSChange;
			Chars.ClIncomingCloseCallHandler = ArpSIncomingCloseCall;
			Chars.ClIncomingDropPartyHandler = ArpSIncomingDropParty;
			Chars.ClCallConnectedHandler = ArpSCallConnected;
			
			Status = NdisClOpenAddressFamily(pIntF->NdisBindingHandle,
											 &pIntF->AddrFamily,
											 pIntF,			// Use this as the Af context too
											 &Chars,
											 sizeof(NDIS_CLIENT_CHARACTERISTICS),
											 &pIntF->NdisAfHandle);
			ARPS_CHECK_IRQL(EntryIrql);
			if (Status != NDIS_STATUS_PENDING)
			{
				ARPS_CHECK_IRQL(EntryIrql);
				ArpSOpenAfComplete(Status, pIntF, pIntF->NdisAfHandle);
				ARPS_CHECK_IRQL(EntryIrql);
			}
		}
		else
		{
			ARPS_CHECK_IRQL(EntryIrql);
			ArpSTryCloseAdapter(pIntF);
			ARPS_CHECK_IRQL(EntryIrql);
		}
	}
	ARPS_CHECK_IRQL(EntryIrql);
}

VOID
ArpSOpenAfComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisAfHandle
	)
/*++

Routine Description:

	Completion processing for the OpenAf call.

Arguments:

	Status				Status of OpenAf
	ProtocolAfContext	Pointer to the pIntF
	NdisAfHandle		Ndis Handle to refer to this Af

Return Value:


--*/
{
	PINTF			pIntF = (PINTF)ProtocolAfContext;
	PCO_SAP			Sap;
	KIRQL			OldIrql;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pIntF->NdisAfHandle = NdisAfHandle;
	
		if (ArpSReferenceIntF(pIntF))
		{
			//
			// Insert this into the global adapter list
			//
			ACQUIRE_SPIN_LOCK(&ArpSIfListLock, &OldIrql);

			ACQUIRE_SPIN_LOCK_DPC(&pIntF->Lock);

			pIntF->Flags |= INTF_AF_OPENED;
			pIntF->Next = ArpSIfList;
			ArpSIfList = pIntF;
			ArpSIfListSize++;
	
			RELEASE_SPIN_LOCK_DPC(&pIntF->Lock);
			RELEASE_SPIN_LOCK(&ArpSIfListLock, OldIrql);
	
			//
			// Now register a SAP on this interface
			//
			ArpSRegisterSap(pIntF);
		}
		else
		{
			NDIS_STATUS	Sts;

			Sts = NdisClCloseAddressFamily(pIntF->NdisAfHandle);
			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSCloseAfComplete(Status, pIntF);
			}
		}
	}
	else
	{
		//
		// Failed to open the Address family. Cleanup and exit
		//
		LOG_ERROR(Status);

		ArpSTryCloseAdapter(pIntF);

	}
}


VOID
ArpSRegisterSap(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Register the Sap for receiving incoming calls. De-register any existing saps (this can
	happen if an address change happens).

Arguments:


Return Value:


--*/
{
	NDIS_STATUS		Status;
	PATM_SAP		pAtmSap;
	PATM_ADDRESS	pAtmAddress;

	//
	// Kill previous sap if any and register a new one. Save this while we
	// register the new one. We kill this regardless of whether the new one
	// successfully registers or not - since the address has potentially changed
	//
	if (pIntF->NdisSapHandle != NULL)
	{
		Status = NdisClDeregisterSap(pIntF->NdisSapHandle);
		pIntF->NdisSapHandle = NULL;
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSDeregisterSapComplete(Status, pIntF);
		}
	}

	do
	{
		//
		// Allocate memory for registering the SAP, if doing it for the first time.
		//
		if (pIntF->Sap == NULL)
		{
			pIntF->Sap = (PCO_SAP)ALLOC_NP_MEM(sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS), POOL_TAG_SAP);
		}
	
		if (pIntF->Sap == NULL)
		{
			LOG_ERROR(Status);
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		else
		{
			ZERO_MEM(pIntF->Sap, sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS));
			pAtmSap = (PATM_SAP)pIntF->Sap->Sap;
			pAtmAddress = (PATM_ADDRESS)(pAtmSap->Addresses);
					
			pIntF->Sap->SapType = SAP_TYPE_NSAP;
			pIntF->Sap->SapLength = sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);
	
			//
			//  Fill in the ATM SAP with default values
			//
			COPY_MEM(&pAtmSap->Blli, &ArpSDefaultBlli, sizeof(ATM_BLLI_IE));
			COPY_MEM(&pAtmSap->Bhli, &ArpSDefaultBhli, sizeof(ATM_BHLI_IE));

			//
			//  ATM Address to "listen" on: Wild card everything except the SEL.
			//
			pAtmSap->NumberOfAddresses = 1;
			pAtmAddress->AddressType = SAP_FIELD_ANY_AESA_REST;
			pAtmAddress->NumberOfDigits = 20;
			pAtmAddress->Address[20-1] = pIntF->SelByte;
	
			Status = NdisClRegisterSap(pIntF->NdisAfHandle,
									   pIntF,
									   pIntF->Sap,
									   &pIntF->NdisSapHandle);
			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSRegisterSapComplete(Status,
										pIntF,
										pIntF->Sap,
										pIntF->NdisSapHandle);
			}
		}
	} while (FALSE);

	if ((Status != NDIS_STATUS_SUCCESS) && (Status != NDIS_STATUS_PENDING))
	{
		Status = NdisClCloseAddressFamily(pIntF->NdisAfHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseAfComplete(Status, pIntF);
		}
	}
}


VOID
ArpSRegisterSapComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	PCO_SAP					Sap,
	IN	NDIS_HANDLE				NdisSapHandle
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF	pIntF = (PINTF)ProtocolSapContext;

	ASSERT (Sap == pIntF->Sap);
	if (Status != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(DBG_LEVEL_WARN,
			("RegisterSapComplete failed (%x): Intf %x, Name %Z\n",
				Status, pIntF, &pIntF->InterfaceName));

		LOG_ERROR(Status);
		FREE_MEM(pIntF->Sap);
		pIntF->Sap = NULL;

		ArpSDereferenceIntF(pIntF);
	}
	else
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		pIntF->Flags |= INTF_SAP_REGISTERED;
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		pIntF->NdisSapHandle = NdisSapHandle;
	}
}


VOID
ArpSDeregisterSapComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolSapContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF	pIntF = (PINTF)ProtocolSapContext;

	DBGPRINT(DBG_LEVEL_INFO,
			("DeregisterSapComplete: Intf %Z\n", &pIntF->InterfaceName));

	pIntF->NdisSapHandle = NULL;
	
	if (pIntF->Sap)
	{
		FREE_MEM(pIntF->Sap);
		pIntF->Sap = NULL;
	}

	//
	// Nothing to do here except deref the IntF block here.
	//
	ArpSDereferenceIntF(pIntF);
}


VOID
ArpSCloseAfComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF	pIntF = (PINTF)ProtocolAfContext;

	DBGPRINT(DBG_LEVEL_NOTICE,
			("CloseAfComplete: pIntF %x, Flags %x, Ref %x, Intf %Z\n",
				 pIntF, pIntF->Flags, pIntF->RefCount, &pIntF->InterfaceName));

	pIntF->NdisAfHandle = NULL;

	//
	// Nothing much to do except dereference the pIntF
	//
	ArpSDereferenceIntF(pIntF);
}


VOID
ArpSCloseAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF	pIntF = (PINTF)ProtocolBindingContext;
	KIRQL	OldIrql;
	
	DBGPRINT(DBG_LEVEL_INFO,
			("CloseAdapterComplete: Intf %Z\n", &pIntF->InterfaceName));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	//
	// Set the interface to closing
	//
	ASSERT ((pIntF->Flags & INTF_CLOSING) == 0);
	pIntF->Flags |= INTF_CLOSING;
	pIntF->NdisBindingHandle = NULL;

	//
	// Stop the timer thread
	//
	KeSetEvent(&pIntF->TimerThreadEvent, IO_NETWORK_INCREMENT, FALSE);
	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	//
	// Finally dereference it
	//
	ArpSDereferenceIntF(pIntF);
}


NDIS_STATUS
ArpSCreateVc(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisVcHandle,
	OUT	PNDIS_HANDLE			ProtocolVcContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF		pIntF = (PINTF)ProtocolAfContext;
	PARP_VC		Vc;
	KIRQL		OldIrql;
	NDIS_STATUS	Status;

	DBGPRINT(DBG_LEVEL_INFO,
			("CreateVc: NdisVcHandle %lx, Intf %Z\n", NdisVcHandle, &pIntF->InterfaceName));
	//
	// Allocate a Vc, initialize it and link it into the IntF
	//
	*ProtocolVcContext = NULL;		// Assume failure
    Status = NDIS_STATUS_RESOURCES;

	Vc = (PARP_VC)ALLOC_NP_MEM(sizeof(ARP_VC), POOL_TAG_VC);
	if (Vc != NULL)
	{
		ZERO_MEM(Vc, sizeof(ARP_VC));
		Vc->NdisVcHandle = NdisVcHandle;
		Vc->IntF = pIntF;
		Vc->RefCount = 1;	// Dereferenced when DeleteVc is called.
		Vc->VcType = VC_TYPE_INCOMING;
		if (ArpSReferenceIntF(pIntF))
		{
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

			if (++(pIntF->ArpStats.CurrentClientVCs) > pIntF->ArpStats.MaxClientVCs)
			{
					pIntF->ArpStats.MaxClientVCs = pIntF->ArpStats.CurrentClientVCs;
			}
			
			InsertHeadList(&pIntF->InactiveVcHead, &Vc->List);
			Vc->VcId = pIntF->LastVcId;
			pIntF->LastVcId ++;
			if (pIntF->LastVcId == -1)
			{
				pIntF->LastVcId = 1;
			}

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			*ProtocolVcContext = Vc;
			DBGPRINT(DBG_LEVEL_INFO,
					("CreateVc: Created Vc %lx, Id %lx\n", Vc, Vc->VcId));
			Status = NDIS_STATUS_SUCCESS;
		}
		else
		{
			FREE_MEM(Vc);	
			Status = NDIS_STATUS_CLOSING;
		}
	}

	return Status;
}


NDIS_STATUS
ArpSDeleteVc(
	IN	NDIS_HANDLE				ProtocolVcContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PARP_VC		Vc = (PARP_VC)ProtocolVcContext;

	DBGPRINT(DBG_LEVEL_INFO,
			("DeleteVc: For Vc %lx, Id %lx\n", Vc, Vc->VcId));

	Vc->IntF->ArpStats.CurrentClientVCs--;
	Vc->NdisVcHandle = NULL;
	ArpSDereferenceVc(Vc, FALSE, FALSE);

	return NDIS_STATUS_SUCCESS;
}


VOID
ArpSCoSendComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	)
/*++

Routine Description:

	Completion routine for the previously pended send. Just return the packet to the pool of free packets.


Arguments:

	Status				Status of Completion
	ProtocolVcContext	Pointer to the Vc
	Packet				The packet in question

Return Value:


--*/
{
	PARP_VC			Vc = (PARP_VC)ProtocolVcContext;
	PPROTOCOL_RESD	Resd;

	Resd = RESD_FROM_PKT(Packet);

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSCoSendComplete: Packet %lx, Vc %lx, ResdVc %lx, Id %lx\n",
				Packet, Vc, Resd->Vc, Vc->VcId));

	if (Status != NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(DBG_LEVEL_ERROR,
				("ArpSCoSendComplete: Failed for Vc = %lx, status = %lx\n", Vc, Status));
	}

	if ((Resd->Flags & RESD_FLAG_MARS_PKT) == 0)
	{
		ExInterlockedPushEntrySList(&ArpSPktList,
									&Resd->FreeList,
									&ArpSPktListLock);

		ArpSDereferenceVc(Resd->Vc, FALSE, TRUE);
	}
	else
	{
		MarsFreePacket(Packet);
	}

}


NDIS_STATUS
ArpSIncomingCall(
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS	CallParameters
	)
/*++

Routine Description:

	Handler for incoming call. We accept the call unless we are shutting down and then
	do the actual processing when the call processing completes.

Arguments:

	ProtocolSapContext		Pointer to the IntF
	ProtocolVcContext		Pointer to the Vc
    CallParameters			Call Parameters

Return Value:


--*/
{
	PINTF						pIntF = (PINTF)ProtocolSapContext;
	PARP_VC						Vc = (PARP_VC)ProtocolVcContext;
    Q2931_CALLMGR_PARAMETERS UNALIGNED *	CallMgrSpecific;
	KIRQL						OldIrql;
	NDIS_STATUS					Status = NDIS_STATUS_SUCCESS;

	ASSERT (Vc->IntF == pIntF);

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSIncomingCall: On Vc %lx, Id %lx\n", Vc, Vc->VcId));
	//
	// Mark the Vc to indicate the call processing is underway
	//
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	pIntF->ArpStats.TotalIncomingCalls++;

	ASSERT ((Vc->Flags & (ARPVC_CALLPROCESSING | ARPVC_ACTIVE | ARPVC_CALLPROCESSING)) == 0);
	Vc->Flags |= ARPVC_CALLPROCESSING;

	//
	// Get the remote atm address from the call-parameters
	//
	CallMgrSpecific = (PQ2931_CALLMGR_PARAMETERS)&CallParameters->CallMgrParameters->CallMgrSpecific.Parameters[0];
    Vc->HwAddr.Address = CallMgrSpecific->CallingParty;

	//
	// Get the max size of packets we can send on this VC, from the
	// AAL5 parameters. Limit it to the size our miniport can support.
	//
	Vc->MaxSendSize = pIntF->MaxPacketSize;	// default

	if (CallMgrSpecific->InfoElementCount > 0)
	{
		Q2931_IE UNALIGNED *			pIe;
		AAL5_PARAMETERS UNALIGNED *		pAal5;
		ULONG							IeCount;

		pIe = (PQ2931_IE)CallMgrSpecific->InfoElements;
		for (IeCount = CallMgrSpecific->InfoElementCount;
			 IeCount != 0;
			 IeCount--)
		{
			if (pIe->IEType == IE_AALParameters)
			{
				pAal5 = &(((PAAL_PARAMETERS_IE)pIe->IE)->AALSpecificParameters.AAL5Parameters);
				//
				// Make sure we don't send more than what the caller can handle.
				//
				if (pAal5->ForwardMaxCPCSSDUSize < Vc->MaxSendSize)
				{
					Vc->MaxSendSize = pAal5->ForwardMaxCPCSSDUSize;
				}

				//
				// Make sure this greater than the min allowed.
				//
				if (pAal5->ForwardMaxCPCSSDUSize < ARPS_MIN_MAX_PKT_SIZE)
				{
					DBGPRINT(DBG_LEVEL_WARN,
					("ArpSIncomingCall: Vc %lx max pkt size too small(%lu)\n",
 						Vc, Vc->MaxSendSize));
					Status = NDIS_STATUS_RESOURCES;
				}

				//
				// Make sure the caller doesn't send more than what our
				// miniport can handle.
				//
				if (pAal5->BackwardMaxCPCSSDUSize > pIntF->MaxPacketSize)
				{
					pAal5->BackwardMaxCPCSSDUSize = pIntF->MaxPacketSize;
				}
				break;
			}
			pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
		}
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	return Status;
}

VOID
ArpSCallConnected(
	IN	NDIS_HANDLE				ProtocolVcContext
	)
/*++

Routine Description:

	Last hand-shake in the incoming call path. Move the Vc to the list of active calls.

Arguments:

	ProtocolVcContext	Pointer to VC

Return Value:

	None.

--*/
{
	PARP_VC		Vc = (PARP_VC)ProtocolVcContext;
	PINTF		pIntF;
	KIRQL		OldIrql;

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSCallConnected: On Vc %lx, Id %lx\n", Vc, Vc->VcId));


	pIntF = Vc->IntF;
	pIntF->ArpStats.TotalActiveVCs++;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	ASSERT((Vc->Flags & ARPVC_ACTIVE) == 0);
	ASSERT(Vc->Flags & ARPVC_CALLPROCESSING);

	Vc->Flags |= ARPVC_ACTIVE;
	Vc->Flags &= ~ARPVC_CALLPROCESSING;

	RemoveEntryList(&Vc->List);
	InsertHeadList(&pIntF->ActiveVcHead, &Vc->List);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
}


VOID
ArpSMakeCallComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	NDIS_HANDLE				NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS		CallParameters
	)
/*++

Routine Description:

	Handle completion of an earlier call to NdisClMakeCall. The only
	outgoing call is for ClusterControlVc. If the status indicates
	success, AddParty's are initiated for all pending Cluster members.
	Otherwise, this cluster member is deleted, and if there are any
	other cluster members in the list, we initiate a MakeCall with
	one of them.

Arguments:

	Status				Result of NdisClMakeCall
	ProtocolVcContext	Pointer to ClusterControlVc
	NdisPartyHandle		If successful, the handle for this party
	CallParameters		Pointer to Call parameters

Return Value:

	None.

--*/
{
	KIRQL				OldIrql;
	PINTF				pIntF;
	PMARS_VC			pVc;
	PCLUSTER_MEMBER		pMember;
	PCLUSTER_MEMBER		pNextMember;
	NDIS_HANDLE         NdisVcHandle;

	pVc = (PMARS_VC)ProtocolVcContext;

	if (pVc->VcType == VC_TYPE_CHECK_REGADDR)
	{
		ArpSMakeRegAddrCallComplete(
				Status,
				(PREG_ADDR_CTXT) ProtocolVcContext
				);
		return;						// ******  EARLY RETURN ****************
	}
	
	pIntF = pVc->pIntF;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("MakeCallComplete: Status %x, pVc %x, VC ConnState %x\n",
				Status, pVc, MARS_GET_VC_CONN_STATE(pVc)));

	FREE_MEM(CallParameters);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	//
	// Get the Cluster member we were trying to connect to.
	// 
	for (pMember = pIntF->ClusterMembers;
		 pMember != NULL_PCLUSTER_MEMBER;
		 pMember = (PCLUSTER_MEMBER)pMember->Next)
	{
		if (MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_SETUP_IN_PROGRESS)
		{
			break;
		}
	}
	ASSERT(pMember != NULL_PCLUSTER_MEMBER);

	pIntF->CCAddingParties--;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		ASSERT(NdisPartyHandle != NULL);
		MARS_SET_CM_CONN_STATE(pMember, CM_CONN_ACTIVE);
		pMember->NdisPartyHandle = NdisPartyHandle;

		pIntF->CCActiveParties++;

		if (pMember->Flags & CM_INVALID)
		{
			//
			// Deleting was deferred because the connection was being
			// setup. Now that it's up, strictly speaking we should
			// try to delete it again, BUT we don't because we
			// may also need to add other members now, and we can't really
			// drop the call itself while we're adding other parties!
			//
			MARSDBGPRINT(DBG_LEVEL_WARN,
					("pMember 0x%p is INVALID, but NOT dropping CCVC call.\n",
					 pMember));

			// do nothing...
		}

		if (MARS_GET_VC_CONN_STATE(pVc) == MVC_CONN_SETUP_IN_PROGRESS)
		{
			MARS_SET_VC_CONN_STATE(pVc, MVC_CONN_ACTIVE);

			//
			// Add all pending cluster members as parties
			//
			for (pMember = pIntF->ClusterMembers;
				 pMember != NULL_PCLUSTER_MEMBER;
				 pMember = pNextMember)
			{
				pNextMember = (PCLUSTER_MEMBER)pMember->Next;

				if (MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_IDLE)
				{
					RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

					MarsAddMemberToClusterControlVc(pIntF, pMember);

					ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

					if (!MarsIsValidClusterMember(pIntF, pNextMember))
					{
						//
						// Oops, the next member has gone away in the
						// mean time. In this unlikely case, we simply
						// quit processing the list early.
						//
						break;
					}
				}
			}

			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			//
			// Send off any queued packets, if we can.
			//
			MarsSendOnClusterControlVc(pIntF, NULL);
		}
		else
		{
			BOOLEAN fLocked;
			//
			// We are closing down.
			//
			MARS_SET_VC_CONN_STATE(pVc, MVC_CONN_ACTIVE);
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

			fLocked = MarsDelMemberFromClusterControlVc(pIntF, pMember, FALSE, 0);
			ASSERT(!fLocked);
		}
	}
	else
	{
		MARSDBGPRINT(DBG_LEVEL_WARN,
					("MakeCall error %x, pMember %x to addr:", Status, pMember));
		MARSDUMPATMADDR(DBG_LEVEL_WARN, &pMember->HwAddr.Address, "");
					
		//
		// Connection failed. Delete this member from our Cluster member list.
		//
		pIntF->MarsStats.FailedCCVCAddParties++;
		MarsDeleteClusterMember(pIntF, pMember);

		MARS_SET_VC_CONN_STATE(pVc, MVC_CONN_IDLE);

		//
		// See if we have other Cluster members. If so, pick up one
		// of them and re-initiate the ClusterControlVc.
		//
		for (pMember = pIntF->ClusterMembers;
 			 pMember != NULL_PCLUSTER_MEMBER;
 			 pMember = (PCLUSTER_MEMBER)pMember->Next)
		{
			if (MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_IDLE)
			{
				break;
			}
		}

		if (pMember == NULL_PCLUSTER_MEMBER)
		{
		    //
		    //  No other cluster members, so we'll tear down the CC VC.
		    //
			NdisVcHandle = pIntF->ClusterControlVc->NdisVcHandle;
    		DBGPRINT(DBG_LEVEL_ERROR,
			    ("ATMARPS: pIntF %x, deleting CC VC, VcHandle %x\n", pIntF, NdisVcHandle));
			FREE_MEM(pIntF->ClusterControlVc);
			pIntF->ClusterControlVc = NULL;
		}

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		if (pMember != NULL_PCLUSTER_MEMBER)
		{
			MarsAddMemberToClusterControlVc(pIntF, pMember);
		}
		else
		{
			Status = NdisCoDeleteVc(NdisVcHandle);
			ASSERT(Status == NDIS_STATUS_SUCCESS);
			MarsFreePacketsQueuedForClusterControlVc(pIntF);
		}
	}

}


VOID
ArpSIncomingCloseCall(
	IN	NDIS_STATUS				CloseStatus,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PVOID					CloseData	OPTIONAL,
	IN	UINT					Size		OPTIONAL
	)
/*++

Routine Description:

	Indication of an incoming close call from the network. If this
	is not on ClusterControlVc, then we mark the VC as inactive, and
	move it to the Inactive VC list. If this is on ClusterControlVc,
	there must be only one party on the PMP connection. We update
	that member's state.

	In any case, we call NdisClCloseCall to complete the handshake.

Arguments:

	CloseStatus			Status of Close
	ProtocolVcContext	Pointer to VC (ARP_VC or MARS_VC)
	CloseData			Optional Close data (IGNORED)
	Size				Size of Optional Close Data (OPTIONAL)

Return Value:

	None

--*/
{
	PARP_VC			Vc = (PARP_VC)ProtocolVcContext;
	PMARS_VC		pMarsVc;
	PINTF			pIntF;
	NDIS_STATUS		Status;

	if (Vc->VcType == VC_TYPE_INCOMING)
	{
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSIncomingCloseCall: On Vc %lx, Id %lx\n",
				 ProtocolVcContext, Vc->VcId));

		ArpSInitiateCloseCall(Vc);
	}
	else if (Vc->VcType == VC_TYPE_CHECK_REGADDR)
	{
		ArpSIncomingRegAddrCloseCall(
			CloseStatus, 
			(PREG_ADDR_CTXT) ProtocolVcContext
			);
	}
	else
	{
		ASSERT(Vc->VcType == VC_TYPE_MARS_CC);
		pMarsVc = (PMARS_VC)ProtocolVcContext;
		pIntF = pMarsVc->pIntF;
		MARS_SET_VC_CONN_STATE(pMarsVc, MVC_CONN_CLOSE_RECEIVED);
		{
			PPROTOCOL_RESD		Resd;

			Resd = ALLOC_NP_MEM(sizeof(PROTOCOL_RESD), POOL_TAG_MARS);
			if (Resd != NULL)
			{
				Resd->Flags = RESD_FLAG_KILL_CCVC;
				Resd->Vc = (PARP_VC)pIntF;
				KeInsertQueue(&MarsReqQueue, &Resd->ReqList);
			}
			else
			{
				MarsAbortAllMembers(pIntF);
			}
		}
	}

}


VOID
ArpSCloseCallComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	NDIS_HANDLE				ProtocolPartyContext OPTIONAL
	)
/*++

Routine Description:

	This is called to complete our call to NdisClCloseCall. If the VC
	is other than ClusterControlVc, we simply update its state.

	If this is on ClusterControlVc, we delete the last member.

Arguments:

	CloseStatus				Status of Close
	Status					Status of NdisClCloseCall
	ProtocolVcContext		Pointer to our VC structure
	ProtocolPartyContext	If the VC is ClusterControlVc, this is a pointer
							to the Cluster Member that was disconnected.

Return Value:

	None

--*/
{
	PARP_VC				Vc = (PARP_VC)ProtocolVcContext;
	PMARS_VC			pMarsVc;
	PCLUSTER_MEMBER		pMember;
	PINTF				pIntF;
	KIRQL				OldIrql;
	BOOLEAN				bStopping;
	NDIS_HANDLE			NdisVcHandle;

	ASSERT(Status == NDIS_STATUS_SUCCESS);

	if (Vc->VcType == VC_TYPE_INCOMING)
	{
		pIntF = Vc->IntF;

		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSCloseCallComplete: On Vc %lx\n", Vc));

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

		ASSERT ((Vc->Flags & ARPVC_CLOSING) != 0);
		Vc->Flags &= ~ARPVC_CLOSING;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}
	else if (Vc->VcType == VC_TYPE_CHECK_REGADDR)
	{
		ArpSCloseRegAddrCallComplete(
				Status,
				(PREG_ADDR_CTXT) ProtocolVcContext
				);
	}
	else
	{
		//
		//  Must be ClusterControlVc
		//
		pMarsVc = (PMARS_VC)ProtocolVcContext;
		pIntF = pMarsVc->pIntF;

		ASSERT(pMarsVc == pIntF->ClusterControlVc);

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		MARS_SET_VC_CONN_STATE(pMarsVc, MVC_CONN_IDLE);

		pMember = (PCLUSTER_MEMBER)ProtocolPartyContext;
		MARS_SET_CM_CONN_STATE(pMember, CM_CONN_IDLE);

		ASSERT(pIntF->CCAddingParties == 0);

		pIntF->CCActiveParties = pIntF->CCDroppingParties = pIntF->CCAddingParties = 0;

		bStopping = ((pIntF->Flags & INTF_STOPPING) != 0);

		MarsDeleteClusterMember(pIntF, pMember);

		ARPS_ASSERT(pIntF->ClusterControlVc);
		NdisVcHandle = pIntF->ClusterControlVc->NdisVcHandle;
		FREE_MEM(pIntF->ClusterControlVc);
		pIntF->ClusterControlVc = NULL;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		if (NdisVcHandle != NULL)
		{
			(VOID)NdisCoDeleteVc(NdisVcHandle);
		}

	}

}


VOID
ArpSAddPartyComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolPartyContext,
	IN	NDIS_HANDLE				NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS		CallParameters
	)
/*++

Routine Description:

	Completion of NdisClAddParty to add a new party to ClusterControlVc.
	If successful, update the member's state. Otherwise, delete it.

Arguments:

	Status					Status of AddParty
	ProtocolPartyContext	Pointer to Cluster Member being added
	NdisPartyHandle			Valid if AddParty successful
	CallParameters			Pointer to AddParty call parameters

Return Value:

	None

--*/
{
	PCLUSTER_MEMBER		pMember;
	PINTF				pIntF;
	KIRQL				OldIrql;

	FREE_MEM(CallParameters);

	pMember = (PCLUSTER_MEMBER)ProtocolPartyContext;
	pIntF = pMember->pIntF;

	MARSDBGPRINT(DBG_LEVEL_LOUD,
			("AddPartyComplete: Status %x, pMember %x, NdisPartyHandle %x\n",
					Status, pMember, NdisPartyHandle));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	ASSERT(pMember->pGroupList == NULL_PGROUP_MEMBER);

	pIntF->CCAddingParties--;	// AddPartyComplete

	if (Status == NDIS_STATUS_SUCCESS)
	{
		MARS_SET_CM_CONN_STATE(pMember, CM_CONN_ACTIVE);
		pMember->NdisPartyHandle = NdisPartyHandle;
		pIntF->CCActiveParties++;	// AddPartyComplete

		if (pMember->Flags & CM_INVALID)
		{
			//
			// Deleting was deferred because the connection was being
			// setup. Now that it's up, we will try to delete it again
			// (should have better luck this time!).
			//
			BOOLEAN fLocked;
			fLocked = MarsDelMemberFromClusterControlVc(
							pIntF,
							pIntF->ClusterMembers,
							TRUE,
							OldIrql
							);
			if(!fLocked)
			{
				ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
			}
			
		}
	}
	else
	{
		MARSDBGPRINT(DBG_LEVEL_WARN,
				("AddParty Failed: pMember %x, Status %x, Addr: ",
					pMember, Status));
		MARSDUMPATMADDR(DBG_LEVEL_WARN, &pMember->HwAddr.Address, "");
		pIntF->MarsStats.FailedCCVCAddParties++;

		MARS_SET_CM_CONN_STATE(pMember, CM_CONN_IDLE);
		MarsDeleteClusterMember(pIntF, pMember);
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	//
	// Send any queued packets, if appropriate.
	//
	MarsSendOnClusterControlVc(pIntF, NULL);
}


VOID
ArpSDropPartyComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolPartyContext
	)
/*++

Routine Description:

	This is called to signify completion of a previous NdisClDropParty,
	to drop a cluster member off the ClusterControlVc. Delete the member.

Arguments:

	Status					Status of DropParty
	ProtocolPartyContext	Pointer to Cluster Member being dropped

Return Value:

	None.

--*/
{
	KIRQL					OldIrql;
	PCLUSTER_MEMBER			pMember;
	PINTF					pIntF;
	PMARS_VC				pVc;
	BOOLEAN					IsVcClosing;

	ASSERT(Status == NDIS_STATUS_SUCCESS);
	pMember = (PCLUSTER_MEMBER)ProtocolPartyContext;
	pIntF = pMember->pIntF;
	ASSERT(pIntF->ClusterControlVc != NULL_PMARS_VC);

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	MARS_SET_CM_CONN_STATE(pMember, CM_CONN_IDLE);
	pIntF->CCDroppingParties--;

	//
	// Check if we are closing ClusterControlVc, and just one party is left.
	//
	pVc = pIntF->ClusterControlVc;
	IsVcClosing = ((MARS_GET_VC_CONN_STATE(pVc) == MVC_CONN_NEED_CLOSE) &&
				   (pIntF->CCActiveParties == 1) &&
				   (pIntF->CCAddingParties + pIntF->CCDroppingParties == 0));

	MarsDeleteClusterMember(pIntF, pMember);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	if (IsVcClosing)
	{
		BOOLEAN fLocked;
		fLocked = MarsDelMemberFromClusterControlVc(
						pIntF,
						pIntF->ClusterMembers,
						FALSE,
						0
						);
		ASSERT(!fLocked);
	}
}


VOID
ArpSIncomingDropParty(
	IN	NDIS_STATUS				DropStatus,
	IN	NDIS_HANDLE				ProtocolPartyContext,
	IN	PVOID					CloseData	OPTIONAL,
	IN	UINT					Size		OPTIONAL
	)
/*++

Routine Description:

	Indication that a Cluster Member has dropped off the ClusterControlVc.
	We complete this handshake by calling NdisClDropParty.

Arguments:

	DropStatus				Status
	ProtocolPartyContext	Pointer to Cluster Member
	CloseData				Optional Close data (IGNORED)
	Size					Size of Optional Close Data (OPTIONAL)

Return Value:

	None

--*/
{
	PCLUSTER_MEMBER			pMember;
	PINTF					pIntF;
	KIRQL					OldIrql;

	pMember = (PCLUSTER_MEMBER)ProtocolPartyContext;
	pIntF = pMember->pIntF;
	ASSERT(MARS_GET_CM_CONN_STATE(pMember) == CM_CONN_ACTIVE);

	MARSDBGPRINT(DBG_LEVEL_NOTICE,
			("IncomingDropParty: pIntF %x, pMember %x, Addr: ", pIntF, pMember));
	MARSDUMPATMADDR(DBG_LEVEL_NOTICE, &pMember->HwAddr.Address, "");

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	//
	// Remove its membership from all groups.
	// AND disable further groups from being added.
	//
	MarsUnlinkAllGroupsOnClusterMember(pIntF, pMember);

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	{
		BOOLEAN fLocked;
		fLocked = MarsDelMemberFromClusterControlVc(pIntF, pMember, FALSE, 0);
		ASSERT(!fLocked);
	}
}


NDIS_STATUS
ArpSCoRequest(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST		NdisRequest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF		pIntF = (PINTF)ProtocolAfContext;
	KIRQL		OldIrql;
	BOOLEAN		ValidAf;

	DBGPRINT(DBG_LEVEL_INFO,
			("CallMgrRequest: Request %lx, Type %d, OID %lx\n",
			 NdisRequest, NdisRequest->RequestType, NdisRequest->DATA.SET_INFORMATION.Oid));

	switch(NdisRequest->DATA.SET_INFORMATION.Oid)
	{
	  case OID_CO_ADDRESS_CHANGE:
		ValidAf = FALSE;
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		pIntF->Flags |= INTF_ADDRESS_VALID;
		ValidAf = ((pIntF->Flags & INTF_AF_OPENED) != 0);
		pIntF->NumAddressesRegd = 0;
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	
		if (ValidAf)
		{
			ArpSQueryAndSetAddresses(pIntF);
		}
		break;

	 case OID_CO_AF_CLOSE:
#if DBG
		DbgPrint("atmarps: OID_CO_AF_CLOSE\n");
#endif
		if (ArpSReferenceIntF(pIntF))
		{
			//
			// ArpSStopInterface dereferences the pIntF
			//
			(VOID)ArpSStopInterface(pIntF, FALSE);
		}
	 	break;

	 default:
	 	break;
	}

	return NDIS_STATUS_SUCCESS;
}


VOID
ArpSCoRequestComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST			NdisRequest
	)
/*++

Routine Description:

	Completion routine for the NdisCoRequest api.

Arguments:

	Status					Status of completion
	ProtocolAfContext		Pointer to the IntF structure
	ProtocolVcContext		Pointer to the VC structure
	ProtocolPartyContext	Not used by us since we do not make calls
	NdisRequest				Pointer to the request structure

Return Value:

	None

--*/
{
	PINTF			pIntF = (PINTF)ProtocolAfContext;
	BOOLEAN			FreeReq = TRUE;
	KIRQL			OldIrql;
	PKEVENT 		pEvent = NULL;

	DBGPRINT(DBG_LEVEL_INFO,
			 ("CoRequestComplete: Request %lx, Type %d, OID %lx\n",
			 NdisRequest, NdisRequest->RequestType, NdisRequest->DATA.QUERY_INFORMATION.Oid));

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	switch(NdisRequest->DATA.SET_INFORMATION.Oid)
	{
	  case OID_CO_ADD_ADDRESS:
		if (Status == NDIS_STATUS_SUCCESS)
		{
			DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: Registered address # %d\n", pIntF->NumAddressesRegd+1));
		
			if (pIntF->NumAddressesRegd < pIntF->NumAllocedRegdAddresses)
			{
				PCO_ADDRESS	pCoAddr;
				PATM_ADDRESS pAddress;

				// Copy the registered address from the ndis request into the
				// array of registered addresses.
				//
				pCoAddr = NdisRequest->DATA.SET_INFORMATION.InformationBuffer;
				pAddress =  (PATM_ADDRESS)(pCoAddr->Address);
				pIntF->RegAddresses[pIntF->NumAddressesRegd] = *pAddress;
				pIntF->NumAddressesRegd ++;
			}
			else
			{
				//
				// 12/22/1998 JosephJ
				// We could potentially get here if the total number of outstanding add address requests
				// is greater then NumAllocedRegAddresses. One way this could happen is if ArpSQueryAndSetAddresses
				// is called multiple times in quick succession. Note that ArpSQueryAndSetAddresses is called from
				// two places: ArpSCoRequest and ArpSReqdAdaprConfiguration.
				//
				// Previously, we would increment NumAddressRegd in this condition. Now we simply ignore this.
				//
			}
		}
		else
		{
			DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: CO_ADD_ADDRESS Failed %lx\n", Status));
		}

		//
		// Try registering the next address. ArpSValidateOneRegAddress will
		// unlink and free pIntF->pRegAddrCtxt if there are no more addresses
		// to be registered.
		//
		if (pIntF->pRegAddrCtxt != NULL)
		{
			ArpSValidateOneRegdAddress(
					pIntF,
					OldIrql
					);
			//
			// Lock released by above call.
			//
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		}
		else
		{
			ASSERT(FALSE); // can't get here.
		}
		// We don't want to free this ndis request here, because it's actually
		// part of pIntF->pRegAddrCtxt.
		//
		FreeReq = FALSE;
		break;

	  case OID_CO_GET_ADDRESSES:
	  	//
	  	// (On success) We just got our configured address value.
	  	// We save this value AND THEN move on the next stage of initialization --
	  	// validating and setting the "registered" addresses -- these are the
	  	// addresses we read from the registry. See 05/14/1999 notes.txt entry
		// for details.
	  	//
		if (Status == NDIS_STATUS_SUCCESS)
		{
			PCO_ADDRESS_LIST	pCoAddrList;
			UINT				i;

			pCoAddrList = (PCO_ADDRESS_LIST)(NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer);
			ASSERT(pCoAddrList->NumberOfAddresses == 1);

			DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: Configured address, %d/%d Size %d\n",
					 pCoAddrList->NumberOfAddresses,
					 pCoAddrList->NumberOfAddressesAvailable,
					 pCoAddrList->AddressList.AddressSize));

			ASSERT(pCoAddrList->AddressList.AddressSize == (sizeof(CO_ADDRESS) + sizeof(ATM_ADDRESS)));
			COPY_MEM(&pIntF->ConfiguredAddress,
					 pCoAddrList->AddressList.Address,
					 sizeof(ATM_ADDRESS));

			DBGPRINT(DBG_LEVEL_INFO,
					("CoRequestComplete: Configured Address (%s): ",
					(pIntF->ConfiguredAddress.AddressType == ATM_E164) ? "E164" : "NSAP"));
			for (i = 0; i < pIntF->ConfiguredAddress.NumberOfDigits; i++)
			{
				DBGPRINT(DBG_LEVEL_INFO + DBG_NO_HDR,
						("%02x ", pIntF->ConfiguredAddress.Address[i]));
			}
			DBGPRINT(DBG_LEVEL_INFO | DBG_NO_HDR, ("\n"));

		}
		else
		{
			DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: CO_GET_ADDRESS Failed %lx\n", Status));
		}

		//
		// Validate  and set the registered addresses.
		//
		ArpSValidateAndSetRegdAddresses(pIntF, OldIrql);

		// IntF lock released by the above.
		//
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		break;

	  case OID_CO_DELETE_ADDRESS:
	  		DBGPRINT(DBG_LEVEL_INFO,
					 ("CoRequestComplete: Deleted address. Status=%x\n", Status));
		if (pIntF->DelAddressesEvent != NULL)
		{
			// Someone's waiting for all the addresses to be deleted...
			//

			ASSERT(pIntF->NumPendingDelAddresses >  0);
			if (--(pIntF->NumPendingDelAddresses) == 0)
			{
				// Deletion of all addresses is over, signal the event.
				//
				pEvent = pIntF->DelAddressesEvent;
				pIntF->DelAddressesEvent = NULL;
			}
		}
	  	break;
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	if (pEvent != NULL)
	{
		KeSetEvent(pEvent, IO_NETWORK_INCREMENT, FALSE);
	}

	if (FreeReq)
	{
		FREE_MEM(NdisRequest);
	}
}


VOID
ArpSIncomingCallQoSChange(
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS		CallParameters
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_LEVEL_WARN, ("QoSChange: Ignored\n"));
}



VOID
ArpSQueryAdapter(
	IN	PINTF					pIntF
)
/*++

Routine Description:

	Query the miniport we are bound to for the following info:
	1. Line rate
	2. Max packet size

	These will overwrite the defaults we set up in ArpSCreateIntF.

Arguments:

	pIntF		Pointer to Interface

Return Value:

	None

--*/
{

	ArpSSendNdisRequest(pIntF,
						OID_GEN_CO_LINK_SPEED,
						(PVOID)&(pIntF->LinkSpeed),
						sizeof(NDIS_CO_LINK_SPEED));

	ArpSSendNdisRequest(pIntF,
						OID_ATM_MAX_AAL5_PACKET_SIZE,
						(PVOID)&(pIntF->MaxPacketSize),
						sizeof(ULONG));
}




VOID
ArpSSendNdisRequest(
	IN	PINTF					pIntF,
	IN	NDIS_OID				Oid,
	IN	PVOID					pBuffer,
	IN	ULONG					BufferLength
)
/*++

Routine Description:

	NDIS Request generator, for sending NDIS requests to the miniport.

Arguments:

	pIntF			Ptr to Interface
	Oid				The parameter being queried
	pBuffer			Points to parameter
	BufferLength	Length of above

Return Value:

	None

--*/
{
	NDIS_STATUS				Status;
	PNDIS_REQUEST			pRequest;

	pRequest = (PNDIS_REQUEST)ALLOC_NP_MEM(sizeof(NDIS_REQUEST), POOL_TAG_INTF);
	if (pRequest == (PNDIS_REQUEST)NULL)
	{
		return;
	}

	ZERO_MEM(pRequest, sizeof(NDIS_REQUEST));

	//
	// Query for the line rate.
	//
	pRequest->DATA.QUERY_INFORMATION.Oid = Oid;
	pRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
	pRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
	pRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
	pRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;

	NdisRequest(&Status,
				pIntF->NdisBindingHandle,
				pRequest);

	if (Status != NDIS_STATUS_PENDING)
	{
		ArpSRequestComplete(
				(NDIS_HANDLE)pIntF,
				pRequest,
				Status);
	}
}




VOID
ArpSRequestComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_REQUEST			pRequest,
	IN	NDIS_STATUS				Status
)
/*++

Routine Description:

	Completion of our call to NdisRequest(). Do some follow-up.

Arguments:

	ProtocolBindingContext		Pointer to IntF
	pRequest					The request that just completed
	Status						Status of NdisRequest()

Return Value:

	None

--*/
{
	PINTF			pIntF;

	pIntF = (PINTF)ProtocolBindingContext;

	switch (pRequest->DATA.QUERY_INFORMATION.Oid)
	{
		case OID_ATM_MAX_AAL5_PACKET_SIZE:
			if (pIntF->MaxPacketSize < pIntF->CCFlowSpec.SendMaxSize)
			{
				pIntF->CCFlowSpec.SendMaxSize =
				pIntF->CCFlowSpec.ReceiveMaxSize = pIntF->MaxPacketSize;
			}
			DBGPRINT(DBG_LEVEL_INFO,
					("Miniport Max AAL5 Packet Size: %d (decimal)\n",
						pIntF->MaxPacketSize));
			break;
		case OID_GEN_CO_LINK_SPEED:
			//
			// Convert to bytes/sec
			//
			pIntF->LinkSpeed.Outbound = (pIntF->LinkSpeed.Outbound * 100 / 8);
			pIntF->LinkSpeed.Inbound = (pIntF->LinkSpeed.Inbound * 100 / 8);
			if (pIntF->LinkSpeed.Outbound < pIntF->CCFlowSpec.SendBandwidth)
			{
				pIntF->CCFlowSpec.SendBandwidth = pIntF->LinkSpeed.Outbound;
			}
			if (pIntF->LinkSpeed.Inbound < pIntF->CCFlowSpec.ReceiveBandwidth)
			{
				pIntF->CCFlowSpec.ReceiveBandwidth = pIntF->LinkSpeed.Inbound;
			}
			DBGPRINT(DBG_LEVEL_INFO,
					("Miniport Link Speed (decimal, bytes/sec): In %d, Out %d\n",
					pIntF->LinkSpeed.Inbound, pIntF->LinkSpeed.Outbound));
			break;
		default:
			ASSERT(FALSE);
			break;
	}

	FREE_MEM(pRequest);
}




VOID
ArpSUnbindAdapter(
	OUT	PNDIS_STATUS			UnbindStatus,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PINTF			pIntF = (PINTF)ProtocolBindingContext;

	DBGPRINT(DBG_LEVEL_WARN,
			("UnbindAdapter: Intf %x, Name %Z\n", pIntF, &pIntF->InterfaceName));

	if (ArpSReferenceIntF(pIntF))
	{
		//
		// ArpSStopInterface dereferences the pIntF
		//
		*UnbindStatus = ArpSStopInterface(pIntF, TRUE);
	}
}


NDIS_STATUS
ArpSStopInterface(
	IN	PINTF					pIntF,
	IN	BOOLEAN					bCloseAdapter
	)
//
// NOTE: ArpSStopInterface MAY be called concurrently multiple times.
//
{
	KEVENT			CleanupEvent;
	NDIS_STATUS		Status;
	KIRQL			OldIrql;
	BOOLEAN			bWaitForClose;

	DBGPRINT(DBG_LEVEL_NOTICE,
			("StopInterface: Intf %x, Flags %x, Name %Z, bClose %d\n",
				pIntF, pIntF->Flags, &pIntF->InterfaceName, bCloseAdapter));

	bWaitForClose = FALSE;
	if (bCloseAdapter)
	{

		//
		// Event to be set when the IntF cleanup is complete
		//
		if (pIntF->CleanupEvent == NULL)
		{
			KeInitializeEvent(&CleanupEvent, NotificationEvent, FALSE);
			pIntF->CleanupEvent = &CleanupEvent;
			bWaitForClose = TRUE;
		}
		else
		{
			ASSERT(FALSE);
		}
	}


	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	//
	// NOTE: we can't simply skip the shutdown steps if
	// INTF_STOPPING is already set, because we need to make sure all the steps
	// are complete before we call  NdisCloseAdapter.
	//

	pIntF->Flags |= INTF_STOPPING;

	//
	// Start off by de-registering the Sap
	//
	if (pIntF->Flags & INTF_SAP_REGISTERED)
	{
		pIntF->Flags &= ~INTF_SAP_REGISTERED;
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		Status = NdisClDeregisterSap(pIntF->NdisSapHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSDeregisterSapComplete(Status, pIntF);
		}
		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	}

	//
	// Walk the list of Active Vcs and close them down
	//

	while (!IsListEmpty(&pIntF->ActiveVcHead))
	{
		PARP_VC	Vc;

		Vc = CONTAINING_RECORD(pIntF->ActiveVcHead.Flink, ARP_VC, List);

		if ((Vc->Flags & ARPVC_CLOSING) == 0)
		{
			Vc->Flags |= ARPVC_CLOSING;
			Vc->Flags &= ~ARPVC_ACTIVE;
		
			//
			// The ArpEntry part of the Vc gets cleaned up seperately.
			//
			Vc->ArpEntry = NULL;
		
			ASSERT(Vc->HwAddr.SubAddress == NULL);
		
			RemoveEntryList(&Vc->List);
			InsertHeadList(&pIntF->InactiveVcHead, &Vc->List);
		
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		
			Status = NdisClCloseCall(Vc->NdisVcHandle, NULL, NULL, 0);
		
			if (Status != NDIS_STATUS_PENDING)
			{
				ArpSCloseCallComplete(Status, Vc, NULL);
			}
	
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
		}
	}

	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	MarsStopInterface(pIntF);

	//
	// Deregister all registered addresses...
	//
	DeregisterAllAddresses(pIntF);

	//
	// Now close Address family
	//
	if (pIntF->Flags & INTF_AF_OPENED)
	{
		pIntF->Flags &= ~INTF_AF_OPENED;

		Status = NdisClCloseAddressFamily(pIntF->NdisAfHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseAfComplete(Status, pIntF);
		}
	}

	if (bCloseAdapter)
	{
		//
		// Now close the adapter.
		//
		ArpSTryCloseAdapter(pIntF);
	}

	//
	// Take away reference added by caller.
	//
	ArpSDereferenceIntF(pIntF);

	if (bWaitForClose)
	{
		//
		// Wait for the cleanup to complete, i.e. last reference on the Interface
		// to go away.
		//
		WAIT_FOR_OBJECT(Status, &CleanupEvent, NULL);
	}

	return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
ArpSPnPEventHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			pNetPnPEvent
	)
{
	PINTF						pIntF;
	NDIS_STATUS					Status;
	PNET_DEVICE_POWER_STATE		pPowerState = (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;

	pIntF = (PINTF)ProtocolBindingContext;

	do
	{
		switch (pNetPnPEvent->NetEvent)
		{
			case NetEventSetPower:
				switch (*pPowerState)
				{
					case NetDeviceStateD0:
						Status = NDIS_STATUS_SUCCESS;
						break;

					default:
						//
						// We can't suspend, so we ask NDIS to Unbind us by
						// returning this status:
						//
						Status = NDIS_STATUS_NOT_SUPPORTED;
						break;
				}
				break;

			case NetEventQueryPower:	// FALLTHRU
			case NetEventQueryRemoveDevice:	// FALLTHRU
			case NetEventCancelRemoveDevice:
				Status = NDIS_STATUS_SUCCESS;
				break;
			
			case NetEventReconfigure:
				if (pIntF)
				{
					Status = ArpSReadAdapterConfiguration(pIntF);
				}
				else
				{
					//
					// Global changes
					//
					Status = NDIS_STATUS_SUCCESS;
				}
				break;

			case NetEventBindList:
			default:
				Status = NDIS_STATUS_NOT_SUPPORTED;
				break;
		}

		break;
	}
	while (FALSE);

	return (Status);
}



VOID
ArpSStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_LEVEL_WARN, ("StatusIndication: Ignored\n"));
}


VOID
ArpSReceiveComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return;
}


VOID
ArpSStatusComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_LEVEL_WARN, ("StatusComplete: Ignored\n"));
}


VOID
ArpSCoStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_LEVEL_WARN, ("CoStatus: Ignored\n"));
}




VOID
ArpSInitiateCloseCall(
	IN	PARP_VC					Vc
	)
/*++

Routine Description:

	Start off an NDIS Call Closing sequence on the ARP VC, if all
	conditions are right.

Arguments:

	Vc		- Pointer to ARP Vc

Return Value:

	None

--*/
{
	PINTF			pIntF;
	NDIS_HANDLE		NdisVcHandle;
	NDIS_HANDLE		NdisPartyHandle;
	NDIS_STATUS		Status;
	KIRQL			OldIrql;

	pIntF = Vc->IntF;
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

	DBGPRINT(DBG_LEVEL_NOTICE, 
	("InitiateClose: VC %x, ref %d, flags %x, Pending %d, ArpEntry %x\n",
			Vc, Vc->RefCount, Vc->Flags, Vc->PendingSends, Vc->ArpEntry));

	if (Vc->PendingSends == 0)
	{
		//
		//  No outstanding packets, we can start closing this call.
		//

		NdisVcHandle = Vc->NdisVcHandle;
		NdisPartyHandle = NULL;

		Vc->Flags |= ARPVC_CLOSING;
		Vc->Flags &= ~ARPVC_CLOSE_PENDING;
		Vc->Flags &= ~ARPVC_ACTIVE;

		//
		// The ArpEntry part of the Vc gets cleaned up seperately.
		//
		Vc->ArpEntry = NULL;

		ASSERT(Vc->HwAddr.SubAddress == NULL);

		RemoveEntryList(&Vc->List);
		InsertHeadList(&pIntF->InactiveVcHead, &Vc->List);

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		Status = NdisClCloseCall(NdisVcHandle, NdisPartyHandle, NULL, 0);

		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseCallComplete(Status, Vc, (NDIS_HANDLE)NULL);
		}
	}
	else
	{
		//
		//  Mark this Vc as needing CloseCall.
		//
		Vc->Flags &= ~ARPVC_ACTIVE;
		Vc->Flags |= ARPVC_CLOSE_PENDING;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
	}

}


VOID
DeregisterAllAddresses(
	IN	PINTF					pIntF
	)
{
	//
	// Deregister any registered addresses from the switch.
	//
	ULONG				NumAllocedRegdAddresses;
	PATM_ADDRESS		RegAddresses;
	KIRQL				OldIrql;
	NDIS_STATUS			Status;
	ULONG				NumAddressesRegd;

	// Clear the registered address field.
	//
	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	NumAllocedRegdAddresses = pIntF->NumAllocedRegdAddresses;
	RegAddresses = pIntF->RegAddresses;
	pIntF->NumAllocedRegdAddresses = 0;
	pIntF->RegAddresses = NULL;
	NumAddressesRegd = pIntF->NumAddressesRegd;
	pIntF->NumAddressesRegd = 0;

	// Deregister all registered addresses with the switch.
	//
	if (NumAddressesRegd)
	{
		KEVENT			DelAddressesEvent;
		BOOLEAN			fRet;
		KeInitializeEvent(&DelAddressesEvent, NotificationEvent, FALSE);
		ASSERT(pIntF->DelAddressesEvent == NULL);
		ASSERT(pIntF->NumPendingDelAddresses ==  0);
		pIntF->DelAddressesEvent = &DelAddressesEvent;
		pIntF->NumPendingDelAddresses =  NumAllocedRegdAddresses;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		DBGPRINT(DBG_LEVEL_WARN, ("DeregisterAllAddresses: Going to derigester addresses\n"));

		fRet = ArpSDeleteIntFAddresses(
					pIntF,
					NumAllocedRegdAddresses,
					RegAddresses
					);
		
		if (fRet == FALSE)
		{
			// This means that deregistration was not started for ALL addresses
			// This is a bad situation, and in this case, we don't wait.
			//
			ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
			pIntF->DelAddressesEvent  =  NULL;
			pIntF->NumPendingDelAddresses =  0;
			RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);
		}
		else
		{

			DBGPRINT(DBG_LEVEL_WARN, ("DeregisterAllAddresses: Waiting for addresses to be deleted\n"));
			WAIT_FOR_OBJECT(Status, &DelAddressesEvent, NULL);
		}
	}
	else
	{
		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	}


	// Free RegAddresses.
	//
	if (RegAddresses)
	{
		FREE_MEM(RegAddresses);
	}
}

VOID
ArpSTryCloseAdapter(
	IN	PINTF					pIntF // NOLOCKIN LOLOCKOUT
)
//
// Close adapter if it's still in the "open" state. Need to
// guard against closing the adapter more than once.
//
{
	KIRQL			OldIrql;
	BOOLEAN 		bCloseAdapter;
	NDIS_STATUS		Status;

	bCloseAdapter = FALSE;

	ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);
	if (pIntF->Flags & INTF_ADAPTER_OPENED)
	{
		pIntF->Flags &= ~INTF_ADAPTER_OPENED;
		bCloseAdapter = TRUE;
	}
	RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

	if (bCloseAdapter)
	{
		NdisCloseAdapter(&Status, pIntF->NdisBindingHandle);
		if (Status != NDIS_STATUS_PENDING)
		{
			ArpSCloseAdapterComplete(pIntF, Status);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\protos.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

	protos.h

Abstract:

	This file contains the function proto-types and macros.

Author:

	Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

	Kernel mode

Revision History:

--*/

#ifndef	_PROTOS_
#define	_PROTOS_

#define	POOL_TAG_PG				'AprA'
#define	POOL_TAG_VC				'VprA'
#define	POOL_TAG_INTF			'IprA'
#define	POOL_TAG_ADDR			'AprA'
#define	POOL_TAG_BUF			'BprA'
#define	POOL_TAG_REQ			'RprA'
#define	POOL_TAG_SAP			'SprA'
#define POOL_TAG_BLK			'KprA'
#define POOL_TAG_MARS			'MprA'

#if DBG

extern
PVOID
ArpSAllocMem(
	IN	UINT					Size,
	IN	ULONG					FileLine,
	IN	ULONG					Tag,
	IN	BOOLEAN					Paged
	);

extern
VOID
ArpSFreeMem(
	IN	PVOID					pMem,
	IN	ULONG					FileLine
	);

#define	ALLOC_NP_MEM(_size, _tag)		ArpSAllocMem(_size, __LINE__ | _FILENUM_, _tag, FALSE)
#define	ALLOC_PG_MEM(_size)				ArpSAllocMem(_size, __LINE__ | _FILENUM_, POOL_TAG_PG, TRUE)
#define	FREE_MEM(_p)					ArpSFreeMem(_p, __LINE__ | _FILENUM_)

#else

#define	ALLOC_NP_MEM(_size, _tag)		ExAllocatePoolWithTag(NonPagedPool, _size, _tag)
#define	ALLOC_PG_MEM(_size)				ExAllocatePoolWithTag(PagedPool, _size, POOL_TAG_PG)
#define	FREE_MEM(_p)					ExFreePool(_p)

#endif

#define	ZERO_MEM(_p, _size)				RtlZeroMemory(_p, _size)
#define	COPY_MEM(_d, _s, _size)			RtlCopyMemory(_d, _s, _size)
#define	MOVE_MEM(_d, _s, _size)			RtlMoveMemory(_d, _s, _size)
#define	COMP_MEM(_p1, _p2, _size_)		RtlEqualMemory(_p1, _p2, _size_)

#define	INITIALIZE_SPIN_LOCK(_l)		KeInitializeSpinLock(_l)
#define	ACQUIRE_SPIN_LOCK(_l, _i)		KeAcquireSpinLock(_l, _i)
#define	ACQUIRE_SPIN_LOCK_DPC(_l)		KeAcquireSpinLockAtDpcLevel(_l)
#define	RELEASE_SPIN_LOCK(_l, _i)		KeReleaseSpinLock(_l, _i)
#define	RELEASE_SPIN_LOCK_DPC(_l)		KeReleaseSpinLockFromDpcLevel(_l)
#define	INITIALIZE_MUTEX(_m_)			KeInitializeMutex(_m_, 0xFFFF)
#define	RELEASE_MUTEX(_m_)				KeReleaseMutex(_m_, FALSE);
#define	WAIT_FOR_OBJECT(_S_, _O_, _TO_)	(_S_) = KeWaitForSingleObject(_O_,			\
																	  Executive,	\
																	  KernelMode,	\
																	  TRUE,			\
																	  _TO_)			\

#define INIT_EVENT(_pEv)				NdisInitializeEvent(_pEv)
#define SET_EVENT(_pEv)					NdisSetEvent(_pEv)
#define WAIT_FOR_EVENT(_pEv)			NdisWaitEvent(_pEv, 0)


extern
NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT			DriverObject,
	IN	PUNICODE_STRING			RegistryPath
	);

extern
NTSTATUS
ArpSDispatch(
	IN	PDEVICE_OBJECT			pDeviceObject,
	IN	PIRP					pIrp
	);

extern
NTSTATUS
ArpSHandleIoctlRequest(
	IN	PIRP					pIrp,
	IN	PIO_STACK_LOCATION		pIrpSp
	);

extern
NTSTATUS
ArpSEnumerateInterfaces(
	IN	PUCHAR					pBuffer,
	IN OUT	PULONG_PTR			pSize
	);

extern
NTSTATUS
ArpSFlushArpCache(
	IN	 PINTF					pIntF
	);

extern
NTSTATUS
ArpSQueryOrAddArpEntry(
	IN	 PINTF					pIntF,
	IN	OUT	PIOCTL_QA_ENTRY		pQaBuf,
	IN	OPERATION				Operation
	);

extern
NTSTATUS
ArpSQueryArpCache(
	IN	 PINTF					pIntF,
	IN	PUCHAR					pBuf,
	IN OUT PULONG_PTR			pSize
	);

extern
NTSTATUS
ArpSQueryArpStats(
	IN	PINTF					pIntF,
	OUT	PARP_SERVER_STATISTICS 	pArpStats
	);

extern
NTSTATUS
ArpSQueryMarsCache(
	IN	 PINTF					pIntF,
	IN	PUCHAR					pBuf,
	IN OUT PULONG_PTR			pSize
	);

extern
NTSTATUS
ArpSQueryMarsStats(
	IN	PINTF					pIntF,
	OUT	PMARS_SERVER_STATISTICS pMarsStats
	);

extern
VOID
ArpSResetStats(
	IN	PINTF					pIntF
	);

extern
VOID
ArpSUnload(
	IN	PDRIVER_OBJECT			DriverObject
	);

extern
VOID
ArpSShutDown(
	VOID
	);

extern
NDIS_STATUS
ArpSStopInterface(
	IN	PINTF					pIntF,
	IN	BOOLEAN					bCloseAdapter
	);

extern
NDIS_STATUS
ArpSPnPEventHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			pNetPnPEvent
	);

extern
PINTF	
ArpSCreateIntF(
	IN	PNDIS_STRING			DeviceName,
	IN	PNDIS_STRING			ConfigString,
	IN  NDIS_HANDLE				BindingContext
	);

extern
VOID
ArpSReqThread(
	IN	PVOID					Context
	);

extern
VOID
ArpSTimerThread(
	IN	PVOID					Context
	);

extern
NTSTATUS
ArpSReadGlobalConfiguration(
	IN	PUNICODE_STRING			RegistryPath
	);

extern
NDIS_STATUS
ArpSReadAdapterConfigFromRegistry(
	IN	PINTF					pIntF,
	OUT	PATMARPS_CONFIG			pConfig
	);

extern
NDIS_STATUS
ArpSReadAdapterConfiguration(
	IN	PINTF					pIntF
	);

extern
VOID
ArpSConvertStringToIpPair(
	OUT	PNDIS_STATUS			pStatus,
	IN	PNDIS_STRING			pString,
	IN	PMCS_ENTRY				pMcsEntry
	);

extern
BOOLEAN
IPConvertStringToAddress(
    IN PWCHAR AddressString,
	OUT PULONG IpAddress
	);

extern
VOID
ArpSReadArpCache(
	IN	PINTF					pIntF
	);

extern
BOOLEAN
ArpSWriteArpCache(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	);

extern
VOID
MarsReqThread(
	IN	PVOID					Context
	);

extern
VOID
MarsHandleRequest(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
MarsHandleJoin(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
MarsHandleLeave(
	IN	PINTF					pIntF,
	IN	PARP_VC					Vc,
	IN	PMARS_HEADER			Header,
	IN	PNDIS_PACKET			Packet
	);

extern
PCLUSTER_MEMBER
MarsLookupClusterMember(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr
	);

extern
PCLUSTER_MEMBER
MarsCreateClusterMember(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr
	);

extern
VOID
MarsDeleteClusterMember(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	);

extern
PMARS_ENTRY
MarsLookupMarsEntry(
	IN	PINTF					pIntF,
	IN	IPADDR					GrpAddr,
	IN	BOOLEAN					bCreateNew
	);

extern
BOOLEAN
MarsIsAddressMcsServed(
	IN	PINTF					pIntF,
	IN	IPADDR					IPAddress
	);

extern
VOID
MarsPunchHoles(
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PGROUP_MEMBER			pGroupList,
	IN	PINTF					pIntF,
	IN	IPADDR UNALIGNED *		pOutBuf					OPTIONAL,
	OUT	PUSHORT					pMinMaxCount,
	OUT	BOOLEAN *				pAnyHolesPunched
	);

extern
BOOLEAN
MarsAddClusterMemberToGroups(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PNDIS_PACKET			Packet,
	IN	PMARS_JOIN_LEAVE		JHdr,
	IN	UINT					Length,
	OUT	PNDIS_PACKET *			ppClusterPacket
	);

extern
VOID
MarsUnlinkAllGroupsOnClusterMember(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	);

extern
BOOLEAN
MarsDelClusterMemberFromGroups(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	PMCAST_ADDR_PAIR		pGrpAddrRange,
	IN	PNDIS_PACKET			Packet,
	IN	PMARS_JOIN_LEAVE		LHdr,
	IN	UINT					Length,
	OUT	PNDIS_PACKET *			ppClusterPacket
	);

extern
PNDIS_PACKET
MarsAllocControlPacket(
	IN	PINTF					pIntF,
	IN	ULONG					PacketLength,
	OUT	PUCHAR *				pPacketStart
	);

extern
VOID
MarsFreePacket(
	IN	PNDIS_PACKET			Packet
	);

extern
PNDIS_PACKET
MarsAllocPacketHdrCopy(
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
MarsSendOnClusterControlVc(
	IN	PINTF					pIntF,
	IN	PNDIS_PACKET			Packet	OPTIONAL
	);

extern
VOID
MarsFreePacketsQueuedForClusterControlVc(
	IN	PINTF					pIntF
	);

extern
BOOLEAN
MarsDelMemberFromClusterControlVc(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember,
	IN	BOOLEAN					fIfLocked,
	IN	KIRQL					OldIrql			OPTIONAL
	);

extern
VOID
MarsAddMemberToClusterControlVc(
	IN	PINTF					pIntF,
	IN	PCLUSTER_MEMBER			pMember
	);

extern
PCO_CALL_PARAMETERS
MarsPrepareCallParameters(
	IN	PINTF					pIntF,
	IN	PHW_ADDR				pHwAddr,
	IN	BOOLEAN					IsMakeCall
	);

extern
BOOLEAN
MarsSendRedirect(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	);

extern
VOID
MarsAbortAllMembers(
	IN	PINTF					pIntF
	);

extern
VOID
MarsStopInterface(
	IN	PINTF					pIntF
	);

extern
VOID
MarsDumpPacket(
	IN	PUCHAR					Packet,
	IN	UINT					PktLen
	);

extern
VOID
MarsDumpIpAddr(
	IN	IPADDR					IpAddr,
	IN	PCHAR					String
	);

extern
VOID
MarsDumpAtmAddr(
	IN	PATM_ADDRESS			AtmAddr,
	IN	PCHAR					String
	);

extern
VOID
MarsDumpMap(
	IN	PCHAR					String,
	IN	IPADDR					IpAddr,
	IN	PATM_ADDRESS			AtmAddr
	);

extern
NTSTATUS
ArpSInitializeNdis(
	VOID
	);

extern
VOID
ArpSDeinitializeNdis(
	VOID
	);

extern
VOID
ArpSOpenAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status,
	IN	NDIS_STATUS				OpenErrorStatus
	);

extern
VOID
ArpSCloseAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status
	);

extern
VOID
ArpSStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	);

extern
VOID
ArpSReceiveComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	);

extern
VOID
ArpSStatusComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	);

VOID
ArpSQueryAdapter(
	IN	PINTF					pIntF
	);

extern
VOID
ArpSSendNdisRequest(
	IN	PINTF					pIntF,
	IN	NDIS_OID				Oid,
	IN	PVOID					pBuffer,
	IN	ULONG					BufferLength
	);

extern
VOID
ArpSRequestComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_REQUEST			pRequest,
	IN	NDIS_STATUS				Status
	);

extern
VOID
ArpSBindAdapter(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			DeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
	);

extern
VOID
ArpSUnbindAdapter(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
	);


extern
VOID
ArpSCoSendComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	);

extern
VOID
ArpSCoStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	);

extern
NDIS_STATUS
ArpSCoRequest(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST		NdisRequest
	);

extern
VOID
ArpSCoRequestComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST			NdisRequest
	);


extern
VOID
ArpSCoAfRegisterNotify(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY		AddressFamily
	);


extern
NDIS_STATUS
ArpSCreateVc(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisVcHandle,
	OUT	PNDIS_HANDLE			ProtocolVcContext
	);

extern
NDIS_STATUS
ArpSDeleteVc(
	IN	NDIS_HANDLE				ProtocolVcContext
	);

extern
VOID
ArpSOpenAfComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisAfHandle
	);

extern
VOID
ArpSCloseAfComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext
	);

extern
VOID
ArpSRegisterSap(
	IN	PINTF					pIntF
	);

extern
VOID
ArpSRegisterSapComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	PCO_SAP					Sap,
	IN	NDIS_HANDLE				NdisSapHandle
	);

extern
VOID
ArpSDeregisterSapComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolSapContext
	);

extern
VOID
ArpSMakeCallComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	NDIS_HANDLE				NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS		CallParameters
	);

extern
VOID
ArpSCloseCallComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	NDIS_HANDLE				ProtocolPartyContext OPTIONAL
	);

extern
VOID
ArpSAddPartyComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolPartyContext,
	IN	NDIS_HANDLE				NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS		CallParameters
	);

extern
VOID
ArpSDropPartyComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolPartyContext
	);

extern
NDIS_STATUS
ArpSIncomingCall(
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN OUT PCO_CALL_PARAMETERS	CallParameters
	);

extern
VOID
ArpSIncomingDropParty(
	IN	NDIS_STATUS				DropStatus,
	IN	NDIS_HANDLE				ProtocolPartyContext,
	IN	PVOID					CloseData	OPTIONAL,
	IN	UINT					Size		OPTIONAL
	);

extern
VOID
ArpSCallConnected(
	IN	NDIS_HANDLE				ProtocolVcContext
	);

extern
VOID
ArpSIncomingCloseCall(
	IN	NDIS_STATUS				CloseStatus,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PVOID					CloseData	OPTIONAL,
	IN	UINT					Size		OPTIONAL
	);

extern
VOID
ArpSIncomingCallQoSChange(
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS		CallParameters
	);

extern
VOID
ArpSInitiateCloseCall(
	IN	PARP_VC					Vc
	);

extern
UINT
ArpSHandleArpRequest(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	);

extern
PARP_ENTRY
ArpSLookupEntryByIpAddr(
	IN	PINTF					pIntF,
	IN	IPADDR					IpAddr
	);

extern
PARP_ENTRY
ArpSLookupEntryByAtmAddr(
	IN	PINTF					pIntF,
	IN	PATM_ADDRESS			Address,
	IN	PATM_ADDRESS			SubAddress	OPTIONAL
	);

extern
PARP_ENTRY
ArpSAddArpEntry(
	IN	PINTF					pIntF,
	IN	IPADDR					IpAddr,
	IN	PATM_ADDRESS			Address,
	IN	PATM_ADDRESS			SubAddress	OPTIONAL,
	IN	PARP_VC					Vc			OPTIONAL
	);

extern
PARP_ENTRY
ArpSAddArpEntryFromDisk(
	IN	PINTF					pIntF,
	IN	PDISK_ENTRY				pDiskEntry
	);

extern
VOID
ArpSUpdateArpEntry(
	IN	PINTF					pIntF,
	IN	PARP_ENTRY				ArpEntry,
	IN	IPADDR					IpAddr,
	IN	PHW_ADDR				HwAddr,
	IN	PARP_VC					Vc
	);

extern
VOID
ArpSBuildArpReply(
	IN	PINTF					pIntF,
	IN	PARP_ENTRY				ArpEntry,
	IN	PARPS_HEADER			Header,
	IN	PNDIS_PACKET			Pkt
	);

extern
BOOLEAN
ArpSAgeEntry(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	);

extern
BOOLEAN
ArpSDeleteIntFAddresses(
	IN	PINTF					pIntF,
	IN	INT						NumAddresses,
	IN	PATM_ADDRESS			AddrList
	);

extern
VOID
ArpSQueryAndSetAddresses(
	IN	PINTF					pIntF
	);

VOID
ArpSValidateAndSetRegdAddresses(
	IN	PINTF			pIntF,
	IN	KIRQL			OldIrql
	);

VOID
ArpSMakeRegAddrCallComplete(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	);

VOID
ArpSCloseRegAddrCallComplete(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	);

VOID
ArpSIncomingRegAddrCloseCall(
	IN	NDIS_STATUS 	Status,
	IN 	PREG_ADDR_CTXT	pRegAddrCtxt
	);

VOID
ArpSValidateOneRegdAddress(
	IN	PINTF			pIntF,
	IN	KIRQL			OldIrql
	);

VOID
ArpSSetupValidationCallParams(
	IN PREG_ADDR_CTXT	pRegAddrCtxt, // LOCKIN LOCKOUT (pIntF lock)
	IN PATM_ADDRESS 	pAtmAddr
	);

VOID
ArpSUnlinkRegAddrCtxt(
	PINTF			pIntF, 		// LOCKIN NOLOCKOUT
	KIRQL			OldIrql
	);

VOID
ArpSLogFailedRegistration(
		PATM_ADDRESS pAtmAddress
	);

extern
BOOLEAN
ArpSReferenceIntF(
	IN	PINTF					pIntF
	);

extern
PINTF
ArpSReferenceIntFByName(
	IN	PINTERFACE_NAME			pInterface
	);

extern
VOID
ArpSDereferenceIntF(
	IN	PINTF					pIntF
	);

extern
BOOLEAN
ArpSReferenceVc(
	IN	PARP_VC					Vc,
	IN	BOOLEAN					bSendRef
	);

extern
VOID
ArpSDereferenceVc(
	IN	PARP_VC					Vc,
	IN	BOOLEAN					KillArpEntry,
	IN	BOOLEAN					bSendComplete
	);

extern
VOID
ArpSSleep(
	IN	UINT					TimeInMs
	);

extern
VOID
ArpSFreeGlobalData(
	VOID
	);

extern
VOID
ArpSTimerCancel(
	IN	PTIMER					pTimerList
	);

extern
VOID
ArpSTimerEnqueue(
	IN	PINTF					pIntF,
	IN	PTIMER					pTimer
	);

extern
PVOID
ArpSAllocBlock(
	IN	PINTF					pIntF,
	IN	ENTRY_TYPE				EntryType
	);

extern
VOID
ArpSFreeBlock(
	IN	PVOID					pBlock
	);

BOOLEAN
ArpSValidAtmAddress(
	IN	PATM_ADDRESS			AtmAddr,
	IN	UINT					MaxSize
	);


VOID
DeregisterAllAddresses(
	IN	PINTF					pIntF
	);

BOOLEAN
MarsIsValidClusterMember(
	PINTF				pIntF,
	PCLUSTER_MEMBER		pPossibleMember
	);

VOID
ArpSTryCloseAdapter(
	IN	PINTF					pIntF // NOLOCKIN LOLOCKOUT
	);

#if	DBG

extern
VOID
ArpSDumpPacket(
	IN	PUCHAR					Packet,
	IN	UINT					PktLen
	);

extern
VOID
ArpSDumpAddress(
	IN	IPADDR					IpAddr,
	IN	PHW_ADDR				HwAddr,
	IN	PCHAR					String
	);

extern
VOID
ArpSDumpIpAddr(
	IN	IPADDR					IpAddr,
	IN	PCHAR					String
	);

extern
VOID
ArpSDumpAtmAddr(
	IN	PATM_ADDRESS			AtmAddr,
	IN	PCHAR					String
	);

#else

#define	ArpSDumpPacket(_Packet, _PktLen)
#define	ArpSDumpAddress(_IpAddr, _HwAddr, _String)
#define	ArpSDumpIpAddr(_IpAddr, _String)
#define	ArpSDumpAtmAddr(_AtmAddr, _String)

#endif

/*
 * The following macros deal with on-the-wire integer and long values
 *
 * On the wire format is big-endian i.e. a long value of 0x01020304 is
 * represented as 01 02 03 04. Similarly an int value of 0x0102 is
 * represented as 01 02.
 *
 * The host format is not assumed since it will vary from processor to
 * processor.
 */

#pragma	alloc_text(INIT, DriverEntry)
#pragma	alloc_text(INIT, ArpSReadGlobalConfiguration)
#pragma	alloc_text(INIT, ArpSInitializeNdis)
#pragma	alloc_text(PAGE, ArpSReadArpCache)
#pragma	alloc_text(PAGE, ArpSWriteArpCache)
#pragma	alloc_text(PAGE, ArpSSleep)
#pragma	alloc_text(PAGE, ArpSReqThread)
#pragma	alloc_text(PAGE, ArpSTimerThread)
#pragma	alloc_text(PAGE, ArpSDispatch)
#pragma	alloc_text(PAGE, ArpSLookupEntryByIpAddr)
#pragma	alloc_text(PAGE, ArpSLookupEntryByAtmAddr)
#pragma	alloc_text(PAGE, ArpSAddArpEntry)
#pragma	alloc_text(PAGE, ArpSAddArpEntryFromDisk)
#pragma	alloc_text(PAGE, ArpSCreateIntF)

#pragma	alloc_text(PAGE, MarsReqThread)
#endif	// _PROTOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\timer.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	timer.h

Abstract:

	This module contains routines to schedule timer events.

Author:

	Jameel Hyder (jameelh@microsoft.com)

Revision History:
	Jul 1996		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_TIMER_
#define	_TIMER_

struct _Timer;

typedef
BOOLEAN
(*TIMER_ROUTINE)(
	IN struct _IntF *		pIntF,
	IN struct _Timer *		pTimer,
	IN BOOLEAN				TimerShuttingDown
	);

typedef	struct _Timer
{
	struct _Timer *			Next;
	struct _Timer **		Prev;
	TIMER_ROUTINE			Routine;		// Timer routine
	SHORT					AbsTime;		// Absolute time, for re-enqueue
	SHORT					RelDelta;		// Relative to the previous entry
} TIMER, *PTIMER;


#define	ArpSTimerInitialize(pTimer, TimerRoutine, DeltaTime)	\
	{															\
		(pTimer)->Routine = TimerRoutine;						\
		(pTimer)->AbsTime = DeltaTime;							\
	}

#define	ArpSGetCurrentTick()	ArpSTimerCurrentTick

// Keep this at 15 sec units
#define	MULTIPLIER				4				// To convert minutes to ticks
#define	TIMER_TICK				-15*10000000L	// 15s in 100ns units

#endif	// _TIMER_




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\timer.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This file contains the code to manipulate timers.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_TIMER

VOID
ArpSTimerEnqueue(
	IN	PINTF					pIntF,
	IN	PTIMER					pTimer
	)
/*++

Routine Description:

	The timer events are maintained as a list which the timer thread wakes up,
	it looks at every timer tick. The list is maintained in such a way that
	only the head of the list needs to be updated every tick i.e. the entire
	list is never scanned. The way this is achieved is by keeping delta times
	relative to the previous entry.

	Every timer tick, the relative time at the head of the list is decremented.
	When that goes to ZERO, the head of the list is unlinked and dispatched.

	To give an example, we have the following events queued at time slots
	X			Schedule A after 10 ticks.
	X+3			Schedule B after 5  ticks.
	X+5			Schedule C after 4  ticks.
	X+8			Schedule D after 6  ticks.

	So A will schedule at X+10, B at X+8 (X+3+5), C at X+9 (X+5+4) and
	D at X+14 (X+8+6).

	The above example covers all the situations.

	- NULL List.
	- Inserting at head of list.
	- Inserting in the middle of the list.
	- Appending to the list tail.

	The list will look as follows.

		    BEFORE                          AFTER
		    ------                          -----

    X   Head -->|                  Head -> A(10) ->|
    A(10)

    X+3 Head -> A(7) ->|           Head -> B(5) -> A(2) ->|
    B(5)

    X+5 Head -> B(3) -> A(2) ->|   Head -> B(3) -> C(1) -> A(1) ->|
    C(4)

    X+8 Head -> C(1) -> A(1) ->|   Head -> C(1) -> A(1) -> D(4) ->|
    D(6)

	The granularity is one tick. THIS MUST BE CALLED WITH THE TIMER LOCK HELD.

Arguments:


Return Value:

--*/
{
	PTIMER		pList, *ppList;
	USHORT		DeltaTime = pTimer->AbsTime;

#if DBG
	if (pTimer->Routine == (TIMER_ROUTINE)NULL)
	{
		DBGPRINT(DBG_LEVEL_ERROR,
				("TimerEnqueue: pIntF %x, pTimer %x, NULL Routine!\n",
					pIntF, pTimer));
		DbgBreakPoint();
	}
#endif // DBG

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerEnqueue: Entered for pTimer %lx\n", pTimer));

	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &pIntF->ArpTimer;
		 (pList = *ppList) != NULL;
		 ppList = &pList->Next)
	{
		if (DeltaTime <= pList->RelDelta)
		{
			pList->RelDelta -= DeltaTime;
			break;
		}
		DeltaTime -= pList->RelDelta;
	}
	

	// Link this in the chain
	pTimer->RelDelta = DeltaTime;
	pTimer->Next = pList;
	pTimer->Prev = ppList;
	*ppList = pTimer;
	if (pList != NULL)
	{
		pList->Prev = &pTimer->Next;
	}
}


VOID
ArpSTimerCancel(
	IN	PTIMER					pTimer
	)
/*++

Routine Description:

	Cancel a previously queued timer. Called with the ArpCache mutex held.

Arguments:


Return Value:

--*/
{
	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerCancel: Entered for pTimer %lx\n", pTimer));

	//
	// Unlink it from the list adjusting relative deltas carefully
	//
	if (pTimer->Next != NULL)
	{
		pTimer->Next->RelDelta += pTimer->RelDelta;
		pTimer->Next->Prev = pTimer->Prev;
	}

	*(pTimer->Prev) = pTimer->Next;
}


VOID
ArpSTimerThread(
	IN	PVOID					Context
	)
/*++

Routine Description:

	Handle timer events here.

Arguments:

	None

Return Value:

	None
--*/
{
	PINTF			pIntF = (PINTF)Context;
	NTSTATUS		Status;
	LARGE_INTEGER	TimeOut;
	PTIMER			pTimer;
	BOOLEAN			ReQueue;

	ARPS_PAGED_CODE( );

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerThread: Came to life\n"));

	TimeOut.QuadPart = TIMER_TICK;

	do
	{
		WAIT_FOR_OBJECT(Status, &pIntF->TimerThreadEvent, &TimeOut);
		if (Status == STATUS_SUCCESS)
		{
			//
			// Signalled to quit, do so.
			//
			break;
		}

		WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);	

		if ((pTimer = pIntF->ArpTimer) != NULL)
		{
			//
			// Careful here. If two timers fire together - let them !!
			//
			if (pTimer->RelDelta != 0)
				pTimer->RelDelta --;

			if (pTimer->RelDelta == 0)
			{
				pIntF->ArpTimer = pTimer->Next;
				if (pIntF->ArpTimer != NULL)
				{
					pIntF->ArpTimer->Prev = &pIntF->ArpTimer;
				}

				ReQueue = (*pTimer->Routine)(pIntF, pTimer, FALSE);
				if (ReQueue)
				{
					ArpSTimerEnqueue(pIntF, pTimer);
				}
			}
		}

		RELEASE_MUTEX(&pIntF->ArpCacheMutex);	
	} while (TRUE);

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerThread: terminating\n"));

	//
	// Now fire all queued timers
	//
	WAIT_FOR_OBJECT(Status, &pIntF->ArpCacheMutex, NULL);	

	for (pTimer = pIntF->ArpTimer;
		 pTimer != NULL;
		 pTimer = pIntF->ArpTimer)
	{
		pIntF->ArpTimer = pTimer->Next;
		ReQueue = (*pTimer->Routine)(pIntF, pTimer, TRUE);
		ASSERT(ReQueue == FALSE);
	}

	RELEASE_MUTEX(&pIntF->ArpCacheMutex);	

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSTimerThread: terminated\n"));
	//
	// Finally dereference the IntF
	//
	ArpSDereferenceIntF(pIntF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\util.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file contains the code for misc. functions.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_UTIL

#if	DBG

PVOID
ArpSAllocMem(
	IN	UINT					Size,
	IN	ULONG					FileLine,
	IN	ULONG					Tag,
	IN	BOOLEAN					Paged
	)
{
	PVOID	pMem;

	pMem = ExAllocatePoolWithTag(Paged ? PagedPool : NonPagedPool, Size, Tag);
#if _DBG
	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSAllocMem: %d bytes (%sPaged) from %lx -> %lx\n",
			Size, Paged ? "" : "Non", FileLine, pMem));
#endif
	return pMem;
}


VOID
ArpSFreeMem(
	IN	PVOID					pMem,
	IN	ULONG					FileLine
	)
{
#if _DBG
	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSFreeMem: %lx from %lx\n", FileLine, pMem));
#endif
	ExFreePool(pMem);
}

#endif

PVOID
ArpSAllocBlock(
	IN	PINTF					pIntF,
	IN	ENTRY_TYPE				EntryType
	)
/*++

Routine Description:

Arguments:


Return Value:

--*/
{
	PARP_BLOCK	ArpBlock;
	PENTRY_HDR	pBlock;
	PHW_ADDR	HwAddr;
	USHORT		Size;
	BOOLEAN		Paged;

#if 0
	// arvindm - used by MARS
	ARPS_PAGED_CODE( );
#endif

	ASSERT (EntryType < ARP_BLOCK_TYPES);
	pBlock = NULL;

	//
	// If the block head has no free entries then there are none !!
	// Pick the right block based on whether it is file or dir
	//
	Size = ArpSEntrySize[EntryType];
	Paged = ArpSBlockIsPaged[EntryType];
	ArpBlock = pIntF->PartialArpBlocks[EntryType];

	if (ArpBlock == NULL)
	{
		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSAllocBlock: ... and allocating a new block for EntryType %ld\n", EntryType));

		ArpBlock = Paged ?  (PARP_BLOCK)ALLOC_PG_MEM(BLOCK_ALLOC_SIZE) :
							(PARP_BLOCK)ALLOC_NP_MEM(BLOCK_ALLOC_SIZE, POOL_TAG_BLK);
		if (ArpBlock != NULL)
		{
			USHORT	i;
			USHORT	Cnt;

			DBGPRINT(DBG_LEVEL_WARN,
					("ArpSAllocBlock: Allocated a new block for EntryType %d\n", EntryType));

			//
			// Link it in the list
			//
			ArpBlock->IntF = pIntF;
			ArpBlock->EntryType = EntryType;
            ArpBlock->NumFree = Cnt = ArpSNumEntriesInBlock[EntryType];

			LinkDoubleAtHead(pIntF->PartialArpBlocks[EntryType], ArpBlock);

			//
			// Initialize the list of free entries
			//
			for (i = 0, pBlock = ArpBlock->FreeHead = (PENTRY_HDR)((PUCHAR)ArpBlock + sizeof(ARP_BLOCK));
				 i < Cnt;
				 i++, pBlock = pBlock->Next)
			{
				HwAddr = (PHW_ADDR)(pBlock + 1);
				pBlock->Next = (i == (Cnt - 1)) ? NULL : ((PUCHAR)pBlock + Size);
				HwAddr->SubAddress = NULL;
				if ((EntryType == ARP_BLOCK_SUBADDR) || (EntryType == MARS_CLUSTER_SUBADDR))
					HwAddr->SubAddress = (PATM_ADDRESS)((PUCHAR)pBlock+Size);
			}
		}
	}
	else
	{
		ASSERT(ArpBlock->NumFree <= ArpSNumEntriesInBlock[EntryType]);
		ASSERT(ArpBlock->NumFree > 0);

		DBGPRINT(DBG_LEVEL_INFO,
				("ArpSAllocBlock: Found space in Block %lx\n", ArpBlock));
	}


	if (ArpBlock != NULL)
	{
		PARP_BLOCK	pTmp;

		pBlock = ArpBlock->FreeHead;

		ArpBlock->FreeHead = pBlock->Next;
		ArpBlock->NumFree --;
		ZERO_MEM(pBlock, Size);
		if ((EntryType == ARP_BLOCK_SUBADDR) || (EntryType == MARS_CLUSTER_SUBADDR))
		{
			HwAddr = (PHW_ADDR)(pBlock + 1);
			HwAddr->SubAddress = (PATM_ADDRESS)((PUCHAR)pBlock + Size);
		}

		//
		// If the block is now empty (completely used), unlink it from here and move it
		// to the Used list.
		//
		if (ArpBlock->NumFree == 0)
		{
	        UnlinkDouble(ArpBlock);
			LinkDoubleAtHead(pIntF->UsedArpBlocks[EntryType], ArpBlock)
		}
	}

	return pBlock;
}


VOID
ArpSFreeBlock(
	IN	PVOID					pBlock
	)
/*++

Routine Description:

Arguments:


Return Value:

--*/
{
	PARP_BLOCK	ArpBlock;

#if 0
	// arvindm - MARS
	ARPS_PAGED_CODE( );
#endif

	//
	// NOTE: The following code *depends* on the fact that we allocate ARP_BLOCKs as
	//		 single page blocks and also that these are allocated *at* page boundaries
	//		 This lets us *cheaply* get to the owning ARP_BLOCK from ARP_ENTRY.
	//
	ArpBlock = (PARP_BLOCK)((ULONG_PTR)pBlock & ~(PAGE_SIZE-1));

	ASSERT (ArpBlock->EntryType < ARP_BLOCK_TYPES);
	ASSERT(ArpBlock->NumFree < ArpSNumEntriesInBlock[ArpBlock->EntryType]);

	DBGPRINT(DBG_LEVEL_INFO,
			("ArpSFreepBlock: Returning pBlock %lx to Block %lx\n", pBlock, ArpBlock));

	ArpBlock->NumFree ++;
	((PENTRY_HDR)pBlock)->Next = ArpBlock->FreeHead;
	ArpBlock->FreeHead = pBlock;

	if (ArpBlock->NumFree == 1)
	{
		//
		// The block is now partially free (was completely used). Move it to the partial list
		//

		UnlinkDouble(ArpBlock);
		LinkDoubleAtHead(ArpBlock->IntF->PartialArpBlocks[ArpBlock->EntryType], ArpBlock)
	}
	else if (ArpBlock->NumFree == ArpSNumEntriesInBlock[ArpBlock->EntryType])
	{
		//
		// The block is now completely free (was partially used). Free it.
		//
		UnlinkDouble(ArpBlock);
		FREE_MEM(ArpBlock);
	}
}


BOOLEAN
ArpSValidAtmAddress(
	IN	PATM_ADDRESS			AtmAddr,
	IN	UINT					MaxSize
	)
{
	//
	// TODO -- validate
	//
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\aac.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	aac.c	- DbgExtension Structure information specific to ATMARPC.SYS

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-30-98    Created

Notes:

--*/


#include "precomp.h"


enum
{
    typeid_NULL,
    typeid_ATMARP_GLOBALS,
    typeid_ATMARP_ADAPTER,
    typeid_ATMARP_INTERFACE,
    typeid_ATMARP_ATM_ENTRY,
    typeid_ATMARP_IP_ENTRY,
    typeid_ATMARP_VC
};

extern TYPE_INFO *g_rgTypes[];
//
// STRUCTURES CONCERNING TYPE "ATMARP_ADAPTER"
//

STRUCT_FIELD_INFO  rgfi_ATMARP_ADAPTER[] =
{

#if DBG
  {
    "aaa_sig",
     FIELD_OFFSET(ATMARP_ADAPTER, aaa_sig),
     FIELD_SIZE(ATMARP_ADAPTER, aaa_sig)
  },
#endif

  {
    "pNextAdapter",
     FIELD_OFFSET(ATMARP_ADAPTER, pNextAdapter),
     FIELD_SIZE(ATMARP_ADAPTER, pNextAdapter)
  },


  {
    "pInterfaceList",
     FIELD_OFFSET(ATMARP_ADAPTER, pInterfaceList),
     FIELD_SIZE(ATMARP_ADAPTER, pInterfaceList)
  },

  {
    "InterfaceCount",
     FIELD_OFFSET(ATMARP_ADAPTER, InterfaceCount),
     FIELD_SIZE(ATMARP_ADAPTER, InterfaceCount)
  },

  {
    "NdisAdapterHandle",
     FIELD_OFFSET(ATMARP_ADAPTER, NdisAdapterHandle),
     FIELD_SIZE(ATMARP_ADAPTER, NdisAdapterHandle)
  },

  {
    "BindContext",
     FIELD_OFFSET(ATMARP_ADAPTER, BindContext),
     FIELD_SIZE(ATMARP_ADAPTER, BindContext)
  },

  {
    "SystemSpecific1",
     FIELD_OFFSET(ATMARP_ADAPTER, SystemSpecific1),
     FIELD_SIZE(ATMARP_ADAPTER, SystemSpecific1)
  },

  {
    "SystemSpecific2",
     FIELD_OFFSET(ATMARP_ADAPTER, SystemSpecific2),
     FIELD_SIZE(ATMARP_ADAPTER, SystemSpecific2)
  },

#if OBSOLETE
  {
    "AdapterConfigHandle",
     FIELD_OFFSET(ATMARP_ADAPTER, AdapterConfigHandle),
     FIELD_SIZE(ATMARP_ADAPTER, AdapterConfigHandle)
  },
#endif // OBSOLETE

  {
    "IPConfigString",
     FIELD_OFFSET(ATMARP_ADAPTER, IPConfigString),
     FIELD_SIZE(ATMARP_ADAPTER, IPConfigString)
  },

  {
    "UnbindContext",
     FIELD_OFFSET(ATMARP_ADAPTER, UnbindContext),
     FIELD_SIZE(ATMARP_ADAPTER, UnbindContext)
  },

  {
    "Medium",
     FIELD_OFFSET(ATMARP_ADAPTER, Medium),
     FIELD_SIZE(ATMARP_ADAPTER, Medium)
  },

  {
    "Flags",
     FIELD_OFFSET(ATMARP_ADAPTER, Flags),
     FIELD_SIZE(ATMARP_ADAPTER, Flags)
  },

  {
    "LineRate",
     FIELD_OFFSET(ATMARP_ADAPTER, LineRate),
     FIELD_SIZE(ATMARP_ADAPTER, LineRate)
  },

  {
    "MaxPacketSize",
     FIELD_OFFSET(ATMARP_ADAPTER, MaxPacketSize),
     FIELD_SIZE(ATMARP_ADAPTER, MaxPacketSize)
  },

  {
    "MacAddress",
     FIELD_OFFSET(ATMARP_ADAPTER, MacAddress),
     FIELD_SIZE(ATMARP_ADAPTER, MacAddress)
  },

  {
    "DescrLength",
     FIELD_OFFSET(ATMARP_ADAPTER, DescrLength),
     FIELD_SIZE(ATMARP_ADAPTER, DescrLength)
  },

  {
    "pDescrString",
     FIELD_OFFSET(ATMARP_ADAPTER, pDescrString),
     FIELD_SIZE(ATMARP_ADAPTER, pDescrString)
  },

  {
    "DeviceName",
     FIELD_OFFSET(ATMARP_ADAPTER, DeviceName),
     FIELD_SIZE(ATMARP_ADAPTER, DeviceName)
  },

  {
    "ConfigString",
     FIELD_OFFSET(ATMARP_ADAPTER, ConfigString),
     FIELD_SIZE(ATMARP_ADAPTER, ConfigString)
  },


  {
    "Block",
     FIELD_OFFSET(ATMARP_ADAPTER, Block),
     FIELD_SIZE(ATMARP_ADAPTER, Block)
  },

  {
  	NULL
  }


};

TYPE_INFO type_ATMARP_ADAPTER = {
    "ATMARP_ADAPTER",
    "a",
     typeid_ATMARP_ADAPTER,
	 fTYPEINFO_ISLIST,			// Flags
     sizeof(ATMARP_ADAPTER),
     rgfi_ATMARP_ADAPTER,
     FIELD_OFFSET(ATMARP_ADAPTER, pNextAdapter) // offset to next pointer.
};



//
// STRUCTURES CONCERNING TYPE "ATMARP_GLOBALS"
//


STRUCT_FIELD_INFO  rgfi_ATMARP_GLOBALS[] =
{
#if DBG
  {
    "aag_sig",
     FIELD_OFFSET(ATMARP_GLOBALS, aag_sig),
     FIELD_SIZE(ATMARP_GLOBALS, aag_sig)
  },
#endif // DBG

  {
    "Lock",
     FIELD_OFFSET(ATMARP_GLOBALS, Lock),
     FIELD_SIZE(ATMARP_GLOBALS, Lock)
  },

  {
    "ProtocolHandle",
     FIELD_OFFSET(ATMARP_GLOBALS, ProtocolHandle),
     FIELD_SIZE(ATMARP_GLOBALS, ProtocolHandle)
  },

  {
    "pDriverObject",
     FIELD_OFFSET(ATMARP_GLOBALS, pDriverObject),
     FIELD_SIZE(ATMARP_GLOBALS, pDriverObject)
  },

  {
    "pDeviceObject",
     FIELD_OFFSET(ATMARP_GLOBALS, pDeviceObject),
     FIELD_SIZE(ATMARP_GLOBALS, pDeviceObject)
  },


  {
    "pAdapterList",
     FIELD_OFFSET(ATMARP_GLOBALS, pAdapterList),
     FIELD_SIZE(ATMARP_GLOBALS, pAdapterList)
  },

  {
    "AdapterCount",
     FIELD_OFFSET(ATMARP_GLOBALS, AdapterCount),
     FIELD_SIZE(ATMARP_GLOBALS, AdapterCount)
  },

  {
    "bUnloading",
     FIELD_OFFSET(ATMARP_GLOBALS, bUnloading),
     FIELD_SIZE(ATMARP_GLOBALS, bUnloading)
  },

#ifdef NEWARP

  {
    "ARPRegisterHandle",
     FIELD_OFFSET(ATMARP_GLOBALS, ARPRegisterHandle),
     FIELD_SIZE(ATMARP_GLOBALS, ARPRegisterHandle)
  },

  {
    "pIPAddInterfaceRtn",
     FIELD_OFFSET(ATMARP_GLOBALS, pIPAddInterfaceRtn),
     FIELD_SIZE(ATMARP_GLOBALS, pIPAddInterfaceRtn)
  },

  {
    "pIPDelInterfaceRtn",
     FIELD_OFFSET(ATMARP_GLOBALS, pIPDelInterfaceRtn),
     FIELD_SIZE(ATMARP_GLOBALS, pIPDelInterfaceRtn)
  },

  {
    "pIPBindCompleteRtn",
     FIELD_OFFSET(ATMARP_GLOBALS, pIPBindCompleteRtn),
     FIELD_SIZE(ATMARP_GLOBALS, pIPBindCompleteRtn)
  },

#else
    #error "unimplemented"
#endif // NEWARP

  {
    "Block",
     FIELD_OFFSET(ATMARP_GLOBALS, Block),
     FIELD_SIZE(ATMARP_GLOBALS, Block)
  },


#ifdef GPC

#if DBG
  {
    "aaq_sig",
     FIELD_OFFSET(ATMARP_GLOBALS, aaq_sig),
     FIELD_SIZE(ATMARP_GLOBALS, aaq_sig)
  },
#endif

  {
    "pFlowInfoList",
     FIELD_OFFSET(ATMARP_GLOBALS, pFlowInfoList),
     FIELD_SIZE(ATMARP_GLOBALS, pFlowInfoList)
  },

  {
    "GpcClientHandle",
     FIELD_OFFSET(ATMARP_GLOBALS, GpcClientHandle),
     FIELD_SIZE(ATMARP_GLOBALS, GpcClientHandle)
  },

  {
    "bGpcInitialized",
     FIELD_OFFSET(ATMARP_GLOBALS, bGpcInitialized),
     FIELD_SIZE(ATMARP_GLOBALS, bGpcInitialized)
  },

  {
    "GpcCalls",
     FIELD_OFFSET(ATMARP_GLOBALS, GpcCalls),
     FIELD_SIZE(ATMARP_GLOBALS, GpcCalls)
  },
#endif // GPC

  {
  	NULL
  }

};


TYPE_INFO type_ATMARP_GLOBALS = {
    "ATMARP_GLOBALS",
    "aag",
     typeid_ATMARP_GLOBALS,
     0,
     sizeof(ATMARP_GLOBALS),
     rgfi_ATMARP_GLOBALS
};


//
// STRUCTURES CONCERNING TYPE "ATMARP_INTERFACE"
//

STRUCT_FIELD_INFO  rgfi_ATMARP_INTERFACE[] =
{

#if DBG
  {
    "aai_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aai_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aai_sig)
  },
#endif


//	struct _ATMARP_INTERFACE *	pNextInterface;		// in list of ATMARP interfaces
  {
    "pNextInterface",
     FIELD_OFFSET(ATMARP_INTERFACE, pNextInterface),
     FIELD_SIZE(ATMARP_INTERFACE, pNextInterface)
  },
//	ULONG						RefCount;			// References to this interface
  {
    "RefCount",
     FIELD_OFFSET(ATMARP_INTERFACE, RefCount),
     FIELD_SIZE(ATMARP_INTERFACE, RefCount)
  },
//	ULONG						AdminState;			// Desired state of this interface
  {
    "AdminState",
     FIELD_OFFSET(ATMARP_INTERFACE, AdminState),
     FIELD_SIZE(ATMARP_INTERFACE, AdminState)
  },
//	ULONG						State;				// (Actual) State of this interface
  {
    "State",
     FIELD_OFFSET(ATMARP_INTERFACE, State),
     FIELD_SIZE(ATMARP_INTERFACE, State)
  },

#if (RECONFIG)
    //enum...                               ReconfigState;
  {
    "ReconfigState",
     FIELD_OFFSET(ATMARP_INTERFACE, ReconfigState),
     FIELD_SIZE(ATMARP_INTERFACE, ReconfigState)
  },
#endif // RECONFIG

//	ULONG						Flags;				// Misc state information
  {
    "Flags",
     FIELD_OFFSET(ATMARP_INTERFACE, Flags),
     FIELD_SIZE(ATMARP_INTERFACE, Flags)
  },

#if DBG
//	ULONG						aaim_sig;			// Signature to help debugging
  {
    "aaim_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aaim_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aaim_sig)
  },
#endif

//	struct _ATMARP_INTERFACE *	pAdapter;			// Pointer to Adapter info
  {
    "pAdapter",
     FIELD_OFFSET(ATMARP_INTERFACE, pAdapter),
     FIELD_SIZE(ATMARP_INTERFACE, pAdapter)
  },
#if 0
//	PCO_SAP						pSap;				// SAP info for this interface
  {
    "pSap",
     FIELD_OFFSET(ATMARP_INTERFACE, pSap),
     FIELD_SIZE(ATMARP_INTERFACE, pSap)
  },
#endif // 0

// ATMARP_SAP					SapList;			// Each SAP registered with CallMgr
  {
    "SapList",
     FIELD_OFFSET(ATMARP_INTERFACE, SapList),
     FIELD_SIZE(ATMARP_INTERFACE, SapList)
  },

//	ATMARP_HEADER_POOL			HeaderPool[AA_HEADER_TYPE_MAX];
  {
    "HeaderPool",
     FIELD_OFFSET(ATMARP_INTERFACE, HeaderPool),
     FIELD_SIZE(ATMARP_INTERFACE, HeaderPool)
  },


	//
	//  ----- IP/ARP interface related ----
	//
#if DBG
	//ULONG						aaia_sig;			// Signature to help debugging
  {
    "aaia_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aaia_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aaia_sig)
  },
#endif
//	PVOID						IPContext;			// Use in calls to IP
  {
    "IPContext",
     FIELD_OFFSET(ATMARP_INTERFACE, IPContext),
     FIELD_SIZE(ATMARP_INTERFACE, IPContext)
  },
//	IP_ADDRESS_ENTRY			LocalIPAddress;		// List of local IP addresses. There
  {
    "LocalIPAddress",
     FIELD_OFFSET(ATMARP_INTERFACE, LocalIPAddress),
     FIELD_SIZE(ATMARP_INTERFACE, LocalIPAddress)
  },
													// should be atleast one.
//NDIS_STRING					IPConfigString;		// Config info for IP for this LIS
  {
    "IPConfigString",
     FIELD_OFFSET(ATMARP_INTERFACE, IPConfigString),
     FIELD_SIZE(ATMARP_INTERFACE, IPConfigString)
  },

	//
	//  ----- IP/ATM operation related ----
	//
#if DBG
//	ULONG						aait_sig;			// Signature to help debugging
  {
    "aait_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aait_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aait_sig)
  },
#endif
//	PATMARP_IP_ENTRY *			pArpTable;			// The ARP table
  {
    "pArpTable",
     FIELD_OFFSET(ATMARP_INTERFACE, pArpTable),
     FIELD_SIZE(ATMARP_INTERFACE, pArpTable)
  },
//	ULONG						NumOfArpEntries;	// Entries in the above
  {
    "NumOfArpEntries",
     FIELD_OFFSET(ATMARP_INTERFACE, NumOfArpEntries),
     FIELD_SIZE(ATMARP_INTERFACE, NumOfArpEntries)
  },
//	ATMARP_SERVER_LIST			ArpServerList;		// List of ARP servers
  {
    "ArpServerList",
     FIELD_OFFSET(ATMARP_INTERFACE, ArpServerList),
     FIELD_SIZE(ATMARP_INTERFACE, ArpServerList)
  },
//	PATMARP_SERVER_ENTRY		pCurrentServer;		// ARP server in use
  {
    "pCurrentServer",
     FIELD_OFFSET(ATMARP_INTERFACE, pCurrentServer),
     FIELD_SIZE(ATMARP_INTERFACE, pCurrentServer)
  },
//	PATMARP_ATM_ENTRY			pAtmEntryList;		// List of all ATM Entries
  {
    "pAtmEntryList",
     FIELD_OFFSET(ATMARP_INTERFACE, pAtmEntryList),
     FIELD_SIZE(ATMARP_INTERFACE, pAtmEntryList)
  },
//	ULONG						AtmInterfaceUp;		// The ATM interface is considered
  {
    "AtmInterfaceUp",
     FIELD_OFFSET(ATMARP_INTERFACE, AtmInterfaceUp),
     FIELD_SIZE(ATMARP_INTERFACE, AtmInterfaceUp)
  },
													// "up" after ILMI addr regn is over
//	ATM_ADDRESS					LocalAtmAddress;	// Our ATM (HW) Address
  {
    "LocalAtmAddress",
     FIELD_OFFSET(ATMARP_INTERFACE, LocalAtmAddress),
     FIELD_SIZE(ATMARP_INTERFACE, LocalAtmAddress)
  },

//	ATMARP_TIMER_LIST			TimerList[AAT_CLASS_MAX];
  {
    "TimerList",
     FIELD_OFFSET(ATMARP_INTERFACE, TimerList),
     FIELD_SIZE(ATMARP_INTERFACE, TimerList)
  },

#ifdef IPMCAST
	//
	//  ---- IP Multicast over ATM stuff ----
	//
#if DBG
	//ULONG						aaic_sig;			// Signature for debugging
  {
    "aaic_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aaic_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aaic_sig)
  },
#endif // DBG
//	ULONG						IpMcState;			// State of IP Multicast/ATM
  {
    "IpMcState",
     FIELD_OFFSET(ATMARP_INTERFACE, IpMcState),
     FIELD_SIZE(ATMARP_INTERFACE, IpMcState)
  },
//	PATMARP_IPMC_JOIN_ENTRY		pJoinList;			// List of MC groups we have Joined
  {
    "pJoinList",
     FIELD_OFFSET(ATMARP_INTERFACE, pJoinList),
     FIELD_SIZE(ATMARP_INTERFACE, pJoinList)
  },
//	PATMARP_IP_ENTRY			pMcSendList;		// Sorted list of MC groups we send to
  {
    "pMcSendList",
     FIELD_OFFSET(ATMARP_INTERFACE, pMcSendList),
     FIELD_SIZE(ATMARP_INTERFACE, pMcSendList)
  },
//	ATMARP_SERVER_LIST			MARSList;			// List of MARS (servers)
  {
    "MARSList",
     FIELD_OFFSET(ATMARP_INTERFACE, MARSList),
     FIELD_SIZE(ATMARP_INTERFACE, MARSList)
  },
//	PATMARP_SERVER_ENTRY		pCurrentMARS;		// MARS in use
  {
    "pCurrentMARS",
     FIELD_OFFSET(ATMARP_INTERFACE, pCurrentMARS),
     FIELD_SIZE(ATMARP_INTERFACE, pCurrentMARS)
  },
#endif // IPMCAST

//	PAA_GET_PACKET_SPEC_FUNC	pGetPacketSpecFunc;	// Routine to extract packet specs
  {
    "pGetPacketSpecFunc",
     FIELD_OFFSET(ATMARP_INTERFACE, pGetPacketSpecFunc),
     FIELD_SIZE(ATMARP_INTERFACE, pGetPacketSpecFunc)
  },

//	PATMARP_FLOW_INFO			pFlowInfoList;		// List of configured flows
  {
    "pFlowInfoList",
     FIELD_OFFSET(ATMARP_INTERFACE, pFlowInfoList),
     FIELD_SIZE(ATMARP_INTERFACE, pFlowInfoList)
  },

#ifdef DHCP_OVER_ATM
//	BOOLEAN						DhcpEnabled;
  {
    "DhcpEnabled",
     FIELD_OFFSET(ATMARP_INTERFACE, DhcpEnabled),
     FIELD_SIZE(ATMARP_INTERFACE, DhcpEnabled)
  },
//	ATM_ADDRESS					DhcpServerAddress;
  {
    "DhcpServerAddress",
     FIELD_OFFSET(ATMARP_INTERFACE, DhcpServerAddress),
     FIELD_SIZE(ATMARP_INTERFACE, DhcpServerAddress)
  },
//	PATMARP_ATM_ENTRY			pDhcpServerAtmEntry;
  {
    "pDhcpServerAtmEntry",
     FIELD_OFFSET(ATMARP_INTERFACE, pDhcpServerAtmEntry),
     FIELD_SIZE(ATMARP_INTERFACE, pDhcpServerAtmEntry)
  },
#endif // DHCP_OVER_ATM

	//
	//  ---- WMI Information ---
	//
#if ATMARP_WMI
#if DBG
//	ULONG						aaiw_sig;			// Signature to help debugging
  {
    "aaiw_sig",
     FIELD_OFFSET(ATMARP_INTERFACE, aaiw_sig),
     FIELD_SIZE(ATMARP_INTERFACE, aaiw_sig)
  },
#endif

//	struct _ATMARP_IF_WMI_INFO *pIfWmiInfo;
  {
    "pIfWmiInfo",
     FIELD_OFFSET(ATMARP_INTERFACE, pIfWmiInfo),
     FIELD_SIZE(ATMARP_INTERFACE, pIfWmiInfo)
  },
#endif // ATMARP_WMI

  {
  	NULL
  }

};

TYPE_INFO type_ATMARP_INTERFACE = {
    "ATMARP_INTERFACE",
    "i",
     typeid_ATMARP_INTERFACE,
     fTYPEINFO_ISLIST,
     sizeof(ATMARP_INTERFACE),
     rgfi_ATMARP_INTERFACE,
     FIELD_OFFSET(ATMARP_INTERFACE, pNextInterface) // offset to next pointer.
};

//
// STRUCTURES CONCERNING TYPE "ATMARP_ATM_ENTRY"
//


BITFIELD_INFO rgAtmEntryFlagsInfo[] =
{
	{
	"IDLE",
	AA_ATM_ENTRY_STATE_MASK,
	AA_ATM_ENTRY_IDLE
	},

	{
	"ACTIVE",
	AA_ATM_ENTRY_STATE_MASK,
	AA_ATM_ENTRY_ACTIVE
	},

	{
	"CLOSING",
	AA_ATM_ENTRY_STATE_MASK,
	AA_ATM_ENTRY_CLOSING
	},

	{
	"UCAST",
	AA_ATM_ENTRY_TYPE_MASK,
	AA_ATM_ENTRY_TYPE_UCAST
	},

	{
	"NUCAST",
	AA_ATM_ENTRY_TYPE_MASK,
	AA_ATM_ENTRY_TYPE_NUCAST
	},


	{
	NULL
	}
};

TYPE_INFO type_ATMARP_ATM_ENTRY_FLAGS = {
    "",
    "",
    typeid_NULL,
    fTYPEINFO_ISBITFIELD,
    sizeof(ULONG),
    NULL,
    0,
    rgAtmEntryFlagsInfo
};

STRUCT_FIELD_INFO  rgfi_ATMARP_ATM_ENTRY[] =
{

#if DBG
  {
    "aae_sig",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, aae_sig),
     FIELD_SIZE(ATMARP_ATM_ENTRY, aae_sig)
  },
#endif


//	struct _ATMARP_ATM_ENTRY *	pNext;
  {
    "pNext",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pNext),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pNext)
  },
//	ULONG						RefCount;			// References
  {
    "RefCount",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, RefCount),
     FIELD_SIZE(ATMARP_ATM_ENTRY, RefCount)
  },
//	ULONG						Flags;			// Desired state of this interface
  {
    "Flags",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, Flags),
     FIELD_SIZE(ATMARP_ATM_ENTRY, Flags),
     0, // flags
	 &type_ATMARP_ATM_ENTRY_FLAGS
  },


#if 0
//	ULONG						Lock;
  {
    "Lock",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, Lock),
     FIELD_SIZE(ATMARP_ATM_ENTRY, Lock)
  },
#endif

     // struct _ATMARP_INTERFACE *      pInterface;     // Back pointer
  {
    "pInterface",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pInterface),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pInterface)
  },


// struct _ATMARP_VC *             pVcList;        // List of VCs to this ATM
  {
    "pVcList",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pVcList),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pVcList)
  },


// struct _ATMARP_VC *				pBestEffortVc;	// One of the Best Effort VCs here
  {
    "pBestEffortVc",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pBestEffortVc),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pBestEffortVc)
  },
// struct _ATMARP_IP_ENTRY *		pIpEntryList;	// List of IP entries that
  {
    "pIpEntryList",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pIpEntryList),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pIpEntryList)
  },

// ATM_ADDRESS						ATMAddress;		// "ATM Number" in the RFC
  {
    "ATMAddress",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, ATMAddress),
     FIELD_SIZE(ATMARP_ATM_ENTRY, ATMAddress)
  },

#if 0
// ATM_ADDRESS						ATMSubAddress;
  {
    "ATMSubAddress",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, ATMSubAddress),
     FIELD_SIZE(ATMARP_ATM_ENTRY, ATMSubAddress)
  },
#endif // 0

#ifdef IPMCAST
// struct _ATMARP_IPMC_ATM_INFO *	pMcAtmInfo;		// Additional info for multicast
  {
    "pMcAtmInfo",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pMcAtmInfo),
     FIELD_SIZE(ATMARP_ATM_ENTRY, pMcAtmInfo)
  },
#endif // IPMCAST


#if DBG
//UCHAR Refs[AE_REFTYPE_COUNT];
  {
    "Refs",
     FIELD_OFFSET(ATMARP_ATM_ENTRY, Refs),
     FIELD_SIZE(ATMARP_ATM_ENTRY, Refs)
  },
#endif //DBG

	{
		NULL
	}


};

TYPE_INFO type_ATMARP_ATM_ENTRY = {
    "ATMARP_ATM_ENTRY",
    "ae",
     typeid_ATMARP_ATM_ENTRY,
     fTYPEINFO_ISLIST,
     sizeof(ATMARP_ATM_ENTRY),
     rgfi_ATMARP_ATM_ENTRY,
     FIELD_OFFSET(ATMARP_ATM_ENTRY, pNext) // offset to next pointer.
};

//
// STRUCTURES CONCERNING TYPE "ATMARP_IP_ENTRY"
//

BITFIELD_INFO rgIpEntryFlagsInfo[] =
{

	{
	"IDLE",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_IDLE
	},

	{
	"ARPING",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_ARPING
	},

	{
	"INARPING",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_INARPING
	},
	{
	"RESOLVED",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_RESOLVED
	},

	{
	"COMM_ERROR",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_COMM_ERROR
	},

	{
	"ABORTING",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_ABORTING
	},

	{
	"AGED_OUT",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_AGED_OUT
	},

	{
	"SEEN_NAK",
	AA_IP_ENTRY_STATE_MASK,
	AA_IP_ENTRY_SEEN_NAK
	},


#ifdef IPMCAST

#define MC	AA_IP_ENTRY_ADDR_TYPE_NUCAST
//			
//				We use this to only dump other multicast-related fields
//				if this field is set.

	{
	"MC_NO_REVALIDATION",
	MC|AA_IP_ENTRY_MC_VALIDATE_MASK,
	MC|AA_IP_ENTRY_MC_NO_REVALIDATION
	},

	{
	"MC_REVALIDATE",
	MC|AA_IP_ENTRY_MC_VALIDATE_MASK,
	MC|AA_IP_ENTRY_MC_REVALIDATE
	},

	{
	"MC_REVALIDATING",
	MC|AA_IP_ENTRY_MC_VALIDATE_MASK,
	MC|AA_IP_ENTRY_MC_REVALIDATING
	},


	{
	"MC_IDLE",
	MC|AA_IP_ENTRY_MC_RESOLVE_MASK,
	MC|AA_IP_ENTRY_MC_IDLE
	},

	{
	"MC_AWAIT_MULTI",
	MC|AA_IP_ENTRY_MC_RESOLVE_MASK,
	MC|AA_IP_ENTRY_MC_AWAIT_MULTI
	},

	{
	"MC_DISCARDING_MULTI",
	MC|AA_IP_ENTRY_MC_RESOLVE_MASK,
	MC|AA_IP_ENTRY_MC_DISCARDING_MULTI
	},

	{
	"MC_RESOLVED",
	MC|AA_IP_ENTRY_MC_RESOLVE_MASK,
	MC|AA_IP_ENTRY_MC_RESOLVED
	},

	{
	"UCAST",
	AA_IP_ENTRY_ADDR_TYPE_MASK,
	AA_IP_ENTRY_ADDR_TYPE_UCAST
	},

	{
	"NUCAST",
	AA_IP_ENTRY_ADDR_TYPE_MASK,
	AA_IP_ENTRY_ADDR_TYPE_NUCAST
	},

#endif // IPMCAST


	{
	"STATIC",
	AA_IP_ENTRY_TYPE_MASK,
	AA_IP_ENTRY_IS_STATIC
	},

	{
		NULL
	}
};


TYPE_INFO type_ATMARP_IP_ENTRY_FLAGS = {
    "",
    "",
    typeid_NULL,
    fTYPEINFO_ISBITFIELD,
    sizeof(ULONG),
    NULL,
    0,
    rgIpEntryFlagsInfo
};


STRUCT_FIELD_INFO  rgfi_ATMARP_IP_ENTRY[] =
{

#if DBG
  {
    "aip_sig",
     FIELD_OFFSET(ATMARP_IP_ENTRY, aip_sig),
     FIELD_SIZE(ATMARP_IP_ENTRY, aip_sig)
  },
#endif

//	IP_ADDRESS						IPAddress;		// IP Address
  {
    "IPAddress",
     FIELD_OFFSET(ATMARP_IP_ENTRY, IPAddress),
     FIELD_SIZE(ATMARP_IP_ENTRY, IPAddress)
  },

//	struct _ATMARP_IP_ENTRY *	pNextEntry;
  {
    "pNextEntry",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pNextEntry),
     FIELD_SIZE(ATMARP_IP_ENTRY, pNextEntry)
  },

//	struct _ATMARP_IP_ENTRY *		pNextToAtm;		// List of entries pointing to
  {
    "pNextToAtm",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pNextToAtm),
     FIELD_SIZE(ATMARP_IP_ENTRY, pNextToAtm)
  },

//	ULONG						Flags;			// Desired state of this interface
  {
    "Flags",
     FIELD_OFFSET(ATMARP_IP_ENTRY, Flags),
     FIELD_SIZE(ATMARP_IP_ENTRY, Flags),
     0, // flags
	 &type_ATMARP_IP_ENTRY_FLAGS
  },

//	ULONG						RefCount;			// References
  {
    "RefCount",
     FIELD_OFFSET(ATMARP_IP_ENTRY, RefCount),
     FIELD_SIZE(ATMARP_IP_ENTRY, RefCount)
  },

#if 0
//	ULONG						Lock;
  {
    "Lock",
     FIELD_OFFSET(ATMARP_IP_ENTRY, Lock),
     FIELD_SIZE(ATMARP_IP_ENTRY, Lock)
  },
#endif

     // struct _ATMARP_INTERFACE *      pInterface;     // Back pointer
  {
    "pInterface",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pInterface),
     FIELD_SIZE(ATMARP_IP_ENTRY, pInterface)
  },


//	PATMARP_ATM_ENTRY				pAtmEntry;		// Pointer to all ATM info
  {
    "pAtmEntry",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pAtmEntry),
     FIELD_SIZE(ATMARP_IP_ENTRY, pAtmEntry)
  },


#ifdef IPMCAST

//	struct _ATMARP_IP_ENTRY *		pNextMcEntry;	// Next "higher" Multicast IP Entry
  {
    "pNextMcEntry",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pNextMcEntry),
     FIELD_SIZE(ATMARP_IP_ENTRY, pNextMcEntry)
  },

//	USHORT							NextMultiSeq;	// Sequence Number expected
  {
    "NextMultiSeq",
     FIELD_OFFSET(ATMARP_IP_ENTRY, NextMultiSeq),
     FIELD_SIZE(ATMARP_IP_ENTRY, NextMultiSeq)
  },

													// in the next MULTI
#if 0
	USHORT							Filler;
#endif // 0

#endif // IPMCAST


//	ATMARP_TIMER					Timer;			// Timers are: (all exclusive)
  {
    "Timer",
     FIELD_OFFSET(ATMARP_IP_ENTRY, Timer),
     FIELD_SIZE(ATMARP_IP_ENTRY, Timer)
  },


//	ULONG							RetriesLeft;
  {
    "RetriesLeft",
     FIELD_OFFSET(ATMARP_IP_ENTRY, RetriesLeft),
     FIELD_SIZE(ATMARP_IP_ENTRY, RetriesLeft)
  },

//	PNDIS_PACKET					PacketList;		// List of packets waiting to be sent
  {
    "PacketList",
     FIELD_OFFSET(ATMARP_IP_ENTRY, PacketList),
     FIELD_SIZE(ATMARP_IP_ENTRY, PacketList)
  },

// RouteCacheEntry *				pRCEList;		// List of Route Cache Entries
  {
    "pRCEList",
     FIELD_OFFSET(ATMARP_IP_ENTRY, pRCEList),
     FIELD_SIZE(ATMARP_IP_ENTRY, pRCEList)
  },

#if 0
#ifdef CUBDD
	SINGLE_LIST_ENTRY				PendingIrpList;	// List of IRP's waiting for
													// this IP address to be resolved.
#endif // CUBDD
#endif// 0

#if DBG
//UCHAR Refs[IE_REFTYPE_COUNT];
  {
    "Refs",
     FIELD_OFFSET(ATMARP_IP_ENTRY, Refs),
     FIELD_SIZE(ATMARP_IP_ENTRY, Refs)
  },
#endif //DBG

  {
  	NULL
  }

};

TYPE_INFO type_ATMARP_IP_ENTRY = {
    "ATMARP_IP_ENTRY",
    "ip",
     typeid_ATMARP_IP_ENTRY,
     fTYPEINFO_ISLIST,
     sizeof(ATMARP_IP_ENTRY),
     rgfi_ATMARP_IP_ENTRY,
     FIELD_OFFSET(ATMARP_IP_ENTRY, pNextToAtm) // offset to next pointer.
};


//
// STRUCTURES CONCERNING TYPE "ATMARP_VC"
//

STRUCT_FIELD_INFO  rgfi_ATMARP_VC[] =
{

#if DBG
  {
    "avc_sig",
     FIELD_OFFSET(ATMARP_VC, avc_sig),
     FIELD_SIZE(ATMARP_VC, avc_sig)
  },
#endif


//	struct _ATMARP_VC *	pNextVc;
  {
    "pNextVc",
     FIELD_OFFSET(ATMARP_VC, pNextVc),
     FIELD_SIZE(ATMARP_VC, pNextVc)
  },



//	ULONG						RefCount;			// References
  {
    "RefCount",
     FIELD_OFFSET(ATMARP_VC, RefCount),
     FIELD_SIZE(ATMARP_VC, RefCount)
  },

#if 0
//	ULONG						Lock;
  {
    "Lock",
     FIELD_OFFSET(ATMARP_VC, Lock),
     FIELD_SIZE(ATMARP_VC, Lock)
  },
#endif

//	ULONG						Flags;			// Desired state of this interface
  {
    "Flags",
     FIELD_OFFSET(ATMARP_VC, Flags),
     FIELD_SIZE(ATMARP_VC, Flags)
  },


	//	NDIS_HANDLE						NdisVcHandle;	// For NDIS calls
  {
    "NdisVcHandle",
     FIELD_OFFSET(ATMARP_VC, NdisVcHandle),
     FIELD_SIZE(ATMARP_VC, NdisVcHandle)
  },

  // struct _ATMARP_INTERFACE *      pInterface;     // Back pointer
  {
    "pInterface",
     FIELD_OFFSET(ATMARP_VC, pInterface),
     FIELD_SIZE(ATMARP_VC, pInterface)
  },


//	PATMARP_ATM_ENTRY				pAtmEntry;		// Pointer to all ATM info
  {
    "pAtmEntry",
     FIELD_OFFSET(ATMARP_VC, pAtmEntry),
     FIELD_SIZE(ATMARP_VC, pAtmEntry)
  },


//	PNDIS_PACKET					PacketList;		// List of packets waiting to be sent
  {
    "PacketList",
     FIELD_OFFSET(ATMARP_VC, PacketList),
     FIELD_SIZE(ATMARP_VC, PacketList)
  },




//	ATMARP_TIMER					Timer;			// Timers are: (all exclusive)
  {
    "Timer",
     FIELD_OFFSET(ATMARP_VC, Timer),
     FIELD_SIZE(ATMARP_VC, Timer)
  },

//	ULONG							RetriesLeft;
  {
    "RetriesLeft",
     FIELD_OFFSET(ATMARP_VC, RetriesLeft),
     FIELD_SIZE(ATMARP_VC, RetriesLeft)
  },

#ifdef GPC
//	PVOID							FlowHandle;		// Points to Flow Info struct
  {
    "FlowHandle",
     FIELD_OFFSET(ATMARP_VC, FlowHandle),
     FIELD_SIZE(ATMARP_VC, FlowHandle)
  },
#endif // GPC



//	ATMARP_FILTER_SPEC				FilterSpec;		// Filter Spec (Protocol, port)
  {
    "FilterSpec",
     FIELD_OFFSET(ATMARP_VC, FilterSpec),
     FIELD_SIZE(ATMARP_VC, FilterSpec)
  },

//	ATMARP_FLOW_SPEC				FlowSpec;		// Flow Spec (QoS etc) for this conn
  {
    "FlowSpec",
     FIELD_OFFSET(ATMARP_VC, FlowSpec),
     FIELD_SIZE(ATMARP_VC, FlowSpec)
  },

  {
  	NULL
  }

};

TYPE_INFO type_ATMARP_VC = {
    "ATMARP_VC",
    "vc",
     typeid_ATMARP_VC,
     fTYPEINFO_ISLIST,
     sizeof(ATMARP_VC),
     rgfi_ATMARP_VC,
     FIELD_OFFSET(ATMARP_VC, pNextVc) // offset to next pointer.
};


TYPE_INFO *g_rgAAC_Types[] =
{
    &type_ATMARP_GLOBALS,
    &type_ATMARP_ADAPTER,
    &type_ATMARP_INTERFACE,
    &type_ATMARP_ATM_ENTRY,
    &type_ATMARP_IP_ENTRY,
    &type_ATMARP_VC,

    NULL
};

#if 0
typedef struct
{
    const char *szName; // of variable.
    const char *szShortName;
    TYPE_INFO  *pBaseType;  // could be null (unspecified).
    UINT       uFlags;
    UINT       cbSize;
    UINT_PTR   uAddr;       // Address in debuggee's address space.

} GLOBALVAR_INFO;
#endif

GLOBALVAR_INFO g_rgAAC_Globals[] =
{
    {
        "AtmArpGlobalInfo",
        "aag",
         &type_ATMARP_GLOBALS,
         0,
         sizeof(AtmArpGlobalInfo),
         0
    },


    {
        "AtmArpProtocolCharacteristics",
        "pc",
         NULL,
         0,
         sizeof(AtmArpProtocolCharacteristics),
         0
    },

    {
        "AtmArpClientCharacteristics",
        "cc",
         NULL,
         0,
         sizeof(AtmArpClientCharacteristics),
         0
    },

    {
    NULL
    }
};

UINT_PTR
AAC_ResolveAddress(
		TYPE_INFO *pType
		);

NAMESPACE AAC_NameSpace = {
			g_rgAAC_Types,
			g_rgAAC_Globals,
			AAC_ResolveAddress
			};

void
AAC_CmdHandler(
	DBGCOMMAND *pCmd
	);

void
do_aac(PCSTR args)
{

	DBGCOMMAND *pCmd = Parse(args, &AAC_NameSpace);
	if (pCmd)
	{
		//DumpCommand(pCmd);
		DoCommand(pCmd, AAC_CmdHandler);
		FreeCommand(pCmd);
		pCmd = NULL;
	}

    return;

}

void
do_help(PCSTR args)
{
    return;
}


void
AAC_CmdHandler(
	DBGCOMMAND *pCmd
	)
{
	MyDbgPrintf("Handler called \n");
}


UINT_PTR
AAC_ResolveAddress(
		TYPE_INFO *pType
		)
{
	UINT_PTR uAddr = 0;
	UINT uOffset = 0;
	BOOL fRet = FALSE;
	UINT_PTR uParentAddress = 0;

	static UINT_PTR uAddr_AtmArpGlobalInfo;

	//
	// If this type has a parent (container) type, we will use the containing
	// type's cached address if its available, else we'll resolve the
	// containers type. The root types are globals -- we do an
	// expression evaluation for them.
	//

    switch(pType->uTypeID)
    {

    case typeid_ATMARP_GLOBALS:
		if (!uAddr_AtmArpGlobalInfo)
		{
  			uAddr_AtmArpGlobalInfo =
					 dbgextGetExpression("atmarpc!AtmArpGlobalInfo");
			pType->uCachedAddress =  uAddr_AtmArpGlobalInfo;
		}
    	uAddr  = uAddr_AtmArpGlobalInfo;
    	if (uAddr)
    	{
    		fRet = TRUE;
    	}
    	break;

    case typeid_ATMARP_ADAPTER:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_GLOBALS.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_GLOBALS);
		}
		if (uParentAddress)
		{
    		uOffset =  FIELD_OFFSET(ATMARP_GLOBALS, pAdapterList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress+uOffset,
								&uAddr,
								"ATMARP_GLOBALS::pAdapterList"
								);
		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
		}
		break;

    case typeid_ATMARP_INTERFACE:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_ADAPTER.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_ADAPTER);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(ATMARP_ADAPTER, pInterfaceList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"ATMARP_ADAPTER::pInterfaceList"
								);

		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

    case typeid_ATMARP_ATM_ENTRY:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_INTERFACE.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_INTERFACE);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(ATMARP_INTERFACE, pAtmEntryList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"ATMARP_INTERFACE::pAtmEntryList"
								);

		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

    case typeid_ATMARP_IP_ENTRY:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_ATM_ENTRY.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_ATM_ENTRY);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(ATMARP_ATM_ENTRY, pIpEntryList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"ATMARP_ATM_ENTRY::pIpEntryList"
								);

		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

    case typeid_ATMARP_VC:
    	//
    	//
    	//
		uParentAddress =  type_ATMARP_ATM_ENTRY.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  AAC_ResolveAddress(&type_ATMARP_ATM_ENTRY);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(ATMARP_ATM_ENTRY, pVcList);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"ATMARP_ATM_ENTRY::pVcList"
								);

		#if 0
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

	default:
		MYASSERT(FALSE);
		break;

    }

	if (!fRet)
	{
		uAddr = 0;
	}

	MyDbgPrintf("ResolveAddress[%s] returns 0x%08lx\n", pType->szName, uAddr);
    return uAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\parse.h ===
typedef enum // tokens: * . ? [ ] / help dt dg L number <identifier>
{
    tokSTAR,            // *
    tokDOT,             // .
    tokQUESTION,        // ?
    tokLBRAC,           // [
    tokRBRAC,           // ]
    tokSLASH,           // /
    tokKEYWORD,         // alnum strings which match one of the known keys.
    tokNUMBER,           // 0xcbde 129
    tokIDENTIFIER       // non-keyword and non-number alnum

} eTOKTYPE;


typedef struct
{
    eTOKTYPE eTok;
    UINT     uID;     // Tok-specific ID:
                      //    IDENTIFIER: a unique number across all identifiers.
                      //    NUMBER: the number
                      //    KEYWORD: eKEYWORD
                      //    Other tokens: uID is unused.
    char    *szStr;   // String containg original chars that made up this token.

                      // Note: a string of pure hex digits which is followed 
                      // by a non-alnum char is assumed to be a number --
                      // later if it turns out to be more likely that it is
                      // an identifier, it is converted to an identifier.
                      // Same deal with a keyword -- if it turns out based
                      // on context to be most likely an identifier or part
                      // of an identifier, it will be converted to an
                      // identifier.
    
} TOKEN;

typedef enum
{
    keywordNULL,            // Invalid keyword, use for sentinels.
    keywordHELP,            // help
    keywordDUMP_TYPE,       // dt
    keywordDUMP_GLOBALS,    // dg
    keywordL                // L

} eKEYWORD;

//
// Following is not used currently...
//
typedef enum
{
    phraseCMD,
    phraseIDENTIFIER,   // with optional wildcards
    phraseINDEX,        // [2], [*],  [1-3], etc.
    phraseDOT,          // .
    phraseNUMBER,       // 0x8908 abcd
    phraseOBJ_COUNT,    // L 2
    phraseFLAG          // /xyz

} ePHRASE;

typedef enum
{
    cmdDUMP_TYPE,
    cmdDUMP_GLOBALS,
    cmdHELP

}ePRIMARY_COMMAND;


struct _DBGCOMMAND;

typedef void (*PFN_SPECIAL_COMMAND_HANDLER)(struct _DBGCOMMAND *pCmd);

typedef struct _DBGCOMMAND
{
	NAMESPACE 		*pNameSpace;	// Name space applicable for this command.
    ePRIMARY_COMMAND ePrimaryCmd; // DumpGlobals, DumpType, help
    UINT 			uFlags;            // One or more fCMDFLAG_*
    TOKEN 			*ptokObject;     // eg <type>
    TOKEN 			*ptokSubObject;  // eg <field>
    UINT 			uVectorIndexStart; // if[0]
    UINT 			uVectorIndexEnd; // if[0]
    UINT 			uObjectAddress; // <address>
    UINT 			uObjectCount; // L 10

    void 			*pvContext;    // private context.
    //PFN_SPECIAL_COMMAND_HANDLER pfnSpecialHandler;

} DBGCOMMAND;


#define fCMDFLAG_HAS_VECTOR_INDEX       (0x1<<0)
#define fCMDFLAG_HAS_SUBOBJECT          (0x1<<1)
#define fCMDFLAG_HAS_OBJECT_ADDRESS     (0x1<<2)
#define fCMDFLAG_HAS_OBJECT_COUNT       (0x1<<3)
#define fCMDFLAG_OBJECT_STAR_PREFIX     (0x1<<4)
#define fCMDFLAG_OBJECT_STAR_SUFFIX     (0x1<<5)
#define fCMDFLAG_SUBOBJECT_STAR_PREFIX  (0x1<<6)
#define fCMDFLAG_SUBOBJECT_STAR_SUFFIX  (0x1<<7)

#define CMD_SET_FLAG(_pCmd, _f)  ((_pCmd)->uFlags |= (_f))
#define CMD_CLEAR_FLAG(_pCmd, _f)  ((_pCmd)->uFlags &= ~(_f))
#define CMD_IS_FLAG_SET(_pCmd, _f)  ((_pCmd)->uFlags & (_f))

DBGCOMMAND *
Parse(
    IN  const char *szInput,
    IN	NAMESPACE *
);

void
FreeCommand(
    DBGCOMMAND *pCommand
);

void
DumpCommand(
    DBGCOMMAND *pCommand
);


#if 0
//!aac dt <type> . <field> <address> L <count> <flags>
//!aac dt <type> [index] . <field>   L <count> <flags>
//!aac dg <name> . <field>
//
//!aac dt if[*].*handle* 0x324890 L 5

0. Break up sentance into tokens:
        keywords: * . L dg dt ? help [ ] /
        identifier: contiguous non-keyword alnum
        number: interpreted as hex with optional 0x.
1st pass: combine "[*]", "*word*", "/xyz" into single entities 

1. Parse primary command: literal text
2. Parse primary object: [*]literal_text[*]
3. Parse index "[...]"
4. Parse field "."
5. Parse address (hex number)
6. Parse object count L <count>
#endif //  0

void
DoCommand(DBGCOMMAND *pCmd, PFN_SPECIAL_COMMAND_HANDLER pfnHandler);

void
DoDumpType(DBGCOMMAND *pCmd);

void
DoDumpGlobals(DBGCOMMAND *pCmd);

void
DoHelp(DBGCOMMAND *pCmd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\common.h ===
//
// Handlers for top-level extension commands.
//

void
do_aac(PCSTR args);

void
do_ndis(PCSTR args);

void
do_help(PCSTR args);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\dummy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	dummy.c	- dummy global vars.

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-30-98    Created

Notes:

--*/


#include "precomp.h"
#if TESTPROGRAM


ATMARP_GLOBALS		DummyAtmArpGlobalInfo;
ATMARP_ADAPTER		DummyAtmArpAdapter;

ATMARP_INTERFACE	DummyAtmArpInterface0;
ATMARP_INTERFACE	DummyAtmArpInterface1;
ATMARP_INTERFACE	DummyAtmArpInterface2;

ATMARP_ATM_ENTRY	DummyAtmArpAtmEntry0;
ATMARP_ATM_ENTRY	DummyAtmArpAtmEntry1;
ATMARP_ATM_ENTRY	DummyAtmArpAtmEntry2;

ATMARP_IP_ENTRY	DummyAtmArpIpEntry0;
ATMARP_IP_ENTRY	DummyAtmArpIpEntry1;
ATMARP_IP_ENTRY	DummyAtmArpIpEntry2;

ATMARP_VC	DummyAtmArpVc0;
ATMARP_VC	DummyAtmArpVc1;
ATMARP_VC	DummyAtmArpVc2;

NDIS_PROTOCOL_CHARACTERISTICS DummyAtmArpProtocolCharacteristics;
NDIS_CLIENT_CHARACTERISTICS DummyAtmArpClientCharacteristics;

void *pvDummyAtmArpGlobalInfo              = &DummyAtmArpGlobalInfo;
void *pvDummyAtmArpProtocolCharacteristics =&DummyAtmArpProtocolCharacteristics;
void *pvDummyAtmArpClientCharacteristics   =  &DummyAtmArpClientCharacteristics;

void
init_ATMARP_INTERFACE(ATMARP_INTERFACE *pI, ATMARP_INTERFACE *pNext);
void
init_ATMARP_ADAPTER(ATMARP_ADAPTER *pA, ATMARP_ADAPTER *pNext);
void
init_ATMARP_GLOBALS(ATMARP_GLOBALS *pG);
void
init_ATMARP_ATM_ENTRY(ATMARP_ATM_ENTRY *pAE, ATMARP_ATM_ENTRY *pNext);
void
init_ATMARP_IP_ENTRY(ATMARP_IP_ENTRY *pIP, ATMARP_IP_ENTRY *pNext);
void
init_ATMARP_VC(ATMARP_VC *pVC, ATMARP_VC *pNext);

void setup_dummy_vars(void)
{
	//
	// Set up dummy list of VCs
	//
	init_ATMARP_VC(&DummyAtmArpVc0, &DummyAtmArpVc1);
	init_ATMARP_VC(&DummyAtmArpVc1, &DummyAtmArpVc2);
	init_ATMARP_VC(&DummyAtmArpVc2, NULL);

	// Set up dummy list of IP entries..
	//
	init_ATMARP_IP_ENTRY(&DummyAtmArpIpEntry0, &DummyAtmArpIpEntry1);
	init_ATMARP_IP_ENTRY(&DummyAtmArpIpEntry1, &DummyAtmArpIpEntry2);
	init_ATMARP_IP_ENTRY(&DummyAtmArpIpEntry2, NULL);

	//
	// Set up dummy list of atm entries..
	//
	init_ATMARP_ATM_ENTRY(&DummyAtmArpAtmEntry0, &DummyAtmArpAtmEntry1);
	init_ATMARP_ATM_ENTRY(&DummyAtmArpAtmEntry1, &DummyAtmArpAtmEntry2);
	init_ATMARP_ATM_ENTRY(&DummyAtmArpAtmEntry2, NULL);

	//
	// Set up dummy list of interfaces..
	//
	init_ATMARP_INTERFACE(&DummyAtmArpInterface0, &DummyAtmArpInterface1);
	init_ATMARP_INTERFACE(&DummyAtmArpInterface1, &DummyAtmArpInterface2);
	init_ATMARP_INTERFACE(&DummyAtmArpInterface2, NULL);

	//
	// Set up dummy adapter structure.
	//
	init_ATMARP_ADAPTER(&DummyAtmArpAdapter, NULL);

	//
	// Set up dummy gobal info structure.
	//
	init_ATMARP_GLOBALS(&DummyAtmArpGlobalInfo);

}

void
init_ATMARP_INTERFACE(ATMARP_INTERFACE *pI, ATMARP_INTERFACE *pNext)
{
#if DBG
	pI->aai_sig = aai_signature;
#endif // DBG

	pI->pNextInterface = pNext;
	pI->pAtmEntryList = &DummyAtmArpAtmEntry0;

}

void
init_ATMARP_ADAPTER(ATMARP_ADAPTER *pA, ATMARP_ADAPTER *pNext)
{
#if DBG
	pA->aaa_sig = aaa_signature;
#endif

	pA->pNextAdapter = pNext;
	pA->pInterfaceList = &DummyAtmArpInterface0;
	pA->InterfaceCount = 3;
}

void
init_ATMARP_GLOBALS(ATMARP_GLOBALS *pG)
{
#if DBG
	pG->aag_sig  =  aag_signature;
#endif

	pG->pAdapterList = &DummyAtmArpAdapter;
	pG->AdapterCount = 1;
}

void
init_ATMARP_ATM_ENTRY(ATMARP_ATM_ENTRY *pAE, ATMARP_ATM_ENTRY *pNext)
{
#if DBG
	pAE->aae_sig = aae_signature;
#endif // DBG

	pAE->pNext = pNext;
	pAE->pIpEntryList = &DummyAtmArpIpEntry0;
	pAE->pVcList = &DummyAtmArpVc0;

	pAE->Flags =  AA_ATM_ENTRY_CLOSING;

}

void
init_ATMARP_IP_ENTRY(ATMARP_IP_ENTRY *pIP, ATMARP_IP_ENTRY *pNext)
{
#if DBG
	pIP->aip_sig = aip_signature;
#endif // DBG

	pIP->pNextToAtm = pNext;
	pIP->Flags =   AA_IP_ENTRY_ADDR_TYPE_NUCAST| AA_IP_ENTRY_MC_REVALIDATING;


}

void
init_ATMARP_VC(ATMARP_VC *pVC, ATMARP_VC *pNext)
{
#if DBG
	pVC->avc_sig = avc_signature;
#endif // DBG

	pVC->pNextVc = pNext;

}

#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\registry.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This file contains the code to read the registry.

Author:

    Jameel Hyder (jameelh@microsoft.com)	July 1996

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#define	_FILENUM_		FILENUM_REGISTRY

NTSTATUS
ArpSReadGlobalConfiguration(
	IN	PUNICODE_STRING		RegistryPath
	)
/*++

Routine Description:

	Read the global registry.

Arguments:

	RegistryPath - Pointer to the service section in the registry.

Return Value:

	Error code from registry apis.

--*/
{
	NDIS_STATUS	Status;
	NDIS_HANDLE	ConfigHandle;

	//
	// Open the per-adapter registry config
	//
	NdisOpenProtocolConfiguration(&Status,
								  &ConfigHandle,
								  RegistryPath);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		NDIS_STRING						ArpsBufString = NDIS_STRING_CONST("ArpBuffers");
		NDIS_STRING						FlushString = NDIS_STRING_CONST("FlushTime");
		PNDIS_CONFIGURATION_PARAMETER	Param;

		//
		// Read number of configured buffers
		//
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &ArpsBufString,
							  NdisParameterInteger);
		if ((Status == NDIS_STATUS_SUCCESS) &&
			(Param->ParameterType == NdisParameterInteger))
		{
			ArpSBuffers = Param->ParameterData.IntegerData;
		}

		//
		// Should we save cache in a file ?
		//
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &FlushString,
							  NdisParameterInteger);
		if ((Status == NDIS_STATUS_SUCCESS) &&
			(Param->ParameterType == NdisParameterInteger))
		{
			ArpSFlushTime = (USHORT)(Param->ParameterData.IntegerData * MULTIPLIER);
		}

		NdisCloseConfiguration(ConfigHandle);
	}

	return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
ArpSReadAdapterConfigFromRegistry(
	IN	PINTF				pIntF,
	OUT	PATMARPS_CONFIG		pConfig
	)
/*++

Routine Description:

	Read configuration for the specified interface.

Arguments:

	pIntF		- Interface
	pConfig		- Place to return information read in.

Return Value:

	Error code from registry apis.

--*/
{
	NDIS_STATUS	Status;
	NDIS_HANDLE	ConfigHandle;

	//
	// Open the per-adapter registry config
	//
	NdisOpenProtocolConfiguration(&Status,
								  &ConfigHandle,
								  &pIntF->ConfigString);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		NDIS_STRING						RegdAddrsString = NDIS_STRING_CONST("RegisteredAddresses");
		NDIS_STRING						SelString = NDIS_STRING_CONST("Selector");
		NDIS_STRING						McsString = NDIS_STRING_CONST("MulticastAddresses");
		PNDIS_CONFIGURATION_PARAMETER	Param;
		PWSTR							p;
		UINT							i, Length;

		//
		// Read the value, if present for the selector byte to be used for the registered sap
		// for the std. address (as opposed to added addresses).
		//
		pConfig->SelByte = 0;
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &SelString,
							  NdisParameterInteger);
		if ((Status == NDIS_STATUS_SUCCESS) &&
			(Param->ParameterType == NdisParameterInteger) &&
			(Param->ParameterData.IntegerData <= 0xFF))
		{
			pConfig->SelByte = (UCHAR)(Param->ParameterData.IntegerData);
			DBGPRINT(DBG_LEVEL_INFO,
					("Selector byte for interface %Z is %d\n",
					&pIntF->InterfaceName, pConfig->SelByte));
		}

		//
		// Read registered addresses here. On an interface there can be a set of
		// atm addresses registered. These need to be added and SAPs registered on
		// them.
		//
		pConfig->NumAllocedRegdAddresses = 0;
		pConfig->RegAddresses = NULL;
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &RegdAddrsString,
							  NdisParameterMultiString);
		if ((Status == NDIS_STATUS_SUCCESS) && (Param->ParameterType == NdisParameterMultiString))
		{
			NDIS_STRING	String;

			//
			// Param now contains a list of atm addresses. Convert them into the right format and store
			// it in the intf structure. First determine the number of addresses.
			//
			for (p = Param->ParameterData.StringData.Buffer, i = 0;
				 *p != L'\0';
				 i++)
			{
				RtlInitUnicodeString(&String, p);
				DBGPRINT(DBG_LEVEL_INFO,
						("Configured address for interface %Z - %Z\n",
						&pIntF->InterfaceName, &String));

				p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
			}

			if (i)
			{
				//
				// Allocate space for the addresses
				//
				pConfig->RegAddresses = (PATM_ADDRESS)ALLOC_NP_MEM(sizeof(ATM_ADDRESS) * i, POOL_TAG_ADDR);
				if (pConfig->RegAddresses == NULL)
				{
					LOG_ERROR(NDIS_STATUS_RESOURCES);
				}
				else
				{
					DBGPRINT(DBG_LEVEL_INFO,
					("%d addresses registered for %Z\n", i, &pIntF->InterfaceName));
	
					ZERO_MEM(pConfig->RegAddresses, sizeof(ATM_ADDRESS) * i);
					for (i = 0, p = Param->ParameterData.StringData.Buffer;
 						*p != L'\0';
 						NOTHING)
					{
						RtlInitUnicodeString(&String, p);
						NdisConvertStringToAtmAddress(&Status, &String, &pConfig->RegAddresses[i]);
						if (Status == NDIS_STATUS_SUCCESS)
						{
							i++;
							pConfig->NumAllocedRegdAddresses ++;
						}
						else
						{
							DBGPRINT(DBG_LEVEL_ERROR,
							("ArpSReadAdapterConfiguration: Failed to convert address %Z\n",
									&String));
						}
						p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
					}
				}
			}
		}

		pConfig->pMcsList = NULL;
		NdisReadConfiguration(&Status,
							  &Param,
							  ConfigHandle,
							  &McsString,
							  NdisParameterMultiString);
		if ((Status == NDIS_STATUS_SUCCESS) && (Param->ParameterType == NdisParameterMultiString))
		{
			NDIS_STRING	String;

			//
			// Param now contains a list of Multicast IP Address ranges.
			// Each string is of the form "M.M.M.M-N.N.N.N"
			// Read them in.
			//
			for (p = Param->ParameterData.StringData.Buffer, i = 0;
				 *p != L'\0';
				 i++)
			{
				RtlInitUnicodeString(&String, p);
				DBGPRINT(DBG_LEVEL_INFO,
						("Configured Multicast range for interface %Z - %Z\n",
						&pIntF->InterfaceName, &String));

				p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
			}

			//
			// Allocate space for the addresses
			//
			pConfig->pMcsList = (PMCS_ENTRY)ALLOC_NP_MEM(sizeof(MCS_ENTRY) * i, POOL_TAG_MARS);
			if (pConfig->pMcsList == (PMCS_ENTRY)NULL)
			{
				LOG_ERROR(NDIS_STATUS_RESOURCES);
			}
			else
			{
				DBGPRINT(DBG_LEVEL_INFO,
						("%d Multicast ranges configured on %Z\n", i, &pIntF->InterfaceName));

				ZERO_MEM(pConfig->pMcsList, sizeof(MCS_ENTRY) * i);
				for (i = 0, p = Param->ParameterData.StringData.Buffer;
					 *p != L'\0';
					 NOTHING)
				{
					RtlInitUnicodeString(&String, p);
					ArpSConvertStringToIpPair(&Status, &String, &pConfig->pMcsList[i]);
					if (Status == NDIS_STATUS_SUCCESS)
					{
						if (i > 0)
						{
							pConfig->pMcsList[i-1].Next = &(pConfig->pMcsList[i]);
						}
						i++;
					}
					else
					{
						DBGPRINT(DBG_LEVEL_ERROR,
								("ArpSReadAdapterConfiguration: Failed to convert IP Range %Z\n",
								&String));
					}
					p = (PWSTR)((PUCHAR)p + String.Length + sizeof(WCHAR));
				}
			}
		}


		//
		// Close the configuration handle
		//
		NdisCloseConfiguration(ConfigHandle);

		Status = NDIS_STATUS_SUCCESS;
	}

	return Status;
}



NDIS_STATUS
ArpSReadAdapterConfiguration(
	IN	PINTF				pIntF
	)
/*++

Routine Description:

	Read the registry for parameters for the specified Interface.
	This could be in response to a reconfiguration event, in which
	case handle existing values/structures.

Arguments:

	pIntF - Interface to be read in.

Return Value:

	Error code from registry apis.

--*/
{
	NDIS_STATUS			Status;
	ATMARPS_CONFIG		AtmArpSConfig;
	KIRQL				OldIrql;
	
	ULONG				PrevNumAllocedRegdAddresses;
	PATM_ADDRESS		PrevRegAddresses;
	PMCS_ENTRY			PrevMcsList;

	Status = ArpSReadAdapterConfigFromRegistry(pIntF, &AtmArpSConfig);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		//
		// Copy them into the interface structure. We could be handling a
		// parameter reconfig, so any space used to store old information.
		//

		ACQUIRE_SPIN_LOCK(&pIntF->Lock, &OldIrql);

		//
		// Selector Byte:
		//
		pIntF->SelByte = AtmArpSConfig.SelByte;

		//
		// List of addresses to be registered with the switch.
		// Take out the old list first. We'll have to delete those
		// addresses (deregister them from the switch).
		//
		PrevNumAllocedRegdAddresses = pIntF->NumAllocedRegdAddresses;
		PrevRegAddresses = pIntF->RegAddresses;

		//
		// Get the new list in:
		//
		pIntF->NumAllocedRegdAddresses = AtmArpSConfig.NumAllocedRegdAddresses;
		pIntF->RegAddresses = AtmArpSConfig.RegAddresses;
		pIntF->NumAddressesRegd = 0;	// reset count of addresses regd with switch

		//
		// Take out the old MCS list and insert the new one.
		//
		PrevMcsList = pIntF->pMcsList;
		pIntF->pMcsList = AtmArpSConfig.pMcsList;

		RELEASE_SPIN_LOCK(&pIntF->Lock, OldIrql);

		//
		// Deregister all previously registered addresses with the switch.
		//
		if (PrevNumAllocedRegdAddresses)
		{
			ArpSDeleteIntFAddresses(pIntF, PrevNumAllocedRegdAddresses, PrevRegAddresses);

			//
			// Register the new list of addresses with the switch.
			//
			ArpSQueryAndSetAddresses(pIntF);
		}

		//
		// Free unused memory.
		//
		if (PrevMcsList)
		{
			FREE_MEM(PrevMcsList);
		}

		if (PrevRegAddresses)
		{
			FREE_MEM(PrevRegAddresses);
		}

	}

	return Status;
}


VOID
ArpSConvertStringToIpPair(
	OUT	PNDIS_STATUS			pStatus,
	IN	PNDIS_STRING			pString,
	IN	PMCS_ENTRY				pMcsEntry
	)
/*++

Routine Description:

	Extract a pair of IP addresses that identify a range of multicast addresses
	that this MCS serves, from the given string.

Arguments:

	pStatus		- Place to return status
	pString		- Points to string containing "<IP1>-<IP2>"
	pMcsEntry	- Entry to read into.

Return Value:

	None. *pStatus is set to indicate the status of this call.

--*/
{
	PWSTR			pMin, pMax;
	IPADDR			Min, Max;
	ULONG			Length;
	ULONG			i;

    ARPS_PAGED_CODE();

	Length = pString->Length;

	*pStatus = NDIS_STATUS_FAILURE;

	do
	{
		//
		//  Locate the '-' and replace it with a NULL char.
		//
		pMin = pString->Buffer;
		pMax = pString->Buffer;

		for (i = 0; i < Length; i++, pMax++)
		{
			if (*pMax == L'-')
			{
				*pMax++ = L'\0';
				break;
			}
		}

		if (i == Length)
		{
			break;	// Didn't find '-'
		}

		if (IPConvertStringToAddress(pMin, &Min) &&
			IPConvertStringToAddress(pMax, &Max))
		{
			DBGPRINT(DBG_LEVEL_INFO, ("MCS pair: "));
			ArpSDumpIpAddr(Min, " to ");
			ArpSDumpIpAddr(Max, "\n");

			pMcsEntry->GrpAddrPair.MinAddr = Min;
			pMcsEntry->GrpAddrPair.MaxAddr = Max;
			*pStatus = NDIS_STATUS_SUCCESS;
		}

		break;
	}
	while (FALSE);

}


#define IP_ADDRESS_STRING_LENGTH (16+2)     // +2 for double NULL on MULTI_SZ


BOOLEAN
IPConvertStringToAddress(
    IN PWCHAR AddressString,
	OUT PULONG IpAddress
	)

/*++

Routine Description

    This function converts an Internet standard 4-octet dotted decimal
	IP address string into a numeric IP address. Unlike inet_addr(), this
	routine does not support address strings of less than 4 octets nor does
	it support octal and hexadecimal octets.

	Copied from tcpip\ip\ntip.c

Arguments

    AddressString    - IP address in dotted decimal notation
	IpAddress        - Pointer to a variable to hold the resulting address

Return Value:

	TRUE if the address string was converted. FALSE otherwise.

--*/

{
    UNICODE_STRING  unicodeString;
	STRING          aString;
	UCHAR           dataBuffer[IP_ADDRESS_STRING_LENGTH];
	NTSTATUS        status;
	PUCHAR          addressPtr, cp, startPointer, endPointer;
	ULONG           digit, multiplier;
	int             i;


    ARPS_PAGED_CODE();

    aString.Length = 0;
	aString.MaximumLength = IP_ADDRESS_STRING_LENGTH;
	aString.Buffer = dataBuffer;

	RtlInitUnicodeString(&unicodeString, AddressString);

	status = RtlUnicodeStringToAnsiString(
	             &aString,
				 &unicodeString,
				 FALSE
				 );

    if (!NT_SUCCESS(status)) {
	    return(FALSE);
	}

    *IpAddress = 0;
	addressPtr = (PUCHAR) IpAddress;
	startPointer = dataBuffer;
	endPointer = dataBuffer;
	i = 3;

    while (i >= 0) {
        //
		// Collect the characters up to a '.' or the end of the string.
		//
		while ((*endPointer != '.') && (*endPointer != '\0')) {
			endPointer++;
		}

		if (startPointer == endPointer) {
			return(FALSE);
		}

		//
		// Convert the number.
		//

        for ( cp = (endPointer - 1), multiplier = 1, digit = 0;
			  cp >= startPointer;
			  cp--, multiplier *= 10
			) {

			if ((*cp < '0') || (*cp > '9') || (multiplier > 100)) {
				return(FALSE);
			}

			digit += (multiplier * ((ULONG) (*cp - '0')));
		}

		if (digit > 255) {
			return(FALSE);
		}

        addressPtr[i] = (UCHAR) digit;

		//
		// We are finished if we have found and converted 4 octets and have
		// no other characters left in the string.
		//
	    if ( (i-- == 0) &&
			 ((*endPointer == '\0') || (*endPointer == ' '))
		   ) {
			return(TRUE);
		}

        if (*endPointer == '\0') {
			return(FALSE);
		}

		startPointer = ++endPointer;
	}

	return(FALSE);
}

	


VOID
ArpSReadArpCache(
	IN	PINTF					pIntF
	)
/*++

Routine Description:

	Read the per-adapter Arp Cache. TBD.

Arguments:

	pIntF - Per adapter arp cache.

Return Value:

	None

--*/
{
	HANDLE				FileHandle;
	OBJECT_ATTRIBUTES	ObjectAttributes;
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			Status;
	LARGE_INTEGER		Offset;
	ULONG				Space, NumEntries;
	PDISK_HEADER		DskHdr;
	PUCHAR				Buffer;
    PDISK_ENTRY			pDskEntry;
	PARP_ENTRY			ArpEntry;

	Buffer = ALLOC_PG_MEM(DISK_BUFFER_SIZE);
	if (Buffer == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
		return;
	}

	InitializeObjectAttributes(&ObjectAttributes,
							   &pIntF->FileName,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);

	Status = ZwCreateFile(&FileHandle,
						  SYNCHRONIZE | FILE_READ_DATA,
						  &ObjectAttributes,
						  &IoStatus,
						  NULL,
						  0,
						  0,
						  FILE_OPEN,
						  FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY,
						  NULL,
						  0);

	if (Status == STATUS_SUCCESS)
	{
		do
		{
			//
			// First read the disk header and validate it
			//
			Offset.QuadPart = 0;
			Status = ZwReadFile(FileHandle,
								NULL,
								NULL,
								NULL,
								&IoStatus,
								Buffer,
								DISK_BUFFER_SIZE,
								&Offset,
								NULL);
			if (Status != STATUS_SUCCESS)
			{
				LOG_ERROR(Status);
				break;
			}

			DskHdr = (PDISK_HEADER)Buffer;
			if ((IoStatus.Information < sizeof(DISK_HEADER)) ||
				(DskHdr->Signature != DISK_HDR_SIGNATURE) ||
				(DskHdr->Version != DISK_HDR_VERSION))
			{
				LOG_ERROR(STATUS_INVALID_LEVEL);
				break;
			}
	
			NumEntries = DskHdr->NumberOfArpEntries;
			Space = (ULONG) IoStatus.Information - sizeof(DISK_HEADER);
            pDskEntry = (PDISK_ENTRY)(Buffer + sizeof(DISK_HEADER));
			Offset.QuadPart = sizeof(DISK_HEADER);
			while (NumEntries > 0)
			{
				UINT	Consumed;

				if ((Space < sizeof(DISK_ENTRY)) ||
					(Space < (sizeof(DISK_ENTRY) + pDskEntry->AtmAddr.SubAddrLen)))
				{
					Status = ZwReadFile(FileHandle,
										NULL,
										NULL,
										NULL,
										&IoStatus,
										Buffer,
										DISK_BUFFER_SIZE,
										&Offset,
										NULL);
					if (Status != STATUS_SUCCESS)
					{
						LOG_ERROR(Status);
						break;
					}

					pDskEntry = (PDISK_ENTRY)Buffer;
					if ((IoStatus.Information < sizeof(DISK_ENTRY)) ||
						(IoStatus.Information < (sizeof(DISK_ENTRY) + pDskEntry->AtmAddr.SubAddrLen)))
					{
						LOG_ERROR(STATUS_INVALID_LEVEL);
						break;
					}
					Space = (ULONG) IoStatus.Information - sizeof(DISK_HEADER);
				}

				ArpEntry = ArpSAddArpEntryFromDisk(pIntF, pDskEntry);
				ASSERT (ArpEntry != NULL);

				Consumed = (sizeof(DISK_ENTRY) + SIZE_4N(pDskEntry->AtmAddr.SubAddrLen));
				(PUCHAR)pDskEntry += Consumed;
				Offset.QuadPart += Consumed;
				Space -= Consumed;
				NumEntries --;
			}
		} while (FALSE);

		ZwClose(FileHandle);
	}

	FREE_MEM(Buffer);
}


BOOLEAN
ArpSWriteArpCache(
	IN	PINTF					pIntF,
	IN	PTIMER					Timer,
	IN	BOOLEAN					TimerShuttingDown
	)
/*++

Routine Description:

	Write the per-adapter Arp Cache. TBD.

Arguments:

	pIntF - Per adapter arp cache.
	Timer -	FlushTimer
	TimerShuttingDown - Do not requeue when set.

Return Value:

	TRUE to requeue unless TimerShuttingDown is set

--*/
{
	HANDLE				FileHandle;
	OBJECT_ATTRIBUTES	ObjectAttributes;
	IO_STATUS_BLOCK		IoStatus;
	NTSTATUS			Status;
	LARGE_INTEGER		Offset;
	ULONG				Space, i;
	PDISK_HEADER		DskHdr;
	PUCHAR				Buffer;
    PDISK_ENTRY			pDskEntry;
	PARP_ENTRY			ArpEntry;
	TIME				SystemTime, LocalTime;
	ULONG				CurrentTime;

	Buffer = ALLOC_PG_MEM(DISK_BUFFER_SIZE);
	if (Buffer == NULL)
	{
		LOG_ERROR(NDIS_STATUS_RESOURCES);
		return (!TimerShuttingDown);
	}

	KeQuerySystemTime(&SystemTime);

	ExSystemTimeToLocalTime(&SystemTime, &LocalTime);

	// Convert this to number of seconds since 1980
	if (!RtlTimeToSecondsSince1980(&LocalTime, &CurrentTime))
	{
		// Could not convert! Bail out.
		LOG_ERROR(NDIS_STATUS_BUFFER_OVERFLOW);
		FREE_MEM(Buffer);
		return (!TimerShuttingDown);
	}

	InitializeObjectAttributes(&ObjectAttributes,
							   &pIntF->FileName,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);

	Status = ZwCreateFile(&FileHandle,
						  SYNCHRONIZE | FILE_WRITE_DATA,
						  &ObjectAttributes,
						  &IoStatus,
						  NULL,
						  0,
						  0,
						  FILE_OVERWRITE_IF,
						  FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY,
						  NULL,
						  0);
	if (Status == STATUS_SUCCESS)
	{
		do
		{
			Offset.QuadPart = 0;
			Space = DISK_BUFFER_SIZE - sizeof(DISK_HEADER);
			DskHdr = (PDISK_HEADER)Buffer;
			pDskEntry = (PDISK_ENTRY)(Buffer + sizeof(DISK_HEADER));
			DskHdr->Signature = DISK_HDR_SIGNATURE;
			DskHdr->Version = DISK_HDR_VERSION;
			DskHdr->NumberOfArpEntries = pIntF->NumCacheEntries;
			DskHdr->TimeStamp = CurrentTime;

			for (i =0; i < ARP_TABLE_SIZE; i++)
			{
				for (ArpEntry = pIntF->ArpCache[i];
					 ArpEntry != NULL;
					 ArpEntry = ArpEntry->Next)
				{
					UINT	Size;

					Size = sizeof(DISK_ENTRY) + ((ArpEntry->HwAddr.SubAddress != NULL) ?
														SIZE_4N(ArpEntry->HwAddr.SubAddress->NumberOfDigits) : 0);
					if (Space < Size)
					{
						Status = ZwWriteFile(FileHandle,
											 NULL,
											 NULL,
											 NULL,
											 &IoStatus,
											 Buffer,
											 DISK_BUFFER_SIZE - Space,
											 &Offset,
											 NULL);
						if (Status != STATUS_SUCCESS)
						{
							LOG_ERROR(Status);
							break;
						}

						Space = DISK_BUFFER_SIZE;
						pDskEntry = (PDISK_ENTRY)Buffer;
						Offset.QuadPart += (DISK_BUFFER_SIZE - Space);
					}

					pDskEntry->IpAddr = ArpEntry->IpAddr;
					pDskEntry->AtmAddr.AddrType = (UCHAR)ArpEntry->HwAddr.Address.AddressType;
					pDskEntry->AtmAddr.AddrLen = (UCHAR)ArpEntry->HwAddr.Address.NumberOfDigits;
					COPY_MEM(pDskEntry->AtmAddr.Address,
							 ArpEntry->HwAddr.Address.Address,
							 pDskEntry->AtmAddr.AddrLen);

					pDskEntry->AtmAddr.SubAddrLen = 0;
					if (ArpEntry->HwAddr.SubAddress != NULL)
					{
						pDskEntry->AtmAddr.SubAddrLen = (UCHAR)ArpEntry->HwAddr.SubAddress->NumberOfDigits;
						pDskEntry->AtmAddr.SubAddrType = (UCHAR)ArpEntry->HwAddr.SubAddress->AddressType;
						COPY_MEM((PUCHAR)pDskEntry + sizeof(DISK_ENTRY),
								 ArpEntry->HwAddr.SubAddress->Address,
								 pDskEntry->AtmAddr.SubAddrLen);
					}

					Space -= Size;
					(PUCHAR)pDskEntry += Size;
				}

				if (Status != STATUS_SUCCESS)
				{
					break;
				}
			}
		} while (FALSE);

		if ((Status == STATUS_SUCCESS) && (Space < DISK_BUFFER_SIZE))
		{
			Status = ZwWriteFile(FileHandle,
								 NULL,
								 NULL,
								 NULL,
								 &IoStatus,
								 Buffer,
								 DISK_BUFFER_SIZE - Space,
								 &Offset,
								 NULL);
		}

		ZwClose(FileHandle);
	}

	FREE_MEM(Buffer);

   	return (!TimerShuttingDown);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\componentdef\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\main.c ===
#include "precomp.h"

#ifdef TESTPROGRAM

WINDBG_EXTENSION_APIS ExtensionApis;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    );
//
// dprintf          (ExtensionApis.lpOutputRoutine)
// GetExpression    (ExtensionApis.lpGetExpressionRoutine)
// GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
// Disassm          (ExtensionApis.lpDisasmRoutine)
// CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
// ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
// WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
// GetContext       (ExtensionApis.lpGetThreadContextRoutine)
// SetContext       (ExtensionApis.lpSetThreadContextRoutine)
// Ioctl            (ExtensionApis.lpIoctlRoutine)
// StackTrace       (ExtensionApis.lpStackTraceRoutine)
//

#if 0
//
// Dummy global vars for "GetExpression".
//
UINT g1;
UINT g2;
#endif // 0

ULONG
DummyMyGetExpression (
    PCSTR lpExpression
    );
void setup_dummy_vars(void);

ULONG
WDBGAPI
MyGetExpression (
    PCSTR lpExpression
    )
{
	return DummyMyGetExpression(lpExpression);
}


ULONG
WDBGAPI
MyReadMemory (
    ULONG  offset,
    PVOID  lpBuffer,
    ULONG  cb,
    PULONG lpcbBytesRead
    )
{
    BOOL fRet = FALSE;

    _try
    {

        CopyMemory(lpBuffer, (void*)offset, cb);
        *lpcbBytesRead = cb;
        fRet = TRUE;
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
    	MyDbgPrintf("Read memory exception at 0x%lu[%lu]\n", offset, cb);
        fRet = FALSE;
    }

    return fRet;
}

ULONG
WDBGAPI
MyWriteMemory(
    ULONG   offset,
    LPCVOID lpBuffer,
    ULONG   cb,
    PULONG  lpcbBytesWritten
    )
{
    BOOL fRet = FALSE;

    _try
    {

        CopyMemory((void*)offset, lpBuffer, cb);
        *lpcbBytesWritten = cb;
        fRet = TRUE;
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
    }

    return fRet;
}

void test_walklist(void);

int __cdecl main(
	int argc,
	char *argv[]
	)
{
    UINT u=0;

    ExtensionApis.lpOutputRoutine = printf;
    ExtensionApis.lpGetExpressionRoutine = MyGetExpression;
    ExtensionApis.lpReadProcessMemoryRoutine = MyReadMemory;
    ExtensionApis.lpWriteProcessMemoryRoutine = MyWriteMemory;

    WinDbgExtensionDllInit(
        &ExtensionApis,
        0xc, // MajorVersion,
        0x0 // MinorVersion
        );

	//
	// This sets up some dummy global variables.
	//
	setup_dummy_vars();
#if 0

	test_walklist();

#else // 0

    do
    {
        char rgch[256];

        printf("> ");
        u = scanf("%[^\n]", rgch);
        if (!u || u==EOF) break;

        // printf("Input = [%s]\n", rgch);

        if (*rgch == 'q') break;

        do_aac(rgch);

      // skip past EOL
      {
          char c;
          u = scanf("%c", &c);
      }

    } while (u!=EOF);

#endif // 0

  return 0;
}

typedef struct _LIST
{
	struct _LIST *pNext;
	UINT  uKey;
} LIST;

LIST L3 = {NULL, 0x4000};
LIST L2 = {&L3,  0x3000};
LIST L1 = {&L2,  0X2000};
LIST L0 = {&L1,  0X1000};

ULONG
NodeFunc_DumpLIST (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	LIST L;
	BOOL fRet = dbgextReadMemory(
					uNodeAddr,
					&L,
					sizeof(L),
					"LIST"
					);
	if (fRet)
	{
		MyDbgPrintf(
			"LIST[%lu]@0x%08lx = {Next=0x%08lx, Key=0x%lx}\n",
			uIndex,
			uNodeAddr,
			L.pNext,
			L.uKey
			);
	}
	return 0;
}

void test_walklist(void)
{
	UINT uRet = 0;

	uRet =  WalkList(
				(UINT_PTR) &L0,
				0,
				0, // 0 start
				-1,// -1 end
				NULL,
				//NodeFunc_DumpAddress,
				NodeFunc_DumpLIST,
				"Test list"
				);

}

ULONG
DummyMyGetExpression (
    PCSTR lpExpression
    )
{
	extern void *pvDummyAtmArpGlobalInfo;
	extern void *pvDummyAtmArpProtocolCharacteristics;
	extern void *pvDummyAtmArpClientCharacteristics;


    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpGlobalInfo"))
    {
        return (ULONG) pvDummyAtmArpGlobalInfo;
    }

    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpProtocolCharacteristics"))
    {
        return (ULONG) pvDummyAtmArpProtocolCharacteristics;
    }

    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpClientCharacteristics"))
    {
        return (ULONG) pvDummyAtmArpClientCharacteristics;
    }

    return 0;

}
#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\parse.c ===
#include "precomp.h"

typedef struct
{
    eKEYWORD eKey;
    char *szzAliases;   // Multi-sz string of aliases.
                        // First one is the "official" name.
} KEYWORDREC;

KEYWORDREC rgKeywords[] =
{
    {keywordHELP,           "help\0"},
    {keywordDUMP_TYPE,      "dt\0"},
    {keywordDUMP_GLOBALS,   "dg\0"},
    {keywordL,              "L\0"},
    {keywordNULL,           NULL}      // sentinel, must be last.
};


//
// Contains the list of tokens created by parsing an input string.
//
typedef struct
{
    TOKEN *rgToks;
    UINT cToks;
    UINT uNextFreeTok;
    UINT uCurrentTok;

    char *rgStringBuf;
    UINT cchStringBuf;
    UINT uNextFree;
    BOOL fFinalized;
    CRITICAL_SECTION crit;

} TOKLIST;


DBGCOMMAND *
parse_command(TOKLIST *pTL, NAMESPACE *pNameSpace);

TOKLIST
*toklist_create(void);

void
toklist_destroy(TOKLIST *pTL);

BOOL
toklist_add(TOKLIST *pTL, eTOKTYPE eTok, char *szOrig, UINT uID);

BOOL
toklist_finalize(TOKLIST *pTL);


TOKEN *
toklist_get_next(TOKLIST *pTL);

BOOL
toklist_restart(TOKLIST *pTL);

void
toklist_dump(TOKLIST *pTL);

void
tok_dump(TOKEN *pTok);


UINT
toklist_tokenize(TOKLIST *pTL, char *szInput);

UINT
toklist_parse_keyword(
      TOKLIST *pTL,
      KEYWORDREC rgKeywords[],
      char *pcInput
      );

UINT
toklist_parse_hexnum(
      TOKLIST *pTL,
      char *pcInput
      );

UINT
toklist_parse_identifier(
      TOKLIST *pTL,
      char *pcInput
      );

BOOL
cmd_parse_help(
    DBGCOMMAND *pCmd,
    TOKLIST *pTL
    );

BOOL
tok_try_force_to_ident(TOKLIST *pTL, BOOL fPrefixStar, TOKEN *pTok);

void
MyDumpObject (
    DBGCOMMAND *pCmd,
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    UINT     cbSize,
    const char *szDescription
    );


ULONG
NodeFunc_DumpType (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);

ULONG
NodeFunc_UpdateCache (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);


DBGCOMMAND *
Parse(
    IN  const char *szInput,
    IN	NAMESPACE *pNameSpace
)
{
    TOKLIST *pTL = NULL;
    BOOL fRet = FALSE;
    DBGCOMMAND *pCmd = NULL;
    UINT cbInput =  (lstrlenA(szInput)+1)*sizeof(*szInput);
    char *szRWInput
        = LocalAlloc(LPTR, cbInput);

    // MyDbgPrintf("Parse(\"%s\");\n", szInput);

    if (szRWInput)
    {
        CopyMemory(szRWInput, szInput, cbInput);
        pTL =  toklist_create();
    }

    if (pTL)
    {

#if TEST_TOKLIST_ADD
    #if 0
        fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
        fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
        fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
        fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
        fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
        fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
        fRet = toklist_add(pTL, tokKEYWORD,     "help",     keywordHELP);
        fRet = toklist_add(pTL, tokNUMBER,      "0x1234",   0x1234);
        fRet = toklist_add(pTL, tokIDENTIFIER,  "cow",      0);
        fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
        fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
        fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
        fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
        fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
        fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
        fRet = toklist_add(pTL, tokKEYWORD,     "help",     keywordHELP);
        fRet = toklist_add(pTL, tokNUMBER,      "0x1234",   0x1234);
        fRet = toklist_add(pTL, tokIDENTIFIER,  "cow",      0);
    #else
        char rgInput[] =
                 // "*.?[]/"
                 // "help "
                 // "0x12340 0 1 02 "
                 // "kelp"
                "dt if[*].*handle* 0x324890 L 5"
                ;
        toklist_tokenize (pTL, rgInput);
    #endif

#endif // TEST_TOKLIST_ADD

        toklist_tokenize(pTL, szRWInput);

        toklist_finalize(pTL);

        // toklist_dump(pTL);

        pCmd = parse_command(pTL, pNameSpace);

        if (!pCmd)
        {
            toklist_destroy(pTL);
        }
        pTL = NULL;
    }

    if (szRWInput)
    {
        LocalFree(szRWInput);
        szRWInput = NULL;
    }

    return pCmd;

}

void
FreeCommand(
    DBGCOMMAND *pCmd
)
{
    if (pCmd)
    {
        TOKLIST *pTL =  (TOKLIST*)pCmd->pvContext;
        if (pTL)
        {
            // MyDbgPrintf("FreeCommand:\n");
            // toklist_restart(pTL);
            // toklist_dump(pTL);
            toklist_destroy((TOKLIST*)pCmd->pvContext);
        }

        ZeroMemory(pCmd, sizeof(*pCmd));
        LocalFree(pCmd);
    }
}

void
DumpCommand(
    DBGCOMMAND *pCmd
)
{
    char *szCmd = "";
    char *szObjPreStar = "";
    char *szObj = "";
    char *szObjSufStar = "";
    char *szObjVecRange = "";
    char *szDot = "";
    char *szSubObjPreStar = "";
    char *szSubObj = "";
    char *szSubObjSufStar = "";
    char *szObjAddr  = "";
    char *szObjCount = "";
    char rgVecRange[64];
    char rgObjAddr[64];
    char rgObjCount[64];


    if (!pCmd) goto end;

    switch(pCmd->ePrimaryCmd)
    {
    case cmdDUMP_TYPE:       szCmd = "dt"; break;
    case cmdDUMP_GLOBALS:    szCmd = "dg"; break;
    case cmdHELP:            szCmd = "help"; break;
    default:            szCmd = "<unknown>"; break;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
    {
        szObjPreStar = "*";
    }
    if (pCmd->ptokObject)
    {
        szObj = pCmd->ptokObject->szStr;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
    {
        szObjSufStar = "*";
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_VECTOR_INDEX))
    {
        wsprintfA(
            rgVecRange,
            "[%ld,%ld]",
            pCmd->uVectorIndexStart,
            pCmd->uVectorIndexEnd
            );

        szObjVecRange = rgVecRange;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_SUBOBJECT))
    {
        szDot = ".";
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX))
    {
        szSubObjPreStar = "*";
    }

    if (pCmd->ptokSubObject)
    {
        szSubObj = pCmd->ptokSubObject->szStr;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
    {
        szSubObjSufStar = "*";
    }

    if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_ADDRESS))
    {
        wsprintf(rgObjAddr, "0x%lx", pCmd->uObjectAddress);
        szObjAddr = rgObjAddr;
    }

    if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_COUNT))
    {
        wsprintf(rgObjCount, " L 0x%lx", pCmd->uObjectCount);
        szObjCount = rgObjCount;
    }

    {
    #if 0
        MyDbgPrintf(
            "\nCOMMAND = {"
            "cmd=%lu;"
            "F=0x%lx;"
            "O=0x%lx;"
            "SO=0x%lx;"
            "VS=%ld;"
            "VE=%ld;"
            "OA=0x%lx;"
            "OC=%ld;"
            "}\n",
            pCmd->ePrimaryCmd,
            pCmd->uFlags,
            pCmd->ptokObject,
            pCmd->ptokSubObject,
            pCmd->uVectorIndexStart,
            pCmd->uVectorIndexEnd,
            pCmd->uObjectAddress,
            pCmd->uObjectCount
            );
    #else
        MyDbgPrintf(
            "COMMAND = \"%s %s%s%s%s%s%s%s%s%s%s\";\n",
            szCmd,
            szObjPreStar,
            szObj,
            szObjSufStar,
            szObjVecRange,
            szDot,
            szSubObjPreStar,
            szSubObj,
            szSubObjSufStar,
            szObjAddr,
            szObjCount
        );
    #endif
    }
end:
    return;
}


#define TL_LOCK(_ptl)   EnterCriticalSection(&(_ptl)->crit)
#define TL_UNLOCK(_ptl) LeaveCriticalSection(&(_ptl)->crit)


TOKLIST
*toklist_create(void)
{
    TOKLIST *pTL = LocalAlloc(LPTR, sizeof(TOKLIST));

    if (pTL)
    {
        InitializeCriticalSection(&pTL->crit);
    }

    return pTL;
}


void
toklist_destroy(TOKLIST *pTL)
{
    if (pTL)
    {
        TL_LOCK(pTL);

        if (pTL->rgToks)
        {
            LocalFree(pTL->rgToks);
        }

        if (pTL->rgStringBuf)
        {
            LocalFree(pTL->rgStringBuf);
        }

        DeleteCriticalSection(&pTL->crit);

        ZeroMemory(pTL, sizeof(*pTL));
        LocalFree(pTL);
    }
}


BOOL
toklist_add(TOKLIST *pTL, eTOKTYPE eTok, char *szOrig, UINT uID)
{
    BOOL fRet = FALSE;
    TOKEN *pTok = NULL;
    UINT cch  = 0;
    char *pc  = NULL;

    TL_LOCK(pTL);

    if (pTL->fFinalized) goto end;

    //
    // Make sure we've enough space for the token.
    //
    if (pTL->uNextFreeTok >= pTL->cToks)
    {
        UINT cNewToks = 2*pTL->cToks+1;
        TOKEN *pNewToks = (TOKEN*) LocalAlloc(LPTR, cNewToks*sizeof(*pNewToks));
        if (!pNewToks) goto end;

        if (pTL->rgToks)
        {
            CopyMemory(
                pNewToks,
                pTL->rgToks,
                pTL->uNextFreeTok*sizeof(*pNewToks)
                );

            LocalFree(pTL->rgToks);
        }

        pTL->rgToks = pNewToks;
        pTL->cToks = cNewToks;
    }

    //
    // Now deal with szOrig
    //

    cch = lstrlenA(szOrig)+1;

    if ((pTL->uNextFree+cch+1) > pTL->cchStringBuf) // "+1" because multisz
    {
        UINT cNewStr = 2*pTL->cchStringBuf+cch+1;
        char *pNewStr = LocalAlloc(LPTR, cNewStr*sizeof(*pNewStr));
        if (!pNewStr) goto end;

        if (pTL->rgStringBuf)
        {
            CopyMemory(
                pNewStr,
                pTL->rgStringBuf,
                pTL->uNextFree*sizeof(*pNewStr)
                );
            LocalFree(pTL->rgStringBuf);

            //
            // Since we've reallocated the string buffer, we must
            // now fixup the string pointers in the list of tokens
            //
            {
                TOKEN *pTok = pTL->rgToks;
                TOKEN *pTokEnd = pTok + pTL->uNextFreeTok;
                for(; pTok<pTokEnd; pTok++)
                {
                    pTok->szStr = pNewStr + (pTok->szStr - pTL->rgStringBuf);
                }
            }
        }

        pTL->rgStringBuf = pNewStr;
        pTL->cchStringBuf = cNewStr;
    }

    //
    // At this point we know we have enough space...
    //

    //
    // See if we already have this string and if not copy it...
    //
    {
        BOOL fFound = FALSE;
        for (pc = pTL->rgStringBuf; *pc; pc+=(lstrlenA(pc)+1))
        {
            if (!lstrcmpiA(pc, szOrig))
            {
                // found it
                fFound = TRUE;
                break;
            }
        }


        if (!fFound)
        {
            MYASSERT(pTL->uNextFree == (UINT) (pc-pTL->rgStringBuf));

            CopyMemory(
                pc,
                szOrig,
                cch*sizeof(*szOrig)
                );
            pTL->uNextFree += cch;
        }
    }

    if (eTok == tokIDENTIFIER)
    {
        //
        // For this special case we ignore the passed-in uID and
        // use instead the offset of the string in our string table.
        //
        uID =  (UINT) (pc - pTL->rgStringBuf);
    }

    pTok = pTL->rgToks+pTL->uNextFreeTok++;
    pTok->eTok = eTok;
    pTok->uID = uID;
    pTok->szStr = pc;
    fRet = TRUE;

end:

    TL_UNLOCK(pTL);
    return fRet;
}


BOOL
toklist_finalize(TOKLIST *pTL)
{
    BOOL fRet = FALSE;

    TL_LOCK(pTL);

    if (pTL->fFinalized) goto end;

    pTL->fFinalized = TRUE;
    fRet = TRUE;

end:

    TL_UNLOCK(pTL);
    return fRet;
}

BOOL
toklist_restart(TOKLIST *pTL)
{
    BOOL fRet = FALSE;

    TL_LOCK(pTL);

    if (!pTL->fFinalized) goto end;
    pTL->uCurrentTok = 0;
    fRet = TRUE;

end:

    TL_UNLOCK(pTL);
    return fRet;
}


TOKEN *
toklist_get_next(TOKLIST *pTL)
{
    TOKEN *pTok = NULL;

    TL_LOCK(pTL);

    if (!pTL->fFinalized) goto end;

    if (pTL->uCurrentTok >= pTL->uNextFreeTok)
    {
        MYASSERT(pTL->uCurrentTok == pTL->uNextFreeTok);
        goto end;
    }
    else
    {
        pTok = pTL->rgToks+pTL->uCurrentTok++;
    }

end:
    TL_UNLOCK(pTL);


    return pTok;
}

void
toklist_dump(TOKLIST *pTL)
{
    TL_LOCK(pTL);

    MyDbgPrintf(
            "\nTOKLIST 0x%08lx = {"
            "fFin=%lu cToks=%lu  uNextFreeTok=%lu cchStr=%lu uNextFree=%lu"
            "}\n",
            pTL,
            pTL->fFinalized,
            pTL->cToks,
            pTL->uNextFreeTok,
            pTL->cchStringBuf,
            pTL->uNextFree
        );

    if (pTL->fFinalized)
    {
        TOKEN *pTok =  toklist_get_next(pTL);
        while(pTok)
        {
            tok_dump(pTok);

            pTok =  toklist_get_next(pTL);
        }
        toklist_restart(pTL);
    }

    TL_UNLOCK(pTL);
}


void
tok_dump(TOKEN *pTok)
{
    MyDbgPrintf(
            "\tTOKEN 0x%08lx = {eTok=%lu uID=0x%08lx sz=\"%s\"}\n",
            pTok,
            pTok->eTok,
            pTok->uID,
            pTok->szStr
        );

}


UINT
toklist_tokenize(TOKLIST *pTL, char *szInput)
{
    UINT cTokens = 0;
    char *pc = szInput;
    char c = 0;
    BOOL fRet = FALSE;

    for (; (c=*pc)!=0; pc++)
    {
        switch(c)
        {

        case '*':
            fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
            continue;

        case '.':
            fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
            continue;

        case '?':
            fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
            continue;

        case '[':
            fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
            continue;

        case ']':
            fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
            continue;

        case '/':
            fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
            continue;

        case '\n':
        case '\r':
        case '\t':
        case ' ':
            continue;

        default:

            {
                UINT uCharsParsed =  0;
                char *pcEnd = pc;
                char cSave = 0;

                //
                // We'll locate the end of the potential keyword/number/ident:
                // and temprarily place a NULL char there.
                //
                //
                while (__iscsym(*pcEnd))
                {
                    pcEnd++;
                }

                cSave = *pcEnd;
                *pcEnd = 0;

                if (__iscsymf(c))
                {
                    // This may be a keyword, hex number or identifier. We try
                    // in this order
                    uCharsParsed =  toklist_parse_keyword(
                                                pTL,
                                                rgKeywords,
                                                pc
                                                );

                    if (!uCharsParsed && isxdigit(c))
                    {
                        //
                        // Didn't find a keyword and this is a hex digit --
                        // let's try to parse it as a hex number...
                        //
                        uCharsParsed =  toklist_parse_hexnum(pTL, pc);
                    }

                    if (!uCharsParsed)
                    {
                        //
                        // Parse it as an identifier...
                        //
                        uCharsParsed =  toklist_parse_identifier(pTL, pc);
                    }

                    if (!uCharsParsed)
                    {
                        //
                        // This is an error
                        //
                        MyDbgPrintf("Error at %s\n", pc);
                        goto end;
                    }
                }
                else if (isxdigit(c))
                {
                   uCharsParsed =  toklist_parse_hexnum(pTL, pc);
                }

                //
                // If we've parsed anything it should be ALL of the string...
                //
                MYASSERT(!uCharsParsed || uCharsParsed==(UINT)lstrlenA(pc));

                //
                // Restore the char we replaced by NULL.
                //
                *pcEnd = cSave;

                if (!uCharsParsed)
                {
                    //
                    // Syntax error
                    //
                    MyDbgPrintf("Error at %s\n", pc);
                    goto end;
                }
                else
                {
                    pc+= (uCharsParsed-1); // "-1" because of pc++ in
                                            // for clause above.
                }
            }
        }
    }

end:

return cTokens;

}

UINT
toklist_parse_keyword(
      TOKLIST *pTL,
      KEYWORDREC rgKeywords[],
      char *pcInput
      )
//
// Assumes 1st char is valid.
//
{
    UINT uRet = 0;
    KEYWORDREC *pkr = rgKeywords;

    if (!__iscsymf(*pcInput)) goto end;

    for (;pkr->eKey!=keywordNULL; pkr++)
    {
        if (!lstrcmpi(pcInput, pkr->szzAliases))
        {
            //
            // found it
            //
            toklist_add(pTL, tokKEYWORD,  pcInput,  pkr->eKey);
            uRet = lstrlenA(pcInput);
            break;
        }
    }

end:

    return uRet;
}

UINT
toklist_parse_hexnum(
      TOKLIST *pTL,
      char *pcInput
      )
{
    char *pc = pcInput;
    UINT uValue = 0;
    char c;
    UINT u;

    //
    //  look for and ignore the "0x" prefix...
    //
    if (pc[0]=='0' && (pc[1]=='x' || pc[1]=='X'))
    {
        pc+=2;
    }


    //
    // Reject number if it is doesn't contain hex digits or is too large
    //
    for (u=0; isxdigit(*pc) && u<8; pc++,u++)
    {
        UINT uDigit = 0;

        char c = *pc;
        if (!isdigit(c))
        {
            c = (char) _toupper(c);
            uDigit = 10 + c - 'A';
        }
        else
        {
            uDigit = c - '0';
        }

        uValue = (uValue<<4)|uDigit;
    }

    if (!u || *pc)
    {
        return 0;
    }
    else
    {
        toklist_add(pTL, tokNUMBER, pcInput, uValue);
        return pc - pcInput;
    }
}

UINT
toklist_parse_identifier(
      TOKLIST *pTL,
      char *pcInput
      )
{
    UINT uRet = 0;

    if (!__iscsymf(*pcInput)) goto end;

    toklist_add(pTL, tokIDENTIFIER,  pcInput,  0);
    uRet = lstrlenA(pcInput);

end:

    return uRet;
}

DBGCOMMAND *
parse_command(TOKLIST *pTL, NAMESPACE *pNameSpace)
{
    BOOL fRet = FALSE;
    DBGCOMMAND *pCmd = LocalAlloc(LPTR, sizeof(*pCmd));
    TOKEN *pTok =  NULL;
    BOOL fSyntaxError = FALSE;

    if (!pCmd) goto end;

    toklist_restart(pTL);
    pTok =  toklist_get_next(pTL);

    if (!pTok) goto end;

	pCmd->pNameSpace = pNameSpace;
    //
    // Now let's step through the token list, building up our command
    // information.
    //

    // look for help or ?
    if (pTok->eTok == tokQUESTION
       || (pTok->eTok == tokKEYWORD && pTok->uID == keywordHELP))
    {
        pCmd->ePrimaryCmd = cmdHELP;
        fRet = cmd_parse_help(pCmd, pTL);
        goto end;
    }

    fSyntaxError = TRUE;
    fRet = FALSE;

	//
	// Here we would look for other keywords. Currently there are none
	// (dt and dg are not used anymore).
	//
	//
	#if OBSOLETE
    if (pTok->eTok == tokKEYWORD)
    {
           BOOL fDump = FALSE;
		if (pTok->uID == keywordDUMP_TYPE)
        {
            pCmd->ePrimaryCmd = cmdDUMP_TYPE;
            fDump = TRUE;
        }
        else if (pTok->uID == keywordDUMP_GLOBALS)
        {
            pCmd->ePrimaryCmd = cmdDUMP_GLOBALS;
            fDump = TRUE;
        }
        ...
	}
	#endif // OBSOLETE

	pCmd->ePrimaryCmd = cmdDUMP_TYPE;

	//
	// Pares the form a[b].*c* d L e
	//
	{

		BOOL   fPrefixStar = FALSE;
		// we look for patterns like...
		//!aac <type> . <field> <address> L <count> <flags>
		//!aac <type> [index] . <field>   L <count> <flags>
		//
		//!aac i[*].*handle* 0x324890 L 5
		//[*]ident[*]\[<range>\][.][*]ident[*] <number> [L <number>]

		UINT uFlags;            // One or more fCMDFLAG_*
		TOKEN *ptokObject;     // eg <type>
		TOKEN *ptokSubObject;  // eg <field>
		UINT uVectorIndexStart; // if[0]
		UINT uVectorIndexEnd; // if[0]
		UINT uObjectAddress; // <address>
		UINT uObjectCount; // L 10
	
		//
		// 1. Look for primary star
		//
		if (pTok && pTok->eTok == tokSTAR)
		{
			fPrefixStar = TRUE;
			CMD_SET_FLAG(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX);
			pTok = toklist_get_next(pTL);
		}

		//
		// 2.  Look for ident
		//
		if (pTok && tok_try_force_to_ident(pTL, fPrefixStar, pTok))
		{
			//
			// This will try to convert keywords and numbers to idents if
			// possible.
			//
			pCmd->ptokObject = pTok;
			pTok = toklist_get_next(pTL);
		}

		//
		// 3. Look for suffix * for object.
		//
		if (pTok && pTok->eTok == tokSTAR)
		{
			CMD_SET_FLAG(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX);
			pTok = toklist_get_next(pTL);
		}

		//
		// 4. Look for Vector Range
		//
		if (pTok && pTok->eTok == tokLBRAC)
		{
			//
			// For now, we support either a single * or a single number.
			//
			pTok = toklist_get_next(pTL);

			if (!pTok)
			{
				goto end; // Error -- incomplete vector range
			}
			else
			{
				if (pTok->eTok == tokSTAR)
				{
					pCmd->uVectorIndexStart = 0;
					pCmd->uVectorIndexEnd = (UINT) -1;
				}
				else if (pTok->eTok == tokNUMBER)
				{
					pCmd->uVectorIndexStart =
					pCmd->uVectorIndexEnd = pTok->uID;
				}
				else
				{
					goto end; // failure...
				}

				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_VECTOR_INDEX);

				pTok = toklist_get_next(pTL);

				if (!pTok || pTok->eTok != tokRBRAC)
				{
					goto end; // failure ... expect RBRAC.
				}
				else
				{
					pTok = toklist_get_next(pTL);
				}
			}
		}

		//
		// 5. Look for DOT
		//
		if (pTok && pTok->eTok == tokDOT)
		{
			fPrefixStar = FALSE;
			pTok = toklist_get_next(pTL);

			// We expect ([*]ident[*]|*)
			//
			// 1. Look for primary star
			//
			if (pTok && pTok->eTok == tokSTAR)
			{
				fPrefixStar = TRUE;
				CMD_SET_FLAG(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX);
				pTok = toklist_get_next(pTL);
			}

			//
			// 2.  Look for ident
			//
			if (pTok && tok_try_force_to_ident(pTL, fPrefixStar, pTok))
			{
				//
				// This will try to convert keywords and numbers to idents if
				// possible.
				//
				pCmd->ptokSubObject = pTok;
				pTok = toklist_get_next(pTL);
			}

			//
			// 3. Look for suffix * for object.
			//
			if (pTok && pTok->eTok == tokSTAR)
			{
				CMD_SET_FLAG(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX);
				pTok = toklist_get_next(pTL);
			}

			//
			// At this point we should either have a non-null IDENT
			// or the PREFIX START should be set for the object
			// (indicateing "a.*").
			//
			if (    pCmd->ptokSubObject
 				|| (pCmd->uFlags & fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
			{
				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_SUBOBJECT);
			}
			else
			{
				goto end; // error
			}
		}

		//
		// 6. Look for object address
		//
		if (pTok && pTok->eTok == tokNUMBER)
		{
			pCmd->uObjectAddress = pTok->uID;
			CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS);
			pTok = toklist_get_next(pTL);
		}

		//
		// 7. Look for object count
		//
		if (   pTok && pTok->eTok == tokKEYWORD
			&& pTok->uID == keywordL)
		{
			pTok = toklist_get_next(pTL);
			if (pTok && pTok->eTok == tokNUMBER)
			{
				pCmd->uObjectCount = pTok->uID;
				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_OBJECT_COUNT);
				pTok = toklist_get_next(pTL);
			}
			else
			{
				// error
			}
		}

		//
		// At this point we should be done...
		//
		if (pTok)
		{
			// error -- extra garbage...
		}
		else
		{
			// Success.
			fRet = TRUE;
			fSyntaxError = FALSE;
		}
	}

end:

    if (fRet)
    {
        pCmd->pvContext = pTL;
    }
    else
    {
        if (fSyntaxError)
        {
            MyDbgPrintf("Unexpected: %s\n", (pTok) ? pTok->szStr : "<null>");
        }
        else
        {
            MyDbgPrintf("Parse failed\n");
        }

        if (pCmd)
        {
            ZeroMemory(pCmd, sizeof(*pCmd));
            LocalFree(pCmd);
            pCmd = NULL;
        }
    }

    if (pTL)
    {
        toklist_restart(pTL);
    }

    return pCmd;
}

BOOL
cmd_parse_help(
    DBGCOMMAND *pCmd,
    TOKLIST *pTL
    )
{
    TOKEN *pTok = toklist_get_next(pTL);

    if (!pTok || pTok->eTok == tokSTAR)
    {
        // User type "help" or "help *"
        MyDbgPrintf("DO HELP\n");
    }

    return TRUE;
}

BOOL
tok_try_force_to_ident(TOKLIST *pTL, BOOL fPrefixStar, TOKEN *pTok)
//
// This gets called when an identifier is expected -- so we see if this
// particular token can be interpreted as in identifier. Some examples
// of when we can do this:
//  dt if.*20334     <--- the "20334" could be part of an identifier, because
//                        of the * prefix.
//
//  dt L.help        <--- both "L" and "help" would have been parsed as
//                        keywords, but here they are intended to be
//                        identifiers.
//  dt abc.def       <--- abc and def would have been parsed as numbers (they
//                        are valid hex numbers), but are intended to be
//                        identifiers.
{
    BOOL fRet = FALSE;

    switch(pTok->eTok)
    {

    case tokNUMBER:
        //
        // We could do this, but subject to some restrictions...
        //
        if (!__iscsymf(pTok->szStr[0]) &&  !fPrefixStar)
        {
            break; // Can't to this: no prefix wild-card (*) and the
                   // number starts with a non-letter.
        }

        // FALL THROUGH ...

    case tokKEYWORD:
        //
        // We can go ahead, but we must make pTok.uID now the offset
        // from the start of the internal string array.
        //
        {
            char *pc = pTL->rgStringBuf;

            for (; *pc; pc+=(lstrlenA(pc)+1))
            {
                if (!lstrcmpiA(pc, pTok->szStr))
                {
                    // found it
                    // MyDbgPrintf("FORCE_TO_IDENT:\nOLD:\n");
                    // tok_dump(pTok);
                    pTok->uID =  (UINT) (pc - pTL->rgStringBuf);
                    pTok->eTok = tokIDENTIFIER;
                    // MyDbgPrintf("NEW:\n");
                    // tok_dump(pTok);
                    fRet = TRUE;

                    break;
                }
            }
        }
        break;

    case tokIDENTIFIER:
        //
        // nothing to do...
        //
        fRet = TRUE;
        break;

    default:
        //
        // Can't convert any other kind of token to identifier...
        //
        break;

    }

    return fRet;
}

void
DoCommand(DBGCOMMAND *pCmd, PFN_SPECIAL_COMMAND_HANDLER pfnHandler)
{
    char *szMsg = NULL;

//    pCmd->pfnSpecialHandler = pfnHandler;

    switch(pCmd->ePrimaryCmd)
    {
    case cmdDUMP_TYPE:
        DoDumpType(pCmd);
        break;
    case cmdDUMP_GLOBALS:
        DoDumpGlobals(pCmd);
        break;
    case cmdHELP:
        DoHelp(pCmd);
        break;

    default:
        szMsg = "Unknown command\n";
        break;
    }


    if (szMsg)
    {
        MyDbgPrintf(szMsg);
    }

    return;
}


typedef struct
{
    DBGCOMMAND *pCmd;
    TYPE_INFO  *pType;

} MY_LIST_NODE_CONTEXT;

typedef
ULONG
MyDumpListNode (
		UINT_PTR uNodeAddr,
		UINT uIndex,
		void *pvContext
		);

void
DoDumpType(DBGCOMMAND *pCmd)
{
    char *szPattern = NULL;
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;
    TYPE_INFO **ppti = NULL;
    UINT uMatchCount = 0;
    TYPE_INFO *ptiDump = NULL;

    //
    // Pick a selection function ...
    //
    if (pCmd->ptokObject)
    {
        szPattern = pCmd->ptokObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }

    }

    //
    // search through global type array for type pName.
    //
    for(ppti=pCmd->pNameSpace->pTypes;*ppti;ppti++)
    {
        TYPE_INFO *pti = *ppti;
        bool fMatch  = !szPattern
                   || !_stricmp(szPattern, pti->szShortName)
                   || pfnMatchingFunction(szPattern,  pti->szName);

        if (fMatch)
        {
        #if 0
            MyDbgPrintf(
                "TYPE \"%2s\" %s (%lu Bytes)\n",
                pti->szShortName,
                pti->szName,
                pti->cbSize
                );
		#endif // 0
            uMatchCount++;
            if (!ptiDump)
            {
                ptiDump = pti;
            }

#if 0
            uAddr =
            MyDbgPrintf(
                "dc 0x%08lx L %03lx \"%2s\" %s\n",
                pgi->uAddr,
                pgi->cbSize,
                pgi->szShortName,
                pgi->szName
                );
            if (szPattern && pgi->uAddr)
            {
                MyDumpObject(
                    pCmd,
                    pgi->pBaseType,
                    pgi->uAddr,
                    pgi->cbSize,
                    pgi->szName
                    );
            }
#endif // 0
        }
    }

    if (!uMatchCount)
    {
        MyDbgPrintf(
            "Could not find type \"%s\"",
             (szPattern ? szPattern : "*")
             );
    }
    else if (   uMatchCount==1)
    {

		UINT uObjectCount = 1;
		UINT uStartIndex = 0;
		UINT uObjectAddress = 0;
		BOOLEAN fList =  TYPEISLIST(ptiDump)!=0;

    	if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS))
    	{
			uObjectAddress = pCmd->uObjectAddress;
		}

		//
		// Determine start index.
		//
		if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_VECTOR_INDEX))
		{
			uStartIndex =  pCmd->uVectorIndexStart;
			if (fList && !CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_COUNT))
			{
				uObjectCount =  pCmd->uVectorIndexEnd - uStartIndex;
				if (uObjectCount != (UINT) -1)
				{
					uObjectCount++;
				}
			}
		}

		//
		// Determine object count...
		//
		if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_COUNT))
		{
			uObjectCount =  pCmd->uObjectCount;
		}

		//
		// If no address is specified, we'll try to resolve it ...
		//
    	if (!CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS))
    	{
    		BOOLEAN fUseCache = FALSE;

			//
			// Algorithm for determining whether to use cache or to resolve
			// address:
			//
			if (ptiDump->uCachedAddress)
			{
				//
				// Except for the special case of [0], we will use
				// the the cached value.
				//
				if (!(		uStartIndex ==0
					 	&& 	uObjectCount==1
					 	&&  CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_VECTOR_INDEX)))
				{
					fUseCache = TRUE;
				}
			}

			if (fUseCache)
			{
				uObjectAddress = ptiDump->uCachedAddress;
			}
			else
			{
				if (pCmd->pNameSpace->pfnResolveAddress)
				{
					uObjectAddress = pCmd->pNameSpace->pfnResolveAddress(
														ptiDump
														);
				}
			}
    	}

    	if (uObjectAddress && uObjectCount)
    	{

			//
			// Prune these to "reasonable" values.
			//
			if (uObjectCount > 100)
			{
				MyDbgPrintf("Limiting object count to 100\n");
				uObjectCount = 100;
			}

			if (fList)
			{
				MY_LIST_NODE_CONTEXT Context;
				Context.pCmd = pCmd;
				Context.pType = ptiDump;

				WalkList(
					uObjectAddress,		// start address
					ptiDump->uNextOffset, 		// next offset
					uStartIndex,
					uStartIndex+uObjectCount-1, // end index
					&Context,					// context
					NodeFunc_DumpType,			// function
					(char *) ptiDump->szName
					);

				//
				// If only a single structure was dumped, and it was dumped
				// successfully, we will update this structure's cache.
				// TODO: we don't check for success
				//
				if (uObjectCount==1)
				{
					WalkList(
						uObjectAddress,			// start address
						ptiDump->uNextOffset, 	// next offset
						uStartIndex,
						uStartIndex,  			// end index
						ptiDump,					// context
						NodeFunc_UpdateCache,	// function
						(char *) ptiDump->szName
						);
				}
			}
			else
			{
				UINT cbSize =  ptiDump->cbSize;
				UINT uAddr  =  uObjectAddress + uStartIndex*cbSize;
				UINT uEnd   =  uAddr + uObjectCount*cbSize;
				//
				// For arays, compute offset to start address
				//
				uObjectAddress = uAddr;

				for (; uAddr<uEnd; uAddr+=cbSize)
				{
					MyDumpObject(
						pCmd,
						ptiDump,
						uAddr,
						ptiDump->cbSize,
						ptiDump->szName
						);
				}
				//
				// If only a single structure was dumped, and it was dumped
				// successfully, we will update this structure's cache.
				// TODO: we don't check for success
				//
				if (uObjectCount==1)
				{
					ptiDump->uCachedAddress = uObjectAddress;
				}
			}

    	}
    	else
    	{
    		MyDbgPrintf(
				"Could not resolve address for object %s\n",
				ptiDump->szName
				);
    	}
    }

}

void
DoDumpGlobals(DBGCOMMAND *pCmd)
{
    GLOBALVAR_INFO *pgi = pCmd->pNameSpace->pGlobals;
    char *szPattern = NULL;
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;

    //
    // Pick a selection function ...
    //
    if (pCmd->ptokObject)
    {
        szPattern = pCmd->ptokObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }

    }

    //
    // Run through our list of globals, and if the entry is selected,
    // we will display it.
    //
    for (;pgi->szName; pgi++)
    {
        bool fMatch  = !szPattern
                       || !_stricmp(szPattern, pgi->szShortName)
                       || pfnMatchingFunction(szPattern,  pgi->szName);
        if (fMatch)
        {
            pgi->uAddr = dbgextGetExpression(pgi->szName);
            MyDbgPrintf(
                "dc 0x%08lx L %03lx \"%2s\" %s\n",
                pgi->uAddr,
                pgi->cbSize,
                pgi->szShortName,
                pgi->szName
                );
            if (szPattern && pgi->uAddr)
            {
                MyDumpObject(
                    pCmd,
                    pgi->pBaseType,
                    pgi->uAddr,
                    pgi->cbSize,
                    pgi->szName
                    );
            }
        }
    }
}

void
DoHelp(
	DBGCOMMAND *pCmd // OPTIONAL
	)
{
	//
	//
	//
    MyDbgPrintf("help unimplemented\n");
}

void
MyDumpObject (
    DBGCOMMAND *pCmd,
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    UINT     cbSize,
    const char *szDescription
    )
{
    UINT uMatchFlags = 0;
    char *szFieldSpec  = NULL;

    if (pCmd->ptokSubObject)
    {
        szFieldSpec = pCmd->ptokSubObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
        {
            uMatchFlags = fMATCH_SUBSTRING;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX))
        {
            uMatchFlags = fMATCH_SUFFIX;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
        {
            uMatchFlags = fMATCH_PREFIX;
        }
    }

    if (!pType)
    {
        DumpMemory(
            uAddr,
            cbSize,
            0,
            szDescription
            );
    }
    else
    {
        DumpStructure(pType, uAddr, szFieldSpec, uMatchFlags);
    }
}

ULONG
NodeFunc_DumpType (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	MY_LIST_NODE_CONTEXT *pContext =  (MY_LIST_NODE_CONTEXT*) pvContext;

	MyDbgPrintf("[%lu] ", uIndex);
	MyDumpObject (
		pContext->pCmd,
		pContext->pType,
		uNodeAddr,
		pContext->pType->cbSize,
		pContext->pType->szName
		);
	return 0;
}

ULONG
NodeFunc_UpdateCache (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	TYPE_INFO *pti = (TYPE_INFO*) pvContext;

	if (pti->uCachedAddress != uNodeAddr)
	{
		MyDbgPrintf(
			"Updating Cache from 0x%lx to 0x%lx\n",
			pti->uCachedAddress,
			uNodeAddr
			);
	}
	pti->uCachedAddress = uNodeAddr;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\netepvcm.inf: $(_INX)\netepvcm.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)


$(O)\netepvcp.inf: $(_INX)\netepvcp.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\ndis.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	ndis.c	- DbgExtension Structure information specific to NDIS.SYS

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     04-26-98    Created

Notes:

--*/


#include "precomp.h"
//#include <ndis.h>
//#include <ndismini.h>


enum
{
    typeid_NDIS_MINIPORT_BLOCK,
    typeid_NDIS_M_DRIVER_BLOCK
};


extern TYPE_INFO *g_rgTypes[];
//
// STRUCTURES CONCERNING TYPE "NDIS_MINIPORT_BLOCK"
//

STRUCT_FIELD_INFO  rgfi_NDIS_MINIPORT_BLOCK[] =
{

  {
    "NullValue",
     FIELD_OFFSET(NDIS_MINIPORT_BLOCK, NullValue),
     FIELD_SIZE(NDIS_MINIPORT_BLOCK, NullValue)
  },
  {
  	NULL
  }


};

TYPE_INFO type_NDIS_MINIPORT_BLOCK = {
    "NDIS_MINIPORT_BLOCK",
    "mpb",
     typeid_NDIS_MINIPORT_BLOCK,
	 fTYPEINFO_ISLIST,			// Flags
     sizeof(NDIS_MINIPORT_BLOCK),
     rgfi_NDIS_MINIPORT_BLOCK,
     FIELD_OFFSET(NDIS_MINIPORT_BLOCK, NextMiniport) // offset to next pointer.
};


//
// STRUCTURES CONCERNING TYPE "NDIS_M_DRIVER_BLOCK"
//


STRUCT_FIELD_INFO  rgfi_NDIS_M_DRIVER_BLOCK[] =
{
  {
    "MiniportQueue",
     FIELD_OFFSET(NDIS_M_DRIVER_BLOCK, MiniportQueue),
     FIELD_SIZE(NDIS_M_DRIVER_BLOCK, MiniportQueue)
  },
  {
  	NULL
  }

};

TYPE_INFO type_NDIS_M_DRIVER_BLOCK = {
    "NDIS_M_DRIVER_BLOCK",
    "mdb",
     typeid_NDIS_M_DRIVER_BLOCK,
	 fTYPEINFO_ISLIST,			// Flags
     sizeof(NDIS_M_DRIVER_BLOCK),
     rgfi_NDIS_M_DRIVER_BLOCK,
     FIELD_OFFSET(NDIS_M_DRIVER_BLOCK, NextDriver) // offset to next pointer.
};



TYPE_INFO *g_rgNDIS_Types[] =
{
    &type_NDIS_MINIPORT_BLOCK,
    &type_NDIS_M_DRIVER_BLOCK,

    NULL
};


GLOBALVAR_INFO g_rgNDIS_Globals[] = 
{

	//
	// Check out aac.c for examples of how to add information about global
	// structures...
	//

    {
    NULL
    }

};

UINT_PTR
NDIS_ResolveAddress(
		TYPE_INFO *pType
		);

NAMESPACE NDIS_NameSpace = {
		g_rgNDIS_Types,
		g_rgNDIS_Globals,
		NDIS_ResolveAddress
		};

void
NdisCmdHandler(
	DBGCOMMAND *pCmd
	);

void
do_ndis(PCSTR args)
{

	DBGCOMMAND *pCmd = Parse(args, &NDIS_NameSpace);
	if (pCmd)
	{
		DumpCommand(pCmd);
		DoCommand(pCmd, NdisCmdHandler);
		FreeCommand(pCmd);
		pCmd = NULL;
	}

    return;
}

//mdb list= (PNDIS_M_DRIVER_BLOCK)GetExpression("ndis!ndisMiniDriverList");

void
NdisCmdHandler(
	DBGCOMMAND *pCmd
	)
{
	MyDbgPrintf("Handler called \n");
}

UINT_PTR
NDIS_ResolveAddress(
		TYPE_INFO *pType
		)
{
	UINT_PTR uAddr = 0;
	UINT uOffset = 0;
	BOOLEAN fRet = FALSE;
	UINT_PTR uParentAddress = 0;

// NDIS!ndisMiniDriverList
	static UINT_PTR uAddr_ndisMiniDriverList;

	//
	// If this type has a parent (container) type, we will use the containing
	// type's cached address if its available, else we'll resolve the
	// containers type. The root types are globals -- we do an
	// expression evaluation for them.
	//

    switch(pType->uTypeID)
    {


    case typeid_NDIS_M_DRIVER_BLOCK:
    	//
    	// We pick up the global ndisMiniDriverList address if we haven't
    	// already...
    	//
		if (!uAddr_ndisMiniDriverList)
		{
  			uAddr_ndisMiniDriverList =
					 dbgextGetExpression("ndis!ndisMiniDriverList");
		}
		uAddr = uAddr_ndisMiniDriverList;

		if (uAddr)
		{
			fRet =  TRUE;
		}
		break;

    case typeid_NDIS_MINIPORT_BLOCK:
    	//
    	//
    	//
		uParentAddress =  type_NDIS_M_DRIVER_BLOCK.uCachedAddress;
		if (!uParentAddress)
		{
			uParentAddress =  NDIS_ResolveAddress(&type_NDIS_M_DRIVER_BLOCK);
		}

		if (uParentAddress)
    	{

    		uOffset =   FIELD_OFFSET(NDIS_M_DRIVER_BLOCK, MiniportQueue);
			fRet =  dbgextReadUINT_PTR(
								uParentAddress + uOffset,
								&uAddr,
								"NDIS_M_DRIVER_BLOCK::MiniportQueue"
								);

		#if 1
			MyDbgPrintf(
				"fRet = %lu; uParentOff=0x%lx uAddr=0x%lx[0x%lx]\n",
				 fRet,
				 uParentAddress+uOffset,
				 uAddr,
				 *(UINT_PTR*)(uParentAddress+uOffset)
				);
		#endif // 0
    	}
    	break;

	default:
		MYASSERT(FALSE);
		break;

    }

	if (!fRet)
	{
		uAddr = 0;
	}

	MyDbgPrintf("ResolveAddress[%s] returns 0x%08lx\n", pType->szName, uAddr);
    return uAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>

#include <windef.h>
#include <winbase.h>
#include <winuser.h>
#include <wdbgexts.h>
#include <stdio.h>

#include <ntosp.h>
#include <ndis.h>

#include "util.h"
#include "parse.h"


#if BINARY_COMPATIBLE
#include "cmddk.h"
#endif // BINARY_COMPATIBLE

#include <atm.h>
#include <cxport.h>
#include <ip.h>
#include <arpinfo.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <llinfo.h>

#ifndef ATMARP_WIN98
#include <tdistat.h>
#include <ipifcons.h>
#endif

#include <atmarpif.h>

#ifdef NEWARP

#ifdef _PNP_POWER_
#include <ntddip.h>
#include <llipif.h>
#else

#ifdef ATMARP_WIN98
#define _PNP_POWER_ 1
#endif

#include <ntddip.h>

#ifdef ATMARP_WIN98
#undef _PNP_POWER_
#undef NT
#include <tdistat.h>
#endif

#include <llipif.h>

#ifdef ATMARP_WIN98
#define NT 1
#endif

#endif // _PNP_POWER_

#else

#include <llipif0.h>

#endif // NEWARP

#include <ntddip.h>

#include "system.h"
#include "debug.h"

#ifdef GPC
#include "gpcifc.h"
#include "traffic.h"
#include "ntddtc.h"
#endif // GPC

#include "aaqos.h"
#include "arppkt.h"

#ifdef IPMCAST
#include "marspkt.h"
#endif // IPMCAST

#include "atmarp.h"
#include "cubdd.h"
#include "macros.h"

#ifdef ATMARP_WMI
#include <wmistr.h>
#include "aawmi.h"
#endif // ATMARP_WMI

#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	util.c	- Generic Debugger Extension Utilities

Abstract:

	Taken from AliD's ndiskd(ndiskd.c).

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-30-98    Created (taken fron AliD's ndiskd (ndiskd.c).

Notes:

--*/
#include "precomp.h"
#include "common.h"

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?




/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG) pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN DWORD dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while( size > 0 ) {

    if (count >= 3000)
        count = 3000;

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN DWORD dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !GetData( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (DWORD)ListEntry.Flink == dwListHeadAddr || (DWORD)ListEntry.Flink == 0 )
            break;

        if( !GetData( &ListEntry, (DWORD)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (DWORD)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}



/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}


/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN DWORD dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

char *mystrtok ( char *string, char * control )
{
    static UCHAR *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

        
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    g_pfnDbgPrintf = dprintf;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s IPATM Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{

	//
	// for now don't bother to version check
	//
	return;
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
//	VOID
//	PrintName(
//		PUNICODE_STRING Name
//		);
// print a unicode string
// Note: the Buffer field in unicode string is unmapped
//
VOID
PrintName(
	PUNICODE_STRING Name
	)
{
	USHORT i;
	WCHAR ubuf[256];
	UCHAR abuf[256];
	
	if (!GetString((DWORD)Name->Buffer, ubuf, (ULONG)Name->Length))
	{
		return;
	}

	for (i = 0; i < Name->Length/2; i++)
	{
		abuf[i] = (UCHAR)ubuf[i];
	}
	abuf[i] = 0;

	dprintf("%s",abuf);
}

MYPWINDBG_OUTPUT_ROUTINE g_pfnDbgPrintf = NULL;




bool
dbgextReadMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    )
{
    UINT cbBytesRead=0;

    bool fRet = ReadMemory(
                    uOffset,
                    pvBuffer,
                    cb,
                    &cbBytesRead
                    );
    if (!fRet || cbBytesRead != cb)
    {
        ERRPRT("Read  failed: 0x%X(%s, %u bytes)\n",uOffset,pszDescription,cb);
        fRet = FALSE;
    }

    return fRet;
}

bool
dbgextWriteMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    )
{
    UINT cbBytesWritten=0;
    bool fRet = WriteMemory(
                    uOffset,
                    pvBuffer,
                    cb,
                    &cbBytesWritten
                    );
    if (!fRet || cbBytesWritten != cb)
    {
        ERRPRT("Write failed: 0x%X(%s, %u bytes)\n",uOffset,pszDescription,cb);
        fRet = FALSE;
    }
    return 0;
}


bool
dbgextReadUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR *pu,
    char *pszDescription
    )
{
    UINT cbBytesRead=0;

    bool fRet = ReadMemory(
                    uOffset,
                    pu,
                    sizeof(*pu),
                    &cbBytesRead
                    );
    if (!fRet || cbBytesRead != sizeof(*pu))
    {
        ERRPRT("Read  failed: 0x%X(%s, UINT_PTR)\n",uOffset,pszDescription);
        fRet = FALSE;
    }

    return fRet;
}

bool
dbgextWriteUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR u,
    char *pszDescription
    )
{
    UINT cbBytesWritten=0;
    bool fRet = WriteMemory(
                    uOffset,
                    &u,
                    sizeof(uOffset),
                    &cbBytesWritten
                    );
    if (!fRet || cbBytesWritten != sizeof(u))
    {
        ERRPRT("Write failed: 0x%X(%s, UINT_PTR)\n",uOffset,pszDescription);
        fRet = FALSE;
    }
    return fRet;
}

UINT_PTR
dbgextGetExpression(
    const char *pcszExpression
    )
{
    UINT_PTR uRet =  GetExpression(pcszExpression);
    
    //
    // At such a point we use this for something besides pointers,
    // we will remove the check below.
    //

    if (!uRet)
    {
        ERRPRT("Eval  failed: \"%s\"\n", pcszExpression);
    }

    return uRet;
}


void
DumpObjects(TYPE_INFO *pType, UINT_PTR uAddr, UINT cObjects, UINT uFlags)
{
    //
    // Print object's type and size
    //
    dprintf(
        "%s@0x%X (%lu Bytes)\n",
        pType->szName,
        uAddr,
        pType->cbSize
        );


    DumpMemory(
        uAddr,
        pType->cbSize,
        0,
        pType->szName
        );
    
    //
    // Dump bytes...
    //

    return;
}

BYTE rgbScratchBuffer[100000];

bool
DumpMemory(
    UINT_PTR uAddr,
    UINT cb,
    UINT uFlags,
    const char *pszDescription
    )
{
    bool fTruncated = FALSE;
    bool fRet = FALSE;
    UINT cbLeft = cb;
    char *pbSrc = rgbScratchBuffer;

    if (cbLeft>1024)
    {
        cbLeft = 1024;
        fTruncated = TRUE;
    }
    
    fRet = dbgextReadMemory(
            uAddr,
            rgbScratchBuffer,
            cbLeft,
            (char*)pszDescription
            );

    if (!fRet) goto end;

    #define ROWSIZE 16 // bytes
    //
    // Dump away...
    //
    while (cbLeft)
    {
        char rgTmp_dwords[ROWSIZE];
        char rgTmp_bytes[ROWSIZE];
        char *pb=NULL;
        UINT cbRow = ROWSIZE;
        if (cbRow > cbLeft)
        {
            cbRow = cbLeft;
        }
    
        
        memset(rgTmp_dwords, 0xff, sizeof(rgTmp_dwords));
        memset(rgTmp_bytes,  ' ', sizeof(rgTmp_bytes));

        memcpy(rgTmp_dwords, pbSrc, cbRow);
        memcpy(rgTmp_bytes,  pbSrc, cbRow);
        
        // sanitize bytes
        for (pb=rgTmp_bytes; pb<(rgTmp_bytes+sizeof(rgTmp_bytes)); pb++)
        {
            char c = *pb;
            if (c>=0x20 && c<0x7f) // isprint is too permissive.
            {
                if (*pb=='\t')
                {
                    *pb=' ';
                }
            }
            else
            {
                *pb='.';
            }
        }

        dprintf(
            "    %08lx: %08lx %08lx %08lx %08lx |%4.4s|%4.4s|%4.4s|%4.4s|\n",
            uAddr,
            ((DWORD*) rgTmp_dwords)[0],
            ((DWORD*) rgTmp_dwords)[1],
            ((DWORD*) rgTmp_dwords)[2],
            ((DWORD*) rgTmp_dwords)[3],
        #if 1
            rgTmp_bytes+0,
            rgTmp_bytes+4,
            rgTmp_bytes+8,
            rgTmp_bytes+12
        #else
            "aaaabbbbccccdddd",
            "bbbb",
            "cccc",
            "dddd"
        #endif
            );

        cbLeft -= cbRow;
        pbSrc += cbRow;
        uAddr += cbRow;
    }

#if 0
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
#endif // 

end:

    return fRet;
}


bool
MatchPrefix(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }

    return fRet;
}

bool
MatchSuffix(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        szString += (uS-uP);
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }
    return fRet;
}

bool
MatchSubstring(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        const char *szLast =  szString + (uS-uP);
        do
        {
            fRet = (_memicmp(szPattern, szString, uP)==0);

        } while (!fRet && szString++ < szLast);
    }

    return fRet;
}

bool
MatchExactly(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP==uS)
    {
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }

    return fRet;
}


bool
MatchAlways(const char *szPattern, const char *szString)
{
    return TRUE;
}

void
DumpBitFields(
		ULONG  			Flags,
    	BITFIELD_INFO	rgBitFieldInfo[]
		)
{
	BITFIELD_INFO *pbf = rgBitFieldInfo;

	for(;pbf->szName; pbf++)
	{
		if ((Flags & pbf->Mask) == pbf->Value)
		{
			MyDbgPrintf(" %s", pbf->szName);
		}
	}
}

void
DumpStructure(
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    char *szFieldSpec,
    UINT uFlags
    )
{
    //
    // Determine field comparision function ...
    //
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;

    //
    // Pick a selection function ...
    //
    if (szFieldSpec)
    {
        if (uFlags & fMATCH_SUBSTRING)
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (uFlags & fMATCH_SUFFIX)
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (uFlags & fMATCH_PREFIX)
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }
    }

    //
    // Print object's type and size
    //
    dprintf(
        "%s@0x%X (%lu Bytes)\n",
        pType->szName,
        uAddr,
        pType->cbSize
        );

    //
    // Run through all the fields in this type, and if the entry is selected,
    // we will display it.
    //
    {
        STRUCT_FIELD_INFO *pField = pType->rgFields;
        for (;pField->szFieldName; pField++)
        {
            bool fMatch  = !szFieldSpec
                           || pfnMatchingFunction(szFieldSpec, pField->szFieldName);
            if (fMatch)
            {
                UINT_PTR uFieldAddr = uAddr + pField->uFieldOffset;

                // special-case small fields...
                if (pField->uFieldSize<=sizeof(ULONG_PTR))
                {

					ULONG_PTR Buf=0;
    				BOOL fRet = dbgextReadMemory(
										uFieldAddr,
										&Buf,
										pField->uFieldSize,
                        				(char*)pField->szFieldName
										);
					if (fRet)
					{
						// print it as a hex number

						MyDbgPrintf(
							"\n%s\t[%lx,%lx]: 0x%lx",
							pField->szFieldName,
							pField->uFieldOffset,
							pField->uFieldSize,
							Buf
							);

						//
						// If it's an embedded object and it's a bitfield,
						// print the bitfields...
						//
						if (	FIELD_IS_EMBEDDED_TYPE(pField)
							&&  TYPEISBITFIELD(pField->pBaseType) )
						{
							DumpBitFields(
									Buf,
								    pField->pBaseType->rgBitFieldInfo
								    );
							
						}
						
						MyDbgPrintf("\n");
	
					}
					continue;
				}

            #if 0
                MyDbgPrintf(
                    "%s\ndc 0x%08lx L %03lx %s\n",
                    pField->szSourceText,
                    uFieldAddr,
                    pField->uFieldSize,
                    pField->szFieldName
                    );
            #else // 1
                MyDbgPrintf(
                    "\n%s\t[%lx,%lx]\n",
                    pField->szFieldName,
                    pField->uFieldOffset,
                    pField->uFieldSize
                    );
            #endif // 1

                // if (szFieldSpec)
                {
                #if 0
                    MyDumpObjects(
                        pCmd,
                        pgi->pBaseType,
                        pgi->uAddr,
                        pgi->cbSize,
                        pgi->szName
                        );
                #endif // 0
                    DumpMemory(
                        uFieldAddr,
                        pField->uFieldSize,
                        0,
                        pField->szFieldName
                        );
                }
            }
        }
    }

    return;
}


DECLARE_API( help )
{
    do_help(args);
}


DECLARE_API( aac )
{
    do_aac(args);
}

ULONG
NodeFunc_DumpAddress (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	MyDbgPrintf("[%lu] 0x%08lx\n", uIndex, uNodeAddr);
	return 0;
}

UINT
WalkList(
	UINT_PTR uStartAddress,
	UINT uNextOffset,
	UINT uStartIndex,
	UINT uEndIndex,
	void *pvContext,
	PFNNODEFUNC pFunc,
	char *pszDescription
	)
//
// Visit each node in the list in turn,
// reading just the next pointers. It calls pFunc for each list node
// between uStartIndex and uEndIndex. It terminates under the first of
// the following conditions:
// 	* Null pointer
// 	* ReadMemoryError
// 	* Read past uEndIndex
// 	* pFunc returns FALSE
//
{
	UINT uIndex = 0;
	UINT_PTR uAddress = uStartAddress;
	BOOL fRet = TRUE;
	UINT uRet = 0;


	//
	// First skip until we get to uStart Index
	//
	for (;fRet && uAddress && uIndex < uStartIndex; uIndex++)
	{
		fRet =  dbgextReadUINT_PTR(
							uAddress+uNextOffset,
							&uAddress,
							pszDescription
							);
	}


	//
	// Now call pFunc with each node
	//
	for (;fRet && uAddress && uIndex <= uEndIndex; uIndex++)
	{
		uRet = pFunc(uAddress, uIndex, pvContext);

		fRet =  dbgextReadUINT_PTR(
							uAddress+uNextOffset,
							&uAddress,
							pszDescription
							);
	}

	pFunc = NodeFunc_DumpAddress;
	return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( sfiltern )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( sfiltern ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\util.h ===
#define  MYASSERT(_cond) \
            ((_cond) ?  0 : MyDbgPrintf("ASSERTION FAILED\n"))


typedef int bool;


//
// Debugger Extension Primitives
//


bool
dbgextReadMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    );

bool
dbgextReadUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR *pu,
    char *pszDescription
    );


bool
dbgextWriteMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    );
bool
dbgextWriteUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR u,
    char *pszDescription
    );


UINT_PTR
dbgextGetExpression(
    const char *pcszExpression
    );


#if 0   // Not sure what this one is about...
void 
dbgextGetSymbol(
    void *offset,
    UCHAR *pchBuffer,
    UINT  *pDisplacement
    );
#endif // 0

typedef
void
(__cdecl *MYPWINDBG_OUTPUT_ROUTINE)(
    const char * lpFormat,
    ...
    );

extern MYPWINDBG_OUTPUT_ROUTINE g_pfnDbgPrintf;

#define MyDbgPrintf g_pfnDbgPrintf


//
//  User Commands Parsing Support and Structures
//
typedef struct
{
    //TOKEN tokCmd;
    UINT uParam;
    UINT uFlags;

} COMMAND;

//!aac if@0x099900.*sig*
//!aac if[0].*sig*

struct _TYPE_INFO;

typedef
UINT_PTR
(*PFN_DUMP)(
				struct _TYPE_INFO *pType,
				UINT uFlags
				);
#define fDUMP_ONE_LINE_SUMMARY (0x1)

typedef struct
{
	char *szName;
	UINT Mask;
	UINT Value;

} BITFIELD_INFO;


typedef struct _TYPE_INFO
{
    const char *	szName;
    const char *	szShortName;
    UINT 			uTypeID;
    UINT 			uFlags;		// One or more fTYPEINFO_ flags.
    UINT 			cbSize;

    struct _STRUCT_FIELD_INFO *rgFields;

    UINT 			uNextOffset;
					// If this type is a list element, this is the offset
					// in bytes to the next pointer.
					// Only valid if uFlags contains fTYPEINFO_ISLIST
					
    BITFIELD_INFO	*rgBitFieldInfo;
    				//
    				// If this type is a bitfield, this this points
    				// to an array of BITFIELD_INFO structs, giving
    				// the set of valid bitfield constants that can
    				// be held in this bitfield.
    				//
    				// Note -- only one of rgFields and rgBitField info
    				// 		   should be non-null (both can be null).
    				//

	UINT_PTR		uCachedAddress; // Set to the address of this type that
									// was most recently referenced.


	PFN_DUMP		pfnDump;

} TYPE_INFO;



#define fTYPEINFO_ISLIST     (0x1<<0)
#define fTYPEINFO_ISBITFIELD (0x1<<1)

#define TYPEISLIST(_pType) 		((_pType)->uFlags & fTYPEINFO_ISLIST)
#define TYPEISBITFIELD(_pType) 	((_pType)->uFlags & fTYPEINFO_ISBITFIELD)

//
// STRUCT_FIELD_INFO contains information about a particular field of a struct.
//
typedef struct _STRUCT_FIELD_INFO
{
    const char *szFieldName;
    UINT uFieldOffset; // Offset in bytes from start of containing structure.
    UINT uFieldSize;
    UINT uFlags;  // one or more fFI_* flags define below
    TYPE_INFO *pBaseType;

} STRUCT_FIELD_INFO;


#define fFI_PTR     (0x1<<0)    // Field is a pointer
#define fFI_LIST    (0x1<<1)    // Field is a pointer to 1st element of a list
#define fFI_ARRAY   (0x1<<2)    // Field is an array (pointer to array if 
                                // fFI_PTR is set). 
#define fFI_OPAQUE  (0x1<<3)    // Treat object as opaque, of size uObjectSize.
                                // If set then fLIST must not be set.

#define FIELD_IS_EMBEDDED_TYPE(_pFI)  \
				(   !((_pFI)->uFlags & (fFI_PTR|fFI_OPAQUE|fFI_ARRAY)) \
				 && ((_pFI)->pBaseType))
		//
		//	true iff the field is itself a valid type
		//

#define FIELD_IS_PTR_TO_TYPE(_pFI)  \
				(   ((_pFI)->uFlags & fFI_PTR) \
				 && !((_pFI)->uFlags & (fFI_OPAQUE|fFI_ARRAY)) \
				 && ((_pFI)->pBaseType))
		//
		//	true iff the field is pointer to a valid type
		//

#define FIELD_SIZE(type, field)  sizeof(((type *)0)->field)

//
// Information about a global variable.
//
typedef struct
{
    const char *szName; // of variable.
    const char *szShortName;
    TYPE_INFO  *pBaseType;  // could be null (unspecified).
    UINT       uFlags;
    UINT       cbSize;
    UINT_PTR   uAddr;       // Address in debuggee's address space.
    
} GLOBALVAR_INFO;


typedef
UINT_PTR
(*PFN_RESOLVE_ADDRESS)(
				TYPE_INFO *pType
				);

typedef struct
{
	TYPE_INFO	**pTypes;
	GLOBALVAR_INFO *pGlobals;
	PFN_RESOLVE_ADDRESS pfnResolveAddress;

} NAMESPACE;

void
DumpObjects(TYPE_INFO *pType, UINT_PTR uAddr, UINT cObjects, UINT uFlags);

#define fMATCH_SUBSTRING (0x1<<0)
#define fMATCH_PREFIX    (0x1<<1)
#define fMATCH_SUFFIX    (0x1<<2)

void
DumpStructure(
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    char *szFieldSpec,
    UINT uFlags
    );

bool
DumpMemory(
    UINT_PTR uAddr,
    UINT cb,
    UINT uFlags,
    const char *pszDescription
    );

typedef bool (*PFNMATCHINGFUNCTION) (
                    const char *szPattern,
                    const char *szString
                    );

bool
MatchPrefix(const char *szPattern, const char *szString);

bool
MatchSuffix(const char *szPattern, const char *szString);

bool
MatchSubstring(const char *szPattern, const char *szString);

bool
MatchExactly(const char *szPattern, const char *szString);

bool
MatchAlways(const char *szPattern, const char *szString);

typedef ULONG (*PFNNODEFUNC)(
				UINT_PTR uNodeAddr,
				UINT uIndex,
				void *pvContext
				);
//
//	 PFNNODEFUNC is the prototype of the func passed into WalkList
//


UINT
WalkList(
	UINT_PTR uStartAddress,
	UINT uNextOffset,
	UINT uStartIndex,
	UINT uEndIndex,
	void *pvContext,
	PFNNODEFUNC pFunc,
	char *pszDescription
	);
//
// Visit each node in the list in turn,
// reading just the next pointers. It calls pFunc for each list node
// between uStartIndex and uEndIndex. It terminates under the first of
// the following conditions:
// 	* Null pointer
// 	* ReadMemoryError
// 	* Read past uEndIndex
// 	* pFunc returns FALSE
//


ULONG
NodeFunc_DumpAddress (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);
//
//	This is a sample node function -- simply dumps the specfied address.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\implinc.cpp ===
#include "pch.h"
#pragma hdrstop

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>


//EXTERN_C const IID IID_INetLanConnectionUiInfo = {0xC08956A6,0x1CD3,0x11D1,{0xB1,0xC5,0x00,0x80,0x5F,0xC1,0x27,0x0E}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\dllmain.cpp ===
#include "pch.h"
#pragma hdrstop
#include "sfilter.h"
#include "initguid.h"
#include "sfiltern_i.c"

// Global
//#include "sfnetcfg_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CBaseClass, CBaseClass)
END_OBJECT_MAP()





/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{


    if (dwReason == DLL_PROCESS_ATTACH)
    {
		TraceMsg (L"-- DllMain  Attach\n");

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
		TraceMsg (L"-- DllMain  Detach\n");

		_Module.Term();
    }



    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	TraceMsg (L"--DllCanUnloadNow\n");

    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	TraceMsg (L"--DllGetClassObject\n");

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    TraceMsg (L"--DllRegisterServer\n");

    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TraceMsg (L"--DllUnregisterServer\n");

    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\mystring.h ===
// mystring.h
//
// Programmer: Carmen Sarro
// Copyright (c) Microsoft Corporation, 1997
//
// Microsoft Technical Education
// C++ Programming
// Lab 1

#ifndef MYSTRING_H_
#define MYSTRING_H_



const MAX_LEN = 100;

#if DBG
void TraceMsg(PCWSTR szFormat, ...);
#else
inline void TraceMsg(PCWSTR szFormat, ...) {}
#endif

 

class MyString
{
private:
    int m_len;
    wchar_t data[MAX_LEN];
public:
    MyString();
    MyString(wchar_t *str);
    MyString(const MyString &);

    const MyString& operator= (PCWSTR  lp);
    const MyString& operator= (const MyString& MyStr);

    BOOLEAN append(const wchar_t* str);
    void append(MyString str);
    int len();
    const wchar_t* wcharptr();
    const wchar_t* c_str() const;
    void Zero();
    void NullTerminate();
};

int compare(MyString first, MyString second);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\mystring.cpp ===
// mystring.cpp
//
// Programmer: Carmen Sarro
// Copyright (c) Microsoft Corporation, 1997
//
// Microsoft Technical Education
// C++ Programming
// Lab 1


#include "pch.h"
#pragma hdrstop


MyString::MyString()
{
	Zero();

	*data = L'\0';
	m_len = 0;
}

MyString::MyString(wchar_t *str)
{	
	Zero();
	m_len = wcslen(str);
	

	// Since strlen returns the number of characters in str, excluding the terminal NULL,
	// and since strncpy does not automatically append the terminal NULL, 
	// if m_len < MAX_LEN we want to copy m_len + 1 characters because we assume the 
	// last character of the source string is the terminal NULL.  Otherwise we explicitly 
	// set the last element to the terminal NULL.
	
	if (m_len >= MAX_LEN - 1){
		m_len = MAX_LEN - 1;
		wcsncpy(data, str, m_len);
		data[m_len] = L'\0';
	}
	else {
		wcscpy(data, str);
	}
}

MyString::MyString (const MyString& MyStr)
{

	wcscpy(data, MyStr.data);

	
	m_len = wcslen(MyStr.data);

	this->NullTerminate();		
}


const MyString& MyString::operator= (PCWSTR lp)
{
	Zero();

	wcscpy(data, lp);
	m_len = wcslen(lp);

	this->NullTerminate();

	return (*this);
}

const MyString& MyString::operator= (const MyString& MyStr)
{
	wcscpy(data, MyStr.data);
	
	m_len = MyStr.m_len;

	this->NullTerminate();		

	return (*this);
}




const wchar_t* MyString::wcharptr()
{
	return data;
}


int MyString::len()
{
	return m_len;
}

void MyString::append(MyString str)
{
	wcsncat(data, str.data, MAX_LEN - m_len - 1);
	m_len += wcslen(data + m_len); 
	this->NullTerminate();		

}




BOOLEAN
MyString::append(const wchar_t *str)
{
	BOOLEAN fDidCopy = FALSE;
	UINT Length = 0;

	if (str == NULL || (wcslen(str) + m_len > MAX_LEN + 1) )
	{
		return fDidCopy;
	}
	
	wcsncat(data, str, MAX_LEN - m_len - 1);
	m_len += wcslen(data);
	fDidCopy = TRUE;

	this->NullTerminate();		

	return fDidCopy;
}

int compare(MyString firstStr, MyString secondStr)
{
	return wcscmp(firstStr.wcharptr(), secondStr.wcharptr());
}




const wchar_t* MyString::c_str() const
{
	return (data);
}



void MyString::Zero()
{
	UINT i = 0;

	m_len = 0;

	for (i = 0; i < MAX_LEN; i++)
	{
		data[i] = 0;
	}

}




VOID
MyString::NullTerminate()
{
	if (data[m_len] != L'\0')
	{
		data[++m_len] = L'\0';
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\macros.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       M A C R O S. H
//
//  Contents:   Local declarations for the Notify object code for the sample filter.
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------


#ifndef _MACROS_H
#define _MACROS_H


// =================================================================
// Defines
#define FALL_THROUGH    // For informational purpose in a switch statement
#define NOTHING // For informational purpose  in a for loop
#define IM_NAME_LENGTH 0x2e // = len ("\Device\<Guid>") in unicode

// =================================================================
// string constants
//

static const WCHAR c_szAtmEpvcP[]               = L"ATMEPVCP";
static const WCHAR c_szEpvcDevice[]             = L"Device";

const WCHAR c_szSFilterParams[]         = L"System\\CurrentControlSet\\Services\\ATMEPVCP\\Parameters";
const WCHAR c_szSFilterNdisName[]       = L"ATMEPVCP";
const WCHAR c_szAtmAdapterPnpId[]       = L"AtmAdapterPnpId";
const WCHAR c_szUpperBindings[]         = L"UpperBindings";
const WCHAR c_szDevice[]                = L"\\Device\\"; 
const WCHAR c_szInfId_MS_ATMEPVCM[]     = L"MS_ATMEPVCM";
const WCHAR c_szBackslash[]             = L"\\";
const WCHAR c_szParameters[]            = L"Parameters";
const WCHAR c_szAdapters[]              = L"Adapters";
const WCHAR c_szRegKeyServices[]        = L"System\\CurrentControlSet\\Services";
const WCHAR c_szRegParamAdapter[]       = L"System\\CurrentControlSet\\Services\\ATMEPVCP\\Parameters\\Adapters";
const WCHAR c_szIMMiniportList[]            = L"IMMiniportList";
const WCHAR c_szIMiniportName[]         = L"Name";






// ====================================================================
// macros to be used.
//



#define ReleaseAndSetToNull(_O) \
    ReleaseObj(_O);             \
    _O = NULL ;             


#define TraceBreak(_s)  TraceMsg(_s);BREAKPOINT();              



#define MemAlloc(_Len) malloc(_Len);

#define MemFree(_pv)  free(_pv);

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))


    
;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\proto.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       P R O T O . H
//
//  Contents:   Local declarations for the Notify object code for the sample filter.
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------


#ifndef _PROTOS_H
#define PROTOS_H


LRESULT 
CALLBACK 
SampleFilterDialogProc(
    HWND hWnd, 
    UINT uMsg,
    WPARAM wParam, 
    LPARAM lParam
    )   ;

    
UINT 
CALLBACK 
SampleFilterPropSheetPageProc(
    HWND hWnd, 
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    );


    
HRESULT 
HrOpenAdapterParamsKey(
    GUID* pguidAdapter,
    HKEY* phkeyAdapter
    );

    

ULONG 
ReleaseObj(
    IUnknown* punk
    );


ULONG 
AddRefObj (
    IUnknown* punk
    );





typedef enum _ADD_OR_REMOVE
{
    AddMiniport,
    RemoveMiniport

} ADD_OR_REMOVE;


HRESULT
HrAddOrRemoveAdapter (
    INetCfg*            pnc,
    PCWSTR              pszComponentId,
    ADD_OR_REMOVE       AddOrRemove,
    INetCfgComponent**  ppnccMiniport
    );


HRESULT
HrInstallAdapter (
    INetCfgClassSetup*  pSetupClass,
    PCWSTR           pszComponentId,
    INetCfgComponent**  ppncc
    );


HRESULT
HrDeInstallAdapter (
    INetCfgClass*       pncClass,
    INetCfgClassSetup*  pSetupClass,
    PCWSTR              pszComponentId
    );

HRESULT
HrGetLastComponentAndInterface (
    INetCfgBindingPath* pNcbPath,
    INetCfgComponent** ppncc,
    PWSTR* ppszInterfaceName);




//
// Reg.cpp functions begin here
//


HRESULT
HrRegOpenAdapterKey (
    IN PCWSTR pszComponentName,
    IN BOOL fCreate,
    OUT HKEY* phkey);


HRESULT
HrRegOpenAdapterGuid(
    IN HKEY phkeyAdapters,
    IN PGUID pAdapterGuid,
    IN BOOL fCreate,
    OUT HKEY *phGuidKey
    );


HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition);


HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult);

HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult);


HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCWSTR pszRemoveKey);



HRESULT
HrRegOpenAString(
    IN CONST WCHAR *pcszStr ,
    IN BOOL fCreate,
    OUT PHKEY phKey 
    );

ULONG
CbOfSzAndTermSafe (
    IN PCWSTR psz);



HRESULT 
HrRegSetSz (
    HKEY hkey, 
    PCWSTR pszValueName, 
    PCWSTR pszValue
    );


HRESULT
HrRegSetValueEx (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    IN const BYTE *pbData,
    IN DWORD cbData);


HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCWSTR pszValueName);

HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN OUT LPDWORD pcchSubkeyName,
    OUT PWSTR  pszClass,
    IN OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime);



HRESULT
HrRegQueryTypeWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    DWORD   dwType,
    LPBYTE* ppbValue,
    DWORD*  pcbValue);


HRESULT
HrRegQueryValueWithAlloc (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize);


HRESULT
HrRegQueryValueEx (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    OUT LPDWORD   pdwType,
    OUT LPBYTE    pbData,
    OUT LPDWORD   pcbData);


HRESULT
HrRegQuerySzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue);

HRESULT
HrRegQueryMultiSzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue);

HRESULT 
HrRegSetSz (
    HKEY hkey, 
    PCWSTR pszValueName, 
    PCWSTR pszValue
    );
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P C H . H
//
//  Contents:   Pre-compiled header file for the sample filter
//
//  Notes:
//
//----------------------------------------------------------------------------

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <initguid.h>
#include <devguid.h>
#include <MyString.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\resource.h ===
//#include <ncres.h>

#pragma once

#define IDR_REG_SAMPLE_FILTER 40001

#define IDD_SAMPLE_FILTER_GENERAL 1850
#define IDC_PARAM1                1851
#define IDC_BundleId              1852
#define IDC_UpperBindings         1853
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\sfilter.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S F I L T E R . C P P
//
//  Contents:   Notify object code for the sample filter.
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "sfilter.h"
#include "proto.h"
#include "macros.h"



//+---------------------------------------------------------------------------
//
//  Function:   ReleaseObj
//
//  Purpose:    Release an object pointed to by punk by calling
//              punk->Release();
//
//  Arguments:
//      punk [in]   Object to be Released'd. Can be NULL.
//
//  Returns:    Result of Release call.
//
//
//  Notes:      Using this function to Release an object .
//

inline 
ULONG 
ReleaseObj(
	IUnknown* punk
	)
{
    return (punk) ? punk->Release () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefObj
//
//  Purpose:    AddRef's the object pointed to by punk by calling
//              punk->AddRef();
//
//  Arguments:
//      punk [in]   Object to be AddRef'd. Can be NULL.
//
//  Returns:    Result of AddRef call.
//
//
//  Notes:      Using this function to AddRef an object will reduce
//              our code size.
//
inline 
ULONG 
AddRefObj (
    IUnknown* punk
    )
{
    return (punk) ? punk->AddRef () : 0;
}





//+---------------------------------------------------------------------------
//
// Function:  CIMMiniport::CIMMiniport
//
// Purpose:   constructor for class CIMMiniport
//
// Arguments: None
//
// Returns:
//
// Notes:
//
CIMMiniport::CIMMiniport(VOID)
{  

    m_fDeleted 			= FALSE;
    m_fNewIMMiniport 	= FALSE;

    m_fCreateMiniportOnPropertyApply = FALSE;
    m_fRemoveMiniportOnPropertyApply = FALSE;
    pNext = NULL;
    pOldNext = NULL;
    return;
	
}


//+---------------------------------------------------------------------------
//
// Function:  CUnderlyingAdapter::CUnderlyingAdapter
//
// Purpose:   constructor for class CUnderlyingAdapter
//
// Arguments: None
//
// Returns:
//
// Notes:
//
CUnderlyingAdapter::CUnderlyingAdapter(VOID)
{  
	m_fBindingChanged = FALSE;
	m_fDeleted = FALSE;
	pNext = NULL;
	m_pOldIMMiniport = NULL;
	m_pIMMiniport = NULL;
	m_NumberofIMMiniports = 0;
	
}


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::CBaseClass
//
// Purpose:   constructor for class CBaseClass
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CBaseClass::CBaseClass(VOID) :
        m_pncc(NULL),
        m_pnc(NULL),
        m_eApplyAction(eActUnknown),
        m_pUnkContext(NULL)
{
    TraceMsg(L"--> CBaseClass::CBaseClass\n");

    m_cAdaptersAdded   = 0;
    m_fDirty  			= FALSE;
    m_fUpgrade 			= FALSE;
    m_fValid 			= FALSE;
    m_fNoIMMinportInstalled = TRUE;
    m_pUnderlyingAdapter = NULL;
}


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::~CBaseClass
//
// Purpose:   destructor for class CBaseClass
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CBaseClass::~CBaseClass(VOID)
{
    TraceMsg(L"--> CBaseClass::~CBaseClass\n");

    // release interfaces if acquired

    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);
    ReleaseObj(m_pUnkContext);
}

// =================================================================
// INetCfgNotify
//
// The following functions provide the INetCfgNotify interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
STDMETHODIMP 
CBaseClass::
Initialize(
	INetCfgComponent* pnccItem,
        INetCfg* pnc, 
        BOOL fInstalling
        )
{
	HRESULT hr = S_OK;
    TraceMsg(L"--> CBaseClass::Initialize\n");
    

    // save INetCfg & INetCfgComponent and add refcount

    m_pncc = pnccItem;
    m_pnc = pnc;

    if (m_pncc)
    {
        m_pncc->AddRef();
    }
    if (m_pnc)
    {
        m_pnc->AddRef();
    }


    //
    // If this not an installation, then we need to 
    // initialize all of our data and classes
    //
    if (!fInstalling)
    {
        hr = HrLoadConfiguration();
    }

	


    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure SampleFilter
//
// Arguments:
//    pszAnswerFile    [in]  name of AnswerFile
//    pszAnswerSection [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CBaseClass::ReadAnswerFile(PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    TraceMsg(L"--> CBaseClass::ReadAnswerFile\n");

    PCWSTR pszParamReadFromAnswerFile = L"ParamFromAnswerFile";

    // We will pretend here that szParamReadFromAnswerFile was actually
    // read from the AnswerFile using the following steps
    //
    //   - Open file pszAnswerFile using SetupAPI
    //   - locate section pszAnswerSection
    //   - locate the required key and get its value
    //   - store its value in pszParamReadFromAnswerFile
    //   - close HINF for pszAnswerFile

    // Now that we have read pszParamReadFromAnswerFile from the
    // AnswerFile, store it in our memory structure.
    // Remember we should not be writing it to the registry till
    // our Apply is called!!
    //

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CBaseClass::Install(DWORD dw)
{
    TraceMsg(L"--> CBaseClass::Install\n");

    // Start up the install process
    HRESULT hr = S_OK;
    ULONG State = 0;

    m_eApplyAction = eActInstall;

    TraceMsg(L"--> Installing the miniport\n");

  	m_fValid = TRUE;

  	//
  	// Add devices in the NotyfBindingAdd routine
  	//
  	
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
STDMETHODIMP CBaseClass::Removing(VOID)
{
    TraceMsg(L"--> CBaseClass::Removing\n");

    HRESULT     hr = S_OK;

    m_eApplyAction = eActRemove;
    

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::Cancel
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::CancelChanges(VOID)
{
    TraceMsg(L"--> CBaseClass::CancelChanges\n");


    //
    // Remove a device here if necessary, if the miniport has been Added (Installed)
    // but not Applied to the Registry
    //

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
//
STDMETHODIMP CBaseClass::ApplyRegistryChanges(VOID)
{
    TraceMsg(L"--> CBaseClass::ApplyRegistryChanges\n");
    BREAKPOINT();

    HRESULT hr=S_OK;




	if (m_fValid && m_fDirty)
    {
    	//
    	// TODO Do We need this?
    	//
        // UpdateElanDisplayNames();

        // flush out the registry and send reconfig notifications
        hr = HrFlushConfiguration();
    }

		
	//
	// Failure Unwrap
	//
    if (FAILED(hr))
    {

    	
		TraceMsg(L"  Failed to apply registry changes \n");
		
        hr = S_OK;
    }
	

    // do things that are specific to a config action
    // TODO _ move the install down here 

	TraceMsg(L"<-- CBaseClass::ApplyRegistryChanges hr %x\n", hr);

    return hr;
}
















STDMETHODIMP
CBaseClass::ApplyPnpChanges(
    IN INetCfgPnpReconfigCallback* pICallback)
{
    WCHAR szDeviceName[64];

	TraceMsg(L"--> CBaseClass::ApplyPnpChanges\n" );



/*    pICallback->SendPnpReconfig (
        NCRL_NDIS,
        c_szSFilterNdisName,
        szDeviceName,
        m_sfParams.m_szBundleId,
        (wcslen(m_sfParams.m_szBundleId) + 1) * sizeof(WCHAR));
*/
	TraceMsg(L"<-- CBaseClass::ApplyPnpChanges \n");
    return S_OK;
}

// =================================================================
// INetCfgSystemNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::GetSupportedNotifications
//
// Purpose:   Tell the system which notifications we are interested in
//
// Arguments:
//    pdwNotificationFlag [out]  pointer to NotificationFlag
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::GetSupportedNotifications(
        OUT DWORD* pdwNotificationFlag)
{
    TraceMsg(L"--> CBaseClass::GetSupportedNotifications\n");

    *pdwNotificationFlag = NCN_NET | NCN_NETTRANS | NCN_ADD | NCN_REMOVE;

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::SysQueryBindingPath
//
// Purpose:   Allow or veto formation of a binding path
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::SysQueryBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    TraceMsg(L"--> CBaseClass::SysQueryBindingPath\n");

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::SysNotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbpItem    [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::SysNotifyBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem)
{
    TraceMsg(L"--> CBaseClass::SysNotifyBindingPath\n");

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::SysNotifyComponent
//
// Purpose:   System tells us by calling this function which
//            component has undergone a change (installed/removed)
//
// Arguments:
//    dwChangeFlag [in]  type of system change
//    pncc         [in]  pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::SysNotifyComponent(DWORD dwChangeFlag,
        INetCfgComponent* pncc)
{
    TraceMsg(L"--> CBaseClass::SysNotifyComponent\n");

    return S_OK;
}








// =================================================================
// INetCfgComponentNotifyBinding Interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::QueryBindingPath
//
// Purpose:  This is specific to the component being installed. This will 
//            ask us if we want to bind to the Item being passed into
//            this routine. We can veto by returning NETCFG_S_DISABLE_QUERY 
//
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbpItem    [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBaseClass::QueryBindingPath(
	IN DWORD dwChangeFlag,  
	IN INetCfgBindingPath *pncbpItem  
  )
  
{
    TraceMsg(L"-- CBaseClass::QueryBindingPath\n");


    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBaseClass::NotifyBindingPath
//
// Purpose:  We are now being told to bind to the component passed to us. 
//           Use this to get the guid and populate
//           Services\<Protocol>\Parameters\Adapters\<Guid> field
//
//
// Arguments:
//    dwChangeFlag [in]  type of system change
//    pncc         [in]  pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP 
CBaseClass::
NotifyBindingPath(
	IN DWORD dwChangeFlag,  
	IN INetCfgBindingPath *pncbpItem  
  	)
{
	HRESULT hr = S_OK;
	PWSTR pszBindName = NULL;
    INetCfgComponent* pnccLastComponent = NULL;
	DWORD 	dwMyChangeFlag = 0; 	


    TraceMsg(L"--> CBaseClass::NotifyBindingPath\n");
    BREAKPOINT();
	//
	// The flags will tell us if a binding is being added.
	// If the adapter is being added, then we will also be told if 
	// this is to Enabled or Disabled
	//

	do
	{


		//
		// First, get the component from the bind object
		//
		hr = HrGetLastComponentAndInterface(pncbpItem,
                                            &pnccLastComponent, NULL);
        if (S_OK != hr)
		{
			TraceMsg(L"HrGetLastComponentAndInterface Failed");
			pnccLastComponent = NULL;
			break;
		}

		//
		// Get the name of the new component
		//

		hr = pnccLastComponent->GetBindName(&pszBindName);

        if (S_OK != hr)
		{
			TraceMsg(L"GetBindName Failed");
			pszBindName = NULL;
			break;
		}


		//
		//  Do the add/remove depending on the flags
		//
		TraceMsg (L"dwChangeFlag %x\n", dwChangeFlag);

		//
		// Isolate the Change Flags
		//
		dwMyChangeFlag = (NCN_ADD | NCN_REMOVE | NCN_UPDATE);
		dwMyChangeFlag &= dwChangeFlag;

		switch (dwMyChangeFlag)
		{
			case NCN_ADD :
			{
				TraceMsg (L" Binding Notification - add\n");

	        	hr = HrNotifyBindingAdd(pnccLastComponent, pszBindName);

		        if (S_OK != hr)
				{
					TraceMsg(L"HrNotifyBindingAdd Failed");
				}

				
				break;
			}
			case NCN_REMOVE :
			{
				TraceMsg (L" Binding Notification - remove\n");			

                hr = HrNotifyBindingRemove(pnccLastComponent, pszBindName);
                
		        if (S_OK != hr)
				{
					TraceMsg(L"HrNotifyBindingRemove Failed");
				}
			
				break;
			}
			case NCN_UPDATE:
			{
				TraceMsg (L" Binding Notification - NCN_UPDATE\n");			

			}
			default: 
			{
				TraceMsg(L"  Invalid Switch Opcode %x\n", dwMyChangeFlag);
			}




		}
		
    	//
    	// simply mark the adapter as changed so we don't send 
    	// add / remove notifications
    	//
		
		this->m_pUnderlyingAdapter->m_fBindingChanged = TRUE;

		

	} while (FALSE);


	//
	// Free all locally allocated structure
	//
	if (pszBindName != NULL)
	{
    	CoTaskMemFree (pszBindName);
    }

    
	ReleaseObj (pnccLastComponent);
		

    TraceMsg(L"<-- CBaseClass::NotifyBindingPath %x\n", hr);
	

    return hr;
}









// ------------ END OF NOTIFY OBJECT FUNCTIONS --------------------





// -----------------------------------------------------------------
//
//  Utility Functions
//

HRESULT HrGetBindingInterfaceComponents (
    INetCfgBindingInterface*    pncbi,
    INetCfgComponent**          ppnccUpper,
    INetCfgComponent**          ppnccLower)
{
    HRESULT hr=S_OK;

    // Initialize output parameters
    *ppnccUpper = NULL;
    *ppnccLower = NULL;

    INetCfgComponent* pnccUpper;
    INetCfgComponent* pnccLower;

    hr = pncbi->GetUpperComponent(&pnccUpper);
    if (SUCCEEDED(hr))
    {
        hr = pncbi->GetLowerComponent(&pnccLower);
        if (SUCCEEDED(hr))
        {
            *ppnccUpper = pnccUpper;
            *ppnccLower = pnccLower;
        }
        else
        {
            ReleaseObj(pnccUpper);
        }
    }

    return hr;
}

HRESULT HrOpenAdapterParamsKey(GUID* pguidAdapter,
                               HKEY* phkeyAdapter)
{
    HRESULT hr=S_OK;

    HKEY hkeyServiceParams;
    WCHAR szGuid[48];
    WCHAR szAdapterSubkey[128];
    DWORD dwError;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegParamAdapter,
                     0, KEY_ALL_ACCESS, &hkeyServiceParams))
    {
        StringFromGUID2(*pguidAdapter, szGuid, 47);
        _stprintf(szAdapterSubkey, L"\\%s", szGuid);
        if (ERROR_SUCCESS !=
            (dwError = RegOpenKeyEx(hkeyServiceParams,
                                    szAdapterSubkey, 0,
                                    KEY_ALL_ACCESS, phkeyAdapter)))
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
        RegCloseKey(hkeyServiceParams);
    }

    return hr;
}

#if DBG
void TraceMsg(PCWSTR szFormat, ...)
{
    static WCHAR szTempBuf[4096];

    va_list arglist;

    va_start(arglist, szFormat);

    _vstprintf(szTempBuf, szFormat, arglist);
    OutputDebugString(szTempBuf);

    va_end(arglist);
}

#endif


// ----------------------------------------------------------------------
//
// Function:  HrAddOrRemoveAdapter 
//   
//    
// 
// Purpose:   Its purpose is to add or remove an IM adapter to the system 
//
// Arguments:
//    
// Returns:
//
// Notes:
//


HRESULT
HrAddOrRemoveAdapter (
    INetCfg*            pnc,
    PCWSTR              pszComponentId,
    ADD_OR_REMOVE		AddOrRemove,
    INetCfgComponent**  ppnccMiniport
    )
{
	HRESULT hr = S_OK;
    INetCfgClass* pncClass = NULL;
	INetCfgClassSetup* pncClassSetup = NULL;

	TraceMsg (L"->HrAddOrRemoveAdapter \n");
	BREAKPOINT();

	do 
	{

		//
		//  Lets get Interface that represents all adapters
		//
		TraceMsg(L" Calling QueryNetCfgClass \n");
		
	    hr = pnc->QueryNetCfgClass (&GUID_DEVCLASS_NET, 
	                                         IID_INetCfgClass,  // we want InetCfg class
	                                         reinterpret_cast<void**>(&pncClass));  // store the return object here
	    if (S_OK != hr)
	    {
			TraceBreak (L"HrAddOrRemoveAdapter  QueryNetCfgClass \n");
			break;
	    }

	    
	    
		//
		// Now lets get the SetupClass that corresponds to our Net cfg Class
		//
		TraceMsg(L"Calling QueryInterface  \n");

	    hr = pncClass->QueryInterface (IID_INetCfgClassSetup,
	            						reinterpret_cast<void**>(&pncClassSetup));

	    if (S_OK != hr)
	    {

			TraceBreak (L"HrAddOrRemoveAdapter  QueryInterface  \n");
			break;
		
		}        


	    if (AddOrRemove == AddMiniport)
	    {

			TraceMsg(L" Calling  HrInstallAdapter \n");
			
			hr = HrInstallAdapter (pncClassSetup,  // the setup class
			                 pszComponentId,  // which device to add
			                 ppnccMiniport
			                 );  
	        
	    }
	    else
		{
			TraceMsg(L"Calling  HrDeInstallAdapter  \n");
			
			hr = HrDeInstallAdapter (pncClass,
                                     pncClassSetup,
                                     pszComponentId
                                     );
                                

		}


	    // Normalize the HRESULT.
	    // Possible values of hr at this point are S_FALSE,
	    // NETCFG_S_REBOOT, and NETCFG_S_STILL_REFERENCED.
	    //
	    if (! SUCCEEDED(hr))
	    {
			TraceBreak (L"HrAddOrRemoveAdapter  Install Or  DeInstall\n");
			hr = S_OK;
			break;
	    }


	} while (FALSE);

	if (pncClassSetup)
	{
	    ReleaseObj( pncClassSetup);
	}

	if (pncClass)
	{
		ReleaseObj (pncClass);

	}
	
    TraceMsg (L"<--HrAddOrRemoveAdapter hr %x\n", hr );
    return hr;
}






// ----------------------------------------------------------------------
//
// Function:  HrInstallAdapter 
//   
//    
// 
// Purpose:   This install the IM adapter 
//
// Arguments:
//  
//   pSetupClass 		: The setup class that can install the IM miniport
//   pszComponentId		: The PnP Id of the IM miniport
//   ppncc 				: The component that was just installed
//
//
// Returns:
//
// Notes:
//


HRESULT
HrInstallAdapter (
	INetCfgClassSetup*  pSetupClass,
    PCWSTR           pszComponentId,
    INetCfgComponent**  ppncc
	)
{

	HRESULT hr;
	
	hr = pSetupClass->Install(pszComponentId , 
	                          NULL , 			// OboToken
	                          0,     			// dwSetupFlags	
	                          0, 				// dwUpgradeFromBuildNo
	                          NULL , 			// pszwAnswerFile
	                          NULL , 			// pszwAnswerSections
	                          ppncc );			// Output - Miniport Component

    TraceMsg (L"HrInstallAdapter hr %x\n", hr );

	return hr;
}



// ----------------------------------------------------------------------
//
// Function:  HrDeInstallAdapter 
//   
//    
// 
// Purpose:   This uninstalls the IM adapter 
//
// Arguments:
//    pncClass,
//	  pSetupClass,
//    pszComponentId
//
// Returns:
//
// Notes:
//

HRESULT
HrDeInstallAdapter (
	INetCfgClass* 		pncClass,
	INetCfgClassSetup*  pSetupClass,
    PCWSTR              pszComponentId
	)

{

	HRESULT hr;

    // Find and remove the component.
    //
    INetCfgComponent* pncMiniport;

    TraceMsg (L"->HrDeInstallAdapter \n");

	do
	{
		//
		// Lets find our miniport
		//
	    hr = pncClass->FindComponent (pszComponentId, &pncMiniport);

	    if (S_OK != hr)
	    {
			break;
	    }

	    //
	    // Use the setup class to de install our miniport
	    //
	    TraceMsg (L" Calling DeInstall hr %x\n", hr );

	    hr = pSetupClass->DeInstall (pncMiniport,
	                				 NULL, 
	                				 NULL);

		//
		// Release the object as we are done with it
		//
		
		ReleaseObj (pncMiniport);

    } while (FALSE);


	TraceMsg (L"<-HrRemoveAdapter hr %x", hr );

	return hr;	



}










//-----------------------------------------------------------------------  
//  Private methods asocciated with the classes
//-----------------------------------------------------------------------


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrNotifyBindingAdd 
//   
// Purpose:   The notification is to our protocol. It informs us that a 
//             a physical  adapter is being added to our protocol's entry
//
// Arguments:
//    pnccAdapter		: The adapter  being added, Use it to get the GUID 
//	  pszBindName		: The name of the adapter (Should be in the form of a Guid)
//
// Returns:
//
// Notes:
//

HRESULT
CBaseClass::HrNotifyBindingAdd (
    INetCfgComponent* pnccAdapter,
    PCWSTR pszBindName)
{
    HRESULT hr = S_OK;

    // we should see if this adapter is
    // is already in our list but marked as for deletion. If so, simply unmark
    // the adapter and all of it's Elans. The Binding Add could be a fake one
    // when it is in uprade process.

    BOOL 								fFound = FALSE;
    CUnderlyingAdapter*  	pAdapterInfo  = NULL;
	INetCfgComponent*   				pnccNewMiniport = NULL;
	CIMMiniport* 			pIMMiniport = NULL;
	ADD_OR_REMOVE						Add  = AddMiniport;


	TraceMsg (L"-->HrNotifyBindingAdd psBindName %x\n",pszBindName );

	pAdapterInfo  = this->GetUnderlyingAdaptersListHead();


	//
	//  Search the entire list to see if this adapter (binding) has
	//  already been added
	//
	BREAKPOINT();
	while (pAdapterInfo != NULL && fFound == FALSE)
	{
	    //  search the in-memory list for this adapter

	    if (!lstrcmpiW(pszBindName, pAdapterInfo->SzGetAdapterBindName()))
	    {
	        fFound = TRUE;
	        break;
	    }

	    //
	    // Move to the next Adapter here
	    //
	    pAdapterInfo = pAdapterInfo->GetNext();
	}



	do
	{
	
	    if (fFound) // Add an old adapter back
	    {

			//
	        // mark it un-deleted
			//
	        pAdapterInfo->m_fDeleted = FALSE;

			//
			// No more to do
			//
	        break;

	    }


		//
		// We have a new underlying adapter
		//
	    
		//
		//  Create a new in-memory adapter object
		//
        pAdapterInfo = new CUnderlyingAdapter;


        if (pAdapterInfo == NULL)
        {	
			TraceMsg (L"pAdapterInfo Allocation Failed\n");
			break;
        }

        //
        // Get the Guid for the new adapter
        //
        GUID guidAdapter;
        hr = pnccAdapter->GetInstanceGuid(&guidAdapter); 

        if (S_OK != hr)
	    {
			TraceMsg (L"GetInstanceGuid Failed\n");
			break;

        }

		//
		// Update the Adapter's Guid here
		//
		pAdapterInfo->m_AdapterGuid  = guidAdapter;
        
		//
        // the adapter is newly added
		//
		pAdapterInfo->m_fBindingChanged = TRUE;

		//
        // Set the bind name of the adapter
		//
		pAdapterInfo->SetAdapterBindName(pszBindName);

		//
        // Get the PnpId of the adapter
        //
		PWSTR pszPnpDevNodeId = NULL;
		
        hr = pnccAdapter->GetPnpDevNodeId(&pszPnpDevNodeId);

        if (S_OK != hr)
        {
			TraceMsg (L"GetPnpDevNodeId  Failed\n");
			break;
        
		}

		//
		// Update the PnP Id in our structure
		//
        pAdapterInfo->SetAdapterPnpId(pszPnpDevNodeId);
        CoTaskMemFree(pszPnpDevNodeId);


		//
		// Allocate memory for our IM Miniport that corresponds to 
		// this physical adapter
		//
		pIMMiniport = new CIMMiniport();

		
		if (pIMMiniport == NULL)
        {
			TraceMsg (L"pIMMiniport Allocation Failed\n");
			break;
        }

		
        //
        // Now lets add our IM miniport which corresponds to 
        // this adapter
        //
        TraceMsg(L" About to Add IM miniport \n");
		
        pIMMiniport->m_fNewIMMiniport = TRUE;
        
    	

        hr = HrAddOrRemoveAdapter(this->m_pnc, 				// NetConfig class
		                          c_szInfId_MS_ATMEPVCM,  	// Inf file to use,
        		                  Add,						// Add a miniport
                		          &pnccNewMiniport);  		// new miniport

        if (SUCCEEDED(hr) == FALSE)
        {
		    TraceMsg(L"HrAddOrRemoveAdapter failed\n");
		    pnccNewMiniport = NULL;
			break;
		}


        TraceMsg(L" Updating IM miniport strings \n");
		            
		//
        //  Update the BindName
        //
        PWSTR pszIMBindName;

        
        hr = pnccNewMiniport->GetBindName(&pszIMBindName);

        if (S_OK != hr)
        {
		    TraceMsg(L"Get Bind Name Failed \n");
		    pszIMBindName = NULL;
			break;
        }

        
        TraceMsg(L" IM BindName %x\n",pszIMBindName );

                    
        pIMMiniport->SetIMMiniportBindName(pszIMBindName);
        CoTaskMemFree(pszIMBindName);

		//
        //  Update the Device param
        //
        tstring strIMMiniport;
        strIMMiniport= c_szDevice;
        strIMMiniport.append(pIMMiniport->SzGetIMMiniportBindName());

		TraceMsg (L"Setting IM Device Name\n");
        pIMMiniport->SetIMMiniportDeviceName(strIMMiniport.c_str());

		

        TraceMsg(L" IM Device Name  %s\n",strIMMiniport.c_str());


		{
			//
			// TODO This is different than ATMALNE 
			// Set up a display name
			//
			tstring     strNewDisplayName = L"Ethernet ATM Miniport";

			(VOID)pnccNewMiniport->SetDisplayName(strNewDisplayName.c_str());



		}



		pAdapterInfo->AddIMiniport(pIMMiniport); 

		this->AddUnderlyingAdapter(pAdapterInfo);


		if (this->m_pUnderlyingAdapter == NULL)
		{
			TraceMsg(L"m_pUnderlyingAdapter  == NULL\n");
			BREAKPOINT();
		} 

		if (pAdapterInfo->m_pIMMiniport == NULL)
		{
			TraceMsg(L"pAdapterInfo->m_pIMMiniport == NULL\n");
			BREAKPOINT();

		}


        //  Mark the in-memory configuration dirty
        m_fDirty = TRUE;


        ReleaseObj(pnccNewMiniport);
    
		hr = S_OK;



	} while (FALSE);

	if (S_OK != hr)
    {
		//
		// Failure CleanUp. 
		//
        TraceMsg(L" Main loop in HrAdd Adapter has failed\n");
		
		BREAKPOINT();
		
		//
		// remove the IM miniport if necessary
		//

		if(pAdapterInfo != NULL)
		{
			delete pAdapterInfo;
			pAdapterInfo = NULL;
		}

		if (pIMMiniport != NULL)
		{
			delete pIMMiniport;
			pIMMiniport = NULL;
		}

    }

	TraceMsg (L"<--HrNotifyBindingAdd \n");
    return hr;
}









// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrNotifyBindingRemove  
//   
// Purpose:   The notification is to our protocol. It informs us that a 
//             a physical  adapter is being unbound from our protocol.
//             We need to verify that this adapter exists and if so remove
//             its associated IM miniport
//
// Arguments:
//    pnccAdapter		: The adapter  being added,  
//	  pszBindName		: The name of the adapter
//
// Returns:
//
// Notes:
//



HRESULT
CBaseClass::
HrNotifyBindingRemove (
    INetCfgComponent* pnccAdapter,
    PCWSTR pszBindName)
{
    HRESULT hr = S_OK;
    CUnderlyingAdapter 	*pAdapterInfo= NULL;
	CIMMiniport			*pIMMiniport = NULL;


	TraceMsg (L"--> HrNotifyBindingRemove \n");
 
    //  search the in-memory list for this adapter
    BOOL    fFound = FALSE;



	pAdapterInfo = this->GetUnderlyingAdaptersListHead();


	//
	//  Search the entire list to see if this adapter (binding) has
	//  already been added
	//
	while (pAdapterInfo != NULL && fFound == FALSE)
	{
	    //  search the in-memory list for this adapter

		TraceMsg (L" pszBindName %x m_strAdapterBindName %x\n",
		           pszBindName, 
		           pAdapterInfo->SzGetAdapterBindName() );
 
        if (!lstrcmpiW (pszBindName, pAdapterInfo->SzGetAdapterBindName()))
        {
            fFound = TRUE;
            break;
		}

	    //
	    // Move to the next Adapter here
	    //
	    pAdapterInfo = pAdapterInfo->GetNext();
	}





	TraceMsg (L"-- HrNotifyBindingRemove fFound %x\n", fFound);

	do 
	{


	    if (fFound == FALSE)
	    {

			TraceBreak (L" HrNotifyBindingRemove fFound FALSE\n");

			break;
	    }


		//
        // mark it deleted
        //
        pAdapterInfo->m_fDeleted = TRUE;

		//
        // mark as binding changed
        //
        pAdapterInfo->m_fBindingChanged = TRUE;

		//
        // if this is upgrade, then do not delete its associated IM miniport 
        // otherwise, delete them now
        //
        HRESULT hrIm = S_OK;

		pIMMiniport  = pAdapterInfo->m_pIMMiniport;


        if (m_fUpgrade == FALSE)
        {
        	//
        	// TODO ; Atm Lane does something special on upgrades
        	//
			//break;
        }

		TraceMsg (L" About to remove a miniport instance\n");
        //
        // Remove corresponding miniport.
        //
        hrIm = HrRemoveMiniportInstance(pIMMiniport->SzGetIMMiniportBindName());

        if (SUCCEEDED(hrIm))
        {
            pIMMiniport->m_fDeleted = TRUE;
        }
        else
        {
            TraceMsg(L"HrRemoveMiniportInstance failed", hrIm);
            hrIm = S_OK;
        }
        
		//
        // mark the in-memory configuration dirty
        //
        this->m_fDirty = TRUE;
    
	    
	} while (FALSE);
	
	TraceMsg (L"<-- HrNotifyBindingRemove hr %x\n", hr);
    return hr;
}









// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrRemoveMiniportInstance 
//   
// Purpose:   The notification is to our protocol. It informs us that a 
//             a physical  adapter is being unbound from our protocol.
//             We need to verify that this adapter exists and if so remove
//             its associated IM miniport
//
// Arguments:
//    pnccAdapter		: The adapter  being added,  
//	  pszBindName		: The name of the adapter
//
// Returns:
//
// Notes:
//




HRESULT 
CBaseClass::
HrRemoveMiniportInstance(
	PCWSTR  pszBindNameToRemove
	)
{
    // Enumerate adapters in the system.
    //
    HRESULT 				hr = S_OK;
    BOOL 					fRemove = FALSE;
    INetCfgComponent* 		pnccAdapterInstance = NULL;


    GUID	GuidClass;

    TraceMsg (L"--> HrRemoveMiniportInstance hr %x\n", hr);

	    


	do
	{

		hr = HrFindNetCardInstance(pszBindNameToRemove,
		                           &pnccAdapterInstance );

		if (hr != S_OK)
		{
			TraceBreak(L"HrRemoveMiniportInstance  HrFindNetCardInstance FAILED \n");
			pnccAdapterInstance  = NULL;
			break;
		}

		
		

	    hr = HrRemoveComponent( this->m_pnc, 
	                             pnccAdapterInstance);
		if (hr != S_OK)
		{
			TraceBreak(L"HrRemoveMiniportInstance  HrRemoveComponent FAILED \n");
			pnccAdapterInstance  = NULL;
			break;
		}

	} while (FALSE);

	//
	// Free memory and locally allocated objects
	//
	
    ReleaseAndSetToNull (pnccAdapterInstance );
  
		



	TraceMsg (L"<-- HrRemoveMiniportInstance hr %x\n", hr);

    return hr;
}




// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrNotifyBindingAdd 
//   
// Purpose:   The notification is to our protocol. It informs us that a 
//             a physical  adapter is being unbound from our protocol.
//             We need to verify that this adapter exists and if so remove
//             its associated IM miniport
//
// Arguments:
//    pnccAdapter		: The adapter  being added,  
//	  pszBindName		: The name of the adapter
//
// Returns:
//
// Notes:
//

HRESULT
CBaseClass::HrRemoveComponent (
    INetCfg*            pnc,
    INetCfgComponent*   pnccToRemove
    )
{

	TraceMsg (L"--> HrRemoveComponent \n");

    // Get the class setup interface for this component.
    //
    GUID guidClass;
    HRESULT hr = pnccToRemove->GetClassGuid (&guidClass);

    
    if (SUCCEEDED(hr))
    {
        // Use the class setup interface to remove the component.
        //
        INetCfgClassSetup* pSetup;
        hr = pnc->QueryNetCfgClass (&guidClass,
                            IID_INetCfgClassSetup,
                            reinterpret_cast<void**>(&pSetup));
        if (SUCCEEDED(hr))
        {
            hr = pSetup->DeInstall (pnccToRemove, 
                                    NULL, 
                                    NULL);
            ReleaseObj (pSetup);
        }
    }

    TraceMsg (L"<-- HrRemoveComponent  hr %x\n", hr);

    return hr;
}



//-------------------------------------------------------------
// F U N C T I O N S   U S E D   I N   F L U S H I N G
//-------------------------------------------------------------


// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrFlushConfiguration
//   
// Purpose:  	This is called from the ApplyRegistryChange. We need
//				to modify the registry here. 
//   			
//             
//
//
//
// Arguments:
//
// Returns:
//
// Notes:
//

HRESULT 
CBaseClass::
HrFlushConfiguration()
{
    HRESULT hr  = S_OK;
    HKEY    hkeyAdapterList = NULL;

    //  Open the "Adapters" list key
	TraceMsg (L"--> HrFlushConfiguration  \n");
	
    do
    {
	    hr = HrRegOpenAdapterKey(c_szAtmEpvcP, 
	                            TRUE, 
	                            &hkeyAdapterList);

	    if (S_OK != hr)
	    {
			TraceMsg (L" HrRegOpenAdapterKey FAILED\n");
			break;
	    }



		CUnderlyingAdapter *pAdapterInfo = NULL;

		//
		// Get the first Underlying Adapter
		//
		pAdapterInfo = this->GetUnderlyingAdaptersListHead();

		//
		// Now iterate through each of the adapters
		// and write their configuration to the 
		// registry
		//
		
        HRESULT hrTmp;

		while (pAdapterInfo != NULL)
		{

			//
            //  Flush this adapter's configuration
            //
            hrTmp = HrFlushAdapterConfiguration(hkeyAdapterList, pAdapterInfo);


            if (SUCCEEDED(hrTmp))
            {
                // Raid #255910: only send Elan change notification if the
                // binding to the physical adapter has not changed
                if (!pAdapterInfo->m_fBindingChanged)
                {
                    // Compare Elan list and send notifications
                    hrTmp = HrReconfigEpvc(pAdapterInfo);

                    if (FAILED(hrTmp))
                    {
                        hrTmp = NETCFG_S_REBOOT;
                    }
                }
            }
            else
            {
                TraceMsg(L"HrFlushAdapterConfiguration failed for adapter %x", pAdapterInfo);
                TraceBreak (L"HrFlushAdapterConfiguration  FAILED \n");

	            hrTmp = S_OK;
	            break;
            }

            if (S_OK ==hr)
            {
				hr = hrTmp;
			}

			//
			// Now move to the next adapter
			//
			pAdapterInfo = pAdapterInfo->GetNext();

			//
			// Temporary debugging
			//
			if (pAdapterInfo != NULL)
			{
				TraceBreak (L"pAdapterInfo should be Null\n");
			}
			
        } //while (pAdapterInfo != NULL);
        


        
        RegCloseKey(hkeyAdapterList);

	    
	}while (FALSE);

	TraceMsg (L"<-- HrFlushConfiguration  hr %x \n", hr);


    return hr;








}



// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrFlushAdapterConfiguration
//   
//   
// Purpose:  	This function either deletes or add the Adapter BindName
//              to the registry
//
//
// Arguments:
//
// Returns:
//
// Notes:
//

HRESULT
CBaseClass::
HrFlushAdapterConfiguration(
	HKEY hkeyAdapterList,
    CUnderlyingAdapter *pAdapterInfo
	)
{

    HRESULT hr  = S_OK;

    HKEY    hkeyAdapter     = NULL;
    DWORD   dwDisposition;

	TraceMsg (L"--> HrFlushAdapterConfiguration\n");

    if (pAdapterInfo->m_fDeleted == TRUE)
    {
        //  Adapter is marked for deletion
        //  Delete this adapter's whole registry branch
        hr = HrRegDeleteKeyTree(hkeyAdapterList,
                                pAdapterInfo->SzGetAdapterBindName());
    }
    else
    {
    	

    	//
        // open this adapter's subkey, we are now at 
        // Protocol->Parameters->Adapters
        //
        

        hr = HrRegCreateKeyEx(
                                hkeyAdapterList,
                                pAdapterInfo->SzGetAdapterBindName(),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyAdapter,
                                &dwDisposition);

        if (S_OK == hr)
        {
        
	    	//
	        // open this adapter's subkey, we are now at 
	        // Protocol->Parameters->Adapters->Guid
	        //
            hr = HrFlushMiniportList(hkeyAdapter, pAdapterInfo);

            RegCloseKey(hkeyAdapter);
        }
    }


	TraceMsg (L"<-- HrFlushAdapterConfiguration hr %x\n", hr);
    return hr;





}









// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrFlushMiniportList
//   
//   
// Purpose:  	This function either deletes or add the Adapter BindName
//              to the registry
//
//
// Arguments:
//
// Returns:
//
// Notes:
//

HRESULT 
CBaseClass::
HrFlushMiniportList(
	HKEY hkeyAdapterGuid,
    CUnderlyingAdapter *pAdapterInfo
    )
{
    HRESULT hr  = S_OK;
    DWORD 	dwDisposition = 0;

	CIMMiniport *pIMMiniport = NULL;
	INetCfgComponent 		*pnccIMMiniport = NULL;
	tstring					*pIMMiniportGuid;
	DWORD 					dwNumberOfIMMiniports ; 
	UINT 					i = 0;
	PWSTR					pwstr = NULL;
	UINT					index = 0;
	UINT 					Size = 0;
	HKEY 					hKeyMiniportList = NULL;
	INetCfgComponent 		*pnccAtmEpvc = NULL;
	
	
	TraceMsg (L"--> HrFlushMiniportList \n" );

	do
	{
		//
		//  Open the Elan list subkey
		//
		hr = HrRegCreateKeyEx(
		                        hkeyAdapterGuid,
		                        c_szIMMiniportList,
		                        REG_OPTION_NON_VOLATILE,
		                        KEY_ALL_ACCESS,
		                        NULL,
		                        &hKeyMiniportList,
		                        &dwDisposition);

		if (S_OK != hr)
		{
			TraceBreak (L"--> HrFlushMiniportList HrRegCreateKeyEx FAILED \n" );
			break;

		}
		
		//
		// Iterate through all the IM Miniports on this adapter 
		// and get their string.
		//
		dwNumberOfIMMiniports = pAdapterInfo->DwNumberOfIMMiniports();

		//
		// Get the IM miniport List Head
		//

	
	    
		pIMMiniport = pAdapterInfo->IMiniportListHead();

		

		if (pIMMiniport == NULL)
		{
			TraceBreak (L" HrFlushMiniportList pIMMiniport is Null = FAILED\n" );
			break;
		}

		//
		// Now iterate through all the miniports and 
		// flush them to the registry
		//

		while ( pIMMiniport != NULL)
		{
			//
			//  This function does all the hard work
			//
	     	hr = HrFlushMiniportConfiguration(hKeyMiniportList, 
	     	                                  pIMMiniport);

            if (FAILED(hr))
            {
                TraceBreak(L"HrFlushMiniportConfiguration failure");
                hr = S_OK;
            }

			//
			// If this is a first time addition to the registry
			// we need to write the ATM adapter's Pnp ID to the 
			// registry. This is ATM specific
			//

        	if ((!pIMMiniport->m_fDeleted) && (pIMMiniport->m_fNewIMMiniport))
        	{
				//
				// Find this Miniport and write The PnP Id 
				// of the atm adapter to the registry
				//
                hr = HrFindNetCardInstance(pIMMiniport->SzGetIMMiniportBindName(),
                                           &pnccAtmEpvc);
                if (S_OK == hr)
                {
                    HKEY hkeyMiniport = NULL;

                    hr = pnccAtmEpvc->OpenParamKey(&hkeyMiniport);
                    if (S_OK == hr)
                    {
                    	//
                    	// Write the PnP Id here
                    	//
                        HrRegSetSz(hkeyMiniport, 
                                   c_szAtmAdapterPnpId,
                                   pAdapterInfo->SzGetAdapterPnpId());
                    }
                    
                    RegCloseKey(hkeyMiniport);
                }
                
                ReleaseObj(pnccAtmEpvc);

			} // if ((!pIMMiniport->m_fDeleted) && (pIMMiniport->m_fNewIMMiniport	))
        	

			
			pIMMiniport = pIMMiniport->GetNext();
		                
        }// 		while ( pIMMiniport != NULL)


        RegCloseKey(hKeyMiniportList);
   
     
    }
    while (FALSE);

	//
	// Clean Up
	//  
	
	if (pnccIMMiniport != NULL)
	{
		ReleaseObj(pnccIMMiniport);

	}

	hr = S_OK;

	TraceMsg (L"<-- HrFlushMiniportList hr %x\n", hr);
    return hr;
}




// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrFlushMiniportConfiguration
//   
//   
// Purpose:  	This function either deletes or add the IM Miniport
//              to the registry
//
//
// Arguments:
//	HKEY hkeyMiniportList - Key of the MiniportList, 
//	CIMMiniport pIMMiniport - IM miniport structure 
//
// Returns:
//
// Notes:
//

HRESULT 
CBaseClass::
HrFlushMiniportConfiguration(
	HKEY hkeyMiniportList, 
	CIMMiniport *pIMMiniport
	)

{
	HRESULT hr = S_OK;
	PCWSTR*	pstrDeviceName = NULL;
	TraceMsg (L"--> HrFlushMiniportConfiguration \n");

    if (pIMMiniport->m_fDeleted)
    {

    	hr = HrDeleteMiniport(hkeyMiniportList, 
		                     pIMMiniport);
		                     

    }
    else
    {

    	hr = HrWriteMiniport(hkeyMiniportList, 
		                     pIMMiniport);
		                     
	}
	
	TraceMsg (L"<-- HrFlushMiniportConfiguration %x\n",hr);
	return hr;

}



// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrDeleteMiniport
//   
//   
// Purpose:  	As the miniport needs to be deleted from the registry
//				this function does the deletion
//
//
// Arguments:
//	HKEY hkeyMiniportList - Key of the MiniportList, 
//	CIMMiniport pIMMiniport - IM miniport structure 
//
// Returns:
//
// Notes:
//


HRESULT
CBaseClass::
HrDeleteMiniport(
	HKEY hkeyMiniportList, 
	CIMMiniport *pIMMiniport
	)
{
	HRESULT hr = S_OK;
	TraceMsg (L"--> HrDeleteMiniport \n");



    PCWSTR szBindName = pIMMiniport->SzGetIMMiniportBindName();

    if (lstrlenW(szBindName)) // only if the bindname is not empty
    {
    	//
        //  Miniport is marked for deletion
        //  Delete this Miniport's whole registry branch
        //
        hr = HrRegDeleteKeyTree(hkeyMiniportList,
                                szBindName);
    }


	TraceMsg (L"<-- HrDeleteMiniport hr %x\n", hr);
	return hr;

}



// ----------------------------------------------------------------------
//
// Function:  CBaseClass::HrWriteMiniport
//   
//   
// Purpose:  	To add a miniport, we make an entry under the IMMiniport 
// 				list. Under this we write the all important Upper Bindings
//              Keyword
//
//
// Arguments:
//	HKEY hkeyMiniportList - Key of the MiniportList, 
//	CIMMiniport pIMMiniport - IM miniport structure 
//
// Returns:
//
// Notes:
//

HRESULT
CBaseClass::
HrWriteMiniport(
	HKEY hkeyMiniportList, 
	CIMMiniport *pIMMiniport
	)
{
	HKEY    hkeyMiniport = NULL;
	DWORD   dwDisposition;
	PWSTR	pstrDeviceName = NULL;
	DWORD 	dwLen = 0;
	HRESULT hr;

	TraceMsg (L"--> HrWriteMiniport \n");

	do
	{
		//
		// open/create this Miniport's key
		//
	    hr = HrRegCreateKeyEx(
	                            hkeyMiniportList,
	                            pIMMiniport->SzGetIMMiniportBindName(),
	                            REG_OPTION_NON_VOLATILE,
	                            KEY_ALL_ACCESS,
	                            NULL,
	                            &hkeyMiniport,
	                            &dwDisposition);

		if (hr != S_OK)
		{
			TraceMsg (L"Write Miniport CreateRegKey Failed\n");
			hkeyMiniport = NULL;
			break;
		}
 
		//
		// Use the string values from the miniport to create an entry for Upperbindindings
		//

		//
		// Copy the string into our buffer, 
		//

		pstrDeviceName = (PWSTR	)pIMMiniport->SzGetIMMiniportDeviceName();

		if ( pstrDeviceName  == NULL)
		{
			TraceBreak(L"Write Miniport  - SzGetIMMiniportDeviceName Failed\n");
			break;

		}


		dwLen = wcslen(pstrDeviceName);

		if (dwLen != IM_NAME_LENGTH )
		{
			TraceMsg(L"Invalide Name Length. pstr %p - %s, Len %x",
		         pstrDeviceName,
		         pstrDeviceName,
		         dwLen);
		         
			BREAKPOINT();			    

		}

		TraceMsg(L"Str %p - %s , Len %x\n",
		         pstrDeviceName,
		         pstrDeviceName,
		         dwLen);
	         
		if (pstrDeviceName[dwLen] != L'\0')
		{
			TraceMsg (L" Null termination  pwstr %p, Index %d\n",pstrDeviceName ,dwLen);
			BREAKPOINT();

			pstrDeviceName [dwLen++] = L'\0';
		}
				

		


		hr = HrRegSetValueEx( hkeyMiniport,
		                      c_szUpperBindings,
		                      REG_SZ,
		                      (unsigned char*)pstrDeviceName,
		                      dwLen*2);  // Unicode to bytes 

		if (hr != S_OK)
		{
			TraceBreak (L"WriteMiniport - HrRegSetValueEx FAILED\n");
		}

	} while (FALSE);

	if (hkeyMiniport != NULL)
	{
		RegCloseKey(hkeyMiniport );
	}



	TraceMsg (L"<-- HrWriteMiniport\n");
	return hr;

}






HRESULT
CBaseClass::
HrFindNetCardInstance(
    PCWSTR             pszBindNameToFind,
    INetCfgComponent** ppncc)
{
    *ppncc = NULL;

    TraceMsg (L"--> HrFindNetCardInstance\n" );

	//
    // Enumerate adapters in the system.
    //
    HRESULT 				hr = S_OK;
    BOOL 					fFound = FALSE;
	IEnumNetCfgComponent *	pEnumComponent = NULL;
	INetCfgComponent* 		pNccAdapter = NULL;
	CONST ULONG 			celt = 1;  // Number of  elements wanted.
	ULONG 					celtFetched = 0;  // Number of elements fetched
    INetCfgClass* 			pncclass = NULL;
    PWSTR 					pszBindName = NULL;	
	//
	// We need to fing the component that has the name we 
	// are looking for . Look in all NetClass devices
	//

	do
	{


		hr = m_pnc->QueryNetCfgClass(&GUID_DEVCLASS_NET, 
		                             IID_INetCfgClass,
                                     reinterpret_cast<void**>(&pncclass));

	    if ((SUCCEEDED(hr)) == FALSE)
	    {
				pncclass = NULL;
				TraceBreak(L"HrFindNetCardInstance  QueryNetCfgClass FAILED\n");
				break;
	    }

    	//
        // Get the enumerator and set it for the base class.
        //
        
        hr = pncclass->EnumComponents(&pEnumComponent);

        if ((SUCCEEDED(hr)) == FALSE)
        {
        	TraceBreak (L" HrFindNetCardInstance EnumComponents FAILED\n");
        	pEnumComponent = NULL;
        	break;
        }


        //
        // Now iterate through all the net class component
        //
        while ((fFound == FALSE) && (hr == S_OK))
		{
			pNccAdapter = NULL;

			//
			// Lets get the next Component
			//
			
			hr = pEnumComponent->Next(celt,
			                          &pNccAdapter,
			                          &celtFetched);
			//
			//  Get the bindname of the miniport
			//
			if (S_OK != hr)
			{
				//
				// We might break, if there are no more elements
				//
				pNccAdapter = NULL;
				break;
			}	



	        hr = pNccAdapter->GetBindName(&pszBindName);

	        if (S_OK != hr)
	        {
	        	TraceBreak(L" HrFindNetCardInstance GetBindName Failed\n")
				pszBindName = NULL;
				break;
	        }

			//	
            //  If the right one tell it to remove itself and end
            //

            
            fFound = !lstrcmpiW(pszBindName, pszBindNameToFind);
            CoTaskMemFree (pszBindName);

            if (fFound)
            {
                *ppncc = pNccAdapter;
            }
            else
            {
				ReleaseAndSetToNull(pNccAdapter);
            }
            
        } // end of while ((fFound == FALSE) && (hr == S_OK))


			

		
    } while (FALSE);

    if (pncclass != NULL)
    {
    	ReleaseAndSetToNull(pncclass);
	}

	ReleaseAndSetToNull (pEnumComponent);
	
	
    TraceMsg (L"<-- HrFindNetCardInstance hr %x\n", hr );
    return hr;
}




//------------------------------------------------------------
//
//  simple member functions for the CBaseClass
//
//------------------------------------------------------------

VOID
CBaseClass::
AddUnderlyingAdapter(
    	CUnderlyingAdapter  * pAdapter)
{

		//
		// Insert this at the head
		//
		this->SetUnderlyingAdapterListHead(pAdapter);

		this->m_cAdaptersAdded ++;	

}


VOID
CBaseClass::
SetUnderlyingAdapterListHead(
    	CUnderlyingAdapter * pAdapter
    	)
{
	//
	// Insert this at the head
	//
	pAdapter->SetNext(this->GetUnderlyingAdaptersListHead());

	this->m_pUnderlyingAdapter = pAdapter;


}
    


CUnderlyingAdapter *
CBaseClass::
GetUnderlyingAdaptersListHead(
	VOID)
{
	return (this->m_pUnderlyingAdapter);
}

DWORD
CBaseClass::DwNumberUnderlyingAdapter()
{
	return this->m_cAdaptersAdded ;
}




//------------------------------------------------------------
//
//  member functions for the Underlying Adapter
//
//------------------------------------------------------------


VOID CUnderlyingAdapter::SetAdapterBindName(PCWSTR pszAdapterBindName)
{
    m_strAdapterBindName = pszAdapterBindName;
    return;
}

PCWSTR CUnderlyingAdapter::SzGetAdapterBindName(VOID)
{
    return m_strAdapterBindName.c_str();
}

VOID CUnderlyingAdapter::SetAdapterPnpId(PCWSTR pszAdapterPnpId)
{
    m_strAdapterPnpId = pszAdapterPnpId;
    return;
}

PCWSTR CUnderlyingAdapter::SzGetAdapterPnpId(VOID)
{
    return m_strAdapterPnpId.c_str();
}


HRESULT CUnderlyingAdapter::SetNext ( CUnderlyingAdapter *pNextUnderlyingAdapter )
{
	this->pNext = pNextUnderlyingAdapter;
	return S_OK;
}

CUnderlyingAdapter *CUnderlyingAdapter::GetNext()
{
	return pNext;
}


VOID CUnderlyingAdapter::AddIMiniport(CIMMiniport* pNextIMiniport)
{
	//
	// Set up this new Miniport as the head of the list
	//
	this->SetIMiniportListHead(pNextIMiniport);
	this->m_NumberofIMMiniports ++;
			
}


CIMMiniport* CUnderlyingAdapter::IMiniportListHead()
{
	return (this->m_pIMMiniport);
}



VOID CUnderlyingAdapter::SetIMiniportListHead(CIMMiniport* pNewHead)
{
	pNewHead->SetNext(this->IMiniportListHead() );
	

	this->m_pIMMiniport = pNewHead;
	
}

VOID CUnderlyingAdapter::AddOldIMiniport(CIMMiniport* pIMiniport)
{
	//
	// Set up this new Miniport as the head of the list
	//
	this->SetOldIMiniportListHead(pIMiniport);

			
}


CIMMiniport* CUnderlyingAdapter::OldIMiniportListHead()
{
	return (this->m_pOldIMMiniport);
}



VOID CUnderlyingAdapter::SetOldIMiniportListHead(CIMMiniport* pNewHead)
{
	pNewHead->SetNextOld(this->OldIMiniportListHead() );

	this->m_pOldIMMiniport = pNewHead;
}


DWORD CUnderlyingAdapter::DwNumberOfIMMiniports()
{
	return m_NumberofIMMiniports;
}


//------------------------------------------------------------
//
//  member functions for the IM miniport
//
//------------------------------------------------------------

VOID CIMMiniport::SetIMMiniportBindName(PCWSTR pszIMMiniportBindName)
{
    m_strIMMiniportBindName = pszIMMiniportBindName;
    return;
}

PCWSTR CIMMiniport::SzGetIMMiniportBindName(VOID)
{
    return m_strIMMiniportBindName.c_str();
}

VOID CIMMiniport::SetIMMiniportDeviceName(PCWSTR pszIMMiniportDeviceName)
{
    m_strIMMiniportDeviceName = pszIMMiniportDeviceName;
    return;
}

PCWSTR CIMMiniport::SzGetIMMiniportDeviceName(VOID)
{
    return m_strIMMiniportDeviceName.c_str();
}

DWORD CIMMiniport::DwGetIMMiniportNameLength(VOID)
{
    return m_strIMMiniportDeviceName.len();
}


VOID CIMMiniport::SetIMMiniportName(PCWSTR pszIMMiniportName)
{
    m_strIMMiniportName = pszIMMiniportName;
    return;
}

VOID CIMMiniport::SetIMMiniportName(PWSTR pszIMMiniportName)
{
    m_strIMMiniportName = pszIMMiniportName;
    return;
}

PCWSTR CIMMiniport::SzGetIMMiniportName(VOID)
{
    return m_strIMMiniportName.c_str();
}


VOID CIMMiniport::SetNext (	CIMMiniport *pNextIMiniport )
{
	pNext = pNextIMiniport;
}


CIMMiniport* CIMMiniport::GetNext(VOID)
{
	return pNext ;
}


VOID CIMMiniport::SetNextOld (	CIMMiniport *pNextIMiniport )
{
	pOldNext  = pNextIMiniport;
}


CIMMiniport* CIMMiniport::GetNextOld(VOID)
{
	return pOldNext ;
}











//+---------------------------------------------------------------------------
//
//  Function:   HrGetLastComponentAndInterface
//
//  Purpose:    This function enumerates a binding path, returns the last
//              component on the path and optionally return the last binding
//              interface name in this path.
	//
//  Arguments:
//      pncbp               [in]    The INetCfgBindingPath *
//      ppncc               [out]   The INetCfgComponent * of the last component on the path
//      ppszInterfaceName   [out]   The interface name of the last binding interface of the path
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//
HRESULT
HrGetLastComponentAndInterface (
    INetCfgBindingPath* pNcbPath,
    INetCfgComponent** ppncc,
    PWSTR* ppszInterfaceName)
{

	ULONG ulElement = 0;
	INetCfgBindingInterface* 		pNcbInterface = NULL;
    INetCfgBindingInterface* 		pncbiLast = NULL;
    INetCfgComponent* 				pnccLowerComponent = NULL;
	IEnumNetCfgBindingInterface*	pEnumInterface = NULL;  

	TraceMsg (L"--> HrGetLastComponentAndInterface \n");
		
	
    // Initialize output parameters.
    //
    *ppncc = NULL;
    if (ppszInterfaceName)
    {
        *ppszInterfaceName = NULL;
    }

    // Enumerate binding interfaces and keep track of
    // the last interface.
    //
    HRESULT hr = S_OK;

	do
    {

		hr = pNcbPath->EnumBindingInterfaces(&pEnumInterface );

		if (hr != S_OK )
		{
			TraceMsg(L" EnumBindingInterfaces FAILED\n");
			pEnumInterface = NULL;
			break;
		}

		//
		//  Iterate till we reach the last element in the path
		//
	 
		do
		{
			pNcbInterface = NULL;
		
			hr = pEnumInterface ->Next (1,
			                            &pNcbInterface,
			                            &ulElement);

			if (hr 	!= S_OK )
			{
				pNcbInterface = NULL ; // Failure

				break;
			}

			if (ulElement == 0 || pNcbInterface == NULL || hr 	!= S_OK)
			{
				pNcbInterface  = NULL;
				break;  // We have reached the last element and it is in pncbiLast.
			
			}
			ReleaseObj(pncbiLast);
			pncbiLast = pNcbInterface;
			

		} while (hr == S_OK && pNcbInterface != NULL);
		

		//
		// If this is the last element, then get its name and 
		// return it to the caller. The last element is in pncbiLast
		//
		if (pNcbInterface != NULL)
		{
			//
			// We did not reach the last element
			//
			TraceMsg (L"Did not get the last interface\n");
			break;
			
		}

	    hr = S_OK;


	    hr = pncbiLast->GetLowerComponent(&pnccLowerComponent);
	    if (S_OK != hr)
	    {
	    	TraceMsg(L" GetLowerComponent Failed ");
	    	break;
	    }
	    

	    // Get the name of the interface if requested.
	    //
	    if (ppszInterfaceName)
	    {
	        hr = pncbiLast->GetName(ppszInterfaceName);
	    }

	    // If we've succeded everything, (including the optional
	    // return of the interface name above) then assign and addref
	    // the output interface.
	    //
	    if (S_OK == hr)
	    {
	        AddRefObj (pnccLowerComponent);
	        *ppncc = pnccLowerComponent;
	    }
	    else
	    {

		    // Important to release our use of this interface in case
		    // we failed and didn't assign it as an output parameter.
		    //
		    ReleaseAndSetToNull (pnccLowerComponent);
		}
		
    } while (FALSE);

	//
    // Don't forget to release the binding interface itself.
    //
    ReleaseObj(pncbiLast);

	
	TraceMsg (L"<-- HrGetLastComponentAndInterface  ppszInterfaceName %x\n", ppszInterfaceName);
    return hr;
}



//---------------------------------------------------------------------------
//  These functions are used to load the configuration from the registry
//---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadConfiguration
//
//  Purpose:  This loads the Miniport and adapters that have already been 
//            installed into our own data structures
//
//  Arguments:
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//


HRESULT 
CBaseClass::
HrLoadConfiguration(
	VOID
	)
{
    HRESULT     hr  = S_OK;
    WCHAR       szBuf[MAX_PATH+1];
    FILETIME    time;
    DWORD       dwSize;
    DWORD       dwRegIndex = 0;
    HKEY    	hkeyAdapterList = NULL;

	TraceMsg (L"-->HrLoadConfiguration \n");
	
    // mark the memory version of the registy valid
    this->m_fValid = TRUE;

	BREAKPOINT();

	do
	{
	    // Try to open an existing key first.
	    //
	    
	    hr = HrRegOpenAdapterKey(c_szAtmEpvcP, 
	                            FALSE, 
	                            &hkeyAdapterList
	                            );
	    if (FAILED(hr))
	    {
	    	//
	        // Only on failure do we try to create it
	        //
	        hr = HrRegOpenAdapterKey(c_szAtmEpvcP, TRUE, &hkeyAdapterList);
	    }

	    if (S_OK != hr)
	    {
			TraceBreak(L"HrLoadConfiguration  HrRegOpenAdapterKey FAILED\n");
			hkeyAdapterList = NULL;
			break;
	    }

		//
		// Initialize the Size and hr
		//

        dwSize = (sizeof(szBuf)/ sizeof(szBuf[0]));

        hr = S_OK;
	
        while (hr == S_OK)
        {
        	//
        	// Iterate through all the adapters in <Protocol>\Paramters\Adapters
        	//

        	hr = HrRegEnumKeyEx (hkeyAdapterList, 
        	                     dwRegIndex,
			                     szBuf, 
			                     &dwSize, 
			                     NULL, 
			                     NULL, 
			                     &time);
			if (hr != S_OK)
			{
				break;
			}

			//		
	        // load this adapter's config
	        //
            hr = HrLoadAdapterConfiguration (hkeyAdapterList, szBuf);
            if (S_OK != hr)
            {
                TraceBreak (L"HrLoadConfiguration   HrLoadAdapterConfiguration  failed\n" );
                hr = S_OK;
                //
                // continue on.
                //
            }

			//
			// Re-Initialize the Size
			//
            dwRegIndex++;
    	    dwSize = (sizeof(szBuf)/ sizeof(szBuf[0]));
    	}

		//
		// Why did we exit from our adapter enumeration
		//
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }




	} while (FALSE);

	if (hkeyAdapterList != NULL)
	{
		RegCloseKey (hkeyAdapterList);
	}
	
	TraceMsg (L"<--HrLoadConfiguration %x\n", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrLoadAdapterConfiguration
//
//  Purpose:   Load the Underlying Adapter into our structure
//
//
//
//  Arguments:
//    	HKEY hkeyAdapterList - hKeyAdapterList,
//      PWSTR pszAdapterName - Adapter Name for the underlying adapter
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//


HRESULT 
CBaseClass::
HrLoadAdapterConfiguration(
	HKEY hkeyAdapterList,
    PWSTR pszAdapterName
    )
{
    HRESULT 							hr = S_OK;
    HKEY    							hkeyAdapter = NULL;
    DWORD   							dwDisposition;
    CUnderlyingAdapter*   	pAdapterInfo = NULL;
	INetCfgComponent*   				pnccAdapter    = NULL;
	PWSTR 								pszPnpDevNodeId = NULL;
	GUID 								guidAdapter;
    

	TraceMsg(L"-->HrLoadAdapterConfiguration %s\n",pszAdapterName);
	do
	{
		//
	    // load this adapter
	    //
	    pAdapterInfo = new CUnderlyingAdapter;

	    if (pAdapterInfo == NULL)
	    {
			TraceBreak (L"HrLoadAdapterConfiguration new Adapter FAILED\n");
			break;
	    }

	    pAdapterInfo->SetAdapterBindName(pszAdapterName);

	    this->AddUnderlyingAdapter(pAdapterInfo);

		//
	    // open this adapter's subkey
		//
	    hr = HrRegCreateKeyEx(
	                hkeyAdapterList,
	                pszAdapterName,
	                REG_OPTION_NON_VOLATILE,
	                KEY_ALL_ACCESS,
	                NULL,
	                &hkeyAdapter,
	                &dwDisposition);

	    if (S_OK != hr)
	    {
	    	hkeyAdapter = NULL;
			TraceBreak(L" HrLoadAdapterConfiguration  HrRegCreateKeyEx FAILED \n");
			break;
	    }

	    //
	    // load the PnpId
	    //
	    TraceMsg (L"pszAdapter->Name %x - %s \n", pszAdapterName, pszAdapterName);
	    
	    hr = HrFindNetCardInstance(pszAdapterName, 
	                               &pnccAdapter);
	    
		if (S_OK != hr)
		{
			//
			// Failure - exit
			//
			TraceBreak (L"HrLoadAdapterConfiguration HrFindNetCardInstance FAILED\n");
			pnccAdapter =  NULL;
			break;

		}
	    if (S_FALSE == hr)
	    {
	    	//
	        // normalize return - but exit
	        //
	        hr = S_OK;
	        pnccAdapter =  NULL;
	        break;
	    }

	    hr = pnccAdapter->GetPnpDevNodeId(&pszPnpDevNodeId);
	
	
	    if (S_OK == hr)
	    {
	        pAdapterInfo->SetAdapterPnpId(pszPnpDevNodeId);
	        CoTaskMemFree(pszPnpDevNodeId);
	    }
    

	    
		hr = pnccAdapter->GetInstanceGuid(&guidAdapter); 

		if (S_OK == hr)
		{
		    pAdapterInfo->m_AdapterGuid = guidAdapter;
		}

		//
	    // load the IM Miniport
	    //
	    
	    hr = HrLoadIMMiniportListConfiguration(hkeyAdapter, 
	                                            pAdapterInfo);

		if (S_OK != hr)
		{
			TraceBreak (L"HrLoadAdapterConfiguration HrFindNetCardInstance FAILED\n");
			break;
		
		}

		        
    

    } while (FALSE);


	if (pnccAdapter != NULL)
	{
	    ReleaseAndSetToNull(pnccAdapter);
    }
    
    if (hkeyAdapter != NULL)
    {	
    	RegCloseKey(hkeyAdapter);
	}

    TraceMsg(L"<--HrLoadAdapterConfiguration %x\n", hr);

    return hr;
}





//+---------------------------------------------------------------------------
//
//  Function:   HrLoadIMMiniportListConfiguration
//
//  Purpose:   Load the IM miniports hanging of this adapter into our structure
//
//
//
//  Arguments:
//    	HKEY hkeyAdapterList - hKeyAdapterList,
//      PWSTR pszAdapterName - Adapter Name for the underlying adapter
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//


HRESULT
CBaseClass::
HrLoadIMMiniportListConfiguration(
    HKEY hkeyAdapter,
    CUnderlyingAdapter* pAdapterInfo)
{
    HRESULT hr = S_OK;
	UINT i;

	//
    // open the IMminiport under the adapter subkey
    //
    HKEY    hkeyIMMiniportList= NULL;
    DWORD   dwDisposition;
    

    WCHAR       szBuf[MAX_PATH+1];
    FILETIME    time;
    DWORD       dwSize;
    DWORD       dwRegIndex = 0;
    PWSTR		pszIMDevices = NULL;
	PWSTR		p = NULL;
	
    TraceMsg(L"--> HrLoadIMMiniportListConfiguration \n");

    do
    {
	
	    
		//
	    // open the MiniportList subkey. Then we will iterate through all
	    // the IM miniport that exist under this key
	    //
	
	    
	    hr = HrRegCreateKeyEx(hkeyAdapter, 
	                          c_szIMMiniportList, 
	                          REG_OPTION_NON_VOLATILE,
	                          KEY_ALL_ACCESS, 
	                          NULL, 
	                          &hkeyIMMiniportList, 
	                          &dwDisposition);

	    if (S_OK != hr)
	    {
			TraceBreak (L"LoadMiniportList - CreateRegKey FAILED \n");
			hkeyIMMiniportList = NULL;
			break;
	    }

		//
		// Initialize variables through the iteration
		//
		
	    dwSize = celems(szBuf);

	    hr = S_OK;

	    
	    while(SUCCEEDED(hr) == TRUE)
	    {
	      	hr=  HrRegEnumKeyEx(hkeyIMMiniportList, 
	                          dwRegIndex, 
	                          szBuf,
			                  &dwSize, 
			                  NULL, 
			                  NULL, 
			                  &time);
	        if (hr != S_OK)
	        {
				break;
	        }

			//
			// load this IMMiniport;s  configuration
			//
	        hr = HrLoadIMiniportConfiguration(hkeyIMMiniportList,
	                                         szBuf,
	                                         pAdapterInfo);

	        if (S_OK != hr)
	        {
	            TraceBreak(L"HrLoadMiniportConfiguration failed \n ");
	            //
	            // Do not break
	            //
	            hr = S_OK;
	        }
	        else 
	        {
	        	if (m_fNoIMMinportInstalled)
	            {
	                m_fNoIMMinportInstalled = FALSE;
	                
	            }
			
	        }

	        
			//
			// prepare for the next iteration
	        // increment index and reset size variable
	        //
	        dwRegIndex ++;
	        dwSize = celems(szBuf);


		}// end of while(SUCCEEDED(hr) == TRUE)
	    

	    if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		{
			hr = S_OK;
		}

		RegCloseKey(hkeyIMMiniportList);
	    
	} while (FALSE);
    	
    TraceMsg(L"<-- HrLoadIMMiniportListConfiguration %x\n", hr);

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrLoadIMiniportConfiguration
//
//  Purpose:   Load a single IM miniport hanging of this adapter into our structure
//             The Miniport is loaded into two lists . 
//
//
//  Arguments:
//    HKEY hkeyIMiniportList,
//    PWSTR pszIMiniport,
//    CUnderlyingAdapter * pAdapterInfo)
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//

HRESULT
CBaseClass::
HrLoadIMiniportConfiguration(
    HKEY hkeyMiniportList,
    PWSTR pszIMiniportName,
    CUnderlyingAdapter * pAdapterInfo
    )
{
    HRESULT hr  = S_OK;
    HKEY    hkeyIMiniport    = NULL;
	DWORD   dwDisposition;

    TraceMsg (L"-->HrLoadIMminiportConfiguration  \n");

    
    do
    {
		// load this IMMiniport info
		CIMMiniport* pIMMiniportInfo = NULL;
		pIMMiniportInfo = new CIMMiniport;

		CIMMiniport* pOldIMMiniportInfo = NULL;
		pOldIMMiniportInfo = new CIMMiniport;

		if ((pIMMiniportInfo == NULL) ||
			(pOldIMMiniportInfo == NULL))
		{
			hr = E_OUTOFMEMORY;
			if (pIMMiniportInfo)
			{
				delete pIMMiniportInfo;
			}
			if (pOldIMMiniportInfo)
			{
				delete pOldIMMiniportInfo;
			}

			break;
        }

		pAdapterInfo->AddIMiniport(pIMMiniportInfo);
		pIMMiniportInfo->SetIMMiniportBindName(pszIMiniportName);

		pAdapterInfo->AddOldIMiniport(pOldIMMiniportInfo);
		pOldIMMiniportInfo->SetIMMiniportBindName(pszIMiniportName);

		//
		// open the IMMiniport's key
		//
		HKEY    hkeyIMMiniport    = NULL;
		DWORD   dwDisposition;


		hr = HrRegCreateKeyEx (hkeyMiniportList, 
		                       pszIMiniportName, 
		                       REG_OPTION_NON_VOLATILE,
		                       KEY_ALL_ACCESS, 
		                       NULL, 
		                       &hkeyIMMiniport, 
		                       &dwDisposition);

		if (S_OK == hr)
		{
			// read the Device parameter
			PWSTR pszIMiniportDevice;

			hr = HrRegQuerySzWithAlloc (hkeyIMMiniport, 
			                            c_szUpperBindings, 
			                            &pszIMiniportDevice);
			if (S_OK == hr)
			{
				//
				// load the Device name
				//
				pIMMiniportInfo->SetIMMiniportDeviceName(pszIMiniportDevice);
				pOldIMMiniportInfo->SetIMMiniportDeviceName(pszIMiniportDevice);
				MemFree (pszIMiniportDevice);


			}
			RegCloseKey (hkeyIMMiniport);
		}
	}
	while (FALSE);

    TraceMsg (L"<-- HrLoadIMminiportConfiguration  hr %x \n", hr);
	return hr;
}





HRESULT 
CBaseClass::
HrReconfigEpvc(
	CUnderlyingAdapter* pAdapterInfo
	)
{
    HRESULT hr = S_OK;

    // Note: if atm physical adapter is deleted, no notification of removing elan
    // is necessary. Lane protocol driver will know to delete all the elans
    // (confirmed above with ArvindM 3/12).

    // Raid #371343, don't send notification if ATM card not connected


	TraceMsg (L" -- HrReconfigEpvc\n");
    return hr;

 #if 0
 
    if ((!pAdapterInfo->m_fDeleted) && 
        FIsAdapterEnabled(&(pAdapterInfo->m_guidInstanceId)))  
    {
        ElanChangeType elanChangeType;

        // loop thru the elan list on this adapter
        ELAN_INFO_LIST::iterator    iterLstElans;

        for (iterLstElans = pAdapterInfo->m_lstElans.begin();
                iterLstElans != pAdapterInfo->m_lstElans.end();
                iterLstElans++)
        {
            CALaneCfgElanInfo * pElanInfo = *iterLstElans;

            // if this Elan is marked as for delete
            if (pElanInfo->m_fDeleted)
            {
                PCWSTR szBindName = pElanInfo->SzGetElanBindName();

                if (lstrlenW(szBindName)) // only if the bindname is not empty
                {
                    // notify deletion
                    elanChangeType = DEL_ELAN;
                    hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                            elanChangeType);
                }
            }
            else
            {
                BOOL fFound = FALSE;

                ELAN_INFO_LIST::iterator    iterLstOldElans;

                // loop through the old elan list, see if we can find a match
                for (iterLstOldElans = pAdapterInfo->m_lstOldElans.begin();
                        iterLstOldElans != pAdapterInfo->m_lstOldElans.end();
                        iterLstOldElans++)
                {
                    CALaneCfgElanInfo * pOldElanInfo = * iterLstOldElans;

                    if (0 == lstrcmpiW(pElanInfo->SzGetElanBindName(),
                                      pOldElanInfo->SzGetElanBindName()))
                    {
                        // we found a match
                        fFound = TRUE;

                        // has the elan name changed ?
                        if (lstrcmpiW(pElanInfo->SzGetElanName(),
                                     pOldElanInfo->SzGetElanName()) != 0)
                        {
                            elanChangeType = MOD_ELAN;
                            hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                                    elanChangeType);
                        }
                    }
                }

                if (!fFound)
                {
                    elanChangeType = ADD_ELAN;
                    hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                            elanChangeType);

                    // Raid #384380: If no ELAN was installed, ignore the error
                    if ((S_OK != hr) &&(m_fNoIMMinportInstalled))
                    {
                        TraceError("Adding ELAN failed but error ignored 
since there was no ELAN installed so LANE driver is not started, reset hr to 
S_OK", hr);
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceError("CALaneCfg::HrReconfigLane", hr);
    return hr;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\str.h ===
//
// For now include the stl functions provided in net\config\inc
//

#include "pch.h"
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <ncreg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\reg.cpp ===
#include "pch.h"
#pragma hdrstop
#include "sfilter.h"
#include "proto.h"
#include "macros.h"





//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAdapterKey
//
//  Purpose:    This creates or opens the Adapters subkey to a component
//
//  Arguments:
//      pszComponentName [in]   The name of the component being
//      fCreate [in]            TRUE if the directory is to be created
//      phkey [out]             The handle to the Adapters subkey
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:      The handle has to be released by the calling app on SUCCESS
//
HRESULT
HrRegOpenAdapterKey (
    IN PCWSTR pszComponentName,
    IN BOOL fCreate,
    OUT HKEY* phkey)
{
    HRESULT     hr              = S_OK;
    DWORD       dwDisposition   = 0x0;
    tstring     strKey;

	TraceMsg (L"--> HrRegOpenAdapterKey \n");
 


    // Build the registry path
    strKey = c_szRegParamAdapter;

	
	//
	// Now do the operation on the registry
	//
	hr = HrRegOpenAString (strKey.c_str(), fCreate, phkey);
	

	if (hr != S_OK)
	{
		phkey = NULL;
	}

	TraceMsg (L"<-- HrRegOpenAdapterKey \n");
    return hr;
}




//
// Basic utility function
//

ULONG
CbOfSzAndTermSafe (
    IN PCWSTR psz)
{
	if (psz)
	{
	 	return (wcslen (psz) + 1) * sizeof(WCHAR); 

	}
	else
	{
		return 0;
	}
}



//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAdapterGuid
//
//  Purpose:    This creates and entry under the adapter key. The entry contains
//				Guid of the underlying adapter.
//
//  Arguments:
//	IN HKEY phkeyAdapters  - key - Service-><Protocol>->Parameters\Adapters entry,
//	IN PGUID pAdapterGuid - Guid of the underlying adapter
//	OUT PHKEY phGuidKey - The key to be used to access the new entry
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//              Appropriate KEy if successful
//
//
//  Notes:      The handle has to be released by the calling app on SUCCESS
//

HRESULT
HrRegOpenAdapterGuid(
	IN HKEY phkeyAdapters,
	IN PGUID pAdapterGuid,
	IN BOOL	fCreate,
	OUT HKEY *phGuidKey
	)
{
    HRESULT     hr              = S_OK;
    DWORD       dwDisposition   = 0x0;
    tstring     strKey;
    WCHAR 		szGuid[64];
    ULONG		lr = 0;


	TraceMsg (L"--> HrRegCreateAdapterGuid \n");
 


    // Build the registry path
    strKey = c_szRegParamAdapter;
	strKey.append(c_szBackslash);
	
	//
	// Convert the Guid to  a string
	//
	
    StringFromGUID2(
        *pAdapterGuid,
        szGuid,
        (sizeof(szGuid) / sizeof(szGuid[0])));


	//
	//  Append it to Services\<Protocl>\Parameters\Adapters\
 	//

	strKey.append(szGuid);



	TraceMsg(L"Check String of Adapter Guid %s \n", strKey.wcharptr());
	BREAKPOINT();

	//
	// Now do the operation on the registry
	//
	hr = HrRegOpenAString (strKey.c_str(), fCreate, phGuidKey);

	if (hr != S_OK)
	{
		phGuidKey = NULL;
	}
	//
	//  return the hr error code
	//
	TraceMsg (L"<-- HrRegCreateAdapterGuid \n");

	return hr;


}



//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAdapterKey
//
//  Purpose:    This creates and entry under the adapter Guid key. The entry is
//              the KeyWord "Upperbindings" and it contains the Guid of the IM 
//              IM Miniport. 
//
//  Arguments:
//	IN HKEY phkeyAdapterGuid - The key to <Protocol>->Paramaters->Adapters->Guid,
//	IN PGUID pIMMiniportGuid, - The Guid of the IM miniport
//	OUT HKEY *phImMiniportKey - Key for the IMminiport key
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//              Appropriate KEy if successful
//
//
//  Notes:      The handle has to be released by the calling app on SUCCESS
//

HRESULT
HrRegOpenIMMiniportGuid(
	IN HKEY phkeyAdapterGuid,
	IN PGUID pIMMiniportGuid,
	IN BOOL fCreate,
	OUT PHKEY phImMiniportKey
	)
{
	HRESULT 	hr = ERROR_INVALID_PARAMETER;
	tstring 	strDevice;  
	WCHAR		szGuid[GUID_LENGTH];
	DWORD       dwDisposition   = 0x0;
	HKEY 		hImMiniportKey = NULL;


	do
	{
		//
		// If the key, Guid  is NULL Return 
		//
		if ((phkeyAdapterGuid == NULL) ||
			(pIMMiniportGuid == NULL) )
		{
			TraceBreak (L"HrRegSetIMMiniportGuid Bad arguments\n");
			break;
		}
		    

		strDevice = c_szDevice;

		//
		// Convert the Guid to  a string.
		// Insert '\Device\' at the beginning of the string
		//
		//

		StringFromGUID2(
		        *pIMMiniportGuid,
		        szGuid,
		        (sizeof(szGuid) / sizeof(szGuid[0])));



		strDevice.append(szGuid);

		//
		// Now do the operation on the registry
		//
		hr = HrRegOpenAString (strDevice.c_str(), fCreate, &hImMiniportKey);


	
	}while (FALSE);
	//
	//  update the output variable
	//
	
	if (hr == S_OK && phImMiniportKey  != NULL)
	{
		*phImMiniportKey = hImMiniportKey;
	}

	
	//
	//  return the hr error code
	//
	TraceMsg (L"<-- HrRegOpenIMMiniportGuid \n");

	return hr;



}





//---------------------------------------------------------------------------
// 			Basic Functions accessed only by the routines above
//----------------------------------------------------------------------------





//+---------------------------------------------------------------------------
//
//  Function:   HrRegCreateKeyEx
//
//  Purpose:    Creates a registry key by calling RegCreateKeyEx.
//
//  Arguments:
//      hkey                 [in]
//      pszSubkey            [in]
//      dwOptions            [in]   See the Win32 documentation for the
//      samDesired           [in]   RegCreateKeyEx function.
//      lpSecurityAttributes [in]
//      phkResult            [out]
//      pdwDisposition       [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition)
{
    LONG lr = RegCreateKeyExW (hkey, pszSubkey, 0, NULL, dwOptions, samDesired,
            lpSecurityAttributes, phkResult, pdwDisposition);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceMsg(L"HrRegCreateKeyEx %x SubKey %s\n", hr, pszSubkey);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyEx
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)
{

	HRESULT hr = ERROR_INVALID_PARAMETER;
	long lr = ERROR_INVALID_PARAMETER;

	do 
	{
		if (hkey == NULL ||
		    pszSubkey == NULL )
		{
			TraceBreak(L"HrRegOpenKey - Invalid Parameters \n");
			break;
		}
	
    	lr = RegOpenKeyExW (hkey, 
    	                         pszSubkey, 
    	                         0, 
    	                         samDesired, 
    	                         phkResult);
    	                         
	    hr = HRESULT_FROM_WIN32(lr);
	    if (FAILED(hr))
	    {
	        *phkResult = NULL;
	    }

	    
	} while (FALSE);

	
    TraceMsg (L"HrRegOpenKeyEx %x, %x",  hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetValue
//
//  Purpose:    Sets the data for the given registry value by calling the
//              appropriate WinReg function.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      dwType       [in]    See the Win32 documentation for the RegSetValueEx
//      pbData       [in]    function.
//      cbData       [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//



HRESULT 
HrRegSetSz (
	HKEY hkey, 
	PCWSTR pszValueName, 
	PCWSTR pszValue
	)
{
	TraceMsg (L"--> HrHrRegSetSz  \n");

    LONG lr = RegSetValueExW(hkey, 
                             pszValueName, 
                             0, 
                             REG_SZ, 
                             (LPBYTE)pszValue, 
                             CbOfSzAndTermSafe (pszValue) );;

                             
    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    
    TraceMsg (L"<-- HrRegSetValue  hr %x\n", hr);
	return hr;
}





//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteKeyTree
//
//  Purpose:    Deletes an entire registry hive.
//
//  Arguments:
//      hkeyParent  [in]   Handle to open key where the desired key resides.
//      pszRemoveKey [in]   Name of key to delete.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCWSTR pszRemoveKey)
{

    // Open the key we want to remove
    HKEY 		hkeyRemove;
    HRESULT 	hr = ERROR_INVALID_PARAMETER;
    WCHAR       szValueName [MAX_PATH];
    DWORD       cchBuffSize = MAX_PATH;
    FILETIME    ft;
    LONG        lr;


    TraceMsg(L"-->HrRegDeleteKeyTree \n");

	do
	{

	    HRESULT hr = HrRegOpenKeyEx(hkeyParent, 
	                                pszRemoveKey, 
	                                KEY_ALL_ACCESS,
	                                &hkeyRemove);

	    if (S_OK != hr)
	    {
			TraceBreak(L"HrRegDeleteKeyTree->HrRegOpenKeyEx Failed\n"); 
			break;
	    }


        // Enum the keys children, and remove those sub-trees
        while (ERROR_SUCCESS == (lr = RegEnumKeyExW (hkeyRemove,
                									0,
                									szValueName,
                									&cchBuffSize,
                									NULL,
                									NULL,
                									NULL,
                									&ft)))
        {
            HrRegDeleteKeyTree (hkeyRemove, szValueName);
            cchBuffSize = MAX_PATH;
        }


        
        RegCloseKey (hkeyRemove);

        if ((ERROR_SUCCESS == lr) || (ERROR_NO_MORE_ITEMS == lr))
        {
            lr = RegDeleteKeyW (hkeyParent, pszRemoveKey);
        }

        hr = HRESULT_FROM_WIN32 (lr);

    } while (FALSE);

	TraceMsg(L"<--HrRegDeleteKeyTree %x\n", hr);

    return hr;
}






















//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAString
//
//  Purpose:    This creates and entry under the adapter key. The entry contains
//				Guid of the underlying adapter.
//
//  Arguments:
//	IN WCHAR_T *pcszStr - A string 
//  IN BOOL fCreate - Create Or Open,
//	OUT PHKEY phKey - The key to be used to access the new entry
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//              Appropriate KEy if successful
//
//
//  Notes:      The handle has to be released by the calling app on SUCCESS
//

HRESULT
HrRegOpenAString(
	IN CONST WCHAR *pcszStr ,
	IN BOOL fCreate,
	OUT PHKEY phKey 
	)
{
    HRESULT     hr              = S_OK;
    DWORD       dwDisposition   = 0x0;
    ULONG		lr = 0;


	TraceMsg (L"--> HrRegOpenAString\n");
 


	TraceMsg(L"   String opened %s \n", pcszStr);


	if (fCreate)
	{
		//
		// Create the entry
		//
			

	   	hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
	                          pcszStr,
	                          REG_OPTION_NON_VOLATILE,
	                          KEY_ALL_ACCESS,
	                          NULL ,
	                          phKey,
	                          &dwDisposition);

	}
	else
	{
		//
		// Open the entry
		//
		   hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                pcszStr,
                                KEY_READ,
                                phKey);
    

	}

	if (hr != S_OK)
	{
		phKey = NULL;
	}
	//
	//  return the hr error code
	//
	TraceMsg (L"<-- HrRegOpenAString\n");

	return hr;


}












//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetValueEx
//
//  Purpose:    Sets the data for the given registry value by calling the
//              RegSetValueEx function.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      dwType       [in]    See the Win32 documentation for the RegSetValueEx
//      pbData       [in]    function.
//      cbData       [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegSetValueEx (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    
    LONG lr = RegSetValueExW(hkey, 
                             pszValueName, 
                             0, 
                             dwType, 
                             pbData, 
                             cbData);

                             
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceMsg(L"--HrRegSetValue ValueName %s, Data %s, hr %x \n", pszValueName, pbData, hr);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteValue
//
//  Purpose:    Deletes the given registry value.
//
//  Arguments:
//      hkey        [in]    See the Win32 documentation for the RegDeleteValue
//      pszValueName [in]    function.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCWSTR pszValueName)
{
    
    LONG lr = RegDeleteValueW (hkey, 
                               pszValueName);

    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceMsg(L"--HrRegDeleteValue  ValueName %s, hr %x \n", pszValueName, hr);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumKeyEx
//
//  Purpose:    Enumerates subkeys of the specified open registry key.
//
//  Arguments:
//      hkey             [in]
//      dwIndex          [in]   See the Win32 documentation for the
//      pszSubkeyName    [out]  RegEnumKeyEx function.
//      pcchSubkeyName   [inout]
//      pszClass         [out]
//      pcchClass        [inout]
//      pftLastWriteTime [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:
//
HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN OUT LPDWORD pcchSubkeyName,
    OUT PWSTR  pszClass,
    IN OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime)
{

    LONG lr = RegEnumKeyExW (hkey, dwIndex, pszSubkeyName, pcchSubkeyName,
                            NULL, pszClass, pcchClass, pftLastWriteTime);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceMsg(L" -- HrRegEnumKeyEx");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeWithAlloc
//
//  Purpose:    Retrieves a type'd value from the registry and returns a
//              pre-allocated buffer with the data and optionally the size of
//              the returned buffer.
//
//  Arguments:
//      hkey         [in]    Handle of parent key
//      pszValueName [in]    Name of value to query
//      ppbValue     [out]   Buffer with binary data
//      pcbValue     [out]   Size of buffer in bytes. If NULL, size is not
//                           returned.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:      Free the returned buffer with MemFree.
//
HRESULT
HrRegQueryTypeWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    DWORD   dwType,
    LPBYTE* ppbValue,
    DWORD*  pcbValue)
{
    HRESULT hr;
    DWORD   dwTypeRet;
    LPBYTE  pbData;
    DWORD   cbData;


    // Get the value.
    //
    hr = HrRegQueryValueWithAlloc(hkey, pszValueName, &dwTypeRet,
                                  &pbData, &cbData);

    // It's type should be REG_BINARY. (duh).
    //
    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        MemFree(pbData);
        pbData = NULL;

        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
    }

    // Assign the output parameters.
    if (S_OK == hr)
    {
        *ppbValue = pbData;
        if (pcbValue)
        {
            *pcbValue = cbData;
        }
    }
    else
    {
        *ppbValue = NULL;
        if (pcbValue)
        {
            *pcbValue = 0;
        }
    }

    TraceMsg  (L" -- HrRegQueryTypeWithAlloc hr %x\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueWithAlloc
//
//  Purpose:    Retrieve a registry value in a buffer allocated by this
//              function. This goes through the mess of checking the value
//              size, allocating the buffer, and then calling back to get the
//              actual value. Returns the buffer to the user.
//
//  Arguments:
//      hkey         [in]        An open HKEY (the one that contains the value
//                              to be read)
//      pszValueName [in]        Name of the registry value
//      pdwType      [in/out]    The REG_ type that we plan to be reading
//      ppbBuffer    [out]       Pointer to an LPBYTE buffer that will contain
//                              the registry value
//      pdwSize      [out]       Pointer to a DWORD that will contain the size
//                              of the ppbBuffer.
//
//
//
HRESULT
HrRegQueryValueWithAlloc (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize)
{
    HRESULT hr;
    BYTE abData [256];
    DWORD cbData;
    BOOL fReQuery = FALSE;


    // Initialize the output parameters.
    //
    *ppbBuffer = NULL;
    if (pdwSize)
    {
        *pdwSize = 0;
    }

    // Get the size of the data, and if it will fit, the data too.
    //
    cbData = sizeof(abData);
    hr = HrRegQueryValueEx (
            hkey,
            pszValueName,
            pdwType,
            abData,
            &cbData);
    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
    {
        // The data didn't fit, so we'll have to requery for it after
        // we allocate our buffer.
        //
        fReQuery = TRUE;
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        // Allocate the buffer for the required size.
        //
        BYTE* pbBuffer = (BYTE*)MemAlloc (cbData);
        if (pbBuffer)
        {
            if (fReQuery)
            {
                hr = HrRegQueryValueEx (
                        hkey,
                        pszValueName,
                        pdwType,
                        pbBuffer,
                        &cbData);
            }
            else
            {
                CopyMemory (pbBuffer, abData, cbData);
            }

            if (S_OK == hr)
            {
                // Fill in the return values.
                //
                *ppbBuffer = pbBuffer;

                if (pdwSize)
                {
                    *pdwSize = cbData;
                }
            }
            else
            {
                MemFree (pbBuffer);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceMsg  (L" -- HrRegQueryValueWithAlloc hr %x\n", hr);

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueEx
//
//  Purpose:    Retrieves the data from the given registry value by calling
//              RegQueryValueEx.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      pdwType      [out]   See the Win32 documentation for the
//      pbData       [out]   RegQueryValueEx function.
//      pcbData      [in,out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//
//  Notes:      Note that pcbData is an *in/out* param. Set this to the size
//              of the buffer pointed to by pbData *before* calling this
//              function!
//
HRESULT
HrRegQueryValueEx (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    OUT LPDWORD   pdwType,
    OUT LPBYTE    pbData,
    OUT LPDWORD   pcbData)
{
    

    LONG lr = RegQueryValueExW (hkey, pszValueName, NULL, pdwType,
                    pbData, pcbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceMsg  (L" -- HrRegQueryValueEx hr %x\n", hr);
    return hr;
}



HRESULT
HrRegQuerySzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_SZ,
                (LPBYTE*)pszValue, NULL);
}




HRESULT
HrRegQueryMultiSzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue)
{
	TraceMsg  (L" -- HrRegQueryMultiSzWithAlloc pszValueName %s\n",pszValueName );
	


    return HrRegQueryTypeWithAlloc (hkey, 
                                    pszValueName, 
                                    REG_MULTI_SZ,
                                    (LPBYTE*)pszValue, 
                                    NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\typedefs.h ===
typedef GUID*  PGUID;
typedef HKEY *PHKEY;




#define GUID_LENGTH sizeof(GUID) + 1
#define NOTHING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\notify\sfilter.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       S F I L T E R . H
//
//  Contents:   Notify object code for the sample filter.
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------


#pragma once
#include "sfiltern.h"
#include "resource.h"
#include "MyString.h"
#include "typedefs.h"


#define SINGLE_ADAPTER_ONLY 1

// What type of config change the user/system is performing
enum ConfigAction {eActUnknown, eActInstall, eActRemove, eActPropertyUI};

#define MAX_ADAPTERS 64         // max no. of physical adapters in a machine
//#define MAX_PATH   75
#define MaxPath 75

#define NO_BREAKS 1

#if NO_BREAKS
#define BREAKPOINT()
#else
#define BREAKPOINT() __asm int 3
#endif


typedef MyString tstring;
//
// This is the class to represent the IM Miniport.
//
class CIMMiniport
{

    public:
    CIMMiniport(
        VOID
        );

    VOID 
    SetIMMiniportBindName(
        PCWSTR pszIMMiniportBindName
        );

    PCWSTR 
    SzGetIMMiniportBindName(
        VOID
        );

    VOID 
    SetIMMiniportDeviceName(
        PCWSTR pszIMMiniportDeviceName
        );

    PCWSTR 
    SzGetIMMiniportDeviceName(
        VOID
        );

    VOID 
    SetIMMiniportName(
        PCWSTR pszIMMiniportName
        );

    VOID 
    SetIMMiniportName(
        PWSTR pszIMMiniportName
        );

    PCWSTR 
        SzGetIMMiniportName(
        VOID
        );

    DWORD DwGetIMMiniportNameLength(
        VOID
        );

    VOID SetNext (CIMMiniport *);       

    CIMMiniport* GetNext();

    VOID SetNextOld (CIMMiniport *);        

    CIMMiniport* GetNextOld();

    DWORD DwNumberOfIMMiniports();


    //
    // Member Variables (public) begin here
    //
    BOOL        m_fDeleted;
    BOOL        m_fNewIMMiniport;

    BOOL        m_fRemoveMiniportOnPropertyApply;
    BOOL        m_fCreateMiniportOnPropertyApply;

    
private:

    //
    // Private variables begin here
    //

    tstring     m_strIMMiniportBindName;
    tstring     m_strIMMiniportDeviceName;
    tstring     m_strIMMiniportName;
    CIMMiniport * pNext;
    CIMMiniport * pOldNext;
    
};



//------------------------------------------------
// CUnderlyingAdapter
//  - Class definition for the underlying adapter
//------------------------------------------------
class CUnderlyingAdapter
{
    public:

    //
    // Member functions
    //
    CUnderlyingAdapter(
        VOID
        );
    
    VOID 
    SetAdapterBindName(
        PCWSTR pszAdapterBindName
        );
        
    PCWSTR SzGetAdapterBindName(
        VOID
        );

    VOID 
    SetAdapterPnpId(
        PCWSTR szAdapterBindName
        );

    PCWSTR  
    SzGetAdapterPnpId(
        VOID
        );


        
    HRESULT 
    SetNext (
        CUnderlyingAdapter *
        );

    CUnderlyingAdapter *GetNext();

    DWORD DwNumberOfIMMiniports();

    //
    // Functions to access the lists
    //
    VOID AddIMiniport(CIMMiniport*);    
    CIMMiniport* IMiniportListHead();
    VOID SetIMiniportListHead(CIMMiniport* pNewHead);

    VOID AddOldIMiniport(CIMMiniport*); 
    CIMMiniport* OldIMiniportListHead();
    VOID SetOldIMiniportListHead(CIMMiniport* pHead);


    //
    // Public Variables
    //
    BOOLEAN     m_fBindingChanged;
    BOOLEAN     m_fDeleted;
    
    GUID   m_AdapterGuid ;
    CIMMiniport         *m_pIMMiniport;

    CIMMiniport         *m_pOldIMMiniport;

    
    
    
    private:

    //
    // Private variables
    //
    tstring             m_strAdapterBindName;
    tstring             m_strAdapterPnpId;
    CUnderlyingAdapter *pNext;
    DWORD           m_NumberofIMMiniports;

};

//------------------------------------------------
// CUnderlyingAdapter
//  - End
//------------------------------------------------




//------------------------------------------------
// CBaseClass 
//  - Base class for the entire notify object
//------------------------------------------------


class CBaseClass :
    public CComObjectRoot,
    public CComCoClass<CBaseClass, &CLSID_CBaseClass>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentNotifyGlobal
{
public:
    CBaseClass(VOID);
    ~CBaseClass(VOID);

    BEGIN_COM_MAP(CBaseClass)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CBaseClass)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_SAMPLE_FILTER)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR szAnswerFile,
                                     PCWSTR szAnswerSections);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();


// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

// Private methods
    HRESULT HrNotifyBindingAdd(
        INetCfgComponent* pnccAdapter,
        PCWSTR pszBindName);

    HRESULT HrNotifyBindingRemove(
        INetCfgComponent* pnccAdapter,
        PCWSTR pszBindName);

    HRESULT HrRemoveMiniportInstance(
        PCWSTR pszBindNameToRemove
        );

    HRESULT
    CBaseClass::HrRemoveComponent (
        INetCfg*            pnc,
        INetCfgComponent*   pnccToRemove
        );

    HRESULT HrFlushConfiguration();

    HRESULT HrFlushAdapterConfiguration(
        HKEY hkeyAdapterList,
        CUnderlyingAdapter *pAdapterInfo
        );

    HRESULT HrFlushMiniportList(
        HKEY hkeyAdapter,
        CUnderlyingAdapter *pAdapterInfo
        );
    


    HRESULT
    HrFindNetCardInstance(
        PCWSTR             pszBindNameToFind,
        INetCfgComponent** ppncc
        );



    HRESULT 
    HrReconfigEpvc(
        CUnderlyingAdapter* pAdapterInfo
        );

    
    HRESULT 
    HrLoadConfiguration(
        VOID
        );


    HRESULT 
    HrLoadAdapterConfiguration(
        HKEY hkeyAdapterList,
        PWSTR pszAdapterName
    );

    VOID
    AddUnderlyingAdapter(
        CUnderlyingAdapter  *);

    VOID
    SetUnderlyingAdapterListHead(
        CUnderlyingAdapter * 
        );

    CUnderlyingAdapter *
    GetUnderlyingAdaptersListHead();

    DWORD
    DwNumberUnderlyingAdapter();

    
    HRESULT
    HrLoadIMiniportConfiguration(
        HKEY hkeyMiniportList,
        PWSTR pszIMiniportName,
        CUnderlyingAdapter * pAdapterInfo
        );

    HRESULT
    HrLoadIMMiniportListConfiguration(
        HKEY hkeyAdapter,
        CUnderlyingAdapter* pAdapterInfo
        );

    HRESULT 
    HrFlushMiniportConfiguration(
    HKEY hkeyMiniportList, 
    CIMMiniport *pIMMiniport
    );
        
    HRESULT
    HrWriteMiniport(
        HKEY hkeyMiniportList, 
        CIMMiniport *pIMMiniport
    );


    HRESULT
    HrDeleteMiniport(
        HKEY hkeyMiniportList, 
        CIMMiniport *pIMMiniport
    );


private:
    INetCfgComponent*   m_pncc;  // Protocol's Net Config component
    INetCfg*            m_pnc;
    ConfigAction        m_eApplyAction;
    CUnderlyingAdapter  *m_pUnderlyingAdapter;

    IUnknown*           m_pUnkContext;
    UINT                m_cAdaptersAdded;
    BOOL                m_fDirty;
    BOOL                m_fUpgrade;
    BOOL                m_fValid;
    BOOL                m_fNoIMMinportInstalled;

    // Utility functions
public:

private:

};

//------------------------------------------------
// CBaseClass 
//  - End
//------------------------------------------------

#if 0
#if DBG
void TraceMsg(PCWSTR szFormat, ...);
#else
#define TraceMsg   (_Str)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\ccdefs.h ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// ccdefs.h
//
// ATM - Ethernet Encapsulation Intermediate Driver 
//
// '#defines' used in the driver.
//
// 03/23/2000 ADube Created.
//


#define TESTMODE 0

//
// Define spew levels. The code will be checked in with testmode turned off
//

#if TESTMODE
    #define DEFAULTTRACELEVEL TL_T
    #define DEFAULTTRACEMASK TM_NoRM
#else
    #define DEFAULTTRACELEVEL TL_A
    #define DEFAULTTRACEMASK TM_Base
#endif


#define NDIS_WDM 1

#define PKT_STACKS 0



#if (DBG)
        // Define this to enable a whole lot of extra checking in the RM api'd -- things
        // like debug associations and extra checking while locking/unlocking.
        //
        #define RM_EXTRA_CHECKING 1
#endif // DBG

#define EPVC_NDIS_MAJOR_VERSION     5
#define EPVC_NDIS_MINOR_VERSION     0



#define DISCARD_NON_UNICAST TRUE

#define MAX_BUNDLEID_LENGTH 50
#define TAG 'Epvc'
#define WAIT_INFINITE 0
#define ATMEPVC_GLOBALS_SIG 'GvpE'
#define ATMEPVC_MP_MEDIUM NdisMedium802_3
#define ATMEPVC_DEF_MAX_AAL5_PDU_SIZE   ((64*1024)-1)
//
//  Maximum bytes for ethernet/802.3 header 
//
#define EPVC_ETH_HEADERSIZE         14
#define EPVC_HEADERSIZE             4
#define MCAST_LIST_SIZE             32
#define MAX_ETHERNET_FRAME          1514 
#define MAX_IPv4_FRAME              MAX_ETHERNET_FRAME - sizeof(EPVC_ETH_HEADER)          
#define EPVC_MAX_FRAME_SIZE         MAX_ETHERNET_FRAME
#define EPVC_MAX_PT_SIZE            EPVC_MAX_FRAME_SIZE + 20
#define MIN_ETHERNET_SIZE           sizeof (IPHeader) + sizeof (EPVC_ETH_HEADER)
#define EPVC_ETH_ENCAP_SIZE         2

//
// Packet Releated definitions
//

#define MAX_PACKET_POOL_SIZE 0x0000FFFF
#define MIN_PACKET_POOL_SIZE 0x000000FF
#define ARPDBG_REF_EVERY_PACKET 1

#define DEFAULT_MAC_HEADER_SIZE 14
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\debug.h ===
// Copyright (c) 2000-2001, Microsoft Corporation, all rights reserved
//
// debug.h
// ATM - Ethernet Encapsulation Intermediate Driver 
// Debug helper header
//
//  03/23/2000 Adube Created.


#ifndef _DEBUG_H_
#define _DEBUG_H_






//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

#define MODULE_DRIVER 1
#define MODULE_MINIPORT 2
#define MODULE_PROTOCOL 3

//
//  These are the tags used in the allocation routines
//  so that the memory dumps will identify what structure
//  follows the tag.
//
//

#define TAG_FREED               'FvpE'
#define TAG_PROTOCOL            'PvpE'
#define TAG_ADAPTER             'AvpE'
#define TAG_TASK                'TvpE'
#define TAG_MINIPORT            'MvpE'
#define TAG_DEFAULT             'ZvpE'
#define TAG_WORKITEM            'WvpE'
#define TAG_RCV                 'RvpE'
//
// Trace Modules  used in debugging.
// Each module has its own number. 
//
#define TM_Dr   0x1 // Driver Entry
#define TM_Mp   0x2 // Miniport
#define TM_Pt   0x4 // Protocol
#define TM_Cl   0x20 // Client 
#define TM_Rq   0x40 // Requests
#define TM_Send 0x200 // Sends
#define TM_Recv 0x100 // Receive
#define TM_RM   0x400 // Resource Manager


//
// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x18 // Interface (highest level workable for general use)
#define TL_N    0x20 // Normal
#define TL_T    0x25 // Displays Entry and Exit points of all functions
#define TL_V    0x30 // Verbose
#define TL_D    0x40 // Dump packets



// Trace mask bits.
//

#define TM_Wild 0xFFFFFFFF // Everything
#define TM_All  0x7FFFFFFF // Everything except corruption checks
#define TM_Base 0x000000FF // Base only
#define TM_NoRM (TM_Base & (~(TM_RM|TM_Rq)))

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE( ulLevel, ulMask, Args)                             \
{                                                              \
    if ((ulLevel <= g_ulTraceLevel) && ((g_ulTraceMask & ulMask) )) \
    {                                                          \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "EPVC: !ASSERT( %s ) at line %d of %s\n",  \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel == g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else

extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;

#if TESTMODE
    #define epvcBreakPoint() DbgBreakPoint();
#else
    #define epvcBreakPoint() 
#endif


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#define epvcBreakPoint() 

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\client.h ===
VOID
EpvcCoOpenAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisAfHandle
    );

VOID
EpvcCoCloseAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext
    );




VOID
EpvcCoMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );


VOID
EpvcCoCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    );




NDIS_STATUS
EpvcCoIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );


VOID
EpvcCoCallConnected(
    IN  NDIS_HANDLE             ProtocolVcContext
    );


VOID
EpvcCoIncomingClose(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    );

//
// CO_CREATE_VC_HANDLER and CO_DELETE_VC_HANDLER are synchronous calls
//
NDIS_STATUS
EpvcClientCreateVc(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

NDIS_STATUS
EpvcClientDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

NDIS_STATUS
EpvcCoRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );


VOID
EpvcCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    );

VOID
EpvcCoCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    );

NDIS_STATUS
epvcPrepareAndSendNdisRequest(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PEPVC_NDIS_REQUEST          pEpvcNdisRequest,
    IN  REQUEST_COMPLETION          pFunc,              // OPTIONAL
    IN  NDIS_OID                    Oid,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  PEPVC_I_MINIPORT            pMiniport,          // OPTIONAL
    IN  BOOLEAN                     fPendedRequest,     // OPTIONAL
    IN  BOOLEAN                     fPendedSet,         // OPTIONAL
    IN  PRM_STACK_RECORD            pSR
    );

VOID
epvcMiniportQueueWorkItem (
    IN PEPVC_WORK_ITEM pEpvcWorkItem,
    IN PEPVC_I_MINIPORT pMiniport,
    IN PEVPC_WORK_ITEM_FUNC pFn,
    IN NDIS_STATUS Status,
    IN PRM_STACK_RECORD pSR
    );


VOID
epvcCoGenericWorkItem (
    IN PNDIS_WORK_ITEM pNdisWorkItem,
    IN PVOID Context
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\client.c ===
#include "precomp.h"
#pragma hdrstop

#include "macros.h"


VOID
EpvcCoOpenAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisAfHandle
    )
{ 
    ENTER("OpenAdapterComplete", 0x5d75dabd)
    PEPVC_I_MINIPORT        pMiniport = (PEPVC_I_MINIPORT)ProtocolAfContext;
    PTASK_AF                pAfTask = (PTASK_AF )pMiniport->af.pAfTask;
    RM_DECLARE_STACK_RECORD(sr)

    TRACE (TL_T, TM_Cl, (" == EpvcCoOpenAfComplete Context %p Status %x AfHAndle %x", 
                       pMiniport, Status, NdisAfHandle) );

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Store the Af Handle
    //

    if (NDIS_STATUS_SUCCESS == Status)
    {
        LOCKOBJ (pMiniport, &sr);
        pMiniport->af.AfHandle = NdisAfHandle;

        //
        // Update variables on the miniport structure
        // as this task has been given the go ahead
        //
        MiniportSetFlag (pMiniport, fMP_AddressFamilyOpened);
        MiniportClearFlag (pMiniport, fMP_InfoAfClosed);                

        epvcLinkToExternal(
            &pMiniport->Hdr,                    // pObject
            0x5546d299,
            (UINT_PTR)pMiniport->af.AfHandle ,              // Instance1
            EPVC_ASSOC_MINIPORT_OPEN_AF,            // AssociationID
            "    Open AF NdisHandle=%p\n",// szFormat
            &sr
            );


        

        UNLOCKOBJ(pMiniport, &sr);

    }
    else
    {
        ASSERT (pMiniport->af.AfHandle == NULL);
        
        pMiniport->af.AfHandle = NULL;
    }
    
    pAfTask ->ReturnStatus = Status; 

    //
    // Add an association between 
    //
    
    RmResumeTask (&pAfTask->TskHdr , 0, &sr); 
    RM_ASSERT_CLEAR(&sr);

    EXIT();
}


VOID
epvcCoCloseAfCompleteWorkItem(
    PRM_OBJECT_HEADER pObj,
    NDIS_STATUS Status,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Resuming  the Af task
    
Arguments:
    
    
--*/
{

    ENTER("epvcCoCloseAfCompleteWorkItem", 0xf6edfcb8)
    PEPVC_I_MINIPORT        pMiniport = NULL ;
    PTASK_AF                pAfTask = NULL;


    pMiniport = (PEPVC_I_MINIPORT)pObj ;

    LOCKOBJ (pMiniport, pSR);
    MiniportSetFlag (pMiniport, fMP_InfoAfClosed);  
    UNLOCKOBJ (pMiniport, pSR);
    
    pAfTask = (PTASK_AF )pMiniport->af.pAfTask;
                                   
    
    if (NDIS_STATUS_SUCCESS==Status )
    {
        LOCKOBJ (pMiniport, pSR);

        epvcUnlinkFromExternal(
            &pMiniport->Hdr,                    // pObject
            0x5546d299,
            (UINT_PTR)pMiniport->af.AfHandle ,              // Instance1
            EPVC_ASSOC_MINIPORT_OPEN_AF,            // AssociationID
            pSR
            );

        pMiniport->af.AfHandle = NULL;
                    
        UNLOCKOBJ(pMiniport, pSR);

    }
    
    RmResumeTask (&pAfTask->TskHdr , 0, pSR); 

    EXIT();
    return;

}

VOID
EpvcCoCloseAfComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext
    )
/*++

Routine Description:

    Signifies that the AF has been closed. 
    Resume the Af task - through a workitem 
    
Arguments:
    
    
--*/
{ 
    ENTER("EpvcCoCloseAfComplete ", 0x5d75dabd)
    PEPVC_I_MINIPORT        pMiniport = (PEPVC_I_MINIPORT)ProtocolAfContext;
    PTASK_AF                pAfTask = (PTASK_AF )pMiniport->af.pAfTask;
    RM_DECLARE_STACK_RECORD(sr)
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    
    TRACE (TL_T, TM_Cl, (" == EpvcCoCloseAfComplete Context %p Status %x ", 
                       pMiniport, Status) );

    //
    // Store the Status
    //

    pAfTask->ReturnStatus = Status; 

    //
    // Queue the WorkItem
    //
    epvcMiniportQueueWorkItem (
        &pMiniport->af.CloseAfWorkItem,
        pMiniport,
        epvcCoCloseAfCompleteWorkItem,
        Status,
        &sr
        );

    EXIT();
    RM_ASSERT_CLEAR(&sr);
    return;
}


VOID
EpvcCoMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     pCallParameters
    )
/*++

Routine Description:

    This is a notification from Ndis that the Make Call has completed. 
    We need to pass the Status back to the original thread, so use the Vc
    Task as a context
    
Arguments:
    
    
--*/
    
{
    ENTER ("EpvcCoMakeCallComplete", 0x1716ee4b)

    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT) ProtocolVcContext;
    PTASK_VC            pTaskVc = pMiniport->vc.pTaskVc;

    RM_DECLARE_STACK_RECORD(SR);
    
    //ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    TRACE (TL_T, TM_Cl, (" == EpvcCoMakeCallComplete Status %x", Status) );

    pTaskVc->ReturnStatus  = Status; 

    ASSERT (pCallParameters != NULL);
    epvcFreeMemory (pCallParameters ,CALL_PARAMETER_SIZE, 0);

    
    RmResumeTask (&pTaskVc->TskHdr, 0 , &SR);
        
    EXIT();
    RM_ASSERT_CLEAR(&SR);

}


VOID
epvcCoCloseCallCompleteWorkItem(
    PRM_OBJECT_HEADER pObj, 
    NDIS_STATUS Status,
    PRM_STACK_RECORD pSR            
    )
{ 
    ENTER ("EpvcCoCloseCallComplete", 0xbd67524a)

    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT) pObj;
    PTASK_VC            pTaskVc = pMiniport->vc.pTaskVc;

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    TRACE (TL_T, TM_Cl, (" == EpvcCoCloseCallComplete") );

    pTaskVc->ReturnStatus  = Status; 
    
    RmResumeTask (&pTaskVc->TskHdr, 0 , pSR);
    RM_ASSERT_CLEAR(pSR);

}


VOID
EpvcCoCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL
    )
{ 
    ENTER ("EpvcCoCloseCallComplete", 0xbd67524a)

    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT) ProtocolVcContext;

    RM_DECLARE_STACK_RECORD(SR);

    TRACE (TL_T, TM_Cl, (" == EpvcCoCloseCallComplete") );

    epvcMiniportQueueWorkItem (&pMiniport->vc.CallVcWorkItem,
                               pMiniport,
                               epvcCoCloseCallCompleteWorkItem,
                               Status,
                               &SR
                               );

    RM_ASSERT_CLEAR(&SR);

}





NDIS_STATUS
EpvcCoIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
{ 
    TRACE (TL_T, TM_Cl, (" == EpvcCoIncomingCall") );
    return NDIS_STATUS_FAILURE;

}


VOID
EpvcCoCallConnected(
    IN  NDIS_HANDLE             ProtocolVcContext
    )
{ 
    TRACE (TL_T, TM_Cl, (" == EpvcCoCallConnected") );

}


VOID
EpvcCoIncomingClose(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PVOID                   CloseData   OPTIONAL,
    IN  UINT                    Size        OPTIONAL
    )
{ 
    TRACE (TL_T, TM_Cl, (" == EpvcCoIncomingClose") );

}


//
// CO_CREATE_VC_HANDLER and CO_DELETE_VC_HANDLER are synchronous calls
//
NDIS_STATUS
EpvcClientCreateVc(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    )
{

    TRACE (TL_T, TM_Cl, (" == EpvcClientCreateVc") );


    return NDIS_STATUS_FAILURE;
}

NDIS_STATUS
EpvcClientDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    )
{
    TRACE (TL_T, TM_Cl, (" == EpvcClientDeleteVc") );
    return NDIS_STATUS_FAILURE;

}




NDIS_STATUS
EpvcCoRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        pNdisRequest
    )
/*++

Routine Description:

    This routine is called by NDIS when our Call Manager sends us an
    NDIS Request. NDIS Requests that are of significance to us are:
    - OID_CO_ADDRESS_CHANGE
        The set of addresses registered with the switch has changed,
        i.e. address registration is complete. We issue an NDIS Request
        ourselves to get the list of addresses registered.
    - OID_CO_SIGNALING_ENABLED
        We ignore this as of now.
        TODO: Add code that uses this and the SIGNALING_DISABLED
        OIDs to optimize on making calls.
    - OID_CO_SIGNALING_DISABLED
        We ignore this for now.
    - OID_CO_AF_CLOSE
        The Call manager wants us to shut down this AF open .

    We ignore all other OIDs.

Arguments:

    ProtocolAfContext           - Our context for the Address Family binding,
                                  which is a pointer to the ATMEPVC Interface.
    ProtocolVcContext           - Our context for a VC, which is a pointer to
                                  an ATMEPVC VC structure.
    ProtocolPartyContext        - Our context for a Party. Since we don't do
                                  PMP, this is ignored (must be NULL).
    pNdisRequest                - Pointer to the NDIS Request.

Return Value:

    NDIS_STATUS_SUCCESS if we recognized the OID
    NDIS_STATUS_NOT_RECOGNIZED if we didn't.

--*/

{
    ENTER("EpvcCoRequest",0xcc5aff85)
    PEPVC_I_MINIPORT            pMiniport;
    NDIS_STATUS                 Status;
    RM_DECLARE_STACK_RECORD (SR)    
    
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    pMiniport = (PEPVC_I_MINIPORT)ProtocolAfContext;

    

    TRACE (TL_T, TM_Cl, (" ==> EpvcCoRequest") );


    
    //
    //  Initialize
    //
    Status = NDIS_STATUS_NOT_RECOGNIZED;

    if (pNdisRequest->RequestType == NdisRequestSetInformation)
    {
        switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
        {
            case OID_CO_ADDRESS_CHANGE:
                TRACE (TL_I, TM_Cl, ("CoRequestHandler: CO_ADDRESS_CHANGE\n"));
                //
                //  The Call Manager says that the list of addresses
                //  registered on this interface has changed. Get the
                //  (potentially) new ATM address for this interface.
                Status = NDIS_STATUS_SUCCESS;
                break;
            
            case OID_CO_SIGNALING_ENABLED:
                TRACE (TL_I, TM_Cl, ("CoRequestHandler: CoRequestHandler: CO_SIGNALING_ENABLED\n"));
                // ignored for now
                Status = NDIS_STATUS_FAILURE;
                break;

            case OID_CO_SIGNALING_DISABLED:
                TRACE (TL_I, TM_Cl, ("CoRequestHandler: CO_SIGNALING_DISABLEDn"));
                // Ignored for now
                Status = NDIS_STATUS_FAILURE;
                break;

            case OID_CO_AF_CLOSE:
                TRACE (TL_I, TM_Cl, ("CoRequestHandler: CO_AF_CLOSE on MINIPORT %x\n", pMiniport));

                Status = epvcProcessOidCloseAf(pMiniport, &SR);
        
                break;

            default:
                break;
        }
    }

    TRACE (TL_T, TM_Cl, (" <== EpvcCoRequest") );
    RM_ASSERT_CLEAR(&SR)
    EXIT()
    return (Status);
}




VOID
EpvcCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolAfContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST           pRequest
    )
{
    

    TRACE (TL_T, TM_Cl, (" == EpvcCoRequest pRequest %x", pRequest) );

        


}





NDIS_STATUS
epvcPrepareAndSendNdisRequest(
    IN  PEPVC_ADAPTER           pAdapter,
    IN  PEPVC_NDIS_REQUEST          pEpvcNdisRequest,
    IN  REQUEST_COMPLETION          pFunc,              // OPTIONAL
    IN  NDIS_OID                    Oid,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  PEPVC_I_MINIPORT            pMiniport,          // OPTIONAL
    IN  BOOLEAN                     fPendedRequest,     // OPTIONAL
    IN  BOOLEAN                     fPendedSet,         // OPTIONAL
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Send an NDIS Request to query an adapter for information.
    If the request pends, block on the EPVC Adapter structure
    till it completes.

Arguments:

    pAdapter                - Points to EPVCAdapter structure   
    pNdisRequest            - Pointer to UNITIALIZED NDIS request structure
    pTask                   - OPTIONAL Task. If NULL, we block until the operation
                              completes.
    PendCode                - PendCode to suspend pTask
    Oid                     - OID to be passed in the request
    pBuffer                 - place for value(s)
    BufferLength            - length of above
    pMiniport               - Minport associated withe this request - OPTIONAL
    fPendedRequest          - A request was pended at the miniport - OPTIONAL
    fPendedSet              - Pended a Set Request - OPTIONAL
    
Return Value:

    The NDIS status of the request.

--*/
{
    ENTER("epvcPrepareAndSendNdisRequest",0x1cc515d5)

    NDIS_STATUS         Status;
    PNDIS_REQUEST       pNdisRequest = &pEpvcNdisRequest->Request;

    TRACE (TL_T, TM_Cl, ("==>epvcSendAdapterNdisRequest pAdapter %x, pRequest %x",
                       pAdapter, pNdisRequest));

    //ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    TRACE (TL_V, TM_Rq, ("Cl Requesting Adapter %x, Oid %x, Buffer %x, Length %x, pFunc %x",
                         pAdapter,
                         Oid,
                         pBuffer,
                         BufferLength,
                         pFunc) );

    ASSERT (pNdisRequest != NULL);
    
    EPVC_ZEROSTRUCT(pEpvcNdisRequest);


    //
    //  Fill in the NDIS Request structure
    //
    if (RequestType == NdisRequestQueryInformation)
    {
        pNdisRequest->RequestType = NdisRequestQueryInformation;
        pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
        pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
        pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
        pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
        pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
    }
    else
    {
        ASSERT(RequestType == NdisRequestSetInformation);
        pNdisRequest->RequestType = NdisRequestSetInformation;
        pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
        pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
        pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
        pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
        pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = BufferLength;
    }

    ASSERT (pAdapter->bind.BindingHandle != NULL);

    //
    // If the completion routine is not defined then wait for this request
    // to complete. 
    //

    if (pFunc == NULL)
    {
        // We might potentially wait.
        //
        ASSERT_PASSIVE();

        //
        //Insure that we aren't blocking a request that reached our miniport edge
        //
        ASSERT (pMiniport == NULL);

        NdisInitializeEvent(&pEpvcNdisRequest->Event);
        
        NdisRequest(
            &Status,
            pAdapter->bind.BindingHandle,
            pNdisRequest
            );
        if (PEND(Status))
        {
            NdisWaitEvent(&pEpvcNdisRequest->Event, 0);
            Status = pEpvcNdisRequest->Status;
        }

    }
    else
    {
        pEpvcNdisRequest->pFunc = pFunc;
        pEpvcNdisRequest->pMiniport = pMiniport;
        pEpvcNdisRequest->fPendedRequest  = fPendedRequest ;
        pEpvcNdisRequest->fSet = fPendedSet;
        
        //
        // Set up an assoc between the miniport and this request
        //


        epvcLinkToExternal (&pMiniport->Hdr,    // pHdr
                            0x46591e2d,         // LUID
                            (UINT_PTR)pEpvcNdisRequest, // External entity
                            EPVC_ASSOC_MINIPORT_REQUEST,    // AssocID
                            "NetWorKAddressRequest %p\n",
                             pSR
                             ) ;


        NdisRequest(
            &Status,
            pAdapter->bind.BindingHandle,
            pNdisRequest
            );
            
        if (!PEND(Status))
        {
            (pFunc) (pEpvcNdisRequest, Status);

            // Let this thread complete with a status of pending
            Status = NDIS_STATUS_PENDING;

        }
    }


    if (Status == NDIS_STATUS_SUCCESS)
    {
        TRACE(TL_V, TM_Rq,("Adapter Query - Oid %x", Oid));
        DUMPDW (TL_V, TM_Rq, pBuffer, BufferLength);
    }
    return Status;
}





VOID
epvcCoGenericWorkItem (
    IN PNDIS_WORK_ITEM pNdisWorkItem,
    IN PVOID Context
    )
/*++

Routine Description:

    Deref the miniport and invoke the function associated with 
    the workitem
    
Arguments:
    
    
--*/

{

    ENTER ("epvcCoGenericWorkItem ", 0x45b597e8)
    PEPVC_WORK_ITEM pEpvcWorkItem = (PEPVC_WORK_ITEM )pNdisWorkItem;
    RM_DECLARE_STACK_RECORD (SR);
    //
    // Deref the miniport or adapter
    //

    epvcUnlinkFromExternal(
        pEpvcWorkItem->pParentObj,                  // pObject
        0x3a70de02,
        (UINT_PTR)pNdisWorkItem,                // Instance1
        EPVC_ASSOC_WORKITEM,            // AssociationID
        &SR
        );



    //
    // Call the function so that the work is completed
    //
    (pEpvcWorkItem->pFn) (pEpvcWorkItem->pParentObj, pEpvcWorkItem->ReturnStatus, &SR);

    EXIT();

}


VOID
epvcMiniportQueueWorkItem (
    IN PEPVC_WORK_ITEM pEpvcWorkItem,
    IN PEPVC_I_MINIPORT pMiniport,
    IN PEVPC_WORK_ITEM_FUNC pFn,
    IN NDIS_STATUS Status,
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Set up the Epvc Work Item with the pfn, Status and , ref the miniport 
     and then queue the workitem    
Arguments:
    
    
--*/
{
    ENTER("epvcMiniportQueueWorkItem ", 0xc041af99); 

    //
    // Store the contexts 
    //

    pEpvcWorkItem->ReturnStatus = Status; 
    pEpvcWorkItem->pParentObj = &pMiniport->Hdr;
    pEpvcWorkItem->pFn = pFn;

    //
    // Ref the RM Obj (its a miniport or an adapter)
    //
    epvcLinkToExternal( &pMiniport->Hdr,
                         0x62efba09,
                         (UINT_PTR)&pEpvcWorkItem->WorkItem,
                         EPVC_ASSOC_WORKITEM,
                         "    WorkItem %p\n",
                         pSR);

    //
    // Queue the WorkItem
    //
    
    epvcInitializeWorkItem (&pMiniport->Hdr,
                            &pEpvcWorkItem->WorkItem,
                            epvcCoGenericWorkItem,
                            NULL,
                            pSR);


    EXIT()

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\macros.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Macros used in ATMEPVC

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    ADube     03-23-00    created, .

--*/



#ifndef _MACROS_H
#define _MACROS_H


#define FALL_THROUGH    // For informational purpose in a switch statement


// Warning -- FAIL(NDIS_STATUS_PENDING) == TRUE
//
#define FAIL(_Status) ((_Status) != NDIS_STATUS_SUCCESS)
#define PEND(_Status) ((_Status) == NDIS_STATUS_PENDING)

#if RM_EXTRA_CHECKING
#define LOCKHDR(_pHdr, _psr) \
                        RmWriteLockObject((_pHdr), dbg_func_locid, (_psr))
#else // !RM_EXTRA_CHECKING
#define LOCKHDR(_pHdr, _psr) \
                        RmWriteLockObject((_pHdr), (_psr))
#endif // !RM_EXTRA_CHECKING

#define LOCKOBJ(_pObj, _psr) \
                        LOCKHDR(&(_pObj)->Hdr, (_psr))

#define UNLOCKHDR(_pHdr, _psr) \
                        RmUnlockObject((_pHdr), (_psr))
#define UNLOCKOBJ(_pObj, _psr) \
                        UNLOCKHDR(&(_pObj)->Hdr, (_psr))



#define EPVC_ALLOCSTRUCT(_p, _tag) \
                NdisAllocateMemoryWithTag(&(_p), sizeof(*(_p)), (_tag))

                

#define EPVC_FREE(_p)           NdisFreeMemory((_p), 0, 0)

#define EPVC_ZEROSTRUCT(_p) \
                NdisZeroMemory((_p), sizeof(*(_p)))

#define ARRAY_LENGTH(_array) (sizeof(_array)/sizeof((_array)[0]))

#if RM_EXTRA_CHECKING
#define DBG_ADDASSOC(_phdr, _e1, _e2, _assoc, _fmt, _psr)\
                                    RmDbgAddAssociation(    \
                                        dbg_func_locid,     \
                                        (_phdr),            \
                                        (UINT_PTR) (_e1),   \
                                        (UINT_PTR) (_e2),   \
                                        (_assoc),           \
                                        (_fmt),             \
                                        (_psr)              \
                                        )

#define DBG_DELASSOC(_phdr, _e1, _e2, _assoc, _psr)         \
                                    RmDbgDeleteAssociation( \
                                        dbg_func_locid,     \
                                        (_phdr),            \
                                        (UINT_PTR) (_e1),   \
                                        (UINT_PTR) (_e2),   \
                                        (_assoc),           \
                                        (_psr)              \
                                        )


// (debug only) Enumeration of types of associations.
//




#else // !RM_EXTRA_CHECKING
#define DBG_ADDASSOC(_phdr, _e1, _e2, _assoc, _fmt, _psr) (0)
#define DBG_DELASSOC(_phdr, _e1, _e2, _assoc, _psr) (0)
#endif  // !RM_EXTRA_CHECKING





#define EPVC_ATPASSIVE()     (KeGetCurrentIrql()==PASSIVE_LEVEL)









#if DO_TIMESTAMPS

    void
    epvcTimeStamp(
        char *szFormatString,
        UINT Val
        );
    #define  TIMESTAMP(_FormatString) \
        epvcTimeStamp( "TIMESTAMP %lu:%lu.%lu ATMEPVC " _FormatString "\n", 0)
    #define  TIMESTAMP1(_FormatString, _Val) \
        epvcTimeStamp( "TIMESTAMP %lu:%lu.%lu ATMEPVC " _FormatString "\n", (_Val))

#else // !DO_TIMESTAMPS

    #define  TIMESTAMP(_FormatString)
    #define  TIMESTAMP1(_FormatString, _Val)
#endif // !DO_TIMESTAMPS


#define TRACE_BREAK(_Mod, Str)      \
    TRACE (TL_A, _Mod, Str);        \
    ASSERT (NdisStatus == NDIS_STATUS_SUCCESS); \
    break;

#define GET_ADAPTER_FROM_MINIPORT(_pM) _pM->pAdapter


//
// Miniport Flag access routines
//

#define MiniportTestFlag(_A, _F)                ((epvcReadFlags(&(_A)->Hdr.State) & (_F))!= 0)
#define MiniportSetFlag(_A, _F)                 (epvcSetFlags(&(_A)->Hdr.State, (_F)))
#define MiniportClearFlag(_A, _F)               (epvcClearFlags(&(_A)->Hdr.State, (_F)))
#define MiniportTestFlags(_A, _F)               ((epvcReadFlags(&(_A)->Hdr.State) & (_F)) == (_F))


//
// Adapter Flag access routines
//

#define AdapterTestFlag(_A, _F)                 ((epvcReadFlags(&(_A)->Hdr.State) & (_F))!= 0)
#define AdapterSetFlag(_A, _F)                  (epvcSetFlags(&(_A)->Hdr.State, (_F)))
#define AdapterClearFlag(_A, _F)                (epvcClearFlags(&(_A)->Hdr.State, (_F)))
#define AdapterTestFlags(_A, _F)                ((epvcReadFlags(&(_A)->Hdr.State) & (_F)) == (_F))

#define epvcLinkToExternal(_Hdr, _Luid, _Ext, _Num, _Str, _sr)  \
    RmLinkToExternalEx (_Hdr,_Luid,_Ext,_Num,_Str,_sr);


#define epvcUnlinkFromExternal(_Hdr, _Luid, _Ext, _Assoc, _sr)  \
        RmUnlinkFromExternalEx(                                     \
            _Hdr,                                                   \
            _Luid,                                                  \
            _Ext,                                                   \
            _Assoc,                                                 \
            _sr                                                     \
            );





/*++
ULONG
LINKSPEED_TO_CPS(
    IN  ULONG               LinkSpeed
)
Convert from NDIS "Link Speed" to cells per second
--*/
#define LINKSPEED_TO_CPS(_LinkSpeed)        (((_LinkSpeed)*100)/(48*8))




#define CALL_PARAMETER_SIZE     sizeof(CO_CALL_PARAMETERS) +   \
                                sizeof(CO_CALL_MANAGER_PARAMETERS) + \
                                sizeof(CO_MEDIA_PARAMETERS) + \
                                sizeof(ATM_MEDIA_PARAMETERS)




#define MP_OFFSET(field) ((UINT)FIELD_OFFSET(EPVC_I_MINIPORT,field))
#define MP_SIZE(field) sizeof(((PEPVC_I_MINIPORT)0)->field)


// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.  The
// stash-area is a ULONGLONG so that all allocated blocks remain ULONGLONG
// aligned as they would be otherwise, preventing problems on Alphas.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = ulTag;
    return (pBuf + MEMORY_ALLOCATION_ALIGNMENT);
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}



#define CanMiniportIndicate(_M) (MiniportTestFlag(_M, fMP_MiniportInitialized)== TRUE)


#define epvcIncrementMallocFailure()


#define ASSERTAndBreak(_condition)          ASSERT(_condition); break;

#define epvcSetSendPktStats()

#define epvcSendCompleteStats()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\driver.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    ATMEPVC - Driver Entry and associated functions

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    ADube      03-23-00    created, .

--*/


#include "precomp.h"
#pragma hdrstop

#pragma NDIS_INIT_FUNCTION(DriverEntry)


//
// temp global variables
//
NDIS_HANDLE ProtHandle, DriverHandle;


//
// global variables
//

NDIS_PHYSICAL_ADDRESS           HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1, -1);
NDIS_HANDLE                     ProtHandle = NULL;
NDIS_HANDLE                     DriverHandle = NULL;
NDIS_MEDIUM                     MediumArray[1] =
                                    {
                                        NdisMediumAtm
                                    };


LIST_ENTRY                      g_ProtocolList;                                 
EPVC_GLOBALS                    EpvcGlobals;


RM_STATUS
epvcResHandleGlobalProtocolList(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );




RM_STATUS
epvcRegisterIMDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );




RM_STATUS
epvcUnloadDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );

RM_STATUS
epvcDeRegisterIMDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );

RM_STATUS
epvcIMDriverRegistration(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    );


//--------------------------------------------------------------------------------
//                                                                              //
//  Global Root structure definitions                                           //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


// List of fixed resources used by ArpGlobals
//
enum
{
    RTYPE_GLOBAL_PROTOCOL_LIST,
    RTYPE_GLOBAL_REGISTER_IM
    
}; // EPVC_GLOBAL_RESOURCES;

//
// Identifies information pertaining to the use of the above resources.
// Following table MUST be in strict increasing order of the RTYPE_GLOBAL
// enum.
//

RM_RESOURCE_TABLE_ENTRY 
EpvcGlobals_ResourceTable[] =
{

    {RTYPE_GLOBAL_PROTOCOL_LIST,    epvcResHandleGlobalProtocolList},

    {RTYPE_GLOBAL_REGISTER_IM,  epvcIMDriverRegistration}


};

// Static information about ArpGlobals.
//
RM_STATIC_OBJECT_INFO
EpvcGlobals_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "EpvcGlobals",  // TypeName
    0, // Timeout

    NULL, // pfnCreate
    NULL, // pfnDelete
    NULL, // pfnVerifyLock

    sizeof(EpvcGlobals_ResourceTable)/sizeof(EpvcGlobals_ResourceTable[1]),
    EpvcGlobals_ResourceTable
};






//--------------------------------------------------------------------------------
//                                                                              //
//  Underlying Adapters. The Protocol gets called at BindAdapter for            //
//  each adapter                                                                //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------



// eovcAdapter_HashInfo contains information required maintain a hashtable
// of EPVC_ADAPTER objects.
//
RM_HASH_INFO
epvcAdapter_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    epvcAdapterCompareKey,  // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    epvcAdapterHash     // pfnHash

};


// EpvcGlobals_AdapterStaticInfo  contains static information about
// objects of type EPVC_ADAPTERS.
// It is a group of Adapters that the protocol has bound to
//
RM_STATIC_OBJECT_INFO
EpvcGlobals_AdapterStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Adapter",  // TypeName
    0, // Timeout

    epvcAdapterCreate,  // pfnCreate
    epvcAdapterDelete,      // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &epvcAdapter_HashInfo
};



//--------------------------------------------------------------------------------
//                                                                              //
//  Intermediate miniports - each hangs of a protocol block                     //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------

// arpAdapter_HashInfo contains information required maintain a hashtable
// of EPVC_ADAPTER objects.
//
RM_HASH_INFO
epvc_I_Miniport_HashInfo= 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    epvcIMiniportCompareKey,    // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    epvcIMiniportHash       // pfnHash

};


RM_STATIC_OBJECT_INFO
EpvcGlobals_I_MiniportStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "IMiniport",    // TypeName
    0, // Timeout

    epvcIMiniportCreate,    // pfnCreate
    epvcIMiniportDelete,        // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &epvc_I_Miniport_HashInfo
};




//
// Variables used in debugging
//
#if DBG
ULONG g_ulTraceLevel= DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK ;
#endif










NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    )
/*++

Routine Description:


Arguments:

Return Value:


--*/
{
    NDIS_STATUS                     Status;
    NTSTATUS                        NtStatus;

    BOOLEAN     AllocatedGlobals = FALSE;
    ENTER("DriverEntry", 0xbfcb7eb1)


    RM_DECLARE_STACK_RECORD(SR)

    TIMESTAMP("==>DriverEntry");

    
    TRACE ( TL_T, TM_Dr,("==>Atm Epvc DriverEntry\n"));


    do
    {
        //
        // Inititalize the global variables
        //

        
        // Must be done before any RM apis are used.
        //
        RmInitializeRm();

        RmInitializeLock(
                    &EpvcGlobals.Lock,
                    LOCKLEVEL_GLOBAL
                    );

        RmInitializeHeader(
                NULL,                   // pParentObject,
                &EpvcGlobals.Hdr,
                ATMEPVC_GLOBALS_SIG  ,
                &EpvcGlobals.Lock,
                &EpvcGlobals_StaticInfo,
                NULL,                   // szDescription
                &SR
                );


        AllocatedGlobals = TRUE;

        //
        // Initialize globals
        //
        EpvcGlobals.driver.pDriverObject = DriverObject;
        EpvcGlobals.driver.pRegistryPath  = RegistryPath;


        //
        // Register the IM Miniport with NDIS.
        //
        Status = RmLoadGenericResource(
                    &EpvcGlobals.Hdr,
                    RTYPE_GLOBAL_PROTOCOL_LIST,
                    &SR
                    );

        if (FAIL(Status)) break;

        //
        // Register the protocol with NDIS.
        //
        Status = RmLoadGenericResource(
                    &EpvcGlobals.Hdr,
                    RTYPE_GLOBAL_REGISTER_IM,
                    &SR
                    );

        if (FAIL(Status)) break;

    
    } while (FALSE);

    
    if (FAIL(Status))
    {
        if (AllocatedGlobals)
        {
            RmUnloadAllGenericResources(
                    &EpvcGlobals.Hdr,
                    &SR
                    );
            RmDeallocateObject(
                    &EpvcGlobals.Hdr,
                    &SR
                    );
        }

        // Must be done after any RM apis are used and async activity complete.
        //
        RmDeinitializeRm();

        NtStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        NtStatus = NDIS_STATUS_SUCCESS;
    }

    EXIT()

    TIMESTAMP("<==DriverEntry");

    RM_ASSERT_CLEAR(&SR);
    
    return Status ;

}




VOID
EpvcUnload(
    IN  PDRIVER_OBJECT              pDriverObject
)
/*++

Routine Description:

    This routine is called by the system prior to unloading us.
    Currently, we just undo everything we did in DriverEntry,
    that is, de-register ourselves as an NDIS protocol, and delete
    the device object we had created.

Arguments:

    pDriverObject   - Pointer to the driver object created by the system.

Return Value:

    None

--*/
{
    NDIS_STATUS NdisStatus; 
    ENTER("Unload", 0xc8482549)
    RM_DECLARE_STACK_RECORD(sr);
    

    TIMESTAMP("==>Unload");


    RmUnloadAllGenericResources(&EpvcGlobals.Hdr, &sr);

    RmDeallocateObject(&EpvcGlobals.Hdr, &sr);

    // Must be done after any RM apis are used and async activity complete.
    //
    RmDeinitializeRm();

    // TODO? Block(250);

    RM_ASSERT_CLEAR(&sr)
    EXIT()
    TIMESTAMP("<==Unload");
    return;
}



RM_STATUS
epvcResHandleGlobalProtocolList(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
    )
{
    PEPVC_GLOBALS               pGlobals    = NULL;


    ENTER("GlobalAdapterList", 0xb407e79e)
    
    TRACE (TL_T, TM_Dr, ("==>epvcResHandleGlobalProtocolList pObj %x, Op", 
                         pObj , Op ) );


    pGlobals    = CONTAINING_RECORD(
                                      pObj,
                                      EPVC_GLOBALS,
                                      Hdr);


    //
    // 
    if (Op == RM_RESOURCE_OP_LOAD)
    {
        //
        //  Allocate adapter list.
        //
        TR_WARN(("LOADING"));

        RmInitializeGroup(
                        pObj,                                   // pParentObject
                        &EpvcGlobals_AdapterStaticInfo,         // pStaticInfo
                        &(pGlobals->adapters.Group),            // pGroup
                        "Adapters Group",                       // szDescription
                        pSR                                     // pStackRecord
                        );
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // We're unloading this "resource", i.e., unloading and deallocating the 
        // global adapter list. We first unload and free all the adapters
        // in the list, and then free the list itself.
        //
        TR_WARN(("UNLOADING"));
        
        //
        // We expect there to be no adapter objects at this point.
        //
        ASSERT(pGlobals->adapters.Group.HashTable.NumItems == 0);


        RmDeinitializeGroup(&pGlobals->adapters.Group, pSR);
        NdisZeroMemory(&(pGlobals->adapters), sizeof(pGlobals->adapters));
    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(!"Unexpected OpCode epvcResHandleGlobalProtocolList ");
    }




    TRACE (TL_T, TM_Dr, ("<==epvcResHandleGlobalProtocolList Status %x", 
                         NDIS_STATUS_SUCCESS) );

    EXIT()
    RM_ASSERT_CLEAR(pSR);

    return NDIS_STATUS_SUCCESS;

}



RM_STATUS
epvcIMDriverRegistration(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    )
{
    TRACE (TL_T, TM_Mp, ("epvcIMDriverRegistration Op %x", Op));
    if (RM_RESOURCE_OP_LOAD == Op)
    {
        epvcRegisterIMDriver(pObj,Op,pvUserParams,psr);
    }
    else
    {
        epvcDeRegisterIMDriver(pObj,Op,pvUserParams,psr);
    }

    return NDIS_STATUS_SUCCESS;
}


RM_STATUS
epvcRegisterIMDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    )
{
    NDIS_STATUS                     Status = NDIS_STATUS_FAILURE;
    PEPVC_GLOBALS                   pGlobals    = NULL;
    NDIS_PROTOCOL_CHARACTERISTICS   PChars;
    NDIS_MINIPORT_CHARACTERISTICS   MChars;
    NDIS_STRING                     Name;

    ENTER("epvcRegisterIMDriver", 0x0d0f008a);
    
    pGlobals    = CONTAINING_RECORD(
                                      pObj,
                                      EPVC_GLOBALS,
                                      Hdr);



    TRACE (TL_T, TM_Dr, ("==>epvcRegisterIMDriver Globals %x", 
                         pObj) );

    //
    // Register the miniport with NDIS. Note that it is the miniport
    // which was started as a driver and not the protocol. Also the miniport
    // must be registered prior to the protocol since the protocol's BindAdapter
    // handler can be initiated anytime and when it is, it must be ready to
    // start driver instances.
    //
    NdisMInitializeWrapper(&pGlobals->driver.WrapperHandle, 
                       pGlobals->driver.pDriverObject, 
                       pGlobals->driver.pRegistryPath, 
                       NULL);
    NdisZeroMemory(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

    MChars.MajorNdisVersion = 5;
    MChars.MinorNdisVersion = 0;

    MChars.InitializeHandler = EpvcInitialize;
    MChars.QueryInformationHandler = EpvcMpQueryInformation;
    MChars.SetInformationHandler = EpvcMpSetInformation;
    MChars.ResetHandler = MPReset;
    MChars.TransferDataHandler = MPTransferData;
    MChars.HaltHandler = EpvcHalt;

    //
    // We will disable the check for hang timeout so we do not
    // need a check for hang handler!
    //
    MChars.CheckForHangHandler = NULL;
    MChars.SendHandler = NULL;
    MChars.ReturnPacketHandler = EpvcReturnPacket;

    //
    // Either the Send or the SendPackets handler should be specified.
    // If SendPackets handler is specified, SendHandler is ignored
    //
     MChars.SendPacketsHandler = EpvcSendPackets;

    Status = NdisIMRegisterLayeredMiniport(pGlobals->driver.WrapperHandle,
                                           &MChars,
                                           sizeof(MChars),
                                           &EpvcGlobals.driver.DriverHandle);

    ASSERT  (EpvcGlobals.driver.DriverHandle != NULL);                                          
    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // todo: fix failure case
        //
        ASSERT (0);
    };


    //
    // Now register the protocol.
    //
    NdisZeroMemory(&PChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    PChars.MajorNdisVersion = 5;
    PChars.MinorNdisVersion = 0;

    //
    // Make sure the protocol-name matches the service-name under which this protocol is installed.
    // This is needed to ensure that NDIS can correctly determine the binding and call us to bind
    // to miniports below.
    //
    NdisInitUnicodeString(&Name, L"ATMEPVCP");  // Protocol name
    PChars.Name = Name;
    PChars.OpenAdapterCompleteHandler = EpvcOpenAdapterComplete;
    PChars.CloseAdapterCompleteHandler = EpvcCloseAdapterComplete;
    PChars.SendCompleteHandler = NULL;
    PChars.TransferDataCompleteHandler = PtTransferDataComplete;
    
    PChars.ResetCompleteHandler = EpvcResetComplete;
    PChars.RequestCompleteHandler =     EpvcRequestComplete ;
    PChars.ReceiveHandler = PtReceive;
    PChars.ReceiveCompleteHandler = EpvcPtReceiveComplete;
    PChars.StatusHandler = EpvcStatus;
    PChars.StatusCompleteHandler = PtStatusComplete;
    PChars.BindAdapterHandler = EpvcBindAdapter;
    PChars.UnbindAdapterHandler = EpvcUnbindAdapter;
    PChars.UnloadHandler = NULL;
    PChars.ReceivePacketHandler = PtReceivePacket;
    PChars.PnPEventHandler= EpvcPtPNPHandler;
    PChars.CoAfRegisterNotifyHandler = EpvcAfRegisterNotify;
    PChars.CoSendCompleteHandler = EpvcPtSendComplete;  
    PChars.CoReceivePacketHandler = EpvcCoReceive;
    

    {
        //
        // Update client characteristis
        //
        PNDIS_CLIENT_CHARACTERISTICS    pNdisCC     = &(pGlobals->ndis.CC);

        NdisZeroMemory(pNdisCC, sizeof(*pNdisCC));
        pNdisCC->MajorVersion                   = EPVC_NDIS_MAJOR_VERSION;
        pNdisCC->MinorVersion                   = EPVC_NDIS_MINOR_VERSION;
        pNdisCC->ClCreateVcHandler              = EpvcClientCreateVc;
        pNdisCC->ClDeleteVcHandler              = EpvcClientDeleteVc;
        pNdisCC->ClRequestHandler               = EpvcCoRequest;
        pNdisCC->ClRequestCompleteHandler       = EpvcCoRequestComplete;
        pNdisCC->ClOpenAfCompleteHandler        = EpvcCoOpenAfComplete;
        pNdisCC->ClCloseAfCompleteHandler       = EpvcCoCloseAfComplete;
        pNdisCC->ClMakeCallCompleteHandler      = EpvcCoMakeCallComplete;
        pNdisCC->ClModifyCallQoSCompleteHandler = NULL;
        pNdisCC->ClIncomingCloseCallHandler     = EpvcCoIncomingClose;
        pNdisCC->ClCallConnectedHandler         = EpvcCoCallConnected;
        pNdisCC->ClCloseCallCompleteHandler     = EpvcCoCloseCallComplete;
        pNdisCC->ClIncomingCallHandler          = EpvcCoIncomingCall;

    }

    NdisRegisterProtocol(&Status,
                         &pGlobals->driver.ProtocolHandle,
                         &PChars,
                         sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    ASSERT(Status == NDIS_STATUS_SUCCESS);

    NdisMRegisterUnloadHandler(pGlobals->driver.WrapperHandle, 
                               EpvcUnload);

    ASSERT (pGlobals == &EpvcGlobals);                                     

    
    NdisIMAssociateMiniport(EpvcGlobals.driver.DriverHandle, pGlobals->driver.ProtocolHandle);


    EXIT()
        
    TRACE (TL_T, TM_Dr, ("<==epvcRegisterIMDriver  ") );

    return Status;

}


RM_STATUS
epvcDeRegisterIMDriver(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
    )
{

    NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;

    TRACE (TL_T, TM_Pt, ("== eovcDeRegisterIMDriver"));

    while (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        NdisDeregisterProtocol(&NdisStatus, EpvcGlobals.driver.ProtocolHandle);
        NdisMSleep(1000);
    }   


    return NdisStatus;
}



void
DbgMark(UINT Luid)
{
    // do nothing useful, but do something specific, so that the compiler doesn't
    // alias DbgMark to some other function that happens to do nothing.
    //
    static int i;
    i=Luid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\miniport.h ===
#ifndef _MINIPORT_H

#define _MINIPORT_H


//-------------------------------------------------------------//
//                                                              //
// Headers and Lengths used for Ethernet packets                    //
//                                                             //
//-------------------------------------------------------------//

#define MINIMUM_ETHERNET_LENGTH 64

#define ETHERNET_PADDING_LENGTH 2

// 64 bytes of zeroes - used in padding ethernet packets
extern UCHAR gPaddingBytes[MINIMUM_ETHERNET_LENGTH];

//-------------------------------------------------------------//
//                                                             //
// Function declarations                                          //
//                                                             //
//-------------------------------------------------------------//



PRM_OBJECT_HEADER
epvcIMiniportCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );


VOID
epvcIMiniportDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );


BOOLEAN
epvcIMiniportCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    );

ULONG
epvcIMiniportHash(
    PVOID           pKey
    );

VOID
epvcVcSetupDone (
    PTASK_VC pTaskVc, 
    PEPVC_I_MINIPORT pMiniport
    );

VOID
epvcVcTeardownDone(
    PTASK_VC pTaskVc, 
    PEPVC_I_MINIPORT pMiniport
    );
    
NDIS_STATUS
epvcSetPacketFilter(
    IN PEPVC_I_MINIPORT pMiniport,
    IN ULONG Filter,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
EpvcInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    );
VOID
EpvcHalt(
    IN  NDIS_HANDLE             MiniportAdapterContext
    );
NDIS_STATUS 
EpvcMpQueryInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
);



NDIS_STATUS 
EpvcMpSetInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
);







NDIS_STATUS
epvcMpSetNetworkAddresses(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    IN  PRM_STACK_RECORD        pSR,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
);


NDIS_STATUS
epvcMpSetNetworkAddresses(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    IN  PRM_STACK_RECORD        pSR,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
);


VOID
epvcSetupMakeCallParameters(
    PEPVC_I_MINIPORT pMiniport, 
    PCO_CALL_PARAMETERS *ppCallParameters
    );

VOID
epvcInitiateMiniportHalt(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PRM_STACK_RECORD pSR
    );

VOID
epvcMpHaltDoUnbind(
    PEPVC_I_MINIPORT pMiniport, 
    PRM_STACK_RECORD pSR
    );


NDIS_STATUS
epvcTaskHaltMiniport(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );
    


NDIS_STATUS
epvcAddLLCEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pOldPkt,
    PNDIS_PACKET pNewPkt,
    PRM_STACK_RECORD pSR
    );
    
NDIS_STATUS
epvcAdapterSend(
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPkt,
    PRM_STACK_RECORD pSR
    );


VOID
epvcGetSendPkt (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pSentPkt,
    IN PEPVC_SEND_STRUCT pSendStruct,
    IN PRM_STACK_RECORD pSR
    );


VOID
epvcFreeSendPkt(
    PEPVC_I_MINIPORT pMiniport,
    IN PEPVC_SEND_STRUCT pSendStruct
    );

NDIS_STATUS
epvcRemoveSendEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    );

NDIS_STATUS
epvcAddRecvEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    );


NDIS_STATUS
epvcRemoveSendEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    );


NDIS_STATUS
epvcRemoveRecvEncapsulation (
    PEPVC_I_MINIPORT pMiniport , 
    PNDIS_PACKET pNewPkt
    );


VOID
EpvcSendPackets(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    );


NDIS_STATUS
epvcMiniportReadConfig(
    IN PEPVC_I_MINIPORT pMiniport,
    NDIS_HANDLE     WrapperConfigurationContext,
    PRM_STACK_RECORD pSR
    );


VOID
epvcDumpPkt (
    IN PNDIS_PACKET pPkt
    );

BOOLEAN
epvcCheckAndReturnArps (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET pPkt,
    IN PEPVC_SEND_STRUCT pSendStruct,
    IN PRM_STACK_RECORD pSR
    );

    
VOID
epvcFormulateArpResponse (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PEPVC_ARP_CONTEXT pArpContext,
    IN PRM_STACK_RECORD pSR
    );
    


VOID
epvcInitializeMiniportLookasideLists (
    IN PEPVC_I_MINIPORT pMiniport
    );


NDIS_STATUS
epvcInitializeMiniportPacketPools (
    IN PEPVC_I_MINIPORT pMiniport
    );


VOID
epvcDeleteMiniportLookasideLists (
    IN PEPVC_I_MINIPORT pMiniport
    );

VOID
epvcDeleteMiniportPacketPools (
    IN PEPVC_I_MINIPORT pMiniport
    );

NDIS_STATUS
epvcTaskRespondToArp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );


VOID
epvcArpTimer(
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );


VOID
epvcExtractPktInfo (
    PEPVC_I_MINIPORT        pMiniport,
    PNDIS_PACKET            pPacket ,
    PEPVC_SEND_STRUCT       SendStruct
    );

NDIS_STATUS 
epvcRemoveEthernetHeader (
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    );


NDIS_STATUS
epvcSendRoutine(
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    PRM_STACK_RECORD pSR
    );

VOID
epvcSetPacketContext (
    IN PEPVC_SEND_STRUCT pSendStruct, 
    PRM_STACK_RECORD pSR
    );

VOID
epvcInitializeMiniportParameters(
    PEPVC_I_MINIPORT pMiniport
    );


VOID
epvcReturnPacketUsingAllocation(
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    OUT PNDIS_PACKET *ppOriginalPacket,
    IN  PRM_STACK_RECORD        pSR

    );


VOID
epvcReturnPacketUsingStacks (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    IN  PRM_STACK_RECORD        pSR

    );

VOID
EpvcReturnPacket(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            Packet
    );

VOID
epvcDerefSendPkt (
    PNDIS_PACKET pNdisPacket,
    PRM_OBJECT_HEADER pHdr
    );


VOID
epvcDerefRecvPkt (
    PNDIS_PACKET pNdisPacket,
    PRM_OBJECT_HEADER pHdr
    );
    
VOID
epvcRefRecvPkt(
    PNDIS_PACKET        pNdisPacket,
    PRM_OBJECT_HEADER   pHdr // either an adapter or a miniport
    );


NDIS_STATUS
epvcTaskCloseAddressFamily(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
epvcProcessReturnPacket (
    IN  PEPVC_I_MINIPORT    pMiniport,
    IN  PNDIS_PACKET        Packet,
    OUT PPNDIS_PACKET       ppOrigPacket, 
    IN  PRM_STACK_RECORD    pSR
    );

NDIS_STATUS 
epvcAddEthernetTail(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    );

VOID
epvcRemoveEthernetTail (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPacket,
    IN PEPVC_PKT_CONTEXT pContext
    );

VOID
epvcRemoveEthernetPad (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pPacket
    );

NDIS_STATUS 
epvcAddEthernetPad(
    PEPVC_SEND_STRUCT pSendStruct,  
    IN PRM_STACK_RECORD pSR
    );


VOID
epvcCancelDeviceInstance(
    IN PEPVC_I_MINIPORT pMiniport ,
    IN PRM_STACK_RECORD pSR
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

    Abstract:

            Precompiled header file for ATMEPVC.SYS

            Author:


            Revision History:

Who         When        What
--------    --------    ----
 ADube      03-23-00   created 

--*/





//
// This file has all the C Defines that will be used in the compilation
// 
#include "ccdefs.h"

//
// Common header files in ntos\inc
//

#include <ndis.h>
#include <atm40.h>

//
// RM apis
//
#include "rmdbg.h"
#include "rm.h"

//
// Local Header files
//
#include "macros.h"
#include "debug.h"
#include "priv.h"
#include "util.h"
#include "client.h"
#include "miniport.h"
#include "protocol.h"
#include "wrapper.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\miniport.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    ATM Ethernet PVC driver

Author:
    ADube - created
    
Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//--------------------------------------------------------------------------------
//                                                                              //
//  Global Variables used by miniports                                          //
//                                                                              //
//--------------------------------------------------------------------------------

static
NDIS_OID EthernetSupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_ID,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_GEN_NETWORK_LAYER_ADDRESSES,
    };


MP_REG_ENTRY NICRegTable[] = {
// reg value name                  Offset in MP_ADAPTER            Field size        Default Value              Min             Max               
{NDIS_STRING_CONST("VCI"),       0, MP_OFFSET(config.vci),     MP_SIZE(config.vci),      0,                      0,              65535},
{NDIS_STRING_CONST("VPI"),       0, MP_OFFSET(config.vpi),     MP_SIZE(config.vpi),      0,                      0,              255},
{NDIS_STRING_CONST("Encap"),     0, MP_OFFSET(Encap),          MP_SIZE(Encap),           2,                      0,              3},
};
    

BOOLEAN g_bDumpPackets = FALSE;
BOOLEAN g_fDiscardNonUnicastPackets  = DISCARD_NON_UNICAST;

//-------------------------------------------------------------//
//                                                             //
// Pre defined LLC, SNAP and Other Headers for encapsulation        //
//                                                             //
//-------------------------------------------------------------//


//
// Ethernet Encapsulation
//
UCHAR LLCSnapEthernet[] = 
{
    0xaa, 0xaa,0x03, // LLC
    0x00, 0x80,0xc2, // OUI
    0x00, 0x07,      // PID
    0x00, 0x00       // PAD
};

//
// Ip v4 encapsulation
//
UCHAR LLCSnapIpv4[8] = 
{
    0xaa, 0xaa,0x03, // LLC
    0x00, 0x00,0x00, // OUI
    0x08, 0x00       // PID
};


UCHAR gPaddingBytes[MINIMUM_ETHERNET_LENGTH] = 
{
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,
    0,0,0,0

};





//--------------------------------------------------------------------------------
//                                                                              //
//  miniports   functions                                                          //
//                                                                              //
//--------------------------------------------------------------------------------


VOID
epvcReturnPacketUsingAllocation(
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    OUT PNDIS_PACKET *ppOriginalPacket,
    IN  PRM_STACK_RECORD        pSR

    )
/*++

Routine Description:
 Extracts the original packet 
 frees all the ndis buffers in new packet
 
 returns the original packet 
 

Arguments:


Return Value:


--*/
{   
    PNDIS_PACKET        pOrigPacket = NULL;
    PEPVC_PKT_CONTEXT   pPktContext = NULL;

    TRACE (TL_T, TM_Recv , ("==>epvcReturnPacketUsingAllocation  pMiniport %p, pPacket %p", 
                          pMiniport, 
                          Packet));

    pPktContext = (PEPVC_PKT_CONTEXT )(Packet->MiniportReservedEx);

    pOrigPacket = pPktContext->pOriginalPacket;

    if (pMiniport->fDoIpEncapsulation == TRUE)
    {
        //
        // Extract the lookaside buffer from the packet
        //
        PNDIS_BUFFER            pBuffer = Packet->Private.Head;
        PEPVC_IP_RCV_BUFFER     pIpBuffer= pPktContext ->Stack.ipv4Recv.pIpBuffer;


        if (pIpBuffer == NULL)
        {
            return ; // early return because of failure
        }
        ASSERT (pIpBuffer == NdisBufferVirtualAddress (pBuffer));

        

        //
        // Free the Lookaside Buffer
        //
        epvcFreeToNPagedLookasideList (&pMiniport->rcv.LookasideList,
                                       (PVOID)pIpBuffer);           

        
        //
        // In this case, we have allocated a new ndis buffer
        // so delete it and free the local memory
        epvcFreeBuffer (pBuffer);


        // 
        // The original packet is unchanged and well./
        //
    }
    else
    {
        //
        // This code path is used in both Ethernet and Ethernet+LLC encaps
        //

        // We only need to free the head of the packet as that was allocated
        // by us
        PNDIS_BUFFER            pNdisBuffer = Packet->Private.Head;

        if (pNdisBuffer != NULL)
        {
            epvcFreeBuffer (pNdisBuffer);
        }
    }

    
    epvcFreePacket(Packet,&pMiniport->PktPool.Recv);

    *ppOriginalPacket = pOrigPacket;


    TRACE (TL_T, TM_Recv , ("<==epvcReturnPacketUsingAllocation  pOrigPacket %p", 
                             *ppOriginalPacket));

    return;
}



VOID
epvcReturnPacketUsingStacks (
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    IN  PRM_STACK_RECORD        pSR

    )
/*++

Routine Description:
    
    ipv4 - Restores the orginal Head and tail to this packet
    
 

Arguments:


Return Value:


--*/
{
    PEPVC_PKT_CONTEXT   pPktContext = NULL;
    BOOLEAN Remaining = FALSE; // Unused
    PNDIS_BUFFER    pOldHead = NULL;
    PNDIS_BUFFER    pOldTail = NULL;

    TRACE (TL_T, TM_Recv , ("==>epvcReturnPacketUsingStacks pMiniport %p, pPacket %p", 
                            pMiniport, 
                            Packet));
                            
    pPktContext = (PEPVC_PKT_CONTEXT ) NdisIMGetCurrentPacketStack(Packet, &Remaining);



    if (pMiniport->fDoIpEncapsulation == TRUE)
    {
        //
        // Extract the lookaside buffer from the packet
        //
        PNDIS_BUFFER            pBuffer = Packet->Private.Head;
        PEPVC_IP_RCV_BUFFER     pIpBuffer= pPktContext ->Stack.ipv4Recv.pIpBuffer;

        if (pIpBuffer == NULL)
        {
            return; // early return
        }

        //
        // Extract the old head and tail from the packet
        //
        pOldHead = pIpBuffer->pOldHead;
        pOldTail = pIpBuffer->pOldTail;


        // check to see if we are in this code path because of a failure
        if (pOldHead == NULL)
        {
            return; // early return
        }
        ASSERT (pOldHead != NULL);
        ASSERT (pOldTail != NULL);
        
        ASSERT (&pIpBuffer->u.Byte[0] == NdisBufferVirtualAddress (pBuffer));



        // 
        // Set The original Head and Tail
        //
        Packet->Private.Head = pOldHead;
        Packet->Private.Tail = pOldTail;

        Packet->Private.ValidCounts= FALSE;

        //
        // Free the Lookaside Buffer
        //
        epvcFreeToNPagedLookasideList (&pMiniport->rcv.LookasideList,
                                       (PVOID)pIpBuffer);           

        
        //
        // In this case, we have allocated a new ndis buffer
        // so delete it and free the local memory
        epvcFreeBuffer (pBuffer);
    }
    else
    {
        //
        // This code path is used in both Ethernet and Ethernet+LLC encaps
        //
        
        //
        // We need to free the head as that was locally allocated/
        // We need to revert back to the old Head and tail stored 
        // in the context
        //
        if (pPktContext->Stack.EthLLC.pOldHead == NULL)
        {
            return ; //early return 
        }

        epvcFreeBuffer (Packet->Private.Head);

        Packet->Private.Head = pPktContext->Stack.EthLLC.pOldHead;
        Packet->Private.Tail = pPktContext->Stack.EthLLC.pOldTail;

        Packet->Private.ValidCounts= FALSE;

    }

    TRACE (TL_T, TM_Recv , ("<==epvcReturnPacketUsingStacks ",pMiniport, Packet));

    return;

}


VOID
epvcProcessReturnPacket (
    IN  PEPVC_I_MINIPORT    pMiniport,
    IN  PNDIS_PACKET        Packet,
    OUT PPNDIS_PACKET       ppOrigPacket, 
    IN  PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:
 Free all the locally allocated structures in the packet (packet , mdl, memory)
 Also be able to handle failure cases

Arguments:


Return Value:


--*/
{
    ENTER("epvcProcessReturnPacket", 0x7fafa89d)
    PNDIS_PACKET pOrigPacket = NULL;
    
    TRACE (TL_T, TM_Recv , ("==>epvcProcessReturnPacket  pMiniport %p, pPacket %p", 
                          pMiniport, 
                          Packet));

    if (Packet == NULL)
    {
        return;
    }
    //
    // Packet stacking: Check if this packet belongs to us.
    //
    
    if (NdisGetPoolFromPacket(Packet) != pMiniport->PktPool.Recv.Handle)
    {
        //
        // We reused the original packet in a receive indication.
        //
        epvcReturnPacketUsingStacks (pMiniport, Packet, pSR);
        pOrigPacket = Packet;
    }
    else
    {
        //
        // This is a packet allocated from this IM's receive packet pool.
        // Reclaim our packet, and return the original to the driver below.
        //
        epvcReturnPacketUsingAllocation(pMiniport, Packet, &pOrigPacket, pSR);
    }

    //
    // Update the output variable
    //
    if (ppOrigPacket)
    {
        *ppOrigPacket = pOrigPacket;
    }
    EXIT()
}
    



VOID
EpvcReturnPacket(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    ENTER ("EpvcReturnPacket",0x58d2259e)
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT)MiniportAdapterContext;
    PNDIS_PACKET pOrigPacket = NULL;

    RM_DECLARE_STACK_RECORD (SR);

    // Free all the locally allocated structures in the packet
    //
    epvcProcessReturnPacket (pMiniport, Packet, &pOrigPacket ,&SR);

    // Return the original packet to ndis
    //
    if (pOrigPacket != NULL)
    {
        epvcReturnPacketToNdis(pMiniport, pOrigPacket, &SR);
    }
    else
    {
        ASSERT (!"Original packet is NULL\n");
    }
    
    EXIT();

}



NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer
    )
/*++

Routine Description:

    Miniport's transfer data handler.

Arguments:

    Packet                  Destination packet
    BytesTransferred        Place-holder for how much data was copied
    MiniportAdapterContext  Pointer to the adapter structure
    MiniportReceiveContext  Context
    ByteOffset              Offset into the packet for copying data
    BytesToTransfer         How much to copy.

Return Value:

    Status of transfer

--*/
{
    PEPVC_I_MINIPORT pMiniport= (PEPVC_I_MINIPORT)MiniportAdapterContext;
    NDIS_STATUS Status;

    //
    // Return, if the device is OFF
    //

    if (MiniportTestFlag (pMiniport, fMP_MiniportInitialized) == FALSE)
    {
        return NDIS_STATUS_FAILURE;
    }


    NdisTransferData(&Status,
                     pMiniport->pAdapter->bind.BindingHandle,
                     MiniportReceiveContext,
                     ByteOffset,
                     BytesToTransfer,
                     Packet,
                     BytesTransferred);

    return(Status);
}







NDIS_STATUS
MPReset(
    OUT PBOOLEAN                AddressingReset,
    IN  NDIS_HANDLE             MiniportAdapterContext
    )
/*++

Routine Description:

    Reset Handler. We just don't do anything.

Arguments:

    AddressingReset         To let NDIS know whether we need help from it with our reset
    MiniportAdapterContext  Pointer to our adapter

Return Value:


--*/
{
    PADAPT  pAdapt = (PADAPT)MiniportAdapterContext;



    *AddressingReset = FALSE;

    return(NDIS_STATUS_SUCCESS);
}


//
// The functions that do the LBFO work and bundling.
// If LBFO is turned off, then the Set Scondary API is never called and there are no bundles
//






//--------------------------------------------------------------------------------
//                                                                              //
//  Intermediate Miniports. We have one instantiation per address family.       //
//  Entry points used by the RM Apis                                            //
//                                                                              //
//                                                                              //
//                                                                              //
//--------------------------------------------------------------------------------


PRM_OBJECT_HEADER
epvcIMiniportCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        )
/*++

Routine Description:

    Allocate and initialize an object of type EPVC_I_MINIPORT.

Arguments:

    pParentObject   - Object that is to be the parent of the adapter.
    pCreateParams   - Actually a pointer to a EPVC_I_MINIPORT_PARAMS structure,
                      which contains information required to create the adapter.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    PEPVC_I_MINIPORT            pIM;
    PEPVC_I_MINIPORT_PARAMS     pParams = (PEPVC_I_MINIPORT_PARAMS)pCreateParams;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    extern RM_STATIC_OBJECT_INFO EpvcGlobals_I_MiniportStaticInfo; 

    ENTER("IMiniport Create", 0x075b24c1);

    
    TRACE (TL_V, TM_Pt, ("--> epvcIMiniportCreate") );

    EPVC_ALLOCSTRUCT(pIM, TAG_MINIPORT  );
    do
    {


        if (pIM == NULL)
        {
            break;
        }

        EPVC_ZEROSTRUCT(pIM);

        pIM->Hdr.Sig = TAG_MINIPORT;

        //
        // Do all the initialization work here
        //

        RmInitializeLock(
            &pIM->Lock,
            LOCKLEVEL_MINIPORT
            );

        RmInitializeHeader(
            pParentObject,
            &pIM->Hdr,
            TAG_MINIPORT,
            &pIM->Lock,
            &EpvcGlobals_I_MiniportStaticInfo,
            NULL,
            psr
            );

        //
        // Now initialize the adapter structure with the parameters 
        // that were passed in.
        //

        Status = epvcCopyUnicodeString(
                        &(pIM->ndis.DeviceName),
                        pParams->pDeviceName,
                        TRUE                        // Upcase
                        );

        if (FAIL(Status))
        {
            pIM->ndis.DeviceName.Buffer=NULL; // so we don't try to free it later
            break;
        }

        //
        // initialize the informational stuff on the miniport
        //
        pIM->pAdapter               = pParams->pAdapter;
        pIM->info.PacketFilter      = 0;
        pIM->info.CurLookAhead      = pParams->CurLookAhead; 
        pIM->info.NumberOfMiniports     = pParams->NumberOfMiniports;
        pIM->info.LinkSpeed         = pParams->LinkSpeed.Outbound;
        pIM->info.MediaState        = pParams->MediaState;

        
        //
        //  Start by using the real ATM card's MAC address
        //
        
        NdisMoveMemory(
            &pIM->MacAddressEth,
            &pIM->pAdapter->info.MacAddress, 
            sizeof(MAC_ADDRESS)
            );

            //
            //  Not Elan number zero so generate a locally 
            //  administered address by manipulating the first two bytes.
            //
            pIM->MacAddressEth.Byte[0] = 
                0x02 | (((UCHAR)pIM->info.NumberOfMiniports & 0x3f) << 2);
            pIM->MacAddressEth.Byte[1] = 
                (pIM->pAdapter->info.MacAddress.Byte[1] & 0x3f) | 
                ((UCHAR)pIM->info.NumberOfMiniports & 0x3f);


            pIM->info.MacAddressDummy   =   pIM->MacAddressEth;

            pIM->info.MacAddressDummy.Byte[0]++;
            
            pIM->info.MacAddressDummy.Byte[1]++;

            pIM->info.MacAddressDummy.Byte[2]++;

        
        {
            //
            // Create a Dummy Mac address  for receive indications
            //
            pIM->info.MacAddressDest = pIM->MacAddressEth;
            
            
        
        }

        {
            //
            // Create an Ethernet Header to be used
            //
            PEPVC_ETH_HEADER    pRcvEnetHeader = &pIM->RcvEnetHeader ;

            pRcvEnetHeader->eh_daddr = pIM->info.MacAddressDest;
            pRcvEnetHeader->eh_saddr  = pIM->info.MacAddressDummy;
            pRcvEnetHeader->eh_type = net_short (IP_PROT_TYPE );  

        }

        pIM->info.McastAddrCount = 0;

        Status = NDIS_STATUS_SUCCESS;


    }
    while(FALSE);

    if (FAIL(Status))
    {
        if (pIM != NULL)
        {
            epvcIMiniportDelete ((PRM_OBJECT_HEADER) pIM, psr);
            pIM = NULL;
        }
    }

    TRACE (TL_V, TM_Pt, ("<-- epvcIMiniportCreate pIMiniport. %p",pIM) );

    return (PRM_OBJECT_HEADER) pIM;
}


VOID
epvcIMiniportDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Free an object of type EPVC_I_MINIPORT.

Arguments:

    pHdr    - Actually a pointer to the EPVC_I_MINIPORT to be deleted.

--*/
{
    PEPVC_I_MINIPORT pMiniport = (PEPVC_I_MINIPORT) pObj;

    TRACE (TL_V, TM_Pt, ("-- epvcIMiniportDelete  pAdapter %p",pMiniport) );
    
    pMiniport->Hdr.Sig = TAG_FREED;

    EPVC_FREE   (pMiniport);
}




BOOLEAN
epvcIMiniportCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for EPVC_I_MINIPORT.

Arguments:

    pKey        - Points to a Epvc Protocol object.
    pItem       - Points to EPVC_I_MINIPORT.Hdr.HashLink.

Return Value:

    TRUE IFF the key (adapter name) exactly matches the key of the specified 
    adapter object.

--*/
{
    PEPVC_I_MINIPORT pIM = NULL;
    PNDIS_STRING pName = (PNDIS_STRING) pKey;
    BOOLEAN fCompare;

    pIM  = CONTAINING_RECORD(pItem, EPVC_I_MINIPORT, Hdr.HashLink);

    //
    // TODO: maybe case-insensitive compare?
    //

    if (   (pIM->ndis.DeviceName.Length == pName->Length)
        && NdisEqualMemory(pIM->ndis.DeviceName.Buffer, pName->Buffer, pName->Length))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    

    TRACE (TL_V, TM_Pt, ("-- epvcProtocolCompareKey pIM %p, pKey, return %x",pIM, pKey, fCompare ) );

    return fCompare;
}



ULONG
epvcIMiniportHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be a pointer to an Epvc Protocol block.

Return Value:

    ULONG-sized hash of the string.
    

--*/
{
    TRACE(TL_T, TM_Mp, ("epvcIMiniportHash %x", pKey));
    {   
        PNDIS_STRING pName = (PNDIS_STRING) pKey;
        WCHAR *pwch = pName->Buffer;
        WCHAR *pwchEnd = pName->Buffer + pName->Length/sizeof(*pwch);
        ULONG Hash  = 0;


        for (;pwch < pwchEnd; pwch++)
        {
            Hash ^= (Hash<<1) ^ *pwch;
        }
        
        return Hash;
    }
    
}





NDIS_STATUS
epvcTaskVcSetup(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:


Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{

    ENTER("epvcTaskVcSetup", 0x64085960)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_VC            pTaskVc     = (PTASK_VC) pTask;
    PEPVC_ADAPTER       pAdapter    = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;
    NDIS_HANDLE         NdisVcHandle = NULL;
    PCO_CALL_PARAMETERS pCallParameters = NULL;


    enum 
    {
        Stage_Start =0, // default
        Stage_CreateVc,
        Stage_MakeCall,
        Stage_DeleteVc, // in case of failure
        Stage_TaskCompleted,
        Stage_End       
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task



    
    TRACE ( TL_T, TM_Pt, ("==> epvcTaskVcSetup %x",pTask->Hdr.State  ) );

    switch (pTask->Hdr.State)
    {
        case Stage_Start:
        {
            LOCKOBJ (pMiniport, pSR);
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->vc.pTaskVc)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->vc.pTaskVc);
                
                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->vc.pTaskVc == pTaskVc);
            //
            // Check to see if our work is already done
            //
            if (MiniportTestFlag(pMiniport,  fMP_MakeCallSucceeded) == TRUE)
            {
                //
                // Our work had been done. So break out and complete the task
                //
                Status = NDIS_STATUS_SUCCESS;
                pTaskVc->ReturnStatus = NDIS_STATUS_SUCCESS;

                
                pTask->Hdr.State = Stage_TaskCompleted;
                UNLOCKOBJ(pMiniport, pSR);
                break;
            }

            MiniportClearFlag (pMiniport,fMP_InfoCallClosed);
            MiniportSetFlag (pMiniport, fMP_InfoMakingCall);

            UNLOCKOBJ(pMiniport, pSR);

            //
            // Now begin the real work
            //

            //
            // Set up the call parameters. If it fails ,then exit
            //
            epvcSetupMakeCallParameters(pMiniport, &pCallParameters);

            if (pCallParameters  == NULL)
            {
                Status = NDIS_STATUS_FAILURE;
                pTaskVc->ReturnStatus = NDIS_STATUS_FAILURE;
                pTask->Hdr.State = Stage_TaskCompleted;
                break;
            
            }
            //
            // Create Vc - Syncronous call
            // 
            ASSERT (pAdapter->Hdr.Sig = TAG_ADAPTER);
            
            Status  = epvcCoCreateVc(pAdapter->bind.BindingHandle,
                                    pMiniport->af.AfHandle      OPTIONAL,   // For CM signalling VCs
                                    pMiniport,
                                    &NdisVcHandle);
                                    
            ASSERT (PEND(Status) == FALSE); // this is a synchronous call

            if (FAIL(Status) == TRUE)
            {       
                //
                // We have failed. This task is done. There are not
                // resources to be freed, although a flag has to be 
                // cleared
                //
                NdisVcHandle = NULL;
                pMiniport->vc.VcHandle = NULL;

                pTask->Hdr.State = Stage_TaskCompleted;
                break;
            }

            ASSERT (Status == NDIS_STATUS_SUCCESS);
            //
            // Store the Vc Handle
            //
            LOCKOBJ (pMiniport, pSR);

            pMiniport->vc.VcHandle = NdisVcHandle;
            epvcLinkToExternal( &pMiniport->Hdr,
                             0xf52962f1,
                             (UINT_PTR)pMiniport->vc.VcHandle,
                             EPVC_ASSOC_MINIPORT_OPEN_VC,
                             "    VcHandle %p\n",
                             pSR);


            UNLOCKOBJ (pMiniport, pSR);


    
            //
            // Do a Make Call
            //
            pTask->Hdr.State  = Stage_MakeCall;


            RmSuspendTask(pTask, 0, pSR);
            
            Status = epvcClMakeCall(NdisVcHandle,
                                 pCallParameters,
                                 NULL,  //Party Context
                                 NULL // PartyHandle
                                 );
                                 
            if (NDIS_STATUS_PENDING !=Status)
            {
                EpvcCoMakeCallComplete(Status,
                                      pMiniport,
                                      NULL,
                                      0);
                
                
            }
            break;  
        }
        case Stage_MakeCall:
        {
            //
            // The make call has been completed. 
            // If we have succeeded then we update our flags 
            // and exit.
            //
            // If the make call has failed, then I need to delete the VC
            //

            ASSERT (NDIS_STATUS_CALL_ACTIVE  != pTaskVc->ReturnStatus);
            
            if (NDIS_STATUS_SUCCESS == pTaskVc->ReturnStatus)
            {
                LOCKOBJ(pMiniport, pSR);

                MiniportSetFlag (pMiniport, fMP_MakeCallSucceeded);
                MiniportClearFlag (pMiniport, fMP_InfoMakingCall);

    
                UNLOCKOBJ (pMiniport, pSR);

                
            
            }
            else
            {
                NDIS_HANDLE VcHandle = NULL;
                //
                // Delete the VC, as we do not want a VC without an active 
                // Make call on it.
                //
                ASSERT (NDIS_STATUS_SUCCESS == pTaskVc->ReturnStatus);              
                                        
                LOCKOBJ(pMiniport, pSR);

                VcHandle = pMiniport->vc.VcHandle;
                
                epvcUnlinkFromExternal( &pMiniport->Hdr,
                                        0xa914405a,
                                        (UINT_PTR)pMiniport->vc.VcHandle,
                                        EPVC_ASSOC_MINIPORT_OPEN_VC, 
                                        pSR);

                pMiniport->vc.VcHandle = NULL;

                UNLOCKOBJ (pMiniport, pSR);

                TRACE (TL_I, TM_Mp,("Deleting Vc because of a failure in MakeCall"));

                Status = epvcCoDeleteVc(VcHandle);
                
                //
                // TODO: Fix Failure case
                //
                ASSERT (NDIS_STATUS_SUCCESS == Status );

                
            
                
            }

            //
            // This task is over. Now do the indications
            //
            pTask->Hdr.State = Stage_TaskCompleted;

            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        

    } // end of switch 

    if ( Stage_TaskCompleted == pTask->Hdr.State )
    {

        pTask->Hdr.State = Stage_End;

        ASSERT (NDIS_STATUS_PENDING !=Status );

        //
        // Do any cleanup indications to NDIS over here
        //
        epvcVcSetupDone ( pTaskVc, pMiniport);

        LOCKOBJ(pMiniport, pSR);

        pMiniport->vc.pTaskVc = NULL;
    
        UNLOCKOBJ (pMiniport, pSR);

        

    }

    TRACE ( TL_T, TM_Mp, ("<== epvcTaskVcSetup , Status %x",Status) );

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    return Status;          

}


VOID
epvcVcSetupDone (
    PTASK_VC pTaskVc, 
    PEPVC_I_MINIPORT pMiniport
    )
/*++

Routine Description:

    If the task was queued because of SetPacket Filter request then 
    this function completes the request.

    If the task was run because of the Indicate Media Connect event, then
    this thread indicates a Media Connect to NDIS

Arguments:
    Status  - Did the VcSetup Succeed or Fail
    pTaskVc - Task in question
    pMiniport - the Miniport that the task operated on
    
Return Value:

    None:
    
--*/
    
{


    if (TaskCause_NdisRequest == pTaskVc->Cause )
    {
        //
        // Since requests are serialized, we don't acquire the lock
        //
        TRACE (TL_V, TM_Rq, ("Completing SetPacketFilter Request %x", pTaskVc->ReturnStatus ));

        if (pTaskVc->ReturnStatus == NDIS_STATUS_SUCCESS)
        {
            pMiniport->info.PacketFilter = pTaskVc->PacketFilter;
        }
        NdisMSetInformationComplete (pMiniport->ndis.MiniportAdapterHandle, pTaskVc->ReturnStatus);

    }
    else
    {
        ASSERT (TaskCause_MediaConnect == pTaskVc->Cause );

        pMiniport->info.MediaState = NdisMediaStateConnected;
        
        NdisMIndicateStatus ( pMiniport->ndis.MiniportAdapterHandle,
                              NDIS_STATUS_MEDIA_CONNECT,
                              NULL,
                              0);
    }


}



NDIS_STATUS
epvcTaskVcTeardown(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:


Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{

    ENTER("epvcTaskVcTeardown", 0x68c96c4d)
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT ) RM_PARENT_OBJECT(pTask);
    PTASK_VC            pTaskVc     = (PTASK_VC) pTask;
    PEPVC_ADAPTER       pAdapter    = (PEPVC_ADAPTER)pMiniport->Hdr.pParentObject;
    NDIS_HANDLE         NdisVcHandle = NULL;
    PCO_CALL_PARAMETERS pCallParameters = NULL;


    enum 
    {
        Stage_Start =0, // default
        Stage_CloseCallComplete,
        Stage_DeleteVc, 
        Stage_TaskCompleted,
        Stage_End
    
    }; // To be used in pTask->Hdr.State to indicate the state of the Task

    TRACE ( TL_T, TM_Pt, ("==> epvcTaskVcTeardown %x",pTask->Hdr.State  ) );

    switch (pTask->Hdr.State)
    {
        case Stage_Start:
        {
            LOCKOBJ (pMiniport, pSR);
            
            if (epvcIsThisTaskPrimary ( pTask, &(PRM_TASK)(pMiniport->vc.pTaskVc)) == FALSE)
            {
                PRM_TASK pOtherTask = (PRM_TASK)(pMiniport->vc.pTaskVc);
                
                RmTmpReferenceObject (&pOtherTask->Hdr, pSR);

                //
                // Set The state so we restart this code after main task completes 
                //

                pTask->Hdr.State = Stage_Start;
                UNLOCKOBJ(pMiniport, pSR);

                

                RmPendTaskOnOtherTask (pTask, 0, pOtherTask, pSR);

                RmTmpDereferenceObject(&pOtherTask->Hdr,pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We are the primary task
            //
            ASSERT (pMiniport->vc.pTaskVc == pTaskVc);
            //
            // Check to see if our work is already done
            //
            if (MiniportTestFlag(pMiniport,  fMP_MakeCallSucceeded) == FALSE)
            {
                //
                // Our work had been done. So break out and complete the task
                //
                Status = NDIS_STATUS_SUCCESS;
                pTask->Hdr.State = Stage_TaskCompleted;
                UNLOCKOBJ(pMiniport, pSR);
                break;
            }

            
            MiniportClearFlag (pMiniport, fMP_MakeCallSucceeded);
            MiniportSetFlag (pMiniport, fMP_InfoClosingCall);
    
            UNLOCKOBJ(pMiniport, pSR);

            //
            // Now close the call - Asynchronously. 
            //
            pTask->Hdr.State = Stage_CloseCallComplete;

            RmSuspendTask (pTask, 0, pSR);
            
            Status = epvcClCloseCall( pMiniport->vc.VcHandle);

            if (NDIS_STATUS_PENDING != Status)
            {
                EpvcCoCloseCallComplete (Status,
                                         pMiniport,
                                         NULL
                                         );
                
            }

            Status = NDIS_STATUS_PENDING;
            break;
        }

        case Stage_CloseCallComplete:
        {
            NDIS_HANDLE VcHandle = NULL;
            
            LOCKOBJ(pMiniport, pSR);

            VcHandle = pMiniport->vc.VcHandle;
            
            epvcUnlinkFromExternal(&pMiniport->Hdr,
                                   0x5d7b5ea8,
                                   (UINT_PTR)pMiniport->vc.VcHandle,
                                   EPVC_ASSOC_MINIPORT_OPEN_VC,
                                   pSR);

            pMiniport->vc.VcHandle = NULL;
            
            UNLOCKOBJ(pMiniport, pSR);

            Status = epvcCoDeleteVc(VcHandle);
            //
            // This is an assertion because the DeleteVc cannot fail.
            // We do a DeleteVc in one place only and it is serialized.
            //

            ASSERT (Status == NDIS_STATUS_SUCCESS);

            pTask->Hdr.State = Stage_TaskCompleted;

            break;
        }

        case Stage_End:
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        
        
    }


    if (Stage_TaskCompleted == pTask->Hdr.State )
    {
        pTask->Hdr.State  = Stage_End;

        //
        // Complete the request or the Media Disconnect;
        //
        epvcVcTeardownDone(pTaskVc, pMiniport);

        LOCKOBJ (pMiniport, pSR);

        //
        // Update informational flags
        //
        MiniportClearFlag (pMiniport, fMP_InfoClosingCall);
        MiniportSetFlag (pMiniport, fMP_InfoCallClosed);

        pMiniport->vc.pTaskVc = NULL;
    
        
        UNLOCKOBJ(pMiniport, pSR);
    }
    TRACE ( TL_T, TM_Mp, ("<== epvcTaskVcTeardown , Status %x",Status) );

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    return Status;          

}



VOID
epvcVcTeardownDone(
    PTASK_VC pTaskVc, 
    PEPVC_I_MINIPORT pMiniport
    )
{
    TRACE ( TL_T, TM_Mp, ("==> epvcVcTeardownDone ") );

    switch (pTaskVc->Cause)
    {
        case TaskCause_NdisRequest:
        {

            ASSERT (pTaskVc->ReturnStatus != NDIS_STATUS_PENDING);

            //
            // Since requests are serialized, we don't acquire the lock
            //
            pMiniport->info.PacketFilter = pTaskVc->PacketFilter;

            NdisMSetInformationComplete(pMiniport->ndis.MiniportAdapterHandle,
                                        pTaskVc->ReturnStatus);
            
            break;
        }
        case TaskCause_MediaDisconnect:
        {
        
            pMiniport->info.MediaState = NdisMediaStateDisconnected;
            
            epvcMIndicateStatus ( pMiniport,
                                  NDIS_STATUS_MEDIA_DISCONNECT,
                                  NULL,
                                  0);
            break;
        }

        default:
        {
            // Do nothing.
            //
        }
        




    }

    
    


    TRACE ( TL_T, TM_Mp, ("<== epvcVcTeardownDone ") );

}





NDIS_STATUS
EpvcInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    )
/*++

Routine Description:

    This is the initialize handler which gets called as a result of the BindAdapter handler
    calling NdisIMInitializeDeviceInstanceEx(). The context parameter which we pass there is
    the adapter structure which we retreive here. We also need to initialize the Power Management
    variable.
    LoadBalalncing- We keep a global list of all the passthru miniports installed and bundle
    two of them together if they have the same BundleId (read from registry)

    Arguments:

    OpenErrorStatus         Not used by us.
    SelectedMediumIndex     Place-holder for what media we are using
    MediumArray             Array of ndis media passed down to us to pick from
    MediumArraySize         Size of the array
    MiniportAdapterHandle   The handle NDIS uses to refer to us
    WrapperConfigurationContext For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    ENTER ("EpvcInitialize", 0xa935a2a5)
    UINT    i;
    PEPVC_I_MINIPORT                pMiniport = NULL;
    NDIS_STATUS                     Status = NDIS_STATUS_FAILURE;
    KIRQL                           OldIrql;
    
    enum 
    {
        Stage_Start,
        Stage_AllocatedPacketPools,
        Stage_AllocatedLookasideLists
    };

    ULONG                           State = Stage_Start;

    RM_DECLARE_STACK_RECORD (SR);
    
    TRACE (TL_T, TM_Mp, ("==>EpvcInitialize MiniportAdapterHandle %x", MiniportAdapterHandle));

    //
    // Start off by retrieving the adapter context and storing the Miniport handle in it
    //
    pMiniport = NdisIMGetDeviceContext(MiniportAdapterHandle);

    if (pMiniport->Hdr.Sig != TAG_MINIPORT)
    {
        ASSERT (pMiniport->Hdr.Sig == TAG_MINIPORT);
        return NDIS_STATUS_FAILURE;
    }
    
    pMiniport->ndis.MiniportAdapterHandle  = MiniportAdapterHandle;

    //
    // Make sure the medium saved is one of the ones being offered
    //

    for (i = 0; i < MediumArraySize; i++)
    {
        if (MediumArray[i] == ATMEPVC_MP_MEDIUM )
        {
            *SelectedMediumIndex = i;
            break;
        }
    }

    if (i == MediumArraySize)
    {
        return(NDIS_STATUS_UNSUPPORTED_MEDIA);
    }


    //
    // Set the attributes now. The NDIS_ATTRIBUTE_DESERIALIZE is the key. This enables us
    // to make up-calls to NDIS w/o having to call NdisIMSwitchToMiniport/NdisIMQueueCallBack.
    // This also forces us to protect our data using spinlocks where appropriate. Also in this
    // case NDIS does not queue packets on out behalf. Since this is a very simple pass-thru
    // miniport, we do not have a need to protect anything. However in a general case there
    // will be a need to use per-adapter spin-locks for the packet queues at the very least.
    //
    NdisMSetAttributesEx(MiniportAdapterHandle,
                         pMiniport,
                         0,                                     // CheckForHangTimeInSeconds
                         NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT   |
                            NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT|
                            NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
                            NDIS_ATTRIBUTE_DESERIALIZE,                         
                         0);


    //
    // We are done, with the no failure stuff. From now on we need to undo
    //

    do
    {

        Status = epvcMiniportReadConfig(pMiniport, WrapperConfigurationContext,&SR  );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            //
            // Undo Configuration values
            // 
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;

        }

        epvcInitializeMiniportParameters(pMiniport);

        
        //
        // allocate Packet pools.
        //

        Status = epvcInitializeMiniportPacketPools (pMiniport);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERT (Status == NDIS_STATUS_SUCCESS);
            break;
        }

        State = Stage_AllocatedPacketPools;
 

        //
        // Allocate lookaside lists
        //

        epvcInitializeMiniportLookasideLists(pMiniport);


        State = Stage_AllocatedLookasideLists;


        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);
    

    TRACE (TL_T, TM_Mp, ("<==EpvcInitialize pMiniport %x, Status %x", pMiniport, Status ));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        BOOLEAN fSetDeInit = FALSE;
        
        LOCKOBJ(pMiniport, &SR);
        MiniportSetFlag(pMiniport, ,fMP_MiniportInitialized);

        if (MiniportTestFlag (pMiniport, fMP_MiniportCancelInstance))
        {
            fSetDeInit = TRUE;
        }
        UNLOCKOBJ(pMiniport, &SR);

        //
        // Check to see if we have a DeInit Waiting for us.
        // This will only be set if a Cancel Device Instance fails.
        //
        if (fSetDeInit  == TRUE)
        {
            epvcSetEvent (&pMiniport->pnp.DeInitEvent);
        }
    }
    else
    {
        //
        // Undo Code
        //
        ASSERT (FAIL(Status) == TRUE);
        
        switch (State)
        {

            case Stage_AllocatedLookasideLists:

                epvcDeleteMiniportLookasideLists (pMiniport);

                FALL_THROUGH
                
            case Stage_AllocatedPacketPools:

                epvcDeleteMiniportPacketPools(pMiniport);
                FALL_THROUGH


            default:
                break;



        }



    }


    RM_ASSERT_CLEAR(&SR);
    EXIT();
    return Status;
}


VOID
EpvcHalt(
    IN  NDIS_HANDLE             MiniportAdapterContext
    )
/*++

Routine Description:

    Halt handler. All the hard-work for clean-up is done here.

Arguments:

    MiniportAdapterContext  Pointer to the Adapter

Return Value:

    None.

--*/
{
    ENTER("EpvcHalt",0x6b407ae1)
    PEPVC_I_MINIPORT    pMiniport   = (PEPVC_I_MINIPORT)MiniportAdapterContext;
    PEPVC_ADAPTER       pAdapter    = pMiniport->pAdapter;
    PRM_TASK            pTask       = NULL;
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;

    RM_DECLARE_STACK_RECORD (SR);
    
    TRACE (TL_V, TM_Mp, ("==>Epvc MPHaltMiniport"));

    do
    {
        LOCKOBJ (pMiniport, &SR);
        //
        // Clear the flag so we can block all sends/receives/requests
        //
        MiniportClearFlag(pMiniport, fMP_MiniportInitialized);
        MiniportSetFlag(pMiniport, fMP_InfoHalting);                    
    
        //
        // Ref the miniport, this indirectly refs the adpater as well
        //
        RmTmpReferenceObject (&pMiniport->Hdr, &SR);

        //
        // Kick of the miniport halt task and wait for it to complete
        //
        Status = epvcAllocateTask(
                &pMiniport->Hdr,            // pParentObject,
                epvcTaskHaltMiniport,   // pfnHandler,
                0,                          // Timeout,
                "Task: Halt Intermediate Miniport", // szDescription
                &pTask,
                &SR
                );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        //
        // Reference the task so it is around until our Wait for completion
        // is complete
        //
        RmTmpReferenceObject (&pTask->Hdr, &SR);

        UNLOCKOBJ (pMiniport, &SR);

        //
        // This Kicks of the task that will close the Call, Delete
        // the VC and close the AF. We do this all synchronously
        //
        {
            PTASK_HALT pHalt = (PTASK_HALT) pTask;
            
            epvcInitializeEvent (&pHalt->CompleteEvent);
            
            RmStartTask(pTask, 0, &SR);

            TRACE (TL_V, TM_Mp, ("About to Wait - for Halt Complete Event"));

            epvcWaitEvent (&pHalt->CompleteEvent, WAIT_INFINITE);

            TRACE (TL_V, TM_Mp, ("Wait Complete- for Halt Complete Event"));


        }       

        LOCKOBJ (pMiniport, &SR);

        //
        // Deref the task . Ref was made above.
        //
        
        RmTmpDereferenceObject (&pTask->Hdr, &SR);


    } while (FALSE);    


    MiniportClearFlag(pMiniport, fMP_InfoHalting);

    UNLOCKOBJ(pMiniport, &SR);

    RmTmpDereferenceObject(&pMiniport->Hdr, &SR);


    RM_ASSERT_CLEAR(&SR);

    TRACE (TL_V, TM_Mp, ("<==Epvc MPHaltMiniport"));

}



VOID    
epvcSetPacketFilterWorkItem (
    PNDIS_WORK_ITEM  pWorkItem, 
    PVOID Context
    )
/*++
Routine Description:

    Decrements the refcount on the filter and processes the new packet filter
    

Return Value:

    None
    
--*/
{
    ENTER ("epvcSetPacketFilterWorkItem  ",0x3e1cdbba )
    PEPVC_I_MINIPORT    pMiniport = NULL;
    PRM_TASK            pTask = NULL;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    UINT                Filter ;
    
    RM_DECLARE_STACK_RECORD (SR);


    do
    {
        pMiniport = CONTAINING_RECORD (pWorkItem, 
                                       EPVC_I_MINIPORT,
                                       vc.PacketFilterWorkItem) ;

        //
        // Dereference the workitem off the miniport 
        //
            

        epvcUnlinkFromExternal( &pMiniport->Hdr,
                             0xa1f5e3cc,
                             (UINT_PTR)pWorkItem,
                             EPVC_ASSOC_SET_FILTER_WORKITEM,
                             &SR);

        //
        // Start the task to create or delete the VC
        //
        Filter = pMiniport->vc.NewFilter ;
        //
        // If this is a repition, then succeed it synchronously
        //
        if (Filter  == pMiniport->info.PacketFilter)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        LOCKOBJ(pMiniport, &SR);

        //
        // Are we moving to a Zero filter value
        //

        if (Filter  == 0)
        {
            //
            // Delete the Vc, so that we stop doing any receives
            // 

            Status = epvcAllocateTask(
                &pMiniport->Hdr,            // pParentObject,
                epvcTaskVcTeardown, // pfnHandler,
                0,                          // Timeout,
                "Task: Delete Vc",  // szDescription
                &pTask,
                &SR
                );


        }
        else
        {
            //
            // We are moving a non-zero values
            //

            //
            // Create the Vc, so that we can send 
            // 

            Status = epvcAllocateTask(
                &pMiniport->Hdr,            // pParentObject,
                epvcTaskVcSetup,    // pfnHandler,
                0,                          // Timeout,
                "Task: Create Vc",  // szDescription
                &pTask,
                &SR
                );



        }

        UNLOCKOBJ(pMiniport, &SR);
        
        if (FAIL(Status) == TRUE)
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate create/ delete Vc task!\n"));
            ASSERT (0);
            break;
        }
        


        //
        // Update the cause if the task
        //
        
        ((PTASK_VC)pTask)->Cause = TaskCause_NdisRequest;
        ((PTASK_VC)pTask)->PacketFilter  = Filter  ;
        
        RmStartTask(pTask, 0, &SR);

        Status = NDIS_STATUS_PENDING;

    } while (FALSE);

    //
    // complete the request if the task has not been started
    //
    if (PEND(Status) != TRUE)
    {
        NdisMSetInformationComplete (pMiniport->ndis.MiniportAdapterHandle, Status);

    }

    EXIT();
}




NDIS_STATUS
epvcSetPacketFilter(
    IN PEPVC_I_MINIPORT pMiniport,
    IN ULONG Filter,
    PRM_STACK_RECORD pSR
    )

/*++
Routine Description:

    This routine is called when a miniport get a set packet filter.
    It validates the arguments, If all is well then it process the request

    For a non-zero filter, a create VC and a Make call is done.
    For a zero filter, the call is closed and the Vc Deleted

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    ENTER ("epvcSetPacketFilter", 0x97c6b961)
    NDIS_STATUS Status = NDIS_STATUS_PENDING;
    PNDIS_WORK_ITEM pSetFilterWorItem = &pMiniport->vc.PacketFilterWorkItem; 
    PRM_TASK pTask = NULL;

    
    TRACE (TL_T, TM_Mp, ("==>epvcSetPacketFilter Filter %X", Filter ));

    do
    {
        LOCKOBJ (pMiniport, pSR);

        epvcLinkToExternal( &pMiniport->Hdr,
                             0x20bc1fbf,
                             (UINT_PTR)pSetFilterWorItem,
                             EPVC_ASSOC_SET_FILTER_WORKITEM,
                             "    PacketFilterWorkItem %p\n",
                             pSR);

        //
        // Update the cause of the task
        //
        UNLOCKOBJ(pMiniport, pSR);


        //
        // Now schedule the work item so it runs at passive level and pass the Vc as
        // an argument
        //

        pMiniport->vc.NewFilter = Filter;
        
        NdisInitializeWorkItem ( pSetFilterWorItem , 
                             (NDIS_PROC)epvcSetPacketFilterWorkItem ,
                             (PVOID)pTask );

                            

        NdisScheduleWorkItem (pSetFilterWorItem );

            

        Status = NDIS_STATUS_PENDING;


    } while (FALSE);
    


    TRACE (TL_T, TM_Mp, ("<==epvcSetPacketFilter %x", Status));

    EXIT();
    return Status;
}



NDIS_STATUS 
EpvcMpQueryInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
)
/*++

Routine Description:

    The QueryInformation Handler for the virtual miniport.

Arguments:

    MiniportAdapterContext  - a pointer to the Elan.

    Oid                     - the NDIS_OID to process.

    InformationBuffer       - a pointer into the NdisRequest->InformationBuffer
                              into which store the result of the query.

    InformationBufferLength - a pointer to the number of bytes left in the
    InformationBuffer.

    BytesWritten            - a pointer to the number of bytes written into the
    InformationBuffer.

    BytesNeeded             - If there is not enough room in the information
                              buffer then this will contain the number of bytes
                              needed to complete the request.

Return Value:

    The function value is the status of the operation.

--*/
{
    ENTER ("EpvcMpQueryInformation", 0x3da2473b)
    UINT                    BytesLeft       = InformationBufferLength;
    PUCHAR                  InfoBuffer      = (PUCHAR)(InformationBuffer);
    NDIS_STATUS             StatusToReturn  = NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS    HardwareStatus  = NdisHardwareStatusReady;
    NDIS_MEDIUM             Medium;
    PEPVC_I_MINIPORT        pMiniport = NULL;   
    PEPVC_ADAPTER           pAdapter= NULL;
    ULONG                   GenericULong =0;
    USHORT                  GenericUShort=0;
    UCHAR                   GenericArray[6];
    UINT                    MoveBytes       = sizeof(ULONG);
    PVOID                   MoveSource      = (PVOID)(&GenericULong);
    ULONG                   i=0;
    BOOLEAN                 IsShuttingDown = FALSE;
    RM_DECLARE_STACK_RECORD (SR);
        
    TRACE(TL_T, TM_Rq, ("==>EpvcMpQueryInformation pMiniport %x, Oid, Buffer %x, Length, %x",
                       pMiniport,
                       Oid,
                       InformationBuffer,
                       InformationBufferLength));               

    pMiniport = (PEPVC_I_MINIPORT)MiniportAdapterContext;


    LOCKOBJ(pMiniport, &SR);
    IsShuttingDown = (! MiniportTestFlag(pMiniport, fMP_MiniportInitialized));
    pAdapter = pMiniport->pAdapter;
    UNLOCKOBJ(pMiniport,&SR);

    //
    // Switch on request type
    //
    switch (Oid) 
    {
        case OID_GEN_MAC_OPTIONS:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAC_OPTIONS"));

            GenericULong =                      
                NDIS_MAC_OPTION_NO_LOOPBACK;

            break;

        case OID_GEN_SUPPORTED_LIST:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_SUPPORTED_LIST"));

            MoveSource = (PVOID)(EthernetSupportedOids);
            MoveBytes = sizeof(EthernetSupportedOids);

            break;

        case OID_GEN_HARDWARE_STATUS:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_HARDWARE_STATUS"));

            HardwareStatus = NdisHardwareStatusReady;
            MoveSource = (PVOID)(&HardwareStatus);
            MoveBytes = sizeof(NDIS_HARDWARE_STATUS);

            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MEDIA_CONNECT_STATUS"));

            MoveSource = (PVOID)(&pMiniport->info.MediaState);
            MoveBytes = sizeof(NDIS_MEDIA_STATE);

            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MEDIA_SUPPORTED"));
            Medium = ATMEPVC_MP_MEDIUM;

            MoveSource = (PVOID) (&Medium);
            MoveBytes = sizeof(NDIS_MEDIUM);

            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAXIMUM_LOOKAHEAD"));

            GenericULong = pMiniport->info.CurLookAhead;
            
            
            break;
            
        case OID_GEN_CURRENT_LOOKAHEAD:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_CURRENT_LOOKAHEAD"));
            GenericULong  = pMiniport->info.CurLookAhead  ;
            
            
            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAXIMUM_FRAME_SIZE"));
            // 
            // Similiar to AtmLane . Take the size of the Ethernet frame and strip the
            // ethernet header off. 
            //
            GenericULong = EPVC_MAX_FRAME_SIZE  - EPVC_ETH_HEADERSIZE   ;
            
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAXIMUM_TOTAL_SIZE"));
            //
            // This value is inclusive of headers 
            //
            GenericULong = EPVC_MAX_FRAME_SIZE;
                        
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_TRANSMIT_BLOCK_SIZE"));
            //
            // This is inclusive of headers. 
            //
            GenericULong = EPVC_MAX_FRAME_SIZE;
            

            break;
            
        case OID_GEN_RECEIVE_BLOCK_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_RECEIVE_BLOCK_SIZE"));
            GenericULong = EPVC_MAX_FRAME_SIZE ;
            
            break;
        
        case OID_GEN_MAXIMUM_SEND_PACKETS:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_MAXIMUM_SEND_PACKETS"));
            GenericULong = 32;      // XXX What is our limit? From adapter?
            
            break;
        
            case OID_GEN_LINK_SPEED:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_LINK_SPEED"));
            GenericULong = pMiniport->info.LinkSpeed;

            
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_RECEIVE_BUFFER_SPACE"));
            GenericULong = 32 * 1024;   // XXX What should this really be?
            

            break;

        case OID_GEN_VENDOR_ID:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_VENDOR_ID"));
            NdisMoveMemory(
                (PVOID)&GenericULong,
                &pMiniport->MacAddressEth,
                3
                );
            GenericULong &= 0xFFFFFF00;
            MoveSource = (PVOID)(&GenericULong);
            MoveBytes = sizeof(GenericULong);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_VENDOR_DESCRIPTION"));
            MoveSource = (PVOID)"Microsoft ATM Ethernet Emulation";
            MoveBytes = 28;

            break;

        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_VENDOR_DRIVER_VERSION:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_DRIVER_VERSION"));
            GenericUShort = ((USHORT)5 << 8) | 0;
            MoveSource = (PVOID)(&GenericUShort);
            MoveBytes = sizeof(GenericUShort);

            break;

        case OID_802_3_PERMANENT_ADDRESS:
        case OID_802_3_CURRENT_ADDRESS:
        
            TRACE (TL_V, TM_Rq,(" Miniport Query OID_802_3_CURRENT_ADDRESS"));

            NdisMoveMemory((PCHAR)GenericArray,
                        &pMiniport->MacAddressEth,
                        sizeof(MAC_ADDRESS));
            MoveSource = (PVOID)(GenericArray);
            MoveBytes = sizeof(MAC_ADDRESS);


            break;


        case OID_802_3_MULTICAST_LIST:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_802_3_MULTICAST_LIST"));
            MoveSource = (PVOID) &pMiniport->info.McastAddrs[0];
            MoveBytes = pMiniport->info.McastAddrCount * sizeof(MAC_ADDRESS);

            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_802_3_MAXIMUM_LIST_SIZE"));
            GenericULong = MCAST_LIST_SIZE;
        
            
            break;
            


        case OID_GEN_XMIT_OK:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_XMIT_OK"));
            GenericULong = (UINT)(pMiniport->count.FramesXmitOk);
            
            break;

        case OID_GEN_RCV_OK:

            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_RCV_OK"));
            GenericULong = (UINT)(pMiniport->count.FramesRecvOk);

            
            break;
        case OID_GEN_RCV_ERROR:
        
            TRACE (TL_V, TM_Rq,(" Miniport Query OID_GEN_RCV_OK"));
            GenericULong = pMiniport->count.RecvDropped ;
            break;

        case OID_GEN_XMIT_ERROR:
        case OID_GEN_RCV_NO_BUFFER:
        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:
    
            TRACE (TL_V, TM_Rq,(" Miniport Query - Unimplemented Stats Oid"));
            GenericULong = 0;

            
            break;

        default:

            StatusToReturn = NDIS_STATUS_INVALID_OID;
            break;

    }


    if (StatusToReturn == NDIS_STATUS_SUCCESS) 
    {
        if (MoveBytes > BytesLeft) 
        {
            //
            // Not enough room in InformationBuffer. Punt
            //
            *BytesNeeded = MoveBytes;

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        }
        else
        {
            //
            // Store and print result.
            //
            NdisMoveMemory(InfoBuffer, MoveSource, MoveBytes);

            TRACE (TL_V, TM_Rq, ("Query Request Oid %x", Oid));
            DUMPDW( TL_V, TM_Rq, MoveSource, MoveBytes);
            
            (*BytesWritten) = MoveBytes;
        }
    }


    TRACE(TL_T, TM_Rq, ("<==EpvcMpQueryInformation Status %x",StatusToReturn)); 
    RM_ASSERT_CLEAR(&SR);
    return StatusToReturn;
}




NDIS_STATUS 
EpvcMpSetInformation(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_OID                Oid,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
)
/*++

Routine Description:

    Handles a set operation for a single OID.

Arguments:

    MiniportAdapterContext  - a pointer to the Elan.

    Oid                     - the NDIS_OID to process.

    InformationBuffer       - Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead               - If the call is successful, returns the number
                              of bytes read from InformationBuffer.

    BytesNeeded             - If there is not enough data in InformationBuffer
                              to satisfy the OID, returns the amount of storage
                              needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID

--*/
{
    ENTER ("EpvcMpSetInformation", 0x619a7528)
    NDIS_STATUS         StatusToReturn  = NDIS_STATUS_SUCCESS;
    UINT                BytesLeft       = InformationBufferLength;
    PUCHAR              InfoBuffer      = (PUCHAR)(InformationBuffer);
    UINT                OidLength;
    ULONG               LookAhead;
    ULONG               Filter;
    PEPVC_I_MINIPORT    pMiniport = NULL;
    PEPVC_ADAPTER       pAdapter = NULL;
    BOOLEAN             IsShuttingDown = FALSE;
    RM_DECLARE_STACK_RECORD (SR);
        
    TRACE(TL_T, TM_Mp, ("==>EpvcMpSetInformation pMiniport %x, Oid, Buffer %x, Length, %x",
                       pMiniport,
                       Oid,
                       InformationBuffer,
                       InformationBufferLength));               

    pMiniport = (PEPVC_I_MINIPORT)MiniportAdapterContext;

    LOCKOBJ(pMiniport, &SR);
    IsShuttingDown =(! MiniportTestFlag(pMiniport, fMP_MiniportInitialized));
    pAdapter = pMiniport->pAdapter;
    UNLOCKOBJ(pMiniport,&SR);

    if (IsShuttingDown)
    {
        TRACE (TL_I, TM_Mp,(" Miniport shutting down. Trivially succeeding Set OID %x \n", Oid ));
        *BytesRead = 0;
        *BytesNeeded = 0;

        StatusToReturn = NDIS_STATUS_SUCCESS;
        return (StatusToReturn);
    }

    //
    // Get Oid and Length of request
    //
    OidLength = BytesLeft;

    switch (Oid) 
    {

        case OID_802_3_MULTICAST_LIST:

            TRACE (TL_V, TM_Rq,(" Miniport Set OID_802_3_MULTICAST_LIST"));

            if (OidLength % sizeof(MAC_ADDRESS))
            {
                StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }
            
            if (OidLength > (MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)))
            {
                StatusToReturn = NDIS_STATUS_MULTICAST_FULL;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }
            
            NdisZeroMemory(
                    &pMiniport->info.McastAddrs[0], 
                    MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)
                    );
            NdisMoveMemory(
                    &pMiniport->info.McastAddrs[0], 
                    InfoBuffer,
                    OidLength
                    );
            pMiniport->info.McastAddrCount = OidLength / sizeof(MAC_ADDRESS);


            break;

        case OID_GEN_CURRENT_PACKET_FILTER:

            TRACE (TL_V, TM_Rq,(" Miniport Set OID_GEN_CURRENT_PACKET_FILTER"));
            //
            // Verify length
            //
            if (OidLength != sizeof(ULONG)) 
            {
                StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = sizeof(ULONG);
                ASSERT (0);
                break;
            }

            BytesLeft = sizeof (ULONG);
            //
            // Store the new value.
            //
            NdisMoveMemory(&Filter, InfoBuffer, BytesLeft );

            //
            // Don't allow promisc mode, because we can't support that.
            //
            if (Filter & NDIS_PACKET_TYPE_PROMISCUOUS)
            {
                StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            StatusToReturn   = epvcSetPacketFilter(pMiniport, Filter, &SR);

            break;

        case OID_802_5_CURRENT_FUNCTIONAL:
        case OID_802_5_CURRENT_GROUP:
            TRACE (TL_V, TM_Rq,(" Miniport Set OID_802_5_CURRENT_GROUP"));

            // XXX just accept whatever for now ???
            
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            TRACE (TL_V, TM_Rq,(" Miniport Set OID_GEN_CURRENT_LOOKAHEAD"));

            //
            // Verify length
            //
            if (OidLength != 4) 
            {
                StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
                *BytesNeeded = 0;
                break;
            }

            //
            // Store the new value.
            //
            NdisMoveMemory(&LookAhead, InfoBuffer, 4);

            ASSERT (pMiniport->pAdapter != NULL);
            
            if (LookAhead <= pAdapter->info.MaxAAL5PacketSize)
            {
                pMiniport->info.CurLookAhead = LookAhead;
                TRACE (TL_V, TM_Mp, ("New Lookahead size %x \n",pMiniport->info.CurLookAhead )); 
            }
            else 
            {
                StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
            }

            break;

        case OID_GEN_NETWORK_LAYER_ADDRESSES:
            TRACE (TL_V, TM_Rq,(" Miniport Set OID_GEN_NETWORK_LAYER_ADDRESSES"));
            StatusToReturn = epvcMpSetNetworkAddresses(
                                pMiniport,
                                InformationBuffer,
                                InformationBufferLength,
                                &SR,
                                BytesRead,
                                BytesNeeded);
            break;
                                
        default:

            StatusToReturn = NDIS_STATUS_INVALID_OID;

            *BytesRead = 0;
            *BytesNeeded = 0;

            break;

    }

    if (StatusToReturn == NDIS_STATUS_SUCCESS) 
    {
        *BytesRead = BytesLeft;
        *BytesNeeded = 0;
        DUMPDW( TL_V, TM_Rq, InformationBuffer, *BytesRead );
    }
    

    TRACE(TL_T, TM_Mp, ("<==EpvcMpSetInformation Status %x",StatusToReturn));   
    RM_ASSERT_CLEAR(&SR);
    return StatusToReturn;
}




VOID
epvcMPLocalRequestComplete (
    PEPVC_NDIS_REQUEST pEpvcRequest, 
    NDIS_STATUS Status
    )
/*++

Routine Description:

    Miniport's local Request Completion handler for the occasion
    when a locally allocated NdisRequest was sent to the miniport below us.

    We look up to see if a request to our miniport edge initiated this request.
    If so, we complete the Set/Query

    Assumes that the epvcRequest was allocated from the HEAP

Arguments:
    pEpvcRequest - Locally allocated Request structure
    
Return Value:
--*/
{
    ENTER("epvcMPLocalRequestComplete ", 0x77d107ae)
    PEPVC_I_MINIPORT pMiniport = pEpvcRequest->pMiniport;

    RM_DECLARE_STACK_RECORD (SR);
    //
    // First complete the request that we have pended
    //

    do
    {
    
        if (pMiniport == NULL || pEpvcRequest->fPendedRequest == FALSE)
        {
            //
            // No pended request to complete
            //
            break;
        }

        if (pEpvcRequest->fSet  == TRUE)
        {
            NdisMSetInformationComplete (pMiniport->ndis.MiniportAdapterHandle,
                                         Status);
        }
        else
        {
            NdisMQueryInformationComplete (pMiniport->ndis.MiniportAdapterHandle,
                                         Status);


        }


    } while (FALSE);

    if (pMiniport != NULL)
    {
        //
        // Deref the miniport
        //
        epvcUnlinkFromExternal( &pMiniport->Hdr,  //pHdr
                                       0xaa625b37, // Luid
                                       (UINT_PTR)pEpvcRequest,// External entity
                                       EPVC_ASSOC_MINIPORT_REQUEST,         // AssocID
                                       &SR
                                       );
    }


    //
    // now free the memory that was allocated. 
    //
    NdisFreeMemory (pEpvcRequest, sizeof (*pEpvcRequest), 0);


}





NDIS_STATUS
epvcMpSetNetworkAddresses(
    IN  PEPVC_I_MINIPORT        pMiniport,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength,
    IN  PRM_STACK_RECORD        pSR,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
)
/*++

Routine Description:

    Called when the protocol above us wants to let us know about
    the network address(es) assigned to this interface. If this is TCP/IP,
    then we reformat and send a request to the ATM Call Manager to set
    its atmfMyIpNmAddress object. We pick the first IP address given to us.

Arguments:

    pMiniport                   - Pointer to the ELAN

    InformationBuffer       - Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead               - If the call is successful, returns the number
                              of bytes read from InformationBuffer.

    BytesNeeded             - If there is not enough data in InformationBuffer
                              to satisfy the OID, returns the amount of storage
                              needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
--*/
{
    ENTER("epvcMpSetNetworkAddresses" , 0x385441e2)
    NETWORK_ADDRESS_LIST UNALIGNED *        pAddrList = NULL;
    NETWORK_ADDRESS UNALIGNED *             pAddr = NULL;
    NETWORK_ADDRESS_IP UNALIGNED *          pIpAddr= NULL;
    ULONG                                   Size;
    PUCHAR                                  pNetworkAddr = NULL;
    NDIS_HANDLE                             NdisAdapterHandle;
    NDIS_HANDLE                             NdisAfHandle;
    NDIS_STATUS                             Status;
    PEPVC_ADAPTER                           pAdapter = (PEPVC_ADAPTER)pMiniport->pAdapter;

    //
    //  Initialize.
    //
    *BytesRead = 0;
    Status = NDIS_STATUS_SUCCESS;

    pAddrList = (NETWORK_ADDRESS_LIST UNALIGNED *)InformationBuffer;

    do
    {

        *BytesNeeded = sizeof(*pAddrList) -
                        FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
                        sizeof(NETWORK_ADDRESS) -
                        FIELD_OFFSET(NETWORK_ADDRESS, Address);

        if (InformationBufferLength < *BytesNeeded)
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (pAddrList->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
        {
            // Not interesting.
            break;
        }

        if (pAddrList->AddressCount <= 0)
        {
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        pAddr = (NETWORK_ADDRESS UNALIGNED *)&pAddrList->Address[0];

        if ((pAddr->AddressLength > InformationBufferLength - *BytesNeeded) ||
            (pAddr->AddressLength == 0))
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (pAddr->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
        {
            // Not interesting.
            break;
        }

        if (pAddr->AddressLength < sizeof(NETWORK_ADDRESS_IP))
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        pIpAddr = (NETWORK_ADDRESS_IP UNALIGNED *)&pAddr->Address[0];

        //
        //  Allocate an NDIS request to send down to the call manager.
        //
        Size = sizeof(pIpAddr->in_addr);
        Status = epvcAllocateMemoryWithTag(&pNetworkAddr, Size, TAG_DEFAULT );

        if ((FAIL(Status) == TRUE) || pNetworkAddr == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            pNetworkAddr = NULL;
            break;
        }

        //
        //  Copy the network address in.
        //
        NdisMoveMemory(pNetworkAddr, &pIpAddr->in_addr, sizeof(pIpAddr->in_addr));

        TRACE (TL_V, TM_Mp, (" Set network layer addr: length %d\n", pAddr->AddressLength));
#if DBG
        if (pAddr->AddressLength >= 4)
        {
            TRACE(TL_V, TM_Mp, ("Network layer addr: %d.%d.%d.%d\n",
                    pNetworkAddr[0],
                    pNetworkAddr[1],
                    pNetworkAddr[2],
                    pNetworkAddr[3]));
        }
#endif // DBG

        //
        //  Send off the request.
        //
        { 
            PEPVC_NDIS_REQUEST pRequest;        

            do
            {
        
                Status = epvcAllocateMemoryWithTag (&pRequest, sizeof(*pRequest), TAG_DEFAULT) ;

                if (Status != NDIS_STATUS_SUCCESS)
                {
                    pRequest = NULL;
                    break;
                }



                //
                // There is no failure code path in prepareandsendrequest.
                // Our completion handler will get called and free the memory
                //
                Status = epvcPrepareAndSendNdisRequest(
                                                       pAdapter,
                                                       pRequest,
                                                       epvcMPLocalRequestComplete,
                                                       OID_ATM_MY_IP_NM_ADDRESS,
                                                       pNetworkAddr,
                                                       sizeof(pIpAddr->in_addr),
                                                       NdisRequestSetInformation,
                                                       pMiniport,
                                                       TRUE, // We have Pended a Request
                                                       TRUE, // The Pended request is a Set 
                                                       pSR
                                                       );
                                
                

            } while (FALSE);
            
        }
        break;
    }
    while (FALSE);

    EXIT();
    return (Status);
}






VOID
epvcSetupMakeCallParameters(
    PEPVC_I_MINIPORT pMiniport, 
    PCO_CALL_PARAMETERS *ppCallParameters
    )
/*++

Routine Description:

    Sets up the Call parameters after reading the information
    from the miniport block

Arguments:
    pMiniport - Miniport in question
    ppCallParameter - Location of Call Parameters

Return Value:
    return value *ppCallParamter is NULL on Failure

--*/
{
    ULONG                               RequestSize = 0;
    NDIS_STATUS                         Status = NDIS_STATUS_FAILURE;
    PCO_CALL_PARAMETERS                 pCallParameters = NULL;
    PCO_CALL_MANAGER_PARAMETERS         pCallMgrParameters = NULL;
    PCO_MEDIA_PARAMETERS                pMediaParameters = NULL;
    PATM_MEDIA_PARAMETERS               pAtmMediaParameters = NULL;

    do
    {
        Status = epvcAllocateMemoryWithTag( &pCallParameters,
                                       CALL_PARAMETER_SIZE,
                                       TAG_DEFAULT);

        if (Status != NDIS_STATUS_SUCCESS || pCallParameters  == NULL)
        {
                pCallParameters = NULL;     
                Status = NDIS_STATUS_RESOURCES;
                break;
        }

        NdisZeroMemory (pCallParameters, CALL_PARAMETER_SIZE);

        //
        //  Distribute space and link up pointers amongst the various
        //  structures for the PVC.
        //
        //  pCallParameters------->+----------------------------+
        //                         | CO_CALL_PARAMETERS         |
        //  pCallMgrParameters---->+----------------------------+
        //                         | CO_CALL_MANAGER_PARAMETERS |
        //  pMediaParameters------>+----------------------------+
        //                         | CO_MEDIA_PARAMETERS        |
        //  pAtmMediaParameters--->+----------------------------+
        //                         | ATM_MEDIA_PARAMETERS       |
        //                         +----------------------------+
        //

        pCallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)
                                ((PUCHAR)pCallParameters +
                                sizeof(CO_CALL_PARAMETERS));
        pCallParameters->CallMgrParameters = pCallMgrParameters;
        pCallMgrParameters->CallMgrSpecific.ParamType = 0;  
        pCallMgrParameters->CallMgrSpecific.Length = 0;
        pMediaParameters = (PCO_MEDIA_PARAMETERS)
            pCallMgrParameters->CallMgrSpecific.Parameters;
        pCallParameters->MediaParameters = pMediaParameters;
        pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)
                                pMediaParameters->MediaSpecific.Parameters;


        //
        //  Call Manager generic flow paramters:
        //
        pCallMgrParameters->Transmit.TokenRate = 
                pMiniport->pAdapter->info.LinkSpeed.Outbound/8*100; // cnvt decibits to bytes
        pCallMgrParameters->Transmit.PeakBandwidth = 
                pMiniport->pAdapter->info.LinkSpeed.Outbound/8*100; // cnvt decibits to bytes
        pCallMgrParameters->Transmit.ServiceType = SERVICETYPE_BESTEFFORT;

        pCallMgrParameters->Receive.TokenRate = 
                pMiniport->pAdapter->info.LinkSpeed.Inbound/8*100;  // cnvt decibits to bytes
        pCallMgrParameters->Receive.PeakBandwidth = 
                pMiniport->pAdapter->info.LinkSpeed.Inbound/8*100;  // cnvt decibits to bytes
        pCallMgrParameters->Receive.ServiceType = SERVICETYPE_BESTEFFORT;

        //
        //  use 1516 per spec
        //
        pCallMgrParameters->Transmit.TokenBucketSize = 
            pCallMgrParameters->Transmit.MaxSduSize = 
            pCallMgrParameters->Receive.TokenBucketSize = 
            pCallMgrParameters->Receive.MaxSduSize = 
                 1516;

        //
        //  PVC Generic and ATM-specific Media Parameters
        //
        pMediaParameters->Flags = TRANSMIT_VC | RECEIVE_VC;
        pMediaParameters->MediaSpecific.ParamType = ATM_MEDIA_SPECIFIC;
        pMediaParameters->MediaSpecific.Length = sizeof(ATM_MEDIA_PARAMETERS);

        pAtmMediaParameters->ConnectionId.Vpi = pMiniport->config.vpi;  //0
        pAtmMediaParameters->ConnectionId.Vci = pMiniport->config.vci;  

        TRACE (TL_I, TM_Mp, ("Miniport Configuration vci %x ,vpi %x", 
                             pMiniport->config.vci ,
                             pMiniport->config.vpi ));

        ASSERT (pMiniport->MaxAcceptablePkt > 1000);
        
        pAtmMediaParameters->AALType = AAL_TYPE_AAL5;
        pAtmMediaParameters->Transmit.PeakCellRate = 
            LINKSPEED_TO_CPS(pMiniport->pAdapter->info.LinkSpeed.Outbound);
        pAtmMediaParameters->Transmit.MaxSduSize = pMiniport->MaxAcceptablePkt    ;
        pAtmMediaParameters->Transmit.ServiceCategory = 
            ATM_SERVICE_CATEGORY_UBR;
        pAtmMediaParameters->Receive.PeakCellRate = 
            LINKSPEED_TO_CPS(pMiniport->pAdapter->info.LinkSpeed.Outbound);
        pAtmMediaParameters->Receive.MaxSduSize = pMiniport->MaxAcceptablePkt   ;
        pAtmMediaParameters->Receive.ServiceCategory = 
            ATM_SERVICE_CATEGORY_UBR;

        //
        //  Set PVC flag here
        //
        pCallParameters->Flags |= PERMANENT_VC;


                                
    } while (FALSE);

    if (Status == NDIS_STATUS_SUCCESS && pCallParameters != NULL)
    {
        //
        // Set up the return value here
        //
        *ppCallParameters = pCallParameters;

    }
    else
    {
        //
        // Clear the Failure case
        //
        *ppCallParameters = NULL;
    }
}   





VOID
epvcRefRecvPkt(
    PNDIS_PACKET        pNdisPacket,
    PRM_OBJECT_HEADER   pHdr // either an adapter or a miniport
    )
{

    // The following macros are just so that we can make 
    // the proper debug association
    // depending on how closely we are tracking outstanding  packets.
    //
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
    #define szEPVCASSOC_EXTLINK_INDICATED_PKT_FORMAT "    indicated pkt 0x%p\n"

        //
        // If ARPDBG_REF_EVERY_PKT
        //      We add an "external" link for EVERY packet. We'll later remove this
        //      reference when the send completes for this packet.
        // else
        //      Only a transition from zero to non-zero outstanding sends, we
        //      add an "external" link. We'll later remove this link when the
        //      transition from non-zero to zero happens.
        //

    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        epvcLinkToExternal (
            pHdr,                           // pHdr
            0x92036e12,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            EPVC_ASSOC_EXTLINK_INDICATED_PKT,           // AssocID
            szEPVCASSOC_EXTLINK_INDICATED_PKT_FORMAT ,
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(pHdr);

    #endif // !RM_EXTRA_CHECKING

    
    #undef  OUR_EXTERNAL_ENTITY
    #undef  szEPVCASSOC_EXTLINK_INDICATED_PKT_FORMAT 

    #if RM_EXTRA_CHECKING

        RM_ASSERT_CLEAR(&sr);

    #endif
}



VOID
epvcDerefRecvPkt (
    PNDIS_PACKET pNdisPacket,
    PRM_OBJECT_HEADER pHdr
    )
{
    // The following macros are just so that we can make 
    // the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
    #if RM_EXTRA_CHECKING


        RM_DECLARE_STACK_RECORD(sr)
    
        epvcUnlinkFromExternal(
                pHdr,                           // pHdr
                0x110ad55b,                             // LUID
                (UINT_PTR)pNdisPacket,                  // External entity
                EPVC_ASSOC_EXTLINK_INDICATED_PKT,           // AssocID
                &sr
                );
    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast (pHdr);

    #endif // !RM_EXTRA_CHECKING

    #if RM_EXTRA_CHECKING

        RM_ASSERT_CLEAR(&sr);

    #endif



}

VOID
epvcDerefSendPkt (
    PNDIS_PACKET pNdisPacket,
    PRM_OBJECT_HEADER pHdr
    )
{
    // The following macros are just so that we can make 
    // the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)
    
        epvcUnlinkFromExternal(
                pHdr,                           // pHdr
                0xf43e0a10,                             // LUID
                (UINT_PTR)pNdisPacket,                  // External entity
                EPVC_ASSOC_EXTLINK_PKT_TO_SEND,         // AssocID
                &sr
                );
    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast (pHdr);

    #endif // !RM_EXTRA_CHECKING


    #if RM_EXTRA_CHECKING

        RM_ASSERT_CLEAR(&sr);

    #endif



}


VOID
epvcRefSendPkt(
    PNDIS_PACKET        pNdisPacket,
    PRM_OBJECT_HEADER   pHdr // either an adapter or a miniport
    )
{

    // The following macros are just so that we can make 
    // the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
    #define szEPVCASSOC_EXTLINK_DEST_TO_PKT_FORMAT "    send pkt 0x%p\n"


    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        epvcLinkToExternal (
            pHdr,                           // pHdr
            0xabd17475,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            EPVC_ASSOC_EXTLINK_PKT_TO_SEND,         // AssocID
            szEPVCASSOC_EXTLINK_DEST_TO_PKT_FORMAT ,
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(pHdr);

    #endif // !RM_EXTRA_CHECKING

    
    #undef  OUR_EXTERNAL_ENTITY
    #undef  szEPVCASSOC_EXTLINK_DEST_TO_PKT_FORMAT 

    #if RM_EXTRA_CHECKING

        RM_ASSERT_CLEAR(&sr);

    #endif
}


VOID
epvcExtractPktInfo (
    PEPVC_I_MINIPORT        pMiniport,
    PNDIS_PACKET            pPacket ,
    PEPVC_SEND_STRUCT       pSendStruct
    )
/*++

Routine Description:


Arguments:


Return Value:
    
--*/
{

    pSendStruct->pOldPacket = pPacket;
    pSendStruct->pMiniport = pMiniport;

    epvcSetSendPktStats();

}



NDIS_STATUS
epvcSendRoutine(
    IN PEPVC_I_MINIPORT pMiniport, 
    IN PNDIS_PACKET Packet,
    PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This routine does all the hard work.
    It responds to arps if necessary..
    It removes Ethernet Headers if necessary
    It allocates a new packet if necessary 
    It sends the new packet on the wire


Arguments:
    pMiniport - Miniport in question
    Packet - Packet to be sent

Return Value:
    Returns Pending, otherwise expects the calling 
    routine to complete the packet
    
--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    PNDIS_PACKET            pNewPkt = NULL;
    EPVC_SEND_STRUCT        SendStruct;

    TRACE (TL_T, TM_Send, ("==>epvcSendRoutine") );

    EPVC_ZEROSTRUCT (&SendStruct);

    do
    {
        epvcExtractPktInfo (pMiniport, Packet, &SendStruct  );

        //
        // if we are doing IP encapsulation, then respond 
        // to the Arp
        //

        if (pMiniport->fDoIpEncapsulation == TRUE) 
        {
            
            //
            // We need to do some special processing for this packet
            //
            SendStruct.fIsThisAnArp = \
                     epvcCheckAndReturnArps (pMiniport, 
                                            Packet ,
                                            &SendStruct, 
                                            pSR);

                                 

            if (SendStruct.fIsThisAnArp  == TRUE  )
            {
                Status = NDIS_STATUS_SUCCESS;
                break ; // Arps are not sent to the atm driver
            }

            if (SendStruct.fNotIPv4Pkt == TRUE)
            {
                // This is not an IPv4 packet. Fail the send.
                Status = NDIS_STATUS_FAILURE;
                break;
            }
        }



        //
        // Allocate a new packet to be sent 
        //
        epvcGetSendPkt(pMiniport, 
                       Packet,
                       &SendStruct,
                       pSR);

        if (SendStruct.pNewPacket == NULL)
        {
            ASSERTAndBreak (SendStruct.pNewPacket != NULL);
        }
        //
        // SendStruct.pNewPacket is guaranteed to have the NdisBuffers Set up

        //
        // Remove Ethernet Header - if necessary
        //
        Status = epvcRemoveEthernetHeader (&SendStruct, pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERTAndBreak (Status == NDIS_STATUS_SUCCESS)
        }

        //
        // Add Ethernet Padding - if necessary
        //
        Status = epvcAddEthernetTail (&SendStruct, pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERTAndBreak (Status == NDIS_STATUS_SUCCESS)
        }

        //
        // Add Ethernet Pad 0x00 0x00 to head of packet - if necessary
        //
        Status = epvcAddEthernetPad (&SendStruct, pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERTAndBreak (Status == NDIS_STATUS_SUCCESS)
        }

        //
        // Add LLC Encapsulation - if necessary
        //
        Status = epvcAddLLCEncapsulation (pMiniport , Packet, SendStruct.pNewPacket, pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERTAndBreak (Status == NDIS_STATUS_SUCCESS)
        }

        //
        // set the context information for the send complete
        //
        epvcSetPacketContext (&SendStruct, pSR);

        //
        // Only Send if successful
        //
        epvcDumpPkt (SendStruct.pNewPacket);


        Status = epvcAdapterSend(pMiniport,
                                 SendStruct.pNewPacket,
                                 pSR);


    } while (FALSE);

    if (Status != NDIS_STATUS_PENDING &&   // We had a failure
        SendStruct.pNewPacket != NULL )  // but we were able to get a packet
    {
        epvcFreeSendPkt (pMiniport, &SendStruct);
    }

    TRACE (TL_T, TM_Send, ("<==epvcSendRoutine") );
    return Status;
}


VOID
EpvcSendPackets(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    Send Packet Array handler. Either this or our SendPacket handler is called
    based on which one is enabled in our Miniport Characteristics.


Arguments:

    MiniportAdapterContext  Pointer to our adapter
    PacketArray             Set of packets to send
    NumberOfPackets         Self-explanatory

Return Value:

    None

--*/
{
    PEPVC_I_MINIPORT    pMiniport = (PEPVC_I_MINIPORT)MiniportAdapterContext;
    
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    UINT                i;
    RM_DECLARE_STACK_RECORD (SR);

    DBGMARK(0xdaab68c3);

    TRACE (TL_T, TM_Send, ("==>EpvcSendPackets pMiniport %p, pPktArray %p, Num %x",
                              pMiniport, PacketArray, NumberOfPackets));

    for (i = 0; i < NumberOfPackets; i++)
    {
        PEPVC_PKT_CONTEXT           Rsvd;
        PNDIS_PACKET    Packet = NULL; 
    
        Packet = PacketArray[i];

        epvcValidatePacket (Packet);

        Status= epvcSendRoutine (pMiniport, Packet, &SR);

        if (Status != NDIS_STATUS_PENDING)
        {
            epvcMSendComplete(pMiniport, Packet , Status);
        }

    }

    TRACE (TL_T, TM_Send, ("<==EpvcSendPackets "));
    RM_ASSERT_CLEAR(&SR);

    return;
}   


VOID
epvcFreeSendPkt(
    PEPVC_I_MINIPORT pMiniport,
    IN PEPVC_SEND_STRUCT pSendStruct
    )
/*++
Routine Description:

    Pops the packet stack if stacks were used or free the new packet after
    copying the per packet info

Arguments:
    pMiniport - which the packet was sent to
    pSentPkt - The packet that is being sent.
    ppPkt - the new packet that was allocated or the old one if a stack was available
    
--*/

{
    ENTER ("epvcFreeSendPkt", 0xff3ce0fd)
    PNDIS_PACKET pOldPkt = pSendStruct->pOldPacket;
    PNDIS_PACKET pNewPkt = pSendStruct->pNewPacket;
    
    TRACE (TL_T, TM_Send, ("==>epvcFreeSendPkt pNewPkt %x, pPOldPkt ",pNewPkt, pOldPkt));

    //
    // Remove the ethernet padding - if necessary
    //
    epvcRemoveEthernetPad (pMiniport, pNewPkt);

    //
    // Remove the Ethernet Tail-  if necessary
    //
    epvcRemoveEthernetTail(pMiniport, pNewPkt, &pSendStruct->Context);

    //
    // If the two packets are the same, then we used Packet Stacks
    //

    if (pNewPkt != NULL && pSendStruct->fUsingStacks== FALSE)
    {
            NdisIMCopySendCompletePerPacketInfo (pOldPkt, pNewPkt);

            epvcFreePacket(pNewPkt,&pMiniport->PktPool.Send);

            pNewPkt = pSendStruct->pNewPacket = NULL;

    }       





    TRACE (TL_T, TM_Send, ("<==epvcFreeSendPkt pNewPkt %x, pPOldPkt ",pNewPkt, pOldPkt));
    EXIT()
    return;
}


VOID
epvcGetSendPkt (
    IN PEPVC_I_MINIPORT pMiniport,
    IN PNDIS_PACKET pSentPkt,
    OUT PEPVC_SEND_STRUCT pSendStruct,
    IN PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Allocates an NdisPkt or pushes a Pkt Stack to get a valid NdisPkt that 
    can be sent to the adapter below.

Arguments:
    pMiniport - which the packet was sent to
    pSentPkt - The packet that is being sent.
    ppPkt - the new packet that was allocated or the old one if a stack was available
    
--*/

{
    ENTER ("epvcGetSendPkt", 0x5734054f)

    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    PNDIS_PACKET            pNewPkt  = NULL;
    BOOLEAN                 Remaining = FALSE;
    PVOID                   MediaSpecificInfo = NULL;
    UINT                    MediaSpecificInfoSize = 0;

    
    TRACE (TL_T, TM_Send, ("==>epvcGetSendPkt  pSentPkt %x",pSentPkt));


    do
    {
        
#if PKT_STACKS

        //
        // Packet stacks: Check if we can use the same packet for sending down.
        //
        pStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);
        if (Remaining)
        {
            //
            // We can reuse "Packet".
            //
            // NOTE: if we needed to keep per-packet information in packets
            // sent down, we can use pStack->IMReserved[].
            //
            
            pNewPkt = pSentPkt;
            pSendStruct->pPktStack = pStack;
            
            pSendStruct->fUsingStacks  = TRUE;
            break;
            
        }
#endif

        pSendStruct->fUsingStacks  = FALSE;

        epvcAllocatePacket(&Status,
                           &pNewPkt,
                           &pMiniport->PktPool.Send);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            PNDIS_PACKET_EXTENSION  Old, New;
            PEPVC_PKT_CONTEXT Rsvd = NULL;


            Rsvd = (PEPVC_PKT_CONTEXT)(pNewPkt->ProtocolReserved);
            Rsvd->pOriginalPacket = pSentPkt;

            pNewPkt->Private.Flags = NdisGetPacketFlags(pSentPkt);

            pNewPkt->Private.Head = pSentPkt->Private.Head;
            pNewPkt->Private.Tail = pSentPkt->Private.Tail;

            //
            // Copy the OOB Offset from the original packet to the new
            // packet.
            //
            NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(pNewPkt),
                           NDIS_OOB_DATA_FROM_PACKET(pSentPkt),
                           sizeof(NDIS_PACKET_OOB_DATA));
            //
            // Copy relevant parts of the per packet info into the new packet