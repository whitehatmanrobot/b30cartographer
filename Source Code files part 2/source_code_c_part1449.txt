       // Expire this entry ?
            //

            entriesScanned++;
            if ( ExpireTime->QuadPart >= entry->BaseTime.QuadPart ) {

                DebugTrace(0,"Expiring page %d entry %d msgId %s\n",
                        CurrentPage, i, entry->MsgId );

                //
                // Set the delete bit.
                //

                mapPage->ArtOffset[i] |= OFFSET_FLAG_DELETED;
                mapPage->ActualCount--;

                //
                // Link this into a chain
                //

                LinkDeletedEntry( mapPage, entryOffset );

            } else {

                //
                // See if this can be the oldest time
                //

                if ( oldestTime->QuadPart > entry->BaseTime.QuadPart ) {
                    oldestTime->QuadPart = entry->BaseTime.QuadPart;
                }
            }
        }
    }

    //
    // set the new
    //

    if ( mapPage->ActualCount == 0 ) {
        oldestTime->QuadPart = 0;
    }

    //
    // Flush
    //

    FlushPage( hLock, mapPage );

    //
    // See if the page needs to be compacted
    //

    if ( mapPage->FragmentedBytes > FRAG_THRESHOLD ) {
        CompactPage(hLock, mapPage);
    }

exit:
    ReleasePageShared(mapPage, hLock);
    LEAVE
    return TRUE;

} // ExpireEntriesInPage
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\hash\modhash\modhash.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	<dbgtrace.h>
#include	<tigtypes.h>
#include	<ihash.h>
#include	<crchash.h>
#include	<fsconst.h>
typedef char *LPMULTISZ ;
#include	<nntpmeta.h>
#include	<nwstree.h>
#include	<ctype.h>

#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

CNNTPVRootTable *g_pVRTable = NULL;
CNewsTreeCore *g_pNewsTree = NULL;
CXoverMap *g_pXOver = NULL;
CMsgArtMap *g_pArt = NULL;

#define WMDPATH L"/LM/modhash"
#define MDPATH "/LM/modhash"
#define PROGID_NO_DRIVER L"TestNT.NoDriver"
#define VRPATH L""

#define INI_KEY_GROUPNAME   "Group%i"
#define INI_KEY_ARTIDMAX    "ArtIdMax%i"
#define TESTIFS_SECTION     "TestIFS"

class CExtractor : public IExtractObject {
	public: 
		BOOL DoExtract(GROUPID groupid, 
					   ARTICLEID articleid, 
					   PGROUP_ENTRY pGroups, 
					   DWORD cGroups)
		{
			if(groupid & 0x1) return TRUE; else return FALSE;
		}
};

void Post(char *pszGroup, DWORD iArticleId, char *pszMessageId) {
	CGRPCOREPTR pGroup;
	HRESULT hr;

	hr = g_pNewsTree->FindOrCreateGroup(pszGroup, FALSE, FALSE, FALSE, &pGroup);
	if (FAILED(hr)) {
		printf("group %s doesn't seem to exist.  hr = 0x%x\n", pszGroup, hr);
		return;
	}

	DWORD iGroupId = pGroup->GetGroupId();
	printf("-- post %s:%i %s\n", pszGroup, iArticleId, pszMessageId);
	printf("%s -> %i\n", pszGroup, iGroupId);

	CStoreId storeid;
	storeid.cLen = 10;
	strcpy((char *) storeid.pbStoreId, "thisistst");

	if (g_pArt->InsertMapEntry(pszMessageId, 
							   0, 
							   0, 
							   iGroupId, 
							   iArticleId,
							   storeid)) 
	{
		SYSTEMTIME systime;
		FILETIME filetime;
		GetLocalTime(&systime);
		SystemTimeToFileTime(&systime, &filetime);
		DWORD cStoreId = 1;
		BYTE cCrossposts = 1;
		if (g_pXOver->CreatePrimaryNovEntry(iGroupId, 
											iArticleId, 
											0, 
											0,
											&filetime,
											pszMessageId,
											strlen(pszMessageId),
											0,
											NULL,
											cStoreId,
											&storeid,
											&cCrossposts
											))
		{
			printf("post successful\n");
		} else {
			printf("CreatePrimaryNovEntry failed with %lu\n", GetLastError());
			g_pArt->DeleteMapEntry(pszMessageId);
		}
	} else {
		printf("InsertMapEntry failed with %lu\n", GetLastError());
	}
}

void DumpStoreId(CStoreId storeid) {
	if (storeid.cLen == 0) return;

	DWORD i = 0;
	while (i < storeid.cLen) {
		DWORD j, c;

		c = (j + 16 > storeid.cLen) ? storeid.cLen : j + 16;
		printf("StoreId: %02x-%02x: ", i, c);
		for (j = i; j < c; j++) 
			printf("%02x ", storeid.pbStoreId[j]);
		printf(" | ");
		for (j = i; j < c; j++) 
			printf("%c", (isprint(storeid.pbStoreId[j])) ? storeid.pbStoreId[j] : '.');
		printf("\n");
		i = j;
	}
}

void FindMessageId(char *pszMessageId) {
	printf("-- findmsgid %s\n", pszMessageId);

	WORD iHeaderOffset, cHeaderLength;
	DWORD iArticleId, iGroupId;
	CStoreId storeid;
	if (g_pArt->GetEntryArticleId(pszMessageId, 
								  iHeaderOffset,
								  cHeaderLength,
								  iArticleId,
								  iGroupId,
								  storeid))
	{
		CGRPCOREPTR pGroup = g_pNewsTree->GetGroup(iGroupId);
		if (pGroup) {
			printf("%i -> %s\n", iGroupId, pGroup->GetNativeName());
			printf("%s is %s:%i\n", pszMessageId, pGroup->GetNativeName(), iArticleId);
		} else {
			printf("couldn't find group for groupid %i\n", iGroupId);
			printf("%s is %i:%i\n", pszMessageId, iGroupId, iArticleId);
		}
		DumpStoreId(storeid);
	} else {
		printf("GetEntryArticleId failed with %lu\n", GetLastError());
	}
}

void FindArtId(char *pszGroup, DWORD iArticleId) {
	printf("-- findartid %s:%i\n", pszGroup, iArticleId);

	CGRPCOREPTR pGroup;
	HRESULT hr;

	hr = g_pNewsTree->FindOrCreateGroup(pszGroup, FALSE, FALSE, FALSE, &pGroup);
	if (FAILED(hr)) {
		printf("group %s doesn't seem to exist.  hr = 0x%x\n", pszGroup, hr);
		return;
	}

	DWORD iGroupId = pGroup->GetGroupId();
	printf("%s -> %i\n", pszGroup, iGroupId);

	WORD iHeaderOffset, cHeaderLength;
	DWORD iPriArticleId, iPriGroupId;
	char pszMessageId[256];
	CStoreId storeid;
	DWORD cDataLen;
	if (g_pXOver->GetPrimaryArticle(iGroupId,
									iArticleId,
									iPriGroupId,
									iPriArticleId,
									256,
									pszMessageId,
									cDataLen,
								    iHeaderOffset,
								    cHeaderLength,
								    storeid))
	{
		CGRPCOREPTR pGroup = g_pNewsTree->GetGroup(iPriGroupId);
		if (pGroup) {
			printf("%i -> %s\n", iPriGroupId, pGroup->GetNativeName());
			printf("%s:%i is %s, %s:%i\n", 
				pszGroup, iArticleId,
				pszMessageId, pGroup->GetNativeName(), iPriArticleId);
		} else {
			printf("couldn't find group for groupid %i\n", iGroupId);
			printf("%s:%i is %s, %i:%i\n", 
				pszGroup, iArticleId,
				pszMessageId, iPriGroupId, iPriArticleId);
		}
		DumpStoreId(storeid);
	} else {
		printf("GetEntryArticleId failed with %lu\n", GetLastError());
	}
}

void DeleteMessageId(char *pszMessageId) {
	printf("-- deletemsgid %s\n", pszMessageId);

	WORD iHeaderOffset, cHeaderLength;
	DWORD iArticleId, iGroupId;
	CStoreId storeid;
	if (g_pArt->GetEntryArticleId(pszMessageId, 
								  iHeaderOffset,
								  cHeaderLength,
								  iArticleId,
								  iGroupId,
								  storeid))
	{
		printf("%s is %i:%i\n", pszMessageId, iGroupId, iArticleId);
		if (g_pArt->DeleteMapEntry(pszMessageId)) {
			if (g_pXOver->DeleteNovEntry(iGroupId, iArticleId)) {
				printf("delete successful\n");
			} else {
				printf("DeleteNovEntry failed with %lu\n", GetLastError());
			}
		} else {
			printf("DeleteMapEntry failed with %lu\n", GetLastError());
		}
	}
}

void PostIFS(char *pszGroup, DWORD iArticleId, char *pszMessageId, BYTE* pbStoreId, BYTE cbStoreId) {
	CGRPCOREPTR pGroup;
	HRESULT hr;

	hr = g_pNewsTree->FindOrCreateGroup(pszGroup, FALSE, FALSE, FALSE, &pGroup);
	if (FAILED(hr)) {
		printf("group %s doesn't seem to exist.  hr = 0x%x\n", pszGroup, hr);
		return;
	}

	CStoreId storeid;
	storeid.cLen = cbStoreId;
	memcpy(storeid.pbStoreId, pbStoreId, cbStoreId);

	DWORD iGroupId = pGroup->GetGroupId();
	printf("-- postIFS %s:%i %s\n", pszGroup, iArticleId, pszMessageId);
    DumpStoreId(storeid);
	printf("%s -> %i\n", pszGroup, iGroupId);

	if (g_pArt->InsertMapEntry(pszMessageId, 
							   0, 
							   0, 
							   iGroupId, 
							   iArticleId,
							   storeid)) 
	{
		SYSTEMTIME systime;
		FILETIME filetime;
		GetLocalTime(&systime);
		SystemTimeToFileTime(&systime, &filetime);
		if (g_pXOver->CreatePrimaryNovEntry(iGroupId, 
											iArticleId, 
											0, 
											0,
											&filetime,
											pszMessageId,
											strlen(pszMessageId),
											0,
											NULL))
		{
			printf("post successful\n");
		} else {
			printf("CreatePrimaryNovEntry failed with %lu\n", GetLastError());
			g_pArt->DeleteMapEntry(pszMessageId);
		}
	} else {
		printf("InsertMapEntry failed with %lu\n", GetLastError());
	}
}

void TestIFS(char* pszIniFile) {

    int     cGroups = 0;
    char    szKey[20];
    char    szArtIdMax[20];
    int     iArtIdMax;
    char    szFIDMID[MAX_PATH];
    char    szGroupName[1024];
    char    szMessageId[MAX_PATH];


    while (1)
    {
        //  Get the newsgroup name
        sprintf(szKey, INI_KEY_GROUPNAME, cGroups);
        GetPrivateProfileString(TESTIFS_SECTION,
                                szKey,
                                "",
                                szGroupName,
                                1024,
                                pszIniFile);

        if (szGroupName[0] == 0)
        {
            break;
        }

        printf("Post to %s ...\n", szGroupName);

        //  Now get the ArtIdMax
        sprintf(szKey, INI_KEY_ARTIDMAX, cGroups);
        GetPrivateProfileString(TESTIFS_SECTION,
                                szKey,
                                "",
                                szArtIdMax,
                                20,
                                pszIniFile);
        if (szArtIdMax[0] == 0)
        {
            break;
        }
        iArtIdMax = atoi(szArtIdMax);
        if (iArtIdMax < 0) iArtIdMax = 1;
        printf("...with %d articles...\n", iArtIdMax);

        //  Loop through dwArtIdMax times and do PostIFS
        //  randomlly generate message-id's, use first 8 byte of
        //  the group name as FID, and first 8 byte of ArtId as MID
        while (iArtIdMax-- > 0)
        {
            //  Generate the Message-id
            sprintf(szMessageId, "<mid%d@testifs.com>", iArtIdMax);
            ZeroMemory(szFIDMID, sizeof(szFIDMID));
            sprintf(szFIDMID, "%.8hs%d", szGroupName, iArtIdMax);

            //  Call PostIFS to post this article, FID/MID is always 16 bytes long
            PostIFS(szGroupName, iArtIdMax, szMessageId, (BYTE *)szFIDMID, 16);
        }

        cGroups++;
    }

}


void CreateGroup(char *pszGroupName) {
	printf("-- create group %s\n", pszGroupName);
	if (!g_pNewsTree->CreateGroup(pszGroupName, FALSE)) {
		printf("CreateGroup failed with %lu\n", GetLastError());
	}
}

void SetHighwater(char *pszGroup, DWORD iHigh) {
	printf("-- sethigh %s %i\n", pszGroup, iHigh);

	HRESULT hr;
	CGRPCOREPTR pGroup;

	hr = g_pNewsTree->FindOrCreateGroup(pszGroup, FALSE, FALSE, FALSE, &pGroup);
	if (FAILED(hr)) {
		printf("group %s doesn't seem to exist.  hr = 0x%x\n", pszGroup, hr);
		return;
	}

	pGroup->SetMessageCount(iHigh - 1);
	pGroup->SetHighWatermark(iHigh);
	pGroup->SaveFixedProperties();
}

void ProcessCommands(int argc, char **argv) {
	while (argc) {
		if (strcmp(*argv, "post") == 0) {
			if (argc < 3) {
				printf("not enough arguments to post");
				return;
			}
			argc -= 3;
			char *pszGroupName = *(++argv);
			DWORD iArticleId = atoi(*(++argv));
			char szMessageId[MAX_PATH];
			sprintf(szMessageId, "<%s>", *(++argv));

			Post(pszGroupName, iArticleId, szMessageId);
		} else if (strcmp(*argv, "findmsgid") == 0) {
			if (argc < 1) {
				printf("not enough arguments to findmsgid");
				return;
			}
			argc -= 1;
			char szMessageId[MAX_PATH];
			sprintf(szMessageId, "<%s>", *(++argv));

			FindMessageId(szMessageId);
		} else if (strcmp(*argv, "findartid") == 0) {
			if (argc < 2) {
				printf("not enough arguments to findartid");
				return;
			}
			argc -= 2;
			char *pszGroupName = *(++argv);
			DWORD iArticleId = atoi(*(++argv));

			FindArtId(pszGroupName, iArticleId);		
		} else if (strcmp(*argv, "deletemsgid") == 0) {
			if (argc < 1) {
				printf("not enough arguments to deletemsgid");
				return;
			}
			argc -= 1;
			char szMessageId[MAX_PATH];
			sprintf(szMessageId, "<%s>", *(++argv));

			DeleteMessageId(szMessageId);		
		} else if (strcmp(*argv, "creategroup") == 0) {
			if (argc < 1) {
				printf("not enough arguments to creategroup");
				return;
			}
			argc -= 1;
			char *pszGroupName = *(++argv);

			CreateGroup(pszGroupName);				
		} else if (strcmp(*argv, "sethigh") == 0) {
			if (argc < 2) {
				printf("not enough arguments to sethigh");
				return;
			}
			argc -= 2;
			char *pszGroupName = *(++argv);
			DWORD iHigh = atoi(*(++argv));

			SetHighwater(pszGroupName, iHigh);				
		} else if (strcmp(*argv, "testifs") == 0) {
			if (argc < 1) {
				printf("not enough arguments to TestIFS");
				return;
			}
			argc -= 1;
			char *pszIniFile = *(++argv);

			TestIFS(pszIniFile);
		} else {
			printf("skipping unknown command %s\n", *argv);
		}
		argc--;
		argv++;
	}
}

void InitializeNewstree(char *szGroupList, char *szGroupVarList) {
	HRESULT hr;
	BOOL fFatal;
	IMSAdminBaseW *pMB;
	METADATA_HANDLE hmRoot;
	
	// initialize COM and the metabase
	printf("initializing metabase\n");
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr)) {
		printf("CoInitializeEx failed with 0x%x\n", hr);
		exit(0);
	}

	hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL, 
						  IID_IMSAdminBase_W, (LPVOID *) &pMB);
	if (FAILED(hr)) {
		printf("CoCreateInstance failed with 0x%x\n", hr);
		exit(0);
	}

	// create a vroot entry for the root.  we don't have any other 
	// vroot entries
	DWORD i = 0;
	do {
		hr = pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE, 
					      L"", 
					      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					      100,
					      &hmRoot);
		if (FAILED(hr) && i++ < 5) Sleep(50);
	} while (FAILED(hr) && i < 5);
	if (FAILED(hr)) {
		printf("creating virtual root hierarchy\n");
		printf("OpenKey failed with 0x%x\n", hr);
		exit(0);
	}

	// first we delete whatever exists in the metabase under this path,
	// then we create a new area to play in
	pMB->DeleteKey(hmRoot, WMDPATH);
	hr = pMB->AddKey(hmRoot, WMDPATH);
	if (FAILED(hr)) {
		printf("creating key %s\n", MDPATH);
		printf("AddKey failed with 0x%x\n", hr);
		exit(0);
	}
	// we configure one root vroot with parameters set to create no driver
	METADATA_RECORD mdrProgID = { 
		MD_VR_DRIVER_PROGID, 
		METADATA_INHERIT, 
		ALL_METADATA, 
		STRING_METADATA, 
		(lstrlenW(PROGID_NO_DRIVER)+1) * sizeof(WCHAR), 
		(BYTE *) PROGID_NO_DRIVER, 
		0 
	};
	hr = pMB->SetData(hmRoot, WMDPATH, &mdrProgID);
	if (FAILED(hr)) {
		printf("setting MD_VR_DRIVER_PROGID = \"%S\"\n", PROGID_NO_DRIVER);
		printf("SetData failed with 0x%x\n", hr);
		exit(0);
	}

	METADATA_RECORD mdrVRPath = { 
		MD_VR_PATH, 
		METADATA_INHERIT, 
		ALL_METADATA, 
		STRING_METADATA, 
		(lstrlenW(VRPATH)+1) * sizeof(WCHAR), 
		(BYTE *) VRPATH, 
		0 
	};
	hr = pMB->SetData(hmRoot, WMDPATH, &mdrVRPath);
	if (FAILED(hr)) {
		printf("setting MD_VR_PATH = \"%S\"\n", VRPATH);
		printf("SetData failed with 0x%x\n", hr);
		exit(0);
	}

	pMB->CloseKey(hmRoot);
	pMB->Release();

	// initialize our news tree
	printf("initializing newstree object\n");
	g_pNewsTree = new CNewsTreeCore();
	g_pVRTable = new CNNTPVRootTable(g_pNewsTree->GetINewsTree(), 
									 CNewsTreeCore::VRootRescanCallback);
	g_pNewsTree->Init(g_pVRTable, fFatal, 100, TRUE);

	// initialize the vroot table
	printf("initializing vroot table\n");
	hr = g_pVRTable->Initialize(MDPATH);
	if (FAILED(hr)) {
		printf("g_pVRTable->Initialize(\"%s\") returned %x\n", MDPATH, hr);
		exit(0);
	}

	// load the newstree from disk
	g_pNewsTree->LoadTree(szGroupList, szGroupVarList);	
}

void ShutdownNewstree() {
	g_pNewsTree->StopTree();
	g_pNewsTree->TermTree();
	delete g_pVRTable;
	delete g_pNewsTree;
}

int __cdecl main(int argc, char **argv) {
	CExtractor extractor;
	char szXOverFile[MAX_PATH];
	char szArticleFile[MAX_PATH];
	char szGroupList[MAX_PATH];
	char szGroupVarList[MAX_PATH];

	if (argc < 2) {
		printf("usage: modhash <nntpfile dir> [commands...]\n");
		printf(" commands:\n");
		printf("  post <groupname> <artid> <msgid>\n");
		printf("  findmsgid <msgid>\n");
		printf("  findartid <groupname> <artid>\n");
		printf("  deletemsgid <msgid>\n");
		printf("  creategroup <groupname>\n");
		printf("  sethigh <groupname> <highwatermark>\n");
		return 0;
	}

	sprintf(szXOverFile, "%s\\xover.hsh", argv[1]);
	sprintf(szArticleFile, "%s\\article.hsh", argv[1]);
	sprintf(szGroupList, "%s\\group.lst", argv[1]);
	sprintf(szGroupVarList, "%s\\groupvar.lst", argv[1]);

	printf("-- initializing\n");

	printf("xover.hsh path: %s\n", szXOverFile);
	printf("article.hsh path: %s\n", szArticleFile);
	printf("group.lst path: %s\n", szGroupList);
	printf("groupvar.lst path: %s\n", szGroupVarList);

	crcinit();
	CVRootTable::GlobalInitialize();

	_Module.Init(NULL, (HINSTANCE) INVALID_HANDLE_VALUE);

	InitializeNewstree(szGroupList, szGroupVarList);

	printf("initializing hash tables\n");
	InitializeNNTPHashLibrary();

	printf("initializing CXoverMap\n");
	g_pXOver = CXoverMap::CreateXoverMap();
	g_pArt = CMsgArtMap::CreateMsgArtMap();
	if (g_pXOver && g_pArt && !g_pXOver->Initialize(szXOverFile, 0)) {
		printf("CXoverMap::Initialize failed with %lu", GetLastError());
		delete g_pXOver;
		g_pXOver = NULL;
	}
	printf("initializing CMsgArtMap\n");
	if (g_pXOver && g_pArt && !g_pArt->Initialize(szArticleFile, 0)) {
		printf("CMsgArtMap::Initialize failed with %lu", GetLastError());
		delete g_pArt;
		g_pArt = NULL;
	}

	ProcessCommands(argc - 2, argv + 2);

	printf("-- shutting down\n");

	if (g_pXOver) {
		g_pXOver->Shutdown();
		delete g_pXOver;
		g_pXOver = NULL;
	}
	if (g_pArt) {
		g_pArt->Shutdown();
		delete g_pArt;
		g_pArt = NULL;
	}
	
	TermNNTPHashLibrary();

	ShutdownNewstree();

	_Module.Term();

	CVRootTable::GlobalShutdown();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\heap\src\baseheap.cpp ===
#include <windows.h>
#include <randfail.h>
#include <tigtypes.h>
#include "baseheap.h"

#define PARENT_NODE(i) ((((i)+1)>>1)-1)  // i/2
#define LEFT_NODE(i)   (((i)<<1)+1)
#define RIGHT_NODE(i)  (((i)<<1)+2)

#define HEAPSTATE_HEAP     0
#define HEAPSTATE_SORTED   1

//
//	Implementation of CHeap class
//

BOOL CHeap::isEmpty( void )
{
    return (HeapSize <= 0);
}

CHeap::CHeap( void )
{
    ForgetAll();
}

void CHeap::ForgetAll( void )
{
    HeapSize  = 0;
    HeapState = HEAPSTATE_HEAP;
}

void CHeap::BuildHeap( void )
{
    for ( int iNode = HeapSize/2 - 1; iNode >= 0; iNode-- )
    {
        Heapify( iNode );
    }
    HeapState = HEAPSTATE_HEAP;
}

void CHeap::SortHeap( void )
{
    int HeapSizeHold = HeapSize;
    for ( int iNode = HeapSize - 1; iNode >= 1; iNode-- )
    {
        Exchange( 0, iNode );
        HeapSize--;
        Heapify( 0 );
    }

    HeapSize = HeapSizeHold;

    for( iNode = 0; iNode < HeapSize/2; iNode ++ ) {
    	Exchange( iNode, HeapSize-1-iNode ) ;
    }

    HeapState = HEAPSTATE_SORTED;
}

void CHeap::Heapify( int iNode )
{
    for ( ; ; )
    {
        int L = LEFT_NODE( iNode );
        int R = RIGHT_NODE( iNode );
        int Largest;

        //  CompareNodes returns TRUE if L > iNode
        if ( L < HeapSize && CompareNodes( L, iNode ) )
            Largest = L;
        else
            Largest = iNode;

        //  CompareNodes returns TRUE if R > Largest
        if ( R < HeapSize && CompareNodes( R, Largest ) )
            Largest = R;

        if ( iNode != Largest )
        {
            Exchange( iNode, Largest );
            iNode = Largest;
        }
        else
        {
            break;
        }
    }
}

//
//	Implementation of CArticleHeap class
//

CArticleHeap::CArticleHeap( void )
{
}

BOOL CArticleHeap::ExtractOldest( FILETIME& ft, GROUPID& GroupId, ARTICLEID& ArticleId, DWORD& ArticleSize )
{
    if ( HeapSize <= 0 )
        return FALSE;

    if ( HEAPSTATE_HEAP == HeapState )
        SortHeap();

    HeapSize--;
    ft          = Heap[HeapSize].ft;
    GroupId     = Heap[HeapSize].GroupId;
    ArticleId   = Heap[HeapSize].ArticleId;
    ArticleSize = Heap[HeapSize].ArticleSize;

    return TRUE;
}

void CArticleHeap::Insert( FILETIME ft, GROUPID GroupId, ARTICLEID ArticleId, DWORD ArticleSize )
{
    if ( HEAPSTATE_SORTED == HeapState )
        BuildHeap();

    if ( HeapSize >= MAX_ARTHEAP_SIZE )
    {
        // Forget Youngest while adding new node to Heap.
        //
        if( CompareFileTime( &ft, &Heap[0].ft ) < 0 ) {
	        Heap[0].ft          = ft;
	        Heap[0].GroupId     = GroupId;
	        Heap[0].ArticleId   = ArticleId;
	        Heap[0].ArticleSize = ArticleSize;
	        Heapify( 0 );
	    }
        return;
    }
    else
    {
        int iNode = HeapSize++;
        while ( iNode > 0 && CompareFileTime( &Heap[PARENT_NODE( iNode )].ft, &ft ) < 0 )
        {
            Heap[iNode] = Heap[PARENT_NODE( iNode )];
            iNode = PARENT_NODE( iNode );
        }
        Heap[iNode].ft          = ft;
        Heap[iNode].GroupId     = GroupId;
        Heap[iNode].ArticleId   = ArticleId;
        Heap[iNode].ArticleSize = ArticleSize;
    }
}

void CArticleHeap::Exchange( int iNode, int jNode )
{
    ARTICLE_HEAP_NODE T = Heap[iNode];
    Heap[iNode] = Heap[jNode];
    Heap[jNode] = T;
}

BOOL CArticleHeap::CompareNodes( int iNode1, int iNode2 )
{
    if( CompareFileTime( &Heap[iNode1].ft, &Heap[iNode2].ft ) > 0 ) {
        return TRUE;
    }

    return FALSE;
}

//
//	Implementation of CXIXHeap class
//

CXIXHeap::CXIXHeap( void )
{
}

BOOL CXIXHeap::ExtractOldest( FILETIME& ft, GROUPID& GroupId, ARTICLEID& ArticleIdBase )
{
    if ( HeapSize <= 0 )
        return FALSE;

    if ( HEAPSTATE_HEAP == HeapState )
        SortHeap();

    HeapSize--;
    ft          = Heap[HeapSize].ft;
    GroupId     = Heap[HeapSize].GroupId;
    ArticleIdBase   = Heap[HeapSize].ArticleIdBase;

    return TRUE;
}

void CXIXHeap::Insert( FILETIME ft, GROUPID GroupId, ARTICLEID ArticleIdBase )
{
    if ( HEAPSTATE_SORTED == HeapState )
        BuildHeap();

    if ( HeapSize >= MAX_XIXHEAP_SIZE )
    {
        // Forget Youngest while adding new node to Heap.
        //
        if( CompareFileTime( &ft, &Heap[0].ft ) < 0 ) {
	        Heap[0].ft          = ft;
	        Heap[0].GroupId     = GroupId;
	        Heap[0].ArticleIdBase   = ArticleIdBase;
	        Heapify( 0 );
	    }
        return;
    }
    else
    {
        int iNode = HeapSize++;
        while ( iNode > 0 && CompareFileTime( &Heap[PARENT_NODE( iNode )].ft, &ft ) < 0 )
        {
            Heap[iNode] = Heap[PARENT_NODE( iNode )];
            iNode = PARENT_NODE( iNode );
        }
        Heap[iNode].ft          = ft;
        Heap[iNode].GroupId     = GroupId;
        Heap[iNode].ArticleIdBase   = ArticleIdBase;
    }
}

void CXIXHeap::Exchange( int iNode, int jNode )
{
    XIX_HEAP_NODE T = Heap[iNode];
    Heap[iNode] = Heap[jNode];
    Heap[jNode] = T;
}

BOOL CXIXHeap::CompareNodes( int iNode1, int iNode2 )
{
    if( CompareFileTime( &Heap[iNode1].ft, &Heap[iNode2].ft ) > 0 ) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\hash\src\xhash.cpp ===
/*++

	XHASH.CPP

	This file implements all of the code specific to
	the XOVER hash table used by NNTP.


--*/



#include	<windows.h>
#include	<stdlib.h>
#include    <xmemwrpr.h>
#include	<dbgtrace.h>
#include	"hashmap.h"
#include	"nntphash.h"



WORD
MyRand(
    IN DWORD& seed,
	IN DWORD	val
    )
{
    DWORD next = seed;
    next = (seed*val) * 1103515245 + 12345;   // magic!!
	seed = next ;
    return (WORD)((next/65536) % 32768);
}

HASH_VALUE
IDHash(
    IN DWORD Key1,
    IN DWORD Key2
    )
/*++

Routine Description:

    Used to find the hash value given 2 numbers. (Used for articleid + groupId)

Arguments:

    Key1 - first key to hash.  MS bit mapped to LSb of hash value
    Key2 - second key to hash.  LS bit mapped to MS bit of hash value.

Return Value:

    Hash value

--*/
{
    HASH_VALUE val;

    DWORD	val1 = 0x80000000, val2 = 0x80000000;

    //
    // Do Key1 first
    //

	DWORD	lowBits = Key2 & 0xf ;

	DWORD	TempKey2 = Key2 & (~0xf) ;
	DWORD	seed1 = (Key2 << (Key1 & 0x7)) - Key1 ;

	Key1 = (0x80000000 - ((67+Key1)*(19+Key1)*(7+Key1)+12345)) ^ (((3+Key1)*(5+Key1)+12345) << ((Key1&0xf)+8)) ;
	TempKey2 = (0x80000000 - ((67+TempKey2)*(19+TempKey2)*(7+TempKey2)*(1+TempKey2)+12345)) ^ ((TempKey2+12345) << (((TempKey2>>4)&0x7)+8)) ;
	
	val1 -=	(MyRand( seed1, Key1 ) << (Key1 & 0xf)) ;
	val1 += MyRand( seed1, Key1 ) << (((TempKey2 >> 4) & 0x3)+4) ;
	val1 ^=	MyRand( seed1, Key1 ) << 17 ;

	DWORD	seed2 = val1 - TempKey2 ;

	val2 -= MyRand( seed2, TempKey2 >> 1 ) << (((Key1 << 3)^Key1) &0xf) ;
	val2 =  (val2 + MyRand( seed2, TempKey2 )) << (13 ^ Key1) ;
	val2 ^= MyRand( seed2, TempKey2 ) << 15 ;

	
	//DWORD	val = val1 + val2 ;

	val = (val1 + val2 + 67) * (val1 - val2 + 19) * (val1 % (val2 + 67)) ;

	val += (MyRand( seed2, lowBits ) >> 3) ;

    return(val);

} // IDHash



DWORD	
ExtractGroupInfo(	LPSTR	data,
					GROUPID	&groupid,
					ARTICLEID	&articleid ) {

	char*	p = 0 ;
	p=strtok(data, "!");

	if ( p == NULL ) {
		_ASSERT(FALSE);
		return ERROR_INTERNAL_ERROR;
	}

	groupid	= atoi(p);
	p+=(strlen(p)+1);
	articleid  = atoi(p);

	return	0 ;
}


CXoverKey::CXoverKey() :
	m_groupid( INVALID_GROUPID ),
	m_articleid( INVALID_ARTICLEID ),
	m_cb( 0 )	{

}

DWORD
CXoverKey::Hash()	const	{
/*++

Routine Description :

	This function computes the hash value of a Message ID key

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	return	IDHash( m_groupid, m_articleid ) ;
}


BOOL
CXoverKey::CompareKeys(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function compares a key stored within ourselves to
	one that has been serialized into the hash table !

Arguments :

	Pointer to the start of the block of serialized data

Return Value :

	TRUE if the keys match !

--*/


	Key*	pKey = (XOVER_MAP_ENTRY*)pbPtr ;

	if( pKey->KeyLength() == m_cb	&&
        (lstrcmp(pKey->KeyPosition(), (const char*)&m_rgbSerialize[0]) == 0) ) {
        return TRUE;
    }

    return FALSE;
}


LPBYTE
CXoverKey::EntryData(	LPBYTE	pbPtr,
							DWORD&	cbKeyOut )	const	{
/*++

Routine Description :

	This function returns a pointer to where the data is
	serialized.  We always return the pointer we were passed
	as we have funky serialization semantics that places
	the key not before the data but somewhere in the middle
	or end.

Arguments :

	pbPtr - Start of serialized hash entyr
	cbKeyOut - returns the size of the key

Return Value :

	Pointer to where the data resides - same as pbPtr

--*/


	_ASSERT( pbPtr != 0 ) ;
	
	Key*	pKey = (Key*)pbPtr ;
	cbKeyOut = pKey->KeyLength() ;

	return	pbPtr ;
}


LPBYTE
CXoverKey::Serialize(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function saves a key into the hash table.
	We use functions off of the template type 'Key' to
	determine where we should stick the message id

Arguments :

	pbPtr - Start od where we should serialize to

Return Value :

	same as pbPtr

--*/

	_ASSERT( m_pData != 0  ) ;
	_ASSERT( pbPtr != 0 ) ;

	Key*	pKey = (Key*)pbPtr ;

	pKey->KeyLength() = WORD(m_cb) ;

	CopyMemory( SerializeOffset(pbPtr),
				m_rgbSerialize,
				m_cb ) ;
	return	pbPtr ;
}	


LPBYTE
CXoverKey::Restore(	LPBYTE	pbPtr, DWORD	&cbOut )		{
/*++

Routine Description :

	This function is called to recover a key from where
	it was Serialize()'d .

Arguments :

	pbPtr - Start of the block of serialized data

Return Value :

	pbPtr if successfull, NULL otherwise

--*/

	Key*	pKey = (Key*)pbPtr ;

	if( pKey->KeyLength() <= sizeof( m_rgbSerialize ) ) {
		CopyMemory( m_rgbSerialize, pKey->KeyPosition(), pKey->KeyLength() ) ;
		m_cb = pKey->KeyLength() ;
		return	pbPtr ;
	}
	return	0 ;
}


DWORD
CXoverKey::Size()	const	{
/*++

Routine Description :

	This function retruns the size of the key - which is just
	the number of bytes makeing up the message id.
	The bytes use to hold the serialized length are accounted
	for by the

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	return	m_cb ;
}


BOOL
CXoverKey::Verify(	BYTE*	pbContainer, BYTE*	pbData, DWORD	cb )	const	{

	return	TRUE ;

}



LPBYTE	
CXoverData::Serialize(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function saves XOVER data into a location in the XOVER file.
	Size() is called before we are to make sure there is sufficient
	room - we must use exactly Size() bytes !

Arguments :

	pbPtr - the location to save our data !

Return Value :

	Pointer to the first byte following the serialized data !

--*/

	XOVER_MAP_ENTRY*	pEntry = (XOVER_MAP_ENTRY*)pbPtr ;

	//
	//	Save the static header portions !
	//
	//
	pEntry->FileTime = m_data.FileTime ;
	pEntry->HeaderOffset = m_data.HeaderOffset ;
	pEntry->HeaderLength = m_data.HeaderLength ;
	pEntry->Flags = m_data.Flags ;
	pEntry->NumberOfXPostings = m_data.NumberOfXPostings ;

	//
	//	If we are primary then we have cross post info to save !
	//
	if( m_data.Flags & XOVER_MAP_PRIMARY ) {

		if( m_pGroups ) {
			CopyMemory( pEntry->XPostingsPosition(), m_pGroups,
				sizeof( m_pGroups[0] ) * m_cGroups ) ;
		}
	}	else	{
		_ASSERT(m_pGroups == 0 ) ;
		_ASSERT(m_cGroups == 0 ) ;
	}

	//
	//	If we are not primary this points at a buffer containing
	//	the primart Group and ArticleId formatted correctly - otherwise
	//	it really does contain the primary Message Id !
	//
	if( m_pchMessageId ) {
		pEntry->XoverDataLen = (WORD)m_cbMessageId ;
		CopyMemory( pEntry->MessageIDPosition(),
			m_pchMessageId, m_cbMessageId ) ;
	}
	return	pEntry->MessageIDPosition() + m_cbMessageId ;
}

LPBYTE
CXoverData::Restore(	LPBYTE	pbPtr,
						DWORD&	cbOut	
						)	{
/*++

Routine Description :

	This function copies the data out of a serialized XOVER
	entry into internal buffers.
	If there is not enough memory to hold the variable length
	objects we will succeed this call and mark a
	member variable (m_fSufficientBuffer) as FALSE.

Arguments :

	pbPtr - Buffer to restore from

	cbOut -		returns the number of bytes to hold this data

Return Value :

	Pointer to following byte if successfull - FALSE otherwise !

--*/

	CopyMemory( &m_data, pbPtr, sizeof( m_data ) - 1 ) ;

	XOVER_MAP_ENTRY*	pEntry = (XOVER_MAP_ENTRY*) pbPtr ;

	cbOut = Size() ;

	m_fSufficientBuffer = TRUE ;

	if( m_pGroups ) {
		if( m_cGroups >= m_data.NumberOfXPostings ) {
			m_cGroups = m_data.NumberOfXPostings ;
			CopyMemory( m_pGroups, pEntry->XPostingsPosition(),
				m_cGroups * sizeof( m_pGroups[0] ) ) ;

		}	else	{
		
			//
			//	Do not fail - assume caller checks
			//	our structures to determine failures !
			//
			m_fSufficientBuffer = FALSE ;
		}

	}

	if( m_data.Flags & XOVER_MAP_PRIMARY ) {
		if( m_pchMessageId ) {
			if( m_cbMessageId >= m_data.XoverDataLen ) {

				m_cbMessageId = 0 ;
	
				if( !m_pExtractor ||
					m_pExtractor->DoExtract(	m_PrimaryGroup,
									m_PrimaryArticle,
									(GROUP_ENTRY*)pEntry->XPostingsPosition(),
									pEntry->NumberOfXPostings ) ) {

					m_cbMessageId = m_data.XoverDataLen ;
					CopyMemory( m_pchMessageId, pEntry->MessageIDPosition(),
						m_cbMessageId ) ;

				}
			}	else	{

				m_fSufficientBuffer = FALSE ;			

			}
		}
	}	else	{

		if( m_data.XoverDataLen > 40 ) {
			SetLastError( ERROR_INTERNAL_ERROR ) ;
		}	else	{
			m_cb = m_data.XoverDataLen ;
			CopyMemory( m_rgbPrimaryBuff, pEntry->MessageIDPosition(),
					m_cb ) ;

		}
	}
	return	pbPtr + pEntry->TotalSize() ;
}

DWORD	
CXoverData::Size()	const	{

	DWORD	cbSize = sizeof( XOVER_MAP_ENTRY ) -1 ;
	if( m_pGroups ) {
		cbSize += m_data.NumberOfXPostings * sizeof( GROUP_ENTRY ) ;
	}
	if( m_pchMessageId ) {
		cbSize += m_data.XoverDataLen ;
	}
	return	cbSize ;
}


DWORD
CXoverKeyNew::Hash()	const	{
/*++

Routine Description :

	This function computes the hash value of a Message ID key

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	return	IDHash( m_key.GroupId, m_key.ArticleId ) ;
}



LPBYTE
CXoverDataNew::Restore(	LPBYTE	pbPtr,
								DWORD&	cbOut
								) {
	PXOVER_ENTRY	pEntry = (PXOVER_ENTRY)pbPtr ;
	DWORD cbStoreId = 0;

	if( pEntry->IsXoverEntry() ) {

		CopyMemory( &m_data, pbPtr, sizeof( m_data ) - 1 ) ;

		cbOut = Size() ;

		m_fSufficientBuffer = TRUE ;

		if( m_pGroups ) {
			if( m_cGroups >= m_data.NumberOfXPostings ) {
				m_cGroups = m_data.NumberOfXPostings ;
				CopyMemory( m_pGroups, pEntry->XPostingsPosition(),
					m_cGroups * sizeof( m_pGroups[0] ) ) ;

			}	else	{
			
				if( m_fFailRestore )	{
					return	0 ;
				}
				//
				//	Do not fail - assume caller checks
				//	our structures to determine failures !
				//
				m_fSufficientBuffer = FALSE ;
			}

		}

		if( m_data.Flags & XOVER_MAP_PRIMARY ) {
			m_PrimaryGroup = pEntry->Key.GroupId;
			m_PrimaryArticle = pEntry->Key.ArticleId;
		}	else	{
			GROUP_ENTRY*	p = pEntry->PrimaryEntry() ;
			m_PrimaryGroup = p->GroupId;
			m_PrimaryArticle = p->ArticleId;
		}

		if( m_data.Flags & XOVER_MAP_PRIMARY ) {
			if( m_pchMessageId ) {
				if( m_cbMessageId >= m_data.XoverDataLen ) {

					m_cbMessageId = 0 ;
		
					if( !m_pExtractor ||
						m_pExtractor->DoExtract(	m_PrimaryGroup,
										m_PrimaryArticle,
										(GROUP_ENTRY*)pEntry->XPostingsPosition(),
										pEntry->NumberOfXPostings ) ) {

						m_cbMessageId = m_data.XoverDataLen ;
						CopyMemory( m_pchMessageId, pEntry->MessageIDPosition(),
							m_cbMessageId ) ;

					}
				}	else	{

					if( m_fFailRestore )
						return	0 ;

					m_fSufficientBuffer = FALSE ;			

				}
			}

			if (m_data.Flags & XOVER_CONTAINS_STOREID) {
				BYTE *p = pEntry->StoreIdPosition();

				// get the count of store ids
				m_cEntryStoreIds = *p; p++;
				DWORD c = min(m_cStoreIds, m_cEntryStoreIds);
				if (c < m_cStoreIds) m_cStoreIds = c;

				// copy the crosspost count array
				if (m_pcCrossposts) CopyMemory(m_pcCrossposts, p, m_cEntryStoreIds);
				p += m_cEntryStoreIds;

				// copy the store id array
				for (DWORD i = 0; i < c; i++) {
					m_pStoreIds[i].cLen = *p; p++;
					CopyMemory(m_pStoreIds[i].pbStoreId, p, m_pStoreIds[i].cLen); p += m_pStoreIds[i].cLen;
				}
				cbStoreId = (DWORD)(p - pEntry->StoreIdPosition());
			} else {
				m_cEntryStoreIds = 0;
			}
		}
#if 0
			else	{

			if( m_data.XoverDataLen > 40 ) {
				SetLastError( ERROR_INTERNAL_ERROR ) ;
			}	else	{
				m_cb = m_data.XoverDataLen ;
				CopyMemory( m_rgbPrimaryBuff, pEntry->MessageIDPosition(),
						m_cb ) ;

			}
		}
#endif
		return	pbPtr + pEntry->TotalSize() + cbStoreId;
		
	}	else	{

		CXoverData*	pXover = GetBackLevel() ;

		pXover->m_pchMessageId = m_pchMessageId ;
		pXover->m_cbMessageId = m_cbMessageId ;
		pXover->m_pExtractor = m_pExtractor ;
		pXover->m_PrimaryGroup = m_PrimaryGroup ;
		pXover->m_PrimaryArticle = m_PrimaryArticle ;
		pXover->m_cGroups = m_cGroups ;
		pXover->m_pGroups = m_pGroups ;
		pXover->m_cb = m_cb ;

		LPBYTE	lpb = pXover->Restore( pbPtr, cbOut ) ;

		m_data.FileTime = pXover->m_data.FileTime ;
		m_data.Flags = pXover->m_data.Flags ;
		m_data.NumberOfXPostings = pXover->m_data.NumberOfXPostings ;
		m_data.XoverDataLen = pXover->m_data.XoverDataLen ;
		m_data.HeaderOffset = pXover->m_data.HeaderOffset ;
		m_data.HeaderLength = pXover->m_data.HeaderLength ;

		m_fSufficientBuffer = pXover->m_fSufficientBuffer ;
		m_pGroups = pXover->m_pGroups ;
		m_cGroups = pXover->m_cGroups ;
		m_pchMessageId = pXover->m_pchMessageId ;
		m_cbMessageId = pXover->m_cbMessageId ;
		m_cb = pXover->m_cb ;
		m_cEntryStoreIds = 0;
		
				
		if( !(m_data.Flags & XOVER_MAP_PRIMARY) ) {
			ExtractGroupInfo( pXover->m_rgbPrimaryBuff, m_PrimaryGroup, m_PrimaryArticle ) ;

		}
		return	lpb ;
	}
	return 0 ;
}


LPBYTE	
CXoverDataNew::Serialize(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function saves XOVER data into a location in the XOVER file.
	Size() is called before we are to make sure there is sufficient
	room - we must use exactly Size() bytes !

Arguments :

	pbPtr - the location to save our data !

Return Value :

	Pointer to the first byte following the serialized data !

--*/

	XOVER_ENTRY*	pEntry = (XOVER_ENTRY*)pbPtr ;

	//
	//	Save the static header portions !
	//
	//
	pEntry->FileTime = m_data.FileTime ;
	pEntry->Flags = m_data.Flags ;
	pEntry->NumberOfXPostings = m_data.NumberOfXPostings ;
	pEntry->XoverDataLen = m_data.XoverDataLen ;
	pEntry->HeaderOffset = m_data.HeaderOffset ;
	pEntry->HeaderLength = m_data.HeaderLength ;

	_ASSERT( pEntry->IsXoverEntry() ) ;

	//
	//	If we are primary then we have cross post info to save !
	//
	if( m_data.Flags & XOVER_MAP_PRIMARY ) {

		if( m_pGroups ) {
			CopyMemory( pEntry->XPostingsPosition(), m_pGroups,
				sizeof( m_pGroups[0] ) * m_cGroups ) ;
		}	else	{
			_ASSERT( pEntry->NumberOfXPostings == 0 ) ;
		}
	}	else	{

		_ASSERT( pEntry->NumberOfXPostings == 1 ) ;

		GROUP_ENTRY*	pGroup = pEntry->PrimaryEntry() ;
		pGroup->GroupId = m_PrimaryGroup ;
		pGroup->ArticleId = m_PrimaryArticle ;


		_ASSERT(m_pGroups == 0 ) ;
		_ASSERT(m_cGroups == 0 ) ;
	}

	//
	//	If we are not primary this points at a buffer containing
	//	the primart Group and ArticleId formatted correctly - otherwise
	//	it really does contain the primary Message Id !
	//
	if( m_pchMessageId ) {
		pEntry->XoverDataLen = (WORD)m_cbMessageId ;
		CopyMemory( pEntry->MessageIDPosition(),
			m_pchMessageId, m_cbMessageId ) ;
	}

	DWORD cbStoreId = 0;
	// this data has a count of store Ids followed by each store id.  Each
	// store id contains a length byte followed by data bytes.
	if ((m_data.Flags & XOVER_MAP_PRIMARY) && m_cStoreIds > 0) {
		_ASSERT(m_data.Flags & XOVER_CONTAINS_STOREID);
		BYTE *p = pEntry->StoreIdPosition();
		// store the length of this array
		*p = (BYTE) m_cStoreIds; p++;
		// store the crosspost count array
		CopyMemory(p, m_pcCrossposts, m_cStoreIds); p += m_cStoreIds;
		for (DWORD i = 0; i < m_cStoreIds; i++) {
			*p = m_pStoreIds[i].cLen; p++;

			CopyMemory(p, m_pStoreIds[i].pbStoreId, m_pStoreIds[i].cLen);
			p += m_pStoreIds[i].cLen;
		}
		cbStoreId = (DWORD)(p - pEntry->StoreIdPosition());
	}

	return	pEntry->MessageIDPosition() + m_cbMessageId + cbStoreId;
}


DWORD	
CXoverDataNew::Size()	const	{
	DWORD	cbSize = sizeof( XOVER_ENTRY ) -1 ;

	if( m_pGroups ) {
		cbSize += m_data.NumberOfXPostings * sizeof( GROUP_ENTRY ) ;
	}
	if( m_pchMessageId ) {
		cbSize += m_data.XoverDataLen ;
	}	
	if ((m_data.Flags & XOVER_MAP_PRIMARY) && m_cStoreIds > 0) {
		cbSize += sizeof(BYTE);			// storeid count
		cbSize += m_cStoreIds;			// crosspost count array
		for (DWORD i = 0; i < m_cStoreIds; i++) {
			cbSize += sizeof(BYTE);		// storeid length
			cbSize += m_pStoreIds[i].cLen;
		}
	}
	return	cbSize ;
}


CXoverMap*
CXoverMap::CreateXoverMap(StoreType st)	{

	return	new	CXoverMapImp() ;

}

CXoverMap::~CXoverMap()	{
}


BOOL
CXoverMapImp::CreatePrimaryNovEntry(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		WORD		HeaderOffset,
		WORD		HeaderLength,
		PFILETIME	FileTime,
		LPCSTR		szMessageId,
		DWORD		cbMessageId,
		DWORD		cEntries,
		GROUP_ENTRY	*pEntries,
		DWORD		cStoreIds,
		CStoreId	*pStoreIds,
		BYTE		*pcCrossposts
		)	{
/*++

Routine Description :

	Create an entry in the XOVER table for a Primary Entry.
	The Primary entry contains cross posting info and the Message
	Id of the new element.

Arguments :

	GroupId - Primary Grouop ID
	ArticleId	- Primary Article Id
	HeaderOffset - Offset to the RFC 822 header
	HeaderLength - Length of the RFC 822 Header
	FileTime - Time the article arrived
	szMessageId - The Message Id of the article
	cbMessageId - length of the Message Id
	cEntries - Number of GROUP_ENTRY objects to be serialized
	pEntries - Pointer to the GROUP_ENTRY objects to be saved in the entry
	
Return Value :

	TRUE if successfull !

--*/

	_ASSERT( cEntries <= 255 ) ;

	CXoverDataNew	data(		*FileTime,
							HeaderOffset,
							HeaderLength,
							BYTE(cEntries),
							pEntries,
							cbMessageId,
							(LPSTR)szMessageId,
							BYTE(cStoreIds),
							pStoreIds,
							pcCrossposts
							) ;
	CXoverKeyNew	key( GroupId, ArticleId, &data.m_data ) ;

	return	CHashMap::InsertMapEntry(	&key,
										&data ) ;	
	
}

BOOL
CXoverMapImp::CreateXPostNovEntry(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		WORD		HeaderOffset,
		WORD		HeaderLength,
		PFILETIME	FileTime,
		GROUPID		PrimaryGroupId,
		ARTICLEID	PrimaryArticleId
		)	{
/*++

Routine Description :

	Create an entry for a cross posted article.
	
Arguments :

	GroupId - The Group the cross posted article resides in
	ArticleId - The Id of the article in the cross posting group
	HeaderOffset - Offset to the RFC 822 Header within the article
	HeaderLength - Length of the RFC 822 header within the article
	FileTime - Time the article arrived on the systyem
	PrimaryGroupId - The Group of the primary article
	PrimaryArticleId - The Id of the Primary Article within the Primary Group

Return Value :

	TRUE if successfull.

--*/

	CXoverDataNew	data(	*FileTime,
						HeaderOffset,
						HeaderLength,
						PrimaryGroupId,
						PrimaryArticleId
						) ;

	CXoverKeyNew	key( GroupId, ArticleId, &data.m_data ) ;

	return	CHashMap::InsertMapEntry(	&key,
										&data ) ;

}

BOOL
CXoverMapImp::DeleteNovEntry(
		GROUPID		GroupId,
		ARTICLEID	ArticleId
		)	{
/*++

Routine Description :

	Removes an entry from the hash table

Arguments :

	GroupId - Id of the group for which we wish to remove the entry
	ArticleId - Id of the article within the group

Return Value :

	TRUE if successfull !

--*/

	CXoverKeyNew	key( GroupId, ArticleId, 0 ) ;

	return	CHashMap::DeleteMapEntry(	&key ) ;
}

BOOL
CXoverMapImp::ExtractNovEntryInfo(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		BOOL		&fPrimary,
		WORD		&HeaderOffset,
		WORD		&HeaderLength,
		PFILETIME	FileTime,
		DWORD		&DataLen,
		PCHAR		MessageId,
		DWORD		&cStoreIds,
		CStoreId	*pStoreIds,
		BYTE		*pcCrossposts,
		IExtractObject*	pExtract
		)	{
/*++

Routine Description :

	Extract selected information about the specified article -
	if the article is not a primary article but a cross posting
	we will find the primary article and get info there  !

Arguments :

	GroupId - NewsGroup in which the article we want info about resides
	ArticleId - Id of the article within GroupId
	fPrimary - Returns whether the article is the primary Article
	HeaderOffset - returns the offset to the RFC 822 header within the article
	HeaderLength - returns the length of the RFC 822 header
	FileTime - returns the time the article was added to the system
	DataLen - IN/OUT parameter - comes in with the size of the MessageId buffer,
		returns the number of bytes placed in buffer
	MessageId - Buffer to hold the message Id
	pExtract -

Return Value :

	TRUE if successfull, FALSE otherwise !

--*/

	CXoverKeyNew	key(	GroupId,	ArticleId, 0 ) ;
	CXoverDataNew	data ;

	data.m_pchMessageId = MessageId ;
	data.m_cbMessageId = DataLen ;
	data.m_pExtractor = pExtract ;
	data.m_PrimaryGroup = GroupId ;
	data.m_PrimaryArticle = ArticleId ;
	data.m_cStoreIds = cStoreIds;
	data.m_pStoreIds = pStoreIds;
	data.m_pcCrossposts = pcCrossposts;

	char	*pchPrimary = data.m_pchMessageId ;
	BOOL	fSuccess = FALSE ;

	if(	fSuccess = CHashMap::LookupMapEntry(	&key,
												&data ) )	{

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) )	{

			fPrimary = FALSE ;

			//
			//	Assume that we need to reread these !
			//
			data.m_pchMessageId = MessageId ;
			data.m_cbMessageId = DataLen ;

#if 0
			ExtractGroupInfo(	&data.m_rgbPrimaryBuff[0],
								GroupId,
								ArticleId ) ;

			data.m_PrimaryGroup = GroupId ;
			data.m_PrimaryArticle = ArticleId ;
#else
			GroupId = data.m_PrimaryGroup ;
			ArticleId = data.m_PrimaryArticle ;
			_ASSERT( GroupId != INVALID_GROUPID ) ;
			_ASSERT( ArticleId != INVALID_ARTICLEID ) ;
#endif

			CXoverKeyNew	key2(	GroupId, ArticleId, 0 ) ;
			
			fSuccess = CHashMap::LookupMapEntry(	&key2,
													&data ) ;


		}	else	{

			fPrimary = TRUE ;

		}
	}	

	// report the number of ids in the entry
	cStoreIds = data.m_cEntryStoreIds;

	if( fSuccess ) {

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) ) {
			SetLastError( ERROR_INTERNAL_ERROR ) ;
			return	FALSE ;
		}

		HeaderOffset = data.m_data.HeaderOffset ;
		HeaderLength = data.m_data.HeaderLength ;
		*FileTime = data.m_data.FileTime ;

		DataLen = data.m_data.XoverDataLen ;

		if( !data.m_fSufficientBuffer ) {
			SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
		}	else	{
			DataLen = data.m_cbMessageId ;
		}

		return	data.m_fSufficientBuffer ;
	}
	return	FALSE ;
}


//
//	Get the primary article and the message-id if necessary
//
BOOL
CXoverMapImp::GetPrimaryArticle(	
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		GROUPID&	GroupIdPrimary,
		ARTICLEID&	ArticleIdPrimary,
		DWORD		cbBuffer,
		PCHAR		MessageId,
		DWORD&		DataLen,
		WORD&		HeaderOffset,
		WORD&		HeaderLength,
		CStoreId	&storeid
		)	{

	_ASSERT( GroupId != INVALID_GROUPID ) ;
	_ASSERT( ArticleId != INVALID_ARTICLEID ) ;
	
	GroupIdPrimary = INVALID_GROUPID ;
	ArticleIdPrimary = INVALID_ARTICLEID ;

	CXoverKeyNew	key(	GroupId,	ArticleId, 0 ) ;
	CXoverDataNew	data ;

	data.m_pchMessageId = MessageId ;
	data.m_cbMessageId = DataLen ;
	data.m_PrimaryGroup = GroupId ;
	data.m_PrimaryArticle = ArticleId ;
	data.m_cStoreIds = 1;
	data.m_pStoreIds = &storeid;

	char	*pchPrimary = data.m_pchMessageId ;
	BOOL	fSuccess = FALSE ;

	if(	fSuccess = CHashMap::LookupMapEntry(	&key,
												&data ) )	{

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) )	{

#if 0
			ExtractGroupInfo(	&data.m_rgbPrimaryBuff[0],
								GroupId,
								ArticleId ) ;

			data.m_PrimaryGroup = GroupId ;
			data.m_PrimaryArticle = ArticleId ;
#else
			GroupId = data.m_PrimaryGroup ;
			ArticleId = data.m_PrimaryArticle ;
			_ASSERT( GroupId != INVALID_GROUPID ) ;
			_ASSERT( ArticleId != INVALID_ARTICLEID ) ;
#endif

			CXoverKeyNew	key2(	GroupId, ArticleId, 0 ) ;
			
			//
			//	Assume that we need to reread these !
			//
			data.m_pchMessageId = MessageId ;
			data.m_cbMessageId = DataLen ;

			fSuccess = CHashMap::LookupMapEntry(	&key2,
													&data ) ;


		}	

		GroupIdPrimary = GroupId ;
		ArticleIdPrimary = ArticleId ;

	}	

	if( fSuccess ) {

		HeaderOffset = data.m_data.HeaderOffset ;
		HeaderLength = data.m_data.HeaderLength ;

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) ) {
			GroupIdPrimary = INVALID_GROUPID ;
			ArticleIdPrimary = INVALID_ARTICLEID ;
			SetLastError( ERROR_INTERNAL_ERROR ) ;
			return	FALSE ;
		}

		if( MessageId )	{
			DataLen = data.m_data.XoverDataLen ;

			if( !data.m_fSufficientBuffer) {
				SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
				return	FALSE ;
			}	else	{
				DataLen = data.m_cbMessageId ;
			}
		}

		return	TRUE ;
	}
	return	FALSE ;




}


//
//	Check to see whether the specified entry exists -
//	don't care about its contents !
//
BOOL
CXoverMapImp::Contains(	
		GROUPID		GroupId,
		ARTICLEID	ArticleId
		)	{

	CXoverKeyNew	key(	GroupId,	ArticleId, 0 ) ;

	return	CHashMap::Contains( &key ) ;
}

//
//	Get all the cross-posting information related to an article !
//
BOOL
CXoverMapImp::GetArticleXPosts(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		BOOL		PrimaryOnly,
		PGROUP_ENTRY	GroupList,
		DWORD		&GroupListSize,
		DWORD		&NumberOfGroups,
		PBYTE		rgcCrossposts
		)	{


	CXoverKeyNew	key(	GroupId,	ArticleId, 0 ) ;
	CXoverDataNew	data ;

	DWORD	WorkingSize = GroupListSize ;
	PGROUP_ENTRY	WorkingEntry = GroupList ;
	DWORD cStoreCrossposts;

	if( WorkingSize < sizeof( GROUP_ENTRY ) ) {
		WorkingEntry = 0 ;
		WorkingSize = 0 ;
	}

	if( WorkingSize != 0 && !PrimaryOnly ) {
		data.m_cGroups = (WorkingSize / sizeof( GROUP_ENTRY )) - 1 ;
		if( data.m_cGroups != 0 ) {
			data.m_pGroups = WorkingEntry+1 ;
		}	
	}

	data.m_pcCrossposts = rgcCrossposts;

	BOOL	fSuccess = FALSE ;

	if(	fSuccess = CHashMap::LookupMapEntry(	&key,
												&data ) )	{


		if( (data.m_data.Flags & XOVER_MAP_PRIMARY) )	{

			if( WorkingEntry != 0 ) {
				WorkingEntry->GroupId = GroupId ;
				WorkingEntry->ArticleId = ArticleId ;
			}

		}	else	{

#if 0
			//
			//	Assume that we need to reread these !
			//
			ExtractGroupInfo(	&data.m_rgbPrimaryBuff[0],
								GroupId,
								ArticleId ) ;
#else
			GroupId = data.m_PrimaryGroup ;
			ArticleId = data.m_PrimaryArticle ;
#endif

			if( WorkingEntry != 0 ) {
				WorkingEntry->GroupId = GroupId ;
				WorkingEntry->ArticleId = ArticleId ;
			}

		}

		if( PrimaryOnly ) {

			//
			//	If we only want the primary we're all set !!
			//
			GroupListSize = sizeof( GROUP_ENTRY ) ;
			NumberOfGroups = 1 ;

			if( WorkingEntry == 0 ) {
				SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
				return	FALSE ;
			}

			//
			//	We're all done then !
			//
			return	TRUE ;

		}	

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) ) {
	
			CXoverKeyNew	key2(	GroupId, ArticleId, 0 ) ;

			if( WorkingSize != 0 && !PrimaryOnly ) {
				data.m_cGroups = (WorkingSize / sizeof( GROUP_ENTRY )) - 1 ;
				if( data.m_cGroups != 0 ) {
					data.m_pGroups = WorkingEntry+1 ;
				}	
			}


			fSuccess = CHashMap::LookupMapEntry(	&key2,
													&data ) ;
		}
	}	

	if( fSuccess ) {

		NumberOfGroups = 1 + data.m_data.NumberOfXPostings ;
		GroupListSize = NumberOfGroups * sizeof( GROUP_ENTRY ) ;

		if( !data.m_fSufficientBuffer )
			SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;

		return	data.m_fSufficientBuffer ;
	}
	return	FALSE ;
}

//
//	Initialize the hash table
//
BOOL
CXoverMapImp::Initialize(	
		LPSTR		lpstrXoverFile,
		HASH_FAILURE_PFN	pfnHint,
		BOOL	fNoBuffering
		)	{

	return	CHashMap::Initialize(
							lpstrXoverFile,
                            XOVER_HEAD_SIGNATURE,
                            0,
							1,
							g_pSharedCache,
							HASH_VFLAG_PAGE_BASIC_CHECKS,
							pfnHint,
							0,
							fNoBuffering
							) ;
}

BOOL
CXoverMapImp::SearchNovEntry(
		GROUPID		GroupId,
		ARTICLEID	ArticleId,
		PCHAR		XoverData,
		PDWORD		DataLen,
        BOOL        fDeleteOrphans
		)	{

	CXoverKeyNew	key( GroupId, ArticleId, 0 ) ;
	CXoverDataNew	data ;

    DWORD   Length = 0 ;
    if( DataLen != 0 )
        Length = *DataLen ;

    if( Length != 0 ) {
    	data.m_pchMessageId = XoverData ;
        data.m_cbMessageId = Length ;
    }

	BOOL	fSuccess = FALSE ;

	if(	fSuccess = CHashMap::LookupMapEntry(	&key,
												&data ) )	{

		if( !(data.m_data.Flags & XOVER_MAP_PRIMARY) )	{

			//
			//	Assume that we need to reread these !
			//
            if( Length != 0 ) {
    	        data.m_pchMessageId = XoverData ;
                data.m_cbMessageId = Length ;
            }

#if 0
			ExtractGroupInfo(	&data.m_rgbPrimaryBuff[0],
								GroupId,
								ArticleId ) ;
#else
			GroupId = data.m_PrimaryGroup ;
			ArticleId = data.m_PrimaryArticle ;
#endif

    		CXoverKeyNew	key2(	GroupId, ArticleId, 0 ) ;
            fSuccess = CHashMap::LookupMapEntry(	fDeleteOrphans ? &key2 : &key,
													&data ) ;
            if( !fSuccess && fDeleteOrphans ) {
        		CHashMap::DeleteMapEntry(	&key ) ;
                SetLastError( ERROR_FILE_NOT_FOUND );
                return FALSE;
            }
		}	
	}

	if( fSuccess ) {

        if( DataLen != 0 )
    		*DataLen = data.m_data.XoverDataLen ;

		if( !data.m_fSufficientBuffer )
			SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;

		return	data.m_fSufficientBuffer ;
	}
	return	FALSE ;
}

void
CXoverMapImp::Shutdown(

		)	{
/*++

Routine Description :

	Terminate the hash table

Arguments :

	None

Return Value :

	None

--*/

	CHashMap::Shutdown( FALSE ) ;

}

DWORD
CXoverMapImp::GetEntryCount()	{
/*++

Routine Description :

	Return the number of entries in the hash table

Arguments :

	None

Return Value :

	Number of Message ID's in the table

--*/

	return	CHashMap::GetEntryCount() ;

}

BOOL
CXoverMapImp::IsActive() {
/*++

Routine Description :

	Returns TRUE if hash table operational

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	return	CHashMap::IsActive() ;

}

CXoverMapImp::~CXoverMapImp()	{
}

BOOL
CXoverMapImp::GetFirstNovEntry(
				OUT	CXoverMapIterator*	&pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer,
				OUT	PCHAR	MessageId,
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				)	{
	//
	//	Validate our arguments !
	//
	_ASSERT( pIterator == 0 ) ;
	_ASSERT( (MessageId == 0 && cbBuffer == 0) || (MessageId != 0 && cbBuffer != 0) ) ;
	_ASSERT( (cGroupBuffer == 0 && pGroupList ==0) || (cGroupBuffer != 0 && pGroupList != 0) ) ;

	GroupId = INVALID_GROUPID ;
	ArticleId = INVALID_ARTICLEID ;
	cGroups = 0 ;

	BOOL	fSuccess = FALSE ;
	

	CXoverMapIteratorImp*	pImp = new	CXoverMapIteratorImp() ;

	if( pImp ) {
		//
		//	This is the object we use to get the key of the XOVER entry !
		//
		CXoverKeyNew	key ;

		//
		//	This is the object we give to the basic hash table to get the
		//	Data portion of the XOVER entry !
		//
		CXoverDataNew	data ;
		data.m_fFailRestore = TRUE ;
		
		//
		//	Setup the data object so that it extracts the fields the caller requested !
		//
		//	If the user provides space for more than one GROUP_ENTRY object, arrange
		//	space so that we have room to stick the primary as the first entry !
		//
		if( cGroupBuffer > 1 ) {
			data.m_cGroups = cGroupBuffer - 1 ;
			data.m_pGroups = pGroupList + 1 ;
		}

		//
		//	Setup to extract the Message-ID if requested !
		//
		data.m_pchMessageId = MessageId ;
		data.m_cbMessageId = cbBuffer ;

		DWORD	cbKeyRequired= 0 ;
		DWORD	cbEntryRequired = 0 ;

		fSuccess = GetFirstMapEntry(	
											&key,
											cbKeyRequired,
											&data,
											cbEntryRequired,
											&pImp->m_IteratorContext,
											0
											) ;

		//
		//	Now - this should have extracted the data we want !
		//

		if( !fSuccess ) {
			if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {
				//
				//	If the error is that the user did not provide enough memory to get the
				//	first item in the hash table, then we will return them the iterator
				//	even though we return FALSE as well !
				//	
				pIterator = pImp ;

			}	else	{
				//
				//	Don't give out a useless Iterator, destroy it !
				//
				delete	pImp ;
				_ASSERT( pIterator == 0 ) ;
			}
		}	else	{

			//
			//	Give out the iterator that can be used to continue walking the tree !
			//
			pIterator = pImp ;

			//
			//	Do the basic items
			//
			GroupId = key.m_key.GroupId ;
			ArticleId = key.m_key.ArticleId ;

			fIsPrimary = (GroupId == data.m_PrimaryGroup) && (ArticleId == data.m_PrimaryArticle) ;

			//
			//	Is this the primary entry ? if so fix up the GROUP_ENTRY structure !
			//
			if( cGroupBuffer >= 1 ) {
				pGroupList[0].GroupId = data.m_PrimaryGroup ;
				pGroupList[0].ArticleId = data.m_PrimaryArticle ;
			}		
		}
	}
	return	fSuccess ;
}

BOOL
CXoverMapImp::GetNextNovEntry(		
				IN	CXoverMapIterator*	pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer,
				OUT	PCHAR	MessageId,
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				)	{	

	//
	//	Do some argument validation !
	//
	_ASSERT( pIterator != 0 ) ;
	_ASSERT( (MessageId == 0 && cbBuffer == 0) || (MessageId != 0 && cbBuffer != 0) ) ;
	_ASSERT( (cGroupBuffer == 0 && pGroupList ==0) || (cGroupBuffer != 0 && pGroupList != 0) ) ;
	_ASSERT( cGroups == 0 ) ;

	//
	//	Downcast to the actual implementation of the iterator !
	//
	CXoverMapIteratorImp	*pImp = (CXoverMapIteratorImp*)pIterator ;

	//
	//	Set all out parameters to illegal stuff !
	//
	GroupId = INVALID_GROUPID ;
	ArticleId = INVALID_ARTICLEID ;
	cGroups = 0 ;
	
	//
	//	This is the object we use to get the key of the XOVER entry !
	//
	CXoverKeyNew	key ;

	//
	//	This is the object we give to the basic hash table to get the
	//	Data portion of the XOVER entry !
	//
	CXoverDataNew	data ;
	data.m_fFailRestore = TRUE ;
	
	//
	//	Setup the data object so that it extracts the fields the caller requested !
	//
	//	If the user provides space for more than one GROUP_ENTRY object, arrange
	//	space so that we have room to stick the primary as the first entry !
	//
	if( cGroupBuffer > 1 ) {
		data.m_cGroups = cGroupBuffer - 1 ;
		data.m_pGroups = pGroupList + 1 ;
	}

	//
	//	Setup to extract the Message-ID if requested !
	//
	data.m_pchMessageId = MessageId ;
	data.m_cbMessageId = cbBuffer ;

	DWORD	cbKeyRequired= 0 ;
	DWORD	cbEntryRequired = 0 ;

	BOOL	fSuccess = GetNextMapEntry(	&key,
										cbKeyRequired,
										&data,
										cbEntryRequired,
										&pImp->m_IteratorContext,
										0
										) ;

	//
	//	Now - this should have extracted the data we want !
	//

	if( fSuccess ) {
		//
		//	Is this the primary entry ? if so fix up the GROUP_ENTRY structure !
		//
		//
		//	Do the basic items
		//
		GroupId = key.m_key.GroupId ;
		ArticleId = key.m_key.ArticleId ;

		fIsPrimary = (GroupId == data.m_PrimaryGroup) && (ArticleId == data.m_PrimaryArticle) ;

		//
		//	Is this the primary entry ? if so fix up the GROUP_ENTRY structure !
		//
		if( cGroupBuffer >= 1 ) {
			pGroupList[0].GroupId = data.m_PrimaryGroup ;
			pGroupList[0].ArticleId = data.m_PrimaryArticle ;
		}		
	}
	return	fSuccess ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\heap\test\heaptst.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include    <stdlib.h>
#include    "tigtypes.h"
#include	"baseheap.h"

VOID
WINAPI
ShowUsage (
             VOID
);

VOID
WINAPI
ParseSwitch (
               CHAR chSwitch,
               int *pArgc,
               char **pArgv[]
);

ARTICLEID
ArticleIdMapper( 
		ARTICLEID	dw
		);

DWORD	
ByteSwapper( 
		DWORD	dw 
		);

BOOL  fScanNws = FALSE;
CHAR  szDir [MAX_PATH+1];

int _cdecl
main (
        int argc,
        char *argv[],
        char *envp[]
)
{
	char    chChar, *pchChar;
    BOOL    fRet = TRUE;
    char    szFile[ MAX_PATH ];
	int	    cbString = 0 ;
	szFile[0] = '\0' ;

	// defaults 
	lstrcpy( szDir, "c:\\winnt\\system32" );

	while (--argc)
	{
		pchChar = *++argv;
		if (*pchChar == '/' || *pchChar == '-')
		{
			while (chChar = *++pchChar)
			{
				ParseSwitch (chChar, &argc, &argv);
			}
		}
	}

    if( fScanNws ) {
        //
        //  Build a heap of NWS files
        //

	    cbString = wsprintf( szFile, "%s\\*.nws", szDir );
        printf("heaptst will scan NWS files in dir %s and build a heap of such files\n", szDir );

        CArticleHeap ArtHeap;
        ArtHeap.ForgetAll();

        //
        //  Scan files in specified dir to build a heap
        //

	    if( szFile[0] != '\0' ) 
	    {
		    WIN32_FIND_DATA FileStats;
		    HANDLE hFind = FindFirstFile( szFile, &FileStats );

		    if ( INVALID_HANDLE_VALUE != hFind )	
		    {
			    do
			    {
                    printf("Scanning file %s\n", FileStats.cFileName );
                    ArtHeap.Insert( FileStats.ftLastWriteTime, 1, 1, FileStats.nFileSizeLow );

			    } while ( FindNextFile( hFind, &FileStats ) );
			    FindClose( hFind );
		    }
	    }

        //
        //  Dump the heap
        //

	    FILETIME   ft;
        SYSTEMTIME st;
	    GROUPID    GroupId;
	    ARTICLEID  ArticleId;
	    DWORD      ArticleSize;

	    while (  ArtHeap.ExtractOldest( ft, GroupId, ArticleId, ArticleSize ) )
	    {
            FileTimeToSystemTime( (const FILETIME*)&ft, &st );
            printf("File size is %d SystemTime is %d::%d::%d\n", ArticleSize, st.wMonth, st.wDay, st.wYear );
	    }

        if( ArtHeap.isEmpty() ) {
            printf("NWS Heap is empty\n");
        }
    }

    //
    //  Build a heap of XIX files
    //

	cbString = wsprintf( szFile, "%s\\*.xix", szDir );
    printf("heaptst will scan XIX files in dir %s and build a heap of such files\n", szDir );

    CXIXHeap XixHeap;
    XixHeap.ForgetAll();

    //
    //  Scan files in specified dir to build a heap
    //

	if( szFile[0] != '\0' ) 
	{
		WIN32_FIND_DATA FileStats;
		HANDLE hFind = FindFirstFile( szFile, &FileStats );

		if ( INVALID_HANDLE_VALUE != hFind )	
		{
			do
			{
                printf("Scanning file %s\n", FileStats.cFileName );

				ARTICLEID iArticleIdBase;

				PCHAR p=strtok(FileStats.cFileName,".");
				if ( p == NULL ) {
					printf("Cannot get article ID base number from %s",FileStats.cFileName);
					continue;
				}

				if( sscanf( p, "%x", &iArticleIdBase ) != 1 ) 
					continue ;

				iArticleIdBase = ArticleIdMapper( iArticleIdBase ) ;

                XixHeap.Insert( FileStats.ftCreationTime, 1, iArticleIdBase );

			} while ( FindNextFile( hFind, &FileStats ) );
			FindClose( hFind );
		}
	}

    //
    //  Dump the heap
    //

	FILETIME   ft;
    SYSTEMTIME st;
	GROUPID    GroupId;
	ARTICLEID  ArticleIdBase;

	while (  XixHeap.ExtractOldest( ft, GroupId, ArticleIdBase ) )
	{
        FileTimeToSystemTime( (const FILETIME*)&ft, &st );
        printf("ArticleIdBase is %d SystemTime is %d::%d::%d\n", ArticleIdBase, st.wMonth, st.wDay, st.wYear );
	}

    if( XixHeap.isEmpty() ) {
        printf("XIX Heap is empty\n");
    }

    return 1;
}

VOID
WINAPI
ShowUsage (
             VOID
)
{
   fputs ("usage: heaptst [switches]\n"
	  "               [-?] show this message\n"
	  "               [-n] scan NWS\n"
	  "               [-d] directory \n"
          ,stderr);

   exit (1);
}


VOID
WINAPI
ParseSwitch (
               CHAR chSwitch,
               int *pArgc,
               char **pArgv[]
)
{
   switch (toupper (chSwitch))
   {

   case '?':
      ShowUsage ();
      break;

   case 'N':
      fScanNws = TRUE;
      break;

   case 'D':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      lstrcpy( szDir, *(*pArgv) );
      break;

   default:
      fprintf (stderr, "heaptst: Invalid switch - /%c\n", chSwitch);
      ShowUsage ();
      break;

   }
}

DWORD	
ByteSwapper( 
		DWORD	dw 
		) {
/*++

Routine Description : 

	Given a DWORD reorder all the bytes within the DWORD.

Arguments : 

	dw - DWORD to shuffle

Return Value ; 

	Shuffled DWORD

--*/

	WORD	w = LOWORD( dw ) ;
	BYTE	lwlb = LOBYTE( w ) ;
	BYTE	lwhb = HIBYTE( w ) ;

	w = HIWORD( dw ) ;
	BYTE	hwlb = LOBYTE( w ) ;
	BYTE	hwhb = HIBYTE( w ) ;

	return	MAKELONG( MAKEWORD( hwhb, hwlb ), MAKEWORD( lwhb, lwlb )  ) ;
}

ARTICLEID
ArticleIdMapper( 
		ARTICLEID	dw
		)	{
/*++

Routine Description : 

	Given an articleid mess with the id to get something that when
	converted to a string will build nice even B-trees on NTFS file systems.
	At the same time, the function must be easily reversible.
	In fact - 

	ARTICLEID == ArticleMapper( ArticleMapper( ARTICLEID ) ) 

Arguments : 

	articleId - the Article Id to mess with

Return Value : 

	A new article id 

--*/
	return	ByteSwapper( dw ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\hash\src\nntphash.h ===
/*++

  NNTPHASH.H

  Defines the internal types used to implement the NNTP Hash tables !


--*/

#ifndef	_NNTPHASH_H_
#define	_NNTPHASH_H_

#include	"tigtypes.h"
#include	"nntpdrv.h"
#include	"ihash.h"


extern	CCACHEPTR	g_pSharedCache ;

//
// type declarations
//

typedef DWORD HASH_VALUE;
typedef DWORD GROUPID, *PGROUPID;
typedef DWORD ARTICLEID, *PARTICLEID;

#define	INVALID_ARTICLEID	((ARTICLEID)(~0))
const GROUPID NullGroupId = (GROUPID) -1;


//
// manifest constants for hash stuff
//

#define     MAX_MSGID_LEN               255

#define     MAX_XPOST_GROUPS            255

//
// MASK and SIGNATURES
//

#define     DELETE_SIGNATURE            0xCCCC
#define     OFFSET_FLAG_DELETED         0x8000
#define     OFFSET_VALUE_MASK           0x7fff
#define     DEF_HEAD_SIGNATURE          0xdefa1234
#define     CACHE_INFO_SIGNATURE        0xbeef0205
#define     GROUP_LINK_MASK             0x80000000

//
// history map stuff (should be reg settable)
//

#define     DEF_EXPIRE_INTERVAL         (3 * SEC_PER_WEEK) // 1 week
#define     DEF_CRAWLER_WAKEUP_TIME     (30)               // 30 secs
#define     MIN_MAXPAGES_TO_CRAWL       (4)

//
//
// what fraction of total pages to crawl.  1/128 means
// we could cover all the pages in 2 hours.  This is
// expressed in terms of shifts.  7 right shift is 128
//

#define     FRACTION_TO_CRAWL_SHFT      7

//
// Indicates that the space used for this entry has been reclaimed
//

#define     ENTRY_DEL_RECLAIMED         ((WORD)0xffff)

//
// Get pointer given the offset and base
//

#define     GET_ENTRY( _base, _offset ) \
                ((PCHAR)(_base) + (_offset))

//
// See if we need to update the stats in the header page
//

#define     UPDATE_HEADER_STATS( ) { \
            if ( (m_nInsertions + m_nDeletions) >= STAT_FLUSH_THRESHOLD ) { \
                FlushHeaderStats( ); \
            } \
}

//
// Disable auto alignments
//

#ifndef _WIN64		// bugbug
			// Let these get packed by the compiler on WIN64 - this is NOT
			// a good long-term solution because it will make this take up
			// too much space on disk.  We should either reorder the struct
			// for win64 or come up with a way to pack/unpack the data on
			// the way to disk.
#pragma pack(1)
#endif



//
// Page header flags
//

#define PAGE_FLAG_SPLIT_IN_PROGRESS     (WORD)0x0001


//
//
//
// This is the structure of each entry in the leaf pages of the
// MsgId to ArticleID mapping table
//

// flags for article entries
// if the high bit is set then there is a flags word.  otherwise there is

// no flags word and it shouldn't be read
#define		ARTFLAG_FLAGS_EXIST			0x80

// if this is set then there is a storeid
#define 	ARTFLAG_STOREID				0x01

// reserved to say that more flags exist in the future
#define		ARTFLAG_RESERVED			0x40

typedef struct _ART_MAP_ENTRY {
	//
	// if the header offset's high bit is set then these flags are read
	//
	BYTE		Flags;

	//
	//	Offsets into article file - where does the head start ?
	//
	WORD		HeaderOffset ;

	//
	//	Size of the header !
	//
	WORD		HeaderLength ;

    //
    // The primary group of article (where it's actually stored)
    //
    GROUPID     PrimaryGroupId;

    //
    // Article Number in primary group
    //
    ARTICLEID   ArticleId;

    //
    // Length of the message ID (excluding null terminator)
    //
    WORD        MsgIdLen;

    //
    // the message ID goes here when the data is serialized
    //
    CHAR		MsgId[1];

	//
	// the primary store identifier.
	//
	BYTE		cStoreId;
	BYTE		rgbStoreId[256];

	//
	//	Return reference to where the MsgIdLen is stored.
	//
	WORD&		KeyLength()
	{
        return MsgIdLen;
	}

	//
	//	Return pointer to where the MsgId is serialized
	//
	CHAR*		KeyPosition()
	{
        return &MsgId[0];
    }

    //
    // To see if the first byte is the flag, if it's
    // the flag, then we match, otherwise we don't
    //
    BOOL        VersionMatch()
    {
        return ( (Flags & ARTFLAG_FLAGS_EXIST) != 0 );
    }

} ART_MAP_ENTRY, * PART_MAP_ENTRY;

typedef struct MCIS_ART_MAP_ENTRY {

	//
	//	Offsets into article file - where does the head start ?
	//
	WORD		HeaderOffset ;

	//
	//	Size of the header !
	//
	WORD		HeaderLength ;

	//
    // Length of the message ID (excluding null terminator)
    //
    WORD        MsgIdLen;

    //
    // The primary group of article (where it's actually stored)
    //
    GROUPID     PrimaryGroupId;

    //
    // Article Number in primary group
    //
    ARTICLEID   ArticleId;

    //
    // the message ID goes here when the data is serialized
    //
    CHAR		MsgId[1];

	//
	//	Return reference to where the MsgIdLen is stored.
	//
	WORD&		KeyLength()
	{
	        return MsgIdLen;
    }

	//
	//	Return pointer to where the MsgId is serialized
	//
	CHAR*		KeyPosition()
	{
        return &MsgId[0];
	}

	//
	// Check to see if the version matches
	//

	BOOL        VersionMatch()
	{
	    return ( ((*PBYTE(this)) & ARTFLAG_FLAGS_EXIST) == 0 );
	}

} MCIS_ART_MAP_ENTRY, * PMCIS_ART_MAP_ENTRY;

//
//
//
// This is the structure of each entry in the leaf pages of the hash table.
//

typedef struct _HISTORY_MAP_ENTRY {
    //
    // Length of the message ID (excluding null terminator)
    //

    WORD        MsgIdLen;

    //
    // Base file time of the entry.  Used for expiring entry.
    //

    ULARGE_INTEGER  BaseTime;

    //
    // Start of message ID string (null terminated)
    //

    CHAR        MsgId[1];

	//
	//	Return reference to where the MsgIdLen is stored.
	//
	WORD&		KeyLength()	{	return	MsgIdLen ;	}

	//
	//	Return pointer to where the MsgId is serialized
	//
	CHAR*		KeyPosition()	{	return	&MsgId[0] ;	}

	//
	//  We'll always say version match since we don't have backward
	//  compatibility problem
	//

	BOOL        VersionMatch() { return TRUE; }

} HISTORY_MAP_ENTRY, *PHISTORY_MAP_ENTRY;

//
//
//
// This is the structure of each entry in the leaf pages of the hash table.
//

typedef struct _XOVER_MAP_ENTRY {
    //
    // Length of the message ID (excluding null terminator)
    //

    WORD        KeyLen;

    //
    // Time inserted
    //

    FILETIME    FileTime;

	//
	//	Offsets into article file - where does the head start ?
	//
	WORD		HeaderOffset ;

	//
	//	Size of the header !
	//
	WORD		HeaderLength ;

    //
    // Length of xover data
    //

    WORD        XoverDataLen;

    //
    // Additional info about this entry
    //

    BYTE        Flags;

    //
    // Number of xpostings
    //

    BYTE        NumberOfXPostings;

    //
    // Start of variable data
    //

    CHAR        Data[1];

    //
    // Start of xposting list
    //
    //GROUP_ENTRY   XPostings;

    //
    // Start of key (null terminated)
    //
    //
    //CHAR        Key[1];

    //
    // Start of xover data (null terminated)
    //
    //CHAR        XoverData[1];

	WORD&		KeyLength()	{	return	KeyLen ;	}

	CHAR*		KeyPosition(	)	{

		return	Data + NumberOfXPostings*sizeof(GROUP_ENTRY) ;

	}

	BYTE*		XPostingsPosition()	{
		return	(BYTE*)&Data[0] ;
	}

	BYTE*		MessageIDPosition()	{
		return	(BYTE*)(Data + NumberOfXPostings*sizeof(GROUP_ENTRY) + KeyLen) ;
	}

	DWORD		TotalSize()	{
		return	sizeof( _XOVER_MAP_ENTRY ) - 1 + NumberOfXPostings * sizeof( GROUP_ENTRY ) + XoverDataLen + KeyLen ;
	}


} XOVER_MAP_ENTRY, *PXOVER_MAP_ENTRY;


//
// XOVER FLAGS
//

#define XOVER_MAP_PRIMARY       ((BYTE)0x01)
#define	XOVER_IS_NEW			((BYTE)0x02)
#define XOVER_CONTAINS_STOREID	((BYTE)0x04)

//
//
//
// This is the version 2 structure for XOVER_MAP_ENTRY -
//	this structure is used in all released versions
//	of NNTP after K2 Beta3.
//
//	For back compatability - the Flags field must be
//	at the sameoffset as the Flags field in the
//	original XOVER_MAP_ENTRY !
//

typedef struct _XOVER_ENTRY {
	//
	//	This is the GROUPID and ARTICLEID used to look this
	//	entry up in the xover hash table !
	//
	GROUP_ENTRY	Key ;

    //
    // Time inserted
    //
    FILETIME    FileTime;

	//
	//	NOTE
	//
    //
    // Additional info about this entry
    //
    BYTE        Flags;

    //
    // Number of xpostings
    //
    BYTE        NumberOfXPostings;

    //
    // Length of the message ID (excluding null terminator)
    //
    WORD        XoverDataLen;

	//
	//	Offsets into article file - where does the head start ?
	//
	WORD		HeaderOffset ;

	//
	//	Size of the header !
	//
	WORD		HeaderLength ;


    //
    // Start of variable data
    //

    CHAR        Data[1];

    //
    // Start of xposting list
    //
    //GROUP_ENTRY   XPostings;

    //
    // Start of key (null terminated)
    //
    //
    //CHAR        MessageId[1];

	//
	// array of store ids (count is cStoreIds)
	// BYTE		cStoreIds;
	// BYTE		*rgcCrossposts;
	// STOREID	*rgStoreIds;
	//

	BYTE*		XPostingsPosition()	{
		return	(BYTE*)&Data[0] ;
	}

	GROUP_ENTRY*	PrimaryEntry()	{
		_ASSERT( NumberOfXPostings == 1 ) ;
		return	(GROUP_ENTRY*)XPostingsPosition() ;
	}

	BYTE*		MessageIDPosition()	{
		return	(BYTE*)(Data + NumberOfXPostings*sizeof(GROUP_ENTRY)) ;
	}

	BYTE *StoreIdPosition() {
		return MessageIDPosition() + XoverDataLen;
	}

	DWORD		TotalSize()	{
		return	sizeof( _XOVER_ENTRY ) - 1 + NumberOfXPostings * sizeof( GROUP_ENTRY ) + XoverDataLen ;
	}

	BOOL		IsXoverEntry()	{
		return	Flags & XOVER_IS_NEW ;
	}

} XOVER_ENTRY, *PXOVER_ENTRY;


#ifndef _WIN64
#pragma pack()
#endif

#include	"hashmap.h"


template<	class	Key, class OldKey >
class	CMessageIDKey	:	public	IKeyInterface	{
private :

	//
	//	Pointer to a message-id contained within angle brackets '<msg@id>'
	//
	LPSTR	m_lpbMessageID ;

	//
	//	Length of the message-id !
	//
	WORD	m_cbMessageID ;

public :

	//
	//	This constructor is used when we have a key we wish to
	//	serialize !
	//
	CMessageIDKey(	LPSTR	lpbMessageID,
					WORD	cbMessageID
					)	:
		m_lpbMessageID( lpbMessageID ),
		m_cbMessageID( cbMessageID )	{
	}

	//
	//	The public interface required by CHashMap follows
	//

	//
	//	Compute the Hash value of the Key we are holding !
	//
	DWORD	Hash()	const ;

	//
	//	Compare a serialized Message-Id to one that we are holding
	//
	BOOL	CompareKeys(	LPBYTE	pbPtr )	const ;

	//
	//	Determine where the serialized data begins !
	//
	LPBYTE	EntryData(	LPBYTE	pbPtr,
						DWORD&	cbKeyOut
						)	const ;


	//
	//	Save the key into the hash table
	//
	LPBYTE	Serialize(	LPBYTE	pbPtr ) const	;

	//
	//	Restore the key from the hash table
	//
	LPBYTE	Restore(	LPBYTE	pbPtr,
						DWORD&	cbOut
						)	;

	//
	//	Return the size of the key
	//
	DWORD	Size( )	const ;

	//
	//	Verify that the message-id looks legitimate !
	//
	BOOL	Verify( LPBYTE	pbContainer,
					LPBYTE	pbPtr,
					DWORD	cb
					) const ;

} ;


class	CXoverKey : public	IKeyInterface	{
private :

	typedef	XOVER_MAP_ENTRY	Key;

	GROUPID		m_groupid ;
	ARTICLEID	m_articleid ;
	Key*		m_pData ;

	BYTE		m_rgbSerialize[ 40 ] ;
	DWORD		m_cb ;

	CHAR*		SerializeOffset( BYTE *	pb )	const	{
		_ASSERT( m_pData != 0 ) ;
		return	(CHAR*)(m_pData->KeyPosition() - ((CHAR*)m_pData) + (CHAR*)pb) ;
	}

public :

	CXoverKey() ;

	//
	//	This constructor is used when we have a key we wish to
	//	serialize !
	//
	CXoverKey(	GROUPID	groupId,
				ARTICLEID	articleId,
				XOVER_MAP_ENTRY*	data
					)	:
		m_groupid( groupId ),
		m_articleid( articleId ),
		m_pData( data ),
		m_cb( 0 )	{

		m_cb = wsprintf( (char*)m_rgbSerialize, "%lu!%lu", m_groupid, m_articleid);
		m_cb++;
	}

	//
	//	The public interface required by CHashMap follows
	//

	//
	//	Compute the Hash value of the Key we are holding !
	//
	DWORD	Hash()	const ;

	//
	//	Compare a serialized Message-Id to one that we are holding
	//
	BOOL	CompareKeys(	LPBYTE	pbPtr )	const ;

	//
	//	Determine where the serialized data begins !
	//
	LPBYTE	EntryData(	LPBYTE	pbPtr,
						DWORD&	cbKeyOut
						)	const ;


	//
	//	Save the key into the hash table
	//
	LPBYTE	Serialize(	LPBYTE	pbPtr ) const	;

	//
	//	Restore the key from the hash table
	//
	LPBYTE	Restore(	LPBYTE	pbPtr,
						DWORD&	cbOut
						)	;

	//
	//	Return the size of the key
	//
	DWORD	Size( )	const ;

	//
	//	Verify that the message-id looks legitimate !
	//
	BOOL	Verify( LPBYTE	pbContainer,
					LPBYTE	pbPtr,
					DWORD	cb
					) const ;

	//
	//	Placement operator new - let us construct this thing in place !
	//
	void*
	operator	new(	size_t	size,
						LPBYTE	lpb
						) {
		return	lpb ;
	}

} ;

class	CXoverKeyNew :	public	IKeyInterface	{

	BYTE			m_rgbBackLevel[ (sizeof( CXoverKey ) + 16) ] ;

	CXoverKey*		m_pBackLevelKey ;

	class	CXoverKey*
	GetBackLevel()	const	{
		if( m_pBackLevelKey == 0 ) {
			(CXoverKey*)m_pBackLevelKey =
				new( (LPBYTE)m_rgbBackLevel )	CXoverKey(	m_key.GroupId,
															m_key.ArticleId,
															0
															) ;
		}
		return	m_pBackLevelKey ;
	}

public :

	//
	//	Public expose this for people who are using this object
	//	to extract info from the hash tables (i.e. GetNextNovEntry())
	//
	GROUP_ENTRY		m_key ;

	CXoverKeyNew() :
		m_pBackLevelKey( 0 )	{
		m_key.GroupId = INVALID_GROUPID ;
		m_key.ArticleId = INVALID_ARTICLEID ;
	}

	CXoverKeyNew(	GROUPID		group,
					ARTICLEID	article,
					LPVOID		lpvBogus
					)	:
		m_pBackLevelKey( 0 ) {
		m_key.GroupId = group ;
		m_key.ArticleId = article ;
	}

	//
	//	Compute the Hash Value of the key we are holding
	//
	DWORD
	Hash()	const ;

	//
	//	Compare our key to one serialized in the file !
	//
	BOOL
	CompareKeys(	LPBYTE	pbPtr	)	const	{
		PXOVER_ENTRY	px = (PXOVER_ENTRY)pbPtr ;
		if( px->IsXoverEntry() ) {
			return	memcmp( pbPtr, &m_key, sizeof( m_key ) ) == 0 ;
		}
		return	GetBackLevel()->CompareKeys( pbPtr ) ;
	}

	//
	//	Determine where the serialized data begins !
	//
	LPBYTE
	EntryData(	LPBYTE	pbPtr,
				DWORD&	cbKeyOut
				)	const	{
		PXOVER_ENTRY	px = (PXOVER_ENTRY)pbPtr ;
		if( px->IsXoverEntry() )	{
			cbKeyOut = sizeof( m_key ) ;
			return	pbPtr ;
		}
		LPBYTE	lpbReturn = GetBackLevel()->EntryData( pbPtr, cbKeyOut ) ;
		_ASSERT( lpbReturn == pbPtr ) ;
		return	lpbReturn ;
	}

	//
	//	Save the key into the hash table !
	//
	LPBYTE
	Serialize( LPBYTE	pbPtr )		const	{
		PGROUP_ENTRY	pgroup = (PGROUP_ENTRY)pbPtr ;
		*pgroup = m_key ;
		return	pbPtr ;
	}

	//
	//	Restore the key into the hash table !
	//
	LPBYTE
	Restore(	LPBYTE	pbPtr,
				DWORD&	cbOut
				)	{
		PXOVER_ENTRY	px = (PXOVER_ENTRY)pbPtr ;
		if( px->IsXoverEntry() ) {
			m_key = px->Key ;
			cbOut = sizeof( m_key ) ;
			return	pbPtr ;
		}
		return	GetBackLevel()->Restore( pbPtr, cbOut ) ;
	}

	//
	//	Return the size of the key !
	//
	DWORD
	Size()	const	{
		return	sizeof( m_key ) ;
	}

	//
	//	Verify that everything looks legit !
	//
	BOOL
	Verify(	LPBYTE	pbContainer,
			LPBYTE	pbPtr,
			DWORD	cb
			)	const	{
		return	TRUE ;
	}
} ;

class	CXoverData : public	ISerialize	{
/*++

This class deals with XOVER entries in the hash tables as they were formatted in
MCIS 2.0, K2 and NT5 Beta 2.  This class should no longer be used to save
XOVER entries into the hash tables, but only to extract the back level entries
that may remain after upgrade scenarios.

--*/
public :

	XOVER_MAP_ENTRY		m_data ;

	DWORD				m_cGroups ;
	GROUP_ENTRY*		m_pGroups ;

	DWORD				m_cbMessageId ;
	LPSTR				m_pchMessageId ;

	CHAR				m_rgbPrimaryBuff[40] ;
	DWORD				m_cb ;
	BOOL				m_fSufficientBuffer ;

	GROUPID				m_PrimaryGroup ;
	ARTICLEID			m_PrimaryArticle ;
	IExtractObject*		m_pExtractor ;

	//
	//	How do we report failures to Unserialize a buffer -
	//	if this is TRUE then if we cannot hold all the serialized data
	//	that we are getting through a Restore operation, we return
	//	NULL from our Restore() API, otherwise we return a NON-NULL
	//	value, which lets hashmap think we succeeded, but capture
	//	in our internal state data to let us figure out how to retry
	//	and grow buffers to successfully restore the whole item.
	//
	//	We need to distinguish this case when we are doing enumerations !
	//
	BOOL			m_fFailRestore ;


	CXoverData() :
		m_cGroups( 0 ),
		m_pGroups( 0 ),
		m_cbMessageId( 0 ),
		m_pchMessageId( 0 ),
		m_cb( 0 ),
		m_fSufficientBuffer( FALSE ),
		m_pExtractor( 0 )	{

		m_rgbPrimaryBuff[0] = '\0' ;
		ZeroMemory( &m_data, sizeof( m_data ) ) ;
	}


	CXoverData(
			FILETIME		FileTime,
			WORD			HeaderOffset,
			WORD			HeaderLength,
			BYTE			NumberOfXPostings = 0,
			GROUP_ENTRY*	pXPosts = 0,
			DWORD			cbMessageId = 0,
			LPSTR			lpstrMessageId = 0
			) :
		m_cGroups( NumberOfXPostings ),
		m_pGroups( pXPosts ),
		m_cbMessageId( cbMessageId ),
		m_pchMessageId( lpstrMessageId ),
		m_cb( 0 ),
		m_fSufficientBuffer( FALSE ),
		m_pExtractor( 0 )	{

		m_rgbPrimaryBuff[0] = '\0' ;

		m_data.FileTime = FileTime ;
		m_data.HeaderOffset = HeaderOffset ;
		m_data.HeaderLength = HeaderLength ;
		m_data.Flags = XOVER_MAP_PRIMARY ;
		m_data.NumberOfXPostings = NumberOfXPostings ;
		m_data.XoverDataLen = (WORD)cbMessageId ;

	}

	CXoverData(
			FILETIME		FileTime,
			WORD			HeaderOffset,
			WORD			HeaderLength,
			GROUPID			PrimaryGroup,
			ARTICLEID		PrimaryArticle
			)	:
		m_fSufficientBuffer( FALSE ),
		m_pGroups( 0 ),
		m_cGroups( 0 ),
		m_pExtractor( 0 )	{

		m_data.FileTime = FileTime ;
		m_data.HeaderOffset = HeaderOffset ;
		m_data.HeaderLength = HeaderLength ;
		m_data.Flags = 0 ;
		m_data.NumberOfXPostings = 0 ;
		m_data.XoverDataLen = 0 ;

		m_cb = wsprintf( (char*)m_rgbPrimaryBuff, "%lu!%lu", PrimaryGroup, PrimaryArticle ) ;
		m_cb++ ;

		m_data.XoverDataLen = WORD(m_cb) ;
		m_pchMessageId = m_rgbPrimaryBuff ;
		m_cbMessageId = m_cb ;
	}

	//
	//	Save the data into the XOVER hash table !
	//
	LPBYTE
	Serialize(	LPBYTE	pbPtr )	const ;

	//
	//	Restore selected portions of the entry !
	//
	LPBYTE
	Restore(	LPBYTE	pbPtr,
				DWORD&	cbOut	) ;

	//
	//	Return the size required !
	//
	DWORD
	Size()	const ;

	BOOL
	Verify(	LPBYTE	pbContainer,
			LPBYTE	pbPtr,
			DWORD	cb )	const	{

		return	TRUE ;
	}

	//
	//	Placement operator new - let us construct this thing in place !
	//
	void*
	operator	new(	size_t	size,
						LPBYTE	lpb
						) {
		return	lpb ;
	}



} ;

//
//	This class is for reading existing and new format Xover entries !
//
class	CXoverDataNew:	public	ISerialize	{
/*++

This class deals with XOVER entries in the hash tables as they exist in
NT5 Beta3 and NT5 RTM releases.

--*/

	BYTE			m_rgbBackLevel[ (sizeof( CXoverData ) + 16) ] ;

	class	CXoverData*	m_pBackLevelData ;

	class	CXoverData*
	GetBackLevel()	const	{
		if( m_pBackLevelData == 0 ) {
			(CXoverData*)m_pBackLevelData =
				new( (LPBYTE)m_rgbBackLevel )	CXoverData(	) ;
		}
		return	m_pBackLevelData ;
	}

public :

	//
	//	This field gets a copy of the entire fixed portion of the entry !
	//
	XOVER_ENTRY		m_data ;

	//
	//	Fields that get the primary group info !
	//
	GROUPID			m_PrimaryGroup ;
	ARTICLEID		m_PrimaryArticle ;

	//
	//	Points to a buffer to receive the internet Message Id
	//
	LPSTR			m_pchMessageId ;
	DWORD			m_cbMessageId ;

	//
	//	Points to a buffer to get the Cross Posted Information !
	//
	DWORD			m_cGroups ;
	GROUP_ENTRY*	m_pGroups ;

	//
	//	How do we report failures to Unserialize a buffer -
	//	if this is TRUE then if we cannot hold all the serialized data
	//	that we are getting through a Restore operation, we return
	//	NULL from our Restore() API, otherwise we return a NON-NULL
	//	value, which lets hashmap think we succeeded, but capture
	//	in our internal state data to let us figure out how to retry
	//	and grow buffers to successfully restore the whole item.
	//
	//	We need to distinguish this case when we are doing enumerations !
	//
	BOOL			m_fFailRestore ;

	//
	//	Was there enough room to recover all the data we wanted !
	//
	BOOL			m_fSufficientBuffer ;

	//
	//	Variable the recovers the size of the extract Message Id !
	//
	DWORD			m_cb ;

	//
	//	Object which massages results during extraction of XOVER entries !
	//
	IExtractObject*		m_pExtractor ;

	//
	// storeid information
	//
	// length of m_pStoreIds.  in restore only this number of entries will
	// be restored into m_pStoreIds.
	DWORD			m_cStoreIds;
	// array of store ids
	CStoreId		*m_pStoreIds;
	// array of count of crossposts per store id
	BYTE			*m_pcCrossposts;
	// number of store ids in the entry
	DWORD			m_cEntryStoreIds;

	//
	//
	//
	//
	CXoverDataNew(
			LPSTR	lpbMessageId,
			DWORD	cbMessageId,
			GROUP_ENTRY*	pGroups,
			DWORD	cGroups,
			IExtractObject*	pExtractor = 0,
			DWORD	cStoreIds = 0,
			CStoreId *pStoreIds = NULL,
			BYTE	*pcCrossposts = NULL
			)	:
		m_fFailRestore( FALSE ),
		m_pBackLevelData( 0 ),
		m_PrimaryGroup( INVALID_GROUPID ),
		m_PrimaryArticle( INVALID_ARTICLEID ),
		m_pchMessageId( lpbMessageId ),
		m_cbMessageId( cbMessageId ),
		m_pGroups( pGroups ),
		m_cGroups( cGroups ),
		m_fSufficientBuffer( FALSE ),
		m_cb( 0 ),
		m_pExtractor( pExtractor )	,
		m_cStoreIds(cStoreIds),
		m_pStoreIds(pStoreIds),
		m_pcCrossposts(pcCrossposts)
	{
	}


	CXoverDataNew(
			FILETIME		FileTime,
			WORD			HeaderOffset,
			WORD			HeaderLength,
			BYTE			NumberOfXPostings = 0,
			GROUP_ENTRY*	pXPosts = 0,
			DWORD			cbMessageId = 0,
			LPSTR			lpstrMessageId = 0  ,
			DWORD			cStoreIds = 0,
			CStoreId		*pStoreIds = NULL,
			BYTE			*pcCrossposts = NULL
			) :
		m_fFailRestore( FALSE ),
		m_pBackLevelData( 0 ),
		m_PrimaryGroup( INVALID_GROUPID ),
		m_PrimaryArticle( INVALID_ARTICLEID ),
		m_cGroups( NumberOfXPostings ),
		m_pGroups( pXPosts ),
		m_cbMessageId( cbMessageId ),
		m_pchMessageId( lpstrMessageId ),
		m_fSufficientBuffer( FALSE ),
		m_cb( 0 ),
		m_pExtractor( 0 ),
		m_cStoreIds(cStoreIds),
		m_pStoreIds(pStoreIds),
		m_pcCrossposts(pcCrossposts)
	{

		m_data.FileTime = FileTime ;
		m_data.HeaderOffset = HeaderOffset ;
		m_data.HeaderLength = HeaderLength ;
		m_data.Flags = XOVER_MAP_PRIMARY | XOVER_IS_NEW ;
		m_data.NumberOfXPostings = NumberOfXPostings ;
		m_data.XoverDataLen = (WORD)cbMessageId ;
		if (m_cStoreIds > 0) m_data.Flags |= XOVER_CONTAINS_STOREID;

		_ASSERT( m_data.XoverDataLen == m_cbMessageId ) ;

	}

	CXoverDataNew(
			FILETIME		FileTime,
			WORD			HeaderOffset,
			WORD			HeaderLength,
			GROUPID			PrimaryGroup,
			ARTICLEID		PrimaryArticle
			)	:
		m_fFailRestore( FALSE ),
		m_pBackLevelData( 0 ),
		m_PrimaryGroup( PrimaryGroup ),
		m_PrimaryArticle( PrimaryArticle ),
		m_pGroups( 0 ),
		m_cGroups( 0 ),
		m_cbMessageId( 0 ),
		m_pchMessageId( 0 ),
		m_fSufficientBuffer( FALSE ),
		m_cb( 0 ),
		m_pExtractor( 0 ),
		m_cStoreIds(0),
		m_pStoreIds(NULL),
		m_pcCrossposts(NULL)
	{

		m_data.FileTime = FileTime ;
		m_data.HeaderOffset = HeaderOffset ;
		m_data.HeaderLength = HeaderLength ;
		m_data.Flags = XOVER_IS_NEW  ;
		m_data.NumberOfXPostings = 1 ;
		m_data.XoverDataLen = 0 ;

	}


	//
	//	This constructor is used when we are building a
	//	CXoverDataNew object which we will use to retrieve
	//	Xover Data !
	//
	CXoverDataNew()	:
		m_pBackLevelData( 0 ),
		m_PrimaryGroup( INVALID_GROUPID ),
		m_PrimaryArticle( INVALID_ARTICLEID ),
		m_pGroups( 0 ),
		m_cGroups( 0 ),
		m_pchMessageId( 0 ),
		m_cbMessageId( 0 ),
		m_fSufficientBuffer( FALSE ),
		m_cb( 0 ),
		m_pExtractor( 0 ),
		m_cStoreIds(0),
		m_pStoreIds(NULL),
		m_pcCrossposts(NULL)
	{
	}

	//
	//	Save the data into the XOVER hash table -
	//	this should not be called this class is for extraction ONLY !
	//
	LPBYTE
	Serialize(	LPBYTE	pbPtr )	const ;


	//
	//	Restore selected portions of the entry !
	//
	LPBYTE
	Restore(	LPBYTE	pbPtr,
				DWORD&	cbOut	) ;

	//
	//	Return the size required - should not be
	//	called - this class supports Restore() only !
	//
	DWORD
	Size()	const ;


	//
	//	Verify that the entry looks good !
	//
	BOOL
	Verify(	LPBYTE	pbContainer,
			LPBYTE	pbPtr,
			DWORD	cb )	const	{

		return	TRUE ;
	}

	void CheckStoreIds(void);

} ;




class	CArticleData	:	public	ISerialize	{
public :
	ART_MAP_ENTRY	m_articleData;

	CArticleData() {
		ZeroMemory( &m_articleData, sizeof( m_articleData ) ) ;
	}

	CArticleData(
			WORD		HeaderOffset,
			WORD		HeaderLength,
			GROUPID		PrimaryGroup,
			ARTICLEID	ArticleNo,
			CStoreId	&storeid
			);

	//
	//	Save the key into the hash table
	//
	LPBYTE Serialize(LPBYTE pbPtr) const;

	//
	//	Restore the key from the hash table
	//
	LPBYTE Restore(LPBYTE pbPtr, DWORD& cbOut);

	//
	//	Return the size of the key
	//
	DWORD Size() const;

	//
	//	Verify that the message-id looks legitimate !
	//
	BOOL Verify(LPBYTE pbContainer, LPBYTE pbPtr, DWORD cb) const;

private:

    //
    // Restoring an MCIS entry
    //

    LPBYTE RestoreMCIS(LPBYTE pbPtr, DWORD& cbOut );
};


class	CHistoryData	:	public	ISerialize	{
public :

	HISTORY_MAP_ENTRY	m_historyData ;

	CHistoryData(
			ULARGE_INTEGER	BaseTime
			)	{

		m_historyData.BaseTime = BaseTime ;
	}


	//
	//	Save the key into the hash table
	//
	LPBYTE	Serialize(	LPBYTE	pbPtr ) const	{

		HISTORY_MAP_ENTRY*	pSerialize = (HISTORY_MAP_ENTRY*)pbPtr ;

		pSerialize->BaseTime = m_historyData.BaseTime ;

		return	(BYTE*)pSerialize->KeyPosition() + pSerialize->KeyLength() ;

	}

	//
	//	Restore the key from the hash table
	//
	LPBYTE	Restore(	LPBYTE	pbPtr,
						DWORD&	cbOut
						)	{
		cbOut = sizeof( m_historyData ) ;
		CopyMemory(	&m_historyData, pbPtr, cbOut ) ;
		return	pbPtr + cbOut ;
	}

	//
	//	Return the size of the key
	//
	DWORD	Size( )	const	{
		return	sizeof( m_historyData ) - sizeof( m_historyData.MsgId ) ;
	}

	//
	//	Verify that the message-id looks legitimate !
	//
	BOOL	Verify( LPBYTE	pbContainer,
					LPBYTE	pbPtr,
					DWORD	cb
					) const		{
		return	TRUE ;
	}
} ;


class	CMsgArtMapImp : public	CMsgArtMap,	private	CHashMap	{
public :

	CMsgArtMapImp() ;

	//
	//	Destroy a CMsgArtMap object
	//
	~CMsgArtMapImp() ;

	BOOL
	DeleteMapEntry(
			LPCSTR	MessageID
			) ;

	//
	//	Delete a an entry in the hash table using the MessageID key
	//
	BOOL
	GetEntryArticleId(
			LPCSTR	MessageID,
			WORD&	HeaderOffset,
			WORD&	HeaderLength,
			ARTICLEID&	ArticleId,
			GROUPID&	GroupId,
			CStoreId	&storeid
			) ;

	//
	//	Get all the info we have on a Message ID
	//
	BOOL
	Initialize(
			LPSTR	lpstrArticleFile,
			HASH_FAILURE_PFN	pfn,
			BOOL	fNoBuffering = FALSE
			) ;

	//
	//	Insert an entry into the hash table
	//
	BOOL
	InsertMapEntry(
			LPCSTR		MessageID,
			WORD		HeaderOffset,
			WORD		HeaderLength,
			GROUPID		PrimaryGroup,
			ARTICLEID	ArticleID,
			CStoreId	&storeid
			) ;

	//
	//	Modify an existing entry in the hash ttable
	//
	BOOL
	SetArticleNumber(
			LPCSTR		MessageID,
			WORD		HeaderOffset,
			WORD		HeaderLength,
			GROUPID		Group,
			ARTICLEID	ArticleId,
			CStoreId	&storeid = g_storeidDefault
			);

	//
	//	Check to see if a MessageID is present in the system !
	//
	BOOL
	SearchMapEntry(
			LPCSTR	MessageID
			) ;

	//
	//	Terminate everything
	//
	void
	Shutdown(
			BOOL	fLocksHeld
			) ;

	//
	//	return the number of entries in the hash table
	//
	DWORD
	GetEntryCount() ;

	//
	//	This creates an object conforming to this interface !
	//
	BOOL
	IsActive() ;

} ;

class	CHistoryList	{
public :
	CHistoryList*	m_pNext ;
	CHistoryList*	m_pPrev ;
	CHistoryList()	:
		m_pNext( 0 ), m_pPrev( 0 ) {    m_pNext = this ; m_pPrev = this ; }

	virtual	void
	Expire() {}

} ;

class	CHistoryImp	:	public	CHistory,
						public	CHistoryList,
						private	CHashMap	{
private :

	//
	//	Handle of the thread which expires entries
	//
	static	HANDLE	g_hCrawler ;

	//
	//	Amount of time the crawler thread should sleep between iterations
	//
	static	DWORD	g_crawlerSleepTimeInSec ;

	//
	//	Handle used to stop crawler thread
	//
	static	HANDLE	g_hTermination ;

	//
	//	Critical section which protects doubly linked list
	//	of History Hash Tables
	//
	static	CRITICAL_SECTION	g_listcrit ;

	//
	//	Head of the doubly linked list of history hash tables !
	//
	static	CHistoryList	g_listhead ;

	//
	//	The thread which crawls over history tables doing stuff !
	//
	static	DWORD	WINAPI
	CrawlerThread(	LPVOID	) ;

	//
	//	How long entries last in seconds !
	//
	DWORD	m_expireTimeInSec ;

	//
	//	Number of pages to crawl with each iteration
	//
	DWORD	m_maxEntriesToCrawl ;

	//
	//	if TRUE then we should be expiring entries in this table !
	//
	BOOL	m_fExpire ;

	//
	//	The context we use to walk through expiring stuff !
	//
	CHashWalkContext	m_ExpireContext ;

	//
	//	This bool is used to determine if the m_ExpireContext has been initializsed !
	//
	BOOL	m_fContextInitialized ;

	//
	//	function which expires entries from the history table !
	//
	void
	Expire() ;

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a delete
    //
    VOID I_DoAuxInsertEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD EntryOffset
                    ) ;

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a delete
    //
    VOID I_DoAuxDeleteEntry(
                    IN PMAP_PAGE MapPage,
                    IN DWORD EntryOffset
                    ) ;

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a page split
    //
    VOID I_DoAuxPageSplit(
                    IN PMAP_PAGE OldPage,
                    IN PMAP_PAGE NewPage,
                    IN PVOID NewEntry
                    ) ;




public:

	//
	//	This function initializes all of our globals !
	//
	static	BOOL
	Init() ;

	//
	//	This function terminates all of our globals !
	//
	static	BOOL
	Term() ;

	//
	//	This function creates the threads which expire
	//	entries out of all the history tables which may
	//	be created !
	//
	static	BOOL
	StartExpirationThreads(	DWORD	CrawlerSleepTime) ;

	//
	//	This function terminates the threads which expire
	//	entries out of all the history tables which may be
	//	created.
	//
	static	BOOL
	TermExpirationThreads() ;

	//
	//	Construct one of our objects
	//
	CHistoryImp() ;

	//
	//	Destroy the History table
	//
	virtual	~CHistoryImp() ;

	//
	//	amount of time entries last in the history table
	//
	virtual	DWORD
	ExpireTimeInSec() ;


	//
	//	Delete a MessageID from this table
	//
	virtual	BOOL
	DeleteMapEntry(
			LPSTR	MessageID
			) ;

	//
	//	Initialize the Hash table
	//
	virtual	BOOL
	Initialize(
			LPSTR	lpstrArticleFile,
			BOOL	fCreateExpirationThread,
			HASH_FAILURE_PFN	pfn,
			DWORD	ExpireTimeInSec,
			DWORD	MaxEntriesToCrawl,
			BOOL	fNoBuffering = FALSE
			) ;

	//
	//	Insert an entry into the hash table
	//
	virtual	BOOL
	InsertMapEntry(
			LPCSTR	MessageID,
			PFILETIME	BaseTime
			) ;

	//
	//	Check for the presence of a Message ID in the history table
	//
	virtual	BOOL
	SearchMapEntry(
			LPCSTR	MessageID
			) ;

	//
	//	Shutdown the hash table
	//
	virtual	void
	Shutdown(
			BOOL	fLocksHeld
			) ;

	//
	//	Return the number of entries in the hash table
	//
	virtual	DWORD
	GetEntryCount() ;

	//
	//	Is the hash table initialized and functional ?
	//
	virtual	BOOL
	IsActive() ;
} ;


class	CXoverMapIteratorImp : public	CXoverMapIterator	{
private :
	//
	//	No copying allowed !
	//
	CXoverMapIteratorImp( CXoverMapIteratorImp& ) ;
	CXoverMapIteratorImp&	operator=( CXoverMapIteratorImp ) ;

protected :
	//
	//	CXoverMapImp is our friend, and does all of our
	//	creation etc... !
	//
	friend class	CXoverMapImp ;
	//
	//	This keeps track of our location in the base table !
	//
	CHashWalkContext	m_IteratorContext ;

	//
	//	All member's protected, since you can only use us indirectly
	//	through GetFirstNovEntry, GetNextNovEntry()
	//
	CXoverMapIteratorImp()	{}

}  ;


//
//	Specify the interface used to access data in the XOVER hash table
//
//
class	CXoverMapImp : public	CXoverMap, private	CHashMap	{
public :

	//
	//	Destructor is virtual because most work done in a derived class
	//
	~CXoverMapImp() ;

	//
	//	Create an entry for the primary article
	//
	virtual	BOOL
	CreatePrimaryNovEntry(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			WORD		HeaderOffset,
			WORD		HeaderLength,
			PFILETIME	FileTime,
			LPCSTR		szMessageId,
			DWORD		cbMessageId,
			DWORD		cEntries,
			GROUP_ENTRY	*pEntries,
			DWORD		cStoreIds,
			CStoreId	*pStoreIds,
			BYTE		*pcCrossposts
			) ;


	//
	//	Create a Cross Posting entry that references the
	//	specified primary entry !
	//
	virtual	BOOL
	CreateXPostNovEntry(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			WORD		HeaderOffset,
			WORD		HeaderLength,
			PFILETIME	FileTime,
			GROUPID		PrimaryGroupId,
			ARTICLEID	PrimaryArticleId
			) ;

	//
	//	Delete an entry from the hash table!
	//
	virtual	BOOL
	DeleteNovEntry(
			GROUPID		GroupId,
			ARTICLEID	ArticleId
			) ;

	//
	//	Get all the information stored about an entry
	//
	virtual	BOOL
	ExtractNovEntryInfo(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			BOOL		&fPrimary,
			WORD		&HeaderOffset,
			WORD		&HeaderLength,
			PFILETIME	FileTime,
			DWORD		&DataLen,
			PCHAR		MessageId,
			DWORD 		&cStoreEntries,
			CStoreId	*pStoreIds,
			BYTE		*pcCrossposts,
			IExtractObject*	pExtract = 0
			) ;

	//
	//	Get the primary article and the message-id if necessary
	//
	virtual	BOOL
	GetPrimaryArticle(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			GROUPID&	GroupIdPrimary,
			ARTICLEID&	ArticleIdPrimary,
			DWORD		cbBuffer,
			PCHAR		MessageId,
			DWORD&		DataLen,
			WORD&		HeaderOffset,
			WORD&		HeaderLength,
			CStoreId	&storeid
			) ;

	//
	//	Check to see whether the specified entry exists -
	//	don't care about its contents !
	//
	virtual	BOOL
	Contains(
			GROUPID		GroupId,
			ARTICLEID	ArticleId
			) ;

	//
	//	Get all the cross-posting information related to an article !
	//
	virtual	BOOL
	GetArticleXPosts(
			GROUPID		GroupId,
			ARTICLEID	AritlceId,
			BOOL		PrimaryOnly,
			PGROUP_ENTRY	GroupList,
			DWORD		&GroupListSize,
			DWORD		&NumberOfGroups,
			PBYTE		rgcCrossposts = NULL
			) ;

	//
	//	Initialize the hash table
	//
	virtual	BOOL
	Initialize(
			LPSTR		lpstrXoverFile,
			HASH_FAILURE_PFN	pfnHint,
			BOOL	fNoBuffering = FALSE
			) ;

	virtual	BOOL
	SearchNovEntry(
			GROUPID		GroupId,
			ARTICLEID	ArticleId,
			PCHAR		XoverData,
			PDWORD		DataLen,
            BOOL        fDeleteOrphans = FALSE
			) ;

	//
	//	Signal the hash table to shutdown
	//
	virtual	void
	Shutdown( ) ;

	//
	//	Return the number of entries in the hash table !
	//
	virtual	DWORD
	GetEntryCount() ;

	//
	//	Returns TRUE if the hash table is successfully
	//	initialized and ready to do interesting stuff !!!
	//
	virtual	BOOL
	IsActive() ;

	BOOL
	GetFirstNovEntry(
				OUT	CXoverMapIterator*	&pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer,
				OUT	PCHAR	MessageId,
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				) ;


	BOOL
	GetNextNovEntry(
				OUT	CXoverMapIterator*	pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer,
				OUT	PCHAR	MessageId,
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				) ;


} ;




#endif	// _NNTPHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\mapfile\mapfile.cpp ===
/* ------------------------------------------------------------------------
  mapfile.cpp
     (was bbmpfile.cpp)
  	A wrapper function to perform the cook book type operations required
  	to map a file into memory.  Maps the whole file, and nothing but the
  	file, so help me God.  Returns a pointer to void;  NULL on error.
  	An error also results in an entry in the event log, unless the error
  	is "file not found" during CreateFile().

  Copyright (C)  1994, 1995  Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

   ------------------------------------------------------------------------ */

#include <windows.h>
#include <randfail.h>
#include "mapfile.h"

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for unicode mapping.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:11 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, to support tracking of objects in exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack )
{

    HANDLE   hFile;				// Ditto.

	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;			// Until later.

    hFile = CreateFileW( pwchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;				// Default values are failure.
    }
    wcsncpy( m_rgwchFileName, pwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, 0 );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for ascii file name version.

  Author
  	Lindsay Harris	- lindsayh

  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
    HANDLE   hFile;				// Ditto.

	//    Set default values corresponding to no mapping happened.
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.

    hFile = CreateFile( pchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
		   && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile.
  	Constructor for ascii file name version.

  Note: Creates file handle if necessary. Does not close file handle.

  Author
  	Lindsay Harris	- lindsayh


  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease )
{
	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.

	if ( INVALID_HANDLE_VALUE == hFile )
	{
		hFile = CreateFile( pchFileName,
					 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
					 FILE_SHARE_READ, NULL, OPEN_EXISTING,
					 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

		if ( INVALID_HANDLE_VALUE == hFile )
		{
			//  Only legitimate reason for coming here is non-existent file.
            //
			if (  GetLastError() != ERROR_FILE_NOT_FOUND
               && GetLastError() != ERROR_PATH_NOT_FOUND )
			{
				// Error case
                //
				m_pv = NULL;
			}
			return;
		}
	}

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	return;
}

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease, BOOL fZero )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease, fZero );

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::~CMapFile
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFile::~CMapFile( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pv )
		{
			UnmapViewOfFile( m_pv );
		}
	}
	return;
}



/* ------------------------------------------------------------------------
  CMapFile::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFile::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease, BOOL fZero )
{

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.
	}

#if 1
    if ( cbIncrease )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbNewSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }
#endif

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( hFile, NULL,
                                 fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, cbNewSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pv = MapViewOfFile( hFileMap,
                                 fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !m_pv )
	{
        // Error case
        //
		m_pv = NULL;
		m_cb = 0;			// Also set to zero, just in case.

	}

	if( fZero && cbIncrease )
	{
		// zero out the part grown
		DWORD cbOldSize = cbNewSize - cbIncrease;
		ZeroMemory( (LPVOID)((LPBYTE)m_pv + cbOldSize), cbNewSize - cbOldSize );
	}

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );
	

    return;

}




/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:21 on Mon 20 Feb 1995    -by-    Lindsay Harris   [lindsayh]
  	Amended to use unicode file name.

	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  WCHAR  *pwchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//
    VOID    *pvRet;				// Returned to caller
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFileW( pwchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
		    // Error case
    	}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  char  *pchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//

    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
		}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return  pvRet;

}



/* -------------------------------------------------------------------------
  pvFromHandle
  	Creates a mapped file from an file handle. Does not close that handle.

  History

  	21 Dec 1994 	-by-	Carl Kadie		 [carlk]
	Based on pvMapFile code by Lindsay Harris   [lindsayh]

   ------------------------------------------------------------------------- */

void *
pvFromHandle( HANDLE hFile,
              BOOL bWriteEnable,        // If the file is to be writeable
              DWORD  * pdwSizeFinal,    // If not Null, returns the final size of the file
              DWORD dwSizeIncrease )    // Use 0 if the size is not to increase
{
	DWORD dwSize;
    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;


	dwSize = GetFileSize( hFile, NULL ) + dwSizeIncrease;
    if ( pdwSizeFinal )
	{
		*pdwSizeFinal = dwSize;
	}

	// If the ultimate size of the file is 0, then return NULL. The
	// calling program may decide that this is OK.
    //
	if ( !dwSize)
	{
		return NULL;
	}

#if 1
    if ( dwSizeIncrease )
    {
        _ASSERT(bWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == (fpos = SetFilePointer( hFile, dwSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            BOOL fClose = CloseHandle( hFile );           // No handle leaks.
            return NULL;
        }
    }
#endif

    //
    // Create the mapping object.
    //								
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, dwSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		//  Log the error,  but continue, which returns the error.
        //
#if 0
		char	rgchErr[ MAX_PATH + 32 ];
		wsprintf( rgchErr, "MapViewOfFile" );
		LogErrorEvent( MSG_GEN_FAIL, rgchErr, "pvFromHandle" );
#endif
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //

    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose ) ;

	return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.
	Also, allows the file to be grown.

  History

  	11:08 on Tue 18 Oct 1994	-by-	Carl Kadie		 [carlk]
	Generalize pvMapFile to add support for adding to the file

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile(	const char  * pchFileName,		// The name of the file
			BOOL bWriteEnable,		// If the file is to be writeable
 			DWORD  * pdwSizeFinal, // If not Null, returns the final size of the file
			DWORD dwSizeIncrease )     // Use 0 if the size is not to increase
{
	//
	// Cook book formula.
	//
    HANDLE   hFile;
    VOID    *pvRet;				/* Returned to caller */
	
	// If the file is to grow, it only makes sense to open it read/write.
    //
	if (0 != dwSizeIncrease && !bWriteEnable)
	{
		return NULL;
	}

    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_ALWAYS,  //changed from open_existing
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        return  NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
	pvRet = pvFromHandle(hFile, bWriteEnable, pdwSizeFinal, dwSizeIncrease);

	BOOL fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

    return  pvRet;
}

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

/* ------------------------------------------------------------------------
  CMapFileEx::CMapFileEx
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFileEx::CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
	m_hFile = INVALID_HANDLE_VALUE;
	m_pvFrontGuard = NULL;
	m_cbFrontGuardSize = 0;
	m_pvRearGuard = NULL;
	m_cbRearGuardSize = 0;
	InitializeCriticalSection(&m_csProtectMap);

	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	m_hFile = hFile;

	return;
}


/* ------------------------------------------------------------------------
  CMapFileEx::~CMapFileEx
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFileEx::~CMapFileEx( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//

	//   Lock
	EnterCriticalSection(&m_csProtectMap);

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pvFrontGuard )
		{
			_ASSERT( m_pvFrontGuard && m_pv && m_pvRearGuard );
			_ASSERT( m_cbFrontGuardSize && m_cb && m_cbRearGuardSize );

			// get rid of guard pages
			DWORD dwOldProtect = PAGE_READONLY | PAGE_GUARD;
			if(!VirtualProtect(
						(LPVOID)m_pvFrontGuard,
						m_cbFrontGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pv,
						m_cb,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pvRearGuard,
						m_cbRearGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1== 0 );
				goto CMapFileEx_Exit ;
			}

			MoveMemory( m_pvFrontGuard, m_pv, m_cb );

			FlushViewOfFile( m_pvFrontGuard, m_cb ) ;

			UnmapViewOfFile( (LPVOID)m_pvFrontGuard );

			if( INVALID_HANDLE_VALUE != m_hFile )
			{
				if( SetFilePointer( m_hFile, m_cb, NULL, FILE_BEGIN ) == m_cb ) 
				{
					SetEndOfFile( m_hFile ) ;
				}
			}

			m_pvFrontGuard = m_pvRearGuard = m_pv = NULL ;
			m_cbFrontGuardSize = m_cb = m_cbRearGuardSize = 0;
		}
	}

CMapFileEx_Exit:

	LeaveCriticalSection(&m_csProtectMap);

	DeleteCriticalSection(&m_csProtectMap);

	return;
}



/* ------------------------------------------------------------------------
  CMapFileEx::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFileEx::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease )
{
	BOOL fErr = FALSE;

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;
	DWORD	cbOldSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.

		// In the guard page version we always grow the file by 2*GuardPageSize !
		cbNewSize = m_cb;
	}

	//
	// Add guard page logic
	//
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	DWORD dwPageSize = si.dwPageSize ;
	DWORD dwGuardPageSize = si.dwAllocationGranularity;

	// GuardPageSize should be > cbNewSize
	while( cbNewSize > dwGuardPageSize )
	{
		dwGuardPageSize += si.dwAllocationGranularity;
	}

	// cbNewSize should be a multiple of dwPageSize, to ensure rear guard page is properly aligned
	_ASSERT( (cbNewSize % dwPageSize) == 0 ) ;

	DWORD cbAllocSize = (2 * (dwGuardPageSize)) + cbNewSize;
	DWORD dwOldProtect = PAGE_READWRITE ;
	DWORD dwError;

	//
	//	Grow the file to match the size of memory mapping
	//

    if ( cbIncrease || cbAllocSize )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbAllocSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( 
							hFile, 
							NULL,
                            fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                            0, 
							cbAllocSize,	// NOTE: this is greater than cbNewSize by 2*GuardPageSize
							NULL 
							);

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
		m_cb = 0;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pvFrontGuard = (LPBYTE)MapViewOfFile( 
									hFileMap,
									fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
									0, 0, 0
									);

	if ( !m_pvFrontGuard )
	{
		//
        // Error case
        //
		fErr = TRUE;
		goto MapFromHandle_Exit;
	}

	// zero out the part grown
	cbOldSize = cbNewSize - cbIncrease;
	ZeroMemory( m_pvFrontGuard + cbOldSize, cbAllocSize - cbOldSize );

	// front guard page of size (64KB)
	m_cbFrontGuardSize = dwGuardPageSize ;

	// actual memory-mapping
	m_pv = m_pvFrontGuard + m_cbFrontGuardSize ;
	MoveMemory( m_pv, m_pvFrontGuard, cbNewSize );

	// rear guard page of size (64KB)
	m_pvRearGuard  = m_pv + cbNewSize ;
	m_cbRearGuardSize = m_cbFrontGuardSize ;

	// zero out the front and rear guard pages
	ZeroMemory( m_pvFrontGuard, m_cbFrontGuardSize );
	ZeroMemory( m_pvRearGuard,  m_cbRearGuardSize );

	// make front page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvFrontGuard,
				m_cbFrontGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}

	// make mapping read-only; users of CMapFileEx will need to use the
	// UnprotectMapping() / ProtectMapping() calls to write to this mapping.
	if(!VirtualProtect(
				(LPVOID)m_pv,
				cbNewSize,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}

	// make rear page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvRearGuard,
				m_cbRearGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}


MapFromHandle_Exit:

	dwError = GetLastError();

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );
	
	// reset all member vars in error cases
	if( fErr )
	{
		m_pvFrontGuard = m_pvRearGuard = m_pv = NULL;
		m_cbFrontGuardSize = m_cbRearGuardSize = m_cb = 0;
		m_hFile = INVALID_HANDLE_VALUE;
	}

    return;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	Change mapping from READONLY to READWRITE when a write is necessary
	**** NOTE: Calls to UnprotectMapping() and ProtectMapping() should be matched ***
	eg:
		{
			UnprotectMapping();

			//
			//	 code to write to the mapping
			//

			ProtectMapping();
		}

	Returns TRUE on success, FALSE on failure
	Lock is held only if returns TRUE

   ------------------------------------------------------------------------ */

BOOL	
CMapFileEx::UnprotectMapping()
{
	DWORD dwOldProtect = PAGE_READONLY;

	// *** This is released in ProtectMapping() ***
	EnterCriticalSection(&m_csProtectMap);

	// enable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READWRITE,
				&dwOldProtect
				))
	{
		LeaveCriticalSection(&m_csProtectMap);
		return FALSE;
	}

	return TRUE;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	This is called to revert the mapping protection back to READONLY
	**** The thread calling this function should have the protect lock *****

	Returns TRUE on success, FALSE on failure
	Lock is released in either case

   ------------------------------------------------------------------------ */

BOOL	
CMapFileEx::ProtectMapping()
{
	DWORD dwOldProtect = PAGE_READWRITE;
	BOOL  fRet = TRUE;

	// disable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		fRet = FALSE ;
	}

	LeaveCriticalSection(&m_csProtectMap);
	return fRet;
}

/* ------------------------------------------------------------------------
  CMapFileEx::Cleanup
  	Called when MapFromHandle fails - Does the necessary VirtualProtects
	to revert guard pages back and unmap view of file.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

void
CMapFileEx::Cleanup( void )
{
	_ASSERT( m_pvFrontGuard && m_pv && m_pvRearGuard );
	_ASSERT( m_cbFrontGuardSize && m_cb && m_cbRearGuardSize );

	//
	// get rid of guard pages - make everything PAGE_READWRITE !
	//
	DWORD dwOldProtect = PAGE_READONLY | PAGE_GUARD;
	VirtualProtect( (LPVOID)m_pvFrontGuard, m_cbFrontGuardSize, PAGE_READWRITE, &dwOldProtect);
	VirtualProtect( (LPVOID)m_pv, m_cb, PAGE_READWRITE, &dwOldProtect);
	VirtualProtect( (LPVOID)m_pvRearGuard, m_cbRearGuardSize, PAGE_READWRITE, &dwOldProtect);

	// move data back
	MoveMemory( m_pvFrontGuard, m_pv, m_cb );

	// flush and unmap !
	FlushViewOfFile( m_pvFrontGuard, m_cb ) ;
	UnmapViewOfFile( (LPVOID)m_pvFrontGuard );

	if( INVALID_HANDLE_VALUE != m_hFile )
	{
		if( SetFilePointer( m_hFile, m_cb, NULL, FILE_BEGIN ) == m_cb ) 
		{
			SetEndOfFile( m_hFile ) ;
		}
	}

	m_pvFrontGuard = m_pvRearGuard = m_pv = NULL ;
	m_cbFrontGuardSize = m_cb = m_cbRearGuardSize = 0;

	return;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\hash\xtest\xtest.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	<dbgtrace.h>
#include	"tigtypes.h"
#include	"ihash.h"


class	CExtractor :	public	IExtractObject	{
public :

	BOOL
	DoExtract(	GROUPID	groupid,
				ARTICLEID	articleid,
				PGROUP_ENTRY	pGroups,
				DWORD	cGroups	)	{

		if( groupid & 0x1 )
			return	TRUE ;
		return	FALSE ;
	}
} ;

int __cdecl
main(	int	argc,	char*	argv[] ) {

	CExtractor	extractor ;

	DeleteFile( "d:\\xtest.hsh" ) ;

	InitializeNNTPHashLibrary() ;

	CXoverMap*	pXover = CXoverMap::CreateXoverMap() ;

	pXover->Initialize(	"d:\\xtest.hsh",
						0 ) ;


	char			szBuff[256] ;
	GROUP_ENTRY		rgGroups[10] ;
	ARTICLEID		articleid ;

	for(	GROUPID	group = 1; group < 10; group ++ ) {

		for(	articleid = 1; articleid<100; articleid ++ ) {

			DWORD	cb = wsprintf( szBuff, "<art=%dgrp=%d@mydomain.com>", 100*articleid, 100*group ) ;
			for( DWORD	xPosts = 0; xPosts<10; xPosts ++ ) {

				rgGroups[xPosts].GroupId = group + 20 + xPosts ;
				rgGroups[xPosts].ArticleId = articleid * 10 + xPosts ;

			}

			FILETIME	filetime ;
			GetSystemTimeAsFileTime( &filetime ) ;
			
			BOOL	fSuccess = pXover->CreatePrimaryNovEntry(
									group,
									articleid,
									0,
									200,
									&filetime,
									szBuff,
									cb,
									10,
									rgGroups
									) ;

			_ASSERT(fSuccess) ;

			for( xPosts = 0; xPosts<10; xPosts ++ ) {
				
				fSuccess = pXover->CreateXPostNovEntry(
									rgGroups[xPosts].GroupId,
									rgGroups[xPosts].ArticleId,
									0,
									200,
									&filetime,
									group,
									articleid
									) ;

				_ASSERT(fSuccess) ;
			}
		}
	}	

	GROUP_ENTRY	groupsCheck[20] ;

	for(	GROUPID	groupCheck=1; groupCheck<=group; groupCheck++ ) {

		for( ARTICLEID	artCheck=1; artCheck<=articleid; artCheck++ ) {

			BOOL	fSuccess = pXover->Contains( groupCheck, artCheck ) ;

			_ASSERT(fSuccess || artCheck==articleid || groupCheck==group) ;			

			DWORD	NumberOfGroups = 0 ;
			DWORD	Size = sizeof( groupsCheck ) ;

			fSuccess = pXover->GetArticleXPosts(
											groupCheck,
											artCheck,
											TRUE,
											groupsCheck,
											Size,
											NumberOfGroups ) ;

			_ASSERT( fSuccess || ((GetLastError() == ERROR_FILE_NOT_FOUND) &&
				groupCheck == group || artCheck==articleid) ) ;

			_ASSERT( !fSuccess || Size == sizeof( groupsCheck[0] ) ) ;
			_ASSERT( !fSuccess || NumberOfGroups == 1 ) ;

			NumberOfGroups = 0 ;
			Size = sizeof( groupsCheck[0] ) * 5 ;

			fSuccess = pXover->GetArticleXPosts(
											groupCheck,
											artCheck,
											FALSE,
											groupsCheck,
											Size,
											NumberOfGroups ) ;

			_ASSERT( !fSuccess && (GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
					Size == sizeof(GROUP_ENTRY)*11 && NumberOfGroups == 11) ||
					(GetLastError() == ERROR_FILE_NOT_FOUND && artCheck==articleid || groupCheck==group) ) ;

			NumberOfGroups = 0 ;
			Size = sizeof( groupsCheck ) ;

			fSuccess = pXover->GetArticleXPosts(
											groupCheck,
											artCheck,
											FALSE,
											groupsCheck,
											Size,
											NumberOfGroups ) ;

			_ASSERT( fSuccess || (GetLastError() == ERROR_FILE_NOT_FOUND &&
				artCheck==articleid || groupCheck==group )) ;

			if( fSuccess ) {
				_ASSERT(  NumberOfGroups == 11 ) ;
				_ASSERT( Size = sizeof(GROUP_ENTRY)*11 ) ;


				FILETIME	timeTest ;
				WORD		HeaderOffsetTest ;
				WORD		HeaderLengthTest ;
				char		MessageId[256] ;
				DWORD		MessageIdLen = 10 ;
				BOOL		fPrimary ;
				DWORD		cStoreIds = 0;

				fSuccess = pXover->ExtractNovEntryInfo(
											groupCheck,
											artCheck,
											fPrimary,
											HeaderOffsetTest,
											HeaderLengthTest,
											&timeTest,
											MessageIdLen,
											MessageId,
											cStoreIds,
											NULL,
											NULL) ;

				_ASSERT( !fSuccess && GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ;

				cStoreIds = 0;
				fSuccess = pXover->ExtractNovEntryInfo(
											groupCheck,
											artCheck,
											fPrimary,
											HeaderOffsetTest,
											HeaderLengthTest,
											&timeTest,
											MessageIdLen,
											MessageId,
											cStoreIds,
											NULL,
											NULL,
											0) ;

				_ASSERT( fSuccess ) ;
				_ASSERT( fPrimary ) ;

				DWORD	dwJunk = 0 ;
				GROUPID	groupTest ;
				ARTICLEID	artTest ;
				CStoreId storeid;

				fSuccess = pXover->GetPrimaryArticle(
											groupCheck,
											artCheck,
											groupTest,
											artTest,
											0,
											0,
											dwJunk,
											HeaderOffsetTest,
											HeaderLengthTest,
											storeid) ;

				_ASSERT( fSuccess ) ;
				_ASSERT( groupTest == groupCheck && artTest == artCheck ) ;

				char	TestId[5] ;
				dwJunk = 0 ;

				fSuccess = pXover->GetPrimaryArticle(
											groupCheck,
											artCheck,
											groupTest,
											artTest,
											sizeof( TestId ),
											TestId,
											dwJunk,
											HeaderOffsetTest,
											HeaderLengthTest,
											storeid
											) ;

				_ASSERT( !fSuccess ) ;
				_ASSERT( dwJunk > sizeof( TestId ) ) ;

				char	BigTestId[512] ;
				ZeroMemory( BigTestId, sizeof( BigTestId ) ) ;

				fSuccess = pXover->GetPrimaryArticle(
											groupCheck,
											artCheck,
											groupTest,
											artTest,
											dwJunk,
											BigTestId,
											dwJunk,
											HeaderOffsetTest,
											HeaderLengthTest,
											storeid
											) ;

				_ASSERT( fSuccess ) ;
				_ASSERT( dwJunk > sizeof( TestId ) ) ;
				_ASSERT( (DWORD)lstrlen( BigTestId ) == dwJunk ) ;
				_ASSERT( groupTest == groupCheck && artTest == artCheck ) ;

				for( DWORD i=0; i<11; i++ ) {

					FILETIME	timeAlt ;
					WORD		HeaderOffsetAlt ;
					WORD		HeaderLengthAlt ;
					char		MessageIdAlt[256] ;
					DWORD		MessageIdLenAlt = 10 ;
					BOOL		fPrimary ;
					DWORD		cStoreIds = 0;

					fSuccess = pXover->ExtractNovEntryInfo(
											groupsCheck[i].GroupId,
											groupsCheck[i].ArticleId,
											fPrimary,
											HeaderOffsetAlt,
											HeaderLengthAlt,
											&timeAlt,
											MessageIdLenAlt,
											MessageIdAlt,
											cStoreIds,
											NULL,
											NULL
											) ;

					_ASSERT( !fSuccess && GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ;

					cStoreIds = 0;
					fSuccess = pXover->ExtractNovEntryInfo(
											groupsCheck[i].GroupId,
											groupsCheck[i].ArticleId,
											fPrimary,
											HeaderOffsetAlt,
											HeaderLengthAlt,
											&timeAlt,
											MessageIdLenAlt,
											MessageIdAlt,
											cStoreIds,
											NULL,
											NULL
											) ;

					_ASSERT( fSuccess ) ;
					_ASSERT( memcmp( &timeAlt, &timeTest, sizeof( timeAlt ) ) == 0 ) ;
					_ASSERT( HeaderOffsetTest == HeaderOffsetAlt ) ;
					_ASSERT( HeaderLengthTest == HeaderLengthAlt ) ;
					_ASSERT( memcmp( MessageId, MessageIdAlt, MessageIdLenAlt ) == 0 ) ;
					_ASSERT( MessageIdLen == MessageIdLenAlt ) ;
					_ASSERT( !fPrimary || i==0 ) ;

					MessageIdLenAlt = 10 ;

					cStoreIds = 0;
					fSuccess = pXover->ExtractNovEntryInfo(
											groupsCheck[i].GroupId,
											groupsCheck[i].ArticleId,
											fPrimary,
											HeaderOffsetAlt,
											HeaderLengthAlt,
											&timeAlt,
											MessageIdLenAlt,
											MessageIdAlt,
											cStoreIds,
											NULL,
											NULL,
											&extractor
											) ;

					_ASSERT( !fSuccess && GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ;

					cStoreIds = 0;
					fSuccess = pXover->ExtractNovEntryInfo(
											groupsCheck[i].GroupId,
											groupsCheck[i].ArticleId,
											fPrimary,
											HeaderOffsetAlt,
											HeaderLengthAlt,
											&timeAlt,
											MessageIdLenAlt,
											MessageIdAlt,
											cStoreIds,
											NULL,
											NULL,
											&extractor
											) ;

					_ASSERT( fSuccess ) ;
					_ASSERT( memcmp( &timeAlt, &timeTest, sizeof( timeAlt ) ) == 0 ) ;
					_ASSERT( HeaderOffsetTest == HeaderOffsetAlt ) ;
					_ASSERT( HeaderLengthTest == HeaderLengthAlt ) ;
					_ASSERT( memcmp( MessageId, MessageIdAlt, MessageIdLenAlt ) == 0 ) ;
					_ASSERT( MessageIdLen == MessageIdLenAlt || MessageIdLenAlt == 0 ) ;
					_ASSERT( !fPrimary || i==0 ) ;


					_ASSERT( pXover->Contains( groupsCheck[i].GroupId, groupsCheck[i].ArticleId ) ) ;


					GROUP_ENTRY	moreGroups[11] ;
					Size = sizeof( moreGroups ) ;
					NumberOfGroups = 0 ;

					fSuccess = pXover->GetArticleXPosts(
											groupsCheck[i].GroupId,
											groupsCheck[i].ArticleId,
											FALSE,
											moreGroups,
											Size,
											NumberOfGroups ) ;

					_ASSERT( fSuccess ) ;
					_ASSERT( Size == sizeof( moreGroups ) ) ;
					_ASSERT( memcmp( moreGroups, groupsCheck, Size ) == 0 ) ;

					CStoreId storeid;
					fSuccess = pXover->GetPrimaryArticle(
												groupsCheck[i].GroupId,
												groupsCheck[i].ArticleId,
												groupTest,
												artTest,
												0,
												0,
												dwJunk,
												HeaderOffsetTest,
												HeaderLengthTest,
												storeid
												) ;

					_ASSERT( fSuccess ) ;
					_ASSERT( groupTest == groupCheck && artTest == artCheck ) ;

					char	TestId[5] ;
					dwJunk = 0 ;

					fSuccess = pXover->GetPrimaryArticle(
												groupsCheck[i].GroupId,
												groupsCheck[i].ArticleId,
												groupTest,
												artTest,
												sizeof( TestId ),
												TestId,
												dwJunk,
												HeaderOffsetTest,
												HeaderLengthTest,
												storeid
												) ;

					_ASSERT( !fSuccess ) ;
					_ASSERT( dwJunk > sizeof( TestId ) ) ;

					char	BigTestId[512] ;
					ZeroMemory( BigTestId, sizeof( BigTestId ) ) ;

					fSuccess = pXover->GetPrimaryArticle(
												groupsCheck[i].GroupId,
												groupsCheck[i].ArticleId,
												groupTest,
												artTest,
												dwJunk,
												BigTestId,
												dwJunk,
												HeaderOffsetTest,
												HeaderLengthTest,
												storeid
												) ;

					_ASSERT( fSuccess ) ;
					_ASSERT( dwJunk > sizeof( TestId ) ) ;
					_ASSERT( (DWORD)lstrlen( BigTestId ) == dwJunk ) ;
					_ASSERT( groupTest == groupCheck && artTest == artCheck ) ;

				}
			}

			DWORD	DataLen = 10 ;
			fSuccess = pXover->SearchNovEntry(
									groupCheck,
									artCheck,
									szBuff,
									&DataLen ) ;
	
			_ASSERT( !fSuccess &&
					(GetLastError() == ERROR_FILE_NOT_FOUND &&
						artCheck==articleid || groupCheck==group) ||
					(GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
						artCheck != articleid && groupCheck != group) ) ;

			fSuccess = pXover->SearchNovEntry(
									groupCheck,
									artCheck,
									szBuff,
									&DataLen ) ;

			_ASSERT( fSuccess ||
					(GetLastError() == ERROR_FILE_NOT_FOUND &&
						artCheck==articleid || groupCheck==group) ) ;

		}
	}


	pXover->Shutdown() ;
	
	delete	pXover ;

	TermNNTPHashLibrary() ;

    return  0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\src\stdinc.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\src\makefile.inc ===
$(O)\mailmsg.h : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpmsg.h: ..\..\server\nntpmsg.mc
    mc -v -r $(O) -h $(O) $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\src\grpiter.cpp ===
//
//	grpiter.cpp
//
//	This file contains the implementation of the CGroupIteratorCore class.
//
//


#include	"stdinc.h"
#include	"wildmat.h"

BOOL MatchGroup(LPMULTISZ multiszPatterns, LPSTR lpstrGroup);

CGroupIteratorCore::CGroupIteratorCore( 
						CNewsTreeCore*  pTree,
						CGRPCOREPTR		&pFirst
						) : 
/*++

Routine Description : 

	This builds an iterator that will enumerate all newsgoups
	without doing any wildmat pattern matching.
	We will do secure newsgroup checking however.

Arguments : 

	pFirst - First newsgroup in the list
		Caller must be holding a reference to this so that 
		there is no chance of the newsgroup being destroyed
		untill we can set up our reference 
		(done through a smart pointer)

	fIncludeSecureGroups - 
		if TRUE then include secure newsgroups in iteration.

	CSecurityCtx* pClientLogon - client security context

	BOOL	IsClientSecure	- is client connection secure

Return Value : 

	None.
	
--*/
	m_pTree( pTree ),
	m_multiszPatterns( 0 ),
	m_pCurrentGroup( pFirst ), 
	m_fIncludeSpecial( FALSE ),
	m_cRef(1) 
{

	//
	//	Make sure we start on a valid newsgroup !
	//
	if (pFirst && (pFirst->IsSpecial() || (pFirst->IsDeleted()))) Next();

	if( m_pCurrentGroup ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastEnd = m_fPastBegin = TRUE ;
	}
}

CGroupIteratorCore::CGroupIteratorCore( 
								CNewsTreeCore*  pTree,
								LPMULTISZ	lpstr,	
								CGRPCOREPTR&	pFirst,
								BOOL		fSpecialGroups
								) :
/*++

Routine Description : 

	Create an interator that will do wildmat pattern matching.

Arguments : 

	lpstr - wildmat patterns
	pFirst - first newsgroup 
	fIncludeSecureGroups - if TRUE include secure SSL only newsgroups
	fSpecialGroups - if TRUE include reserved groups

Return Value : 

	None.

--*/
	m_pTree( pTree ),
	m_multiszPatterns( lpstr ), 
	m_pCurrentGroup( pFirst ), 
	m_fPastEnd( TRUE ),
	m_fIncludeSpecial( fSpecialGroups ),
	m_cRef(1)
{

	//
	//	Check whether the first group is legal
	//
	if (pFirst != 0 && 
	    ((pFirst->IsSpecial() && !m_fIncludeSpecial) ||
		 (pFirst->IsDeleted()) ||
		 (!MatchGroup( m_multiszPatterns, pFirst->GetName())))) 
	{
		Next() ;
	}

	if( m_pCurrentGroup != 0 ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastEnd = m_fPastBegin = TRUE ;
	}
}

CGroupIteratorCore::~CGroupIteratorCore() {
}

BOOL
CGroupIteratorCore::IsBegin()	{

	BOOL	fRtn = FALSE ;
	if( m_pCurrentGroup == 0 ) 
		fRtn = m_fPastBegin ;
	return	fRtn ;
}

BOOL
CGroupIteratorCore::IsEnd()	{

	BOOL	fRtn = FALSE ;
	if( m_pCurrentGroup == 0 ) 
		fRtn = m_fPastEnd ;
	return	fRtn ;
}

/*++
	
	MatchGroup - 
		
	All negation strings (starting with '!')  must precede other strings.

--*/
BOOL
MatchGroup(	LPMULTISZ	multiszPatterns,	LPSTR lpstrGroup ) {

	Assert( multiszPatterns != 0 ) ;
	
    if( multiszPatterns == 0 ) {
        return  TRUE ;
    }

	LPSTR	lpstrPattern = multiszPatterns ;

	while( *lpstrPattern != '\0' )	{
		if( *lpstrPattern == '!' ) {
			_strlwr( lpstrPattern+1 );
			if( HrMatchWildmat( lpstrGroup, lpstrPattern+1 ) == ERROR_SUCCESS ) {
				return	FALSE ;
			}
		}	else	{
			_strlwr( lpstrPattern );
			if( HrMatchWildmat( lpstrGroup, lpstrPattern ) == ERROR_SUCCESS ) {
				return	TRUE ;
			}
		}
		lpstrPattern += lstrlen( lpstrPattern ) + 1 ;
	}
	return	FALSE ;
};

void
CGroupIteratorCore::NextInternal()	{
/*++

Routine description : 

	This function advances the iterators current group pointer 
	to the next valid newsgroup.

	NOTE: this is called by the constructor to spin past newsgroups with the same prefix
	that are not visible.

Arguments : 

	None.

Return Value : 

	None.

--*/

	CNewsGroupCore*	pTemp  = 0 ;
	LPSTR lpRootGroup = NULL;
	DWORD RootGroupSize = 0;

	_ASSERT( m_pCurrentGroup );

	m_pTree->m_LockTables.ShareLock() ;

	pTemp = m_pCurrentGroup ;
	lpRootGroup = pTemp->GetName();
	RootGroupSize = lstrlen( lpRootGroup );

	// spin past groups with the same prefix
	do {
			pTemp = pTemp->m_pNext ;
	} while( (pTemp && (strstr( pTemp->GetName(), lpRootGroup ) == pTemp->GetName()) && (*(pTemp->GetName()+RootGroupSize) == '.') ) || 
				(pTemp && pTemp->IsDeleted()) );

	// either we are past the end or the current group does not have lpRootGroup as the prefix
	_ASSERT( (pTemp == NULL) ||
				(strstr( pTemp->GetName(), lpRootGroup ) != pTemp->GetName()) ||
				(*(pTemp->GetName()+RootGroupSize) != '.') );

	//
	//	Use a reference counting smart pointer to close windows where the 
	//	newsgroup is destroyed after our call to ShareUnlock().
	//
	CGRPCOREPTR	pPtrTemp = pTemp ;
	_ASSERT( !pPtrTemp || !pPtrTemp->IsDeleted() );

	m_pTree->m_LockTables.ShareUnlock() ;

	//
	//	This could implicity call the destructor for the newsgroup we 
	//	were pointing at - which tries to unlink the newsgroup after 
	//	grabbing the m_LockTables lock exclusively - which is why this
	//	code is outside of the call to ShareLock().
	//
	m_pCurrentGroup = pPtrTemp ;

	if( m_pCurrentGroup != 0 ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastEnd = TRUE ;
	}
}

void
CGroupIteratorCore::Next()	{
/*++

Routine description : 

	This function advances the iterators current group pointer 
	to the next valid newsgroup.

Arguments : 

	None.

Return Value : 

	None.

--*/

	CNewsGroupCore*	pTemp  = 0 ;

	m_pTree->m_LockTables.ShareLock() ;

	pTemp = m_pCurrentGroup->m_pNext ;

	if( !m_fIncludeSpecial || m_multiszPatterns) {
		while (pTemp != 0 && 
			   ((!m_fIncludeSpecial && pTemp->IsSpecial()) ||
				(pTemp->IsDeleted()) ||
				(m_multiszPatterns && !MatchGroup( m_multiszPatterns, pTemp->GetName())))) 
		{
			pTemp = pTemp->m_pNext ;
		}

		_ASSERT( pTemp == 0 ||
				((!m_fIncludeSpecial && !pTemp->IsSpecial()) ||
				 (m_fIncludeSpecial)) ) ;
	}

	//
	//	Use a reference counting smart pointer to close windows where the 
	//	newsgroup is destroyed after our call to ShareUnlock().
	//
	CGRPCOREPTR	pPtrTemp = pTemp ;
	_ASSERT( !pPtrTemp || !pPtrTemp->IsDeleted() );

	m_pTree->m_LockTables.ShareUnlock() ;

	//
	//	This could implicity call the destructor for the newsgroup we 
	//	were pointing at - which tries to unlink the newsgroup after 
	//	grabbing the m_LockTables lock exclusively - which is why this
	//	code is outside of the call to ShareLock().
	//
	m_pCurrentGroup = pPtrTemp ;

	if( m_pCurrentGroup != 0 ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastEnd = TRUE ;
	}
}

void
CGroupIteratorCore::Prev()	{
/*++

Routine Description : 

	Find the previous element in the list.

Arguments : 

	None.

Return Value : 

	None.

--*/

	CNewsGroupCore*	pTemp = 0 ;

#if 0
	if( !m_multiszPatterns )	{
#endif
	
	m_pTree->m_LockTables.ShareLock() ;

	pTemp = m_pCurrentGroup->m_pPrev ;

	if( !m_fIncludeSpecial || m_multiszPatterns) {

		while (pTemp != 0 && 
			   ((!m_fIncludeSpecial && pTemp->IsSpecial()) ||
				(pTemp->IsDeleted()) ||
				(m_multiszPatterns && !MatchGroup( m_multiszPatterns, pTemp->GetName())))) 
		{
			pTemp = pTemp->m_pPrev ;
		}

		_ASSERT( pTemp == 0 ||
				((!m_fIncludeSpecial && !pTemp->IsSpecial()) ||
				 (m_fIncludeSpecial)) ) ;
	}

	//
	//	Use a reference counting smart pointer to close windows where the 
	//	newsgroup is destroyed after our call to ShareUnlock().
	//
	CGRPCOREPTR	pPtrTemp = pTemp ;
	_ASSERT( !pPtrTemp || !pPtrTemp->IsDeleted() );

	m_pTree->m_LockTables.ShareUnlock() ;
	//
	//	This could implicity call the destructor for the newsgroup we 
	//	were pointing at - which tries to unlink the newsgroup after 
	//	grabbing the m_LockTables lock exclusively - which is why this
	//	code is outside of the call to ShareLock().
	//
	m_pCurrentGroup = pPtrTemp ;

	if( m_pCurrentGroup != 0 ) {
		m_fPastEnd = m_fPastBegin = FALSE ;
	}	else	{
		m_fPastBegin = TRUE ;
	}
}

HRESULT CGroupIteratorCore::Current(INNTPPropertyBag **ppGroup, INntpComplete *pProtocolComplete ) {
	_ASSERT(ppGroup != NULL);
	if (ppGroup == NULL) return E_INVALIDARG;

	CGRPCOREPTR pGroup = Current();
	if (pGroup == NULL) return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

	*ppGroup = pGroup->GetPropertyBag();
#ifdef DEBUG
	if ( pProtocolComplete ) ((CNntpComplete*)pProtocolComplete)->BumpGroupCounter();
#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\src\group.cpp ===
#include    "stdinc.h"

CShareLockNH    CNewsGroupCore::m_rglock[GROUP_LOCK_ARRAY_SIZE];

CNewsGroupCore::~CNewsGroupCore() {
	TraceQuietEnter("CNewsGroupCore::~CNewsGroupCore");
	
	_ASSERT(m_dwSignature == CNEWSGROUPCORE_SIGNATURE);

	m_pNewsTree->m_LockTables.ExclusiveLock();

    // remove ourselves from the list of newsgroups
    if (this->m_pPrev != NULL) {
        this->m_pPrev->m_pNext = m_pNext;
    } else if (m_pNewsTree->m_pFirst == this) {
        m_pNewsTree->m_pFirst = this->m_pNext;
    }
    if (this->m_pNext != NULL) {
        this->m_pNext->m_pPrev = m_pPrev;
    } else if (m_pNewsTree->m_pLast == this) {
	    m_pNewsTree->m_pLast = this->m_pPrev;
    }
    m_pPrev = m_pNext = NULL;

	m_pNewsTree->m_LockTables.ExclusiveUnlock();

    // clean up allocated memory
    if (m_pszGroupName != NULL) {
        XDELETE m_pszGroupName;
        m_pszGroupName = NULL;
    }
    if (m_pszNativeName != NULL) {
        XDELETE m_pszNativeName;
        m_pszNativeName = NULL;
    }
	if (m_pszHelpText != NULL) {
		XDELETE m_pszHelpText;
		m_pszHelpText = NULL;
		m_cchHelpText = 0;
	}
	if (m_pszPrettyName != NULL) {
		XDELETE m_pszPrettyName;
		m_pszPrettyName = NULL;
		m_cchPrettyName = 0;
	}
	if (m_pszModerator != NULL) {
		XDELETE m_pszModerator;
		m_pszModerator = NULL;
		m_cchModerator = 0;
	}

	if (m_pVRoot != NULL) {
		m_pVRoot->Release();
		m_pVRoot = NULL;
	}

	//ZeroMemory(this, sizeof(CNewsGroupCore));
	this->m_dwSignature = CNEWSGROUPCORE_SIGNATURE_DEL;
}

void CNewsGroupCore::SaveFixedProperties() {
	INNTPPropertyBag *pBag = GetPropertyBag();
	m_pNewsTree->SaveGroup(pBag);
	pBag->Release();
}

BOOL CNewsGroupCore::SetPrettyName(LPCSTR szPrettyName, int cch) {
	ExclusiveLock();
	if (cch == -1) cch = (szPrettyName == NULL) ? 0 : strlen(szPrettyName);
	BOOL f = FALSE;
	if (m_pszPrettyName != NULL) {
		XDELETE[] m_pszPrettyName;
		m_pszPrettyName = NULL;
		m_cchPrettyName = 0;
	}
	if (cch > 0) {
		m_pszPrettyName = XNEW char[(cch * sizeof(char)) + 1];
		if (m_pszPrettyName != NULL) {
			strcpy(m_pszPrettyName, szPrettyName);
			m_cchPrettyName = cch ;
			f = TRUE;
		} else {
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	} else {
		f = TRUE;
	}
	m_fVarPropChanged = TRUE;
	ExclusiveUnlock();
	return f;						
}

BOOL CNewsGroupCore::SetNativeName(LPCSTR szNativeName, int cch) {

    //
    // Validate if native name differs only in case with group name
    //
    if ( (DWORD)cch != m_cchGroupName ||
            _strnicmp( szNativeName, m_pszGroupName, cch ) ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

	ExclusiveLock();
	if (cch == -1) cch = (szNativeName == NULL) ? 0 : strlen(szNativeName);
	BOOL f = FALSE;
	if (m_pszNativeName != NULL) {

	    if ( m_pszNativeName != m_pszGroupName ) {
    		XDELETE[] m_pszNativeName;
        }

	    m_pszNativeName = NULL;
		
	}
	if (cch > 0) {
		m_pszNativeName = XNEW char[(cch * sizeof(char)) + 1];
		if (m_pszNativeName != NULL) {
			strcpy(m_pszNativeName, szNativeName);
			f = TRUE;
		} else {
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	} else {
		f = TRUE;
	}
	m_fVarPropChanged = TRUE;
	ExclusiveUnlock();
	return f;						
}

BOOL CNewsGroupCore::SetModerator(LPCSTR szModerator, int cch) {
	ExclusiveLock();
	if (cch == -1) cch = (szModerator == NULL) ? 0 : strlen(szModerator);
	BOOL f = FALSE;
	if (m_pszModerator != NULL) {
		XDELETE[] m_pszModerator;
		m_pszModerator = NULL;
		m_cchModerator = 0;
	}
	if (cch > 0) {
		m_pszModerator = XNEW char[(cch * sizeof(char)) + 1];
		if (m_pszModerator != NULL) {
			strcpy(m_pszModerator, szModerator);
			m_cchModerator = cch ;
			f = TRUE;
		} else {
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	} else {
		f = TRUE;
	}
	ExclusiveUnlock();
	m_fVarPropChanged = TRUE;
	return f;						
}

BOOL CNewsGroupCore::SetHelpText(LPCSTR szHelpText, int cch) {
	ExclusiveLock();
	if (cch == -1) cch = (szHelpText == NULL) ? 0 : strlen(szHelpText);
	BOOL f = FALSE;
	if (m_pszHelpText != NULL) {
		XDELETE[] m_pszHelpText;
		m_pszHelpText = NULL;
		m_cchHelpText = 0;
	}
	if (cch > 0) {
		m_pszHelpText = XNEW char[(cch * sizeof(char)) + 1];
		if (m_pszHelpText != NULL) {
			strcpy(m_pszHelpText, szHelpText);
			m_cchHelpText = cch ;
			f = TRUE;
		} else {
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	} else {
		f = TRUE;
	}
	ExclusiveUnlock();
	m_fVarPropChanged = TRUE;
	return f;				
}

void
CNewsGroupCore::InsertArticleId(	
					ARTICLEID	artid
					)		{
/*++

Routine Description :

	Record the presence of an article id in our newsgroup.	
	This is called on slaves when a master sticks articles into
	a newsgroup, as well as during rebuilds initiated by nntpbld.exe

Arguments :

	artid - the article in our newsgroup

Return Value :

	None.

--*/
    //
    // If i am delete, do nothing
    //
    if ( IsDeleted() ) return;

    //
    // Lock myself first
    //
    ExclusiveLock();

    //
    // If I am deleted, do nothing
    //
    if ( m_fDeleted ) {
        ExclusiveUnlock();
        return;
    }

    //
    // Adjust high watermark
    //
    m_iHighWatermark = max( m_iHighWatermark, artid );

    //
    // Unlock it
    //
    ExclusiveUnlock();
}

ARTICLEID
CNewsGroupCore::AllocateArticleId(	)	{
/*++

Routine Description :

	Get an ID to be used for a newly posted article.
	We just bump a counter for this id.

Arguments :

	None.

Return Value

	The article id for the new article.	

--*/
    ExclusiveLock();
	ARTICLEID artid = ++m_iHighWatermark;
	ExclusiveUnlock();
	return	artid ;
}

CNewsGroupCore::AddReferenceTo(
                    ARTICLEID,
                    CArticleRef&    artref
                    ) {
/*++

Routine description :

    This function is used for cross posted articles which
    are physically stored in another newsgroup - we bump
    the number of articles in this group.

Arguments :

    We don't use our arguments anymore -
    place holders in case we ever want to create disk links

Return Value :

    TRUE if successfull - always succeed.

--*/
    if (IsDeleted()) return FALSE;

    return TRUE;
}

BOOL CNewsGroupCore::SetDriverStringProperty(   DWORD   cProperties,
                                                DWORD   rgidProperties[] )
{
    TraceFunctEnter( "CNewsGroupCore::SetDriverStringProperty" );

    HANDLE  heDone = NULL;
    HRESULT hr = S_OK;
    CNntpSyncComplete scComplete;
    INNTPPropertyBag *pPropBag = NULL;

    // get vroot
    CNNTPVRoot *pVRoot = GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Set Vroot to completion object
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pVRoot->SetGroup(   pPropBag, cProperties, rgidProperties, &scComplete );

    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "SetGroup failed with %x", hr );
    }

    // Here the property bag should have been released by
    // the driver
    pPropBag = NULL;

Exit:

    if ( pVRoot ) pVRoot->Release();
    if ( pPropBag ) pPropBag->Release();

    if ( FAILED( hr ) ) SetLastError( HRESULT_FROM_WIN32( hr ) );

    TraceFunctLeave();
    return SUCCEEDED( hr );
}

BOOL
CNewsGroupCore::IsGroupAccessible(  HANDLE hClientToken,
                                    DWORD   dwAccessDesired )
/*++
Routine description:

    Wrapper of the vroot call "CheckGroupAccess".  This function
    is called by CNewsGroup's IsGroupAccessibleInternal.

Arguments:

    HANDLE hClientToken - The client's access token to check against
    DWORD  dwAccessDesired - The desired access rights to check

Return value:

    TRUE - Access allowed
    FALSE - Access denied
--*/
{
    TraceFunctEnter( "CNewsGroupCore::IsGroupAccessible" );

    HRESULT hr = S_OK;
    CNntpSyncComplete scComplete;
    INNTPPropertyBag *pPropBag = NULL;

    //
    // If he wanted to post but we only have read permission, we'll
    // fail it
    //
    if ( (dwAccessDesired & NNTP_ACCESS_POST) && ( IsReadOnly() || !IsAllowPost() )) {
        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    // get vroot
    CNNTPVRoot *pVRoot = GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // if it's UNC Vroot and the vroot has impersonation
    // token, return true
    if ( pVRoot->GetLogonInfo() == CNNTPVRoot::VROOT_LOGON_UNC &&
         pVRoot->GetImpersonationToken() ) {
        DebugTrace( 0, "Has personation token" );
        goto Exit;
    }

    //
    // Set vroot to the completion object
    //
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pVRoot->CheckGroupAccess(   pPropBag,
                                hClientToken,
                                dwAccessDesired,
                                &scComplete );

    //
    // Wait for completion
    //
    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();

    // Here the property bag should have been released by
    // the driver
    pPropBag = NULL;

Exit:

    if ( pVRoot ) pVRoot->Release();
    if ( pPropBag ) pPropBag->Release();

    if ( FAILED( hr ) ) SetLastError( hr );

    TraceFunctLeave();
    return SUCCEEDED( hr );
}

BOOL
CNewsGroupCore::RebuildGroup(  HANDLE hClientToken )
/*++
Routine description:

    Rebuild this group in store.

Arguments:

    HANDLE hClientToken - The client's access token to check against

Return value:

    TRUE - Succeeded  FALSE otherwise
--*/
{
    TraceFunctEnter( "CNewsGroupCore::Rebuild" );

    HRESULT hr = S_OK;
    CNntpSyncComplete scComplete;
    INNTPPropertyBag *pPropBag = NULL;

    // get vroot
    CNNTPVRoot *pVRoot = GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Set vroot to the completion object
    //
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pVRoot->RebuildGroup(   pPropBag,
                            hClientToken,
                            &scComplete );

    //
    // Wait for completion
    //
    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();

    // Here the property bag should have been released by
    // the driver
    pPropBag = NULL;

Exit:

    if ( pVRoot ) pVRoot->Release();
    if ( pPropBag ) pPropBag->Release();

    if ( FAILED( hr ) ) SetLastError( hr );

    TraceFunctLeave();
    return SUCCEEDED( hr );
}

BOOL
CNewsGroupCore::ShouldCacheXover()
/*++
Routine description:

    Check if I should insert entry into xix cache for this group.

Arguments:

    None.

Return value:

    TRUE if the group doesn't have per-item sec-desc and the
    cache hit counter is greater than threshold; FALSE otherwise
--*/
{
    CGrabShareLock lock(this);

    //
    // First check cache hit count, if it's below threshold,
    // we'll return FALSE immediately
    //
    if ( m_dwCacheHit < CACHE_HIT_THRESHOLD ) return FALSE;

    //
    // If it's greater than the CACHE_HIT_THRESHOLD, we'll
    // still check if the group has per-item sec-desc
    //

    //
    // If it's file system driver, we'll always return TRUE if
    // it has been referenced for enough times, since it doesn't
    // have per item sec-desc
    //
    CNNTPVRoot *pVRoot = GetVRootWithoutLock();
    if ( NULL == pVRoot ) {
        // No vroot ?  a bad group ?  no cache
        return FALSE;
    }

    if ( pVRoot->GetLogonInfo() != CNNTPVRoot::VROOT_LOGON_EX ) {
        pVRoot->Release();
        return TRUE;
    }

    pVRoot->Release();

    //
    // For exchange vroots, we'll check sec-desc
    //
    INNTPPropertyBag *pPropBag = GetPropertyBag();
    _ASSERT( pPropBag );    // should never be NULL;
    BYTE pbBuffer[512];
    DWORD dwLen = 512;
    BOOL  f;
    HRESULT hr = pPropBag->GetBLOB( NEWSGRP_PROP_SECDESC, pbBuffer, &dwLen );
    pPropBag->Release();

    f = ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) != hr );

    return f;
}

BOOL
CNewsGroupCore::ComputeXoverCacheDir(	char	(&szPath)[MAX_PATH*2],
										BOOL&	fFlatDir,
										BOOL	fLocksHeld
										) 	{
/*++

Routine Description :

	Figure out where the .XIX files should be saved and return whether
	they are flat within the direectory !

Arguments :

	szPath - gets the target directory !

Return Value :

	TRUE if .xix files are flat in the directory - FALSE otherwise !

--*/

	BOOL	fReturn = FALSE ;

	if( !fLocksHeld ) 	{
		ShareLock() ;
	}
	DWORD	cbOut ;

	CNNTPVRoot*	pVRoot = GetVRootWithoutLock() ;
	if( pVRoot != 0 ) {
		fReturn =
			pVRoot->GetXoverCacheDir(	
									this,
									&szPath[0],
									sizeof( szPath ),
									&cbOut,
									&fFlatDir
									) ;
		pVRoot->Release() ;
		if( !fReturn || cbOut == 0 ) 	{
			CNntpServerInstanceWrapperEx*	pInst = m_pNewsTree->m_pInstWrapper ;
			PCHAR	szTemp = pInst->PeerTempDirectory() ;
			if( strlen( szTemp ) < sizeof( szPath ) ) 	{
				strcpy( szPath, szTemp ) ;
				fFlatDir = TRUE ;
				fReturn = TRUE ;
			}
		}
	}

	if( !fLocksHeld ) 	{
		ShareUnlock() ;
	}

	return	fReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\src\nntpbag.cpp ===
// NNTPPropertyBag.cpp : Implementation of CNNTPPropertyBag
#include "stdinc.h"


/////////////////////////////////////////////////////////////////////////////
// CNNTPPropertyBag - Interface methods

HRESULT CNNTPPropertyBag::Validate()
/*++
Routine description:

    Current logic: a property bag could be empty, but it must be associated
    with a newsgroup.  Otherwise, ie. the news group pointer is not initialized,
    Get/Set operations can not be done on this property bag.  Because right now
    it's only relaying properties and doesn't have its own storage.

Arguments:

    None.

Return value:

    None.
--*/
{
    _ASSERT( m_pParentGroup );
    m_PropBag.Validate();
    return S_OK;
}

ULONG _stdcall CNNTPPropertyBag::Release() {
	_ASSERT(m_pcRef != NULL);
	
	// see if we need to save changes back
	if (m_fPropChanges) {
	    m_fPropChanges = FALSE;
	    m_pParentGroup->SaveFixedProperties();
	}
	
	// our parent group should always have at least one reference
	if ( InterlockedDecrement( m_pcRef ) == 0 ) {
	    _ASSERT( 0 );
	}
	
	return *(m_pcRef);
}

STDMETHODIMP CNNTPPropertyBag::PutBLOB(IN DWORD dwID, IN DWORD cbValue, IN PBYTE pbValue)
/*++
Routine description:

    Put property by blob.

Arguments:

    IN DWORD dwID   -   The property ID
    IN DWORD cbValue-   The length, in bytes of blob
    IN PBYTE pbValue-   The pointer to the blob

Return value:

    S_OK            - Success
    S_FALSE			- OK, but property doesn't previously exist
    E_FAIL          - Failed.
    E_INVALIDARG    - Arguments invalid ( possibly prop id not supported )
    E_OUTOFMEMORY   - Memory allocation fail
    CO_E_NOT_SUPPORTED- The operation not supported ( eg. some properties are read only )
--*/
{
    _ASSERT( cbValue > 0 );
    _ASSERT( pbValue );

    //
    // Validate if the bag has been initialized
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) ) 
    	return m_PropBag.PutBLOB( dwID, pbValue, cbValue );
    
    switch( dwID ) {

		case NEWSGRP_PROP_PRETTYNAME:
		    _ASSERT( cbValue == 0 || *(pbValue + cbValue - 1) == 0 );
			if ( !m_pParentGroup->SetPrettyName( LPCSTR(pbValue), cbValue ) ) 
				return HRESULT_FROM_WIN32( GetLastError() );
			break;

		case NEWSGRP_PROP_DESC:
		    _ASSERT( cbValue == 0 || *(pbValue + cbValue - 1 ) == 0 );
			if ( !m_pParentGroup->SetHelpText( LPCSTR(pbValue), cbValue ) )
				return HRESULT_FROM_WIN32( GetLastError() );
			break;

		case NEWSGRP_PROP_MODERATOR:
		    _ASSERT( cbValue == 0 || *(pbValue + cbValue - 1 ) == 0 );
			if ( !m_pParentGroup->SetModerator( LPCSTR(pbValue), cbValue ) )
				return HRESULT_FROM_WIN32( GetLastError() );
			break;

	    case NEWSGRP_PROP_NATIVENAME:
	        _ASSERT( cbValue == 0 || *(pbValue + cbValue - 1 ) == 0 );
	        if ( !m_pParentGroup->SetNativeName( LPCSTR(pbValue), cbValue) )
	            return HRESULT_FROM_WIN32( GetLastError() );
	        break;

        default:
            return E_INVALIDARG;
    }

	return S_OK;
}

STDMETHODIMP CNNTPPropertyBag::GetBLOB(IN DWORD dwID, OUT PBYTE pbValue, OUT PDWORD pcbValue)
/*++
Routine description:

    Get property by blob.

Arguments:

    IN DWORD dwID       - Propert ID to get
    OUT PBYTE pbValue   - Buffer to contain value to be returned
    IN PDWORD pcbValue  - Buffer length
    OUT PDWORD pcbValue - Buffer length needed, or property size returned

Return value

    S_OK            - Success
    E_FAIL          - Fail
    HRESULT_FROM_WIN32( ERROR_NOT_FOUND )- Invalid arguments ( possibly property id not supported )
    TYPE_E_BUFFERTOOSMALL - Buffer too small, please check actual buffer size needed
                            in pcbValue
--*/
{
    _ASSERT( pbValue );
    _ASSERT( pcbValue );

    DWORD   dwSizeNeeded;
    LPCSTR	lpstrSource;
    HRESULT	hr;
    DWORD	dwLen = *pcbValue;

    //
    // Validate if the bag has been initiated
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) ) {
    	hr = m_PropBag.GetBLOB( dwID, pbValue, &dwLen );
    	_ASSERT( dwLen <= *pcbValue );
    	*pcbValue = dwLen;
    	return hr;
    }
    	
    switch( dwID ) {
    
        case NEWSGRP_PROP_NATIVENAME:	// must have property
            _ASSERT( m_pParentGroup->m_pszGroupName );
            dwSizeNeeded =  m_pParentGroup->GetGroupNameLen() * sizeof( CHAR );
            if ( *pcbValue < dwSizeNeeded ) {
                *pcbValue = dwSizeNeeded;
                return TYPE_E_BUFFERTOOSMALL;
            }
            CopyMemory( pbValue, m_pParentGroup->GetNativeName(), dwSizeNeeded );
            *pcbValue = dwSizeNeeded;  
            break;
            
        case NEWSGRP_PROP_NAME:		// must have property
            dwSizeNeeded = ( m_pParentGroup->GetGroupNameLen() ) * sizeof( CHAR );
            if ( *pcbValue < dwSizeNeeded ) {
                *pcbValue = dwSizeNeeded;
                return TYPE_E_BUFFERTOOSMALL;
            }
            CopyMemory( pbValue, m_pParentGroup->GetGroupName(), dwSizeNeeded );
            *pcbValue = dwSizeNeeded ;  
            break;

        case NEWSGRP_PROP_PRETTYNAME:	// optional
        	if ( lpstrSource = m_pParentGroup->GetPrettyName( &dwSizeNeeded ) ) {
        		if ( *pcbValue < dwSizeNeeded ) { 
        			*pcbValue = dwSizeNeeded;
        			return TYPE_E_BUFFERTOOSMALL;
        		}
        		CopyMemory( pbValue, lpstrSource, dwSizeNeeded );
        		*pcbValue = dwSizeNeeded;
        	} else { // property doesn't exist
        		*pcbValue = 1;
        		*pbValue = 0;
        	}
        	break;

        case NEWSGRP_PROP_DESC:	// optional
        	if ( lpstrSource = m_pParentGroup->GetHelpText( &dwSizeNeeded ) ) {
        		if ( *pcbValue < dwSizeNeeded  ) { 
        			*pcbValue = dwSizeNeeded;
        			return TYPE_E_BUFFERTOOSMALL;
        		}
        		CopyMemory( pbValue, lpstrSource, dwSizeNeeded );
        		*pcbValue = dwSizeNeeded;
        	} else { // property doesn't exist
        		*pcbValue = 1;
        		*pbValue = 0;
        	}
        	break;

        case NEWSGRP_PROP_MODERATOR:	// optional
        	if ( lpstrSource = m_pParentGroup->GetModerator( &dwSizeNeeded ) ) {
        		if ( *pcbValue < dwSizeNeeded ) { 
        			*pcbValue = dwSizeNeeded;
        			return TYPE_E_BUFFERTOOSMALL;
        		}
        		CopyMemory( pbValue, lpstrSource, dwSizeNeeded );
        		*pcbValue = dwSizeNeeded;
        	} else { // property doesn't exist
        		*pcbValue = 1;
        		*pbValue = 0;
        	}
        	break;
        	
        default:
            return HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }        
            
    return S_OK;
}        

STDMETHODIMP CNNTPPropertyBag::PutDWord(IN DWORD dwID, IN DWORD dwValue)
/*++
Routine description:

    Put a dword property

Arguments:

    IN DWORD dwID       - The property id
    IN DWORD dwValue    - The value to be put

Return value:

    S_OK    - Success
    E_FAIL  - Fail
    E_INVALIDARG - Invalid arguments ( possibly the property not supported )
    CO_E_NOT_SUPPORTED - Operation not supported ( eg. property readonly )
--*/ 
{
	FILETIME ftBuffer;

    //
    // Validate if the property bag has been initiated
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) ) 
    	return m_PropBag.PutDWord( dwID, dwValue );
    	
    switch( dwID ) {
    
        case NEWSGRP_PROP_LASTARTICLE:
            m_pParentGroup->SetHighWatermark( dwValue );
			m_fPropChanges = TRUE;
            break;

        case NEWSGRP_PROP_FIRSTARTICLE:
            m_pParentGroup->SetLowWatermark( dwValue );
			m_fPropChanges = TRUE;
            break;

        case NEWSGRP_PROP_ARTICLECOUNT:
            m_pParentGroup->SetMessageCount( dwValue );
			m_fPropChanges = TRUE;
            break;

		case NEWSGRP_PROP_DATEHIGH:
			ftBuffer = m_pParentGroup->GetCreateDate();
			ftBuffer.dwHighDateTime = dwValue;
			m_pParentGroup->SetCreateDate( ftBuffer );
			m_fPropChanges = TRUE;
			break;

		case NEWSGRP_PROP_DATELOW:
			ftBuffer = m_pParentGroup->GetCreateDate();
			ftBuffer.dwLowDateTime = dwValue;
			m_pParentGroup->SetCreateDate( ftBuffer );
			m_fPropChanges = TRUE;
			break;

        default:
            return E_INVALIDARG;
    }

    return S_OK;
} 

STDMETHODIMP CNNTPPropertyBag::GetDWord(IN DWORD dwID, OUT PDWORD pdwValue)
/*++
Routine description:

    Get dword properties

Arguments:

    IN DWORD dwID   - The property ID.
    OUT PDWORD pdwValue - Buffer for the property value to be returned

Return value:

    S_OK    - Success
    E_FAIL  - Fail
    HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) - Invalid arguments ( possibly property not supported )
-*/
{
    _ASSERT( pdwValue );
	FILETIME	ftBuffer;

	Validate();
	if ( DRIVER_OWNED( dwID ) )
		return m_PropBag.GetDWord( dwID, pdwValue );
		
    switch( dwID ) {
    
        case NEWSGRP_PROP_GROUPID:
            *pdwValue = m_pParentGroup->GetGroupId();
            break;

        case NEWSGRP_PROP_LASTARTICLE:
            *pdwValue = m_pParentGroup->GetHighWatermark();
            break;

        case NEWSGRP_PROP_FIRSTARTICLE:
            *pdwValue = m_pParentGroup->GetLowWatermark();
            break;

        case NEWSGRP_PROP_ARTICLECOUNT:
            *pdwValue = m_pParentGroup->GetMessageCount();
            break;

		case NEWSGRP_PROP_NAMELEN:
			*pdwValue = m_pParentGroup->GetGroupNameLen();
			break;

		case NEWSGRP_PROP_DATELOW:
			ftBuffer = m_pParentGroup->GetCreateDate();
			*pdwValue = ftBuffer.dwLowDateTime;
			break;

		case NEWSGRP_PROP_DATEHIGH:
			ftBuffer = m_pParentGroup->GetCreateDate();
			*pdwValue = ftBuffer.dwHighDateTime;
			break;

		default:
            return HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }

    return S_OK;
}
        
STDMETHODIMP CNNTPPropertyBag::PutInterface(DWORD dwID, IUnknown * punkValue)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CNNTPPropertyBag::GetInterface(DWORD dwID, IUnknown * * ppunkValue)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CNNTPPropertyBag::PutBool( IN DWORD dwID, IN BOOL fValue )
/*++
Routine description:

    Put a boolean property

Arguments:

    IN DWORD dwID - The property id.
    IN BOOL  fValue- The boolean value to be put

Return value:

    S_OK    - Success
    E_FAIL  - Fail
    E_INVALIDARG - Invalid argument ( possibly the proerty not supported )
--*/
{
    //
    // Validate if the bag has been initiated
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) ) 
    	return m_PropBag.PutBool( dwID, fValue );
    	
    switch( dwID ) {

        case NEWSGRP_PROP_READONLY:
            m_pParentGroup->SetReadOnly( fValue );
			m_fPropChanges = TRUE;
            break;

		case NEWSGRP_PROP_ISSPECIAL:
			m_pParentGroup->SetSpecial( fValue );
			m_fPropChanges = TRUE;
			break;

        default:
            return E_INVALIDARG;
    }

    return S_OK;
}

STDMETHODIMP CNNTPPropertyBag::GetBool( IN DWORD dwID, OUT PBOOL pfValue )
/*++
Routine description:

    Get a boolean property

Arguments:

    IN DWORD dwID   - The property id
    OUT PBOOL pfValue   - Buffer for boolean value returned

Return value:

    S_OK    - Success
    E_FAIL  - Fail
    HRESULT_FROM_WIN32( ERROR_NOT_FOUND )- Invalid argument ( possibly the property not supported )
--*/
{
    _ASSERT( pfValue );

    //
    // Validate if the bag has been initiated
    //
    Validate();

    if ( DRIVER_OWNED( dwID ) )
    	return m_PropBag.GetBool( dwID, pfValue );
    	
    switch( dwID ) {
        
        case NEWSGRP_PROP_READONLY:
            *pfValue = m_pParentGroup->IsReadOnly();
            break;

		case NEWSGRP_PROP_ISSPECIAL:
			*pfValue = m_pParentGroup->IsSpecial();
			break;

        default:
            return HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }

    return S_OK;
}
         
STDMETHODIMP CNNTPPropertyBag::RemoveProperty(DWORD dwID)
{
	_ASSERT( DRIVER_OWNED( dwID ) );
	
	return m_PropBag.RemoveProperty( dwID );
}

/////////////////////////////////////////////////////////////////////
// CNNTPPropertyBag - Priate methods
CNNTPPropertyBag::STRING_COMP_RESULTS
CNNTPPropertyBag::ComplexStringCompare( 	IN LPCSTR sz1, 
											IN LPCSTR sz2, 
											IN DWORD dwLen )
/*++
Routine Description:

	Compare two given strings.

Arguments:

	IN LPCSTR sz1 - The first string to be compared
	IN LPCSTR sz2 - The second string to be compared
	IN DWORD dwLen - The length to compare

Return value:

	0 - String exactly the same
	1 - String not exactly the same but only varies in case
	2 - Otherwise
--*/
{
	_ASSERT( sz1 );
	_ASSERT( sz2 );
	_ASSERT( dwLen > 0 );

	LPCSTR	lpstr1 = sz1; 
	LPCSTR	lpstr2 = sz2;
	BOOL	fCaseDifferent = FALSE;

	while ( dwLen > 0 && *lpstr1 && *lpstr2 && 
			tolower(*lpstr1) == tolower(*lpstr2) ) {
		if ( *lpstr1 != *lpstr2 ) fCaseDifferent = TRUE;
		lpstr1++, lpstr2++, dwLen--;
	}

	if ( dwLen > 0 )
		return CNNTPPropertyBag::DIFFER;	// big difference between two strings
	_ASSERT( dwLen == 0 );
	if ( fCaseDifferent ) return CNNTPPropertyBag::DIFFER_IN_CASE;
	else return CNNTPPropertyBag::SAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\src\newstree.cpp ===
/*++

        newstree.cpp

        This file contains the code implementing the CNewsTreeCore object.
        There can only be one CNewsTreeCore object per Tigris server.
        Each CNewsTreeCore object is responsible for helping callers
        search and find arbitrary newsgroups.

        To support this, the CNewsTreeCore object maintains two HASH Tables -
        One hash table for searching for newsgroups by name, another
        to search by GROUP ID.
        Additionally, we maintain a linked list of (alphabetical) of all
        the newsgroups.  And finally, we maintain a thread which is used
        to periodically save newsgroup information and handle expiration.


--*/

#define         DEFINE_FHASH_FUNCTIONS
#include    "stdinc.h"
#include <time.h>
#include "nntpmsg.h"

//
// Out latest groupvar.lst version
//
#define GROUPVAR_VER    1

//template      class   TFHash< CGrpLpstr, LPSTR > ;
//template      class   TFHash< CGrpGroupId,    GROUPID > ;

char    szSlaveGroup[]  = "_slavegroup._slavegroup" ;
#define VROOT_CHANGE_LATENCY 10000

// External functions
DWORD   ScanDigits(     char*   pchBegin,       DWORD   cb );
DWORD   Scan(   char*   pchBegin,       DWORD   cb );
void    StartHintFunction( void );
void    StopHintFunction( void );
BOOL    fTestComponents( const char * szNewsgroups      );
VOID    NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    );

VOID
NntpLogEventEx(
    IN DWORD  idMessage,               // id for log message
    IN WORD   cSubStrings,             // count of substrings
    IN const  CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode,                 // error code if any
        IN DWORD  dwInstanceId                     // virtual server instance id 
    );

DWORD   
Scan(   char*   pchBegin,       DWORD   cb ) {
        //
        //      This is a utility used when reading a newsgroup
        //      info. from disk.
        //

        for( DWORD      i=0; i < cb; i++ ) {
                if( pchBegin[i] == ' ' || pchBegin[i] == '\n' ) {
                        return i+1 ;                    
                }               
        }
        return  0 ;
}

DWORD   
ScanDigits(     char*   pchBegin,       DWORD   cb ) {
        //
        //      This is a utility used when reading a newsgroup
        //      info. from disk.
        //

        for( DWORD      i=0; i < cb; i++ ) {
                if( pchBegin[i] == ' ' || pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
                        return i+1 ;                    
                }
                if( !isdigit( pchBegin[i] ) && pchBegin[i] != '-' )     {
                        return  0 ;
                }               
        }
        return  0 ;
}

DWORD   
ComputeHash( LPSTR      lpstrIn ) {
        //
        //      Compute a hash value for the newsgroup name
        //

        return  CRCHash( (BYTE*)lpstrIn, strlen( lpstrIn ) + 1 ) ;
}

DWORD   ComputeGroupIdHash(     GROUPID grpid )         {
        //
        //      Compute a hash value for the newsgroup id
        //
        
        return  grpid ;
}

LPSTR   FindFileExtension( char *szFile )   {

    int cb = lstrlen( szFile ) ;
    for( char *pch = szFile+cb; *pch != '.'; pch -- ) ;

    return  pch ;
}

//
//      static term for CNewsTreeCore objects
//
void
CNewsTreeCore::TermTree()       {
/*++

Routine Description : 

        save's the tree and releases our references on the newsgroup objects.

Arguments : 

        None.

Return Value : 

        TRUE if successfull.


--*/
        if (m_pFixedPropsFile && m_pVarPropsFile) {

                if (!SaveTree()) {
                        // log event??
                } else {
                    m_pVarPropsFile->Compact();
                }
                m_pFixedPropsFile->Term();
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                XDELETE m_pVarPropsFile;
                m_pVarPropsFile = NULL;
        }

        m_LockTables.ExclusiveLock();

        // empty our two hash tables, and remove our references on all of the
        // newsgroups
        m_HashNames.Empty();
        m_HashGroupId.Empty();
        
        CNewsGroupCore *p = m_pFirst;
        while (p && p->IsDeleted()) p = p->m_pNext;
        if (p) p->AddRef();
        m_LockTables.ExclusiveUnlock() ;

        while (p != NULL) {
                m_LockTables.ExclusiveLock();
                CNewsGroupCore *pThis = p;
                p = p->m_pNext;
                while (p && p->IsDeleted()) p = p->m_pNext;
                if ( p ) p->AddRef();
                pThis->MarkDeleted();
                m_LockTables.ExclusiveUnlock();
                pThis->Release();
                pThis->Release();
        }


        m_pVRTable->EnumerateVRoots(NULL, CNewsTreeCore::DropDriverCallback);
}

BOOL
CNewsTreeCore::StopTree()       {
/*++

Routine Description : 

        This function signals all of the background threads we create that 
        it is time to stop and shuts them down.

Arguments : 

        None.

Return Value : 
        TRUE if Successfull.

--*/

    m_LockTables.ExclusiveLock();
        m_fStoppingTree = TRUE;
        m_LockTables.ExclusiveUnlock();

        return TRUE;
}

BOOL
CNewsTreeCore::InitNewsgroupGlobals(DWORD cNumLocks)    {
/*++

Routine Description : 

        Set up all the newsgroup class globals - this is two critical sections
        used for allocating article id's

Arguments : 

        None.

Return Value : 

        None.

--*/

        //
        //      The only thing we have are critical sections for allocating 
        //      article-id's.
        //

        InitializeCriticalSection( & m_critIdAllocator ) ;
        //InitializeCriticalSection( & m_critLowAllocator ) ;

        m_NumberOfLocks = cNumLocks ;

        m_LockPathInfo = XNEW CShareLockNH[m_NumberOfLocks] ;
        
        if( m_LockPathInfo != 0 ) 
                return  TRUE ;
        else
                return  FALSE ;
}

void
CNewsTreeCore::TermNewsgroupGlobals()   {
/*++

Routine Description : 

        Release and destroy all class global object.s

Arguments : 

        None.

Return Value 

        TRUE if successfull (always succeed).

--*/

        //
        //      Done with our critical section !
        //

        if( m_LockPathInfo != 0 )       {
                XDELETE[]       m_LockPathInfo ;
                m_LockPathInfo = 0 ;
        }
        
        DeleteCriticalSection( &m_critIdAllocator ) ;
        //DeleteCriticalSection( &m_critLowAllocator ) ;
}       

void
CNewsTreeCore::RenameGroupFile()        {
/*++

Routine Description : 

        This function just renames the file containing all the group info.
        We are called during recover boot when we think the newsgroup file
        may be corrupt or whatever, and we wish to save the old version
        before we create a new one.

Arguments : 

        None.

Return Value : 

        None.

--*/




}


CNewsTreeCore::CNewsTreeCore(INntpServer *pServerObject) :
        m_pFirst( 0 ),
        m_pLast( 0 ),
        m_cGroups( 0 ),
        m_idStartSpecial( FIRST_RESERVED_GROUPID ),
        m_idLastSpecial( LAST_RESERVED_GROUPID ),
        m_idSpecialHigh( FIRST_RESERVED_GROUPID ),
        m_idSlaveGroup( INVALID_ARTICLEID ),
        m_idStart( FIRST_GROUPID ),
        m_fStoppingTree( FALSE ),
        m_idHigh( FIRST_GROUPID ),
        m_pVRTable(NULL),
        m_pFixedPropsFile(NULL),
        m_pVarPropsFile(NULL),
        m_pServerObject(pServerObject),
        m_fVRTableInit(FALSE),
        m_pInstWrapper( NULL )
{
        m_inewstree.Init(this);
        // keep a reference for ourselves
        m_inewstree.AddRef();
}

CNewsTreeCore::~CNewsTreeCore() {
        TraceFunctEnter( "CNewsTreeCore::~CNewsTreeCore" ) ;
        TermNewsgroupGlobals();
        TraceFunctLeave();
}

BOOL
CNewsTreeCore::Init( 
                        CNNTPVRootTable *pVRTable,
                        CNntpServerInstanceWrapperEx *pInstWrapper,
                        BOOL& fFatal,
                        DWORD cNumLocks,
                        BOOL fRejectGenomeGroups
                        ) {
/*++

Routine Description : 

        Initialize the news tree.
        We need to setup the hash tables, check that the root virtual root is intact
        and then during regular server start up we would load a list of newsgroups from 
        a file.

Arguments : 


Return Value : 

        TRUE if successfull.

--*/
        //
        //      This function will initialize the newstree object
        //      and read the group.lst file if it can.
        //

        TraceFunctEnter( "CNewsTreeCore::Init" ) ;

        fFatal = FALSE;
        m_fStoppingTree = FALSE;
        m_fRejectGenomeGroups = fRejectGenomeGroups;
        m_pVRTable = pVRTable;

        BOOL    fRtn = TRUE ;

        //
        // Set the instance wrapper
        //
        m_pInstWrapper = pInstWrapper;

        //
        //      Init objects global to newsgroup scope
        //
        if( !InitNewsgroupGlobals(cNumLocks) ) {
                fFatal = TRUE ;
                return FALSE ;
        }

        m_LockTables.ExclusiveLock() ;

        fRtn &= m_HashNames.Init( &CNewsGroupCore::m_pNextByName, 
                                                          10000, 
                                                          5000, 
                                                          ComputeHash,
                                                          2,
                                                          &CNewsGroupCore::GetKey,
                                                          &CNewsGroupCore::MatchKey);
        fRtn &= m_HashGroupId.Init( &CNewsGroupCore::m_pNextById, 
                                                                10000, 
                                                                5000, 
                                                                ComputeGroupIdHash,
                                                                2,
                                                                &CNewsGroupCore::GetKeyId,
                                                                &CNewsGroupCore::MatchKeyId) ;
        m_cDeltas = 0 ;         // OpenTree can call CNewsTreeCore::Dirty() while doing error checking -
                                                // so initialize it now !

        m_LockTables.ExclusiveUnlock() ;

        if( !fRtn ) {
                fFatal = TRUE ;
                return  FALSE ;
        }

        return  fRtn ;
}

BOOL
CNewsTreeCore::LoadTreeEnumCallback(DATA_BLOCK &block, void *pContext, DWORD dwOffset, BOOL bInOrder ) {
        TraceQuietEnter("CNewsTreeCore::LoadTreeEnumCallback");

        static DWORD dwHintCounter=0;
        static time_t tNextHint=0;

        // Update our hints roughly every five seconds.  We only check the
        // time every 10 groups or so..
        if( dwHintCounter++ % 10 == 0 ) {
                time_t now = time(NULL);
                if (now > tNextHint) {
                        StartHintFunction();
                        tNextHint = now + 5;
                }
        }

        CNewsTreeCore *pThis = (CNewsTreeCore *) pContext;
        INNTPPropertyBag *pPropBag;
        HRESULT hr = S_OK;

        CGRPCOREPTR pNewGroup;

        //DebugTrace((DWORD_PTR) pThis, "loading group %s/%i", block.szGroupName,
        //      block.dwGroupId);

        if (!pThis->CreateGroupInternal(block.szGroupName, 
                                                                        block.szGroupName,
                                                                        block.dwGroupId,
                                                                        FALSE,
                                                                        NULL,
                                                                        block.bSpecial,
                                                                        &pNewGroup,
                                                                        FALSE,
                                                                        TRUE,
                                    FALSE,
                                    bInOrder ))
        {
                TraceFunctLeave();
                return FALSE;
        }

        _ASSERT(pNewGroup != NULL);

        pNewGroup->SetHighWatermark(block.dwHighWaterMark);
        pNewGroup->SetLowWatermark(block.dwLowWaterMark);
        pNewGroup->SetMessageCount(block.dwArtCount);
        pNewGroup->SetReadOnly(block.bReadOnly);
        pNewGroup->SetCreateDate(block.ftCreateDate);
        pNewGroup->SetExpireLow( block.dwLowWaterMark ? block.dwLowWaterMark-1 : 0 );

        // Load the grouplist offset, we have to ask the property bag to do so
        pPropBag = pNewGroup->GetPropertyBag();
        _ASSERT( pPropBag );    // should not be zero in any case
        hr = pPropBag->PutDWord( NEWSGRP_PROP_FIXOFFSET, dwOffset );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Loading fix offset failed %x", hr );
            pPropBag->Release();
            TraceFunctLeave();
            return FALSE;
        }

    pPropBag->Release();

    //
        // Set read only to be the value we want to set last, since at this point
        // we are ready to be posted to, if readonly is false
        //
        pNewGroup->SetAllowPost( TRUE );

        //
        // Set the group to be expireable, since at this moment we are ready
        //
        pNewGroup->SetAllowExpire( TRUE );

        return TRUE;
}

// 
// the format of these records is:
// <groupid><helptext>0<moderator>0<prettyname>0
//

void
CNewsTreeCore::FlatFileOffsetCallback(void *pTree,
                                                                          BYTE *pData, 
                                                                          DWORD cData, 
                                                                          DWORD iNewOffset) 
{
        CNewsTreeCore *pThis = (CNewsTreeCore *) pTree;

        _ASSERT(cData >= 4);
        DWORD iGroupId = *((DWORD *) pData);

        CNewsGroupCore *pGroup = pThis->m_HashGroupId.SearchKey(iGroupId);
        _ASSERT(pGroup);
        if (pGroup) {
                pGroup->SetVarOffset(iNewOffset);
        }
}

//
// load a flatfile record and save the properties into the group object
//
// assumes that the hashtable lock is held in R or W mode.
//
HRESULT 
CNewsTreeCore::ParseFFRecord(BYTE *pData,
                                                         DWORD cData,
                                                         DWORD iNewOffset,
                                                         DWORD dwVersion ) 
{
        DWORD iGroupId = *((DWORD *) pData);

        char *pszHelpText = (char *) (pData + 4);
        int cchHelpText = strlen(pszHelpText);
        char *pszModerator = pszHelpText + cchHelpText + 1;
        int cchModerator = strlen(pszModerator);
        char *pszPrettyName = pszModerator + cchModerator + 1;
        int cchPrettyName = strlen(pszPrettyName);
        DWORD dwCacheHit = 0;   // Default to be no hit

        //
        // If version >= 1, we need to pick up property "dwCacheHit"
        //
        if ( dwVersion >= 1 ) {
            PBYTE pb = PBYTE(pszPrettyName + cchPrettyName + 1);
            CopyMemory( &dwCacheHit, pb, sizeof( DWORD ) );
        }

        CNewsGroupCore *pGroup = m_HashGroupId.SearchKey(iGroupId);
        if (pGroup) {
                if (cchHelpText) pGroup->SetHelpText(pszHelpText, cchHelpText+1);
                if (cchModerator) pGroup->SetModerator(pszModerator, cchModerator+1);
                if (cchPrettyName) pGroup->SetPrettyName(pszPrettyName, cchPrettyName+1);
                pGroup->SetVarOffset(iNewOffset);
                pGroup->SetCacheHit( dwCacheHit );

                //
            // Whenever the version is old, we'll mark that the group's var property
            // has been changed, so that we'll force the record to be re-written into
            // flatfile, with a most current version number
            //
            if ( dwVersion < GROUPVAR_VER ) {
                pGroup->ChangedVarProps();
            }
        } else {
                return E_FAIL;
        }
        
        return S_OK;
}

//
// save the variable length properties into a flatfile record.  since the
// max length of these properties is 512 bytes each, and there are 3 of
// them we shouldn't be able to overflow a flatfile record.
//
HRESULT 
CNewsTreeCore::BuildFFRecord(CNewsGroupCore *pGroup,
                                                         BYTE *pData,
                                                         DWORD *pcData) 
{
        *pcData = 0;
        const char *psz; 
        DWORD cch;
        DWORD dwCacheHit;

        pGroup->SavedVarProps();

        _ASSERT(MAX_RECORD_SIZE > 512 + 512 + 512 + 4);

        // save the group id
        DWORD dwGroupId = pGroup->GetGroupId();
        memcpy(pData + *pcData, &dwGroupId, sizeof(DWORD)); *pcData += 4;

        // save the help text (including the trailing 0);
        psz = pGroup->GetHelpText(&cch); 
        if (cch == 0) {
                pData[*pcData] = 0; (*pcData)++;
        } else {
                memcpy(pData + *pcData, psz, cch ); *pcData += cch ;
        }
        _ASSERT(*pcData < MAX_RECORD_SIZE);

        // save the moderator (including the trailing 0);
        psz = pGroup->GetModerator(&cch); 
        if (cch == 0) {
                pData[*pcData] = 0; (*pcData)++;
        } else {
                memcpy(pData + *pcData, psz, cch ); *pcData += cch ;
        }
        _ASSERT(*pcData < MAX_RECORD_SIZE);

        // save the help text (including the trailing 0);
        psz = pGroup->GetPrettyName(&cch); 
        if (cch == 0) {
                pData[*pcData] = 0; (*pcData)++;
        } else {
                memcpy(pData + *pcData, psz, cch ); *pcData += cch ;
        }       
        _ASSERT(*pcData < MAX_RECORD_SIZE);

        // Save the cache hit count
        dwCacheHit = pGroup->GetCacheHit();
    memcpy( pData + *pcData, &dwCacheHit, sizeof( DWORD ) );
    *pcData += sizeof( DWORD );

        // if the record contains no useful data then we don't need to save it.
        if (*pcData == sizeof(DWORD) + 3 * sizeof(char)) *pcData = 0;

        return S_OK;
}

BOOL
CNewsTreeCore::LoadTree(char *pszFixedPropsFilename, 
                                                char *pszVarPropsFilename,
                                                BOOL&   fUpgrade,
                                                DWORD   dwInstanceId,
                                                BOOL    fVerify ) 
{
        TraceFunctEnter("CNewsTreeCore::LoadTree");
        CHAR    szOldListFile[MAX_PATH+1];
        BOOL    bFatal = FALSE;

        //
        // Initialize upgrade to be false
        //
        fUpgrade = FALSE;

        _ASSERT(pszFixedPropsFilename != NULL);
        _ASSERT(pszVarPropsFilename != NULL);

        m_pFixedPropsFile = XNEW CFixPropPersist(pszFixedPropsFilename);
        
        if (m_pFixedPropsFile == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
        }

        m_pVarPropsFile = XNEW CFlatFile(pszVarPropsFilename,
                                                                        "",
                                                                        this,
                                                                        FlatFileOffsetCallback,
                                                                        (DWORD) 'VprG');
        if (m_pVarPropsFile == NULL) {
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                TraceFunctLeave();
                return FALSE;
        }

        m_LockTables.ExclusiveLock() ;

        if (!m_pFixedPropsFile->Init(TRUE, this, &m_idHigh, CNewsTreeCore::LoadTreeEnumCallback)) {

            // If it's a old version group.lst, we'll try the old way to parse it
            if ( GetLastError() == ERROR_OLD_WIN_VERSION ) {

            // Delete the fix prop object and move the old group.lst
            strcpy( szOldListFile, pszFixedPropsFilename );
            strcat( szOldListFile, ".bak" );
            DeleteFile( szOldListFile );
            if ( !MoveFile( pszFixedPropsFilename, szOldListFile ) ) {
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                XDELETE m_pVarPropsFile;
                m_pVarPropsFile = NULL;
                m_LockTables.ExclusiveUnlock();
                TraceFunctLeave();
                return FALSE;
            }

            // Init the fix prop file again: this time since the file doesn't exist, 
            // a new file will be created
            if ( !m_pFixedPropsFile->Init(TRUE, this, NULL, CNewsTreeCore::LoadTreeEnumCallback)) {
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                XDELETE m_pVarPropsFile;
                m_pVarPropsFile = NULL;
                m_LockTables.ExclusiveUnlock();
                TraceFunctLeave();
                return FALSE;
            }
            
                if ( !OpenTree( szOldListFile, dwInstanceId, fVerify, bFatal, FALSE ) || bFatal ) {

                    // No one can recognize this file, bail
                    m_pFixedPropsFile->Term();
                        XDELETE m_pFixedPropsFile;
                        m_pFixedPropsFile = NULL;
                        XDELETE m_pVarPropsFile;
                        m_pVarPropsFile = NULL;

                        // we restore the group.lst file
                        DeleteFile( pszFixedPropsFilename );
                        _VERIFY( MoveFile( szOldListFile, pszFixedPropsFilename ) );
                        
                        m_LockTables.ExclusiveUnlock();
                        TraceFunctLeave();
                        return FALSE;
            }

            // Set upgrade to be true
            fUpgrade = TRUE;

            // OK, we may delete the old bak file
            _VERIFY( DeleteFile( szOldListFile ) );
            
        } else {

            // fatal error, we should fail
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
            XDELETE m_pVarPropsFile;
                    m_pVarPropsFile = NULL;
                m_LockTables.ExclusiveUnlock();
                    TraceFunctLeave();
                return FALSE;
        }
        } 
        
        BYTE pData[MAX_RECORD_SIZE];
        DWORD cData = MAX_RECORD_SIZE;
        DWORD iOffset;
        DWORD dwVersion;
        DWORD dwHintCounter = 0;
        time_t tNextHint = 0;

        //
    // Enumerate all the records in flatfile
        //
        HRESULT hr = m_pVarPropsFile->GetFirstRecord(pData, &cData, &iOffset, &dwVersion );
        while (hr == S_OK) {
                // Update our hints roughly every five seconds.  We only check the
                // time every 10 groups or so..
                if( dwHintCounter++ % 10 == 0 ) {
                        time_t now = time(NULL);
                        if (now > tNextHint) {
                                StartHintFunction();
                                tNextHint = now + 5;
                        }
            }

                hr = ParseFFRecord(pData, cData, iOffset, dwVersion );
                if (SUCCEEDED(hr)) {
                    cData = MAX_RECORD_SIZE;
                    hr = m_pVarPropsFile->GetNextRecord(pData, &cData, &iOffset, &dwVersion );
                }
        }

        if (FAILED(hr)) {
                m_pFixedPropsFile->Term();
                XDELETE m_pFixedPropsFile;
                m_pFixedPropsFile = NULL;
                XDELETE m_pVarPropsFile;
                m_pVarPropsFile = NULL;
                ErrorTrace((DWORD_PTR) this, "enum varprops file failed with %x", hr);
                m_LockTables.ExclusiveUnlock();
                TraceFunctLeave();
                return FALSE;
        }

        m_LockTables.ExclusiveUnlock() ;

        TraceFunctLeave();
        return TRUE;
}

BOOL
CNewsTreeCore::SaveGroup(INNTPPropertyBag *pGroup) {
        _ASSERT(pGroup != NULL);
        return m_pFixedPropsFile->SetGroup(pGroup, ALL_FIX_PROPERTIES);
}

BOOL
CNewsTreeCore::SaveTree( BOOL fTerminate ) {
        m_LockTables.ExclusiveLock();

        BYTE pData[MAX_RECORD_SIZE];
        DWORD cData;
        INNTPPropertyBag *pPropBag;
        BOOL    bInited = TRUE;
        BOOL    bToSave = TRUE;
        DWORD dwHintCounter=0;
        time_t tNextHint=0;
        DWORD lastError = NO_ERROR;

    _ASSERT( m_pFixedPropsFile );
        if ( !m_pFixedPropsFile->SaveTreeInit() ) {
            lastError = GetLastError();
            // In rtl, this is non-fatal, we just don't 
            // use the backup ordered list file
            bToSave = bInited = FALSE;
        }

        CNewsGroupCore *p = m_pFirst;
        while (p != NULL) {
                // Update our hints roughly every five seconds.  We only check the
                // time every 10 groups or so..
                if( dwHintCounter++ % 10 == 0 ) {
                        time_t now = time(NULL);
                        if (now > tNextHint) {
                                StopHintFunction();
                                tNextHint = now + 5;
                        }
                }

                if (!(p->IsDeleted())) {

                    //
                    // Before I save all the properties, i need to make everybody
                    // know that we are dieing and we don't want anybody to post
                    // or expire
                    //
                    p->SetAllowExpire( FALSE );
                    p->SetAllowPost( FALSE );

                        //
                        // BUGBUG - event logs if any of these operations fail
                        //
                        if (p->DidVarPropsChange() || p->ShouldCacheXover() ) {
                                if (p->GetVarOffset() != 0) {
                                        m_pVarPropsFile->DeleteRecord(p->GetVarOffset());
                                } 
                                if (!(p->IsDeleted())) {
                                        BuildFFRecord(p, pData, &cData);
                                        if (cData > 0) m_pVarPropsFile->InsertRecord(   pData, 
                                                                                        cData, 
                                                                                        NULL,
                                                                                        GROUPVAR_VER );
                                }
                        }

                        // Save it to the ordered backup file
                        if ( bToSave ) {
                        pPropBag = p->GetPropertyBag();
                        _ASSERT( pPropBag );    // this shouldn't fail
                        if ( !m_pFixedPropsFile->SaveGroup( pPropBag ) ) {
                            // This is still fine in rtl
                            lastError = GetLastError();
                            bToSave = FALSE;
                        }
                pPropBag->Release();
            }

            //
            // If we are not terminateing, we should allow post and expire again
            //
            if ( !fTerminate ) {
                p->SetAllowExpire( TRUE );
                p->SetAllowPost( TRUE );
            }
                        
                }
                p = p->m_pNext;
        }

        // Close the savetree process in fixprop stuff, telling it 
        // whether we want to void it
        if ( bInited ) {
            _VERIFY( m_pFixedPropsFile->SaveTreeClose( bToSave ) );
        } 

        if (!bToSave) {
                // An error occurred while trying to save.
                NntpLogEventEx(NNTP_SAVETREE_FAILED,
                        0, (const CHAR **)NULL, 
                        lastError,
                        m_pInstWrapper->GetInstanceId()) ;
        }

        m_LockTables.ExclusiveUnlock(); 

        return TRUE;
}

BOOL
CNewsTreeCore::CreateSpecialGroups()    {
/*++

Routine Description : 

        This function creates newsgroups which have 'reserved' names which 
        we use in a special fashion for master slave etc...

Arguments : 

        None.

Return Value : 

        TRUE if Successfull
        FALSE otherwise.

--*/

        CNewsGroupCore *pGroup;

        char*   sz = (char*)szSlaveGroup ;

    m_LockTables.ExclusiveLock();

    //
    // If the tree has already been stopped, return false
    //
    if ( m_fStoppingTree ) {
        m_LockTables.ExclusiveUnlock();
        return FALSE;
    }
    
        if( (pGroup = m_HashNames.SearchKey(sz)) )      {
                m_idSlaveGroup = pGroup->GetGroupId() ;
        }       else    {
                if( !CreateGroupInternal(   sz, 
                                            NULL,           //no native name
                                            m_idSlaveGroup, 
                                            FALSE,          //not anonymous
                                            NULL,           //system token
                                            TRUE            //is special group
                                        )) {
                    m_LockTables.ExclusiveUnlock();
                        return  FALSE ;
                }
        }

        //
        // Slave group should be non-read only, since we set group to be read only
        // before we append the group to list, we'll now set it back
        //
        pGroup = m_HashNames.SearchKey(sz);
        if ( pGroup ) {
            pGroup->SetAllowPost( TRUE );
            pGroup->SetAllowExpire( TRUE );
        }
        
        m_LockTables.ExclusiveUnlock();
        return  TRUE ;
}

void
CNewsTreeCore::Dirty() {
/*++

Routine Description : 

        This function marks a counter which lets our background thread know that
        the newstree has been changed and should be saved to a file again.

Arguments : 

        None.

Return Value : 

        None.

--*/
        //
        //      Mark the newstree as dirty so that the background thread will save our info.
        //

        InterlockedIncrement( &m_cDeltas ) ;

}

void
CNewsTreeCore::ReportGroupId(   
                                        GROUPID groupid 
                                        ) {
/*++

Routine Description : 

        This function is used during boot up to report the group id's that are read
        from the file where we saved all the newsgroups.  We want to figure out what
        the next 'legal' group id would be that we can use.

Arguments ;

        groupid - the Group ID that was found in the file

Return Value : 

        None.
        
--*/


        //
        //      This function is used during bootup when we read groupid's from disk.
        //      We use it to maintain a high water mark of groupid's so that the next
        //      group that is created gets a unique id.
        //
        if(     groupid >= m_idStartSpecial && groupid <= m_idLastSpecial ) {
                if( groupid > m_idSpecialHigh ) {
                        m_idSpecialHigh = groupid ;
                }
        }       else    {
                if( groupid >= m_idHigh ) {
                        m_idHigh = groupid + 1;
                }
        }
}


#if 0
BOOL
CNewsTreeCore::DeleteGroupFile()        {
/*++

Routine Description : 

        This function deletes the group.lst file (The file that
        we save the newstree to.)
        
Arguments : 

        None.

Return Value : 

        TRUE if successfull.
        FALSE otherwise.  We will preserver GetLastError() from the DeleteFile() call.

--*/

        
        return  DeleteFile( m_pInstance->QueryGroupListFile() ) ;

}


BOOL
CNewsTreeCore::VerifyGroupFile( )       {
/*++

Routine Description : 

        This function checks that the group.lst file is intact and 
        appears to be valid.  We do this by merely confirming some check sum
        bytes that should be the last 4 bytes at the end of the file.

Arguments : 

        None.

Return Value : 

        TRUE if the Group.lst file is good.
        FALSE if corrupt or non-existant.

--*/

        CMapFile        map(    m_pInstance->QueryGroupListFile(), FALSE, 0 ) ;
        if( map.fGood() ) {

                DWORD   cb ;
                char*   pchBegin = (char*)map.pvAddress( &cb ) ;

                DWORD   UNALIGNED*      pdwCheckSum = (DWORD UNALIGNED *)(pchBegin + cb - 4);
                
                if( *pdwCheckSum != INNHash( (BYTE*)pchBegin, cb-4 ) ) {
                        return  FALSE ;
                }       else    {
                        return  TRUE ;
                }
        }
        return  FALSE ;
}

#endif


BOOL
CNewsTreeCore::OpenTree(        
                LPSTR   szGroupListFile,
                DWORD   dwInstanceId,
                                BOOL    fRandomVerifies, 
                                BOOL&   fFatalError, 
                                BOOL    fIgnoreChecksum                         )       {
/*++

Routine Description : 

        This function reads in the file which contains all of the group information.
        

Arguments : 

        fRandomVerifies -       If TRUE then the server should check some fraction of 
                the groups within the file against the harddisk. (Ensure directory exists etc...)

        fFatailError -  OUT parameter which the function can use to indicate that an
                extremely bad error occurred reading the file and the server should not boot
                in its normal mode.

        fIgnoreChecksum - If TRUE then we should not check the checksum in the file 
                against the contents.

Return Value : 
        
        TRUE if successfull FALSE otherwise.

--*/

        //
        //      This function restorces the newstree from its saved file.
        //

        DWORD   dwHintCounter = 0 ;
        DWORD   cVerifyCounter = 1 ;
        BOOL    fVerify = FALSE ;
        fFatalError = FALSE ;
        CHAR    szGroupName[MAX_NEWSGROUP_NAME+1];
        CHAR    szNativeName[MAX_NEWSGROUP_NAME+1];
        DWORD   dwLowWatermark;
        DWORD   dwHighWatermark;
        DWORD   dwArticleCount;
        DWORD   dwGroupId;
        BOOL    bReadOnly = FALSE;
        FILETIME    ftCreateDate;
        BOOL    bSpecial = FALSE;
        BOOL    bHasNativeName;
        LPSTR   lpstrNativeName;
        INNTPPropertyBag *pPropBag;

        TraceFunctEnter("CNewsTreeCore::OpenTree");

        CMapFile        map( szGroupListFile,  FALSE, 0 ) ;

        // missing group.lst file is not fatal 
        if( !map.fGood() ) {
                return FALSE;
        }

        //
        //      Verify checksum on group.lst file - bail if incorrect !
        //

        DWORD   cb ;
        char*   pchBegin = (char*)map.pvAddress( &cb ) ;

        if( !fIgnoreChecksum ) {
                        
                DWORD   UNALIGNED*      pdwCheckSum = (DWORD UNALIGNED *)(pchBegin + cb - 4);
                        
                if( *pdwCheckSum != INNHash( (BYTE*)pchBegin, cb-4 ) ) {
                        PCHAR   args[2] ;
                        CHAR    szId[20];
                        _itoa( dwInstanceId, szId, 10 );
                        args[0] = szId;
                        args[1] = szGroupListFile ;


                        NntpLogEvent(   NNTP_GROUPLST_CHKSUM_BAD,
                                                        2, 
                                                        (const char **)args, 
                                                        0 
                                                        ) ;
                        return  FALSE ;
                }
        }
        cb -= 4 ;

        // calculate random verification skip number
        // 91 is heuristically the avg length in bytes of a newsgroup entry in group.lst
        // Always verify approx 10 groups independent of the size of the newstree
        DWORD cGroups = (cb+4)/91;
        DWORD cQ = cGroups / 10;
        DWORD cR = cGroups % 10;
        DWORD cSkipFactor = cR >= 25 ? cQ+1 : cQ;
        if(!cSkipFactor) ++cSkipFactor; // min should be 1

        _ASSERT(cSkipFactor);

        // read in the DWORD on the first line - this is the minimum m_idHigh we should use
        // if this DWORD is not present - m_idHigh = max of all group ids + 1
        DWORD cbIdHigh, idHigh;
        if( (cbIdHigh = ScanDigits( pchBegin, cb )) != 0 )      
        {
                idHigh = atoi( pchBegin ) ;
                ReportGroupId( idHigh-1 ) ;
                DebugTrace((DWORD_PTR)this, "idHigh = %d", idHigh );
                pchBegin += cbIdHigh ;
                cb -= cbIdHigh ;
        }

        //
        //      ok, now read group.lst line by line and add the groups to the newstree
        //
        while( cb != 0 ) {

                if( fRandomVerifies && (cVerifyCounter ++ % cSkipFactor == 0 ) && (cVerifyCounter<15) ) {
                        fVerify = TRUE ;
                }       else    {
                        fVerify = FALSE ;
                }

        // Read the fix prop stuff
                DWORD   cbUsed = 0 ;
                BOOL    fInit = ParseGroupParam(    pchBegin, 
                                                    cb, 
                                                    cbUsed, 
                                                    szGroupName,
                                                    szNativeName,
                                                    dwGroupId,
                                                    bSpecial,
                                                    dwHighWatermark,
                                                    dwLowWatermark,
                                                    dwArticleCount,
                                                    bReadOnly,
                                                    bHasNativeName,
                                                    ftCreateDate ) ;
                if( cbUsed == 0 ) {

                        // Fatal Error - blow out of here
                        PCHAR   args[2] ;
                        CHAR    szId[20];
                        _itoa(dwInstanceId, szId, 10 );
                        args[0] = szId;
                        args[1] = szGroupListFile;
                        NntpLogEvent(
                                                NNTP_GROUPLIST_CORRUPT,
                                                2,
                                                (const char **)args,
                                                0 
                                                ) ;

                        goto OpenTree_ErrExit;
                }       else    {
                        if( fInit ) {
                            CGRPCOREPTR pGroup;
                            
                            // Now create the group
                            _ASSERT( strlen( szGroupName ) <= MAX_NEWSGROUP_NAME );
                            _ASSERT( strlen( szNativeName ) <= MAX_NEWSGROUP_NAME );
                            _ASSERT( dwHighWatermark >= dwLowWatermark ||
                                        dwLowWatermark - dwHighWatermark == 1 );
                            lpstrNativeName = bHasNativeName ? szNativeName : NULL;
                            if ( !CreateGroupInternal(  szGroupName,
                                                        lpstrNativeName,
                                                        dwGroupId,
                                                        FALSE,
                                                        NULL,
                                                        bSpecial,
                                                        &pGroup,
                                                        FALSE,
                                                        TRUE,
                                                        TRUE ) ) {
                                        goto OpenTree_ErrExit;
                                } else {

                                    // keep setting other properties
                                    _ASSERT( pGroup );
                                    pGroup->SetHighWatermark( dwHighWatermark );
                                    pGroup->SetLowWatermark( dwLowWatermark );
                                    pGroup->SetMessageCount( dwArticleCount );
                    pGroup->SetReadOnly( bReadOnly );
                                    pGroup->SetCreateDate( ftCreateDate );
                                    pGroup->SetExpireLow( dwLowWatermark ? dwLowWatermark-1 : 0 );

                                    //
                                    // The last thing to set is read only, so that we can
                                    // allow posting, expire to work on this group since we 
                                    // have setup all the properties already
                                    //
                                    pGroup->SetAllowPost( TRUE );

                                    //
                                    // Also say the group can be expired
                                    //
                                    pGroup->SetAllowExpire( TRUE );

                                    // Add this group object to the fix prop file
                                pPropBag = pGroup->GetPropertyBag();
                                if ( !m_pFixedPropsFile->AddGroup( pPropBag ) ) {
                                    ErrorTrace( 0, "Add group failed %d", GetLastError() );

                                    // this is fatal, since coming here, the fix prop file
                                    // should be brand new
                                    goto OpenTree_ErrExit;
                                }

                                // Since fixprop doesn't know releasing prop bags ...
                                pPropBag->Release();
                                pPropBag = NULL;
                                }
                        }       else    {
                                //      
                                // How should we handle an error 
                                if( fVerify /*|| m_pInstance->RecoverBoot()*/ ) {
                                        goto OpenTree_ErrExit;
                                }
                        }
                }
                pchBegin += cbUsed ;
                cb -= cbUsed ;

                if( dwHintCounter++ % 200 == 0 ) {

                        StartHintFunction() ;
                }                               
        }

        return  TRUE ;

OpenTree_ErrExit:

        fFatalError = TRUE;
        return  FALSE ;
}

BOOL
CNewsTreeCore::ParseGroupParam( 
                                char    *pchBegin, 
                                DWORD   cb,     
                                DWORD   &cbOut,
                                LPSTR   szGroupName,
                                LPSTR   szNativeName,
                                DWORD&   dwGroupId,
                                BOOL&    bSpecial,
                                DWORD&   dwHighWatermark,
                                DWORD&   dwLowWatermark,
                                DWORD&   dwArticleCount,
                                BOOL&    bReadOnly,
                                BOOL&    bHasNativeName,
                                FILETIME&    ftCreateDate
                                ){
/*++

Routine description : 

        Read an newsgroup data from the saved format.

Arguments : 

        pchBegin - buffer containing article data
        cb - Number of bytes to the end of the buffer
        &cbOut - Out parameter, number of bytes read to 
                make up one CNewsgroup object
        fVerify - if TRUE check physical articles for consistency

Return Value : 

        TRUE if successfull
        FALSE otherwise.

--*/
        //
        //      This function is the partner of SaveToBuffer - 
        //      It will parse newsgroup data that has been written with
        //      SaveToBuffer.  We are intentionally unforgiving, extra
        //      spaces, missing args etc.... will cause us to return
        //      cbOut as 0.  This should be used by the caller to 
        //      entirely bail processing of the newsgroup data file.
        //
        //      Additionally, our BOOL return value is used to indicate
        //      whether a successfully parsed newsgroup appears to be intact.
        //      If directories don't exist etc... we will return FALSE and 
        //      cbOut NON ZERO.  The caller should use this to delete the 
        //      newsgroup from its tables.
        //

        //
        //      cbOut should be the number of bytes we consumed -
        //      we will only return non 0 if we successfully read every field from the file !
        //
        cbOut = 0 ;
        BOOL    fReturn = TRUE ;

        TraceFunctEnter( "CNewsGroupCore::Init( char*, DWORD, DWORD )" ) ;

        BOOL    fDoCheck = FALSE ;      // Should we check article integrity - if newsgroups move !

        DWORD   cbScan = 0 ;
        DWORD   cbRead = 0 ;
        DWORD   cbGroupName = 0 ;

        // scan group name
        if( (cbScan = Scan( pchBegin+cbRead, cb-cbRead )) == 0 ) {
                return  FALSE ;
        }       else    {
                CopyMemory( szGroupName, pchBegin, cbScan ) ;
                szGroupName[cbScan-1] = '\0' ;
                DebugTrace((DWORD_PTR) this, "Scanned group name -=%s=", szGroupName ) ;
        }

        cbRead += cbScan ;

    // scan vroot path - discarded
        if( (cbScan = Scan( pchBegin+cbRead, cb-cbRead )) == 0 ) {
                return  FALSE ;
        }       
        
        cbRead+=cbScan ;

    // scan low watermark
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 ) {
                return  FALSE ;
        }       else    {

                dwLowWatermark = atol( pchBegin + cbRead ) ;

#if 0
                if( m_artLow != 0 ) 
                        m_artXoverExpireLow = m_artLow - 1 ;
                else
                        m_artXoverExpireLow = 0 ;
#endif
                
        
        }

        cbRead += cbScan ;

        // scan high watermark
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;         
        }       else    {
                
                dwHighWatermark = atol( pchBegin + cbRead ) ;

        // I don't know why mcis group.lst file saved the high
        // watermark one higher than the real
        if ( dwHighWatermark > 0 ) dwHighWatermark--;

        }

        cbRead += cbScan ;

    // scan message count
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;         
        }       else    {

                dwArticleCount = atol( pchBegin + cbRead ) ;

        }

        cbRead += cbScan ;

    // scan group id
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;         
        }       else    {

                dwGroupId = atol( pchBegin + cbRead ) ;
        }

        DebugTrace((DWORD_PTR) this, "Scanned m_artLow %d m_artHigh %d m_cArticle %d m_groupid %x", 
                        dwLowWatermark, dwHighWatermark, dwArticleCount, dwGroupId ) ;

        cbRead += cbScan ;

    // scan time stamp
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;         
        }       else    {

                ftCreateDate.dwLowDateTime = atoi( pchBegin + cbRead ) ;

        }

        cbRead += cbScan ;

        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                return  FALSE ;         
        }       else    {

                ftCreateDate.dwHighDateTime = atoi( pchBegin + cbRead ) ;

        }

        cbRead += cbScan ;

    // scan read only bit
        if( (cbScan = ScanDigits( pchBegin + cbRead, cb-cbRead )) == 0 )        {
                bReadOnly = FALSE ;             // default if we dont find this flag !
        }       else    {

                bReadOnly = atoi( pchBegin + cbRead ) ;

        }

        cbRead += cbScan ;

        if( *(pchBegin+cbRead-1) == '\n' ) {
                cbRead--;
        }

    // scan native name
        if( (cbScan = Scan( pchBegin+cbRead, cb-cbRead )) <= 1 ) {
                // did not find native group name, NULL it to save space !!
                bHasNativeName = FALSE;
        }       else    {
                CopyMemory( szNativeName, pchBegin+cbRead, cbScan ) ;
                szNativeName[cbScan-1] = '\0' ;
                DebugTrace((DWORD_PTR) this, "Scanned native group name -=%s=", szNativeName ) ;
        bHasNativeName = TRUE;
        }

        cbRead += cbScan ;

        if( pchBegin[cbRead-1] != '\n' && pchBegin[cbRead-1] != '\r' ) {
                return FALSE ;
        }
        while( cbRead < cb && (pchBegin[cbRead] == '\n' || pchBegin[cbRead] == '\r') ) {
                cbRead ++ ;
        }

        //
        //      Return to the caller the number of bytes consumed
        //      We may still fail - but with this info the caller can continue reading the file !
        //      
        cbOut = cbRead ;

        _ASSERT( cbOut >= cbRead ) ;

        //
        //      If we've reached this point, then we've successfully read the entry in the group.lst
        //      file.  Now we will do some validity checking !
        //

	return	fReturn ;
}

void
CNewsTreeCore::AppendList(      CNewsGroupCore* pGroup )        {
        //
        //      This function appends a newsgroup to the list of newsgroups.
        //      The real work horse is InsertList, however this function lets
        //      us speed up insertion when we are fairly confident the newgroup
        //      being added as at the end.
        //      (ie. when we save newsgroups to a file, we save them alphabetically.
        //      so this is a good function for this use.)
        //

        _ASSERT( pGroup != 0 ) ;

        if( m_pFirst == 0 ) {
                Assert( m_pLast == 0 ) ;
                m_pFirst = pGroup ;
                m_pLast = pGroup ;
        }       else    {

                CNewsCompareName        comp( pGroup ) ;

                if( comp.IsMatch( m_pLast ) < 0 ) {
                        m_pLast->m_pNext = pGroup ;
                        pGroup->m_pPrev = m_pLast ;
                        m_pLast = pGroup ;
                }       else    {
                        InsertList( pGroup, 0 ) ;
                }
        }
}

void
CNewsTreeCore::InsertList( CNewsGroupCore   *pGroup,    CNewsGroupCore  *pParent ) {
        //
        //      Insert a newsgroup into the tree.
        //      The parent newsgroup is provided (optionally may be 0), as it can be used
        //      to speed inserts since we know the child will follow
        //      in lexicographic order shortly after the parent.
        //

        _ASSERT( pGroup != 0 ) ;

        CNewsCompareName    comp( pGroup ) ;

        if( m_pFirst == 0 ) {
                Assert( m_pLast == 0 ) ;
                m_pFirst = pGroup ;
                m_pLast = pGroup ;
        }   else    {
                Assert( m_pLast != 0 ) ;

                CNewsGroupCore  *p = m_pFirst ;
                if( pParent && comp.IsMatch( pParent ) < 0 )
                        p = pParent ;

                int i ;
                while( (p && (i = comp.IsMatch( p )) < 0) || (p && p->IsDeleted()) ) {
                        p = p->m_pNext ;
                }

                if( p && i == 0 ) {
                        // Assert( p == pGroup ) ;
                        // duplicate found - p should not be deleted else we would have skipped it
                        _ASSERT( !p->IsDeleted() );

                }   else    {
                        if( p ) {

                                _ASSERT( !p->IsDeleted() );
                                pGroup->m_pPrev = p->m_pPrev ;
                                pGroup->m_pNext = p ;
                                if( p->m_pPrev )
                                        p->m_pPrev->m_pNext = pGroup ;
                                p->m_pPrev = pGroup ;
                        }   else {
                                m_pLast->m_pNext = pGroup ;
                                pGroup->m_pPrev = m_pLast ;
                                m_pLast = pGroup ;
                        }

                        if( p == m_pFirst ) {
                                _ASSERT( pGroup != 0 ) ;
                                m_pFirst = pGroup ;
                        }
                }
        }
}

//
// !! This function should NOT be used. Newsgroup objects should unlink themselves
// in their destructors.
void
CNewsTreeCore::RemoveList(  CNewsGroupCore  *pGroup ) {
        //
        //      Remove a newsgroup from the doubly linked list !
        //

        m_cDeltas ++ ;

        if( pGroup->m_pPrev != 0 ) {
                pGroup->m_pPrev->m_pNext = pGroup->m_pNext ;
        }   else    {
                _ASSERT( pGroup->m_pNext != 0 || m_pLast == pGroup ) ;
                m_pFirst = pGroup->m_pNext ;
        }

        if( pGroup->m_pNext != 0 ) {
                pGroup->m_pNext->m_pPrev = pGroup->m_pPrev ;
        }   else    {
                m_pLast = pGroup->m_pPrev ;
                _ASSERT( pGroup->m_pPrev != 0 || m_pFirst == pGroup ) ;
        }

        pGroup->m_pPrev = 0;
        pGroup->m_pNext = 0;
}

BOOL
CNewsTreeCore::Insert( CNewsGroupCore   *pGroup,   CNewsGroupCore  *pParent ) {
        //
        //      Insert a newsgroup into all hash tables and linked lists !
        //      Parent newsgroup provided to help optimize inserts into linked lists
        //

        m_cDeltas++ ;

        if( !m_HashNames.InsertDataHash( pGroup->GetGroupNameHash(), *pGroup ) ) {
                return FALSE;
        }

        if( !m_HashGroupId.InsertData( *pGroup ) ) {
                m_HashNames.DeleteData( pGroup->GetName() );
                return FALSE;
        }

        InsertList( pGroup, pParent ) ;
//      pGroup->AddRef();
        m_cGroups ++ ;

        return TRUE;
}

BOOL
CNewsTreeCore::InsertEx( CNewsGroupCore   *pGroup ) {
        //
        //      Insert a newsgroup into m_HashNames hash table and linked lists !
        //      Parent newsgroup provided to help optimize inserts into linked lists
        //

        m_cDeltas++ ;

        if( !m_HashNames.InsertData( *pGroup ) ) {
                return FALSE;
        }

        InsertList( pGroup, 0 ) ;
//      pGroup->AddRef();
        m_cGroups ++ ;

        return TRUE;
}

BOOL
CNewsTreeCore::HashGroupId( CNewsGroupCore   *pGroup ) {
        //
        //      Insert a newsgroup into m_HashGroupId hash table
        //
        m_LockTables.ExclusiveLock() ;

        if( !m_HashGroupId.InsertData( *pGroup ) ) {
                m_HashNames.DeleteData( pGroup->GetName() );
                pGroup->MarkDeleted();
                m_LockTables.ExclusiveUnlock() ;
                return FALSE;
        }
        m_LockTables.ExclusiveUnlock() ;

        return TRUE;
}

BOOL
CNewsTreeCore::Append(  CNewsGroupCore  *pGroup ) {
        //
        //      Append a newsgroup - newsgroup should fall on end of list
        //      or there will be a performance price to finds its proper location !
        //

        m_cDeltas ++ ;

        if( !m_HashNames.InsertData( *pGroup ) ) {
                return FALSE;
        }

        if( !m_HashGroupId.InsertData( *pGroup ) ) {
                m_HashNames.DeleteData( pGroup->GetName() );
                return FALSE;
        }

        AppendList( pGroup ) ;
//      pGroup->AddRef();
        m_cGroups ++ ;

        return TRUE;
}

CGRPCOREPTRHASREF       
CNewsTreeCore::GetGroup(        
                                const   char*   lpstrGroupName, 
                                int cb 
                                ) {
/*++

Routine Description : 

        Find a newsgroup based on a name.  We may desctuctively
        use the callers buffer, so we will convert the string 
        to lower case in place before doing the search.

Arguments : 

        lpstrGroupName - Name of the group to find
        cb - number of bytes in the name

Return Value : 

        Pointer to Newsgroup, NULL if not found.

--*/

        _ASSERT( lpstrGroupName != NULL ) ;

        TraceQuietEnter(        "CNewsTreeCore::GetGroup" ) ;

        CGRPCOREPTR     pGroup = 0 ;
        if (m_fStoppingTree) return (CNewsGroupCore *)pGroup;     

        _strlwr( (char*)lpstrGroupName ) ;

        m_LockTables.ShareLock() ;

        if (m_fStoppingTree) {
                m_LockTables.ShareUnlock();
                return (CNewsGroupCore *)pGroup;  
        }

        char*   szTemp = (char*)lpstrGroupName ;

        pGroup = m_HashNames.SearchKey(szTemp);
        m_LockTables.ShareUnlock() ;
        return  (CNewsGroupCore *)pGroup ;
}


CGRPCOREPTRHASREF       
CNewsTreeCore::GetGroupPreserveBuffer(  
                                                const   char*   lpstrGroup,     
                                                int     cb 
                                                )       {
/*++

Routine Description : 

        This function will find a group based on its name.
        For some reason the caller has the group in a buffer it doesn't want 
        modified, so we must not touch the original bytes.
        Since we must do all our searches in lower case, we will copy 
        the buffer and lower case it locally.

Arguments : 
        
        lpstrGroup - The group to find - must be NULL terminated.
        cb      - The length of the group's name

Return Value : 

        Smart pointer to the newsgroup, NULL smart pointer if not found.

--*/

        TraceFunctEnter(        "CNewsTreeCore::GetGroup" ) ;

        _ASSERT( lpstrGroup != 0 ) ;
        _ASSERT( cb != 0 ) ;
        _ASSERT( lpstrGroup[cb-1] == '\0' ) ;

        CGRPCOREPTR     pGroup = 0 ;
        char    szGroupBuff[512] ;
        if( cb < sizeof( szGroupBuff ) ) {
                CopyMemory(     szGroupBuff, lpstrGroup, cb ) ;
                _strlwr( szGroupBuff ) ;

                DebugTrace((DWORD_PTR) this, "grabbing shared lock -" ) ;
                m_LockTables.ShareLock() ;

                char    *szTemp = szGroupBuff ;

                pGroup = m_HashNames.SearchKey(szTemp);

                DebugTrace((DWORD_PTR) this, "releasing lock" ) ;
                m_LockTables.ShareUnlock() ;
        }
        return  (CNewsGroupCore *)pGroup ;
}

CGRPCOREPTRHASREF       
CNewsTreeCore::GetGroupById(    
                                GROUPID groupid,
                                BOOL    fFirm
                                ) {
/*++

Routine Description : 

        Find a newsgroup based on groupid.

Arguments : 

        groupid of the group we want to find.

Return Value : 

        Poniter to newsgroup, NULL if not found.

--*/

        TraceFunctEnter( "CNewsTreeCore::GetGroup" ) ;

        CGRPCOREPTR     pGroup = 0 ;
        if (!fFirm && m_fStoppingTree) return (CNewsGroupCore *)pGroup;   

        DebugTrace((DWORD_PTR) this, "grabbing shared lock" ) ;

        m_LockTables.ShareLock() ;

        if (!fFirm && m_fStoppingTree) {
                m_LockTables.ShareUnlock();
                return (CNewsGroupCore *)pGroup;  
        }

        pGroup = m_HashGroupId.SearchKey(groupid);
        DebugTrace((DWORD_PTR) this, "release lock" ) ;
        m_LockTables.ShareUnlock() ;
        return  (CNewsGroupCore *)pGroup ;
}

CGRPCOREPTRHASREF       
CNewsTreeCore::GetParent( 
                        IN  char*  lpGroupName,
                        IN  DWORD  cbGroup,
                        OUT DWORD& cbConsumed
                           ) {
/*++

Routine Description : 

        Find the parent of a newsgroup.

Arguments : 

        char* lpGroupName -  name of newsgroup whose parent we want to find 
                                                 (should be NULL terminated)
        DWORD cbGroup - length of szGroupName
        DWORD cbConsumed - bytes consumed by this function

Return Value : 

        Pointer to parent Newsgroup, NULL if not found.

--*/

        _ASSERT( lpGroupName != NULL ) ;
        _ASSERT( *(lpGroupName + cbGroup) == '\0' );
        _ASSERT( cbConsumed == 0 );

        TraceFunctEnter( "CNewsTreeCore::GetParent" ) ;

        CGRPCOREPTR pGroup = 0;

        char* pch = lpGroupName+cbGroup-1;

        do
        {
                while( pch != lpGroupName )
                {
                        if( *pch == '.' )
                                break;
                        pch--;
                        cbConsumed++;
                }

                if( pch != lpGroupName )
                {
                        _ASSERT( DWORD(pch-lpGroupName) <= (cbGroup-1) );
                        *pch-- = '\0';
                        cbConsumed++;

                        pGroup = GetGroup( lpGroupName, cbGroup - cbConsumed ) ;
                }
                else
                        break;

        } while( !pGroup );

        // return the parent group; if this is NULL the whole buffer should be consumed
        _ASSERT( pGroup || (cbConsumed == cbGroup-1) );

        return (CNewsGroupCore *)pGroup;
}

BOOL
CNewsTreeCore::Remove( 
                                CNewsGroupCore      *pGroup ,
                                BOOL fHaveExLock
                
                                ) {
/*++

Routine Description : 

        Remove all references to the newsgroup from the newstree.
        The newsgroup may continue to exist if there is anybody holding
        onto a smart pointer to it.

--*/

        TraceFunctEnter( "CNewsTreeCore::Remove" ) ;

        DebugTrace((DWORD_PTR) this, "Getting Exclusive Lock " ) ;

        HRESULT hr = S_OK;

        if (!fHaveExLock) m_LockTables.ExclusiveLock() ;

    //  fix bug 80453 - avoid double-release in Remove() if two threads come in at the
    //  same time!
    if (pGroup->IsDeleted())
    {
        if (!fHaveExLock) m_LockTables.ExclusiveUnlock();
        return FALSE;
    }

        // Remove this group from all hash tables and lists
        // This makes the group inaccessible
        LPSTR lpstrGroup = pGroup->GetName();
        GROUPID grpId = pGroup->GetGroupId();

        _VERIFY(m_HashNames.DeleteData(lpstrGroup) == pGroup);
        _VERIFY(m_HashGroupId.DeleteData(grpId) == pGroup);

        m_cGroups -- ;

        // !! Do not explicitly remove a newsgroup object from the list
        // This is done in the newsgroup object destructor
        // RemoveList( pGroup );

        // mark as deleted so newsgroup iterators skip over this one
        pGroup->MarkDeleted();

        DebugTrace((DWORD_PTR) this, "releasing lock" ) ;

        if (!fHaveExLock) m_LockTables.ExclusiveUnlock() ;

        pGroup->Release();

    return TRUE;
}

void
CNewsTreeCore::RemoveEx( 
                                CNewsGroupCore   *pGroup 
                                ) {
/*++

Routine Description : 

        Remove all references to the newsgroup from the newstree.
        This is called only by Standard rebuild to mark newsgroups deleted.
        The newsgroup may continue to exist if there is anybody holding
        onto a smart pointer to it.

--*/

        TraceFunctEnter( "CNewsTreeCore::RemoveEx" ) ;

        DebugTrace((DWORD_PTR) this, "Getting Exclusive Lock " ) ;

        m_LockTables.ExclusiveLock() ;

        // Remove this group from all hash tables and lists
        // This makes the group inaccessible
        LPSTR lpstrGroup = pGroup->GetName();

        m_HashNames.DeleteData( lpstrGroup ) ;

        pGroup->Release();
        m_cGroups -- ;

        // !! Do not explicitly remove a newsgroup object from the list
        // This is done in the newsgroup object destructor
        // RemoveList( pGroup );

        // mark as deleted so newsgroup iterators skip over this one
        pGroup->MarkDeleted();

        DebugTrace((DWORD_PTR) this, "releasing lock" ) ;

        m_LockTables.ExclusiveUnlock() ;
}

GROUPID
CNewsTreeCore::GetSlaveGroupid()        {
        return  m_idSlaveGroup ;
}       

BOOL
CNewsTreeCore::RemoveGroupFromTreeOnly( CNewsGroupCore *pGroup )
/*++
Routine description:

    Remove the group from newstree only

Arguments:

    CNewsGroupCore *pGroup - The newsgroup to be removed

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
        TraceFunctEnter("CNewsTreeCore::RemoveGroup");

        if (m_fStoppingTree) return FALSE;
        if (pGroup->IsDeleted()) return FALSE;

        // remove group from internal hash tables and lists
        if (!Remove(pGroup)) return FALSE;

        // remove the group from the fix props file
        INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
        m_pFixedPropsFile->RemoveGroup(pBag);
        pBag->Release();

    // also remove it from the var props file
    if (pGroup->GetVarOffset() != 0) {
        m_pVarPropsFile->DeleteRecord(pGroup->GetVarOffset());
    } 

    TraceFunctLeave();
    return TRUE;
}

//
// unlink a group from the group list.  this doesn't physically remove a
// group from a store, RemoveDriverGroup should be used for that.
//
BOOL
CNewsTreeCore::RemoveGroup( CNewsGroupCore *pGroup )
{
        TraceFunctEnter("CNewsTreeCore::RemoveGroup");

        if (m_fStoppingTree) return FALSE;
        if (pGroup->IsDeleted()) return FALSE;

        // remove group from internal hash tables and lists
        if (!Remove(pGroup)) return FALSE;

        // remove the group from the fix props file
        INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
        m_pFixedPropsFile->RemoveGroup(pBag);
        pBag->Release();

    // also remove it from the var props file
    if (pGroup->GetVarOffset() != 0) {
        m_pVarPropsFile->DeleteRecord(pGroup->GetVarOffset());
    } 

    //
    // Put the group into rmgroup queue
    //
    if(!m_pInstWrapper->EnqueueRmgroup( pGroup ) )  {
        ErrorTrace( 0, "Could not enqueue newsgroup %s", pGroup->GetName());
        return FALSE;
    }

    TraceFunctLeave();
        return TRUE;
}

//
// physically remove a group from a store.  This doesn't remove a group from
// the tree, use RemoveGroup for that.
//
BOOL CNewsTreeCore::RemoveDriverGroup(  CNewsGroupCore *pGroup ) {
        TraceFunctEnter("CNewsTreeCore::RemoveDriverGroup");

        CNNTPVRoot *pVRoot = pGroup->GetVRoot();
        if (pVRoot == NULL) return TRUE;

        // create a completion object
        INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
        HRESULT hr = S_OK;
        CNntpSyncComplete scComplete;

        //
        // Set vroot to the completion object
        //
        scComplete.SetVRoot( pVRoot );
        
        // start the remove operation
        pVRoot->RemoveGroup(pBag, &scComplete );

        // wait for it to complete
        _ASSERT( scComplete.IsGood() );
        hr = scComplete.WaitForCompletion();
        
        pVRoot->Release();
        
        // check out status and return it
        if (FAILED(hr)) SetLastError(hr);
        TraceFunctLeave();
        return SUCCEEDED(hr);
}

HRESULT
CNewsTreeCore::FindOrCreateGroup(       
                                                LPSTR           lpstrGroupName, 
                                                BOOL            fIsAllLowerCase,
                                                BOOL            fCreateIfNotExist,
                                                BOOL            fCreateInStore,
                                                CGRPCOREPTR     *ppGroup,
                                                HANDLE      hToken,
                                                BOOL        fAnonymous,
                                                GROUPID     groupid,
                                                BOOL        fSetGroupId ) 
{
/*++

Routine Description : 

        This function can do a lookup for a group or create a group all in
        one operation.  

Arguments : 

        lpstrGroupName - Name of the newsgroup
        fIsAllLowerCase - If TRUE the newsgroup name is already lower case,
                if FALSE we will make our own lower case copy of the newsgroup 
                name.
        fCreateIfNotExist - create the group if its not found?
        ppGroup - recieves the group pointer

Return Value : 

        TRUE if successfull.
        FALSE otherwise.

--*/

        HRESULT hr = S_OK;
        char    szBuff[512] ;
        LPSTR   lpstrNativeGroupName = NULL ;
        
        TraceQuietEnter("CNewsTreeCore::CreateGroup");

        if( !fIsAllLowerCase ) {

                int     cb = 0 ;                
                lpstrNativeGroupName = lpstrGroupName;
                if( (cb = lstrlen( lpstrGroupName )+1) < sizeof( szBuff ) )             {
        
                        CopyMemory( szBuff, lpstrGroupName, cb ) ;
                        _strlwr( szBuff ) ;
                        lpstrGroupName = szBuff ;
                }

                //
                //      Optimize - if the native group name is all lower case, store
                //      only one of 'em.
                //
                
                if( strcmp( lpstrGroupName, lpstrNativeGroupName ) == 0 ) {
                        lpstrNativeGroupName = NULL ;
                }
        }

        m_LockTables.ShareLock() ;

        if (m_fStoppingTree) {
                m_LockTables.ShareUnlock();
                return E_UNEXPECTED;    
        }

        CGRPCOREPTR pOldGroup = m_HashNames.SearchKey(lpstrGroupName);
        if( pOldGroup == NULL)  {
                if (!fCreateIfNotExist) {
                        m_LockTables.ShareUnlock() ;
                        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
                }

                // since there is a timing window here we need to redo our
                // check to see if the group exists
                m_LockTables.ShareUnlock() ;
                m_LockTables.ExclusiveLock() ;

                //
                // check stopping tree again
                //
                if ( m_fStoppingTree ) {
                    m_LockTables.ExclusiveUnlock();
                    return E_UNEXPECTED;
                }
                pOldGroup = m_HashNames.SearchKey(lpstrGroupName);
                if (pOldGroup != NULL) {
                        m_LockTables.ExclusiveUnlock() ;
                        pOldGroup->SetDecorateVisitedFlag(TRUE);
                        DebugTrace((DWORD_PTR) this, "set visited %s", pOldGroup->GetName());
                        if (ppGroup != NULL) *ppGroup = pOldGroup;
                        hr = S_FALSE;
                } else {
                        CGRPCOREPTR     pNewGroup = NULL;
        
                        BOOL fRtn = CreateGroupInternal( 
                                                                lpstrGroupName, 
                                                                lpstrNativeGroupName,
                                                                groupid, 
                                                                fAnonymous,
                                                                hToken,
                                                                FALSE,
                                                                &pNewGroup,
                                                                TRUE,
                                                                fSetGroupId, 
                                                                fCreateInStore
                                                                ) ;
        
                        m_LockTables.ExclusiveUnlock() ;
        
                        // bail if CreateGroupInternal fails !
                        if(!fRtn) {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                if (SUCCEEDED(hr)) hr = E_FAIL;
                                return hr;
                        } else {
                                //
                                // Before appending this guy onto newstree, we should reset its watermark
                                // if there is an old group lying around
                                //
                m_pInstWrapper->AdjustWatermarkIfNec( pNewGroup );                              

                //
                // Set the group to be postable
                //
                pNewGroup->SetAllowPost( TRUE );

                //
                // Set the group to be expireable
                //
                pNewGroup->SetAllowExpire( TRUE );

                                pNewGroup->SetDecorateVisitedFlag(TRUE);
                                DebugTrace((DWORD_PTR) this, "set visited %s", pNewGroup->GetName());
                        }
        
                        if (ppGroup != NULL) *ppGroup = pNewGroup;
                }
        }       else    {
                m_LockTables.ShareUnlock() ;
                pOldGroup->SetDecorateVisitedFlag(TRUE);
                //DebugTrace((DWORD_PTR) this, "set visited %s", pOldGroup->GetName());
                if (ppGroup != NULL) *ppGroup = pOldGroup;
                hr = S_FALSE;
        }
        return hr;
}

static  char    szCreateFileString[] = "\\\\?\\" ;
                        
BOOL
CNewsTreeCore::CreateGroupInternal(     LPSTR           lpstrGroupName,
                                                                LPSTR           lpstrNativeGroupName,
                                                                GROUPID&        groupid,
                                                                BOOL        fAnonymous,
                                                                HANDLE      hToken,
                                                                BOOL            fSpecial,
                                                                CGRPCOREPTR     *ppGroup,
                                                                BOOL            fAddToGroupFiles,
                                                                BOOL            fSetGroupId,
                                                                BOOL            fCreateInStore,
                                                                BOOL        fAppend ) 
{
        /*++

        Routine Description :

                This function exists to create newsgroups.
                We will create all the necessary directories etc...
                Caller must have exclusive lock to newstree held.

        Arguments : 

                lpstrGroupName - The name of the newsgroup that we want to create !
                lpstrNativeGroupName - The native (case-preserved) name of the newsgroup
                fSpecial - If TRUE the caller wants to build a special internal newsgroup
                        not to be seen by clients - we can suppress our usual validity checking !
                ppGroup - recieves the group object that was created

        Return Value : 

                TRUE    if Created Successfully, FALSE otherwise

--*/

        TraceQuietEnter( "CNewsTreeCore::CreateGroup" ) ;

        BOOL    fRtn = TRUE ;
        CNntpSyncComplete scComplete;

        if( !fSpecial ) {

                if( lpstrGroupName == 0 ) {
                        SetLastError( ERROR_INVALID_NAME );
                        return  FALSE ;
                }

                //
                // Reject weird Genome groups like alt.024.-.-.0
                // -johnson
                //

                if ( m_fRejectGenomeGroups &&
                         (*lpstrGroupName == 'a') &&
                         (lstrlen(lpstrGroupName) > 4) ) {

                        if ( *(lpstrGroupName+4) == '0') {
                                SetLastError( ERROR_INVALID_NAME );
                                return(FALSE);
                        }
                }

                //
                //      Group names may not contain a slash
                //
                if( strchr( lpstrGroupName, '\\' ) != 0 ) {
                        SetLastError( ERROR_INVALID_NAME );
                        return  FALSE ;
                }

                //
                //  Group names may not contain ".."
                // 
                if ( strstr( lpstrGroupName, ".." ) != 0 ) {
                    SetLastError( ERROR_INVALID_NAME );
                    return FALSE;
                }

                if( !fTestComponents( lpstrGroupName ) ) {
                        SetLastError( ERROR_INVALID_NAME );
                        return  FALSE ;
                }

        }       else    {

                if( m_idSpecialHigh == m_idLastSpecial ) {
                        SetLastError( ERROR_INVALID_NAME );
                        return  FALSE ;
                }

        }

        DWORD   dw = 0 ;
        BOOL    fFound = FALSE ;

        // DebugTrace( (DWORD_PTR)this, "Did not find group %s", lpstrGroupName ) ;

        CGRPCOREPTR     pParent = 0 ;           
        //LPSTR lpstrRootDir = NntpTreeRoot;

        //
        //      Make sure the newsgroup is not already present !
        //
        if( m_HashNames.SearchKey( lpstrGroupName) == NULL ) {

                CNewsGroupCore* pNews = AllocateGroup();

                if (pNews != 0) {
                        NNTPVROOTPTR pVRoot = NULL;
                        HRESULT hr;

                        if (m_fVRTableInit) {
                                hr = m_pVRTable->FindVRoot(lpstrGroupName, &pVRoot);
                        } else {
                                hr = S_OK;
                        }

                        if (SUCCEEDED(hr)) {
                                if (!fSetGroupId) {
                                        if( !fSpecial ) {
                                                groupid = m_idHigh++ ;
                                        }       else    {
                                                groupid = m_idSpecialHigh ++ ;
                                        }                       
                                } else {
                                        CNewsGroupCore *pGroup = m_HashGroupId.SearchKey(groupid);
                                        _ASSERT(pGroup == NULL);
                                        if (pGroup != NULL) {
                                                m_LockTables.ExclusiveUnlock();
                                                pNews->Release();
                                                m_LockTables.ExclusiveLock();
                                                SetLastError(ERROR_ALREADY_EXISTS);
                                                return FALSE;
                                        }

                                        if (fSpecial && groupid >= m_idSpecialHigh) 
                                                m_idSpecialHigh = groupid + 1;
                                        if (!fSpecial && groupid >= m_idHigh) 
                                                m_idHigh = groupid + 1;

                                }
                                
                                if (!pNews->Init( lpstrGroupName, 
                                                                lpstrNativeGroupName,
                                                                groupid,
                                                                pVRoot,
                                                                fSpecial
                                                                )) {
                                        // Init calls SetLastError
                                        TraceFunctLeave();
                                        return FALSE;
                                }

                                INNTPPropertyBag *pBag = pNews->GetPropertyBag();
                                if (fCreateInStore && fAddToGroupFiles && pVRoot && pVRoot->IsDriver()) {
                                        // call into the driver to create the group.  because the
                                        // driver may take a long time we let go of our lock.  this
                                        // means that we need to check that the group hasn't already
                                        // been created by another thread when we get the lock back.
                                        m_LockTables.ExclusiveUnlock();

                                        //
                                        // Set vroot to the completion object
                                        //
                                        scComplete.SetVRoot( pVRoot );
                
                                        // add a reference for creategroup
                                        pBag->AddRef();
                                        pVRoot->CreateGroup(    pBag, 
                                                                &scComplete,
                                                                hToken,
                                                                fAnonymous );
                                        _ASSERT( scComplete.IsGood() );
                                        hr = scComplete.WaitForCompletion();

                                        m_LockTables.ExclusiveLock();

                                        //
                                        // re-check m_fStoppingTree
                                        //
                                        if ( m_fStoppingTree ) {
                                            DebugTrace( 0, "Tree stopping, group creation aborted" );
                                            pBag->Release();
                                            m_LockTables.ExclusiveUnlock();
                                            pNews->Release();
                                            m_LockTables.ExclusiveLock();
                                            SetLastError( ERROR_OPERATION_ABORTED );
                                            TraceFunctLeave();
                                            return FALSE;
                                        }
        
                                        // check to see if the create group failed or if the group was
                                        // created by someone else
                                        BOOL fExists = ((m_HashGroupId.SearchKey(groupid) != NULL) ||
                                                                (m_HashNames.SearchKey(lpstrGroupName) != NULL));
                                        if (FAILED(hr) || fExists) {
                                                ErrorTrace((DWORD_PTR) this, "driver->CreateGroup failed with 0x%x", hr);
                                                pBag->Release();
                                                m_LockTables.ExclusiveUnlock();
                                                pNews->Release();
                                                m_LockTables.ExclusiveLock();
                                                SetLastError((fExists) ? ERROR_ALREADY_EXISTS : hr);
                                                TraceFunctLeave();
                                                return FALSE;
                                        }
                                }

                                //
                                // Set the group to be read only, so that even though it's inserted
                                // into the list, it's still non-postable.  This is because we'll
                                // double check with rmgroup queue and adjust watermarks before allowing
                                // any posting into this group.  We cannot do check here, because
                                // the check may cause the old group to be destroyed.  The destroy of
                                // old group needs to hold a table lock.  However we are already in
                                // table lock.  
                                //
                                pNews->SetAllowPost( FALSE );
                                pNews->SetAllowExpire( FALSE );

                                // insert in the newstree as usual
                                if ( fAppend )
                                        fRtn = Append( pNews );
                                else {
                                        // Find the parent newsgroup as a hint where to start looking for
                                        // the insertion point.
                                        CHAR szParentGroupName[MAX_NEWSGROUP_NAME+1];
                                        lstrcpyn(szParentGroupName, lpstrGroupName, MAX_NEWSGROUP_NAME);
                                        LPSTR pszLastDot;
                                        while ((pszLastDot=strrchr(szParentGroupName, '.'))) {
                                                *pszLastDot = NULL;
                                                pParent = m_HashNames.SearchKey(szParentGroupName);
                                                if (pParent)
                                                        break;
                                        }
                                        fRtn = Insert( pNews, (CNewsGroupCore*)pParent );
                                }
                                if ( fRtn ) {

                                        if (fAddToGroupFiles) {
                                                // add the group to the group file
                                                _ASSERT(m_pFixedPropsFile);
                                                if (m_pFixedPropsFile->AddGroup(pBag)) {
                                                        pBag->Release();
                                                if (ppGroup) *ppGroup = pNews;
                                                        return TRUE ;
                                                }
                        pNews->AddRef();
                                                Remove(pNews, TRUE);
                                        } else {
                                                pBag->Release();
                                        if (ppGroup) *ppGroup = pNews;
                                                return TRUE;
                                        }
                                }
                                pBag->Release();
                        }       else    {
                                //_ASSERT(FALSE);
                        }
                }       else    {
                        _ASSERT(FALSE);
                }

                if( pNews != 0 ) {
                        m_LockTables.ExclusiveUnlock();
                        pNews->Release();
                        m_LockTables.ExclusiveLock();
                }

        }                                       

        SetLastError(ERROR_ALREADY_EXISTS);
        return  FALSE ;
}

CNewsCompareId::CNewsCompareId( GROUPID id ) : 
        m_id( id ) {}

CNewsCompareId::IsMatch( CNewsGroupCore  *pGroup ) {
    return  pGroup->GetGroupId() - m_id ;
}

DWORD
CNewsCompareId::ComputeHash( ) {
    return  CNewsGroupCore::ComputeIdHash( m_id ) ;
}

CNewsCompareName::CNewsCompareName( LPSTR lpstr ) : 
        m_lpstr( lpstr ) { }

CNewsCompareName::CNewsCompareName( CNewsGroupCore *p ) : 
        m_lpstr( p->GetGroupName() ) {}

CNewsCompareName::IsMatch( CNewsGroupCore    *pGroup ) {
    return  lstrcmp( pGroup->GetGroupName(), m_lpstr ) ;
}

DWORD
CNewsCompareName::ComputeHash( ) {
    return  CNewsGroupCore::ComputeNameHash( m_lpstr ) ;
}


CGroupIteratorCore*
CNewsTreeCore::ActiveGroups(BOOL    fReverse) {
/*++

Routine Description : 

        Build an iterator that can be used to walk all of the 
        client visible newsgroups.

Arguments : 
        
        fIncludeSecureGroups - 
                IF TRUE then the iterator we return will visit the
                SSL only newsgroups.

Return Value : 

        An iterator, NULL if an error occurs

--*/

        m_LockTables.ShareLock() ;
        CGRPCOREPTR     pStart;
    if( !fReverse ) {
                CNewsGroupCore *p = m_pFirst;
                while (p && p->IsDeleted()) p = p->m_pNext;
                pStart = p;
    } else {
                CNewsGroupCore *p = m_pLast;
                while (p && p->IsDeleted()) p = p->m_pPrev;
                pStart = p;
    }
        m_LockTables.ShareUnlock() ;

        CGroupIteratorCore*     pReturn = XNEW CGroupIteratorCore(this, pStart) ;
        return  pReturn ;
}

CGroupIteratorCore*
CNewsTreeCore::GetIterator(LPMULTISZ lpstrPattern, BOOL fIncludeSpecialGroups) {
/*++

Routine Description : 

        Build an iterator that  will list newsgroups meeting
        all of the specified requirements.

Arguments : 

        lpstrPattern - wildmat patterns the newsgroup must match
        fIncludeSecureGroups - if TRUE then include secure (SSL only) newsgroups
        fIncludeSpecialGroups - if TRUE then include reserved newsgroups

Return Value : 

        An iterator, NULL on error

--*/

        CGRPCOREPTR pFirst;

        m_LockTables.ShareLock() ;
        CNewsGroupCore *p = m_pFirst;
        while (p != NULL && p->IsDeleted()) p = p->m_pNext;
        pFirst = p;
        m_LockTables.ShareUnlock() ;

        CGroupIteratorCore*     pIterator = XNEW CGroupIteratorCore(
                                                                                                this,
                                                                                                lpstrPattern, 
                                                                                                pFirst, 
                                                                                                fIncludeSpecialGroups
                                                                                                ) ;

    return  pIterator ;
}

//
// find the vroot which owns a group name
//
HRESULT CNewsTreeCore::LookupVRoot(char *pszGroup, INntpDriver **ppDriver) {
        NNTPVROOTPTR pVRoot;

        if (m_fVRTableInit) {
                HRESULT hr = m_pVRTable->FindVRoot(pszGroup, &pVRoot);
                if (FAILED(hr)) return hr;
        } else {
                return E_UNEXPECTED;
        }

        *ppDriver = pVRoot->GetDriver();

        return S_OK;
}

//
// given a group ID find the matching group
//
// parameters:
//   dwGroupID - the group ID
//   
//
HRESULT CINewsTree::FindGroupByID(DWORD dwGroupID,
                                                                  INNTPPropertyBag **ppNewsgroupProps,
                                                                  INntpComplete *pProtocolComplete ) 
{
        _ASSERT(this != NULL);
        _ASSERT(ppNewsgroupProps != NULL);

        return E_NOTIMPL;
}

// 
// given a group name find the matching group.  if the group doesn't
// exist and fCreateIfNotExist is set then a new group will be created.
// the new group won't be available until CommitGroup() is called.
// if the group is Release'd before CommitGroup was called then it
// won't be added.
//
HRESULT CINewsTree::FindOrCreateGroupByName(LPSTR pszGroupName,
                                                                                BOOL fCreateIfNotExist,
                                                                                INNTPPropertyBag **ppNewsgroupProps,
                                                                                INntpComplete *pProtocolComplete,
                                                                                GROUPID groupid,
                                                                                BOOL fSetGroupId )
{
        CGRPCOREPTR pGroup;
        HRESULT hr;

        _ASSERT(pszGroupName != NULL);
        _ASSERT(this != NULL);
        _ASSERT(ppNewsgroupProps != NULL);

        hr = m_pParentTree->FindOrCreateGroup(  pszGroupName, 
                                                FALSE, 
                                                fCreateIfNotExist, 
                                                FALSE, 
                                                &pGroup,
                                                NULL,
                                                FALSE,
                                                groupid,
                                                fSetGroupId );

        if (SUCCEEDED(hr)) {
                *ppNewsgroupProps = pGroup->GetPropertyBag();
#ifdef DEBUG
                if ( pProtocolComplete ) ((CNntpComplete *)pProtocolComplete)->BumpGroupCounter();
#endif
        } else {
                *ppNewsgroupProps = NULL;
        }
                                                                         
        return hr;
}

//
// add a new group to the newstree
//
HRESULT CINewsTree::CommitGroup(INNTPPropertyBag *pNewsgroupProps) {
        _ASSERT(pNewsgroupProps != NULL);
        _ASSERT(this != NULL);

        return S_OK;
}

//
// remove an entry
//
HRESULT CINewsTree::RemoveGroupByID(DWORD dwGroupID) {
        _ASSERT(this != NULL);

        return E_NOTIMPL;
}

HRESULT CINewsTree::RemoveGroupByName(LPSTR pszGroupName, LPVOID lpContext) {
        _ASSERT(pszGroupName != NULL);
        _ASSERT(this != NULL);

        CGRPCOREPTR pGroup;
        HRESULT hr;

    //  First, get the CGRPCOREPTR
        hr = m_pParentTree->FindOrCreateGroup(  pszGroupName, 
                                                FALSE, 
                                                FALSE,  // fCreateIfNotExist, 
                                                FALSE,  // fCreateinStore
                                                &pGroup,
                                                NULL,
                                                FALSE );

        if (SUCCEEDED(hr)) {
                //  Found the group, delete it from Newstree only
        if (!m_pParentTree->RemoveGroupFromTreeOnly(pGroup))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        }

    return hr;
}

//
// enumerate across the list of keys.  
//
HRESULT CINewsTree::GetIterator(INewsTreeIterator **ppIterator) {
        _ASSERT(this != NULL);
        _ASSERT(ppIterator != NULL);
        if (ppIterator == NULL) return E_INVALIDARG;

        *ppIterator = m_pParentTree->ActiveGroups();
        if (*ppIterator == NULL) return E_OUTOFMEMORY;

        return S_OK;
}

HRESULT CINewsTree::GetNntpServer(INntpServer **ppNntpServer) {
        _ASSERT(ppNntpServer != NULL);
        _ASSERT(this != NULL);
        if (ppNntpServer == NULL) return E_INVALIDARG;

        *ppNntpServer = m_pParentTree->GetNntpServer();
        return S_OK;
}

HRESULT CINewsTree::LookupVRoot(char *pszGroup, INntpDriver **ppDriver) {
        _ASSERT(this != NULL);
        _ASSERT(ppDriver != NULL);

        return m_pParentTree->LookupVRoot(pszGroup, ppDriver);
}

//
// this callback is called for each vroot in the vroot table.  it calls
// the drop driver method
//
// parameters:
//   pEnumContext - ignored
//   pVRoot - the pointer to the vroot object.
//
void CNewsTreeCore::DropDriverCallback(void *pEnumContext,
                                                                           CVRoot *pVRoot) 
{
        ((CNNTPVRoot *) pVRoot)->DropDriver();
}

//
// a vroot rescan took place.  enumerate through all of the groups and
// update their vroot pointers
//
void CNewsTreeCore::VRootRescanCallback(void *pContext) {
        TraceQuietEnter("CNewsTreeCore::VRootRescanCallback");
        
        CNewsTreeCore *pThis = ((CINewsTree *) pContext)->GetTree();

        pThis->m_LockTables.ShareLock() ;
        pThis->m_fVRTableInit = TRUE;
        CNewsGroupCore *p = pThis->m_pFirst;
        while (p) {
                NNTPVROOTPTR pVRoot;
                HRESULT hr = pThis->m_pVRTable->FindVRoot(p->GetName(), &pVRoot);
                if (FAILED(hr)) pVRoot = NULL;
                p->UpdateVRoot(pVRoot);
                //DebugTrace((DWORD_PTR) pThis, "group %s has vroot 0x%x", 
                //      p->GetName(), pVRoot);
        
            p = p->m_pNext;
        }
        pThis->m_LockTables.ShareUnlock() ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\mapfile\mapfile.h ===
/* -------------------------------------------------------------------------
  mapfile.h
      (was bbmpfile.h)
  	Definitions for the mapped file class.

  Copyright (C) 1995   Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:49 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on pvMapFile() and derivatives.

   ------------------------------------------------------------------------- */

/*
 *    Generic class to handle mapped files.  Part of the reason for
 *  turning this into a class is to allow tracking of mapping/unmapping
 *  and thus to handle clean up of dangling mappings in exception
 *  handling code.  Tracking is enabled if the fTrack parameter is
 *  specified.
 */

#ifndef _MAPFILE_H_
#define _MAPFILE_H_

//   Bits used in the m_fFlags field below.
#define	MF_TRACKING		0x0001			// Tracking use of this item.
#define	MF_RELINQUISH	0x0002			// Someone else to free this item.


class  CMapFile
{
public:
	CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease = 0);
	CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack );
	CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbSizeIncrease = 0 );
	CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0, BOOL fZero = FALSE );

	~CMapFile( void );

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

private:
	DWORD	 m_cb;			// Size of this file.
	void	*m_pv;			// Address to use.
	DWORD	 m_fFlags;		// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease, BOOL fZero = FALSE );
};


/*
 *    For compatability with old code, the original functions remain.
 */

void *pvMapFile( DWORD *pdwSize, const char  *pchFileName, BOOL bWriteEnable );
void *pvMapFile( DWORD *pdwSize, const WCHAR *pwchFileName, BOOL bWriteEnable );

void *pvMapFile(const char  *pchFileName, BOOL bWriteEnable,
		 DWORD  *pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

void * pvFromHandle( HANDLE hFile,	BOOL bWriteEnable,
		DWORD * pdwSizeFinal = NULL, DWORD dwSizeIncrease = 0);

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

class  CMapFileEx
{
public:
	CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD dwSizeIncrease = 0 );
	~CMapFileEx( void );
	void Cleanup( void );		// cleanup in case of failure !

	//   Get the details of this item.
	void	*pvAddress( DWORD *pcb ) { if( pcb ) *pcb = m_cb; return (void*)m_pv; };

	//   Relinquish control (meaning someone else unmaps file).
	void	 Relinquish( void )  {  m_fFlags |= MF_RELINQUISH;  };

	//	Tells if mapping is OK.
	BOOL	fGood(void) {return NULL != m_pv; };

	//	Protect and Unprotect mapping
	BOOL	ProtectMapping();
	BOOL	UnprotectMapping();

private:
	DWORD	 m_cb;								// Size of this file.
	LPBYTE	 m_pv;								// Address to use.
	DWORD	 m_fFlags;							// See above for the bits used in here.
	WCHAR	 m_rgwchFileName[ MAX_PATH ];		// For error recording.

	HANDLE	 m_hFile;							// handle to the mapped file
	LPBYTE	 m_pvFrontGuard;					// front guard page
	DWORD	 m_cbFrontGuardSize;				// front guard page size
	LPBYTE	 m_pvRearGuard;						// rear guard page
	DWORD	 m_cbRearGuardSize;					// rear guard page size
	CRITICAL_SECTION m_csProtectMap;			// crit sect to protect/unprotect mapping

	void	 MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease );
};

#endif // DEBUG
#endif // _MAPFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\src\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
};
#endif

#include <xmemwrpr.h>
#include <malloc.h>
#include <mbstring.h>
#include <nntptype.h>
#include <nntps.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <nntpmeta.h>
#include <nntpcons.h>
#include <nntputil.h>

#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"
#include "crchash.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include <instwpex.h>
#include "nntpvr.h"
#include "group.h"
#include "nwstree.h"
#include "nntpbag.h"
#include "nntperr.h"
#include "mapfile.h"
#include "ihash.h"
#include "drvid.h"

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\src\nntpvr.cpp ===
#include "stdinc.h"

#include "nntpdrv_i.c"

#define DEFAULT_DRIVER_PROGID L"NNTP.FSPrepare"
#define NO_DRIVER_PROGID L"TestNT.NoDriver"
#define EX_DRIVER_PROGID L"NNTP.ExDriverPrepare"

extern char szSlaveGroup[];

CNntpComplete::CNntpComplete(CNNTPVRoot *pVRoot) {
#ifdef DEBUG
    m_cGroups = 0;
#endif
	m_cRef = 1;
	m_hr = E_FAIL;
	m_pVRoot = pVRoot;
	if (m_pVRoot) m_pVRoot->AddRef();
}

HRESULT CNntpComplete::GetResult() {
	return m_hr;
}

void CNntpComplete::SetResult(HRESULT hr) {
	m_hr = hr;
}

void CNntpComplete::SetVRoot(CNNTPVRoot *pVRoot) {
	if( pVRoot != m_pVRoot ) 	{
		CNNTPVRoot*	pTemp ;
		pTemp = m_pVRoot ;
		m_pVRoot = pVRoot ;
		if( m_pVRoot )
			m_pVRoot->AddRef() ;
		if( pTemp )
			pTemp->Release() ;
	}
}

ULONG CNntpComplete::AddRef() {
   	long	l = InterlockedIncrement(&m_cRef);
	_ASSERT( l >= 0 ) ;
	return	l ;
}

void CNntpComplete::Destroy() {
	XDELETE this;
}

ULONG CNntpComplete::Release() {
#ifdef DEBUG
    _ASSERT( m_cGroups == 0 );
#endif
	LONG i = InterlockedDecrement(&m_cRef);
	_ASSERT( i >= 0 ) ;
  	if (i == 0) Destroy();
	return i;
}

HRESULT CNntpComplete::QueryInterface(const IID &iid, VOID **ppv) {
	if ( iid == IID_IUnknown ) {
		*ppv = static_cast<IUnknown*>(this);
	} else if ( iid == IID_INntpComplete ) {
		*ppv = static_cast<INntpComplete*>(this);
	} else {
		*ppv = NULL;
		return E_NOINTERFACE;
	}
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CNNTPVRoot *CNntpComplete::GetVRoot() {
	return m_pVRoot;
}

CNntpComplete::~CNntpComplete() {
	if (m_pVRoot) {
		// this ASSERT is hit if nothing ever calls SetResult() because
		// E_FAIL is the default value for m_hr.
		_ASSERT((GetResult() != E_FAIL) || (m_cRef!=0));

		// update the vroot state if the store went down
		m_pVRoot->UpdateState(GetResult());
	
		// release the vroot
		m_pVRoot->Release();
		m_pVRoot = NULL;
	}
}

void
CNntpComplete::Reset()	{
/*++

Routine Description :

	This function restores the completion object to the same state
	it would be after construction, so that it can be re-issued to
	a Store driver.

Arguments :

	None.

Return Value :

	None.

--*/
#ifdef DEBUG
    m_cGroups = 0;
#endif

	_ASSERT( m_cRef == 0 ) ;
	_ASSERT( m_hr != E_FAIL ) ;
	m_cRef = 1 ;
	m_hr = E_FAIL ;

	//
	//	We leave the VRoot pointer alone - assume client
	//	 is going to use the same VRoot.  NOTE :
	//	m_pVroot should be NONNULL since we've already gone
	//	through one opeartion !
	//
	//_ASSERT( m_pVRoot != 0 ) ;

}

CNNTPVRoot::CNNTPVRoot() {
	m_cchDirectory = 0;
	*m_szDirectory = 0;
	m_pDriver = NULL;
	m_pDriverPrepare = NULL;
#ifdef DEBUG
	m_pDriverBackup = NULL;
#endif
	m_hImpersonation = NULL;
	m_clsidDriverPrepare = GUID_NULL;
	m_eState = VROOT_STATE_UNINIT;
	m_pMB = NULL;
	m_bExpire = FALSE;
    m_eLogonInfo = VROOT_LOGON_DEFAULT;
    m_lDecCompleted = 1;
    m_fUpgrade = FALSE;
    m_dwWin32Error = NOERROR;
}

CNNTPVRoot::~CNNTPVRoot() {
	DropDriver();
	if ( m_hImpersonation ) CloseHandle( m_hImpersonation );
	if ( m_pMB ) m_pMB->Release();
}

void CNNTPVRoot::DropDriver() {
	INntpDriver *pDriver;
	INntpDriverPrepare *pDriverPrepare;
	
	m_lock.ExclusiveLock();
	Verify();
	pDriverPrepare = m_pDriverPrepare;
	m_pDriverPrepare = NULL;
	pDriver = m_pDriver;
	m_pDriver = NULL;
#ifdef DEBUG
	m_pDriverBackup = NULL;
#endif
	m_eState = VROOT_STATE_UNINIT;
	m_lock.ExclusiveUnlock();
	SetVRootErrorCode(ERROR_PIPE_NOT_CONNECTED);	

	if (pDriverPrepare) pDriverPrepare->Release();
	if (pDriver) pDriver->Release();
}

#ifdef DEBUG
//
// do a bunch of asserts which verify that our member variables are valid.
//
// this should only be called while a lock is held (shared or exclusive)
//
void CNNTPVRoot::Verify(void) {
	_ASSERT(m_pDriverBackup == m_pDriver);
	switch (m_eState) {
		case VROOT_STATE_UNINIT:
			_ASSERT(m_pDriver == NULL);
			_ASSERT(m_pDriverPrepare == NULL);
			break;
		case VROOT_STATE_CONNECTING:
			// the driver may be NULL if the store driver is halfway through
			// connecting
			//
			// _ASSERT(m_pDriver == NULL);
			_ASSERT(m_pDriverPrepare != NULL);
			break;
		case VROOT_STATE_CONNECTED:
			_ASSERT(m_pDriver != NULL);
			_ASSERT(m_pDriverPrepare == NULL);
			break;
		default:
			_ASSERT(m_eState == VROOT_STATE_UNINIT ||
					m_eState == VROOT_STATE_CONNECTING ||
					m_eState == VROOT_STATE_CONNECTED);
			break;
	}
}
#endif

BOOL CNNTPVRoot::CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    )
/*++

Routine Description:

    Given a user name potentially in the form domain\user, zero terminates
    the domain name and returns pointers to the domain name and the user name

Arguments:

    pszDomainAndUser - Pointer to user name or domain and user name
    ppszUser - Receives pointer to user portion of name
    ppszDomain - Receives pointer to domain portion of name

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    static CHAR szDefaultDomain[MAX_COMPUTERNAME_LENGTH+1];

    //
    //  Crack the name into domain/user components.
    //

    *ppszDomain = pszDomainAndUser;
    *ppszUser   = (PCHAR)_mbspbrk( (PUCHAR)pszDomainAndUser, (PUCHAR)"/\\" );

    if( *ppszUser == NULL )
    {
        //
        //  No domain name specified, just the username so we assume the
        //  user is on the local machine
        //

        if ( !*szDefaultDomain )
        {
            _ASSERT( pfnGetDefaultDomainName );
            if ( !pfnGetDefaultDomainName( szDefaultDomain,
                                        sizeof(szDefaultDomain)))
            {
                return FALSE;
            }
        }

        *ppszDomain = szDefaultDomain;
        *ppszUser   = pszDomainAndUser;
    }
    else
    {
        //
        //  Both domain & user specified, skip delimiter.
        //

        **ppszUser = L'\0';
        (*ppszUser)++;

        if( ( **ppszUser == L'\0' ) ||
            ( **ppszUser == L'\\' ) ||
            ( **ppszUser == L'/' ) )
        {
            //
            //  Name is of one of the following (invalid) forms:
            //
            //      "domain\"
            //      "domain\\..."
            //      "domain/..."
            //

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    return TRUE;
}

//
// Logon on the user, return the impersonation token
//
HANDLE CNNTPVRoot::LogonUser(   LPSTR  szAccountName,
                                LPSTR  szPassWord )
{
    TraceFunctEnter( "CNNTPVRoot::LogonUser" );
    _ASSERT( szAccountName );
    _ASSERT( szPassWord );

    CHAR       szDomainAndUser[DNLEN+UNLEN+2];
    CHAR   *   szUserOnly;
    CHAR   *   szDomain;
    HANDLE      hToken = NULL;
    BOOL        fReturn;

    //
    //  Validate parameters & state.
    //
    _ASSERT( *szAccountName != 0 );
    _ASSERT( strlen( szAccountName ) < sizeof( szDomainAndUser ) );
    _ASSERT( strlen( szPassWord ) <= PWLEN );

    //
    //  Save a copy of the domain\user so we can squirrel around
    //  with it a bit.
    //

    strcpy( szDomainAndUser, szAccountName );

    //
    //  Crack the name into domain/user components.
    //  Then try and logon as the specified user.
    //

    fReturn = ( CrackUserAndDomain( szDomainAndUser,
                                   &szUserOnly,
                                   &szDomain ) &&
               ::LogonUserA(szUserOnly,
                          szDomain,
                          szPassWord,
                          LOGON32_LOGON_INTERACTIVE, //LOGON32_LOGON_NETWORK,
                          LOGON32_PROVIDER_DEFAULT,
                          &hToken )
               );

    if ( !fReturn) {

        //
        //  Logon user failed.
        //

        ErrorTrace( 0, " CrachUserAndDomain/LogonUser (%s) failed Error=%d\n",
                       szAccountName, GetLastError());

        hToken = NULL;
    } else {
        HANDLE hImpersonation = NULL;

        // we need to obtain the impersonation token, the primary token cannot
        // be used for a lot of purposes :(
        if (!DuplicateTokenEx( hToken,      // hSourceToken
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,  // Obtain impersonation
                               TokenImpersonation,
                               &hImpersonation)  // hDestinationToken
            ) {

            DebugTrace( 0, "Creating ImpersonationToken failed. Error = %d\n",
                        GetLastError()
                        );

            // cleanup and exit.
            hImpersonation = NULL;

            // Fall through for cleanup
        }

        //
        // close original token. If Duplicate was successful,
        //  we should have ref in the hImpersonation.
        // Send the impersonation token to the client.
        //
        CloseHandle( hToken);
        hToken = hImpersonation;
    }

    //
    //  Success!
    //

    return hToken;

} // LogonUser()

//
// reads the following parameters:
//
// MD_VR_PATH -> m_szDirectory
// MD_VR_DRIVER_PROGID -> m_clsidDriverPrepare
//
// calls StartConnecting()
//
HRESULT CNNTPVRoot::ReadParameters(IMSAdminBase *pMB, METADATA_HANDLE hmb) {
	TraceFunctEnter("CNNTPVRoot::ReadParameters");

	_ASSERT(m_pMB == NULL);
	m_pMB = pMB;
	m_pMB->AddRef();

	HRESULT hr = CIISVRoot::ReadParameters(m_pMB, hmb);

	if (FAILED(hr)) return hr;

	_ASSERT(m_eState == VROOT_STATE_UNINIT);
	Verify();

	WCHAR wszDirectory[MAX_PATH];
	DWORD cch = MAX_PATH;
	if (FAILED(GetString(m_pMB, hmb, MD_VR_PATH, wszDirectory, &cch))) {
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		TraceFunctLeave();
		DebugTrace((DWORD_PTR) this, "GetString failed with %x", hr);
		return hr;
	}

	if (WideCharToMultiByte(CP_ACP, 0,
							wszDirectory, cch,
							m_szDirectory, MAX_PATH,
							NULL, NULL) == 0)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace((DWORD_PTR) this, "WideCharToMultiByte failed with %x", hr);
		TraceFunctLeave();
		return hr;
	}
	m_cchDirectory = lstrlen(m_szDirectory);

	// get the progid for the driver that we want to use.  if it isn't
	// specified then we'll use the CLSID for the exchange store driver.
	// there is a "special" progid called "TestNT.NoDriver" that disables
	// the drivers.
	WCHAR wszProgId[MAX_PATH];
	cch = MAX_PATH;
	if (FAILED(GetString(m_pMB, hmb, MD_VR_DRIVER_PROGID, wszProgId, &cch))) {
		lstrcpyW(wszProgId, DEFAULT_DRIVER_PROGID);
	}

	// Initialize the logon info to default value
	m_eLogonInfo = VROOT_LOGON_DEFAULT;

	if (lstrcmpW(wszProgId, NO_DRIVER_PROGID) != 0) {

	    // If it's FS Driver, we check whether it's UNC and whether we need
	    // to use vroot level logon credential
	    if (    _wcsicmp( wszProgId, DEFAULT_DRIVER_PROGID ) == 0 &&
    	        *m_szDirectory == '\\' && *(m_szDirectory+1) == '\\' ) {   // UNC
    	    DWORD dwUseAccount = 0;
            hr = GetDWord( m_pMB, hmb, MD_VR_USE_ACCOUNT, &dwUseAccount );
            if ( FAILED( hr ) || dwUseAccount == 1 ) m_eLogonInfo = VROOT_LOGON_UNC;
        } else if ( _wcsicmp( wszProgId, EX_DRIVER_PROGID ) == 0 ) {
            // Exchange vroot
            m_eLogonInfo = VROOT_LOGON_EX;
        }

        // For UNC , we'll need the vroot logon token, do logon
        if ( m_eLogonInfo == VROOT_LOGON_UNC  ) {

            WCHAR   wszAccountName[MAX_PATH+1];
            CHAR    szAccountName[MAX_PATH+1];
            WCHAR   wszPassword[MAX_PATH+1];
            CHAR    szPassword[MAX_PATH+1];
            DWORD   cchAccountName = MAX_PATH;
            DWORD   cchPassword = MAX_PATH;

            if ( SUCCEEDED( hr = GetString(  m_pMB,
                                        hmb,
                                        MD_VR_USERNAME,
                                        wszAccountName,
                                        &cchAccountName ) )
                  && SUCCEEDED( hr = GetString(  m_pMB,
                                            hmb,
                                            MD_VR_PASSWORD,
                                            wszPassword,
                                            &cchPassword ) )) {
                CopyUnicodeStringIntoAscii( szAccountName, wszAccountName );
                CopyUnicodeStringIntoAscii( szPassword, wszPassword );
                m_hImpersonation = LogonUser(   szAccountName,
                                                    szPassword );
                if ( NULL == m_hImpersonation ) {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    ErrorTrace( 0, "Logon using vroot account failed %x", hr );
                    TraceFunctLeave();
                    return hr;
                }
            } else {

                // Logon credential missing in vroot configuration, this is also fatal
                ErrorTrace( 0, "Logon credential missing in vroot configuration" );
                TraceFunctLeave();
                return hr;
            }

            _ASSERT( NULL != m_hImpersonation );
        }
	
		// get a CLSID for the driver
		hr = CLSIDFromProgID(wszProgId, &m_clsidDriverPrepare);
		if (FAILED(hr)) {
			// BUGBUG - log an event about an invalid progid being supplied
			DebugTrace((DWORD_PTR) this, "CLSIDFromProgID failed with %x", hr);
			TraceFunctLeave();
			return hr;
		}

		m_lock.ExclusiveLock();
		hr = StartConnecting();
		m_lock.ExclusiveUnlock();
	} else {
		hr = S_OK;
	}

    // Read the expire configuration, does the vroot handle expire itself ?
	DWORD   dwExpire;
	if ( SUCCEEDED( GetDWord( m_pMB, hmb, MD_VR_DO_EXPIRE, &dwExpire ) ) ) {
	    m_bExpire = ( dwExpire == 0 ) ? FALSE : TRUE;
	} else m_bExpire = FALSE;
	
	DebugTrace((DWORD_PTR) this, "success");
	return hr;
}

void
CNNTPVRoot::DispatchDropVRoot(
    )
/*++

Description:

    This function handles orphan VRoot during VRootRescan/VRootDelete
    We need to drop PrepareDriver, if exists.
    Can't drop good driver because it's gaurantee to complete operations,
    plus dropping good driver may result in unexpected AV!!!

Arguments:

    NONE

Return Values:

    NONE
--*/
{
	INntpDriverPrepare *pDriverPrepare;
	
	m_lock.ExclusiveLock();
	Verify();
	pDriverPrepare = m_pDriverPrepare;
	m_pDriverPrepare = NULL;
	m_lock.ExclusiveUnlock();

	if (pDriverPrepare) pDriverPrepare->Release();
}

HRESULT CNNTPVRoot::MapGroupToPath(const char *pszGroup,
								   char *pszPath,
								   DWORD cchPath,
								   PDWORD pcchDirRoot,
								   PDWORD pcchVRoot)
{
	DWORD cchVRoot;
	const char *pszVRoot = GetVRootName(&cchVRoot);

	if (_snprintf(pszPath, cchPath, "%s%s%s",
				  m_szDirectory,
				  (pszGroup[cchVRoot] == '.') ? "" : "\\",
				  &(pszGroup[cchVRoot])) < 0)
	{
		return E_INVALIDARG;
	}

	for (char *p = &pszPath[lstrlen(m_szDirectory)]; *p != 0; p++) {
		if (*p == '.') *p = '\\';
	}

	if (pcchDirRoot != NULL) *pcchDirRoot = m_cchDirectory;
	if (pcchVRoot != NULL) *pcchVRoot = cchVRoot;

	return S_OK;
}

//
// Set the key MD_WIN32_ERROR on the virtual root
//
void CNNTPVRoot::SetVRootErrorCode(DWORD dwErrorCode) {
	METADATA_HANDLE hmb;
	HRESULT hr;

//
//	BUG 74747 : this will cause MB deadlocks !!
//	Contact RajeevR for details.
//
#if 0	
	hr = m_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
				   		m_wszConfigPath,
				   		METADATA_PERMISSION_WRITE,
				   		100,
				   		&hmb);

	if (SUCCEEDED(hr)) {
		METADATA_RECORD mdr = {
			MD_WIN32_ERROR,
			0,
			ALL_METADATA,
			DWORD_METADATA,
			sizeof(DWORD),
			(BYTE *) &dwErrorCode,
			0
		};

		hr = m_pMB->SetData(hmb, L"", &mdr);
		// we don't do anything if this fails

		hr = m_pMB->CloseKey(hmb);
		_ASSERT(SUCCEEDED(hr));
	}
#endif
    //
    // Set it through instance wrapper
    //
    /*
    CHAR    szVRootPath[METADATA_MAX_NAME_LEN+1];
    _ASSERT( m_pVRootTable );
    _ASSERT( ((CNNTPVRootTable*)m_pVRootTable)->GetInstWrapper() );
    CopyUnicodeStringIntoAscii( szVRootPath, m_wszConfigPath);
    ((CNNTPVRootTable*)m_pVRootTable)->GetInstWrapper()->SetWin32Error( szVRootPath, dwErrorCode );
    */

    //
    // OK, now we have the rpc to get win32 error, we set it to
    // a internal member variable
    //
    m_dwWin32Error = dwErrorCode;
}

//
// move us from VROOT_STATE_UNINIT to VROOT_STATE_CONNECTING.
//
// returns: S_OK if state was changed properly, or an error otherwise.
//
// locking: assumes the exclusive lock is held
//
HRESULT CNNTPVRoot::StartConnecting() {
        INntpDriverPrepare *pPrepareDriver = NULL;
	TraceFunctEnter("CNNTPVRoot::StartConnecting");
	HANDLE  hToken = m_hImpersonation ? m_hImpersonation :
	                    g_hProcessImpersonationToken;

	Verify();

	//
	// Set the vroot error code to say that we are connecting
	//
	SetVRootErrorCode(ERROR_PIPE_NOT_CONNECTED);

	_ASSERT(m_eState != VROOT_STATE_CONNECTED);
	if (m_eState != VROOT_STATE_UNINIT) return E_UNEXPECTED;

	HRESULT hr;

	// this can happen if the special "no driver" progid was used.  This
	// should only be used in unit test situations.
	if (m_clsidDriverPrepare == GUID_NULL) { return E_INVALIDARG; }

	// create the driver
	hr = CoCreateInstance(m_clsidDriverPrepare,
						  NULL,
						  CLSCTX_INPROC_SERVER,
						  (REFIID) IID_INntpDriverPrepare,
						  (void **) &m_pDriverPrepare);
	if (FAILED(hr)) {
		DebugTrace((DWORD_PTR) this, "CoCreateInstance failed with %x", hr);
		TraceFunctLeave();
		return hr;
	}
	_ASSERT(m_pDriverPrepare != NULL);

	// create a new completion object
	CNNTPVRoot::CPrepareComplete *pComplete = XNEW CNNTPVRoot::CPrepareComplete(this);
	if (pComplete == NULL) {
		DebugTrace((DWORD_PTR) this, "new CPrepareComplete failed");
		m_pDriverPrepare->Release();
		m_pDriverPrepare = NULL;
		TraceFunctLeave();
		return E_OUTOFMEMORY;
	}

	m_eState = VROOT_STATE_CONNECTING;

        //
        // We can not call into driver while holding a lock, so we are releasing
        // the lock.  But before releasing the lock, we'll save off the prepare
        // driver to stack, add ref to it, since m_pPrepareDriver could be dropped
        // to NULL by DropDriver while we are outside the lock
        //
    pPrepareDriver = m_pDriverPrepare;
    pPrepareDriver->AddRef();
	m_lock.ExclusiveUnlock();

	// get a pointer to the server object
	INntpServer *pNntpServer;
	hr = GetContext()->GetNntpServer(&pNntpServer);
	if (FAILED(hr)) {
		// this should never happen
		_ASSERT(FALSE);
		DebugTrace((DWORD_PTR) this, "GetNntpServer failed with 0x%x", hr);
		pPrepareDriver->Release();
		pPrepareDriver->Release();
		pPrepareDriver = NULL;
		TraceFunctLeave();
		return hr;
	}

	// add a reference to the metabase on the drivers behalf
	m_pMB->AddRef();
	pNntpServer->AddRef();
	GetContext()->AddRef();

	// Prepare the flag to tell driver whether we are right after upgrade
	DWORD   dwFlag = 0;
	if ( m_fUpgrade ) dwFlag |= NNTP_CONNECT_UPGRADE;

	// start the driver initialization process
	_ASSERT( pPrepareDriver );
	pPrepareDriver->Connect(GetConfigPath(),
							  GetVRootName(),
							  m_pMB,
							  pNntpServer,
							  GetContext(),
							  &(pComplete->m_pDriver),
							  pComplete,
							  hToken,
							  dwFlag );

	//
	// We should make sure that driver has added a ref to prepare driver
	// before returning on this thread, so that DropDriver doesn't
	// destroy the prepare driver while it's still being accessed by
	// the connect thread
	//
	pPrepareDriver->Release();

	m_lock.ExclusiveLock();

	Verify();

	TraceFunctLeave();
	return hr;
}

//
// this is called before a driver operation to verify that we are in the
// connected state.  it returns FALSE otherwise.  if we are in the
// UNINIT state then this will try to get us into the connecting state
//
// locking: assumes the share lock is held
//
BOOL CNNTPVRoot::CheckState() {
	Verify();

	switch (m_eState) {
		case VROOT_STATE_CONNECTING:
			return FALSE;
			break;
		case VROOT_STATE_CONNECTED:
			return TRUE;
			break;
		default:
			_ASSERT(m_eState == VROOT_STATE_UNINIT);
			//
			// here we make an attempt to connect.  this requires
			// switching to an exclusive lock, starting the connection
			// process, then switching back to the shared
			// lock and seeing what state we are in.
			//
			if (!m_lock.SharedToExclusive()) {
				// if we couldn't migrate the lock (because others held the
				// shared lock at the same time) then release our lock and
				// explicitly grab the exclusive lock.
				m_lock.ShareUnlock();
				m_lock.ExclusiveLock();
			}
			if (m_eState == VROOT_STATE_UNINIT) StartConnecting();
			m_lock.ExclusiveToShared();
			// if we are now connected then return TRUE, otherwise return
			// FALSE
			return (m_eState == VROOT_STATE_CONNECTED);
			break;
	}
}

//
// check to see if the HRESULT is due to a driver going down.  if
// so drop our connection to the driver and update our state
//
// locking: assumes no lock is held
//
void CNNTPVRoot::UpdateState(HRESULT hr) {
	if (hr == NNTP_E_REMOTE_STORE_DOWN) {
		m_lock.ExclusiveLock();

		//
		// we can't assume our state here because multiple threads could
		// enter UpdateState() with the same error code at the same time.
		//
		if (m_eState == VROOT_STATE_CONNECTED) {
			// if we are connected then we should have a driver interface but
			// no prepare interface
			_ASSERT(m_pDriver != NULL);
			_ASSERT(m_pDriverPrepare == NULL);
			m_pDriver->Release();
			m_pDriver = NULL;
#ifdef DEBUG
			m_pDriverBackup = NULL;
#endif
			m_eState = VROOT_STATE_UNINIT;

			StartConnecting();
		}

		m_lock.ExclusiveUnlock();
	}
}

/////////////////////////////////////////////////////////////////////////
// WRAPPERS FOR DRIVER OPERATIONS                                      //
/////////////////////////////////////////////////////////////////////////

void CNNTPVRoot::DecorateNewsTreeObject(CNntpComplete *pCompletion) {
	TraceFunctEnter("CNNTPVRoot::DecorateNewsTreeObject");
	
	INntpDriver *pDriver;
	HANDLE      hToken;

	DebugTrace((DWORD_PTR) this, "in DecorateNewsTreeObject wrapper");

	// If we have UNC Vroot configuration, we'll use
	// the vroot level token, otherwise use the process token, because
	// the decorate newstree operation is done in system context
	_ASSERT( g_hProcessImpersonationToken );

	if ( m_eLogonInfo == VROOT_LOGON_EX ) hToken = NULL;    // use system
	else if ( m_hImpersonation ) hToken = m_hImpersonation;
	else hToken = g_hProcessImpersonationToken;
	
	pCompletion->SetVRoot(this);
	if ((pDriver = GetDriver( pCompletion ))) {
		pDriver->DecorateNewsTreeObject(hToken, pCompletion);
		pDriver->Release();
	} else {
	    pCompletion->SetResult(E_UNEXPECTED);
	    pCompletion->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::CreateGroup(   INNTPPropertyBag *pGroup,
                                CNntpComplete *pCompletion,
                                HANDLE      hToken,
                                BOOL fAnonymous ) {
	TraceFunctEnter("CNNTPVRoot::CreateGroup");
	
	INntpDriver *pDriver;

	DebugTrace((DWORD_PTR) this, "in CreateGroup wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
	else {
        if( !hToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;   // use system
            else hToken = g_hProcessImpersonationToken;
        }
    }
	
	pCompletion->SetVRoot(this);

    pCompletion->BumpGroupCounter();
	if ((pDriver = GetDriver( pCompletion ))) {
		pDriver->CreateGroup(pGroup, hToken, pCompletion, fAnonymous );
		pDriver->Release();
	} else {
		if (pGroup) pCompletion->ReleaseBag( pGroup );
		pCompletion->SetResult(E_UNEXPECTED);
	    pCompletion->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::RemoveGroup(   INNTPPropertyBag *pGroup,
                                CNntpComplete *pCompletion ) {
	TraceFunctEnter("CNNTPVRoot::RemoveGroup");
	
	INntpDriver *pDriver;
	HANDLE  hToken;

	DebugTrace((DWORD_PTR) this, "in RemoveGroup wrapper");

    if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
    else {
        if ( VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;    //use system
        else hToken = g_hProcessImpersonationToken;
    }
	
	pCompletion->SetVRoot(this);
	pCompletion->BumpGroupCounter();
	if ((pDriver = GetDriver( pCompletion ))) {
		pDriver->RemoveGroup(pGroup, hToken, pCompletion, FALSE );
		pDriver->Release();
	} else {
		if (pGroup) pCompletion->ReleaseBag( pGroup );
		pCompletion->SetResult(E_UNEXPECTED);
	    pCompletion->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::SetGroup(  INNTPPropertyBag    *pGroup,
                            DWORD       cProperties,
                            DWORD       idProperties[],
                            CNntpComplete *pCompletion )
{
	TraceFunctEnter("CNNTPVRoot::SetGroup");
	
	_ASSERT( pGroup );
    _ASSERT( pCompletion );

	DebugTrace((DWORD_PTR) this, "in SetGroup wrapper");

    INntpDriver *pDriver;
    HANDLE  hToken;

    // There is no control set group, so we'll use either process
    // or store's administrator token here.
    if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
    else {
        if ( VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;    // use system
        else hToken = g_hProcessImpersonationToken;
    }

    pCompletion->SetVRoot( this );
    pCompletion->BumpGroupCounter();
    if ( (pDriver = GetDriver( pCompletion ))) {
        pDriver->SetGroupProperties(    pGroup,
                                        cProperties,
                                        idProperties,
                                        hToken,
                                        pCompletion,
                                        FALSE );
        pDriver->Release();
	} else {
		if (pGroup) pCompletion->ReleaseBag( pGroup );
		pCompletion->SetResult(E_UNEXPECTED);
	    pCompletion->Release();
    }

	Verify();
	TraceFunctLeave();
}

void
CNNTPVRoot::GetArticle(		CNewsGroupCore  *pPrimaryGroup,
							CNewsGroupCore  *pCurrentGroup,
							ARTICLEID       idPrimary,
							ARTICLEID       idCurrent,
							STOREID         storeid,
							FIO_CONTEXT     **ppfioContext,
							HANDLE          hImpersonate,
							CNntpComplete   *pComplete,
                            BOOL            fAnonymous )
{
	TraceFunctEnter("CNNTPVRoot::GetArticle");

	
	//
	//	The primary Group cannot be NULL - although the secondary one may !
	//
	_ASSERT( pPrimaryGroup != 0 ) ;

	DebugTrace((DWORD_PTR) this, "in GetArticle wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hImpersonate = m_hImpersonation;
	else {
        if( !hImpersonate ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hImpersonate = NULL;
            else hImpersonate = g_hProcessImpersonationToken;
        }
    }
	
	INntpDriver *pDriver;
	pComplete->SetVRoot(this);
	if ((pDriver = GetDriver( pComplete ))) {
		INNTPPropertyBag *pPrimaryBag = pPrimaryGroup->GetPropertyBag();
		pComplete->BumpGroupCounter();
		INNTPPropertyBag *pCurrentBag = 0 ;
		if( pCurrentGroup ) {
			pCurrentBag = pCurrentGroup->GetPropertyBag();
			pComplete->BumpGroupCounter();
	    }
		pDriver->GetArticle(pPrimaryBag,
							pCurrentBag,
							idPrimary,
							idCurrent,
							storeid,
							hImpersonate,
							(void **) ppfioContext,
							pComplete,
                            fAnonymous );
		pDriver->Release();
	} else {
	    pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
	}

	Verify();
	TraceFunctLeave();
}

void	
CNNTPVRoot::GetXover(	IN	CNewsGroupCore	*pGroup,
						IN	ARTICLEID		idMinArticle,
						IN	ARTICLEID		idMaxArticle,
						OUT	ARTICLEID		*pidLastArticle,
						OUT	char*			pBuffer,
						IN	DWORD			cbIn,
						OUT	DWORD*			pcbOut,
						IN	HANDLE			hToken,
						IN	CNntpComplete*	pComplete,
                        IN  BOOL            fAnonymous
						) 	{
/*++	



Routine Description :

	This function wraps access to the storage driver for retrieving
	XOVER information.   We take a generic completion object and set
	it up to capture Driver error codes etc... that we would want to
	cause us to reset our VROOOTs etc....

Arguments :

	pGroup	The Group that we are getting XOVER data for
	idMinArticle	The smallest article number that we want INCLUDED in the
		XOVER result set !
	idMaxArticle	The smallest article number that we want EXCLUDED from the
		XOVER data set, all smaller article numbers should be INCLUDED
	pidLastArticle	



--*/
	TraceFunctEnter("CNNTPVRoot::GetXover");

	//
	//	The primary Group cannot be NULL - although the secondary one may !
	//
	_ASSERT( pGroup != 0 ) ;
	_ASSERT( idMinArticle != INVALID_ARTICLEID ) ;
	_ASSERT( idMaxArticle != INVALID_ARTICLEID ) ;
	_ASSERT( pidLastArticle != 0 ) ;
	_ASSERT( pBuffer != 0 ) ;
	_ASSERT( cbIn != 0 ) ;
	_ASSERT( pcbOut != 0 ) ;
	_ASSERT( pComplete != 0 ) ;

	DebugTrace(0, "in GetXover wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
	else {
        if( !hToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;
            else hToken = g_hProcessImpersonationToken;
        }
    }

	INntpDriver *pDriver;
	pComplete->SetVRoot(this);
	if ((pDriver = GetDriver( pComplete ))) {
		INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
		pComplete->BumpGroupCounter();
		pDriver->GetXover(	pBag,
							idMinArticle,
							idMaxArticle,
							pidLastArticle,
							pBuffer,
							cbIn,
							pcbOut,
							hToken,
							pComplete,
							fAnonymous
							) ;
		pDriver->Release();
	} else {
	    pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
	}

	Verify();
	TraceFunctLeave();
}


		//
		//	Wrap calls to the drivers to get the path for XOVER caching !
		//
BOOL	
CNNTPVRoot::GetXoverCacheDir(	
					IN	CNewsGroupCore*	pGroup,
					OUT	char*	pBuffer,
					IN	DWORD	cbIn,
					OUT	DWORD*	pcbOut,
					OUT	BOOL*	pfFlatDir
					) 	{

	_ASSERT( pGroup != 0 ) ;
	_ASSERT( pBuffer != 0 ) ;
	_ASSERT( pcbOut != 0 ) ;
	_ASSERT( pfFlatDir != 0 ) ;

	INntpDriver *pDriver;
	HRESULT hr  ;
	if ((pDriver = GetDriverHR( &hr ))) {
		INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
		hr = pDriver->GetXoverCacheDirectory(	
							pBag,
							pBuffer,
							cbIn,
							pcbOut,
							pfFlatDir
							) ;
		pDriver->Release();
		if( SUCCEEDED(hr ) ) {
			return	TRUE ;
		}
	}
	return	FALSE ;
}



void	
CNNTPVRoot::GetXhdr(	IN	CNewsGroupCore	*pGroup,
						IN	ARTICLEID		idMinArticle,
						IN	ARTICLEID		idMaxArticle,
						OUT	ARTICLEID		*pidLastArticle,
						LPSTR               szHeader,
						OUT	char*			pBuffer,
						IN	DWORD			cbIn,
						OUT	DWORD*			pcbOut,
						IN	HANDLE			hToken,
						IN	CNntpComplete*	pComplete,
                        IN  BOOL            fAnonymous
						) 	{
/*++	



Routine Description :

	This function wraps access to the storage driver for retrieving
	XHDR information.   We take a generic completion object and set
	it up to capture Driver error codes etc... that we would want to
	cause us to reset our VROOOTs etc....

Arguments :

	pGroup	The Group that we are getting XOVER data for
	idMinArticle	The smallest article number that we want INCLUDED in the
		XOVER result set !
	idMaxArticle	The smallest article number that we want EXCLUDED from the
		XOVER data set, all smaller article numbers should be INCLUDED
	pidLastArticle	



--*/
	TraceFunctEnter("CNNTPVRoot::GetXover");

	//
	//	The primary Group cannot be NULL - although the secondary one may !
	//
	_ASSERT( pGroup != 0 ) ;
	_ASSERT( idMinArticle != INVALID_ARTICLEID ) ;
	_ASSERT( idMaxArticle != INVALID_ARTICLEID ) ;
	_ASSERT( pidLastArticle != 0 ) ;
	_ASSERT( szHeader );
	_ASSERT( pBuffer != 0 ) ;
	_ASSERT( cbIn != 0 ) ;
	_ASSERT( pcbOut != 0 ) ;
	_ASSERT( pComplete != 0 ) ;

	DebugTrace(0, "in GetXover wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hToken = m_hImpersonation;
	else {
        if( !hToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hToken = NULL;
            else hToken = g_hProcessImpersonationToken;
        }
    }

	INntpDriver *pDriver;
	pComplete->SetVRoot(this);
	if ((pDriver = GetDriver( pComplete ))) {
		INNTPPropertyBag *pBag = pGroup->GetPropertyBag();
		pComplete->BumpGroupCounter();
		pDriver->GetXhdr(	pBag,
							idMinArticle,
							idMaxArticle,
							pidLastArticle,
							szHeader,
							pBuffer,
							cbIn,
							pcbOut,
							hToken,
							pComplete,
							fAnonymous
							) ;
		pDriver->Release();
	} else {
	    pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::CommitPost(IUnknown					*punkMessage,
			    		    STOREID						*pStoreId,
						    STOREID						*rgOtherStoreIds,
						    HANDLE                      hClientToken,
						    CNntpComplete				*pComplete,
                            BOOL                        fAnonymous )
{
	TraceFunctEnter("CNNTPVRoot::CommitPost");
	
	INntpDriver *pDriver;
	HANDLE      hImpersonate;

	DebugTrace((DWORD_PTR) this, "in CommitPost wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hClientToken = m_hImpersonation;
	else {
        if( !hClientToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hClientToken = NULL;
            else hClientToken = g_hProcessImpersonationToken;
        }
    }
	
	pComplete->SetVRoot(this);
	if ((pDriver = GetDriver( pComplete ))) {
		pDriver->CommitPost(punkMessage,
		                    pStoreId,
		                    rgOtherStoreIds,
		                    hClientToken ,
		                    pComplete,
		                    fAnonymous );
		pDriver->Release();
	} else {
		if (punkMessage) punkMessage->Release();
		pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::CheckGroupAccess(  INNTPPropertyBag    *pPropBag,
                                    HANDLE              hClientToken,
                                    DWORD               dwAccessDesired,
                                    CNntpComplete       *pComplete )
{
	TraceFunctEnter("CNNTPVRoot::CheckGroupAccess");
	
	INntpDriver *pDriver;
    pComplete->SetVRoot(this);
    pComplete->BumpGroupCounter();

	// BUGBUG - the MMC doesn't set MD_ACCESS_READ in the metabase, so
	// we assume that read always works.
	DWORD dwGenericMask = GENERIC_READ;
	if (GetAccessMask() & MD_ACCESS_READ) dwGenericMask |= GENERIC_READ;
	if (GetAccessMask() & MD_ACCESS_WRITE) dwGenericMask |= GENERIC_WRITE;

    //
    // If we have specified post, create, remove access types but
    // metabase says that it doesn't have write access, then we
    // will fail it
    //
	if ( ((dwGenericMask & GENERIC_WRITE) == 0) && (dwAccessDesired != NNTP_ACCESS_READ) ) {
		pComplete->SetResult(E_ACCESSDENIED);
		if ( pPropBag ) pComplete->ReleaseBag( pPropBag );
		pComplete->Release();
	} else {
	
	    if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
            hClientToken = m_hImpersonation;
        else {
            if ( NULL == hClientToken ) {
	            if ( VROOT_LOGON_EX == m_eLogonInfo ) hClientToken = NULL;
	            else  hClientToken = g_hProcessImpersonationToken;
	        }
	    }
	
	    if ((pDriver = GetDriver( pComplete ))) {
	        pDriver->CheckGroupAccess(  pPropBag,
	                                    hClientToken,
	                                    dwAccessDesired,
	                                    pComplete );
	        pDriver->Release();
		} else {
			if (pPropBag) pComplete->ReleaseBag( pPropBag );
			pComplete->SetResult(E_UNEXPECTED);
			pComplete->Release();
	    }
	}

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::DeleteArticle( INNTPPropertyBag    *pPropBag,
                                DWORD               cArticles,
                                ARTICLEID           rgidArt[],
                                STOREID             rgidStore[],
                                HANDLE              hClientToken,
                                PDWORD              piFailed,
                                CNntpComplete       *pComplete,
                                BOOL                fAnonymous )
{
	TraceFunctEnter("CNNTPVRoot::DeleteArticle");
	
	DebugTrace((DWORD_PTR) this, "in DeleteArticle wrapper");

	if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hClientToken = m_hImpersonation;
	else {
        if( !hClientToken ) {
            if (  VROOT_LOGON_EX == m_eLogonInfo ) hClientToken = NULL;
            else hClientToken = g_hProcessImpersonationToken;
        }
    }

	INntpDriver *pDriver;
    pComplete->SetVRoot(this);
    pComplete->BumpGroupCounter();
    if ( (pDriver = GetDriver( pComplete ))) {
        pDriver->DeleteArticle( pPropBag,
                                cArticles,
                                rgidArt,
                                rgidStore,
                                hClientToken,
                                piFailed,
                                pComplete,
                                fAnonymous );
        pDriver->Release();
	} else {
		if (pPropBag) pComplete->ReleaseBag( pPropBag );
		pComplete->SetResult(E_UNEXPECTED);
	    pComplete->Release();
    }

	Verify();
	TraceFunctLeave();
}

void CNNTPVRoot::RebuildGroup(  INNTPPropertyBag *pPropBag,
                                HANDLE          hClientToken,
                                CNntpComplete   *pComplete )
{
    TraceFunctEnter( "CNNTPVRoot::RebuildGroup" );

    DebugTrace( 0, "in Rebuild group wrapper" );

    if ( m_hImpersonation && VROOT_LOGON_UNC == m_eLogonInfo )
        hClientToken = m_hImpersonation;
    else {
        if ( !hClientToken ) {
            if ( VROOT_LOGON_EX == m_eLogonInfo ) hClientToken = NULL;
            else hClientToken = g_hProcessImpersonationToken;
        }
    }

    INntpDriver *pDriver;
    pComplete->SetVRoot(this);
    pComplete->BumpGroupCounter();
    if ( (pDriver = GetDriver( pComplete ) ) ) {
        pDriver->RebuildGroup(  pPropBag,
                                hClientToken,
                                pComplete );
        pDriver->Release();
    } else {
        if ( pPropBag ) pComplete->ReleaseBag( pPropBag );
        pComplete->SetResult(E_UNEXPECTED);
        pComplete->Release();
    }

    Verify();
    TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////////////
// COMPLETION OBJECTS                                                  //
/////////////////////////////////////////////////////////////////////////

//
// this method is called when the IPrepareDriver::Connect call completes
//
CNNTPVRoot::CPrepareComplete::~CPrepareComplete() {
	TraceFunctEnter("CPrepareComplete");
	
	// temp driver pointers.  if they aren't NULL then a operation will occur
	// after releasing the lock:
	// pDriver - Release()
	// pDriverPrepare - Release()
	// pDriverDecorate - DecorateNewstree(pComplete)
	INntpDriver *pDriver = NULL, *pDriverDecorate = NULL;
	INntpDriverPrepare *pDriverPrepare = NULL;

	// the completion object that we will use with decorate
    CNNTPVRoot::CDecorateComplete *pComplete;
    HANDLE      hToken = NULL;

    GetVRoot()->m_lock.ExclusiveLock();

	DWORD ecVRoot = ERROR_SUCCESS;

	// copy the driver pointer from the completion object to the vroot
	GetVRoot()->m_pDriver = m_pDriver;

#ifdef DEBUG
	GetVRoot()->m_pDriverBackup = GetVRoot()->m_pDriver;
#endif

	// see if the call succeeded
    if (SUCCEEDED(GetResult())) {
		// yes, then update our vroot state and start the decorate newstree
		// process going
        pComplete = XNEW CNNTPVRoot::CDecorateComplete(GetVRoot());
        if (pComplete == NULL) {
			// not enough memory to build a completion object, so tear down
			// the connect
            GetVRoot()->m_eState = VROOT_STATE_UNINIT;
			pDriver = GetVRoot()->m_pDriver;
		    GetVRoot()->m_pDriver = NULL;
#ifdef DEBUG
			GetVRoot()->m_pDriverBackup = NULL;
#endif
			ecVRoot = ERROR_NOT_ENOUGH_MEMORY;
        } else {
			// mark each of the groups in the vroot as not having been
			// visited
			CNewsTreeCore *pTree = ((CINewsTree *) GetVRoot()->GetContext())->GetTree();

			pTree->m_LockTables.ShareLock();

			CNewsGroupCore *p = pTree->m_pFirst;
			while (p) {
				//DebugTrace((DWORD_PTR) this, "reset visited %s", p->GetName());
				// if this group belongs to this vroot then mark its visited
				// flag as FALSE
				CNNTPVRoot *pVRoot = p->GetVRoot();
				if (pVRoot == GetVRoot()) p->SetDecorateVisitedFlag(FALSE);
				if (pVRoot) pVRoot->Release();

			    p = p->m_pNext;
			}        	

			pTree->m_LockTables.ShareUnlock();

			// call DecorateNewstree
			GetVRoot()->SetDecStarted();
			GetVRoot()->m_eState = VROOT_STATE_CONNECTED;
			pDriverDecorate = GetVRoot()->m_pDriver;
			pDriverDecorate->AddRef();
        }
    } else {
		// the call didn't succeed
        GetVRoot()->m_eState = VROOT_STATE_UNINIT;
		HRESULT hr = GetResult();
		ecVRoot = (HRESULT_FACILITY(hr) == FACILITY_NT_BIT) ?
				   HRESULT_CODE(hr) :
				   hr;
    }

    // drop our reference to the prepare interface
	pDriverPrepare = GetVRoot()->m_pDriverPrepare;
	GetVRoot()->m_pDriverPrepare = NULL;
    GetVRoot()->m_lock.ExclusiveUnlock();

	// set the vroot error code
	GetVRoot()->SetVRootErrorCode(ecVRoot);	

 	if (pDriverPrepare) pDriverPrepare->Release();
	// we should never be releasing the driver and decorating it.
	_ASSERT(!(pDriver && pDriverDecorate));
	if (pDriver) pDriver->Release();
	if (pDriverDecorate) {

	    if ( GetVRoot()->m_hImpersonation && VROOT_LOGON_UNC == GetVRoot()->m_eLogonInfo )
            hToken = GetVRoot()->m_hImpersonation;
        else {
            if ( VROOT_LOGON_EX == GetVRoot()->m_eLogonInfo ) hToken = NULL;
            else hToken = g_hProcessImpersonationToken;
        }

		pDriverDecorate->DecorateNewsTreeObject(hToken, pComplete);
		pDriverDecorate->Release();
	}
}

void CNNTPVRoot::CDecorateComplete::CreateControlGroups(INntpDriver *pDriver) {
	char szNewsgroup [3][MAX_NEWSGROUP_NAME];
	BOOL fRet = TRUE;

	TraceFunctEnter("CNNTPVRoot::CPrepareComplete::CreateControlGroups");
	
	lstrcpy(szNewsgroup[0], "control.newgroup");
	lstrcpy(szNewsgroup[1], "control.rmgroup");
	lstrcpy(szNewsgroup[2], "control.cancel");

	CINewsTree *pINewsTree = (CINewsTree *) m_pVRoot->GetContext();
	CNewsTreeCore *pTree = pINewsTree->GetTree();
	CGRPCOREPTR	pGroup;
	HRESULT hr;

    for (int i=0; i<3; i++) {
		INntpDriver *pGroupDriver;

		// check to see if this vroot owns the group.  if not then we
		// shouldn't create it
		hr = pINewsTree->LookupVRoot(szNewsgroup[i], &pGroupDriver);
		if (FAILED(hr)) fRet = FALSE;
		if (FAILED(hr) || pDriver != pGroupDriver) continue;

		// try and create the group.  if it doesn't exist it will be
		// created, or if it does exist then we'll just get a pointer to it
    	BOOL f = pTree->CreateGroup(szNewsgroup[i], TRUE, NULL, FALSE );
		if (!f) {
       	    ErrorTrace(0,"Failed to create newsgroup %s, ec = %i",
				szNewsgroup[i], GetLastError());
       	    fRet = FALSE ;
		}
    }

	if (!fRet) {
		// BUGBUG - log error
	}
}

void CNNTPVRoot::CDecorateComplete::CreateSpecialGroups(INntpDriver *pDriver) {
    TraceFunctEnter( "CNNTPVRoot::CDecorateComplete::CreateSpecialGroups" );

    CINewsTree *pINewsTree = (CINewsTree *)m_pVRoot->GetContext();
    CNewsTreeCore *pTree = pINewsTree->GetTree();
    CGRPCOREPTR pGroup;
    HRESULT hr;

    //
    // Make sure that the group belongs to us
    //
    INntpDriver *pGroupDriver;
    hr = pINewsTree->LookupVRoot( szSlaveGroup, &pGroupDriver );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Lookup vroot for slave group failed %x", hr );
        return;
    }

    if ( pDriver != pGroupDriver ) {
        // It's none of our business
        DebugTrace( 0, "I shouldn't create special group" );
        return;
    }

    //
    // I should create it
    //
    pTree->CreateSpecialGroups();
    TraceFunctLeave();
}

//
// this method is called when the INntpDriver::DecorateNewstree call completes
//
CNNTPVRoot::CDecorateComplete::~CDecorateComplete() {
	TraceFunctEnter("CDecorateComplete");

	HRESULT hr = GetResult();

    GetVRoot()->m_lock.ShareLock();

    //
	// if the vroot state still isn't CONNECTED then this vroot has gone
	// down and we shouldn't do anything
	//
	if (GetVRoot()->m_eState == VROOT_STATE_CONNECTED) {

	    // visit each of the groups in the tree that point to this vroot and
	    // see if they were visited
	    CNewsTreeCore *pTree = ((CINewsTree *) GetVRoot()->GetContext())->GetTree();

	    pTree->m_LockTables.ShareLock();
	    CNewsGroupCore *p = pTree->m_pFirst;
	    while( p && p->IsDeleted() ) p = p->m_pNext;
	    if (p) p->AddRef();
	    pTree->m_LockTables.ShareUnlock();

	    while (p && !(pTree->m_fStoppingTree)) {
		    //DebugTrace((DWORD_PTR) this, "check visited %s, flag = %i",
			//    p->GetName(), p->GetDecorateVisitedFlag());
		    // if this group belongs to this vroot then see if it has been
		    // visited.  if not then delete it
		    CNNTPVRoot *pVRoot = p->GetVRoot();
		    //DebugTrace((DWORD_PTR) this, "vroot 0x%x, group vroot 0x%x",
			//    GetVRoot(), pVRoot);
		    if (pVRoot == GetVRoot() &&         // I am in charge of this vroot
		        (!(p->GetDecorateVisitedFlag()) // The group hasn't been visited
		        || FAILED( hr ) )  ) {          // or we failed in decorate newstree
			    DebugTrace((DWORD_PTR) this, "remove unvisited %s", p->GetName());
			    pTree->RemoveGroupFromTreeOnly(p);
		    }
		    if (pVRoot) pVRoot->Release();

		    pTree->m_LockTables.ShareLock();

            CNewsGroupCore *pOld = p;

		    do {
	            p = p->m_pNext;
	        } while ( p && p->IsDeleted() );
		
		    if (p) p->AddRef();
		    pTree->m_LockTables.ShareUnlock();

		    pOld->Release();
	    }        	
	    if (p) p->Release();

	    // Release hte share lock here before calling into driver
	    GetVRoot()->m_lock.ShareUnlock();

	    //
	    // We should check if decorate newstree succeeded, if failed, we should
	    // release the driver
	    //
        if ( SUCCEEDED( GetResult() ) ) {

            //
	        // Create control groups and special groups
	        //
	        INntpDriver *pDriver = GetVRoot()->GetDriver( NULL );
	        if ( pDriver ) {
	            CreateControlGroups( pDriver );
	            CreateSpecialGroups( pDriver );
	            pDriver->Release();
	        }
	    } else {

	        GetVRoot()->m_lock.ExclusiveLock();

            INntpDriver *pDriver = GetVRoot()->m_pDriver;
            INntpDriverPrepare *pPrepare = GetVRoot()->m_pDriverPrepare;
            GetVRoot()->m_pDriver = NULL;
#ifdef DEBUG
            GetVRoot()->m_pDriverBackup = NULL;
#endif
            GetVRoot()->m_pDriverPrepare = NULL;
            GetVRoot()->m_eState = VROOT_STATE_UNINIT;

            GetVRoot()->m_lock.ExclusiveUnlock();

            GetVRoot()->SetVRootErrorCode( GetResult() );
            if ( pDriver ) pDriver->Release();
            if ( pPrepare ) pPrepare->Release();
        }

    } else {
   	    GetVRoot()->m_lock.ShareUnlock();
    }

    //
    // Set decorate complete flag, this is just for rebuild purpose
    //
    GetVRoot()->SetDecCompleted();
}

void
CNNTPVRootTable::BlockEnumerateCallback(    PVOID   pvContext,
                                            CVRoot  *pVRoot )
/*++
Routine description:

    Check if the vroot is in stable state, if it is, return true
    through context, otherwise false through context

Arguments:

    PVOID   pvContext   - context ( for return value )
    CVRoot  *pVRoot     - VRoot

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::BlockEnumerateCallback" );
    _ASSERT( pvContext );
    _ASSERT( pVRoot );

    //
    // We know that it's safe to cast it back
    //
    CNNTPVRoot *pNntpVRoot = (CNNTPVRoot*)pVRoot;

    *((BOOL*)pvContext) = *((BOOL*)pvContext) && pNntpVRoot->InStableState();
}

void
CNNTPVRootTable::DecCompleteEnumCallback(   PVOID   pvContext,
                                            CVRoot  *pVRoot )
/*++
Routine description:

    Check if the vroot is finished with decorate newstree

Arguments:

    PVOID pvContext     - context ( for return value )
    CVRoot  *pVRoot     - VRoot

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::DecCompleteEnumCallback" );
    _ASSERT( pvContext );
    _ASSERT( pVRoot );

    //
    // We know that it's safe to cast it back
    //
    CNNTPVRoot *pNntpVRoot = (CNNTPVRoot*)pVRoot;

    *((BOOL*)pvContext) = *((BOOL*)pvContext) && pNntpVRoot->DecCompleted();
}

BOOL
CNNTPVRootTable::BlockUntilStable( DWORD dwWaitMSeconds )
/*++
Routine description:

    This function enumerates all the vroots, waits for all of them to reach
    stable state - either CONNECTED or UNINITED.

    The function should not be called during normal server startup.  IT's
    called in rebuild.

Arguments:

    DWORD dwWaitSeconds - How many seconds to wait as the polling interval

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::BlockUntilStable" );
    _ASSERT( dwWaitMSeconds > 0 );

    BOOL    fStable = FALSE;
    HRESULT hr      = S_OK;
    DWORD   dwTimeOutRetries = 10 * 60; // 600 sec, 10 minutes
    DWORD   cRetries = 0;

    //
    // We should wait for all the vroot connection to fail or succeed,
    // if any vroot is hung during connection, we'll time out and fail
    // the rebuild
    //
    while( cRetries++ < dwTimeOutRetries && SUCCEEDED( hr ) && !fStable ) {
        fStable = TRUE;
        hr = EnumerateVRoots( &fStable, BlockEnumerateCallback );
        if ( SUCCEEDED( hr ) && !fStable ) {
            Sleep( dwWaitMSeconds );
        }
    }

    //
    // If we have been timed out, we should return error
    //
    if ( !fStable || FAILED( hr ) ) {
        DebugTrace( 0, "We are timed out waiting for vroot connection" );
        SetLastError( WAIT_TIMEOUT );
        return FALSE;
    }

    //
    // Now we should really block until decoratenewstree to complete
    //
    fStable = FALSE;
    while( SUCCEEDED( hr ) && !fStable ) {
        fStable = TRUE;
        hr = EnumerateVRoots( &fStable, DecCompleteEnumCallback );
        if ( SUCCEEDED( hr ) && !fStable ) {
            Sleep( dwWaitMSeconds );
        }
    }

    return SUCCEEDED( hr );
}

void
CNNTPVRootTable::CheckEnumerateCallback(    PVOID   pvContext,
                                            CVRoot  *pVRoot )
/*++
Routine description:

    Call back function for:
    Check to see if every configured vroot has been successfully connected.

Arguments:

    PVOID   pvContext   - context ( for return value )
    CVRoot  *pVRoot     - VRoot

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::CheckEnumerateCallback" );
    _ASSERT( pvContext );
    _ASSERT( pVRoot );

    //
    // We know that it's safe to cast it back
    //
    CNNTPVRoot *pNntpVRoot = (CNNTPVRoot*)pVRoot;

    *((BOOL*)pvContext) = *((BOOL*)pvContext ) && pNntpVRoot->IsConnected();
}

BOOL
CNNTPVRootTable::AllConnected()
/*++
Routine description;

    This function enumerates all the vroots to see if all of them are
    connected.  The function may be called during rebuild, when the
    rebuild requires to rebuild all the vroots.  It should be called
    after calling BlockUntilStable - when the vroot connection reaches
    stability

Arguments:

    None.

Return value:

    TRUE if every vroot is connected, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::CheckConnections" );

    BOOL    fConnected  = TRUE;
    HRESULT hr          = S_OK;

    hr = EnumerateVRoots( &fConnected, CheckEnumerateCallback );

    return SUCCEEDED( hr ) && fConnected;
}

DWORD
CNNTPVRootTable::GetVRootWin32Error(    LPWSTR  wszVRootPath,
                                        PDWORD  pdwWin32Error )
/*++
Routine description:

    Get the vroot connection status error code

Arguments:

    LPWSTR  wszVRootPath -  The vroot to get connection status from
    PDWORD  pdwWin32Error - To return the win32 error code

Return value:

    NOERROR if succeeded, WIN32 error code otherwise
--*/
{
    TraceFunctEnter( "CNNTPVRootTable::GetVRootWin32Error" );
    _ASSERT( wszVRootPath );
    _ASSERT( pdwWin32Error );

    CHAR    szGroupName[MAX_NEWSGROUP_NAME+1];
    DWORD   dw = NOERROR;

    //
    // Convert the vrpath to ascii
    //
    CopyUnicodeStringIntoAscii( szGroupName, wszVRootPath );

    //
    // Make it look like a news group so that we can do vrtable lookup
    //
    LPSTR   lpstr = szGroupName;
    while( *lpstr ) {
        if ( *lpstr == '/' ) *lpstr = '.';
        *lpstr = (CHAR)tolower( *lpstr );
        lpstr++;
    };

    //
    // Now search for the vroot and get its connection status
    //
    NNTPVROOTPTR pVRoot = NULL;
    HRESULT hr = FindVRoot( szGroupName, &pVRoot );
    if ( pVRoot ) {
        dw = pVRoot->GetVRootWin32Error( pdwWin32Error );
    } else {

        // vroot was not ever configured
        *pdwWin32Error = ERROR_NOT_FOUND;
    }

    TraceFunctLeave();
    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\nntpbld2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nntpbld.rc
//
#define IDS_HELPTEXT                    1
#define IDS_TEMP_DIR                    2
#define IDS_CANT_CREATE_TEMP            3
#define IDS_USING_ACTIVE_FILE           4
#define IDS_FILE_NOT_FOUND              5
#define IDS_USING_GROUP_FILE            6
#define IDS_GEN_FILE                    7
#define IDS_OUTPUT_FILE                 8
#define IDS_CANT_CREATE_FILE            9
#define IDS_REBUILD_ERROR			   10
#define IDS_INVALID_SWITCH			   11
#define IDS_REBUILD_FAILED			   12
#define IDS_GETSTATUS_FAILED		   13
#define IDS_REBUILD_PROGRESS		   14
#define IDS_REBUILD_DONE			   15

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\newstree\utest\testnt.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <stdinc.h>
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

#include "nntpdrv.h"

GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName = NULL;
HANDLE  g_hProcessImpersonationToken = NULL;

// INI file keys, etc
static const char g_pszDefaultSectionName[] = "testnt";
#define INI_KEY_MBPATH "MetabasePath"
#define DEF_KEY_MBPATH "/LM/testnt"
#define INI_KEY_GROUPNAME "Group%i"
#define INI_KEY_INSERTORDER "InsertOrder"
#define INI_KEY_REMOVEORDER "RemoveOrder"
#define INI_KEY_LISTORDER "ListOrder"
#define INI_KEY_WILDMAT "Wildmat"
#define INI_KEY_WILDMATLISTORDER "WildmatListOrder"

// keys expected in the vroot
#define PROGID_NO_DRIVER L"TestNT.NoDriver"
#define VRPATH L""

// an array of groups that we'll play with
DWORD g_cGroups;
char **g_rgszGroupList;
char **g_rgszInsertOrder;
char **g_rgszRemoveOrder;
char **g_rgszListOrder;
DWORD g_cWildmatGroups;
char **g_rgszWildmatListOrder;
char g_szWildmat[1024];

// path to our corner of the metabase
char g_szMBPath[1024];
WCHAR g_wszMBPath[1024];

// our newstree file
char g_szGroupList[1024];
char g_szVarGroupList[1024];

// our vroot table
CNNTPVRootTable *g_pVRTable;
CNewsTreeCore *g_pNewsTree;

// global count of errors
LONG g_cErrors;

void Verify(BOOL fTest, const char *szError, const char *szContext, DWORD dwLine) {
	if (fTest) return;
	InterlockedIncrement(&g_cErrors);
	printf("ERROR: line %i -- %s (%s)\n", dwLine, szError, szContext);
	_ASSERT(FALSE);
}

#define V(__f__, __szError__, __szContext__) Verify(__f__, __szError__, __szContext__, __LINE__)

void StartHintFunction( void )
{}

DWORD INNHash( PBYTE pb, DWORD )
{ return 0; }

BOOL fTestComponents( LPCSTR what )
{ return TRUE; }


// get a DWORD from an INI file
int GetINIDWord(const char *szINIFile, const char *pszSectionName, const char *szKey, int dwDefault) {
	char szBuf[MAX_PATH];

	GetPrivateProfileString(pszSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

VOID
CopyUnicodeStringIntoAscii(
    IN LPSTR AsciiString,
    IN LPWSTR UnicodeString
 )
{
    while ( (*AsciiString++ = (CHAR)*UnicodeString++) != '\0');

} // CopyUnicodeStringIntoAscii

//
// parse a string from the INI file into one of our arrays of groups.
// the string should be a comma delimited list of number which contains no
// duplicates.  the numbers are indexs into the g_rgszGroupList.  this
// builds up rgszArray to be in the order specified by the indexes.
//
// parameters:
//   szINIFile - the INI file to read from
//   pszSectionName - the section in the INI file to read from
//   pszKeyName - the key to read
//   rgszArray - the array of string pointers to populate
//   pdwCount - if this is NULL then this function requires that 
//              rgszArray is populated to be the same length as g_cGroups.
//              otherwise this returns the number of groups in the array.
//
void ParseIntoArray(const char *szINIFile, 
					const char *pszSectionName, 
					const char *pszKeyName, 
					char **rgszArray, 
					DWORD *pdwCount) 
{
	char szBuf[1024];
	GetPrivateProfileString(pszSectionName,
							pszKeyName,
							"",
							szBuf,
							1024,
							szINIFile);

	V(*szBuf != 0, "Missing required key", pszKeyName);

	// used to find duplicates
	BOOL *rgfUsed = new BOOL[g_cGroups];
	V(rgfUsed != NULL, "memory allocation for failed", "rgfUsed");
	ZeroMemory(rgfUsed, sizeof(BOOL) * g_cGroups);

	char *p = szBuf;
	char *pComma = NULL;
	DWORD i = 0;
	do {
		// find the next comma
		pComma = strchr(p, ',');
		// set it to 0 if it exists
		if (pComma != NULL) *pComma = 0; 

		// convert the current text string (which should be anumber) into a #
		DWORD iGroupList = atoi(p);
		// make sure that it is valid
		V(i < g_cGroups, "array contains too many items", pszKeyName);
		V(!(rgfUsed[i]), "array contains duplicate indexes", pszKeyName);
		rgfUsed[i] = TRUE;

		if (i < g_cGroups) {
			V(iGroupList >= 0 && iGroupList < g_cGroups, "array index out of bounds", pszKeyName);
			rgszArray[i] = g_rgszGroupList[iGroupList];
		}
	
		// move our pointer to the next item in the list
		if (pComma != NULL) p = pComma + 1;
		i++;
	} while (pComma != NULL);

	if (pdwCount == NULL) {
		V(i == g_cGroups, "array doesn't contain enough items", pszKeyName);
	} else {
		*pdwCount = i;
	}

	delete[] rgfUsed;
}

// read our parameters from the INI file.  
void ReadINIFile(const char *szINIFile, const char *pszSectionName) {
	char szBuf[1024];
	DWORD i;

	// get the base metabase path
	GetPrivateProfileString(pszSectionName,
							INI_KEY_MBPATH,
							DEF_KEY_MBPATH,
							szBuf,
							1024,
							szINIFile);
	mbstowcs(g_wszMBPath, szBuf, 1024);
	strcpy(g_szMBPath, szBuf);
	printf("metabase path = %s\n", g_szMBPath);

	// get the wildmat used for the wildmat list test
	GetPrivateProfileString(pszSectionName,
							INI_KEY_WILDMAT,
							"",
							szBuf,
							1024,
							szINIFile);
	V(*szBuf != 0, "Required key not found in INI file", INI_KEY_WILDMAT);
	strcpy(g_szWildmat, szBuf);

	printf("reading groups from INI file\n");
	// get the number of vroots listed in the INI file
	for (g_cGroups = 0; *szBuf != 0; g_cGroups++) {
		char szKey[20];
		sprintf(szKey, INI_KEY_GROUPNAME, g_cGroups);
		GetPrivateProfileString(pszSectionName,
								szKey,
								"",
								szBuf,
								1024,
								szINIFile);
	}
	// fix off by one error
	g_cGroups--;
	V(g_cGroups != 0, "at least one group must be specified", NULL);

	// allocate an array of groups
	g_rgszGroupList = new PCHAR[g_cGroups];
	g_rgszInsertOrder = new PCHAR[g_cGroups];
	g_rgszRemoveOrder = new PCHAR[g_cGroups];
	g_rgszListOrder = new PCHAR[g_cGroups];
	g_rgszWildmatListOrder = new PCHAR[g_cGroups];

	for (i = 0; i < g_cGroups; i++) {
		char szKey[20];
		sprintf(szKey, INI_KEY_GROUPNAME, i);
		GetPrivateProfileString(pszSectionName,
								szKey,
								"",
								szBuf,
								1024,
								szINIFile);		
		g_rgszGroupList[i] = new char[lstrlen(szBuf) + 1];
		lstrcpy(g_rgszGroupList[i], szBuf);
	}

	ParseIntoArray(szINIFile, pszSectionName, 
				   INI_KEY_INSERTORDER, g_rgszInsertOrder, NULL);
	ParseIntoArray(szINIFile, pszSectionName, 
				   INI_KEY_REMOVEORDER, g_rgszRemoveOrder, NULL);
	ParseIntoArray(szINIFile, pszSectionName, 
				   INI_KEY_LISTORDER, g_rgszListOrder, NULL);
	ParseIntoArray(szINIFile, pszSectionName, 
				   INI_KEY_WILDMATLISTORDER, g_rgszWildmatListOrder, 
				   &g_cWildmatGroups);

	if (g_cErrors > 0) {
		printf("errors parsing INI file\n");
		exit(g_cErrors);
	}
	printf("read %i groups from INI file\n", g_cGroups);
}

void Initialize(BOOL fDeleteGroupList) {
	HRESULT hr;
	BOOL fFatal;
	static IMSAdminBaseW *pMB;
	METADATA_HANDLE hmRoot;
	
	// initialize COM and the metabase
	printf("initializing metabase\n");
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	V(SUCCEEDED(hr), "CoInitializeEx", NULL);

	hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL, 
						  IID_IMSAdminBase_W, (LPVOID *) &pMB);
	V(hr == S_OK, "CoCreateInstance", NULL);

	// create a vroot entry for the root.  we don't have any other 
	// vroot entries
	printf("creating virtual root hierarchy\n");
	DWORD i = 0;
	do {
		hr = pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE, 
					      L"", 
					      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					      100,
					      &hmRoot);
		if (FAILED(hr) && i++ < 5) Sleep(50);
	} while (FAILED(hr) && i < 5);
	V(hr == S_OK, "metabase OpenKey(root)", NULL);

	// first we delete whatever exists in the metabase under this path,
	// then we create a new area to play in
	pMB->DeleteKey(hmRoot, g_wszMBPath);
	printf("creating key %s\n", g_wszMBPath);
	hr = pMB->AddKey(hmRoot, g_wszMBPath);
	V(hr == S_OK, "AddKey failed", g_szMBPath);
	// we configure one root vroot with parameters set to create no driver
	METADATA_RECORD mdrProgID = { 
		MD_VR_DRIVER_PROGID, 
		METADATA_INHERIT, 
		ALL_METADATA, 
		STRING_METADATA, 
		(lstrlenW(PROGID_NO_DRIVER)+1) * sizeof(WCHAR), 
		(BYTE *) PROGID_NO_DRIVER, 
		0 
	};
	printf("setting MD_VR_DRIVER_PROGID = \"%S\"\n", PROGID_NO_DRIVER);
	hr = pMB->SetData(hmRoot, g_wszMBPath, &mdrProgID);
	V(hr == S_OK, "SetData(MD_VR_DRIVER_PROGID) failed", g_szMBPath);

	METADATA_RECORD mdrVRPath = { 
		MD_VR_PATH, 
		METADATA_INHERIT, 
		ALL_METADATA, 
		STRING_METADATA, 
		(lstrlenW(VRPATH)+1) * sizeof(WCHAR), 
		(BYTE *) VRPATH, 
		0 
	};
	printf("setting MD_VR_PATH = \"%S\"\n", VRPATH);
	hr = pMB->SetData(hmRoot, g_wszMBPath, &mdrVRPath);
	V(hr == S_OK, "SetData(MD_VR_PATH) failed", g_szMBPath);

	pMB->CloseKey(hmRoot);
	pMB->Release();

	// initialize our news tree
	printf("initializing newstree object\n");
	g_pNewsTree = new CNewsTreeCore();
	g_pVRTable = new CNNTPVRootTable(g_pNewsTree->GetINewsTree(), 
									 CNewsTreeCore::VRootRescanCallback);
	g_pNewsTree->Init(g_pVRTable, fFatal, 100, TRUE);

	// initialize the vroot table
	printf("initializing vroot table\n");
	hr = g_pVRTable->Initialize(g_szMBPath);
	printf("g_pVRTable->Initialize(\"%s\") returned %x\n", g_szMBPath, hr);
	V(hr == S_OK, "g_pVRTable->Initialize() failed", g_szMBPath);

	// load the newstree from disk
	// figure out a group.lst filename
	GetEnvironmentVariable("temp", g_szGroupList, 1024);
	lstrcat(g_szGroupList, "\\group.lst");
	printf("using group.lst path %s\n", g_szGroupList);
	if (fDeleteGroupList) DeleteFile(g_szGroupList);
	GetEnvironmentVariable("temp", g_szVarGroupList, 1024);
	lstrcat(g_szVarGroupList, "\\groupvar.lst");
	printf("using groupvar.lst path %s\n", g_szVarGroupList);
	if (fDeleteGroupList) DeleteFile(g_szVarGroupList);
	g_pNewsTree->LoadTree(g_szGroupList, g_szVarGroupList);	
}

void Shutdown() {
	g_pNewsTree->StopTree();
	g_pNewsTree->TermTree();
	delete g_pVRTable;
	delete g_pNewsTree;
}

void List(BOOL fFull = FALSE, CNewsTreeCore *pNT = g_pNewsTree) {
	CGroupIteratorCore *pi = pNT->ActiveGroups();
	DWORD i = 0;

	printf("-- group list\n");
	while (!pi->IsEnd()) {
		char szBuf[1024];
		CGRPCOREPTR pGroup = pi->Current(), pGroup2 = NULL, pGroup3 = NULL;
		INNTPPropertyBag *pGroupBag;

		V(pi != NULL, "pi->Current() returned NULL, shouldn't have", NULL);

		if (fFull) {
			printf("%s %s\n", pGroup->GetNativeName(), pGroup->GetPrettyName());
		} else {
			printf("%s\n", pGroup->GetNativeName());
		}

		// verifying that the native name and group name are the same
		V(_strcmpi(pGroup->GetNativeName(), pGroup->GetName()) == 0, "verify group name and native name are the same", pGroup->GetNativeName());

		// get the native name through the property bag and verify that 
		// it is the same as the native name found through the group.
		pGroupBag = pGroup->GetPropertyBag();
		DWORD dwSize = 1024;
		HRESULT hr = pGroupBag->GetBLOB(NEWSGRP_PROP_NATIVENAME, 
										(BYTE*)szBuf, 
										&dwSize);
		V(hr == S_OK, "use IPropertyBag to get native name (should pass)", pGroup->GetNativeName());
		V(lstrcmp(pGroup->GetNativeName(), szBuf) == 0, "make sure property bag points to correct group", pGroup->GetNativeName());
		pGroupBag->Release();

		// get the group object for this group through the newstree
		// and verify that it is the same
		strcpy(szBuf, pGroup->GetGroupName());
		pGroup2 = pNT->GetGroup(szBuf, pGroup->GetGroupNameLen());
		V(pGroup2 == pGroup, "verify GetGroup found same group (by name)", pGroup->GetNativeName());

		// set the moderator prettyname to be the same as the group name plus "pretty"
		char szPrettyName[1024] = "prettyname for ";
		lstrcat(szPrettyName, pGroup->GetNativeName());
		pGroup->SetPrettyName(szPrettyName);

		// get the group by its groupid and verify that it is the same
		pGroup3 = pNT->GetGroup(pGroup->GetGroupId());
		V(pGroup == pGroup3, "verify GetGroup found same group (by id)", pGroup->GetNativeName());

		// go to the next group
		pi->Next();
		i++;
	}

	printf("%i groups in list\n", i);
}

void List2(CNewsTreeCore *pNT = g_pNewsTree) {
	INewsTreeIterator *pi;
	HRESULT hr = pNT->GetINewsTree()->GetIterator(&pi);
	DWORD i = 0;

	V(hr == S_OK, "GetIterator should return OK", NULL);
	V(pi != NULL, "iterator pointer shouldn't be NULL", NULL);

	printf("-- group list (via COM)\n");
	while (!pi->IsEnd()) {
		char szBuf[1024];
		INNTPPropertyBag *pGroupBag;
		hr = pi->Current(&pGroupBag, NULL );
		V(hr == S_OK, "Current() should return OK", NULL);
		V(pGroupBag != NULL, "Current() shouldn't return NULL", NULL);

		// get the native name through the property bag and verify that 
		// it is the same as the native name found through the group.
		DWORD dwSize = 1024;
		HRESULT hr = pGroupBag->GetBLOB(NEWSGRP_PROP_NATIVENAME, 
										(BYTE*)szBuf, 
										&dwSize);
		V(hr == S_OK, "use IPropertyBag to get native name (should pass)", NULL);
		printf("%s\n", szBuf);
		pGroupBag->Release();

		// go to the next group
		pi->Next();
		i++;
	}

	printf("%i groups in list\n", i);
}

// 
// this should try to hit all of the common uses and error cases of the
// newstree and newsgroup objects
// 
void TestFunctionality() {
	DWORD i;
	HRESULT hr;

	printf("-- start TestFunctionality\n");
	printf("-- adding some groups via CNewsTreeCore\n");
	// in a loop create each of the groups
	for (i = 0; i < g_cGroups; i++) {
		char *szGroup = g_rgszInsertOrder[i];

		printf("%s\n", szGroup);
		V(g_pNewsTree->CreateGroup(szGroup, FALSE), "CreateGroup failed (should pass)", szGroup);
		// try to add it again and verify that it fails
		V(!(g_pNewsTree->CreateGroup(szGroup, FALSE)), "CreateGroup passed (should fail)", szGroup);
	}
	List();

	List2();

	printf("-- verifying list\n");
	// list them and make sure that the list matches what we expect
	CGroupIteratorCore *pi = g_pNewsTree->ActiveGroups();
	i = 0;
	while (!pi->IsEnd()) {
		V(i < g_cGroups, "iterator found more groups then exist", NULL);

		if (i < g_cGroups) {
			char *szGroup = g_rgszListOrder[i];
			CGRPCOREPTR pGroup = pi->Current();

			printf("%s (expect %s)\n", pGroup->GetNativeName(), szGroup);
			V(strcmp(pGroup->GetNativeName(), szGroup) == 0, "group order incorrect", szGroup);
		}

		// go to the next group
		pi->Next();
		i++;
	}

	printf("-- verifying list (wildmat = %s)\n", g_szWildmat);
	// list them and make sure that the list matches what we expect
	pi = g_pNewsTree->GetIterator(g_szWildmat, FALSE);
	i = 0;
	while (!pi->IsEnd()) {
		V(i < g_cWildmatGroups, "iterator found more groups then exist", NULL);

		if (i < g_cWildmatGroups) {
			char *szGroup = g_rgszWildmatListOrder[i];
			CGRPCOREPTR pGroup = pi->Current();

			printf("%s (expect %s)\n", pGroup->GetNativeName(), szGroup);
			V(strcmp(pGroup->GetNativeName(), szGroup) == 0, "group order incorrect", szGroup);
		}

		// go to the next group
		pi->Next();
		i++;
	}

	// 
	// walk the group list and add and remove groups
	//
	for (i = 0; i < g_cGroups; i++) {
		char *szGroup = g_rgszGroupList[i];
		CGRPCOREPTR pGroup;

		// look up a newsgroup
		printf("-- looking for %s\n", szGroup);
		hr = g_pNewsTree->FindOrCreateGroup(szGroup, FALSE, FALSE, FALSE, &pGroup);
		V(hr == S_FALSE, "FindOrCreateGroup, should find it", szGroup);
		
		// remove it
		printf("-- removing %s\n", pGroup->GetGroupName());
		V(g_pNewsTree->RemoveGroup(pGroup), "remove group, should pass", szGroup);
		V(!(g_pNewsTree->RemoveGroup(pGroup)), "remove group, should fail", szGroup);
		pGroup = NULL;
		List();

		// add it again
		printf("-- adding %s\n", szGroup);
		V(g_pNewsTree->CreateGroup(szGroup, FALSE), "CreateGroup failed (should pass)", szGroup);
		V(!(g_pNewsTree->CreateGroup(szGroup, FALSE)), "CreateGroup passed (should fail)", szGroup);
		List();
	}
	
	// remove all of the groups, using an iterator
	printf("-- remove all groups (iterator)\n");
	pi = g_pNewsTree->ActiveGroups();
	i = 0;
	while (!pi->IsEnd()) {
		V(i < g_cGroups, "iterator found more groups then exist", NULL);

		if (i < g_cGroups) {
			CGRPCOREPTR pGroup = pi->Current();
			char *szGroup = g_rgszListOrder[i];

			printf("%s\n", pGroup->GetNativeName());
			V(strcmp(pGroup->GetNativeName(), szGroup) == 0, "group order incorrect", szGroup);
			V(g_pNewsTree->RemoveGroup(pGroup), "RemoveGroup failed (should pass)", szGroup);
			V(!(g_pNewsTree->RemoveGroup(pGroup)), "RemoveGroup passed (should fail)", szGroup);
		}

		// go to the next group
		pi->Next();
		i++;
	}
	List();

	// add the groups back again
	printf("-- adding the groups back again\n");
	// in a loop create each of the groups
	for (i = 0; i < g_cGroups; i++) {
		char *szGroup = g_rgszInsertOrder[i];

		printf("%s\n", szGroup);
		V(g_pNewsTree->CreateGroup(szGroup, FALSE), "CreateGroup failed (should pass)", szGroup);
		// try to add it again and verify that it fails
		V(!(g_pNewsTree->CreateGroup(szGroup, FALSE)), "CreateGroup passed (should fail)", szGroup);
	}
	List();

#if 0
	// remove them all using their names and lookups
	printf("-- remove all groups (by name)\n");
	for (i = 0; i < g_cGroups; i++) {
		char *szGroup = g_rgszRemoveOrder[i];
		CGRPCOREPTR pGroup;

		printf("%s\n", szGroup);
		hr = g_pNewsTree->FindOrCreateGroup(szGroup, FALSE, FALSE, &pGroup);
		V(hr == S_OK, "FindOrCreateGroup, should find it", szGroup);

		V(g_pNewsTree->RemoveGroup(pGroup), "RemoveGroup failed (should pass)", szGroup);
		V(!(g_pNewsTree->RemoveGroup(pGroup)), "RemoveGroup passed (should fail)", szGroup);
	}
	List();
#endif

	printf("-- done in TestFunctionality\n");
}

// 
// this should try to hit all of the common uses and error cases of the
// newstree and newsgroup objects
// 
void DumpGroups() {
	printf("-- start DumpGroups\n");

	List(TRUE);

	printf("-- done in DumpGroups\n");
}

int _cdecl main(int argc, const char **argv) {
	CVRootTable::GlobalInitialize();

	_Module.Init(NULL, (HINSTANCE) INVALID_HANDLE_VALUE);

	int rc;
	g_cErrors = 0;

	if (argc < 2 || argc > 3 || (strcmp(argv[1], "/help") == 0)) {
		printf("usage: testnt inifile [ini section name]\n");
		printf("  default section name is \"testnt\"\n");
		printf("  The following keys are required:\n");
		printf("  * Group%%i - up to N keys consecutively named are expected,\n");
		printf("    with each one consisting of the name of a newsgroup.  The group\n");
		printf("    numbers are zero based and must be consecutive.\n");
		printf("  * InsertOrder - the order that these groups should be inserted\n");
		printf("    in.  The list is a comma delimited set of numbers, where each\n");
		printf("    number corresponds to a group specified with a group key\n");
		printf("  * RemoveOrder - the order that these groups should be removed in.\n");
		printf("  * ListOrder - the order that these groups should be found in\n");
		printf("    when executing a list command.\n");
		printf("  * Wildmat - a wildmat to use for testing the iterator.\n");
		printf("  * WildmatListOrder - the order that these groups should be found in\n");
		printf("    when executing a list command with the specified wildmat.\n");
		printf("  Optional keys:\n");
		printf("  * MetabasePath - where we make our vroot table.  Default is %s\n", DEF_KEY_MBPATH);
		printf("  Example section:\n");
		printf("  [testnt]\n");
		printf("  Group0=alt.test\n");
		printf("  Group1=rec.test\n");
		printf("  InsertOrder=0,1\n");
		printf("  RemoveOrder=1,0\n");
		printf("  ListOrder=0,1\n");
		printf("  Wildmat=r*\n");
		printf("  WildmatListOrder=1\n");
		rc = 1;
	} else {
		const char *pszSectionName = (argc == 2) ? g_pszDefaultSectionName : argv[2];
		printf("reading from INI section %s\n", pszSectionName);
		ReadINIFile(argv[1], pszSectionName);
		Initialize(TRUE);
		TestFunctionality();
		Shutdown();
		Initialize(FALSE);
		DumpGroups();
		Shutdown();
		rc = g_cErrors;
	}

	_Module.Term();

	CVRootTable::GlobalShutdown();

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\nntpbld2\nntpbld.cpp ===
/*++

   Copyright    (c)    1997        Microsoft Corporation

   Module Name:

        nntpbld.cpp

   Abstract:

        This file implements nntpbld.exe using the nntpbld RPCs.

   Author:

        Rajeev Rajan    (RajeevR)      May-10-1997

--*/


//
//  windows headers
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
//  k2 headers
//

#include <inetinfo.h>
#include <norminfo.h>
#include <apiutil.h>

//
//  nntp headers
//

#include <nntptype.h>
#include <nntpapi.h>
#include "resource.h"

//
//  Prototypes
//

VOID
CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPCTSTR AsciiString
        );

HINSTANCE   hModuleInstance = 0 ;
char        StringBuff[4096] ;

void
usage()	{

    LoadString( hModuleInstance, IDS_HELPTEXT, StringBuff, sizeof( StringBuff ) ) ;
    printf( StringBuff ) ;

#if 0
    printf(	"Nntpbld.exe\n"
			"\t Use nntpbld.exe to restore a servers corrupted \n"
			"\t data structures, or to build a server from an active file\n" );
	printf(	"\t-s   Virtual server Id \n") ;
	printf(	"\t-e   Specifies that the non-leaf directories which \n"
			"\t     Do not contain articles should be omitted from the list\n" ) ;
	printf(	"\t-a   <filename>	This will rebuild a server based \n"
			"\t     on the newsgroups contained in the active file <filename>.\n"
			"\t     See documentation on how to produce an active file.\n" ) ;
	printf(	"\t-c   clean build the server \n" ) ;
	printf(	"\t-G   The tool will automatically scan the virtual roots\n"
			"\t     and produce a file containing the list of newsgroups\n" 
			"\t     this file will then be used to rebuild the server \n" ) ;
	printf(	"\tNOTE:    The -a and -G options are mutually exclusive.\n" ) ;
	printf(	"\t-x   Don't delete xix index files \n") ;
	printf(	"\t-w   Number of threads \n") ;
	printf(	"\t-h   Don't delete history file \n") ;
    printf(	"\t-o   <filename> This will be the name of the file in \n"
			"\t     which the rebuild report is saved.\n");
#endif			
} 

int
_cdecl
main(	int	argc,	char*	argv[] ) {

	BOOL	    DiscardEmptyInternalNodes = FALSE ;
	//BOOL	    DeleteIndexFiles = TRUE ;
	DWORD	    ReuseIndexFiles = NNTPBLD_DEGREE_THOROUGH ;
	BOOL        DoClean = FALSE ;
	BOOL        IsActive = FALSE ;
	BOOL        NoHistoryDelete = FALSE ;
	BOOL        SkipCorruptGroup = FALSE ;
	LPSTR	    lpstrGroupFile = 0 ;
	DWORD	    InstanceId = 1;
	DWORD       NumThreads = 1;
	LPWSTR      RemServerW = (PWCH)NULL;
	WCHAR       ServerName[256];
    NET_API_STATUS  err;
	NNTPBLD_INFO	config;
	LPNNTPBLD_INFO	lpconfig = NULL;
	WCHAR       GroupListFile [ MAX_PATH ];
	WCHAR       ReportFile	  [ MAX_PATH ];
	DWORD	    ParmErr ;
	LPVOID 		lpMsgBuf;
	BOOL 		fVerbose = FALSE;


	if( argc < 2 ) {
		usage() ;
		return 1 ;
	}

    INT cur = 1;
    PCHAR x;

	char	szTempPath[MAX_PATH*2] ;
	char	szTempFile[MAX_PATH*2] ;
	char	szOutputFile[MAX_PATH*2] ;
	char	szGroupFile[MAX_PATH*2] ;

	if( GetTempPath( sizeof( szTempPath ), szTempPath ) == 0 ) {
        LoadString( hModuleInstance, IDS_TEMP_DIR, StringBuff, sizeof( StringBuff ) ) ;
        printf( StringBuff, GetLastError() ) ;
		return 1 ;
	}

	if( GetTempFileName( szTempPath, "build", 0, szOutputFile ) == 0 ) {
        LoadString( hModuleInstance, IDS_CANT_CREATE_TEMP, StringBuff, sizeof( StringBuff ) ) ;
        printf( StringBuff, GetLastError() ) ;
		return	1 ;
	}

	LPSTR	lpstrOutput = szOutputFile;
	LPSTR	lpstrFilePart = 0 ;

    //
    // Parse command line
    //

    while ( cur < argc ) {

        x=argv[cur++];
        if ( *(x) == '-' || *(x) == '/' ) {
			x++ ;

            switch (*x) {

			case 'a' : 
				if( lpstrGroupFile != 0 ) {
					usage() ;
					return	1 ;
				}
				if( cur >= argc ) {
					usage() ;
					return 1;
				}
				lpstrGroupFile = argv[cur++] ;
				IsActive = TRUE ;

				if( SearchPath(
							NULL, 
							lpstrGroupFile, 
							NULL,
							sizeof( szGroupFile ),
							szGroupFile,
							&lpstrFilePart 
							) )	{
							
                    LoadString( hModuleInstance, IDS_USING_ACTIVE_FILE, 
                          StringBuff, sizeof( StringBuff ) ) ;
                    printf( StringBuff, szGroupFile ) ;

				}	else	{

                    LoadString(hModuleInstance, IDS_FILE_NOT_FOUND, 
                        StringBuff, sizeof( StringBuff ) ) ;
                    printf( StringBuff, lpstrGroupFile ) ;
					return	1 ;

				}
				break ;

			case 'k' :  // Skip Corrupted Newsgroup in Standard rebuild 
				SkipCorruptGroup = TRUE;
				break;

			case 'F' :  // Fast rebuild group.lst 
				ReuseIndexFiles = NNTPBLD_DEGREE_STANDARD;

				// fall through to take all settings as -G to:
				// a) Use the logic to exclusive -a, -F, and -G switches
				// b) Take all settings as -G to scan virtual root, etc...

            case 'G' : 
				if( lpstrGroupFile != 0 ) {
					usage() ;
					return 1 ;
				}

                IsActive = FALSE ;
				DoClean = TRUE ;
				

				if( GetTempFileName( szTempPath, "nntp", 0, szTempFile ) == 0 ) {
					printf( "Can't create temp file - error %d\n", GetLastError() ) ;
					return	1 ;
				}
				lpstrGroupFile = szTempFile ;

                LoadString( hModuleInstance, IDS_GEN_FILE, StringBuff, sizeof( StringBuff ) ) ;
                printf( StringBuff, lpstrGroupFile ) ;

				break ;

			case 'c' : 
				DoClean = TRUE ;
				break ;
				
			case 'h' : 
				NoHistoryDelete = TRUE ;
				break ;
				
			case 'e' : 
				DiscardEmptyInternalNodes = TRUE ;
				break ;

			case 'x' : 
				//DeleteIndexFiles = FALSE ;
				if (ReuseIndexFiles == NNTPBLD_DEGREE_THOROUGH)
				    ReuseIndexFiles = NNTPBLD_DEGREE_MEDIUM ;
				break ;

			case 'w' : 
				if( cur >= argc ) {
					usage() ;
					return 1 ;
				}
				NumThreads = atoi( argv[cur++] );
				break ;

            case 's':
				if( cur >= argc ) {
					usage() ;
					return 1 ;
				}
                InstanceId = atoi( argv[cur++] );
                break;

			case 'o' : 
				if( cur >= argc ) {
					usage() ;
					return 1 ;
				}
				lpstrOutput = argv[cur++] ;
				break ;

			case 'v' : 
				fVerbose = TRUE ;
				break ;
				
            default:
                usage( );
                return(1);
            }
		}	else	{

			//
			//	Command line arg that does not start with '-',
			//	the arguments are bad somehow causing us to mess up the parsing !
			//

			usage() ;
			return 1 ;

		}
    }

    //
    //  Error checks
    //

    if( !lpstrGroupFile ) {
        LoadString( hModuleInstance, IDS_INVALID_SWITCH, StringBuff, sizeof( StringBuff ) ) ;
        printf( StringBuff ) ;
      	usage();
        return 1;
    }

    LoadString( hModuleInstance, IDS_OUTPUT_FILE, StringBuff, sizeof( StringBuff ) ) ;
    printf( StringBuff, lpstrOutput ) ;

    //
    //  Now, we have all the params - fill in config struct
    //
    
    ZeroMemory(&config,sizeof(config));
	config.Verbose = fVerbose ;
	config.DoClean = DoClean ;
	config.NoHistoryDelete = NoHistoryDelete ;
	config.ReuseIndexFiles = ReuseIndexFiles ;
	config.OmitNonleafDirs = DiscardEmptyInternalNodes ;
	config.IsActiveFile = IsActive ;
	config.NumThreads = NumThreads ;
	if (SkipCorruptGroup)
    {
        // make sure -k should be combined with -F
        if (ReuseIndexFiles != NNTPBLD_DEGREE_STANDARD)
        {
            usage();
            return 1;
        }
        // set the bit to enable SkipCorruptGroup
        config.ReuseIndexFiles |= 0x00000100;
    }

	CopyAsciiStringIntoUnicode( ReportFile, (LPCTSTR)lpstrOutput );
	config.szReportFile = ReportFile;
	config.cbReportFile = wcslen( ReportFile );

	CopyAsciiStringIntoUnicode( GroupListFile, (LPCTSTR)lpstrGroupFile );
	config.szGroupFile = GroupListFile;
	config.cbGroupFile = wcslen( GroupListFile );

	//
	//	Make RPC to server to start rebuild
	//
	err = NntpStartRebuild(
				RemServerW,
				InstanceId,
				&config,
				&ParmErr
				) ;

	if( err != NO_ERROR ) {
		//
		//	handle error !
		//
		if( !FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			err,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf,
			0,
			NULL 
    		) ) 
		{
			lpMsgBuf = (LPVOID)LocalAlloc( LPTR, 20 );
			wsprintf( (LPTSTR)lpMsgBuf, "%d", err );
		}
		
        LoadString( hModuleInstance, IDS_REBUILD_FAILED, StringBuff, sizeof( StringBuff ) ) ;
        printf( StringBuff, lpMsgBuf ) ;
		LocalFree( lpMsgBuf );
		return 1;
	}

	//
	//	Update progress
	//
	
	DWORD	xP = 0;
	DWORD   dwProgress ;
	
	do
	{
		Sleep( 1000 );
		
		err = NntpGetBuildStatus(
					RemServerW,
					InstanceId,
					FALSE,
					&dwProgress
					) ;

		if( err != NO_ERROR ) {

			//
			//	handle error !
			//

			if( !FormatMessage( 
				FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
				NULL,
				err,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				(LPTSTR) &lpMsgBuf,
				0,
				NULL 
	    		) ) 
			{
				lpMsgBuf = (LPVOID)LocalAlloc( LPTR, 20 );
				wsprintf( (LPTSTR)lpMsgBuf, "%d", err );
			}
		
	        LoadString( hModuleInstance, IDS_GETSTATUS_FAILED, StringBuff, sizeof( StringBuff ) ) ;
    	    printf( StringBuff, lpMsgBuf ) ;
			LocalFree( lpMsgBuf );
			break ;
		}

		if( dwProgress && (xP != dwProgress)) {
	        LoadString( hModuleInstance, IDS_REBUILD_PROGRESS, StringBuff, sizeof( StringBuff ) ) ;
	   	    printf( StringBuff, dwProgress ) ;
   		}
   		
		xP = dwProgress ;

	} while ( xP < 100 );

	if( err == NO_ERROR ) {
        LoadString( hModuleInstance, IDS_REBUILD_DONE, StringBuff, sizeof( StringBuff ) ) ;
   	    printf( StringBuff, dwProgress ) ;
	}
    
	return	0 ;
}

VOID
CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPCTSTR AsciiString
        )
{
    while ( (*UnicodeString++ = (WCHAR)*AsciiString++) != (WCHAR)'\0');

} // CopyAsciiStringIntoUnicode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\nntpdbg\makefile.inc ===
$(O)\nntpdrv.h $(O)\nntpdrv_i.c : $(STAXINC)\export\nntpdrv.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpdrv_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpdrv_i.c \
    -header $@ \
    -tlb $(O)\nntpdrv.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpsvc.h $(O)\nntpsvc_s.c : $(STAXNNTP)\nntpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\nntpsvc_s.c \
    -header $@ \
    -tlb $(O)\nntpsvc.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfilt.h $(O)\nntpfilt_i.c : $(STAXNNTP)\core\include\nntpfilt.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfilt_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfilt_i.c \
    -header $@ \
    -tlb $(O)\nntpfilt.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpmsg.h $(O)\nntpmsg.rc $(O)\msg00001.bin: ..\server\nntpmsg.mc ..\..\..\..\inc\inetamsg.mc
    copy /a ..\..\..\..\inc\inetamsg.mc + /a ..\server\nntpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\nntpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\nntpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\nntpdbg\dbgnntp.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    inetdbg.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#ifdef DBG
#undef DBG
#endif

#define dllexp
#define CALL_STACK_BUF_SIZE 1024

//
// To obtain the private & protected members of C++ class,
// let me fake the "private" keyword
//
# define private    public
# define protected    public

#define INCL_INETSRV_INCS
#include <tigris.hxx>
#include "smtpcli.h"

#include  <ntsdexts.h>
#include "nntpdbgp.h"

extern "C" {
#if 0
void __cdecl main( void )
{
   ;
}
#endif
}

//
// Globals that we have to have because we included others' headers
//

CShareLockNH    CNewsGroupCore::m_rglock[GROUP_LOCK_ARRAY_SIZE];

//DECLARE_DEBUG_PRINTS_OBJECT( );

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

// globals
char g_szBuffer [1024];	// temp buffer for misc stuff

VOID
PrintUsage(
    VOID
    );

VOID
PrintSystemTime(
	FILETIME* pftTime
	);

VOID
PrintString(
	LPSTR lp1,
	LPSTR lp2
	);

VOID
DbgPrintInstance(
	NNTP_SERVER_INSTANCE* pInstance
	);

VOID
DbgPrintNewstree(
	CNewsTree* ptree,
	DWORD nGroups
	);

CNewsGroup*
DbgPrintNewsgroup(
    CNewsGroup * pSrcGroup
    );

CNNTPVRoot*
DbgPrintVRoot(
    CNNTPVRoot *pDestGroup
    );

VOID
DbgPrintVRootList(
	CNNTPVRoot* pFirstVRoot,
	DWORD nVRoots
	);

VOID
DbgPrintDebugVRootList(
	CNNTPVRoot* pFirstVRoot,
	DWORD nVRoots
	);

void
DbgPrintVRootTable(
    CNNTPVRootTable * pVRTable
    );

VOID
DbgDumpPool(
	CSmtpClientPool* pSCPool
	);

VOID
DbgDumpFeedBlock(
	PFEED_BLOCK feedBlock
	);

VOID
DbgDumpFeedList(
	CFeedList* pSrcFeedList,
	CFeedList* pDstFeedList
	);

VOID
DbgDumpCPool(CPool* pCPool, DWORD dwSignature, LPCSTR symbol);

VOID
SkipArgument( LPSTR* ppArg )
{
    // skip the arg and the spaces after
    while( *(*ppArg) != ' ' ) (*ppArg)++;
    while( *(*ppArg) == ' ' ) (*ppArg)++;
}

//
//  Here and elsewhere we use "nntpsvc" prefix in GetExpression() calls.
//

#define DEBUG_PREFIX    "&nntpsvc!"

#define DumpDword( symbol )                                     \
        {                                                       \
            DWORD dw = GetExpression( DEBUG_PREFIX symbol );    \
            DWORD dwValue = 0;                                  \
                                                                \
            if ( dw )                                           \
            {                                                   \
                if ( ReadMemory( (LPVOID) dw,                   \
                                 &dwValue,                      \
                                 sizeof(dwValue),               \
                                 NULL ))                        \
                {                                               \
                    dprintf( "\t" symbol "   = %8d (0x%8lx)\n", \
                             dwValue,                           \
                             dwValue );                         \
                }                                               \
            }                                                   \
        }

#define DumpCPool( symbol, signature )                          \
        {                                                       \
           DbgDumpCPool((CPool*)GetExpression(DEBUG_PREFIX symbol), signature, symbol );    \
        }


//
// util functions
//
VOID
CopyUnicodeStringIntoAscii(
            IN LPSTR AsciiString,
            IN LPWSTR UnicodeString
                 )
{
    while ( (*AsciiString++ = (CHAR)*UnicodeString++) != '\0');

} // CopyUnicodeStringIntoAscii

DECLARE_API( help )
{
    INIT_API();

    PrintUsage();
}

DECLARE_API( cpool )
{
	CPool* pCPool;

	INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the instance
    //
	pCPool = (CPool*)GetExpression( lpArgumentString );
	
    if ( !pCPool )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	DbgDumpCPool(pCPool, 0, NULL);
}

DECLARE_API( cpools )
{
    INIT_API();

    //
    //  Dump Nntpsvc cpools
    //

    dprintf("Nntpsvc Cpools:\n");

    DumpCPool("CArticle__gArticlePool",ARTICLE_SIGNATURE);
    DumpCPool("CCIOAllocator__IOPool",CIO_SIGNATURE) ;
    DumpCPool("CFeed__gFeedPool",FEED_SIGNATURE) ;
    DumpCPool("CChannel__gChannelPool",CHANNEL_SIGNATURE) ;
    DumpCPool("CSessionSocket__gSocketAllocator",SESSION_SOCKET_SIGNATURE) ;
    DumpCPool("CSessionState__gStatePool",SESSION_STATE_SIGNATURE) ;
    DumpCPool("CXoverIndex__gCacheAllocator",1) ;
    DumpCPool("CXoverIndex__gXoverIndexAllocator",1) ;
}

DECLARE_API( instance )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	NNTP_SERVER_INSTANCE	  *pSrcInst, *pDstInst;
	DWORD		  cbInst = sizeof(NNTP_SERVER_INSTANCE);

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the instance
    //
	pSrcInst = (NNTP_SERVER_INSTANCE*)GetExpression( lpArgumentString );
	
    if ( !pSrcInst )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	dprintf("Instance object is 0x%p\n", pSrcInst);

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	pDstInst = (NNTP_SERVER_INSTANCE*) DbgAlloc( cbInst );

	if( !pDstInst )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return;
	}

	if( !ReadMemory( pSrcInst, pDstInst, cbInst, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcInst);
		DbgFree( pDstInst );
		return;
	}

	//
	//	Dump the the server instance
	//
	
	DbgPrintInstance( pDstInst );
	DbgFree( pDstInst );
}

DECLARE_API( newstree )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CNewsTree	  *pSrcTree, *pDstTree;
	DWORD		  cbTree = sizeof(CNewsTree);
	DWORD		  nGroups = 0;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the global newstree pointer
    //
	pSrcTree = (CNewsTree*)GetExpression( lpArgumentString );
	
    if ( !pSrcTree )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	// same as doing pSrcTree = *ppSrcTree !!
	dprintf("Newstree object is 0x%p\n", pSrcTree);

    SkipArgument( &lpArgumentString );
    nGroups = atoi( lpArgumentString );
    
	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	pDstTree = (CNewsTree*) DbgAlloc( cbTree );

	if( !pDstTree )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return;
	}

	if( !ReadMemory( pSrcTree, pDstTree, cbTree, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcTree);
		DbgFree( pDstTree );
		return;
	}

	//
	//	Dump the newstree
	//
	DbgPrintNewstree( pDstTree, nGroups );
	DbgFree( pDstTree );
}

DECLARE_API( vrootlist )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    CNNTPVRoot    *pFirstVRoot;
	DWORD		  nVRoots = 0;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the first vroot
    //
    
	pFirstVRoot = (CNNTPVRoot*)GetExpression( lpArgumentString );
    if ( !pFirstVRoot )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

    SkipArgument( &lpArgumentString );
    nVRoots = atoi( lpArgumentString );
    
	//
	//	Dump the list
	//
	DbgPrintVRootList( pFirstVRoot, nVRoots );
}


DECLARE_API( newsgroup )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CNewsGroup*   pSrcGroup;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Treat the argument as the address of a CNewsGroup struct
    //	NOTE: pSrcGroup is an address in the debuggee's address space !
	//

    pSrcGroup = (CNewsGroup*)GetExpression( lpArgumentString );

    if ( !pSrcGroup )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	//
	//	Dump the CNewsGroup object
	//
	DbgPrintNewsgroup( pSrcGroup );
}

DECLARE_API( vroot )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CNNTPVRoot*   pVroot = NULL;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Treat the argument as the address of a CNNTPVRoot struct
    //	NOTE: pVroot is an address in the debuggee's address space !
	//

    pVroot = (CNNTPVRoot*)GetExpression( lpArgumentString );

    if ( !pVroot )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	//
	//	Dump the CNNTPVRoot object
	//
	DbgPrintVRoot( pVroot );
}

DECLARE_API( vrtable )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CNNTPVRootTable*   pVRTable = NULL;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Treat the argument as the address of a CNNTPVRootTable struct
    //	NOTE: pVRTable is an address in the debuggee's address space !
	//

    pVRTable = (CNNTPVRootTable*)GetExpression( lpArgumentString );

    if ( !pVRTable )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	//
	//	Dump the CNNTPVRootTable object
	//
	DbgPrintVRootTable( pVRTable );
}

DECLARE_API( sockets )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CSessionSocket	  *pSrcSocket, *pDstSocket;
	DWORD		  cbSocket = sizeof(CSessionSocket);

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Get the address of the socket obj
    //
	pSrcSocket = (CSessionSocket*)GetExpression( lpArgumentString );
	
    if ( !pSrcSocket )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	dprintf("Socket object is 0x%p\n", pSrcSocket);

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	pDstSocket = (CSessionSocket*) DbgAlloc( cbSocket );

	if( !pDstSocket )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return;
	}

	if( !ReadMemory( pSrcSocket, pDstSocket, cbSocket, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcSocket);
		DbgFree( pDstSocket );
		return;
	}

	//
	//	Dump the socket obj
	//

	dprintf(" ========== socket object =========== \n");

    dprintf(" Prev = 0x%p Next = 0x%p \n", pDstSocket->m_pPrev, pDstSocket->m_pPrev);
    dprintf(" Sink = 0x%p \n", pDstSocket->m_pSink );
    dprintf(" Port = 0x%08lx \n", pDstSocket->m_nntpPort );
    dprintf(" ClientContext = 0x%p \n", pDstSocket->m_context );
    
	dprintf(" ========== socket object =========== \n");
	
	DbgFree( pDstSocket );
}

DECLARE_API( smtp )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CSmtpClientPool		*pSrcSCPool, *pDstSCPool;
	DWORD				cbSCPool = sizeof(CSmtpClientPool);

    INIT_API();

    //
    //  Get the address of the global newstree pointer
    //
	pSrcSCPool = (CSmtpClientPool*)GetExpression( DEBUG_PREFIX "g_SCPool" );
	
    if ( !pSrcSCPool )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", DEBUG_PREFIX "g_SCPool" );
        return;
    }

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	pDstSCPool = (CSmtpClientPool*) DbgAlloc( cbSCPool );

	if( !pDstSCPool )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return;
	}

	if( !ReadMemory( pSrcSCPool, pDstSCPool, cbSCPool, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcSCPool);
		DbgFree( pDstSCPool );
		return;
	}

    //
    //  Dump the smtp conx cache
    //
	DbgDumpPool( pDstSCPool );
	DbgFree( pDstSCPool );
}

DECLARE_API( feedlist )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	CFeedList*	  pSrcFeedList;
	CFeedList*	  pDstFeedList;
	DWORD		  cbFeedList = sizeof(CFeedList);

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

	//
	//	Get the ActiveFeeds global
	//
	pSrcFeedList = (CFeedList*)GetExpression( lpArgumentString );
	
    if ( !pSrcFeedList )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

	pDstFeedList = (CFeedList*)DbgAlloc( cbFeedList );
	if( !pDstFeedList )
	{
		dprintf("nntpdbg: Unable to allocate memory\n");
		return;
	}

    //
    //  Dump the feedblock list
    //
	if( !ReadMemory( pSrcFeedList, pDstFeedList, cbFeedList, NULL ) )
	{
		dprintf("nntpdbg: Unable to read memory at 0x%p\n", pSrcFeedList );
		DbgFree( pDstFeedList );
		return;
	}

	DbgDumpFeedList( pSrcFeedList, pDstFeedList );
	DbgFree( pDstFeedList );
}

DECLARE_API( feed )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
	PFEED_BLOCK	  feedBlock;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage();
        return;
    }

    //
    //  Treat the argument as the address of a FEED_BLOCK
    //

    feedBlock = (PFEED_BLOCK)GetExpression( lpArgumentString );

    if ( !feedBlock )
    {
        dprintf( "nntpdbg: Unable to evaluate \"%s\"\n", lpArgumentString );
        return;
    }

    DbgDumpFeedBlock( feedBlock );
}

DECLARE_API( rf )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    INIT_API();

    PLONG   pcCallStack = NULL;
    LONG    cCallStack = 0;
    PVOID   pvCallStack = NULL;
    CHAR**  ppchCallStack = NULL;
    CHAR**  ppchReal = NULL;
    LPVOID  lpvCallStack = NULL;
    LPVOID  lpvBuffer = NULL;

    //
    //  Get the number of buffers
    //
	pcCallStack = (PLONG)GetExpression( "exstrace!g_iCallStack" );
    if ( !pcCallStack )
    {
        dprintf( "nntpdbg: Unable to evaluate \"exstrace!g_cCallStack\"\n" );
        return;
    }

    if ( !ReadMemory( pcCallStack, &cCallStack, sizeof(LONG), NULL ) ) {
        dprintf( "nntpdbg: Could not read g_cCallStack\n" );
        return;
    }

    //
    // Get pointer to buffer
    //
    pvCallStack = (CHAR**)GetExpression( "exstrace!g_ppchCallStack" );
    if ( !pvCallStack ) 
    {
        dprintf( "nntpdbg: Unable to evaluate \"exstrace!g_ppchCallStack\"\n" );
        return;
    }

    if ( !ReadMemory( pvCallStack, &ppchCallStack, sizeof(CHAR**), NULL ) ) {
        dprintf( "nntpdbg: Could not read g_ppchCallStack\n" );
        return;
    }

    lpvCallStack = DbgAlloc( sizeof(CHAR*) * cCallStack );
    if ( !lpvCallStack ) {
        dprintf( "nntpdbg: Unable to allocate memory\n" );
        return;
    }

    if ( !ReadMemory( ppchCallStack, lpvCallStack, sizeof(CHAR*)*cCallStack, NULL ) ) {
        dprintf( "nntpdbg: Could not get data at 0x%x\n", ppchCallStack );
        DbgFree( lpvCallStack );
        return;
    } else 
        ppchReal = (CHAR**)lpvCallStack;

    lpvBuffer = DbgAlloc( CALL_STACK_BUF_SIZE );
    if ( !lpvBuffer ) {
        DbgFree( lpvCallStack );
        dprintf( "nntpdbg: Unable to allocate memory\n" );
        return;
    }
    
    for ( LONG i = 0; i < cCallStack; i++ ) {
        if( ppchReal[i] ) {
            if ( !ReadMemory( ppchReal[i], lpvBuffer, CALL_STACK_BUF_SIZE, NULL ) ) {
                dprintf( "nntpdbg: Could not get data at 0x%x\n", ppchReal[i] );
                DbgFree( lpvCallStack );
                DbgFree( lpvBuffer );
                return;
            }
            *(PBYTE(lpvBuffer)+CALL_STACK_BUF_SIZE-1) = 0;
            dprintf("%s\n", (PCHAR)lpvBuffer );
        }
    }

    DbgFree( lpvBuffer );
	DbgFree( lpvCallStack );
}

VOID
PrintUsage(
    VOID
    )
{
    dprintf("\n\nMicrosoft Internet News Server debugging extension, Version 2.0\n\n");

    dprintf("!vroot <address>       - Dump nntp virtual root\n");
    dprintf("!vrtable <address>     - Dump nntp virtual root table\n");
    dprintf("!vrootlist <address> <n> - Dump the first <n> vroots in the table\n");
    dprintf("!cpool <address>       - Dump CPool at <address>\n");
    dprintf("!cpools                - Dump nntpsvc cpools\n");
    dprintf("!instance <address>    - Dump instance at <address> \n");
    dprintf("!newstree <address> <n>- Dump first <n> newsgroups in newstree at <address> \n");
    dprintf("!newsgroup <address>   - Dump newsgroup at <address> \n");
    dprintf("!sockets <address>     - Dump socket at <address> \n");
    dprintf("!smtp                  - Dump smtp conx cache \n");
    dprintf("!feedlist <address>    - Dump active feedblock list at <address> \n");
    dprintf("!feed <address>        - Dump feedblock at <address> \n");
    dprintf("!rf                    - Dump all randfail call stacks \n" );
    dprintf("!help                  - Usage \n\n");
}

VOID
DbgPrintInstance(
	NNTP_SERVER_INSTANCE* pInst
	)
/*++

Routine Description:
	
	Dump the first n newsgroup objects in the newstree.
	NOTE: Assumed that the pointer passed is in OUR address space

--*/
{
	dprintf("\n\n======== Begin Instance dump =========\n");

    if ( NNTP_SERVER_INSTANCE_SIGNATURE == pInst->m_signature ) {
    
        switch( pInst->m_dwServerState ) {
            case MD_SERVER_STATE_STARTED:
                dprintf("Server state is started\n");
                break;
            case MD_SERVER_STATE_STARTING:
                dprintf("Server state is starting\n");
                break;
            case MD_SERVER_STATE_STOPPING:
                dprintf("Server state is stopping\n" );
                break;
            case MD_SERVER_STATE_STOPPED:
                dprintf("Server state is stopped\n" );
                break;
            case MD_SERVER_STATE_PAUSING:
                dprintf("Server state is pausing\n" );
                break;
            case MD_SERVER_STATE_PAUSED:
                dprintf("Server state is paused\n" );
                break;
            case MD_SERVER_STATE_CONTINUING:
                dprintf("Server state is continuing\n" );
                break;
        }

        dprintf("Server has %d references\n", pInst->m_reference );
        dprintf("Instance id is %d\n", pInst->QueryInstanceId() );
        dprintf("Default port is %d\n", pInst->m_sDefaultPort );
        pInst->m_fAddedToServerInstanceList ?
            dprintf("Added to server instance list\n" ) :
            dprintf("NOT added to server instance list\n" );
        dprintf("It has %d connections now\n", pInst->m_dwCurrentConnections );
        dprintf("Owning service is 0x%p\n", pInst->m_Service );
        dprintf("Previous instance 0x%p\n", 
                CONTAINING_RECORD(  pInst->m_InstanceListEntry.Flink,
                                    IIS_SERVER_INSTANCE,
                                    m_InstanceListEntry ) );
        dprintf("Next instance 0x%p\n", 
                CONTAINING_RECORD(  pInst->m_InstanceListEntry.Blink,
                                    IIS_SERVER_INSTANCE,
                                    m_InstanceListEntry ) );
        pInst->m_ServiceStartCalled ?
            dprintf("Start method called\n") :
            dprintf("Start method NOT called\n" );
            
        dprintf("Article table pointer 0x%p\n", pInst->m_pArticleTable );
        dprintf("History table pointer 0x%p\n", pInst->m_pHistoryTable );
        dprintf("Xover table pointer 0x%p\n", pInst->m_pXoverTable );
        dprintf("Xover cache is 0x%p\n", pInst->m_pXCache );
        dprintf("Expire object is 0x%p\n", pInst->m_pExpireObject );
        dprintf("VRoot table is 0x%p\n", pInst->m_pVRootTable );
        dprintf("Dirnot object is 0x%p\n", pInst->m_pDirNot );
        dprintf("Server object is 0x%p\n", pInst->m_pNntpServerObject );
        dprintf("Wrapper( for posting lib) is 0x%p\n", pInst->m_pInstanceWrapper );
        dprintf("Wrapper( for newstree lib) is 0x%p\n", pInst->m_pInstanceWrapperEx );
        dprintf("SEO router 0x%p\n", pInst->m_pSEORouter );
        dprintf("Newstree is 0x%p\n", pInst->m_pTree );
        
        pInst->m_fAllowClientPosts ?
                dprintf("Server allows client posts\n") :
                dprintf("Server doesn't allow client posts\n" );
        pInst->m_fAllowFeedPosts ?
                dprintf("Server allows feed posts\n" ) :
                dprintf("Server doesn't allow feed posts\n" );
        pInst->m_fAllowControlMessages ?
                dprintf("Server allows control messages\n" ) :
                dprintf("Server doesn't allow control messages\n" );
        pInst->m_fNewnewsAllowed ?
                dprintf("Newnews allowed\n" ) :
                dprintf("Newnews not allowed\n" );
                
        dprintf("Client post hard limit %d\n", pInst->m_cbHardLimit );
        dprintf("Client post soft limit %d\n", pInst->m_cbSoftLimit );
        dprintf("Feed hard limit %d\n", pInst->m_cbFeedHardLimit );
        dprintf("Feed soft limit %d\n", pInst->m_cbFeedSoftLimit );
        dprintf("SSL access params 0x%08lx\n", pInst->m_dwSslAccessPerms );
        dprintf("SSLInfo object 0x%p\n", pInst->m_pSSLInfo );
        dprintf("Rebuild object 0x%p\n", pInst->m_pRebuild );
        dprintf("Last rebuild error %d\n", pInst->m_dwLastRebuildError );
        dprintf("Socket list 0x%p\n", pInst->m_pInUseList );
        dprintf("Active feed list 0x%p\n", pInst->m_pActiveFeeds );
        dprintf("Passive feed list 0x%p\n", pInst->m_pPassiveFeeds );
        
    } else {
        
        dprintf("Instance signature bad\n" );
    }
    
	dprintf("\n\n======== End Instance dump =========\n\n");
}

VOID
DbgPrintNewstree(
	CNewsTree* ptree,
	DWORD nGroups
	)
/*++

Routine Description:
	
	Dump the first n newsgroup objects in the newstree.
	NOTE: Assumed that the pointer passed is in OUR address space

--*/
{
	CNewsGroup* pGroup;

   	dprintf("\n\n======== Newstree members =========\n");

	dprintf(" Owning instance is 0x%p\n", ptree->m_pInstance );
	dprintf(" StartSpecial is %d\n", ptree->m_idStartSpecial );
	dprintf(" LastSpecial is %d\n", ptree->m_idLastSpecial );
	dprintf(" idSlaveGroup is %d\n", ptree->m_idSlaveGroup );
	dprintf(" idSpecialHigh is %d\n", ptree->m_idSpecialHigh );
	dprintf(" idStart is %d\n", ptree->m_idStart );
	dprintf(" idHigh is %d\n", ptree->m_idHigh );
    dprintf(" First group is 0x%p\n", ptree->m_pFirst );
    dprintf(" Last group is 0x%p\n", ptree->m_pLast );
    dprintf(" Num groups is %d\n", ptree->m_cGroups );
    dprintf(" VRoot table is 0x%p\n", ptree->m_pVRTable );
    ptree->m_fStoppingTree ?    dprintf( " Tree is being stopped\n" ) :
                                dprintf( " Tree is not being stopped\n" );
    dprintf(" Group.lst object is 0x%p\n", ptree->m_pFixedPropsFile );
    dprintf(" Groupvar.lst object is 0x%p\n", ptree->m_pVarPropsFile );
    dprintf(" Server object is 0x%p\n", ptree->m_pServerObject );
    ptree->m_fVRTableInit ? dprintf(" Vroot table initialized\n" ) :
                            dprintf(" Vroot table NOT initialized\n" );
    

    if( nGroups ) 
    {
    	dprintf("\n\n======== Begin Newstree dump =========\n");
    
	    for( pGroup = (CNewsGroup*)ptree->m_pFirst; pGroup && nGroups--; )
    	{
	    	pGroup = DbgPrintNewsgroup( pGroup );
	    }

    	dprintf("\n\n======== End Newstree dump =========\n\n");
	}
}

VOID
DbgPrintVRootList(
	CNNTPVRoot* pFirstVRoot,
	DWORD nVRoots
	)
/*++

Routine Description:
	
	Dump the first n newsgroup objects in the newstree.
	NOTE: Assumed that the pointer passed is in OUR address space

--*/
{
	CNNTPVRoot* pVRoot;

    if( nVRoots ) 
    {
    	dprintf("\n\n======== Begin virtual root list dump =========\n");
    
	    for( pVRoot = pFirstVRoot; pVRoot && nVRoots--; )
    	{
	    	pVRoot = DbgPrintVRoot( pVRoot );
	    }

    	dprintf("\n\n======== End virtual root list dump =========\n\n");
	}
}

VOID
PrintSystemTime(
	FILETIME* pftTime
	)
{
	SYSTEMTIME st;
	FileTimeToSystemTime( pftTime, &st );

	dprintf(" %04d::%02d::%02d::::%02d::%02d::%02d\n", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
}

VOID
PrintString(
	LPSTR lp1,
	LPSTR lp2
	)
{
	move( g_szBuffer, lp2 );
	dprintf( lp1, g_szBuffer );
}

CNewsGroup*
DbgPrintNewsgroup(
    CNewsGroup * pSrcGroup
    )
/*++

Routine Description:
	
	Dump the newsgroup object at pGroup.
	NOTE: Assumed that the pointer passed in is in the debuggee's address space
	      ie. we need to allocate memory and copy the data over into our address space !

Arguments:

Returns:

	The next newsgroup pointer

--*/
{
	CNewsGroup  *pGroup, *pDstGroup;
	char	    szNewsGroup [MAX_NEWSGROUP_NAME];
	DWORD       cbGroupName;
	LPCSTR	    lpstrGroup; 
	DWORD	    cbPath, cbNewsGroup;
	CNewsGroup* pGroupRet   = NULL;
	BOOL        fActive     = TRUE;         
	SYSTEMTIME  sysTime;

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	
	cbNewsGroup = sizeof(CNewsGroup);
	pDstGroup = (CNewsGroup*) DbgAlloc( cbNewsGroup );

	if( !pDstGroup )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return NULL;
	}

	if( !ReadMemory( pSrcGroup, pDstGroup, cbNewsGroup, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pSrcGroup);
		goto DbgPrintNewsgroup_Exit;
	}

	// Now, we can use pGroup to access the members of the CNewsGroup object
	pGroup = pDstGroup;

	//
	//	Dump the newsgroup object
	//
	
	dprintf("\n\n======== Begin Newsgroup object =========\n\n");

	//
	// Check to see if group object is deallocated
	//

	fActive = ( pGroup->m_dwSignature == CNEWSGROUPCORE_SIGNATURE );

	if ( fActive ) {

        //
        // dump newsgroup name
        //
	
        lpstrGroup = pGroup->m_pszGroupName;
        cbGroupName = pGroup->m_cchGroupName; // it should have already included '\0'
        if( ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL) ) {
	        dprintf("Newsgroup name is %s\n", szNewsGroup );
        }

        //
        // Dump native name
        //

        lpstrGroup = pGroup->m_pszNativeName;
        if ( lpstrGroup && ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL ) ) {
            dprintf("Pretty name is %s\n", szNewsGroup );
        } else {
            dprintf("No native name\n" );
        }

        //
        // Dump pretty name
        //

        lpstrGroup = pGroup->m_pszPrettyName;
        cbGroupName = pGroup->m_cchPrettyName;
        if ( lpstrGroup && ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL ) ) {
	        dprintf("Pretty name is %s\n", szNewsGroup );
	    } else {
	        dprintf("No pretty name\n" );
        }

        //
        // Dump help text
        //

        lpstrGroup = pGroup->m_pszHelpText;
        cbGroupName = pGroup->m_cchHelpText;
        if ( lpstrGroup && ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL ) ) {
            dprintf("Help text is %s\n", szNewsGroup );
        } else {
            dprintf("No help text\n" );
        }

        //
        // Dump moderator
        //

        lpstrGroup = pGroup->m_pszModerator;
        cbGroupName = pGroup->m_cchModerator;
        if ( lpstrGroup && ReadMemory( lpstrGroup, szNewsGroup, cbGroupName, NULL ) ) {
            dprintf("Moderator is %s\n", szNewsGroup );
        } else {
            dprintf("No moderator\n" );
        }

        //
	    // dump group privates
	    //
	    
	    dprintf("Ref count is %d\n", pGroup->m_cRefs );
	    dprintf("Parent tree is 0x%p\n", pGroup->m_pNewsTree );
	    dprintf("Parent vroot is 0x%p\n", pGroup->m_pVRoot );
	    dprintf("Low watermark is %d\n", pGroup->m_iLowWatermark);
	    dprintf("High watermark is %d\n", pGroup->m_iHighWatermark);
	    dprintf("Article estimate is %d\n", pGroup->m_cMessages );
	    dprintf("Group id is %d\n", pGroup->m_dwGroupId );
	    pGroup->m_fReadOnly ? dprintf("Group is read only\n" ) : dprintf("Group is not read only\n" );
	    pGroup->m_fDeleted ? dprintf("Group is marked deleted\n") : dprintf("Group is NOT marked deleted\n");
	    FileTimeToSystemTime( &(pGroup->m_ftCreateDate), &sysTime );
        dprintf("Group create time: %d/%d/%d - %d:%d:%d\n",
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wYear,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond );
        dprintf("Cache hit is %d\n", pGroup->m_dwCacheHit );
        pGroup->m_fAllowExpire ? dprintf( "Expire allowed\n" ) : dprintf( "Expire not allowed\n" );
        pGroup->m_fAllowPost ? dprintf( "Post allowed\n" ) : dprintf( "Expire not allowed\n" );
        pGroup->m_fDecorateVisited ? dprintf( "Decorate visited\n" ) : dprintf( "Decorate non-visited\n" );
        dprintf("m_artXoverExpireLow is %d\n", pGroup->m_artXoverExpireLow);
	    dprintf("Prev group is 0x%p\n", pGroup->m_pPrev);
	    dprintf("Next group is 0x%p\n", pGroup->m_pNext);
	    pGroupRet = (CNewsGroup*)pGroup->m_pNext;
	} else {

	    dprintf( "Newsgroup signature is bad\n" );
	}

	dprintf("\n======== End Newsgroup object =========\n");

DbgPrintNewsgroup_Exit:

	DbgFreeEx( pDstGroup );

	return pGroupRet;
}

CNNTPVRoot*
DbgPrintVRoot(
    CNNTPVRoot * pVRoot
    )
/*++

Routine Description:
	
	Dump the vroot object at pVRoot
	NOTE: Assumed that the pointer passed in is in the debuggee's address space
	      ie. we need to allocate memory and copy the data over into our address space !

Arguments:

Returns:

	The next newsgroup pointer

--*/
{
    CNNTPVRoot  *pDestVRoot, *pMyVRoot;
	DWORD       cbVRoot;
	CNNTPVRoot* pVRootRet   = NULL;
	BOOL        fActive     = FALSE;

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	
	cbVRoot = sizeof(CNNTPVRoot);
	pDestVRoot = (CNNTPVRoot*) DbgAlloc( cbVRoot );

	if( !pDestVRoot )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return NULL;
	}

	if( !ReadMemory( pVRoot, pDestVRoot, cbVRoot, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pVRoot );
		goto DbgPrintVRoot_Exit;
	}

	// Now, we can use pMyVRoot to access the members of the CNNTPVRoot object
	pMyVRoot = pDestVRoot;

	//
	//	Dump the vroot object
	//
	
	dprintf("\n\n======== Begin virtual root object =========\n\n");

	//
	// Check to see if group object is deallocated
	//

	fActive = ( pMyVRoot->m_dwSig == VROOT_GOOD_SIG );

	if ( fActive ) {

	    //
	    // Dump reference
        //

        dprintf("Reference count is %d\n", pMyVRoot->m_cRefs );
        dprintf("Next vroot is 0x%p\n", pMyVRoot->m_pNext );
        pVRootRet = (CNNTPVRoot*)pMyVRoot->m_pNext;
        dprintf("Prev vroot is 0x%p\n", pMyVRoot->m_pPrev );
        pMyVRoot->m_fInit ? dprintf("Vroot is initialized\n") :
                            dprintf("Vroot is NOT initialized\n" );
        dprintf("Vroot name is %s\n", pMyVRoot->m_szVRootName );
        dprintf("Owning vroot table is 0x%p\n", pMyVRoot->m_pVRootTable );
        pMyVRoot->m_fUpgrade ?  dprintf("This is an upgraded vroot\n" ) :
                                dprintf("This is not an upgraded vroot\n" );
        pMyVRoot->m_fIsIndexed ?  dprintf("Content indexed\n" ) :
                                dprintf("Not content indexed\n" );
        dprintf("Access bitmask is 0x%08lx\n", pMyVRoot->m_dwAccess );
        dprintf("SSL access bitmask 0x%08lx\n", pMyVRoot->m_dwSSL );
        dprintf("Metabase object 0x%p\n", pMyVRoot->m_pMB );
        dprintf("Directory path %s\n", pMyVRoot->m_szDirectory );
        dprintf("Prepare driver 0x%p\n", pMyVRoot->m_pDriverPrepare );
        dprintf("Good driver 0x%p\n", pMyVRoot->m_pDriver );
        switch( pMyVRoot->m_eLogonInfo ) {
            case CNNTPVRoot::VROOT_LOGON_DEFAULT:
                dprintf("This is a file system vroot\n");
                break;
            case CNNTPVRoot::VROOT_LOGON_UNC:
                dprintf("This is a UNC vroot\n" );
                break;
            case CNNTPVRoot::VROOT_LOGON_EX:
                dprintf("This is an exchange vroot\n" );
                break;
        }
        switch( pMyVRoot->m_eState ) {
            case CNNTPVRoot::VROOT_STATE_UNINIT:
                dprintf("Vroot not inited\n" );
                break;
            case CNNTPVRoot::VROOT_STATE_CONNECTING:
                dprintf("Vroot is connecting\n" );
                break;
            case CNNTPVRoot::VROOT_STATE_CONNECTED:
                dprintf("Vroot is connected\n" );
                break;
        }
        dprintf("VRoot Win32 Error %d\n",  pMyVRoot->m_dwWin32Error );
        dprintf("Impersonation token ( for UNC ): %d\n", pMyVRoot->m_hImpersonation );
        pMyVRoot->m_bExpire ?   dprintf("Vroot handles expire himself\n") :
                                dprintf("Protocol should help him expire\n" );
        pMyVRoot->m_lDecCompleted == 0 ?
            dprintf("Decorate newstree in progress\n") :
            dprintf("Decorate newstree completed\n" );
#ifdef DEBUG
        dprintf("Next vroot in debug list 0x%p\n",
                CONTAINING_RECORD(  pMyVRoot->m_DebugList.Flink,
                                    CVRoot,
                                    m_DebugList ) );
#endif
    } else {

        dprintf("Vroot signature bad\n" );
    }
                                
	dprintf("\n======== End virtual root object =========\n");

DbgPrintVRoot_Exit:

	DbgFreeEx( pDestVRoot );

	return pVRootRet;
}

void
DbgPrintVRootTable(
    CNNTPVRootTable * pVRTable
    )
/*++

Routine Description:
	
	Dump the vroot table object at pVRTable
	NOTE: Assumed that the pointer passed in is in the debuggee's address space
	      ie. we need to allocate memory and copy the data over into our address space !

Arguments:

Returns:

	The next newsgroup pointer

--*/
{
    CNNTPVRootTable  *pDestVRTable, *pMyVRTable;
	DWORD       cbVRTable;
	CHAR        szVRootPath[MAX_VROOT_PATH];

	//	
	//	Allocate memory in our address space so we can read data from the debuggee's address space
	//
	
	cbVRTable = sizeof(CNNTPVRootTable);
	pDestVRTable = (CNNTPVRootTable*) DbgAlloc( cbVRTable );

	if( !pDestVRTable )
	{
        dprintf( "nntpdbg: Unable to allocate memory \n");
        return ;
	}

	if( !ReadMemory( pVRTable, pDestVRTable, cbVRTable, NULL ) )
	{
		dprintf("Could not get data at 0x%x\n", pVRTable );
		goto DbgPrintVRootTable_Exit;
	}

	// Now, we can use pMyVRTable to access the members of the CNNTPVRoot object
	pMyVRTable = pDestVRTable;

	//
	//	Dump the vroot object
	//
	
	dprintf("\n\n======== Begin virtual root table object =========\n\n");

#ifdef DEBUG

    if ( IsListEmpty( &pMyVRTable->impl.m_DebugListHead ) ) {
        dprintf("Debug list is empty\n");
    } else {
        dprintf("First vroot in debug list 0x%p\n", 
                CONTAINING_RECORD(  pMyVRTable->impl.m_DebugListHead.Flink,
                                    CVRoot,
                                    m_DebugList ) );
    }
#endif

    CopyUnicodeStringIntoAscii( szVRootPath, pMyVRTable->impl.m_wszRootPath );
    dprintf("VRoot path is %s\n", szVRootPath );
    pMyVRTable->impl.m_fInit ? dprintf("We have been initialized\n") :
                          dprintf("We are not initialized\n" );
    pMyVRTable->impl.m_fShuttingDown ?   dprintf("We are shutting down\n") :
                                    dprintf("We are not shutting down\n" );
    if ( pMyVRTable->impl.m_listVRoots.IsEmpty() ) {
        dprintf("Table is empty\n" );
    } else {
        dprintf("The first vroot on table is 0x%p\n", 
                pMyVRTable->impl.m_listVRoots.m_pHead );
    }
    dprintf("Owning instance wrapper 0x%p\n", pMyVRTable->m_pInstWrapper );

                                
	dprintf("\n======== End virtual root table object =========\n");

DbgPrintVRootTable_Exit:

	DbgFreeEx( pDestVRTable );
}

VOID
DbgDumpPool(
	CSmtpClientPool* pSCPool
	)
/*++

Routine Description:
	
	Dump the smtp cached conx
	NOTE: Assumed that the pointer passed is in OUR address space

--*/
{
	DWORD cSlots = pSCPool->m_cSlots;
	DWORD i;
	BOOL* rgAvailList = NULL;
	CSmtpClient** rgppSCList = NULL;

	dprintf("\n======== Begin CSmtpClientPool dump =========\n\n");

	dprintf("Number of slots is %d\n", cSlots);

	DWORD cbAvailList = sizeof(BOOL)*cSlots;
	DWORD cbSCList = sizeof(CSmtpClient*)*cSlots;

	rgAvailList = (BOOL*)DbgAlloc( cbAvailList );
	if( !rgAvailList || !ReadMemory( pSCPool->m_rgAvailList, rgAvailList, cbAvailList, NULL) )
	{
		dprintf("Failed to allocate or read memory\n");
		goto DbgDumpPool_Exit;
	}

	rgppSCList  = (CSmtpClient**)DbgAlloc( cbSCList );
	if( !rgppSCList || !ReadMemory( pSCPool->m_rgpSCList, rgppSCList, cbSCList, NULL) )
	{
		dprintf("Failed to allocate or read memory\n");
		goto DbgDumpPool_Exit;
	}

	// Dump the conx object pointers and avail status
	for(i=0; i<cSlots; i++)
	{
		dprintf("Smtp conx object %d is 0x%p\n", i+1, rgppSCList [i]);
		dprintf("Avail status is %d\n", rgAvailList [i]);
	}

	dprintf("\n======== End   CSmtpClientPool dump =========\n");

DbgDumpPool_Exit:

	DbgFreeEx( rgAvailList );
	DbgFreeEx( rgppSCList );
}

VOID
DbgDumpFeedBlock(
	PFEED_BLOCK feedBlock
	)
/*++

Routine Description:
	
	Dump the feedBlock passed in; validate signature
	NOTE: Assumed that the pointer passed in is in the debuggee's address space
	      ie. we need to allocate memory and copy the data over into our address space !

Arguments:

Returns:

--*/
{
	FEED_BLOCK	feed;

	// read memory from debuggee's address space
	move( feed, feedBlock );

	// validate signature
	if( FEED_BLOCK_SIGN != feed.Signature )
	{
		dprintf("Invalid Feed block signature Expected: 0x%08lx Got: 0x%08lx \n", FEED_BLOCK_SIGN, feed.Signature );
		return;
	}

	// ok, dump the feed block
	dprintf("============ Begin feed block dump =============== \n");

    dprintf("Number of feeds done so far is %d\n", feed.NumberOfFeeds);
	dprintf("Number of failed connection attempts for Push feeds is %d\n", feed.cFailedAttempts);
    dprintf("The last newsgroup spec Pulled is %d\n", feed.LastNewsgroupPulled);
    dprintf("Resolved IP address is %d\n", feed.IPAddress);
    dprintf("feedblock ListEntry Flink is 0x%p\n", feed.ListEntry.Flink);
    dprintf("feedblock ListEntry Blink is 0x%p\n", feed.ListEntry.Blink);
	dprintf("feed is in progress ? %d\n", feed.FeedsInProgress);
    dprintf("Count of references to this block is %d\n", feed.ReferenceCount);
    dprintf("Current State of this block is %d\n", feed.State);
	dprintf("Should we delete this block when the references reach 0 ? %d\n", feed.MarkedForDelete);
	dprintf("Pointer to a FEED_BLOCK that we are replaced by is 0x%p\n", feed.ReplacedBy);
	dprintf("Pointer to a FEED_BLOCK we replace is 0x%p\n", feed.Replaces);
    dprintf("Type of this feed (push/pull/passive) is %d\n", feed.FeedType);

    //dprintf("Name of reg key this feed info is stored under 0x%p\n", feed.KeyName);

	dprintf("The Queue used to record outgoing articles for this ACTIVE outgoing feed is 0x%p\n", feed.pFeedQueue);
    dprintf("Unique id for this feed block is %d\n", feed.FeedId);
    dprintf("Should we autocreate directories?  %d\n", feed.AutoCreate);
    dprintf("Minutes between feeds is %d\n", feed.FeedIntervalMinutes);

    dprintf("Pull Request Time is");
	PrintSystemTime( &feed.PullRequestTime );

	FILETIME ft;

    dprintf("Start Time is");
	FILETIME_FROM_LI( &ft, &feed.StartTime );
	PrintSystemTime( &ft );

    dprintf("Next Active Time is");
	FILETIME_FROM_LI( &ft, &feed.NextActiveTime);
	PrintSystemTime( &ft );

	PrintString("Name of the feed server is %s\n", feed.ServerName);
	dprintf("Newsgroups to pull is 0x%p\n", feed.Newsgroups);
	dprintf("Distributions is 0x%p\n", feed.Distribution);

	dprintf("Flag indicating whether the feed is currently 'enabled' is %d\n", feed.fEnabled);

	//PrintString("The name to be used in Path processing is %s\n", feed.UucpName);
	PrintString("The directory where we are to store our temp files is %s\n", feed.FeedTempDirectory);

	dprintf("Maximum number of consecutive failed connect attempts before\n");
	dprintf("we disable the feed is %d\n", feed.MaxConnectAttempts);
	dprintf("Number of sessions to create for outbound feeds is %d\n", feed.ConcurrentSessions);
	dprintf("Type of security to have is %d\n", feed.SessionSecurityType);
	dprintf("Authentication security is %d\n", feed.AuthenticationSecurity);

	PrintString("User Account for clear text logons is %s\n", feed.NntpAccount);
	PrintString("User Password for clear text logons is %s\n", feed.NntpPassword);

	dprintf("Allow control messages on this feed ? %d\n", feed.fAllowControlMessages);

	dprintf("============ End    feed block dump =============== \n");
}

VOID
DbgDumpFeedList(
	CFeedList* pSrcFeedList,
	CFeedList* pDstFeedList
	)
/*--
	Arguments:

		pSrcFeedList	-	pointer in debuggee's address space
		pDstFeedList	-	pointer in OUR address space

--*/
{
	LIST_ENTRY  Entry;
	PLIST_ENTRY listEntry;
	PLIST_ENTRY	SrclistEntry =	(pDstFeedList->m_ListHead).Flink ;
	listEntry = SrclistEntry;

	DWORD offset = (DWORD)((DWORD_PTR)&((CFeedList*)0)->m_ListHead);
	PLIST_ENTRY listEnd = (PLIST_ENTRY)((LPBYTE)pSrcFeedList+offset);

	//dprintf("offset is %d listEnd is 0x%p\n", offset, listEnd);
	
	while( listEntry != listEnd ) {

		PFEED_BLOCK	feedBlock = CONTAINING_RECORD(	listEntry, 
													FEED_BLOCK,
													ListEntry );

		DbgDumpFeedBlock( feedBlock );

		SrclistEntry = listEntry;
		move( Entry, SrclistEntry );

		listEntry = Entry.Flink ;
	}
}

VOID
DbgDumpCPool(CPool* pCPool, DWORD dwSignature, LPCSTR szSymbol)
{

    CPool* pPool = (CPool*)DbgAlloc( sizeof(CPool));

    if ( pCPool && pPool )
    {
        if ( ReadMemory( (LPVOID) pCPool,
                         pPool,
                         sizeof(CPool),
                         NULL ))
        {
            dprintf( "%s at 0x%8lx, signature is 0x%.8x\n",
            	(szSymbol?szSymbol:"CPool"),
            	pCPool, pPool->m_dwSignature);

            if( dwSignature != 0 && dwSignature != pPool->m_dwSignature ) {
                dprintf(" *** signature mismatch\n" );
            }

            dprintf(" m_cMaxInstances = %d\n", pPool->m_cMaxInstances );
            dprintf(" m_cInstanceSize = %d\n", pPool->m_cInstanceSize );
            dprintf(" m_cNumberCommitted = %d\n", pPool->m_cNumberCommitted );
            dprintf(" m_cNumberInUse = %d\n", pPool->m_cNumberInUse );
            dprintf(" m_cNumberAvail = %d\n", pPool->m_cNumberAvail );
            dprintf(" m_cFragmentInstances = %d\n", pPool->m_cFragmentInstances );
            dprintf(" m_cFragments = %d\n", pPool->m_cFragments );
            dprintf(" Fragments:\n");
            for(int i=0; i<MAX_CPOOL_FRAGMENTS; i++) {
	    	    dprintf("  %p%s", pPool->m_pFragments[i], ((i+1)%4)==0?"\n":"" );
	    	}
			dprintf("=========================\n");
        }
        DbgFree( (PVOID)pPool );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\nntpdbg\nntpdbgp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#if 0
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#endif

#define move(dst, src)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )


#ifndef DbgAlloc
#define DbgAlloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef DbgFree
#define DbgFree( p ) HeapFree( GetProcessHeap(), 0, (p) )
#define DbgFreeEx( p ) if( (p) ) DbgFree( (p) )
#endif

extern NTSD_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\frommstr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to FromMaster Infeeds


Author:

    Carl Kadie (CarlK)     12-Dec-1995

Revision History:

--*/

#include "stdinc.h"
#include    <stdlib.h>


BOOL
CFromMasterArticle::fValidate(
							CPCString& pcHub,
							const char * szCommand,
							CInFeed*		pInFeed,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	Validates an article from a master. Does not change the article.

Arguments:

	szCommand - The arguments (if any) used to post/xreplic/etc this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	//
	// Check the message id
	//

	if (!m_fieldMessageID.fFindAndParse(*this, nntpReturn))
			return nntpReturn.fFalse();

	//
	//!!!FROMMASTER LATER do multiple masters
	//

	if (m_pInstance->ArticleTable()->SearchMapEntry(m_fieldMessageID.szGet())
		|| m_pInstance->HistoryTable()->SearchMapEntry(m_fieldMessageID.szGet()))
	{
		nntpReturn.fSet(nrcArticleDupMessID, m_fieldMessageID.szGet(), GetLastError());
		return nntpReturn.fFalse();
	}
	

	//
	// From here on, we want to add an entry to the history table
	// even if the article was rejected.
	//


	//
	// Create a list of the fields of interest
	//


	//
	//	NOTE ! Because we will ignore errors caused by bad XREF lines,
	//	we must make sure it is parsed last, otherwise we may miss errors
	//	that occur in parsing the other header lines !
	//
	CField * rgPFields [] = {
            &m_fieldControl,
			&m_fieldPath,
			&m_fieldXref
				};

	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);

	m_cNewsgroups = 0 ;
	LPCSTR	lpstr = szCommand ;
	while( lpstr && *lpstr != '\0' ) {
		lpstr += lstrlen( lpstr ) + 1 ;
		m_cNewsgroups ++ ;
	}

	//
	// Assume the best
	//

	nntpReturn.fSetOK();

	//
	// Even if fFindParseList or fCheckCommandLine fail,
	// save the message id

	CNntpReturn	nntpReturnParse ;

	if (fFindAndParseList((CField * *)rgPFields, cFields, nntpReturnParse))	{
		if( !fCheckCommandLine(szCommand, nntpReturn)	)	{
#ifdef BUGBUG
			if( nntpReturn.m_nrc == nrcInconsistentMasterIds ) {
				pInFeed->LogFeedEvent( NNTP_MASTER_BADARTICLEID, (char*)szMessageID(), m_pInstance->QueryInstanceId() ) ;
			}	else	if(	nntpReturn.m_nrc == nrcInconsistentXref ) {
				pInFeed->LogFeedEvent( NNTP_MASTER_BAD_XREFLINE, (char*)szMessageID(), m_pInstance->QueryInstanceId() ) ;
			}
#endif
		}
	}

	//
	// Now, insert the article, even if fFindAndParseList or fCheckCommandLine
	// failed.
	//

	if (!m_pInstance->ArticleTable()->InsertMapEntry(m_fieldMessageID.szGet()))
		return nntpReturn.fFalse();


	return nntpReturn.fIsOK();
}


BOOL
CFromMasterArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn,
							 PDWORD pdwLinesOffset
			  )
/*++

Routine Description:

	Modify the headers of the article.

Arguments:

	grouplist - A list: for each newsgroup its name, and the article number in that group.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	//
	// We don't want caller to back fill lines line in any case here
	//
	if ( pdwLinesOffset ) *pdwLinesOffset = INVALID_FILE_SIZE;
	
	if( !fCommitHeader( nntpReturn ) )
		return	FALSE ;
	return nntpReturn.fSetOK();
}

BOOL
CFromMasterXrefField::fParse(
							 CArticleCore & article,
							 CNntpReturn & nntpReturn
				 )
 /*++

Routine Description:

  Parses the XRef field.


Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear(); // clear the return object
	
	CPCString pcValue = m_pHeaderString->pcValue;
	CPCString pcHubFromParse;

	pcValue.vGetToken(szWSNLChars, pcHubFromParse);

#if 0
	CPCString pcHub(NntpHubName, HubNameSize);
	if (pcHub != pcHubFromParse)
	{
		char szHubFromParse[MAX_PATH];
		pcHubFromParse.vCopyToSz(szHubFromParse, MAX_PATH);
		return nntpReturn.fSet(nrcArticleXrefBadHub, NntpHubName, szHubFromParse);
	}
#endif

	if( !pcHubFromParse.fEqualIgnoringCase((((CArticle&)article).m_pInstance)->NntpHubName()) ) {
		char szHubFromParse[MAX_PATH];
		pcHubFromParse.vCopyToSz(szHubFromParse, MAX_PATH);
		return nntpReturn.fSet(nrcArticleXrefBadHub, (((CArticle&)article).m_pInstance)->NntpHubName(), szHubFromParse);
	}

	//
	// Count the number of ':''s so we know the number of slots needed
	//

	DWORD dwXrefCount = pcValue.dwCountChar(':');
	if (!m_namereflist.fInit(dwXrefCount, article.pAllocator()))
	{
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
	}

	while (0 < pcValue.m_cch)
	{
		CPCString pcName;
		CPCString pcArticleID;

		pcValue.vGetToken(":", pcName);
		pcValue.vGetToken(szWSNLChars, pcArticleID);

		if ((0 == pcName.m_cch) || (0 == pcArticleID.m_cch))
			return nntpReturn.fSet(nrcArticleBadField, szKeyword());

		NAME_AND_ARTREF Nameref;

		//
		// Convert string to number. Don't need to terminate with a '\0' any
		// nondigit will do.
		//

		(Nameref.artref).m_articleId = (ARTICLEID)atoi(pcArticleID.m_pch);
		Nameref.pcName = pcName;
		m_namereflist.AddTail(Nameref);

		pcValue.dwTrimStart(szWSNLChars) ;
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromMasterArticle::fCheckCommandLine(
									  char const * szCommand,
									  CNntpReturn & nntpReturn
									  )
/*++

Routine Description:


	 Check that the Command line is consistent with the article
		 Currently, just return OK


Arguments:

	szCommand -
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear(); // clear the return object
	//!!!FROMMASTER LATER check against xref data.
/* Here is some code that might be useful when checking consistancy.  */
	//
	// Of the form: "ggg:nnn\0[,ggg:nnn\0...]\0"
	//

	CNAMEREFLIST*	pNameRefList = m_fieldXref.pNamereflistGet() ;

	DWORD   iMatch = 0 ;
	int		i = 0 ;

	POSITION	posInOrder = pNameRefList->GetHeadPosition() ;

	if( pNameRefList != 0 ) {
		char const * sz = szCommand;
		do
		{

			CPCString pcItem((char *)szCommand);
			CPCString pcGroupID;
			CPCString pcArticleID;

			//
			// First get a ggg
			//

			pcItem.vGetToken(":", pcGroupID);

			//
			// Second, get a nnn
			//
			pcItem.vGetToken(szWSNLChars, pcArticleID);
			

			//GROUPID	groupId ;
			ARTICLEID	artId = 0 ; //atoi(  ) ;

			//
			//!!!FROMMASTER LATER check against xref data.
			//
			POSITION	pos = 0 ;
			NAME_AND_ARTREF*	pNameRef = 0 ;
			if( posInOrder != 0 ) {
				pNameRef = pNameRefList->GetNext( posInOrder ) ;
				if( pNameRef->pcName.fEqualIgnoringCase( szCommand ) ) {
					iMatch++ ;
					if( pNameRef->artref.m_articleId != (ARTICLEID)atoi( pcArticleID.sz() ) ) {
						return	nntpReturn.fSet( nrcInconsistentMasterIds ) ;
					}
					goto	KEEP_LOOPING ;
				}	
			}			

			pos = pNameRefList->GetHeadPosition() ;
			pNameRef = pNameRefList->GetNext( pos ) ;
			for( i=pNameRefList->GetCount(); i>0; i--, pNameRef = pNameRefList->GetNext( pos ) ) {
				if( pNameRef->pcName.fEqualIgnoringCase( szCommand ) ) {
					iMatch ++ ;
					if( pNameRef->artref.m_articleId != (ARTICLEID)atoi( pcArticleID.sz() ) )	{					
						return	nntpReturn.fSet( nrcInconsistentMasterIds ) ;
					}
					break ;
				}
			}

			//
			// go to first char after next null
			//

KEEP_LOOPING :
			while ('\0' != szCommand[0])
				szCommand++;
			szCommand++;
		} while ('\0' != szCommand[0]);
	}

	if( iMatch == m_cNewsgroups )
		return nntpReturn.fSetOK();
	else
		return	nntpReturn.fSet( nrcInconsistentXref ) ;
}



BOOL
CFromMasterFeed::fCreateGroupLists(
							CNewsTreeCore * pNewstree,
							CARTPTR & pArticle,
							CNEWSGROUPLIST & grouplist,
							CNAMEREFLIST * pNamereflist,
							LPMULTISZ	multiszCommandLine,
                            CPCString& pcHub,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	For each newsgroup, find the article id for this new article
	in that newsgroup. Uses the data in XRef to do this.


  !!!FROMMASTER this should be replaced to different


Arguments:

	pNewstree - Newstree for this virtual server instance
	pArticle - Pointer to the being processed.
	grouplist - A list of group objects, one for each newsgroup
	namereflist - A list: each item has the name of the newsgroup and groupid and
	               article id
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nntpReturn.fSetClear();

#if 0
	pNamereflist = pArticle->pNamereflistGet();

	POSITION	pos = pNamereflist->GetHeadPosition() ;
	while( pos  )
	{
		NAME_AND_ARTREF * pNameref = pNamereflist->Get(pos);
		char szName[MAX_PATH];
		(pNameref->pcName).vCopyToSz(szName, MAX_PATH);
		CGRPPTR	pGroup = pNewstree->GetGroup(szName, (pNameref->pcName).m_cch);
		if (pGroup)
		{
			/*!!! laterm ilestone
			CSecurity * pSecurity = pGroup->GetSecurity( ) ;
			if (pSecurity->Restricted(m_socket))
			{
				grouplist.RemoveAll();
				break;
			}
			*/
			(pNameref->artref).m_groupId = pGroup->GetGroupId();
			grouplist.AddTail(pGroup);
		}
		(pNameref->pcName).vInsert(pGroup->GetName());
		pNamereflist->GetNext(pos);
	}
#endif

	if( 0==multiszCommandLine ) {
		nntpReturn.fSet( nrcSyntaxError ) ;
		return	FALSE ;
	}

	POSITION	pos = pNamereflist->GetHeadPosition() ;

	LPSTR	lpstrArg = multiszCommandLine ;
	while( lpstrArg != 0 && *lpstrArg != '\0' ) {
		
		LPSTR	lpstrColon = strchr( lpstrArg, ':' ) ;
		if( lpstrColon == 0 ) {
			

		}	else	{
			*lpstrColon = '\0' ;
			_strlwr( lpstrArg ) ;
			CGRPCOREPTR	pGroup = pNewstree->GetGroup( lpstrArg, (int)(lpstrColon-lpstrArg) ) ;
			*lpstrColon++ = ':' ;
			if( pGroup ) {
				
				LPSTR	lpstrCheckDigits = lpstrColon ;
				while( *lpstrCheckDigits ) {
					if( !isdigit( *lpstrCheckDigits ++ ) ) 	{
						nntpReturn.fSet( nrcSyntaxError ) ;
						return	FALSE ;
					}
				}	

				CPostGroupPtr pPostGroupPtr(pGroup);

				grouplist.AddTail( pPostGroupPtr ) ;
				
				NAME_AND_ARTREF		NameRef ;

				//
				// Only I from master care about the compare key, which
				// is the pointer to the vroot, because incoming xref
				// line from master has no knowledge of our vroots, and
				// they might not be ordered by vroots.  Just as we will sorted
				// grouplist based on vroots, we'll also sort nameref list
				// based on vroot.  So we are setting the compare key here
				//
				NameRef.artref.m_compareKey = pGroup->GetVRootWithoutRef();
				NameRef.artref.m_groupId = pGroup->GetGroupId() ;
				NameRef.pcName.vInsert(pGroup->GetName()) ;
				NameRef.artref.m_articleId = (ARTICLEID)atoi( lpstrColon ) ;

				pGroup->InsertArticleId( NameRef.artref.m_articleId ) ;

				pNamereflist->AddTail(NameRef ) ;

			}
		}
		lpstrArg += lstrlen( lpstrArg ) + 1 ;
	}

	return nntpReturn.fSetOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\infeed.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    infeed.cpp

Abstract:

    This module contains definition for the CInFeed base class

Author:

    Carl Kadie (CarlK)     01-Oct-1995

Revision History:

--*/

#include "stdinc.h"
//#include "smtpdll.h"
#include "drvid.h"

//
///!!! is this the best place for this???
//

const time_t INVALID_TIME = (time_t) -1;

//
// The largest allowed xover line.
//

const DWORD cchXOverMax = 3400;

//
// Max warnings to log on moderated post failures
//
#define MAX_EVENTLOG_WARNINGS	9

//
//If some of these look very simple, make them inline!!!!
//

//const   unsigned    cbMAX_FEED_SIZE = MAX_FEED_SIZE ;

HANDLE GetNtAnonymousToken() {
    TraceFunctEnter("GetNtAnonymousToken");

    HANDLE  hToken = NULL;

    //  Impersonate Anonymous token on this thread
    if (!ImpersonateAnonymousToken(GetCurrentThread()))
    {
        DWORD   dw = GetLastError();
        ErrorTrace(0, "ImpersonateAnonymousToken() failed %x", dw);
        return NULL;
    }

    //  Get current thread token
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, TRUE, &hToken))
    {
        ErrorTrace(0, "OpenThreadToken() failed %x", GetLastError());
        // fall through to RevertToSelf
    }

    //  Revert to self
    RevertToSelf();

    return hToken;

}

void SelectToken(
	CSecurityCtx *pSecurityCtx,
	CEncryptCtx *pEncryptCtx,
	HANDLE *phToken,
	BOOL *pfNeedsClosed)
{

	*pfNeedsClosed = FALSE;

	//
	// Set the token.  Note that it might be overwritten below, but we want to
	// have a default value in case it isn't.
	//

	if ( pEncryptCtx && pEncryptCtx->QueryCertificateToken() )
		*phToken = pEncryptCtx->QueryCertificateToken();
	else if ( pSecurityCtx && pSecurityCtx->QueryImpersonationToken() ) {
		*phToken = pSecurityCtx->QueryImpersonationToken();
	} else
		*phToken = NULL;

	//
	// If we're anonymous and this is an exchange vroot, just get the NT token and return it.
	//
	if (pSecurityCtx && pSecurityCtx->IsAnonymous()) {
		*phToken = GetNtAnonymousToken();
		if(*phToken) {
			*pfNeedsClosed = TRUE;
			return;
		}
	}

}

void
SaveGroupList(	char*	pchGroups,	
				DWORD	cbGroups,	
				CNEWSGROUPLIST&	grouplist ) {

	_ASSERT( pchGroups != 0 ) ;
	_ASSERT( cbGroups > 0 ) ;

	DWORD	ib = 0 ;

	POSITION	pos = grouplist.GetHeadPosition() ;
	if( grouplist.IsEmpty() ) {
		pchGroups[0] = '\0' ;
	}	else	{
		while( pos ) {
			CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
			CGRPCOREPTR group = pPostGroupPtr->m_pGroup;

			LPSTR	lpstr = group->GetName() ;
			DWORD	cb = lstrlen( lpstr ) ;

			if( (ib + cb + 1) < cbGroups ) {
				CopyMemory( pchGroups+ib, lpstr, cb ) ;
			}	else	{
				pchGroups[ib-1] = '\0' ;
				return	 ;
			}
			ib+=cb ;
			pchGroups[ib++] = ' ' ;
		}
		pchGroups[ib-1] = '\0' ;
	}
}


void
CInFeed::LogFeedEvent(	DWORD	messageId,	LPSTR	lpstrMessageId, DWORD dwInstanceId )	{
#ifdef BUGBUG

	PCHAR	rgArgs[3] ;
	CHAR    szId[20];

	_itoa( dwInstanceId, szId, 10 );
	rgArgs[0] = szId ;
	rgArgs[1] = ServerNameFromCompletionContext( m_feedCompletionContext ) ;
	rgArgs[2] = lpstrMessageId ;

	if( rgArgs[1] == 0 ) {
		rgArgs[1] = "<UNKNOWN>" ;
	}

	if( m_cEventsLogged < 100 ) {

		NntpLogEvent(
				messageId,
				3,
				(const CHAR **)rgArgs,
				0 ) ;
		

	}	else	if(	m_cEventsLogged == 100 ) {

		//
		//	Log the too many logs this session message !
		//

		NntpLogEvent(
				NNTP_EVENT_TOO_MANY_FEED_LOGS,
				3,
				(const CHAR **)rgArgs,
				0 ) ;

	}
	m_cEventsLogged ++ ;
#endif

}

//
//	K2_TOD: should make this a member of NNTP_SERVER_INSTANCE ?
//

BOOL
gFeedManfPost(
			  CNntpServerInstanceWrapper * pInstance,
			  CNEWSGROUPLIST& newsgroups,
			  CNAMEREFLIST& namerefgroups,
			  class	CSecurityCtx*	pSecurity,
			  BOOL	fIsSecure,
			  CArticle* pArticle,
			  CStoreId *rgStoreIds,
			  BYTE *rgcCrossposts,
			  DWORD cStoreIds,
			  const CPCString & pcXOver,
			  CNntpReturn & nntpReturn,
			  DWORD dwFeedId,
			  char *pszMessageId,
			  WORD HeaderLength
			  )
/*++

Routine Description:

	Puts an article in the news tree.

	!!! this should be made part of feedman eventually


Arguments:

	pInstance - virtual server instance for this post
	newsgroups - a list of newsgroup objects to post to.
	namerefgroups - a list of the names, groupid and article ids of the article
	pArticle - a pointer to the article being processed
	pcXOver - the XOver data from this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{	
    TraceQuietEnter("gFeedManfPost");

	_ASSERT(newsgroups.GetCount() == namerefgroups.GetCount()); //real
	_ASSERT(1 <= newsgroups.GetCount()); //real
	nntpReturn.fSetClear(); // clear the return object

	//
	// Get the article's messageid
	//

	const char *szMessageID;
	if (pszMessageId) {
		_ASSERT(pArticle == NULL);
		szMessageID = pszMessageId;
	} else {
		_ASSERT(pArticle);
		szMessageID = pArticle->szMessageID();
	}
	DWORD	cbMessageID = lstrlen( szMessageID ) ;

	//
	// Loop through all the newsgroups, but get the 1st newsgroup first
	// because it is a special case.
	//

	POSITION	pos1 = newsgroups.GetHeadPosition() ;
	POSITION	pos2 = namerefgroups.GetHeadPosition() ;

	CPostGroupPtr *pPostGroupPtr = newsgroups.GetNext(pos1);
	CGRPCOREPTR pGroup = pPostGroupPtr->m_pGroup;
	NAME_AND_ARTREF * pNameRef = namerefgroups.GetNext( pos2 ) ;
	CArticleRef * pArtrefFirst = &(pNameRef->artref);

    //
    // If the length of the header is zero, see if we have it in pArticle.
    //
	WORD	HeaderOffset = 0 ;
	if (HeaderLength == 0 && pArticle) {
		DWORD	ArticleSize = 0 ;
		pArticle->GetOffsets(	HeaderOffset,
								HeaderLength,
								ArticleSize ) ;
	}

	//
	// Record the location of this article in the hash table
	//

	if (!(pInstance->ArticleTable())->SetArticleNumber(
                szMessageID,
				HeaderOffset,
				HeaderLength,
                pArtrefFirst->m_groupId,
                pArtrefFirst->m_articleId,
				rgStoreIds[0]
                )) {

        //
        //  If this fails, we end up with orphaned NWS files in the
        //  newsgroup. So, delete the file we just inserted...
        //

		if ( pGroup->DeletePhysicalArticle( pArtrefFirst->m_articleId ) )
		{
			DebugTrace(0,"Group %s ArticleId %d - SetArticleNumber failed - phy article deleted", pGroup->GetName(), pArtrefFirst->m_articleId);
		}
		else
		{
			ErrorTrace(0,"Could not delete phy article: GroupId %s ArticleId %d", pGroup->GetName(), pArtrefFirst->m_articleId);
		}

		return nntpReturn.fSet(nrcHashSetArtNumSetFailed,
                pArtrefFirst->m_groupId,
                pArtrefFirst->m_articleId,
                szMessageID,
				GetLastError());
    }

	FILETIME	FileTime ;
	GetSystemTimeAsFileTime( &FileTime ) ;

	//
	// Record the articles Xover information
	//
    DWORD       cXPosts = namerefgroups.GetCount() - 1 ;
    GROUP_ENTRY *pGroups = 0 ;
    if( cXPosts > 0 ) {
		if (pArticle) {
	        pGroups =  (GROUP_ENTRY*)pArticle->pAllocator()->Alloc( cXPosts * sizeof(GROUP_ENTRY) ) ;
		} else {
			pGroups = XNEW GROUP_ENTRY[cXPosts];
		}
	}
    if( pGroups ) {

    	POSITION	pos3 = namerefgroups.GetHeadPosition() ;
        NAME_AND_ARTREF *pNameRefTemp = namerefgroups.GetNext( pos3 ) ;
        for( DWORD i=0; i<cXPosts; i++ ) {

            pNameRefTemp = namerefgroups.GetNext(pos3) ;
            pGroups[i].GroupId = pNameRefTemp->artref.m_groupId ;
            pGroups[i].ArticleId = pNameRefTemp->artref.m_articleId ;

        }


    }

    BOOL    fCreateSuccess =  (pInstance->XoverTable())->CreatePrimaryNovEntry(
                        pArtrefFirst->m_groupId,
			            pArtrefFirst->m_articleId,
						HeaderOffset,
						HeaderLength,
						&FileTime,
						szMessageID, /*pcXOver.m_pch,*/
						cbMessageID, /*pcXOver.m_cch,*/
                        cXPosts,
                        pGroups,
						cStoreIds,
						rgStoreIds,
						rgcCrossposts
                        ) ;

    DWORD gle = NO_ERROR;

    if (!fCreateSuccess)
        gle = GetLastError();

    if( pGroups ) {
		if (pArticle) {
	        pArticle->pAllocator()->Free( (char*)pGroups ) ;
		} else {
			XDELETE[] pGroups;
		}
    }

    if( !fCreateSuccess )   {

		// If CreateNovEntry Fails, the GLE should not be 0
		//_ASSERT(0 != GetLastError());
        SetLastError(gle);
        ErrorTrace(0, "CreatePrimaryNovEntry failed, %x", GetLastError());

		return nntpReturn.fSet(
                    nrcCreateNovEntryFailed,
                    pArtrefFirst->m_groupId,
                    pArtrefFirst->m_articleId,
			    	GetLastError()
                    );
	}

    //
    // Insert primary article succeeded, we'll bump article count
	//
	pGroup->BumpArticleCount( pArtrefFirst->m_articleId );

	//
	// If there no newsgroups, then we are done.
	//

	DWORD cLastRest = namerefgroups.GetCount();
	if (1 == cLastRest)	{

		return nntpReturn.fSetOK();
	}

	//
	// there must be some more newsgroups.
	// Allocate some space for them
	//

	GROUPID * rgGroupID = //!!~MEM(GROUPID *) (pArticle->pAllocator())->Alloc(sizeof(GROUPID) * cLastRest);
						XNEW GROUPID[cLastRest];
	if (!rgGroupID)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);


	gFeedManfPostInternal(pInstance, newsgroups, namerefgroups, pcXOver,
				pos1, pos2, &pGroup, pNameRef, pArtrefFirst,
				szMessageID, rgGroupID,
				HeaderOffset, HeaderLength, FileTime, nntpReturn
				);

	//
	// No matter what, dellocate that memory
	//

    gle = GetLastError();
	//!!!MEM (pArticle->pAllocator())->Free((char *)rgGroupID);
	XDELETE[]rgGroupID;
    SetLastError(gle);

	return nntpReturn.fIsOK();
}

//
//	K2_TOD: should make this a member of NNTP_SERVER_INSTANCE ?
//

BOOL
gFeedManfPostInternal(
			  CNntpServerInstanceWrapper * pInstance,
			  CNEWSGROUPLIST& newsgroups,
			  CNAMEREFLIST& namerefgroups,
			  const CPCString & pcXOver,
			  POSITION & pos1,
			  POSITION & pos2,
			  CGRPCOREPTR * ppGroup,
			  NAME_AND_ARTREF * pNameRef,
			  CArticleRef * pArtrefFirst,
			  const char * szMessageID,
			  GROUPID * rgGroupID,
			  WORD	HeaderOffset,
			  WORD	HeaderLength,
			  FILETIME FileTime,
  			  CNntpReturn & nntpReturn
			  )
/*++

Routine Description:

	Does most of the work of puting an article in the news tree.

	!!! this should be made part of feedman eventually


Arguments:

	pInstance - virtual server instance
	newsgroups - a list of newsgroup objects to post to.
	namerefgroups - a list of the names, groupid and article ids of the article
	pArticle - a pointer to the article being processed
	pcXOver - the XOver data from this article.
	ppGroup - a pointer to the group pointer
	pNameRef - a pointer to the name, group id, and article id
	pArtrefFirst - a pointer groupid/articleid of the first group
	szMessageID - the article's message id
	rgGroupID - an array of group id's
	FileTime - the current time in FILETIME format.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{	

    TraceQuietEnter("gFeedManfPostInternal");

	DWORD cRest = 0;
    BOOL  fSuccess = TRUE;
	while( pos1) {

		_ASSERT(pos2);
		CPostGroupPtr *pPostGroupPtr = newsgroups.GetNext(pos1);
		ppGroup = &(pPostGroupPtr->m_pGroup);
		pNameRef = namerefgroups.GetNext( pos2 ) ;
		if (!(* ppGroup)->AddReferenceTo((pNameRef->artref).m_articleId, *pArtrefFirst))
		{
			char szName[MAX_PATH];
			(pNameRef->pcName).vCopyToSz(szName);

            //  Set failure codes and continue processing -
            //  Error paths will cleanup this article.
			nntpReturn.fSet(nrcNewsgroupAddRefToFailed,	szName, szMessageID);
            fSuccess = FALSE;
		}

		//
		// append this groupid to a list
		//

		rgGroupID[cRest++] = (pNameRef->artref).m_groupId;
	}

    //
    // Bail if we encountered an error while adding refs to logical groups
    //
    if( !fSuccess ) {
        _ASSERT( !nntpReturn.fIsOK() );
        ErrorTrace(0, "AddRef failed for %s", szMessageID);
        return FALSE ;
    }

	//
	// Record the articles Xover information for the remaining newsgroups
	//

	pos2 = namerefgroups.GetHeadPosition() ;
	namerefgroups.GetNext( pos2 ) ;

	//
	// Get the newstree object, to get group by id 
	//
	CNewsTreeCore *pTree = pInstance->GetTree();
	_ASSERT( pTree );

	while( pos2) {
		pNameRef = namerefgroups.GetNext( pos2 ) ;
		CArticleRef * pArtref = &(pNameRef->artref);

		//
		// If the group has already been deleted, don't bother to create nov
		// entry for him
		//
		CGRPCOREPTR pGroup = pTree->GetGroupById( pArtref->m_groupId, TRUE );
		if ( pGroup ) {
		    if (!(pInstance->XoverTable())->CreateXPostNovEntry(pArtref->m_groupId,
			    				pArtref->m_articleId,
				    			HeaderOffset,
					    		HeaderLength,
						    	&FileTime,
                                pArtrefFirst->m_groupId,
                                pArtrefFirst->m_articleId
                                )) {
                ErrorTrace(0, "CreateXPostNovEntry failed %x", GetLastError());
		    	return nntpReturn.fSet(nrcCreateNovEntryFailed,
			    		pArtref->m_groupId,
				    	pArtref->m_articleId,
					    GetLastError());
		    } else {

		        // 
		        // Insert succeeded, we'll bump the article count for this group
		        //
		        pGroup->BumpArticleCount( pArtref->m_articleId );
		    }
		}
	}

	
	
	//
	// Everything is OK, so set return code
	//

	return nntpReturn.fSetOK();
}




char *	
CInFeed::szTempDirectory( void )

/*++

Routine Description:

	Returns the name of the temp directory in which incomming articles
	should be placed.

Arguments:

	None.

Return Value:

	The name of the temp directory.

--*/
{
	return m_szTempDirectory;
} //!!!make inline


DWORD
CInFeed::cInitialBytesGapSize(
					 void
					 )
/*++

Routine Description:

	Returns the size of the gap in the files of incomming articles.


Arguments:

	None.

Return Value:

	The gap size.

--*/
{
	return m_cInitialBytesGapSize;
}


BOOL CInFeed::MailMsgAddAsyncHandle(PATQ_CONTEXT      *ppatqContext,
                                    PVOID             pEndpointObject,
                                    PVOID             pClientContext,
                                    ATQ_COMPLETION    pfnCompletion,
                                    DWORD             cTimeout,
                                    HANDLE            hAsyncIO)
{
	_ASSERT(ppatqContext != NULL);
	_ASSERT(hAsyncIO != INVALID_HANDLE_VALUE);
	if (ppatqContext == NULL || hAsyncIO == INVALID_HANDLE_VALUE) {
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	*ppatqContext = (PATQ_CONTEXT) AssociateFile(hAsyncIO);
	return (*ppatqContext != NULL);
}

void CInFeed::MailMsgFreeContext(PATQ_CONTEXT     pAtqContext,
                                 BOOL             fReuseContext)
{
	ReleaseContext((FIO_CONTEXT *) pAtqContext);
}

CPostContext::CPostComplete::CPostComplete(CInFeed *pInFeed,
										   CPostContext *pContext,
										   INntpComplete *pPostCompletion,
										   BOOL fAnonymous,
										   DWORD &dwSecondary,
										   CNntpReturn &nntpReturn)
  : m_pInFeed(pInFeed),
	m_pContext(pContext),
	m_pPostCompletion(pPostCompletion),
	m_fAnonymous(fAnonymous),
	m_dwSecondary(dwSecondary),
	m_nntpReturn(nntpReturn),
	CNntpComplete()
{
    m_fWriteMapEntries = TRUE;
}

void CPostContext::CPostComplete::Destroy() {
	HRESULT hr = GetResult();

	//
	// see if we are either done or have hit in an error.  in both cases
	// we need to go through WriteMapEntries to properly set the NNTP
	// error code
	//
	
        //  make sure we have Read Acess to the m_pArticle pointer.
        _ASSERT( IsBadReadPtr( (void *) (m_pContext->m_pArticle), sizeof(m_pContext->m_pArticle) ) == 0 );
        _ASSERT( m_pContext->m_pArticle != NULL );
	if (FAILED(hr) || m_pContext->m_cStoreIds == m_pContext->m_cStores) {
	    INntpComplete *pPostCompletion = m_pPostCompletion;

            pPostCompletion->SetResult( hr );
            if ( SUCCEEDED( hr ) && m_fWriteMapEntries ) {
    		BOOL f = m_pInFeed->WriteMapEntries(hr,
                                                    m_pContext,
                                                    m_dwSecondary,
                                                    m_nntpReturn
                                                    );
		pPostCompletion->SetResult( f ? S_OK : E_ABORT );
            } else if ( FAILED( hr )  )  {
                //  fix 600 return code when async post fail in the Store
                CNntpReturn ret;
                ret.fSet(nrcNewsgroupInsertFailed, NULL, NULL);
                m_nntpReturn.fSet(nrcPostFailed, ret.m_nrc, ret.szReturn());
            }

            //
            // Whether we succeeded or not, we'll release the post context
            //
            _ASSERT( m_pContext );
            m_pContext->Release();
            pPostCompletion->Release();
	} else {
            // in this case there are more stores to post to.
            _ASSERT(m_pContext->m_cStoreIds < m_pContext->m_cStores);

            CNntpComplete::Reset();
            m_pVRoot->Release();
            m_pVRoot = NULL;

            //
            // Passing in NULL is fine, since sfromcl guy should never come here
            //
            m_pInFeed->CommitPostToStores(m_pContext, NULL);
	}
}

BOOL
CInFeed::PostEarly(
		CNntpServerInstanceWrapper			*pInstance,
		CSecurityCtx                        *pSecurityCtx,
		CEncryptCtx                         *pEncryptCtx,
		BOOL								fAnonymous,
		const LPMULTISZ						szCommandLine,
		CBUFPTR								&pbufHeaders,
		DWORD								iHeadersOffset,
		DWORD								cbHeaders,
		DWORD								*piHeadersOutOffset,
		DWORD								*pcbHeadersOut,
		PFIO_CONTEXT						*ppFIOContext,
		void								**ppvContext,
		DWORD								&dwSecondary,
		DWORD								dwRemoteIP,
		CNntpReturn							&nntpReturn,
		char                                *pszNewsgroups,
		DWORD                               cbNewsgroups,
		BOOL								fStandardPath,
		BOOL								fPostToStore)
{
	TraceFunctEnter("CInFeed::PostEarly");

	CNntpReturn ret2;
	CPostContext *pContext = NULL;
	HRESULT hr;

	_ASSERT(pInstance);
	_ASSERT(pbufHeaders);
	_ASSERT(cbHeaders > 0);
	*ppFIOContext = NULL;

	pInstance->BumpCounterArticlesReceived();

	// create our context pointer and article object
	pContext = XNEW CPostContext(this,
								0,
								pInstance,
								pSecurityCtx,
								pEncryptCtx,
								fAnonymous,
								pbufHeaders,
								cbHeaders,
								fStandardPath,
								dwSecondary,
								nntpReturn);
	if (pContext) pContext->m_pArticle = pArticleCreate();
	if (pContext == NULL || pContext->m_pArticle == NULL) {
		if (pContext) {
			pContext->Release();
			pContext = NULL;
		}
		pbufHeaders = NULL;
		ret2.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
		_ASSERT(*ppFIOContext == NULL);
		return	nntpReturn.fSet(nrcArticleRejected(fStandardPath),
								ret2.m_nrc, ret2.szReturn());
	}


    //
    // Create the mail message using instance's class factory
    //
    hr = pInstance->CreateMailMsgObject( &pContext->m_pMsg );
    /*
	hr = CoCreateInstance((REFCLSID) clsidIMsg,
		                       NULL,
		                       CLSCTX_INPROC_SERVER,
		                       (REFIID) IID_IMailMsgProperties,
		                       (void**)&pContext->m_pMsg );
    */
	if (FAILED(hr)) {
		pContext->m_pArticle->vClose();
		pContext->Release();
		ret2.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
		pbufHeaders = NULL;
		_ASSERT(*ppFIOContext == NULL);
		return	nntpReturn.fSet(nrcArticleRejected(fStandardPath),
								ret2.m_nrc, ret2.szReturn());
	}

	if (!pContext->m_pArticle->fInit(pbufHeaders->m_rgBuff + iHeadersOffset,
									 cbHeaders,
									 cbHeaders,
									 cbHeaders,
									 &(pContext->m_allocator),
									 pInstance,
									 ret2))
	{
		dwSecondary = ret2.m_nrc;
		pContext->Release();
		pbufHeaders = NULL;
		_ASSERT(*ppFIOContext == NULL);
		return nntpReturn.fSet(nrcArticleRejected(fStandardPath),
							   ret2.m_nrc, ret2.szReturn());
	}

	if (!fPostInternal(pInstance,
					   szCommandLine,
					   pSecurityCtx,
					   pEncryptCtx,
					   pContext->m_fAnonymous,
					   pContext->m_pArticle,
					   pContext->m_grouplist,
					   pContext->m_namereflist,
					   pContext->m_pMsg,
					   pContext->m_allocator,
					   pContext->m_multiszPath,
					   NULL,
					   0,
					   pszNewsgroups,
					   cbNewsgroups,
					   dwRemoteIP,						// XXX: REMOTE IP ADDR
					   ret2,
					   ppFIOContext,
					   &(pContext->m_fBound),
					   &(pContext->m_dwOperations),
					   &(pContext->m_fPostToMod),
					   pContext->m_szModerator ))
	{
		//
		// Moves the message id (if any) to the history table.
		// Unless the message id was a duplicate, or due to HashSetFailed.
        // But we also want to move mid if HashSetFailed is due to moving
        // into history table, which is returned by CANCEL or expiration.
		//
		const char *szMessageID = pContext->m_pArticle->szMessageID();

		if (szMessageID[0] != 0 &&
			!ret2.fIs(nrcArticleDupMessID) &&
		    ((!ret2.fIs(nrcHashSetFailed)) ? TRUE : (NULL != strstr(ret2.szReturn(), "History"))))
		{
 			fMoveMessageIDIfNecc(pInstance, szMessageID, nntpReturn, NULL, FALSE);
		}	

		dwSecondary = ret2.m_nrc;
		pContext->Release();
		pbufHeaders = NULL;
		_ASSERT(*ppFIOContext == NULL);
		return nntpReturn.fSet(nrcArticleRejected(fStandardPath),
							   ret2.m_nrc, ret2.szReturn());
	}

	pContext->m_pFIOContext = *ppFIOContext;


	*piHeadersOutOffset = iHeadersOffset;

	//
	//	Figure out whether the headers were left in our IO buffer, if so then we
	//	don't need to do much !
	//
	if (pContext->m_pArticle->FHeadersInIOBuff(pbufHeaders->m_rgBuff,
											   pbufHeaders->m_cbTotal))
	{
		*pcbHeadersOut = pContext->m_pArticle->GetHeaderPosition(pbufHeaders->m_rgBuff,
																 pbufHeaders->m_cbTotal,
																 *piHeadersOutOffset);
		_ASSERT(*piHeadersOutOffset >= iHeadersOffset);
	}	else	{
		// see if the headers will fit into the buffer
		*pcbHeadersOut = pContext->m_pArticle->GetHeaderLength( );
	
		if (*pcbHeadersOut > (pbufHeaders->m_cbTotal - iHeadersOffset)) {
			*piHeadersOutOffset = 0 ;
			// there isn't enough space.  Lets allocate a larger buffer
			DWORD cbOut = 0;
			pbufHeaders = new (*pcbHeadersOut,
			  				   cbOut,
							   CBuffer::gpDefaultSmallCache,
							   CBuffer::gpDefaultMediumCache)
							   CBuffer (cbOut);
			if (pbufHeaders == NULL ||
				pbufHeaders->m_cbTotal < *pcbHeadersOut)
			{
				ret2.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
				pContext->Release();
				pbufHeaders = NULL;
				_ASSERT(*ppFIOContext == NULL);
				return nntpReturn.fSet(nrcArticleRejected(fStandardPath),
								   	   ret2.m_nrc, ret2.szReturn());	
			}
		}	

		// copy the headers out of the article back into the buffer
		pContext->m_pArticle->CopyHeaders(pbufHeaders->m_rgBuff + *piHeadersOutOffset);
	}

	nntpReturn.fSetOK();

	*ppvContext = pContext;

	return TRUE;
}

BOOL
CInFeed::ShouldBeSentToModerator(   CNntpServerInstanceWrapper *pInstance,
                                    CPostContext *pContext )
/*++
Routine description:

    Check to see if we were to be posted to a moderated group

Argument:

    CNntpServerInstanceWrapper *pInstance   - The server instance wrapper
    CPostContext *pContext                  - The post context

Return value:

    TRUE if we were to be posted to a moderated group, FALSE otherwise
--*/
{
    TraceFunctEnter( "CInFeed::ShouldBeSentToModerator" );
    _ASSERT( pInstance );
    _ASSERT( pContext );
#ifdef DEBUG
    if ( pContext->m_fPostToMod ) {
        POSITION	pos = pContext->m_grouplist.GetHeadPosition();
        _ASSERT( pos );
		CPostGroupPtr *pPostGroupPtr = pContext->m_grouplist.GetNext(pos);
		CGRPCOREPTR pGroup1 = pPostGroupPtr->m_pGroup;
		_ASSERT( pGroup1 );
		CNewsTreeCore *pTree = pInstance->GetTree();
		_ASSERT( pTree );
        CGRPCOREPTR pGroup2 = pTree->GetGroupById( pTree->GetSlaveGroupid() );
        _ASSERT( pGroup2 );
        _ASSERT( pGroup1 == pGroup2 );
    }
#endif
    return pContext->m_fPostToMod;
}

BOOL
CInFeed::SendToModerator(   CNntpServerInstanceWrapper *pInstance,
                            CPostContext *pContext )
/*++
Routine description:

    Send the article to the moderator

Arguments:

    CNntpServerInstanceWrapper  *pInstance  - Server instance wrapper
    CPostContext                *pContext   - Post context

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CInFeed::SendToModerator" );
    _ASSERT( pInstance );
    _ASSERT( pContext );

    //
    // Get the group object from post context
    //
    POSITION    pos = pContext->m_grouplist.GetHeadPosition();
    _ASSERT( pos );
    CPostGroupPtr *pPostGroupPtr = pContext->m_grouplist.GetNext(pos);
    _ASSERT( pPostGroupPtr );
    CGRPCOREPTR pGroup = pPostGroupPtr->m_pGroup;
    _ASSERT( pGroup );

    //
    // Get the article id ( posted to the special group )
    //
	pos = pContext->m_namereflist.GetHeadPosition() ;
	_ASSERT( pos );
	NAME_AND_ARTREF *pNameref = pContext->m_namereflist.GetNext(pos);
	_ASSERT( pNameref );
	if (pNameref == NULL) {
	    return FALSE;
	}
	ARTICLEID artid = pNameref->artref.m_articleId;
	_ASSERT( artid > 0 );

	return pInstance->MailArticle( pGroup, artid, pContext->m_szModerator );
}

void
CInFeed::ApplyModerator( CPostContext   *pContext,
                         CNntpReturn    &nntpReturn )
/*++
Routine description:

    Apply moderator - send the message to moderator

Arguments:

    CPostContext    *pCotnext   - Posting context
    CNntpReturn     &nntpReturn - nntp return

Return value:

    None.
--*/
{
    //
	// We should check for moderator first, if it's a message that needs
	// to be sent to moderator, we should do it here without going any
	// farther
	//
	if ( ShouldBeSentToModerator( pContext->m_pInstance, pContext ) ) {
	    if ( !SendToModerator( pContext->m_pInstance, pContext ) ) {
	        nntpReturn.fSet(nrcPostModeratedFailed, pContext->m_szModerator);
	    } else {
	        nntpReturn.fSetOK();
	    }
	} else nntpReturn.fSetOK();
}

//
// this is called by the protocol when a message is received
//
BOOL
CInFeed::PostCommit(
        CNntpServerInstanceWrapper          *pInstance,
		void								*pvContext,
		HANDLE                              hToken,
		DWORD								&dwSecondary,
		CNntpReturn							&nntpReturn,
		BOOL								fAnonymous,
		INntpComplete*      				pCompletion
		)
{
	CPostContext *pContext = (CPostContext *) pvContext;
	HRESULT hr;
	BOOL    bSyncPost = FALSE;  // this will be taken out when async post is done

    //
    // This is not to be posted to the moderated group, we can go ahead
    //
	hr = TriggerServerEvent(pContext->m_pInstance->GetEventRouter(),
					   		CATID_NNTP_ON_POST,
					   		pContext->m_pArticle,
					   		&(pContext->m_grouplist),
					   		m_dwFeedId,
					   		pContext->m_pMsg);

	if (SUCCEEDED(hr)) {
		//DWORD dwOperations;

		hr = pContext->m_pMsg->GetDWORD(IMSG_NNTP_PROCESSING, &(pContext->m_dwOperations));
		if (SUCCEEDED(hr)) {
			// check to see if they wanted to cancel the post
			if ((pContext->m_dwOperations & NNTP_PROCESS_POST) != NNTP_PROCESS_POST) {
				PostCancel(pvContext, dwSecondary, nntpReturn);
				return	FALSE ;
			}
		}
	}

	pContext->m_hToken = hToken;

	// create a completion object which we'll block on
	pContext->m_completion.m_pPostCompletion = pCompletion ;
	CNntpSyncComplete postcompletion;
	if (pContext->m_completion.m_pPostCompletion == NULL) {
		pContext->m_completion.m_pPostCompletion = &postcompletion;
		bSyncPost = TRUE;
	}

	// figure out how many stores we are dealing with
	DWORD cStores = 0;
	POSITION posGrouplist = pContext->m_grouplist.GetHeadPosition();
	CNNTPVRoot *pThisVRoot = NULL;
	while (posGrouplist != NULL) {
		CPostGroupPtr *pPostGroupPtr = pContext->m_grouplist.GetNext(posGrouplist);
		if (pPostGroupPtr->m_pVRoot != pThisVRoot) {
			pThisVRoot = pPostGroupPtr->m_pVRoot;
			cStores++;
		}
	}

	// let each of the stores save the post.  if this fails then it will
	// back out from all stores that it properly committed to
	pContext->m_cStores = cStores;
	pContext->m_cStoreIds = 0;
	pContext->m_posGrouplist = pContext->m_grouplist.GetHeadPosition();
	pContext->m_pPostGroupPtr = pContext->m_grouplist.GetNext(pContext->m_posGrouplist);
	pContext->m_posNamereflist = pContext->m_namereflist.GetHeadPosition();
	pContext->m_pNameref = pContext->m_namereflist.GetNext(pContext->m_posNamereflist);
	pContext->m_rgStoreIds = (CStoreId *) pContext->m_allocator.Alloc(sizeof(CStoreId) * cStores);
	pContext->m_rgcCrossposts = (BYTE *) pContext->m_allocator.Alloc(sizeof(BYTE) * cStores);
	CommitPostToStores(pContext, pInstance);

	if ( bSyncPost ) {
	    _ASSERT( postcompletion.IsGood() );
	    //
	    // Since this is a Sync event, we'll increase the number of runnable
	    // threads in the Atq pool.
	    //
	    AtqSetInfo(AtqIncMaxPoolThreads, NULL);
		HRESULT hr = postcompletion.WaitForCompletion();
	    AtqSetInfo(AtqDecMaxPoolThreads, NULL);
	}

	return TRUE;
}

BOOL CInFeed::WriteMapEntries(
		HRESULT 							hr,
		CPostContext						*pContext,
		DWORD								&dwSecondary,
		CNntpReturn							&nntpReturn)
{
	CNntpReturn ret2;

	if (SUCCEEDED(hr)) {

		pContext->m_pInstance->BumpCounterArticlesPosted();

		TriggerServerEvent(pContext->m_pInstance->GetEventRouter(),
				   		   CATID_NNTP_ON_POST_FINAL,
				   		   pContext->m_pArticle,
				   		   &(pContext->m_grouplist),
				   		   m_dwFeedId,
				   		   pContext->m_pMsg);

		char szXOver[cchXOverMax];
		CPCString pcXOver(szXOver, cchXOverMax);
		if (pContext->m_pArticle->fXOver(pcXOver, ret2)) {
			if (gFeedManfPost(pContext->m_pInstance,
						  	  pContext->m_grouplist,
						  	  pContext->m_namereflist,
						  	  pContext->m_pSecurityContext,
						  	  !(pContext->m_fAnonymous),
						  	  pContext->m_pArticle,
							  pContext->m_rgStoreIds,
							  pContext->m_rgcCrossposts,
							  pContext->m_cStoreIds,
						  	  pcXOver,
						  	  ret2,
						  	  m_dwFeedId))
			{
				if (pContext->m_pInstance->AddArticleToPushFeeds(
											pContext->m_grouplist,
											pContext->m_pArticle->articleRef(),
											pContext->m_multiszPath,
											ret2))
				{
					ret2.fSetOK();
				}
			}
		}

        //  Only execute control message if Server Event doesn't disable it.
        if (pContext->m_dwOperations & NNTP_PROCESS_CONTROL)
        {
            if (!fApplyControlMessageCommit(pContext->m_pArticle, pContext->m_pSecurityContext, pContext->m_pEncryptContext, pContext->m_fAnonymous, pContext->m_grouplist, &(pContext->m_namereflist), ret2))
            {
			    if( !nntpReturn.fIsOK() )
			    {
				    // bump perfmon counter
				    pContext->m_pArticle->m_pInstance->BumpCounterControlMessagesFailed();
			    }
            }
        }

        if ( pContext->m_dwOperations & NNTP_PROCESS_MODERATOR ) {
                //
                // Send article to moderator if necessary
                //
                pContext->CleanupMailMsgObject();
                ApplyModerator( pContext, ret2 );
        }

        if (!(ret2.fIsOK())) {
			// GUBGUB - back out post
		}
	} else {
		// GUBGUB - unroll succeeded postings?

		ret2.fSet(nrcNewsgroupInsertFailed, NULL, NULL);
	}

	// update nntpReturn as necessary
	dwSecondary = ret2.m_nrc;
	if (ret2.fIsOK()) {
		nntpReturn.fSet(nrcArticleAccepted(pContext->m_fStandardPath));
	} else {

		//
		// Moves the message id (if any) to the history table.
		// Unless the message id was a duplicate, or due to HashSetFailed.
        // But we also want to move mid if HashSetFailed is due to moving
        // into history table, which is returned by CANCEL or expiration.
		//
		const char *szMessageID = pContext->m_pArticle->szMessageID();

		if ('\0' != szMessageID[0] &&
			!ret2.fIs(nrcArticleDupMessID) &&
		    ((!ret2.fIs(nrcHashSetFailed)) ?
				TRUE : (NULL != strstr(ret2.szReturn(), "History"))))
		{
 			fMoveMessageIDIfNecc(pContext->m_pInstance, szMessageID, nntpReturn, pContext->m_hToken, pContext->m_fAnonymous );
		}

		nntpReturn.fSet(nrcArticleRejected(pContext->m_fStandardPath),
			ret2.m_nrc, ret2.szReturn());
	}

	return ret2.fIsOK();
}


//
// this is called by the protocol if a message was cancelled.  we will
// close the message file handle and get rid of the IMailMsgProperties
//
BOOL
CInFeed::PostCancel(
		void								*pvContext,
		DWORD								&dwSecondary,
		CNntpReturn							&nntpReturn)
{
	CPostContext *pContext = (CPostContext *) pvContext;

	CPostGroupPtr *pPostGroupPtr = pContext->m_grouplist.GetHead();
	if (pPostGroupPtr == NULL) {
	    return FALSE;
	}
	IMailMsgStoreDriver *pDriver = pPostGroupPtr->GetStoreDriver();
	HRESULT hr;
	CNntpReturn ret2;

	ret2.fSet(nrcServerEventCancelledPost);

	// we need to release our usage of the file handle
	if (pContext->m_pMsg && pContext->m_fBound) {
		IMailMsgQueueMgmt *pQueueMgmt;
		HRESULT hr;
		hr = pContext->m_pMsg->QueryInterface(IID_IMailMsgQueueMgmt,
									          (void **)&pQueueMgmt);
		if (SUCCEEDED(hr)) {

            //
            // Before we ask mail message to delete it, we'll close
            // the handle forcefully, no one should think this handle
            // is open from now on
            //
            CloseNonCachedFile( pContext->m_pFIOContext );
            pQueueMgmt->Delete(NULL);
			pContext->m_fBound = FALSE;
            pContext->m_pMsg = NULL;
            pQueueMgmt->Release();
		}
	}

	// tell the driver to delete the message
	if ( pContext->m_pMsg ) {
	    pContext->m_pMsg->AddRef();
	    hr = pDriver->Delete(pContext->m_pMsg, NULL);
	    _ASSERT(SUCCEEDED(hr));		// not much that we can do if this failed
	}
	
	// release our reference on the driver
	pDriver->Release();

	// remove the entry from the article hash table, if it was made
	const char *szMessageID = pContext->m_pArticle->szMessageID();
	if (*szMessageID != 0) {
		pContext->m_pInstance->ArticleTable()->DeleteMapEntry(szMessageID);
	}

	dwSecondary = ret2.m_nrc;
	nntpReturn.fSet(nrcArticleRejected(pContext->m_fStandardPath),
		ret2.m_nrc, ret2.szReturn());

	// delete all other state
	pContext->Release();

	return TRUE;
}

BOOL CInFeed::PostPickup(CNntpServerInstanceWrapper	*pInstance,
						 CSecurityCtx               *pSecurityCtx,
						 CEncryptCtx                *pEncryptCtx,
						 BOOL						fAnonymous,
						 HANDLE						hArticle,
						 DWORD						&dwSecondary,
						 CNntpReturn				&nntpreturn,
						 BOOL						fPostToStore)
{
	TraceFunctEnter("CInFeed::PostPickup");

	_ASSERT(pInstance != NULL);

	//
	// memory map the file
	//
	CMapFile map(hArticle, TRUE, FALSE, 0);
	if (!map.fGood()) {
		// the memory map failed, put it on the retry queue
		TraceFunctLeave();
		return FALSE;
	}
	DWORD cMapBuffer;
	char *pMapBuffer = (char *) map.pvAddress(&cMapBuffer);
	BOOL fSuccess = TRUE;

	//
	// a valid buffer needs to be at least 9 bytes long (to contain
	// \r\n\r\n\r\n.\r\n and pass the next two tests.  we aren't
	// assuming anything about what headers need to be here, we'll
	// let fPost handle that).
	//
	CNntpReturn nr;
	char szMessageID[MAX_PATH] = "";
	char szGroups[MAX_PATH] = "";

	if (cMapBuffer >= 9) {
		//
		// make sure the article ends with \r\n.\r\n.  we scan for it, and
		// when we find it we set pDot to point at it.
		//
		char *pDot = pMapBuffer + (cMapBuffer - 5);
		while (fSuccess && memcmp(pDot, "\r\n.\r\n", 5) != 0) {
			pDot--;
			if (pDot == pMapBuffer) fSuccess = FALSE;
		}
	
		if (fSuccess) {
			//
			// find the end of the headers
			//
			char *pEndBuffer = pMapBuffer + (cMapBuffer - 1);
			char *pBodyStart = pMapBuffer;
			while (fSuccess && memcmp(pBodyStart, "\r\n\r\n", 4) != 0) {
				pBodyStart++;
				if (pBodyStart >= pEndBuffer - 4) fSuccess = FALSE;
			}
	
			_ASSERT(pBodyStart > pMapBuffer);
			_ASSERT(pDot < pEndBuffer);
			_ASSERT(pBodyStart < pEndBuffer);
	
			// this can happen if there is junk after the \r\n.\r\n that includes
			// a \r\n\r\n
			if (pBodyStart >= pDot) fSuccess = FALSE;
	
			if (fSuccess) {
				// pBodyStart points to the \r\n\r\n now, point it at the real
				// body
				pBodyStart += 4;
				DWORD cbHead = (DWORD)(pBodyStart - pMapBuffer);
				DWORD cbArticle = (DWORD)((pDot + 5) - pMapBuffer);
				DWORD cbTotal;
				CBUFPTR pbufHeaders = new (cbHead, cbTotal) CBuffer(cbTotal);
				void *pvContext;
				PFIO_CONTEXT pFIOContext;
				DWORD iHeadersOutOffset, cbHeadersOut;

				if (pbufHeaders != NULL && pbufHeaders->m_cbTotal >= cbHead) {
					memcpy(pbufHeaders->m_rgBuff, pMapBuffer, cbHead);

					//
					// pass it into the feed's post method
					//
					fSuccess = PostEarly(pInstance,
										 pSecurityCtx,
										 pEncryptCtx,
										 fAnonymous,
										 "post",
										 pbufHeaders,
										 0,
										 cbHead,
										 &iHeadersOutOffset,
										 &cbHeadersOut,
										 &pFIOContext,
										 &pvContext,
										 dwSecondary,
										 ntohl(INADDR_LOOPBACK),	// Pickup directory, IPaddr=127.0.0.1 for localhost
										 nr,
										 NULL,
										 0);
					if (fSuccess) {
						OVERLAPPED ol;
						HANDLE hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
						DWORD dwDidWrite;
						DWORD i;
	
						for (i = 0; (i < 2) && fSuccess; i++) {
							BYTE *pSource;
							DWORD cSource;
							DWORD iOffset;
	
							switch (i) {
								case 0:
									pSource = (BYTE *) pbufHeaders->m_rgBuff + iHeadersOutOffset;
									cSource = cbHeadersOut - iHeadersOutOffset;
									iOffset = 0;
									break;
								case 1:
									pSource = (BYTE *) pBodyStart;
									cSource = cbArticle - cbHead;
									iOffset = cbHeadersOut - iHeadersOutOffset;
									break;
								default:
									_ASSERT(FALSE);
							}
	
							ol.Internal = 0;
							ol.InternalHigh = 0;
							ol.Offset = iOffset;
							ol.OffsetHigh = 0;
							ol.hEvent = (HANDLE) (((DWORD_PTR) hEvent) | 0x00000001);
	
							// copy the headers into the FIO context
							fSuccess = WriteFile(pFIOContext->m_hFile,
												 pSource,
												 cSource,
												 &dwDidWrite,
												 &ol);
							if (!fSuccess) {
								if (GetLastError() == ERROR_IO_PENDING) {
									fSuccess = TRUE;
									WaitForSingleObject(hEvent, INFINITE);
		
									_VERIFY(GetOverlappedResult(pFIOContext->m_hFile,
															    &ol,
															    &dwDidWrite,
															    FALSE));
								} else {
									nr.fSet(nrcServerFault);
								}
							}
							_ASSERT(!fSuccess || (dwDidWrite == cSource));
						}	
	
						if (fSuccess) {
							// commit it
							fSuccess = PostCommit(pInstance,
							                      pvContext,
												  NULL,
												  dwSecondary,
												  nr,
												  fAnonymous);
							if (fSuccess)
							{
								nr.fSetOK();
							}
						}
					}
				} else {
					nr.fSet(nrcServerFault);
				}
			} else {
				// we couldn't find the \r\n\r\n between the headers and body
				nr.fSet(nrcArticleIncompleteHeader);
			}
		} else {
			// the buffer didn't contain the trailing .
			nr.fSet(nrcArticleIncompleteHeader);
		}
	} else {
		// the buffer was too short to contain the trailing .
		nr.fSet(nrcArticleIncompleteHeader);
	}

	UnmapViewOfFile(pMapBuffer);
	map.Relinquish();

	if (!nr.fIsOK()) {
		return nr.fSet(nrcArticleRejected(TRUE), nr.m_nrc, nr.szReturn());
	} else {
		return nr.fIsOK();
	}
}

static int __cdecl comparegroups(const void *pvGroup1, const void *pvGroup2) {
	CPostGroupPtr *pGroupPtr1 = (CPostGroupPtr *) pvGroup1;
	CPostGroupPtr *pGroupPtr2 = (CPostGroupPtr *) pvGroup2;

	// GUBGUB - read vroot priorities
	if (pGroupPtr1->m_pVRoot < pGroupPtr2->m_pVRoot) {
		return -1;
	} else if (pGroupPtr1->m_pVRoot == pGroupPtr2->m_pVRoot) {
		return 0;
	} else {
		return 1;
	}
}

BOOL
CInFeed::fPostInternal (
						CNntpServerInstanceWrapper *  pInstance,
						const LPMULTISZ	szCommandLine, //the Post, Xreplic, IHave, etc. command line
						CSecurityCtx    *pSecurityCtx,
						CEncryptCtx     *pEncryptCtx,
						BOOL            fAnonymous,
						CARTPTR	        &pArticle,
						CNEWSGROUPLIST  &grouplist,
						CNAMEREFLIST    &namereflist,
						IMailMsgProperties *pMsg,
						CAllocator      &allocator,
						char *          &multiszPath,
						char*		    pchMessageId,
						DWORD		    cbMessageId,
						char*		    pchGroups,
						DWORD		    cbGroups,
						DWORD		    remoteIpAddress,
						CNntpReturn     &nntpReturn,
						PFIO_CONTEXT    *ppFIOContext,
						BOOL            *pfBoundToStore,
						DWORD           *pdwOperations,
						BOOL            *fPostToMod,
						LPSTR           szModerator
						)
/*++

Routine Description:


	 Does most of the processing for an incoming article.


Arguments:

	szCommandLine -  the Post, Xreplic, IHave, etc. command line
	pArticle - a pointer to the article being processed
	pGrouplist - pointer to a list of newsgroup objects to post to.
	pNamerefgroups - pointer to a list of the names, groupid and article ids of the article
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fPostInternal" );

 	HANDLE hToken = NULL;

	nntpReturn.fSetClear(); // clear the return object

	//
	//	Get the newstree, hash tables etc for this virtual server instance
	//
	CNewsTreeCore*  pNewstree = pInstance->GetTree() ;
	CPCString pcHub(pInstance->NntpHubName(), pInstance->HubNameSize());
	CPCString pcDNS(pInstance->NntpDNSName(), pInstance->NntpDNSNameSize()) ;

	//
	//	After initializing the article object - get the message-id thats in the article
	//	for logging purposes - we may overwrite this later, but we want to try to get the
	//	message-id now so we have it in case of most errors !
	//

	strncpy( pchMessageId, pArticle->szMessageID(), cbMessageId ) ;


	//
	// Validate the article
	//

	if (!pArticle->fValidate(pcHub, szCommandLine, this, nntpReturn))
		return nntpReturn.fFalse();

	//
	// Find the list of newsgroups to post to
	//

	DWORD cNewsgroups = pArticle->cNewsgroups();
	if (!grouplist.fInit(cNewsgroups, pArticle->pAllocator()))
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if (!namereflist.fInit(cNewsgroups, pArticle->pAllocator()))
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Remember the path it is posted to
	//

	DWORD dwLength = multiszLength(pArticle->multiszPath());
	multiszPath = (pArticle->pAllocator())->Alloc(dwLength);
	multiszCopy(multiszPath, pArticle->multiszPath(), dwLength);

	//
	//!!!FROMMASTER this should be replaced to different
	//calls for different feeds. By default grouplist will be
	//created from multiszNewsgroups, but in the case of a frommaster
	//feed it will be created from the xref information (or command sz)
	// Likewise 	CNAMEREFLIST namereflist(cNewsgroups);
	//

	if (!fCreateGroupLists(pNewstree, pArticle, grouplist, &namereflist, szCommandLine, pcHub, nntpReturn))
		return nntpReturn.fFalse();

	//
	// pass through the server events interface.  this can change the grouplist
	// if it likes.
	//
	//DWORD dwOperations = 0xffffffff;
	HRESULT hr;

	hr = pMsg->PutDWORD(IMSG_NNTP_PROCESSING, *pdwOperations);
	if (SUCCEEDED(hr)) {
		hr = TriggerServerEvent(pInstance->GetEventRouter(),
								CATID_NNTP_ON_POST_EARLY,
								pArticle,
								&grouplist,
								m_dwFeedId,
								pMsg);
		if (SUCCEEDED(hr)) {
			hr = pMsg->GetDWORD(IMSG_NNTP_PROCESSING, pdwOperations);
		}
	}


	// if the server event doesn't want us to post then don't
	if ((*pdwOperations & NNTP_PROCESS_POST) != NNTP_PROCESS_POST)
		return nntpReturn.fSet(nrcServerEventCancelledPost);

	//
	// Check if article is going to be posted to any newsgroups.
	//

	if (grouplist.IsEmpty())
	{
        // If this is a newgroup control message and we are processing control
		// messages it is ok to have an empty grouplist at this stage
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();

        if(!((cmNewgroup == cmControlMessage) &&
		     (*pdwOperations & NNTP_PROCESS_CONTROL)))
        {
		    BOOL fOK = nntpReturn.fSet(nrcNoGroups());

			//ErrorTrace((long) this, "Article (%s) to be posted to no newsgroups", szFilename);

		    //
		    // If it is OK to post to no newsgroups, then just delete the file
		    //
		    if (fOK)
		    {
			    pArticle->vClose();

				if( !pArticle->fIsArticleCached() )
				{
					// delete only if we create a temp file for this article
					if( !DeleteFile( pArticle->szFilename() ) )
					{
						DWORD	dw = GetLastError() ;
						ErrorTrace( 0, "Delete File of %s failed cause of %d",
							        pArticle->szFilename(), dw ) ;
						_ASSERT( FALSE ) ;
					}
				}
		    }

		    return fOK;
        }
	};

	if (*pdwOperations & NNTP_PROCESS_MODERATOR) {
	    //
	    //  moderated newsgroup check (check Approved: header for moderator)
		//	NOTE: FROMMASTER does nothing here ! The slave relies on the master for this check !!
	    //
		if (!fModeratedCheck(   pInstance,
		                        pArticle,
		                        grouplist,
		                        gHonorApprovedHeaders,
		                        nntpReturn,
		                        szModerator))
	    {
	        //
	        // Return FALSE means this article is not accepted, but probably should
	        // be mailed to moderator.  We'll check nntpReturn, if it's still OK,
	        // we'll go ahead and ask the posting path to get the whole article, then
	        // we'll send the article to moderator in CommitPost phase.  If nntpReturn
	        // says it's not OK, then we'll fail the post
	        //
	        if (!nntpReturn.fIsOK() ) return FALSE;
	        else {
	            *fPostToMod = TRUE;
	            (*pdwOperations) &= ~(NNTP_PROCESS_CONTROL);
	        }
	    }
	}

	//
	//	Now do security check
	//
	if( pSecurityCtx || pEncryptCtx ) {
		if( !fSecurityCheck( pSecurityCtx, pEncryptCtx, grouplist, nntpReturn ) )
			return	nntpReturn.fFalse() ;
	}

	if ( *pdwOperations & NNTP_PROCESS_CONTROL) {
	    //
	    //  check for control messages and apply if necessary
	    //  NOTE: If this is a control message, grouplist and namereflist will be
	    //  changed to the appropriate control.* group. This ensures that the article
	    //  appears ONLY in the control.* groups and not the groups in the Newsgroups header
	    //
		if (!fApplyControlMessageEarly(pArticle, pSecurityCtx, pEncryptCtx, fAnonymous, grouplist, &namereflist, nntpReturn))
	    {
	        // Return TRUE if control message was applied successfully, FALSE otherwise
			return nntpReturn.fIsOK();
	    }
	}

    //
    // Sort the groups based on vroots
    //
    grouplist.Sort( comparegroups );

    //
    // Should also sort the nameref list into same order as grouplst.  This
    // is no-op for from-client.
    //
    SortNameRefList( namereflist );

    //
    //  at this point we have the final grouplist (possibly adjusted by fApplyControlMessage)
    //  so, now create the namereflist. This ensures that the article id high watermark is not
    //  bumped unnecessarily.
    //  NOTE: FROMMASTER should do nothing here
    //
	if (!fCreateNamerefLists(pArticle, grouplist, &namereflist, nntpReturn))
		return nntpReturn.fFalse();

	//
	// Set the artref of the article
	//

	NAME_AND_ARTREF * pNameRef = namereflist.GetHead();
	_ASSERT(pNameRef); // real
	pArticle->vSetArticleRef(pNameRef->artref);

  	//
  	// Looks OK so munge the headers
    // add xref and path
    //
    DWORD   dwLinesOffset = INVALID_FILE_SIZE;
    DWORD   dwHeaderLength = INVALID_FILE_SIZE;
	if (!pArticle->fMungeHeaders(   pcHub, 
	                                pcDNS, 
	                                namereflist, 
	                                remoteIpAddress, 
	                                nntpReturn,
	                                &dwLinesOffset ))
		return nntpReturn.fFalse();

    //
    // Set the new header length
    //
    dwHeaderLength = pArticle->GetHeaderLength();

	strncpy( pchMessageId, pArticle->szMessageID(), cbMessageId ) ;
	if( pchGroups != 0 )
		SaveGroupList(	pchGroups,	cbGroups, grouplist ) ;

	//
	//If necessary, record the message id
	//

	if (!fRecordMessageIDIfNecc(pInstance, pArticle->szMessageID(), nntpReturn))
		return nntpReturn.fFalse();


	//
	// Create the xover info
	//

	char szXOver[cchXOverMax];
	CPCString pcXOver(szXOver, cchXOverMax);
	if (!pArticle->fXOver(pcXOver, nntpReturn))
		return nntpReturn.fFalse();

	//
	// get the article object to copy all of its headers into a place that
	// is safe for reading after the vClose operation below
	//
	if (!pArticle->fMakeGetHeaderSafeAfterClose(nntpReturn))
		return nntpReturn.fFalse();

	//
	// Move the article to a local place, and then queues it up on any outfeeds
	//
	pArticle->vFlush() ;
	pArticle->vClose();
	
	class	CSecurityCtx*	pSecurity = 0 ;
	BOOL	fIsSecure = FALSE ;

	//
	// at this point we are ready to go.  talk to the first driver and
	// get a file handle that we can write to.
	//
	CPostGroupPtr *pPostGroupPtr = grouplist.GetHead();
	IMailMsgStoreDriver *pStoreDriver = pPostGroupPtr->GetStoreDriver();
	if (pStoreDriver == NULL) return nntpReturn.fSet(nrcNewsgroupInsertFailed, NULL, NULL);

	if ( pPostGroupPtr->m_pVRoot->GetImpersonationHandle() )
	    hToken = pPostGroupPtr->m_pVRoot->GetImpersonationHandle();
	else {
		if (pEncryptCtx == NULL && pSecurityCtx == NULL) {
			hToken = NULL;
		} else if (pEncryptCtx->QueryCertificateToken()) {
	        hToken = pEncryptCtx->QueryCertificateToken();
	    } else {
			hToken = pSecurityCtx->QueryImpersonationToken();
		}
	}

 	hr = FillInMailMsg(pMsg, pPostGroupPtr->m_pVRoot, &grouplist, &namereflist, hToken, szModerator );
	if (SUCCEEDED(hr)) {
		pMsg->AddRef();
		HANDLE hFile;
		IMailMsgPropertyStream *pStream = NULL;
		hr = pStoreDriver->AllocMessage(pMsg, 0, &pStream, ppFIOContext, NULL);
		if (SUCCEEDED(hr) && pStream == NULL) {
			pStream = XNEW CDummyMailMsgPropertyStream();
			if (pStream == NULL) hr = E_OUTOFMEMORY;
		}
		if (SUCCEEDED(hr)) {

		    //
		    // Set Lines header back fill offset to fiocontext
		    //
		    (*ppFIOContext)->m_dwLinesOffset = dwLinesOffset;
		    (*ppFIOContext)->m_dwHeaderLength = dwHeaderLength;
		    
			// bind the handle to the mailmsg object
			IMailMsgBind *pBind = NULL;
			hr = pMsg->QueryInterface(__uuidof(IMailMsgBind), (void **) &pBind);
			if (SUCCEEDED(hr)) {
				hr = pBind->BindToStore(pStream,
				 					    pStoreDriver,
									    (*ppFIOContext));
				if (SUCCEEDED(hr)) *pfBoundToStore = TRUE;
			}
			if (pBind) pBind->Release();
			pBind = NULL;
		}
		if( pStream != NULL )
			pStream->Release() ;
	}
	if (pStoreDriver) pStoreDriver->Release();
	pStoreDriver = NULL;

	if (FAILED(hr)) return nntpReturn.fSet(nrcNewsgroupInsertFailed, NULL, NULL);

	TraceFunctLeave();
	return nntpReturn.fSetOK();

}

//
// fill in the required fields in the IMailMsg object
//
// arguments:
// pMsg - the mail msg which we are filling in
// pVRoot - the vroot which will be receiving this mailmsg.
// pGrouplist - the posting path's grouplist
// pNamereflist - the posting path's nameref list
//
HRESULT CInFeed::FillInMailMsg(IMailMsgProperties *pMsg,
							   CNNTPVRoot *pVRoot,
							   CNEWSGROUPLIST *pGrouplist,
							   CNAMEREFLIST *pNamereflist,
							   HANDLE       hToken,
                               char*        pszApprovedHeader )
{
	TraceFunctEnter("CInFeed::FillInMailMsg");
	
	DWORD i=0;
	DWORD rgArticleIds[MAX_NNTPHASH_CROSSPOSTS];
	INNTPPropertyBag *rgpGroupBags[MAX_NNTPHASH_CROSSPOSTS];
	POSITION posGrouplist = pGrouplist->GetHeadPosition();
	POSITION posNamereflist = pNamereflist->GetHeadPosition();
	HRESULT hr;

	if (pNamereflist == NULL) {
	    return E_UNEXPECTED;
	}

	// these sizes need to be the same!
	_ASSERT(pGrouplist->GetCount() == pNamereflist->GetCount());

	while (posGrouplist != NULL) {
		// look at this group.  if it is one of the ones for this driver
		// then add it to the list, otherwise keep looking
		CPostGroupPtr *pPostGroupPtr = pGrouplist->GetNext(posGrouplist);
		if (pPostGroupPtr->m_pVRoot != pVRoot) {
			// if we haven't found any groups for this vroot then we
			// need to keep looking.  otherwise we are done.
			if (i == 0) continue;
			else break;
		}

		// build up the entries needed in the property bag
		NAME_AND_ARTREF *pNameref = pNamereflist->GetNext(posNamereflist);
		rgpGroupBags[i] = pPostGroupPtr->m_pGroup->GetPropertyBag();
		// we don't need to keep this reference because we have a reference
		// counted one already in the CPostGroupPtr.
		rgpGroupBags[i]->Release();
		rgArticleIds[i] = pNameref->artref.m_articleId;

		DebugTrace((DWORD_PTR) this,
				   "group %s, article %i",
				   pPostGroupPtr->m_pGroup->GetGroupName(),
				   pNameref->artref.m_articleId);
		i++;
		_ASSERT(i <= MAX_NNTPHASH_CROSSPOSTS);
		if (i > MAX_NNTPHASH_CROSSPOSTS) break;
	}

	hr = FillMailMsg(pMsg, rgArticleIds, rgpGroupBags, i, hToken, pszApprovedHeader );
	if (FAILED(hr)) return hr;

	TraceFunctLeave();
	return S_OK;
}

//
// fill in the required fields in the IMailMsg object
//
// arguments:
// pMsg - the mail msg which we are filling in
// pArticle - the article object for this message
// pGrouplist - the posting path's grouplist
//
HRESULT FillInMailMsgForSEO(IMailMsgProperties *pMsg,
							CArticle *pArticle,
							CNEWSGROUPLIST *pGrouplist)
{
	TraceFunctEnter("CInFeed::FillInMailMsgForSEO");

	HRESULT hr;

	// save all of the properties into the property bag
	hr = pMsg->PutProperty(IMSG_HEADERS,
						   pArticle->GetShortHeaderLength(),
						   (BYTE*) pArticle->GetHeaderPointer());
	
	if (SUCCEEDED(hr)) {
		char szNewsgroups[4096] = "";

		DWORD c = 0, iGroupList, cGroupList = pGrouplist->GetCount();
		POSITION posGroupList = pGrouplist->GetHeadPosition();
		for (iGroupList = 0;
			 iGroupList < cGroupList;
			 iGroupList++, pGrouplist->GetNext(posGroupList))
		{
			CPostGroupPtr *pPostGroupPtr = pGrouplist->Get(posGroupList);
			CGRPCOREPTR pNewsgroup = pPostGroupPtr->m_pGroup;
			_ASSERT(pNewsgroup != NULL);
			DWORD l = strlen(pNewsgroup->GetName());
			if (l + c < sizeof(szNewsgroups)) {
				if (iGroupList > 0) lstrcatA(szNewsgroups, ",");
				lstrcatA(szNewsgroups, pNewsgroup->GetName());
				c += l;
			} else {
				// BUGBUG - shouldn't use a fixed size buffer
				_ASSERT(FALSE);
			}
		}

		hr = pMsg->PutStringA(IMSG_NEWSGROUP_LIST, szNewsgroups);
	}
				
	TraceFunctLeave();
	return hr;
}

//
// fill in the properties that a driver looks for in an IMailMsgPropertyBag
//
HRESULT CInFeed::FillMailMsg(IMailMsgProperties *pMsg,
							 DWORD *rgArticleIds,
							 INNTPPropertyBag **rgpGroupBags,
							 DWORD cCrossposts,
							 HANDLE hToken,
                             char*  pszApprovedHeader )
{
	_ASSERT(cCrossposts != 0);
	_ASSERT(cCrossposts <= 256);

	HRESULT hr;

	// save all of the properties into the property bag
	hr = pMsg->PutProperty(IMSG_PRIMARY_GROUP,
						   sizeof(INNTPPropertyBag *),
						   (BYTE*) rgpGroupBags);
	
	if (SUCCEEDED(hr)) {
		hr = pMsg->PutProperty(IMSG_SECONDARY_GROUPS,
						  	   sizeof(INNTPPropertyBag *) * cCrossposts,
						  	   (BYTE*) rgpGroupBags);
	}
				
	if (SUCCEEDED(hr)) {
		hr = pMsg->PutProperty(IMSG_PRIMARY_ARTID,
						  	   sizeof(DWORD),
						  	   (BYTE*) rgArticleIds);
	}
				
	if (SUCCEEDED(hr)) {
		hr = pMsg->PutProperty(IMSG_SECONDARY_ARTNUM,
						  	   sizeof(DWORD) * cCrossposts,
						  	   (BYTE*) rgArticleIds);
	}

	if ( SUCCEEDED(hr) ) {
	    hr = pMsg->PutProperty( IMSG_POST_TOKEN, 
                                sizeof( hToken ),
                                (PBYTE)&hToken );
	}

	if (SUCCEEDED(hr)) {
		hr = pMsg->PutStringA(IMMPID_NMP_NNTP_APPROVED_HEADER,
						  	  pszApprovedHeader);
	}

	return hr;
}

//
// Copy the article into each of the stores
//
void CInFeed::CommitPostToStores(CPostContext *pContext, CNntpServerInstanceWrapper *pInstance ) {
	TraceFunctEnter("CInFeed::CommitPostToStores");
	
	DWORD cCrossposts = 0;
	DWORD rgArticleIds[MAX_NNTPHASH_CROSSPOSTS];
	INNTPPropertyBag *rgpGroupBags[MAX_NNTPHASH_CROSSPOSTS];
	CNEWSGROUPLIST *pGrouplist = &(pContext->m_grouplist);
	CNAMEREFLIST *pNamereflist = &(pContext->m_namereflist);
	CStoreId *rgStoreIds = pContext->m_rgStoreIds;
	BYTE *rgcCrossposts = pContext->m_rgcCrossposts;
	HRESULT hr;
	CNNTPVRoot *pThisVRoot = pContext->m_pPostGroupPtr->m_pVRoot;

	// these sizes need to be the same!
	_ASSERT(pGrouplist->GetCount() == pNamereflist->GetCount());

	rgcCrossposts[pContext->m_cStoreIds] = 0;

	//
	// loop at each group that belongs to this vroot
	//
	while (pContext->m_pPostGroupPtr != NULL &&
		   pContext->m_pPostGroupPtr->m_pVRoot == pThisVRoot)
	{
		if (rgcCrossposts[pContext->m_cStoreIds] < MAX_NNTPHASH_CROSSPOSTS) {
			rgpGroupBags[cCrossposts] = pContext->m_pPostGroupPtr->m_pGroup->GetPropertyBag();
			rgArticleIds[cCrossposts] = pContext->m_pNameref->artref.m_articleId;

			// we don't need to keep this reference because we have a reference
			// counted one already in the CPostGroupPtr.
			rgpGroupBags[cCrossposts]->Release();

			rgcCrossposts[pContext->m_cStoreIds]++;
			cCrossposts++;
		} else {
			_ASSERT(cCrossposts < MAX_NNTPHASH_CROSSPOSTS);
		}

		pContext->m_pPostGroupPtr = pGrouplist->GetNext(pContext->m_posGrouplist);
		pContext->m_pNameref = pNamereflist->GetNext(pContext->m_posNamereflist);
	}

	// we should have found at least one group
	_ASSERT(rgcCrossposts[pContext->m_cStoreIds] != 0);

	// build the mail msg for this group
	hr = FillMailMsg(pContext->m_pMsg,
					 rgArticleIds,
					 rgpGroupBags,
					 rgcCrossposts[pContext->m_cStoreIds],
					 pContext->m_hToken,
                     pContext->m_szModerator);

	if (FAILED(hr)) {
		pContext->m_completion.SetResult(hr);
		pContext->m_completion.Release();
		TraceFunctLeave();
		return;
	} else {
		pContext->m_pMsg->AddRef();
		// add a reference for the driver's CommitPost
		pContext->m_completion.AddRef();
		// tell the driver to commit the message
		pThisVRoot->CommitPost(pContext->m_pMsg,
						       &(rgStoreIds[pContext->m_cStoreIds]),
						       NULL,
						       pContext->m_hToken,
						       &(pContext->m_completion),
							   pContext->m_fAnonymous);
		// say that we saw this store id.
		(pContext->m_cStoreIds)++;
		// release our reference
		pContext->m_completion.Release();
	}

	TraceFunctLeave();
}

BOOL
CInFeed::fCreateNamerefLists(
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
		    )
/*++

Routine Description:

  Create the namereflist from the grouplist

  !!!FROMMASTER this should be replaced to different


Arguments:

	grouplist - a list of newsgroup objects to post to.
	namereflist - a list of the names, groupid and article ids of the article
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fCreateNamerefLists" );

	nntpReturn.fSetClear();

	//
	// Check if article is going to be posted to any newsgroups.
	//

	if (grouplist.IsEmpty())
		return nntpReturn.fFalse();

	if( pNamereflist != 0 ) {
		//
		// Allocate article numbers and create the Name/Ref list.
		// !!! for sfromcl could replace real newsgruops with newsgroup 1 right here

		POSITION	pos = grouplist.GetHeadPosition() ;
		while( pos  )
		{
			CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
			CGRPCOREPTR *ppGroup = &(pPostGroupPtr->m_pGroup);
			NAME_AND_ARTREF Nameref;
			(Nameref.artref).m_groupId = (* ppGroup)->GetGroupId();
			(Nameref.artref).m_articleId = (* ppGroup)->AllocateArticleId();
			(Nameref.pcName).vInsert((* ppGroup)->GetNativeName());
			pNamereflist->AddTail(Nameref);
		}
	}

	return nntpReturn.fSetOK();
}

DWORD
CInFeed::CalculateXoverAvail(
						   CARTPTR & pArticle,
                           CPCString& pcHub
						   )
/*++

Routine Description:

	From the article object and other constants, figure out
    the amount of space available for xover data.

Arguments:

	pArticle - a pointer to the article being processed

Return Value:

	Number of bytes available for more xover data

--*/
{
 	TraceFunctEnter( "CInFeed::CalculateXoverAvail" );

    //
    //  Calculate available space for xover info.
    //  At this point, we can figure out all the xover fields except Xref.
    //

	const DWORD cchMaxDate =
			STRLEN(szKwDate)	    // for the Date keyword
			+ 1					    // space following the keyword
			+ cMaxArpaDate		    // bound on the data string
			+ 2                     // for the newline
			+ 1;                    // for a terminating null

	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					    // space following the keyword
			+ 4					    // <..@>
			+ cMaxMessageIDDate     // The message id date
			+ 10				    // One dword
			+ pcHub.m_cch		    // the hub name
			+ 2                     // for the newline
			+ 1;                    // for a terminating null

    DWORD cbFrom = 0, cbSubject = 0, cbRefs = 0;
    pArticle->fGetHeader((char*)szKwFrom,NULL, 0, cbFrom);
    pArticle->fGetHeader((char*)szKwSubject,NULL, 0, cbSubject);
    _ASSERT( cbFrom && cbSubject );
    pArticle->fGetHeader((char*)szKwReferences,NULL, 0, cbRefs);

    DWORD cbXover =
            11                      // article id + tab
            + cbSubject  + 1        // length of subject field + tab
            + cbFrom     + 1        // length of from field + tab
            + cchMaxDate + 1        // length of date field + tab
            + cchMaxMessageID + 1   // length of message-id field + tab
            + 10 + 1                // article size + tab
            + cbRefs + 1            // References field + tab
            + 10 + 1                // Lines field + tab
            + STRLEN(szKwXref)+2    // XRef + : + space
            + pcHub.m_cch + 1;      // Hub name + space

    return max(cchXOverMax - cbXover, 0);
}

BOOL
CInFeed::fCreateGroupLists(
						   CNewsTreeCore* pNewstree,
						   CARTPTR & pArticle,
						   CNEWSGROUPLIST & grouplist,
						   CNAMEREFLIST * pNamereflist,
						   LPMULTISZ	multiszCommandLine,
                           CPCString& pcHub,
						   CNntpReturn & nntpReturn
						   )
/*++

Routine Description:

	From the names of the newsgroups, gets the group objects,
	groupid's and articleid and returns them as lists.

  !!!FROMMASTER this should be replaced to different


Arguments:

	pNewstree - newstree for this virtual server instance
	pArticle - a pointer to the article being processed
	grouplist - a list of newsgroup objects to post to.
	namerefgroups - a list of the names, groupid and article ids of the article
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fCreateGroupLists" );

	nntpReturn.fSetClear();

    //
    //  Calculate available space for xover info. We will use this to
    //  truncate the grouplist, if the newsgroups header is too big.
    //
    DWORD cbXoverAvail = CalculateXoverAvail( pArticle, pcHub );

	const char * multiszNewsgroups = pArticle->multiszNewsgroups();
	DWORD cNewsgroups = pArticle->cNewsgroups();
	
	char const * sz = multiszNewsgroups;
	do
	{
		//!!! DISTR needs something like this
        DWORD cbLen = lstrlen(sz);
		CGRPCOREPTR	pGroup = pNewstree->GetGroupPreserveBuffer( sz, cbLen+1 );//!!!does GetGroup really need the length?
		if (pGroup && (cbXoverAvail > cbLen+10+2) )
		{
			CPostGroupPtr PostGroupPtr(pGroup);
			//
			// If it is already in the tree ...
			//
			/* Security algorithm

				  // Start with a list, L, of newsgroup names from the "Newsgroups:" line.

				  // Remove thoese we don't carry and duplicates.
				  L' = L union Carry

				  If now empty, toHistory with messageid, return

				  // Check if passes wildmat test
				  if not [exists l in L' such that W(l)]
						delete message id

				  //Check if passes security
				  if not [for all l in L', S(l)]
						delete message id

				  Post to L'


			*/
			grouplist.AddTail(PostGroupPtr);
            cbXoverAvail -= (cbLen+10+2);
            _ASSERT( cbXoverAvail > 0 );

        } else if(pGroup == NULL) {

			//
			// If the group does not exist ...
			//
        } else {
            //
            //  Newsgroups: header is too big, truncate the grouplist
            //
            break;
        }

		//
		// go to first char after next null
		//

		while ('\0' != sz[0])
			sz++;
		sz++;
	} while ('\0' != sz[0]);

	return nntpReturn.fSetOK();
}

BOOL
CInFeed::SetLoginName(
					  char * szLoginName
					  )
/*++

Routine Description:

	Sets the LoginName of the user (only used by clients)

Arguments:

	szLoginName - the login name of the client giving us articles


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	strncpy(m_szLoginName, szLoginName, cMaxLoginName);
	m_szLoginName[cMaxLoginName-1] = '\0';

	return TRUE;
}


BOOL CInFeed::fInit(
			PVOID feedCompletionContext,
			const char * szTempDirectory,
			const char * multiszNewnewsPattern,
			DWORD cInitialBytesGapSize,
			BOOL fCreateAutomatically,
			BOOL fDoSecurityChecks,
			BOOL fAllowControlMessages,
			DWORD dwFeedId
			)
/*++

Routine Description:

	Initalizes the InFeed

Arguments:

	sockaddr - the socket address articles are coming in on
	feedCompletionContext - what to call when done
	szTempDirectory - where to put articles pending processing
	multiszNewnewsPattern - what pattern of articles to accept
	cInitialBytesGapSize - what gap to leave in the file before the article
	fCreateAutomatically - make feed's groups our groups?


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
    _ASSERT(ifsUninitialized == m_feedState);
    m_feedState = ifsInitialized;

	m_feedCompletionContext = feedCompletionContext;
	m_szTempDirectory = (char *) szTempDirectory;
	m_multiszNewnewsPattern = (char *) multiszNewnewsPattern;
	m_cInitialBytesGapSize = cInitialBytesGapSize;
	m_fCreateAutomatically = fCreateAutomatically;
	m_fDoSecurityChecks = fDoSecurityChecks ;
	m_fAllowControlMessages = fAllowControlMessages ;
	m_dwFeedId = dwFeedId;

	return TRUE;
};

BOOL		
CInFeed::fMoveMessageIDIfNecc(
						CNntpServerInstanceWrapper *	pInstance,
						const char *			szMessageID,
						CNntpReturn &			nntpReturn,
						HANDLE                  hToken,
						BOOL					fAnonymous
						)
/*++

Routine Description:

	If the message id is in the article table, moves it to the
	history table.

Arguments:

	pInstance - virtual server instance
	szMessageID - the message id to move
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful or unneeded. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fMoveMessageIDIfNecc" );

	//
	// clear the return code object
	//

	nntpReturn.fSetOK();

    //
	// Confirm that the article is not in the table
	//

	WORD	HeaderOffset ;
	WORD	HeaderLength ;
	ARTICLEID ArticleNo;
    GROUPID GroupId;
	CStoreId storeid;

	//
	// Look for the article. It is OK if there is none.
	//

	if (!(pInstance->ArticleTable())->GetEntryArticleId(
											szMessageID,
											HeaderOffset,
											HeaderLength,
											ArticleNo,
											GroupId,
											storeid))
	{
		if (ERROR_FILE_NOT_FOUND == GetLastError())
		{
			return nntpReturn.fSetOK();
		} else {
			return nntpReturn.fSet(nrcArticleTableError, szMessageID, GetLastError());
		}
	}

    //
    // If <GroupId, ArticleNo> is valid, we should simulate a cancel on
    // this message-id to cleanup entries in our hash tables.
    // Else, just zap the message-id in the article map table.
    //

    if( ArticleNo != INVALID_ARTICLEID && GroupId != INVALID_ARTICLEID )
    {
        //
		// Call gExpireArticle to cancel this article
		//

		if (  pInstance->ExpireArticle( GroupId, ArticleNo, &storeid, nntpReturn, hToken, TRUE, fAnonymous ) /*
			   || pInstance->DeletePhysicalArticle( GroupId, ArticleNo, &storeid, hToken, fAnonymous)*/
		)
		{
			DebugTrace((LPARAM)this,"Article cancelled: GroupId %d ArticleId %d", GroupId, ArticleNo);
		}
		else
		{
			ErrorTrace((LPARAM)this, "Could not cancel article: GroupId %d ArticleId %d", GroupId, ArticleNo);
		}
    } else
    {
    	//
	    // Try to delete it from the article table, even if adding to history
    	// table failed.
	    //

        _ASSERT( ArticleNo == INVALID_ARTICLEID && GroupId == INVALID_ARTICLEID );
    	if (!(pInstance->ArticleTable())->DeleteMapEntry(szMessageID))
    		return nntpReturn.fSet(nrcArticleTableCantDel, szMessageID, GetLastError());
    }

	// Use "fIsOK" rather than "fSetOK" because HistoryInsert might have failed
	return nntpReturn.fIsOK();

	TraceFunctLeave();
}


BOOL
CInFeed::fModeratedCheck(
            CNntpServerInstanceWrapper *pInstance,
            CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
            BOOL fCheckApproved,
			CNntpReturn & nntpReturn,
			LPSTR   szModerator
			)
/*++

Routine Description:

    Check for moderated newsgroups. If none of the groups in grouplist are moderated,
    accept the article. Else, we'll reset the grouplist to be the special group, so
    that the posting path can stream the article into the group temporarily and
    CommitPost can mail it out to the moderator.

Arguments:

	pArticle - a pointer to the article being processed
	grouplist - a list of newsgroup objects to post to.
    fCheckApproved - If TRUE, validate contents of Approved header
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if article is to be accepted, FALSE if article is not accepted

--*/
{
 	TraceFunctEnter( "CInFeed::fModeratedCheck" );

	nntpReturn.fSetClear();

	if( !fModeratorChecks() ) {
		return	nntpReturn.fSetOK() ;
	}

    BOOL fAtLeastOneModerated = FALSE;
    DWORD cbModeratorLen = 0;

    POSITION	pos = grouplist.GetHeadPosition();
	while( pos  )
	{
		CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
		CGRPCOREPTR *ppGroup = &(pPostGroupPtr->m_pGroup);
		const char *pszModerator = (*ppGroup)->GetModerator(&cbModeratorLen);
        if(cbModeratorLen && *pszModerator)
        {
			_ASSERT(pszModerator != NULL);
			if (pszModerator) strncpy(szModerator, pszModerator, MAX_MODERATOR_NAME);
            // found first moderated newsgroup in list
            fAtLeastOneModerated = TRUE;
            _ASSERT(cbModeratorLen <= MAX_MODERATOR_NAME);
            szModerator [cbModeratorLen] = '\0';    // null-terminate the moderator string
            break;
        }
	}

    // Mail the article to the moderator of the first moderated newsgroup
    if(fAtLeastOneModerated)
    {
        //
        // Check for Approved header
        //
        char* lpApproved = NULL;
        DWORD cbLen = 0;
        pArticle->fGetHeader((char*)szKwApproved,(LPBYTE)lpApproved, 0, cbLen);

        if(cbLen)
        {
            // validate Approved header only if required
            if(fCheckApproved)
            {
                // Approved header is present - check moderator access
                lpApproved = (pArticle->pAllocator())->Alloc(cbLen+1);
                if(!pArticle->fGetHeader((char*)szKwApproved,(LPBYTE)lpApproved, cbLen+1, cbLen))
                {
                    ErrorTrace((LPARAM)this,"CArticle::fGetheader failed LastError is %d", GetLastError());
                    (pArticle->pAllocator())->Free(lpApproved);
                    return nntpReturn.fSet(nrcServerFault);
                }

                // adjust for \r\n at the end of lpApproved
                cbLen -= 2;
                lpApproved [cbLen] = '\0';

                // If len does not match - reject
                if(cbLen + 1 != cbModeratorLen) // cbModerator includes terminating null
                {
                    (pArticle->pAllocator())->Free(lpApproved);
                    nntpReturn.fSet(nrcNoAccess);
                    return FALSE;
                }

                // Approved email does not match - reject
                if(_strnicmp(lpApproved, szModerator, cbModeratorLen))
                {
                    (pArticle->pAllocator())->Free(lpApproved);
                    nntpReturn.fSet(nrcNoAccess);
                    return FALSE;
                }

                (pArticle->pAllocator())->Free(lpApproved);
                DebugTrace((LPARAM)this,"Approved header matched: moderator is %s",szModerator);
            }
        }
        else
        {
            //
            // We should modify the grouplist so that the article is streamed
            // into the special group before sent out
            //

            //
            // Lets remove all the group's in group.lst
            //
            pos = grouplist.GetHeadPosition();
	        while( pos  ) {
		        CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
		        pPostGroupPtr->Cleanup();
            }
            grouplist.RemoveAll();

            //
            // OK, now push the special group into grouplist
            //
            CNewsTreeCore *pTree = pInstance->GetTree();
            _ASSERT( pTree );

            CGRPCOREPTR pGroup = pTree->GetGroupById(pTree->GetSlaveGroupid());
            _ASSERT( pGroup );
            if ( !pGroup ) {
                ErrorTrace( 0, "Can not find the special group" );
                nntpReturn.fSet( nrcPostModeratedFailed, szModerator );
                return FALSE;
            }

            CPostGroupPtr PostGroupPtr(pGroup);
            grouplist.AddTail( PostGroupPtr );

#if GUBGUB
			// num moderated postings we attempt to deliver to an Smtp server
			pArticle->m_pInstance->BumpCounterModeratedPostingsSent();

            // Approved header absent - mail article to moderator
            if(!pArticle->fMailArticle( szModerator ))
            {
                // handle error - mail server could be down
                ErrorTrace( (LPARAM)this,"Error mailing article to moderator");
                nntpReturn.fSet(nrcPostModeratedFailed, szModerator);

				// log a warning for moderated posting failures; If number of warnings exceeds a limit
				// log a final error and then stop logging.
				DWORD NumWarnings;
				if( (NumWarnings = InterlockedExchangeAddStat( (pArticle->m_pInstance), ModeratedPostingsFailed, 1 )) <= MAX_EVENTLOG_WARNINGS )
				{
					if(NumWarnings < MAX_EVENTLOG_WARNINGS)
					{
						PCHAR args [2];
						CHAR  szId[20];
						_itoa( (pArticle->m_pInstance)->QueryInstanceId(), szId, 10 );
						args [0] = szId;
						args [1] = szModerator;

						NntpLogEvent(		
								NNTP_EVENT_WARNING_SMTP_FAILURE,
								2,
								(const CHAR **)args,
								0 ) ;
					}
					else
					{
						PCHAR args   [3];
						char  szTemp [10];
						CHAR  szId[20];
						_itoa( (pArticle->m_pInstance)->QueryInstanceId(), szId, 10 );
						args [0] = szId;

						args [1] = szModerator;
						wsprintf( szTemp, "%d", MAX_EVENTLOG_WARNINGS+1 );
						args [2] = szTemp;

						NntpLogEvent(		
								NNTP_EVENT_ERROR_SMTP_FAILURE,
								3,
								(const CHAR **)args,
								0 ) ;
					}
				}
                return FALSE;
            }
#endif

            // return 240 OK but dont accept the article
			nntpReturn.fSetOK();
            return FALSE;
        }
    }

    TraceFunctLeave();
    return nntpReturn.fSetOK();
}

BOOL
CInFeed::fSecurityCheck(
		CSecurityCtx    *pSecurityCtx,
		CEncryptCtx     *pEncryptCtx,
		CNEWSGROUPLIST&	grouplist,
		CNntpReturn&	nntpReturn
		)	{
/*++

Routine Description :

	Check that the caller has access to each of the newsgroups
	in the list.

Arguments :

	pcontext - Users context, has all we need to do impersonates etc...
	grouplist - list of newsgroups the user is posting to
	nntpReturn - result

Return Value :

	TRUE if the post can succeed, FALSE otherwise

--*/

	BOOL	fRtn = TRUE;

	BOOL	fNeedsClosed = FALSE;
	HANDLE  hToken = NULL;

    POSITION	pos = grouplist.GetHeadPosition();
    POSITION	pos_current;
	while( pos && fRtn )
	{
		// remember the current position since GetNext will increase it
		pos_current = pos;
		CPostGroupPtr *pPostGroupPtr = grouplist.GetNext(pos);
		CGRPCOREPTR *ppGroup = &(pPostGroupPtr->m_pGroup);

		SelectToken(pSecurityCtx, pEncryptCtx, &hToken, &fNeedsClosed);

		// if the news group is not accessible remove it from the internal group list
		if (!(* ppGroup)->IsGroupAccessible(
						hToken,
						NNTP_ACCESS_POST
						) )
		{
			grouplist.Remove(pos_current);
		}

		if (fNeedsClosed)
			CloseHandle(hToken);
}
	if (grouplist.IsEmpty())
		fRtn = FALSE;

	if( !fRtn )
		return	nntpReturn.fSet( nrcNoAccess ) ;
	else
		return	nntpReturn.fSetOK() ;
}

BOOL
CInFeed::fApplyControlMessageEarly(
        CARTPTR & pArticle,
		CSecurityCtx *pSecurityCtx,
		CEncryptCtx *pEncryptCtx,
		BOOL fAnonymous,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		)
/*++

Routine Description:

    Given an article with the Control: header, applies the control message.
    Derived classes that dont need to apply control messages, should override
    this to do nothing.

    This function is called during PostEarly.  It only does early Control Message
    apply sanity check, but won't commit the action until CommitPost later in the
    posting path.
    fApplyControlMessageCommit() & fApplyControlMessageEarly() are splined-off from
    fApplyControlMessage().

Arguments:

	pArticle - a pointer to the article being processed
    grouplist - reference to the list of newsgroups
    pNamereflist - pointer to the corresponding nameref list
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if this is not a control message or control message is applied successfully
    FALSE, if this is a control message and could not be applied

--*/
{
	TraceFunctEnter("CInFeed::fApplyControlMessageEarly");

    BOOL fRet = TRUE;
	char* lpApproved = NULL;
    char* lpControl = NULL;
	DWORD cbLen = 0;

	nntpReturn.fSetOK();

    //
    // Check for Control: header
    //
    pArticle->fGetHeader((char*)szKwControl, (LPBYTE)lpControl, 0, cbLen);

    // If cbLen is non-zero, this is a control message
    if(cbLen)
    {
		// get a hold of the appropriate newstree object !
		CNewsTreeCore* pNewstree = pArticle->m_pInstance->GetTree();

        // set grouplist and pNamereflist to the control.* group
        // This overrides the Newsgroups header, since control messages
        // should not actually appear in those groups. They appear only
        // in the control.* groups
        // FROMMASTER: do nothing - accept whatever the master sends
        if(!fAdjustGrouplist( pNewstree, pArticle, grouplist, pNamereflist, nntpReturn))
        {
            ErrorTrace((LPARAM)this,"Adjust grouplist failed");
            fRet = nntpReturn.fFalse();
			goto fApplyControlMessageEarly_Exit;
        }

        //
        //  moderated newsgroup check (Ignore contents of Approved: header)
		//	NOTE: FROMMASTER does nothing here - relies on master to have done this check !!
        //
        /* I don't see any need to check for this here
	    if (!fModeratedCheck(pArticle, grouplist, FALSE, nntpReturn))
        {
            // Newsgroup is moderated - dont fall through
            fRet = FALSE;
			goto fApplyControlMessageEarly_Exit;
        }*/

	    //
	    //	Now do security check
	    //
	    if( pSecurityCtx || pEncryptCtx )
        {
		    if( !fSecurityCheck( pSecurityCtx, pEncryptCtx, grouplist, nntpReturn ) )
            {
			    fRet = nntpReturn.fFalse();
				goto fApplyControlMessageEarly_Exit;
            }
	    }

		// Approved check: this checks existence of Approved header for non-moderated newsgroups
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();
		if( (cmControlMessage == cmNewgroup) || (cmControlMessage == cmRmgroup) )
		{
			// newgroup, rmgroup control message MUST have an Approved header
			pArticle->fGetHeader((char*)szKwApproved,(LPBYTE)lpApproved, 0, cbLen);
			if( cbLen == 0 )
			{
				nntpReturn.fSet(nrcNoAccess);
                fRet = FALSE;
				goto fApplyControlMessageEarly_Exit;
			}
		}

    }   // end if(cbLen)

fApplyControlMessageEarly_Exit:

	// cleanup !
	if( lpControl ) {
		// free the control header value if required
		(pArticle->pAllocator())->Free(lpControl);
		lpControl = NULL;
	}

    TraceFunctLeave();
    return fRet;
}

BOOL
CInFeed::fApplyControlMessageCommit(
        CARTPTR & pArticle,
		CSecurityCtx *pSecurityCtx,
		CEncryptCtx *pEncryptCtx,
		BOOL fAnonymous,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		)
/*++

Routine Description:

    Given an article with the Control: header, applies the control message.
    Derived classes that dont need to apply control messages, should override
    this to do nothing.

    Commit the actual Control Message action

Arguments:

	pArticle - a pointer to the article being processed
    grouplist - reference to the list of newsgroups
    pNamereflist - pointer to the corresponding nameref list
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if this is not a control message or control message is applied successfully
    FALSE, if this is a control message and could not be applied

--*/
{
	TraceFunctEnter("CInFeed::fApplyControlMessageCommit");

    BOOL fRet = TRUE;
	char* lpApproved = NULL;
    char* lpControl = NULL;
	CMapFile* pMapFile = NULL;
	DWORD cbLen = 0;

	nntpReturn.fSetOK();

    //
    // Check for Control: header
    //
    pArticle->fGetHeader((char*)szKwControl, (LPBYTE)lpControl, 0, cbLen);

    // If cbLen is non-zero, this is a control message
    if(cbLen)
    {
		// get a hold of the appropriate newstree object !
		CNewsTreeCore* pNewstree = pArticle->m_pInstance->GetTree();

		// bump perfmon counter
		pArticle->m_pInstance->BumpCounterControlMessagesIn();

        // First check to see if control messages are allowed for this feed
	    if(!fAllowControlMessages(pArticle->m_pInstance))
        {
            // if control messages are disabled, dont apply them and return 240 OK
            // NOTE: in either case, the message will appear on the control.* group and get sent on feeds
            DebugTrace((LPARAM)this,"control message disabled: not applied");
		    pArticle->m_pInstance->BumpCounterControlMessagesFailed();
            fRet = nntpReturn.fSetOK();
		    goto fApplyControlMessageCommit_Exit;
        }

        // get the control header value
        lpControl = (pArticle->pAllocator())->Alloc(cbLen+1);
        if(!pArticle->fGetHeader((char*)szKwControl,(LPBYTE)lpControl, cbLen+1, cbLen))
        {
            ErrorTrace((LPARAM)this,"CArticle::fGetheader failed LastError is %d", GetLastError());
            fRet = nntpReturn.fSet(nrcServerFault);
			goto fApplyControlMessageCommit_Exit;
        }

        CPCString pcValue(lpControl, cbLen);

        // trim leading and trailing whitespace and \r\n
	    pcValue.dwTrimStart(szWSNLChars);
	    pcValue.dwTrimEnd(szWSNLChars);

        // get the control message type
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();
        DWORD cbMsgLen = (DWORD)lstrlen(rgchControlMessageTbl[cmControlMessage]);

        // skip to the arguments of the control message
        pcValue.vSkipStart(cbMsgLen);
        pcValue.dwTrimStart(szWSNLChars);
        pcValue.vMakeSz();

        // at least one argument
        if(!pcValue.m_cch)
        {
            fRet = nntpReturn.fSet(nrcArticleFieldMissingValue, rgchControlMessageTbl[cmControlMessage]);
			goto fApplyControlMessageCommit_Exit;
        }

		//
        // get article body - if non-null pMapFile is returned, we need to delete it !
		//
        char* lpBody = NULL;
        DWORD cbBodySize = 0;

#ifdef GUBGUB
        if( !pArticle->fGetBody(pMapFile, lpBody, cbBodySize) )
		{
            ErrorTrace((LPARAM)this,"CArticle::fGetBody failed LastError is %d", GetLastError());
            fRet = nntpReturn.fSet(nrcServerFault);
			goto fApplyControlMessage_Exit;
		}

		_ASSERT( lpBody && cbBodySize );
#endif
        CPCString pcBody(lpBody, cbBodySize);

        // assume not implemented
        nntpReturn.fSet(nrcNotYetImplemented);

        // now we have a control command and at least one argument
        switch(cmControlMessage)
        {
            case cmCancel:

                fRet = fApplyCancelArticle( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, nntpReturn);
                break;

            case cmNewgroup:

                fRet = fApplyNewgroup( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, pcBody, nntpReturn);
                break;

            case cmRmgroup:

				fRet = fApplyRmgroup( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, pcValue, nntpReturn);
                break;

            case cmIhave:

                break;

            case cmSendme:

                break;

            case cmSendsys:

                break;

            case cmVersion:

                break;

            case cmWhogets:

                break;

            case cmCheckgroups:

                break;

            default:

                nntpReturn.fSet(nrcIllegalControlMessage);
                fRet = FALSE;
                break;
        }   // end switch

    }   // end if(cbLen)

fApplyControlMessageCommit_Exit:

	// cleanup !
	if( lpControl ) {
		// free the control header value if required
		(pArticle->pAllocator())->Free(lpControl);
		lpControl = NULL;
	}

	if( pMapFile ) {
		XDELETE pMapFile;
		pMapFile = NULL;
	}

    TraceFunctLeave();
    return fRet;
}

BOOL
CInFeed::fApplyControlMessage(
        CARTPTR & pArticle,
		CSecurityCtx *pSecurityCtx,
		CEncryptCtx *pEncryptCtx,
		BOOL fAnonymous,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		)
/*++

Routine Description:

    Given an article with the Control: header, applies the control message.
    Derived classes that dont need to apply control messages, should override
    this to do nothing.

    Modifies grouplist and pNamereflist to include "control.*" newsgroups instead
    of the newsgroups in the Newsgroups: header.

Arguments:

	pArticle - a pointer to the article being processed
    grouplist - reference to the list of newsgroups
    pNamereflist - pointer to the corresponding nameref list
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if this is not a control message or control message is applied successfully
    FALSE, if this is a control message and could not be applied

--*/
{
	TraceFunctEnter("CInFeed::fApplyControlMessage");

    BOOL fRet = TRUE;
	char* lpApproved = NULL;
    char* lpControl = NULL;
	CMapFile* pMapFile = NULL;
	DWORD cbLen = 0;

	nntpReturn.fSetOK();

    //
    // Check for Control: header
    //
    pArticle->fGetHeader((char*)szKwControl, (LPBYTE)lpControl, 0, cbLen);

    // If cbLen is non-zero, this is a control message
    if(cbLen)
    {
		// get a hold of the appropriate newstree object !
		CNewsTreeCore* pNewstree = pArticle->m_pInstance->GetTree();

		// bump perfmon counter
		pArticle->m_pInstance->BumpCounterControlMessagesIn();

        // get the control header value
        lpControl = (pArticle->pAllocator())->Alloc(cbLen+1);
        if(!pArticle->fGetHeader((char*)szKwControl,(LPBYTE)lpControl, cbLen+1, cbLen))
        {
            ErrorTrace((LPARAM)this,"CArticle::fGetheader failed LastError is %d", GetLastError());
            fRet = nntpReturn.fSet(nrcServerFault);
			goto fApplyControlMessage_Exit;
        }

        CPCString pcValue(lpControl, cbLen);

        // trim leading and trailing whitespace and \r\n
	    pcValue.dwTrimStart(szWSNLChars);
	    pcValue.dwTrimEnd(szWSNLChars);

        // get the control message type
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();
        DWORD cbMsgLen = (DWORD)lstrlen(rgchControlMessageTbl[cmControlMessage]);

        // skip to the arguments of the control message
        pcValue.vSkipStart(cbMsgLen);
        pcValue.dwTrimStart(szWSNLChars);
        pcValue.vMakeSz();

        // at least one argument
        if(!pcValue.m_cch)
        {
            fRet = nntpReturn.fSet(nrcArticleFieldMissingValue, rgchControlMessageTbl[cmControlMessage]);
			goto fApplyControlMessage_Exit;
        }

		//
        // get article body - if non-null pMapFile is returned, we need to delete it !
		//
        char* lpBody = NULL;
        DWORD cbBodySize = 0;

#ifdef GUBGUB
        if( !pArticle->fGetBody(pMapFile, lpBody, cbBodySize) )
		{
            ErrorTrace((LPARAM)this,"CArticle::fGetBody failed LastError is %d", GetLastError());
            fRet = nntpReturn.fSet(nrcServerFault);
			goto fApplyControlMessage_Exit;
		}

		_ASSERT( lpBody && cbBodySize );
#endif
        CPCString pcBody(lpBody, cbBodySize);

        // set grouplist and pNamereflist to the control.* group
        // This overrides the Newsgroups header, since control messages
        // should not actually appear in those groups. They appear only
        // in the control.* groups
        // FROMMASTER: do nothing - accept whatever the master sends
        if(!fAdjustGrouplist( pNewstree, pArticle, grouplist, pNamereflist, nntpReturn))
        {
            ErrorTrace((LPARAM)this,"Adjust grouplist failed");
            fRet = nntpReturn.fFalse();
			goto fApplyControlMessage_Exit;
        }

        //
        //  moderated newsgroup check (Ignore contents of Approved: header)
		//	NOTE: FROMMASTER does nothing here - relies on master to have done this check !!
        //
        /* I don't see any need to check it here
	    if (!fModeratedCheck(pArticle, grouplist, FALSE, nntpReturn))
        {
            // Newsgroup is moderated - dont fall through
            fRet = FALSE;
			goto fApplyControlMessage_Exit;
        }*/

	    //
	    //	Now do security check
	    //
	    if( pSecurityCtx || pEncryptCtx )
        {
		    if( !fSecurityCheck( pSecurityCtx, pEncryptCtx, grouplist, nntpReturn ) )
            {
			    fRet = nntpReturn.fFalse();
				goto fApplyControlMessage_Exit;
            }
	    }

		// Approved check: this checks existence of Approved header for non-moderated newsgroups
		if( (cmControlMessage == cmNewgroup) || (cmControlMessage == cmRmgroup) )
		{
			// newgroup, rmgroup control message MUST have an Approved header
			pArticle->fGetHeader((char*)szKwApproved,(LPBYTE)lpApproved, 0, cbLen);
			if( cbLen == 0 )
			{
				nntpReturn.fSet(nrcNoAccess);
                fRet = FALSE;
				goto fApplyControlMessage_Exit;
			}
		}

        // check to see if control messages are allowed for this feed
		if(!fAllowControlMessages(pArticle->m_pInstance))
        {
            // if control messages are disabled, dont apply them and return 240 OK
            // NOTE: in either case, the message will appear on the control.* group and get sent on feeds
            DebugTrace((LPARAM)this,"control message disabled: not applied");
			pArticle->m_pInstance->BumpCounterControlMessagesFailed();
            fRet = nntpReturn.fSetOK();
			goto fApplyControlMessage_Exit;
        }

        // assume not implemented
        nntpReturn.fSet(nrcNotYetImplemented);

        // now we have a control command and at least one argument
        switch(cmControlMessage)
        {
            case cmCancel:

                fRet = fApplyCancelArticle( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, nntpReturn);
                break;

            case cmNewgroup:

                fRet = fApplyNewgroup( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, pcBody, nntpReturn);
                break;

            case cmRmgroup:

				fRet = fApplyRmgroup( (pArticle->m_pInstance), pSecurityCtx, pEncryptCtx, pcValue, nntpReturn);
                break;

            case cmIhave:

                break;

            case cmSendme:

                break;

            case cmSendsys:

                break;

            case cmVersion:

                break;

            case cmWhogets:

                break;

            case cmCheckgroups:

                break;

            default:

                nntpReturn.fSet(nrcIllegalControlMessage);
                fRet = FALSE;
                break;
        }   // end switch

    }   // end if(cbLen)

fApplyControlMessage_Exit:

	// cleanup !
	if( lpControl ) {
		// free the control header value if required
		(pArticle->pAllocator())->Free(lpControl);
		lpControl = NULL;
	}

	if( pMapFile ) {
		XDELETE pMapFile;
		pMapFile = NULL;
	}

    TraceFunctLeave();
    return fRet;
}

BOOL
CInFeed::fAdjustGrouplist(
		CNewsTreeCore* pNewstree,
        CARTPTR & pArticle,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		)
/*++

Routine Description:

    Modifies grouplist and pNamereflist to include "control.*" newsgroups instead
    of the newsgroups in the Newsgroups: header.

Arguments:

	pNewstree - a pointer to the newstree object for this feed
	pArticle - a pointer to the article being processed
    grouplist - reference to the list of newsgroups
    pNamereflist - pointer to the corresponding nameref list
	nntpReturn - The return value for this function call


Return Value:

    TRUE if the grouplist is adjusted successfully, FALSE otherwise

--*/
{
    BOOL fRet = TRUE;
    TraceFunctEnter("CInFeed::fAdjustGrouplist");

    char* lpGroups = NULL;

    CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();
    DWORD cbMsgLen = (DWORD)lstrlen(rgchControlMessageTbl[cmControlMessage]);

    // control messages should be posted to control.* groups
    lpGroups = (pArticle->pAllocator())->Alloc(cbMsgLen+8+1);
    _ASSERT(lpGroups);
    lstrcpy(lpGroups, "control.");  // 8 chars
    lstrcat(lpGroups, rgchControlMessageTbl[cmControlMessage]);

    if (!grouplist.fInit(1, pArticle->pAllocator()))
    {
	    nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
        (pArticle->pAllocator())->Free(lpGroups);
        return FALSE;
    }

	if (!pNamereflist->fInit(1, pArticle->pAllocator()))
    {
	    nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);
        (pArticle->pAllocator())->Free(lpGroups);
        return FALSE;
    }

	CGRPCOREPTR	pGroup = pNewstree->GetGroup( lpGroups, lstrlen(lpGroups)+1);
	if (pGroup)
	{
	    //
		// If it is already in the tree ...
		//
		grouplist.AddTail(CPostGroupPtr(pGroup));
	}

	//
	// Check if article is going to be posted to any newsgroups.
	//
	if (grouplist.IsEmpty())
    {
	    nntpReturn.fSet(nrcControlNewsgroupMissing);
        (pArticle->pAllocator())->Free(lpGroups);
        return FALSE;
    }

    (pArticle->pAllocator())->Free(lpGroups);
    return fRet;
}

BOOL
CInFeed::fApplyCancelArticleInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
			BOOL fApply,
			CNntpReturn & nntpReturn
			)
/*++

Routine Description:

	If the message id is in the article table, move it to the
	history table - else add it to the history table

    TODO: From header check - the From header in the control message
    should match the From header in the target article.

	!!! SlaveFromClient is different - just does ACL checks

Arguments:

	pcontext - client logon context (for ACL checks only)
	pcValue - the message id to cancel
	fApply - if TRUE, apply the control message else do ACL checks only
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful or unneeded. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fApplyCancelArticle" );

 	HANDLE hToken = NULL;
 	BOOL fNeedsClosed = FALSE;

	//
	// clear the return code object
	//

	nntpReturn.fSetOK();

    //
    // validate argument
    //
    _ASSERT(pcValue.m_cch);
    const char* szMessageID = (const char*)pcValue.m_pch;
    char chStart = szMessageID [0];
    char chEnd   = szMessageID [pcValue.m_cch-1];
    if(chStart != '<' || chEnd != '>')
    {
        return nntpReturn.fSet(nrcArticleBadMessageID, szMessageID, szKwControl);
    }

	WORD	HeaderOffset ;
	WORD	HeaderLength ;
	ARTICLEID ArticleNo;
    GROUPID GroupId;

	//
	// Look for the article in the article table.
    // If there is none, insert in the history table
	//

	CStoreId storeid;
	if (!(pInstance->ArticleTable())->GetEntryArticleId(
										szMessageID,
										HeaderOffset,
										HeaderLength,
										ArticleNo,
										GroupId,
										storeid))
	{
		if (ERROR_FILE_NOT_FOUND != GetLastError())
		{
			return nntpReturn.fSet(nrcArticleTableError, szMessageID, GetLastError());
		}
        else
        {
			// do not apply for SlaveFromClientFeeds
			if( fApply )
			{
				//
				// Put it in the history table. If there is an error, record it but
				// continue so that the entry can be removed from the ArticleTable
				// !!! SlaveFromClient should not execute this.
				//

				FILETIME	FileTime ;
				GetSystemTimeAsFileTime( &FileTime ) ;
				nntpReturn.fSetOK(); // assume the best

				if (!(pInstance->HistoryTable())->InsertMapEntry(szMessageID, &FileTime))
				{
					// If it already exists in the history table, we are ok
					if(ERROR_ALREADY_EXISTS != GetLastError())
						nntpReturn.fSet(nrcHashSetFailed, szMessageID, "History", GetLastError());
				}
			}
        }
	}
    else
    {
        //
        // Article found in the article table - check From header
		// NOTE: rfc suggests we can avoid this check.
        //

		//
		// 3rd level ACL check: client context should have access to cancel an article
		//
		CNewsTreeCore*	ptree = pInstance->GetTree() ;
		CGRPCOREPTR	pGroup = ptree->GetGroupById( GroupId ) ;
		if( pGroup != 0 )
		{

			SelectToken(pSecurityCtx, pEncryptCtx, &hToken, &fNeedsClosed);
	
			if( !pGroup->IsGroupAccessible(
												hToken,
												NNTP_ACCESS_REMOVE
												) )
			{
				DebugTrace((LPARAM)this, "Group %s Cancel article: Access denied", pGroup->GetName());
				if (fNeedsClosed)
					CloseHandle(hToken);
				return nntpReturn.fSet( nrcNoAccess ) ;
			}
		}

		// do not apply for SlaveFromClientFeeds
		if( fApply && pGroup )
		{
		    // We should have hToken got here
		
			//
			// Call gExpireArticle to cancel this article
			// !!! SlaveFromClient should not execute this.
			//
			if (  pInstance->ExpireArticle( GroupId, ArticleNo, &storeid, nntpReturn, hToken, TRUE, fAnonymous ) /*
				   || pInstance->DeletePhysicalArticle( GroupId, ArticleNo, &storeid, hToken, fAnonymous )*/
			)
			{
				DebugTrace((LPARAM)this,"Article cancelled: GroupId %d ArticleId %d", GroupId, ArticleNo);
			}
			else
			{
				ErrorTrace((LPARAM)this, "Could not cancel article: GroupId %d ArticleId %d", GroupId, ArticleNo);
				if (fNeedsClosed)
					CloseHandle(hToken);
				return nntpReturn.fIsOK();
			}
		}
    }

	if (fNeedsClosed)
		CloseHandle(hToken);


	TraceFunctLeave();

	// Use "fIsOK" rather than "fSetOK" because HistoryInsert might have failed
	return nntpReturn.fIsOK();
}

BOOL
CInFeed::fApplyNewgroupInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
            CPCString & pcBody,
			BOOL fApply,
			CNntpReturn & nntpReturn
			)
/*++

Routine Description:

    Add a new newsgroup in response to a control message. Follows son-of-RFC1036 spec.

    NOTE: A newgroup control message should be posted to the control.newgroup group.
    Only the moderator of this group can send this message. A newgroup control message
    without the proper Approved header will be rejected.

    TODO: The code to add a newsgroup has been lifted from svcgroup.cpp. This code
    should be probably be made a member of CNewsTree and called by the RPC stub as well
    as this function.

    TODO: Allow change of moderation status ?

	!!! SlaveFromClient is different - just does ACL checks

Arguments:

    pcontext - client logon context (for ACL checks only)
	pcValue - argument to the newgroup command
    pcBody - body of the article
	fApply - if TRUE, apply the control message else do ACL checks only
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful or unneeded. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fApplyNewgroup" );

	//
	// clear the return code object
	//
	nntpReturn.fSetOK();

    char	szNewsgroup[MAX_NEWSGROUP_NAME+1] ;
    char	szNewsgroupTemp[MAX_NEWSGROUP_NAME+1] ;
    char	szParentGroup[MAX_NEWSGROUP_NAME+1] ;
	char	szDescription[MAX_DESCRIPTIVE_TEXT+1] ;
	char	szModerator[MAX_MODERATOR_NAME+1] ;
	DWORD   cbNewsgroup = 0;
	DWORD   cbParentGroup = 0;
    DWORD   cbDescription = 0;
	DWORD	cbModerator = 0;
    BOOL    fModerated = FALSE;
	char*   pch = NULL;
	HANDLE  hToken;
	BOOL fNeedsClosed = FALSE;

	szNewsgroup[0] = '\0' ;
	szDescription[0] = '\0' ;
	szModerator[0] = '\0';

    //
    // get the newsgroup name
    //
    CPCString pcNewsgroup;
    pcValue.vGetToken(" ", pcNewsgroup);
    cbNewsgroup = pcNewsgroup.m_cch;

    // validate newsgroup name length
    if(cbNewsgroup == 0 || cbNewsgroup >= MAX_NEWSGROUP_NAME)
        return nntpReturn.fSet(nrcBadNewsgroupNameLen);

    // make a copy of the newsgroup name
    pcNewsgroup.vCopyToSz(szNewsgroup);

	//
	// check for "moderated" / "unmoderated" qualifier
	// if "moderated", get the default moderator
	// default moderator is hiphenated-newsgroup@default
	//
	CPCString pcModeration;
	pcValue.vGetToken("\r\n", pcModeration);

	if( pcModeration.fEqualIgnoringCase("moderated") )
	{
		fModerated = TRUE;
		cbModerator = MAX_MODERATOR_NAME;
		if( pInstance->GetDefaultModerator( szNewsgroup, szModerator, &cbModerator ) ) {
			_ASSERT( !cbModerator || (cbModerator == (DWORD)lstrlen( szModerator )+1) );
		} else {
			ErrorTrace((LPARAM)this,"Error %d GetDefaultModerator", GetLastError());
			cbModerator = 0;
		}
	}

    //
    // get the newsgroup description and moderator (if provided)
    //
    CPCString pcDescription;

#ifdef GUBGUB
    _ASSERT(pcBody.m_cch);

    //
    //  search for the descriptor-tag in the body
    //
    do
    {
        pcBody.vGetToken("\r\n", pcDescription);    // skip this line

        // check if line is descriptor-tag
        if(pcDescription.fEqualIgnoringCase(lpNewgroupDescriptorTag))
        {
            // Newsgroup description is present
            pcBody.dwTrimStart(szWSNLChars);        // skip whitespace and \r\n
            pcBody.vGetToken(" \t", pcDescription); // skip the newsgroup name
            pcBody.dwTrimStart(szWSChars);          // skip whitespace after the newsgroup name
            pcBody.vGetToken("\r\n", pcDescription);// this is the description
            cbDescription = pcDescription.m_cch;

            // validate newsgroup description length
            cbDescription = min( cbDescription, MAX_DESCRIPTIVE_TEXT );
			pcDescription.m_cch = cbDescription;

            // make a copy of the newsgroup description
            pcDescription.vCopyToSz(szDescription);

            break;
        }
		else if( fModerated &&
					!_strnicmp( pcDescription.m_pch, lpModeratorTag, sizeof(lpModeratorTag)-1 ) )
		{
			// Newsgroup is moderated and moderator name is present
			pcDescription.vGetToken("\r\n", pcModeration);
			pcModeration.vSkipStart( sizeof(lpModeratorTag)-1 );
			pcModeration.dwTrimStart(szWSChars);
			pcModeration.dwTrimEnd(szWSNLChars);
			cbModerator = pcModeration.m_cch;

            // validate moderator length
            cbModerator = min( cbModerator, MAX_MODERATOR_NAME );
			pcModeration.m_cch = cbModerator;

			// make a copy of the moderator
			pcModeration.vCopyToSz(szModerator);
		}

    } while(pcBody.m_cch);
#endif


	// get global newstree object
	CNewsTreeCore*	ptree = pInstance->GetTree();

	//
	// If the group does not exist - ACL check the parent
    // If the group exists already - ACL check the group
	//
	lstrcpy( szNewsgroupTemp, szNewsgroup );
    CGRPCOREPTR	pGroup = ptree->GetGroup( szNewsgroupTemp, lstrlen( szNewsgroupTemp ) ) ;

	if( pGroup != 0 )
	{

		SelectToken(pSecurityCtx, pEncryptCtx, &hToken, &fNeedsClosed);

		// group exists - do an ACL check on the newsgroup
		if( !pGroup->IsGroupAccessible(
								hToken,
								NNTP_ACCESS_EDIT_FOLDER
								) )
		{
			DebugTrace((LPARAM)this, "Group %s newgroup: Access denied", pGroup->GetName());
			if (fNeedsClosed)
				CloseHandle(hToken);
			return nntpReturn.fSet( nrcNoAccess ) ;
		}
	}
	else
	{
		if( pSecurityCtx || pEncryptCtx )
		{
			// group does not exist ! Do an ACL check on the parent (if it exists)
			lstrcpy( szParentGroup, szNewsgroup );
			cbParentGroup = cbNewsgroup;
			DWORD cbConsumed = 0;

			// Get a default token
			SelectToken(pSecurityCtx, pEncryptCtx, &hToken, &fNeedsClosed);

			//
			//	walk up the tree and find the first parent group
			//

			CGRPCOREPTR pParentGroup = 0;
			while( (pParentGroup = ptree->GetParent(
											szParentGroup,
											cbParentGroup,
											cbConsumed
											)) )
			{

				if (fNeedsClosed)
					CloseHandle(hToken);
				SelectToken(pSecurityCtx, pEncryptCtx, &hToken, &fNeedsClosed);

				// If parent exists, do an ACL check on the parent
				if( !pParentGroup->IsGroupAccessible(
											hToken,
											NNTP_ACCESS_CREATE_SUBFOLDER
											) )
				{
					// parent ACL check failed - fail the newgroup
					DebugTrace((LPARAM)this, "Group %s newgroup: Access denied on parent group", pParentGroup->GetName());
					if (fNeedsClosed)
						CloseHandle(hToken);
					return nntpReturn.fSet( nrcNoAccess ) ;
				}
				else
				{
					// parent ACL check succeeded - honor the newgroup
					break;
				}

				// !! Not executed here - would be if we walk through all ancestors to the root
				cbParentGroup -= cbConsumed;
				cbConsumed = 0;
			}

			//
			//	Should add logic to post to a control.newrootgroup in case this group is a root group
			//  This would allow admins to set ACLs on control.newrootgroup and thus control who creates a root group.
			//
		}
	}

	// do not apply for SlaveFromClientFeeds
	if( !fApply ) {
		if (fNeedsClosed)
			CloseHandle(hToken);
		return nntpReturn.fIsOK();
	}
	
	//
	//	All ACL checks completed - apply the newgroup control message
    //	we have all the info - create/modify the group
	//  !!! SlaveFromClient should not execute this.
	//

	// create the group !!!
	if( pGroup == 0 )
	{
		if( !ptree->CreateGroup( szNewsgroup, FALSE, hToken, fAnonymous ) )
		{
			// Failed to create group
			ErrorTrace((LPARAM)this, "Group %s newgroup: create group failed", szNewsgroup );
			if (fNeedsClosed)
				CloseHandle(hToken);
			return nntpReturn.fSet(nrcCreateNewsgroupFailed);
		}

		pGroup = ptree->GetGroup( szNewsgroup, lstrlen( szNewsgroup ) ) ;
		//_ASSERT( pGroup );
	}

    //
    // Only when we have a good group pointer do we do the following, notice that 
    // group pointer could be null in case the group is deleted right away after
    // the creation
    //
    if ( pGroup ) {
	    // Moderator info ? rfc does not provide a way to set this
	    // workaround rfc by using a "default moderator"
	    if( fModerated ) pGroup->SetModerator(szModerator);

	    // set Description info
	    if( szDescription[0] != '\0' ) pGroup->SetHelpText(szDescription);

	    PCHAR	args[2] ;
	    CHAR    szId[20];
	    _itoa( pInstance->QueryInstanceId(), szId, 10 );
	    args[0] = szId ;
	    args[1] = pGroup->GetNativeName() ;

	    NntpLogEvent(		
			    NNTP_EVENT_NEWGROUP_CMSG_APPLIED,
			    2,
			    (const CHAR **)args,
			    0 ) ;

    }

	if (fNeedsClosed)
		CloseHandle(hToken);

	return nntpReturn.fIsOK();
}

BOOL
CInFeed::fApplyRmgroupInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
            CPCString & pcValue,
			BOOL	fApply,
			CNntpReturn & nntpReturn
			)
/*++

Routine Description:

    Remove a newsgroup in response to a control message. Follows son-of-RFC1036 spec.

    NOTE: A rmgroup control message should be posted to the control.rmgroup group.
    Only the moderator of this group can send this message. A rmgroup control message
    without the proper Approved header will be rejected.

	!!! SlaveFromClient is different - just does ACL checks

Arguments:

	pcontext - client logon context (for ACL checking)
	pcValue - argument to the newgroup command
	fApply - if TRUE, apply the control message else do ACL checks only
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful or unneeded. FALSE, otherwise.

--*/
{
 	TraceFunctEnter( "CInFeed::fApplyRmgroup" );
 	HANDLE  hToken;
 	BOOL fNeedsClosed = FALSE;

	//
	// clear the return code object
	//
	nntpReturn.fSetOK();

    char	szNewsgroup[MAX_NEWSGROUP_NAME] ;

    DWORD   cbNewsgroup = 0;
	szNewsgroup[0] = '\0' ;

    //
    // get the newsgroup name
    //
    CPCString pcNewsgroup;
    pcValue.vGetToken(" ", pcNewsgroup);
    cbNewsgroup = pcNewsgroup.m_cch;

    // validate newsgroup name length
    if(cbNewsgroup == 0 || cbNewsgroup >= MAX_NEWSGROUP_NAME)
        return nntpReturn.fSet(nrcBadNewsgroupNameLen);

    // make a copy of the newsgroup name
    pcNewsgroup.vCopyToSz(szNewsgroup);

    //
    // Now we have all the info - remove the group
    //
	CNewsTreeCore*	ptree = pInstance->GetTree() ;

	CGRPCOREPTR	pGroup = ptree->GetGroup( szNewsgroup, cbNewsgroup) ;
	if( pGroup == 0 )
    {
	    nntpReturn.fSet(nrcGetGroupFailed);
	}
	else
    {
		//
		//	3rd level ACL check: check client access to rmgroup argument
		//

		SelectToken(pSecurityCtx, pEncryptCtx, &hToken, &fNeedsClosed);

		if( !pGroup->IsGroupAccessible(
										hToken,
										NNTP_ACCESS_REMOVE_FOLDER
										) )

		{
			DebugTrace((LPARAM)this, "Group %s rmgroup: Access denied", pGroup->GetName());
			if (fNeedsClosed)
				CloseHandle(hToken);
			nntpReturn.fSet( nrcNoAccess ) ;
		}
		else
		{
			if (fNeedsClosed)
				CloseHandle(hToken);

			if( fApply )
			{
				// ACL check succeeded - apply rmgroup
				// !!! SlaveFromClient should not execute this.
				if( !ptree->RemoveGroup( pGroup ) )
					nntpReturn.fSet(nrcServerFault);

				PCHAR	args[2] ;
				CHAR    szId[20];
				_itoa( pInstance->QueryInstanceId(), szId, 10 );
				args[0] = szId ;
				args[1] = pGroup->GetNativeName() ;

				NntpLogEvent(		
					NNTP_EVENT_RMGROUP_CMSG_APPLIED,
					2,
					(const CHAR **)args,
					0 ) ;

			}
		}
	}

	return nntpReturn.fIsOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfilt.h $(O)\nntpfilt_i.c : $(STAXNNTP)\core\include\nntpfilt.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfilt_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfilt_i.c \
    -header $@ \
    -tlb $(O)\nntpfilt.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpmsg.h: ..\..\server\nntpmsg.mc
    mc -v -r $(O) -h $(O) $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\article.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    article.cpp

Abstract:

    This module contains definition for the CArticle base class.

	This class provides basic, general tools to parse and edit a
	Netnews articles.

	The basic idea is to map the files containing the articles and
	then to record the location of parts of the articles with CPCStrings.
	A CPCString is just a pointer (usually into the mapped file) and a length.

Author:

    Carl Kadie (CarlK)     06-Oct-1995

Revision History:

--*/

#ifdef	_NO_TEMPLATES_
#define	DEFINE_CGROUPLST_FUNCTIONS
#endif

#include    <stdlib.h>
#include	"stdinc.h"
//#include "smtpdll.h"

#ifdef	_NO_TEMPLATES_

CGROUPLST_CONSTRUCTOR( NAME_AND_ARTREF ) ;
CGROUPLST_FINIT( NAME_AND_ARTREF ) ;
CGROUPLST_FASBEENINITED( NAME_AND_ARTREF ) ;
CGROUPLST_DESTRUCTOR( NAME_AND_ARTREF ) ;
CGROUPLST_GETHEADPOSITION( NAME_AND_ARTREF ) ;
CGROUPLST_ISEMPTY( NAME_AND_ARTREF ) ;
CGROUPLST_REMOVEALL( NAME_AND_ARTREF ) ;
CGROUPLST_GETCOUNT( NAME_AND_ARTREF ) ;
CGROUPLST_GETNEXT( NAME_AND_ARTREF ) ;
CGROUPLST_GETHEAD( NAME_AND_ARTREF ) ;
CGROUPLST_GET( NAME_AND_ARTREF ) ;
CGROUPLST_ADDTAIL( NAME_AND_ARTREF ) ;


CGROUPLST_CONSTRUCTOR( CGRPPTR ) ;
CGROUPLST_FINIT( CGRPPTR ) ;
CGROUPLST_FASBEENINITED( CGRPPTR ) ;
CGROUPLST_DESTRUCTOR( CGRPPTR ) ;
CGROUPLST_GETHEADPOSITION( CGRPPTR ) ;
CGROUPLST_ISEMPTY( CGRPPTR ) ;
CGROUPLST_REMOVEALL( CGRPPTR ) ;
CGROUPLST_GETCOUNT( CGRPPTR ) ;
CGROUPLST_GETNEXT( CGRPPTR ) ;
CGROUPLST_GETHEAD( CGRPPTR ) ;
CGROUPLST_GET( CGRPPTR ) ;
CGROUPLST_ADDTAIL( CGRPPTR ) ;



#endif


//
// Some function prototypes
//

BOOL
CArticle::InitClass(
					void
					)
/*++

Routine Description:

    Preallocates memory for CArticle objects

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
	return	gArticlePool.ReserveMemory( MAX_ARTICLES, cbMAX_ARTICLE_SIZE ) ;	
}


BOOL
CArticle::TermClass(
					void
					)
/*++

Routine Description:

    Called when objects are freed.

Arguments:

    None.

Return Value:

    TRUE

--*/
{

	_ASSERT( gArticlePool.GetAllocCount() == 0 ) ;
	return	gArticlePool.ReleaseMemory() ;

}


CArticle::CArticle(
                void
                ):
/*++

Routine Description:

    Class Constructor. Does nothing except initial member variables.

Arguments:

    None.

Return Value:

    TRUE

--*/m_pInstance( NULL )/*
	m_hFile(INVALID_HANDLE_VALUE),
	m_pOpenFile( 0 ),
	m_pInstance( NULL ),
	m_cHeaders(0),
	m_articleState(asUninitialized),
	m_pHeaderBuffer( 0 ),
	m_pMapFile( 0 )*/
{
   m_szFilename = 0 ;
   numArticle++;

} // CArticle

	
	
CArticle::~CArticle(
                    void
                    )
/*++

Routine Description:

    Class destructor

Arguments:

    None.

Return Value:

    None

--*/
{
	//
	// If file handle is open, close it, make sure 
	// if we have done this, our base class's destructor
	// doesn't do it 
	//

	if( m_hFile != INVALID_HANDLE_VALUE )
	{
		BOOL	fSuccess = ArtCloseHandle( 
												m_hFile
												) ;
        _ASSERT( fSuccess ) ;
        m_hFile = INVALID_HANDLE_VALUE;
	}
}

BOOL	
CArticle::fInstallArticle(
			class	CNewsGroupCore&	group,
			ARTICLEID	articleid, 
			class	CSecurityCtx*	pSecurity,
			BOOL	fIsSecure,
			void *pGrouplist,
			DWORD dwFeedId
			)	{
/*++

Routine Description : 

	Place a CArticle object into a newsgroup.
	The CArticle object may reside only in memory, or we may have
	a file containing the article available.

Arguments : 

	group -	The newsgroup we are placing the article into
	articleid - The articleid within the newsgroup
	pSecurity - The client's security context
	fIsSecure - TRUE if the client is using a secure (SSL?) session

Return Value : 

	TRUE if successfull !

--*/

#if 0
	if( fIsArticleCached() ) {
	
		if( m_pHeaderBuffer ) {

			return	group.InsertArticle(	this,
											pGrouplist,
											dwFeedId,
											articleid,
											m_pcHeader.m_pch,
											m_pcHeader.m_cch,
											m_pcBody.m_pch,
											m_pcBody.m_cch,
											pSecurity,
											fIsSecure,
											multiszNewsgroups()
											) ;
		}	else	{

			return	group.InsertArticle(	this,
											pGrouplist,
											dwFeedId,
											articleid,
											m_pcArticle.m_pch,
											m_pcArticle.m_cch,
											0,
											0,
											pSecurity,
											fIsSecure,
											multiszNewsgroups()
											) ;

		}
		
	}	else	{

		return	group.InsertArticle(	this,
										pGrouplist,
										dwFeedId,
										articleid,
										m_szFilename,
										pSecurity,
										fIsSecure,
										multiszNewsgroups()
										) ;

	}
#endif
	return	FALSE ;
}

extern       MAIL_FROM_SWITCH        mfMailFromHeader;

BOOL	
CArticle::fMailArticle(
			LPSTR	lpModerator
			//class	CSecurityCtx*	pSecurity,
			//BOOL	fIsSecure	
			)	{
/*++

Routine Description : 

	Pass the article to a mail provider.
	The CArticle object may reside only in memory, or we may have
	a file containing the article available.

Arguments : 

	pSecurity - The client's security context
	fIsSecure - TRUE if the client is using a secure (SSL?) session

Return Value : 

	TRUE if successfull !

--*/

    char  szSmtpAddress [MAX_PATH+1];
    DWORD cbAddressSize = MAX_PATH;
	LPSTR lpFrom = NULL;
	DWORD cbLen = 0;
	BOOL  fRet = TRUE;

    m_pInstance->GetSmtpAddress(szSmtpAddress, &cbAddressSize);
	LPSTR lpTempDirectory = m_pInstance->PeerTempDirectory();

	// construct mail message from header if required
	if( mfMailFromHeader == mfAdmin )
	{
		lpFrom = m_pInstance->QueryAdminEmail();
		cbLen  = m_pInstance->QueryAdminEmailLen()-1;	// len includes terminating null
	} else if( mfMailFromHeader == mfArticle ) {
		fGetHeader((char*)szKwFrom,(LPBYTE)lpFrom, 0, cbLen);
		if( cbLen ) {
			lpFrom = pAllocator()->Alloc(cbLen+1);
			if(!fGetHeader((char*)szKwFrom,(LPBYTE)lpFrom, cbLen+1, cbLen)) {
				pAllocator()->Free(lpFrom);
				lpFrom = NULL;
				cbLen = 0;
			} else {
				//
				//	TODO: Need to call into Keith's smtpaddr lib to clean up this header
				//	Some SMTP server's would have a problem with quotes in the from: hdr
				//
				cbLen -= 2;
			}
		}
	}

	_ASSERT( (lpFrom && cbLen) || (!lpFrom && !cbLen) );

	if( fIsArticleCached() ) {

		// NOTE: fPostArticleEx takes both file and memory info for an article
		// If the file info is valid, memory is not and vice versa
		if( m_pHeaderBuffer ) {

			fRet =	fPostArticleEx(	INVALID_HANDLE_VALUE,	// file handle
									NULL,					// filename
									0,						// file offset
									0,						// article length in file
									m_pcHeader.m_pch,		// header
									m_pcHeader.m_cch,		// header size
									m_pcBody.m_pch,			// body
									m_pcBody.m_cch,			// body size
									lpModerator,			// moderator
									szSmtpAddress,			// SMTP server
									cbAddressSize,			// sizeof server
									lpTempDirectory,		// temp dir
									lpFrom,					// mail envelope from hdr
									cbLen					// from hdr len
									//pSecurity,
									//fIsSecure
									) ;
		}	else	{

			fRet =	fPostArticleEx(	INVALID_HANDLE_VALUE,	// file handle
									NULL,					// filename
									0,						// file offset
									0,						// article length in file
									m_pcArticle.m_pch,		// article
									m_pcArticle.m_cch,		// article size
									0,						// body
									0,						// body size
									lpModerator,			// moderator
									szSmtpAddress,			// SMTP server
									cbAddressSize,			// sizeof server
									lpTempDirectory,		// temp dir
									lpFrom,					// mail envelope from hdr
									cbLen					// from hdr len
									//pSecurity,
									//fIsSecure
									) ;
		}
		
	}	else	{

		HANDLE hFile = INVALID_HANDLE_VALUE;
		DWORD  dwOffset = 0;
		DWORD  dwLength = 0;

		BOOL fWhole = fWholeArticle(hFile, dwOffset, dwLength);
		_ASSERT( fWhole );

		fRet =	fPostArticleEx(	hFile,				// file handle
								m_szFilename,		// filename
								dwOffset,			// file offset
								dwLength,			// article length in file
								0,					// header - not valid
								0,					// size - not valid
								0,					// body - not valid
								0,					// body size - not valid
								lpModerator,		// moderator
								szSmtpAddress,		// SMTP server
								cbAddressSize,		// sizeof server
								lpTempDirectory,	// temp dir
								lpFrom,				// mail envelope from hdr
								cbLen				// from hdr len
								//pSecurity,
								//fIsSecure
								) ;
	}

	// Free from header if allocated
	if( lpFrom && (mfMailFromHeader == mfArticle) ) {
		pAllocator()->Free(lpFrom);
		lpFrom = NULL;
	}

	return	fRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\fromclnt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to FromClient Infeeds

	As the name suggests, these for for processing articles that come from
	clients. The idea is to be very strict in what is allowed from the client.
	If an article doesn't match spec, it is either fixed or rejected.


Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:

--*/


#include "stdinc.h"

BOOL
CFromClientArticle::fValidate(
							CPCString& pcHub,
							const char * szCommand,
							CInFeed*	pInFeed,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	Validates an article from a client. Does not change the article
	except to fix (if necessary) the capitalization of some header keywords.

Arguments:

	szCommand - The arguments (if any) used to post/xreplic/etc this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// Check article state
	//

	_ASSERT(asPreParsed == m_articleState);

#if 0
	char chBad;
	if (!m_pcHeader.fCheckTextOrSpace(chBad))
		return nntpReturn.fSet(nrcArticleBadChar,  (BYTE) chBad, "header");
#endif

    //
    // Check required and optional fields
    //

	CField * rgPFields [] = {
            &m_fieldControl,
			&m_fieldSubject,
			&m_fieldNewsgroups,
			&m_fieldDistribution,
			&m_fieldFrom,
			&m_fieldDate,
			&m_fieldFollowupTo,
			&m_fieldReplyTo,
			&m_fieldApproved,
			&m_fieldSender,
			&m_fieldOrganization,
			&m_fieldSummary,
			&m_fieldReferences,
			&m_fieldLines,
			&m_fieldKeyword,
			&m_fieldExpires,
			&m_fieldPath,
            &m_fieldNNTPPostingHost,
			&m_fieldMessageID	// must be last - as we may not want to parse it !
				};
	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);

	if( !gHonorClientMessageIDs ) {
		cFields -- ;
	}

	if (!fFindAndParseList((CField * *) rgPFields, cFields, nntpReturn))
		return nntpReturn.fFalse();

	CPCString	pcDate = m_fieldDate.pcGet() ;
	if( pcDate.m_pch != 0 ) {

		if( !AgeCheck( pcDate ) ) {
			nntpReturn.fSet( nrcArticleDateTooOld ) ;
			return	FALSE ;
		}
	}

	LPSTR	lpstrMessageId = m_fieldMessageID.szGet() ;
	if( lpstrMessageId != 0 && *lpstrMessageId != '\0' ) {
		if (m_pInstance->ArticleTable()->SearchMapEntry(lpstrMessageId)
			|| m_pInstance->HistoryTable()->SearchMapEntry(lpstrMessageId))
		{
			nntpReturn.fSet(nrcArticleDupMessID, lpstrMessageId, GetLastError());
			return nntpReturn.fFalse();
		}
	}


	//
	// Confirm (and fix, if necessary) the capitalization of the fields
	//

	if (!fConfirmCapsList((CField * *) rgPFields, cFields, nntpReturn))
		return nntpReturn.fFalse();
//
	//!!!CLIENT LATER Not doing anything with control messages
	//

	/* !!!CLIENT LATER
	Body
	SHOULD limit signatures -- !!!LATER
	Early  difficulties in inferring return addresses from article headers led to "signatures": short closing texts,  automatically  added  to  the end of articles by posting agents, identifying the poster and giving his network addresses etc.  If  a  poster

 or posting agent does append a signature to an article, the signature SHOULD be preceded with  a  delimiter line  containing  (only)  two hyphens (ASCII 45) followed by one blank (ASCII  32).   Posting  agents  SHOULD  limit  the length  of  signatures

 since  verbose  excess bordering on abuse is common if no restraint is imposed;  4  lines  is  a common limit.

	Whole Article
	No NULL character allowed
	Header and body lines MAY contain any ASCII characters other than CR (ASCII 13), LF (ASCII 10), and NUL (ASCII 0).
	NO char > oct 127 allowed (unless co-operating)
	Articles  MUST  not  contain  any octet with value exceeding 127, i.e. any octet that is not an ASCII character.
	Limit to 60K -- LATER
	Posters SHOULD limit  posted  articles  to  at  most  60,000 octets,  including  headers  and EOL representations, unless the articles are being posted only within a cooperating sub-net which is known to be capable of handling larger articles gracefully.


  Posting agents presented with a  large  article SHOULD warn the poster and request confirmation.
	*/

	return nntpReturn.fSetOK();
}


BOOL
CFromClientArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn,
							 PDWORD     pdwLinesOffset
			  )

/*++

Routine Description:

	Modify the headers of the article.

Arguments:

	grouplist - A list: for each newsgroup its name, and the article number in that group.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	/* !!!CLIENT LATER
	Must validate encodings see From parsing
	Posting agents MUST ensure that any material  resembling  an  encoded  word (complete  with  all delimiters), in a context where encoded words may appear, really is an encoded word.

	*/

	if (!(
  			   m_fieldMessageID.fSet(*this, pcDNS, nntpReturn)
  			&& m_fieldNewsgroups.fSet(*this, nntpReturn)
  			&& m_fieldDistribution.fSet(*this, nntpReturn)
  			&& m_fieldDate.fSet(*this, nntpReturn)
  			&& m_fieldLines.fSet(*this, nntpReturn)
  			&& m_fieldOrganization.fSet(*this, nntpReturn)
  			&& m_fieldPath.fSet(*this, pcHub, nntpReturn)
			&& m_fieldXref.fSet(pcHub, grouplist, *this, m_fieldNewsgroups, nntpReturn)
			&& m_fieldNNTPPostingHost.fSet(*this, remoteIpAddress, nntpReturn)
			/* && m_fieldXAuthLoginName.fSet(*this, nntpReturn) */
			&& fDeleteEmptyHeader(nntpReturn)
			&& fSaveHeader(nntpReturn, pdwLinesOffset)
		))
		return nntpReturn.fFalse();

    //
    // if we don't need to back fill, set pdwLinesOffset to INVALID_FILE_SIZE,
    // so that the caller will know that this message doesn't need back fill of lines
    //
    if ( pdwLinesOffset && !m_fieldLines.fNeedBackFill() )
        *pdwLinesOffset = INVALID_FILE_SIZE;

	return nntpReturn.fSetOK();
}

BOOL
CFromClientArticle::fCheckBodyLength(
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Checks if the length of the body is within bounds.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	//!!!CLIENT NEXT need to add a real body length check here
	//

	return nntpReturn.fSetOK();
}



BOOL
CFromClientNewsgroupsField::fSet(
				   				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Rewrites the Newsgroups line, fixing some problems such as
	extra whitespace and duplicates.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsParsed == m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is the size of the old line
	//

	const DWORD cchMaxNewsgroups =
			(m_pHeaderString->pcLine).m_cch
			+ 2 // for the newline
			+ 1; // for a terminating null


	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxNewsgroups);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Newsgroups: "
	//

	pcLine << szKwNewsgroups << (char) ' ';

	//
	// Loop through the newsgroups
	//

	_ASSERT(0 < cGet());//real
	char const * szNewsgroup = multiSzGet();
	do
	{

	//
	// Start with newsgroup name, then add comma
	//

//		pcLine << szDownCase((char *)szNewsgroup, szNewsgroupBuf) << (char) ',';
		pcLine << szNewsgroup << (char) ',';

		//
		// go to first char after next null
		//

		while ('\0' != szNewsgroup[0])
			szNewsgroup++;
		szNewsgroup++;
	} while ('\0' != szNewsgroup[0]);

	//
	// Remove the last ","
	//

	pcLine.vSkipEnd(1);

	pcLine	<< "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxNewsgroups-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwNewsgroups, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromClientDistributionField::fSet(
				   				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Rewrites the Distribution line, fixing some problems such as
	extra whitespace and duplicates.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// If it was not found exists, then just return
	//

	if (fsNotFound == m_fieldState)
		return nntpReturn.fSetOK();


	//
	// Otherwise, fix up what was found.
	//

	//
	// Check article state
	//

	_ASSERT(fsParsed == m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is the size of the old line
	//

	const DWORD cchMaxDistribution =
			(m_pHeaderString->pcLine).m_cch
			+ 2 // for the newline
			+ 1; // for a terminating null


	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxDistribution);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Distribution: "
	//

	pcLine << szKwDistribution << (char) ' ';

	//
	// Loop through the Distribution
	//

	_ASSERT(0 <= (int)cGet());//real
	char const * szDistributrionValue = multiSzGet();
	do
	{

	//
	// Start with distribution value and add comma
	//

//		pcLine << szDownCase((char *)szDistributrionValue, szDistributrionValueBuf) << ',';
		pcLine << szDistributrionValue << (char) ',';

		//
		// go to first char after next null
		//

		while ('\0' != szDistributrionValue[0])
			szDistributrionValue++;
		szDistributrionValue++;
	} while ('\0' != szDistributrionValue[0]);

	//
	// Remove the last ","
	//

	pcLine.vSkipEnd(1);

	pcLine	<< "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxDistribution-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwDistribution, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}



BOOL
CFromClientDateField::fSet(
				   				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	If the date field is missing, adds it.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//
	//
	// If it already exists, then just return
	//

	if (fsParsed == m_fieldState)
		return nntpReturn.fSetOK();


	//
	// Otherwise, add it.
	//

	_ASSERT(fsNotFound == m_fieldState);//real
	CPCString pcLine;

	//
	// max size needed is
	//

	const DWORD cchMaxDate =
			STRLEN(szKwDate)	// for the Date keyword
			+ 1					// space following the keyword
			+ cMaxArpaDate		// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxDate);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	char szDateBuf[cMaxArpaDate];

	//
	// Start with "Date: ", then add the date and the newline
	//

	pcLine << szKwDate << (char) ' ' << (GetArpaDate(szDateBuf)) << "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxDate-1 >= pcLine.m_cch);//real

	if (!article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}

/*
Organization: Optional  But if not and default is given, create
The Organization header content is a short phrase  identify-ing the posters organization:
Organization-content = nonblank-text
This header is typically supplied by the posting agent.  The Organization content SHOULD  mention  geographical  location (e.g.  city  and  country)  when  it is not obvious from the organization?s name.  policy.  Posting agents SHOULD permit the poster t


o override a local default Organization header.
*/

BOOL
CFromClientOrganizationField::fSet(
   				   				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Optional, But if not given my user and default is given, create


Arguments:

	country -


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

//
//!!!CLIENT NEXT - add this code
//

	return nntpReturn.fSetOK();
}

//
//!!!constize
//

/*
Restricted Syntax
The  From header contains the electronic address, and possibly the full name, of the articles author:
From-content  = address [ space "(" paren-phrase ")" ]
/  [ plain-phrase space ] "<" address ">"
paren-phrase  = 1*( paren-char / space / encoded-word )
paren-char    = <ASCII printable character except ()<>\>
plain-phrase  = plain-word *( space plain-word )
plain-word    = unquoted-word / quoted-word / encoded-word
unquoted-word = 1*unquoted-char
unquoted-char = <ASCII printable character except !()<>@,;:\".[]>
               quoted-word   = quote 1*( quoted-char / space ) quote
               quote         = <" (ASCII 34)>
               quoted-char   = <ASCII printable character except "()<>\>
               address       = local-part "@" domain
               local-part    = unquoted-word *( "." unquoted-word )
               domain        = unquoted-word *( "." unquoted-word )

(Encoded words are described in section 4.5.)  The full name is  distinguished  from  the  electronic  address  either by enclosing the former in parentheses (making  it  resemble  a MAIL  comment, after the address) or by enclosing the latter in angle br


ackets.  The second form is  preferred.   In  the first  form, encoded words inside the full name MUST be composed  entirely  of  <paren-char>s.   In  the  second  form, encoded  words  inside the full name may not contain characters other than letters (o

f either case),  digits,  and  the characters "!", "*", "+", "-", "/", "=", and "_".  The local part is case-sensitive (except that all case counterparts of "postmaster"  are  deemed  equivalent),  the domain is case-insensitive, and all other parts of  t


he  From  content  are comments  which  MUST  be  ignored  by news software (except insofar as reading agents may wish to display  them  to  the reader).   Posters  and  posting  agents MUST restrict them-selves to this subset of the MAIL From syntax; rel


ayers  MAY accept  a  broader subset, but see the discussion in section 9.1.
Avoid "!" and "@" in full names
Posters  and  posting agents SHOULD avoid use of the characters "!" and "@" in full names, as they may trigger unwanted header rewriting by old, simple-minded news software.
"." and "," must be quoted
NOTE: Also, the characters "." and ",", not infrequently found in names (e.g., "John  W.  Campbell, Jr."), are NOT, repeat NOT, allowed in an unquoted word.  A From header like the following  MUST  not be written without the quotation marks:
                    From:	"John W. Campbell, Jr." <editor@analog.com>

*/
/*
 Three permissible forms documented in RFC 1036 should be supported.  Full names within this header line can only contain printable ASCII (0x20 to 0x7E) except "(", ")", "<", ">".  The following characters are inadvisable: ",", ":", "@", "!", "/", "=", ";


".  Test cases include non-printable characters, empty header line (can?t be empty), missing/duplicate "@" address delimiter, multiple address, name lists (not supported), missing address, invalid address, inadvisable characters in name, etc.
 */

BOOL
CFromClientXAuthLoginNameField::fSet(
				 				 CFromClientArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	replace with our value


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsInitialized == m_fieldState);//real
	CPCString pcLine;


	//
	// max size needed is
	//

	const DWORD cchMaxXAuthLoginName =
			STRLEN(szKwXAuthLoginName)	// for the XAuthLoginName keyword
			+ 1					// space following the keyword
			+ cMaxLoginName		// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxXAuthLoginName);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "XAuthLoginName: "
	//

	wsprintf(pcLine.m_pch, "%s ", szKwXAuthLoginName);
	pcLine.m_cch = STRLEN(szKwXAuthLoginName)	+ 1;

	//
	// Add the data value and newline
	//

	pcLine << (article.m_szLoginName) << "\r\n";
	pcLine.vMakeSz(); // Terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxXAuthLoginName-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwXAuthLoginName, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.m_pAllocator->Free(pcLine.m_pch);

		return nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}






//
//!!!CLIENT NEXT: In Newsgroups: parse need to check for illegal groups like "control" and "poster"
//

/*
Followup-To: Optional
Email address is not allowed. Like newsgroups line or "poster" (capitalization?)
NOTE: The way to request that followups be  mailed to  a specific address other than that in the From line is  to  supply  "Followup-To: poster"  and  a Reply-To header.  Putting a mailing address in the Followup-To  line  is  incorrect;  posting  agent

should reject or rewrite such headers.
*/
/*
Reply-To: Optional
Must be a valid email address
*/

/*

//
///!!!CLIENT NEXT should Hubname be lower case?
///!!!CLIENT NEXT should Hubname be the domain name (for message id?)
//

/*
Message-ID: Replace any with own
How to create a messageid
5.3. Message-ID
The  Message-ID  header contains the articles message ID, a unique identifier  distinguishing  the  article  from  every other article:
Message-ID-content  = message-id
message-id          = "<" local-part "@" domain ">"
As  with  From addresses, a message IDs local part is case-sensitive and its domain is case-insensitive.  The  "<"  and ">"  are  parts  of the message ID, not peculiarities of the Message-ID header.
NOTE: News message IDs are a restricted subset  of MAIL message IDs.  In particular, no existing news software copes properly with MAIL quoting  conventions  within  the local part, so they are forbid-den.  This is unfortunate, particularly for  X.400 gat

es on gatewaying in section 10.
The domain in the message ID SHOULD  be  the  full  Internet domain name of the posting agent?s host.  Use of the ".uucp" pseudo-domain (for hosts registered in the UUCP maps) or the ".bitnet"  pseudo-domain  (for Bitnet hosts) is permissible, but SHOUL

be avoided.
Posters and posting agents MUST generate the local part of a
message ID using an algorithm which obeys the specified syn-
tax (words separated by ".",  with  certain  characters  not
permitted)  (see  section  5.2  for  details),  and will not repeat itself (ever).  The  algorithm  SHOULD  not  generate message  IDs which differ only in case of letters.  Note the specification in section 6.5 of a recommended convention for indicatin

 subject  changes.  Otherwise the algorithm is up to the implementor.
NOTE: The crucial use of message IDs is to distinguish  circulating  articles  from  each other and from articles circulated recently.  They are  also potentially  useful  as  permanent  indexing keys, hence the requirement for permanent  uniqueness...  b


ut   indexers  cannot  absolutely  rely  on  this because the earlier RFCs  urged  it  but  did  not demand  it.  All major implementations have always generated  permanently-unique   message   IDs   by design,  but  in  some  cases this is sensitive to p


roper administration,  and  duplicates  may  have occurred by accident.
NOTE:  The most popular method of generating local parts is to use the date and time, plus  some  way of distinguishing between simultaneous postings on the same host (e.g. a process number), and  encode them  in a suitably-restricted alphabet.  An olde

but now  less-popular  alternative  is  to  use  a sequence  number,  incremented  each time the host generates a new message ID; this is workable,  but requires  careful  design  to  cope  properly with simultaneous  posting  attempts,  and  is  not  a

robust  in  the presence of crashes and other malfunctions.
NOTE: Some buggy news software  considers  message
IDs  completely case-insensitive, hence the advice
to  avoid  relying  on  case  distinctions.    The
restrictions  placed  on  the  "alphabet" of local
parts and domains in section 5.2 have  the  useful side effect of making it unnecessary to parse message IDs in complex ways to break them into  case-sensitive and case-insensitive portions.

*/
BOOL
CFromClientMessageIDField::fSet(
				 				 CFromClientArticle  & article,
								 CPCString & pcHub,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Replaces any messageid field, with a newly created one.


  Form: <1993Jun27.0645330123.1778.343@localmachinename>

Arguments:

	article - The article being processed.
	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	if( m_fieldState == fsParsed ) {
		return	nntpReturn.fSetOK() ;
	}

	CPCString pcLine;


	//
	// max size needed is
	//

#if 0
	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					// space following the keyword
			+ 5					// <..@>
			+ cMaxMessageIDDate // The message id date
			+ 20				// Two dwords
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ 1; // for a terminating null
#endif

	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					// space following the keyword
			+ 4					// <..@>
			+ cMaxMessageIDDate // The message id date
			+ 10				// One dword
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// The message-id created (without the newlines) must be less than the max
	//

	_ASSERT(cchMaxMessageID - 2 < MAX_MSGID_LEN);

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxMessageID);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "MessageID: <"
	//

	wsprintf(pcLine.m_pch, "%s <", szKwMessageID);
	pcLine.m_cch = STRLEN(szKwMessageID)	+ 2;

	char szMessageIDBuf[cMaxMessageIDDate];

	CArticleRef artRef = article.articleRef();

	pcLine
			//
			// Add the local part
			//
			<< (GetMessageIDDate( artRef.m_groupId, artRef.m_articleId, szMessageIDBuf))
			<< (char) '.'
			//<< (GetCurrentProcessId())
			//<< '.'
			<< (const DWORD) (GetCurrentThreadId())
			//
			// Add '@' and domain and '>' and newline
			//
			<< (char) '@'
			<< pcHub ///!!!CLIENT NEXT I need the local machine rather than the hub
			<< ">\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	//_ASSERT(cchMaxMessageID-1-STRLEN(szKwMessageID)-1 >= pcLine.m_cch);//real
	_ASSERT(cchMaxMessageID >= pcLine.m_cch+1);//real

	if (!(
  		article.fRemoveAny(szKwMessageID, nntpReturn)//!!!CLIENT NEXT -- this really only needs to be called of state is parsed
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}


	//
	//Also save the value (without newlines but with room for a terminating
	//a '\0') in m_szMessageID
	//

	DWORD cchMessageID = pcLine.m_cch - 2 - STRLEN(szKwMessageID) - 1;
	strncpy(m_szMessageID, pcLine.m_pch + STRLEN(szKwMessageID)	+ 1, cchMessageID);
	m_szMessageID[cchMessageID] ='\0';
	_ASSERT('<' == m_szMessageID[0] && '>' == m_szMessageID[cchMessageID-1]);


	return nntpReturn.fSetOK();
}


BOOL
CFromClientPathField::fSet(
						   CFromClientArticle & article,
						   CPCString & pcHub,
						   CNntpReturn & nntpReturn
						   )
/*++

Routine Description:


	Replaces any existing Path header with a newly created one that
	contains only the name of the hub.


Arguments:

	article - The article being processed.
	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsInitialized != m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is
	//

	DWORD	cbOldPath = 0 ;
	if( m_pHeaderString && m_pHeaderString->pcValue.m_pch ) {
		cbOldPath = m_pHeaderString->pcValue.m_cch + 1 ;	//include 1 for extra '!'
	}

	const DWORD cchMaxPath =
			STRLEN(szKwPath)	// for the Path keyword
			+ 1					// space following the keyword
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ cbOldPath // in case there already is a path header !
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxPath);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Path: <hubname>"
	//

	pcLine << szKwPath << (char) ' ' << pcHub ;		//	<< "\r\n";

	if( m_pHeaderString && m_pHeaderString->pcValue.m_pch ) {
		_ASSERT( m_pHeaderString->pcValue.m_cch != 0 ) ;
		pcLine << "!" << (m_pHeaderString->pcValue) ;
	}

	pcLine << "\r\n" ;

	pcLine.vMakeSz();

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxPath-1 == pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwPath, nntpReturn)//!!!CLIENT NEXT -- this really only needs to be called of state is parsed
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);

		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromClientNNTPPostingHostField::fSet(
									  CFromClientArticle & article,
									  DWORD remoteIpAddress,
									  CNntpReturn & nntpReturn
									  )
/*++

Routine Description:

	Behavior is governed by global set by a reg key.
	In any case, this removes any old NNTPPostingHost headers.

	If global is set, a new NNTP-Posting-Host header is added
	else no new header is added. default behavior is to NOT add
	this header.

Arguments:

	article - The article being processed.
	remoteIpAddress - client IP address
	nntpReturn - The return value for this function call



Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state - article validation should have rejected this
    // post if this header was present.
	//

	_ASSERT(fsNotFound == m_fieldState);//real

	//
	//	generate header only if reg key is set
	//	if an error occurs, revert to default behavior
	//
	while ( gEnableNntpPostingHost ) {

		IN_ADDR remoteAddr;
		char szIpAddress [16];
		DWORD cbIpAddr = 0;
		struct hostent* pRemoteHost = NULL;
		DWORD cbRemoteHost = 0;

        // Convert IP to dotted decimal format
        _ASSERT( sizeof(remoteAddr) == sizeof(remoteIpAddress) );
        CopyMemory( (LPVOID)&remoteAddr, (LPVOID)&remoteIpAddress, sizeof(remoteIpAddress) );
	    DWORD dwError = InetNtoa( remoteAddr, szIpAddress);
		_ASSERT( dwError == NO_ERROR);  // since we had given sufficient buffer
		cbIpAddr = lstrlen( szIpAddress );

		//
		// Do a reverse DNS lookup on client IP
		//

		pRemoteHost = gethostbyaddr( (const char FAR*) &remoteIpAddress, sizeof( remoteIpAddress), PF_INET );
		if( pRemoteHost != NULL ) {
			cbRemoteHost = lstrlen( pRemoteHost->h_name ) + 1;
		}

		// calculate length of header
		DWORD cchMaxHost =
				STRLEN(szKwNNTPPostingHost)	// for the NNTPPostingHost keyword
				+ 1							// space following the keyword
				+ cbRemoteHost				// the reverse DNS name followed by space
//				+ 2							// enclosing []
				+ cbIpAddr					// dotted-decimal IP address
				+ 2							// for the newline
				+ 1;						// for a terminating null

		CPCString pcLine;

		//
		// Allocate memory for line within a PCString.
		//

		pcLine.m_pch  = article.pAllocator()->Alloc( cchMaxHost );
		if (!pcLine.m_pch)
			break;

		//
		// NNTP-Posting-Host: <reverse DNS lookup name> <[dotted-decimal IP address]\r\n
		//
		pcLine << szKwNNTPPostingHost << (char) ' ';
		if( pRemoteHost != NULL ) {
			pcLine << pRemoteHost->h_name << (char) ' ';
		}

		pcLine << szIpAddress << "\r\n";
		pcLine.vMakeSz();

		//
		// confirm that we allocated enough memory
		//
		_ASSERT(cchMaxHost-1 == pcLine.m_cch);

		if (!(
  			article.fRemoveAny(szKwNNTPPostingHost, nntpReturn)
			&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
			))
		{
			//
			// If anything went wrong, free the memory.
			//

			article.pAllocator()->Free(pcLine.m_pch);

			return nntpReturn.fFalse();
		}

		return nntpReturn.fSetOK();
	}

	//
	//	Default behavior - remove NNTP-Posting-Host header if present
	//
	return article.fRemoveAny(szKwNNTPPostingHost, nntpReturn);

}


BOOL
CFromClientDistributionField::fParse(
									 CArticleCore & article,
									 CNntpReturn & nntpReturn
									 )
/*++

Routine Description:

  Parses the Distribution field. Here is the grammer from Son of 1036:

               Newsgroups-content  = newsgroup-name *( ng-delim newsgroup-name )
               newsgroup-name      = plain-component *( "." component )
               component           = plain-component / encoded-word
               plain-component     = component-start *13component-rest
               component-start     = lowercase / digit
               lowercase           = <letter a-z>
               component-rest      = component-start / "+" / "-" / "_"
               ng-delim            = ","


Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	if (!fParseSplit(TRUE, m_multiSzDistribution, m_cDistribution, " \t\r\n,",
			article, nntpReturn))
		return FALSE;

	//
	//Check for duplicates
	//

	DWORD cOldCount = m_cDistribution;
	if (!fMultiSzRemoveDupI(m_multiSzDistribution, m_cDistribution, m_pAllocator))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if( m_cDistribution == 0 ) {
		return	nntpReturn.fSetOK() ;
	}

	//
	// check for illegal characters and substrings in Distribution name
	//

	char const * szDistribution = m_multiSzDistribution;
	do
	{
		if ('\0' == szDistribution[0]
			|| !fTestAComponent(szDistribution)
			)
		return nntpReturn.fSet(nrcArticleFieldIllegalComponent, szDistribution, szKeyword());

		//
		// go to first char after next null
		//

		while ('\0' != szDistribution[0])
			szDistribution++;
		szDistribution++;
	} while ('\0' != szDistribution[0]);

	return nntpReturn.fSetOK();
}

BOOL
CFromClientLinesField::fParse(
						 CArticleCore & article,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Parses the Lines field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real

	if (!fParseSimple(TRUE, m_pc, nntpReturn))
		return nntpReturn.fFalse();

	char * pchMax = m_pc.pchMax();
	for (char * pch = m_pc.m_pch; pch < pchMax; pch++)
	{
		if (!isdigit(*pch))
			return nntpReturn.fSet(nrcArticleFieldBadChar, (BYTE) *pch, szKeyword());
	}

	return nntpReturn.fSetOK();
}

BOOL
CFromClientReferencesField::fParse(
								   CArticleCore & article,
								   CNntpReturn & nntpReturn
								   )
/*++

Routine Description:

	Parses the References field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	if (!fParseSplit(FALSE, m_multiSzReferences, m_cReferences, szWSNLChars,
			article, nntpReturn))
		return nntpReturn.fFalse();

	//
	// check for illegal characters and substrings in References name
	//

	char const * szReferences = m_multiSzReferences;
	do
	{
		if (!fTestAMessageID(szReferences, nntpReturn))
			return nntpReturn.fFalse();

		//
		// go to first char after next null
		//

		while ('\0' != szReferences[0])
			szReferences++;
		szReferences++;
	} while ('\0' != szReferences[0]);

	return nntpReturn.fSetOK();
}

BOOL
CFromClientFeed::fRecordMessageIDIfNecc(
										CNntpServerInstanceWrapper * pInstance,
										const char * szMessageID,
										CNntpReturn & nntpReturn
										)
/*++

Routine Description:

	Records the MessageID of an article in article table.

Arguments:

	pInstance - virtual server instance
	szMessageID - the message id to record
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Now, insert the article
	//

	if (!(pInstance->ArticleTable())->InsertMapEntry(szMessageID))
		return nntpReturn.fSet(nrcArticleDupMessID, szMessageID, GetLastError());

	return nntpReturn.fSetOK();
}

#if 0
//
// This function handles picking up files from the pickup directory.
//
// parameters:
// 		pvInstance [in] - a void pointer to the current instance
//		pwszFilename [in] - the filename that was detected in the pickup dir
// returns:
//		TRUE - the file was handled.  if TRUE is returned than directory
//				notification won't put this file on the retryq.
//		FALSE - the file was not handled.  this causes the file to be put
//				onto the retry q.  PickupFile will be called with this file
//				again.
// notes:
//  	pInstance->IncrementPickupCount() and DecrementPickupCount() should
//		be used to keep track of the number of threads which are currently
//		in this method.  the instance won't shutdown until there are no
// 		threads in this method.
//
BOOL CFromClientFeed::PickupFile(PVOID pvInstance, WCHAR *pwszFilename) {
	DWORD dwFileSizeHigh = 0;
    ULARGE_INTEGER liStart;
    ULARGE_INTEGER liNow;
    FILETIME now;


	TraceFunctEnter("CFromClientFeed::PickupFile");

    GetSystemTimeAsFileTime(&now);
    LI_FROM_FILETIME(&liStart, &now);

	CNntpServerInstanceWrapper *pInstance = (NNTP_SERVER_INSTANCE *) pvInstance;

	pInstance->IncrementPickupCount();

	//
	// Check to see if the instance is good !
	//
	if( !CheckIISInstance( pInstance ) ) {
		ErrorTrace(0,"Instance %d not runnable", pInstance->QueryInstanceId() );
		pInstance->DecrementPickupCount();
		TraceFunctLeave();
		// we return TRUE so that this item isn't put back onto the retry q
		return TRUE;
	}

	//
	// open the file
	//
	HANDLE hFile = CreateFileW(pwszFilename, GENERIC_READ | GENERIC_WRITE,
							   0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		if (GetLastError() == ERROR_FILE_NOT_FOUND) {
			ErrorTrace(0, "%S reported in pickup dir, but doesn't exist",
				pwszFilename);
			pInstance->DecrementPickupCount();
			TraceFunctLeave();
			return TRUE;
		} else {
			ErrorTrace(0, "%S reported in pickup dir, can't open, retry later",
				pwszFilename);
			pInstance->DecrementPickupCount();
			TraceFunctLeave();
			return FALSE;
		}
	}

	//
	// handle 0 length files - zap 'em !
	//

	if( !GetFileSize( hFile, &dwFileSizeHigh ) && !dwFileSizeHigh ) {
		ErrorTrace(0,"%S is zero length - deleting", pwszFilename);
		_VERIFY( CloseHandle( hFile ) );
		DeleteFileW( pwszFilename );
		pInstance->DecrementPickupCount();
		TraceFunctLeave();
		return TRUE;
	}

	//
	// post this file
	//
	CInFeed *pFeed;

	pFeed = pInstance->NewClientFeed();
	if (pFeed == NULL) {
		ErrorTrace(0, "couldn't allocate CFromClientFeed to handle %S",
			pwszFilename);
		pInstance->DecrementPickupCount();
		TraceFunctLeave();
		return FALSE;
	}
	pFeed->fInit(pInstance->m_pFeedblockDirPickupPostings,
				 pInstance->m_PeerTempDirectory,
				 0,
				 0,
				 0,
				 FALSE,
				 TRUE,
				 pInstance->m_pFeedblockDirPickupPostings->FeedId);

	//
	// memory map the file
	//
	CMapFile map(hFile, TRUE, FALSE, 0);
	if (!map.fGood()) {
		// the memory map failed, put it on the retry queue
		ErrorTrace(0, "%S reported in pickup dir, can't map, retry later",
			pwszFilename);
		delete pFeed;
		pInstance->DecrementPickupCount();
		TraceFunctLeave();
		return FALSE;
	}
	DWORD cMapBuffer;
	char *pMapBuffer = (char *) map.pvAddress(&cMapBuffer);
	BOOL fSuccess = TRUE;

	//
	// a valid buffer needs to be at least 9 bytes long (to contain
	// \r\n\r\n\r\n.\r\n and pass the next two tests.  we aren't
	// assuming anything about what headers need to be here, we'll
	// let fPost handle that).
	//
	CNntpReturn nr;
	DWORD	dwSecondary;
	char szMessageID[MAX_PATH] = "";
	char szGroups[MAX_PATH] = "";

	if (cMapBuffer >= 9) {
		//
		// make sure the article ends with \r\n.\r\n.  we scan for it, and
		// when we find it we set pDot to point at it.
		//
		char *pDot = pMapBuffer + (cMapBuffer - 5);
		while (fSuccess && memcmp(pDot, "\r\n.\r\n", 5) != 0) {
			pDot--;
			if (pDot == pMapBuffer) fSuccess = FALSE;
		}

		if (fSuccess) {
			//
			// find the end of the headers
			//
			char *pEndBuffer = pMapBuffer + (cMapBuffer - 1);
			char *pBodyStart = pMapBuffer;
			while (fSuccess && memcmp(pBodyStart, "\r\n\r\n", 4) != 0) {
				pBodyStart++;
				if (pBodyStart >= pEndBuffer - 4) fSuccess = FALSE;
			}

			_ASSERT(pBodyStart > pMapBuffer);
			_ASSERT(pDot < pEndBuffer);
			_ASSERT(pBodyStart < pEndBuffer);

			// this can happen if there is junk after the \r\n.\r\n that includes
			// a \r\n\r\n
			if (pBodyStart >= pDot) fSuccess = FALSE;

			if (fSuccess) {
				// pBodyStart points to the \r\n\r\n now, point it at the real
				// body
				pBodyStart += 4;
				DWORD cbHead = pBodyStart - pMapBuffer;
				DWORD cbArticle = (pDot + 5) - pMapBuffer;
				//
				// pass it into the feed's post method
				//
				fSuccess = pFeed->fPost(pInstance,
										NULL,
										NULL,
										pMapBuffer,
										cbHead,
										cbArticle,
										cMapBuffer,
										szMessageID,
										MAX_PATH,
										szGroups,
										MAX_PATH,
										0,
										nr,
										dwSecondary
										);
			} else {
				// we couldn't find the \r\n\r\n between the headers and body
				nr.fSet(nrcPostFailed, dwSecondary, "Bad Article");
				dwSecondary = nrcArticleIncompleteHeader;
			}
		} else {
			// the buffer didn't contain the trailing .
			nr.fSet(nrcPostFailed, dwSecondary, "Bad Article");
			dwSecondary = nrcArticleIncompleteHeader;
		}
	} else {
		// the buffer was too short to contain the trailing .
		nr.fSet(nrcPostFailed, dwSecondary, "Bad Article");
		dwSecondary = nrcArticleIncompleteHeader;
	}

	pFeed->IncrementFeedCounter(dwSecondary);

	delete pFeed;

	//
	// close the file
	//
	UnmapViewOfFile(pMapBuffer);
	map.Relinquish();
	_VERIFY( CloseHandle(hFile) );

	WCHAR *pwszDestDirectory = pInstance->QueryFailedPickupDirectory();

	// check the status and act appropriately
	if (fSuccess || pwszDestDirectory[0] == (WCHAR) 0) {
		// the post was successful, delete the file
		if (!DeleteFileW(pwszFilename)) {
			ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
				pwszFilename, GetLastError());
//			_ASSERT(FALSE);
		}
	} else {
		// the post failed, move the file to a badarticles directory
		WCHAR wszDest[MAX_PATH + 1];
		WCHAR *pwszBasename = pwszFilename + lstrlenW(pwszFilename);
		while (pwszBasename[-1] != L'\\' && pwszBasename > pwszFilename)
			*pwszBasename--;
		lstrcpyW(wszDest, pwszDestDirectory);
		lstrcatW(wszDest, pwszBasename);

		if (!MoveFileExW(pwszFilename, wszDest, MOVEFILE_COPY_ALLOWED)) {
			ErrorTrace(0, "MoveFileW(%S, %S) failed with %lu",
				pwszFilename, wszDest, GetLastError());

			// if this failed then we need to make a unique name to copy
			// to
			UINT cDest = GetTempFileNameW(pwszDestDirectory, L"nws", 0,
				wszDest);

			// this can fail if the bad articles directory has all temp file
			// names used or if the directory doesn't exist
			if (cDest == 0) {
				ErrorTrace(0, "GetTempFileNameW failed with %lu", GetLastError());
				if (!DeleteFileW(pwszFilename)) {
					ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
						pwszFilename, GetLastError());
					_ASSERT(FALSE);
				}
			} else {
				// GetTempFileName creates a 0 byte file with the name wszDest,
				// so we need to allow copying over that
				if (!MoveFileExW(pwszFilename, wszDest, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {
					// this should never happen.  just in case it does we just
					// delete the file
					ErrorTrace(0, "MoveFile(%S, %S) failed with %lu",
						pwszFilename, wszDest, GetLastError());
					if (!DeleteFileW(pwszFilename)) {
						ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
							pwszFilename, GetLastError());
//						_ASSERT(FALSE);
					}
				}
			}
		}
	}

	//
	// we log an event if they have event logging turned on for the Post
	// command and if this is an error or if they have erroronly logging
	// turned off
	//
	if (pInstance->GetCommandLogMask() & ePost &&
		((!(pInstance->GetCommandLogMask() & eErrorsOnly)) ||
		 (NNTPRET_IS_ERROR(nr.m_nrc))))
	{
		//
		// make a transaction log event
		//
	    INETLOG_INFORMATION request;			// log information
		char szFilename[MAX_PATH];				// the filename in ascii
		if (!WideCharToMultiByte(CP_ACP, 0, pwszFilename, -1, szFilename, MAX_PATH, NULL, NULL)) szFilename[0] = 0;

		// build the request structure
		ZeroMemory( &request, sizeof(request));
		request.pszClientUserName = "<pickup>";
	    // How long were we processing this?
	    GetSystemTimeAsFileTime( &now );
	    LI_FROM_FILETIME( &liNow, &now );
	    liNow.QuadPart -= liStart.QuadPart;
	    liNow.QuadPart /= (ULONGLONG)( 10 * 1000 );
	    request.msTimeForProcessing = liNow.LowPart;
		request.dwWin32Status = dwSecondary;
		request.dwProtocolStatus = nr.m_nrc;
		request.pszOperation = "post";
		request.cbOperation  = 4;
		if (*szMessageID != 0) {
			request.pszTarget = szGroups;
			request.cbTarget = lstrlen(szGroups);
		}
		if (*szGroups != 0) {
			request.pszParameters = szMessageID;
		}

		// log the event
	    if (pInstance->m_Logging.LogInformation(&request) != NO_ERROR) {
	        ErrorTrace(0,"Error %d Logging information!", GetLastError());
	    }
	}

	pInstance->DecrementPickupCount();
	TraceFunctLeave();
	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\frompeer.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to Peer Infeeds


Author:

    Carl Kadie (CarlK)     12-Dec-1995

Revision History:

--*/


#include "stdinc.h"


BOOL
CFromPeerArticle::fValidate(
						CPCString& pcHub,
						const char * szCommand,
						CInFeed*	pInFeed,
				  		CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	Validates an article from a peer. Does not change the article.

Arguments:

	szCommand - The arguments (if any) used to post/xreplic/etc this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	/* Son of 1036 says:
          An article MUST have one, and only one, of each of the  fol-
          lowing headers: Date, From, Message-ID, Subject, Newsgroups,
          Path.
		  */

	//
	// Check the message id first
	//

	if (!m_fieldMessageID.fFindAndParse(*this, nntpReturn))
			return nntpReturn.fFalse();

	if (m_pInstance->ArticleTable()->SearchMapEntry(m_fieldMessageID.szGet())
		|| m_pInstance->HistoryTable()->SearchMapEntry(m_fieldMessageID.szGet()))
	{
		nntpReturn.fSet(nrcArticleDupMessID, m_fieldMessageID.szGet(), GetLastError());
		return nntpReturn.fFalse();
	}
	
	//
	// From here on, we want to add an entry to the history table
	// even if the article was rejected.
	//

	//
	// Create a list of the fields of interest
	//

	CField * rgPFields [] = {
            &m_fieldControl,
			&m_fieldDate,
			&m_fieldLines,
			&m_fieldFrom,
			&m_fieldSubject,
			&m_fieldNewsgroups,
			&m_fieldDistribution,
			&m_fieldPath
				};

	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);

	nntpReturn.fSetOK(); // assume the best

	if (fFindAndParseList((CField * *)rgPFields, cFields, nntpReturn))
	{
		//
		// check that this hub does not appear as a relayer in the path
		//
		m_fieldPath.fCheck(pcHub, nntpReturn);
	}

	CPCString	pcDate = m_fieldDate.pcGet() ;
	if( pcDate.m_pch != 0 ) {
	
		if( !AgeCheck( pcDate ) ) {
			nntpReturn.fSet( nrcArticleDateTooOld ) ;

			//
			//	Most errors we should store the message-id in the hash tables
			//	so that they can make into the history table later.  But if we 
			//	did that in this case, then by sending us article with old dates
			//	we could be forced to overflow our History Table.  We know that 
			//	we will reject the article if it comes around again - so why bother ?
			//

			return	FALSE ;
		}
	}

	//
	// Even if parsing and the path check failed, insert the article's
	// message id in the article table.
	//

	if (!m_pInstance->ArticleTable()->InsertMapEntry(m_fieldMessageID.szGet(), NULL))
		return nntpReturn.fSet(nrcHashSetFailed, m_fieldMessageID.szGet(), "Article",
				GetLastError() );

	// nntpReturn.fIsOK could be true or false depending on how find/parse and path
	// check went.
	//

	return nntpReturn.fIsOK();
}


BOOL
CFromPeerArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn,
							 PDWORD     pdwLinesOffset
			  )
/*++

Routine Description:


	 Modify the headers.


Arguments:

	grouplist - a list of newsgroups to post to (name, groupid, article id)
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	if (!(
  			m_fieldPath.fSet(pcHub, *this, nntpReturn)
			&& m_fieldLines.fSet(*this, nntpReturn)
			&& m_fieldXref.fSet(pcHub, grouplist, *this, m_fieldNewsgroups, nntpReturn)
			&& fSaveHeader(nntpReturn)
		))
		return nntpReturn.fFalse();

	//
	// If we the lines line was already there, we'll tell the caller not
	// to back fill the lines information
	//
	if ( pdwLinesOffset && !m_fieldLines.fNeedBackFill() )
	    *pdwLinesOffset = INVALID_FILE_SIZE;

	return nntpReturn.fSetOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\stdinc.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\nntpsupp.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nntpsupp.cpp

Abstract:

    This module contains support routines for the Tigris server

Author:

    Johnson Apacible (JohnsonA)     18-Sept-1995

Revision History:

--*/

#include "stdinc.h"

//
//  Taken from NCSA HTTP and wwwlib.
//  (Copied from Gibraltar code -johnsona)
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = (int)(bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    return TRUE;
}

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded )
{
   unsigned char *outptr;
   unsigned int i;

   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   for (i=0; i<nbytes; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   /* If nbytes was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
   if(i == nbytes+1) {
      /* There were only 2 bytes in that last group */
      outptr[-1] = '=';
   } else if(i == nbytes+2) {
      /* There was only 1 byte in that last group */
      outptr[-1] = '=';
      outptr[-2] = '=';
   }

   *outptr = '\0';

   return TRUE;
}

DWORD
NntpGetTime(
    VOID
    )
{
    NTSTATUS      ntStatus;
    LARGE_INTEGER timeSystem;
    DWORD         cSecondsSince1970 = 0;

    ntStatus = NtQuerySystemTime( &timeSystem );
    if( NT_SUCCESS(ntStatus) ) {
        RtlTimeToSecondsSince1970( &timeSystem, (PULONG)&cSecondsSince1970 );
    }

    return cSecondsSince1970;

} // NntpGetTime

#if 0
//
// Used to map a BYTE to a WORD in reverse order
//

WORD ch2word[256] = {
    0x0000, 0x8000, 0x2000, 0xa000, 0x0800, 0x8800, 0x2800, 0xa800,
    0x0200, 0x8200, 0x2200, 0xa200, 0x0a00, 0x8a00, 0x2a00, 0xaa00,
    0x0080, 0x8080, 0x2080, 0xa080, 0x0880, 0x8880, 0x2880, 0xa880,
    0x0280, 0x8280, 0x2280, 0xa280, 0x0a80, 0x8a80, 0x2a80, 0xaa80,
    0x0020, 0x8020, 0x2020, 0xa020, 0x0820, 0x8820, 0x2820, 0xa820,
    0x0220, 0x8220, 0x2220, 0xa220, 0x0a20, 0x8a20, 0x2a20, 0xaa20,
    0x00a0, 0x80a0, 0x20a0, 0xa0a0, 0x08a0, 0x88a0, 0x28a0, 0xa8a0,
    0x02a0, 0x82a0, 0x22a0, 0xa2a0, 0x0aa0, 0x8aa0, 0x2aa0, 0xaaa0,

    0x0008, 0x8008, 0x2008, 0xa008, 0x0808, 0x8808, 0x2808, 0xa808,
    0x0208, 0x8208, 0x2208, 0xa208, 0x0a08, 0x8a08, 0x2a08, 0xaa08,
    0x0088, 0x8088, 0x2088, 0xa088, 0x0888, 0x8888, 0x2888, 0xa888,
    0x0288, 0x8288, 0x2288, 0xa288, 0x0a88, 0x8a88, 0x2a88, 0xaa88,
    0x0028, 0x8028, 0x2028, 0xa028, 0x0828, 0x8828, 0x2828, 0xa828,
    0x0228, 0x8228, 0x2228, 0xa228, 0x0a28, 0x8a28, 0x2a28, 0xaa28,
    0x00a8, 0x80a8, 0x20a8, 0xa0a8, 0x08a8, 0x88a8, 0x28a8, 0xa8a8,
    0x02a8, 0x82a8, 0x22a8, 0xa2a8, 0x0aa8, 0x8aa8, 0x2aa8, 0xaaa8,

    0x0002, 0x8002, 0x2002, 0xa002, 0x0802, 0x8802, 0x2802, 0xa802,
    0x0202, 0x8202, 0x2202, 0xa202, 0x0a02, 0x8a02, 0x2a02, 0xaa02,
    0x0082, 0x8082, 0x2082, 0xa082, 0x0882, 0x8882, 0x2882, 0xa882,
    0x0282, 0x8282, 0x2282, 0xa282, 0x0a82, 0x8a82, 0x2a82, 0xaa82,
    0x0022, 0x8022, 0x2022, 0xa022, 0x0822, 0x8822, 0x2822, 0xa822,
    0x0222, 0x8222, 0x2222, 0xa222, 0x0a22, 0x8a22, 0x2a22, 0xaa22,
    0x00a2, 0x80a2, 0x20a2, 0xa0a2, 0x08a2, 0x88a2, 0x28a2, 0xa8a2,
    0x02a2, 0x82a2, 0x22a2, 0xa2a2, 0x0aa2, 0x8aa2, 0x2aa2, 0xaaa2,

    0x000a, 0x800a, 0x200a, 0xa00a, 0x080a, 0x880a, 0x280a, 0xa80a,
    0x020a, 0x820a, 0x220a, 0xa20a, 0x0a0a, 0x8a0a, 0x2a0a, 0xaa0a,
    0x008a, 0x808a, 0x208a, 0xa08a, 0x088a, 0x888a, 0x288a, 0xa88a,
    0x028a, 0x828a, 0x228a, 0xa28a, 0x0a8a, 0x8a8a, 0x2a8a, 0xaa8a,
    0x002a, 0x802a, 0x202a, 0xa02a, 0x082a, 0x882a, 0x282a, 0xa82a,
    0x022a, 0x822a, 0x222a, 0xa22a, 0x0a2a, 0x8a2a, 0x2a2a, 0xaa2a,
    0x00aa, 0x80aa, 0x20aa, 0xa0aa, 0x08aa, 0x88aa, 0x28aa, 0xa8aa,
    0x02aa, 0x82aa, 0x22aa, 0xa2aa, 0x0aaa, 0x8aaa, 0x2aaa, 0xaaaa
    };


WORD
MyRand(
    IN DWORD& seed,
	IN DWORD	val
    )
{
    DWORD next = seed;
    next = (seed*val) * 1103515245 + 12345;   // magic!!
	seed = next ;
    return (WORD)((next/65536) % 32768);
}

HASH_VALUE
IDHash(
    IN DWORD Key1,
    IN DWORD Key2
    )
/*++

Routine Description:

    Used to find the hash value given 2 numbers. (Used for articleid + groupId)

Arguments:

    Key1 - first key to hash.  MS bit mapped to LSb of hash value
    Key2 - second key to hash.  LS bit mapped to MS bit of hash value.

Return Value:

    Hash value

--*/
{
    HASH_VALUE val;

#if 0
    WORD hiWord;
    WORD loWord;
    BYTE hiByte;
    BYTE loByte;

    //
    // Do Key1 first
    //

    loByte = Key1 & 0x00ff;
    hiByte = (Key1 & 0xff00) >> 8;

    loWord = ch2word[loByte] >> 1;
    hiWord = ch2word[hiByte] >> 1;

    val = (DWORD)(loWord << 16) | (DWORD)hiWord;

    //
    // ok, now do Key2
    //

    loByte = Key2 & 0x00ff;
    hiByte = (Key2 & 0xff00) >> 8;

    loWord = ch2word[loByte];
    hiWord = ch2word[hiByte];

    val |= (DWORD)(loWord << 16) | (DWORD)hiWord | (DWORD)Key2;
#endif

#if 0
    //
    // Do Key1 first
    //

    val = MyRand(Key1);
    val |= ( MyRand(Key1) << 15);
    val |= ( MyRand(Key1) << 30);

    //
    // ok, now do Key2
    //

    val ^= MyRand(Key2);
    val ^= ( MyRand(Key2) << 15);
    val ^= ( MyRand(Key2) << 30);
#endif

    DWORD	val1 = 0x80000000, val2 = 0x80000000;

    //
    // Do Key1 first
    //

	DWORD	lowBits = Key2 & 0xf ;

	DWORD	TempKey2 = Key2 & (~0xf) ;
	DWORD	seed1 = (Key2 << (Key1 & 0x7)) - Key1 ;

	Key1 = (0x80000000 - ((67+Key1)*(19+Key1)*(7+Key1)+12345)) ^ (((3+Key1)*(5+Key1)+12345) << ((Key1&0xf)+8)) ;
	TempKey2 = (0x80000000 - ((67+TempKey2)*(19+TempKey2)*(7+TempKey2)*(1+TempKey2)+12345)) ^ ((TempKey2+12345) << (((TempKey2>>4)&0x7)+8)) ;
	
	val1 -=	(MyRand( seed1, Key1 ) << (Key1 & 0xf)) ;
	val1 += MyRand( seed1, Key1 ) << (((TempKey2 >> 4) & 0x3)+4) ;
	val1 ^=	MyRand( seed1, Key1 ) << 17 ;

	DWORD	seed2 = val1 - TempKey2 ;

	val2 -= MyRand( seed2, TempKey2 >> 1 ) << (((Key1 << 3)^Key1) &0xf) ;
	val2 =  val2 + MyRand( seed2, TempKey2 ) << (13 ^ Key1) ;
	val2 ^= MyRand( seed2, TempKey2 ) << 15 ;

	
	//DWORD	val = val1 + val2 ;

	val = (val1 + val2 + 67) * (val1 - val2 + 19) * (val1 % (val2 + 67)) ;

	val += (MyRand( seed2, lowBits ) >> 3) ;

    return(val);

} // IDHash
#endif

BOOL
IsIPInList(
    IN PDWORD IPList,
    IN DWORD IPAddress
    )
/*++

Routine Description:

    Check whether a given IP is in a given list

Arguments:

    IPList - The list where the IP address is to checked against.
    IPAddress - The ip address to be checked.

Return Value:

    TRUE, if the IPAddress is in to IPList
    FALSE, otherwise.

--*/
{

    DWORD i = 0;

    //
    // If the list is empty, then there's no master.
    //

    if ( IPList == NULL ) {
        return(FALSE);
    }

    //
    // ok, search the list for it
    //

    while ( IPList[i] != INADDR_NONE ) {

        if ( IPList[i] == IPAddress ) {
            return(TRUE);
        }
        ++i;
    }

    //
    // Not found. ergo, not a master
    //

    return(FALSE);

} // IsIPInList

#if 0
//
//
// Hashing function adopted from the INN code (see copyright below)
//

/*
    Copyright 1988 Jon Zeeff (zeeff@b-tech.ann-arbor.mi.us)
    You can use this code in any manner, as long as you leave my name on it
    and don't hold me responsible for any problems with it.

 * This is a simplified version of the pathalias hashing function.
 * Thanks to Steve Belovin and Peter Honeyman
 *
 * hash a string into a long int.  31 bit crc (from andrew appel).
 * the crc table is computed at run time by crcinit() -- we could
 * precompute, but it takes 1 clock tick on a 750.
 *
 * This fast table calculation works only if POLY is a prime polynomial
 * in the field of integers modulo 2.  Since the coefficients of a
 * 32-bit polynomial won't fit in a 32-bit word, the high-order bit is
 * implicit.  IT MUST ALSO BE THE CASE that the coefficients of orders
 * 31 down to 25 are zero.  Happily, we have candidates, from
 * E. J.  Watson, "Primitive Polynomials (Mod 2)", Math. Comp. 16 (1962):
 *  x^32 + x^7 + x^5 + x^3 + x^2 + x^1 + x^0
 *  x^31 + x^3 + x^0
 *
 * We reverse the bits to get:
 *  111101010000000000000000000000001 but drop the last 1
 *         f   5   0   0   0   0   0   0
 *  010010000000000000000000000000001 ditto, for 31-bit crc
 *     4   8   0   0   0   0   0   0
 */

#define POLY 0x48000000L    /* 31-bit polynomial (avoids sign problems) */

static long CrcTable[128];

/*
 - crcinit - initialize tables for hash function
 */
void
crcinit(
    VOID
    )
{
    INT i, j;
    DWORD sum;

    for (i = 0; i < 128; ++i) {
        sum = 0;
        for (j = 7 - 1; j >= 0; --j) {
            if (i & (1 << j)) {
                sum ^= POLY >> j;
            }
        }
        CrcTable[i] = sum;
    }
} // crcinit

/*
 - hash - Honeyman's nice hashing function
 */
HASH_VALUE
INNHash(
    LPBYTE Key,
    DWORD Length
    )
{
    DWORD sum = 0;

    while ( Length-- ) {

        sum = (sum >> 7) ^ CrcTable[(sum ^ (*Key++)) & 0x7f];
    }
    return(sum);

} // INNHash
#endif

//
// From Carlk's extcmk2.cpp
//

typedef char * CHARPTR;

#if 0
Some old unit tests
	char test1[] = {'\0', '\0'};
	fMultiSzRemoveDupI(test1, 0); //=> same


	char test2[] = {'a', '\0', '\0'};
	fMultiSzRemoveDupI(test2, 1);  //=> same

	char test3[] = {'a', 'b', '\0', '\0'};
	fMultiSzRemoveDupI(test3, 1);  //=> same

	char test4[] = {'a', 'c', '\0', 'a', 'b', '\0', '\0'};
	fMultiSzRemoveDupI(test4, 2);  //=> same

	char test5[] = {'a', '\0', 'a', '\0', '\0'};
	fMultiSzRemoveDupI(test5, 2);  //=> {'a', '\0', '\0'}

	char test6[] = {'a', '\0', 'a', 'c', '\0', 'a', 'b', '\0','a', 'c', '\0', 'a', 'b', '\0','z', 'a', 'p', '\0', '\0'};
	fMultiSzRemoveDupI(test6, 6); //=> {'a', '\0', 'a', 'c', '\0', 'a', 'b', '\0','z', 'a', 'p', '\0', '\0'}


BOOL
fMultiSzRemoveDupI(char * multiSz, DWORD & c, CAllocator * pAllocator)
{
	char * * rgsz;
	char * multiSzOut = NULL; // this is only used if necessary
	DWORD k = 0;
	BOOL	fOK = FALSE; // assume the worst
	DWORD	cb = 0 ;


	rgsz = (CHARPTR *) pAllocator->Alloc(sizeof(CHARPTR) * c);
	if (!rgsz)
		return FALSE;

	char * sz = multiSz;

	for (DWORD i = 0; i < c; i++)
	{
 		_ASSERT('\0' != sz[0]); // real

		cb = lstrlen( sz ) ;

		// Look for match
		BOOL fMatch = FALSE; // assume
		for (DWORD j = 0; j < k; j++)
		{
			if (0 == _stricmp(sz, rgsz[j]))
			{
				fMatch = TRUE;
				break;
			}

		}

		// Handle match
		if (fMatch)
			{
				// If they are equal and we are not yet
				// using multiSzOut, the start it at 'sz'
				if (!multiSzOut)
					multiSzOut = sz;
			} else {
				// If the are not equal and we are using multiSzOut
				// then copy sz into multiSzOut;
				if (multiSzOut)
				{
					rgsz[k++] = multiSzOut;
					vStrCopyInc(sz, multiSzOut);
					*multiSzOut++ = '\0'; // add terminating null
				}	else	{
					rgsz[k++] = sz;
				}

			}

		// go to first char after next null
		//while ('\0' != sz[0])
		//	sz++;
		//sz++;
		sz += cb + 1 ;
		}


	fOK = TRUE;

	pAllocator->Free((char *)rgsz);


	c = k;
	if (multiSzOut)
		multiSzOut[0] = '\0';
	return fOK;
}

///!!!
// Copies the NULL, too
void
vStrCopyInc(char * szIn, char * & szOut)
{
	while (*szIn)
		*szOut++ = *szIn++;
}
#endif

DWORD
multiszLength(
			  char const * multisz
			  )
 /*
   returns the length of the multisz
   INCLUDING all nulls
 */
{
	char * pch;
	for (pch = (char *) multisz;
		!(pch[0] == '\0' && pch[1] == '\0');
		pch++)
	{};

	return (DWORD)(pch + 2 - multisz);

}

const char *
multiszCopy(
			char const * multiszTo,
			const char * multiszFrom,
			DWORD dwCount
			)
{
	const char * sz = multiszFrom;
	char * mzTo = (char *) multiszTo;
	do
	{
		// go to first char after next null
		while ((DWORD)(sz-multiszFrom) < dwCount && '\0' != sz[0])
			*mzTo++ = *sz++;
		if ((DWORD)(sz-multiszFrom) < dwCount )
			*mzTo++ = *sz++;
	} while ((DWORD)(sz-multiszFrom) < dwCount && '\0' != sz[0]);
	if( (DWORD)(sz-multiszFrom) < dwCount ) {
		*mzTo++ = '\0' ;
	}

    return multiszTo;
}

// no longer does lower-case - we preserve the newsgroup case
char *
szDownCase(
		   char * sz,
		   char * szBuf
		   )
{
	char * oldSzBuf = szBuf;
	for (;*sz; sz++)
		*(szBuf++) = (*sz); // tolower(*sz);
	*szBuf = '\0';
	return oldSzBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\seodisp.cpp ===
#include "stdinc.h"
#include "wildmat.h"

#define INITGUID
#include "initguid.h"

DEFINE_GUID(NNTP_SOURCE_TYPE_GUID, 
0xc028fd82, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);
DEFINE_GUID(CATID_NNTP_ON_POST_EARLY, 
0xc028fd86, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);
DEFINE_GUID(CATID_NNTP_ON_POST, 
0xc028fd83, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);
DEFINE_GUID(CATID_NNTP_ON_POST_FINAL, 
0xc028fd85, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);
DEFINE_GUID(CLSID_CNNTPDispatcher, 
0xc028fd84, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);

DEFINE_GUID(GUID_NNTPSVC, 
0x8e3ecb8c, 0xe9a, 0x11d1, 0x85, 0xd1, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);

// {0xCD000080,0x8B95,0x11D1,{0x82,0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D}}
DEFINE_GUID(IID_IConstructIMessageFromIMailMsg, 0xCD000080,0x8B95,0x11D1,0x82,
0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D);

DWORD ComputeDropHash( const  LPCSTR&	lpstrIn);

CNNTPDispatcher::CNNTPParams::CNNTPParams() : m_iidEvent(GUID_NULL) {
	m_szRule = NULL;
	m_pCDOMessage = NULL;
}

void CNNTPDispatcher::CNNTPParams::Init(IID iidEvent,
										CArticle *pArticle,
										CNEWSGROUPLIST *pGrouplist,
										DWORD dwFeedId,
										IMailMsgProperties *pMailMsg)
{ 
	m_pArticle = pArticle;
	m_pGrouplist = pGrouplist;
	m_dwFeedId = dwFeedId;
	m_pMailMsg = pMailMsg;
	m_iidEvent = iidEvent;
}

CNNTPDispatcher::CNNTPParams::~CNNTPParams() { 
	if (m_szRule != NULL) {
		XDELETE m_szRule;
		m_szRule = NULL;
	}
	if (m_pCDOMessage != NULL) {
		m_pCDOMessage->Release();
		m_pCDOMessage = NULL;
	}
}

//
// initialize a new binding.  we cache information from the binding database
// here
//
HRESULT CNNTPDispatcher::CNNTPBinding::Init(IEventBinding *piBinding) {
	HRESULT hr;
	CComPtr<IEventPropertyBag> piEventProperties;

	// get the parent initialized
	hr = CBinding::Init(piBinding);
	if (FAILED(hr)) return hr;

	// get the binding database 
	hr = m_piBinding->get_SourceProperties(&piEventProperties);
	if (FAILED(hr)) return hr;

	// get the rule from the binding database
	hr = piEventProperties->Item(&CComVariant("Rule"), &m_vRule);
	if (FAILED(hr)) return hr;

	if (m_vRule.vt == VT_BSTR) m_cRule = lstrlenW(m_vRule.bstrVal) + 1;

	// get the newsgroup list from the binding database
	CComVariant vNewsgroupList;
	hr = piEventProperties->Item(&CComVariant("NewsgroupList"), 
								 &vNewsgroupList);
	if (FAILED(hr)) return hr;
	// go through each of the groups in the newsgroup list and add them 
	// to the groupset
	m_groupset.Init(ComputeDropHash);
	if (vNewsgroupList.vt == VT_BSTR) {
		//
		// copy the list to an ascii string and go through it, adding
		// each group to the groupset.
		//
		DWORD cNewsgroupList = lstrlenW(vNewsgroupList.bstrVal);
		char *pszGrouplist = XNEW char[cNewsgroupList + 1];
		if (pszGrouplist == NULL) return E_OUTOFMEMORY;
		if (WideCharToMultiByte(CP_ACP, 0, vNewsgroupList.bstrVal, 
							    -1, pszGrouplist, cNewsgroupList + 1, NULL,
								NULL) <= 0)
		{
			XDELETE[] pszGrouplist;
			return HRESULT_FROM_WIN32(GetLastError());
		}

		char *pszGroup = pszGrouplist, *pszComma;
		do {
			pszComma = strchr(pszGroup, ',');
			if (pszComma != NULL) *pszComma = 0;
			if (!m_groupset.AddGroup(pszGroup)) {
				XDELETE[] pszGrouplist;
				return E_OUTOFMEMORY;
			}
			pszGroup = pszComma + 1;
		} while (pszComma != NULL);

		XDELETE[] pszGrouplist;
		
		m_fGroupset = TRUE;
	} else {
		m_fGroupset = FALSE;
	}

	return S_OK;
}

//
// check the rule to see if we should call the child object
//
// returns:
//	S_OK - handle this event
// 	S_FALSE - skip this event
// 	<else> - error
//
HRESULT CNNTPDispatcher::CNNTPParams::CheckRule(CBinding &bBinding) {
	CNNTPBinding *pbNNTPBinding = (CNNTPBinding *) &bBinding;
	HRESULT hr;

	// do the header patterns rule check
	m_szRule = 0;
	hr = HeaderPatternsRule(pbNNTPBinding);
	// if this check passed and there is a valid groupset, then also
	// check against the groupset.
	if (hr == S_OK && pbNNTPBinding->m_fGroupset) {
		hr = GroupListRule(pbNNTPBinding);
	}

	return hr;
}

//
// check to see if any of the groups that this message is being posted
// to are in the grouplist hash table
//
HRESULT CNNTPDispatcher::CNNTPParams::GroupListRule(CNNTPBinding *pbNNTPBinding) {
	DWORD iGroupList, cGroupList = m_pGrouplist->GetCount();
	POSITION posGroupList = m_pGrouplist->GetHeadPosition();
	for (iGroupList = 0; 
		 iGroupList < cGroupList; 
		 iGroupList++, m_pGrouplist->GetNext(posGroupList)) 
	{
		CPostGroupPtr *pPostGroupPtr = m_pGrouplist->Get(posGroupList);
		CGRPCOREPTR pNewsgroup = pPostGroupPtr->m_pGroup;
		_ASSERT(pNewsgroup != NULL);
		LPSTR pszNewsgroup = pNewsgroup->GetNativeName();

		if (pbNNTPBinding->m_groupset.IsGroupMember(pszNewsgroup)) return S_OK;
	}

	return S_FALSE;
}

HRESULT CNNTPDispatcher::CNNTPParams::NewsgroupPatternsRule(CNNTPBinding *pbNNTPBinding, 
														    char *pszNewsgroupPatterns) 
{
	DWORD cRule = MAX_RULE_LENGTH;
	HRESULT hr;

	hr = S_FALSE;
	// try each comma delimited group in the newsgroup patterns
	// list
	char *pszNewsgroupPattern = pszNewsgroupPatterns;
	while (pszNewsgroupPattern != NULL && *pszNewsgroupPattern != 0) {
		// find the next comma in the string and turn it into a 0
		// if it exists
		char *pszComma = strchr(pszNewsgroupPatterns, ',');
		if (pszComma != NULL) *pszComma = 0;

		DWORD iGroupList, cGroupList = m_pGrouplist->GetCount();
		POSITION posGroupList = m_pGrouplist->GetHeadPosition();
		for (iGroupList = 0; 
			 iGroupList < cGroupList; 
			 iGroupList++, m_pGrouplist->GetNext(posGroupList)) 
		{
			CPostGroupPtr *pPostGroupPtr = m_pGrouplist->Get(posGroupList);
			CGRPCOREPTR pNewsgroup = pPostGroupPtr->m_pGroup;
			_ASSERT(pNewsgroup != NULL);
			LPSTR pszNewsgroup = pNewsgroup->GetNativeName();

			DWORD ec = HrMatchWildmat(pszNewsgroup, pszNewsgroupPattern);
			switch (ec) {
				case ERROR_SUCCESS: 
					return S_OK; 
					break;
				case ERROR_FILE_NOT_FOUND: 
					_ASSERT(hr == S_FALSE);
					break;
				default: 
					return HRESULT_FROM_WIN32(ec); 
					break;
			}			
		}

		// the next pattern is the one past the end of the comma
		pszNewsgroupPattern = (pszComma == NULL) ? NULL : pszComma + 1;
	}

	return hr;
}

HRESULT CNNTPDispatcher::CNNTPParams::FeedIDRule(CNNTPBinding *pbNNTPBinding, 
											     char *pszFeedIDs) 
{
	HRESULT hr = S_FALSE;

	// try each comma delimited group in the newsgroup patterns
	// list
	char *pszFeedID = pszFeedIDs;
	while (pszFeedID != NULL && *pszFeedID != 0) {
		// find the next comma in the string and turn it into a 0
		// if it exists
		char *pszComma = strchr(pszFeedIDs, ',');
		if (pszComma != NULL) *pszComma = 0;
		
		// convert the text FeedID into an integer and compare it against
		// the current FeedID
		DWORD dwFeedID = (DWORD) atol(pszFeedID);
		if (m_dwFeedId == dwFeedID) {
			// we found a match, so the rule passes
			return S_OK;
		}

		// the next pattern is the one past the end of the comma
		pszFeedID = (pszComma == NULL) ? NULL : pszComma + 1;
	}

	return hr;
}

//
// rule syntax:
// <header1>=<pattern1-1>,<pattern1-2>;<header2>=<pattern2-1>
//
// if there isn't a pattern specified for a header then the existence of the
// header will trigger the rule.  
// 
// :Newsgroup is a special header which refers to the envelope newsgroup
// information.
//
// any match in the rule causes the filter to be triggered.
//
// example:
// control=rmgroup,newgroup;:newsgroups=comp.*
//
// this will trigger the filter on rmgroup and newgroup postings in the 
// comp.* heirarchy
//
HRESULT CNNTPDispatcher::CNNTPParams::HeaderPatternsRule(CNNTPBinding *pbNNTPBinding) {
	HRESULT hr;
	BOOL fCaseSensitive = FALSE;

	if (pbNNTPBinding->m_vRule.vt != VT_BSTR) {
		// this rule isn't in the metabase, so we pass it
		return S_OK;
	} else {
		hr = S_OK;

		// copy the rule into an ascii string
		m_szRule = XNEW char[pbNNTPBinding->m_cRule];
		if (m_szRule == NULL) return E_OUTOFMEMORY;
		if (WideCharToMultiByte(CP_ACP, 0, pbNNTPBinding->m_vRule.bstrVal, 
							    -1, m_szRule, pbNNTPBinding->m_cRule, NULL, NULL) <= 0)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}

		// try each semi-colon delimited rule in the header patterns list
		char *pszHeader = m_szRule;
		while (pszHeader != NULL && *pszHeader != 0) {
			// find the next semicolon in the string and turn it into a 0
			// if it exists
			char *pszSemiColon = strchr(pszHeader, ';');
			if (pszSemiColon != NULL) *pszSemiColon = 0;

			// set pszContents to point to the text which must be matched
			// in the header.  if pszContents == NULL then just having
			// the header exist is good enough.
			char *pszPatterns = strchr(pszHeader, '=');
			if (pszPatterns == NULL) {
				// this is a directive, honor it
				if (lstrcmpi(pszHeader, "case-sensitive") == 0) {
					fCaseSensitive = TRUE;
				} else if (lstrcmpi(pszHeader, "case-insensitive") == 0) {
					fCaseSensitive = FALSE;
				} else {
					return E_INVALIDARG;
				}
			} else {
				// they are doing a header comparison
				
				// check to see if the right side of the = is blank
				if (pszPatterns[1] == 0) {
					pszPatterns = NULL;
				} else {
					*pszPatterns = 0;
					(pszPatterns++);
				}

				if (lstrcmpi(pszHeader, ":newsgroups") == 0) {
					// call into the newsgroup rule engine to handle this
					hr = NewsgroupPatternsRule(pbNNTPBinding, pszPatterns);
					// if we got back S_FALSE or an error then return that
					if (hr != S_OK) return hr;
				} else if (lstrcmpi(pszHeader, ":feedid") == 0) {
					// call into the feedid rule engine to handle this
					hr = FeedIDRule(pbNNTPBinding, pszPatterns);
					// if we got back S_FALSE or an error then return that
					if (hr != S_OK) return hr;
				} else {
					// we now have the header that we are looking for in 
					// pszHeader and the list of patterns that we are interested 
					// in pszPatterns.  Make the lookup into the header
					// data structure
					char szHeaderData[4096];
					DWORD cHeaderData;
					BOOL f = m_pArticle->fGetHeader(pszHeader, 
													(BYTE *) szHeaderData, 
										   		    4096, cHeaderData);
					if (!f) {
						switch (GetLastError()) {
							case ERROR_INSUFFICIENT_BUFFER:
								// BUGBUG - should handle this better.  for now we
								// just assume that the header doesn't match
								return S_FALSE;
								break;
							case ERROR_INVALID_NAME:
								// header wasn't found
								return S_FALSE;
								break;
							default:
								_ASSERT(FALSE);
								return(HRESULT_FROM_WIN32(GetLastError()));
								break;
						}
					} else {
						// convert the trailing \r\n to 0
						szHeaderData[cHeaderData - 2] = 0;
						// if there is no pszContents then just having the header
						// is good enough.
						if (pszPatterns == NULL) return S_OK;

						// if they don't care about case then lowercase the
						// string
						if (!fCaseSensitive) _strlwr(szHeaderData);
		
						// assume that we won't find a match.  once we do
						// find a match then we are okay and we'll stop looking
						// for further matches
						hr = S_FALSE;
						do {
							char *pszComma = strchr(pszPatterns, ',');
							if (pszComma != NULL) *pszComma = 0;

							// if they don't care about case then lowercase the
							// string
							if (!fCaseSensitive) _strlwr(pszPatterns);
		
							// check to see if it passes the pattern that we have
							switch (HrMatchWildmat(szHeaderData, pszPatterns)) {
								case ERROR_SUCCESS: 
									hr = S_OK;
									break;
								case ERROR_FILE_NOT_FOUND: 
									break;
								default: 
									hr = HRESULT_FROM_WIN32(hr); 
									break;
							}
	
							// the next pattern is past the comma
							pszPatterns = (pszComma == NULL) ? NULL : pszComma + 1;
						} while (pszPatterns != NULL && hr == S_FALSE);
						// if we didn't find a match or if there was an error
						// then bail
						if (hr != S_OK) return hr;
					}
				}
			}

			// if we get here then everything should have matched so far
			_ASSERT(hr == S_OK);

			// the next pattern is the one past the end of the semicolon
			pszHeader = (pszSemiColon == NULL) ? NULL : pszSemiColon + 1;
		}
	} 

	return hr;
}

//
// call the child object
//
HRESULT CNNTPDispatcher::CNNTPParams::CallObject(CBinding &bBinding,
												 IUnknown *punkObject) 
{
	HRESULT hr = S_OK;
	INNTPFilter *pFilter;

	hr = FillInMailMsgForSEO(m_pMailMsg, m_pArticle, m_pGrouplist);
	if (SUCCEEDED(hr)) {
		hr = punkObject->QueryInterface(IID_INNTPFilter, (void **) &pFilter);
		if (SUCCEEDED(hr)) {
			hr = pFilter->OnPost(m_pMailMsg);
			pFilter->Release();
		} else if (hr == E_NOINTERFACE) {
			hr = CallCdoObject(punkObject);
		}
	}

	return hr;
}

//
// Call a CDO child object
//
HRESULT CNNTPDispatcher::CNNTPParams::CallCdoObject(IUnknown *punkObject) {
	HRESULT hr = S_OK;
	void *pFilter;
	CdoEventStatus eStatus = cdoRunNextSink;
	IID iidInterface;
	CdoEventType eEventType;
	
	if (m_iidEvent == CATID_NNTP_ON_POST_EARLY) {
		iidInterface = IID_INNTPOnPostEarly;
		eEventType = cdoNNTPOnPostEarly;
	} else if (m_iidEvent == CATID_NNTP_ON_POST_FINAL) {
		iidInterface = IID_INNTPOnPostFinal;
		eEventType = cdoNNTPOnPostFinal;
	} else {
		iidInterface = IID_INNTPOnPost;
		eEventType = cdoNNTPOnPost;
		_ASSERT(m_iidEvent == CATID_NNTP_ON_POST);
	}

	// QI for the CDO interface
	hr = punkObject->QueryInterface(iidInterface, &pFilter);

	if (SUCCEEDED(hr)) {
		// see if we need to create a CDO message object
		if (m_pCDOMessage == NULL) {
			hr = CoCreateInstance(CLSID_Message,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IMessage,
								  (void **) &m_pCDOMessage);
			if (SUCCEEDED(hr)) {
				IConstructIMessageFromIMailMsg *pConstruct;
				hr = m_pCDOMessage->QueryInterface(
						IID_IConstructIMessageFromIMailMsg,
						(void **) &pConstruct);
				if (SUCCEEDED(hr)) {
					hr = pConstruct->Construct(eEventType, m_pMailMsg);
					pConstruct->Release();
				}
				if (FAILED(hr)) {
					m_pCDOMessage->Release();
					m_pCDOMessage = NULL;
				}
			}
		}

		// call the CDO interface
		switch (eEventType) {
			case cdoNNTPOnPostEarly:
				hr = ((INNTPOnPostEarly *) pFilter)->OnPostEarly(m_pCDOMessage, &eStatus);
				((INNTPOnPostEarly *) pFilter)->Release();
				break;
			case cdoNNTPOnPost:
				hr = ((INNTPOnPost *) pFilter)->OnPost(m_pCDOMessage, &eStatus);
				((INNTPOnPost *) pFilter)->Release();
				break;
			case cdoNNTPOnPostFinal:
				hr = ((INNTPOnPostFinal *) pFilter)->OnPostFinal(m_pCDOMessage, &eStatus);
				((INNTPOnPostFinal *) pFilter)->Release();
				break;
			default:
				_ASSERT(FALSE);
				hr = E_UNEXPECTED;
				break;
		}
	}

	if (eStatus == cdoSkipRemainingSinks) hr = S_FALSE;

	return hr;
}

HRESULT STDMETHODCALLTYPE CNNTPDispatcher::OnPost(REFIID iidEvent,
												  void *pArticle,
												  void *pGrouplist,
												  DWORD dwFeedId,
												  void *pMailMsg)
{
	// create the params object, and pass it into the dispatcher
	CNNTPParams NNTPParams;
	
	NNTPParams.Init(iidEvent,
					(CArticle *) pArticle,
					(CNEWSGROUPLIST *) pGrouplist, 
					dwFeedId,
					(IMailMsgProperties *) pMailMsg);

	return Dispatcher(iidEvent, &NNTPParams);
}

//
// trigger an nntp server event
//
// arguments:
//    [in] pRouter - the router object returned by MakeServerEventsRouter
//    [in] iidEvent - the GUID for the event
//    [in] pArticle - the article 
//    [in] pGrouplist - the newsgroup list
//	  [in] dwOperations - bitmask of operations that filter doesn't want
//						  server to do.
// returns:
//    S_OK - success
//    <else> - error
//
HRESULT TriggerServerEvent(IEventRouter *pRouter,
						   IID iidEvent,
						   CArticle *pArticle,
						   CNEWSGROUPLIST *pGrouplist,
						   DWORD dwFeedId,
						   IMailMsgProperties *pMailMsg) 
{
	CNNTPDispatcherClassFactory cf;
	CComPtr<INNTPDispatcher> pEventDispatcher;
	HRESULT hr;
	DWORD htokSecurity;

	if (pRouter == NULL) return E_POINTER;

	hr = pRouter->GetDispatcherByClassFactory(CLSID_CNNTPDispatcher,
										 	  &cf,
										 	  iidEvent,
										 	  IID_INNTPDispatcher,
										 	  (IUnknown **) &pEventDispatcher);
	if (FAILED(hr)) return hr;

	hr = pEventDispatcher->OnPost(iidEvent, 
								  pArticle, 
								  pGrouplist, 
								  dwFeedId, 
								  pMailMsg);
	return hr;
}

DWORD ComputeDropHash(const  LPCSTR& lpstrIn) {
	//
	//	Compute a hash value for the newsgroup name
	//
	return	INNHash( (BYTE*)lpstrIn, lstrlen( lpstrIn ) ) ;
}

#if 0
//
// this function performs service level server events registration
//
HRESULT RegisterSEOService() {
	HRESULT hr;
	CComBSTR bstrNNTPOnPostCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST);
	CComBSTR bstrNNTPOnPostFinalCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);

	//
	// see if we've done the service level registration by getting the list
	// of source types and seeing if the NNTP source type is registered
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL, 
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	if (FAILED(hr)) return hr;
	// if this failed then we need to register the source type and event
	// component categories
	if (hr == S_FALSE) {
		// register the component categories
		CComPtr<IEventComCat> pComCat;
		hr = CoCreateInstance(CLSID_CEventComCat, NULL, CLSCTX_ALL, 
						 	  IID_IEventComCat, (LPVOID *) &pComCat);
		if (hr != S_OK) return hr;
		CComBSTR bstrNNTPOnPostCATID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST);
		CComBSTR bstrOnPost = "NNTP OnPost";
		hr = pComCat->RegisterCategory(bstrNNTPOnPostCATID, bstrOnPost, 0);
		if (FAILED(hr)) return hr;
		CComBSTR bstrNNTPOnPostFinalCATID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);
		CComBSTR bstrOnPostFinal = "NNTP OnPostFinal";
		hr = pComCat->RegisterCategory(bstrNNTPOnPostFinalCATID, bstrOnPostFinal, 0);
		if (FAILED(hr)) return hr;
	
		// register the source type
		hr = pSourceTypes->Add(bstrSourceTypeGUID, &pSourceType);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
		CComBSTR bstrSourceTypeDisplayName = "NNTP Server";
		hr = pSourceType->put_DisplayName(bstrSourceTypeDisplayName);
		if (FAILED(hr)) return hr;
		hr = pSourceType->Save();
		if (FAILED(hr)) return hr;

		// add the event types to the source type
		CComPtr<IEventTypes> pEventTypes;
		hr = pSourceType->get_EventTypes(&pEventTypes);
		if (FAILED(hr)) return hr;
		hr = pEventTypes->Add(bstrNNTPOnPostCatID);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
		hr = pEventTypes->Add(bstrNNTPOnPostFinalCatID);
		if (FAILED(hr)) return hr;
		_ASSERT(hr == S_OK);
	}

	return S_OK;
}

//
// this function performs instance level server events registration
//
HRESULT RegisterSEOInstance(DWORD dwInstanceID, char *szDropDirectory) {
	HRESULT hr;
	CComBSTR bstrNNTPOnPostFinalCatID = (LPCOLESTR) CStringGUID(CATID_NNTP_ON_POST_FINAL);

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL, 
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// generate a GUID for this source, which is based on GUID_NNTPSVC 
	// mangled by the instance ID
	//
	CComPtr<IEventUtil> pEventUtil;
	hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL, 
					 	  IID_IEventUtil, (LPVOID *) &pEventUtil);
	if (hr != S_OK) return hr;
	CComBSTR bstrNNTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_NNTPSVC);
	CComBSTR bstrSourceGUID;
	hr = pEventUtil->GetIndexedGUID(bstrNNTPSvcGUID, dwInstanceID, &bstrSourceGUID);
	if (FAILED(hr)) return hr;

	//
	// see if this source is registered with the list of sources for the
	// NNTP source type
	//
	CComPtr<IEventSources> pEventSources;
	hr = pSourceType->get_Sources(&pEventSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSource> pEventSource;
	hr = pEventSources->Item(&CComVariant(bstrSourceGUID), &pEventSource);
	if (FAILED(hr)) return hr;
	//
	// if the source guid doesn't exist then we need to register a new
	// source for the NNTP source type and add directory drop as a binding
	//
	if (hr == S_FALSE) {
		// register the NNTPSvc source
		hr = pEventSources->Add(bstrSourceGUID, &pEventSource);
		if (FAILED(hr)) return hr;
		char szSourceDisplayName[50];
		_snprintf(szSourceDisplayName, 50, "nntpsvc %lu", dwInstanceID);
		CComBSTR bstrSourceDisplayName = szSourceDisplayName;
		hr = pEventSource->put_DisplayName(bstrSourceDisplayName);
		if (FAILED(hr)) return hr;
	
		// create the event database for this source
		CComPtr<IEventDatabaseManager> pDatabaseManager;
		hr = CoCreateInstance(CLSID_CEventMetabaseDatabaseManager, NULL, CLSCTX_ALL, 
						 	  IID_IEventDatabaseManager, (LPVOID *) &pDatabaseManager);
		if (hr != S_OK) return hr;
		CComBSTR bstrEventPath;
		CComBSTR bstrService = "nntpsvc";
		hr = pDatabaseManager->MakeVServerPath(bstrService, dwInstanceID, &bstrEventPath);
		if (FAILED(hr)) return hr;
		CComPtr<IUnknown> pDatabaseMoniker;
		hr = pDatabaseManager->CreateDatabase(bstrEventPath, &pDatabaseMoniker);
		if (FAILED(hr)) return hr;
		hr = pEventSource->put_BindingManagerMoniker(pDatabaseMoniker);
		if (FAILED(hr)) return hr;
	
		// save everything we've done so far
		hr = pEventSource->Save();
		if (FAILED(hr)) return hr;
		hr = pSourceType->Save();
		if (FAILED(hr)) return hr;
	
		// add a new binding for Directory Drop with an empty newsgroup
		// list rule
		CComPtr<IEventBindingManager> pBindingManager;
		hr = pEventSource->GetBindingManager(&pBindingManager);
		if (FAILED(hr)) return hr;
		CComPtr<IEventBindings> pEventBindings;
		hr = pBindingManager->get_Bindings(bstrNNTPOnPostFinalCatID, &pEventBindings);
		if (FAILED(hr)) return hr;
		CComPtr<IEventBinding> pEventBinding;
		hr = pEventBindings->Add(L"", &pEventBinding);
		if (FAILED(hr)) return hr;
		CComBSTR bstrBindingDisplayName = "Directory Drop";
		hr = pEventBinding->put_DisplayName(bstrBindingDisplayName);
		if (FAILED(hr)) return hr;
		CComBSTR bstrSinkClass = "NNTP.DirectoryDrop";
		hr = pEventBinding->put_SinkClass(bstrSinkClass);
		if (FAILED(hr)) return hr;
		CComPtr<IEventPropertyBag> pSourceProperties;
		hr = pEventBinding->get_SourceProperties(&pSourceProperties);
		if (FAILED(hr)) return hr;
		CComBSTR bstrPropName;
		CComBSTR bstrPropValue;
		bstrPropName = "NewsgroupList";
		bstrPropValue = "";
		hr = pSourceProperties->Add(bstrPropName, &CComVariant(bstrPropValue));
		if (FAILED(hr)) return hr;
		CComPtr<IEventPropertyBag> pSinkProperties;
		hr = pEventBinding->get_SinkProperties(&pSinkProperties);
		if (FAILED(hr)) return hr;
		bstrPropName = "Drop Directory";
		bstrPropValue = szDropDirectory;
		hr = pSinkProperties->Add(bstrPropName, &CComVariant(bstrPropValue));
		if (FAILED(hr)) return hr;
		hr = pEventBinding->Save();
		if (FAILED(hr)) return hr;
	}
	
	return S_OK;
}

//
// this function performs instance level unregistration
//
HRESULT UnregisterSEOInstance(DWORD dwInstanceID) {
	HRESULT hr;

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL, 
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// generate a GUID for this source, which is based on GUID_NNTPSVC 
	// mangled by the instance ID
	//
	CComPtr<IEventUtil> pEventUtil;
	hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL, 
					 	  IID_IEventUtil, (LPVOID *) &pEventUtil);
	if (hr != S_OK) return hr;
	CComBSTR bstrNNTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_NNTPSVC);
	CComBSTR bstrSourceGUID;
	hr = pEventUtil->GetIndexedGUID(bstrNNTPSvcGUID, dwInstanceID, &bstrSourceGUID);
	if (FAILED(hr)) return hr;

	//
	// remove this source from the list of registered sources
	//
	CComPtr<IEventSources> pEventSources;
	hr = pSourceType->get_Sources(&pEventSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSource> pEventSource;
	hr = pEventSources->Remove(&CComVariant(bstrSourceGUID));
	if (FAILED(hr)) return hr;
	
	return S_OK;
}

HRESULT UnregisterOrphanedSources(void) {
	HRESULT hr;

	//
	// find the NNTP source type in the event manager
	//
	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL, 
					 	  IID_IEventManager, (LPVOID *) &pEventManager);
	if (hr != S_OK) return hr;
	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	if (FAILED(hr)) return hr;
	CComPtr<IEventSourceType> pSourceType;
	CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(NNTP_SOURCE_TYPE_GUID);
	hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
	_ASSERT(hr != S_OK || pSourceType != NULL);
	if (hr != S_OK) return hr;

	//
	// get the list of sources registered for this source type
	//
	CComPtr<IEventSources> pSources;
	hr = pSourceType->get_Sources(&pSources);
	if (FAILED(hr)) return hr;
	CComPtr<IEnumVARIANT> pSourceEnum;
	hr = pSources->get__NewEnum((IUnknown **) &pSourceEnum);
	if (FAILED(hr)) return hr;

	do {
		VARIANT varSource;

		hr = pSourceEnum->Next(1, &varSource, NULL);
		if (FAILED(hr)) return hr;
		if (hr == S_OK) {
			if (varSource.vt == VT_DISPATCH) {
				CComPtr<IEventSource> pSource;

				// QI for the IEventSource interface
				hr = varSource.punkVal->QueryInterface(IID_IEventSource, 
													 (void **) &pSource);
				if (FAILED(hr)) return hr;
				varSource.punkVal->Release();

				// get the binding manager
				CComBSTR bstrSourceID;
				hr = pSource->get_ID(&bstrSourceID);
				if (FAILED(hr)) return hr;

				// get the index from the SourceID
				CStringGUID guidIndex(bstrSourceID);
				DWORD iInstance;
				if (guidIndex.GetIndex(GUID_NNTPSVC, &iInstance)) {
					// see if this instance exists
    				MB mb((IMDCOM*)g_pInetSvc->QueryMDObject());
					char szMBPath[50];

					_snprintf(szMBPath, 50, "LM/nntpsvc/%lu", iInstance);
					if (mb.Open(szMBPath)) {
						// it exists, so just close the mb and keep going
						mb.Close();
					} else {
						// the instance is gone, clean up this source in
						// the metabase
						hr = pSources->Remove(&CComVariant(bstrSourceID));
						_ASSERT(SUCCEEDED(hr));
					}
				}

				pSource.Release();
			} else {
				_ASSERT(FALSE);
			}
		}
	} while (hr == S_OK);

	return S_OK;
}
#endif

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include "nntpdisp_i.c"
#include "nntpfilt_i.c"
#include "cdo_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>

#include <xmemwrpr.h>
#include <malloc.h>
#include <imd.h>

#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <ntlmsp.h>
        //#include <sslsp.h>
#include <buffer.hxx>

#include <pudebug.h>
#include <iistypes.hxx>
#include <simssl2.h>
#include <tssec.hxx>
#include <simauth2.h>
#include <nntptype.h>
#include <nntps.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <tsunami.hxx>
#include <nntpmeta.h>
#include <time.h>
#include <smartptr.h>
#include <fcache.h>
#include <tcpproc.h>
#include <nntpcons.h>

#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"
#include "crchash.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include <instwpex.h>
#include "nntpvr.h"
#include "group.h"
#include "nwstree.h"
#include "nntpbag.h"
#include "nntperr.h"
#include <ihash.h>
#include <atq.h>

#include "cbuffer.h"
#include "cfeed.h"
#include "infeed.h"
#include "fromclnt.h"
#include "frompeer.h"
#include "frommstr.h"
#include "sfromcl.h"
#include "nntputil.h"
#include "seo.h"
#include "cstream.h"
#include "mailmsg.h"
#include "mailmsgi.h"
#include "seodisp.h"
#include <randfail.h>
#include <nntpdrv.h>
#include "smtpdll.h"
#include "nntpmsg.h"
#include "cdoconstimsg.h"

VOID
NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    );

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\utest\artsupp.cpp ===
#include <stdinc.h>

//
// CPool is used to allocate memory while processing an article.
//

CPool   CArticle::gArticlePool(ARTICLE_SIGNATURE);

//
//  Largest possible CArticle derived object
//
#define MAX_ARTICLE_SIZE    max(    sizeof( CArticle ), \
                            max(    sizeof( CFromPeerArticle ), \
                            max(    sizeof( CFromClientArticle ),   \
                            sizeof( CFromMasterArticle )   	\
                             ) ) )

//
// An upperbound on the number of article objects that can
// exist at any time.
//
const   unsigned    cbMAX_ARTICLE_SIZE = MAX_ARTICLE_SIZE ;

void*	
CArticle::operator	new(	size_t	size )
{
	_ASSERT( size <= cbMAX_ARTICLE_SIZE ) ;
	return	gArticlePool.Alloc() ;
}

void
CArticle::operator	delete( void*	pv )
{
	gArticlePool.Free( pv ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\seodisp.h ===
#ifndef __SEODISP_H__
#define __SEODISP_H__
#define _ATL_NO_DEBUG_CRT
#define _WINDLL
//#include "stdafx.h"
#define _ASSERTE _ASSERT
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL
#include "seolib.h"
#include "seo.h"
#include "nntpdisp.h"
#include "nntpfilt.h"
#include "ddroplst.h"
#include "cdo.h"

#define MAX_RULE_LENGTH 4096

class CNNTPDispatcher :
		public CEventBaseDispatcher,
		public CComObjectRoot,
		public INNTPDispatcher
{
	public:
		DECLARE_PROTECT_FINAL_CONSTRUCT();
	
#if 0
		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
									   L"NNTPDispatcher.Class",
									   L"NNTP.Dispatcher.1",
									   L"NNTP.Dispatcher");
#endif
	
		DECLARE_GET_CONTROLLING_UNKNOWN();

		DECLARE_NOT_AGGREGATABLE(CNNTPDispatcher);
	
		BEGIN_COM_MAP(CNNTPDispatcher)
			COM_INTERFACE_ENTRY(IEventDispatcher)
			COM_INTERFACE_ENTRY(INNTPDispatcher)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()

		// this code gets called during initialization
		HRESULT FinalConstruct() {
			HRESULT hr;
			// we need to do this to signal that we are free threaded
			hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
			// if SUCCEEDED(hr) then hr must be S_OK
			_ASSERT((!SUCCEEDED(hr)) || hr == S_OK);
			// if SUCCEEDED(hr) return S_OK else return hr;
			return (SUCCEEDED(hr)) ? S_OK : hr;
		}

		// this has the global destructor code in it
		void FinalRelease() {}

		class CNNTPBinding : public CEventBaseDispatcher::CBinding {
			public:
				virtual HRESULT Init(IEventBinding *piBinding);
			public:
				CComVariant m_vRule;
				DWORD m_cRule;
				CDDropGroupSet m_groupset;
				BOOL m_fGroupset;
		};

		virtual HRESULT AllocBinding(REFGUID rguidEventType,
									 IEventBinding *piBinding,
									 CBinding **ppNewBinding)
		{
			if (ppNewBinding) *ppNewBinding = NULL;
			if (!piBinding || !ppNewBinding) return E_POINTER;
			*ppNewBinding = new CNNTPBinding;
			if (*ppNewBinding == NULL) return E_OUTOFMEMORY;
			return S_OK;
		}

		class CNNTPParams : public CEventBaseDispatcher::CParams {
			public:
				CNNTPParams();
				void Init(IID iidEvent,
						  CArticle *pArticle,
						  CNEWSGROUPLIST *pGrouplist,
						  DWORD dwFeedId,
						  IMailMsgProperties *pMailMsg);
				~CNNTPParams();
				virtual HRESULT CheckRule(CBinding &bBinding);
				virtual HRESULT CallObject(CBinding &bBinding, IUnknown *punkObject);
				virtual HRESULT CallCdoObject(IUnknown *punkObject);
			private:
				HRESULT HeaderPatternsRule(CNNTPBinding *pbNNTPBinding);
				HRESULT GroupListRule(CNNTPBinding *pbNNTPBinding);
				HRESULT NewsgroupPatternsRule(CNNTPBinding *pbNNTPBinding,
											  char *pszNewsgroupPatterns);
				HRESULT FeedIDRule(CNNTPBinding *pbNNTPBinding,
								   char *pszFeedIDs);
			public:
				CArticle *m_pArticle;
				CNEWSGROUPLIST *m_pGrouplist;
				DWORD m_dwFeedId;
				IMailMsgProperties *m_pMailMsg;
				IMessage *m_pCDOMessage;
				IID m_iidEvent;

				// our local copy of the rule
				char *m_szRule;
		};

		HRESULT STDMETHODCALLTYPE OnPost(REFIID iidEvent,
										 void *pArticle,
										 void *pGrouplist,
										 DWORD dwFeedId,
										 void *pMailMsg);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};

class CNNTPDispatcherClassFactory : public IClassFactory {
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void * * ppvObj) {
		_ASSERT(FALSE);
		return E_NOTIMPL;
	}
	unsigned long  STDMETHODCALLTYPE AddRef () { _ASSERT(FALSE); return 0; }
	unsigned long  STDMETHODCALLTYPE Release () { _ASSERT(FALSE); return 0; }

	// *** IClassFactory methods ***
	HRESULT STDMETHODCALLTYPE CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,  void * * ppvObj) {
		return CComObject<CNNTPDispatcher>::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
	}
	HRESULT STDMETHODCALLTYPE LockServer (int fLock) {
		_ASSERT(FALSE);
		return E_NOTIMPL;
	}
};
	

HRESULT TriggerServerEvent(IEventRouter *pRouter,
						   IID iidEvent,
						   CArticle *pArticle,
						   CNEWSGROUPLIST *pGrouplist,
						   DWORD dwFeedId,
						   IMailMsgProperties *pMailMsg);

HRESULT FillInMailMsgForSEO(IMailMsgProperties *pMsg,
							CArticle *pArticle,
					  		CNEWSGROUPLIST *pGrouplist);


DEFINE_GUID(GUID_NNTPSVC,
0x8e3ecb8c, 0xe9a, 0x11d1, 0x85, 0xd1, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\utest\newwild.cpp ===
#include	"stdinc.h"
#include "wildmat.h"

//---[ Description of the Wildmat standard ]-----------------------------------
//
//  Taken from:
//
//  INTERNET-DRAFT                                               S. Barber
//  Expires: September 1, 1996                  Academ Consulting Services
//                                                              April 1996
//                           Common NNTP Extensions
//                        draft-barber-nntp-imp-03.txt
//  
//      The WILDMAT format was first developed by Rich Salz to provide
//      a uniform mechanism for matching patterns in the same manner
//      that the UNIX shell matches filenames. There are five pattern
//      matching operations other than a strict one-to-one match
//      between the pattern and the source to be checked for a match.
//      The first is an asterisk (*) to match any sequence of zero or
//      more characters. The second is a question mark (?) to match any
//      single character. The third specifies a specific set of
//      characters. The set is specified as a list of characters, or as
//      a range of characters where the beginning and end of the range
//      are separated by a minus (or dash) character, or as any
//      combination of lists and ranges. The dash can also be included
//      in the range as a character it if is the beginning or end of
//      the range. This set is enclosed in square brackets. The close
//      square bracket (]) may be used in a range if it is the first
//      character in the set. The fourth operation is the same as the
//      logical not of the third operation and is specified the same
//      way as the third with the addition of a caret character (^) at
//      the beginning of the test string just inside the open square
//      bracket. The final operation uses the backslash character to
//      invalidate the special meaning of the a open square bracket ([),
//      the asterisk, or the question mark.
//  
//  3.3.1 Examples
//  
//      a. [^]-] -- matches any character other than a close square bracket
//                  or a minus sign/dash.
//  
//      b. *bdc  -- matches any string that ends with the string "bdc"
//                  including the string "bdc" (without quotes).
//  
//      c. [0-9a-zA-Z] -- matches any string containing any alphanumeric string
//                  in English.
//  
//      d. a??d  --  matches any four character string which begins
//                   with a and ends with d.
//  
//-----------------------------------------------------------------------------



//----[ NOTES ]----------------------------------------------------------------
//                                                                            
// 		This function will raise an invalid access exception if either pszText                                                     
// 		or pszPattern is invalid or not null terminated while dereferencing the                                                    
// 		string. If this is possible, surround the call in a try-except block.                                                      
//  
//-----------------------------------------------------------------------------



//---[ Defines ]---------------------------------------------------------------

#define STACK_SIZE      256



//---[ HrMatchWildmat ]--------------------------------------------------------
//
//  Description:
//
//      Provides support for the "Wildmat" wild-card matching standard. See
//      description above.
//
//  Params:
//
//      pszText         String to test
//      pszPattern      Pattern to test against
//
//  Returns:
//      
//      ERROR_SUCCESS               If function succeeded, and match was found
//      ERROR_INVALID_PARAMETER     Text or pattern string is invalid
//      
//      ERROR_CAN_NOT_COMPLETE      Some other error occurred.
//
//  
//-----------------------------------------------------------------------------


HRESULT HrMatchWildmat(const char* pszText, const char* pszPattern)
{


	_ASSERT(pszText != NULL && pszPattern != NULL);



	BOOL fCharSet = FALSE;	// TRUE if currently parsing a character set in a pattern
	BOOL fNegated = FALSE;	// TRUE if there is a '^' at the beginning of the set
	BOOL fInSet   = FALSE;  // indicates when matching of a character set has completed
				// used to short-circuit character set evaluation
	int iStackPtr = 0;	// stack pointer
    
	const char* textStack[STACK_SIZE];	// stack of text pointers
	const char* patternStack[STACK_SIZE];	// stack of pattern pointers


	// If the pattern consists solely of a * then any text will match
	if (strcmp(pszPattern, "*") == 0)
		return ERROR_SUCCESS;


	while (TRUE) 
    {
		switch (*pszPattern) 
        {
		    case '*':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
                    

				// If there is a * at the end of the pattern then at this point we are
				// sure that we got a match
				if (pszPattern[1] == '\0')
					return ERROR_SUCCESS;


				// We could write a simpler recursive wildmat function. Here we would
				// recursively call wildmat. Instead, for performance reasons this
				// solution is iterative.
				// Here we save the current values of the text pointer and stack pointer
				// on a stack and we leave the * in the pattern, with the effect of
				// matching one character with the *. The next time through the while
				// loop, the * will still be in the pattern, thus we will try to match
				// the rest of the input with this *. If it turns to fail, we go back
				// one character.
				// See the comments right before the BACK label below.
		    	if (*pszText != '\0') 
                {
		    		if (iStackPtr == STACK_SIZE) 
                        return ERROR_CAN_NOT_COMPLETE;			// stack overflow
                        
		    		textStack[iStackPtr] = pszText;			// save current text pointer
		    		patternStack[iStackPtr] = pszPattern;	// save current pattern pointer
		    		iStackPtr++;
		    		pszPattern--;	// leave * in the input pattern and match one character
		    	}
		    	break;

		    case '?':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
		    	if (*pszText == '\0') 
                    goto BACK;
		    	break;

		    case '[':
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
                    
		    	fCharSet = TRUE;		    // beginning a character set
		    	fNegated = FALSE;			// so far we haven't seen a '^'
		    	fInSet = FALSE;				// used to short-circuit the evaluation of
		    						// membership to the character set

		    	// treat '^', '-' and ']' as special cases if they are
		    	// at the beginning of the character set (also "[^-a]" and "[^]a]")
		    	if (pszPattern[1] == '^') 
                {
		    		fNegated = TRUE;
		    		pszPattern++;
		    	}
		    	// '-' and ']' are literals if they appear at the beggining of the set
		    	if (pszPattern[1] == '-' || pszPattern[1] == ']') 
                {
		    		fInSet = (*pszText == pszPattern[1]);
		    		pszPattern++;
		    	}
		    	break;
		    		
		    case ']':
		    	if (fCharSet) 
                {
		    		if ((!fNegated && !fInSet) || (fNegated && fInSet)) 
                        goto BACK;
                        
		    		fCharSet = FALSE;		// this marks the end of a character set
		    	} 
                else 
                {
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '-':
		    	if (fCharSet) 
                {
		    		unsigned char startRange = pszPattern[-1];	// we use unsigned char
					unsigned char endRange;						// to support extended
					unsigned char ch;							// characters

		    		if (pszPattern[1] == '\0')
		    			return ERROR_INVALID_PARAMETER;
		    		else 
                    {
                        if (pszPattern[1] == ']')		// a dash at the end of the set is
		    			    fInSet = (*pszText == '-');	// treated as a literal
		    		    else 
                        {							    // we have a range
		    		    	if (pszPattern[1] == '\\')  // escape character, skip it
                            {	
		    		    		pszPattern++;
		    		    		if (pszPattern[1] == '\0') 
                                    return ERROR_INVALID_PARAMETER;
		    		    	}
							ch = *pszText;
							endRange = pszPattern[1];

							if (startRange > endRange)
								return ERROR_INVALID_PARAMETER;
							// here is where we could need unsigned characters
		    		    	fInSet = (ch >= startRange && ch <= endRange);
		    		    	pszPattern++;
		    		    	break;
		    		    }
                    }
		    	} 
                else 
                {						// outside a character set '-' has no special meaning
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '\0':					// end of the pattern
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
		    	if (*pszText == '\0')
		    		return ERROR_SUCCESS;
		    	else
		    		goto BACK;
		    	break;

		    default:				
DEFAULT:    	
                if (*pszPattern == '\\') 
                {
		    		pszPattern++;		// escape character, treat the next character as a literal
		    		if (*pszPattern == '\0') 
                        return ERROR_INVALID_PARAMETER;
		    	}
		    	if (!fCharSet) 
                {						// any other character is treated as a literal
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	} 
                else 
                {
		    		// the following if takes care of the two "special" cases:
		    		//		[c-a]       (we don't want to accept c), and
		    		//		[c-]		(we want to accept c)
		    		if (!(pszPattern[1] == '-' && pszPattern[2] != ']'))
		    			fInSet = (*pszText == *pszPattern);
		    	}
		    	break;
		} // switch

		pszPattern++;
		
        if (!fCharSet) 
        {
			if (*pszText != '\0') 
                pszText++;
		} 
        else 
        {               			// code to short-circuit character set evaluation
			if (fInSet) 			// skip the rest of the character set
            {		
				while (*pszPattern != '\0' && *pszPattern != ']') 
                {
					if (*pszPattern == '\\')
                    {				// escape character, treat the next character as a literal
						pszPattern++;
						if (*pszPattern == '\0') 
                            return ERROR_INVALID_PARAMETER;
					}
					pszPattern++;
				}
			}
		}
		continue;	// the continue statement is to jump to the beginning of the loop,
					// we could have used used goto some label but that's what continue's
					// are for.


		// This is only reached by jumping to BACK.
		// This is equivalent to returning from a recursive solution of wildmat.
		// If the stack pointer is zero then the bottommost "recursive call" failed,
		// otherwise we "unwind one stack frame" and resume execution of the previous
		// call at the top of the while loop. Notice that since "recursive calls" are
		// only done when we find a '*' in the pattern outside a character set, the
		// value of fCharSet has to be set to false.
BACK:	
        if (iStackPtr == 0)                     	// we exhausted all possibilities
            return ERROR_FILE_NOT_FOUND;
            
		iStackPtr--;						    	// try matching no characters with the '*'
		pszText = textStack[iStackPtr];
		pszPattern = patternStack[iStackPtr] + 1;	// eat the '*' matching no input characters
		fCharSet = FALSE;				        	// this has to be the case
	} // while

    // should never get here
	_ASSERT(FALSE);						
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\sfromcl.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sfromcl.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to SlaveFromClient Infeeds


Author:

    Carl Kadie (CarlK)     12-Dec-1995

Revision History:

--*/


#include "stdinc.h"


BOOL
CSlaveFromClientArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn,
							 PDWORD pdwLinesOffset
			  )
/*++

Routine Description:

	 Just like FromClientArticle's fMungeHeaders only doesn't create a xref,
		 just removes it


Arguments:

	grouplist - a list of the newsgroups the article is posted to.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	nntpReturn.fSetClear(); // clear the return object

	if (!(
  			   m_fieldMessageID.fSet(*this, pcDNS, nntpReturn)
  			&& m_fieldNewsgroups.fSet(*this, nntpReturn)
  			&& m_fieldDistribution.fSet(*this, nntpReturn)
  			&& m_fieldDate.fSet(*this, nntpReturn)
  			&& m_fieldOrganization.fSet(*this, nntpReturn)
			/* && m_fieldLines.fSet(*this, nntpReturn) */
  			&& m_fieldPath.fSet(*this, pcHub, nntpReturn)
			&& m_fieldNNTPPostingHost.fSet(*this, remoteIpAddress, nntpReturn)
			/* && m_fieldXAuthLoginName.fSet(*this, nntpReturn) */
			/* && m_fieldXref.fSet(*this, nntpReturn) */
			&& fDeleteEmptyHeader(nntpReturn)
			&& fSaveHeader(nntpReturn)
		))
		return nntpReturn.fFalse();

	//
	// We didn't seem to care about Lines field, tell the caller not to back 
	// fill
	//
	if ( pdwLinesOffset ) *pdwLinesOffset = INVALID_FILE_SIZE;

	return nntpReturn.fSetOK();
}

BOOL
CSlaveFromClientFeed::fPostInternal (
									 CNntpServerInstanceWrapper * pInstance,
									 const LPMULTISZ	szCommandLine, //the Post, Xreplic, IHave, etc. command line
									 CSecurityCtx   *pSecurityCtx,
									 CEncryptCtx *pEncryptCtx,
									 BOOL fAnonymous,
									 CARTPTR	& pArticle,
                                     CNEWSGROUPLIST &grouplist,
                                     CNAMEREFLIST &namereflist,
                                     IMailMsgProperties *pMsg,
									 CAllocator & allocator,
									 char*		& multiszPath,
									 char*		pchMessageId,
									 DWORD		cbMessageId,
									 char*		pchGroups,
									 DWORD		cbGroups,
									 DWORD		remoteIpAddress,
									 CNntpReturn & nntpReturn,
                                     PFIO_CONTEXT *ppFIOContext,
                                     BOOL *pfBoundToStore,
                                     DWORD *pdwOperations,
                                     BOOL *pfPostToMod,
                                     LPSTR  szModerator
						)
/*++

Routine Description:


	 Does most of the processing for an incoming article.


Arguments:

	hFile - The handle of the file.
	szFilename - The name of the file.
	szCommandLine -  the Post, Xreplic, IHave, etc. command line
	pArticle - a pointer to the article being processed
	pGrouplist - pointer to a list of newsgroup objects to post to.
	pNamerefgroups - pointer to a list of the names, groupid and article ids of the article
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
 	TraceFunctEnter( "CSlaveFromClientFeed::fPostInternal" );

    HRESULT hr      = S_OK;
    HANDLE  hToken  = NULL;

	nntpReturn.fSetClear(); // clear the return object

	CNewsTreeCore*  pNewstree = pInstance->GetTree() ;
	CPCString pcHub(pInstance->NntpHubName(), pInstance->HubNameSize());
	CPCString pcDNS(pInstance->NntpDNSName(), pInstance->NntpDNSNameSize()) ;

	//
	//	After initializing the article object - get the message-id thats in the article 
	//	for logging purposes - we may overwrite this later, but we want to try to get the 
	//	message-id now so we have it in case of most errors !
	//

	strncpy( pchMessageId, pArticle->szMessageID(), cbMessageId ) ;

	//
	// Validate the article
	//

	if (!pArticle->fValidate(pcHub, szCommandLine, this, nntpReturn))
		return nntpReturn.fFalse();
	
	//
	// Find the list of newsgroups the poster wants to post to.
	//

	DWORD cNewsgroups = pArticle->cNewsgroups();
	if (!grouplist.fInit(cNewsgroups, pArticle->pAllocator()))
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if (!namereflist.fInit(cNewsgroups, pArticle->pAllocator()))
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if (!fCreateGroupLists(pNewstree, pArticle, grouplist, (CNAMEREFLIST*)NULL, szCommandLine, pcHub, nntpReturn))
		return nntpReturn.fFalse();

	//
	//	Set up the namereflist object to refer to the slave posting group !
	//

	CGRPCOREPTR pGroup = pNewstree->GetGroupById(pNewstree->GetSlaveGroupid());//!!!!!pNewstree->GetSlaveGroupid()
	if (!pGroup)
	{
		_ASSERT(FALSE);
		return nntpReturn.fSet(nrcSlaveGroupMissing);
	}


	// Alocate the article id
    ARTICLEID   articleId ;

	articleId = pGroup->AllocateArticleId();

	NAME_AND_ARTREF	Nameref ;
	(Nameref.artref).m_groupId = pGroup->GetGroupId() ;
	(Nameref.artref).m_articleId = articleId ;
	(Nameref.pcName).vInsert( pGroup->GetName() ) ;
	namereflist.AddTail( Nameref ) ;

	if( grouplist.IsEmpty() ) 
	{
        // If this is a newgroup control message it is ok to have an empty grouplist at this stage
        CONTROL_MESSAGE_TYPE cmControlMessage = pArticle->cmGetControlMessage();

        if(cmNewgroup != cmControlMessage)
        {
			BOOL	fOk = nntpReturn.fSet(nrcNoGroups()) ;

			if( !fOk ) {
				return	fOk ;
			}
		}
	}

    //
    //  moderated newsgroup check (check Approved: header for moderator)
    //
	if (!fModeratedCheck(   pInstance,
	                        pArticle, 
	                        grouplist, 
	                        gHonorApprovedHeaders, 
	                        nntpReturn,
	                        szModerator ))
    {
        //
        // If FALSE is returned, we'll still check nntpReturn, if nntpReturn is
        // OK, it means the group is moderated and we should mail the message
        // to moderator;  otherwise it's a real failed case
        //
        if ( !nntpReturn.fIsOK() ) return FALSE;
        else {
            *pfPostToMod = TRUE;
        }
    }

	//
	//	Now do security check
	//
	if( pSecurityCtx || pEncryptCtx ) {
		if( !fSecurityCheck( pSecurityCtx, pEncryptCtx, grouplist, nntpReturn ) ) 
			return	nntpReturn.fFalse() ;
	}
    
    //
    //  check for control messages - just do ACL checks with the client context
    //
    // Should not apply control message at all at this point, we should apply
    // control message when the post comes back from master
    //
    /*
	if (!fApplyControlMessage(pArticle, pSecurityCtx, pEncryptCtx, fAnonymous, grouplist, &namereflist, nntpReturn))
    {
		if( !nntpReturn.fIsOK() )
		{
			// bump perfmon counter
			pInstance->BumpCounterControlMessagesFailed();
		}

        // Return TRUE if control message was applied successfully, FALSE otherwise
		return nntpReturn.fIsOK();
    }
    */

	//
  	// Looks OK so munge the headers
    // remove xref and add path
    //

	if (!pArticle->fMungeHeaders(pcHub, pcDNS, namereflist, remoteIpAddress, nntpReturn))
		return nntpReturn.fFalse();

	strncpy( pchMessageId, pArticle->szMessageID(), cbMessageId ) ;
	if( pchGroups != 0 ) 
		SaveGroupList(	pchGroups,	cbGroups, grouplist ) ;

	//
	// Move the article to a local place, and then queues it up on any outfeeds
	//

	pArticle->vFlush() ;
	pArticle->vClose();

    //
    // at this point we are ready to go, talk to the first driver and 
    // get a file handle that we can write to
    //
    CNNTPVRoot *pVRoot = pGroup->GetVRoot();
    _ASSERT( pVRoot );
    IMailMsgStoreDriver *pStoreDriver = pVRoot->GetStoreDriver();
    if ( NULL == pStoreDriver ) {
        pVRoot->Release();
        return nntpReturn.fSet( nrcNewsgroupInsertFailed, pGroup->GetGroupName(), pchMessageId );
    }

    //
    // Get the right hToken: the post should have permission to post
    // to the slave group
    //
    if ( pVRoot->GetImpersonationHandle() )
        hToken = pVRoot->GetImpersonationHandle();
    else {
        if ( NULL == pEncryptCtx && pSecurityCtx == NULL )
            hToken = NULL;
        else if ( pEncryptCtx->QueryCertificateToken() ) {
            hToken = pEncryptCtx->QueryCertificateToken();
        } else {
            hToken = pSecurityCtx->QueryImpersonationToken();
        }
    }

    //
    // Fill up properties into mailmsg: we know that slave group is going to 
    // be file system only, so passing in group pointer and article id would be
    // enough
    //
    hr = FillInMailMsg(pMsg, pGroup, articleId, hToken, szModerator ); 
    if ( SUCCEEDED( hr ) ) {
        pMsg->AddRef();
        HANDLE hFile;
        IMailMsgPropertyStream *pStream = NULL;
        hr = pStoreDriver->AllocMessage( pMsg, 0, &pStream, ppFIOContext, NULL );
        if ( SUCCEEDED( hr ) && pStream == NULL ) {
            pStream = XNEW CDummyMailMsgPropertyStream;
            if ( NULL == pStream ) hr = E_OUTOFMEMORY;
        }
        if ( SUCCEEDED( hr ) ) {

            //
            // Bind the handle to the mailmsg object
            //
            IMailMsgBind *pBind = NULL;
            hr = pMsg->QueryInterface(__uuidof(IMailMsgBind), (void **) &pBind);
            if ( SUCCEEDED( hr ) ) {
                hr = pBind->BindToStore(    pStream,
                                            pStoreDriver,
                                            *ppFIOContext );
                if ( SUCCEEDED( hr ) ) *pfBoundToStore = TRUE;
            }
            if ( pBind ) pBind->Release();
            pBind = NULL;
        }
    }
    
    if ( pStoreDriver ) pStoreDriver->Release();
    pStoreDriver = NULL;
    if ( pVRoot ) pVRoot->Release();
    pVRoot = NULL;

    if ( FAILED( hr ) ) return nntpReturn.fSet( nrcNewsgroupInsertFailed, NULL, NULL ); 

    //
    // Now ready to put it into push feed queue
    //
    /* not until we have committed the post
	CArticleRef	articleRef( pGroup->GetGroupId(), articleId ) ;
	if( !pInstance->AddArticleToPushFeeds( grouplist, articleRef, multiszPath, nntpReturn ) )
		return	nntpReturn.fFalse() ;
    */

	TraceFunctLeave();
	return nntpReturn.fSetOK();
}

HRESULT CSlaveFromClientFeed::FillInMailMsg(IMailMsgProperties *pMsg, 
							                CNewsGroupCore *pGroup, 
							                ARTICLEID   articleId,
							                HANDLE       hToken,
                                            char*       pszApprovedHeader )
/*++
Routine description:

    Fill in properties into mailmsg object so that driver can get those
    properties on AllocMessage

Arguments:

    IMailMsgProperties *pMsg    - The message object
    CNNTPVRoot *pVRoot          - Pointer to the vroot
    CNewsGroupCore *pGroup      - The group to alloc the message from
    ARTICLEID   articleId       - The article id for this article
    HANDLE      hToken          - Client hToken

Return value:

    HRESULT
--*/
{
	TraceFunctEnter("CSlaveFromClientFeed::FillInMailMsg");
	
	DWORD i=0;
	DWORD rgArticleIds[1];
	INNTPPropertyBag *rgpGroupBags[1];
	HRESULT hr;

    //
	// build up the entries needed in the property bag
	//
	rgpGroupBags[0] = pGroup->GetPropertyBag();

	//
	// we don't need to keep this reference because we have a reference
	// counted one already in the pGroup and we know that AllocMessage
	// is synchronous
	//.  
	rgpGroupBags[0]->Release();
	rgArticleIds[0] = articleId;
	
	DebugTrace( 0, 
				"group %s, article %i", 
				pGroup->GetGroupName(),
				articleId);

	hr = FillMailMsg(pMsg, rgArticleIds, rgpGroupBags, 1, hToken, pszApprovedHeader );
	if (FAILED(hr)) return hr;

	TraceFunctLeave();
	return S_OK;
}

void CSlaveFromClientFeed::CommitPostToStores(  CPostContext *pContext, 
                                                CNntpServerInstanceWrapper *pInstance)
/*++
Routine description:

    Since we know that sfromclient type of post will be only posted to
    slave group in file system.  We pretty much don't need to do anything
    here except to put the article into feed queue

Arguments:

    CPostContext *pContext  - Post context

Return value:

    None.
--*/
{
	TraceFunctEnter("CSlaveFromclientFeed::CommitPostToStores");
	_ASSERT( pContext );
	_ASSERT( pInstance );

	CNntpReturn ret;

	//
	// If it's posted to a moderated group, we'll try to apply
	// the moderator stuff by sending out the article
	//
	if ( pContext->m_fPostToMod ) {

	    pContext->CleanupMailMsgObject();
	    ApplyModerator( pContext, ret );

	    if ( ret.fIsOK() ) 
	        pContext->m_completion.m_nntpReturn.fSet( nrcArticleAccepted(pContext->m_fStandardPath) );
	    else
	        pContext->m_completion.m_nntpReturn.fSet( nrcArticleRejected(pContext->m_fStandardPath) );
	} else {

    	//
	    // We try real hard to get the slave group id and article id from namereflist
    	// remember ?  we added the slave group ref info to tail of namereflist
	    //
    	POSITION posNamereflist = pContext->m_namereflist.GetHeadPosition();
	    NAME_AND_ARTREF *pnameref;
    	DWORD       err;

	    while( posNamereflist ) {
	        pnameref = pContext->m_namereflist.GetNext( posNamereflist );
        }

        //
        // There must be one art ref in there
        //
        _ASSERT( pnameref );

	    //
    	// Put it onto push feed queue
	    //
    	if( !pInstance->AddArticleToPushFeeds(  pContext->m_grouplist, 
	                                            pnameref->artref, 
	                                            pContext->m_multiszPath, 
	                                            ret ) ) {
    	    err = GetLastError();
	        if ( NO_ERROR == err ) err = ERROR_NOT_ENOUGH_MEMORY;
	        pContext->m_completion.SetResult( HRESULT_FROM_WIN32( err ) );
    	    pContext->m_completion.m_nntpReturn.fSet( nrcArticleRejected( pContext->m_fStandardPath),
	                                                ret.m_nrc, 
	                                                ret.szReturn() );
    	} else {
	        pContext->m_completion.SetResult( S_OK );
	        pContext->m_completion.m_nntpReturn.fSet( nrcArticleAccepted( pContext->m_fStandardPath));
    	}
    }

	//
	// Before we release the completion object, we should tell the destroy guy 
	// that 1. we are the only group to be committed and hence we are done; 2.
	// set the flag telling it not to insert us into map entries
	//
	pContext->m_completion.m_fWriteMapEntries = FALSE;
	pContext->m_cStoreIds = pContext->m_cStores;

	//
	// Now release the completion object
	//
	pContext->m_completion.Release();

	TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\utest\stdinc.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\utest\wildmat.h ===
//---[ wildmat.h ]-------------------------------------------------------------
//
//  Description:
//      Provides support for the "wildmat" wildcard matching standard. Info
//      on this standard comes from the internet draft:
//
//      draft-barber-nntp-imp-03.txt
//      S. Barber
//      April, 1996
//
//  Copyright (C) Microsoft Corp. 1996.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

#ifndef _WILDMAT_H_
#define _WILDMAT_H_

//---[ Prototypes ]------------------------------------------------------------

HRESULT HrMatchWildmat( const char *pszText, const char *pszPattern );

#endif // _WILDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\src\seomsg.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	ptable.cpp

Abstract:

	This module contains the property table

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/05/97	created

--*/

#include "stdinc.h"
#include "props.h"
#include "seostrm.h"

// ======================================================================
// Define macros for declaring accessors
//
#define GET_ACCESSOR(PropertyName)								\
	static HRESULT Get##PropertyName(LPSTR	pszName,			\
						LPVOID	pContext,						\
						LPVOID	pCacheData,						\
						LPVOID	pvBuffer,						\
						LPDWORD	pdwBufferLen)

#define SET_ACCESSOR(PropertyName)								\
	static HRESULT Set##PropertyName(LPSTR	pszName,			\
						LPVOID	pContext,						\
						LPVOID	pCacheData,						\
						LPVOID	pvBuffer,						\
						DWORD	dwBufferLen,					\
						DWORD	ptPropertyType)

#define COMMIT_ACCESSOR(PropertyName)							\
	static HRESULT Commit##PropertyName(LPSTR	pszName,		\
						LPVOID	pContext,						\
						LPVOID	pCacheData)

#define INVALIDATE_ACCESSOR(PropertyName)						\
	static HRESULT Invalidate##PropertyName(LPSTR	pszName,	\
					LPVOID	pCacheData,							\
					DWORD	ptPropertyType)

#define DECLARE_ACCESSORS(PropertyName)							\
	GET_ACCESSOR(PropertyName);									\
	SET_ACCESSOR(PropertyName);									\
	COMMIT_ACCESSOR(PropertyName);								\
	INVALIDATE_ACCESSOR(PropertyName)

#define ACCESSOR_LIST(PropertyName)								\
	Get##PropertyName, Set##PropertyName,						\
	Commit##PropertyName, Invalidate##PropertyName

// ======================================================================
// Forward declarations for the accessor functions
//
DECLARE_ACCESSORS(MessageStream);
DECLARE_ACCESSORS(Newsgroups);
DECLARE_ACCESSORS(Header);
DECLARE_ACCESSORS(Filename);
DECLARE_ACCESSORS(FeedID);
DECLARE_ACCESSORS(Post);
DECLARE_ACCESSORS(ProcessControl);
DECLARE_ACCESSORS(ProcessModerator);
#ifdef SECURITY_CONTEXT_PROPERTY
DECLARE_ACCESSORS(SecurityContext);
#endif

// ======================================================================
// Define the property table array.  The most used items should be in
// the front of the list for speed.  Items that have cCharsToCompare not
// equal to 0 are slightly more expensive to compare.
//
// Instructions for adding static properties:
// 1) Declare the accessors above
// 2) Add the item to the table below in sorted manner
// 3) Implement the 4 accessors.
//
PROPERTY_ITEM g_rgpiPropertyTable[] = {
	{ "newsgroups",			0, PT_STRING,		PA_READ_WRITE,	NULL, NULL, ACCESSOR_LIST(Newsgroups) 		},
	{ "message stream",		0, PT_INTERFACE,	PA_READ, 		NULL, NULL, ACCESSOR_LIST(MessageStream)	},
	{ "header-",			7, PT_STRING,		PA_READ,		NULL, NULL, ACCESSOR_LIST(Header)			},
	{ "post",				0, PT_DWORD,		PA_READ_WRITE,	NULL, NULL, ACCESSOR_LIST(Post)			 	},
	{ "process control",	0, PT_DWORD,		PA_READ_WRITE,	NULL, NULL, ACCESSOR_LIST(ProcessControl)	},
	{ "process moderator",	0, PT_DWORD,		PA_READ_WRITE,	NULL, NULL, ACCESSOR_LIST(ProcessModerator)	},
	{ "filename",			0, PT_STRING,		PA_READ,		NULL, NULL, ACCESSOR_LIST(Filename)			},
	{ "feedid",				0, PT_DWORD,		PA_READ,		NULL, NULL, ACCESSOR_LIST(FeedID)			},
#if SECURITY_CONTEXT_PROPERTY
	{ "security context",	0, PT_DWORD,		PA_WRITE,  	 	NULL, NULL, ACCESSOR_LIST(SecurityContext) 	},
#endif
}; 

// ======================================================================
// Implementation of property accessors
//

// ======================================================================
// Get methods
//
// The get methods are implementation-specific. It first checks if the 
// desired property is already cached. If so, the cached value is returned
// Otherwise, it will fetch the value from the media. This makes sure
// that the properties will not be loaded if not necessary.

GET_ACCESSOR(MessageStream) {
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;
    CPropertyValueInterface *pCache = (CPropertyValueInterface *) pCacheData;

	IStream *pStream = NULL;

    if (!(pCache->IsValid())) {
		//
		// 3 possible cases:
		// OnPostFinal - article was cached in memory:
		//		in this case m_hFile will be valid and will point to the 
		//		file which was written into the store with the article
		// OnPostFinal - article was read onto disk (>4k):
		//		in this case m_hFile == INVALID_HANDLE_VALUE, but 
		//		m_szFilename != NULL.  create a stream from the filename
		// OnPost - article is mapped into memory
		// 		in this case we can use pStream->fGetStream to get an
		//		article stream
		//
		if (pParams->m_hFile != INVALID_HANDLE_VALUE) {
			CStreamFile *pFileStream = XNEW CStreamFile(pParams->m_hFile, FALSE, TRUE);
			if (pFileStream == NULL) return E_OUTOFMEMORY;
			pStream = pFileStream;
		} else if (pParams->m_szFilename != NULL) {
			HANDLE hFile = CreateFile(pParams->m_szFilename, 
									  GENERIC_READ | GENERIC_WRITE, 
									  0, NULL, OPEN_EXISTING, 
									  FILE_ATTRIBUTE_NORMAL, NULL);
			if (hFile == INVALID_HANDLE_VALUE) 
				return HRESULT_FROM_WIN32(GetLastError());
			
			CStreamFile *pFileStream = XNEW CStreamFile(hFile, TRUE, TRUE);
			if (pFileStream == NULL) return E_OUTOFMEMORY;
			pStream = pFileStream;
		} else {
			if (!pParams->m_pArticle->fGetStream(&pStream)) return E_OUTOFMEMORY;
			_ASSERT(pStream != NULL);
		}
		pCache->Set(pStream, FALSE);
    }

	// copy from the cache back to the user
    if (*pdwBufferLen < sizeof(IUnknown *)) {
    	*pdwBufferLen = sizeof(IUnknown *);
		return(TYPE_E_BUFFERTOOSMALL);
	}

    *(IUnknown **)pvBuffer = pCache->Get();
    *pdwBufferLen = sizeof(IUnknown *);
	return S_OK;
}

GET_ACCESSOR(Newsgroups) {
	CPropertyValueString *pCache = (CPropertyValueString *)pCacheData;
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;

	// if its not in the cache then retrieve it from the CArticle object,
	// then put the results into the cache
	if (!pCache->IsValid()) {
		char szNewsgroups[1024] = "";

		DWORD iGroupList, cGroupList = pParams->m_pGrouplist->GetCount();
		POSITION posGroupList = pParams->m_pGrouplist->GetHeadPosition();
		for (iGroupList = 0; 
			 iGroupList < cGroupList; 
			 iGroupList++, pParams->m_pGrouplist->GetNext(posGroupList)) 
		{
			CPostGroupPtr *pPostGroupPtr = pParams->m_pGrouplist->Get(posGroupList);
			CGRPCOREPTR pNewsgroup = pPostGroupPtr->m_pGroup;
			_ASSERT(pNewsgroup != NULL);
			if (iGroupList > 0) lstrcatA(szNewsgroups, ",");
			lstrcatA(szNewsgroups, pNewsgroup->GetName());
		}

		// update the cache
		HRESULT hr;
		hr = pCache->Set(szNewsgroups, FALSE);
		if (FAILED(hr)) return hr;
	}

	// We should have the address string here, copy it into the buffer
	_ASSERT(pCache->IsValid());
	DWORD cData;
	LPSTR pszData = pCache->Get(&cData);
	if (cData > *pdwBufferLen) {
		*pdwBufferLen = cData;
		return(TYPE_E_BUFFERTOOSMALL);
	}

	// Copy from cache to the buffer
	MoveMemory(pvBuffer, pszData, cData);
	*pdwBufferLen = cData;
	return(S_OK);
}

GET_ACCESSOR(Header) {
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;

	_ASSERT(pCacheData == NULL);

	DWORD cBufferLen;
	char *pszHeader = pszName + 7;
	BOOL f = pParams->m_pArticle->fGetHeader(pszHeader, (BYTE *) pvBuffer, *pdwBufferLen, cBufferLen);
	*pdwBufferLen = cBufferLen + 1;
	if (!f) {
		switch (GetLastError()) {
			case ERROR_INSUFFICIENT_BUFFER:
				return TYPE_E_BUFFERTOOSMALL;
				break;
			default:
				return HRESULT_FROM_WIN32(GetLastError());
				break;
		}
	} 

	// NULL terminate and remove the CRLF from the string before returning it
	((BYTE *) pvBuffer)[cBufferLen - 2] = 0;

	return S_OK;
}

GET_ACCESSOR(Filename) {
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;

	_ASSERT(pCacheData == NULL);

	HRESULT hr;

	// this property is only supported in the OnPostFinal event
	if (!(pParams->m_fOnPostFinal)) {
		hr = E_ACCESSDENIED;
	} else {
		_ASSERT(pParams->m_szFilename != NULL);
		// make sure that they have enough buffer space to do the copy.  if
		// not then report how much space we require.
		DWORD cFilename = lstrlenA(pParams->m_szFilename) + 1;
		if (cFilename > *pdwBufferLen) {
			hr = TYPE_E_BUFFERTOOSMALL;
		} else {
			memcpy(pvBuffer, pParams->m_szFilename, cFilename);
			hr = S_OK;
		}
		*pdwBufferLen = cFilename;
	}

	return hr;
}

GET_ACCESSOR(FeedID) {
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;

	_ASSERT(pCacheData == NULL);

	HRESULT hr;

	// make sure they gave us enough buffer space
	if (sizeof(DWORD) > *pdwBufferLen) {
		hr = TYPE_E_BUFFERTOOSMALL;
	} else {
		*((DWORD *) pvBuffer) = pParams->m_dwFeedId;
		hr = S_OK;
	}
	*pdwBufferLen = sizeof(DWORD);

	return hr;
}

static inline HRESULT GetOperationBit(LPSTR pszName,
							   LPVOID pContext,	
							   LPVOID pCacheData,
							   LPVOID pvBuffer,	
							   LPDWORD pdwBufferLen,
							   DWORD dwOperationBit)
{
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;
    CPropertyValueDWORD     *pCache = (CPropertyValueDWORD *)pCacheData;

	// these operation bits aren't supported in the OnPostFinal event
	if (pParams->m_fOnPostFinal) {
		return E_ACCESSDENIED;
	}

    if (!(pCache->IsValid())) {
		// get the property from the nntpparams structure and put it into
		// the cache
		pCache->Set(((*(pParams->m_pdwOperations) & dwOperationBit) == 
														 	dwOperationBit), 
					FALSE);
    }

	// copy from the cache back to the user
    if (*pdwBufferLen < sizeof(DWORD)) {
    	*pdwBufferLen = sizeof(DWORD);
		return(TYPE_E_BUFFERTOOSMALL);
	}

    *(DWORD *)pvBuffer = pCache->Get();
    *pdwBufferLen = sizeof(DWORD);
    return(S_OK);
}

GET_ACCESSOR(Post) {
	return GetOperationBit(pszName, pContext, pCacheData, pvBuffer, 
						   pdwBufferLen, OP_POST);
}

GET_ACCESSOR(ProcessControl) {
	return GetOperationBit(pszName, pContext, pCacheData, pvBuffer, 
						   pdwBufferLen, OP_PROCESS_CONTROL);
}

GET_ACCESSOR(ProcessModerator) {
	return GetOperationBit(pszName, pContext, pCacheData, pvBuffer, 
						   pdwBufferLen, OP_PROCESS_MODERATOR);
}

#ifdef SECURITY_CONTEXT_PROPERTY
GET_ACCESSOR(SecurityContext) {
	// write-only
	return E_NOTIMPL;
}
#endif

// ======================================================================
// Set methods
//
// We don't want to hit the medium every time a sink calls set, we just
// update the internal cache records. When the source gets this back, it
// will commit the changes to media.
//
// We provide and use generic set methods.

SET_ACCESSOR(MessageStream) {
	// read-only, so nothing to set
	return E_NOTIMPL;
}

SET_ACCESSOR(Newsgroups) {
	// these operation bits aren't supported in the OnPostFinal event
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;
	if (pParams->m_fOnPostFinal) {
		return E_ACCESSDENIED;
	}

	CPropertyValueString *pCache = (CPropertyValueString *) pCacheData;
	if (ptPropertyType != PT_STRING) return E_INVALIDARG;
	return pCache->Set((LPSTR) pvBuffer, TRUE);
}

SET_ACCESSOR(Header) {
	// read-only, so nothing to set
	return E_NOTIMPL;
}

SET_ACCESSOR(Filename) {
	// read-only, so nothing to set
	return E_NOTIMPL;
}

SET_ACCESSOR(FeedID) {
	// read-only, so nothing to set
	return E_NOTIMPL;
}

static inline HRESULT SetDWORD(LPSTR pszName,
							   LPVOID pContext,
							   LPVOID pCacheData,
							   LPVOID pvBuffer,	
							   DWORD dwBufferLen,
							   DWORD ptPropertyType)
{
	// these operation bits aren't supported in the OnPostFinal event
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;
	if (pParams->m_fOnPostFinal) {
		return E_ACCESSDENIED;
	}

	CPropertyValueDWORD *pCache = (CPropertyValueDWORD *) pCacheData;
	if (ptPropertyType != PT_DWORD) return E_INVALIDARG;
	if (dwBufferLen != sizeof(DWORD)) return E_INVALIDARG;
	return pCache->Set(*((DWORD *) pvBuffer), TRUE);
}

SET_ACCESSOR(Post) {
	return SetDWORD(pszName, pContext, pCacheData, pvBuffer, dwBufferLen, ptPropertyType);
}

SET_ACCESSOR(ProcessControl) {
	return SetDWORD(pszName, pContext, pCacheData, pvBuffer, dwBufferLen, ptPropertyType);
}

SET_ACCESSOR(ProcessModerator) {
	return SetDWORD(pszName, pContext, pCacheData, pvBuffer, dwBufferLen, ptPropertyType);
}

#ifdef SECURITY_CONTEXT_PROPERTY
SET_ACCESSOR(SecurityContext) {
	return SetDWORD(pszName, pContext, pCacheData, pvBuffer, dwBufferLen, ptPropertyType);
}
#endif

// ======================================================================
// Commit methods
//
// These methods are called when the source gets this back after all
// sinks have done processing, it commits changed informaiton to the media

COMMIT_ACCESSOR(MessageStream) {
	// read-only, so nothing to commit.
	return S_OK;
}

COMMIT_ACCESSOR(Newsgroups) {
    CPropertyValueString *pCache = (CPropertyValueString *)pCacheData;
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;

	if (!(pCache->HasChanged())) return TRUE;
	char *szGroup = pCache->Get(), *szNextGroup;

	CNntpServerInstanceWrapper *pInstance;
	pInstance = pParams->m_pArticle->m_pInstance;
	_ASSERT(pInstance != NULL);

	// the property is cached as a string of group names, seperated by commas.
	// we walk this list, get the individual newsgroup names, and add them
	// to the group list.
	pParams->m_pGrouplist->RemoveAll();
	_ASSERT(pParams->m_pGrouplist->IsEmpty());
	do {
		szNextGroup = strchr(szGroup, ',');
		if (szNextGroup != NULL) {
			*szNextGroup = 0;
		}
		CNewsTreeCore *pTree = pInstance->GetTree();
		_ASSERT(pTree != NULL);
		CGRPCOREPTR pGroup = pTree->GetGroupPreserveBuffer(szGroup, 
													   lstrlen(szGroup)+1);
		if (pGroup) {
			pParams->m_pGrouplist->AddTail(CPostGroupPtr(pGroup));
		}
		if (szNextGroup != NULL) {
			*szNextGroup = ',';
			szGroup = szNextGroup + 1;
		}
	} while (szNextGroup != NULL);

	return S_OK;
}

COMMIT_ACCESSOR(Header) {
	// read-only, so nothing to commit.
	return S_OK;
}

COMMIT_ACCESSOR(Filename) {
	// read-only, so nothing to commit.
	return S_OK;
}

COMMIT_ACCESSOR(FeedID) {
	// read-only, so nothing to commit.
	return S_OK;
}

static inline 
HRESULT CommitOperationBit(LPSTR pszName,
						   LPVOID pContext,
						   LPVOID pCacheData,
						   DWORD dwOperationBit)
{
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;
    CPropertyValueDWORD     *pCache = (CPropertyValueDWORD *)pCacheData;

	if (!(pCache->HasChanged())) return S_OK;

	if (pCache->Get()) {
		*(pParams->m_pdwOperations) |= dwOperationBit;
	} else {
		*(pParams->m_pdwOperations) &= ~dwOperationBit;
	}

	return S_OK;
}

COMMIT_ACCESSOR(Post) {
	return CommitOperationBit(pszName, pContext, pCacheData, OP_POST);
}

COMMIT_ACCESSOR(ProcessControl) {
	return CommitOperationBit(pszName, pContext, pCacheData, 
							  OP_PROCESS_CONTROL);
}

COMMIT_ACCESSOR(ProcessModerator) {
	return CommitOperationBit(pszName, pContext, pCacheData, 
							  OP_PROCESS_MODERATOR);
}

#ifdef SECURITY_CONTEXT_PROPERTY
COMMIT_ACCESSOR(SecurityContext) {
	CNNTPDispatcher::CNNTPParams *pParams = 
							(CNNTPDispatcher::CNNTPParams *) pContext;
    CPropertyValueDWORD     *pCache = (CPropertyValueDWORD *)pCacheData;

	if (pCache->HasChanged()) *(pParams->m_phtokSecurity) = pCache->Get();
	return S_OK;
}
#endif

// ======================================================================
// Invalidate methods
//
// These methods are called when the source wants to rollback any changes
//
// We provide and use generic methods

static inline 
HRESULT InvalidateGeneric(LPSTR pszName,
						  LPVOID pCacheData,
						  DWORD ptPropertyType,
						  DWORD ptRequiredType)
{
	if (ptPropertyType != ptRequiredType) {
		_ASSERT(FALSE);
		return E_INVALIDARG;
	}
	CPropertyValue *pCache = (CPropertyValue *) pCacheData;
	pCache->Invalidate();

	return S_OK;
}

INVALIDATE_ACCESSOR(MessageStream) {
	return InvalidateGeneric(pszName, pCacheData, ptPropertyType, PT_INTERFACE);
}

INVALIDATE_ACCESSOR(Newsgroups) {
	return InvalidateGeneric(pszName, pCacheData, ptPropertyType, PT_STRING);
}

INVALIDATE_ACCESSOR(Header) {
	// we don't use a cache for this, so invalidate is a no-op
	return S_OK;
}

INVALIDATE_ACCESSOR(Filename) {
	// we don't use a cache for this, so invalidate is a no-op
	return S_OK;
}

INVALIDATE_ACCESSOR(FeedID) {
	// we don't use a cache for this, so invalidate is a no-op
	return S_OK;
}

INVALIDATE_ACCESSOR(Post) {
	return InvalidateGeneric(pszName, pCacheData, ptPropertyType, PT_DWORD);
}

INVALIDATE_ACCESSOR(ProcessControl) {
	return InvalidateGeneric(pszName, pCacheData, ptPropertyType, PT_DWORD);
}

INVALIDATE_ACCESSOR(ProcessModerator) {
	return InvalidateGeneric(pszName, pCacheData, ptPropertyType, PT_DWORD);
}

#ifdef SECURITY_CONTEXT_PROPERTY
INVALIDATE_ACCESSOR(SecurityContext) {
	return InvalidateGeneric(pszName, pCacheData, ptPropertyType, PT_DWORD);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\utest\nnpost.cpp ===
#include <stdinc.h>

#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName = NULL;
HANDLE  g_hProcessImpersonationToken = NULL;

class CNntpServerInstanceWrapperImpl : public CNntpServerInstanceWrapper {
	private:
		CXoverMap *m_pXoverMap;
		CMsgArtMap *m_pMsgArtMap;
		CNewsTreeCore *m_pNewsTreeCore;
		CHistory *m_pHistory;
		char m_szTempDir[MAX_PATH];

	public:
		CNntpServerInstanceWrapperImpl(CXoverMap *pXoverMap,
									   CMsgArtMap *pMsgArtMap,
									   CNewsTreeCore *pNewsTreeCore,
									   CHistory *pHistory) 
		{
			m_pXoverMap = pXoverMap;
			m_pMsgArtMap = pMsgArtMap;
			m_pNewsTreeCore = pNewsTreeCore;
			m_pHistory = pHistory;
			GetTempPath(MAX_PATH, m_szTempDir);
		};

		virtual BOOL AllowClientPosts() 
			{ return TRUE; }

		virtual BOOL AllowControlMessages() 
			{ return TRUE; }

		virtual DWORD FeedHardLimit() 
			{ return 100000000; }

		virtual DWORD FeedSoftLimit() 
			{ return 100000000; }

		virtual void EnterRPCCritSec() 
			{ }

		virtual void LeaveRPCCritSet() 
			{ }

        virtual void EnterNewsgroupCritSec()
            { }

        virtual void LeaveNewsgroupCritSec()
            { }

		virtual CMsgArtMap *ArticleTable() 
			{ return m_pMsgArtMap; }

		virtual CHistory *HistoryTable() 
			{ return m_pHistory; }

		virtual CXoverMap *XoverTable() 
			{ return m_pXoverMap; }

		virtual char *NntpHubName() 
			{ return "nnpost"; }

		virtual DWORD HubNameSize() 
			{ return strlen(NntpHubName()); }

		virtual char *NntpDNSName()
			{ return "nnpost"; }

		virtual DWORD NntpDNSNameSize() 
			{ return strlen(NntpDNSName()); }

		virtual CNewsTreeCore *GetTree() 
			{ return m_pNewsTreeCore; }

		virtual void BumpCounterControlMessagesFailed() 
			{ }

		virtual void BumpCounterArticlesReceived() 
			{ }

		virtual void BumpCounterArticlesPosted() 
			{ }

		virtual void BumpCounterModeratedPostingsSent() 
			{ }

		virtual void BumpCounterControlMessagesIn() 
			{ }

		virtual void IncrementFeedCounter(void *feedcompcontext, DWORD nrc) 
			{ }

		virtual BOOL ExpireArticle(GROUPID groupid, ARTICLEID artid, STOREID *pStoreId, CNntpReturn &nntpreturn) {
			printf("!!!!! Expire %i %i\n", groupid, artid);
			return FALSE;
		}

		virtual BOOL DeletePhysicalArticle(GROUPID groupid, ARTICLEID artid, STOREID *pStoreId) {
			printf("!!!!! DeletePhysicalArticle %i %i\n", groupid, artid);
			return FALSE;
		}

		virtual BOOL GetDefaultModerator(LPSTR pszNewsgroup, LPSTR pszDefaultModerator, PDWORD pcbDefaultModerator)
			{ return FALSE; }

		virtual BOOL AddArticleToPushFeeds(CNEWSGROUPLIST &newsgroups, CArticleRef artrefFirst, char *multiszPath, CNntpReturn &nntpReturn) {
			printf("!!!!! AddArticleToPushFeeds\n");
			return FALSE;
		}

		virtual BOOL NNTPCloseHandle(HANDLE &hFile, PCACHEFILE &pcontext) {
			printf("!!!!! NNTPCloseHandle\n");
			return FALSE;
		}

		virtual BOOL GetSmtpAddress( LPSTR pszAddress, PDWORD pcbAddress ) {
			return FALSE;
		}

		virtual PCHAR PeerTempDirectory() {
			return m_szTempDir;
		}
		
		virtual LPSTR QueryAdminEmail() {
			return "admin@none.com";
		}

		virtual DWORD QueryAdminEmailLen() {
			return strlen(QueryAdminEmail());
		}

		virtual DWORD QueryInstanceId() {
			return 1;
		}
};

VOID
CopyUnicodeStringIntoAscii(
            IN LPSTR AsciiString,
            IN LPWSTR UnicodeString
                 )
{
    while ( (*AsciiString++ = (CHAR)*UnicodeString++) != '\0');

} // CopyUnicodeStringIntoAscii

int __cdecl main(int argc, char **argv) {
    char szInetpubPath[MAX_PATH];
	char szDefaultIniSection[] = "nnpost";
	char *pszIniFile = NULL;
	char *pszIniSection = szDefaultIniSection;
	CNntpServer *pServer = NULL;
	CNewsTreeCore *pNewsTree = NULL;
	CNNTPVRootTable *pVRTable = NULL;
	CXoverMap *pXOver = NULL;
	CMsgArtMap *pArt = NULL;
	CHistory *pHistory = NULL;
	CNntpServerInstanceWrapper *pInstance = NULL;

    if (argc < 2) {
        printf("Usage: nnpost <ini file> <ini section>\n");
        exit(0);
    }
	pszIniFile = argv[1];
	if (argc > 2) pszIniSection = argv[2];

	printf("reading parameters from INI file %s, section [%s]\n",
		pszIniFile, pszIniSection);

    GetPrivateProfileString(pszIniSection,
                            "InetpubPath",
                            "",
                            szInetpubPath,
                            MAX_PATH,
                            pszIniFile);

    if (*szInetpubPath == 0) { 
		printf("ERROR: missing required key InetpubPath\n");
		return 1;
	}

    char szXOverFile[MAX_PATH];
	char szArticleFile[MAX_PATH];
	char szGroupList[MAX_PATH];
	char szGroupVarList[MAX_PATH];
	char szHistoryFile[MAX_PATH];

    sprintf(szXOverFile, "%s\\xover.hsh", szInetpubPath);
	sprintf(szArticleFile, "%s\\article.hsh", szInetpubPath);
	sprintf(szHistoryFile, "%s\\history.hsh", szInetpubPath);
	sprintf(szGroupList, "%s\\group.lst", szInetpubPath);
	sprintf(szGroupVarList, "%s\\groupvar.lst", szInetpubPath);

	printf("----- parameters -----\n");
	printf("xover.hsh path: %s\n", szXOverFile);
	printf("article.hsh path: %s\n", szArticleFile);
	printf("history.hsh path: %s\n", szHistoryFile);
	printf("group.lst path: %s\n", szGroupList);
	printf("groupvar.lst path: %s\n", szGroupVarList);
	

	// do global initializations
	_Module.Init(NULL, (HINSTANCE) INVALID_HANDLE_VALUE);
	HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr)) {
		printf("couldn't initialize COM, hr = 0x%x\n", hr);
		return 1;
	}

	CBuffer::InitClass();
	CArticle::InitClass();
	InitializeIISRTL() ;
    AtqInitialize( 0 ) ;
    crcinit();
    CVRootTable::GlobalInitialize();
    if (!CArticleCore::InitClass()) {
        printf("CArticleCore::InitClass() failed - 0x%x\n", GetLastError() );
        return 1;
    }
	printf("----- Initializing CHashMap\n");
	InitializeNNTPHashLibrary();

	// make our server objects
	printf("----- new CNntpServer\n");
    pServer = new CNntpServer();
	printf("----- new CNewsTreeCore\n");
    pNewsTree = new CNewsTreeCore(pServer);
	printf("----- new CNNTPVRootTable\n");
    pVRTable = new CNNTPVRootTable(pNewsTree->GetINewsTree(),
							CNewsTreeCore::VRootRescanCallback);
	BOOL fFatal;
	printf("----- Initializing newstree\n");
    pNewsTree->Init(pVRTable, fFatal, 100, TRUE);
	printf("----- Initializing vroot table\n");
    hr = pVRTable->Initialize("LM/nntpsvc/1/ROOT");
    printf("pVRTable->Initialize() returned %x\n", hr);

	printf("----- loading the newstree\n");
    pNewsTree->LoadTree(szGroupList, szGroupVarList);	


	printf("----- initializing CXoverMap\n");
	pXOver = CXoverMap::CreateXoverMap();
	pArt = CMsgArtMap::CreateMsgArtMap();
	pHistory = CHistory::CreateCHistory();
	if (pXOver && pArt && pHistory && !pXOver->Initialize(szXOverFile, 0)) {
		printf("CXoverMap::Initialize failed with %lu", GetLastError());
		delete pXOver;
		pXOver = NULL;
	}

	printf("----- initializing CMsgArtMap\n");
	if (pXOver && pArt && pHistory && !pArt->Initialize(szArticleFile, 0)) {
		printf("CMsgArtMap::Initialize failed with %lu", GetLastError());
		delete pArt;
		pArt = NULL;
	}	

	printf("----- initializing CHistory\n");
	if (pXOver && pArt && pHistory && !pHistory->Initialize(szHistoryFile, 0)) {
		printf("CHistory::Initialize failed with %lu", GetLastError());
		delete pHistory;
		pHistory = NULL;
	}	

	pInstance = new CNntpServerInstanceWrapperImpl(pXOver, pArt, pNewsTree, pHistory);

	printf("----- creating feed object and initializing it\n");
	CFromClientFeed *pFeed = new CFromClientFeed();
	char szTempPath[MAX_PATH];
	 GetTempPath(1024, szTempPath);
	pFeed->fInit(NULL,
				 szTempPath,
				 0,
				 0,
				 0,
				 FALSE,
				 TRUE,
				 -2);

	// parse the article to find the end of headers and end of body
	BOOL fSuccess = TRUE;
	char szArticle[] =
	 "From: alex\r\nSubject: alex\r\nNewsgroups: alex alex2\r\n\r\ntest\r\n.\r\n";
	DWORD cbArticle = strlen(szArticle);
	
	char *pDot = szArticle + (cbArticle - 5);

	// find the end of article
	while (fSuccess && memcmp(pDot, "\r\n.\r\n", 5) != 0) {
	    pDot--;
	    if (pDot == szArticle) fSuccess = FALSE;
	}
	if (fSuccess) {
		//
		// find the end of the headers
		//
		char *pEndBuffer = szArticle + (cbArticle - 1);
		char *pBodyStart = szArticle;
		while (fSuccess && memcmp(pBodyStart, "\r\n\r\n", 4) != 0) {
		    pBodyStart++;
		    if (pBodyStart >= pEndBuffer - 4) fSuccess = FALSE;
		}
		
		_ASSERT(pBodyStart > szArticle);
		_ASSERT(pDot < pEndBuffer);
		_ASSERT(pBodyStart < pEndBuffer);
		
		// this can happen if there is junk after the \r\n.\r\n that i
		// a \r\n\r\n
		if (pBodyStart >= pDot) fSuccess = FALSE;
		if (fSuccess) {
			DWORD cbTotal;
			CBUFPTR pbufHeaders = new (4000, cbTotal) CBuffer(cbTotal);
			pBodyStart += 4;
			DWORD cbHead = pBodyStart - szArticle;
			DWORD cbArticle = (pDot + 5) - szArticle;
	
			printf("cbHead = %i\n", cbHead);
			printf("cbArticle = %i\n", cbArticle);
			printf("cbuffer size = %i\n", pbufHeaders->m_cbTotal);
			BOOL f;
			DWORD cbNewHead, iNewHead;
			void *pvContext;
			DWORD dwSecondary;
			CNntpReturn nntpret;
			HANDLE hFile;

			strcpy(pbufHeaders->m_rgBuff, szArticle);

			f = pFeed->PostEarly(pInstance,
								 NULL,
                                 NULL,
								 TRUE,
								 "post",
								 pbufHeaders,
								 0,
								 cbHead,
								 &iNewHead,
								 &cbNewHead,
								 &hFile,
								 &pvContext,
								 dwSecondary,
								 ntohl(INADDR_LOOPBACK),			// IPAddr=127.0.0.1
								 nntpret);

			if (f) {
				OVERLAPPED          ovl;
				HANDLE              heDone;
				DWORD 				cbWritten;

				::ZeroMemory(&ovl, sizeof(ovl));
				heDone = CreateEvent(NULL, FALSE, FALSE, NULL);
				ovl.hEvent = heDone;

				BOOL bSuccess = ::WriteFile(hFile, pbufHeaders->m_rgBuff, cbNewHead, &cbWritten, &ovl);
				if (GetLastError() == ERROR_IO_PENDING) {
				    WaitForSingleObject(heDone, INFINITE);
				    bSuccess = TRUE;
				}
				if (!bSuccess) {
				    printf("WriteFile() failed writing to content file - %i\n", GetLastError());
				}

				ovl.Offset = cbNewHead;
				bSuccess = ::WriteFile(hFile, szArticle + cbHead, cbArticle - cbHead, &cbWritten, &ovl);
				if (GetLastError() == ERROR_IO_PENDING) {
				    WaitForSingleObject(heDone, INFINITE);
				    bSuccess = TRUE;
				}
				if (!bSuccess) {
				    printf("WriteFile() failed writing to content file - %i\n", GetLastError());
				}

				pFeed->PostCommit(pvContext, NULL, dwSecondary, nntpret);
			}

			delete pbufHeaders;
		} else {
			printf("----- invalid article\n");
		}

	}

	printf("----- shutting down\n");
	delete pFeed;
	if (pHistory) {
		pHistory->Shutdown();
		delete pHistory;
		pHistory = NULL;
	}
	if (pXOver) {
		pXOver->Shutdown();
		delete pXOver;
		pXOver = NULL;
	}
	if (pArt) {
		pArt->Shutdown();
		delete pArt;
		pArt = NULL;
	}
	

	if (pNewsTree) {
	    pNewsTree->StopTree();
	    pNewsTree->TermTree();
	}
	if (pVRTable) {
		delete pVRTable;
		pVRTable = NULL;
	}
	if (pNewsTree) {
	    delete pNewsTree;
		pNewsTree = NULL;
	}

	if (pServer) delete pServer;

	TermNNTPHashLibrary();
    CArticleCore::TermClass();

    CVRootTable::GlobalShutdown();

    AtqTerminate( ) ;
    
    TerminateIISRTL() ;
	CArticle::TermClass();
	CBuffer::TermClass();
	CoUninitialize ();
	 _Module.Term();

	return 0;
}

void
CFeed::LogFeedEvent(	DWORD	messageId,	LPSTR	lpstrMessageId, DWORD dwInstanceId )	{

	return ;

}	

//
//  Bool to determine whether we will honor a message-id in an article
//  posted by a client !
//
BOOL    gHonorClientMessageIDs = TRUE ;

//
//  BOOL used to determine whether we will generate the NNTP-Posting-Host
//  header on client Posts. Default is to not generate this.
//
BOOL        gEnableNntpPostingHost = TRUE ;

//
//  Rate at which we poll vroot information to update CNewsGroup objects
//  (in minutes)
//
DWORD   gNewsgroupUpdateRate = 5 ;  // default - 5 minutes

//
//  Bool used to determine whether the server enforces Approved: header
//  matching on moderated posts !
//
BOOL    gHonorApprovedHeaders = TRUE ;

MAIL_FROM_SWITCH    mfMailFromHeader = mfNone;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\utest\cfeed.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cfeed.cpp

Abstract:

    This module contains definition for the CFeed base class

Author:

    Carl Kadie (CarlK)     01-Oct-1995

Revision History:

--*/

#include "tigris.hxx"

//
//If some of these look very simple, make them inline!!!!
//

CPool	CFeed::gFeedPool(FEED_SIGNATURE) ;


//
//  Largest possible CInFeed derived object
//
#define MAX_FEED_SIZE   max(    sizeof( CFeed ),    \
                            max(    sizeof( COutFeed ), \
                            max(    sizeof( CInFeed ),  \
                            max(    sizeof( CFromPeerFeed ),    \
                            max(    sizeof( CFromMasterFeed ),  \
                                    sizeof( CFromClientFeed )   \
                             ) ) ) ) )

const   unsigned    cbMAX_FEED_SIZE = MAX_FEED_SIZE ;

BOOL	
CFeed::InitClass()	
/*++

Routine Description:

    Preallocates CPOOL memory for articles

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{

	return	gFeedPool.ReserveMemory(	MAX_FEEDS, cbMAX_FEED_SIZE ) ;

}


BOOL
CFeed::TermClass(
				   void
				   )
/*++

Routine Description:

	Called when done with CPOOL.

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	_ASSERT( gFeedPool.GetAllocCount() == 0 ) ;

	return	gFeedPool.ReleaseMemory() ;

}

void
CFeed::LogFeedEvent(	DWORD	messageId,	LPSTR	lpstrMessageId, DWORD dwInstanceId )	{

	return ;

}	

void*	CFeed::operator	new(	size_t	size )
{
	Assert( size <= MAX_FEED_SIZE ) ;
	return	gFeedPool.Alloc() ;
}

void	CFeed::operator	delete(	void*	pv )
{
	gFeedPool.Free( pv ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\utest\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

#define _UNIT_TEST_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
};
#endif

#include "irtlmisc.h"
#include "atq.h"

#include <malloc.h>
#include <imd.h>

extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <wincrypt.h>
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <ntlmsp.h>
#include <buffer.hxx>
                //#include <sslsp.h>
}

#include <pudebug.h>
#include <iistypes.hxx>
#include <simssl2.h>
#include <tssec.hxx>
#include <simauth2.h>

#include <nntptype.h>
#include <nntps.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <tsunami.hxx>
#include <nntpmeta.h>
#include <time.h>
#include <smartptr.h>
#include <fcache.h>
extern "C" {
#include <tcpproc.h>
}
#include <nntpcons.h>

#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"
#include "crchash.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include "nntpvr.h"
#include "group.h"
#include "nwstree.h"
#include "nntpbag.h"
#include "nntperr.h"
#include <ihash.h>

#include "cbuffer.h"
#include "cfeed.h"
#include "infeed.h"
#include "fromclnt.h"
#include "frompeer.h"
#include "frommstr.h"
#include "sfromcl.h"
#include "nntputil.h"
#include "nntpsrvi.h"

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\post\utest\nntpsrvi.h ===
//
//  Copyright    (c)    1998        Microsoft Corporation
//
//  Module Name:
//
//      nntpsrvi.h
//
//  Abstract:
//
//		Defines CNntpServer, which implements the INntpServer interface
//
//  Author:
//
//      Alex Wetmore
//
//  

class CNntpServer : public INntpServer {
	private:
	    //
	    // Reference counting
	    //
	    LONG   m_cRef;

	public:
	    //
	    // Constructors
	    //
	    CNntpServer() {
	        m_cRef = 1;
	    }

	public:
		//
		// INntpServer ----------------------------------------------------
		//

		//
		// find the primary groupid/articleid for an article given the secondary
		// groupid/articleid
		//
		// returns:
		//  S_OK - found primary
		//  S_FALSE - the values given were the primary
		//  otherwise error
		//
		void __stdcall FindPrimaryArticle(INNTPPropertyBag *pgroupSecondary,
		                   				  DWORD   		  artidSecondary,
		                   				  INNTPPropertyBag **pgroupPrimary,
		                   				  DWORD   		  *partidPrimary,
										  INntpComplete    *pComplete)
        {
            pComplete->SetResult(E_NOTIMPL);
            pComplete->Release();
        }
		
		//
	    // IUnknown ------------------------------------------------------
		//
	    HRESULT __stdcall QueryInterface(const IID& iid, VOID** ppv) {
	        if (iid == IID_IUnknown) {
	            *ppv = static_cast<IUnknown*>(this);
	        } else if (iid == IID_INntpServer) {
	            *ppv = static_cast<INntpServer*>(this);
	        } else {
	            *ppv = NULL;
	            return E_NOINTERFACE;
	        }
	        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	        return S_OK;
	    }

	    ULONG __stdcall AddRef() {
			return InterlockedIncrement(&m_cRef);
	    }
	
	    ULONG __stdcall Release() {
	        if ( InterlockedDecrement(&m_cRef) == 0 ) {
				// we should never hit zero because the instance creates 
				// us and should always have one reference
	            _ASSERT( 0 );
	        }
	
	        return m_cRef;
	    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\search\src\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:       pch.cxx
//
//  Contents:   Pre-compiled header
//
//--------------------------------------------------------------------------


#define __QUERY__

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <dbgtrace.h>
#include "parse.h"

// return and TraceFunctLeave() at once, even returning a Win32 error code if
// necessary
#define ret(__rc__) { 													\
	TraceFunctLeave(); 													\
	return(__rc__);														\
}

#define retEC(__ec__, __rc__) {											\
	SetLastError(__ec__); 												\
	DebugTrace(0, "error return (ec = 0x%x, %lu)\n", __ec__, __ec__); 	\
	TraceFunctLeave(); 													\
	return(__rc__); 													\
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\search\utest\doquery\fname2id.h ===
#ifndef __FNAME2ID_H__

//
// Convert an NNTP filename to an article ID
//
// parameters:
//	[in] pszFilename - the name of the file containing the news 
//                     article (no path)
//  [out] pdwID      - the article ID
// returns:
//  true on success, false + GetLastError() on error.
//
BOOL NNTPFilenameToArticleID(LPWSTR pszFilename, DWORD *pcID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\search\src\parse.cpp ===
#define INITGUID
#define DEFINE_STRCONST
#include <pch.cxx>
#include <ole2.h>
#include <exchmole.h>

//
// information needed to convert months from IMAP format to IS format
//
typedef const struct MONTH_INFO_st {
	char	*pszIMAPName;				// the IMAP name of the date
	char	*pszISName;					// the IS name for the date
} MONTH_INFO;

//
// the types of search key operands
//
typedef enum {
	eAString,					// an astring type
	eNumber,					// a numeric type
	eDate,						// a date
	eSearchKey,					// a nested search key
	eDateDay,					// a date where we need to use =
	eNone 						// no operand
} SKEY_OPERAND_TYPE;

//
// this is the table of valid search keys as defined in the SEARCH proposal.
// it contains all "simple" search keys.  special cases are noted with 
// comments and are handled specially in TranslateSearchKey().
//
// these need to be kept in alphabetical order to allow us to use a
// binary search.  
//
SKEY_INFO CNntpSearchTranslator::m_rgSearchKeys[] = {
	// ( is a special case
	{ "ALL",		"@NewsArticleID > 0",NULL,	eNone, 		FALSE	},
	{ "BEFORE",		"@Write < ",		NULL,	eDate,		FALSE	},
	{ "BODY",		"@Contents ",		NULL,	eAString,	FALSE	},
	// CHARSET is a special case
	{ "FROM",		"@NewsFrom ",		NULL,	eAString,	FALSE	},
	// HEADER is a special case
	// IN is a special case
	{ "LARGER",		"@Size > ",			NULL,	eNumber,	FALSE	},
//	{ "NEWSGROUP",	"#NewsGroups ",		NULL,	eAString,	TRUE	},
	{ "NOT",		"NOT ",				NULL,	eSearchKey,	FALSE	},
	{ "ON",			"@Write ",			NULL,	eDateDay,	FALSE	},
	// OR is a special case
	{ "SENTBEFORE",	"@NewsDate < ",		NULL,	eDate,		FALSE	},
	{ "SENTON",		"@NewsDate ",		NULL,	eDateDay,	FALSE	},
	{ "SENTSINCE",	"@NewsDate > ",		NULL,	eDate,		FALSE	},
	{ "SINCE",		"@Write > ",		NULL,	eDate,		FALSE	},
	{ "SMALLER",	"@Size < ",			NULL,	eNumber,	FALSE	},
	{ "SUBJECT",	"@NewsSubject ",	NULL,	eAString,	FALSE	},
	{ "TEXT",		"@All ",			NULL,	eAString,	FALSE	},
	// UID is a special case
	{ NULL, 		NULL,				NULL,	eSearchKey,	FALSE	}
};

// size of the table minus the NULL
#define NUM_SEARCH_KEYS (sizeof(m_rgSearchKeys) / sizeof(SKEY_INFO)) - 1

//
// this is the table of valid HEADER fields supported by NNTP.
//
// these need to be kept in alphabetical order to allow us to use a
// binary search.  
//
SKEY_INFO CQueryLanguageTranslator::m_rgHeaders[] = {
	// this is just used to report that we support the :Text search header
	{ ":Body",		"@Contents ",	"@All ",		eAString,	FALSE	},
	{ ":Date",		"@Write ",		"@Write ",		eDateDay,	FALSE	},
	{ ":Text",		"@All ",		"@Contents ",	eAString,	FALSE	},
	{ "Date",		"@NewsDate ",	"#NewsDate ",	eDateDay,	FALSE	},
	{ "From",		"@NewsFrom ",	"#NewsFrom ",	eAString,	FALSE	},
	{ "Message-ID",	"@NewsMsgID ",	"#NewsMsgID ",	eAString,	FALSE	},
//	{ "Newsgroup",	"@NewsGroup ",	"#NewsGroup ",	eAString,	TRUE	},
	{ "Newsgroups",	"@NewsGroups ",	"#NewsGroups ",	eAString,	TRUE	},
	{ "Subject",	"@NewsSubject ","#NewsSubject ",eAString,	FALSE	},
	{ NULL, 		NULL,			NULL,			eSearchKey,	FALSE	}
};

// the number of headers (not counting the NULL) in the above list
const DWORD CQueryLanguageTranslator::m_cHeaders = 
	(sizeof(CQueryLanguageTranslator::m_rgHeaders) / sizeof(SKEY_INFO)) - 1;

//
// IMAP queries keep the date in word form, Tripoli likes the date to be in
// numeric form.  we use this table to convert
//
MONTH_INFO CQueryLanguageTranslator::m_rgMonthTable[] = {
	{ "Jan", "1"  }, 	{ "Feb", "2"  }, 	{ "Mar", "3"  },
	{ "Apr", "4"  }, 	{ "May", "5"  }, 	{ "Jun", "6"  },
	{ "Jul", "7"  }, 	{ "Aug", "8"  }, 	{ "Sep", "9"  },
	{ "Oct", "10" }, 	{ "Nov", "11" }, 	{ "Dec", "12" },
	{ NULL,  NULL }
};

//
// IMAP/Search spec's words and special characters (except those defined
// in the above tables)
//
#define IMAP_OR "OR"
#define IMAP_ALL "ALL"
#define IMAP_UID "UID"
#define IMAP_HEADER "HEADER"
#define IMAP_SPACE " \t"
#define IMAP_OPEN_PAREN "("
#define IMAP_OPEN_PAREN_CHAR '('
#define IMAP_CLOSE_PAREN ")"
#define IMAP_CLOSE_PAREN_CHAR ')'
#define IMAP_QUOTE "\""
#define IMAP_QUOTE_CHAR '"'
#define IMAP_DATE_SEPERATOR "-"
#define IMAP_ATOM_SPECIALS "()* \"\\"
#define IMAP_SET_RANGE_SEPARATOR '-'
#define IMAP_SET_SEPARATORS IMAP_SPACE "-" IMAP_CLOSE_PAREN
#define IMAP_IN "in"
#define IMAP_COMMA ","

#define MIN_MIME2_STRING 9

BOOL CNntpSearchTranslator::Translate(char *pszStatement, char *pszNewsGrp,
									  WCHAR *pwszOutput, DWORD cOutput) {
	TraceFunctEnter("CNntpSearchTranslator::Translate");

	m_pszNewsgroup = pszNewsGrp;
	m_fSpecifiedNewsgroup = FALSE;
	m_fAndWithLast = FALSE;

	BOOL rc = TRUE;
	char *pSearchKey, *p, chEnd;

	// check to see if we have IN parameter
	p = pszStatement;
	pSearchKey = GetCharsTill(&p, IMAP_SPACE, TRUE, &chEnd);
	if (pSearchKey != NULL && _stricmp(IMAP_IN, pSearchKey) == 0) {
		pszStatement = p;
		rc = TranslateIN(&pszStatement, &pwszOutput, &cOutput) &&
			 SkipChars(&pszStatement, IMAP_SPACE, TRUE);
	} else {
		if (chEnd != 0) p[-1] = chEnd;
	}


	// translate each search key and AND them together
	while (rc && *pszStatement != 0) {
		if (m_fAndWithLast) WriteOutput(IS_AND, &pwszOutput, &cOutput);
		else m_fAndWithLast = TRUE;
		rc = TranslateSearchKey(&pszStatement, &pwszOutput, &cOutput) &&
			 SkipChars(&pszStatement, IMAP_SPACE, TRUE);
	};

	if (rc && !m_fSpecifiedNewsgroup) {
		if (m_fAndWithLast) WriteOutput(IS_AND, &pwszOutput, &cOutput);

		if (m_pszNewsgroup == NULL) retEC(ERROR_SEARCH_P_NO_GROUP, FALSE);
		rc = WriteOutput(IS_NEWSGROUP IS_SPACE IS_QUOTE, &pwszOutput, &cOutput) &&
			 WriteOutput(m_pszNewsgroup, &pwszOutput, &cOutput) &&
			 WriteOutput(IS_QUOTE, &pwszOutput, &cOutput);
	}

	*pwszOutput = 0;

	ret(rc);
}

BOOL CNntpSearchTranslator::TranslateSearchKey(char **ppszStatement, WCHAR **ppwszOutput, DWORD *pcOutput) {
	TraceFunctEnter("CNntpSearchTranslator::TranslateSearchKey");

	if (!SkipChars(ppszStatement, IMAP_SPACE IMAP_CLOSE_PAREN)) ret(FALSE);
	BOOL fParen = FALSE, fSet = FALSE;
	BOOL rc;
	char *pszSearchKey = NULL, chEnd = NULL;
	if (**ppszStatement == IMAP_OPEN_PAREN_CHAR) {
		fParen = TRUE;
	} else if (isdigit(**ppszStatement)) {
		fSet = TRUE;
	} else {
		pszSearchKey = GetCharsTill(ppszStatement, 
			IMAP_SPACE IMAP_CLOSE_PAREN, TRUE, &chEnd);
		if (pszSearchKey == NULL) ret(FALSE);
	}

	//
	// check for special cases
	//
	if (fParen == TRUE) {
		rc = TranslateAndList(ppszStatement, ppwszOutput, pcOutput);
	} else if (fSet || _stricmp(pszSearchKey, IMAP_UID) == 0) {
		rc = TranslateSet(ppszStatement, ppwszOutput, pcOutput);
	} else if (_stricmp(pszSearchKey, IMAP_OR) == 0) {
		rc = TranslateOR(ppszStatement, ppwszOutput, pcOutput);
	} else if (_stricmp(pszSearchKey, IMAP_HEADER) == 0) {
		rc = TranslateHeader(ppszStatement, ppwszOutput, pcOutput);
	} else {
		//
		// if there were no special cases then look for this key in the
		// search key info list and do a translation
		//
		SKEY_INFO *skinfo = GetSearchKeyInfo(pszSearchKey, 
			NUM_SEARCH_KEYS, m_rgSearchKeys);
		if (skinfo == NULL) {
			if (GetLastError() == ERROR_SEARCH_P_UNSUPPORTED_KEY) 
				SetLastError(ERROR_SEARCH_P_SYNTAX_ERROR);
			ret(FALSE);
		}

		if (skinfo->fSpecifiedNewsgroup) m_fSpecifiedNewsgroup = TRUE;

		if (!WriteOutput(skinfo->pszPropertyName, ppwszOutput, pcOutput))
			ret(FALSE);

		switch (skinfo->eOperandType) {
			case eAString: 	rc = TranslateAString(ppszStatement, ppwszOutput, pcOutput);
							break;
			case eNumber: 	rc = TranslateNumber(ppszStatement, ppwszOutput, pcOutput);
							break;
			case eDate: 	rc = TranslateDate(ppszStatement, ppwszOutput, pcOutput);
							break;
			case eDateDay: 	rc = TranslateDateDay(skinfo->pszPropertyName, ppszStatement, ppwszOutput, pcOutput);
							break;
			case eSearchKey:rc = TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput);
							break;
			case eNone:		rc = TRUE;
							break;
			default:		_ASSERT(FALSE);
							SetLastError(ERROR_SEARCH_P_INTERNAL);
							rc = FALSE;
							break;
		}
	}
	
	if (chEnd == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		**ppszStatement = chEnd;
	}

	ret(rc);
}

//
// convert alt.*,comp.* into (@NewsGroups "alt.*" | @Newsgroups "comp.*")
//
BOOL CNntpSearchTranslator::TranslateIN(char **ppszStatement, WCHAR **ppwszOutput,
								    DWORD *pcOutput)
{
	TraceFunctEnter("CNntpSearchTranslator::TranslateIN");


	char chEnd;
	char *pszWildmat;
	BOOL fFirstNG = TRUE;
	
	do {
		pszWildmat = GetCharsTill(ppszStatement, IMAP_COMMA IMAP_SPACE, 
								  TRUE, &chEnd);

		// If the search pattern is "*", don't bother adding it to the
		// query string we're building.  (Tripoli doesn't like it and
		// it doesn't add any value to the query.)
		if (strcmp(pszWildmat, "*") != 0) {
			if (!fFirstNG) {
				if (!WriteOutput(IS_OR, ppwszOutput, pcOutput)) ret(FALSE);
			} else {
				if (!WriteOutput(IS_OPEN_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
				fFirstNG = FALSE;
			}
			if (pszWildmat == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
			if (*pszWildmat == 0) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
//			if (!WriteOutput(IS_NEWSGROUP_WILDMAT IS_SPACE IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(IS_NEWSGROUP IS_SPACE IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszWildmat, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
		}
	} while (chEnd == ',');

	if (!fFirstNG) {
		if (!WriteOutput(IS_CLOSE_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
		m_fAndWithLast = TRUE;
	}

	m_fSpecifiedNewsgroup = TRUE;

	ret(TRUE);
}

//
// convert <header> <search text> into @News<header> <search text> for
// supported headers
//
BOOL CNntpSearchTranslator::TranslateHeader(char **ppszStatement, WCHAR **ppwszOutput, DWORD *pcOutput) {
	TraceFunctEnter("CNntpSearchTranslator::TranslateSearchKey");

	//
	// extract out the name of the header
	//
	char *pszHeader = GetCharsTill(ppszStatement, IMAP_SPACE, FALSE);
	if (pszHeader == NULL) ret(FALSE);

	//
	// find this header in the list of supported headers
	//
	SKEY_INFO *skinfo = GetSearchKeyInfo(pszHeader, m_cHeaders, 
		m_rgHeaders);
	if (skinfo == NULL) ret(FALSE);

	if (skinfo->fSpecifiedNewsgroup) m_fSpecifiedNewsgroup = TRUE;

	if (!WriteOutput(skinfo->pszPropertyName, ppwszOutput, pcOutput))
		ret(FALSE);

	switch (skinfo->eOperandType) {
		case eAString: 	
			ret(TranslateAString(ppszStatement, ppwszOutput, pcOutput));
			break;
		case eNumber: 	
			ret(TranslateNumber(ppszStatement, ppwszOutput, pcOutput));
			break;
		case eDate: 	
			ret(TranslateDate(ppszStatement, ppwszOutput, pcOutput));
			break;
		case eSearchKey:
			ret(TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput));
			break;
		case eNone:		
			ret(TRUE);
			break;
	}

	// should be unreachable
	_ASSERT(FALSE);
	retEC(ERROR_SEARCH_P_INTERNAL, FALSE);
}

//
// convert <searchkey> <searchkey> into (<searchkey> OR <searchkey>)
// (TranslateSearchKey() eats the OR)
//
BOOL CNntpSearchTranslator::TranslateOR(char **ppszStatement, WCHAR **ppwszOutput,
								    DWORD *pcOutput)
{
	TraceFunctEnter("CNntpSearchTranslator::TranslateOR");

	if (!WriteOutput(IS_OPEN_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
	if (!TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput)) ret(FALSE);
	if (!WriteOutput(" " IS_OR " ", ppwszOutput, pcOutput)) ret(FALSE);
	if (!TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput)) ret(FALSE);
	if (!WriteOutput(IS_CLOSE_PAREN, ppwszOutput, pcOutput)) ret(FALSE);

	ret(TRUE);

	TraceFunctLeave();
}

//
// convert (<searchkey> ... <searchkey>) 
// into (<searchkey> AND ... AND <searchkey>)
//
BOOL CNntpSearchTranslator::TranslateAndList(char **ppszStatement, 
									     WCHAR **ppwszOutput, DWORD *pcOutput)
{
	TraceFunctEnter("CNntpSearchTranslator::TranslateAndList");
	
	BOOL rc, fFirstRun = TRUE;

	// skip paren
	(*ppszStatement)++;
	if (!WriteOutput(IS_OPEN_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
	do {
		if (!fFirstRun) WriteOutput(IS_AND, ppwszOutput, pcOutput);
		else fFirstRun = FALSE;
		rc = TranslateSearchKey(ppszStatement, ppwszOutput, pcOutput) &&
			 SkipChars(ppszStatement, IMAP_SPACE);
	} while (rc && **ppszStatement != IMAP_CLOSE_PAREN_CHAR);
	if (!WriteOutput(IS_CLOSE_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
	// skip paren
	(*ppszStatement)++;

	ret(rc);
}

//
// convert:
// uid1-uid2,uid3,uid4
// no spaces are allowed
// into
// ((@NewsArtID >= uid1 and @NewsArtID <= uid2) or 
//  (@NewsArtID == uid3) or (@NewsArtID == uid4))
//
// BUGBUG -- need to support * and *:*
//
BOOL CNntpSearchTranslator::TranslateSet(char **ppszStatement, 
								     WCHAR **ppwszOutput, DWORD *pcOutput) 
{
	TraceFunctEnter("CNntpSearchTranslator::TranslateSet");
	
	BOOL rc, fFirstRun = TRUE;
	char chSeparator;

	if (!SkipChars(ppszStatement, IMAP_SPACE)) ret(FALSE);

	//
	// get the first number (out of one or two, depending on if its
	// a range or an entry in the list)
	//
	char *szFirstNumber = GetCharsTill(ppszStatement, IMAP_SET_SEPARATORS, 
		TRUE, &chSeparator);
	if (szFirstNumber == FALSE) ret(FALSE);
	if (!IsNumber(szFirstNumber)) ret(FALSE);

	char szBuf[256];

	// 
	// see if its a range
	//
	if (chSeparator == IMAP_SET_RANGE_SEPARATOR) {
		// get the second number
		char *szSecondNumber = GetCharsTill(ppszStatement, 
			IMAP_CLOSE_PAREN IMAP_SPACE, TRUE, &chSeparator);
		if (szSecondNumber == NULL) ret(FALSE);	

		BOOL fSecondInfinite = FALSE;

		if (*szSecondNumber == 0) {
			fSecondInfinite = TRUE;
		} else if (!IsNumber(szSecondNumber)) {
			ret(FALSE);
		}

		// print out the IS syntax
		// x-y -> (@NewsArticleID >= x AND @NewsArtID <= y)
		// x- -> @NewsArticleID >= x
		sprintf(szBuf, "%s%s%s", 
			(fSecondInfinite) ? "" : IS_OPEN_PAREN, 
			IS_ARTICLE_ID_GE, szFirstNumber);			
		rc = WriteOutput(szBuf, ppwszOutput, pcOutput);
		if (rc && !fSecondInfinite) {
			// and <= szSecondNumber
			sprintf(szBuf, "%s%s%s", 
				IS_AND IS_ARTICLE_ID_LE, szSecondNumber, IS_CLOSE_PAREN);
			rc = WriteOutput(szBuf, ppwszOutput, pcOutput);
		}
	} else {
		// print out the IS syntax
		// x -> @NewsArtID = x
		sprintf(szBuf, "%s%s%s", IS_ARTICLE_ID, IS_OPERATOR_EQ, 
			szFirstNumber);
		rc = WriteOutput(szBuf, ppwszOutput, pcOutput);
	}

	if (chSeparator == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		(**ppszStatement) = chSeparator;
	}
	
	ret(rc);
}

//
// convert astring types (in the search spec) into the proper strings for
// the tripoli search engine.
//
// BUGBUG - doesn't support MIME or Literal's yet
//
BOOL CQueryLanguageTranslator::TranslateAString(char **ppszStatement, WCHAR **ppwszOutput,
										 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::TranslateAString");
	
	if (!SkipChars(ppszStatement, IMAP_SPACE)) ret(FALSE);

	char *pszString, chEndChar;

	// check for a quoted string.  if we find one then we copy to the output
	// until the end quote, otherwise its an atom (one character)
	if (**ppszStatement == IMAP_QUOTE_CHAR) {
		(*ppszStatement)++;
		pszString = GetCharsTill(ppszStatement, IMAP_QUOTE, FALSE, &chEndChar);
	} else {
		// the string ends with an atom special character
		pszString = GetCharsTill(ppszStatement, IMAP_ATOM_SPECIALS, TRUE, 
								 &chEndChar);
	}

	// make sure we found an close quote
	if (pszString == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	if (!WriteOutput(IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);

	// check to see if its a mime-2 string
	DWORD cString = lstrlen(pszString);
	if (cString > MIN_MIME2_STRING && 
		pszString[0] == '=' && 
		pszString[1] == '?' &&
		pszString[cString - 2] == '?' &&
		pszString[cString - 1] == '=') 
	{
		if (!WriteOutputM2(pszString, ppwszOutput, pcOutput)) ret(FALSE);
	} else {
		if (!WriteOutput(pszString, ppwszOutput, pcOutput)) ret(FALSE);
	}

	if (!WriteOutput(IS_QUOTE IS_WILDMAT, ppwszOutput, pcOutput)) ret(FALSE);

	if (chEndChar == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		(**ppszStatement) = chEndChar;
	}

	ret(TRUE);
}

BOOL CQueryLanguageTranslator::TranslateNumber(char **ppszStatement, WCHAR **ppwszOutput,
										 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::TranslateNumber");

	if (!SkipChars(ppszStatement, IMAP_SPACE)) ret(FALSE);

	char *pszNumber, chEnd;

	pszNumber = GetCharsTill(ppszStatement, IMAP_SPACE IMAP_CLOSE_PAREN, 
		TRUE, &chEnd);
	if (pszNumber == NULL) ret(FALSE);
	if (!IsNumber(pszNumber)) ret(FALSE);

	if (!WriteOutput(pszNumber, ppwszOutput, pcOutput)) ret(FALSE);
	
	// fix the statement to have the closing paren if we ran over it...
	if (chEnd == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		**ppszStatement = chEnd;
	}

	ret(TRUE);
}

//
// translate 18-feb-1974 to 1974/2/18
//
BOOL CQueryLanguageTranslator::TranslateDate(char **ppszStatement, WCHAR **ppwszOutput,
										 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::TranslateDate");

	ret(TranslateDateDay(NULL, ppszStatement, ppwszOutput, pcOutput));
}

//
// translate 18-feb-1974 to ">= 1974/2/18 and pszField <= 1974/2/18 23:59:59"
//
// if pszField is NULL then it will do the following translation:
// translate 18-feb-1974 to "1974/2/18"
//
BOOL CQueryLanguageTranslator::TranslateDateDay(char *pszField,
											 char **ppszStatement, 
											 WCHAR **ppwszOutput,
										 	 DWORD *pcOutput)
{
	TraceFunctEnter("CQueryLanguageTranslator::TranslateDateDay");
	
	if (pszField != NULL) {
		// put out the >=
		if (!WriteOutput(IS_OPERATOR_GE, ppwszOutput, pcOutput)) ret(FALSE);
	}

	// skip whitespace
	if (!SkipChars(ppszStatement, IMAP_SPACE)) ret(FALSE);

	BOOL fQuoted = (**ppszStatement == IMAP_QUOTE_CHAR);

	// skip the open quote if there is one
	if (fQuoted) (*ppszStatement)++;

	// read the day #
	char *pszDayOfMonth = GetCharsTill(ppszStatement, "-", FALSE);
	if (pszDayOfMonth == NULL) ret(FALSE);
	// make sure its valid.
	// must be 1 or 2 chars.  each char must be a number
	if (*pszDayOfMonth == 0 || 
		strlen(pszDayOfMonth) > 2 ||
	    !isdigit(pszDayOfMonth[0]) || 
	    (pszDayOfMonth[1] != 0 && !isdigit(pszDayOfMonth[1])))
	{
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	}

	// read the month
	char *pszMonth = GetCharsTill(ppszStatement, "-", FALSE);
	// make sure its valid.
	// must be 3 chars long
	if (pszMonth == 0 || strlen(pszMonth) != 3) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	// find the IS name for the month
	char *pszISMonth = NULL;
	int i;
	for (i = 0; m_rgMonthTable[i].pszIMAPName != NULL; i++) {
		if (_stricmp(m_rgMonthTable[i].pszIMAPName, pszMonth) == NULL) {
			pszISMonth = m_rgMonthTable[i].pszISName;
			break;
		}
	}
	if (pszISMonth == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	// read the year
	char chEnd, *pszYear = GetCharsTill(ppszStatement, 
		IMAP_SPACE IMAP_CLOSE_PAREN IMAP_QUOTE, TRUE, &chEnd);
	// make sure its valid.
	// must be 4 chars long, each must be a number
	if (strlen(pszYear) != 4 || 
		!isdigit(pszYear[0]) ||
		!isdigit(pszYear[1]) ||
		!isdigit(pszYear[2]) ||
		!isdigit(pszYear[3]))
	{
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	}

	char pszDate[256];

	_snprintf(pszDate, 256, "%s/%s/%s", pszYear, pszISMonth, pszDayOfMonth);
	// BUGBUG - check for overflow
	if (!WriteOutput(pszDate, ppwszOutput, pcOutput)) ret(FALSE);

	if (pszField != NULL) {
		_snprintf(pszDate, 256, " & %s<= %s/%s/%s 23:59:59 ", pszField,
			pszYear, pszISMonth, pszDayOfMonth);
		if (!WriteOutput(pszDate, ppwszOutput, pcOutput)) ret(FALSE);
	}

	// if there was an open quote then skip until the close quote
	if (fQuoted && chEnd != IMAP_QUOTE_CHAR) {
		if (!SkipChars(ppszStatement, IMAP_SPACE, FALSE)) ret(FALSE);
		if (**ppszStatement != IMAP_QUOTE_CHAR) ret(FALSE);
	}

	if (chEnd == IMAP_CLOSE_PAREN_CHAR) {
		(*ppszStatement)--;
		**ppszStatement = chEnd;
	}

	ret(TRUE);
}
BOOL CQueryLanguageTranslator::WriteOutput(char *pszText, WCHAR **ppwszOutput, 
									DWORD *pcOutput) 
{
	TraceFunctEnter("CQueryLanguageTranslator::WriteOutput");

	DWORD iText, iOutput;

	// copy, converting ASCII to Unicode
	for (iText = 0, iOutput = 0; pszText[iText] != 0; iText++, iOutput++) {
		if (iOutput > *pcOutput) retEC(ERROR_MORE_DATA, FALSE);
		(*ppwszOutput)[iOutput] = (char) pszText[iText];
	}
	*pcOutput -= iOutput;
	*ppwszOutput += iOutput;

	ret(TRUE);
}

BOOL CQueryLanguageTranslator::WriteOutputM2(char *pszText, 
											 WCHAR **ppwszOutput, 
									  		 DWORD *pcOutput) 
{
	TraceFunctEnter("CQueryLanguageTranslator::WriteOutputM2");

	IMimeInternational *pMI;
	HRESULT hr;

	// BUGBUG - don't coinit/couninit just for this function
	CoInitialize(NULL);

	hr = CoCreateInstance(CLSID_IMimeInternational,
						  NULL, 
						  CLSCTX_INPROC_SERVER,
						  IID_IMimeInternational, 
						  (void **) &pMI);
	if (FAILED(hr)) {
		DebugTrace(0, "CoCreateInstance failed with 0x%x\n", hr);
		SetLastError(HRESULT_CODE(hr));
		ret(FALSE);
	}

	PROPVARIANT pvDest;
	RFC1522INFO rfc1522info;
	pvDest.vt = VT_LPWSTR;
	rfc1522info.fRfc1522Allowed = TRUE;

	// convert the Mime-2 string to Unicode.  it will be written into
	// pvDest
	hr = pMI->DecodeHeader(NULL, pszText, &pvDest, &rfc1522info);
	if (FAILED(hr)) {
		DebugTrace(0, "DecodeHeader() failed with 0x%x\n", hr);
		SetLastError(HRESULT_CODE(hr));
		ret(FALSE);
	}

	// this shouldn't get changed
	_ASSERT(pvDest.vt == VT_LPWSTR);
	// we should only be passing in rfc1522 strings
	_ASSERT(rfc1522info.fRfc1522Used);

	if (!WriteOutput("\"", ppwszOutput, pcOutput)) ret(FALSE);

	// make sure pvDest will fit into ppwszOutput and copy it over
	DWORD cDest = lstrlenW(pvDest.pwszVal);
	if (cDest > *pcOutput) {
		ErrorTrace(0, "pcOutput (%lu) < cDest (%lu)", *pcOutput, cDest);
		SetLastError(ERROR_OUTOFMEMORY);
		ret(FALSE);
	}

	lstrcpyW(*ppwszOutput , pvDest.pwszVal);
	*pcOutput -= cDest;
	*ppwszOutput += cDest;

	if (!WriteOutput("\"", ppwszOutput, pcOutput)) ret(FALSE);

	pMI->Release();
	CoUninitialize();

	ret(TRUE);
}

BOOL CQueryLanguageTranslator::SkipChars(char **ppszStatement, char *pszSkipList, 
								  BOOL fEndOfStringOkay) 
{
	TraceFunctEnter("CQueryLanguageTranslator::SkipChars");

	char *p = *ppszStatement;

	// loop until we find a character that isn't in the skiplist
	while (*p != 0 && strchr(pszSkipList, *p) != NULL) p++;
	if (*p == 0 && !fEndOfStringOkay) 
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	*ppszStatement = p;
	ret(TRUE);
}

char *CQueryLanguageTranslator::GetCharsTill(char **ppszStatement, char *pszEndList,
									  BOOL fEndOfStringOkay, char *pchEndChar)
{
	TraceFunctEnter("CQueryLanguageTranslator::GetCharsTill");

	char *front = *ppszStatement;
	int i;

	// loop until we find a character that is in the end list
	for (i = 0; front[i] != 0 && strchr(pszEndList, front[i]) == NULL; i++);
	if (front[i] == 0 && !fEndOfStringOkay) 
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	if (pchEndChar != NULL) *pchEndChar = front[i];

	if (front[i] != 0) {
		front[i] = 0;
		*ppszStatement += (i + 1);
	} else {
		*ppszStatement += i;
	}

	ret(front);
}

//
// given a search key's name, find information about it
//
SKEY_INFO *CQueryLanguageTranslator::GetSearchKeyInfo(char *pszSearchKey, 
											   DWORD cSKInfo,
											   SKEY_INFO *pSKInfo) 
{
	TraceFunctEnter("CQueryLanguageTranslator::GetSearchKeyInfo");
	
	int lo = 0, hi = cSKInfo - 1;

	// do a binary search to find the proper searchkey (this requires that
	// the searchkey table is kept sorted)
	do {
		int mid = (lo + hi) / 2;
		int order = _stricmp(pSKInfo[mid].pszSearchKey, pszSearchKey);
		if (order == 0) {
			ret(pSKInfo + mid);
		} else if (order > 0) {
			hi = mid - 1;
		} else {
			lo = mid + 1;
		}
	} while (lo <= hi);
	SetLastError(ERROR_SEARCH_P_UNSUPPORTED_KEY);
	ret(NULL);
}

//
// verify that this string is a valid IMAP number
//
BOOL CQueryLanguageTranslator::IsNumber(char *pszString) {
	TraceFunctEnter("CQueryLanguageTranslator::IsNumber");
	
	int i, l = strlen(pszString);

	for (i = 0; i < l; i++) {
		if (!isdigit(pszString[i])) {
			SetLastError(ERROR_SEARCH_P_SYNTAX_ERROR);
			ret(FALSE);
		}
	}

	ret(TRUE);
}

char *GetSearchHeader(DWORD iIndex) {
	if (iIndex > CQueryLanguageTranslator::m_cHeaders) return NULL;

	return CQueryLanguageTranslator::m_rgHeaders[iIndex].pszSearchKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\search\utest\doquery\fname2id.cpp ===
#include <windows.h>
#include <stdio.h>
#include "fname2id.h"

BOOL NNTPFilenameToArticleID(LPWSTR pszFilename, DWORD *pcID) {
	DWORD cRevID;

	swscanf(pszFilename, L"%x.nws", &cRevID);
	// reverse the bytes
	((char *) pcID)[0] = ((char *) &cRevID)[3];
	((char *) pcID)[1] = ((char *) &cRevID)[2];
	((char *) pcID)[2] = ((char *) &cRevID)[1];
	((char *) pcID)[3] = ((char *) &cRevID)[0];

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\search\src\parsxpat.cpp ===
#include "pch.cxx"
#include "parse.h"

//
// the types of search key operands
//
typedef enum {
	eAString,					// an astring type
	eNumber,					// a numeric type
	eDate,						// a date
	eSearchKey,					// a nested search key
	eDateDay,					// a date where we need to use =
	eNone 						// no operand
} SKEY_OPERAND_TYPE;

#define XPAT_SPACE " \t"					// whitespace characters
#define XPAT_MESSAGE_ID_CHAR '@'			// all message IDs have this
#define XPAT_MESSAGE_ID_PREFIX '<'			// prefix's message IDs
#define XPAT_MESSAGE_ID_SUFFIX '>'			// prefix's message IDs
#define XPAT_RANGE_OPERATOR_CHAR '-'		// used to denote article ID range

BOOL CXpatTranslator::Translate(char *pszStatement, char *pszNewsGrp,
									  WCHAR *pwszOutput, DWORD cOutput) {
	TraceFunctEnter("CXpatTranslator::Translate");

	char **ppszStatement = &pszStatement;
	WCHAR **ppwszOutput = &pwszOutput;
	DWORD *pcOutput = &cOutput;

	m_iLowArticleID = 0;
	m_iHighArticleID = ARTICLEID_INFINITE;

	//
	// if they don't have a newsgroup selected then XPAT doesn't work
	//
	if (pszNewsGrp == NULL) retEC(ERROR_SEARCH_P_NO_GROUP, FALSE);

	// 
	// list the newsgroup for tripoli
	//
	if (!WriteOutput(IS_NEWSGROUP_EQ, ppwszOutput, pcOutput)) ret(FALSE);
	if (!WriteOutput(pszNewsGrp, ppwszOutput, pcOutput)) ret(FALSE);

	//
	// get the header that they want to search
	//
	if (!SkipChars(ppszStatement, XPAT_SPACE)) 
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	char *pszHeader = GetCharsTill(ppszStatement, XPAT_SPACE, FALSE);
	if (pszHeader == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	// 
	// figure out the Tripoli word for this header
	//
	SKEY_INFO *pSkinfo = GetSearchKeyInfo(pszHeader, m_cHeaders, m_rgHeaders);
	if (pSkinfo == NULL) retEC(ERROR_SEARCH_P_UNSUPPORTED_KEY, FALSE);
	char *pszPropertyName;
	if (pSkinfo->eOperandType == eDate || pSkinfo->eOperandType == eDateDay)
		pszPropertyName = pSkinfo->pszPropertyName;
	else
		pszPropertyName = pSkinfo->pszRegexName;
	//
	// get the message ID or article ID
	//
	if (!SkipChars(ppszStatement, XPAT_SPACE)) 
		retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
	char *pszID = GetCharsTill(ppszStatement, XPAT_SPACE, FALSE);
	if (pszID == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

	//
	// its a message ID if it contains an @ sign, otherwise its an article ID
	//
	if (strchr(pszID, XPAT_MESSAGE_ID_CHAR) != NULL &&
	    *pszID == XPAT_MESSAGE_ID_PREFIX &&
		pszID[strlen(pszID) - 1] == XPAT_MESSAGE_ID_SUFFIX) 
	{
		//
		// message ID
		//
		if (!WriteOutput(IS_AND, ppwszOutput, pcOutput)) ret(FALSE);
		if (!WriteOutput(IS_MESSAGE_ID_EQ IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
		if (!WriteOutput(pszID, ppwszOutput, pcOutput)) ret(FALSE);
		if (!WriteOutput(IS_QUOTE, ppwszOutput, pcOutput)) ret(FALSE);
	} else {
		//
		// article ID range
		//
		// possibilities here:
		// x-y
		// x-
		// x
		// -
		// -y
		//
		char *pszDash = strchr(pszID, XPAT_RANGE_OPERATOR_CHAR);
		char *pszFirstArticleID = pszID;
		char *pszSecondArticleID = NULL;
		char szOne[] = "1";
		if (pszDash != NULL) {
			*pszDash = 0;
			pszSecondArticleID = pszDash + 1;
			if (*pszSecondArticleID != 0 && !IsNumber(pszSecondArticleID))
				retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
		}
		// this will be true in the "-" and "-y" cases
		if (pszDash == pszFirstArticleID) pszFirstArticleID = szOne;
		if (!IsNumber(pszFirstArticleID)) 
			retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);

//
// we don't want to use @NewsArticleID to restrict the searchs for XPAT.
// when the article is cross-posted the @NewsArticleID property isn't
// necessarily the article ID for this article in this newsgroup, so 
// restricting it could cause articles that are in the desired set not
// to get returned by tripoli.
//
// the xpat code does its own independent checking of the article ID's
// using the high and low article IDs that we return to it.
//
#if 0
		if (!WriteOutput(IS_AND, ppwszOutput, pcOutput)) ret(FALSE);
		// write to output
		if (pszSecondArticleID == NULL) {
			// just one article (passed in #)
			if (!WriteOutput(IS_ARTICLE_ID_EQ, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszFirstArticleID, ppwszOutput, pcOutput)) ret(FALSE);
		} else if (*pszSecondArticleID == 0) {
			// article to max article (passed in #-)
			if (!WriteOutput(IS_ARTICLE_ID_GE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszFirstArticleID, ppwszOutput, pcOutput)) ret(FALSE);
		} else {
			// article to article (passed in #-#)
			if (!WriteOutput(IS_ARTICLE_ID_GE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszFirstArticleID, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(IS_AND, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(IS_ARTICLE_ID_LE, ppwszOutput, pcOutput)) ret(FALSE);
			if (!WriteOutput(pszSecondArticleID, ppwszOutput, pcOutput)) ret(FALSE);
		}
#endif

		m_iLowArticleID = atoi(pszFirstArticleID);
		if (pszSecondArticleID == NULL) {
			m_iHighArticleID = m_iLowArticleID;
		} else if (*pszSecondArticleID == 0) {
			m_iHighArticleID = ARTICLEID_INFINITE;
		} else {
			if (!IsNumber(pszFirstArticleID)) 
				retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
			m_iHighArticleID = atoi(pszSecondArticleID);
		}
	}

	//
	// take each pattern in turn and add it to the Tripoli string
	//
	BOOL fFirstPattern = TRUE;
	if (!WriteOutput(IS_AND IS_OPEN_PAREN, ppwszOutput, pcOutput)) ret(FALSE);
	do {
		if (!SkipChars(ppszStatement, XPAT_SPACE, !fFirstPattern)) 
			retEC(ERROR_SEARCH_P_SYNTAX_ERROR, TRUE);

		if (**ppszStatement != 0) {
			// if this isn't the first pattern then we need to OR it with 
			// the others
			if (!fFirstPattern) {
				if (!WriteOutput(IS_OR, ppwszOutput, pcOutput)) ret(FALSE);
			}
			if (!WriteOutput(pszPropertyName, ppwszOutput, pcOutput)) ret(FALSE);

			// If it's a date string, run it through the date translator.  Otherwise
			// copy the string with the translation mentioned below.
			switch (pSkinfo->eOperandType) {
			case eDate:
				if (!TranslateDate(ppszStatement, ppwszOutput, pcOutput))
					retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
				break;
			case eDateDay:
				if (!TranslateDateDay(pszPropertyName, ppszStatement, ppwszOutput, pcOutput))
					retEC(ERROR_SEARCH_P_SYNTAX_ERROR, FALSE);
				break;
			default:
				// we need to do the equiv of
				// if (!WriteOutput(pszPattern, ppwszOutput, pcOutput)) ret(FALSE);
				// but at the same time convert [ to |[.
				char *pszPattern = GetCharsTill(ppszStatement, XPAT_SPACE, TRUE);
				if (pszPattern == NULL) retEC(ERROR_SEARCH_P_SYNTAX_ERROR, TRUE);

				DWORD iPattern, iOutput;
				for (iPattern = 0, iOutput = 0; pszPattern[iPattern] != 0; iPattern++, iOutput++) {
					if (iOutput > *pcOutput) retEC(ERROR_MORE_DATA, FALSE);
					if (pszPattern[iPattern] == L'[') {
						(*ppwszOutput)[iOutput] = L'|'; iOutput++;
						(*ppwszOutput)[iOutput] = L'[';
					} else {
						(*ppwszOutput)[iOutput] = (char) pszPattern[iPattern];
					}
				}
				*pcOutput -= iOutput;
				*ppwszOutput += iOutput;
			}
		}

		fFirstPattern = FALSE;
	} while (**ppszStatement != 0);

	if (!WriteOutput(IS_CLOSE_PAREN, ppwszOutput, pcOutput)) ret(FALSE);

	**ppwszOutput = 0;

	ret(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\search\utest\doquery\doquery.cpp ===
#include <stdio.h>
#include <windows.h>
#include "query.h"
#include "parse.h"
#include <dbgtrace.h>
#include "fname2id.h"

void printhelp(void) {
	printf("usage: query [-t | -s | -x] [-g <group>] <query string>\n");
	printf("   -t == search string is in Tripoli search language\n");
	printf("   -s == search string is in NNTP Search language\n");
	printf("   -x == search string is in XPAT language\n");
	printf("   Note: default is NNTP Search\n");
	printf("   -g <group> == current newsgroup\n");
	printf("   -c <catalog path> == Tripoli catalog to query against\n");
	printf("note: you must escape quotes with a backslash\n");
	exit(0);
}

int __cdecl main(int argc, char **argv) {
	InitAsyncTrace();

	CIndexServerQuery *pISQ;
	CNntpSearchTranslator st;
	CXpatTranslator xt;
	CQueryLanguageTranslator *pQlt = &st;
	char szQueryString[4096];
	WCHAR wszTripoliQueryString[4096], wszCatalogPath[1024] = L"";
	char col1[] = "newsgroup", col2[] = "filename";
	char *rgszColumns[2] = { col1, col2 };
	char *szCurGroup = NULL;
	int i = 1;

	while (argc > i && argv[i][0] == '-') {
		switch (argv[i][1]) {
			case 'c':						// catalog path specified
			case 'C':
				if (argc == i) printhelp();
				if (!MultiByteToWideChar(CP_ACP, 0, argv[i + 1], -1,
										 wszCatalogPath, 1024))
				{
					printf("MultiByteToWideChar failed, GetLastError = %lu (0x%x)\n", 
						GetLastError(), GetLastError());
					return(0);
				}				
				i += 2;
				break;
			case 'g':						// newsgroup specified
			case 'G':
				if (argc == i) printhelp();
				szCurGroup = argv[i + 1];
				i += 2;
				break;
			case 't':						// query is in Tripolese
			case 'T':
				pQlt = NULL;
				i += 1;
				break;
			case 's':						// query is in NNTP SEARCH
			case 'S':
				pQlt = &st;
				i += 1;
				break;
			case 'x':						// query is in XPAT
			case 'X':
				pQlt = &xt;
				i += 1;
				break;
			default:						// invalid option passed
				printhelp();
		}
	}

	if (argc == i) printhelp();

	*szQueryString = 0;
	for (i; i < argc; i++) {
		strcat(szQueryString, argv[i]);
		if (i != argc - 1) strcat(szQueryString, " ");
	}

	if (pQlt != NULL) {
		if (!(pQlt->Translate(szQueryString, szCurGroup, wszTripoliQueryString, 4096))) {
			printf("translate failed, GetLastError = %lu (0x%x)\n", 
				GetLastError(), GetLastError());
			return(0);
		}
	} else {
		if (!MultiByteToWideChar(CP_ACP, 0, szQueryString, -1,
								 wszTripoliQueryString, 4096))
		{
			printf("MultiByteToWideChar failed, GetLastError = %lu (0x%x)\n", 
				GetLastError(), GetLastError());
			return(0);
		}
	}

	printf("%S\n", wszTripoliQueryString);

	pISQ = new CIndexServerQuery();

	if (!pISQ->Initialize("IDQ")) {
		printf("initialize failed\n");
		printf("got error %lu/0x%x\n", GetLastError(), GetLastError());
		return 0;
	}
	HANDLE hQuery = pISQ->MakeQuery(wszTripoliQueryString, 2, rgszColumns,
		wszCatalogPath, "c:/query.idq");
	if (hQuery == INVALID_HANDLE_VALUE) {
		printf("query failed\n");
		printf("got error %lu/0x%x\n", GetLastError(), GetLastError());
		// still have to shutdown
	}
	while (hQuery != INVALID_HANDLE_VALUE) {
		PROPVARIANT pvResults[7 * 2];
		PROPVARIANT *pvCur = pvResults;
		DWORD cResults = 7;

		ZeroMemory(pvResults, sizeof(pvResults));

		if (!pISQ->GetQueryResults(&hQuery, &cResults, pvResults)) {
			printf("GetQueryResults failed\n");
			printf("got error %lu/0x%x\n", GetLastError(), GetLastError());
			hQuery = INVALID_HANDLE_VALUE;
			continue;
		}

		for (unsigned i = 0; i < cResults; i++, pvCur += 2) {
			DWORD dwArticleID;

			// both of the columns should be returning as type LPWSTR
//			_ASSERT(pvCur[0].vt == VT_LPWSTR);
//			_ASSERT(pvCur[1].vt == VT_LPWSTR);

			if (pvCur[0].vt == VT_LPWSTR && pvCur[1].vt == VT_LPWSTR) {
				// convert the filename to an article id
				_VERIFY(NNTPFilenameToArticleID(pvCur[1].pwszVal, &dwArticleID));
				printf("%S %S %lu\n", pvCur[0].pwszVal, pvCur[1].pwszVal, dwArticleID);
			} else {
				printf("--unexpected vt's-- ->");
				for (int x = 0; x < 2; x++) {
					printf("[%i]", x);
					if (pvCur[x].vt == VT_LPWSTR) {
						printf("type = WSTR, data = %S ", pvCur[x].pwszVal);
					} else {
						printf("type = %lu ", pvCur[x].vt);
					}
				}
				printf("\n");
			}

			// deallocate memory that was allocated on our behalf
			CoTaskMemFree(pvCur[0].pwszVal);
			CoTaskMemFree(pvCur[1].pwszVal);
		}
	}
	if (!pISQ->Shutdown()) {
		printf("shutdown failed\n");
		printf("got error %lu/0x%x\n", GetLastError(), GetLastError());
		return 0;
	}

	delete pISQ;

	TermAsyncTrace();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\search\utest\qryxlate\qryxlate.cpp ===
#include <stdio.h>
#include <windows.h>
#include "parse.h"
#include <dbgtrace.h>

void printhelp(void) {
	printf("usage: qryxlate [-x|-s] <imap query string>\n");
	printf("  -x == XPAT query language\n");
	printf("  -s == NNTP Search query language\n");
	printf("  -g == current newsgroup (defaults to NULL)\n");
	printf("  default is -x\n");
	printf("  note: you must escape quotes with a backslash\n");
}

int __cdecl main(int argc, char **argv) {
	InitAsyncTrace();

	CNntpSearchTranslator st;
	CXpatTranslator xt;
	CQueryLanguageTranslator *pQlt = &st;
	char szQueryString[4096];
	WCHAR wszTripoliQueryString[4096];
	int iArg = 1;
	char *pszCurrentGroup = NULL;

	if (argc == 1) {
		printhelp();
		return 0;
	}

	while (argv[iArg][0] == '-') {
		if (iArg == argc - 1) {
			printhelp();
			return 0;
		}

		switch (argv[iArg][1]) {
			case 'g':
			case 'G':
				iArg++;
				if (iArg == argc) {
					printhelp();
					return 0;
				}
				pszCurrentGroup = argv[iArg];
				break;
			case 'x':
			case 'X':
				pQlt = &xt;
				break;
			case 's':
			case 'S':
				pQlt = &st;
				break;
			default:
				printhelp();
				return 0;
		}
		iArg++;
	}

	_ASSERT(pQlt != NULL);

	*szQueryString = 0;
	for (; iArg < argc; iArg++) {
		strcat(szQueryString, argv[iArg]);
		if (iArg != argc - 1) strcat(szQueryString, " ");
	}

	if (!(pQlt->Translate(szQueryString, pszCurrentGroup, wszTripoliQueryString, 4096))) {
		printf("translate failed, GetLastError = %lu (0x%x)\n", 
			GetLastError(), GetLastError());
		return(0);
	}

	printf("%S\n", wszTripoliQueryString);
	if (pQlt == &xt) {
		printf("%lu <= articleid <= %lu\n", xt.GetLowArticleID(), 
											xt.GetHighArticleID());
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\cmsg\props.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	props.cpp

Abstract:

	This module contains the implementation of the property search class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/05/97	created

--*/

#include "stdafx.h"

#include "dbgtrace.h"
#include "props.h"

// =================================================================
// Implementation of CPropertyTable
//
int __cdecl CompareProperties(const void *pElem1, const void *pElem2)
{
	LPPROPERTY_ITEM pProp1 = (LPPROPERTY_ITEM) pElem1;
	LPPROPERTY_ITEM pProp2 = (LPPROPERTY_ITEM) pElem2;

	int iResult = 0;

	TraceFunctEnter("CompareProperties");

	//
	// we want to force english language comparisons here, since our API
	// uses english words as property names
	//
	LCID lcidUSEnglish = 
		MAKELCID(
			MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), 
			SORT_DEFAULT);

	// 
	// comparison semantics:
	// in our search code the key item is always set to the first item.
	// the second item will always have cCharsToCompare set to 0 or an
	// integer.  If it is set to 0 then we know that we want to do a full
	// string comparison.  If it is set to a integer >= 1 then we only want
	// to compare up to cCharsToCompare characters.
	//
	int c = (int) (pProp2->cCharsToCompare);
	if (c == 0) {
		c = -1;
	} else {
		// make sure that it is safe to compare c bytes of the key string.
		// if not we know this isn't a match
		if (lstrlen(pProp1->pszName) <= c) iResult = -1;
	}
	if (iResult == 0) {
		iResult = CompareString(lcidUSEnglish, NORM_IGNORECASE, 
								pProp1->pszName, c, 
								pProp2->pszName, c) - 2;
	}

	DebugTrace(NULL, "Comparing <%s> and <%s> yields %d (c = %lu)",
				pProp1->pszName,
				pProp2->pszName,
				iResult, 
				c);

	TraceFunctLeave();

	return(iResult);
}

//
// GetPropertyType - Looks for a named property in the property table
//					 and returns its type.
//
// Arguments
// szPropertyName	- ANSI string of the property name
// pptPropertyType	- Returns type of desired property value
// ppPropertyContext- Context of property
//
// Return values
//
// S_OK				- Succeeded
// E_FAIL			- Property not found
// E_ABORT			- Widechar conversion failure (WCHAR only)
//
HRESULT CPropertyTable::GetPropertyType(LPCSTR		szPropertyName,
										LPDWORD		pptPropertyType,
										LPPROP_CTXT	pPropertyContext)
{
	LPPROPERTY_ITEM	pItem;
	HRESULT			hrRes;

	TraceFunctEnterEx((LPARAM)this, "CPropertyTable::GetPropertyType");

	// Validation
	_ASSERT(szPropertyName);
	_ASSERT(pptPropertyType);
	_ASSERT(pPropertyContext);

	if (!szPropertyName || !pptPropertyType || !pPropertyContext)
		return(E_INVALIDARG);

	*pptPropertyType = PT_NONE;
	pPropertyContext->fIsWideStr = FALSE;

	// Find the property
	pItem = SearchForProperty(szPropertyName);

	// Found?
	if (pItem)
	{
		// Return the base type regardless
		*pptPropertyType = pItem->ptBaseType;
		pPropertyContext->pItem = pItem;
		hrRes = S_OK;
	}
	else
		hrRes = DISP_E_MEMBERNOTFOUND;

	TraceFunctLeave();
	return(hrRes);
}

//
// GetProperty - Retrieves property information using an established context
//
// Arguments
// szPropertyName	- ANSI string of the property name
// pvBuffer			- Pointer to buffer to return property data
//						in native format. If the context is returned 
//						by a Wide version of GetPropertyType, the returned
//						string will be in Wide format.
// pdwBufferLen		- Total length of receiving buffer, receives the length
//						of returned data on successful return
//
// Return values
//
// S_OK				- Succeeded
// E_ABORT			- ANSI to UNICODE conversion failed
// E_INVALIDARG		- Bad params
// E_OUTOFMEMORY	- Not enough memory
// Plus other errors returned by the accessor
//
HRESULT CPropertyTable::GetProperty(LPPROP_CTXT	pPropertyContext,
									LPCSTR		pszPropertyName,
									LPVOID		pvBuffer,
									LPDWORD		pdwBufferLen)
{
	LPPROPERTY_ITEM	pItem = pPropertyContext->pItem;
	HRESULT			hrRes;
	LPVOID			pvTempBuf;
	DWORD			dwOriginalLength;

	TraceFunctEnterEx((LPARAM)this, "CPropertyTable::GetProperty");

	// Validation
	_ASSERT(pvBuffer);
	_ASSERT(pdwBufferLen);

	if (!pvBuffer || !pdwBufferLen)
		return(E_INVALIDARG);

	dwOriginalLength = *pdwBufferLen;

	if (pItem)
	{
		// Is this type of access allowed?
		if (pItem->fAccess & PA_READ)
		{
			// If we have a wide string property, we will use a scratch 
			// buffer, then we will convert it back to UNICODE when we
			// got the value
			if (pPropertyContext->fIsWideStr)
			{
				pvTempBuf = GetScratchBuffer(dwOriginalLength);
				if (!pvTempBuf)
					return(E_OUTOFMEMORY);
			}
			else
				pvTempBuf = pvBuffer;				

			// Found the item, now call the accessor
			_ASSERT(pItem->ptBaseType < PT_MAXPT);
			hrRes = pItem->pfnGetAccessor((char *) pszPropertyName, 
										pItem->pContext,
										pItem->pCacheData,
										pvTempBuf, 
										pdwBufferLen);

			if (SUCCEEDED(hrRes) && pPropertyContext->fIsWideStr)
			{
				// Convert it back to UNICODE
				if (!MultiByteToWideChar(CP_ACP, 0, 
											(LPCSTR)pvTempBuf, 
											*pdwBufferLen,
											(LPWSTR)pvBuffer, 
											dwOriginalLength))
					return(E_ABORT);
			}
		}
		else
			hrRes = E_ACCESSDENIED;
	}
	else
		hrRes = E_INVALIDARG;

	TraceFunctLeave();
	return(hrRes);
}

//
// SetProperty - Sets the named property to the specified value
//
// Arguments
// szPropertyName	- ANSI string of the property name
// pvBuffer			- Pointer to buffer containing property value
//						in native format
// dwBufferLen		- Total length of data
// ptDesiredPropertyType - Type of property value data
//
// Return values
//
// S_OK				- Succeeded
// E_FAIL			- Property not found
// E_OUTOFMEMORY	- Not enough memory
// E_ABORT			- Widechar conversion failure (WCHAR only)
// Plus other errors returned by the accessor
//
HRESULT CPropertyTable::SetProperty(LPCSTR	szPropertyName,
									LPVOID	pvBuffer,
									DWORD	dwBufferLen,
									DWORD	ptPropertyType)
{
	LPPROPERTY_ITEM	pItem;
	HRESULT			hrRes;

	TraceFunctEnterEx((LPARAM)this, "CPropertyTable::SetProperty");

	// Validation
	_ASSERT(szPropertyName);
	_ASSERT(pvBuffer);
	_ASSERT(ptPropertyType < PT_MAXPT);

	if (!szPropertyName || !pvBuffer)
		return(E_INVALIDARG);
	if (ptPropertyType >= PT_MAXPT)
		return(E_INVALIDARG);

	// Find the property
	pItem = SearchForProperty(szPropertyName);

	// Found?
	if (pItem)
	{
		// This type of access allowed?
		if (pItem->fAccess & PA_WRITE)
		{
			// Found the item, now call the accessor
			hrRes = pItem->pfnSetAccessor((LPSTR)szPropertyName, 
										pItem->pContext,
										pItem->pCacheData,
										pvBuffer, 
										dwBufferLen,
										ptPropertyType);
		}
		else
			hrRes = E_ACCESSDENIED;
	}
	else
		hrRes = DISP_E_MEMBERNOTFOUND;

	TraceFunctLeave();
	return(hrRes);
}

//
// this function allows one to set a property using a variant.  if the 
// variant isn't in our desired type then we'll try to convert it.
//
HRESULT CPropertyTable::SetProperty(LPCSTR szPropertyName,
									VARIANT *pvarProperty) 
{
	TraceFunctEnterEx((LPARAM)this, "CPropertyTable::SetPropertyAV");

	LPPROPERTY_ITEM	pItem;
	HRESULT			hr;

	// Validation
	_ASSERT(szPropertyName);
	_ASSERT(pvarProperty);

	if (!szPropertyName || !pvarProperty) return E_POINTER;

	// Find the property
	pItem = SearchForProperty(szPropertyName);
	if (!pItem) return DISP_E_MEMBERNOTFOUND;
	if (!(pItem->fAccess & PA_WRITE)) return E_ACCESSDENIED;

	// get the variant type that we need for this property
	short vtDesired;
	switch (pItem->ptBaseType) {
		case PT_STRING: vtDesired = VT_BSTR; break;
		case PT_DWORD: vtDesired = VT_I4; break;
		case PT_INTERFACE: vtDesired = VT_UNKNOWN; break;
		default: return DISP_E_TYPEMISMATCH;
	}

	// convert the variant to one that we can deal with
	CComVariant varDesired;
	hr = varDesired.ChangeType(vtDesired, pvarProperty);
	if (FAILED(hr)) return hr;

	switch (pItem->ptBaseType) {
		case PT_STRING: {
			DWORD cbstr = lstrlenW(varDesired.bstrVal);

			if (!GetScratchBuffer(cbstr + 1)) return E_OUTOFMEMORY;
			if (!WideCharToMultiByte(CP_ACP, 
									 0, 
									 varDesired.bstrVal,
									 cbstr + 1,
									 m_szBuffer,
									 m_cBuffer,
									 NULL,
									 NULL))
			{
				return HRESULT_FROM_WIN32(GetLastError());
			}

			hr = pItem->pfnSetAccessor((LPSTR) szPropertyName, 
									   pItem->pContext,
									   pItem->pCacheData,
									   m_szBuffer,
									   cbstr,
									   PT_STRING);
			break;
		}
		case PT_DWORD: {
			DWORD dwValue = (DWORD) varDesired.lVal;
			hr = pItem->pfnSetAccessor((LPSTR) szPropertyName, 
									   pItem->pContext,
									   pItem->pCacheData,
									   &dwValue,
									   sizeof(DWORD),
									   PT_DWORD);
			break;
		}
		case PT_INTERFACE: {
			hr = pItem->pfnSetAccessor((LPSTR) szPropertyName, 
									   pItem->pContext,
									   pItem->pCacheData,
									   varDesired.punkVal,
									   sizeof(IUnknown *),
									   PT_INTERFACE);
			break;
		}
	}

	TraceFunctLeave();
	return hr;
}

HRESULT CPropertyTable::CommitChanges()
{
	HRESULT	hrRes = S_OK;

	// this gets set to NULL if our destructor is called
	_ASSERT(m_pProperties != NULL);

	// Call the commit accessor for each item in the property table
	for (DWORD i = 0; i < m_dwProperties; i++)
		if (m_pProperties[i].pfnCommitAccessor(
							m_pProperties[i].pszName,
							m_pProperties[i].pContext,
							m_pProperties[i].pCacheData) != S_OK)
		{
			hrRes = E_FAIL;
		}
		else
		{
			// If we successfully committed, we will invalidate the cache
			m_pProperties[i].pfnInvalidateAccessor(
							m_pProperties[i].pszName,
							m_pProperties[i].pCacheData,
							m_pProperties[i].ptBaseType);
		}

	return(hrRes);
}

HRESULT CPropertyTable::Invalidate()
{
	HRESULT	hrRes = S_OK;

	// Call the invalidate accessor for each item in the property table
	for (DWORD i = 0; i < m_dwProperties; i++)
		m_pProperties[i].pfnInvalidateAccessor(
							m_pProperties[i].pszName,
							m_pProperties[i].pCacheData,
							m_pProperties[i].ptBaseType);
	return(S_OK);
}

//
// Private methods
//
LPVOID CPropertyTable::GetScratchBuffer(DWORD dwSizeDesired)
{
	TraceFunctEnter("CProperty::GetScratchBuffer");

	// See if any action is needed at all
	if (m_cBuffer >= dwSizeDesired)
		return(m_szBuffer);

	// Reallocate ...
	if (m_szBuffer != m_rgcBuffer)
		LocalFree((HLOCAL)m_szBuffer);
		//_VERIFY(LocalFree((HLOCAL)m_szBuffer) == (HLOCAL)NULL);

	// Align buffer size to next page boundary, so we won't have
	// to reallocate until something exceeds 4K
	dwSizeDesired >>= 12;
	dwSizeDesired++;
	dwSizeDesired <<= 12;

	m_szBuffer = (LPSTR)LocalAlloc(0, dwSizeDesired);
	if (!m_szBuffer)
	{
		m_cBuffer = 0;
		return(NULL);
	}
	m_cBuffer = dwSizeDesired;

	TraceFunctLeave();
	return(m_szBuffer);
}

LPPROPERTY_ITEM CPropertyTable::SearchForProperty(LPCSTR szPropertyName)
{
	LPPROPERTY_ITEM	pItem = NULL;

	TraceFunctEnter("CPropertyTable::SearchForProperty");

	// we always do a linear search.  this allows us to optimize for the
	// most common cases and allows us to make assumptions in CompareStrings
	// about which element is the key element that makes CompareStrings 
	// faster.  Since the table for NNTP only contains 6 elements this is
	// not a perf hit.
	DWORD			i;
	PROPERTY_ITEM	KeyItem;

	// Fill in the property name to look for
	KeyItem.pszName = (LPSTR)szPropertyName;

	// Linear search
	pItem = NULL;
	for (i = 0; i < m_dwProperties && pItem == NULL; i++) {
		if (!CompareProperties(&KeyItem, m_pProperties + i)) {
			pItem = m_pProperties + i;
		}
	}

	TraceFunctLeave();
	return(pItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\cmsg\msg.cpp ===
// Msg.cpp : Implementation of CMsg
#include "stdafx.h"

#include "dbgtrace.h"
#include "Msg.h"
#include "imsg_i.c"

/////////////////////////////////////////////////////////////////////////////
// CMsg

/////////////////////////////////////////////////////////////////////////////
// IUnknown
//
HRESULT STDMETHODCALLTYPE CMsg::QueryInterface(	REFIID riid,
												void  ** ppvObject)
{
    //
    // Optimize QueryInterface by only checking minimal number of bytes.
    //
    // IID_IUnknown     = 00000000-0000-0000-C000-000000000046
	// IID_IDispatch	= 00020400-0000-0000-c000-000000000046
	// IID_IMsg			= 507E7D61-EE7C-11D0-869A-00C04FD65616
	// IID_IStream		= 0000000c-0000-0000-c000-000000000046
    //                         ---
    //                           |
    //                           +--- Unique!

    _ASSERT( (IID_IUnknown.Data1		& 0x00000FFF) == 0x000 );
    _ASSERT( (IID_IDispatch.Data1		& 0x00000FFF) == 0x400 );
    _ASSERT( (IID_IMsg.Data1			& 0x00000FFF) == 0xd61 );
    _ASSERT( (IID_IStream.Data1			& 0x00000FFF) == 0x00c );

    IUnknown *pUnkTemp;
    HRESULT hr = S_OK;

    switch( riid.Data1 & 0x00000FFF )
    {
    case 0x000:
		// IUnknown: default interface is IMsg
        if ( IID_IUnknown == riid )
            pUnkTemp = (IUnknown *)(IMsg *)this;
        else
            hr = E_NOINTERFACE;
        break;
	
    case 0x400:
		// IDispatch
        if ( IID_IDispatch == riid )
            pUnkTemp = (IUnknown *)(IDispatch *)this;
        else
            hr = E_NOINTERFACE;
        break;

    case 0xd61:
		// IMsg
        if ( IID_IMsg == riid )
            pUnkTemp = (IUnknown *)(IMsg *)this;
        else
            hr = E_NOINTERFACE;
        break;

	/*
	case 0x00c:
		// IStream
        if ( IID_IStream == riid )
            pUnkTemp = (IUnknown *)(IStream *)m_pStream;
        else
            hr = E_NOINTERFACE;
        break;
	*/

    default:
        pUnkTemp = 0;
        hr = E_NOINTERFACE;
        break;
    }

    if( 0 != pUnkTemp )
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(hr);
}

ULONG STDMETHODCALLTYPE CMsg::AddRef()
{
    return InterlockedIncrement( &m_cRef );
}

ULONG STDMETHODCALLTYPE CMsg::Release()
{
    unsigned long uTmp = InterlockedDecrement( &m_cRef );

// 
// In MCIS 2.0 this object is allocated on the stack, so we never 
// want to call delete on it.
//
#if 0
    if ( 0 == uTmp )
        delete this;
#endif

    return(uTmp);
}

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo
//
STDMETHODIMP CMsg::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMsg,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatchImpl
//
STDMETHODIMP CMsg::get_Value(BSTR bstrValue, VARIANT * pVal)
{
	char		szANSIName[1024];

	// Convert wide character to ANSI into scratch buffer
	if (!WideCharToMultiByte(CP_ACP, 0,
							 (LPWSTR) bstrValue, -1,
							 szANSIName, 1024, NULL, NULL)) 
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return GetVariantA(szANSIName, pVal);
}

STDMETHODIMP CMsg::put_Value(BSTR bstrValue, VARIANT newVal)
{
	char		szANSIName[1024];

	// Convert wide character to ANSI into scratch buffer
	if (!WideCharToMultiByte(CP_ACP, 0,
							 (LPWSTR) bstrValue, -1,
							 szANSIName, 1024, NULL, NULL)) 
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return SetVariantA(szANSIName, &newVal);	
}

/////////////////////////////////////////////////////////////////////////////
// IMsg
//
STDMETHODIMP CMsg::GetVariantA(LPCSTR pszName, VARIANT * pvarResult)
{
	HRESULT		hrRes;
	DWORD		dwType;
	PROP_CTXT	Context;
	LPVOID		pvResult;
	DWORD		dwSize;

	// Get the type
	hrRes = m_PTable.GetPropertyType(pszName, &dwType, &Context);
	if (hrRes != S_OK)
		return(hrRes);

	// Decide which part of the VARIANT to use.
	switch (dwType)
	{
		case PT_DWORD:
			pvarResult->vt = VT_I4;
			pvResult = &pvarResult->lVal;
			dwSize = sizeof(long);
			break;
		case PT_STRING:
			pvarResult->vt = VT_BSTR;

			// We need to get the length of the buffer required
			dwSize = 0;
			hrRes = m_PTable.GetProperty(&Context, pszName, pvResult, &dwSize);

			// Allocate a temp buffer
			pvResult = (LPVOID)LocalAlloc(0, dwSize);
			if (!pvResult)
				return(E_OUTOFMEMORY);
			break;
		case PT_INTERFACE:
			pvarResult->vt = VT_UNKNOWN;
			pvResult = &pvarResult->punkVal;
			dwSize = sizeof(IUnknown *);
			break;
		default:
			return(E_INVALIDARG);
	}

	// Then get the value
	hrRes = m_PTable.GetProperty(&Context, pszName, pvResult, &dwSize);

	// If it's a BSTR we have to assign the string back
	if (pvarResult->vt == VT_BSTR)
	{
		if (SUCCEEDED(hrRes))
		{
			CComBSTR	bstrStr((LPCSTR)pvResult);

			// detach it so that CComBSTR doesn't free the memory
			pvarResult->bstrVal = bstrStr.Detach();
		}
		LocalFree((HLOCAL)pvResult);
		//_VERIFY(LocalFree((HLOCAL)pvResult) == NULL);
	} 
	return(hrRes);
}

STDMETHODIMP CMsg::SetVariantA(LPCSTR pszName, VARIANT * pvarValue)
{
	return m_PTable.SetProperty(pszName, pvarValue);
}

STDMETHODIMP CMsg::GetStringA(LPCSTR pszName, DWORD * pchCount, LPSTR pszResult)
{
	HRESULT		hrRes;
	DWORD		dwType;
	PROP_CTXT	Context;

	// Get the type
	hrRes = m_PTable.GetPropertyType(pszName, &dwType, &Context);
	if (hrRes != S_OK)
		return(hrRes);

	// Check type
	if (dwType != PT_STRING)
		return(TYPE_E_TYPEMISMATCH);

	// Type is right, get the value
	hrRes = m_PTable.GetProperty(&Context, pszName, pszResult, pchCount);
	return(hrRes);
}

STDMETHODIMP CMsg::SetStringA(LPCSTR pszName, DWORD chCount, LPCSTR pszValue)
{
	return(m_PTable.SetProperty(pszName, (LPVOID)pszValue, chCount, PT_STRING));
}

STDMETHODIMP CMsg::GetDwordA(LPCSTR pszName, DWORD * pdwResult)
{
	HRESULT		hrRes;
	DWORD		dwType, dwSize;
	PROP_CTXT	Context;

	// Get the type
	hrRes = m_PTable.GetPropertyType(pszName, &dwType, &Context);
	if (hrRes != S_OK)
		return(hrRes);

	// Check type
	if (dwType != PT_DWORD)
		return(TYPE_E_TYPEMISMATCH);

	// Type is right, get the value
	dwSize = sizeof(DWORD);
	hrRes = m_PTable.GetProperty(&Context, pszName, pdwResult, &dwSize);
	return(hrRes);
}

STDMETHODIMP CMsg::SetDwordA(LPCSTR pszName, DWORD dwValue)
{
	return(m_PTable.SetProperty(pszName, (LPVOID)&dwValue, 4, PT_DWORD));
}

STDMETHODIMP CMsg::GetInterfaceA(LPCSTR pszName, REFIID iidDesired, IUnknown * * ppunkResult)
{
	HRESULT		hrRes;
	DWORD		dwType, dwSize;
	PROP_CTXT	Context;

	// Get the type
	hrRes = m_PTable.GetPropertyType(pszName, &dwType, &Context);
	if (hrRes != S_OK)
		return(hrRes);

	// Check type
	if (dwType != PT_INTERFACE)
		return(TYPE_E_TYPEMISMATCH);

	// Type is right, get the value
	dwSize = sizeof(IUnknown *);
	IUnknown *punk = NULL;
	hrRes = m_PTable.GetProperty(&Context, pszName, &punk, &dwSize);
	if (SUCCEEDED(hrRes)) {
		_ASSERT(punk != NULL);
		hrRes = punk->QueryInterface(iidDesired, (void **) ppunkResult);
		punk->Release();
	} else {
		ppunkResult = NULL;
	}
	return(hrRes);
}

STDMETHODIMP CMsg::SetInterfaceA(LPCSTR pszName, IUnknown * punkValue)
{
	return(m_PTable.SetProperty(pszName, (LPVOID)punkValue, sizeof(IUnknown *), PT_INTERFACE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\cmsg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// #include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\cmsg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__DAE462BE_F3E9_11D0_869A_00C04FD65616__INCLUDED_)
#define AFX_STDAFX_H__DAE462BE_F3E9_11D0_869A_00C04FD65616__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DAE462BE_F3E9_11D0_869A_00C04FD65616__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\ddrop.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "seo.h"
#include "nntpfilt.h"
#include "ddrop.h"
#include "filter.h"
#include <stdio.h>
#include "mailmsgprops.h"

HRESULT CNNTPDirectoryDrop::FinalConstruct() {
	*m_wszDropDirectory = 0;
	return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),
										  &m_pUnkMarshaler.p));
}

void CNNTPDirectoryDrop::FinalRelease() {
	m_pUnkMarshaler.Release();
}

BOOL
AddTerminatedDot(
    HANDLE hFile
    )
/*++

Description:

    Add the terminated dot

Argument:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    TraceFunctEnter( "CNntpFSDriver::AddTerminatedDot" );

    DWORD   ret = NO_ERROR;

    //  SetFilePointer to move the EOF file pointer
    ret = SetFilePointer( hFile,
                          5,            // move file pointer 5 chars more, CRLF.CRLF,...
                          NULL,
                          FILE_END );   // ...from EOF
    if (ret == 0xFFFFFFFF)
    {
        ret = GetLastError();
        ErrorTrace(0, "SetFilePointer() failed - %d\n", ret);
        return FALSE;
    }

    //  pickup the length of the file
    DWORD   cb = ret;

    //  Call SetEndOfFile to actually set the file pointer
    if (!SetEndOfFile( hFile ))
    {
        ret = GetLastError();
        ErrorTrace(0, "SetEndOfFile() failed - %d\n", ret);
        return FALSE;
    }

    //  Write terminating dot sequence
    static	char	szTerminator[] = "\r\n.\r\n" ;
    DWORD   cbOut = 0;
    OVERLAPPED  ovl;
    ovl.Offset = cb - 5;
    ovl.OffsetHigh = 0;
    HANDLE  hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if (hEvent == NULL)
    {
        ErrorTrace(0, "CreateEvent() failed - %d\n", GetLastError());
        return FALSE;
    }

    ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1);
    if (! WriteFile( hFile, szTerminator, 5, &cbOut, &ovl ))
    {
        ret = GetLastError();
        if (ret == ERROR_IO_PENDING)
        {
            WaitForSingleObject( hEvent, INFINITE );
        }
        else
        {
            ErrorTrace(0, "WriteFile() failed - %d\n", ret);
            _VERIFY( CloseHandle(hEvent) );
            return FALSE;
        }
    }

    if (hEvent != 0) {
        _VERIFY( CloseHandle(hEvent) );
    }

    return TRUE;
}

//
// this is our filter function.
//
HRESULT STDMETHODCALLTYPE CNNTPDirectoryDrop::OnPost(IMailMsgProperties *pMsg) {
	HRESULT hr;

#if 0
	// if this code is enabled then the post will be cancelled
	pMsg->PutDWORD(IMMPID_NMP_NNTP_PROCESSING, 0x0);
#endif
	
	_ASSERT(pMsg != NULL);
	if (pMsg == NULL) return E_INVALIDARG;

	HANDLE hFile;
	WCHAR szDestFilename[MAX_PATH];

	if (*m_wszDropDirectory == 0) {
		return E_INVALIDARG;
	}

	// get a temp filename to write to
	// we use GetTickCount() to generate the base of the filename.  This is
	// to increase the number of temporary file names available (by default
	// GetTempFileName() only generated 65k of them, which fills up quickly
	// if nothing is picking up the dropped articles).
	WCHAR wszPrefix[12];

	wsprintfW(wszPrefix, L"d%02x", GetTickCount() & 0xff);
	wszPrefix[3] = 0;
	if (GetTempFileNameW(m_wszDropDirectory, wszPrefix, 0, szDestFilename) == 0) {
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// open the destination file
	hFile = CreateFileW(szDestFilename, GENERIC_READ | GENERIC_WRITE, 
		0, NULL, OPEN_EXISTING, 
		FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		DeleteFileW(szDestFilename);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	PFIO_CONTEXT pFIOContext = AssociateFileEx( hFile,   
	                                            TRUE,   // fStoreWithDots
	                                            TRUE    // fStoreWithTerminatingDots
	                                           );
	if (pFIOContext == NULL) {
		CloseHandle(hFile);
		DeleteFileW(szDestFilename);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// copy from the source stream to the destination file
	hr = pMsg->CopyContentToFileEx( pFIOContext, 
	                                TRUE,
	                                NULL);

	//
	// Handle the trailing dot
	//
	if ( !GetIsFileDotTerminated( pFIOContext ) ) {

	    // No dot, add it
	    AddTerminatedDot( pFIOContext->m_hFile );

	    // Set pFIOContext to has dot
	    SetIsFileDotTerminated( pFIOContext, TRUE );
	}

#if 0
	//
	// if this code is enabled then more properties will be dropped into the
	// file
	//
	SetFilePointer(hFile, 0, 0, FILE_END);

	BYTE buf[4096];
	DWORD c, dw;
	strcpy((char *) buf, "\r\n-------------\r\nheaders = "); c = strlen((char *)buf);
	WriteFile(hFile, buf, c, &dw, NULL);
	pMsg->GetProperty(IMMPID_NMP_HEADERS, 4096, &c, buf);
	WriteFile(hFile, buf, c, &dw, NULL);
	strcpy((char *) buf, "\r\n------------\r\nnewsgroups = "); c = strlen((char *)buf);
	WriteFile(hFile, buf, c, &dw, NULL);
	pMsg->GetProperty(IMMPID_NMP_NEWSGROUP_LIST, 4096, &c, buf);
	WriteFile(hFile, buf, c, &dw, NULL);
	strcpy((char *) buf, "\r\n------------\r\n"); c = strlen((char *)buf);
	WriteFile(hFile, buf, c, &dw, NULL);
#endif

	// cleanup
	ReleaseContext(pFIOContext);

	if (!FAILED(hr)) hr = S_OK;

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\filter.h ===
#ifndef __FILTER_H__
#define __FILTER_H__

#include "nntpfilt.h"

class ATL_NO_VTABLE CNNTPDirectoryDrop : 
	public INNTPFilter,
	public IPersistPropertyBag,
	public CComObjectRoot,
	public CComCoClass<CNNTPDirectoryDrop, &CLSID_CNNTPDirectoryDrop>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"NNTP DirectoryDrop Class",
								   L"NNTP.DirectoryDrop.1",
								   L"NNTP.DirectoryDrop");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CNNTPDirectoryDrop)
		COM_INTERFACE_ENTRY(INNTPFilter)
		COM_INTERFACE_ENTRY(IPersistPropertyBag)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// INNTPFilter
	public:
		HRESULT STDMETHODCALLTYPE OnPost(IMailMsgProperties *pMessage);
	// IPersistPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pCLSID) {
			if (!pCLSID) return (E_POINTER);
			*pCLSID = CLSID_CNNTPDirectoryDrop;
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE InitNew() {
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pProps, 
									   IErrorLog *pErrorLog) 
		{
			HRESULT hrRes;
			CComVariant varValue;

			if (!pProps) return (E_POINTER);
			hrRes = pProps->Read(L"Drop Directory",&varValue,pErrorLog);
			if (SUCCEEDED(hrRes)) {
				hrRes = varValue.ChangeType(VT_BSTR);
				if (SUCCEEDED(hrRes)) {
					if (lstrlenW(varValue.bstrVal) <= MAX_PATH) {
						lstrcpyW(m_wszDropDirectory, varValue.bstrVal);
					}
				}
			}
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE Save(IPropertyBag *pProps, 
									   BOOL fClearDirty, 
									   BOOL fSaveAllProperties) 
		{
			return (S_OK);
		}
	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
		WCHAR m_wszDropDirectory[MAX_PATH];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\dllmain.cpp ===
#include "stdafx.h"
#include "resource.h"

#include "initguid.h"

#include "seo.h"
#include "SEO_i.c"
#include "nntpfilt.h"
#include "ddrop.h"
#include "ddrop_i.c"
#include "nntpfilt_i.c"
#include "filter.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CNNTPDirectoryDrop, CNNTPDirectoryDrop)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		_Module.Init(ObjectMap,hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
		_Module.Term();
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {
	_Module.UnregisterServer();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\makefile.inc ===
$(O)\ddrop.h $(O)\ddrop_i.c : ddrop.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\ddrop_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\ddrop_i.c \
    -header $@ \
    -tlb $(O)\ddrop.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfilt.h $(O)\nntpfilt_i.c : $(STAXNNTP)\core\include\nntpfilt.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfilt_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfilt_i.c \
    -header $@ \
    -tlb $(O)\nntpfilt.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\dllmain.cpp ===
#include "stdafx.h"
#include "dbgtrace.h"
#include "resource.h"

#include "initguid.h"

#include "seo.h"
#include "SEO_i.c"
#include "filttest.h"
#include "nntpfilt.h"
#include "nntpadm.h"
#include "filttest_i.c"
#include "nntpfilt_i.c"
#include "filter.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CNNTPTestFilter, CNNTPTestFilter)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		_Module.Init(ObjectMap,hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
		_Module.Term();
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {
	TraceFunctEnter("DllCanUnloadNow");
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	DebugTrace(0,"Returns %s.",(hRes==S_OK)?"S_OK":"S_FALSE");
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
	TraceFunctEnter("DllGetClassObject");
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {
	TraceFunctEnter("DllRegisterServer");
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer(TRUE);
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {
	TraceFunctEnter("DllUnregisterServer");
	_Module.UnregisterServer();
	DebugTrace(0,"Returns S_OK");
	TraceFunctLeave();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, CComObject<Base> **pp) {
//	template <class Base>
//	HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
//	{
	    _ASSERTE(pp != NULL);
	    HRESULT hRes = E_OUTOFMEMORY;
	    CComObject<Base>* p = NULL;
	    ATLTRY(p = new CComObject<Base>())
	    if (p != NULL)
	    {
//		    p->SetVoid(NULL);					// Change this...
			p->SetVoid(pUnkOuter);				// ... to this.
	        p->InternalFinalConstructAddRef();
	        hRes = p->FinalConstruct();
	        p->InternalFinalConstructRelease();
	        if (hRes != S_OK)
	        {
	            delete p;
	            p = NULL;
	        }
	    }
	    *pp = p;
	    return hRes;
//	}
}


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, REFIID iidDesired, LPVOID *pp) {
	HRESULT hrRes;
	CComObject<Base> *p = NULL;

	_ASSERTE(pp != NULL);
	*pp = NULL;
	hrRes = AtlCreateInstanceOf(pUnkOuter,&p);
	if (SUCCEEDED(hrRes)) {
		_ASSERTE(p != NULL);
		p->AddRef();
		hrRes = p->QueryInterface(iidDesired,pp);
		p->Release();
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the DirDropS
	project.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/96	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\ddrop\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (DWORD)((dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL));

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\nntpadmt.h ===
#ifndef __NNTPADMT_H__
#define __NNTPADMT_H__
#include "nntpadm.h"
#include "imsg.h"

void NNTPAdmUnitTest(IMsg *pMessage, CTLStream *pStream);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\filter.h ===
#ifndef __FILTER_H__
#define __FILTER_H__

#include "nntpfilt.h"
#include "imsg.h"

class ATL_NO_VTABLE CNNTPTestFilter : 
	public INNTPFilter,
	public IPersistPropertyBag,
	public CComObjectRoot,
	public CComCoClass<CNNTPTestFilter, &CLSID_CNNTPTestFilter>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"NNTP TestFilter Class",
								   L"NNTP.TestFilter.1",
								   L"NNTP.TestFilter");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CNNTPTestFilter)
		COM_INTERFACE_ENTRY(INNTPFilter)
		COM_INTERFACE_ENTRY(IPersistPropertyBag)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// INNTPFilter
	public:
		HRESULT STDMETHODCALLTYPE OnPost(IMsg *pMessage);
	// IPersistPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pCLSID) {
			if (!pCLSID) return (E_POINTER);
			*pCLSID = CLSID_CNNTPTestFilter;
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE InitNew() {
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pProps, 
									   IErrorLog *pErrorLog) 
		{
			HRESULT hrRes;
			CComVariant varValue;

			if (!pProps) return (E_POINTER);
			// by default we assume that we are running in OnPostFinal
			m_fOnPostFinal = FALSE;
			hrRes = pProps->Read(L"OnPostFinal",&varValue,pErrorLog);
			if (SUCCEEDED(hrRes)) {
				hrRes = varValue.ChangeType(VT_I4);
				if (SUCCEEDED(hrRes)) {
					m_fOnPostFinal = varValue.iVal;
				}
			}
			return (S_OK);
		}

		HRESULT STDMETHODCALLTYPE Save(IPropertyBag *pProps, 
									   BOOL fClearDirty, 
									   BOOL fSaveAllProperties) 
		{
			return (S_OK);
		}
	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
		WCHAR m_fOnPostFinal;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\nntpadmt.cpp ===
#include "stdafx.h"
#include <dbgtrace.h>
#include "testlib.h"
#include "nntpadmt.h"


static void TestINntpVirtualRoots(INntpVirtualRoots *pINntpVirtualRoots, CTLStream *pStream) {
    TraceFunctEnter("TestINntpVirtualRoots");
    LONG        dw;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;

    // Get Server
    hr = pINntpVirtualRoots->get_Server( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddBSTRResult(bstr);

    // Get Count
    hr = pINntpVirtualRoots->get_Count( &dw );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(dw);

    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestITcpAccess(ITcpAccess *pITcpAccess, CTLStream *pStream) {
    TraceFunctEnter("TestITcpAccess");
    LONG        dw;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;

    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestINntpFeed(INntpFeed *pINntpFeed, CTLStream *pStream) {
    TraceFunctEnter("TestINntpFeed");
    LONG        dw;
    BSTR        bstr = NULL;
    BOOL        fFlag;
    HRESULT     hr = S_OK;

    // Get HashInbound
    hr = pINntpFeed->get_HasInbound( &fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(fFlag);

    // Get HashOutbound
    hr = pINntpFeed->get_HasOutbound( &fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(fFlag);

    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestINntpAdminRebuild(INntpAdminRebuild *pINntpAdminRebuild, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminRebuild");
    LONG        dw;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;

    // Get Server
    hr = pINntpAdminRebuild->get_Server( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddBSTRResult(bstr);

    // Get KeyType
    hr = pINntpAdminRebuild->get_KeyType( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddBSTRResult(bstr);

    // Get Count
    hr = pINntpAdminRebuild->get_GroupFile( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddBSTRResult(bstr);

    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestINntpAdminSessions(INntpAdminSessions *pINntpAdminSessions, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminSessions2");
    LONG        dw;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;

    hr = pINntpAdminSessions->GetNth(0);
    {
        // Get Server
        hr = pINntpAdminSessions->get_Server( &bstr );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);

        // Get KeyType
        hr = pINntpAdminSessions->get_KeyType( &bstr );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);

        // Get Count
        hr = pINntpAdminSessions->get_Count( &dw );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddResult(dw);

        // Terminate
        hr = pINntpAdminSessions->Terminate();
        _ASSERT(SUCCEEDED(hr));
        
        // Terminate
        hr = pINntpAdminSessions->TerminateAll();
        _ASSERT(SUCCEEDED(hr));
        
    }
    pStream->AddResult(hr);

    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestINntpAdminSessions(IMsg *pMsg, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminSessions1");

    INntpAdminSessions* pINntpAdminSessions = NULL;
    HRESULT     hr = S_OK;

    // Create the INntpAdminSessions object
    hr = CoCreateInstance( (REFCLSID) CLSID_CNntpAdminSessions,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           (REFIID) IID_INntpAdminSessions,
                           (void**)&pINntpAdminSessions);
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminSessions( pINntpAdminSessions, pStream );

    // Release it
    if (pINntpAdminSessions) pINntpAdminSessions->Release();

    TraceFunctLeave();
}

static void TestINntpAdminExpiration(INntpAdminExpiration *pINntpAdminExpiration, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminExpiration2");
    LONG        dw;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;

    hr = pINntpAdminExpiration->GetNth(0);
    if (SUCCEEDED(hr))
    {
        // Get Server
        hr = pINntpAdminExpiration->get_Server( &bstr );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);

        // Get KeyType
        hr = pINntpAdminExpiration->get_KeyType( &bstr );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);

        // Get Count
        hr = pINntpAdminExpiration->get_Count( &dw );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddResult(dw);

        // PolicyName
        hr = pINntpAdminExpiration->get_PolicyName(&bstr);
        _ASSERT(SUCCEEDED(hr));
        pStream->AddResult(hr);
    
    }
    pStream->AddResult(hr);

    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestINntpAdminExpiration(IMsg *pMsg, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminExpiration1");

    INntpAdminExpiration* pINntpAdminExpiration = NULL;
    HRESULT     hr = S_OK;

    // Create the INntpAdminExpiration object
    hr = CoCreateInstance( (REFCLSID) CLSID_CNntpAdminExpiration,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           (REFIID) IID_INntpAdminExpiration,
                           (void**)&pINntpAdminExpiration);
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminExpiration( pINntpAdminExpiration, pStream );

    // Release it
    if (pINntpAdminExpiration) pINntpAdminExpiration->Release();

    TraceFunctLeave();
}

static void TestINntpAdminGroups(INntpAdminGroups *pINntpAdminGroups, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminGroups2");
    LONG        dw;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;
    WCHAR       wszGroup[128];

    lstrcpyW( wszGroup, (LPCWSTR) "control.cancel" );

    // Get
    hr = pINntpAdminGroups->Get((BSTR) wszGroup);
    if (SUCCEEDED(hr))
    {
        // Get Server
        hr = pINntpAdminGroups->get_Server( &bstr );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);
    
        // Get KeyType
        hr = pINntpAdminGroups->get_KeyType( &bstr );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);
    
        // Get Count
        hr = pINntpAdminGroups->get_Count( &dw );
        _ASSERT(SUCCEEDED(hr));
        pStream->AddResult(dw);

        // Description
        hr = pINntpAdminGroups->get_Description(&bstr);
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);

        // Moderator
        hr = pINntpAdminGroups->get_Moderator(&bstr);
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);

        // PrettyName
        hr = pINntpAdminGroups->get_PrettyName(&bstr);
        _ASSERT(SUCCEEDED(hr));
        pStream->AddBSTRResult(bstr);

    }
    pStream->AddResult(hr);

    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestINntpAdminGroups(IMsg *pMsg, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminGroups1");

    INntpAdminGroups* pINntpAdminGroups = NULL;
    HRESULT     hr = S_OK;

    // Create the INntpAdminGruops object
    hr = CoCreateInstance( (REFCLSID) CLSID_CNntpAdminGroups,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           (REFIID) IID_INntpAdminGroups,
                           (void**)&pINntpAdminGroups);
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminGroups( pINntpAdminGroups, pStream );

    // Release it
    if (pINntpAdminGroups) pINntpAdminGroups->Release();

    TraceFunctLeave();
}

static void TestINntpAdminFeeds(INntpAdminFeeds *pINntpAdminFeeds, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminFeeds2");
    LONG        dw;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;
    INntpFeed*  pINntpFeed = NULL;

    // Get Server
    hr = pINntpAdminFeeds->get_Server( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddBSTRResult(bstr);

    // Get KeyType
    hr = pINntpAdminFeeds->get_KeyType( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddBSTRResult(bstr);

    // Get Count
    hr = pINntpAdminFeeds->get_Count( &dw );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(dw);

    // Item
    hr = pINntpAdminFeeds->Item(1, &pINntpFeed);
    if (SUCCEEDED(hr))
    {
        TestINntpFeed(pINntpFeed, pStream);
    }
    pStream->AddResult(hr);

    if (pINntpFeed) pINntpFeed->Release();
    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestINntpAdminFeeds(IMsg *pMsg, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdminFeeds1");

    INntpAdminFeeds* pINntpAdminFeeds = NULL;
    HRESULT     hr = S_OK;

    // Create the INntpAdminFeeds object
    hr = CoCreateInstance( (REFCLSID) CLSID_CNntpAdminFeeds,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           (REFIID) IID_INntpAdminFeeds,
                           (void**)&pINntpAdminFeeds);
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminFeeds( pINntpAdminFeeds, pStream );

    // Release it
    if (pINntpAdminFeeds) pINntpAdminFeeds->Release();

    TraceFunctLeave();
}

static void TestINntpVirtualServer(IMsg *pMsg, CTLStream *pStream) {
    TraceFunctEnter("TestINntpVirtualServer");

    INntpVirtualServer* pINntpVirtualServer = NULL;
    INntpAdminFeeds* pINntpAdminFeeds = NULL;
    INntpAdminGroups* pINntpAdminGroups = NULL;
    INntpAdminExpiration* pINntpAdminExpiration = NULL;
    INntpAdminSessions* pINntpAdminSessions = NULL;
    INntpAdminRebuild* pINntpAdminRebuild = NULL;
    INntpVirtualRoots* pINntpVirtualRoots = NULL;
    ITcpAccess* pITcpAccess = NULL;
    LONG        dw;
    BSTR        bstr = NULL;
    BOOL        fFlag;
    HRESULT     hr = S_OK;

    // Create the INntpVirtualServer object
    hr = CoCreateInstance( (REFCLSID) CLSID_CNntpVirtualServer,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           (REFIID) IID_INntpVirtualServer,
                           (void**)&pINntpVirtualServer);
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Get
    hr = pINntpVirtualServer->Get();
    _ASSERT(SUCCEEDED(hr));

    // Get AdminFeeds object
    hr = pINntpVirtualServer->get_FeedsAdmin( (IDispatch **) &pINntpAdminFeeds );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminFeeds(pINntpAdminFeeds, pStream);

    // Get AdminGroups object
    hr = pINntpVirtualServer->get_GroupsAdmin( (IDispatch **) &pINntpAdminGroups );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminGroups(pINntpAdminGroups, pStream);

    // Get AdminExpiration object
    hr = pINntpVirtualServer->get_ExpirationAdmin( (IDispatch **) &pINntpAdminExpiration );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminExpiration(pINntpAdminExpiration, pStream);

    // Get AdminSessions object
    hr = pINntpVirtualServer->get_SessionsAdmin( (IDispatch **) &pINntpAdminSessions );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminSessions(pINntpAdminSessions, pStream);

    // Get AdminRebuild object
    hr = pINntpVirtualServer->get_RebuildAdmin( (IDispatch **) &pINntpAdminRebuild );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpAdminRebuild(pINntpAdminRebuild, pStream);

    // Get AdminVirtualRoots object
    hr = pINntpVirtualServer->get_VirtualRoots( &pINntpVirtualRoots );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestINntpVirtualRoots(pINntpVirtualRoots, pStream);

    // Get TcpAccess object
    hr = pINntpVirtualServer->get_TcpAccess( &pITcpAccess );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    TestITcpAccess(pITcpAccess, pStream);


    // ArticleTimeLimit
    hr = pINntpVirtualServer->get_ArticleTimeLimit( &dw );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(dw);
    hr = pINntpVirtualServer->put_ArticleTimeLimit( dw );
    _ASSERT(SUCCEEDED(hr));

    // HistoryExpiration
    hr = pINntpVirtualServer->get_HistoryExpiration( &dw );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(dw);
    hr = pINntpVirtualServer->put_HistoryExpiration( dw );
    _ASSERT(SUCCEEDED(hr));

    // HonorClientMsgIDs
    hr = pINntpVirtualServer->get_HonorClientMsgIDs( &fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(fFlag);
    hr = pINntpVirtualServer->put_HonorClientMsgIDs( fFlag );
    _ASSERT(SUCCEEDED(hr));

    // SmtpServer
    hr = pINntpVirtualServer->get_SmtpServer( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddBSTRResult(bstr);
    hr = pINntpVirtualServer->put_SmtpServer( bstr );
    _ASSERT(SUCCEEDED(hr));

    // All other properties (get/put) can be added here
    // Will add later because of the huge number of properties....

    // Set all the properties
    hr = pINntpVirtualServer->Set();
    _ASSERT(SUCCEEDED(hr));

    // Release it
    if (pINntpVirtualServer) pINntpVirtualServer->Release();
    if (pINntpAdminFeeds) pINntpAdminFeeds->Release();
    if (pINntpAdminGroups) pINntpAdminGroups->Release();
    if (pINntpAdminExpiration) pINntpAdminExpiration->Release();
    if (pINntpAdminSessions) pINntpAdminSessions->Release();
    if (pINntpAdminRebuild) pINntpAdminRebuild->Release();
    if (pINntpVirtualRoots) pINntpVirtualRoots->Release();
    if (pITcpAccess) pITcpAccess->Release();
    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

static void TestINntpService(IMsg *pMsg, CTLStream *pStream) {
    TraceFunctEnter("TestINntpService");

    INntpService* pINntpService = NULL;
    BOOL        fFlag = FALSE;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;

    // Create the INntpAdmin object
    hr = CoCreateInstance( (REFCLSID) CLSID_CNntpService,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           (REFIID) IID_INntpService,
                           (void**)&pINntpService);
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Get
    hr = pINntpService->Get();
    _ASSERT(SUCCEEDED(hr));

    // Get/Put SmtpServer
    hr = pINntpService->get_SmtpServer( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);
    pStream->AddBSTRResult(bstr);
    hr = pINntpService->put_SmtpServer( bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Allow client posts
    hr = pINntpService->get_AllowClientPosts( &fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(fFlag);
    hr = pINntpService->put_AllowClientPosts( fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Allow feed posts
    hr = pINntpService->get_AllowFeedPosts( &fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(fFlag);
    hr = pINntpService->put_AllowFeedPosts( fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Allow control msgs 
    hr = pINntpService->get_AllowControlMsgs( &fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(fFlag);
    hr = pINntpService->put_AllowControlMsgs( fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Default moderator domain
    hr = pINntpService->get_DefaultModeratorDomain( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);
    pStream->AddBSTRResult(bstr);
    hr = pINntpService->put_DefaultModeratorDomain( bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Disable Newnews
    hr = pINntpService->get_DisableNewnews( &fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(fFlag);
    hr = pINntpService->put_DisableNewnews( fFlag );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Set the value
    hr = pINntpService->Set();
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Release it
    if (pINntpService) pINntpService->Release();
    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}


static void TestINntpAdmin(IMsg *pMsg, CTLStream *pStream) {
    TraceFunctEnter("TestINntpAdmin");

    INntpAdmin* pINntpAdmin = NULL;
    LONG        dw;
    BSTR        bstr = NULL;
    HRESULT     hr = S_OK;

    // Create the INntpAdmin object
    hr = CoCreateInstance( (REFCLSID) CLSID_CNntpAdmin,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           (REFIID) IID_INntpAdmin,
                           (void**)&pINntpAdmin);
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);

    // Get Server
    hr = pINntpAdmin->get_Server( &bstr );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(hr);
    pStream->AddBSTRResult(bstr);

    // Get Version
    hr = pINntpAdmin->get_HighVersion( &dw );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(dw);

    hr = pINntpAdmin->get_LowVersion( &dw );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(dw);

    // Get Build num
    hr = pINntpAdmin->get_BuildNum( &dw );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(dw);

    // Get Service version
    hr = pINntpAdmin->get_ServiceVersion( &dw );
    _ASSERT(SUCCEEDED(hr));
    pStream->AddResult(dw);

    // Release it
    if (pINntpAdmin) pINntpAdmin->Release();
    if (bstr) SysFreeString( bstr );

    TraceFunctLeave();
}

void NNTPAdmUnitTest(IMsg *pMsg, CTLStream *pStream) {
    TraceFunctEnter("NNTPAdmUnitTest");

    TestINntpAdmin(pMsg, pStream);
    //TestINntpService(pMsg, pStream);
    TestINntpVirtualServer(pMsg, pStream);
    TestINntpAdminFeeds(pMsg, pStream);
    TestINntpAdminGroups(pMsg, pStream);
    TestINntpAdminSessions(pMsg, pStream);
    TestINntpAdminExpiration(pMsg, pStream);

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the DirDropS
	project.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/96	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\nntpmsgt.h ===
#ifndef __NNTPMSGT_H__
#define __NNTPMSGT_H__
#include "imsg.h"

void NNTPIMsgUnitTest(IMsg *pMessage, CTLStream *pStream, BOOL fOnPostFinal);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, CComObject<Base> **pp) {
//	template <class Base>
//	HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
//	{
	    _ASSERTE(pp != NULL);
	    HRESULT hRes = E_OUTOFMEMORY;
	    CComObject<Base>* p = NULL;
	    ATLTRY(p = new CComObject<Base>())
	    if (p != NULL)
	    {
//		    p->SetVoid(NULL);					// Change this...
			p->SetVoid(pUnkOuter);				// ... to this.
	        p->InternalFinalConstructAddRef();
	        hRes = p->FinalConstruct();
	        p->InternalFinalConstructRelease();
	        if (hRes != S_OK)
	        {
	            delete p;
	            p = NULL;
	        }
	    }
	    *pp = p;
	    return hRes;
//	}
}


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, REFIID iidDesired, LPVOID *pp) {
	HRESULT hrRes;
	CComObject<Base> *p = NULL;

	_ASSERTE(pp != NULL);
	*pp = NULL;
	hrRes = AtlCreateInstanceOf(pUnkOuter,&p);
	if (SUCCEEDED(hrRes)) {
		_ASSERTE(p != NULL);
		p->AddRef();
		hrRes = p->QueryInterface(iidDesired,pp);
		p->Release();
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\filttest.cpp ===
#include "stdafx.h"
#include "dbgtrace.h"
#include "resource.h"
#include "seo.h"
#include "nntpfilt.h"
#include "filttest.h"
#include "filter.h"
#include <stdio.h>

#include "testlib.h"
#include "nntpmsgt.h"
#include "nntpadmt.h"
#include "nntpseot.h"

HRESULT CNNTPTestFilter::FinalConstruct() {
	return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),
										  &m_pUnkMarshaler.p));
}

void CNNTPTestFilter::FinalRelease() {
	m_pUnkMarshaler.Release();
}

HRESULT STDMETHODCALLTYPE CNNTPTestFilter::OnPost(IMsg *pMessage) {
	CTLStream stream1;
	CTLStream stream2;

	NNTPIMsgUnitTest(pMessage, &stream1, m_fOnPostFinal);
	NNTPIMsgUnitTest(pMessage, &stream2, m_fOnPostFinal);

    NNTPAdmUnitTest(pMessage, &stream1);
    NNTPAdmUnitTest(pMessage, &stream2);

	NNTPSEOUnitTest(pMessage, &stream1, m_fOnPostFinal);
	NNTPSEOUnitTest(pMessage, &stream2, m_fOnPostFinal);

	if (!stream1.Compare(&stream2)) {
		OutputDebugString("NNTP SEO Unit Test: stream comparison failed");
		DebugBreak();
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\nntpmsgt.cpp ===
#include "stdafx.h"
#include <dbgtrace.h>
#include "testlib.h"
#include "nntpmsgt.h"

static void TestStream(IMsg *pMsg, CTLStream *pStream, char *pszParam, BOOL fOnPostFinal) {
	TraceFunctEnter("TestStream");
	
	CComBSTR bstrParam(pszParam);
	HRESULT hr;
	IStream *pMsgStream;
	CComVariant var;
	char szBuf[1024];
	STATSTG statstg;

	// get the message stream using get_Value and then throw it away
	hr = pMsg->get_Value(bstrParam, &var);
	_ASSERT(hr == S_OK && var.vt == VT_UNKNOWN && var.punkVal != NULL);
	pStream->AddResult(hr);
	pStream->AddResult(var.vt);
	pStream->AddResult((DWORD) var.punkVal);

	// get the message stream using GetInterfaceA
	hr = pMsg->GetInterfaceA(pszParam, IID_IStream, (IUnknown **) &pMsgStream);
	_ASSERT(hr == S_OK && pMsgStream != NULL);
	pStream->AddResult(hr);
	pStream->AddResult((DWORD) var.punkVal);

	// make sure that the stream values are the same
	_ASSERT(var.punkVal == pMsgStream);
	var.Clear();

	// try to get the length of the stream
	hr = pMsgStream->Stat(&statstg, STATFLAG_NONAME);
	_ASSERT(hr == S_OK);
	pStream->AddResult(hr);
	_ASSERT(statstg.cbSize.HighPart == 0);
	pStream->AddResult(statstg.cbSize.HighPart);
	pStream->AddResult(statstg.cbSize.LowPart);

	if (statstg.cbSize.LowPart > 256) {
		LARGE_INTEGER liZero = { 0, 0 };
		LARGE_INTEGER liEnd = { -256, 0 };
		DWORD cbRead;

		// get the first 256 bytes of the stream
		hr = pMsgStream->Seek(liZero, STREAM_SEEK_SET, NULL);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
		hr = pMsgStream->Read(szBuf, 256, &cbRead);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
		_ASSERT(cbRead == 256);
		pStream->AddResult(cbRead);
		pStream->AddResultLen(szBuf, 256);

		// get the last 256 bytes of the stream
		hr = pMsgStream->Seek(liEnd, STREAM_SEEK_END, NULL);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
		hr = pMsgStream->Read(szBuf, 256, &cbRead);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
		_ASSERT(cbRead == 256);
		pStream->AddResult(cbRead);
		pStream->AddResultLen(szBuf, 256);
	} else {
		DWORD cbRead;
		LARGE_INTEGER liZero = {0, 0};

		// get the whole stream
		hr = pMsgStream->Seek(liZero, STREAM_SEEK_SET, NULL);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
		hr = pMsgStream->Read(szBuf, 256, &cbRead);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
		pStream->AddResult(cbRead);
		pStream->AddResultLen(szBuf, cbRead);
	}

	// make sure that we can't write to the stream
	DWORD cbWritten = 0;
	lstrcpy(szBuf, "abcdef");
	hr = pMsgStream->Write(szBuf, 6, &cbWritten);
	_ASSERT(FAILED(hr));
	pStream->AddResult(hr);
	pStream->AddResult(cbWritten);

	// make sure that we can't change the stream parameter
	hr = pMsg->SetInterfaceA(pszParam, NULL);
	_ASSERT(FAILED(hr));
	pStream->AddResult(hr);
	var = pMsgStream;
	hr = pMsg->put_Value(bstrParam, var);
	_ASSERT(FAILED(hr));
	pStream->AddResult(hr);
	var.Clear();

	// release the message stream
	pMsgStream->Release();

	TraceFunctLeave();
}

static void TestBool(IMsg *pMsg, CTLStream *pStream, char *pszParam, BOOL fOnPostFinal) {
	TraceFunctEnter("TestBool");
	
	CComBSTR bstrParam(pszParam);
	DWORD dw;
	CComVariant var;
	HRESULT hr;

	if (!fOnPostFinal) {
		// this routine assumes that the value should be TRUE (non-zero) by 
		// default.  it then sets it to 0, checks to make sure that the value 
		// is zero, then changes it back to 1.  In doing so it uses 
		// GetDwordA, SetDwordA, get_Value and put_Value.
		hr = pMsg->GetDwordA(pszParam, &dw);
		_ASSERT(hr == S_OK && dw);
		pStream->AddResult(hr);
		pStream->AddResult(dw);
	
		hr = pMsg->SetDwordA(pszParam, 0);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
	
		hr = pMsg->get_Value(bstrParam, &var);
		_ASSERT(hr == S_OK && var.vt == VT_I4 && var.lVal == 0);
		pStream->AddResult(hr);
		pStream->AddResult(var.vt);
		pStream->AddResult(var.lVal);
		var.Clear();
	
		var.vt = VT_I4;
		var.lVal = dw;
		hr = pMsg->put_Value(bstrParam, var);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
	} else {
		// here we make sure that none of the accessors for this property
		// will work
		hr = pMsg->GetDwordA(pszParam, &dw);
		_ASSERT(FAILED(hr));
		pStream->AddResult(hr);
	
		hr = pMsg->SetDwordA(pszParam, 0);
		_ASSERT(FAILED(hr));
		pStream->AddResult(hr);
	
		hr = pMsg->get_Value(bstrParam, &var);
		_ASSERT(FAILED(hr));
		pStream->AddResult(hr);
		var.Clear();
	
		var.vt = VT_I4;
		var.lVal = dw;
		hr = pMsg->put_Value(bstrParam, var);
		_ASSERT(FAILED(hr));
		pStream->AddResult(hr);
	}

	var.Clear();

	TraceFunctLeave();
}

static void TestDwordRO(IMsg *pMsg, CTLStream *pStream, char *pszParam, BOOL fOnPostFinal) {
	TraceFunctEnter("TestDwordRO");
	
	CComBSTR bstrParam(pszParam);
	DWORD dw;
	CComVariant var;
	HRESULT hr;

	// get the value
	hr = pMsg->GetDwordA(pszParam, &dw);
	_ASSERT(hr == S_OK && dw);
	pStream->AddResult(hr);
	pStream->AddResult(dw);
	
	// get it again
	hr = pMsg->get_Value(bstrParam, &var);
	_ASSERT(hr == S_OK && var.vt == VT_I4);
	pStream->AddResult(hr);
	pStream->AddResult(var.vt);
	pStream->AddResult(var.lVal);
	var.Clear();

	TraceFunctLeave();
}

static void TestStringRO(IMsg *pMsg, CTLStream *pStream, char *pszParam, BOOL fOnPostFinal) {
	TraceFunctEnter("TestStringRO");
	
	DWORD dw;
	HRESULT hr;
	char szBuf[1024];
	CComBSTR bstrParam(pszParam);
	CComVariant var;

	// get the string value
	dw = 1024;
	hr = pMsg->GetStringA(pszParam, &dw, szBuf);
	_ASSERT(hr == S_OK && dw > 0);
	pStream->AddResult(hr);
	pStream->AddResult(szBuf);

	// get the BSTR version of the value
	hr = pMsg->get_Value(bstrParam, &var);
	_ASSERT(hr == S_OK && var.vt == VT_BSTR);
	pStream->AddResult(hr);
	pStream->AddResult(var.vt);
	if (var.vt == VT_BSTR) pStream->AddBSTRResult(var.bstrVal);

	// make sure that we can't set its value
	hr = pMsg->SetStringA(pszParam, dw, szBuf);
	_ASSERT(FAILED(hr));
	pStream->AddResult(hr);

	// make sure that we can't set its value
	hr = pMsg->put_Value(bstrParam, var);
	_ASSERT(FAILED(hr));
	pStream->AddResult(hr);

	var.Clear();

	TraceFunctLeave();
}

static void TestStringRW(IMsg *pMsg, CTLStream *pStream, char *pszParam, BOOL fOnPostFinal) {
	TraceFunctEnter("TestStringRW");
	
	DWORD dw;
	HRESULT hr;
	char szBuf[1024];
	CComBSTR bstrParam(pszParam);
	CComVariant var;

	// get the string value
	dw = 1024;
	hr = pMsg->GetStringA(pszParam, &dw, szBuf);
	_ASSERT(hr == S_OK && dw > 0);
	pStream->AddResult(hr);
	pStream->AddResult(szBuf);

	// get the string value using the variant accessor
	hr = pMsg->get_Value(bstrParam, &var);
	_ASSERT(hr == S_OK && var.vt == VT_BSTR);
	pStream->AddResult(hr);
	pStream->AddResult(var.vt);
	if (var.vt == VT_BSTR) pStream->AddBSTRResult(var.bstrVal);

	// set the string to "junk"
	lstrcpyA(szBuf, "junk");
	hr = pMsg->SetStringA(pszParam, lstrlenA(szBuf), szBuf);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);
	if (SUCCEEDED(hr)) {
		// if we could change it then make sure that getting it reflects
		// the change, then return it to the original value
		dw = 1024;
		hr = pMsg->GetStringA(pszParam, &dw, szBuf);
		_ASSERT(hr == S_OK && dw == 5 && (memcmp(szBuf, "junk", 4) == 0));
		pStream->AddResult(hr);
		pStream->AddResult(dw);
		pStream->AddResult(szBuf);
	
		hr = pMsg->put_Value(bstrParam, var);
		_ASSERT(hr == S_OK);
		pStream->AddResult(hr);
	}

	var.Clear();

	TraceFunctLeave();
}

#define HEADER_SHOULD_WORK 0 
#define HEADER_MIGHT_WORK 1
#define HEADER_SHOULD_FAIL 2

// this is a lot like TestStringRO, but we allow get's to fail if the header
// doesn't exist
static void TestHeader(IMsg *pMsg, CTLStream *pStream, char *pszParam, BOOL fOnPostFinal, DWORD expected) {
	TraceFunctEnter("TestHeader");
	
	DWORD dw;
	HRESULT hr;
	char szBuf[1024];
	CComBSTR bstrParam(pszParam);
	CComVariant var;

	// get the header value
	dw = 1024;
	hr = pMsg->GetStringA(pszParam, &dw, szBuf);
	switch (expected) {
		case HEADER_SHOULD_WORK: _ASSERT(hr == S_OK); break;
		case HEADER_MIGHT_WORK: break;
		case HEADER_SHOULD_FAIL: _ASSERT(hr != S_OK); break;
	}
	pStream->AddResult(hr);
	if (SUCCEEDED(hr)) pStream->AddResult(szBuf);

	// get the BSTR version of the value
	hr = pMsg->get_Value(bstrParam, &var);
	// if we got a result it better be a BSTR
	_ASSERT(FAILED(hr) || var.vt == VT_BSTR);
	pStream->AddResult(hr);
	pStream->AddResult(var.vt);
	if (var.vt == VT_BSTR) pStream->AddBSTRResult(var.bstrVal);

	// make sure that we can't set its value
	hr = pMsg->SetStringA(pszParam, dw, szBuf);
	_ASSERT(FAILED(hr));
	pStream->AddResult(hr);

	// make sure that we can't set its value
	hr = pMsg->put_Value(bstrParam, var);
	_ASSERT(FAILED(hr));
	pStream->AddResult(hr);

	var.Clear();
	
	TraceFunctLeave();
}

void NNTPIMsgUnitTest(IMsg *pMsg, CTLStream *pStream, BOOL fOnPostFinal) {
	TraceFunctEnter("NNTPIMsgUnitTest");

	TestStream(pMsg, pStream, "message stream", fOnPostFinal);
	TestHeader(pMsg, pStream, "header-from", fOnPostFinal, HEADER_SHOULD_WORK);
	TestHeader(pMsg, pStream, "header-newsgroups", fOnPostFinal, HEADER_SHOULD_WORK);
	TestHeader(pMsg, pStream, "header-subject", fOnPostFinal, HEADER_SHOULD_WORK);
	TestHeader(pMsg, pStream, "header-xref", fOnPostFinal, HEADER_MIGHT_WORK);
	TestHeader(pMsg, pStream, "header-date", fOnPostFinal, HEADER_MIGHT_WORK);
	TestHeader(pMsg, pStream, "header-", fOnPostFinal, HEADER_SHOULD_FAIL);
	TestHeader(pMsg, pStream, "header-:newsgroups", fOnPostFinal, HEADER_SHOULD_FAIL);
	TestDwordRO(pMsg, pStream, "feedid", fOnPostFinal);

	if (!fOnPostFinal) {
		TestBool(pMsg, pStream, "post", fOnPostFinal);
		TestBool(pMsg, pStream, "process control", fOnPostFinal);
		TestBool(pMsg, pStream, "process moderator", fOnPostFinal);
		TestStringRW(pMsg, pStream, "newsgroups", fOnPostFinal);
	} else {
		TestStringRO(pMsg, pStream, "newsgroups", fOnPostFinal);
		TestStringRO(pMsg, pStream, "filename", fOnPostFinal);
	}

	TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\nntpseot.cpp ===
#include "stdafx.h"
#include <dbgtrace.h>
#include "testlib.h"
#include "nntpseot.h"

void WalkEventPropertyBag(CTLStream *pStream, CComPtr<IEventPropertyBag> pEventPropertyBag) {
	TraceFunctEnter("WalkEventPropertyBag");

	HRESULT hr;

	CComPtr<IUnknown> punkEventPropertyBagEnum;
	hr = pEventPropertyBag->get__NewEnum(&punkEventPropertyBagEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	CComPtr<IEnumVARIANT> pEventPropertyBagEnum;
	hr = punkEventPropertyBagEnum->QueryInterface(IID_IEnumVARIANT, 
												  (void **) &pEventPropertyBagEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	DWORD cReturned;
	do {
		CComVariant varPropertyName;

		hr = pEventPropertyBagEnum->Next(1, &varPropertyName, &cReturned);
		pStream->AddResult(hr);
		pStream->AddResult(cReturned);
		_ASSERT(hr != S_OK || cReturned == 1);

		if (hr == S_OK) {
			pStream->AddResult(varPropertyName.vt);

			hr = varPropertyName.ChangeType(VT_BSTR);
			pStream->AddResult(hr);
			pStream->AddResult(varPropertyName.vt);
			_ASSERT(hr == S_OK);
			_ASSERT(varPropertyName.vt == VT_BSTR);

			if (varPropertyName.vt == VT_BSTR) {
				pStream->AddBSTRResult(varPropertyName.bstrVal);

				CComVariant varProperty;
				hr = pEventPropertyBag->Item(&varPropertyName, &varProperty);
				pStream->AddResult(hr);
				_ASSERT(hr == S_OK);

				pStream->AddResult(varProperty.vt);

				hr = varProperty.ChangeType(VT_BSTR);
				pStream->AddResult(hr);
				pStream->AddResult(varPropertyName.vt);
				_ASSERT(hr == S_OK || hr == DISP_E_TYPEMISMATCH);
				if (hr == S_OK) { _ASSERT(varPropertyName.vt == VT_BSTR); }

				if (varProperty.vt == VT_BSTR) {
					pStream->AddBSTRResult(varProperty.bstrVal);
				}
			}
		}
	} while (cReturned == 1);
	
	TraceFunctLeave();
}

void WalkEventBindings(CTLStream *pStream, CComPtr<IEventBindings> pEventBindings) {
	TraceFunctEnter("WalkEventBindings");
	
	HRESULT hr;
	
	CComPtr<IUnknown> punkEventBindingsEnum;
	hr = pEventBindings->get__NewEnum(&punkEventBindingsEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	CComPtr<IEnumVARIANT> pEventBindingsEnum;
	hr = punkEventBindingsEnum->QueryInterface(IID_IEnumVARIANT, 
											   (void **) &pEventBindingsEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	DWORD cReturned;
	do {
		VARIANT varEventBinding;

		hr = pEventBindingsEnum->Next(1, &varEventBinding, &cReturned);
		pStream->AddResult(hr);
		pStream->AddResult(cReturned);
		_ASSERT(hr != S_OK || cReturned == 1);

		if (hr == S_OK) {
			pStream->AddResult(varEventBinding.vt);
			_ASSERT(varEventBinding.vt == VT_DISPATCH);

			CComPtr<IEventBinding> pEventBinding;
			hr = varEventBinding.punkVal->QueryInterface(IID_IEventBinding,
													    (void **) &pEventBinding);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);

			CComBSTR bstrTemp;
			hr = pEventBinding->get_DisplayName(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

			hr = pEventBinding->get_SinkClass(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

			hr = pEventBinding->get_ID(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

			VARIANT_BOOL fTemp;
			hr = pEventBinding->get_Enabled(&fTemp);
			pStream->AddResult(hr);
			pStream->AddResult(fTemp);
			_ASSERT(hr == S_OK);

			long lTemp; 
			hr = pEventBinding->get_MaxFirings(&lTemp);
			pStream->AddResult(hr);
			if (hr == S_OK) pStream->AddResult(lTemp);
			_ASSERT(SUCCEEDED(hr));

			DATE dateTemp;
			hr = pEventBinding->get_Expiration(&dateTemp);
			pStream->AddResult(hr);
			if (hr == S_OK) pStream->AddResult(dateTemp);
			_ASSERT(SUCCEEDED(hr));

			CComPtr<IEventPropertyBag> pSourceProperties;
			hr = pEventBinding->get_SourceProperties(&pSourceProperties);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			WalkEventPropertyBag(pStream, pSourceProperties);

			CComPtr<IEventPropertyBag> pSinkProperties;
			hr = pEventBinding->get_SinkProperties(&pSinkProperties);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			WalkEventPropertyBag(pStream, pSinkProperties);

			CComPtr<IEventPropertyBag> pEventBindingProperties;
			hr = pEventBinding->get_EventBindingProperties(&pEventBindingProperties);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			WalkEventPropertyBag(pStream, pEventBindingProperties);
		}
	} while (cReturned == 1);

	TraceFunctLeave();
}

void WalkEventSources(CTLStream *pStream, CComPtr<IEventSources> pEventSources) {
	TraceFunctEnter("WalkEventSources");
	
	HRESULT hr;

	CComPtr<IUnknown> punkEventSourcesEnum;
	hr = pEventSources->get__NewEnum(&punkEventSourcesEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	CComPtr<IEnumVARIANT> pEventSourcesEnum;
	hr = punkEventSourcesEnum->QueryInterface(IID_IEnumVARIANT, 
											   (void **) &pEventSourcesEnum);
	pStream->AddResult(hr);

	DWORD cReturned;
	do {
		VARIANT varEventSource;

		hr = pEventSourcesEnum->Next(1, &varEventSource, &cReturned);
		pStream->AddResult(hr);
		pStream->AddResult(cReturned);
		_ASSERT(hr != S_OK || cReturned == 1);

		if (hr == S_OK) {
			pStream->AddResult(varEventSource.vt);
			_ASSERT(varEventSource.vt == VT_DISPATCH);

			CComPtr<IEventSource> pEventSource;
			hr = varEventSource.punkVal->QueryInterface(IID_IEventSource,
													    (void **) &pEventSource);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			varEventSource.punkVal->Release();

			CComBSTR bstrTemp;
			hr = pEventSource->get_DisplayName(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

			hr = pEventSource->get_ID(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

			CComPtr<IUnknown> punkMoniker;
			hr = pEventSource->get_BindingManagerMoniker(&punkMoniker);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);

			CComPtr<IEventBindingManager> pEventBindingManager;
			hr = pEventSource->GetBindingManager(&pEventBindingManager);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);

			CComPtr<IUnknown> punkEventTypesEnum;
			hr = pEventBindingManager->get__NewEnum(&punkEventTypesEnum);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);

			CComPtr<IEnumVARIANT> pEventTypesEnum;
			hr = punkEventTypesEnum->QueryInterface(IID_IEnumVARIANT,
													(void **) &pEventTypesEnum);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);

			DWORD cReturnedEvents;
			do {
				VARIANT varEventType;

				hr = pEventTypesEnum->Next(1, &varEventType, &cReturnedEvents);
				pStream->AddResult(hr);
				pStream->AddResult(cReturnedEvents);
				_ASSERT(hr != S_OK || cReturnedEvents == 1);

				if (hr == S_OK) {
					pStream->AddResult(varEventType.vt);
					_ASSERT(varEventType.vt == VT_BSTR);

					pStream->AddBSTRResult(varEventType.bstrVal);

					CComPtr<IEventBindings> pEventBindings;
					hr = pEventBindingManager->get_Bindings(
								varEventType.bstrVal, 
								&pEventBindings);
					pStream->AddResult(hr);
					_ASSERT(hr == S_OK);	

					WalkEventBindings(pStream, pEventBindings);
				}
			} while (cReturnedEvents == 1);
		}
	} while (cReturned == 1);

	TraceFunctLeave();
}

void WalkEventTypeSinks(CTLStream *pStream, CComPtr<IEventTypeSinks> pEventTypeSinks) {
	TraceFunctEnter("WalkEventTypeSinks");

	HRESULT hr;

	CComPtr<IUnknown> punkEventTypeSinksEnum;
	hr = pEventTypeSinks->get__NewEnum(&punkEventTypeSinksEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	CComPtr<IEnumVARIANT> pEventTypeSinksEnum;
	hr = punkEventTypeSinksEnum->QueryInterface(IID_IEnumVARIANT, 
											(void **) &pEventTypeSinksEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	DWORD cReturned;
	do {
		VARIANT varEventTypeSink;

		hr = pEventTypeSinksEnum->Next(1, &varEventTypeSink, &cReturned);
		pStream->AddResult(hr);
		pStream->AddResult(cReturned);
		_ASSERT(hr != S_OK || cReturned == 1);

		if (hr == S_OK) {
			pStream->AddResult(varEventTypeSink.vt);
			_ASSERT(varEventTypeSink.vt == VT_BSTR);

			pStream->AddBSTRResult(varEventTypeSink.bstrVal);
		}
	} while (cReturned == 1);

	
	TraceFunctLeave();
}

void WalkEventTypes(CTLStream *pStream, CComPtr<IEventTypes> pEventTypes) {
	TraceFunctEnter("WalkEventTypes");
	
	HRESULT hr;
	
	CComPtr<IUnknown> punkEventTypesEnum;
	hr = pEventTypes->get__NewEnum(&punkEventTypesEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	CComPtr<IEnumVARIANT> pEventTypesEnum;
	hr = punkEventTypesEnum->QueryInterface(IID_IEnumVARIANT,
											(void **) &pEventTypesEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	DWORD cReturned;
	do {
		VARIANT varEventType;

		hr = pEventTypesEnum->Next(1, &varEventType, &cReturned);
		pStream->AddResult(hr);
		pStream->AddResult(cReturned);
		_ASSERT(hr != S_OK || cReturned == 1);

		if (hr == S_OK) {
			pStream->AddResult(varEventType.vt);
			_ASSERT(varEventType.vt == VT_DISPATCH);

			CComPtr<IEventType> pEventType;
			hr = varEventType.punkVal->QueryInterface(IID_IEventType,
													  (void **) &pEventType);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			varEventType.punkVal->Release();

			CComBSTR bstrTemp;
			hr = pEventType->get_DisplayName(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

			hr = pEventType->get_ID(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

#if BUGS_IN_SEO_DONT_LET_THIS_WORK
			CComPtr<IEventTypeSinks> pEventTypeSinks;
			hr = pEventType->get_Sinks(&pEventTypeSinks);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			WalkEventTypeSinks(pStream, pEventTypeSinks);
#endif
		}
	} while (cReturned == 1);

	TraceFunctLeave();
}

void WalkSourceTypes(CTLStream *pStream, CComPtr<IEventSourceTypes> pSourceTypes) {
	TraceFunctEnter("WalkSourceTypes");
	
	HRESULT hr;

	CComPtr<IUnknown> punkSourceTypesEnum;
	hr = pSourceTypes->get__NewEnum(&punkSourceTypesEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	CComPtr<IEnumVARIANT> pSourceTypesEnum;
	hr = punkSourceTypesEnum->QueryInterface(IID_IEnumVARIANT,
											 (void **) &pSourceTypesEnum);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	DWORD cReturned;
	do {
		VARIANT varEventSourceType;

		hr = pSourceTypesEnum->Next(1, &varEventSourceType, &cReturned);
		pStream->AddResult(hr);
		pStream->AddResult(cReturned);
		_ASSERT(SUCCEEDED(hr));
		// if hr == S_OK then cReturned better be one
		_ASSERT((hr != S_OK) || (cReturned == 1));

		if (hr == S_OK) {
			pStream->AddResult(varEventSourceType.vt);
			_ASSERT(varEventSourceType.vt == VT_DISPATCH);

			CComPtr<IEventSourceType> pEventSourceType;
			hr = varEventSourceType.punkVal->QueryInterface(IID_IEventSourceType,
															(void **) &pEventSourceType);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			varEventSourceType.punkVal->Release();

			CComBSTR bstrTemp;
			hr = pEventSourceType->get_ID(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

			hr = pEventSourceType->get_DisplayName(&bstrTemp);
			pStream->AddResult(hr);
			pStream->AddBSTRResult(bstrTemp);
			_ASSERT(hr == S_OK);

			CComPtr<IEventTypes> pEventTypes;
			hr = pEventSourceType->get_EventTypes(&pEventTypes);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			WalkEventTypes(pStream, pEventTypes);

			CComPtr<IEventSources> pEventSources;
			hr = pEventSourceType->get_Sources(&pEventSources);
			pStream->AddResult(hr);
			_ASSERT(hr == S_OK);
			WalkEventSources(pStream, pEventSources);
		}
	} while (cReturned == 1);
	
	TraceFunctLeave();
}

void WalkBindingDatabase(CTLStream *pStream) {
	TraceFunctEnter("DumpBindingDatabase");
	
	HRESULT hr;

	CComPtr<IEventManager> pEventManager;
	hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL, 
						  IID_IEventManager, (LPVOID *) &pEventManager);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	CComPtr<IEventSourceTypes> pSourceTypes;
	hr = pEventManager->get_SourceTypes(&pSourceTypes);
	pStream->AddResult(hr);
	_ASSERT(hr == S_OK);

	WalkSourceTypes(pStream, pSourceTypes);
	
	TraceFunctLeave();
}

void NNTPSEOUnitTest(IMsg *pMsg, CTLStream *pStream, BOOL fOnPostFinal) {
	TraceFunctEnter("NNTPSEOUnitTest");
	
	WalkBindingDatabase(pStream);

	TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\cfeed.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cfeed.cpp

Abstract:

    This module contains definition for the CFeed base class

Author:

    Carl Kadie (CarlK)     01-Oct-1995

Revision History:

--*/

#include "tigris.hxx"

//
//If some of these look very simple, make them inline!!!!
//

CPool	CFeed::gFeedPool(FEED_SIGNATURE) ;


//
//  Largest possible CInFeed derived object
//
#define MAX_FEED_SIZE   max(    sizeof( CFeed ),    \
                            max(    sizeof( COutFeed ), \
                            max(    sizeof( CInFeed ),  \
                            max(    sizeof( CFromPeerFeed ),    \
                            max(    sizeof( CFromMasterFeed ),  \
                                    sizeof( CFromClientFeed )   \
                             ) ) ) ) )

const   unsigned    cbMAX_FEED_SIZE = MAX_FEED_SIZE ;

BOOL	
CFeed::InitClass()	
/*++

Routine Description:

    Preallocates CPOOL memory for articles

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{

	return	gFeedPool.ReserveMemory(	MAX_FEEDS, cbMAX_FEED_SIZE ) ;

}


BOOL
CFeed::TermClass(
				   void
				   )
/*++

Routine Description:

	Called when done with CPOOL.

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	_ASSERT( gFeedPool.GetAllocCount() == 0 ) ;

	return	gFeedPool.ReleaseMemory() ;

}

void
CFeed::LogFeedEvent(	DWORD	messageId,	LPSTR	lpstrMessageId, DWORD dwInstanceId )	{

	return ;

}	

void*	CFeed::operator	new(	size_t	size )
{
	Assert( size <= MAX_FEED_SIZE ) ;
	return	gFeedPool.Alloc() ;
}

void	CFeed::operator	delete(	void*	pv )
{
	gFeedPool.Free( pv ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\nntpseot.h ===
#ifndef __NNTPSEOT_H__
#define __NNTPSEOT_H__
#include "imsg.h"
#include "seo.h"

void NNTPSEOUnitTest(IMsg *pMessage, CTLStream *pStream, BOOL fOnPostFinal);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\adminmb.cxx ===
#include "tigris.hxx"

#define INITGUID
#include "initguid.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ole2.h>
#include "iadmw.h"

//
//  We need a ptr to the IMSAdminBase interface because IMDCOM does not
//  do access checks !
//

IMSAdminBaseW * g_pAdminBase = NULL;

//
//  Following are helper functions for getting to IMSAdminBaseW
//

HRESULT
InitAdminBase()
{
    HRESULT hRes = S_OK;

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ( hRes == CO_E_ALREADYINITIALIZED || SUCCEEDED(hRes) ) {
        hRes = CoCreateInstance(
                   CLSID_MSAdminBase_W,
                   NULL,
                   CLSCTX_SERVER,
                   IID_IMSAdminBase_W,
                   (void**) &g_pAdminBase
                   );
    }

    return hRes;
}

VOID
UninitAdminBase()
{
    if (g_pAdminBase != NULL) {
        g_pAdminBase->Release();
        CoUninitialize();
        g_pAdminBase = NULL;
    }
}

HRESULT
OpenAdminBaseKey(
    IN  LPCWSTR lpPath,
    IN  DWORD   Access,
    OUT METADATA_HANDLE *phHandle
    )
{
    HRESULT hRes = S_OK;
    METADATA_HANDLE RootHandle;

    if (g_pAdminBase == NULL) {
        //
        // Don't have a Metadata interface
        //
        return S_FALSE;
    }

    hRes = g_pAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                lpPath,
                Access,
                100,
                &RootHandle
                );

    if (SUCCEEDED(hRes)) {
        *phHandle = RootHandle;
    }

    return(hRes);
}

VOID
CloseAdminBaseKey(
    IN METADATA_HANDLE hHandle
    )
{
    if( g_pAdminBase ) {
        g_pAdminBase->CloseKey(hHandle);
    }
}

BOOL
AccessCheck( 
    IN METADATA_HANDLE hHandle,
    IN DWORD Access
    )
{
    DWORD i=0;
    WCHAR wszKeyName [METADATA_MAX_NAME_LEN+1];
    HRESULT hr;

    TraceFunctEnter("AccessCheck");

    if( g_pAdminBase ) {

        //
        //  Success in enumerating a key implies access !
        //

        hr = g_pAdminBase->EnumKeys(
                            hHandle,
                            L"",
                            wszKeyName,
                            i);

        if( SUCCEEDED(hr) ) {
            DebugTrace(0,"Access Check found key %S", wszKeyName);
            return TRUE;
        } else {
            DebugTrace(0,"Access Check failed : %x", hr);
        }
    } 
    
    return FALSE;
}

BOOL 
OperatorAccessCheck( 
                  LPCSTR lpMBPath, 
                  DWORD Access 
                  )
/*++

Routine Description : 

    Check operator access against given MB path

Arguments : 
	
    lpMBPath    -   MB path to check access against
    Access      -   Access mask

Return Value : 

	If TRUE, operator has access else not.

--*/
{
    DWORD       err;
    BOOL        fRet = FALSE;
    WCHAR       wszPath [METADATA_MAX_NAME_LEN+1];
    LPWSTR      lpwstrPath = wszPath;
    METADATA_HANDLE hMeta;
    HRESULT     hr;

    TraceFunctEnter("OperatorAccessCheck");

    //
    //  Impersonate the RPC client.
    //

    err = (DWORD)RpcImpersonateClient( NULL );

    if( err != NO_ERROR )
    {
        ErrorTrace(0,"cannot impersonate rpc client error %lu", err );

    } else {

        //
        //  Successfully impersonated RPC client -
        //  Validate access to MB by opening the metabase key
        //

        while ( (*lpwstrPath++ = (WCHAR)*lpMBPath++) != (WCHAR)'\0');

        hr = OpenAdminBaseKey( (LPCWSTR)wszPath, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, &hMeta );
        if ( FAILED(hr) ) 
	    {
		    ErrorTrace(0,"Error opening %S : %x",wszPath,hr);
        } else {
            fRet = AccessCheck( hMeta, Access );
            CloseAdminBaseKey(  hMeta );
        }

        //
        //  Revert to our former self.
        //

        _VERIFY( !RpcRevertToSelf() );
    }

    return fRet;

}   // OperatorAccessCheck
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\addon.h ===
#ifndef	_ADDON_H_
#define	_ADDON_H_

class	CAddon	{
//
//	This class manages files which contains data with the following format : 
//
//	Name<TAB or SPACE>String with Spaces<CRLF>
//
//	Examples of such files are active.txt files and descript.txt files.
//	In these files the 'Name' is the newsgroup name, and the following
//	character contains strings which CNewsGroup objects will reference.
//	(For instance - descript.txt the extra text is the descriptive string provided
//	in response to the list newsgroups command.
//
//	This base class handles memory mapping the file, and handles insert, 
//	deletion and compaction of the data file.  Insertions are appended to the
//	end, there is no attempt to order the data.  Deletions will just overwrite
//	portions of the file with NULL's.  When we compact, we shift all the data
//	around.
//
//	The function LookupFunction() should be overridden by derived classes
//	so as we parse the file they can learn where the content is.
//	The ReadData() and FinishReadData() must be used before any pointer
//	which points into the memory mapping is used, this ensures that 
//	there are not synchronization problems as we compact or grow the file.
//

protected : 

	//	
	//	Handle to the source file 
	//
	HANDLE		m_hFile ;

	//
	//	Memory mapping of the data file !
	//
	CMapFile*	m_pMapFile ;

	//
	//	Number of bytes of the file In use - that contain original or appended data.
	//
	DWORD		m_cbInuse ;

	//
	//	Number of bytes that we have overwritten with NULLs due to deletions
	//
	DWORD		m_cbDeleted ;

	//
	//	Number of bytes at the end of the file available for 'stuff'
	//
	DWORD		m_cbAvailable ;

	//
	//	Reader/Writer lock for accessing the data.
	//
	CShareLockNH	m_Access ;

	//
	//	This function is called for each string in the file - the derived class
	//	should determine whether this string is still needed !
	//	Each line of our data file contains a string followed by a space followed by 
	//	a bunch of text (which may contain spaces).  
	//	The first string will typically be a newsgroup name.  The derived class
	//	should lookup the newsgroup, and set its member pointers to point into our 
	//	data area.  we will notify the derived class if we have to move the data 
	//	around so that the newsgroup pointers can be adjusted.
	//
	virtual		BOOL	LookupFunction( 
							LPSTR	lpstrString, 
							DWORD	cbString, 
							LPSTR	lpstrData, 
							DWORD	cbData,
							LPVOID	lpv ) = 0 ;

	//
	//	This lets the derived class know that all of the data strings are moving around - 
	//	it should delete all of its pointers into our data when this called.
	//	After this is called we will start calling LookupFunction() with the new positions.
	//	This kind of thing happens when we need to grow and shrink our memory mapping.
	//
	virtual		void	ResetAddons() = 0 ;

	//
	//	This function will remove the NULL's that we leave in the data file as we 
	//	remove entries
	//
	void		CompactImage() ;

	//
	//	This function will parse the file and call LookupFunction for each 
	//	entry as we come across it.
	//
	BOOL		ScanImage() ;

public : 

	//
	//	Constructor - set us in an empty state
	//
	CAddon(	) ;

	//
	//	lpstrAddonFile - A file containing newsgroup names followed by space followed by data.
	//	We will get a memory mapping and parse the file, and calll LookupFunction as we 
	//	separate out the distinct newsgroups.
	//	During init we will call LookupFunction with the lpvContext set to NULL.
	//
	BOOL	Init(	
				LPSTR	lpstrAddonFile,	
				BOOL	fCompact = TRUE, 
				DWORD cbGrow = 0
				) ;
	
	//
	//	Add a newsgroup and data to the data file.
	//	We may have to muck with the memory mapping, which may result in a call
	//	to ResetAddons().
	//	Once we have completed appending the line, we will call LookupFunction for the newly 
	//	added line, and pass lpvContext through.
	//
	BOOL	AppendLine( 
					LPSTR	lpstrName,	
					DWORD	cbName,	
					LPSTR	lpstrText,	
					DWORD	cbText, 
					LPVOID lpvContext 
					) ;

	//
	//	Remove a line from the file.  We will fill the line in with NULLs.
	//	When we are close'd we will compact the file removing the NULL's, or we may do 
	//	this during an AppendLine() if we figure we'll recover enough space to make it worth while.
	//
	BOOL	DeleteLine(	
					LPSTR	lpstrName
					) ;

	//
	//	Close all of our memory mappings etc...
	//
	BOOL	Close(	
					BOOL	fCompact,
					LPSTR	lpstrAddonFile
					) ;

	//
	//	Anybody who has stored a pointer as a result of a call to LookupFunction should call 
	//	ReadData() before using that pointer.
	//	This will synchronize all the things that may happen during Append's etc...
	//	(Basically this grabs a Reader/Writer Lock)
	//
	void	ReadData() ;

	//
	//	To be paired with ReadData() - releases locks.
	//
	void	FinishReadData() ;

	//
	//
	//
	void	ExclusiveData() ;

	void	UnlockExclusiveData() ;

} ; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\artsupp.cpp ===
#include <tigris.hxx>

//
// CPool is used to allocate memory while processing an article.
//

CPool   CArticle::gArticlePool(ARTICLE_SIGNATURE);

//
//  Largest possible CArticle derived object
//
#define MAX_ARTICLE_SIZE    max(    sizeof( CArticle ), \
                            max(    sizeof( CFromPeerArticle ), \
                            max(    sizeof( CFromClientArticle ),   \
                            max(    sizeof( CFromMasterArticle ),   \
                                    sizeof( CToClientArticle )  \
                             ) ) ) )

//
// An upperbound on the number of article objects that can
// exist at any time.
//
const   unsigned    cbMAX_ARTICLE_SIZE = MAX_ARTICLE_SIZE ;

void*	
CArticle::operator	new(	size_t	size )
{
	_ASSERT( size <= cbMAX_ARTICLE_SIZE ) ;
	return	gArticlePool.Alloc() ;
}

void
CArticle::operator	delete( void*	pv )
{
	gArticlePool.Free( pv ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\boot.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    This module contains the main function for the chkhash program.

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

#include "tigris.hxx"
#include "chkhash.h"
#include "nntpbld.h"

/*
BOOL
RenameHashFile(
    PHTABLE			ourTable,
	CBootOptions*	pOptions
    );

BOOL
VerifyTable(
    PHTABLE			ourTable,
	CBootOptions*	pOptions
    );
*/

/*

BOOL
DeletePatternFiles(
	CBootOptions*	pOptions,
	LPSTR			lpstrPath,
	LPSTR			lpstrPattern
	);

BOOL
DeleteServerFiles( 
				PNNTP_SERVER_INSTANCE pInstance,
				CBootOptions*		 pOptions,
				MB&					 mb
				);

BOOL
BuildCandidateFile(
			PNNTP_SERVER_INSTANCE 	pInstance,
			IIS_VROOT_TABLE*	 	pTable,	
			LPSTR				 	szFile,
			BOOL					fRejectEmpties,
			DWORD					ReuseIndexFiles,
			LPDWORD 				pdwTotalFiles,
			LPDWORD 				pdwCancelState,
			LPSTR   				szErrString
			);
*/

//
//	WorkCompletion() routine for rebuilding an instance 
//	Steps to rebuild:
//	-	Cleanup tables etc
//	-	Build tree from active file or vroot scan as the case maybe
//	-	Start() the instance
//	-	Rebuild hash tables using group iterator
//	-	Stop() the instance
//	-	signal instance rebuild done (also signal progress)
//

VOID
CRebuildThread::WorkCompletion( PVOID pvRebuildContext ) 
{
    TraceFunctEnter("CRebuildThread::WorkCompletion");

/*
	BOOL	fError = FALSE;
	BOOL	DoClean = FALSE;
	LPSTR	lpstrGroupFile = NULL ;
	DWORD	dwTotalFiles = 0;
	DWORD   cSecs = 0;
	char	szTempPath[MAX_PATH*2] ;
	char	szTempFile[MAX_PATH*2] ;
	char    szErrString[MAX_PATH];
	CBootOptions*	pOptions = NULL ;
	CNewsTree* pTree = NULL ;
	MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
*/

    //
    // Get the instance pointer
    //
    _ASSERT( pvRebuildContext );
	PNNTP_SERVER_INSTANCE pInstance = (PNNTP_SERVER_INSTANCE) pvRebuildContext ;
	_ASSERT( pInstance->QueryServerState() == MD_SERVER_STATE_STOPPED );
	_ASSERT( g_pInetSvc->QueryCurrentServiceState() == SERVICE_RUNNING );

	//
	// Now we call instance's rebuild method - rebuild
	//
	pInstance->Rebuild();

    //
    //  Set last rebuild error
    //

    /*
    if (!pInstance->m_dwLastRebuildError)
        pInstance->m_dwLastRebuildError = GetLastError();
    */
    
    //
    // Done, dereference the instance
    //
    pInstance->Dereference();
	
#if 0
	pOptions = pInstance->m_BootOptions ;
	pInstance->m_dwProgress = 0 ;
	pInstance->m_dwLastRebuildError = 0 ;
	DoClean = pOptions->DoClean ;
    lstrcpy( szErrString, "" );
    
	//
	//	Scan the virtual roots to build a candidate group list file if necessary
	//
	if( DoClean && !pOptions->IsActiveFile ) {

		if( pOptions->szGroupFile[0] == '\0' ) {

			if( GetTempPath( sizeof( szTempPath ), szTempPath ) == 0 ) {
				pOptions->ReportPrint( "Can't get temp path - error %d\n", GetLastError() ) ;
				goto exit;
			}

			if( GetTempFileName( szTempPath, "nntp", 0, szTempFile ) == 0 ) {
				pOptions->ReportPrint( "Can't create temp file - error %d\n", GetLastError() ) ;
				goto exit;
			}
			lstrcpy( pOptions->szGroupFile, szTempFile ) ;
		}

		lpstrGroupFile = pOptions->szGroupFile ;
		if( !BuildCandidateFile(	pInstance,
									pInstance->QueryVrootTable(),
									lpstrGroupFile, 
									pOptions->OmitNonleafDirs, 
									pOptions->ReuseIndexFiles,
									&dwTotalFiles,
									&(pOptions->m_dwCancelState),
									szErrString ) )	
		{
			// error building candidate file
			pOptions->ReportPrint("Failed to build candidates file: Error %d ErrorString %s\n", GetLastError(), szErrString);
			goto exit ;
		}

		DebugTrace(0,"Found %d files in first pass scan", dwTotalFiles );

	} else {
		lpstrGroupFile = pOptions->szGroupFile ;
	}

    //
    //  if standard rebuild, then handle it differently
    //
    
    if ( pOptions->ReuseIndexFiles == NNTPBLD_DEGREE_STANDARD )
    {
        //
        // Patially boot XOVER and ARTICLE hash table
        // Also construct most of the server structures
        //
        if (!pInstance->StartHashTables())
        {
            fError = TRUE;
            ErrorTrace(0,"Error booting hash tables");
            pInstance->StopHashTables();
            goto exit;
        }

        //
	    //	Do the rebuild
	    //

	    pTree = pInstance->GetTree() ;
	    _ASSERT( pTree );
	    _ASSERT( lpstrGroupFile );

        if( pTree->BuildTreeEx( lpstrGroupFile ) )	{

            pOptions->ReportPrint("Rebuilding group.lst file...\n");

            pOptions->m_hShutdownEvent = QueryShutdownEvent();
    	    pOptions->m_dwTotalFiles = dwTotalFiles;
            pOptions->m_cGroups = (DWORD) pTree->GetGroupCount();

            if ( RebuildGroupList( pInstance ) ) 
    	    {
                pOptions->ReportPrint("Done.\n");
            } else {
                fError = TRUE;
                pOptions->ReportPrint("Failed.\n");

            }
        } else {
		    fError = TRUE;
		    pOptions->ReportPrint( "NNTPBLD aborting due to error building news tree\n" ) ;

            //
            //  rebuild cancelled internally !
            //
        
		    pOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING ;
        }

	    //
	    //	If we aborted due to a cancel, simply log error,
        //  and delete the temparory file, if any.
	    //
        if (pOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING) {

    	    pInstance->m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL ;
            DeleteFile( (LPCTSTR) pInstance->QueryGroupListFile() );
            DebugTrace(0,"Instance %d: Rebuild cancelled", pInstance->QueryInstanceId());
		    fError = TRUE;
            
	    }

        //
        // Shutdown hash tables no matter what
        //

        pInstance->StopHashTables();

        if (!fError && !pInstance->m_dwLastRebuildError)
        {

	        //
            // Copy the group.lst.tmp into group.lst, delete group.lst.tmp if success.
            // On StartHashTables() we swapped the name, so the logic is reversed here!!!
            //
            if (!CopyFile( (LPCTSTR) pInstance->QueryGroupListFile(),
                           (LPCTSTR) pOptions->szGroupListTmp,
                           FALSE ))
            {
                //
                // CopyFile failed, log an error, but don't delete group.lst.tmp
                //
                DWORD err = GetLastError();
                DebugTrace(0, "Instance %d: CopyFile() on group.lst.tmp failed %d", pInstance->QueryInstanceId(), err);
                pOptions->ReportPrint("Failed to copy %s to %s\n", pInstance->QueryGroupListFile(), pOptions->szGroupListTmp );
                
                PCHAR   args[2];
                args[0] = pInstance->QueryGroupListFile();
                args[1] = pOptions->szGroupListTmp,

                NntpLogEventEx( NNTP_COPY_FILE_FAILED,
                                2,
                                (const CHAR**)args,
                                err,
                                pInstance->QueryInstanceId() );

                goto exit;
            }
            else
            {
                DeleteFile( (LPCTSTR) pInstance->QueryGroupListFile() );
            }

            //
	        //	Start the instance only when there is no errors during rebuild
	        //
	        pInstance->m_BootOptions->IsReady = TRUE ;
	        if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) )
	        {
		        DebugTrace(0,"Starting instance %d after rebuild", pInstance->QueryInstanceId());
		        if(	!mb.SetDword( "", MD_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_START) )
		        {
			        //
			        //	failed to set server state to started
			        //
			        _ASSERT( FALSE );
                    mb.Close();
                    goto exit;
		        }
		        mb.Close();
	        }
            else
                goto exit;

	        //
	        //	wait for instance to start (timeout default is 2 min - reg config)
	        //

	        while( pInstance->QueryServerState() != MD_SERVER_STATE_STARTED ) {
		        Sleep( 1000 );
		        if( (((cSecs++)*1000) > dwStartupLatency ) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) goto exit;
	        }
        }
        else
        {
            ErrorTrace(0,"Error during Standard rebuild %d",pInstance->m_dwLastRebuildError);
            goto exit;
        }
    }
    else
    {

        //
        //	if clean rebuild, then erase all files
        //

        if ( DoClean ) {
		    if( !DeleteServerFiles( pInstance, pOptions, mb ) ) {
			    //
			    // handle error
			    //
			    fError = TRUE ;
			    ErrorTrace(0,"Error deleting server files");
			    goto exit ;
		    }
	    }

	    //
	    //	Start the instance for the rebuild
	    //	It should start since, we have cleaned out stuff !
	    //
	    pInstance->m_BootOptions->IsReady = TRUE ;
	    if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) )
	    {
		    DebugTrace(0,"Starting instance %d before rebuild", pInstance->QueryInstanceId());
		    if(	!mb.SetDword( "", MD_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_START) )
		    {
			    //
			    //	failed to set server state to started
			    //
			    _ASSERT( FALSE );
		    }
		    mb.Close();
	    }

	    //
	    //	wait for instance to start (timeout default is 2 min - reg config)
	    //

	    while( pInstance->QueryServerState() != MD_SERVER_STATE_STARTED ) {
		    Sleep( 1000 );
		    if( (((cSecs++)*1000) > dwStartupLatency ) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) goto exit;
	    }

	    //
	    //	now we have a clean server up, we will start the rebuild
	    //

	    _ASSERT( pInstance->QueryServerState() == MD_SERVER_STATE_STARTED );
	    pTree = pInstance->GetTree() ;
	    _ASSERT( pTree );
	    _ASSERT( lpstrGroupFile );

	    //
	    //	Rebuild the newstree
	    //

	    if( pTree->BuildTree( lpstrGroupFile ) )	{

    	    //
	        //	Do the rebuild
	        //

            pOptions->ReportPrint("Rebuilding Article and XOver map table...\n");

	        pOptions->m_hShutdownEvent = QueryShutdownEvent();
    	    pOptions->m_dwTotalFiles = dwTotalFiles;

            if ( RebuildArtMapAndXover( pInstance ) ) 
    	    {
                pOptions->ReportPrint("Done.\n");
            } else {
	    	    fError = TRUE;
                pOptions->ReportPrint("Failed.\n");
            }
	
	    } else {
		    fError = TRUE;
		    pOptions->ReportPrint( "NNTPBLD aborting due to error building news tree\n" ) ;

            //
            //  rebuild cancelled internally !
            //
        
		    pOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL_PENDING ;
        }

	    //
	    //	If we aborted due to a cancel, delete all server files
	    //
        if ( (pOptions->m_dwCancelState == NNTPBLD_CMD_CANCEL_PENDING) /*&& DoClean*/ ) {

    	    //
    	    //	stop this instance
    	    //
    	
		    pInstance->m_BootOptions->m_dwCancelState = NNTPBLD_CMD_CANCEL ;
		    if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) )
		    {
			    DebugTrace(0,"Stopping instance %d: Rebuild cancelled", pInstance->QueryInstanceId());
			    if(	!mb.SetDword( "", MD_SERVER_COMMAND, IIS_MD_UT_SERVER, MD_SERVER_COMMAND_STOP) )
			    {
				    //
				    //	failed to set server state to stopped
				    //
				    _ASSERT( FALSE );
			    }
			    mb.Close();

    	        //
	            //	wait for instance to stop (timeout default is 2 min - reg config)
	            //

                cSecs = 0;
			    while( pInstance->QueryServerState() != MD_SERVER_STATE_STOPPED ) {
				    Sleep( 1000 );
				    if( (((cSecs++)*1000) > dwStartupLatency) || (g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) ) goto exit;
			    }

                if ( DoClean ) {
                    _ASSERT( pInstance->QueryServerState() == MD_SERVER_STATE_STOPPED );
			        if( !DeleteServerFiles( pInstance, pOptions, mb ) ) {
				        //
    				    // handle error
	    			    //
		    		    fError = TRUE ;
			    	    ErrorTrace(0,"Error deleting server files");
				        goto exit ;
			        }
			    }
			    pOptions->ReportPrint("Deleted server files\n");
		    }
		    goto exit ;
	    }

	}
    
    //
	//	rebuild done - re-enable posting
	//
	
	_ASSERT( pInstance->QueryServerState() == MD_SERVER_STATE_STARTED );
	if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) ) {
    	pInstance->SetPostingModes( mb, TRUE, TRUE, TRUE );
    	mb.Close();
   	}

exit:

    //
    //  Set last rebuild error
    //

    if (!pInstance->m_dwLastRebuildError)
        pInstance->m_dwLastRebuildError = GetLastError();
    
	//
	//	Use rebuild RPC crit sect to protect m_BootOptions
	//
	EnterCriticalSection( &pInstance->m_critRebuildRpc ) ;

	// NOTE: this is created on a rebuild RPC !
	if( pInstance->m_BootOptions ) {
		if( pInstance->m_BootOptions->m_hOutputFile ) {
			_VERIFY( CloseHandle( pInstance->m_BootOptions->m_hOutputFile ) );
		}
		XDELETE pInstance->m_BootOptions;
		pInstance->m_BootOptions = NULL;
	}

	LeaveCriticalSection( &pInstance->m_critRebuildRpc ) ;

	//
	//  The rebuild thread is done with this instance - deref it
	//  (This ref count was bumped up in the rebuild RPC)
	//
	pInstance->Dereference();
	
    return ;
#endif
}

#if 0
BOOL
VerifyTable(
    PHTABLE			ourTable,
	CBootOptions*	pOptions
    )
{
    pOptions->ReportPrint("\nProcessing %s table(%s)\n",
        ourTable->Description, ourTable->FileName);

#if 0 
    checklink( ourTable, pOptions );
    diagnose( ourTable, pOptions );
#endif
    return(TRUE);

} // VerifyTable

BOOL
RenameHashFile(
    PHTABLE			HTable,
	CBootOptions*	pOptions
    )
{
	char	szNewFileName[MAX_PATH*2] ;

	lstrcpy( szNewFileName, HTable->FileName ) ;
	char*	pchEnd = szNewFileName + lstrlen( szNewFileName ) ;
	while( *pchEnd != '.' && *pchEnd != '\\' ) 
		pchEnd -- ;

	if( *pchEnd == '.' ) {
		lstrcpy( pchEnd+1, "bad" ) ;
	}	else	{
		lstrcat( pchEnd, ".bad" ) ;
	}

    if (!MoveFileEx(
            HTable->FileName,
            szNewFileName,
            MOVEFILE_REPLACE_EXISTING
            ) ) {

        if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
            pOptions->ReportPrint("Error %d in rename\n",GetLastError());
            return(FALSE);
        }

    } else {
        pOptions->ReportPrint("Renaming from %s to %s\n",HTable->FileName, HTable->NewFileName);
    }

    return(TRUE);

} // RenameHashFile
#endif

#if 0
BOOL
BuildCandidateFile(
			PNNTP_SERVER_INSTANCE 	pInstance,
			IIS_VROOT_TABLE*	 	pTable,	
			LPSTR				 	szFile,
			BOOL					fRejectEmpties,
			DWORD					ReuseIndexFiles,
			LPDWORD 				pdwTotalFiles,
			LPDWORD 				pdwCancelState,
			LPSTR   				szErrString
			) {
/*++

Routine Description : 

	This function scans the registry and builds a list of virtual roots which
	we will then recursively scan for candidate directories which we may want to 
	be newsgroups.

	This function calls the instance method - TsEnumVirtualRoots - which
	does the vroot recursive scan from the metabase.

	NOTE: The TsEnum code is stolen from infocomm - would be nice if base IIS
	class exposed this.

Arguments : 

	szFile -	Name of the file in which we will save candidates
	fRejectEmpties - If TRUE don't put empty interior directories into the list
		of candidates (empty leaf directories still placed in candidate file)

Return Value : 

	TRUE if successfull
	FALSE	otherwise.

--*/

	BOOL	fRet = TRUE;
	char	szCurDir[MAX_PATH*2] ;
	NNTPBLD_PARAMS NntpbldParams ;

	TraceFunctEnter("BuildCandidateFile");
	
	GetCurrentDirectory( sizeof( szCurDir ), szCurDir ) ;

	HANDLE	hOutputFile = 
		CreateFile( szFile, 
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ, 	
					NULL, 
					CREATE_ALWAYS, 
					FILE_FLAG_SEQUENTIAL_SCAN,
					NULL 
				) ;

	if( hOutputFile == INVALID_HANDLE_VALUE )	{
        ErrorTrace( 0, "Unable to create File %s due to Error %d.\n", szFile, GetLastError() ) ;
		return	FALSE ; 
	}

	//
	//	Build the nntpbld params blob
	//	This is made available to ScanRoot() by TsEnumVirtualRoots()
	//
	
	NntpbldParams.pTable = pTable;
	NntpbldParams.szFile = szFile;
	NntpbldParams.hOutputFile = hOutputFile;
	NntpbldParams.fRejectEmpties = fRejectEmpties;
	NntpbldParams.ReuseIndexFiles = ReuseIndexFiles;
	NntpbldParams.pdwTotalFiles = pdwTotalFiles;
	NntpbldParams.pdwCancelState = pdwCancelState;
	NntpbldParams.szErrString = szErrString;
	
	fRet = pInstance->TsEnumVirtualRoots( ScanRoot, (LPVOID)&NntpbldParams	);
	
	_VERIFY( CloseHandle( hOutputFile ) );
	SetCurrentDirectory( szCurDir ) ;

	TraceFunctLeave();
	return	fRet ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\seo\utest\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL);

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\cio.cpp ===
/*++

Module Name :

	cio.cpp

Abstract :

	
	This module contains all of the non-inline code for all CIO
	derived classes.  Each CIO derived class represents an abstract
	IO operation such as - read a line of text and parse it,
	read an article, write an article etc...
	All of those classes derived from CIOPassThru are used in conjunction
	with CIODriverSource objects to handle encryption issues.

Author :

	Neil Kaethler

Revision History :


--*/


#include	"tigris.hxx"

#ifdef	CIO_DEBUG
#include	<stdlib.h>		// For Rand() function
#endif

CPool	CCIOAllocator::IOPool(CIO_SIGNATURE) ;
CCIOAllocator	gCIOAllocator ;
CCIOAllocator*	CCIOCache::gpCIOAllocator = &gCIOAllocator ;

DWORD	CIO::cbSmallRequest = 400 ;
DWORD	CIO::cbMediumRequest = 4000 ;
DWORD	CIO::cbLargeRequest = 32000 ;


const	unsigned	cbMAX_IO_SIZE = MAX_IO_SIZE ;

CCIOAllocator::CCIOAllocator()	{
}

#ifdef	DEBUG
void
CCIOAllocator::Erase(
					void*	lpv
					)	{

	FillMemory( (BYTE*)lpv, cbMAX_IO_SIZE, 0xCC ) ;

}

BOOL
CCIOAllocator::EraseCheck(
					void*	lpv
					)	{

	DWORD	cb = cbMAX_IO_SIZE ;
	
	for( DWORD	j=sizeof(CPool*); j < cb; j++ ) {
		if(	((BYTE*)lpv)[j] != 0xCC )
			return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CCIOAllocator::RangeCheck(
					void*	lpv
					)	{

	return	TRUE ;

}

BOOL	
CCIOAllocator::SizeCheck(	DWORD	cb )	{

	return	cb <= cbMAX_IO_SIZE ;

}
#endif

BOOL
CIO::InitClass(	)		{
/*++

Routine Description :

	Initialize the CPool object used to allocate CIO objects.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	cbSmallRequest = CBufferAllocator::rgPoolSizes[0] - 50 ;
	cbMediumRequest = CBufferAllocator::rgPoolSizes[1] - 50 ;
	cbLargeRequest = CBufferAllocator::rgPoolSizes[2] - 50 ;

	return	CCIOAllocator::InitClass() ;
}

BOOL
CIO::TermClass()	{
/*++

Routine Description :

	Release all memory associated with the CPool object used
	to allocate CIO OBJECTs.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	return	CCIOAllocator::TermClass() ;
}

CIO::~CIO()	{
/*++

Routine Description :

	Class Destructor
	
Arguments :

	None.

Return Value :

	None.

--*/


	TraceFunctEnter( "CIO::~CIO" ) ;
	DebugTrace( (DWORD_PTR)this, "Destroy CIO" ) ;


	//
	//	Make sure there are no references left when we are destroyed.
	//	CIO objects are manipulated through a combination of smart pointers
	//	and regular pointers, so we need to be carefull that there are no bugs
	//	where the object is destroyed through a regular pointer while a smart pointer
	//	has a reference.
	//

	_ASSERT( m_refs == -1 ) ;

}

int
CIO::Complete(	CSessionSocket*	pSocket,
				CReadPacket*	pRead,	
				CIO*	&pio	)		{
/*++

Routine Description :

	For derived classes this function will do whatever processing
	is required when a Read Completes.  The CReadPacket will contain
	pointers to the data which was read.   If a CReadPacket is issued
	by a CIO object this function must be overridden.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	This function must be overridden by derived classes if they issue CReadPacket's
	//
	DebugBreak() ;
	return	0 ;
}


int
CIO::Complete(	CSessionSocket*	pSocket,
				CWritePacket*	pRead,	
				CIO*	&pio	)		{
/*++

Routine Description :

	For derived classes this function will do whatever processing
	is required when a Write Completes.  The CWritePacket will contain
	pointers to the data which was written.   If a CWritePacket is issued
	by a CIO object this function must be overridden.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet in which the written data resided.
			  This data may no longer be usable.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	//
	//	This function must be overridden by derived classes if they issue CWritePackets
	//
	DebugBreak() ;
	return	0 ;
}


void
CIO::Complete(	CSessionSocket*	pSocket,	
				CTransmitPacket*	pTransmit,	
				CIO*	&pio )	{
/*++

Routine Description :

	For derived classes this function will do whatever processing
	is required when a TransmitFile Completes.  The CTransmitPacket will contain
	the file handle etc. of whatever file was transmitted..

Arguments :
	
	pSocket - The socket against which the IO was issued
	pTransmit-The packet which describes the TransmitFile operation
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	None.

--*/


	//	
	//	This function must be overridden by derived classes if they issue CTransmitPackets
	//	(NOTE : can't partially complete a CTransmitPacket, that's why the return type is
	//	void).
	//
	DebugBreak() ;
}



void
CIO::Complete(	CSessionSocket*	pSocket,	
				CExecutePacket*	pExecute,	
				CIO*	&pio )	{
/*++

Routine Description :

	For derived classes which have deferred execution of something !

Arguments :
	
	pSocket - The socket against which the IO was issued
	pExecute- The packet which describes the Deferred operation
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	None.

--*/


	//	
	//	This function must be overridden by derived classes if they issue CExecutePackets
	//	(NOTE : can't partially complete a CExecutePackets, that's why the return type is
	//	void).
	//
	DebugBreak() ;
}





void
CIO::Shutdown(	CSessionSocket*	pSocket,	
				CIODriver&	pdriver,	
				SHUTDOWN_CAUSE	cause,
				DWORD	dwErrorCode	 ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	This will give derived classes a chance to close or destroy
	any objects they may be using.

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	DebugBreak() ;
}		

void
CIO::DoShutdown(	CSessionSocket*	pSocket,	
					CIODriver&		driver,	
					SHUTDOWN_CAUSE	cause,
					DWORD	dwErrorCode	 ) {
/*++

Routine Description :

	This function is called by CIODriver's to signal termination of a session.
	We will call the derived classes Shutdown() function after we have given
	the current state a chance to process the Shutdown as well.

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	//	Now call the controlling state's shutdown method !
	if( m_pState != 0 ) {
		m_pState->Shutdown( driver, pSocket, cause, dwErrorCode ) ;
	}

	Shutdown( pSocket, driver, cause, dwErrorCode ) ;
}		


BOOL
CIOShutdown::Start( CIODriver& driver,
					CSessionSocket*	pSocket,
					unsigned cAhead ) {
/*++

Routine Description :

	This function is called to start a CIO object.
	The CIO object should create and Issue whatever packets
	it needs to accomplish its function.
	In the case of CIOShutdown, we exist solely to ease CIODriver
	termination, and do not issue any Packets.

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.


return Value :

	TRUE if successfull, FALSE otherwise

--*/

	//
	//	Shutdown State - so do nothing but keep things apparently moving !
	//
	TraceFunctEnter( "CIOShutdown::Start" ) ;
	DebugTrace( (DWORD_PTR)this, "Start shutdown on driver %x pSocket %x", &driver, pSocket ) ;
	return	TRUE ;
}


BOOL	
CIOShutdown::InitRequest(
			class	CIODriverSource&	driver,	
			CSessionSocket*	pSocket,	
			CReadPacket*	pPacket,	
			BOOL&	fAcceptRequests
			)	{
/*++

Routine Description :

	Somebody is still trying to issue IO's even though
	we are closing things down.  Fail the request and
	keep things moving.

Arguments :

	driver - driver controlling IO completions
	pSocket - Socket IO is associated with
	pPacket - the request packet
	fAcceptRequests - OUT parameter indicating whether
		we will Init more requests - return TRUE here

Return Value :

	Always FALSE, the IO Request was failed.

--*/

	fAcceptRequests = TRUE ;
	return	FALSE ;

}

BOOL	
CIOShutdown::InitRequest(
			class	CIODriverSource&	driver,	
			CSessionSocket*	pSocket,	
			CWritePacket*	pWritePacket,	
			BOOL&	fAcceptRequests
			)	{
/*++

Routine Description :

	Somebody is still trying to issue IO's even though
	we are closing things down.  Fail the request and
	keep things moving.

Arguments :

	driver - driver controlling IO completions
	pSocket - Socket IO is associated with
	pPacket - the request packet
	fAcceptRequests - OUT parameter indicating whether
		we will Init more requests - return TRUE here

Return Value :

	Always FALSE, the IO Request was failed.

--*/

	fAcceptRequests = TRUE ;
	return	FALSE ;

}


BOOL	
CIOShutdown::InitRequest(
			class	CIODriverSource&	driver,	
			CSessionSocket*	pSocket,	
			CTransmitPacket*	pTransmitPacket,	
			BOOL&	fAcceptRequests	
			)	{
/*++

Routine Description :

	Somebody is still trying to issue IO's even though
	we are closing things down.  Fail the request and
	keep things moving.

Arguments :

	driver - driver controlling IO completions
	pSocket - Socket IO is associated with
	pPacket - the request packet
	fAcceptRequests - OUT parameter indicating whether
		we will Init more requests - return TRUE here

Return Value :

	Always FALSE, the IO Request was failed.

--*/

	fAcceptRequests = TRUE ;
	return	FALSE ;
}




int		
CIOShutdown::Complete(	IN CSessionSocket* pSocket,
						IN	CReadPacket*	pPacket,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest ) {
/*++

Routine Description :

	Swallow the packets !! We only help to make sure all packets are
	consumed during CIODriver termination.
	This function is for use with CIODriverSource objects.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The packet containing the completed packet.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.
	pRequest -The request packet which start us off.
	fCompleteRequest - an Out parameter - set to TRUE to indicate
			  the request should be completed !

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	Consume the packet !
	//
	
	fCompleteRequest = TRUE ;
	//
	//	Zero bytes transferred - the operation failed !!
	//
	pRequest->m_cbBytes = 0 ;

	TraceFunctEnter( "CIOShutdown::Complete - CReadPacket" ) ;
	DebugTrace( (DWORD_PTR)this, "read complete shutdown on pSocket %x pPacket %x driver %x", pSocket, pPacket, &(*pPacket->m_pOwner) ) ;
	return	pPacket->m_cbBytes ;
}

int		
CIOShutdown::Complete(	IN CSessionSocket* pSocket,
						IN	CReadPacket*	pPacket,	
						OUT	CIO*	&pio ) {
/*++

Routine Description :

	Swallow the packet - consume all the bytes

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The completed packet
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	Consume the packet
	//
	TraceFunctEnter( "CIOShutdown::Complete - CreadPacket" ) ;
	DebugTrace( (DWORD_PTR)this, "read complete on pSock %x pPacket %x m_pOwner %x", pSocket, pPacket, &(*pPacket->m_pOwner) ) ;
	return	pPacket->m_cbBytes ;
}

int		
CIOShutdown::Complete(	IN CSessionSocket*	pSocket,
						IN	CWritePacket*	pPacket,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest )	{
/*++

Routine Description :

	Swallow the packets !! We only help to make sure all packets are
	consumed during CIODriver termination.
	This function is for use with CIODriverSource objects.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The packet containing the completed packet.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.
	pRequest -The request packet which start us off.
	fCompleteRequest - an Out parameter - set to TRUE to indicate
			  the request should be completed !

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	Consume the packet always !
	//	
	pRequest->m_cbBytes = 0 ;
	fCompleteRequest = TRUE ;

	TraceFunctEnter( "CIOShutdown::Complete - CWritePacket" ) ;
	DebugTrace( (DWORD_PTR)this, "Write Complete on pSock %x pPacket %x m_pOwner %x", pSocket, pPacket, &(*pPacket->m_pOwner) ) ;
	return	pPacket->m_cbBytes ;
}

int		
CIOShutdown::Complete(	IN CSessionSocket*	pSocket,
						IN	CWritePacket*	pPacket,	
						OUT	CIO*	&pio )	{
/*++

Routine Description :

	Swallow the packet - consume all the bytes

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The completed packet
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	//
	//	Consume the packet always !
	//
	TraceFunctEnter( "CIOShutdown::Complete - CWritePacket" ) ;
	DebugTrace( (DWORD_PTR)this, "Write Complete on pSock %x pPacket %x m_pOwner %x", pSocket, pPacket, &(*pPacket->m_pOwner) ) ;
	return	pPacket->m_cbBytes ;
}

void	CIOShutdown::Complete(	IN CSessionSocket*,
								IN	CTransmitPacket*	pPacket,	
								CPacket*	pRequest,	
								BOOL&	fCompleteRequest ) {
/*++

Routine Description :

	Swallow the packets !! We only help to make sure all packets are
	consumed during CIODriver termination.
	This function is for use with CIODriverSource objects.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The packet containing the completed packet.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.
	pRequest -The request packet which start us off.
	fCompleteRequest - an Out parameter - set to TRUE to indicate
			  the request should be completed !

return Value :

	None. (always assumed to be consumed by caller !)

--*/

	//
	//	Consume the packet - pretty easy to do !
	//
	fCompleteRequest = TRUE ;
	pRequest->m_cbBytes = 0 ;


}

void	CIOShutdown::Complete(	IN CSessionSocket*,
								IN	CTransmitPacket*	pPacket,	
								OUT	CIO*	&pio ) {
/*++

Routine Description :

	Swallow the packet - consume all the bytes

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The completed packet
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	None. (always assumed to be consumed by caller !)

--*/

	//
	//	Consume the packet !
	//
}

void	CIOShutdown::Complete(	IN CSessionSocket*,
								IN	CExecutePacket*	pPacket,	
								OUT	CIO*	&pio ) {
/*++

Routine Description :

	Swallow the packet - consume all the bytes

Arguments :
	
	pSocket - The socket against which the IO was issued
	pPacket-  The completed packet
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	None. (always assumed to be consumed by caller !)

--*/

	//
	//	Consume the packet !
	//
	_ASSERT( pPacket != 0 ) ;
	if( pPacket->m_pWrite != 0 ) 	{
		pPacket->m_pOwner->DestroyPacket( pPacket->m_pWrite ) ;
		pPacket->m_pWrite = 0 ;
	}
	pPacket->m_pOwner->DestroyPacket( pPacket ) ;
}



//
//	Maximum number of pending reads while reading an article
//
unsigned	CIOGetArticle::maxReadAhead = 3 ;
//
//	Number of bytes to accumulate before writing to a file !
//
unsigned	CIOGetArticle::cbTooSmallWrite = 4000 ;
//
//	The pattern which marks the end of an article
//
char		CIOGetArticle::szTailState[] = "\r\n.\r\n" ;
//
//	The pattern which marks the end of the head of an article
//	
char		CIOGetArticle::szHeadState[] = "\r\n\r\n" ;

CIOGetArticle::CIOGetArticle(
						CSessionState*	pstate,
						CSessionSocket*	pSocket,	
						CDRIVERPTR&	pDriver,
						LPSTR			lpstrTempDir,
						char			(&szTempName)[MAX_PATH],
						DWORD			cbLimit,
						BOOL			fSaveHead,
						BOOL			fPartial )	:
/*++

Routine Description :

	Class Constructor

Arguments :
	
	pstate - The State which is issuing us and who's completion function
			we should later call
	pSocket -	The socket on which we will be issued
	pDriver -	The CIODriver object handling all of the socket's IO
	pFileChannel -	The File Channel into which we should save all data
	fSaveHead - TRUE if we want the HEAD of the article placed in a buffer !
	fPartial	- If TRUE then we should assume that a CRLF has already
				been sent and '.\r\n' alone can terminate the article.

Return Value :
	
	None

--*/

	//
	//	Get a CIOGetArticle object half way set up - user still needs
	//	to call Init() but we will do much here !
	//
	CIORead( pstate ),
	m_lpstrTempDir( lpstrTempDir ),
	m_szTempName( szTempName ),
	m_pFileChannel( 0 ),	
	m_pFileDriver( 0 ),
	m_pSocketSink( pDriver ),
	m_fDriverInit( FALSE ),
	m_cwrites( 0 ),
	m_cwritesCompleted( 0 ),
	m_cFlowControlled( LONG_MIN ),
	m_fFlowControlled( FALSE ),
	m_cReads( 0 ),
	m_pWrite( 0 ),
	m_cbLimit( cbLimit ),
	m_pchHeadState( 0 ),
	m_ibStartHead( 0 ),
	m_ibStartHeadData( 0 ),
	m_ibEndHead( 0 ),
	m_ibEndHeadData( 0 ),
	m_ibEndArticle( 0 ),
	m_cbHeadBytes( 0 ),
	m_cbGap( 0 )
#ifdef	CIO_DEBUG
	,m_fSuccessfullInit( FALSE ),
	m_fTerminated( FALSE )
#endif
{

	_ASSERT( m_lpstrTempDir != 0 ) ;
	m_szTempName[0] = '\0' ;

	ASSIGNI(m_HardLimit, 0);

	if( fPartial )
		m_pchTailState = &szTailState[2] ;
	else	
		m_pchTailState = &szTailState[0] ;


	if( fSaveHead ) {
		m_fAcceptNonHeaderBytes = TRUE ;
		m_pchHeadState = &szHeadState[0] ;
	}

	TraceFunctEnter( "CIOGetArticle::CIOGetArticle" ) ;

	_ASSERT( m_pFileDriver == 0 ) ;
	_ASSERT( pstate != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pDriver != 0 ) ;

}

CIOGetArticle::~CIOGetArticle( )	{
/*++

Routine Description :

	Class Destructor

Arguments :
	
	None

Return Value :
	
	None

--*/

	//
	//	Destroy a CIOGetArticle - always close our m_pFileDriver if possible
	//	in case we are terminated due to some socket error.
	//
	TraceFunctEnter( "CIOGetArticle::~CIOGetArticle" ) ;

#ifdef	CIO_DEBUG
	//
	//	Our destructor should only be called if we weren't successfully init
	//	or after Term() has been called.
	//
	_ASSERT( !m_fSuccessfullInit || m_fTerminated ) ;
#endif

	DebugTrace( (DWORD_PTR)this, "m_pFileDriver %x m_fDriverInit %x", m_pFileDriver, m_fDriverInit ) ;

	if( m_pFileDriver != 0 ) {
		if( m_fDriverInit )		{
			m_pFileDriver->UnsafeClose( (CSessionSocket*)this, CAUSE_NORMAL_CIO_TERMINATION, 0, FALSE ) ;
		}
	}
	if( m_pWrite != 0 ) {
		CPacket::DestroyAndDelete( m_pWrite ) ;
		m_pWrite = 0 ;
	}
}

void
CIOGetArticle::Term(	CSessionSocket*	pSocket,
						BOOL			fAbort,
						BOOL			fStarted	)	{
/*++

Routine Description :

	Start destroying a successfully initialize CIOGetArticle object

Arguments :
	
	fAbort - If TRUE then destroy the socket which we were using
			If FALSE then only close down our File Channel's

Return Value :

	None

--*/
#ifdef	CIO_DEBUG
	m_fTerminated = TRUE ;
#endif
	//
	//	Start us on our way to destruction !!
	//	If we have been successfully Initialized, then this will
	//	lead to our destruction when our m_pFileDriver eventually shutsdown.
	//	(Since we were succesfully Init() our m_pFileDriver has a reference to us,
	//	so we must allow it to shutdown and destroy us to avoid problems with
	//	circular references and multiple frees !)
	//

	if( m_pFileDriver != 0 ) {
		m_pFileDriver->UnsafeClose( pSocket,
				fAbort ? CAUSE_USERTERM : CAUSE_NORMAL_CIO_TERMINATION, 0, fAbort ) ;
	}
}


void
CIOGetArticle::Shutdown(	CSessionSocket*	pSocket,	
							CIODriver&		driver,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dwOptional )	{
/*++

Routine Description :

	Do whatever work is necessary when one of the two CIODriver's we are
	using is terminated.

Arguments :

	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	TraceFunctEnter( "CIOGetArticle::Shutdown" ) ;
	DebugTrace( (DWORD_PTR)this, "SHutdown args - pSocket %x driver %x cause %x dw %x",
			pSocket, &driver, cause, dwOptional ) ;

	//
	//	This function is called when the CIODriver's we are refenced by our closing down.
	//	Since we are referenced by two of them (one for the socket and one for the file)
	//	we only want to be deleted by the CIODriver for the file.
	//
	if( &driver == m_pFileDriver )	{
		// Out file is closing - what can we do about it !
		//_ASSERT( 1==0 ) ;
#ifdef	CIO_DEBUG
		m_fTerminated = TRUE ;
#endif

		//
		//	We set this to 0 here as we know we will be called here by
		//	the same thread that is completing writes to the file - so
		//	since that's the only thread referencing this member variable -
		//	there are no thread safety issues accessing that member.
		//

		m_pSocketSink = 0 ;

		if ( m_fFlowControlled )
		{
			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );
		}

	}	else	{
		// Close down the rest of our stuff as well !!
		Term( pSocket, cause != CAUSE_NORMAL_CIO_TERMINATION ) ;
	}
}

void
CIOGetArticle::ShutdownFunc(	void *pv,	
								SHUTDOWN_CAUSE	cause,	
								DWORD dw ) {
/*++

Routine Description :

	Notification function which is called when a CIODriver used by
	a CIOGetArticle if finally destroyed.  This function is provided
	to the CIODriver we use for File IO's during out Init().

Arguments :

	pv	-	Pointer to dead CIOGetArticle - this has been destroyed dont use !
	cause -	The reason for termination
	dw		Optional extra information regarding termination

Return Value :

	None

--*/

	TraceFunctEnter( "CIOGetArticle::ShutdownFunc" ) ;
	//
	//	This function gets notified when a CIOFileDriver used by CIOGetArticle
	//	is terminated.  Not much for us to worry about.
	//	(CIODriver's require these functions)
	//

	//_ASSERT( 1==0 ) ;
	return ;
}

BOOL
CIOGetArticle::Start(	CIODriver&	driver,	
						CSessionSocket	*pSocket,	
						unsigned cReadAhead )	{
/*++

Routine Description :

	This function is called to start transferring data from the socket
	into the file.

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/


	_ASSERT( pSocket != 0 ) ;

	m_cReads = -((long)maxReadAhead) + cReadAhead ;

	while( cReadAhead < maxReadAhead )	{
		//
		//	Start reading data from the socket
		//
		CReadPacket*	pRead = driver.CreateDefaultRead( cbMediumRequest ) ;
		if( 0!=pRead )	{
			BOOL	eof ;
			pRead->m_dwExtra1 = 0 ;
			driver.IssuePacket( pRead, pSocket, eof ) ;
			cReadAhead++ ;
			InterlockedIncrement( &m_cReads ) ;
		}	else	{
			//
			// This is a fatal problem only if we couldn't issue ANY reads at all !
			//
			if( cReadAhead == 0 )
				return FALSE  ;
		}
	}	
	return	TRUE ;
}

const	unsigned	MAX_OUTSTANDING_FILE_WRITES	= 8 ;	
const	unsigned	RESTORE_FLOW = 2 ;

void
CIOGetArticle::DoFlowControl( PNNTP_SERVER_INSTANCE pInstance )	{
/*++

Routine Description :

	Check whether it is necessary to set flow control due to
	too many outstanding writes.
	If necessary, then the first time we do put ourselves into Flow Control,
	try to flush our pending writes.
	We should be called only immediately before issuing an Async Write to the file
	to ensure that a CWritePacket completion will actually execute the necessary
	code to restart a flow controlled session.
	(Otherwisse, we could potentially decide to Flow control the session
	and before setting m_fFlowControlled to TRUE all the pending writes complete
	and then we'd be left in a boat where there are no pending reads or
	writes and no way to get out of the flow control state.)

Arguments :

	None.

Return Value :

	None.


--*/

	//
	//	Important - do all tests of m_fFlowControlled before setting
	//	m_cFlowControlled - as other thread will touch m_cFlowControlled
	//	before touching m_fFlowControlled !!
	//	(Will only touch m_fFlowControlled if m_fFlowControlled is TRUE ) !
	//	Thus we know that if m_fFlowControlled is FALSE there is nobody
	//	messing with m_cFlowControlled,
	//
	//

	if( m_cwrites - m_cwritesCompleted > MAX_OUTSTANDING_FILE_WRITES ) {
		
		if( m_fFlowControlled ) {
			// All ready have flow control turned on
			;
		}	else	{
			m_cFlowControlled = -1 ;
			m_fFlowControlled = TRUE ;
			m_pFileChannel->FlushFileBuffers() ;

			IncrementStat( pInstance, SessionsFlowControlled );
		}
	}	else	{
		if( !m_fFlowControlled ) {
			m_cFlowControlled = LONG_MIN ;	// Keep resetting !
		}
	}
}

inline	DWORD
CIOGetArticle::HeaderSpaceAvailable()	{
/*++

Routine Description :

	Compute the amount of space available in the buffer we are using
	to hold the article header !

Arguments :

	None.

Return Value :

	number of bytes available, 0 if we aren't collecting article headers !

--*/

	if( m_pArticleHead != 0 ) {

		return	m_ibEndHead - m_ibEndHeadData ;

	}
	return	0 ;
}

inline	void
CIOGetArticle::FillHeaderSpace(
						char*	pchStart,
						DWORD	cbBytes
						) {
/*++

Routine Description :

	Copy bytes into the header storage area !!
	Caller should ensure that this will fit !!
	
Arguments :

	pchStart - Start of bytes to be copied !
	cbBytes -	Number of bytes to copy !

Return Value :

	None.

--*/

	_ASSERT( m_pArticleHead != 0 ) ;
	_ASSERT( cbBytes + m_ibEndHeadData < m_ibEndHead ) ;

	CopyMemory( m_pArticleHead->m_rgBuff + m_ibEndHeadData,
				pchStart,
				cbBytes
				) ;

	m_ibEndHeadData += cbBytes ;
}

inline	void
CIOGetArticle::InitializeHeaderSpace(
						CReadPacket*	pRead,
						DWORD			cbArticleBytes
						) {
/*++

Routine Description  :

	Given a read packet which contains our first completed read,
	set up all our buffer start for holding header information !
	
Arguments :

	CReadPackets*	pRead - the completed read !
	cbArticleBytes - Number of bytes in the completed read making up the article !

Return Value :

	None.
	
--*/


	_ASSERT( m_pArticleHead == 0 ) ;
	_ASSERT( m_ibStartHead == 0 ) ;
	_ASSERT( m_ibEndHead == 0 ) ;
	_ASSERT( m_ibStartHeadData == 0 ) ;
	_ASSERT( m_ibEndHeadData == 0 ) ;
	_ASSERT( m_cbHeadBytes == 0 ) ;
	_ASSERT( cbArticleBytes <= (pRead->m_ibEndData - pRead->m_ibStartData)) ;

	m_pArticleHead = pRead->m_pbuffer ;

	m_ibStartHead = pRead->m_ibStart ;
	m_ibStartHeadData = pRead->m_ibStartData ;
	m_ibEndHeadData = pRead->m_ibStartData + cbArticleBytes ;

	if( m_ibEndHeadData < pRead->m_ibEndData )
		m_ibEndHead = m_ibEndHeadData ;
	else
		m_ibEndHead = pRead->m_ibEnd ;

}

inline	BOOL
CIOGetArticle::GetBiggerHeaderBuffer(
							CIODriver&	driver,
							DWORD		cbRequired
							) {
/*++

Routine Description :

	We have too much data to fit into the buffer we are using to hold
	header information.  So try to get a bigger buffer and move
	our old data into that buffer !

Arguments :

	driver - A CIODriverSink we can use to allocate buffers !

Return Value :

	TRUE if successfull,
	FALSE otherwise.
	If we fail we leave member variables untouched.

--*/

	_ASSERT( m_pArticleHead != 0 ) ;

	CBuffer*	pTemp = 0 ;

	DWORD	cbRequest = cbMediumRequest ;

	if( (m_pArticleHead->m_cbTotal + cbRequired)  > cbMediumRequest )	{
		cbRequest = cbLargeRequest ;
	}

	if( cbRequest < (cbRequired + (m_ibEndHeadData - m_ibStartHeadData)) ) {
		return	FALSE ;
	}

	pTemp = driver.AllocateBuffer( cbRequest ) ;

	if( pTemp != 0 ) {

		DWORD	cbToCopy = m_ibEndHeadData - m_ibStartHeadData ;
		CopyMemory( pTemp->m_rgBuff,
					&m_pArticleHead->m_rgBuff[ m_ibStartHeadData ],
					cbToCopy
					) ;

		m_ibStartHead = 0 ;
		m_ibStartHeadData = 0 ;
		m_ibEndHead = pTemp->m_cbTotal ;
		m_ibEndHeadData = cbToCopy ;
		m_pArticleHead = pTemp ;

		return	TRUE ;
	}

	return	FALSE ;
}

inline	BOOL
CIOGetArticle::ResetHeaderState(
						CIODriver&	driver
						)	{
/*++

Routine Description :

	This function is called when for some reason an error occurred
	and we wont be able to save the header info for the article.
	We will set all the member variables so that we will continue
	to read the article, however when we finally call the state's completion
	procedure we will tell them an error occurred, and the article
	transfer will fail.

Arguments :

	driver - CIODriverSink that can be used to allocate packets etc !

Return Value :

	None.

--*/

	//
	//	Should only be called before we have started issuing file IO's,
	//	after we start issuing file IO's we should have all the header
	//	data and should not hit errors that would result in our being
	//	called !!!
	//
	_ASSERT( m_pFileDriver == 0 ) ;

	if( m_pArticleHead ) {
		//
		//	If we have an existing buffer - turn it into a write packet
		//	that can be written to the hard disk
		//

		m_pWrite = driver.CreateDefaultWrite(
								m_pArticleHead,
								m_ibStartHead,
								m_ibEndHead,
								m_ibStartHeadData,
								m_ibEndHeadData
								) ;

		if( m_pWrite ) {

			m_pArticleHead = 0 ;
			m_ibStartHead = 0 ;	
			m_ibEndHead = 0 ;
			m_ibStartHeadData = 0;
			m_ibEndHeadData = 0 ;
			m_pchHeadState = 0 ;
			return	TRUE ;

		}	else	{

			return	FALSE ;

		}

	}	else	{
		//
		//	Should already be in a good state !
		//

		_ASSERT( m_pArticleHead == 0 ) ;
		_ASSERT( m_ibStartHead == 0 ) ;
		_ASSERT( m_ibStartHeadData == 0 ) ;
		_ASSERT( m_ibEndHead == 0 ) ;
		_ASSERT( m_ibEndHeadData == 0 ) ;

		m_pchHeadState = 0 ;

	}

	return	TRUE ;
}

void
CIOGetArticle::DoCompletion(
					CSessionSocket*	pSocket,
					HANDLE	hFile,
					DWORD	cbFullBuffer,
					DWORD	cbTotalTransfer,
					DWORD	cbAvailableBuffer,
					DWORD	cbGap
					) {
/*++

Routine Description :

	Call the State's completion function with all the correct
	arguments.

Arguments :
	
	hFile - Handle to the file we used, if we used one !!
		(This will be INVALID_HANDLE_VALUE if no file required !)

Return Value :

	None.

--*/

	//
	//	Figure out error codes if the article looks bad !
	//

	NRC		nrc	= nrcOK ;

	char*	pchHead = 0 ;
	DWORD	cbHeader = 0 ;
	DWORD	cbArticle = 0 ;
	DWORD	cbTotal = 0 ;

	if( m_pArticleHead == 0 ) {
		nrc = nrcHeaderTooLarge ;
	}	else	{

		if( m_pchHeadState != 0 ) {
			nrc = nrcArticleIncompleteHeader ;
		}

		pchHead = &m_pArticleHead->m_rgBuff[m_ibStartHeadData] ;
		cbHeader = m_cbHeadBytes ;
		if( cbAvailableBuffer == 0 )
			cbAvailableBuffer = m_pArticleHead->m_cbTotal - m_ibStartHeadData ;

		//
		//	If there's no file handle, we should have the entire
		//	article in our buffer !!
		//
		if( hFile == INVALID_HANDLE_VALUE ) {

			cbArticle = cbFullBuffer ;

			_ASSERT( cbArticle >= cbHeader ) ;

		}

	}

	//
	//	Call the state's completion function !!
	//

	m_pState->Complete(
						this,
						pSocket,
						nrc,
						pchHead,
						cbHeader,
						cbArticle,
						cbAvailableBuffer,
						hFile,
						cbGap,
						cbTotalTransfer
						) ;
}

BOOL
CIOGetArticle::InitializeForFileIO(
							CSessionSocket*	pSocket,
							CIODriver&		readDriver,
							DWORD			cbHeaderBytes
							)	{
/*++

Routine Description :

	We've been reading data into Ram buffers, and we have gotten so
	much that we've decided not to try to hold it all in RAM.
	So now we must start doing writes to a file somewhere.
	This code will create the file, and set up the necessary
	data structures for processing completed file IO.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	_ASSERT( m_lpstrTempDir != 0 ) ;

	if( !NNTPCreateTempFile( m_lpstrTempDir, m_szTempName ) ) {
		return	FALSE ;
	}

#if 0
	HANDLE	hFile = CreateFile( m_szTempName,
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								0,
								CREATE_ALWAYS,
								FILE_FLAG_OVERLAPPED,
								INVALID_HANDLE_VALUE
								) ;

	if( hFile != INVALID_HANDLE_VALUE ) {

		DWORD	cbGap = m_cbGap ;

		m_pFileChannel = new	CFileChannel() ;
		if( m_pFileChannel->Init(	hFile,
									pSocket,
									cbGap,
									FALSE
									) ) {

			//
			//	Try to create the CIODriver we are going to use to	
			//	complete our async writes !!!
			//

			m_pFileDriver = new CIODriverSink(
										readDriver.GetMediumCache()
										) ;



			if( m_pFileDriver->Init(	m_pFileChannel,
										pSocket,
										ShutdownFunc,
										(void*)this
										) ) {
				m_fDriverInit = TRUE ;

				if( m_pSocketSink != 0 ) {
					//
					//	Now we have to send ourselves into the CIODriverSink() !
					//
					if( m_pFileDriver->SendWriteIO( pSocket, *this, FALSE ) ) {
						return	TRUE ;
					}
				}
			}
		}
	}
#endif

	//
	//	All clean up in error cases is handled by our destructor !
	//
	return	FALSE ;
}



int
CIOGetArticle::Complete(	CSessionSocket*	pSocket,	
							CReadPacket	*pRead,	
							CIO*&	pio	)	{
/*++

Routine Description :

	Called whenever a CReadPacket we have issued completes.
	We only issue read packets against the socket.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	//
	//	This function determines whether we've read an entire article and if so
	//	starts wrapping things up.
	//	All article data we get is either accumulated or issued as a write
	//	to our file.
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	pRead != 0 ) ;
	_ASSERT( pio == this ) ;

	//
	//	Bump the count of writes because we KNOW that IF this is the last read
	//	we may issue a write, CONSEQUENTLY we don't want to confuse the Write Completion
	//	function as to when we are finished.
	//	(It is important to increment before we set the COMPLETE state so that the
	//	thread where writes are completing doesn't get confused and terminate early.)
	//
	//	NOW there is a chance that we won't write this out immediately - in which case we
	//	need to have a matching decrement.	
	//
	m_cwrites ++ ;

	//
	//	Check whether the posting is too big !
	//
	ASSIGNI(m_HardLimit, m_cbLimit);
	if(!EQUALSI(m_HardLimit, 0)) {
		if( GREATER( pRead->m_iStream, m_HardLimit) ) {
			pRead->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_ARTICLE_LIMIT_EXCEEDED,
											0,
											TRUE ) ;
			return	pRead->m_cbBytes ;
		}
	}


	long sign = InterlockedDecrement( &m_cReads ) ;
	long signShutdowns = -1 ;

	//
	//	pch - this will be our current position in the input data
	//
	char	*pch = pRead->StartData();

	//
	//	pchStart and pchEnd - the bounds of the data in the completed
	//	read - after initialization nobody should modify these,
	//	as all the following code uses these instead of StartData(), EndData()
	//	all the time.
	//
	char	*pchStart = pch ;
	char	*pchEnd = pRead->EndData() ;

	//
	//	For those occasions where we get a read which contains both
	//	header and body bytes, but we can't get all the data into a buffer
	//	keep track of where the body bytes start in case we should
	//	do a partial write out of the buffer !
	//
	char	*pchStartBody = pch ;


	//
	//	Pointer to the end of the Header (if we find it !)
	//
	char	*pchEndHead = 0 ;

	//
	//	Number of bytes in the header we found when this read completed !
	//
	DWORD	cbHeadBytes = 0 ;

	//
	//	Number of bytes in the completed read which are part of the article -
	//	this includes any bytes in the header, so cbArticleBytes should always
	//	be greater or equal to cbHeadBytes !
	//
	DWORD	cbArticleBytes = 0 ;

	//
	//	Try to determine if we have found the end of the article ;
	//
	if( m_pchHeadState ) {
		//
		//	We are simultaneously scanning for the end of the
		//	article headers !
		//
		while( pch < pchEnd ) {

			//
			//	We will break out of the loop when we find the end of the
			//	header !
			//
			if( *pch == *m_pchHeadState ) {
				m_pchHeadState ++ ;
				if( *m_pchHeadState == '\0' ) {	
					pchEndHead = pch + 1 ;
					//
					//	break here - we have found the end of the article's header
					//	but not the end of the article, so the following loop
					//	will keep looking for that !
					//
					break ;
				}
			}	else	{
				if( *pch == szHeadState[0] ) {
					m_pchHeadState = &szHeadState[1] ;
				}	else	{
					m_pchHeadState = &szHeadState[0] ;
				}
			}

			//
			//	Test to see if we have come to the end of the article !!
			//
			if( *pch == *m_pchTailState ) {
				m_pchTailState ++ ;
				if( *m_pchTailState == '\0' ) {
					//
					//	Have got the entire terminating sequence - break !
					//
					pch++ ;
					break ;
				}
			}	else	{
				if( *pch == szTailState[0] ) {
					m_pchTailState = &szTailState[1] ;
				}	else	{
					m_pchTailState = &szTailState[0] ;
				}
			}

			pch++ ;
		}
		if( pchEndHead )
			cbHeadBytes = (DWORD)(pchEndHead - pchStart) ;
		else
			cbHeadBytes = (DWORD)(pch - pchStart) ;
	}	
	//
	//	We are not scanning for the end of the article headers !
	//	so keep the loop simpler !
	//
	if( *m_pchTailState != '\0' ) {
		while( pch < pchEnd ) {

			if( *pch == *m_pchTailState ) {
				m_pchTailState ++ ;
				if( *m_pchTailState == '\0' ) {
					//
					//	Have got the entire terminating sequence - break !
					//
					pch++ ;
					break ;
				}
			}	else	{
				if( *pch == szTailState[0] ) {
					m_pchTailState = &szTailState[1] ;
				}	else	{
					m_pchTailState = &szTailState[0] ;
				}
			}
			pch++ ;
		}
	}
	cbArticleBytes = (DWORD)(pch-pchStart) ;

	//
	//	We can do some validation here !
	//	dont go past the end of the buffer !
	//
	_ASSERT( pch <= pchEnd ) ;	
	//
	//	either find the end of the article or examine all the bytes in buffer !
	//
	_ASSERT( *m_pchTailState == '\0' || pch == pchEnd ) ;	
	//
	//	If we have not found the end of the header, then cbHeadBytes
	//	should be the same as cbArticleBytes !!!!
	//
	_ASSERT(	m_pchHeadState == 0 ||
				*m_pchHeadState == '\0' ||
				cbHeadBytes == cbArticleBytes ) ;
	//
	//	Regardless of state - always more bytes in the article than in the
	//	the header !!
	//
	_ASSERT(	cbHeadBytes <= cbArticleBytes ) ;
	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	//
	//	Check to see whether we need to remove CIOGetArticle from
	//	its flow control state !
	//
	if( pRead->m_dwExtra1 != 0 ) {
		//
		//	This Read was issued by the thread that completes writes to
		//	a file, and was marked to indicate we should leave our flow
		//	control state !
		//
		m_fFlowControlled = FALSE ;
		m_cFlowControlled = LONG_MIN ;
	}

	//
	//	Issue a new read if Necessary !!
	//
	BOOL	eof ;
	if( *m_pchTailState != '\0' )	{
		if( InterlockedIncrement( &m_cFlowControlled ) < 0 ) {
			if( sign < 0 ) {
				do	{
					CReadPacket*	pNewRead=pRead->m_pOwner->CreateDefaultRead( cbMediumRequest ) ;
					if( pNewRead )	{
						pNewRead->m_dwExtra1 = 0 ;
						pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;
					}	else	{
						// bugbug ... Need better Error handling !!
						_ASSERT( 1==0 ) ;
					}
				}	while( InterlockedIncrement( &m_cReads ) < 0 ) ;
			}
		}
	}	else	{
		pio = 0 ;
	}


	//
	//	Boolean indicating whether we have examined and used all the bytes
	//	in the completed read.  Start out assuming that we haven't.
	//	
	BOOL	fConsumed = FALSE ;


	//
	//	Are we still trying to accumulate all the bytes in the header of
	//	the article ? If so save the bytes away,
	//	Or if we have a bunch of room in the header buffer, then put
	//	whatever article bytes we have in there as well !
	//
	DWORD	cbAvailable = HeaderSpaceAvailable() ;
	if( m_pchHeadState != 0 ||
		(m_fAcceptNonHeaderBytes &&
		((cbAvailable  > cbArticleBytes) ||
			(m_pArticleHead->m_cbTotal < cbMediumRequest))) ) {
		
		//
		//	If we are still accumulating bytes into our buffer,
		//	then we better not have started doing any file IO !!!!
		//
		_ASSERT( m_pFileDriver == 0 ) ;
		//
		//	Whether we're placing header bytes or the bytes immediately
		//	following the header into our buffer this had better be TRUE !
		//
		_ASSERT( m_fAcceptNonHeaderBytes ) ;

		//
		//	we're still trying to accumulate the header of the article !
		//
		if( m_pArticleHead != 0 ) {

			if( cbAvailable > cbArticleBytes ) {

				fConsumed = TRUE ;
				FillHeaderSpace( pchStart, cbArticleBytes ) ;	

			}	else	{

				//
				//	Need a bigger buffer to hold all the data in the header !
				//	If we already have a resonably sized buffer that will hold
				//	the header than just copy the header text
				//

				if( cbAvailable > cbHeadBytes &&
					m_pArticleHead->m_cbTotal >= cbMediumRequest ) {

					//
					//	If we can't fit all the article bytes but we can
					//	fit all the header bytes than we MUST have the entire
					//	header, and we must have just gotten it !!
					//
					_ASSERT( m_pchHeadState != 0 ) ;
					_ASSERT( *m_pchHeadState == '\0' ) ;
			
					FillHeaderSpace( pchStart, cbHeadBytes ) ;
					pchStartBody += cbHeadBytes ;
	
				}	else	if( !GetBiggerHeaderBuffer( *pRead->m_pOwner, cbArticleBytes ) ) {

					//
					//	Oh-oh ! failed to get a larger header buffer -
					//	lets see if we can fit just the header bytes in the buffer
					//

					if( cbAvailable > cbHeadBytes ) {

						//	Must have entire header if this is the case !
						_ASSERT( m_pchHeadState != 0 ) ;
						_ASSERT( *m_pchHeadState == '\0' ) ;

						FillHeaderSpace( pchStart, cbHeadBytes ) ;
						pchStartBody += cbHeadBytes ;

					}	else	{

						//
						//	Blow off whatever buffers we have - when we call
						//	the m_pState's completion function we will indicate
						//	that we had an error !
						//
						if( !ResetHeaderState( *pRead->m_pOwner ) ) {

							//
							//	A fatal error !!! Can't open a file to hold the article !!!
							//

							pRead->m_pOwner->UnsafeClose(	pSocket,
															CAUSE_OOM,
															GetLastError(),
															TRUE
															) ;
							pio = 0 ;
							return	cbArticleBytes ;
						}

					}
	
				}	else	{

					fConsumed = TRUE ;
					FillHeaderSpace( pchStart, cbArticleBytes ) ;

				}
			}
		
		}	else	{

			//
			//	First time we've completed a read - set up to hold the
			//	header information !
			//		
			fConsumed = TRUE ;	
			InitializeHeaderSpace( pRead, cbArticleBytes ) ;			

		}

		if( m_pchHeadState ) {
			//
			//	Still accumulating header bytes - count them up !
			//
			m_cbHeadBytes += cbHeadBytes ;
			if(	*m_pchHeadState == '\0' ) {

				//
				//	we have received the entire header of the article !
				//
				m_pchHeadState = 0 ;
			}
		}	
	}	

	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	//
	//	Check if all the bytes in the incoming packet were
	//	stored by the above code, which tried to store the bytes
	//	away into a buffer
	//

	if( fConsumed ) {

		if( *m_pchTailState == '\0' ) {

			//
			//	Best of all worlds - we have a complete article, and we have
			//	managed to save it all in a buffer without any file IO !!
			//	Now figure out if we completed it in just one read, cause if we
			//	we have we want to be carefull about how much space we can use
			//	in that read !
			//

			DWORD	cbAvailable = 0 ;
			if( m_pArticleHead == pRead->m_pbuffer ) {

				//
				//	Just one read got everything !!! well the available
				//	bytes will be the entire packet if there was no extra data
				//	otherwise, it will need some adjustment !!
				//
				_ASSERT( pch == pRead->StartData() + cbArticleBytes ) ;

				if( cbArticleBytes != pRead->m_cbBytes ) {
					//
					//	This must mean that we got more bytes then just the article -
					//	shuffle bytes around to get the most usable room in this IO buffer !
					//
					DWORD	cbTemp = pRead->m_ibEnd - pRead->m_ibEndData ;
					if( cbTemp == 0 ) {
						//
						//	There's not going to be any space available -
						//
						cbAvailable = cbArticleBytes ;
					}	else	{

						MoveMemory( pch+cbTemp, pch, pchEnd - pch ) ;
						pRead->m_ibStartData += cbTemp ;
						pRead->m_ibEndData = pRead->m_ibEnd ;
						cbAvailable = cbArticleBytes + cbTemp ;

					}
				}
			}


			DoCompletion(	pSocket,
							INVALID_HANDLE_VALUE,
							m_ibEndHeadData - m_ibStartHeadData,	
							m_ibEndHeadData - m_ibStartHeadData,
							cbAvailable
							) ;

			//
			//	No Next state !
			//
			pio = 0 ;

		}

		//
		//	reset to zero as we are swallowing all the data into a buffer and not issuing writes
		//	to a file !
		//
		m_cwrites = 0 ;

		return	cbArticleBytes ;
	}


	//
	//	If we EVER reach this point, then we have completed a Read which
	//	we did not copy into our header buffer.  That means, we should not
	//	ever place any other reads into our header buffer, as then we would
	//	not have a correct image of the article !!!!
	//
	m_fAcceptNonHeaderBytes = FALSE ;


	//
	//	If we reach this point then we are no longer able to save bytes
	//	in the buffer we has set aside for saving header bytes.
	//	We have to write these bytes to a file now !!!
	//


	if( m_pFileDriver == 0 ) {

		//
		//	This is the first time we have reached this point - so we
		//	need to create a file and everything right now !!!
		//

		if( !InitializeForFileIO(
								pSocket,
								*pRead->m_pOwner,
								m_cbHeadBytes
								)	) {

			//
			//	A fatal error !!! Can't open a file to hold the article !!!
			//

			pRead->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_OOM,
											GetLastError(),
											TRUE
											) ;
			pio = 0 ;
			return	cbArticleBytes ;

		}	else	{

	
			//
			//	In some error cases we will create a WritePacket before we have
			//	created all the CIODriver's to handle the IO, so if we have
			//	one make sure the owner is set correctly !
			//
			if( m_pWrite ) {

				m_pWrite->m_pOwner = m_pFileDriver ;

			}

			//
			//	If we have accumulated some data we need to write it into the file !
			//
			
			if( m_pArticleHead != 0 ) {
				//
				//	Bump the number of writes, as we're going to write the header
				//	to disk now !!!!
				//
				m_cwrites ++ ;
				
				//
				//	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
				//  our destructor if an error has occurred !!
				//
				CWritePacket*	pTempWrite =
					m_pFileDriver->CreateDefaultWrite(
											m_pArticleHead,
											m_ibStartHead,
											m_ibEndHead,
											m_ibStartHeadData,
											m_ibEndHeadData
											) ;

				DoFlowControl( INST(pSocket) ) ;
				m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
			}

		}

	}

	//
	//	Issue a write, unless the user is sending small packets,
	//	in which case we will accumulate the data !!
	//

	//
	//	Note - use pchStartBody in all calculations here, as we may have
	//	taken a fraction of the bytes into our header buffer !!
	//

	if( *m_pchTailState != '\0' )	{
		unsigned	cbSmall = (unsigned)(pchEnd - pchStartBody) ;
		if( cbSmall < cbTooSmallWrite )	{
			if( m_pWrite == 0 )	{
				m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
				m_pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart) ;
			}	else	{
				if( (m_pWrite->m_ibEnd - m_pWrite->m_ibEndData) > cbSmall )		{
					CopyMemory( m_pWrite->EndData(), pchStartBody, cbSmall ) ;
					m_pWrite->m_ibEndData += cbSmall ;
					m_cwrites -- ;		// There will never be a corresponding write for this completiong
										// as we copied the data into another buffer. SO decrement the count.
				}	else	{
					//
					//	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
					//  our destructor if an error has occurred !!
					//
					CWritePacket*	pTempWrite = m_pWrite ;
					m_pWrite = 0 ;
					DoFlowControl( INST(pSocket) ) ;
					m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
					m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
				}
			}
		// If we came through here we should have consumed all bytes in the packet!
		_ASSERT( pch == pchEnd ) ;
		_ASSERT( unsigned(pch - pchStart) == pRead->m_cbBytes ) ;
		return	(int)(pch - pchStart) ;
		}
	}

	if( m_pWrite )	{
		CWritePacket*	pTempWrite = m_pWrite ;
		m_pWrite = 0 ;

		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
	}
	

	CWritePacket*	pWrite = 0 ;
	if( pch == pchEnd )		{
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead ) ;
	}	else	{
		unsigned	ibEnd = pRead->m_ibStartData + (unsigned)(pch - pchStart) ;
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead->m_pbuffer,
						pRead->m_ibStartData, ibEnd,
						pRead->m_ibStartData, ibEnd ) ;
	}

	if( pWrite )	{

	    //
    	//	It is possible that long before we reached here we took a portion
	    //	of this packet and placed it into our header buffer - so adjust for that
    	//	if it occurred !!
	    //
    	pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart) ;

	    _ASSERT( pWrite->m_ibStartData < pWrite->m_ibEndData ) ;

		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pWrite, pSocket, eof ) ;

	}	else	{

		pRead->m_pOwner->UnsafeClose(	pSocket,
										CAUSE_OOM,
										GetLastError(),
										TRUE
										) ;

	}
	_ASSERT( eof == FALSE ) ;

	if( *m_pchTailState == '\0' )	{
		m_pFileChannel->FlushFileBuffers() ;
	}

	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	return	(int)(pch - pchStart) ;
}

int	
CIOGetArticle::Complete(	CSessionSocket*	pSocket,	
							CWritePacket *pWrite,	
							CIO*&	pioOut ) {
/*++

Routine Description :

	Called whenever a write to a file completes.
	We must determine whether we have completed all the writes
	we are going to do and if so call the state's completion function.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet that was writtne to the file.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	TraceFunctEnter( "CIOGetArticle::Complete" ) ;

	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pWrite != 0 ) ;
	_ASSERT( pioOut == this ) ;

	m_cwritesCompleted++ ;

	long	cFlowControlled = 0 ;

	//
	//	Process the completion of a write to a file.
	//	determine whether we need to signal the entire transfer
	//	as completed.
	//

	if( *m_pchTailState == '\0' && m_cwritesCompleted == m_cwrites )	{

		// BUGBUG: loss of 64-bit precision
		DWORD	cbTransfer = DWORD( LOW(pWrite->m_iStream) + pWrite->m_cbBytes ) /*- m_pFileChannel-> */ ;
		DWORD	cbGap = m_pFileChannel->InitialOffset() ;

		HANDLE	hFile = m_pFileChannel->ReleaseSource() ;

		_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;

		DoCompletion(	pSocket,
						hFile,
						0,
						cbTransfer,
						0,			// Let DoCompletion compute available buffer size !
						cbGap
						) ;



		//
		//	NOT ALLOWED TO RETURIN A NEW IO OPERATION !!! Because this function is
		//	operating in a Channel which is temporary !!!
		//

		//	We do not set pioOut to zero, as we want the CIODriver to
		//	call out Shutdown function during its termination processing !


		//
		//	Now we must destroy our channels !!!
		//

		DebugTrace( (DWORD_PTR)this, "Closing File Driver %x ", m_pFileDriver ) ;
		
		//m_pFileDriver->Close( pSocket,	CAUSE_LEGIT_CLOSE, 0, FALSE ) ;
		Term( pSocket, FALSE ) ;

		DebugTrace( (DWORD_PTR)this, "deleting self" ) ;

	}	else	if( ( m_fFlowControlled ) ) {

		if( m_cwrites - m_cwritesCompleted <= RESTORE_FLOW && m_pSocketSink != 0 )	{
			//
			//	ALWAYS issue at least 1 read when coming out of a flow control state !!
			//

			CReadPacket*	pRead = 0 ;

			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );

			cFlowControlled = m_cFlowControlled + 1 ;
			while( cFlowControlled >= 1  ) {
				if( m_pSocketSink == 0 )
					break ;
				pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
				if( 0!=pRead )	{
					BOOL	eof ;
					InterlockedIncrement( &m_cReads ) ;
					pRead->m_dwExtra1 = 0 ;
					pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
				}	
				cFlowControlled -- ;
			}	

			//
			//	The following read is special - we set the m_dwExtra1 field so that
			//	the read completion code can determine that it is time to leave
			//	the flow control state !
			//
			pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
			if( 0!=pRead )	{
				BOOL	eof ;
				pRead->m_dwExtra1 = 1 ;
				InterlockedIncrement( &m_cReads ) ;
				pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
			}	else	{

				//
				//	Fatal error - drop the session !
				//
				m_pSocketSink->UnsafeClose(	pSocket,
											CAUSE_OOM,
											GetLastError(),
											TRUE
											) ;
				return	pWrite->m_cbBytes ;

			}
			cFlowControlled -- ;

			InterlockedExchange( &m_cFlowControlled, LONG_MIN ) ;
			// Set to FALSE after InterlockedExchange !!
			m_fFlowControlled = FALSE ;

		}
	}

	return	pWrite->m_cbBytes ;
}


//CIOGetArticleEx


//
//	Maximum number of pending reads while reading an article
//
unsigned	CIOGetArticleEx::maxReadAhead = 3 ;
//
//	Number of bytes to accumulate before writing to a file !
//
unsigned	CIOGetArticleEx::cbTooSmallWrite = cbLargeRequest - 512;

BOOL
CIOGetArticleEx::FValid()	{

	_ASSERT( !m_pchMatch || strlen( m_pchMatch ) != 0 ) ;
	_ASSERT( m_pchTailState == 0 ||
			m_pchTailState >= m_pchMatch &&
			(m_pchTailState <= m_pchMatch + strlen(m_pchMatch)) ) ;

	_ASSERT( (m_pFileDriver == 0 && m_pFileChannel == 0) ||
			 (m_pFileDriver != 0 && m_pFileChannel != 0) ) ;

	_ASSERT( m_cbLimit != 0 ) ;

	_ASSERT( m_pState != 0 ) ;
	//_ASSERT( m_pSocketSink != 0 ) ;	This can happen during destruction !

	_ASSERT( m_pWrite == 0 ||
			m_pFileDriver != 0 ) ;
	return	TRUE ;
}

CIOGetArticleEx::CIOGetArticleEx(
						CSessionState*	pstate,
						CSessionSocket*	pSocket,	
						CDRIVERPTR&	pDriver,
						DWORD	cbLimit,
						LPSTR	szMatch,
						LPSTR	pchInitial,
						LPSTR	szErrorMatch,
						LPSTR	pchInitialError
						) :
/*++

Routine Description :

	Class Constructor

Arguments :
	
	pstate - The State which is issuing us and who's completion function
			we should later call
	pSocket -	The socket on which we will be issued
	pDriver -	The CIODriver object handling all of the socket's IO
	pFileChannel -	The File Channel into which we should save all data
	fSaveHead - TRUE if we want the HEAD of the article placed in a buffer !
	fPartial	- If TRUE then we should assume that a CRLF has already
				been sent and '.\r\n' alone can terminate the article.

Return Value :
	
	None

--*/

	//
	//	Get a CIOGetArticleEx object half way set up - user still needs
	//	to call Init() but we will do much here !
	//
	CIORead( pstate ),
	m_pchMatch( szMatch ),
	m_pchTailState( pchInitial ),
	m_pchErrorMatch( szErrorMatch ),
	m_pchErrorState( pchInitialError ),
	m_pFileChannel( 0 ),	
	m_pFileDriver( 0 ),
	m_pSocketSink( pDriver ),
	m_fDriverInit( FALSE ),
	m_fSwallow( FALSE ),
	m_cwrites( 0 ),
	m_cwritesCompleted( 0 ),
	m_cFlowControlled( LONG_MIN ),
	m_fFlowControlled( FALSE ),
	m_cReads( 0 ),
	m_pWrite( 0 ),
	m_cbLimit( cbLimit ),
	m_ibStartHead( 0 ),
	m_ibStartHeadData( 0 ),
	m_ibEndHead( 0 ),
	m_ibEndHeadData( 0 )
#ifdef	CIO_DEBUG
	,m_fSuccessfullInit( FALSE ),
	m_fTerminated( FALSE )
#endif
{

	ASSIGNI(m_HardLimit, 0);
	TraceFunctEnter( "CIOGetArticleEx::CIOGetArticleEx" ) ;


	_ASSERT( m_pchTailState != 0 ) ;
	_ASSERT( m_pchMatch != 0 ) ;
	_ASSERT(	(m_pchErrorMatch == 0 && m_pchErrorState == 0) ||
				(m_pchErrorMatch != 0 && m_pchErrorState != 0) ) ;
	_ASSERT( FValid() ) ;
}

CIOGetArticleEx::~CIOGetArticleEx( )	{
/*++

Routine Description :

	Class Destructor

Arguments :
	
	None

Return Value :
	
	None

--*/

	_ASSERT( FValid() ) ;
	//
	//	Destroy a CIOGetArticleEx - always close our m_pFileDriver if possible
	//	in case we are terminated due to some socket error.
	//
	TraceFunctEnter( "CIOGetArticleEx::~CIOGetArticleEx" ) ;

#ifdef	CIO_DEBUG
	//
	//	Our destructor should only be called if we weren't successfully init
	//	or after Term() has been called.
	//
	_ASSERT( !m_fSuccessfullInit || m_fTerminated ) ;
#endif

	DebugTrace( (DWORD_PTR)this, "m_pFileDriver %x m_fDriverInit %x", m_pFileDriver, m_fDriverInit ) ;

	if( m_pFileDriver != 0 ) {
		if( m_fDriverInit )		{
			m_pFileDriver->UnsafeClose( (CSessionSocket*)this, CAUSE_NORMAL_CIO_TERMINATION, 0, FALSE ) ;
		}
	}
	if( m_pWrite != 0 ) {
		CPacket::DestroyAndDelete( m_pWrite ) ;
		m_pWrite = 0 ;
	}
}

void
CIOGetArticleEx::Term(	CSessionSocket*	pSocket,
						BOOL			fAbort,
						BOOL			fStarted	)	{
/*++

Routine Description :

	Start destroying a successfully initialize CIOGetArticleEx object

Arguments :
	
	fAbort - If TRUE then destroy the socket which we were using
			If FALSE then only close down our File Channel's

Return Value :

	None

--*/
#ifdef	CIO_DEBUG
	m_fTerminated = TRUE ;
#endif
	//
	//	Start us on our way to destruction !!
	//	If we have been successfully Initialized, then this will
	//	lead to our destruction when our m_pFileDriver eventually shutsdown.
	//	(Since we were succesfully Init() our m_pFileDriver has a reference to us,
	//	so we must allow it to shutdown and destroy us to avoid problems with
	//	circular references and multiple frees !)
	//

	if( m_pFileDriver != 0 ) {
		m_pFileDriver->UnsafeClose( pSocket,
				fAbort ? CAUSE_USERTERM : CAUSE_NORMAL_CIO_TERMINATION, 0, fAbort ) ;
	}
}


void
CIOGetArticleEx::Shutdown(	CSessionSocket*	pSocket,	
							CIODriver&		driver,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dwOptional )	{
/*++

Routine Description :

	Do whatever work is necessary when one of the two CIODriver's we are
	using is terminated.

Arguments :

	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	TraceFunctEnter( "CIOGetArticleEx::Shutdown" ) ;
	DebugTrace( (DWORD_PTR)this, "SHutdown args - pSocket %x driver %x cause %x dw %x",
			pSocket, &driver, cause, dwOptional ) ;

	//
	//	This function is called when the CIODriver's we are refenced by our closing down.
	//	Since we are referenced by two of them (one for the socket and one for the file)
	//	we only want to be deleted by the CIODriver for the file.
	//
	if( &driver == m_pFileDriver )	{
		// Out file is closing - what can we do about it !
		//_ASSERT( 1==0 ) ;
#ifdef	CIO_DEBUG
		m_fTerminated = TRUE ;
#endif

		//
		//	We set this to 0 here as we know we will be called here by
		//	the same thread that is completing writes to the file - so
		//	since that's the only thread referencing this member variable -
		//	there are no thread safety issues accessing that member.
		//

		m_pSocketSink = 0 ;

		if ( m_fFlowControlled )
		{
			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );
		}

	}	else	{
		// Close down the rest of our stuff as well !!
		Term( pSocket, cause != CAUSE_NORMAL_CIO_TERMINATION ) ;
	}
}

void
CIOGetArticleEx::ShutdownFunc(	void *pv,	
								SHUTDOWN_CAUSE	cause,	
								DWORD dw ) {
/*++

Routine Description :

	Notification function which is called when a CIODriver used by
	a CIOGetArticleEx if finally destroyed.  This function is provided
	to the CIODriver we use for File IO's during out Init().

Arguments :

	pv	-	Pointer to dead CIOGetArticleEx - this has been destroyed dont use !
	cause -	The reason for termination
	dw		Optional extra information regarding termination

Return Value :

	None

--*/

	TraceFunctEnter( "CIOGetArticleEx::ShutdownFunc" ) ;
	//
	//	This function gets notified when a CIOFileDriver used by CIOGetArticleEx
	//	is terminated.  Not much for us to worry about.
	//	(CIODriver's require these functions)
	//

	//_ASSERT( 1==0 ) ;
	return ;
}

BOOL
CIOGetArticleEx::Start(	CIODriver&	driver,	
						CSessionSocket	*pSocket,	
						unsigned cReadAhead )	{
/*++

Routine Description :

	This function is called to start transferring data from the socket
	into the file.

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/


	_ASSERT( pSocket != 0 ) ;

	m_cReads = -((long)maxReadAhead) + cReadAhead ;

	while( cReadAhead < maxReadAhead )	{
		//
		//	Start reading data from the socket
		//
		CReadPacket*	pRead = driver.CreateDefaultRead( cbLargeRequest ) ;
		if( 0!=pRead )	{
			BOOL	eof ;
			pRead->m_dwExtra1 = 0 ;
			driver.IssuePacket( pRead, pSocket, eof ) ;
			cReadAhead++ ;
			InterlockedIncrement( &m_cReads ) ;
		}	else	{
			//
			// This is a fatal problem only if we couldn't issue ANY reads at all !
			//
			if( cReadAhead == 0 )
				return FALSE  ;
		}
	}	
	return	TRUE ;
}

void
CIOGetArticleEx::DoFlowControl( PNNTP_SERVER_INSTANCE pInstance )	{
/*++

Routine Description :

	Check whether it is necessary to set flow control due to
	too many outstanding writes.
	If necessary, then the first time we do put ourselves into Flow Control,
	try to flush our pending writes.
	We should be called only immediately before issuing an Async Write to the file
	to ensure that a CWritePacket completion will actually execute the necessary
	code to restart a flow controlled session.
	(Otherwisse, we could potentially decide to Flow control the session
	and before setting m_fFlowControlled to TRUE all the pending writes complete
	and then we'd be left in a boat where there are no pending reads or
	writes and no way to get out of the flow control state.)

Arguments :

	None.

Return Value :

	None.


--*/

	//
	//	Important - do all tests of m_fFlowControlled before setting
	//	m_cFlowControlled - as other thread will touch m_cFlowControlled
	//	before touching m_fFlowControlled !!
	//	(Will only touch m_fFlowControlled if m_fFlowControlled is TRUE ) !
	//	Thus we know that if m_fFlowControlled is FALSE there is nobody
	//	messing with m_cFlowControlled,
	//
	//

	if( m_cwrites - m_cwritesCompleted > MAX_OUTSTANDING_FILE_WRITES ) {
		
		if( m_fFlowControlled ) {
			// All ready have flow control turned on
			;
		}	else	{
			m_cFlowControlled = -1 ;
			m_fFlowControlled = TRUE ;
			m_pFileChannel->FlushFileBuffers() ;

			IncrementStat( pInstance, SessionsFlowControlled );
		}
	}	else	{
		if( !m_fFlowControlled ) {
			m_cFlowControlled = LONG_MIN ;	// Keep resetting !
		}
	}
}

inline	DWORD
CIOGetArticleEx::HeaderSpaceAvailable()	{
/*++

Routine Description :

	Compute the amount of space available in the buffer we are using
	to hold the article header !

Arguments :

	None.

Return Value :

	number of bytes available, 0 if we aren't collecting article headers !

--*/

	if( m_pArticleHead != 0 ) {

		return	m_ibEndHead - m_ibEndHeadData ;

	}
	return	0 ;
}

inline	void
CIOGetArticleEx::FillHeaderSpace(
						char*	pchStart,
						DWORD	cbBytes
						) {
/*++

Routine Description :

	Copy bytes into the header storage area !!
	Caller should ensure that this will fit !!
	
Arguments :

	pchStart - Start of bytes to be copied !
	cbBytes -	Number of bytes to copy !

Return Value :

	None.

--*/

	_ASSERT( m_pArticleHead != 0 ) ;
	_ASSERT( cbBytes + m_ibEndHeadData < m_ibEndHead ) ;

	CopyMemory( m_pArticleHead->m_rgBuff + m_ibEndHeadData,
				pchStart,
				cbBytes
				) ;

	m_ibEndHeadData += cbBytes ;
}


inline	void
CIOGetArticleEx::InitializeHeaderSpace(
						CReadPacket*	pRead,
						DWORD			cbArticleBytes
						) {
/*++

Routine Description  :

	Given a read packet which contains our first completed read,
	set up all our buffer start for holding header information !
	
Arguments :

	CReadPackets*	pRead - the completed read !
	cbArticleBytes - Number of bytes in the completed read making up the article !

Return Value :

	None.
	
--*/


	_ASSERT( m_pArticleHead == 0 ) ;
	_ASSERT( m_ibStartHead == 0 ) ;
	_ASSERT( m_ibEndHead == 0 ) ;
	_ASSERT( m_ibStartHeadData == 0 ) ;
	_ASSERT( m_ibEndHeadData == 0 ) ;
	_ASSERT( cbArticleBytes <= (pRead->m_ibEndData - pRead->m_ibStartData)) ;

	m_pArticleHead = pRead->m_pbuffer ;

	m_ibStartHead = pRead->m_ibStart ;
	m_ibStartHeadData = pRead->m_ibStartData ;
	m_ibEndHeadData = pRead->m_ibStartData + cbArticleBytes ;

	if( m_ibEndHeadData < pRead->m_ibEndData )
		m_ibEndHead = m_ibEndHeadData ;
	else
		m_ibEndHead = pRead->m_ibEnd ;

}

inline	BOOL
CIOGetArticleEx::GetBiggerHeaderBuffer(
							CIODriver&	driver,
							DWORD		cbRequired
							) {
/*++

Routine Description :

	We have too much data to fit into the buffer we are using to hold
	header information.  So try to get a bigger buffer and move
	our old data into that buffer !

Arguments :

	driver - A CIODriverSink we can use to allocate buffers !

Return Value :

	TRUE if successfull,
	FALSE otherwise.
	If we fail we leave member variables untouched.

--*/

	_ASSERT( m_pArticleHead != 0 ) ;

	CBuffer*	pTemp = 0 ;

	DWORD	cbRequest = cbMediumRequest ;

	if( (m_pArticleHead->m_cbTotal + cbRequired)  > cbMediumRequest )	{
		cbRequest = cbLargeRequest ;
	}

	if( cbRequest < (cbRequired + (m_ibEndHeadData - m_ibStartHeadData)) ) {
		return	FALSE ;
	}

	pTemp = driver.AllocateBuffer( cbRequest ) ;

	if( pTemp != 0 ) {

		DWORD	cbToCopy = m_ibEndHeadData - m_ibStartHeadData ;
		CopyMemory( pTemp->m_rgBuff,
					&m_pArticleHead->m_rgBuff[ m_ibStartHeadData ],
					cbToCopy
					) ;

		m_ibStartHead = 0 ;
		m_ibStartHeadData = 0 ;
		m_ibEndHead = pTemp->m_cbTotal ;
		m_ibEndHeadData = cbToCopy ;
		m_pArticleHead = pTemp ;

		return	TRUE ;
	}

	return	FALSE ;
}

#if 0
inline	BOOL
CIOGetArticleEx::ResetHeaderState(
						CIODriver&	driver
						)	{
/*++

Routine Description :

	This function is called when for some reason an error occurred
	and we wont be able to save the header info for the article.
	We will set all the member variables so that we will continue
	to read the article, however when we finally call the state's completion
	procedure we will tell them an error occurred, and the article
	transfer will fail.

Arguments :

	driver - CIODriverSink that can be used to allocate packets etc !

Return Value :

	None.

--*/

	//
	//	Should only be called before we have started issuing file IO's,
	//	after we start issuing file IO's we should have all the header
	//	data and should not hit errors that would result in our being
	//	called !!!
	//
	_ASSERT( m_pFileDriver == 0 ) ;

	if( m_pArticleHead ) {
		//
		//	If we have an existing buffer - turn it into a write packet
		//	that can be written to the hard disk
		//

		m_pWrite = driver.CreateDefaultWrite(
								m_pArticleHead,
								m_ibStartHead,
								m_ibEndHead,
								m_ibStartHeadData,
								m_ibEndHeadData
								) ;

		if( m_pWrite ) {

			m_pArticleHead = 0 ;
			m_ibStartHead = 0 ;	
			m_ibEndHead = 0 ;
			m_ibStartHeadData = 0;
			m_ibEndHeadData = 0 ;
			m_pchHeadState = 0 ;
			return	TRUE ;

		}	else	{

			return	FALSE ;

		}

	}	else	{
		//
		//	Should already be in a good state !
		//

		_ASSERT( m_pArticleHead == 0 ) ;
		_ASSERT( m_ibStartHead == 0 ) ;
		_ASSERT( m_ibStartHeadData == 0 ) ;
		_ASSERT( m_ibEndHead == 0 ) ;
		_ASSERT( m_ibEndHeadData == 0 ) ;

		m_pchHeadState = 0 ;

	}

	return	TRUE ;
}
void
CIOGetArticleEx::DoCompletion(
					CSessionSocket*	pSocket,
					HANDLE	hFile,
					DWORD	cbFullBuffer,
					DWORD	cbTotalTransfer,
					DWORD	cbAvailableBuffer,
					DWORD	cbGap
					) {
/*++

Routine Description :

	Call the State's completion function with all the correct
	arguments.

Arguments :
	
	hFile - Handle to the file we used, if we used one !!
		(This will be INVALID_HANDLE_VALUE if no file required !)

Return Value :

	None.

--*/

	//
	//	Figure out error codes if the article looks bad !
	//

	NRC		nrc	= nrcOK ;

	char*	pchHead = 0 ;
	DWORD	cbHeader = 0 ;
	DWORD	cbArticle = 0 ;
	DWORD	cbTotal = 0 ;

	if( m_pArticleHead == 0 ) {
		nrc = nrcHeaderTooLarge ;
	}	else	{

		if( m_pchHeadState != 0 ) {
			nrc = nrcArticleIncompleteHeader ;
		}

		pchHead = &m_pArticleHead->m_rgBuff[m_ibStartHeadData] ;
		cbHeader = m_cbHeadBytes ;
		if( cbAvailableBuffer == 0 )
			cbAvailableBuffer = m_pArticleHead->m_cbTotal - m_ibStartHeadData ;

		//
		//	If there's no file handle, we should have the entire
		//	article in our buffer !!
		//
		if( hFile == INVALID_HANDLE_VALUE ) {

			cbArticle = cbFullBuffer ;

			_ASSERT( cbArticle >= cbHeader ) ;

		}

	}

	//
	//	Call the state's completion function !!
	//

	m_pState->Complete(
						this,
						pSocket,
						nrc,
						pchHead,
						cbHeader,
						cbArticle,
						cbAvailableBuffer,
						hFile,
						cbGap,
						cbTotalTransfer
						) ;
}
#endif



BOOL
CIOGetArticleEx::InitializeForFileIO(
							FIO_CONTEXT*	pFIOContext,
							CSessionSocket*	pSocket,
							CIODriver&		readDriver,
							DWORD			cbHeaderBytes
							)	{
/*++

Routine Description :

	We've been reading data into Ram buffers, and we have gotten so
	much that we've decided not to try to hold it all in RAM.
	So now we must start doing writes to a file somewhere.
	This code will create the file, and set up the necessary
	data structures for processing completed file IO.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/
	_ASSERT( FValid() ) ;

	_ASSERT( m_pFileChannel == 0 ) ;
	_ASSERT( m_pFileDriver == 0 ) ;

	if( pFIOContext != 0 ) {

		_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;

		m_pFileChannel = new	CFileChannel() ;
		if( m_pFileChannel && m_pFileChannel->Init(	pFIOContext,
									pSocket,
									0,
									FALSE
									) ) {

			//
			//	Try to create the CIODriver we are going to use to	
			//	complete our async writes !!!
			//

			m_pFileDriver = new CIODriverSink(
										readDriver.GetMediumCache()
										) ;



			if( m_pFileDriver && m_pFileDriver->Init(	m_pFileChannel,
										                pSocket,
                										ShutdownFunc,
				                						(void*)this
										) ) {
				m_fDriverInit = TRUE ;

				if( m_pSocketSink != 0 ) {
					//
					//	Now we have to send ourselves into the CIODriverSink() !
					//
					if( m_pFileDriver->SendWriteIO( pSocket, *this, FALSE ) ) {
						return	TRUE ;
					}
				}
			}
		}
	}

	//
	//	All clean up in error cases is handled by our destructor !
	//
	return	FALSE ;
}


BOOL
CIOGetArticleEx::StartFileIO(
							CSessionSocket*	pSocket,
							FIO_CONTEXT*	pFIOContext,
							CBUFPTR&		pBuffer,
							DWORD			ibStartBuffer,
							DWORD			ibEndBuffer,
							LPSTR			szMatch,
							LPSTR			pchInitial
							)	{
/*++

Routine Description :

	We've been reading data into Ram buffers, and we have gotten so
	much that we've decided not to try to hold it all in RAM.
	So now we must start doing writes to a file somewhere.
	This code will create the file, and set up the necessary
	data structures for processing completed file IO.

Arguments :

	None.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	_ASSERT( szMatch != 0 ) ;
	_ASSERT( pchInitial != 0 ) ;
	_ASSERT( FValid() ) ;

	_ASSERT( m_pFileChannel == 0 ) ;
	_ASSERT( m_pFileDriver == 0 ) ;

	m_pchMatch = szMatch ;
	m_pchTailState = pchInitial ;
	m_pchErrorMatch = 0 ;
	m_pchErrorState = 0 ;

	if( pFIOContext == 0 ) 	{
		_ASSERT( pBuffer == 0 ) ;
		//
		//	We just want to consume all of the bytes that we get and throw them away !
		//
		m_fSwallow = TRUE ;
		return	TRUE ;
	}	else	if( InitializeForFileIO(	pFIOContext,
								pSocket,
								*m_pSocketSink,
								0	) )	{

		//
		//	Well the file is set up - we need to
		//	write the first batch of bytes into the file !
		//
		//
		//	Bump the number of writes, as we're going to write the header
		//	to disk now !!!!
		//
		m_cwrites ++ ;
		//
		//	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
		//  our destructor if an error has occurred !!
		//

		m_pWrite =
			m_pFileDriver->CreateDefaultWrite(
									pBuffer,
									0,
									pBuffer->m_cbTotal,
									ibStartBuffer,
									ibEndBuffer
									) ;

		if( m_pWrite )	{
			_ASSERT( FValid() ) ;
			return	TRUE ;
		}	
	}

	//m_pchMatch = 0 ;
	//m_pchTailState = 0 ;

	//
	//	Shutdown the socket !
	//
	m_pSocketSink->UnsafeClose(	pSocket,
								CAUSE_OOM,
								__LINE__,
								TRUE
								) ;
	//
	//	All clean up in error cases is handled by our destructor !
	//
	return	FALSE ;
}




int
CIOGetArticleEx::Complete(	CSessionSocket*	pSocket,	
							CReadPacket	*pRead,	
							CIO*&	pio	
							)	{
/*++

Routine Description :

	Called whenever a CReadPacket we have issued completes.
	We only issue read packets against the socket.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	//
	//	This function determines whether we've read an entire article and if so
	//	starts wrapping things up.
	//	All article data we get is either accumulated or issued as a write
	//	to our file.
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	pRead != 0 ) ;
	_ASSERT( pio == this ) ;
	_ASSERT( FValid() ) ;

	//
	//	Bump the count of writes because we KNOW that IF this is the last read
	//	we may issue a write, CONSEQUENTLY we don't want to confuse the Write Completion
	//	function as to when we are finished.
	//	(It is important to increment before we set the COMPLETE state so that the
	//	thread where writes are completing doesn't get confused and terminate early.)
	//
	//	NOW there is a chance that we won't write this out immediately - in which case we
	//	need to have a matching decrement.	
	//
	m_cwrites ++ ;

	//
	//	Check whether the posting is too big !
	//
	ASSIGNI(m_HardLimit, m_cbLimit);
	if(!EQUALSI(m_HardLimit, 0)) {
		if( GREATER( pRead->m_iStream, m_HardLimit) ) {
			pRead->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_ARTICLE_LIMIT_EXCEEDED,
											0,
											TRUE ) ;
			return	pRead->m_cbBytes ;
		}
	}


	long sign = InterlockedDecrement( &m_cReads ) ;
	long signShutdowns = -1 ;

	//
	//	pch - this will be our current position in the input data
	//
	char	*pch = pRead->StartData();

	//
	//	pchStart and pchEnd - the bounds of the data in the completed
	//	read - after initialization nobody should modify these,
	//	as all the following code uses these instead of StartData(), EndData()
	//	all the time.
	//
	char	*pchStart = pch ;
	char	*pchEnd = pRead->EndData() ;

	//
	//	For those occasions where we get a read which contains both
	//	header and body bytes, but we can't get all the data into a buffer
	//	keep track of where the body bytes start in case we should
	//	do a partial write out of the buffer !
	//
	char	*pchStartBody = pch ;


	//
	//	Pointer to the end of the Header (if we find it !)
	//
	char	*pchEndHead = 0 ;

	//
	//	Number of bytes in the completed read which are part of the article -
	//	this includes any bytes in the header, so cbArticleBytes should always
	//	be greater or equal to cbHeadBytes !
	//
	DWORD	cbArticleBytes = 0 ;

	//
	//	Are we finished receiving the article !
	//
	BOOL	fFinished = FALSE ;

	//
	//	Try to determine if we have found the end of the article ;
	//
	//
	//	We are not scanning for the end of the article headers !
	//	so keep the loop simpler !
	//
	if( m_pchErrorMatch )	{
		//
		//	We are simultaneously scanning for the end of the
		//	article headers !
		//
		while( pch < pchEnd ) {

			//
			//	We will break out of the loop when we find the end of the
			//	header !
			//
			if( *pch == *m_pchErrorState ) {
				m_pchErrorState ++ ;
				if( *m_pchErrorState == '\0' ) {	
					fFinished = TRUE ;
					pch++ ;
					//
					//	break here - we have found the end of the article's header
					//	but not the end of the article, so the following loop
					//	will keep looking for that !
					//
					break ;
				}
			}	else	{
				if( *pch == m_pchErrorMatch[0] ) {
					m_pchErrorState = &m_pchErrorMatch[1] ;
				}	else	{
					m_pchErrorState = &m_pchErrorMatch[0] ;
				}
			}
			//
			//	Test to see if we have come to the end of the article !!
			//
			if( *pch == *m_pchTailState ) {
				m_pchTailState ++ ;
				if( *m_pchTailState == '\0' ) {
					fFinished = TRUE ;
					//
					//	Have got the entire terminating sequence - break !
					//
					pch++ ;
					break ;
				}
			}	else	{
				if( *pch == m_pchMatch[0] ) {
					m_pchTailState = &m_pchMatch[1] ;
				}	else	{
					m_pchTailState = &m_pchMatch[0] ;
				}
			}
			pch++ ;
		}
	}	else	{
		while( pch < pchEnd ) {
			if( *pch == *m_pchTailState ) {
				m_pchTailState ++ ;
				if( *m_pchTailState == '\0' ) {
					fFinished = TRUE ;
					//
					//	Have got the entire terminating sequence - break !
					//
					pch++ ;
					break ;
				}
			}	else	{
				if( *pch == m_pchMatch[0] ) {
					m_pchTailState = &m_pchMatch[1] ;
				}	else	{
					m_pchTailState = &m_pchMatch[0] ;
				}
			}
			pch++ ;
		}
	}

	cbArticleBytes = (DWORD)(pch-pchStart) ;

	//
	//	Check to see whether we need to remove CIOGetArticleEx from
	//	its flow control state !
	//
	if( pRead->m_dwExtra1 != 0 ) {
		//
		//	This Read was issued by the thread that completes writes to
		//	a file, and was marked to indicate we should leave our flow
		//	control state !
		//
		m_fFlowControlled = FALSE ;
		m_cFlowControlled = LONG_MIN ;
	}
	//
	//	Issue a new read if Necessary !!
	//
	BOOL	eof ;
	if( !fFinished )	{
		if( InterlockedIncrement( &m_cFlowControlled ) < 0 ) {
			if( sign < 0 ) {
				do	{
					CReadPacket*	pNewRead=pRead->m_pOwner->CreateDefaultRead( cbLargeRequest ) ;
					if( pNewRead )	{
						pNewRead->m_dwExtra1 = 0 ;
						pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;
					}	else	{
						// bugbug ... Need better Error handling !!
						_ASSERT( 1==0 ) ;
					}
				}	while( InterlockedIncrement( &m_cReads ) < 0 ) ;
			}
		}
	}

	//
	//	We can do some validation here !
	//	dont go past the end of the buffer !
	//
	_ASSERT( pch <= pchEnd ) ;	
	//
	//	either find the end of the article or examine all the bytes in buffer !
	//
	_ASSERT( *m_pchTailState == '\0'
				|| pch == pchEnd
				|| (m_pchErrorMatch != 0 && m_pchErrorState != 0 && *m_pchErrorState == '\0' ) ) ;	
	_ASSERT( fFinished || pch == pchEnd ) ;
	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	//
	//	Boolean indicating whether we have examined and used all the bytes
	//	in the completed read.  Start out assuming that we haven't.
	//	
	BOOL	fConsumed = FALSE ;

	//
	//	Are we still trying to accumulate all the bytes in the header of
	//	the article ? If so save the bytes away,
	//	Or if we have a bunch of room in the header buffer, then put
	//	whatever article bytes we have in there as well !
	//
	DWORD	cbAvailable = HeaderSpaceAvailable() ;
	if( !m_pFileDriver && !m_fSwallow ) 	{
		m_cwrites = 0 ;
		if( m_pArticleHead != 0 ) {

			if( cbAvailable > cbArticleBytes ||
				GetBiggerHeaderBuffer( *pRead->m_pOwner, cbArticleBytes ) ) {
				fConsumed = TRUE ;
				FillHeaderSpace( pchStart, cbArticleBytes ) ;	
				pchStartBody += cbArticleBytes ;
	
			}	else	{
	
				//
				//	Blow off whatever buffers we have - when we call
				//	the m_pState's completion function we will indicate
				//	that we had an error !
				//
//				if( !ResetHeaderState( *pRead->m_pOwner ) ) {
					//
					//	A fatal error !!! Can't open a file to hold the article !!!
					//
					pRead->m_pOwner->UnsafeClose(	pSocket,
														CAUSE_OOM,
													GetLastError(),
													TRUE
													) ;
						pio = 0 ;
					return	cbArticleBytes ;
//				}
			}
		}	else	{
			//
			//	First time we've completed a read - set up to hold the
			//	header information !
			//		
			fConsumed = TRUE ;	
			InitializeHeaderSpace( pRead, cbArticleBytes ) ;			
		}
		if( fFinished ) {
			//
			//	Must terminate for one of these reasons !
			//
			_ASSERT( *m_pchTailState == '\0' ||
						(m_pchErrorState != 0 && *m_pchErrorState == '\0') ) ;
			BOOL	fGoodMatch = *m_pchTailState == '\0' ;
			//
			//	Received the entire article into a buffer -
			//	lets call the state and let him know !
			//
			//	First however - we will check to see whether we
			//	need to get our client a separate buffer
			//	so that they have play room !
			//
			CBUFPTR	pTemp = m_pArticleHead ;
			if( pTemp == pRead->m_pbuffer ) {
				//
				//	Oh-oh - we're using the IO buffer directly -
				//	we should make sure we get to use the whole
				//	thing - if not make a copy !!
				//
				if( pch != pchEnd ) {
					//
					//	Need to make a copy of the data !
					//
					if( GetBiggerHeaderBuffer( *pRead->m_pOwner, 0 ) ) {
						pTemp = m_pArticleHead ;
					}	else	{
						//
						//	OUT of Memory ! this is a FATAL error !
						//
						pRead->m_pOwner->UnsafeClose(	pSocket,
													CAUSE_OOM,
													__LINE__,
													TRUE
													) ;
					}
				}
			}
			DWORD	ibStart = m_ibStartHeadData ;
			DWORD	cb = m_ibEndHeadData - ibStart ;
			//
			//	Reset all our member variables -
			//	we may be re-used by the calling state
			//	but we want to start our clean !
			//
			m_pchTailState = 0 ;
			m_pchMatch = 0 ;
			m_pArticleHead = 0 ;
			m_ibStartHead = 0 ;
			m_ibEndHead = 0 ;
			m_ibStartHeadData = 0 ;
			m_ibEndHeadData = 0 ;
			_ASSERT( m_cwrites == 0 ) ;
			_ASSERT( !m_fFlowControlled ) ;
			_ASSERT( m_pWrite == 0 ) ;
			_ASSERT( FValid() ) ;

			//
			//	Errors could have caused us to not have a usable buffer
			//	so double check before completing !
			//
			if( pTemp ) 	{
				pio = m_pState->Complete(	this,
										pSocket,
										fGoodMatch,
										pTemp,
										ibStart,
										cb
										) ;
			}


			_ASSERT( FValid() ) ;

		}	
		//
		//	This is the number of bytes we've consumed
		//	from the current packet !
		//
		return	cbArticleBytes ;
	}	else	if( m_fSwallow ) 	{
		//
		//	If we are swallowing all the bytes, all we need to do
		//	is see if we're terminated !
		//
		if( fFinished ) 	{
			_ASSERT( *m_pchTailState == '\0' ||
						(m_pchErrorState != 0 && *m_pchErrorState == '\0') ) ;
			pio = m_pState->Complete(	this,
										pSocket	
										) ;

		}
		return	cbArticleBytes ;
	}

	//
	//	If we enter this portion of CIOGetArticleEx than
	//	we are not picking up errors !
	//
	_ASSERT( m_pchErrorState == 0 ) ;
	_ASSERT( m_pchErrorMatch == 0 ) ;

	//
	//	Issue a write, unless the user is sending small packets,
	//	in which case we will accumulate the data !!
	//
	//
	//	Note - use pchStartBody in all calculations here, as we may have
	//	taken a fraction of the bytes into our header buffer !!
	//
	if (fFinished) {
        pio = 0;
	    unsigned	cbSmall = (unsigned)(pch - pchStart) ;

	    //
	    // Grab the write packet for later use
	    //
	    CWritePacket* pWrite = m_pWrite;
	    m_pWrite = 0;
	    
        //
        // If we have a buffer and the data will fit in it, copy it in.
        //
        if (pWrite != 0 && ((pWrite->m_ibEnd - pWrite->m_ibEndData) > cbSmall)) {
		    CopyMemory( pWrite->EndData(), pchStart, cbSmall ) ;
		    pWrite->m_ibEndData += cbSmall ;
            m_cwrites -- ;		// There will never be a corresponding write for this completiong
    	    				    // as we copied the data into another buffer. SO decrement the count.
        } else {
            //
            // If we're here, then we don't have a buffer, or it's not big
            // enough for the data.
            //
            if (pWrite != 0) {
                // Flush the old buffer since we had one.
                DoFlowControl(INST(pSocket));
                m_pFileDriver->IssuePacket(pWrite, pSocket, eof);
            }

            // Allocate a new buffer

            unsigned ibEnd = pRead->m_ibStartData + cbSmall;
            pWrite = m_pFileDriver->CreateDefaultWrite(
                pRead->m_pbuffer,
                pRead->m_ibStartData, ibEnd,
                pRead->m_ibStartData, ibEnd);

            if (pWrite) {
                pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart);
                _ASSERT(pWrite->m_ibStartData < pWrite->m_ibEndData);
            } else {
                pRead->m_pOwner->UnsafeClose(pSocket, CAUSE_OOM, GetLastError(), TRUE);
            }
        }

        //
        // Buffers have been set up as needed.  Flush them to disk
        //
        // Hack so that we call FIOWriteFileEx correctly within
        // CFileChannel::Write
        //
        if (pWrite) {
            pWrite->m_dwExtra2 = 1;
            DoFlowControl(INST(pSocket));
            m_pFileDriver->IssuePacket(pWrite, pSocket, eof);
        }


        _ASSERT(eof == FALSE);
        _ASSERT(*m_pchTailState == '\0');
        _ASSERT(pchStart == pRead->StartData());
        _ASSERT(pchEnd == pRead->EndData());

        m_pFileChannel->FlushFileBuffers();
        return (int)(pch - pchStart);
    } else {

	    unsigned	cbSmall = (unsigned)(pchEnd - pchStartBody) ;
	    if( cbSmall < cbTooSmallWrite )	{
		    if( m_pWrite == 0 )	{
			    m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
			    if (m_pWrite == NULL) {
            		pRead->m_pOwner->UnsafeClose(pSocket,
						CAUSE_OOM,
						GetLastError(),
						TRUE
						) ;
			        return 0;
			    }
			    m_pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart) ;
		    }	else	{
			    if( (m_pWrite->m_ibEnd - m_pWrite->m_ibEndData) > cbSmall )		{
				    CopyMemory( m_pWrite->EndData(), pchStartBody, cbSmall ) ;
				    m_pWrite->m_ibEndData += cbSmall ;
                    m_cwrites -- ;		// There will never be a corresponding write for this completiong
				    				    // as we copied the data into another buffer. SO decrement the count.
			    }	else	{
				    //
				    //	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
				    //  our destructor if an error has occurred !!
				    //
	                // BUGBUG: Here is where I want to check size and alloc 32k
				    CWritePacket*	pTempWrite = m_pWrite ;
				    m_pWrite = 0 ;
				    DoFlowControl( INST(pSocket) ) ;
				    m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
				    m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
			    }
		    }
		    // If we came through here we should have consumed all bytes in the packet!
		    _ASSERT( pch == pchEnd ) ;
		    _ASSERT( unsigned(pch - pchStart) == pRead->m_cbBytes ) ;
            return	(int)(pch - pchStart) ;
	    }
    }

	if( m_pWrite )	{
		CWritePacket*	pTempWrite = m_pWrite ;
		m_pWrite = 0 ;

		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
	}
	

	CWritePacket*	pWrite = 0 ;
	if( pch == pchEnd )		{
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead ) ;
	}	else	{
		unsigned	ibEnd = pRead->m_ibStartData + (unsigned)(pch - pchStart) ;
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead->m_pbuffer,
						pRead->m_ibStartData, ibEnd,
						pRead->m_ibStartData, ibEnd ) ;
	}

	if( pWrite )	{

		//
	    //	It is possible that long before we reached here we took a portion
    	//	of this packet and placed it into our header buffer - so adjust for that
	    //	if it occurred !!
    	//
	    pWrite->m_ibStartData += (unsigned)(pchStartBody - pchStart) ;

    	_ASSERT( pWrite->m_ibStartData < pWrite->m_ibEndData ) ;

		DoFlowControl( INST(pSocket) ) ;
		//
		//	Hack so that we call FIOWriteFileEx correctly within 
		//	CFileChannel::Write !
		//
		if( fFinished ) 	{
			pWrite->m_dwExtra2 = 1 ;
		}
		m_pFileDriver->IssuePacket( pWrite, pSocket, eof ) ;

	}	else	{

		pRead->m_pOwner->UnsafeClose(	pSocket,
										CAUSE_OOM,
										GetLastError(),
										TRUE
										) ;

	}
	_ASSERT( eof == FALSE ) ;

	if( fFinished )	{
		_ASSERT( *m_pchTailState == '\0' ) ;
		m_pFileChannel->FlushFileBuffers() ;
	}

	//
	//	Nodbody should modify pchStart or pchEnd after initialization !
	//
	_ASSERT(	pchStart == pRead->StartData() ) ;
	_ASSERT(	pchEnd == pRead->EndData() ) ;

	return	(int)(pch - pchStart) ;
}

int	
CIOGetArticleEx::Complete(	CSessionSocket*	pSocket,	
							CWritePacket *pWrite,	
							CIO*&	pioOut ) {
/*++

Routine Description :

	Called whenever a write to a file completes.
	We must determine whether we have completed all the writes
	we are going to do and if so call the state's completion function.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet that was writtne to the file.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	TraceFunctEnter( "CIOGetArticleEx::Complete" ) ;

	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pWrite != 0 ) ;
	_ASSERT( pioOut == this ) ;

	m_cwritesCompleted++ ;

	long	cFlowControlled = 0 ;

	//
	//	Process the completion of a write to a file.
	//	determine whether we need to signal the entire transfer
	//	as completed.
	//

	if( *m_pchTailState == '\0' && m_cwritesCompleted == m_cwrites )	{

		// BUGBUG: loss of 64-bit precision
		DWORD	cbTransfer = DWORD( LOW(pWrite->m_iStream) + pWrite->m_cbBytes ) /*- m_pFileChannel-> */ ;
		FIO_CONTEXT*	pFIOContext= m_pFileChannel->ReleaseSource() ;
		_ASSERT( pFIOContext != 0 ) ;
		_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;

		m_pState->Complete(	this,
							pSocket,
							pFIOContext,
							cbTransfer
							) ;


		//
		//	NOT ALLOWED TO RETURIN A NEW IO OPERATION !!! Because this function is
		//	operating in a Channel which is temporary !!!
		//
		//	We do not set pioOut to zero, as we want the CIODriver to
		//	call out Shutdown function during its termination processing !
		//
		//	Now we must destroy our channels !!!
		//
		DebugTrace( (DWORD_PTR)this, "Closing File Driver %x ", m_pFileDriver ) ;
		Term( pSocket, FALSE ) ;
		DebugTrace( (DWORD_PTR)this, "deleting self" ) ;

	}	else	if( ( m_fFlowControlled ) ) {

		if( m_cwrites - m_cwritesCompleted <= RESTORE_FLOW && m_pSocketSink != 0 )	{
			//
			//	ALWAYS issue at least 1 read when coming out of a flow control state !!
			//

			CReadPacket*	pRead = 0 ;

			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );

			cFlowControlled = m_cFlowControlled + 1 ;
			while( cFlowControlled >= 1  ) {
				if( m_pSocketSink == 0 )
					break ;
				pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
				if( 0!=pRead )	{
					BOOL	eof ;
					InterlockedIncrement( &m_cReads ) ;
					pRead->m_dwExtra1 = 0 ;
					pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
				}	
				cFlowControlled -- ;
			}	

			//
			//	The following read is special - we set the m_dwExtra1 field so that
			//	the read completion code can determine that it is time to leave
			//	the flow control state !
			//
			pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
			if( 0!=pRead )	{
				BOOL	eof ;
				pRead->m_dwExtra1 = 1 ;
				InterlockedIncrement( &m_cReads ) ;
				pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
			}	else	{

				//
				//	Fatal error - drop the session !
				//
				m_pSocketSink->UnsafeClose(	pSocket,
											CAUSE_OOM,
											GetLastError(),
											TRUE
											) ;
				return	pWrite->m_cbBytes ;

			}
			cFlowControlled -- ;

			InterlockedExchange( &m_cFlowControlled, LONG_MIN ) ;
			// Set to FALSE after InterlockedExchange !!
			m_fFlowControlled = FALSE ;

		}
	}

	return	pWrite->m_cbBytes ;
}






//
//	Maximum number of pending reads while reading an article
//
unsigned	CIOReadArticle::maxReadAhead = 3 ;
//
//	Number of bytes to accumulate before writing to a file !
//
unsigned	CIOReadArticle::cbTooSmallWrite = 1024 ;


CIOReadArticle::CIOReadArticle( CSessionState*	pstate,
								CSessionSocket*	pSocket,	
								CDRIVERPTR&	pDriver,
								CFileChannel*	pFileChannel,
								DWORD			cbLimit,
								BOOL fPartial )	:
/*++

Routine Description :

	Class Constructor

Arguments :
	
	pstate - The State which is issuing us and who's completion function
			we should later call
	pSocket -	The socket on which we will be issued
	pDriver -	The CIODriver object handling all of the socket's IO
	pFileChannel -	The File Channel into which we should save all data
	fPartial	- If TRUE then we should assume that a CRLF has already
				been sent and '.\r\n' alone can terminate the article.

Return Value :
	
	None

--*/

	//
	//	Get a CIOReadArticle object half way set up - user still needs
	//	to call Init() but we will do much here !
	//
	CIORead( pstate ),
	m_pFileChannel( pFileChannel ),	
	m_pFileDriver( new CIODriverSink( pDriver->GetMediumCache() ) ),
	m_pSocketSink( pDriver ),
	m_fDriverInit( FALSE ),
	m_cwrites( 0 ),
	m_cwritesCompleted( 0 ),
	m_cFlowControlled( LONG_MIN ),
	m_fFlowControlled( FALSE ),
	m_cReads( 0 ),
	m_pWrite( 0 ),
	m_cbLimit( cbLimit )
#ifdef	CIO_DEBUG
	,m_fSuccessfullInit( FALSE ),
	m_fTerminated( FALSE )
#endif
{

	ASSIGNI( m_HardLimit, 0 );

	if( fPartial )
		m_artstate = BEGINLINE ;
	else	
		m_artstate = NONE ;

	TraceFunctEnter( "CIOReadArticle::CIOReadArticle" ) ;

	ErrorTrace( (DWORD_PTR)this, "CIOReadArticle - created file driver %x using channel %x", ((CIODriverSink*)m_pFileDriver), ((CFileChannel*)pFileChannel) ) ;

	_ASSERT( m_pFileDriver != 0 ) ;
	_ASSERT( pFileChannel != 0 ) ;
	_ASSERT( pstate != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pDriver != 0 ) ;
	_ASSERT(	!m_pFileChannel->FReadChannel() ) ;
}

CIOReadArticle::~CIOReadArticle( )	{
/*++

Routine Description :

	Class Destructor

Arguments :
	
	None

Return Value :
	
	None

--*/

	//
	//	Destroy a CIOReadArticle - always close our m_pFileDriver if possible
	//	in case we are terminated due to some socket error.
	//
	TraceFunctEnter( "CIOReadArticle::~CIOReadArticle" ) ;

#ifdef	CIO_DEBUG
	//
	//	Our destructor should only be called if we weren't successfully init
	//	or after Term() has been called.
	//
	_ASSERT( !m_fSuccessfullInit || m_fTerminated ) ;
#endif

	DebugTrace( (DWORD_PTR)this, "m_pFileDriver %x m_fDriverInit %x", m_pFileDriver, m_fDriverInit ) ;

	if( m_pFileDriver != 0 ) {
		if( m_fDriverInit )		{
			m_pFileDriver->UnsafeClose( (CSessionSocket*)this, CAUSE_NORMAL_CIO_TERMINATION, 0, FALSE ) ;
		}
	}
	if( m_pWrite != 0 ) {
		CPacket::DestroyAndDelete( m_pWrite ) ;
		m_pWrite = 0 ;
	}
}

BOOL
CIOReadArticle::Init(	CSessionSocket* pSocket,
						unsigned cbOffset )	{
/*++

Routine Description :

	Initialize object.

Arguments :

	pSocket - The socket we are reading the article from,
	cbOffset -  Unused

Return Value :

	TRUE if succesfull initialized - must be destroyed with a call to Term()
	FALSE if not successfully initialized - do not call Term()


--*/
	//
	//	Prepare to copy from the specified socket into the specified file
	//
	BOOL	fRtn = FALSE ;
	if( m_pFileDriver!= 0 )	{
		if( m_pFileDriver->Init( m_pFileChannel, pSocket, ShutdownFunc, (void*)this ) )	{
			m_fDriverInit = TRUE ;
			if( !m_pFileDriver->SendWriteIO( pSocket, *this, FALSE ) )	{
				fRtn = FALSE ;
			}	else	{
				fRtn = TRUE ;
#ifdef	CIO_DEBUG
				m_fSuccessfullInit = TRUE ;
#endif				
			}
		}	
	}	
	return	fRtn ;
}

void
CIOReadArticle::Term(	CSessionSocket*	pSocket,
						BOOL			fAbort,
						BOOL			fStarted	)	{
/*++

Routine Description :

	Start destroying a successfully initialize CIOReadArticle object

Arguments :
	
	fAbort - If TRUE then destroy the socket which we were using
			If FALSE then only close down our File Channel's

Return Value :

	None

--*/
#ifdef	CIO_DEBUG
	m_fTerminated = TRUE ;
#endif
	//
	//	Start us on our way to destruction !!
	//	If we have been successfully Initialized, then this will
	//	lead to our destruction when our m_pFileDriver eventually shutsdown.
	//	(Since we were succesfully Init() our m_pFileDriver has a reference to us,
	//	so we must allow it to shutdown and destroy us to avoid problems with
	//	circular references and multiple frees !)
	//

	if( m_pFileDriver != 0 ) {
		m_pFileDriver->UnsafeClose( pSocket,
				fAbort ? CAUSE_USERTERM : CAUSE_NORMAL_CIO_TERMINATION, 0, FALSE ) ;
	}
}


void
CIOReadArticle::Shutdown(	CSessionSocket*	pSocket,	
							CIODriver&		driver,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dwOptional )	{
/*++

Routine Description :

	Do whatever work is necessary when one of the two CIODriver's we are
	using is terminated.

Arguments :

	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	TRUE if the CIO object should be destroyed after this, FALSE otherwise

--*/

	TraceFunctEnter( "CIOreadArticle::Shutdown" ) ;
	DebugTrace( (DWORD_PTR)this, "SHutdown args - pSocket %x driver %x cause %x dw %x",
			pSocket, &driver, cause, dwOptional ) ;

	//
	//	This function is called when the CIODriver's we are refenced by our closing down.
	//	Since we are referenced by two of them (one for the socket and one for the file)
	//	we only want to be deleted by the CIODriver for the file.
	//
	if( &driver == m_pFileDriver )	{
		// Out file is closing - what can we do about it !
		//_ASSERT( 1==0 ) ;
#ifdef	CIO_DEBUG
		m_fTerminated = TRUE ;
#endif

		//
		//	We set this to 0 here as we know we will be called here by
		//	the same thread that is completing writes to the file - so
		//	since that's the only thread referencing this member variable -
		//	there are no thread safety issues accessing that member.
		//

		m_pSocketSink = 0 ;

		if ( m_fFlowControlled )
		{
			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );
		}

		//return	TRUE ;

	}	else	{
		// Close down the rest of our stuff as well !!
		Term( pSocket, cause != CAUSE_NORMAL_CIO_TERMINATION ) ;
	}
}

void
CIOReadArticle::ShutdownFunc(	void *pv,	
								SHUTDOWN_CAUSE	cause,	
								DWORD dw ) {
/*++

Routine Description :

	Notification function which is called when a CIODriver used by
	a CIOReadArticle if finally destroyed.  This function is provided
	to the CIODriver we use for File IO's during out Init().

Arguments :

	pv	-	Pointer to dead CIOReadArticle - this has been destroyed dont use !
	cause -	The reason for termination
	dw		Optional extra information regarding termination

Return Value :

	None

--*/

	TraceFunctEnter( "CIOreadArticle::ShutdownFunc" ) ;
	//
	//	This function gets notified when a CIOFileDriver used by CIOReadArticle
	//	is terminated.  Not much for us to worry about.
	//	(CIODriver's require these functions)
	//

	//_ASSERT( 1==0 ) ;
	return ;
}

BOOL
CIOReadArticle::Start(	CIODriver&	driver,	
						CSessionSocket	*pSocket,	
						unsigned cReadAhead )	{
/*++

Routine Description :

	This function is called to start transferring data from the socket
	into the file.

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/


	_ASSERT( pSocket != 0 ) ;

	m_cReads = -((long)maxReadAhead) + cReadAhead ;

	while( cReadAhead < maxReadAhead )	{
		//
		//	Start reading data from the socket
		//
		CReadPacket*	pRead = driver.CreateDefaultRead( cbMediumRequest ) ;
		if( 0!=pRead )	{
			BOOL	eof ;
			pRead->m_dwExtra1 = 0 ;
			driver.IssuePacket( pRead, pSocket, eof ) ;
			cReadAhead++ ;
			InterlockedIncrement( &m_cReads ) ;
		}	else	{
			//
			// This is a fatal problem only if we couldn't issue ANY reads at all !
			//
			if( cReadAhead == 0 )
				return FALSE  ;
		}
	}	
	return	TRUE ;
}


void
CIOReadArticle::DoFlowControl(PNNTP_SERVER_INSTANCE pInstance)	{
/*++

Routine Description :

	Check whether it is necessary to set flow control due to
	too many outstanding writes.
	If necessary, then the first time we do put ourselves into Flow Control,
	try to flush our pending writes.
	We should be called only immediately before issuing an Async Write to the file
	to ensure that a CWritePacket completion will actually execute the necessary
	code to restart a flow controlled session.
	(Otherwisse, we could potentially decide to Flow control the session
	and before setting m_fFlowControlled to TRUE all the pending writes complete
	and then we'd be left in a boat where there are no pending reads or
	writes and no way to get out of the flow control state.)

Arguments :

	None.

Return Value :

	None.


--*/

	//
	//	Important - do all tests of m_fFlowControlled before setting
	//	m_cFlowControlled - as other thread will touch m_cFlowControlled
	//	before touching m_fFlowControlled !!
	//	(Will only touch m_fFlowControlled if m_fFlowControlled is TRUE ) !
	//	Thus we know that if m_fFlowControlled is FALSE there is nobody
	//	messing with m_cFlowControlled,
	//
	//

	if( m_cwrites - m_cwritesCompleted > MAX_OUTSTANDING_FILE_WRITES ) {
		
		if( m_fFlowControlled ) {
			// All ready have flow control turned on
			;
		}	else	{
			m_cFlowControlled = -1 ;
			m_fFlowControlled = TRUE ;
			m_pFileChannel->FlushFileBuffers() ;

			IncrementStat( pInstance, SessionsFlowControlled );
		}
	}	else	{
		if( !m_fFlowControlled ) {
			m_cFlowControlled = LONG_MIN ;	// Keep resetting !
		}
	}
}

int
CIOReadArticle::Complete(	CSessionSocket*	pSocket,	
							CReadPacket	*pRead,	
							CIO*&	pio	)	{
/*++

Routine Description :

	Called whenever a CReadPacket we have issued completes.
	We only issue packets against the socket.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	//
	//	This function determines whether we've read an entire article and if so
	//	starts wrapping things up.
	//	All article data we get is either accumulated or issued as a write
	//	to our file.
	//

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	pRead != 0 ) ;
	_ASSERT( pio == this ) ;

	ASSIGNI(m_HardLimit, m_cbLimit);
	if(!EQUALSI(m_HardLimit, 0)) {
		if( GREATER( pRead->m_iStream, m_HardLimit ) ) {
			pRead->m_pOwner->UnsafeClose(	pSocket,
											CAUSE_ARTICLE_LIMIT_EXCEEDED,
											0,
											TRUE ) ;
			return	pRead->m_cbBytes ;
		}
	}


	//
	//	Bump the count of writes because we KNOW that IF this is the last read
	//	we will issue a write, CONSEQUENTLY we don't want to confuse the Write Completion
	//	function as to when we are finished.
	//	(It is important to increment before we set the COMPLETE state so that the
	//	thread where writes are completing doesn't get confused and terminate early.)
	//
	//	NOW there is a chance that we won't write this out immediately - in which case we
	//	need to have a matching decrement.	
	//
	long sign = InterlockedDecrement( &m_cReads ) ;
	long signShutdowns = -1 ;
	m_cwrites ++ ;
	_ASSERT( m_cwrites > 0 ) ;

	char	*pch = pRead->StartData();
	char	*pchStart = pch ;
	char	*pchEnd = pRead->EndData() ;
	while(	pch < pchEnd )	{
		if( *pch =='.' && m_artstate == BEGINLINE )	{
			m_artstate = PERIOD ;
		}	else	if( *pch == '\r' )	{
			if( m_artstate == PERIOD )
				m_artstate = COMPLETENEWLINE ;
			else
				m_artstate = NEWLINE ;
		}	else	if( *pch == '\n' )	{
			if( m_artstate == COMPLETENEWLINE ) {
				m_artstate = COMPLETE ;
				pch++ ;		// so that pch points one past end of article !
				break ;
			}	else	if(	m_artstate == NEWLINE )	{
				m_artstate = BEGINLINE ;
			}	else	{
				m_artstate = NONE ;
			}
		}	else	{
			m_artstate = NONE ;
		}
		pch ++ ;
	}
	_ASSERT( pch <= pchEnd ) ;
	_ASSERT( m_artstate == COMPLETE || pch == pchEnd ) ;	// If the article ain't complete
														// then ALL bytes better be consumed !

	//
	//	Check to see whether we need to remove CIOReadArticle from
	//	its flow control state !
	//
	if( pRead->m_dwExtra1 != 0 ) {
		//
		//	This Read was issued by the thread that completes writes to
		//	a file, and was marked to indicate we should leave our flow
		//	control state !
		//
		m_fFlowControlled = FALSE ;
		m_cFlowControlled = LONG_MIN ;
	}
		

	//
	//	Issue a new read if Necessary !!
	//
	BOOL	eof ;
	if( m_artstate != COMPLETE )	{
		if( InterlockedIncrement( &m_cFlowControlled ) < 0 ) {
			if( sign < 0 ) {
				do	{
					CReadPacket*	pNewRead=pRead->m_pOwner->CreateDefaultRead( cbMediumRequest ) ;
					if( pNewRead )	{
						pNewRead->m_dwExtra1 = 0 ;
						pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;
					}	else	{
						// bugbug ... Need better Error handling !!
						_ASSERT( 1==0 ) ;
					}
				}	while( InterlockedIncrement( &m_cReads ) < 0 ) ;
			}
		}
	}	else	{
		pio = 0 ;
		//m_pFileChannel->FlushFileBuffers() ;
	}


	//
	//	Issue a write, unless the user is sending small packets,
	//	in which case we will accumulate the data !!
	//
	if( m_artstate != COMPLETE )	{
		unsigned	cbSmall = (unsigned)(pchEnd - pchStart) ;
		if( cbSmall < cbTooSmallWrite )	{
			if( m_pWrite == 0 )	{
				m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
			}	else	{
				if( (m_pWrite->m_ibEnd - m_pWrite->m_ibEndData) > cbSmall )		{
					CopyMemory( m_pWrite->EndData(), pchStart, cbSmall ) ;
					m_pWrite->m_ibEndData += cbSmall ;
					m_cwrites -- ;		// There will never be a corresponding write for this completiong
										// as we copied the data into another buffer. SO decrement the count.
				}	else	{
					//
					//	Must take care how we call IssuePacket with memeber vars - IssuePacket can call
					//  our destructor if an error has occurred !!
					//
					CWritePacket*	pTempWrite = m_pWrite ;
					m_pWrite = 0 ;
					DoFlowControl( INST(pSocket) ) ;
					m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
					m_pWrite = m_pFileDriver->CreateDefaultWrite( pRead ) ;
				}
			}
		// If we came through here we should have consumed all bytes in the packet!
		_ASSERT( pch == pchEnd ) ;
		_ASSERT( unsigned(pch - pchStart) == pRead->m_cbBytes ) ;
		return	(int)(pch - pchStart) ;
		}
		
	}

	if( m_pWrite )	{
		CWritePacket*	pTempWrite = m_pWrite ;
		m_pWrite = 0 ;

		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pTempWrite, pSocket, eof ) ;
	}
	

	CWritePacket*	pWrite = 0 ;
	if( pch == pchEnd ) 		
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead ) ;
	else	{
		unsigned	ibEnd = pRead->m_ibStartData + (unsigned)(pch - pchStart) ;
		pWrite = m_pFileDriver->CreateDefaultWrite(	pRead->m_pbuffer,
						pRead->m_ibStartData, ibEnd,
						pRead->m_ibStartData, ibEnd ) ;
	}
	if( pWrite )	{
		DoFlowControl( INST(pSocket) ) ;
		m_pFileDriver->IssuePacket( pWrite, pSocket, eof ) ;

	}	else	{
		// Bug bug .... Error Handling Required
		_ASSERT( 1==0 ) ;
	}
	_ASSERT( eof == FALSE ) ;

	if( m_artstate == COMPLETE )	{
		m_pFileChannel->FlushFileBuffers() ;
	}

	return	(int)(pch - pchStart) ;
}

int	
CIOReadArticle::Complete(	CSessionSocket*	pSocket,	
							CWritePacket *pWrite,	
							CIO*&	pioOut ) {
/*++

Routine Description :

	Called whenever a write to a file completes.
	We must determine whether we have completed all the writes
	we are going to do and if so call the state's completion function.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet that was writtne to the file.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	TraceFunctEnter( "CIOReadArticle::Complete" ) ;

	_ASSERT(	pSocket != 0 ) ;
	_ASSERT(	pWrite != 0 ) ;
	_ASSERT( pioOut == this ) ;

	m_cwritesCompleted++ ;

	long	cFlowControlled = 0 ;

	//
	//	Process the completion of a write to a file.
	//	determine whether we need to signal the entire transfer
	//	as completed.
	//

	if( m_artstate == COMPLETE && m_cwritesCompleted == m_cwrites )	{

		// BUGBUG: loss of precision in 64-bit arithmetic !!
		DWORD	cbTransfer = DWORD( LOW(pWrite->m_iStream) + pWrite->m_cbBytes ) ;

		m_pState->Complete( this, pSocket, pWrite->m_pOwner, *m_pFileChannel, cbTransfer ) ;
		//
		//	NOT ALLOWED TO RETURIN A NEW IO OPERATION !!! Because this function is
		//	operating in a Channel which is temporary !!!
		//

		//	We do not set pioOut to zero, as we want the CIODriver to
		//	call out Shutdown function during its termination processing !


		//
		//	Now we must destroy our channels !!!
		//

		DebugTrace( (DWORD_PTR)this, "Closing File Driver %x ", m_pFileDriver ) ;
		
		//m_pFileDriver->Close( pSocket,	CAUSE_LEGIT_CLOSE, 0, FALSE ) ;
		Term( pSocket, FALSE ) ;

		DebugTrace( (DWORD_PTR)this, "deleting self" ) ;

	}	else	if( ( m_fFlowControlled ) ) {

		if( m_cwrites - m_cwritesCompleted <= RESTORE_FLOW && m_pSocketSink != 0 )	{
			//
			//	ALWAYS issue at least 1 read when coming out of a flow control state !!
			//
			CReadPacket*	pRead = 0 ;

			PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
			DecrementStat( pInst, SessionsFlowControlled );

			cFlowControlled = m_cFlowControlled + 1 ;
			while( cFlowControlled >= 1  ) {
				if( m_pSocketSink == 0 )
					break ;
				pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
				if( 0!=pRead )	{
					BOOL	eof ;
					InterlockedIncrement( &m_cReads ) ;
					pRead->m_dwExtra1 = 0 ;
					pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
				}	
				cFlowControlled -- ;
			}	
			//
			//	The following read is special - we set the m_dwExtra1 field so that
			//	the read completion code can determine that it is time to leave
			//	the flow control state !
			//
			pRead = m_pSocketSink->CreateDefaultRead( cbMediumRequest ) ;
			if( 0!=pRead )	{
				BOOL	eof ;
				pRead->m_dwExtra1 = 1 ;
				InterlockedIncrement( &m_cReads ) ;
				pRead->m_pOwner->IssuePacket( pRead, pSocket, eof ) ;
			}	else	{

				//
				//	Fatal error - drop the session !
				//
				m_pSocketSink->UnsafeClose(	pSocket,
											CAUSE_OOM,
											GetLastError(),
											TRUE
											) ;
				return	pWrite->m_cbBytes ;

			}
			cFlowControlled -- ;

			//
			InterlockedExchange( &m_cFlowControlled, LONG_MIN ) ;
			// Set to FALSE after InterlockedExchange !!
			m_fFlowControlled = FALSE ;

		}
	}

	return	pWrite->m_cbBytes ;
}


char	CIOReadLine::szLineState[] = "\r\n" ;

CIOReadLine::CIOReadLine(
					CSessionState*	pstate,
					BOOL	fWatchEOF
					) :
	//
	//	Initialize a CIOReadLine object -
	//	set member variables to neutral values.
	//
	CIORead( pstate ),
	m_fWatchEOF( fWatchEOF ),
	m_pbuffer( 0 ),
	m_pchStart( 0 ),
	m_pchStartData( 0 ),
	m_pchEndData( 0 ),	
	m_pchEnd( 0 ),
	m_pchLineState( &szLineState[0] )	{


	TraceFunctEnter( "CIOReadLine::CIOReadLine" ) ;

	DebugTrace( (DWORD_PTR)this, "New CIOREadline on state %x", pstate ) ;
}

BOOL
CIOReadLine::Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead ) {
/*++

Routine Description :

	This function is called to start reading data from the socket

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/


	//
	//	Start issuing reads !
	//	only do so if there isn't any completed data waiting for us !
	//
	TraceFunctEnter( "CIOReadLine::Start" ) ;

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	m_pbuffer == 0 ) ;
	_ASSERT(	m_pchStart == 0 ) ;
	_ASSERT(	m_pchStartData == 0 ) ;
	_ASSERT(	m_pchEndData == 0 ) ;
	_ASSERT(	m_pchEnd == 0 ) ;

	DebugTrace( (DWORD_PTR)this, "cReadAhead %d driver& %x pSocket %x", cReadAhead, &driver, pSocket ) ;

	if( cReadAhead < 2 )	{

		unsigned	cLimit = 2 ;
		if( m_fWatchEOF ) {
			cLimit = 1 ;
		}

		while( cReadAhead < cLimit )	{
			//
			//	Start reading data from the socket
			//
			CReadPacket*	pRead = driver.CreateDefaultRead( cbSmallRequest ) ;
			if( 0!=pRead )	{
				BOOL	eof ;
				driver.IssuePacket( pRead, pSocket, eof ) ;
				cReadAhead++ ;
			}	else	{
				//
				// This is a fatal problem only if we couldn't issue ANY reads at all !
				//
				if( cReadAhead == 0 )
					return FALSE  ;
			}
		}	

	}	else	{

		driver.ResumeTimeouts() ;
	
	}
	return	TRUE ;
}

void
CIOReadLine::Shutdown(	CSessionSocket*	pSocket,	
						CIODriver&		driver,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We have nothing to worry about here - as long as our destuctor
	is called everything will be cleaned up.

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Alwasy TRUE - we want to be destroyed.

--*/

	//
	//	WE get notified here when the CIODriver is shutting down.
	//	there's not much to do but to tell the driver to destroy us
	//	when done.
	//
	TraceFunctEnter( "CIOReadLine::Shutdown" ) ;
}



int	CIOReadLine::Complete(	IN CSessionSocket*	pSocket,	
							IN CReadPacket*	pRead,	
							OUT	CIO*	&pioOut ) 	{
/*++

Routine Description :

	Called whenever a CReadPacket we have issued completes.
	We only issue packets against the socket.

Arguments :
	
	pSocket - The socket against which the IO was issued
	pRead -	  The packet in which the read data resides
	pioOut	- The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/

	TraceFunctEnter( "CIOReadLine::Complete" ) ;

	_ASSERT( pSocket != 0 ) ;
	_ASSERT(	pRead != 0 ) ;
	_ASSERT( pioOut != 0 ) ;

	char*	pchCurrent = pRead->StartData() ;
	char*	pchStart = pchCurrent ;
	char*	pchEnd = pRead->EndData() ;

	_ASSERT( pchStart != 0 ) ;
	_ASSERT(	pchEnd != 0 ) ;
	_ASSERT(	pchStart <= pchEnd ) ;
	_ASSERT( pchEnd == &pRead->m_pbuffer->m_rgBuff[ pRead->m_ibEndData ] ) ;

	//
	//	We just read some data on a socket - see if we have a complete line.
	//	If we don't, accumulate the data and make sure we have a buffer
	//	large enough to hold our max accumulation size.
	//
	//	NOTE : m_pbuffer is a reference counting smart pointer, so
	//	assigning to it will keep the buffers we are passed in CReadPackets
	//	from being destroyed and preserve them for our use !
	//

	DebugTrace( (DWORD_PTR)this, "pchCurrent %x pchStart %x pchEnd %x", pchCurrent, pchStart, pchEnd ) ;

Top :

	while( pchCurrent < pchEnd ) {

		if( *pchCurrent == *m_pchLineState ) {
			m_pchLineState ++ ;
			if( *m_pchLineState == '\0' ) {
				//
				//	Have got the entire terminating sequence - break !
				//
				pchCurrent++ ;
				break ;
			}
		}	else	{
			if( *pchCurrent == szLineState[0] ) {
				m_pchLineState = &szLineState[1] ;
			}	else	{
				m_pchLineState = &szLineState[0] ;
			}
		}
		pchCurrent++ ;
	}

	_ASSERT( pchCurrent <= pchEnd ) ;

	if( *m_pchLineState == '\0' )	{

		if( m_pbuffer != 0 )	{

			//
			//	If we have a buffer these must all be non-null !
			//
			_ASSERT( m_pchStartData && m_pchEndData && m_pchStart && m_pchEnd ) ;

			unsigned cb = (unsigned)(pchCurrent - pchStart)  ;
			if( cb  < (unsigned)(m_pchEnd - m_pchEndData) )	{

				CopyMemory( m_pchEndData, pchStart, cb )	;
				m_pchEndData += cb ;

			}	else	{
				
				//
				// ERROR COMPLETION !!! The line was TOOOO long
				//
				DWORD	ibZap = min( 50, (DWORD)(m_pchEnd - m_pchStartData) ) ;
				m_pchStartData[ibZap] = '\0' ;
	
				//
				//	just move the enddata pointer to be equal to the end - so that if
				//	we get called again we will always fail the completion !
				//

				pSocket->TransactionLog(	"Line too long",	m_pchStartData, NULL ) ;

				//
				//	Now kill the session ! - this will result in our desctructor getting
				//	called and everything getting cleaned up !
				//

				pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_CIOREADLINE_OVERFLOW, 0 ) ;

				//
				//	We will consume all the bytes, since we're dropping the session anyways !
				//
				return	pRead->m_cbBytes ;
			}
		}	else	{
	
			//
			//	Since we don't have a buffer these must all be Non-Null !
			//
			_ASSERT( !m_pchStartData && !m_pchEndData && !m_pchStart && !m_pchEnd ) ;

			//
			//	Did we get a CRLF alone on a line ?? if so ignore it !
			//

			if( (pchCurrent - pchStart) == (sizeof( CIOReadLine::szLineState ) - 1) )		{
				m_pchLineState = &szLineState[0] ;
				goto	Top ;
			}

			//
			//	Set up these members to point at the current line !
			//
			m_pbuffer = pRead->m_pbuffer ;
			m_pchStart = pRead->Start() ;
			m_pchStartData = pchStart ;
			m_pchEndData = pchCurrent ;
			m_pchEnd = pchCurrent ;
		}

		//
		//	Now have a complete line of text - strip white space and make
		//	array of string pointers !
		//
		_ASSERT(	m_pbuffer && m_pchStart && m_pchStartData &&
					m_pchEndData && m_pchEnd ) ;
		_ASSERT( m_pchEndData <= m_pchEnd ) ;

		char	*rgsz[ MAX_STRINGS ] ;

		ZeroMemory( rgsz, sizeof( rgsz ) ) ;
		int		isz = 0 ;

		for(	char	*pchT = m_pchStartData;
						pchT < m_pchEndData;
						pchT ++ ) {

			if( isspace( (BYTE)*pchT ) || *pchT == '\0' )	{
				*pchT = '\0' ;
				if( rgsz[isz] != 0 ) {

					_ASSERT( strpbrk( rgsz[isz], "\r\n\t " ) == 0  ) ;

					if( (isz+1) < MAX_STRINGS )
						isz ++ ;
				}
			}	else	{
				if( rgsz[isz] == 0 ) {
					rgsz[isz] = pchT ;
				}	else if( (isz+1) == MAX_STRINGS &&
								pchT[-1] == '\0' ) {
					rgsz[isz] = pchT ;
				}
			}
		}

		DebugTrace( (DWORD_PTR)this, "call state %x with 1st arg %s", m_pState, rgsz[0] ? rgsz[0] : "(NULL)" ) ;

		CIO	*pio = this ;
		if( isz != 0 )	{
			pio = m_pState->Complete( this, pSocket, pRead->m_pOwner, isz, rgsz, m_pchStart ) ;

			//
			//	Reset our state entirely regardless of return value.
			//
			m_pbuffer = 0 ;
			m_pchStartData = 0 ;
			m_pchEndData = 0 ;
			m_pchEnd = 0 ;
			m_pchStart = 0 ;
		}

		//
		//	At this point we should always be preparing to examine a new line of text !
		//	If the user spews CRLF's at us we want to keep resetting our state.  Meantime
		//	all those CRLF's will fill our buffer, and if they send to many we will drop
		//	the connection !!
		//
		m_pchLineState = &szLineState[0] ;

		unsigned	cbReturn = (unsigned)(pchCurrent - pchStart) ;

		_ASSERT( cbReturn <= pRead->m_ibEndData - pRead->m_ibStartData ) ;

		pioOut = pio ;
		if( pioOut != this ) {
			DebugTrace( (DWORD_PTR)this, "New pio is %x - delete self", pioOut ) ;
		}	else	{
			if( cbReturn == pRead->m_cbBytes )	{
				//
				//	Have exactly exhausted the current buffer - need to issue another
				//	read.
				//
				_ASSERT( pchCurrent == pchEnd ) ;
				CReadPacket*	pNewRead	= pRead->m_pOwner->CreateDefaultRead( cbSmallRequest ) ;
				if( pNewRead )	{
					BOOL	eof ;
					pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;			
				}	else	{
					pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
				}
			}
		}
		return	cbReturn ;
	}	else	{

		DebugTrace( (DWORD_PTR)this, "No Newline in line m_pbuffer %x m_pchEndData %x m_pchStart %x",
			m_pbuffer, m_pchStartData, m_pchEndData ) ;

		_ASSERT( pchCurrent >= pchStart ) ;
		_ASSERT( pchCurrent <= pchEnd ) ;
		_ASSERT( pchEnd == &pRead->m_pbuffer->m_rgBuff[ pRead->m_ibEndData ] ) ;

		if( m_pbuffer != 0 )		{
			DWORD	cbToCopy = (DWORD)(pchEnd - pchStart) ;
			if( cbToCopy + m_pchEndData >= m_pchEnd ) {
				//
				//	The command line is to long to be processed - blow off the session !
				//			

				//
				//	Null terminate whats in our buffer and log it - just give the log the
				//	first 50 bytes of whatever was coming across !
				//
				DWORD	ibZap = min( 50, (DWORD)(m_pchEnd - m_pchStartData) ) ;
				m_pchStartData[ibZap] = '\0' ;
				//	just move the enddata pointer to be equal to the end - so that if
				//	we get called again we will always fail the completion !
				m_pchEndData = m_pchEnd ;
				pSocket->TransactionLog(	"Line too long",	m_pchStartData, NULL ) ;

				//
				//	Now kill the session ! - this will result in our desctructor getting
				//	called and everything getting cleaned up !
				//
				
				pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_CIOREADLINE_OVERFLOW, 0 ) ;
				return	pRead->m_cbBytes ;
			}
			
			CopyMemory( m_pchEndData, pchStart, pchEnd - pchStart ) ;
			m_pchEndData += (pchEnd - pchStart) ;
		}	else	{
			if( ((pRead->m_ibEnd - pRead->m_ibEndData) < MAX_BYTES) )	{
				DWORD	cbOut = 0 ;

				DWORD	cbFront = 0 ;
				DWORD	cbTail = 0 ;
				pRead->m_pOwner->GetReadReserved( cbFront, cbTail ) ;

				m_pbuffer = new( REQUEST_BYTES+cbFront, cbOut )	CBuffer( cbOut ) ;

				if( m_pbuffer != 0 )		{
					m_pchEnd = &m_pbuffer->m_rgBuff[ m_pbuffer->m_cbTotal ] ;
					m_pchStart = &m_pbuffer->m_rgBuff[0] ;
					m_pchStartData = m_pchStart + cbFront ;
					CopyMemory( m_pchStartData,	pchStart, pchEnd - pchStart ) ;
					m_pchEndData =  m_pchStartData + (pchEnd - pchStart) ;
				}	else	{

					// ERROR COMPLETION !!!!
					_ASSERT( 1==0 ) ;
					pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
					return	pRead->m_cbBytes ;
				}
			}	else	{
				m_pbuffer = pRead->m_pbuffer ;
				m_pchStart = pRead->Start() ;
				m_pchStartData = pchStart ;
				m_pchEndData = pRead->EndData() ;
				m_pchEnd = pRead->End() ;
			}
		}
		_ASSERT( m_pchEndData <= m_pchEnd ) ;
		_ASSERT( m_pchStartData <= m_pchEndData ) ;
		_ASSERT( m_pchStartData >= m_pchStart ) ;
		_ASSERT(	m_pchEndData >= m_pchStartData ) ;
		_ASSERT( m_pchStart && m_pchStartData && m_pchEnd && m_pchEndData ) ;

		_ASSERT( unsigned(pchEnd - pchStart) == pRead->m_cbBytes ) ;

		CReadPacket*	pNewRead	= pRead->m_pOwner->CreateDefaultRead( cbSmallRequest ) ;
		DebugTrace( (DWORD_PTR)this, "Issued New Read Packet %d", pNewRead ) ;
		if( pNewRead )	{
			BOOL	eof ;
			pRead->m_pOwner->IssuePacket( pNewRead, pSocket, eof ) ;			
		}	else	{
			_ASSERT( 1==0 ) ;
			pRead->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
		}

		return	pRead->m_cbBytes ;	// Consumed everything !!
	}
	return	0 ;
}

unsigned	CIOWriteLine::cbJunk ;

CIOWriteLine::CIOWriteLine( CSessionState*	pstate ) :
	//
	//	Initialize to an illegal state - we require a call to InitBuffers()
	//
	CIOWrite( pstate ),
	m_pWritePacket( 0 ),
	m_pchStart( 0 ),
	m_pchEnd( 0 )	{

	TraceFunctEnter( "CIOWriteLine::CIOWriteLine" ) ;
	DebugTrace( (DWORD_PTR)this, "New CIOWriteLine" ) ;

}

CIOWriteLine::~CIOWriteLine( )	{
	//
	//	get rid of anything we're holding !
	//

	if( m_pWritePacket != 0 )	{
		//delete	m_pWritePacket ;
		CPacket::DestroyAndDelete( m_pWritePacket ) ;
	}
}

BOOL
CIOWriteLine::InitBuffers(	CDRIVERPTR&	pdriver,	
							unsigned	cbLimit )	{
/*++

Routine Description :

	This function is called to make the CIOWriteLine initialize all
	the buffers etc... it needs to hold the line we want to output.

Arguments :

	pdriver -	The driver against which we will be issued
	cbLimit	-	Maximum number of byte we will have to hold

Return Value :

	TRUE if successfull, FALSE otherwise

--*/
	_ASSERT( m_pWritePacket == 0 ) ;
	if( m_pWritePacket != 0 )	{
		return	FALSE ;
	}	else	{
		unsigned	cbOut = 0 ;
		//
		//	Get buffer big enough to hold cbLimit bytes of text !
		//

		m_pWritePacket = pdriver->CreateDefaultWrite( cbLimit ) ;
		if( m_pWritePacket != 0 )	{
			_ASSERT( m_pWritePacket->m_pbuffer != 0 ) ;
			m_pchStart = m_pWritePacket->StartData() ;
			m_pchEnd = m_pWritePacket->End() ;
			return	TRUE ;
		}
	}
	return	FALSE ;
}

BOOL
CIOWriteLine::InitBuffers(	CDRIVERPTR&	pdriver,
							CIOReadLine* pReadLine )	{
/*++

Routine Description :

	This function is called to give us a chance to allocate buffers etc... -
	We will be writing exactly what is in the CIOReadLine's buffers !!

Arguments :

	pdriver -	The driver against which we will be issued
	cbLimit	-	Maximum number of byte we will have to hold

Return Value :

	TRUE if successfull, FALSE otherwise

--*/
	_ASSERT(	pdriver != 0 ) ;
	_ASSERT( pReadLine != 0 ) ;
	_ASSERT( pReadLine->m_pbuffer != 0 ) ;
	_ASSERT(	pReadLine->m_pchStart != 0 ) ;
	_ASSERT(	pReadLine->m_pchEnd != 0 ) ;
	_ASSERT(	pReadLine->m_pchStart < pReadLine->m_pchEnd ) ;
	_ASSERT(	pReadLine->m_pchStart >= &pReadLine->m_pbuffer->m_rgBuff[0] ) ;
	_ASSERT(	pReadLine->m_pchStartData >= pReadLine->m_pchStart ) ;
	_ASSERT(	pReadLine->m_pchEnd <= &pReadLine->m_pbuffer->m_rgBuff[pReadLine->m_pbuffer->m_cbTotal] ) ;
	
	//
	//	We're going to write what we just read in a CIOreadLine object -
	//	so build a CWritePacket which uses the same buffer !
	//

	m_pWritePacket = pdriver->CreateDefaultWrite(	pReadLine->m_pbuffer,
						(unsigned)(pReadLine->m_pchStart - &pReadLine->m_pbuffer->m_rgBuff[0]),
						(unsigned)(pReadLine->m_pchEnd - &pReadLine->m_pbuffer->m_rgBuff[0]),
						(unsigned)(pReadLine->m_pchStartData - &pReadLine->m_pbuffer->m_rgBuff[0]),
						(unsigned)(pReadLine->m_pchEndData - &pReadLine->m_pbuffer->m_rgBuff[0])
						) ;

	if( m_pWritePacket )	{
		m_pchStart = pReadLine->m_pchStart ;
		m_pchEnd = pReadLine->m_pchEnd ;
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL	CIOWriteLine::Start(	CIODriver&	driver,	
								CSessionSocket*	pSocket,	
								unsigned	cbReadAhead ) {
/*++

Routine Description :

	This function is called to let us issue our writepacket to the socket

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/

	//
	//	Write the data to the network !
	//

	_ASSERT( m_pWritePacket != 0 ) ;
	_ASSERT( m_pchStart <= m_pchEnd ) ;
	_ASSERT( m_pchStart >= m_pWritePacket->Start() ) ;
	_ASSERT( m_pchStart <= m_pWritePacket->End() ) ;
	BOOL	fRtn = FALSE ;
	if( m_pchStart <= m_pchEnd )	{
		fRtn = TRUE ;
		m_pWritePacket->m_ibEndData = (unsigned)(m_pchStart - &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_ibStart]);

		//
		//	Any failure at this point will result in our Shutdown function
		//	being called, and our Destructor in short order.
		//	This can happen recursively !!!  Once IssuePacket is called
		//	we are not responsible for freeing the packet !!!! So, set our
		//	PacketPointer to 0 before we call IssuePacket !
		//

		CWritePacket*	pTemp = m_pWritePacket ;
		m_pWritePacket = 0 ;

		BOOL	eof ;		
		driver.IssuePacket( pTemp, pSocket, eof ) ;
		//
		//	Reset to Initial State !! - regardless of errors !!
		//	
		m_pchStart = 0 ;
		m_pchEnd = 0 ;
	}
	return	fRtn ;
}

void
CIOWriteLine::Shutdown( CSessionSocket*	pSocket,	
						CIODriver&		driver,
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

}	

int	CIOWriteLine::Complete(	IN CSessionSocket*	pSocket,	
							IN	CWritePacket* pWritePacket,	
							OUT	CIO*&	pioOut ) {
/*++

Routine Description :

	The one and only packet we can issue has completed !

Arguments :
	
	pSocket - The socket against which the IO was issued
	pWrite-	  The packet in which the written data resided.
			  This data may no longer be usable.
	pio	-     The Current CIO pointer of the CIODriver Stream which
              is calling us.

return Value :

	Number of bytes in the ReadPacket which we have consumed.

--*/


	TraceFunctEnter( "CIOWriteLine::Complete" ) ;

	//
	//	Nobody cares too much about how we complete - just let the state know !
	//

	pioOut = m_pState->Complete( this, pSocket, pWritePacket->m_pOwner ) ;
	DebugTrace( (DWORD_PTR)this, "Complete - returned %x packet bytes %d", pioOut, pWritePacket->m_cbBytes ) ;
	if( pioOut != this ) {
		DebugTrace( (DWORD_PTR)this, "CIOWriteLine::Complete - completed writing line - delete self" ) ;
	}
	return	pWritePacket->m_cbBytes ;

}

const	unsigned	MAX_CMD_WRITES = 3 ;

CIOWriteCMD::CIOWriteCMD(	CSessionState*	pstate,	
							CExecute*	pCmd,
							ClientContext&	context,
							BOOL		fIsLargeResponse,
							CLogCollector	*pCollector ) :
	CIOWrite( pstate ),
	m_pCmd( pCmd ),
	m_context( context ),
	m_cWrites( 0 ),
	m_cWritesCompleted( 0 ),
	m_fComplete( FALSE ),
	m_cbBufferSize( cbSmallRequest ),
	m_pCollector( pCollector ) {

	if( fIsLargeResponse )
		m_cbBufferSize = cbMediumRequest ;

	_ASSERT( pCmd != 0 ) ;
}

CIOWriteCMD::~CIOWriteCMD( ) {
	if( m_pCmd != 0 ) {
		delete	m_pCmd ;
	}
}


void
CIOWriteCMD::Shutdown( CSessionSocket*	pSocket,	
						CIODriver&		driver,
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

}	



BOOL
CIOWriteCMD::Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead ) {


	BOOL	fJunk ;
	CWritePacket*	pWrite = driver.CreateDefaultWrite( m_cbBufferSize ) ;
	if( pWrite != 0 ) {
		unsigned	cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
		//
		//	Use this temporary fComplete variable instead of the m_fComplete Member variable.
		//	This keeps us safe from the situation where a write completes before we
		//	have incremented m_cWrites and m_fComplete is set to a TRUE.
		//
		BOOL		fComplete = FALSE ;
		unsigned	cbOut = m_pCmd->FirstBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
		if( m_pCollector != 0 ) {
			ADDI( m_pCollector->m_cbBytesSent, cbOut );
		}

		pWrite->m_ibEndData = pWrite->m_ibStartData + cbOut ;
		driver.IssuePacket( pWrite, pSocket, fJunk ) ;
		m_cWrites ++ ;

		while( !fComplete && m_cWrites < MAX_CMD_WRITES ) {
			pWrite = driver.CreateDefaultWrite( cbMediumRequest ) ;
			if( pWrite == 0 )
				break ;
			cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
			cbOut = m_pCmd->NextBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
			if( m_pCollector != 0 )	{
				ADDI( m_pCollector->m_cbBytesSent, cbOut );
			}

			if( cbOut == 0 ) {
				driver.DestroyPacket( pWrite ) ;
				pWrite = driver.CreateDefaultWrite( cbLargeRequest ) ;
				if( pWrite == 0 )
					break ;
				cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
				cbOut = m_pCmd->NextBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
				if( m_pCollector != 0 )	{
					ADDI( m_pCollector->m_cbBytesSent, cbOut );
				}
				if( cbOut == 0 ) {
					driver.DestroyPacket( pWrite ) ;
					driver.UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
					break ;
				}
			}


			_ASSERT( cb != 0 ) ;
			_ASSERT( cbOut != 0 ) ;

			pWrite->m_ibEndData = pWrite->m_ibStartData + cbOut ;
			driver.IssuePacket( pWrite, pSocket, fJunk ) ;
			m_cWrites ++ ;
		}
		m_fComplete = fComplete ;
		return	TRUE ;
	}
	return	FALSE ;
}

int
CIOWriteCMD::Complete(	CSessionSocket*	pSocket,
						CWritePacket*	pWritePacket,
						CIO*&			pioOut ) {

	m_cWritesCompleted ++ ;
	if( m_fComplete )	{
		if( m_cWritesCompleted == m_cWrites ) {
			pioOut = m_pState->Complete( this, pSocket, pWritePacket->m_pOwner, m_pCmd, m_pCollector ) ;
			m_pCmd = 0 ;	// We are not responsible for destroying this if
							//	we manage to call the completion function !!
							//	So 0 the pointer so our destructor doesn't blow it off.
			_ASSERT( pioOut != this ) ;
		}
	}	else	{
		unsigned	cb = 0 ;
		unsigned	cbOut = 0 ;
		BOOL	fJunk ;
		BOOL	fComplete = m_fComplete ;
		while( !fComplete && (m_cWrites - m_cWritesCompleted) < MAX_CMD_WRITES ) {

			CWritePacket*	pWrite = pWritePacket->m_pOwner->CreateDefaultWrite( cbMediumRequest ) ;
			if( pWrite == 0 )	{
				pWritePacket->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
				break ;
			}
			cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
			cbOut = m_pCmd->NextBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
			if( m_pCollector != 0 ) {
				ADDI( m_pCollector->m_cbBytesSent, cbOut );
			}

			if( cbOut == 0 ) {
				pWritePacket->m_pOwner->DestroyPacket( pWrite ) ;
				pWrite = pWritePacket->m_pOwner->CreateDefaultWrite( cbLargeRequest ) ;
				if( pWrite == 0 )	{
					pWritePacket->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
					break ;
				}
				cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
				cbOut = m_pCmd->NextBuffer( (BYTE*)pWrite->StartData(), cb, m_context, fComplete, m_pCollector ) ;
				if( m_pCollector != 0 )	{
					ADDI( m_pCollector->m_cbBytesSent, cbOut );
				}
				if( cbOut == 0 ) {
					pWritePacket->m_pOwner->DestroyPacket( pWrite ) ;
					pWritePacket->m_pOwner->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
					break ;
				}
			}

			_ASSERT( cb != 0 ) ;
			_ASSERT( cbOut != 0 ) ;

			pWrite->m_ibEndData = pWrite->m_ibStartData + cbOut ;
			pWrite->m_pOwner->IssuePacket( pWrite, pSocket, fJunk ) ;
			m_cWrites ++ ;
		}
		m_fComplete = fComplete ;
	}

	return	pWritePacket->m_cbBytes ;
}

void
CIOWriteAsyncComplete::Complete(	BOOL	fReset	)	{
/*++

Routine Description :

	This function is called by the derived classes when
	the operation has completed !

Arguments :

	fReset - if TRUE we should reset ourselves for another
		operation !

Return Value :

	None.

--*/
	//
	//	Were we pending - do we have something to finish !
	//
	_ASSERT( m_pSocket!= 0 ) ;
	_ASSERT( m_pExecute != 0 ) ;
	//
	//	If no bytes moved, the command can't have completed !
	//
	_ASSERT( m_cbTransfer != 0 || (m_cbTransfer == 0 && !m_fComplete) ) ;
	//
	//	If we're supposed to get a larger buffer, then
	//	no bytes should have moved !
	//
	_ASSERT( !m_fLargerBuffer || (m_fLargerBuffer && m_cbTransfer != 0) ) ;
	//
	//	Copy the member variables into stack variables and set them to NULL.
	//	We must do this because after calling ProcessPacket() we can't touch
	//	any members as we may re-enter this class on this thread !
	//
	CSessionSocket*	pSocket = m_pSocket ;
	CExecutePacket*	pExecute = m_pExecute ;
	m_pExecute = 0;
	m_pSocket = 0 ;
	_ASSERT( pSocket != 0 ) ;

	_ASSERT( pExecute->m_pWrite != 0 ) ;
	pExecute->m_cbTransfer = m_cbTransfer ;
	pExecute->m_fComplete = m_fComplete ;
	pExecute->m_fLargerBuffer = m_fLargerBuffer ;
	CDRIVERPTR	pDriver = pExecute->m_pOwner ;

	//
	//	We've copied all the usefull parts of our state into
	//	the CExecutePacket to send off - now NULL out the reset of
	//	our state so that nobody mistakenly uses it !
	//
	m_cbTransfer = 0 ;
	m_fLargerBuffer = FALSE ;
	m_fComplete = FALSE ;
	if( fReset )
		Reset() ;

	//
	//	NOW ! - release the reference we have to the CIOWriteAsyncCMD -
	//	the session may have dropped and this could lead to our destruction !
	//
	m_pWriteAsyncCMD = 0 ;

	//
	//	Okay - process the completion synchronized with
	//	writes on the socket - we may re-enter this object
	//	on another method because of re-use - so we must
	//	not modify anything after this call !
	//
	pExecute->m_pOwner->ProcessExecute(	pExecute,
										pSocket
										) ;
}


void
CIOWriteAsyncComplete::Reset()	{
/*++

Routine Description :

	This function will reset our state so that we could handle a second Async operation !
	Basically we set our state to be the same as immediately after construction !

Arguments :

	None.

Return Value :

	None.

--*/

	//
	//	Most of our state should have been reset on the call to Complete() !
	//
	_ASSERT( m_pSocket == 0 ) ;
	_ASSERT( m_pExecute == 0 ) ;
	_ASSERT( m_cbTransfer == 0 ) ;
	_ASSERT( m_fLargerBuffer == FALSE ) ;
	_ASSERT( m_fComplete == FALSE ) ;

	//
	//	Reset our base class - and add a refence so we're just like new !
	//
	CNntpComplete::Reset() ;
	AddRef() ;
}


CIOWriteAsyncComplete::~CIOWriteAsyncComplete()	{
/*++

Routine Description :

	Clean up an CIOWriteAsyncComplete object.
	There is not much to do - we just _ASSERT that Complete() has
	been called.

Arguments :

	None.

Return Value :

	None.


--*/
	_ASSERT( m_pExecute == 0 ) ;
	_ASSERT( m_pSocket == 0 ) ;
}

void
CIOWriteAsyncComplete::FPendAsync(	
			CSessionSocket*		pSocket,
			CExecutePacket*		pExecute,
			CIOWriteAsyncCMD*	pWriteAsync
			) 	{
/*++

Routine Description :

	This function is called by the the CIOWriteAsyncCMD when it is ready to
	deal with the completion of the CAsyncExecute object we are dealing with.
	Because our constructor adds a reference, we know that the operation
	can't complete before this guys is called.

Arguments :

	pSocket - the socket we are doing the operation for
	pExecute - the CExecutePacket that will manage the synchronization of the
		drivers completion with our IO's
	pWriteAsync - the guy we add a reference to.
		Ensures that if the session goes down while we are pending we don't get
		destroyed !

Return Value :

	None.

--*/
	_ASSERT( pExecute != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	m_pExecute = pExecute ;
	m_pSocket = pSocket ;
	m_pWriteAsyncCMD = pWriteAsync ;
	Release() ;
}



CIOWriteAsyncCMD::CIOWriteAsyncCMD(	CSessionState*	pstate,	
							CAsyncExecute*	pCmd,
							ClientContext&	context,
							BOOL		fIsLargeResponse,
							CLogCollector	*pCollector
							) :
	CIOWrite( pstate ),
	m_pCmd( pCmd ),
	m_context( context ),
	m_cWrites( 0 ),
	m_cWritesCompleted( 0 ),
	m_fComplete( FALSE ),
	m_cbBufferSize( cbSmallRequest ),
	m_pCollector( pCollector ),
	m_pDeferred( 0 )	{

	m_pfnCurBuffer = &(CAsyncExecute::FirstBuffer) ;

	if( fIsLargeResponse )
		m_cbBufferSize = cbMediumRequest ;

	_ASSERT( pCmd != 0 ) ;
}

CIOWriteAsyncCMD::~CIOWriteAsyncCMD( ) {
	if( m_pCmd != 0 ) {
		delete	m_pCmd ;
	}
}

BOOL
CIOWriteAsyncCMD::Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead
					) {
/*++

Routine Description :

	Start the execution of async commands !

Arguments :
	driver - The CIODriver managing the session
	pSocket - The Socket we're working on
	cReadAhead - Nothing we care about !

Return Value :

	TRUE if we're successfully setup !

--*/

	CExecutePacket*	pExecute = driver.CreateExecutePacket() ;
	if( pExecute )	{
		if(	!Execute(	
					pExecute,
					driver,
					pSocket,
					m_cbBufferSize
					) 	)	{
			//
			//	We own destruction of the CExecutePacket we've created is this fails
			//
			pExecute->m_pOwner->DestroyPacket( pExecute ) ;
			return	FALSE ;
		}
		return	TRUE ;
	}
	return	FALSE ;
}

void
CIOWriteAsyncCMD::Shutdown(
						CSessionSocket*	pSocket,	
						CIODriver&		driver,
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

	//
	//	If we have a deferred completion packet - kill it !
	//
	if( m_pDeferred ) {
		driver.DestroyPacket( m_pDeferred ) ;
		m_pDeferred = 0 ;
	}
}	


BOOL
CIOWriteAsyncCMD::Execute(
						CExecutePacket*	pExecute,
						CIODriver&	driver,
						CSessionSocket*	pSocket,
						DWORD		cbInitialSize
						)	{
/*++

Routine Description :

	This is a helper function for the CIOWriteAsyncCMD class -
	we will build the necessary write packets etc... to issue
	Async Commands against storage drivers.
	(We don't directly deal with Storage drivers - we have a pointer
	to an Async Command object that will issue the operation !)

Arguments :

	pExecute - the CExecutePacket that will carry notification of the
		completion of this async operation back to us !
	driver - the CIODriver managing the session !
	pSocket - the Socket of the session
	cbInitialSize - how big a buffer we think the command could use !

Return Value :

	TRUE if successfull
	FALSE if a fatal error occurs - Caller must destroy
		his CExecutePacket object !

--*/
	//
	//	Basic assumptions about arguments !
	//
	_ASSERT( pExecute != 0 ) ;
	_ASSERT( pSocket != 0 ) ;
	//
	//	Shouldn't be issuing more op's if we think we're done !
	//
	_ASSERT( !m_fComplete ) ;
	//
	//	Better arrive in here without a Write Packet !
	//
	_ASSERT( pExecute->m_pWrite == 0 ) ;
	//
	//	Allocate memory to hold results !
	//
	pExecute->m_pWrite = driver.CreateDefaultWrite( cbInitialSize ) ;
	if( pExecute->m_pWrite == 0 ) {
		//
		//	Fatal error !
		//
		driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
		return	FALSE ;
	}	else	{
		//
		//	Give to the AsyncCommand who will execute against storage
		//	driver !
		//
		unsigned	cb = pExecute->m_pWrite->m_ibEnd - pExecute->m_pWrite->m_ibStartData ;
		CIOWriteAsyncComplete*	pComplete =
			(m_pCmd->*m_pfnCurBuffer)(	(BYTE*)pExecute->m_pWrite->StartData(),
										cb,
										m_context,
										m_pCollector
										) ;
		//
		//	Operation must have been successfully issued against
		//	Storage driver !
		//
		if( pComplete ) {
			pComplete->FPendAsync(	pSocket,
									pExecute,
									this
									) ;
			return	TRUE ;
		}
	}
	driver.UnsafeClose( pSocket, CAUSE_ASYNCCMD_FAILURE, __LINE__ ) ;
	return	FALSE ;
}

void
CIOWriteAsyncCMD::Complete(
						CSessionSocket*	pSocket,
						CExecutePacket*	pExecute,
						CIO*&			pioOut
						)	{
/*++

Routine Description :

	This function deals with the completion of our Async Command.
	Now that the command has completed somewhat - we need to
	take the results of the completion and take the appropriate action.
	Generally if no errors occurred, we will write the data out
	to the socket, if the buffer we gave the command was too small
	we should re-issue against AsyncCommand.

Arguments :

	pSocket - the socket we're doing work for
	pExecute - the packet containing the completion state of
		the AsyncCommand that we're executing
	pioOut - Containing CIODriver's reference to us !

Return Value :

	None.

--*/

	//
	//	Capture IssuePacket noise !
	//
	BOOL	fJunk ;

	//
	//	Basic assumptions about arguments !
	//
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pExecute != 0 ) ;
	_ASSERT( pExecute->m_pWrite != 0 ) ;
	_ASSERT( pExecute->m_pWrite->m_pbuffer != 0 ) ;
	_ASSERT( pioOut == this ) ;

	m_fComplete = pExecute->m_fComplete ;
	//
	//	If this packet completed things, then it better have
	//	succeeded in giving us some bytes to send !
	//
	_ASSERT( !m_fComplete ||
		(m_fComplete && pExecute->m_cbTransfer != 0 &&
			!pExecute->m_fLargerBuffer) ) ;

	//
	//	Default size for buffers holding outgoing data !
	//
	DWORD	cbSize = m_cbBufferSize ;

	//
	//	If it failed - find out why !
	//
	if( pExecute->m_cbTransfer != 0 ) {
		//
		//	Issue the write to the socket !
		//
		m_pfnCurBuffer = &(CAsyncExecute::NextBuffer) ;
		m_cWrites ++ ;
		pExecute->m_pWrite->m_ibEndData = pExecute->m_pWrite->m_ibStartData + pExecute->m_cbTransfer ;
		pExecute->m_pOwner->IssuePacket(	pExecute->m_pWrite,
											pSocket,
											fJunk
											) ;
	}	else	{
		//
		//	Can't be finished if it failed !
		//
		_ASSERT( !m_fComplete ) ;
		//
		//	Preserve the number of bytes we had provided to the client !
		//
		DWORD	cbWrite = pExecute->m_pWrite->m_pbuffer->m_cbTotal ;
		//
		//	Destroy the CWritePacket no matter what went wrong !
		//
		pExecute->m_pOwner->DestroyPacket( pExecute->m_pWrite ) ;
		pExecute->m_pWrite = 0 ;
		//
		//	Did we need to try again with a larger buffer ?
		//
		if( !pExecute->m_fLargerBuffer ||
			(pExecute->m_fLargerBuffer &&
				cbWrite > cbLargeRequest ) ) {
			//
			//	This is a fatal error - tear down the session !
			//
			pExecute->m_pOwner->UnsafeClose( pSocket, CAUSE_ASYNCCMD_FAILURE, __LINE__ ) ;
			pExecute->m_pOwner->DestroyPacket( pExecute ) ;
			return ;
		}	

		//
		//	We only fall through to here if we need to try again
		//	with a large buffer - try the biggest we have !
		//
		cbSize = cbLargeRequest ;
		//
		//	We're going to re-issue the operation - it must not
		//	be the case that we would flow control, otherwise we
		//	never should have issued the operation we're completing now !
		//
		_ASSERT( (m_cWrites - m_cWritesCompleted) <= MAX_CMD_WRITES ) ;
	}	
	//
	//	We should have consumed this Write Packet by this point
	//	so NULL it out of the ExecutePacket !
	//
	pExecute->m_pWrite = 0 ;

	//
	//	Ok - lets keep executing the command !
	//
	if(	m_fComplete )	{
		//
		//	If we've completed the operation we don't need the
		//	Execute packet anymore !
		//
		pExecute->m_pOwner->DestroyPacket( pExecute ) ;
	}	else	{
		if( (m_cWrites - m_cWritesCompleted) > MAX_CMD_WRITES )	{
			//
			//	Save this for later - when the Write Completions catch up !
			//
			m_pDeferred = pExecute ;
		}	else	{
			//
			//	Do more async work against the AsyncExecute object !
			//
			if( !Execute(	pExecute,
							*pExecute->m_pOwner,
							pSocket,
							cbSize
							)	)	{
				//
				//	Fatal error - blow off our CExecutePacket !
				//	NOTE : Execute() will call UnsafeShutdown()
				//	for us in case of failures !
				//
				pExecute->m_pOwner->DestroyPacket( pExecute ) ;
				return ;
			}
		}
	}
}
	

int
CIOWriteAsyncCMD::Complete(	
						CSessionSocket*	pSocket,
						CWritePacket*	pWritePacket,
						CIO*&			pioOut
						) {
/*++

Routine Description :

	We've completed sending some stuff to a client.
	If we're done finishing things, notify our containing
	state - otherwise make sure we keep doing work !

Arguments :

	pSocket - the socket we're doing work for
	pWritePacket - represents the bytes we sent to the client !
	pioOut - a reference to us in the containing CIODriver !

Return Value :
	
	bytes consumed !

--*/

	//
	//	Keep track of how many writes have completed !
	//
	m_cWritesCompleted ++ ;
	if( m_fComplete )	{

		//
		//	If we've completed all Executions of the command,
		//	then we better not have a deferred CExecutePacket
		//	lying around - should have destroyed in on the
		//	Complete path for CExecutePacket's !
		//
		_ASSERT( m_pDeferred == 0 ) ;

		//
		//	We're only really done when the number of
		//	WritePacket Completions catches up with the number
		//	of write packets we issued !
		//
		if( m_cWritesCompleted == m_cWrites ) {
			pioOut = m_pState->Complete( 	this,
											pSocket,
											pWritePacket->m_pOwner,
											m_pCmd,
											m_pCollector
											) ;
			m_pCmd = 0 ;	// We are not responsible for destroying this if
							//	we manage to call the completion function !!
							//	So 0 the pointer so our destructor doesn't blow it off.
			_ASSERT( pioOut != this ) ;
		}
	}	else	{
		//
		//	Check to see if we have any deferred work to do !
		//
		if( m_pDeferred ) 	{
			//	
			//	Okay - issue off one of these commands against our
			//	storage drivers !
			//
			if( !Execute(	m_pDeferred,
							*m_pDeferred->m_pOwner,
							pSocket,
							m_cbBufferSize
							)	)	{
				//
				//	Fatal error - blow off the session !
				//
				m_pDeferred->m_pOwner->DestroyPacket( m_pDeferred ) ;
				_ASSERT( FALSE ) ;
				return	pWritePacket->m_cbBytes ;
			}
			m_pDeferred = 0 ;
		}
	}
	return	pWritePacket->m_cbBytes ;
}


#if 0

void
CIOWriteAsyncCMD::CommandComplete(
						BOOL	fLargerBuffer,
						BOOL	fComplete,
						DWORD	cbTransfer,
						CSessionSocket*	pSocket,
						)	{
/*++

Routine Description :

	This function is called if the operation pending against the
	storage driver completes asynchronously !

Arguments :
	fLargerBuffer - If this is TRUE cbTransfer must be 0, and it indicates
		that we should execute the operation again with a larger buffer !
	cbTransfer - If non zero than its the number of bytes that were copied
		into pPacket - ZERO indicates a fatal error if fLargeBuffer is FALSE !
	pSocket - The socket for thes session
	pPacket - The packet the client was to fill for us !

Return :

	Nothing !

--*/
	_ASSERT( pSocket != 0 ) ;
	_ASSERT( pPacket != 0 ) ;
	_ASSERT( m_pWrite != 0 ) ;
	_ASSERT( m_pExecute != 0 ) ;

	CIODRIVERPTR	pDriver = m_pExecute->m_pOwner ;
	_ASSERT( pDriver != 0 ) ;
	pDriver->ProcessExecute(	

	//
	//	If we arrive here we must have an operation pending
	//

	BOOL	fDefer = (m_cWrites - m_cWritesCompleted) > MAX_CMD_WRITES ;
	CIODRIVERPTR	pdriver = pPacket->m_pOwner ;
	DWORD	cbBufferSize = m_cbBufferSize ;

	if( cbTransfer != 0 )	{
		//
		//	Send off the packet !
		//
		pPacket->m_ibEndData = pPacket->m_ibStartData + cbTransfer ;
		m_cWrites ++ ;
		m_fComplete = fComplete ;
		fDefer &= !m_fComplete ;
		m_fDeferred = fDefer ;

		pdriver->IssuePacket( pPacket, pSocket, fJunk ) ;
			//
		//	Now the question is - should we issue another
		//	operation against AsyncExecute object !
		//
	}	else	if( !fLargerBuffer ) 	{
		//
		//	Fatal error - drop the session !
		//
		driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
		return ;
	}	else	if( fLargerBuffer ) 	{
		cbBufferSize = cbLargeBuffer ;
	}
	//
	//	Fall through to here only if we're considering pending more
	//	operations !
	//
	if( !fDefer ) 	{
		Execute(	
					driver,
					pSocket,
					cbBufferSize
					) ;
	}
}



BOOL
CIOWriteAsyncCMD::Execute(
						CIODriver&	driver,
						CSessionSocket*	pSocket,
						DWORD		cbInitialSize
						)	{


	_ASSERT( !m_fComplete ) ;
	_ASSERT( !m_fTerminated ) ;

	//
	//	Capture the don't care OUT parm of IssuePacket() !
	//
	BOOL	fJunk ;

	//
	//
	//
	_ASSERT( m_pExecute != 0 ) ;

	CWritePacket*	pWrite = driver.CreateDefaultWrite( cbInitialSize ) ;
	if( pWrite != 0 ) {
		unsigned	cb = pWrite->m_ibEnd - pWrite->m_ibStartData ;
		//
		//	Use this temporary fComplete variable instead of the m_fComplete Member variable.
		//	This keeps us safe from the situation where a write completes before we
		//	have incremented m_cWrites and m_fComplete is set to a TRUE.
		//
		BOOL		fComplete = FALSE ;
		CIOWriteAsyncComplete*	pComplete =
			m_pCmd->GetBuffer(	(BYTE*)pWrite->StartData(),
										cb,
										m_context,
										m_pCollector
										) ;
		if( !pComplete ) {
			driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
			return	FALSE ;
		}
		//
		//	Now we have the Async Completion object -
		//	it may have completed already so we will have to handle
		//	that case when we setup for async completion !
		//
		DWORD	cbTransfer ;
		BOOL	fLarger ;
		BOOL	fJunk ;

		if( !pComplete->FPendAsync(	cbTransfer,
									fLarger,
									fComplete,
									pWrite,
									pSocket,
									this
									)	)	{
			_ASSERT( !fLarger ) ;
			_ASSERT( cbTransfer == 0 ) ;
			return	FALSE ;
		}	else	{
			if(	cbTransfer == 0 &&
				fLarger &&
				cbInitialSize != cbLargeRequest	) {
				driver.DestroyPacket( pWrite ) ;
				pWrite = driver.CreateDefaultWrite( cbLargeRequest ) ;
				pComplete =
					m_pCmd->GetBuffer(	
											(BYTE*)pWrite->StartData(),
											cb,
											m_context,
											m_pCollector
											) ;
				m_fComplete = (!!fComplete) ;
				if( !pComplete ) {
					driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
					return	FALSE ;
				}
				if( !pComplete->FPendAsync(	cbTransfer,
											fLarger,
											fComplete,
											pWrite,
											pSocket,
											this
											)	)	{
					_ASSERT( !fLarger ) ;
					_ASSERT( cbTransfer == 0 ) ;
					return	FALSE ;
				}	
				if( cbTransfer == 0 ) 	{
					//
					//	This is a fatal error - tear down !
					//
					driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
					return	FALSE ;
				}
			}
			//
			//	If we get here this must be FALSE as the operation
			//	was successfully issued !
			//
			_ASSERT( !fLarger ) ;
			//
			//	This guy is ready to go - so mark up the
			//	WritePacket and send it off !
			//
			pWrite->m_ibEndData = pWrite->m_ibStartData + cbTransfer ;
			//
			//	Increment this before we issue the IO - and before
			//	we set m_fComplete to fComplete
			//	This way we avoid mistakes regarding our termination
			//	in our completion function !
			//
			m_cWrites ++ ;
			//
			//	We will repeat the loop IF and only If we are not behind
			//	1) The Command hasn't completed
			//	2) The number of
			//
			m_fComplete = fComplete ;
			//
			//	All our state is adjusted before we issue the IO so
			//	that we don't miss taking the correct action when the
			//	IO completes !
			//

			l = InterlockedExchangeAdd( &m_cPending, PACKETS ) + PACKETS ;
			_ASSERT( (l&0XFFFF) >= 1 ) ;

			driver.IssuePacket( pWrite, pSocket, fJunk ) ;
			return	TRUE ;
		}
	}
	driver.UnsafeClose( pSocket, CAUSE_OOM, __LINE__ ) ;
	return	FALSE ;
}
#endif



MultiLine::MultiLine() :
	m_pBuffer( 0 ),
	m_cEntries( 0 )	{

	ZeroMemory( &m_ibOffsets[0], sizeof( m_ibOffsets ) ) ;

}

CIOMLWrite::CIOMLWrite(	
	CSessionState*	pstate,
	MultiLine*		pml,
	BOOL			fCoalesce,
	CLogCollector*	pCollector
	) :
	CIOWrite( pstate ),
	m_pml( pml ),
	m_fCoalesceWrites( fCoalesce ),
	m_pCollector( pCollector ),
	m_iCurrent( 0 )	{

	_ASSERT( m_pml != 0 ) ;
	_ASSERT( m_pml->m_cEntries <= 16 ) ;

}

BOOL
CIOMLWrite::Start(
		CIODriver&		driver,
		CSessionSocket*	pSocket,
		unsigned		cAhead
		) {

	DWORD	c = 0 ;
	DWORD	iNext = 0;

	while( m_iCurrent != (m_pml->m_cEntries) && c<3 ) {

		if( m_fCoalesceWrites ) {

			iNext = m_pml->m_cEntries ;

		}	else	{

			iNext = m_iCurrent+1 ;

		}

		CWritePacket*	pWrite = driver.CreateDefaultWrite(
									m_pml->m_pBuffer,
									m_pml->m_ibOffsets[m_iCurrent],
									m_pml->m_ibOffsets[iNext],
									m_pml->m_ibOffsets[m_iCurrent],
									m_pml->m_ibOffsets[iNext]
									) ;

		if( pWrite ) {

			BOOL	fJunk ;
			driver.IssuePacket( pWrite, pSocket, fJunk ) ;

		}	else	{
			
			return	FALSE ;

		}
		m_iCurrent = iNext ;
		c++ ;
	}
	return	TRUE ;
}


int
CIOMLWrite::Complete(	CSessionSocket*	pSocket,
						CWritePacket*	pPacket,
						CIO*&			pio
						) {

	if( m_fCoalesceWrites ||
		m_iCurrent == (m_pml->m_cEntries)	) {

		_ASSERT( m_iCurrent == m_pml->m_cEntries ) ;

		pio	= m_pState->Complete(
								this,
								pSocket,
								pPacket->m_pOwner
								) ;

	}	else	{

	
		CWritePacket*	pWrite = pPacket->m_pOwner->CreateDefaultWrite(
									m_pml->m_pBuffer,
									m_pml->m_ibOffsets[m_iCurrent],
									m_pml->m_ibOffsets[m_iCurrent+1],
									m_pml->m_ibOffsets[m_iCurrent],
									m_pml->m_ibOffsets[m_iCurrent+1]
									) ;

		if( pWrite ) {

			BOOL	fJunk ;
			pPacket->m_pOwner->IssuePacket( pWrite, pSocket, fJunk ) ;
			m_iCurrent++ ;

		}	else	{

			pPacket->m_pOwner->UnsafeClose( pSocket,
											CAUSE_OOM,
											0
											) ;			

		}
	}
	return	pPacket->m_cbBytes ;
}


void
CIOMLWrite::Shutdown( CSessionSocket*	pSocket,	
						CIODriver&		driver,
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptional ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

}	




CIOTransmit::CIOTransmit(	CSessionState*	pstate ) :
	//
	//	Initialize to an illegal state !
	//
	CIOWrite( pstate ),
	m_pTransmitPacket( 0 ),
	m_pExtraText( 0 ),
	m_pchStartLead( 0 ),
	m_cbLead( 0 ),
	m_cbTail( 0 ),
	m_pchStartTail( 0 ) {

	TraceFunctEnter( "CIOTransmit::CIOTransmit" ) ;
	DebugTrace( (DWORD_PTR)this, "NEW CIOTransmit" ) ;

}

CIOTransmit::~CIOTransmit() {

	if( m_pTransmitPacket != 0 )	{
		//delete	m_pTransmitPacket ;
		CPacket::DestroyAndDelete( m_pTransmitPacket ) ;
	}

}

unsigned	CIOTransmit::cbJunk = 0 ;

BOOL
CIOTransmit::Init(	CDRIVERPTR&	pdriver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,	
					DWORD	cbExtra ) {
	//
	//	Build a transmit packet with appropriate values and get a buffer
	//	for any text we send on the side !
	//

	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( m_pTransmitPacket == 0 ) ;
	_ASSERT( m_pExtraText == 0 ) ;
	_ASSERT( m_pchStartLead == 0 ) ;
	_ASSERT( m_cbLead == 0 ) ;

	
	if( cbExtra != 0 )	{
		DWORD	cbAllocated ;
		m_pExtraText = new( (int)cbExtra, cbAllocated )	CBuffer( cbAllocated ) ;

		if( m_pExtraText == 0 )
			return	FALSE ;
		m_pchStartLead = &m_pExtraText->m_rgBuff[0] ;
	}

	m_pTransmitPacket = pdriver->CreateDefaultTransmit( pFIOContext, ibOffset, cbLength ) ;

	if( m_pTransmitPacket == 0 ) {
		if( m_pExtraText != 0 ) {
			delete	m_pExtraText ;
			m_pExtraText = 0 ;
			m_pchStartLead = 0 ;
		}
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CIOTransmit::Init(	CDRIVERPTR&	pdriver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,	
					CBUFPTR&	m_pbuffer,
					DWORD	ibStart,
					DWORD	ibEnd ) {
	//
	//	Build a transmit packet with appropriate values and get a buffer
	//	for any text we send on the side !
	//

	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( m_pTransmitPacket == 0 ) ;
	_ASSERT( m_pExtraText == 0 ) ;
	_ASSERT( m_pchStartLead == 0 ) ;
	_ASSERT( m_cbLead == 0 ) ;

	m_pTransmitPacket = pdriver->CreateDefaultTransmit( pFIOContext, ibOffset, cbLength ) ;

	if( m_pTransmitPacket != 0 ) {

		m_pExtraText = m_pbuffer ;
		m_cbLead = ibEnd - ibStart ;
		m_pTransmitPacket->m_buffers.Head = &m_pExtraText->m_rgBuff[ibStart] ;
		m_pTransmitPacket->m_buffers.HeadLength = m_cbLead ;

	}	else	{	
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CIOTransmit::InitWithTail(	CDRIVERPTR&	pdriver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,	
					CBUFPTR&	m_pbuffer,
					DWORD	ibStart,
					DWORD	ibEnd ) {
	//
	//	Build a transmit packet with appropriate values and get a buffer
	//	for any text we send on the side !
	//

	_ASSERT( pFIOContext != 0 ) ;
	_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( m_pTransmitPacket == 0 ) ;
	_ASSERT( m_pExtraText == 0 ) ;
	_ASSERT( m_pchStartLead == 0 ) ;
	_ASSERT( m_cbLead == 0 ) ;

	m_pTransmitPacket = pdriver->CreateDefaultTransmit( pFIOContext, ibOffset, cbLength ) ;

	if( m_pTransmitPacket != 0 ) {

		m_pExtraText = m_pbuffer ;
		m_cbLead = ibEnd - ibStart ;
		m_pTransmitPacket->m_buffers.Tail = &m_pExtraText->m_rgBuff[ibStart] ;
		m_pTransmitPacket->m_buffers.TailLength = m_cbLead ;

	}	else	{	
		return	FALSE ;
	}
	return	TRUE ;
}


char*
CIOTransmit::GetBuff( unsigned	&cbRemaining ) {

	//
	//	How many bytes left in that buffer we reserved during Init() ??
	//
	_ASSERT( m_pExtraText != 0 ) ;
	
	if( m_pExtraText != 0 ) {
		cbRemaining = m_pExtraText->m_cbTotal - m_cbLead ;
		return	m_pchStartLead ;
	}
	return	0 ;
}

void
CIOTransmit::AddLeadText( unsigned cb ) {
	//
	//	Text we want to send BEFORE the file
	//

	_ASSERT( cb <= m_pExtraText->m_cbTotal - m_cbLead ) ;

	m_cbLead += cb ;
	m_pchStartLead += cb ;

	m_pTransmitPacket->m_buffers.Head = &m_pExtraText->m_rgBuff[0] ;
	m_pTransmitPacket->m_buffers.HeadLength = m_cbLead ;
}

void
CIOTransmit::AddTailText(	unsigned	cb ) {
	//
	//	For Text we want sent AFTER the file !
	//

	m_cbTail += cb ;
	m_pchStartTail = m_pchStartLead + m_cbLead ;

	m_pTransmitPacket->m_buffers.Tail = &m_pExtraText->m_rgBuff[m_cbLead] ;
	m_pTransmitPacket->m_buffers.TailLength = m_cbTail ;

}

void
CIOTransmit::AddTailText(	char*	pch,	unsigned	cb ) {

	m_pTransmitPacket->m_buffers.Tail = pch ;
	m_pTransmitPacket->m_buffers.TailLength = cb ;
}

LPSTR
CIOTransmit::GetLeadText(	unsigned&	cb )		{

	cb = 0 ;
	LPSTR	lpstrReturn = 0 ;

	if( m_pTransmitPacket ) {
		lpstrReturn = (LPSTR)m_pTransmitPacket->m_buffers.Tail ;
		cb = m_pTransmitPacket->m_buffers.TailLength ;
	}
	return	lpstrReturn ;
}

LPSTR
CIOTransmit::GetTailText(	unsigned&	cb )		{

	cb = 0 ;
	LPSTR	lpstrReturn = 0 ;

	if( m_pTransmitPacket ) {
		lpstrReturn = (LPSTR)m_pTransmitPacket->m_buffers.Head ;
		cb = m_pTransmitPacket->m_buffers.HeadLength ;
	}
	return	lpstrReturn ;
}


void
CIOTransmit::Shutdown(	CSessionSocket*	pSocket,	
						CIODriver&		driver,	
						SHUTDOWN_CAUSE	cause,
						DWORD	dwError ) {
/*++

Routine Description :

	This function is called whenever a session is closed.
	We don't do any clean up at this point - we leave that untill
	our destructor is called

Arguments :
	
	pSocket - The socket which is terminating
	pdriver - The CIODriver derived object handling the IO for the socket
	cause-	  The reason the socket is terminating
	dwErrorCode-     optional additional info about the cause of termination

return Value :

	Always TRUE - we want to be destroyed.

--*/

}

void
CIOTransmit::Complete(	CSessionSocket*	pSocket,	
						CTransmitPacket*	pPacket,
						CIO*&	pio ) {

	//
	//	Let the state know the operation has completed !
	//
	pio = m_pState->Complete( this, pSocket, pPacket->m_pOwner, &pPacket->m_buffers, pPacket->m_cbBytes ) ;	

	_ASSERT( pio != this ) ;	// Can't reuse CIOTransmit's like you can CIOReadLine's !
}

BOOL
CIOTransmit::Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cAhead ) {
/*++

Routine Description :

	This function is called to give us a chance to issue our CTransmitPacket

Arguments :
	
	pdriver - The CIODriver derived object handling the IO for the socket
	pSocket - The Socket against which the IO is being issued
	cAhead -  The number of already issued packets still outstanding on
              this driver.

return Value :

	TRUE if successfull, FALSE otherwise

--*/

	TraceFunctEnter( "CIOTransmit::Start" ) ;

	BOOL	eof ;
	//
	//	Start the Transfer ! - Socket errors could cause our
	//	destructor to be called, and we are not responsible for
	//	freeing the packet after IssuePacket is called so
	//	ZERO out the m_pTransmitPacket member before calling !
	//
	CTransmitPacket*	pTempTransmit = m_pTransmitPacket ;
	m_pTransmitPacket = 0 ;
	driver.IssuePacket( pTempTransmit, pSocket, eof ) ;
	return	TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\chkhash.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    chkhash_H.h

Abstract:

    This module is the main include file for the chkhash

Author:

    Johnson Apacible (JohnsonA)     18-Dec-1995

Revision History:

--*/

#ifndef _CHKHASH_H_
#define _CHKHASH_H_


//
// table stats
//

typedef struct _HTABLE_TYPE {

    //
    // Description of the hash table
    //

    LPCSTR Description;

    //
    // file name the hash table uses
    //

    LPCSTR FileName;

    //
    // name of new table
    //

    LPCSTR NewFileName;


    //
    // hash table signature
    //

    DWORD  Signature;

    //
    // number of entries in the hash table
    //

    DWORD  Entries;

    //
    // total deletions and insertions
    //

    DWORD  TotDels;
    DWORD  TotIns;

    //
    // number of pages containing hash entries
    //

    DWORD  PagesUsed;

    //
    // current file size
    //

    DWORD  FileSize;

    //
    // depth of the directory
    //

    DWORD   DirDepth;

    //
    // list of problems discovered
    //

    DWORD  Flags;

} HTABLE, *PHTABLE;

//
// Flags
//

#define HASH_FLAG_BAD_LINK             0x00000001
#define HASH_FLAG_BAD_SIGN             0x00000002
#define HASH_FLAG_BAD_SIZE             0x00000004
#define HASH_FLAG_CORRUPT              0x00000008
#define HASH_FLAG_NOT_INIT             0x00000010
#define HASH_FLAG_BAD_HASH             0x00000020
#define HASH_FLAG_BAD_ENTRY_COUNT      0x00000040
#define HASH_FLAG_BAD_PAGE_COUNT       0x00000080
#define HASH_FLAG_BAD_DIR_DEPTH        0x00000100

#define HASH_FLAG_NO_FILE              0x00000200

//
// If this is set, then no rebuilding is to take place
// because of a fatal error.
//

#define HASH_FLAG_ABORT_SCAN           0x80000000

//
// These flags indicate that the file is corrupt and should
// be rebuilt
//

#define HASH_FLAGS_CORRUPT             (HASH_FLAG_BAD_LINK | \
                                        HASH_FLAG_BAD_SIGN | \
                                        HASH_FLAG_BAD_SIZE | \
                                        HASH_FLAG_CORRUPT |  \
                                        HASH_FLAG_NOT_INIT | \
                                        HASH_FLAG_BAD_HASH | \
                                        HASH_FLAG_BAD_ENTRY_COUNT)

//
// hash types
//

enum filetype {
        artmap = 0,
        histmap = 1,
        xovermap = 2
        };


//
// function prototypes
//

BOOL
RebuildArtMapAndXover(
	PNNTP_SERVER_INSTANCE pInstance
    );

BOOL
RebuildGroupList(
	PNNTP_SERVER_INSTANCE pInstance
    );

#if 0
BOOL
checklink(
    PHTABLE HTable,
	class	CBootOptions*
    );


BOOL
RebuildArtMapFromXOver(
	PNNTP_SERVER_INSTANCE pInstance,
    class	CBootOptions*,
	LPSTR   lpXoverFilename
    );

BOOL
diagnose(
    PHTABLE HTable,
	class	CBootOptions*
    );

BOOL
RenameAllArticles(
	CNewsTree* pTree,
	CBootOptions*	pOptions
	) ;

#endif

#endif // _CHKHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\cio.h ===
/*++

	cio.h

	This file contains the definitions of the classes defining abstract IO operations.
	
	All such classes are derived from class CIO which defines the basic interface to such operations.
	A 'CIO' operation represents a more abstract IO operation such as :

		Read A Line and Parse into arguments (CIOReadLine)
		Read An Article from one stream into a file until a terminating period is found.
		Write A Line
		Write A File to a stream with text before and after
		
	Most of these operations map more or less directly to NT Calls : TransmitFile, ReadFile and WriteFile

	Each CIO object will create 'Packets' (objects derived from CPacket which are
	passed to the channel to execute through the appropriate NT Call.
	The underlying Channel will process either 'send' the 'packets' directly through a
	call to NT (ie. ReadFile, WriteFile or TransmitFile) or will send the packet to
	a 'CIODriverSource' object which will munge the packets if the session is encrypted.
	(Likewise, CReadPacket's will be munged by the CIODriverSource object before a CIO object
	gets to see the 'completed read'.)

	NOTE : Packets basically wrap OVERLAP structures with extra information about buffers,
	sequence numbers etc....

	There are a special set of CIO objects derived from CIOPassThru which are used by
	CIODriverSource objects to handle SSPI sessions.  (ie. CIOSealMessage and CIOUnsealMessage).
	Together with CIOServerSSL, these objects do the actual encrypt/decrypt and authentication of
	SSPI sessions.   CIOPassThru derives from CIO, however it provides a new and slightly different
	interface which is used by the CIODriverSource to provide the extra info needed to encrypt
	and decrypt.

	The basics of the CIO Interface are as follows :

	Start() -  Issue the first set of packets which start the IO operation

	Complete() - There is a complete function for each of the 3 packets that may be issued.
				When the async IO operation is completed the CIO objects Complete function
				will be called with the now completed 'Packet'.
	
	And in the case of CIOPassThru derived objects there are additionally :

	InitRequest() - There is an InitRequest function for each of the 3 packets that mahy be
				issued.  This gives the CIOPassThru object a chance to massage the Data before
				it is handed off to NT.	

--*/



#ifndef	_CIO_H_
#define	_CIO_H_

#ifdef	DEBUG
#ifndef	CIO_DEBUG
#define	CIO_DEBUG
#endif
#endif

//
// CPool Signature
//

#define CIO_SIGNATURE (DWORD)'1516'





// Forward definition !

#ifndef	_NO_TEMPLATES_

typedef	CRefPtr< CSessionState >	CSTATEPTR ;

#else

typedef	class	INVOKE_SMARTPTR( CSessionState )	CSTATEPTR ;

#endif


//
//	This is the base class defining the virtual interface for all IO operations.
//
//	InitClass() must be called before any objects are created to setup
//	the Pool allocator for the class.
//
class	CIO		{
protected :

	//
	//	Reference Count !
	//
	long	m_refs ;

	//
	//	Smart pointer to the state which gets completion notifications from the
	//	CIO object.
	//
	CSTATEPTR		m_pState ;

	//
	//	The following are initialized after we initialize our buffer management system
	//	Use these to size buffers for generic reads and writes.
	//
	static	DWORD	cbSmallRequest ;
	static	DWORD	cbMediumRequest ;
	static	DWORD	cbLargeRequest ;
	

	//
	//	Protected constructors - only derived classes may exist !
	//
	inline	CIO( ) ;
	inline	CIO( CSessionState*	pState ) ;		// protected so only derived class can construct !

	//
	//	Any kind of IO error will result in Shutdown being called !
	//
	virtual	void	Shutdown(	
							CSessionSocket*	pSocket,	
							CIODriver&	pdriver,	
							enum	SHUTDOWN_CAUSE	cause,	
							DWORD	dwError
							) ;

	inline	void	operator	delete( void *pv ) ;	

	//
	//	Destructor is protected as we only want derived classes to hit it
	//
	virtual	~CIO() ;

public :

	//
	//
	//	Call InitClass() before allocating any objects, TermClass() when all are freed.
	//		We override new and delete for CIO and all derived object.
	//
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;
	
	//
	//	Allocate and release to CPool
	//
	inline	void*	operator	new(	size_t	size, CIODriver& sink ) ;
	inline	static	void	Destroy( CIO*	pio, CIODriver& sink ) ;
	inline	void	DestroySelf() ;
	inline	long	AddRef() ;
	inline	long	RemoveRef() ;
	
	//
	//	IO Interface -
	//	Use these functions to initiate and complete IO operations.
	//
	//	This function MUST be overriden by a derived class.
	//
	virtual	BOOL	Start(	
						CIODriver&	driver,	
						CSessionSocket*	pSocket,
						unsigned cAhead = 0
						) = 0 ;

	//
	//	These are not pure virtual functions as some derived CIO operations do
	//	not ever issue particular kinds of packets, and hence never Complete certain Packet Types either.
	//
	//	However, all of these will DebugBreak() if called !
	//

	//
	//	Process a completed read
	//
	virtual	int
	Complete(	IN CSessionSocket*,
				IN	CReadPacket*,	
				OUT	CIO*	&pio
				) ;

	//
	//	Process a completed write
	//
	virtual	int	
	Complete(	IN CSessionSocket*,
				IN	CWritePacket*,	
				OUT	CIO*	&pio
				) ;

	//
	//	Process a completed TransmitFile
	//
	virtual	void	
	Complete(	IN CSessionSocket*,
				IN	CTransmitPacket*,	
				OUT	CIO*	&pio
				) ;

	//
	//	Process a deferred completion !
	//
	virtual	void
	Complete(	IN	CSessionSocket*,
				IN	CExecutePacket*,
				OUT	CIO*	&pio
				) ;

	//
	//	Indicate whether this CIO operation 'Reads' data -
	//	basically usefull for ASSERT checking
	//
	virtual	BOOL	IsRead()	{	return	FALSE ;	}

	//		Termination interface - when an unexpected error occurs
	//	the CIODriver object will call DoShutdown.  DoShutdown insures that
	//	the current state's Notification functions are called and then it
	//	calls the derived CIO object's shutdown function.
	//	Since more than one CIODriver may reference a CIO object, Shutdown() and DoShutdown()
	//	must figure out whether the object should be deleted.  If the object should be deleted,
	//	return	TRUE, otherwise return FALSE.
	//
	void	DoShutdown(	
						CSessionSocket*	pSocket,	
						CIODriver&	driver,	enum	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwError ) ;

} ;

#ifdef _NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CIO )

#endif

//
//	Some IO operations are clearly 'Reads' and hence are derived from here.
//	This class has no functionality, only exists to make sure 'Reads' and 'Writes' dont get
//	confused.
//
class	CIORead : public	CIO	{
protected :
	inline	CIORead(	CSessionState*	pState ) ;
	BOOL	IsRead()	{	return	TRUE ;	}
#ifdef	DEBUG
	~CIORead() {}
#endif
} ;

//
//	Some IO operations are clearly 'Writes' and hence are derived from here.
//	This class has no functionality, only exists to make sure 'Reads' and 'Writes' dont get
//	confused.
//
class	CIOWrite : public	CIO	{
protected :
	inline	CIOWrite(	CSessionState*	pState ) ;
#ifdef	DEBUG
	~CIOWrite()	{}
#endif

} ;

#ifdef _NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CIORead )
DECLARE_SMARTPTRFUNC( CIOWrite )

#endif


class	CIOPassThru	: public CIO	{
//
//	All CIO objects which wish to operate with a CIODriverSource object must derive
//	from this class and support its interface.
//	
//	CIOPassThru on its own will move all data through without touching -
//	not usefull except for debugging CIODriverSource objects.
//
//

public :
	CIOPassThru() ;

	//
	//	Take a ReadPacket prepared by somebody else, and do whatever we want to adjust
	//	it before sending it on
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CReadPacket*	pPacket,	
						BOOL&	fAcceptRequests
						) ;

	//
	//	Take a Write Packet that has been issued and do whatever munging is necessary -
	//	ie. encrypt the data.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CWritePacket*	pWritePacket,	
						BOOL&	fAcceptRequests
						) ;

	//
	//	Take a TransmitPacket and do what ever filtering is necessary - ie encrypt
	//	the data.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CTransmitPacket*	pTransmitPacket,	
						BOOL&	fAcceptRequests	
						) ;

	//
	//	Start a CIO operation
	//
	BOOL	Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	//
	//	Start a CIOPassThru operation
	//
	virtual	BOOL	Start(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,
						BOOL	&fAcceptRequests,	
						BOOL	&fRequireRequests,	
						unsigned cAhead = 0
						) ;

	//
	//	Do the necessary filtering on a completed read before passing
	//	to the higher protocol layers - this will mean decrypting data etc...
	//
	virtual	int Complete(	
						IN CSessionSocket*,
						IN	CReadPacket*,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest
						) ;

	//
	//	Do the necessary filtering of a completed write before passing
	//	on to the higher layers
	//
	virtual	int	Complete(	
						IN CSessionSocket*,
						IN	CWritePacket*,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest
						) ;

	//
	//	Do the necessary filtering of a completed TransmitFile
	//
	virtual	void	Complete(	
						IN CSessionSocket*,
						IN	CTransmitPacket*,	
						CPacket*	pRequest,	
						BOOL&	fCompleteRequest
						) ;

} ;


#ifdef _NO_TEMPLATES_
DECLARE_SMARTPTRFUNC( CIOPassThru )
#endif


class	CIOSealMessages : public	CIOPassThru	{
//
//	Only exists to perform SSPI Seals on outbound packets.
//
//	NOTE : CTransmitPacket's will probably require another CIOPassThru derived class !
//	This class will only process individual CWritePacket's
//
private:
	//	
	//	Encryption Context which has our SSL keys, SSPI interface etc...
	//
	CEncryptCtx&	m_encrypt ;

protected:

#ifdef	DEBUG
	~CIOSealMessages()	{}
#endif

public :
	
	//
	//	Must build with an Encryption Context ready to go
	//
	CIOSealMessages( CEncryptCtx&	encrypt ) ;

	
	//
	//	The InitRequest will Seal the message and then issue it to
	//	the socket.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CWritePacket*	pWritePacket,	
						BOOL&	fAcceptRequests
						) ;

	//
	//
	//
	virtual	BOOL	Start(	
						CIODriverSource&	driver,	
						CSessionSocket*	pSocket,
						BOOL	&fAcceptRequests,	
						BOOL	&fRequireRequests,	
						unsigned cAhead = 0
						) ;

	//
	//	Completion of Seal'd messages is easy - just mark the pRequest
	//	packet as transferring all of its bytes and indicate that it
	//	should be returned to its originator
	//
	virtual	int	Complete(	IN CSessionSocket*,
							IN	CWritePacket*,	
							CPacket*	pRequest,	
							BOOL&	fCompleteRequest ) ;

	//
	//	We don't have any shutdown processing to do - this will just
	//	return
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	pdriver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

protected :
	//
	//	Util function for Sealing a packet - for internal use only
	//
	BOOL	SealMessage(	
					IN	class	CRWPacket*	pPacket
					)
	{
		SECURITY_STATUS	ss = ERROR_NOT_SUPPORTED ;
		DWORD			cbNew;
		BOOL			fRet = FALSE ;

		fRet = m_encrypt.SealMessage(
						(LPBYTE)pPacket->StartData(),
						pPacket->m_ibEndData - pPacket->m_ibStartData,
						(LPBYTE)pPacket->StartData() - m_encrypt.GetSealHeaderSize(),
						&cbNew );

   		if( fRet )
		{
   			pPacket->m_ibStartData -= m_encrypt.GetSealHeaderSize();
   			pPacket->m_ibEndData += m_encrypt.GetSealTrailerSize();

			_ASSERT( pPacket->m_ibEndData - pPacket->m_ibStartData == cbNew );
   		}

		return	ss;
	}
}  ;

class	CIOUnsealMessages : public	CIOPassThru	{
//
//	Only exists to process inbound read packets and Unseal them.
//
private:
	//
	//	Encryption Context we use to unseal the message
	//
	CEncryptCtx&	m_encrypt ;

	//
	//	A buffer containing partially read data for incomplete Unseal's
	//
	CBUFPTR			m_pbuffer ;
	
	//
	//	Number of bytes we need to build a complete Unseal'able message
	//	in our buffer.  This can be 0 in cases where we can't figure out
	//	how many bytes we need !!!
	//
	DWORD			m_cbRequired ;

	//
	//	Starting point of the usable portion of the buffer
	//
	DWORD			m_ibStart ;

	//
	//	Start of the encrypted data within the buffer
	//
	DWORD			m_ibStartData ;

	//
	//	End of the usable range of bytes within the buffer
	//
	DWORD			m_ibEnd ;

	//
	//	Last byte of received data within the buffer
	//
	DWORD			m_ibEndData ;

protected:

#ifdef	DEBUG
	~CIOUnsealMessages()	{}
#endif

public :

	//
	//	Build a CIOUnsealMessages block - always require an encryption context
	//
	CIOUnsealMessages(
					CEncryptCtx&	encrypt
					) ;

	//
	//	Very little to do when a Read request is issued - just
	//	turn the request around and issue a read against the socket.
	//
	BOOL	InitRequest(
					class	CIODriverSource&	driver,	
					CSessionSocket*	pSocket,	
					CReadPacket*	pReadPacket,	
					BOOL&	fAcceptRequests
					) ;

	//
	//
	//
	BOOL	Start(	CIODriverSource&	driver,	
					CSessionSocket*	pSocket,
					BOOL	&fAcceptRequests,	
					BOOL	&fRequireRequests,	
					unsigned cAhead = 0
					) ;

	//
	//	On completed reads we will copy data out of the buffer
	//	in order to build complete Unseal'able blocks of data.
	//
	int	Complete(	IN CSessionSocket*,
					IN	CReadPacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	//
	//	Very little shutdown work we need to do
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	pdriver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

protected :

	//
	//	Utility function which wraps up our calls to the CEncryptCtx
	//
	BOOL	UnsealMessage(	
					CBuffer&		buffer,
					DWORD&			cbConsumed,
					DWORD&			cbRequired,
					DWORD&			ibStartData,
					DWORD&			ibEndData,
					BOOL&			fComplete
		            )
	{
		SECURITY_STATUS	ss = ERROR_NOT_SUPPORTED ;
		LPBYTE			pbDecrypt;
		DWORD			cbDecrypted;
		DWORD			cbExpected;
		DWORD			ibSaveStartData = ibStartData;
		BOOL			fSuccess = FALSE ;
		fComplete = FALSE ;

		fSuccess = m_encrypt.UnsealMessage(
						(LPBYTE)buffer.m_rgBuff + ibStartData,
						ibEndData - ibStartData,
						&pbDecrypt,
						&cbDecrypted,
						&cbExpected );

		ss = GetLastError() ;

        if ( fSuccess )
		{
			ibStartData = (DWORD)(pbDecrypt - (LPBYTE)buffer.m_rgBuff);
			ibEndData = ibStartData + cbDecrypted;
			cbConsumed = ibEndData - ibSaveStartData;
			fComplete = TRUE ;

			_ASSERT( cbConsumed == m_encrypt.GetSealHeaderSize() + cbDecrypted );
        }
		else if( ss == SEC_E_INCOMPLETE_MESSAGE )
		{
			cbRequired = cbExpected;
			cbConsumed = ibEndData - ibStartData;
			fSuccess = TRUE ;
        }
		else
		{
			//	
			//	Some kind of unanticipated error occurred - return FALSE
			//	and let caller blow the session off.
			//
			cbConsumed = 0;
			cbRequired = 0;
			ibStartData = 0;
			ibEndData = 0;
		}

		return	fSuccess;
	}

	BOOL	DecryptInputBuffer(	
						IN	LPBYTE	pBuffer,
						IN	DWORD	cbInBuffer,
						OUT	DWORD&	cbLead,
						OUT	DWORD&	cbConsumed,
						OUT	DWORD&	cbData,
						OUT	DWORD&	cbRequired,
						OUT	BOOL&	fComplete
						) ;

}  ;

class	CIOTransmitSSL : public	CIOPassThru	{
private :

	//
	//	Encryption context to use to encrypt the file data
	//	this actually lives in a CSessionSocket::m_context object,
	//	and we just keep a reference here to speed things up.
	//
	CEncryptCtx&	m_encryptCtx ;
	
	//
	//	The CIODriverSource which will process completions
	//
	CDRIVERPTR		m_pSocketSink ;

	//
	//	The CIODriverSink which originated the TransmitFile request
	//
	CDRIVERPTR		m_pDriverSource ;
	
	//
	//	The CChannel from which we are reading the data
	//
	CFILEPTR		m_pFileChannel ;

	//
	//	The File Driver from which will handle completion of file IO's
	//
	CSINKPTR		m_pFileDriver ;

	//
	//	The TransmitFileBuffers which will be sent in the message
	//
	TRANSMIT_FILE_BUFFERS	*m_pbuffers ;

	//
	//	This is initialized to a negative number, the absolute value of
	//	which tells us how many reads we want to always have pending.
	//	Each time we issue a read we will InterlockedIncrement this,
	//	and when we reach zero we know that we are so many reads ahead.
	//
	long			m_cReads ;

	//
	//	Number of Writes that have been issued
	//
	DWORD			m_cWrites ;

	//
	//	Number of writes that have beeen completed
	//
	DWORD			m_cWritesCompleted ;

	//
	//	Current position within the file.
	//
	DWORD			m_ibCurrent ;

	//
	//	Final position within the file.
	//
	DWORD			m_ibEnd ;

	//
	//	Number of bytes of trailer text sent
	//
	DWORD			m_cbTailConsumed ;

	//
	//	Are we finished yet ?
	//
	BOOL			m_fCompleted ;

	//
	//	Number of Reads that have been flow controlled
	//
	long			m_cFlowControlled ;

	//	
	//
	//	
	BOOL			m_fFlowControlled ;

	//
	//	Setup the next read
	//
	void	ComputeNextRead(
					CReadPacket*	pRead
					) ;


	//
	//	Given a read and a write packet, adjust the write packet
	//	for any extra data we had prepended to the read, and figure
	//	out if this is the last read necessary from the file.
	//
	BOOL	CompleteRead(
					CReadPacket*	pRead,
					CWritePacket*	pWrite
					) ;

	//
	//	Release all of our stuff, and get ready for a new call
	//	to InitRequest()
	//
	void	Reset() ;


	BOOL	SealMessage(	
					IN	class	CRWPacket*	pPacket
					)
	{
		SECURITY_STATUS	ss = ERROR_NOT_SUPPORTED ;
		DWORD			cbNew;
		BOOL			fRet = FALSE ;

		fRet = m_encryptCtx.SealMessage(
						(LPBYTE)pPacket->StartData(),
						pPacket->m_ibEndData - pPacket->m_ibStartData,
						(LPBYTE)pPacket->StartData() - m_encryptCtx.GetSealHeaderSize(),
						&cbNew );

   		if( fRet )
		{
   			pPacket->m_ibStartData -= m_encryptCtx.GetSealHeaderSize();
   			pPacket->m_ibEndData += m_encryptCtx.GetSealTrailerSize();

			_ASSERT( pPacket->m_ibEndData - pPacket->m_ibStartData == cbNew );
   		}

		return	ss;
	}

protected :
#ifdef	DEBUG
	~CIOTransmitSSL()	{}
#endif

public :

	//
	//	Globals which control flow control !
	//
	static	DWORD	MAX_OUTSTANDING_WRITES ;
	static	DWORD	RESTORE_FLOW ;


	CIOTransmitSSL(
					CEncryptCtx&	encrypt,
					CIODriver&		sink
					) ;

	//
	//	Called to start transferring a file when
	//	we have gotten an initial TransmitFile request
	//
	BOOL	InitRequest(
					class	CIODriverSource&	driver,	
					CSessionSocket*		pSocket,	
					CTransmitPacket*	pTransmitPacket,	
					BOOL&				fAcceptRequests
					) ;

	//
	//	This is called when we are ready to start issuing reads
	//	to a file
	//
	BOOL	Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	//
	//	Called when file reads complete.
	//
	int Complete(	IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	BOOL	Start(	CIODriverSource&	driver,	
					CSessionSocket*	pSocket,
					BOOL	&fAcceptRequests,	
					BOOL	&fRequireRequests,	
					unsigned cAhead = 0
					) ;

	//
	//	Called when a write to a socket completes.
	//
	int	Complete(	IN CSessionSocket*,
					IN	CWritePacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	//
	//	Tear down stuff, if cause == CAUSE_NORMAL_CIO_TERMINATION
	//	then everything has been succesfull, and we only need tear down
	//	our file stuff.
	//	Otherwise, we need to tear down the socket drivers as well.
	//
	void	Term(	
					CSessionSocket*	pSocket,
					enum	SHUTDOWN_CAUSE	cause,
					DWORD	dwError
					) ;					

	//
	//	Our notification function which is called when we terminate
	//	CIODrivers.  This will be called in regular operation as we
	//	finish async IO to different file handles.
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	pdriver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

	static	void	ShutdownFunc(
						void*	pv,
						SHUTDOWN_CAUSE	cause,
						DWORD			dwOptionalError
						) ;

} ;



class	CIOServerSSL	:	public	CIO	{
//
//	Server Side SSL logons.  This CIO object can be
//	issued onto a CIODriverSink at startup, and will do
//	all of the necessary SSL negogtiation to get a session
//	key etc... Once this is established, we'll insert an
//	underlying CIODriverSource mechanism to filter
//	(encrypt/decrypt) all packets on the fly.
//
private :
	
	//
	//	Context we are using for encryption - hold SSPI stuff
	//
	CEncryptCtx		&m_encrypt ;

	//
	//	The write packet we are going to put our data in when
	//	we successfully call m_encrypt.Converse().
	//
	CWritePacket*	m_pWrite ;

	//
	//	Keep track of whether we have successfully authenticated yet.
	//
	BOOL			m_fAuthenticated ;

	//
	//	Number of IO's pending
	//
	long			m_cPending ;

	//
	//	Keep track of CIODriver sequence numbers so that we can
	//	insert a CIODriverSource into the stream later
	//
	SEQUENCENO		m_sequencenoNextRead ;
	SEQUENCENO		m_sequencenoNextWrite ;

	//
	//	Our start function will get called twice - make sure
	//	we don't get messed up because of this.
	//
	BOOL			m_fStarted ;

	//
	//	A buffer containing partially read data for incomplete Unseal's
	//
	CBUFPTR			m_pbuffer ;

	//
	//	Starting offset of data within the buffer
	//
	DWORD			m_ibStartData ;

	//
	//	Number of bytes of data we already have in the buffer !!
	//
	DWORD			m_ibEndData ;

	//
	//	Last byte we can use in the buffer !!
	//
	DWORD			m_ibEnd ;

protected :
	//
	//	Destructor ensures that m_pWrite is released !!
	//
	~CIOServerSSL( ) ;

public :
	//
	//	Create a CIOServerSSL object
	//
	CIOServerSSL(
			CSessionState	*pstate,
			CEncryptCtx& encrypt
			) ;
	
	//
	//	Create a CIODriverSource and initialize it to handle
	//	encryption/decryption
	//
	BOOL	SetupSource(
					CIODriver&	driver,
					CSessionSocket*	pSocket
					) ;

	//
	//	Start stuff going - issue initial reads and the like
	//
	BOOL	Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	//
	//	Next packet in the negogtiation - let SSPI examine it
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	Process completions of our negogtiated packets
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	void	Complete(	
					IN CSessionSocket*,
					IN	CTransmitPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	An error has occurred and the ssession is being blown off.
	//	Very little shutdown work we need to do
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	pdriver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;


} ;

class	CIOShutdown : public CIOPassThru	{
//
//	This CIO object exists solely to help shutdown processing.
//	IO's that are outstanding when a CIODriver is shutdown need to
//	have some minimum processing done during termination, we do that.
//
public :

	//
	//	Build a CIOShutdown object - only one is every built, its
	//	a global.  We put the reference count to an artificially
	//	high number so we never mistakenly think we have to delete it.
	//
	CIOShutdown()	{	m_refs = 0x40000000 ; }

	//
	//	Desctructor -
	//
	~CIOShutdown()	{
#ifdef	_ENABLE_ASSERTS
		m_refs = -1 ;
#endif
	}	


	//
	//	swallow this call - we're dying and if somebody is still trying to do
	//	IO, to bad for them.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CReadPacket*	pPacket,	
						BOOL&	fAcceptRequests
						) ;

	//
	//	swallow this call - we're dying and if somebody is still trying to do
	//	IO, to bad for them.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CWritePacket*	pWritePacket,	
						BOOL&	fAcceptRequests
						) ;


	//
	//	swallow this call - we're dying and if somebody is still trying to do
	//	IO, to bad for them.
	//
	virtual	BOOL	InitRequest(
						class	CIODriverSource&	driver,	
						CSessionSocket*	pSocket,	
						CTransmitPacket*	pTransmitPacket,	
						BOOL&	fAcceptRequests	
						) ;


	//
	//	We don't need this function except to fill our vtbl.
	//
	BOOL	Start(	
					CIODriver&	driver,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	void	Complete(	
					IN CSessionSocket*,
					IN	CTransmitPacket*,	
					CPacket*	pRequest,	
					BOOL&	fCompleteRequest
					) ;

	void	Complete(	
					IN CSessionSocket*,
					IN	CTransmitPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	Process a deferred completion ! - just swallow it !
	//
	void	Complete(	
					IN	CSessionSocket*,
					IN	CExecutePacket*,
					OUT	CIO*	&pio
					) ;

} ;

class	CIOGetArticle : public	CIORead	{
//
//	Do all the IO's necessary to transfer a complete posting
//	from a socket to a file.
//
protected :

	//
	//	Variable to hold onto the tail pattern we're looking for.
	//
	static	char	szTailState[] ;

	//
	//	Varitable to hold onto the head separator patter we're looking for.
	//
	static	char	szHeadState[] ;

	//
	//	The directory to hold the temporary file, if necessary !
	//
	LPSTR			m_lpstrTempDir ;

	//
	//	The prefix for the temporary file, if necessary !
	//
	char			(&m_szTempName)[MAX_PATH];

	//
	//	The CIODriver where we are getting our socket read completions
	//
	CDRIVERPTR		m_pSocketSink ;
	
	//
	//	The CChannel which is handling our File Writes
	//
	CFILEPTR		m_pFileChannel ;

	//
	//	The CIODriver which processes completions of our File Writes
	//
	CSINKPTR		m_pFileDriver ;

	//
	//	Keep track of our Initialization state, in case we are
	//	destroyed before entirely started
	//
	BOOL			m_fDriverInit ;	// TRUE if m_pFileDriver->Init() was called !

	//
	//	Number of empty bytes the caller wants the file to start with !
	//
	DWORD			m_cbGap ;
	
	//
	//	Hard Limit - drop session if this is exceeded.
	//
	DWORD			m_cbLimit ;

	//
	//	The STRMPOSITION which will exceed our hard limit
	//
	STRMPOSITION	m_HardLimit ;

	//
	//	A pointer into szTailState[] indicating what portion of the
	//	trail pattern we've recognized
	//
	LPSTR			m_pchTailState ;

	//
	//	A pointer into szHeadState[] which determines helps us
	//	determine whether we've found the complete head of the article
	//
	LPSTR			m_pchHeadState ;

	//
	//	A smart pointer to a buffer which holds the head of the article
	//
	CBUFPTR			m_pArticleHead ;
	//
	//	The start of the head of the article within the buffer
	//
	DWORD			m_ibStartHead ;
	//
	//	The end of the head of the article within the buffer
	//
	DWORD			m_ibEndHead ;
	//
	//	The starting offset of header bytes within the buffer
	//
	DWORD			m_ibStartHeadData ;
	//
	//	The ending offset of all data within the header buffer
	//
	DWORD			m_ibEndHeadData ;
	//
	//	Number of bytes in the header
	//
	DWORD			m_cbHeadBytes ;
	//
	//	Boolean indicating whether we can stuff non-header bytes into
	//	m_pArticleHead
	//
	BOOL			m_fAcceptNonHeaderBytes ;

	//	The end of the article within the buffer if m_fWholeArticle is TRUE !
	//
	DWORD			m_ibEndArticle ;

	//
	//	Maximum number of Reads that we should be ahead of Writes
	//
	static	unsigned	maxReadAhead ;

	//
	//	Number of bytes which is too small to issue as one file write
	//	accumulate more bytes before doing file IO.
	//
	static	unsigned	cbTooSmallWrite ;

	//
	//	Number of writes issued
	//
	unsigned		m_cwrites ;	//	Count of Writes that were issued

	//
	//	Number of writes that have completed
	//
	unsigned		m_cwritesCompleted ;	// Count of Writes that were completed
	long			m_cFlowControlled ;	// Number of times we should have issued reads
									// but didn't due to flow control to the disk!
	
	long			m_cReads ;			// Number of reads

	//	
	//	Are we in our flow control state
	//
	BOOL			m_fFlowControlled ;

	//
	//	A write packet we are using to accumulate bytes for FILE IO
	//
	CWritePacket*	m_pWrite ;
	
#ifdef	CIO_DEBUG
	//
	//	Debug variables used to ensure that callers properly use Init() Term() interface !
	//
	BOOL			m_fSuccessfullInit ;
	BOOL			m_fTerminated ;
#endif

	//
	//	How many bytes are available in the header storage area ?
	//
	inline	DWORD	HeaderSpaceAvailable() ;

	//
	//	Copy bytes into our header buffer and adjust all the members
	//	to reflect the number of bytes used within the header !
	//
	inline	void	FillHeaderSpace(	
							char*	pchData,
							DWORD	cbData
							) ;

	//
	//	Try to get a larger buffer to hold header information -
	//
	inline	BOOL	GetBiggerHeaderBuffer(
							CIODriver&	driver,
							DWORD		cbRequired
							) ;

	//
	//	Initialize the buffer we're using to hold header information -
	//	grab the buffer right out of the incoming read !!
	//
	inline	void	InitializeHeaderSpace(
							CReadPacket*	pRead,
							DWORD			cbArticleBytes
							) ;

	//
	//	When errors occur call this guy to set us into a state
	//	where we continue to read but end up telling m_pState
	//	that the article transfer failed !!
	//
	inline	BOOL	ResetHeaderState(
							CIODriver&	driver
							) ;

	//
	//	Function for calling m_pStates completion function when
	//	we have completed all the necessary IO's
	//
	void	DoCompletion(	CSessionSocket*	pSocket,
							HANDLE	hFile,
							DWORD	cbFullBuffer,
							DWORD	cbTotalTransfer,
							DWORD	cbAvailableBuffer,
							DWORD	cbGap = 0
							) ;


	//
	//	This function sets things up so that we can start doing
	//	async file IO !
	//
	BOOL	InitializeForFileIO(
								CSessionSocket*	pSocket,
								CIODriver&		readDriver,
								DWORD			cbHeaderBytes
								) ;

	//
	//	Destructor is protected to force clients to use
	//	the correct destruction method !
	//
	~CIOGetArticle( ) ;

public :
	CIOGetArticle(	CSessionState*	pstate,
					CSessionSocket*	pSocket,	
					CDRIVERPTR&	pDriver,
					LPSTR	lpstrTempDir,	
					char	(&lpstrTempName)[MAX_PATH],
					DWORD	cbLimit,	
					BOOL	fSaveHead = FALSE,
					BOOL	fPartial = FALSE )	;

	//
	//	Initialization and termination functions
	//	
	//	After we've been successfully initialized the user must not delete us,
	//	instead they must call our Term function
	//
	BOOL	Init(	CSessionSocket*	pSocket,	
					unsigned cbOffset = 0
					) ;

	//
	//	Termination function - tear down at least the CIODriver for the file
	//	IO, and maybe tear down the Socket's CIODriver (and session as well)
	//
	void	Term(	CSessionSocket*	pSocket,	
					BOOL	fAbort = TRUE,	
					BOOL	fStarted = TRUE
					) ;

	//
	//	Do everything we need to do regarding flow control
	//
	void	DoFlowControl(PNNTP_SERVER_INSTANCE pInstance) ;

	//
	//	Issue our first IO's
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket	*pSocket,	
					unsigned cAhead = 0	
					) ;

	//
	//	A Read from the socket has completed
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	A Write to the file has completed
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	One of the 2 CIODriver's we use is being torn down,
	//	figure out if the other one needs to be torn down as well.
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	driver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

	static	void	ShutdownFunc(	
						void	*pv,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptionalError
						) ;		
} ;

class	CIOGetArticleEx : public	CIORead	{
//
//	Do all the IO's necessary to transfer a complete posting
//	from a socket to a file.
//
protected :

	//
	//	The CIODriver where we are getting our socket read completions
	//
	CDRIVERPTR		m_pSocketSink ;
	//
	//	The CChannel which is handling our File Writes
	//
	CFILEPTR		m_pFileChannel ;
	//
	//	The CIODriver which processes completions of our File Writes
	//
	CSINKPTR		m_pFileDriver ;
	//
	//	Keep track of our Initialization state, in case we are
	//	destroyed before entirely started
	//
	BOOL			m_fDriverInit ;	// TRUE if m_pFileDriver->Init() was called !
	//
	//	Do we want to swallow all of the incoming bytes ?
	//	
	BOOL			m_fSwallow ;
	//
	//	Hard Limit - drop session if this is exceeded.
	//
	DWORD			m_cbLimit ;
	//
	//	The STRMPOSITION which will exceed our hard limit
	//
	STRMPOSITION	m_HardLimit ;
	//
	//	The string we are to match to find the end of this section !
	//
	LPSTR			m_pchMatch ;
	//
	//	A pointer into szTailState[] indicating what portion of the
	//	trail pattern we've recognized
	//
	LPSTR			m_pchTailState ;
	//
	//	The string that if we match indicates some kind of early error
	//	completion !
	//
	LPSTR			m_pchErrorMatch ;
	//
	//	The state of matching the error string !
	//
	LPSTR			m_pchErrorState ;
	//
	//	A smart pointer to a buffer which holds the head of the article
	//
	CBUFPTR			m_pArticleHead ;
	//
	//	The start of the head of the article within the buffer
	//
	DWORD			m_ibStartHead ;
	//
	//	The end of the head of the article within the buffer
	//
	DWORD			m_ibEndHead ;
		//
	//	The starting offset of header bytes within the buffer
	//
	DWORD			m_ibStartHeadData ;
	//
	//	The ending offset of all data within the header buffer
	//
	DWORD			m_ibEndHeadData ;
	//
	//	Maximum number of Reads that we should be ahead of Writes
	//
	static	unsigned	maxReadAhead ;

	//
	//	Number of bytes which is too small to issue as one file write
	//	accumulate more bytes before doing file IO.
	//
	static	unsigned	cbTooSmallWrite ;

	//
	//	Number of writes issued
	//
	unsigned		m_cwrites ;	//	Count of Writes that were issued

	//
	//	Number of writes that have completed
	//
	unsigned		m_cwritesCompleted ;	// Count of Writes that were completed
	long			m_cFlowControlled ;	// Number of times we should have issued reads
									// but didn't due to flow control to the disk!
	
	long			m_cReads ;			// Number of reads

	//	
	//	Are we in our flow control state
	//
	BOOL			m_fFlowControlled ;

	//
	//	A write packet we are using to accumulate bytes for FILE IO
	//
	CWritePacket*	m_pWrite ;
	
#ifdef	CIO_DEBUG
	//
	//	Debug variables used to ensure that callers properly use Init() Term() interface !
	//
	BOOL			m_fSuccessfullInit ;
	BOOL			m_fTerminated ;
#endif


	//
	//	How many bytes are available in the header storage area ?
	//
	inline	DWORD	HeaderSpaceAvailable() ;

	//
	//	Copy bytes into our header buffer and adjust all the members
	//	to reflect the number of bytes used within the header !
	//
	inline	void	FillHeaderSpace(	
							char*	pchData,
							DWORD	cbData
							) ;

	//
	//	Try to get a larger buffer to hold header information -
	//
	inline	BOOL	GetBiggerHeaderBuffer(
							CIODriver&	driver,
							DWORD		cbRequired
							) ;

	//
	//	Initialize the buffer we're using to hold header information -
	//	grab the buffer right out of the incoming read !!
	//
	inline	void	InitializeHeaderSpace(
							CReadPacket*	pRead,
							DWORD			cbArticleBytes
							) ;

	//
	//	This function sets things up so that we can start doing
	//	async file IO !
	//
	BOOL	InitializeForFileIO(
								FIO_CONTEXT*	pFIOContext,
								CSessionSocket*	pSocket,
								CIODriver&		readDriver,
								DWORD			cbHeaderBytes
								) ;

	//
	//	Destructor is protected to force clients to use
	//	the correct destruction method !
	//
	~CIOGetArticleEx( ) ;

	//
	//	Are we a legal object !
	//
	BOOL
	FValid() ;

public :
	CIOGetArticleEx(	
					CSessionState*	pstate,
					CSessionSocket*	pSocket,	
					CDRIVERPTR&	pDriver,
					DWORD	cbLimit,
					LPSTR	szMatch,
					LPSTR	pchInitial,
					LPSTR	szErrorMatch,
					LPSTR	pchInitialError
					)	;

	//
	//	Initialization and termination functions
	//	
	//	After we've been successfully initialized the user must not delete us,
	//	instead they must call our Term function
	//
	BOOL	Init(	CSessionSocket*	pSocket,	
					unsigned cbOffset = 0
					) ;

	//
	//	Termination function - tear down at least the CIODriver for the file
	//	IO, and maybe tear down the Socket's CIODriver (and session as well)
	//
	void	Term(	CSessionSocket*	pSocket,	
					BOOL	fAbort = TRUE,	
					BOOL	fStarted = TRUE
					) ;

	//
	//	Do everything we need to do regarding flow control
	//
	void	DoFlowControl(PNNTP_SERVER_INSTANCE pInstance) ;

	//
	//	Issue our first IO's
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket	*pSocket,	
					unsigned cAhead = 0	
					) ;

	//
	//	Start doing writes to the file !
	//
	BOOL	StartFileIO(
					CSessionSocket*	pSocket,
					FIO_CONTEXT*	pFIOContext,
					CBUFPTR&	pBuffer,
					DWORD		ibStartBuffer,
					DWORD		ibEndBuffer,
					LPSTR		szMatch,
					LPSTR		pchInitial
					) ;

	//
	//	A Read from the socket has completed
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	A Write to the file has completed
	//
	int		Complete(	
					IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	One of the 2 CIODriver's we use is being torn down,
	//	figure out if the other one needs to be torn down as well.
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	driver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

	static	void	ShutdownFunc(	
						void	*pv,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptionalError
						) ;		
} ;




class	CIOReadArticle : public	CIORead	{
//
//	Do all the IO's necessary to transfer a complete posting
//	from a socket to a file.
//
protected :

	//
	//	The CIODriver where we are getting our socket read completions
	//
	CDRIVERPTR			m_pSocketSink ;
	
	//
	//	The CChannel which is handling our File Writes
	//
	CFILEPTR			m_pFileChannel ;

	//
	//	The CIODriver which processes completions of our File Writes
	//
	CSINKPTR			m_pFileDriver ;

	//
	//	Keep track of our Initialization state, in case we are
	//	destroyed before entirely started
	//
	BOOL				m_fDriverInit ;	// TRUE if m_pFileDriver->Init() was called !
	
	//
	//	Hard Limit - drop session if this is exceeded.
	//
	DWORD				m_cbLimit ;

	//
	//	The STRMPOSITION which will exceed our hard limit
	//
	STRMPOSITION		m_HardLimit ;

	//
	//	State information regarding how much of the terminating CRLF.CRLF we've
	//	seend
	//	
	enum	ArtState	{
		NONE	= 0,
		NEWLINE	= 1,
		BEGINLINE	= 2,
		PERIOD = 3,
		COMPLETENEWLINE = 4,
		COMPLETE = 5,
	} ;
	
	//
	//	Current state of CRLF.CRLF	
	//
	ArtState	m_artstate ;

	//
	//	Maximum number of Reads that we should be ahead of Writes
	//
	static	unsigned	maxReadAhead ;

	//
	//	Number of bytes which is too small to issue as one file write
	//	accumulate more bytes before doing file IO.
	//
	static	unsigned	cbTooSmallWrite ;

	//
	//	Number of writes issued
	//
	unsigned	m_cwrites ;	//	Count of Writes that were issued

	//
	//	Number of writes that have completed
	//
	unsigned	m_cwritesCompleted ;	// Count of Writes that were completed
	long		m_cFlowControlled ;	// Number of times we should have issued reads
									// but didn't due to flow control to the disk!
	
	long		m_cReads ;			// Number of reads

	//	
	//	Are we in our flow control state
	//
	BOOL		m_fFlowControlled ;

	//
	//	A write packet we are using to accumulate bytes for FILE IO
	//
	CWritePacket*	m_pWrite ;

#ifdef	CIO_DEBUG
	//
	//	Debug variables used to ensure that callers properly use Init() Term() interface !
	//
	BOOL		m_fSuccessfullInit ;
	BOOL		m_fTerminated ;
#endif

	//
	//	Destructor is protected to force clients through
	//	correct destruction method
	//
	~CIOReadArticle( ) ;

public :
	CIOReadArticle(	CSessionState*	pstate,
					CSessionSocket*	pSocket,	
					CDRIVERPTR&	pDriver,	
					CFileChannel*	pFileChannel,
					DWORD	cbLimit,	
					BOOL	fPartial = FALSE )	;

	//
	//	Initialization and termination functions
	//	
	//	After we've been successfully initialized the user must not delete us,
	//	instead they must call our Term function
	//
	BOOL	Init(	CSessionSocket*	pSocket,	
					unsigned cbOffset = 0
					) ;

	//
	//	Termination function - tear down at least the CIODriver for the file
	//	IO, and maybe tear down the Socket's CIODriver (and session as well)
	//
	void	Term(	CSessionSocket*	pSocket,	
					BOOL	fAbort = TRUE,	
					BOOL	fStarted = TRUE
					) ;

	//
	//	Do everything we need to do regarding flow control
	//
	void	DoFlowControl(PNNTP_SERVER_INSTANCE pInstance) ;

	//
	//	Issue our first IO's
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket	*pSocket,	
					unsigned cAhead = 0	
					) ;

	//
	//	A Read from the socket has completed
	//
	int Complete(	IN CSessionSocket*,
					IN	CReadPacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	A Write to the file has completed
	//
	int	Complete(	IN CSessionSocket*,
					IN	CWritePacket*,	
					OUT	CIO*	&pio
					) ;

	//
	//	One of the 2 CIODriver's we use is being torn down,
	//	figure out if the other one needs to be torn down as well.
	//
	void	Shutdown(	CSessionSocket*	pSocket,	
						CIODriver&	driver,	
						enum	SHUTDOWN_CAUSE	cause,	
						DWORD	dwError
						) ;

	static	void	ShutdownFunc(	
						void	*pv,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptionalError
						) ;		
} ;



class   CIOReadLine ;

//-------------------------------------------------
class	CIOWriteLine :	public	CIOWrite	{
/*++

	Write an arbitrary line to a stream.

--*/
private :
	CWritePacket*	m_pWritePacket ;

	char*	m_pchStart ;
	char*	m_pchEnd ;
	static	unsigned	cbJunk ;
	enum	CONSTANTS	{
		WL_MAX_BYTES	= 768,
	} ;
protected :

	//
	//	Protected destructor to force clients through
	//	correct destruction method !
	//
	~CIOWriteLine( ) ;

public :
	CIOWriteLine( CSessionState*	pstate ) ;
	
	BOOL	InitBuffers( CDRIVERPTR&	pdriver,	CIOReadLine*	pReadLine ) ;
	BOOL	InitBuffers( CDRIVERPTR&	pdriver,	unsigned	cbLimit = WL_MAX_BYTES ) ;
	inline	char*	GetBuff(	unsigned	&cbRemaining = cbJunk ) ;
	inline	char*	GetTail( ) ;
	inline	void	SetLimits(	char*	pchStartData,	char*	pchEndData ) ;	
	inline	void	AddText(	unsigned	cb ) ;
	inline	void	Reset() ;
	
	BOOL	Start(	CIODriver&,	CSessionSocket*	pSocket,	unsigned	cReadAhead = 0 ) ;
	int	Complete(	IN	CSessionSocket*,	IN	CWritePacket*,	OUT CIO*	&pio ) ;
	void	Shutdown(	CSessionSocket*	pSocket,	CIODriver&	driver,	enum	SHUTDOWN_CAUSE	cause,	DWORD	dwError ) ;
} ;

//
//	This class exists to process CExecute derived objects - we will call
//	their Start and PartialExecute functions until they have sent all their data.
//
//
class	CIOWriteCMD :	public	CIOWrite	{
	//
	//	The CExecute derived object which is generating text to send
	//
	class	CExecute*	m_pCmd ;

	//
	//	The m_context - needed by *m_pCmd to get at the sessions state
	//
	struct	ClientContext&	m_context ;

	//
	//	A void pointer meaningless to us, but provided to m_pCmd on each
	//	call so the CExecute object can maintain some state accross calls
	//
	LPVOID		m_pv ;

	//
	//	The number of writes we've issued
	//
	unsigned	m_cWrites ;

	///
	//	The number of writes we've completed.
	//
	unsigned	m_cWritesCompleted ;

	//
	//	The size of the buffers we are using !
	//
	unsigned	m_cbBufferSize ;

	//
	//	Set to TRUE when we've issued the last write we're going to issue
	//
	BOOL		m_fComplete ;
	
	//
	//	Object which wants to collect log information !
	//
	class	CLogCollector*	m_pCollector ;

	//
	//	Destructor is protected to force clients through
	//	correct destruction mechanism !
	//
	~CIOWriteCMD( ) ;

public :

	//
	//	Create a CWriteCmd object which will execute
	//	the specified CExecute object.
	//
	CIOWriteCMD(	
			CSessionState*	pstate,	
			class	CExecute*	pCmd,	
			struct	ClientContext&	context,	
			BOOL	fIsLargeResponse,
			class CLogCollector*	pCollector=0
			) ;

	//
	//	Start calling the CExecute object and issuing
	//	write packets !
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead = 0
					) ;

	//
	//	Called as each write we issue completes !
	//
	int		Complete(	
					CSessionSocket*,	
					CWritePacket*,	
					CIO*&	
					) ;

	//
	//	Called when the session drops and we're still alive !!
	//
	void	Shutdown(	
					CSessionSocket*,	
					CIODriver&,	
					enum SHUTDOWN_CAUSE	cause,	
					DWORD	dw
					) ;
} ;


//
//	This class exists to process CExecute derived objects - we will call
//	their Start and PartialExecute functions until they have sent all their data.
//
//
class	CIOWriteAsyncCMD :	public	CIOWrite	{
	//
	//	The CExecute derived object which is generating text to send
	//
	class	CAsyncExecute*	m_pCmd ;

	//
	//	The m_context - needed by *m_pCmd to get at the sessions state
	//
	struct	ClientContext&	m_context ;

	//
	//	This is the function pointer into the Async Command that we use
	//	get our data !
	//
	typedef	CIOWriteAsyncComplete*	(CAsyncExecute::*PFNBUFFER)(
						BYTE*	pbStart,
						int		cb,
						struct	ClientContext&	context,
						class	CLogCollector*	pCollector
						) ;
	PFNBUFFER	m_pfnCurBuffer ;
	//
	//	The number of writes we've issued
	//
	unsigned	m_cWrites ;

	///
	//	The number of writes we've completed.
	//
	unsigned	m_cWritesCompleted ;

	//
	//	The size of the buffers we are using !
	//
	unsigned	m_cbBufferSize ;
	//
	//	Set to TRUE when we've issued the last write we're going to issue
	//
	BOOL	m_fComplete ;
	//
	//	Hold the packet we use for AsyncCommand completions if we need
	//	to do some flow control against the Command completions !
	//
	CExecutePacket*	m_pDeferred ;
	//
	//	Object which wants to collect log information !
	//
	class	CLogCollector*	m_pCollector ;
	//
	//	A void pointer meaningless to us, but provided to m_pCmd on each
	//	call so the CExecute object can maintain some state accross calls
	//
	LPVOID		m_pv ;
	//
	//	Destructor is protected to force clients through
	//	correct destruction mechanism !
	//
	~CIOWriteAsyncCMD( ) ;

	BOOL
	Execute(
			CExecutePacket*	pExecute,
			CIODriver&		driver,
			CSessionSocket*	pSocket,
			DWORD			cbInitialSize
			) ;

public :

	//
	//	Create a CWriteCmd object which will execute
	//	the specified CExecute object.
	//
	CIOWriteAsyncCMD(	
			CSessionState*	pstate,	
			class	CAsyncExecute*	pCmd,	
			struct	ClientContext&	context,	
			BOOL	fIsLargeResponse,
			class CLogCollector*	pCollector=0
			) ;


	//
	//	Completion function called by the Command object when its
	//	finished filling the buffer !
	//
	void
	CommandComplete(	BOOL	fLargerBuffer,
						BOOL	fComplete,
						DWORD	cbTransferred,
						CSessionSocket*	pSocket
						) ;
						

	//
	//	Start calling the CExecute object and issuing
	//	write packets !
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead = 0
					) ;

	//
	//	Process a deferred completion !
	//
	virtual	void
	Complete(	IN	CSessionSocket*,
				IN	CExecutePacket*,
				OUT	CIO*	&pio
				) ;

	//
	//	Called as each write we issue completes !
	//
	int		Complete(	
					CSessionSocket*,	
					CWritePacket*,	
					CIO*&	
					) ;

	//
	//	Called when the session drops and we're still alive !!
	//
	void	Shutdown(	
					CSessionSocket*,	
					CIODriver&,	
					enum SHUTDOWN_CAUSE	cause,	
					DWORD	dw
					) ;
} ;


typedef	CSmartPtr< CIOWriteAsyncCMD >	CIOWRITEASYNCCMDPTR ;
//
//	This class defines the base class for Store Driver Completion
//	objects that operate with CIOWriteAsyncCMD !
//
class	CIOWriteAsyncComplete : 	public	CNntpComplete	{
private :
	//
	//	CIOWriteAsyncCMD	is a friend of ours so that it
	//	can access this portion of our interface !
	//	
	friend	class	CIOWriteAsyncCMD ;
	//
	//	Hold this stuff for when we complete !
	//
	CSessionSocket*	m_pSocket ;
	//
	//	This is the packet we use to synchronize completion from
	//	the AsyncExecute object with Write Completions on the Completion
	//	port !
	//
	CExecutePacket*	m_pExecute ;
	//
	//	This is a ref counting pointer that we use to maintain a
	//	reference on the CIOWriteAsyncCMD that issued the operation.
	//	This should only be NON NULL if m_pExecute is NON NULL !
	//
	CIOWRITEASYNCCMDPTR	m_pWriteAsyncCMD ;
	//
	//	This function marks the completion object with all the state
	//	it needs to remain as a pending async completion !
	//	If we return FALSE then the operation has already completed
	//	and this object should NOT be touched again !
	//
	void
	FPendAsync(	CSessionSocket*		pSocket,
				CExecutePacket*		pExecute,
				class	CIOWriteAsyncCMD*	pWriteAsync
				) ;
				
protected :
	//
	//	This member must be FALSE if m_cbTransfer is not zero !
	//	This member can be set if m_cbTransfer != 0, which indicates
	//	that we must allocate a larger buffer for the IO operation !
	//
	unsigned	int	m_fLargerBuffer:1 ;
	unsigned	int	m_fComplete:1 ;
	//
	//	This member variable MUST BE SET by the derived class
	//	to contain the number of bytes transferred in the request -
	//	0 is regarded as a fatal error that should tear down the session !
	//
	DWORD	m_cbTransfer ;
	//
	//	This member function is called when the operation is completed !
	//	We are passed fReset which tells us whether we should reset for
	//	another operation !
	//
	void
	Complete(	BOOL	fReset	) ;
	
public :
	//
	//	Add a reference to ourselves when we're constructed !
	//
	CIOWriteAsyncComplete() :
		m_pSocket( 0 ),
		m_pExecute( 0 ),
		m_cbTransfer( 0 ),
		m_fLargerBuffer( FALSE ),
		m_fComplete( FALSE )	{
		AddRef() ;
	}
	//
	//	The destructor is called when the completion object is destroyed -
	//	By the time our destructor gets called, Complete() must be called
	//	for the finished Async operation !
	//
	~CIOWriteAsyncComplete() ;

	//
	//	This function is called only after Complete() has been called -
	//	it will reset our state so that we can be re-used for another
	//	async operation.
	//	NOTE : we will call CNntpComplete::Reset(), so that our base
	//	class is also ready for re-use !
	//
	void
	Reset() ;
}	;




//
//	The multi line structure is used when we wish to be able to
//	issue a CIOWriteMultiline.
//	m_pBuffer must be laid out with
//
//
struct	MultiLine	{
	//
	//	Reference counting to the buffer containing the data
	//
	CBUFPTR		m_pBuffer ;

	//
	//	Number of entries actually present - MAX is 16 !
	//
	DWORD		m_cEntries ;

	//
	//	Offsets to the data -
	//	Note that m_ibOffsets[17] is the offset to the end of the
	//	16th block of data - NOT an offset to the beginning of the
	//	17th piece.  Data is assumed to be contiguous so that
	//	m_ibOffsets[1] - m_ibOffsets[0] is the length of data
	//	starting at m_ibOffsets[0].
	//
	DWORD		m_ibOffsets[17] ;

	MultiLine() ;

	//
	//
	//
	BYTE*		Entry( DWORD i ) {
		_ASSERT( i < 17 ) ;
		return	(BYTE*)&m_pBuffer->m_rgBuff[ m_ibOffsets[i] ] ;
	}
} ;

class	CIOMLWrite :	public	CIOWrite	{
private :

	//
	//	Pointer to the MultiLine object describing the data !
	//
	MultiLine*	m_pml ;

	//
	//	The current chunk we are writing
	//	(only applicable if m_fCoalesceWrites == FALSE)
	//
	DWORD		m_iCurrent ;

	//
	//	if TRUE then the remote server can handling
	//	getting multiple lines all in one chunk !
	//
	BOOL		m_fCoalesceWrites ;

	//
	//	Do we want to log what we are sending !?
	//
	class		CLogCollector*	m_pCollector ;

public :

	//
	//	Create a CWriteCmd object which will execute
	//	the specified CExecute object.
	//
	CIOMLWrite(	
			CSessionState*	pstate,	
			MultiLine*		pml,
			BOOL	fCoalesce = FALSE,
			class CLogCollector*	pCollector=0
			) ;

	//
	//	Start calling the CExecute object and issuing
	//	write packets !
	//
	BOOL	Start(	CIODriver&	driver,	
					CSessionSocket*	pSocket,	
					unsigned	cReadAhead = 0
					) ;

	//
	//	Called as each write we issue completes !
	//
	int		Complete(	
					CSessionSocket*,	
					CWritePacket*,	
					CIO*&	
					) ;

	//
	//	Called when the session drops and we're still alive !!
	//
	void	Shutdown(	
					CSessionSocket*,	
					CIODriver&,	
					enum SHUTDOWN_CAUSE	cause,	
					DWORD	dw
					) ;
} ;



//
//	This class exists to wrap TransmitFile operations.
//
class	CIOTransmit : public	CIOWrite	{
private :
	
	//
	//	The packet representing the transmit file operation !
	//
	CTransmitPacket*	m_pTransmitPacket ;

	//
	//	Buffer holding any extra text we send
	//
	CBUFPTR				m_pExtraText ;

	//
	//	String to send before the file
	//
	char*				m_pchStartLead ;

	//
	//	Length of string to send before the file
	//
	int					m_cbLead ;

	//
	//	String to send following the file
	//
	char*				m_pchStartTail ;

	//
	//	Length of string following the file
	//
	int					m_cbTail ;

	//
	//	Catches unwanted return values
	//
	static	unsigned	cbJunk ;

protected :

	//	
	//	Destructor is protected to force clients through correct
	//	destruction method !
	//
	~CIOTransmit() ;

public :
	//
	//	Constructor stores a reference to the state issuing the IO.
	//
	CIOTransmit( CSessionState*	pstate ) ;

	//
	//	Get ready to transmit just a file with no extra text
	//
	BOOL	Init(	CDRIVERPTR&	pdriver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,	
					DWORD	cbExtra = 0
					) ;

	//
	//	Get ready to transmit a file and some preceeding text !
	//
	BOOL	Init(	CDRIVERPTR&	driver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,
					CBUFPTR&	pbuffer,
					DWORD	ibStart,	
					DWORD	ibEnd
					) ;

	//
	//	Get ready to transmit a file and some following text !
	//
	BOOL	InitWithTail(	
					CDRIVERPTR&	driver,	
					FIO_CONTEXT*	pFIOContext,	
					DWORD	ibOffset,	
					DWORD	cbLength,
					CBUFPTR&	pbuffer,
					DWORD	ibStart,	
					DWORD	ibEnd
					) ;

	//
	//	Sometimes we don't know what text we send during the Init call -
	//	so use GetBuff() to find a buffer we've stored away and to
	//	stick strings into it.
	//
	char*	GetBuff( unsigned	&cbRemaining = cbJunk ) ;

	//
	//	The first cb bytes of the buffer referenced by GetBuff contain
	//	leading text.
	//
	void	AddLeadText( unsigned	cb ) ;

	//
	//	The next cb bytes of the buffer referenced by GetBuff contain trailer text.
	//
	void	AddTailText( unsigned	cb ) ;
	
	//
	//
	//
	void	AddTailText( char*	pch,	unsigned	cb ) ;

	//
	//	Let me see the lead text that is set to go
	//
	LPSTR	GetLeadText(	unsigned	&cb ) ;
	LPSTR	GetTailText(	unsigned	&cb ) ;

	//
	//	Called when everything is setup and its time to do the transmit
	//
	BOOL	Start(	CIODriver&,	CSessionSocket*,	
					unsigned	cAhead
					) ;

	//
	//	Called when the TransmitFile completes !
	//
	void	Complete(	IN CSessionSocket*,
						IN	CTransmitPacket*,	
						OUT	CIO*	&pio
						) ;

	//
	//	Called if the socket drops while Transmit is in progress !
	//
	void	Shutdown(	CSessionSocket*	pSocket,	
						CIODriver&	driver,	
						enum	SHUTDOWN_CAUSE	cause,	
						DWORD	dwError
						) ;
} ;
	

//------------------------------------
class	CIOReadLine : public CIORead {
//
// This class will reissue reads to a socket until a complete line is read (terminated by NewLine)
// or the provided buffer is filled.
//
private :
	friend	class   CIOWriteLine ;
	enum	CONSTANTS	{
		MAX_STRINGS	= 20,		// Maximum number of strings
		MAX_BYTES = 768,		//	At most 1K of data on an individual line
		REQUEST_BYTES = 4000,
	} ;

	//	
	//	This variable holds the pattern we are looking for
	//	to terminate the line
	//
	static	char	szLineState[] ;

	//
	//	This variable is used to determine when we have hit
	//	the end of the line.
	//
	LPSTR	m_pchLineState ;

	//
	// If this is true than we are probably reading from a file
	// and need to be carefull.
	//
	BOOL	m_fWatchEOF ;		

	//
	// The buffer in which the string is held
	//
	CBUFPTR	m_pbuffer ;			

	//
	// Starting point of the usable portion of the buffer
	//
	char*	m_pchStart ;		

	//
	// Start of data within the buffer
	//
	char*	m_pchStartData ;	

	//
	// End of the data within the buffer
	//
	char*	m_pchEndData ;		

	//
	// End of the usable portion of the buffer
	//
	char*	m_pchEnd ;			

#ifdef	DEBUG
protected :
	~CIOReadLine()	{}
#endif

public :

	//
	//	Our constructor - we get passed the state that we are
	//	to report completions to.  We will bump the state's reference count.
	//	Also, fWatchEOF specifies whether we need to take care for
	//	EOF situations when reading from files.
	//
	CIOReadLine(	
					CSessionState*	pstate,
					BOOL fWatchEOF = FALSE
					) ;

	//
	//	Start reading the line - Read from the socket or file.
	//
	BOOL	Start(	
					CIODriver&,	
					CSessionSocket*	pSocket,
					unsigned cAhead = 0
					) ;

	//
	//	One of our reads (socket or file) has completed - see if we have
	//	a complete line of text terminated with CRLF and if so call our states
	//	completion function.
	//
	int		Complete(	
					IN	CSessionSocket*,
					IN CReadPacket*,
					OUT CIO*	&pio
					) ;

	//	
	//	Our shutdown function is called when the session is dropped - we don't
	//	have to do anything !
	//
	void	Shutdown(	
					CSessionSocket*	pSocket,	
					CIODriver&	driver,	
					enum	SHUTDOWN_CAUSE	cause,	
					DWORD	dwError
					) ;

	inline	CBUFPTR	GetBuffer() ;
	inline  DWORD   GetBufferLen() ;
} ;

#ifndef	_NO_TEMPLATES_

typedef	CSmartPtr< CIOReadLine >	CIOREADLINEPTR ;
typedef	CSmartPtr< CIOReadArticle >	CIOREADARTICLEPTR ;
typedef	CSmartPtr< CIOGetArticle >	CIOGETARTICLEPTR ;
typedef	CSmartPtr< CIOWriteLine >	CIOWRITELINEPTR ;
typedef	CSmartPtr< CIOWriteCMD >	CIOWRITECMDPTR ;
typedef	CSmartPtr< CIOTransmit >	CIOTRANSMITPTR ;

#endif


#define	MAX_IO_SIZE		max(	sizeof( CIO ),	\
								max( max( sizeof( CIOReadArticle ), sizeof( CIOGetArticle)),	\
									max( sizeof( CIOWriteLine ),	\
										max( sizeof( CIOTransmit ) ,	\
											max( sizeof( CIOPassThru ),		\
												max( sizeof( CIOServerSSL ), sizeof( CIOReadLine ) ) ) ) ) ) )


#endif	//	_CIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\cio.inl ===
inline	void*	
CIO::operator	new( size_t	size, CIODriver&	sink ) {
	Assert( size <= cbMAX_IO_SIZE ) ;

	return	sink.m_CIOCache.Alloc( size ) ;
}

inline	void
CIO::operator	delete(	void*	pv ) {
}

inline	void
CIO::Destroy( CIO*	pio, CIODriver& sink ) {
	
	_ASSERT( pio->m_refs == -1 ) ;

	delete	pio ;
	sink.m_CIOCache.Free( pio ) ;
}

inline	void
CIO::DestroySelf(	)	{
	delete	this ;
	gCIOAllocator.Release( (LPVOID)this ) ;
}

inline	long
CIO::AddRef()	{
	return	InterlockedIncrement( &m_refs ) ;
}

inline	long
CIO::RemoveRef()	{
	return	InterlockedDecrement( &m_refs ) ;
}

inline	
CIO::CIO() :
	m_refs( -1 ),
	m_pState( 0 )	{
}

inline
CIO::CIO(	CSessionState	*pState ) :
		m_refs( -1 ),
		m_pState( pState )	{
}

inline
CIORead::CIORead(	CSessionState*	pState ) :
	CIO( pState )	{
}

inline
CIOWrite::CIOWrite(	CSessionState*	pState ) :	
	CIO( pState )	{
}



inline
CBUFPTR	CIOReadLine::GetBuffer()	{
	return	m_pbuffer ;
}

inline  DWORD   CIOReadLine::GetBufferLen() {
	return (DWORD)(m_pchEndData - m_pchStartData) ;
}

inline
char*	CIOWriteLine::GetBuff( unsigned&	cbRemaining )	{

	Assert( m_pWritePacket != 0 ) ;
	Assert( m_pchStart != 0 ) ;
	Assert( m_pchEnd != 0 ) ;
	Assert( m_pchEnd >= m_pchStart ) ;
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;
	
	cbRemaining = (unsigned)(m_pchEnd - m_pchStart) ;
	return	m_pchStart ;
}

inline
void	CIOWriteLine::AddText(	unsigned	cb )	{

	Assert( cb != 0 ) ;
	Assert( m_pchStart != 0 ) ;
	Assert( m_pchEnd != 0 ) ;
	Assert(	m_pchStart <= m_pchEnd ) ;
	Assert( m_pWritePacket != 0 ) ;	
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;
	
	m_pchStart +=cb ;
	Assert( m_pchStart <= m_pchEnd ) ;
}

inline	
char*	CIOWriteLine::GetTail()	{

	Assert( m_pWritePacket != 0 ) ;
	Assert( m_pchStart != 0 ) ;
	Assert( m_pchEnd != 0 ) ;
	Assert( m_pchEnd >= m_pchStart ) ;
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;

	return	m_pchEnd ;
}

inline
void	CIOWriteLine::SetLimits(	char*	pchStart,	char*	pchEnd )	{

	Assert( pchStart != 0 ) ;
	Assert( pchEnd != 0 ) ;
	Assert( pchStart != pchEnd ) ;
	Assert(	m_pWritePacket != 0 ) ;
	Assert(	m_pchStart != 0 ) ;
	Assert(	m_pchEnd != 0 ) ;
	Assert(	m_pchEnd >= m_pchStart ) ;
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;
	Assert(	pchStart <= pchEnd ) ;
	Assert(	pchStart >= m_pchStart ) ;
	Assert(	pchEnd <= m_pchEnd );

	m_pWritePacket->m_ibStartData = (unsigned)(pchStart - &m_pWritePacket->m_pbuffer->m_rgBuff[0]) ;
	Assert( m_pWritePacket->m_ibStartData >= m_pWritePacket->m_ibStart ) ;

	m_pchStart = pchEnd ;
	m_pchEnd = m_pWritePacket->EndData() ;

}

inline
void	CIOWriteLine::Reset( )	{

	Assert( m_pWritePacket != 0 ) ;
	Assert( m_pchStart!= 0 ) ;
	Assert(	m_pchEnd != 0 ) ;
	Assert(	m_pchEnd >= m_pchStart ) ;
	Assert(	m_pchStart >= &m_pWritePacket->m_pbuffer->m_rgBuff[0] ) ;
	Assert(	m_pchEnd <= &m_pWritePacket->m_pbuffer->m_rgBuff[m_pWritePacket->m_pbuffer->m_cbTotal] ) ;

	m_pchStart = m_pWritePacket->StartData() ;
	m_pchEnd = m_pWritePacket->End() ;
	m_pWritePacket->m_ibEndData = m_pWritePacket->m_ibStartData ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\commands.inl ===
inline
void*	CExecutableCommand::operator	new(	size_t	size,	struct	ClientContext&	context ) {
	static	size_t	MAX_SIZE = cbMAX_CEXECUTE_SIZE ;
	_ASSERT( size<=MAX_SIZE) ;
	_ASSERT(	cbMAX_CEXECUTE_SIZE <= sizeof( context.m_rgbCommandBuff ) ) ;
#ifdef	DEBUG
	//
	//	Put in a marker so we can check for overruns !
	//
	_ASSERT( size+sizeof(DWORD) <= sizeof( context.m_rgbCommandBuff ) ) ;
	DWORD UNALIGNED*	pdw = (DWORD UNALIGNED*)(&context.m_rgbCommandBuff[MAX_SIZE]) ;
	*pdw = 0xABCDDCBA ;
#endif
	return	context.m_rgbCommandBuff ;
}

inline	
void	CExecutableCommand::operator	delete(	void	*pv, size_t size ) {

#ifdef	DEBUG
	//
	//	Check for overruns !!
	//
	DWORD	UNALIGNED*	pdw = (DWORD UNALIGNED *)( &((BYTE*)pv)[cbMAX_CEXECUTE_SIZE]) ;
	_ASSERT( *pdw == 0xABCDDCBA ) ;
	FillMemory( pv, size, 0xCC ) ;
	*pdw = 0xCCCCCCCC ;
#endif
}

#if 0 
inline
void*	CIOExecute::operator	new(	size_t	size ) {
	Assert( size<= MAX_CIOEXECUTE_SIZE ) ;
	return	gIOExecutePool.Alloc() ;
}

inline
void	CIOExecute::operator	delete(	void*	pv ) {
	gIOExecutePool.Free( pv ) ;
}
#endif

inline	void*	
CSessionState::operator	new(	size_t	size )	{

	Assert( size <= max( cbMAX_STATE_SIZE, cbMAX_CIOEXECUTE_SIZE ) ) ;
	void	*pv = gStatePool.Alloc() ;

	return	pv ;
}

inline	void
CSessionState::operator	delete(	void*	pv )	{
	gStatePool.Free( pv ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll/obj is used.

   Author:

        Murali R. Krishnan    ( MuraliK )    21-Feb-1995

   Project:
        W3 Server DLL

   Revision History:
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb | DbgOutputLogFile )


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

#ifdef __cplusplus
 extern "C" {
#endif

 # include <nt.h>
 # include <ntrtl.h>
 # include <nturtl.h>

 # include <windows.h>

 #ifdef __cplusplus
 };
#endif // __cplusplus


# include <pudebug.h>

//
//  Define the debugging constants
//



# define DEBUG_CONNECTION              0x00001000L
# define DEBUG_SOCKETS                 0x00002000L
# define DEBUG_RPC                     0x00004000L

# define DEBUG_INSTANCE                0x00020000L
# define DEBUG_ENDPOINT                0x00040000L
# define DEBUG_METABASE                0x00080000L

# define DEBUG_CGI                     0x00100000L
# define DEBUG_BGI                     0x00200000L
# define DEBUG_SSI                     0x00400000L
# define DEBUG_SERVICE_CTRL            0x00800000L

# define DEBUG_PARSING                 0x01000000L
# define DEBUG_REQUEST                 0x02000000L

# define DEBUG_INIT                    (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP                 (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT                  0x10000000
# define DEBUG_IID                     0x20000000
# define DEBUG_MISC                    0x40000000


//
// Specific macros for W3 svcs module
//
# define  TCP_PRINT              DBGPRINTF
# define  TCP_REQUIRE( exp)      DBG_REQUIRE( exp)


//
// Following macros are useful for formatting and printing out GUIDs
//

# define GUID_FORMAT   "{%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])

    // Usage:  DBGPRINTF(( DBG_CONTEXT, " My Guid: " GUID_FORMAT " \n", 
    //                     GUID_EXPAND( pMyGuid)));

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\cservice.h ===
//
// CService.h
//
//  This file defines the service object that will be the main wrapper class
//  of the TIGRIS server.
//  This class has largely been stolen from shuttle as it is now.
//
//  Implementation Schedule for all classes defined by this file, and
//  related helper functions to interact with the Gibralter Service architecture.
//      1.5 week
//
//  Unit Test Schedule :
//      0.5 week
//
//      Unit testing will consist of starting and stopping the service
//      and accepting connections.
//



#ifndef _CSERVICE_H_
#define _CSERVICE_H_

//
//  Private constants.
//

#define NNTP_MODULE_NAME      "nntpsvc.dll"

//
//	Cancel states
//
#define NNTPBLD_CMD_NOCANCEL		0
#define NNTPBLD_CMD_CANCEL_PENDING	1
#define NNTPBLD_CMD_CANCEL			2

//
//	Forwards
//
class CSessionSocket ;
class CGroupIterator ;

//
//	Constants
//
//	- Used to decide whether to manipulate socket buffer sizes.
#define	BUFSIZEDONTSET	(-1)

BOOL GetRegDword( HKEY hKey, LPSTR pszValue, LPDWORD pdw );
void StartHintFunction( void ) ;
void StopHintFunction( void ) ;
BOOL EnumSessionShutdown( CSessionSocket* pUser, DWORD lParam,  PVOID   lpv ) ;
DWORD   SetVersionStrings( LPSTR lpszFile, LPSTR lpszTitle, LPSTR   lpstrOut,   DWORD   cbOut   ) ;
APIERR
GetDefaultDomainName(
    STR * pstrDomainName
    );

//
// Nntp Roles
//

typedef enum _NNTP_ROLE {

    RolePeer,
    RoleMaster,
    RoleSlave,
    RoleClient,
    RoleMax

} NNTP_ROLE;

struct  TIGRIS_STATISTICS_0   {

    DWORD   TimeStarted ;
    DWORD   LastClear ;
    DWORD   NumClients ;
    DWORD   NumServers ;
    DWORD   NumUsers ;
    DWORD   LogonAttempts ;
    DWORD   LogonFailures ;
    DWORD   LogonSuccess ;
} ;

typedef TIGRIS_STATISTICS_0*  PTIGRIS_STATISTICS_0 ;

struct  NNTPBLD_STATISTICS_0   {

	__int64	  NumberOfArticles ;
	__int64	  NumberOfXPosts ;
    __int64   ArticleHeaderBytes ;
    __int64   ArticleTotalBytesSI ;
	__int64	  ArticleTotalBytesMI ;
    __int64   ArticlePrimaryXOverBytes ;
    __int64   ArticleXPostXOverBytes ;
    __int64   ArticleMapBytes ;
    __int64   ArticlePrimaryIndexBytes ;
    __int64   ArticleXPostIndexBytes ;
} ;

typedef NNTPBLD_STATISTICS_0*  PNNTPBLD_STATISTICS_0 ;

class	CBootOptions	{
public : 

	//
	//	Specify whether to blow away all old data structures 
	//
	BOOL DoClean ;

	//
	//	If TRUE then don't delete the history file regardless of other settings.
	//
	BOOL NoHistoryDelete ;

	//
	//	Omit non leaf dirs while generating the group list file
	//
	BOOL OmitNonleafDirs ;

	//
	//	If TRUE, dont delete existing xix files
	//
	DWORD ReuseIndexFiles ;

	//
	//	Name of a file containing either an INN style 'Active' file or 
	//	a tool generate newsgroup list file.  Either way, we will pull
	//	newsgroups out of this file and use them to build a news tree.	
	//
	char	szGroupFile[MAX_PATH] ;
	
	//
	//	Name of a temparory group.lst file used by STANDARD rebuild
	//	to store temparory group.lst information.  Normally group.lst.tmp
	//
	char	szGroupListTmp[MAX_PATH] ;
	
	//
	//	If TRUE, rebuild will skip any corrupted groups found.
	//	Only apply to STANDARD rebuild.
	//
	BOOL SkipCorruptGroup ;

	//
	//  If TRUE, rebuild will skip any corrupted vroots, if FASLE
	//  rebuild will fail if any one vroot failed somewhere during
	//  rebuild
	//
	BOOL SkipCorruptVRoot;

	//
	//	Number of newsgroups being skipped by STANDARD rebuild.
	//	And total number of newsgroups being rebuilt.
	//
	DWORD m_cGroupSkipped ;
	DWORD m_cGroups ;

	//
	//
	//	If TRUE then szGroupFile specifies an INN style Active file,
	//	otherwise it specifies a tool generate human edit newsgroup list.
	//
	BOOL IsActiveFile ;	

	//
	//	This is set when the rebuild thread is ready. This is after we
	//	clean out the hash tables.
	//
	BOOL IsReady ;

	//
	//	Handle to the file where we want to save our output.
	//
	HANDLE	m_hOutputFile ;

	//
	//	Handle to check for shutdown
	//
	HANDLE	m_hShutdownEvent ;

	//
	//	Number of worker threads to spawn for the rebuild
	//
	DWORD	cNumThreads ;

	//
	//	Rebuild thread should check if init failed
	//
	BOOL    m_fInitFailed ;

	//
	//	Newsgroup iterator shared by multiple rebuild threads
	//
	CGroupIterator* m_pIterator ;

	//
	//	Lock to synch access to shared iterator
	//
	CRITICAL_SECTION m_csIterLock;

	//
	//	Total number of files to process
	//
	DWORD	m_dwTotalFiles ;

	//
	//	Current number of files processed
	//
	DWORD	m_dwCurrentFiles ;

	//
	//	Cancel state
	//
	DWORD	m_dwCancelState ;

	//
	//	Get stats during nntpbld
	//
	NNTPBLD_STATISTICS_0	NntpbldStats;

	//
	//	Verbose in report file
	//
	BOOL	fVerbose;

	DWORD
	ReportPrint(	
			LPSTR	szString,		
			...
			) ;

	CBootOptions()	{
		DoClean = FALSE ;
		NoHistoryDelete = FALSE ;
		OmitNonleafDirs = FALSE ;
		ReuseIndexFiles = 0  ;
		SkipCorruptGroup = FALSE  ;
		SkipCorruptVRoot = FALSE;
		m_cGroupSkipped = 0  ;
		m_cGroups = 0  ;
		m_hOutputFile = INVALID_HANDLE_VALUE ;
		m_hShutdownEvent = NULL ;
		cNumThreads = 0 ;
		m_fInitFailed = FALSE;
		m_pIterator = NULL;
		m_dwTotalFiles = 0 ;
		m_dwCurrentFiles = 0;
		IsActiveFile = FALSE ;
		IsReady = FALSE ;
		m_dwCancelState = NNTPBLD_CMD_NOCANCEL ;
		ZeroMemory( szGroupFile, sizeof( szGroupFile ) ) ;
		ZeroMemory( szGroupListTmp, sizeof( szGroupListTmp ) ) ;
		ZeroMemory( &NntpbldStats, sizeof( NntpbldStats ) );
	} ;
} ;

#endif  // _CSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\commands.h ===
/*++

	commands.h

	This file defines the various command related structures and classes.
	A command starts as a string a client sends us and which we will parse
	and create a CCmd derived object to represent.

--*/

#ifndef	_COMMANDS_H_
#define	_COMMANDS_H_

#include "isquery.h"
#include "tflist.h"

// Forward Definitions
class	CCmd ;

//
//	Constants representing the different commands -
//
typedef enum    ENMCMDIDS   {
    eAuthinfo	=0x1,
    eArticle	=0x2,
    eBody		=0x4,
    eDate		=0x8,
    eGroup		=0x10,
    eHead		=0x20,
    eHelp		=0x40,
    eIHave		=0x80,
    eLast		=0x100,
    eList		=0x200,
    eMode		=0x800,
    eNewsgroup	=0x1000,
    eNewnews	=0x2000,
    eNext		=0x4000,
    ePost		=0x8000,
	eQuit		=0x10000,
    eSlave		=0x20000,
    eStat		=0x40000,
	eXHdr		=0x80000, 
    eXOver		=0x100000,
	eXReplic	=0x200000,
	eListgroup  =0x400000,
	eSearch     =0x800000,
	eXPat		=0x1000000,
	eErrorsOnly	=0x20000000,	// Do we log errors only?  This bit controls
								// that.
	eOutPush	=0x40000000,	// Do we log outgoing push feeds ?  
								// This bit controls that !
    eUnimp		=0x80000000
}   ECMD ;

typedef	class	CIOExecute*	PIOEXECUTE ;
typedef	PIOEXECUTE	(*MAKEFUNC)(	int	argc, 
									char** argv, 
									class CExecutableCommand*&,
									struct	ClientContext&, 
									class	CIODriver&
									) ;

//
//	A table of SCmdLookup structures is used to find 
//	the write function to parse each command.
//
struct	SCmdLookup	{
	//
	//	lowercase command string
	//
	LPSTR	lpstrCmd ;

	//
	//	Function to call on match
	//
	MAKEFUNC	make;

	//
	//	Command ID - used for selective Transaction logging
	//
    ECMD    eCmd ;

	//
	//	Logon Required - must the user have a logon context
	//	before they can execute this command.
	//
	BOOL	LogonRequired ;

	//
	//	Size hint - does the command generate a lot of text 
	//	in response.  This will be used to determine how 
	//	big a buffer to allocate for the commands response.
	//	TRUE implies the command will have a large amount of 
	//	data to send.
	//
	BOOL	SizeHint ;
} ;

//
//	Utility functiosn
//
LPSTR	ConditionArgs(	int	cArgs, char **argv, BOOL fZapCommas = FALSE ) ;



//
//	The base class for all commands
//
class	CCmd	{

public : 
	//
	//	Build a CCmd derived object to handle the client request
	//
	//	NOTE: A CIOExecute*& (reference to pointer) doesn't compile on all platforms.

	friend	CIOExecute*	make( 
							int cArgs, 
							char **argv, 
							ECMD& rCmd, 
							class CExecutableCommand*& pexecute, 
							struct ClientContext& context, 
							BOOL&	fIsLargeResponse, 
							CIODriver&	driver, 
							LPSTR&	lpstrOperation 
							) ;

public :
	static	SCmdLookup	table[] ;

public :

	//
	//	Place holder functions - may be used in future with security stuff
	//
    virtual BOOL    IsValid() ;
    
} ;


class	CExecutableCommand	: public	CCmd	{
/*++

Class Description : 

	This class defines the interface that the CAcceptNNRPD 
	state machine can use to issue these commands.
	The assumption is that this command can be handled entirely
	by either a CWriteCMD or a CWriteAsyncCMD to manage the IO's

--*/

private : 
	//
	//	Nobody should be allocating memory for these !
	//
	void*	operator	new( size_t	size ) ;	// nobody is allowed to use this operator !!

public : 
	//
	//	We're destroyed through pointers - so make them virtual !
	//
	virtual	~CExecutableCommand()	{}
	//
	//	Custom allocator uses space right in ClientContext structure
	//
	inline	void	*
	operator	new(	size_t	size,	
						struct	ClientContext&	context 
						) ;
	//
	//	Do nothing delete
	//
	inline	void	
	operator	delete(	void *pv, 
						size_t size 
						) ;
	//
	//	Build the necessary CIO objects to execute the Command !
	//	If this returns FALSE we've failed, and need to drop the session !
	//
	virtual	BOOL
	StartCommand(	class	CAcceptNNRPD*	pState,
					BOOL					fIsLarge,
					class	CLogCollector*	pCollector,
					class	CSessionSocket*	pSocket, 
					class	CIODriver&		driver
					) = 0 ;
	//
	//	If there is anything the command needs to do when all of the text is sent
	//	do so when this function is called !
	//
	virtual	BOOL	
	CompleteCommand(	CSessionSocket*	pSocket,
						struct	ClientContext& 
						) ;
} ;




//
//	The base class for all commands which only send text to the client
//
class   CExecute : public CExecutableCommand	{
private :

	//
	//	Hold a temp pointer for any Child classes which may need it in their
	//	PartialExecute's.
	//
	void*	m_pv ;
public :
	//
	//	Get the first block of text to send to the client.
	//
	unsigned	FirstBuffer( BYTE*	pStart, int	cb, struct	ClientContext&	context,	BOOL	&fComplete, class CLogCollector*	pCollector ) ;

	//
	//	Get the subsequent block of text to send to the client !
	//
	unsigned	NextBuffer( BYTE*	pStart, int	cb, struct	ClientContext&	context,	BOOL	&fComplete, class CLogCollector*	pCollector ) ;

protected :
	CExecute() ;

	//
	//	Start execution - usually prints command response code
	//
    virtual int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&,	class	CLogCollector*	pCollector ) ;

	//
	//	Print body of response - derived classes should try to fill this buffer !
	//
    virtual int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context,	class	CLogCollector*	pCollector ) ;
public :

	//
	//	destructor must be virtual as derived classes
	//	are destroyed through a pointer
	//
	virtual	~CExecute()	{}
	//
	//	Issue the CIOWriteCMD that will handle our executiong !
	//
	BOOL
	StartCommand(	class	CAcceptNNRPD*	pState,
					BOOL					fIsLarge,
					class	CLogCollector*	pCollector,
					class	CSessionSocket*	pSocket, 
					class	CIODriver&		driver
					) ;
} ;


class	CAsyncExecute	: 	public	CExecutableCommand	{
/*++

Class Description : 

	This class manages commands which pend async operations to our 
	drivers !

--*/
private : 

	//
	//	friend functions that can can get to our privates !
	//
	friend	class	CIOWriteAsyncCMD ;
public : 

	CAsyncExecute() ;

	//
	//	Get the first block of text to send to the client.
	//
	virtual	class	CIOWriteAsyncComplete*		
	FirstBuffer(	BYTE*	pStart, 
					int		cb, 
					struct	ClientContext&	context,
					class CLogCollector*	pCollector 
					) = 0 ;

	//
	//	Get the subsequent block of text to send to the client !
	//
	virtual	class	CIOWriteAsyncComplete*	
	NextBuffer( 	BYTE*	pStart, 
					int		cb, 
					struct	ClientContext&	context,	
					class CLogCollector*	pCollector 
					) = 0 ;

	//
	//	Issue the CIOWriteAsyncCMD that will handle our executiong !
	//
	BOOL
	StartCommand(	class	CAcceptNNRPD*	pState,
					BOOL					fIsLarge,
					class	CLogCollector*	pCollector,
					class	CSessionSocket*	pSocket, 
					class	CIODriver&		driver
					) ;


} ;




//
//	The base class for all commands which need to issue complex IO operations !
//	(ie. CIOReadArticle)
//
class	CIOExecute : public CSessionState	{
protected :
	CIOExecute() ;
	~CIOExecute() ;

	//
	//	The Next CIOReadLine object to issue once this command completes
	//
	CIOPTR			m_pNextRead ;

	//
	//	Should we do a TransactionLog of the results ?
	//
	CLogCollector*	m_pCollector ;

public :

	//
	//	Used by CAcceptNNRPD to indicate that the object should do a TransactionLog when
	//	completed !
	//
	inline	void	DoTransactionLog(	class	CLogCollector *pCollector )	{	m_pCollector = pCollector ;	}
	
	//
	//	Used by CAcceptNNRPD to save the CIOReadLine which starts the next state
	//
	void		SaveNextIO( CIORead*	pRead ) ;

	//
	//	Used by Derived classes to get the IO should issue when complete !
	//
	CIOREADPTR	GetNextIO( ) ;

	//
	//	In error situations where we have called the Start() function 
	//
	virtual	void	TerminateIOs(	CSessionSocket*	pSocket,	CIORead*	pRead,	CIOWrite*	pWrite ) ;

	//
	//	CIOExecute states have a special way of starting up, as they may need to 
	//	pend async operations against their drivers etc...
	//
	virtual	BOOL
	StartExecute( 
				CSessionSocket* pSocket,
				CDRIVERPTR& pdriver,
				CIORead*&   pRead,
				CIOWrite*&  pWrite 
				) ;


	
} ;

#define MAX_AUTHINFO_BLOB   512

//
//	Print an error message to the client
//
class	CErrorCmd :	public	CExecute	{
private :
	//
	//	A reference to the NNTPReturn Code we should send to client !
	//
	CNntpReturn&	m_return ;
public :
	CErrorCmd(	CNntpReturn&	nntpReturn ) ;
	int	StartExecute(BYTE*	lpb,	int	cb,	BOOL	&fComplete,	void *&pv, struct	ClientContext&, class CLogCollector * ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
	BOOL	CompleteCommand(	CSessionSocket*	pSocket,	struct	ClientContext&	context ) ;
} ;

//
//	Process a Check Command !
//
class	CCheckCmd : public	CExecute	{
private : 

	//
	//	Pointer to the Message-ID we are to examine !
	//
	LPSTR	m_lpstrMessageID ;

public : 
	
	CCheckCmd(	LPSTR	lpstrMessageID ) ;
	
	static	CIOExecute*	make(	int		cArgs, 
								char	**argv, 
								class	CExecutableCommand*&,
								struct	ClientContext&,
								class	CIODriver&
								) ;

	int	StartExecute(	BYTE*	lpb,
						int		cb,
						BOOL&	fComplete, 
						void*&	pv, 
						struct	ClientContext&, 
						class CLogCollector * 
						) ;				

	int	PartialExecute(	BYTE*	lpb,
						int		cb,
						BOOL&	fComplete, 
						void*&	pv, 
						struct	ClientContext&, 
						class CLogCollector * 
						) ;				


} ;


//
//	Process an Authinfo request
//
class	CAuthinfoCmd : public	CExecute {
private :
    CAuthinfoCmd();
    AUTH_COMMAND m_authCommand;
	LPSTR	m_lpstrBlob ;

public :
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector * ) ;
    static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
} ;

//
//	Process a 'article' command
//
class	CArticleCmd :	public	CIOExecute {
protected :

	static	char	szArticleLog[] ;
	static	char	szBodyLog[]	;
	static	char	szHeadLog[] ;
	

	//
	//	The Article ID of the requested article !
	//
	ARTICLEID	m_artid ;

	//
	//	The Transmit IO operation used to send the article to the client!
	//
	CIOTransmit*	m_pTransmit ;

	//
	//	Ptr to virtual server instance - needed so we can close tsunami
	//	cache file handles.
	//
	PNNTP_SERVER_INSTANCE m_pInstance ;

	//
	//	A pointer to the newsgroup in which we found the article - only
	//	held onto so we can log later !
	//
	CGRPPTR	m_pGroup ;

	//
	//	A pointer to the command line - also used for logging !
	//
	LPSTR	m_lpstr ;

	//
	//	Length of the file 
	//
	DWORD	m_cbArticleLength ;
	
	//
	//	The FIO_CONTEXT for the handle we got from the driver !
	//
	FIO_CONTEXT*	m_pFIOContext ;

	//
	//	File offsets etc...
	//
	//	Where does the header start !
	//
	WORD		m_HeaderOffset ;

	//
	//	How long is the header ?
	//
	WORD		m_HeaderLength ;

	//
	//
	//
	CBUFPTR	m_pbuffer ;

	DWORD	m_cbOut ;	// Number of bytes in buffer to send !


	//
	//	This is the class we use for completing driver operations !
	//
	class	CArticleCmdDriverCompletion	:	public	CNntpComplete	{
	private : 
		//
		//	We hold this with a smart pointer to add a reference
		//	until the operation completes.  otherwise, the socket
		//	could shut down while we're waiting for the driver - causing problems !
		//
		CDRIVERPTR	m_pDriver ;
		//
		//	We need this socket for when the operation completes !
		//
		CSessionSocket*	m_pSocket ;
	public : 
		//
		//	The Article Id we should update the current context to if the operation succeeds !
		//
		ARTICLEID	m_ArticleIdUpdate ;
		//
		//	Standard COM - we don't do it - all of this is handled by our base class
		//
		//	AddRef()
		//	Release()
		//	QueryInterface()
		//	SetResult() 
		//

		//
		//	Initialize with two references initially - one that 
		//	we give to the driver and one for ourselves !
		//
		CArticleCmdDriverCompletion( 	CIODriver&	driver,
										CSessionSocket*	pSocket
										)	: 	m_pDriver( &driver ),
										m_pSocket( pSocket ),
										m_ArticleIdUpdate( INVALID_ARTICLEID )	{
			long	l = AddRef() ;	// Add a reference - we remove
									// this manually ourselves !
			_ASSERT( l == 2 ) ;
		}

		//
		//	Okay the last reference was dropped - do the completion work 
		//	and then die !
		//
		void
		Destroy() ;

		//
		//	This version of release doesn't call Destroy - it lets the
		//	caller do the work !
		//
		ULONG	__stdcall	SpecialRelease() ;
	} ;

	//
	//	This is the object we give to the driver to tell us when 
	//	they have barfed up a file handle for us !
	//
	CArticleCmdDriverCompletion	m_DriverCompletion ;
	friend	class	CArticleCmdDriverCompletion ;

	//
	//	The FIO_CONTEXT that the driver returns to us with the embedded handle !
	//
	FIO_CONTEXT*	m_pFileContext ;

	CArticleCmd(	PNNTP_SERVER_INSTANCE pInstance, 
					CIODriver&	driver,
					CSessionSocket*	pSocket,
					LPSTR lpstr = szArticleLog
					) : 
			m_DriverCompletion( driver, pSocket ),
			m_pTransmit( 0 ), 
			m_pInstance( pInstance ),
			m_pbuffer( 0 ), 
			m_cbOut( 0 ), 
			m_lpstr( lpstr ),
			m_pFIOContext( 0 ),
			m_HeaderOffset( 0 ),
			m_HeaderLength( 0 ),
			m_cbArticleLength( 0 )
			{}

	~CArticleCmd() ;
	
	//
	//	Figure out what CArticle we want to send to the client
	//
	BOOL	BuildTransmit( 
					LPSTR	lpstrArg,	
					char	rgchSuccess[4],	
					LPSTR	lpstrOpt, 
					DWORD	cbOpt,	
					ClientContext&	context,
					class	CIODriver&	driver 
					) ;


	static	CARTPTR	GetArticleInfo(	char*	szArg, 
									struct	ClientContext&	context, 
									ARTICLEID	&artid  
									) ;

	static	BOOL	
	GetArticleInfo(	char*		szArg, 
					CGRPPTR&	pGroup,	
					struct		ClientContext&	context, 
					char*		szBuff,	
					DWORD&		cbBuff, 
					char*		szOpt, 
					DWORD		cbOpt,
					OUT	FIO_CONTEXT*	&pContext,
					IN	CNntpComplete*	pComplete,
					OUT	WORD	&HeaderOffset,
					OUT	WORD	&HeaderLength,
					OUT	ARTICLEID	&ArticleIdUpdate
					) ;

	virtual	BOOL	GetTransferParms(	
									FIO_CONTEXT*	&pFIOContext,
									DWORD&	ibStart,
									DWORD&	cbTransfer 
									) ;

	//
	//	Start sending the article to the client
	//
	virtual	BOOL	StartTransfer(	FIO_CONTEXT*	pFIOContext,
									DWORD	ibStart,
									DWORD	cb,
									CSessionSocket*	pSocket,
									CDRIVERPTR&	pdriver,
									CIORead*&,
									CIOWrite*& 
									) ;

	//
	//	CStatCmd uses our GetArticleInfo function !
	//
	friend	class	CStatCmd ;

public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver&) ;

	//
	//	Function required for CSessionState derived objects - start issuing IO's
	//
	BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*& ) ;

	//
	//	This is the function called by CAcceptNNRPD State.
	//	We use this because we want to take care about how our 
	//	driver operation completes !
	//
	virtual	BOOL
	StartExecute( 
				CSessionSocket* pSocket,
				CDRIVERPTR& pdriver,
				CIORead*&   pRead,
				CIOWrite*&  pWrite 
				) ;


	//
	//	Regardless of whether we complete a CIOTransmit of a Write Line
	//	this will do the correct logging etc.... !
	//
	void
	InternalComplete(
				CSessionSocket*	pSocket,
				CDRIVERPTR&		pdriver,
				TRANSMIT_FILE_BUFFERS*	ptrans, 
				unsigned cbBytes 

				) ;
	//
	//	Completes the sending of an error response to the client
	//	if the store driver fails to barf up a FILE handle for us.
	//
	CIO*	
	Complete(	CIOWriteLine*,	
				CSessionSocket *, 
				CDRIVERPTR&	pdriver 
				) ;


	//
	//	TransmitFile Completion
	//
	CIO*	
	Complete(	CIOTransmit*	ptransmit,
				CSessionSocket*	pSocket,
				CDRIVERPTR&	pdriver, 
				TRANSMIT_FILE_BUFFERS*	ptrans, 
				unsigned cbBytes 
				) ;

						

    BOOL    IsValid( ) ;
} ;

//
//	Send the Body of an article - most work done by base class CArticleCmd
//	
class	CBodyCmd : public	CArticleCmd	{
protected : 
//	CBodyCmd(	CARTPTR&	pArticle, ARTICLEID	artid ) :
//			CArticleCmd( pArticle, artid ){}
	CBodyCmd(	PNNTP_SERVER_INSTANCE pInstance,
				CIODriver&	driver,
				CSessionSocket*	pSocket
				) : CArticleCmd( pInstance, driver, pSocket, szBodyLog ) {}

	BOOL	GetTransferParms(	FIO_CONTEXT*	&pFIOContext,	DWORD&	ibStart,	DWORD&	cbTransfer ) ;
public :
#ifdef	RETIRED
	BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*&	pWrite ) ;
#endif
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&, struct ClientContext&, class CIODriver& ) ;
} ;

//
//	Send the Head of an article - most work done by base class CArticleCmd
//
class	CHeadCmd : public CArticleCmd	{
protected : 
//	CHeadCmd(	CARTPTR&	pArticle, ARTICLEID	artid ) : 
//		CArticleCmd( pArticle, artid ) {}
	CHeadCmd(	PNNTP_SERVER_INSTANCE pInstance,
				CIODriver&	driver,
				CSessionSocket*	pSocket
				) : CArticleCmd( pInstance, driver, pSocket, szHeadLog ) {} 
	BOOL	GetTransferParms(	FIO_CONTEXT*	&pFIOContext,	DWORD&	ibStart,	DWORD&	cbTransfer ) ;
	BOOL	StartTransfer(	FIO_CONTEXT*	pFIOContext,	DWORD	ibStart,	DWORD	cb,
						CSessionSocket*	pSocket,	CDRIVERPTR&	pdriver,	CIORead*&,	CIOWrite*& ) ;
public :

#ifdef	RETIRED
	BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*&	pWrite ) ;
#endif
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
} ;

//
//	Send Statistics regarding the article
//
class	CStatCmd : public	CExecute	{
private :
	LPSTR		m_lpstrArg ;
//	CARTPTR		m_pArticle ;
//	ARTICLEID	m_artid ;
public :
	CStatCmd(	LPSTR	lpstrArg ) ;
//	CStatCmd( CARTPTR&	pArticle,	ARTICLEID	artid ) ;
	static	CIOExecute*	make(	int	cArgs, char **argv, class CExecutableCommand*& pexecute, struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;	
} ;


//
//	Report the current date !
//	
class	CDateCmd : public CExecute {
private :
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&, struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
} ;
	
//
//	Select a group ('group' command)
//
class	CGroupCmd : public CExecute {
private :
	//
	//	The group the client wants made current
	//
    CGRPPTR    m_pGroup ;

    CGroupCmd( CGRPPTR ) ;
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver&) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;
	
//
//	Send help text to client
//	
class	CHelpCmd : public CExecute {
private :
	int	m_cbTotal ;
	static	char	szHelp[] ;
public :
	CHelpCmd() ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Select a group and return all the article-id's within the group.
//
class	CListgroupCmd : public CExecute {
private :
	//
	//	The group the client wants made current
	//
    CGRPPTR    m_pGroup ;

    //
    //  The last article id we reported to the client
    //
    ARTICLEID   m_curArticle ;

   	///
	//	Xover handle - will improve performance sometimes
	//
	HXOVER		m_hXover ;

    CListgroupCmd( CGRPPTR ) ;
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver&) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	This will adjust CClientContext to move back one article !
//	
class	CLastCmd : public CExecute {
private :
	ARTICLEID	m_artidMin ;
	CLastCmd(	ARTICLEID	artid ) : m_artidMin( artid ) {}
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Send a list of newsgroups to the client
//	
class	CListCmd : public CExecute {
protected :
	//
	//	We use the CGroupIterator to enumerate through all the appropriate newsgroups !
	//
    CGroupIterator* m_pIterator ;

    CListCmd() ;
    CListCmd( CGroupIterator*   p ) ;
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    ~CListCmd( ) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplte, void *&pv, ClientContext& context, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* ) ;
	void	GetLogStrings(	LPSTR	&lpstrTarget,	LPSTR&	lpstrParameters ) ;
} ;

class	CListNewsgroupsCmd : public	CListCmd	{
public :
	CListNewsgroupsCmd( CGroupIterator*	p ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplte, void *&pv, ClientContext& context, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* ) ;
} ;

class	CListPrettynamesCmd : public CListCmd	{
public :
	CListPrettynamesCmd( CGroupIterator*	p ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplte, void *&pv, ClientContext& context, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* ) ;
} ;

class	CListSearchableCmd : public CListCmd {
public :
    CListSearchableCmd( CGroupIterator*	p ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
};

class	CListExtensionsCmd : public CExecute {
private :
	int	m_cbTotal ;
	static char szExtensions[] ;
public :
	CListExtensionsCmd() ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Send a string to client telling them everythings fine, but do nothing otherwise
//	
class	CModeCmd : public CExecute {
private :
public :
	CModeCmd( ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;

} ;

//
//	Handle the 'slave' command
//
class	CSlaveCmd : public CErrorCmd {
private :
public :
	CSlaveCmd(	CNntpReturn&	nntpReturn ) ;
	static	CIOExecute*	make( int cArgs, char **arg, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
} ;
	
//
//	Determine which newsgroups are new !
//	
class	CNewgroupsCmd : public CExecute {
private :
	//
	//	Time specified by client
	//
	FILETIME	m_time ;

	//
	//	Iterator which will enumerate all newsgroups !
	//
	CGroupIterator*	m_pIterator ;
	CNewgroupsCmd() ;
public :
	CNewgroupsCmd( FILETIME&	time, CGroupIterator*	pIter ) ;
	~CNewgroupsCmd( ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Respond to the newnews command
//
class	CNewnewsCmd : public CExecute	{
private :
	//
	//	Time specified by client
	//
	FILETIME	m_time ;

	//
	//	Clients wildcard string
	//
	LPSTR		m_lpstrPattern ;

	//
	//	Iterator which hits only those newsgroups matching wildcard string !
	//
	CGroupIterator*	m_pIterator ;

	//
	//	Current ArticleId being processed
	//
	ARTICLEID	m_artidCurrent ;

	//
	//	Number of articles in current newsgroup which did not meet the time
	//	requirement !
	//
	DWORD		m_cMisses ;
	CNewnewsCmd() ;
public :
	CNewnewsCmd(	FILETIME&	time,	CGroupIterator*	pIter, LPSTR lpstrPattern ) ;
	~CNewnewsCmd( ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* ) ;
} ;

//
//	Respond to the next command - adjust current article pointer in CClientContext
//	
class	CNextCmd : public CExecute {
private :
	ARTICLEID	m_artidMax ;
	CNextCmd(	ARTICLEID artid ) : m_artidMax( artid ) {}
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	 ClientContext& context, class CLogCollector* pCollector ) ;
} ;


class	CReceiveComplete : 	public	CNntpComplete	{
private : 
	class	CReceiveArticle*	GetContainer() ;
	class	CSessionSocket*	m_pSocket ;
public : 
	CReceiveComplete() : m_pSocket( 0 )	{}
	//
	//	This function is called when we start our work !
	//
	void
	StartPost(	CSessionSocket*	pSocket ) ;
	//
	//	This function gets called when the post completes !
	//
	void
	Destroy() ;
} ;


//
//	Base class for any command which sends an article to the server !
//
class	CReceiveArticle :	public	CIOExecute	{
private :
	//
	//	Our completion object is our friend !
	//
	friend	class	CReceiveComplete ;
	CReceiveArticle() ;					// Cannot use this constructor !!! - must provide string !!!
protected :
	//
	//	This tells us whether CIOReadArticle::Init has been called - in
	//	which case we must be very carefull referencing m_pFileChannel
	//	as CIOReadArticle is responsible for destroying it !
	//
	BOOL			m_fReadArticleInit ;

	//
	//	CIOWriteLine for initial response to command !
	//
	CIOWriteLine*	m_pWriteResponse ;

	//
	//	pointer to socket session driver !
	//
	CDRIVERPTR		m_pDriver ;

	//
	//	The session who owns this post command
	//
	ClientContext*	m_pContext ;

	//
	//	Number of CIO operations completed !
	//
	long			m_cCompleted ;

	//
	//	Used to determine whether our first send to 
	//	the client completed, and whether it is now o.k. to send
	//	the final response code.
	//
	long			m_cFirstSend ;

	//
	//	MULTI_SZ string which was our command line !
	//
	LPMULTISZ		m_lpstrCommand ;	// optional arguments to pSocket->m_context.m_pInFeed->fPost() ; !!

	//
	//	Flag that decides how stringent we are when we get empty articles
	//	For POSTs, we will reject the article only after receiving .CRLF.CRLF
	//	For IHave's and XReplic's, we will reject as soon as we receive a .CRLF
	//
	BOOL			m_fPartial;

	//
	//	For the InFeed to keep track of stuff !
	//
	LPVOID			m_lpvFeedContext ;

	//
	//	This is the completion object we use with the async post stuff !
	//
	CReceiveComplete	m_PostComplete ;

	//
	//	Function which gets first string we send to the client !
	//
	virtual	char*	GetPostOkString() = 0 ;

	//
	//	Return the code which we should we used when failing an illegally formatted article.
	//
	virtual	NRC		BadArticleCode()	{	return	nrcTransferFailedGiveUp ; }	

	//
	//	Function which builds the command string that is logged
	//
	virtual	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) = 0 ;

	//
	//	Function which processes command line if post exceeds soft limit !
	//
	virtual	NRC		ExceedsSoftLimit( PNNTP_SERVER_INSTANCE pInst )	{	return	nrcTransferFailedGiveUp	;	}

	//
	//	Function which indicates whether we should try to patch an article that we
	//	don't find a header in.
	//
	virtual	BOOL	FEnableNetscapeHack()	{	return	FALSE ;	}


	//
	//	Called to send the posting results to the client !
	//
	BOOL	SendResponse(	CSessionSocket*	pSocket,
							class	CIODriver&	driver, 
							CNntpReturn	&nntpReturn 
							) ;

	BOOL
	NetscapeHackPost(	CSessionSocket*	pSocket,
						CBUFPTR&	pBuffer, 
						HANDLE		hToken,
						DWORD		ibStart, 
						DWORD		cbTransfer
						) ;
	
public :
	CReceiveArticle(	LPMULTISZ	lpstrArgs, BOOL fPartial = TRUE ) ;
	~CReceiveArticle() ;

	//
	//	Called to initialize our state and create the initial CIO objects we use to 
	//	start a posting transaction with the client !
	//
	BOOL	Init(	ClientContext&, 
					class CIODriver& driver  
					) ;

	//
	//	Called when a fatal error occurs before our initial CIO objects can be 
	//	issued !
	//
	void	TerminateIOs(	
					CSessionSocket*	pSocket,	
					CIORead*	pRead,	
					CIOWrite*	pWrite 
					) ;

	//
	//	Called by the CAcceptNNRPD state after we've been
	//	constructed and wants to execute us !
	//
	BOOL
	StartExecute( 
				CSessionSocket* pSocket,
                CDRIVERPTR& pdriver,
                CIORead*&   pRead,
                CIOWrite*&  pWrite 
				) ;
	//
	//	Called by the CIODriver mechanism when we are ready to go !
	//
	BOOL	Start(	CSessionSocket*	pSocket, 
					CDRIVERPTR& pdriver, 
					CIORead*&, 
					CIOWrite*& 
					) ;

	//
	//	Called when we have completed writing a line in response to a client !
	//
	CIO*	Complete(	CIOWriteLine*,	
						class	CSessionSocket*,	
						CDRIVERPTR& 
						) ;


	//
	//	This is the signature for a read that completes
	//	entirely in memory !
	//
	CIO*
	Complete(
				class	CIOGetArticleEx*,
				class	CSessionSocket*,
				BOOL	fGoodMatch,
				CBUFPTR&	pBuffer,
				DWORD		ibStart, 
				DWORD		cb
				) ;

	//
	//	This is the completion that is called when we've 
	//	completed transferring an article to a file !
	//
	void
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) ;

	//
	//	This is the completion that is called when we've 
	//	swallowed an article that we didn't want to have !
	//
	CIO*
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*
				) ;

	//
	//	This is the completion that is called when the post
	//	to the driver finishes !
	//
	void
	Complete(	class	CSessionSocket*	pSocket,
				BOOL	fSuccess 
				) ;

	//
	//	Called when the session dies when we are receiving a posting !
	//
	void	Shutdown(	CIODriver&	driver,	
						CSessionSocket*	pSocket,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwError 
						) ;

} ;


class	CAcceptComplete : 	public	CNntpComplete	{
private : 
	class	CAcceptArticle*	GetContainer() ;
	class	CSessionSocket*	m_pSocket ;
public : 
	CAcceptComplete() : m_pSocket( 0 )	{}
	//
	//	This function is called when we start our work !
	//
	void
	StartPost(	CSessionSocket*	pSocket ) ;
	//
	//	This function gets called when the post completes !
	//
	void
	Destroy() ;
} ;


class	CAcceptArticle :	public	CIOExecute	{
private : 

	friend	class	CAcceptComplete ;
	
	CAcceptArticle() ;

protected : 
	//
	//	Command line arguments 
	//
	LPMULTISZ		m_lpstrCommand ;

	//
	//	Is this a partial receive ??
	//
	BOOL		m_fPartial ;
	//
	//	pointer to socket session driver !
	//
	CDRIVERPTR		m_pDriver ;
	//
	//	The session who owns this post command
	//
	ClientContext*	m_pContext ;
	//
	//	For the InFeed to keep track of stuff !
	//
	LPVOID			m_lpvFeedContext ;
	//
	//	The object we use to figure out when our async post completes !
	//
	CAcceptComplete	m_PostCompletion ;

	BOOL
	SendResponse(	CSessionSocket*	pSocket, 
					CIODriver&		driver, 
					CNntpReturn&	nntpReturn,
					LPCSTR			lpstrMessageId
					) ;

	virtual	BOOL	FAllowTransfer(	struct	ClientContext&	) = 0 ;

	//
	//	Return the code which we should we used when failing an illegally formatted article.
	//
	virtual	NRC		BadArticleCode()	{	return	nrcTransferFailedGiveUp ; }	

	//
	//	Function which builds the command string that is logged
	//
	virtual	DWORD	FillLogString(	BYTE*	pbCommandLog, 
									DWORD cbCommandLog 
									) = 0 ;

	//
	//	Function which processes command line if post exceeds soft limit !
	//
	virtual	NRC		ExceedsSoftLimit( PNNTP_SERVER_INSTANCE pInst )	{	return	nrcTransferFailedGiveUp	;	}

public  : 
	CAcceptArticle(	LPMULTISZ	lpstrArgs, 
					ClientContext*	pContext,
					BOOL fPartial = TRUE ) ;
	~CAcceptArticle() ;

	//
	//	Called to initialize our state and create the initial CIO objects we use to 
	//	start a posting transaction with the client !
	//
	BOOL	Init(	ClientContext&, 
					class CIODriver& driver  
					) ;

	//
	//	Called when a fatal error occurs before our initial CIO objects can be 
	//	issued !
	//
	void	TerminateIOs(	
					CSessionSocket*	pSocket,	
					CIORead*	pRead,	
					CIOWrite*	pWrite 
					) ;

	//
	//	Called by the CAcceptNNRPD state after we've been
	//	constructed and wants to execute us !
	//
	BOOL
	StartExecute( 
				CSessionSocket* pSocket,
                CDRIVERPTR& pdriver,
                CIORead*&   pRead,
                CIOWrite*&  pWrite 
				) ;
	//
	//	Called by the CIODriver mechanism when we are ready to go !
	//
	BOOL	Start(	CSessionSocket*	pSocket, 
					CDRIVERPTR& pdriver, 
					CIORead*&, 
					CIOWrite*& 
					) ;

	//
	//	Called when we have completed writing a line in response to a client !
	//
	CIO*	Complete(	CIOWriteLine*,	
						class	CSessionSocket*,	
						CDRIVERPTR& 
						) ;

	//
	//	This is the signature for a read that completes
	//	entirely in memory !
	//
	CIO*
	Complete(
				class	CIOGetArticleEx*,
				class	CSessionSocket*,
				BOOL	fGoodMatch,
				CBUFPTR&	pBuffer,
				DWORD		ibStart, 
				DWORD		cb
				) ;

	//
	//	This is the completion that is called when we've 
	//	completed transferring an article to a file !
	//
	void
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*,
				FIO_CONTEXT*	pContext,
				DWORD	cbTransfer
				) ;

	//
	//	This is the completion that is called when we've 
	//	swallowed an article that we didn't want to have !
	//
	CIO*
	Complete(	class	CIOGetArticleEx*,
				class	CSessionSocket*
				) ;

	//
	//	This is the completion that is called when the post
	//	to the driver finishes !
	//
	void
	Complete(	class	CSessionSocket*	pSocket,
				BOOL	fSuccess 
				) ;

	//
	//	Called when the session dies when we are receiving a posting !
	//
	void	Shutdown(	CIODriver&	driver,	
						CSessionSocket*	pSocket,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwError 
						) ;

} ;

class	CTakethisCmd  :		public	CAcceptArticle	{
protected : 

	//
	//	Returns TRUE if we would take the posting !
	//
	BOOL	FAllowTransfer(	
					struct	ClientContext&	
					) ;

	///
	//	Error code if the article is malformed !
	//
	NRC	
	BadArticleCode()	{	
		return	nrcSArticleRejected ;	
	}

	//
	//	Error code if the article size exceeds the soft posting limit !
	//
	NRC	
	ExceedsSoftLimit()	{	
		return	nrcSArticleRejected ;	
	}

	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) ;

public : 

	//
	//	Construct a Takethis object !
	//
	CTakethisCmd(	LPMULTISZ	lpstrArgs,
					ClientContext*	pContext
					) ;

	static	CIOExecute*	make(	int		cArgs, 
								char**	argv, 
								class	CExecutableCommand*&, 
								struct	ClientContext&, 
								class	CIODriver&
								) ;
} ;


//
//	Handle Post Command
//	
class	CPostCmd : public CReceiveArticle	{
private :
protected :
	//
	//	Get String we send to clients who issue 'Post'
	//
	char*	GetPostOkString() ;
	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) ;
	NRC		ExceedsSoftLimit( )	{	return	nrcPostFailed ;	}
	BOOL	FEnableNetscapeHack()	{	return	TRUE ;	}
public :
	CPostCmd(	LPMULTISZ	lpstrArgs ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
	//BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*& ) ;

	//
	//	Return the code which we should we used when failing an illegally formatted article.
	//
	virtual	NRC		BadArticleCode()	{	return	nrcPostFailed ; }	

} ;

//
//	Handle IHAVE Command
//	bugbug ... not all implemented yet !
//
class	CIHaveCmd :	public	CReceiveArticle	{
private :
protected :
	char*	GetPostOkString() ;
	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) ;
	NRC		ExceedsSoftLimit( PNNTP_SERVER_INSTANCE pInstance ) ;
public :
	CIHaveCmd(	LPMULTISZ	lpstrCmd ) ;
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
} ;

//
//	Handle XREPLIC Command
//
class	CXReplicCmd : public	CReceiveArticle	{
private :

protected :
	char*	GetPostOkString() ;
	DWORD	FillLogString(	BYTE*	pbCommandLog, DWORD cbCommandLog ) ;
	NRC		ExceedsSoftLimit( )	{	return	nrcTransferFailedGiveUp ;	}
public :
	CXReplicCmd( LPMULTISZ	lpstr ) ;
	static	CIOExecute*	make(	int	cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
	//BOOL	Start( CSessionSocket*	pSocket, CDRIVERPTR& pdriver, CIORead*&, CIOWrite*& ) ;
} ;

//
//	Handle QUIT Command
//
class	CQuitCmd : public	CExecute	{
private :
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct	ClientContext&, class CLogCollector* pCollector ) ;

	//
	//	Disconnect the socket when the write completes !
	//
	BOOL	CompleteCommand(	CSessionSocket*	pSocket,	ClientContext&	context ) ;
} ;

class   CXHdrAsyncComplete : public CIOWriteAsyncComplete {
/*++

Class Description:

    This class implements the completion object passed to drivers for XHDR
    operations !
--*/
private:

    //
    // The last article that the driver stuck into our XHDR results!
    //
    ARTICLEID   m_currentArticle;

    //
    // The requested range of articles
    //
    ARTICLEID   m_loArticle;
    ARTICLEID   m_hiArticle;

    //
    // The buffer we've asked the results be put in !
    //
    BYTE*       m_lpb;

    //
    // The size of the buffer
    //
    DWORD       m_cb;

    //
    // Keep track of how many bytes we prefix onto the response
    //
    DWORD       m_cbPrefix;

    //
    // Header key word
    //
    LPSTR       m_szHeader;

    //
    // This guy can examine and manipulate out guts
    //
    friend void
    CNewsGroup::FillBuffer(
        CSecurityCtx *,
        CEncryptCtx *,
        CXHdrAsyncComplete&
    );

    friend class CXHdrCmd;

    //
    // Can only be constructed by our friends
    //
    CXHdrAsyncComplete();

public:

    //
    // This function is called when the last reference is released !
    //
    void
    Destroy();
};

class CXHdrCmd : public CAsyncExecute {
/*++

    This class manages async XHDR operations, executed on behalf of
    clients against our async store driver interface !

--*/
private:

    //
    // These operations are not allowed
    //
    CXHdrCmd();
    CXHdrCmd( CXHdrCmd& );
    CXHdrCmd& operator=(CXHdrCmd& );

    //
    // This is the completion argument that we give to drivers
    //
    CXHdrAsyncComplete  m_Completion;

    //
    // Constructor is private, only Make can produce these guys
    //
    CXHdrCmd( CGRPPTR&  pGroup );

    //
    // The newsgroup from which we are getting the Xhdr data
    //
    CGRPPTR m_pGroup;

public:

    static CIOExecute*  make( int, char**, CExecutableCommand*&, ClientContext&, CIODriver& );
    ~CXHdrCmd();

    //
    // Get the first blob of text to send to the client
    //
    CIOWriteAsyncComplete*
    FirstBuffer(    BYTE*   pStart,
                    int     cb,
                    ClientContext&      context,
                    CLogCollector*      pCollector
                );

    //
    // Get the subsequent block of text to send to the client
    //
    CIOWriteAsyncComplete*
    NextBuffer( BYTE*   pStart,
                int     cb,
                ClientContext&  context,
                CLogCollector*  pCollector
               );
};

class	CXOverCacheWork :	public	CXoverCacheCompletion	{
private : 
	//
	//	This is embedded in an CXOverAsyncComplete object - get it !
	//
	class	CXOverAsyncComplete*	
	GetContainer() ;
	//
	//	Get the newsgroup in which this XOVER operation is being issued !
	//
	CGRPPTR&	
	GetGroup() ;
public : 

	void
	DoXover(	ARTICLEID	articleIdLow,
				ARTICLEID	articleIdHigh,
				ARTICLEID*	particleIdNext, 
				LPBYTE		lpb, 
				DWORD		cb,
				DWORD*		pcbTransfer, 
				class	CNntpComplete*	pComplete
				) ;

	//
	//	this function is called when the operation completes !
	//
	void
	Complete(	BOOL		fSuccess, 
				DWORD		cbTransferred, 
				ARTICLEID	articleIdNext
				) ;

	//
	//	Get the arguments for this XOVER operation !
	//
	void
	GetArguments(	OUT	ARTICLEID&	articleIdLow, 
					OUT	ARTICLEID&	articleIdHigh,
					OUT	ARTICLEID&	articleIdGroupHigh,
					OUT	LPBYTE&		lpbBuffer, 
					OUT	DWORD&		cbBuffer
					) ;	

	//
	//	Get only the range of articles requested for this XOVER op !
	//
	void
	GetRange(	OUT	GROUPID&	groupId,
				OUT	ARTICLEID&	articleIdLow,
				OUT	ARTICLEID&	articleIdHigh,
				OUT	ARTICLEID&	articleIdGroupHigh
				) ;
} ;

class	CXOverAsyncComplete :	public	CIOWriteAsyncComplete	{
/*++

Class	Description : 

	This class implements the completion object passed to 
	drivers for XOVER operations !

--*/
private : 

	class	CXOverCmd*	
	GetContainer() ;

	friend	class	CXOverCacheWork ;

	//
	//	The last article that the driver stuck into our XOVER results !
	//
	ARTICLEID	m_currentArticle ;

	//
	//	The requested range of articles 
	//
	ARTICLEID	m_loArticle ;
	ARTICLEID	m_hiArticle ;
	ARTICLEID	m_groupHighArticle ;

	//
	//	The buffer we've asked the results be put in !
	//
	BYTE*		m_lpb ;
	//
	//	The size of the buffer !
	//
	DWORD		m_cb ;
	//
	//	a handle to help the cache !
	//
	HXOVER		m_hXover ;
	//
	//	Keep track of how many bytes we prefix onto the response !
	//
	DWORD		m_cbPrefix ;
	//
	//	This is the item we give to the XOVER cache if we need to do 
	//	work with it !
	//
	CXOverCacheWork	m_CacheWork ;

	//
	// Count of outstanding FillBuffer completions..
	//

	long m_cFillBufferRefs;
	//
	//	This guy can examine and manipulate our guts !
	//
	friend	void	
	CNewsGroup::FillBuffer(
		class	CSecurityCtx*,
		class	CEncryptCtx*,
		class	CXOverAsyncComplete&
		) ;
		
	friend	class	CXOverCmd ;

	//
	//	Can only be constructed by our friends !
	//	
	CXOverAsyncComplete() ;
public : 
	//
	//	Get the newsgroup in which this XOVER operation is being issued !
	//
	CGRPPTR&	
	GetGroup() ;
	//
	//	This function is called when the last reference is released !
	//
	void
	Destroy() ;

	void InitFillBufferRefs() {
		m_cFillBufferRefs = 2;
	}

	BOOL ReleaseFillBufferRef() {
		_ASSERT(m_cFillBufferRefs > 0);
		return (InterlockedDecrement(&m_cFillBufferRefs) == 0);
	}
} ;

class	CXOverCmd : public CAsyncExecute {
/*++

Class Description : 

	This class manages Async XOVER operations, executed
	on behalf of clients against our ASYNC Store driver 
	interface !
	
--*/
private :

	friend	class	CXOverAsyncComplete ;
	friend	class	CXOverCacheWork;

	//
	//	These operations are not allowed !
	//
	CXOverCmd() ;
	CXOverCmd( CXOverCmd& ) ;
	CXOverCmd&	operator=( CXOverCmd& ) ;

	//
	//	This is the completion argument that we give
	//	to drivers !
	//
	CXOverAsyncComplete	m_Completion ;

	//
	//	Constructor is private - only make() can produce these guys !
	//
    CXOverCmd(	CGRPPTR&	pGroup ) ;

	//
	//	The newsgroup from which we are getting the Xover data
	//
	CGRPPTR		m_pGroup ;

	//
	// A pointer to the ClientContext so the XoverCache code can
	// restart a FillBuffer
	//
	ClientContext *m_pContext;

public :
    static CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    ~CXOverCmd( ) ;

	//
	//	Get the first block of text to send to the client.
	//
	CIOWriteAsyncComplete*		
	FirstBuffer(	BYTE*	pStart, 
					int		cb, 
					struct	ClientContext&	context,
					class CLogCollector*	pCollector 
					) ;

	//
	//	Get the subsequent block of text to send to the client !
	//
	CIOWriteAsyncComplete*	
	NextBuffer( 	BYTE*	pStart, 
					int		cb, 
					struct	ClientContext&	context,	
					class CLogCollector*	pCollector 
					) ;
};

class	COverviewFmtCmd : public CExecute {
private :
    COverviewFmtCmd();

public :
    static CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    ~COverviewFmtCmd( ) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
};

 
#define MAX_SEARCH_RESULTS 9


class CSearchAsyncComplete {
private:
	ARTICLEID m_currentArticle;	// Article we're interested in
	BYTE *m_lpb;				// Pointer to the buffer
	DWORD m_cb;					// Size of the buffer
	HXOVER m_hXover;			// a handle to help the cache
	DWORD m_cbTransfer;			// Number of bytes placed in buffer
	CNntpSyncComplete *m_pComplete;
	//	
	//	This guy can examine and manipulate our guts !
	//
	friend	void	
	CNewsGroup::FillBuffer(
		class	CSecurityCtx*,
		class	CEncryptCtx*,
		class	CSearchAsyncComplete&
		) ;
		
	friend	class	CSearchCmd ;

	//
	//	Can only be constructed by our friends !
	//	
	CSearchAsyncComplete() ;
} ;


class	CSearchCmd : public CExecute {
private :
	// Not permitted:
    CSearchCmd();
    CSearchCmd(const CSearchCmd&);
    CSearchCmd& operator= (const CSearchCmd&);


	CGRPPTR m_pGroup;
	CHAR *m_pszSearchString;
	INntpDriverSearch *m_pSearch;
	INntpSearchResults *m_pSearchResults;

	int m_cResults;			// Number of results in m_pvResults
	int m_iResults;			// Next result to send.  ==cResults means get more

	WCHAR *m_pwszGroupName[MAX_SEARCH_RESULTS];
	DWORD m_pdwArticleID[MAX_SEARCH_RESULTS];

	BOOL m_fMore;
	DWORD m_cMaxSearchResults;

	struct CSearchVRootEntry {
		CSearchVRootEntry *m_pPrev;
		CSearchVRootEntry *m_pNext;
		CNNTPVRoot *m_pVRoot;
		CSearchVRootEntry(CNNTPVRoot *pVRoot) :
			m_pPrev(NULL), m_pNext(NULL),
			m_pVRoot(pVRoot) {}
	};

	
	TFList<CSearchVRootEntry> m_VRootList;
	TFList<CSearchVRootEntry>::Iterator m_VRootListIter;

	static void
	VRootCallback(void *pContext, CVRoot *pVroot);

	HRESULT GetNextSearchInterface(HANDLE hImpersonate, BOOL fAnonymous);

public :
	CSearchCmd(const CGRPPTR& pGroup, CHAR* pszSearchString);

    static CIOExecute*	
    make(
    	int cArgs,
    	char **argv,
    	class CExecutableCommand*&,
    	struct ClientContext&,
    	class CIODriver&
    	);

    ~CSearchCmd( ) ;

	int
	StartExecute(
		BYTE *lpb,
		int cb,
		BOOL &fComplete,
		void *&pv,
		ClientContext& context,
		CLogCollector*  pCollector);

	int
	PartialExecute(
		BYTE *lpb,
		int cb,
		BOOL &fComplete,
		void *&pv,
		ClientContext& context,
		CLogCollector*  pCollector);

};



class	CSearchFieldsCmd : public CExecute {
private :
    CSearchFieldsCmd();

	//
	// the current field name that we are looking at
	//
	DWORD m_iSearchField;

public :
    static CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;
    ~CSearchFieldsCmd( ) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
};


class CXpatAsyncComplete {
private:
	ARTICLEID m_currentArticle;	// Article we're interested in
	BYTE *m_lpb;				// Pointer to the buffer
	DWORD m_cb;					// Size of the buffer
	HXOVER m_hXover;			// a handle to help the cache
	DWORD m_cbTransfer;			// Number of bytes placed in buffer
	CNntpSyncComplete *m_pComplete;
	LPSTR m_szHeader;
	//	
	//	This guy can examine and manipulate our guts !
	//
	friend	void	
	CNewsGroup::FillBuffer(
		class	CSecurityCtx*,
		class	CEncryptCtx*,
		class	CXpatAsyncComplete&
		) ;
		
	friend class CXPatCmd;

	//
	//	Can only be constructed by our friends !
	//	
	CXpatAsyncComplete() ;
};

class CXPatCmd : public CExecute {
private:
    CXPatCmd();

	CGRPPTR m_pGroup;
	INntpDriverSearch *m_pSearch;
	INntpSearchResults *m_pSearchResults;

	int m_cResults;			// Number of results in m_pvResults
	int m_iResults;			// Next result to send.  ==cResults means get more

	BOOL m_fMore;

	WCHAR *m_pwszGroupName[MAX_SEARCH_RESULTS];
	DWORD m_pdwArticleID[MAX_SEARCH_RESULTS];

	char *m_szHeader;		// The header we are searching for
	char *m_szMessageID;	// MsgId we're searching for or NULL if ArtIDs
	DWORD m_dwLowArticleID, m_dwHighArticleID;

	int GetArticleHeader(CGRPPTR pGroup,
		DWORD iArticleID,
		char *szHeader,
		ClientContext& context,
		BYTE *lpb,
		int cb);


public:
	CXPatCmd(INntpDriverSearch *pDriverSearch, 
		INntpSearchResults *pSearchResults);

    static CIOExecute*
    make(
		int cArgs,
 		char **argv,
		class CExecutableCommand*&,
		struct ClientContext&,
		class CIODriver&);

	~CXPatCmd( ) ;

	int
	StartExecute(
		BYTE *lpb,
		int cb,
		BOOL &fComplete,
		void *&pv,
		ClientContext& context,
		class CLogCollector* pCollector);

	int
	PartialExecute(
		BYTE *lpb,
		int cb,
		BOOL &fComplete,
		void *&pv,
		ClientContext& context,
		class CLogCollector* pCollector);
};

/*
class	CXHdrCmd : public	CExecute	{
private : 

	CGRPPTR		m_pGroup ;
	ARTICLEID	m_currentArticle ;
	ARTICLEID	m_loArticle ;
	ARTICLEID	m_hiArticle ;
	LPSTR		m_szHeader ;


	CXHdrCmd( LPSTR	m_szHeader,	CGRPPTR	pGroup,	ARTICLEID	artidlow, ARTICLEID	artidhi	) ;

public : 
	static	CIOExecute*	make(	int	cArgs,	char **argv, class CExecutableCommand*&, struct ClientContext&, class CIODriver& ) ;

    int StartExecute( BYTE *lpb, int cb, BOOL &fComplte, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
    int PartialExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, ClientContext& context, class CLogCollector* pCollector ) ;
} ;
*/
	
class	CUnimpCmd : public CExecute {
private :
public :
	static	CIOExecute*	make( int cArgs, char **argv, class CExecutableCommand*&,  struct ClientContext&, class CIODriver& ) ;

	int	StartExecute( BYTE *lpb, int cb, BOOL &fComplete, void *&pv, struct ClientContext&, class CLogCollector* pCollector ) ;
} ;



//
//	Remove all white space from constants, as some compilers
//	have problems !
//


#if 0 
#define	MAX_CEXECUTE_SIZE max(sizeof(CErrorCmd),\
max(sizeof(CAuthinfoCmd),\
max(sizeof(CListCmd),\
max(sizeof(CModeCmd),\
max(sizeof(CNewgroupsCmd),\
max(sizeof(CNextCmd),\
max(sizeof(CXOverCmd),\
sizeof( CUnimpCmd )))))))))
#else
#define	MAX_CEXECUTE_SIZE max(max(max(sizeof(CErrorCmd),\
max(sizeof(CSlaveCmd),sizeof(CAuthinfoCmd))),\
max(max(sizeof(CStatCmd),max(sizeof(CDateCmd),sizeof(CListCmd))),\
max(max(max(sizeof(CModeCmd),sizeof(CXPatCmd)),\
max(max(sizeof(CGroupCmd),sizeof(CLastCmd)),sizeof(CNewgroupsCmd))),\
max(max(sizeof(CNextCmd),sizeof(CNewnewsCmd)),\
max(max(sizeof(CHelpCmd),sizeof(CXHdrCmd)),sizeof(CXOverCmd)))))),\
max(max(sizeof(CQuitCmd),sizeof(CSearchCmd)),sizeof( CUnimpCmd )))
#endif

extern	const	unsigned	cbMAX_CEXECUTE_SIZE ;

#define	MAX_CIOEXECUTE_SIZE	max(sizeof(	CIOExecute),\
max(sizeof(CArticleCmd),max(\
max(sizeof(CBodyCmd),\
sizeof(CHeadCmd)),max(\
max(sizeof(CReceiveArticle),\
sizeof(CPostCmd)),\
max(sizeof(CIHaveCmd),\
sizeof(CXReplicCmd))))))

extern	const	unsigned	cbMAX_CIOEXECUTE_SIZE ;

extern LPMULTISZ BuildMultiszFromCommas(LPSTR lpstr);

#include    "commands.inl"
	
#endif	// _COMMANDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\connect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    connect.cxx

    This module contains the connection accept routine called by the connection
    thread.


    FILE HISTORY:
        VladimV     30-May-1995     Created

*/
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE   __szTraceSourceFile

#define INCL_INETSRV_INCS
#include "tigris.hxx"

//extern  class   NNTP_IIS_SERVICE*  g_pInetSvc ;


/*******************************************************************

    NAME:       TigrisOnConnect

    SYNOPSIS:   Handles the incoming connection indication from the
                connection thread


    ENTRY:      sNew - New client socket
                psockaddr - Address of new client socket

    HISTORY:

********************************************************************/

VOID NntpOnConnect(
    SOCKET        sNew,
    SOCKADDR_IN*  psockaddrRemote,
    PVOID         pEndpointContext,
    PVOID         pAtqEndpointObject
    )
{
    PIIS_ENDPOINT			pEndpoint    = (PIIS_ENDPOINT)pEndpointContext;
	PNNTP_SERVER_INSTANCE	pInstance    = NULL;
    INT						cbAddr       = sizeof( sockaddr );
	BOOL					fMaxConnectionsExceeded;
    SOCKADDR				sockaddrLocal;
	DWORD					LocalIpAddress;
	DWORD                   dwInstance = 0;

    ENTER("NntpOnConnect");

    if ( getsockname( sNew,
                      &sockaddrLocal,
                      &cbAddr ) != 0 )
    {
		goto sock_exit ;
    }

	//
	//	This is where we associate the connection with the virtual server instance
	//	NOTE: This is different from W3, where the association is done on the HTTP
	//	request. NNTP does not specify domain names in client requests, so a virtual
	//	server is uniquely identified by <IP addr, Port> on the local end.
	//

	LocalIpAddress = ((PSOCKADDR_IN)&sockaddrLocal)->sin_addr.s_addr ;
    pInstance = (PNNTP_SERVER_INSTANCE)pEndpoint->FindAndReferenceInstance(
										NULL,						// Need to pass domain name
										LocalIpAddress,				// Local IP
										&fMaxConnectionsExceeded
										);

	if( pInstance ) {
	    dwInstance = pInstance->QueryInstanceId();
    }

	if( !pInstance ) {
		//
		//	TODO: Check GetLastError() for reason and close socket !!
		//

		if( pInstance ) {
			pInstance->DecrementCurrentConnections();
			pInstance->Dereference();
		}

		BuzzOff( sNew, psockaddrRemote, dwInstance );
		goto sock_exit ;
	}

	//
	//	InitiateConnection will do a pInst->Deref() on failure.
	//

    if ( !pInstance->InitiateConnection(
								(HANDLE)sNew,
								(SOCKADDR_IN*)psockaddrRemote,
                                (SOCKADDR_IN*)&sockaddrLocal,
								NULL,
								pEndpoint->IsSecure()
								)) {

		BuzzOff( sNew, psockaddrRemote, dwInstance );
		goto sock_exit ;
    }
    LEAVE

	return ;

sock_exit:

    //
    //  We failed to use this socket.  Free it up.
    //
    if( !(shutdown( sNew, 2 ) ==0) ) {
        ErrorTrace( (long)sNew, "shutdown failed");
    }
    if( !(closesocket( sNew ) == 0 ) ) {
        ErrorTrace( (long)sNew, "closesocket failed");
    }

	return ;

} // NntpOnConnect

VOID
NntpOnConnectEx(
    VOID * pAtqContext,
    DWORD  cbWritten,
    DWORD  err,
    OVERLAPPED * lpo
    )
/*++
    Description:

        Callback function for new connections when using AcceptEx.
        This function verifies if this is a valid connection
         ( maybe using IP level authentication)
         and creates a new connection object

        The connection object is added to list of active connections.
        If the max number of connections permitted is exceeded,
          the client connection object is destroyed and
          connection is rejected.

    Arguments:

       patqContext:   pointer to ATQ context for the IO operation
       cbWritten:     count of bytes available from first read operation
       dwError:       error if any from initial operation
       lpo:           indicates if this function was called as a result
                       of IO completion or due to some error.

    Returns:

        None.

--*/
{
    BOOL       fAllowConnection    = FALSE;
	BOOL	   fMaxConnectionsExceeded = FALSE;
	DWORD      dwInstance = 0;
    PVOID      pvBuff = 0;
    SOCKADDR * psockaddrLocal = 0;
    SOCKADDR * psockaddrRemote = 0;
    SOCKET     sNew = INVALID_SOCKET;
    PIIS_ENDPOINT pEndpoint;
    PNNTP_SERVER_INSTANCE pInstance;
#ifdef DEBUG
    PCHAR tmpBuffer[1];
#endif

    ENTER("NntpOnConnectEx")

    if ( err || !lpo )
    {
        DebugTrace(0,"[NntpOnConnectEx] Completion failed with error %d, Atq context %lx\n",
                    err, pAtqContext );

		goto sock_exit ;
    }

	_ASSERT( pAtqContext );

    //
    // Get AcceptEx parameters
    //

    AtqGetAcceptExAddrs( (PATQ_CONTEXT) pAtqContext,
                         &sNew,
                         &pvBuff,
                         (PVOID*)&pEndpoint,
                         &psockaddrLocal,
                         &psockaddrRemote );

#ifdef DEBUG
	tmpBuffer[0] = inet_ntoa(((SOCKADDR_IN*)psockaddrRemote)->sin_addr);
	DebugTrace(0,"Remote is %s", tmpBuffer[0]);

	tmpBuffer[0] = inet_ntoa(((SOCKADDR_IN*)psockaddrLocal)->sin_addr);
	DebugTrace(0,"Local is %s", tmpBuffer[0]);
#endif

	_ASSERT( pEndpoint );
    DebugTrace(0,"[NntpOnConnectEx] New connection, AtqCont = %lx, buf = %lx, endp %x written = %d\n",
                    pAtqContext,
                    pvBuff,
                    pEndpoint,
                    cbWritten );

    if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {

        DebugTrace(0,"Connection attempt on inactive service\n");
		BuzzOff( sNew, (PSOCKADDR_IN)psockaddrRemote, dwInstance );

        goto sock_exit;
    }

	//
	//	This is where we associate the connection with the virtual server instance
	//	NOTE: This is different from W3, where the association is done on the HTTP
	//	request. NNTP does not specify domain names in client requests, so a virtual
	//	server is uniquely identified by <IP addr, Port> on the local end.
	//
	//	NOTE1: We need to check to see if MaxConnections is exceeded ! If we reject
	//	a connection, we need to explicitly decrement this count.
	//	NOTE2: The Dereference for this is in the CSessionSocket destructor
	//

    pInstance = (PNNTP_SERVER_INSTANCE)pEndpoint->FindAndReferenceInstance(
										(LPCSTR)NULL,					// domain name
										((PSOCKADDR_IN)psockaddrLocal)->sin_addr.s_addr,	// Local IP
										&fMaxConnectionsExceeded
										);

	if( pInstance ) {
	    dwInstance = pInstance->QueryInstanceId();
    }

	if( !pInstance || fMaxConnectionsExceeded ) {
		//
		//	send refused message and close socket !
		//	TODO: Use GetLastError() to send reason
		//

		ErrorTrace(0,"Unable to find instance [err %d]\n",GetLastError());
		BuzzOff( sNew, (PSOCKADDR_IN)psockaddrRemote, dwInstance );

		if( pInstance ) {
			pInstance->DecrementCurrentConnections();
			pInstance->Dereference();
		}

        goto sock_exit;
	}

	//
	//	Create a session socket and appropriate feed objects and start
	//	NNTP state machines. This also does the IP access check.
	//	InitiateConnection will do a pInst->Deref() on failure.
	//

    if ( !pInstance->InitiateConnection(
								(HANDLE)sNew,
								(SOCKADDR_IN*)psockaddrRemote,
                                (SOCKADDR_IN*)psockaddrLocal,
								pAtqContext,
								pEndpoint->IsSecure()
								)) {
		//
		//	Failed to accept this connection - free it up.
		//
		BuzzOff( sNew, (PSOCKADDR_IN)psockaddrRemote, dwInstance );
		goto sock_exit ;
    }
    LEAVE
	
	return ;

sock_exit:

	//
    //  We failed to use this context.  Free it up.
    //
    if ( !AtqCloseSocket( (PATQ_CONTEXT) pAtqContext, FALSE )) {
		FatalTrace( (DWORD_PTR)pAtqContext, "AtqCloseSocket() failed");
        //  Do not reuse atq context if close failed.
        AtqFreeContext( (PATQ_CONTEXT) pAtqContext, FALSE);
	} else {
		//  Reuse atq context if close succeded
        AtqFreeContext( (PATQ_CONTEXT) pAtqContext, TRUE);
	}

	return ;

} // NntpOnConnectEx

VOID
BuzzOff(
	SOCKET s,
	SOCKADDR_IN* psockaddr,
	DWORD dwInstance )
{
	TraceFunctEnter("BuzzOff");

	//
    // Illegal access!!!
    //

    PCHAR tmpBuffer[2];
    CHAR  szId [20];
    PCHAR  BuzzerMsg = "502 Connection refused\r\n";
    DWORD  cbBuzzerMsg = lstrlen(BuzzerMsg);

    //
    // Send it a nice message before disconnecting
    //

    (VOID)send(s,BuzzerMsg,cbBuzzerMsg,0);

    //
    // Log error in event log
    //

    _itoa( dwInstance, szId, 10 );
    tmpBuffer[0] = szId;
    tmpBuffer[1] = inet_ntoa(psockaddr->sin_addr);
    ErrorTrace(0,"Virtual server %d: Access not allowed for client %s\n",dwInstance,tmpBuffer[0]);

    NntpLogEvent( NNTP_EVENT_CONNECT_DENIED,
                  2,
                  (const CHAR **)tmpBuffer,
                  0 );

	//
    // bye bye
    //

	TraceFunctLeave();
}

BOOL
VerifyClientAccess(
			CSessionSocket*       pSocket,
            SOCKADDR_IN *         psockaddr
            )
/*++

Routine Description:

    This routine verifies that a client can access this server

Arguments:

    psockaddr - the SOCKADDR structure containing the client connect info

Return Value:

    TRUE, client has access
    FALSE, otherwise

--*/
{
	AC_RESULT       acIpAccess;
    BOOL            fNeedDnsCheck = FALSE;
	BOOL			fRet = TRUE;
	struct hostent* pH = NULL;

    ENTER("VerifyClientAccess")

    _ASSERT( pSocket );

	pSocket->QueryAccessCheck()->BindAddr( (PSOCKADDR)psockaddr );
	if ( pSocket->BindInstanceAccessCheck() )
	{
		acIpAccess = pSocket->QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck);
		if ( (acIpAccess == AC_IN_DENY_LIST) ||
				((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) )
		{
			fRet = FALSE;
		}
		else if (fNeedDnsCheck)
		{
			pH = gethostbyaddr( (char*)(&((PSOCKADDR_IN)psockaddr)->sin_addr), 4, PF_INET );
			if(pH != NULL)
			{
				acIpAccess = pSocket->QueryAccessCheck()->CheckName(pH->h_name);
			}
			else
			{
				acIpAccess = AC_IN_DENY_LIST;
			}
		}

		if ( (acIpAccess == AC_IN_DENY_LIST) ||
				(acIpAccess == AC_NOT_IN_GRANT_LIST))
		{
			fRet = FALSE;
		}

    	pSocket->UnbindInstanceAccessCheck();
    	
	} else {
	    _ASSERT( FALSE );
    }

	if(!fRet)
	{
		SetLastError(ERROR_ACCESS_DENIED);
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\commands.cpp ===
/*++

    commands.cpp

    This file contains the code that interprets and implements NNTP commands.

    There are two distinct categories of commands :
    Those derived from CExecute and those derived from CIOExecute.

    All that Commands derived from CExecute do are manipulate the ClientContext structure
    and send text back to the client.

    Commands derived from CIOExecute on the other hand perform more complicate operations
    such as sending or receiving files.  In fact, CIOExecute is also derived from CSessionState
    so such commands are full blown states in the session state machine.
    (Albeit, special states that will return the session to the command processing state - CAcceptNNRPD)

--*/


#include    <stdlib.h>

#define INCL_INETSRV_INCS
#include    "tigris.hxx"

#include "parse.h"

#if 0
CIOExecute* build2( int cArgs, char **argv, class CExecutableCommand*& pexecute, struct ClientContext& context) {
    return   0 ;
}
#endif

//
//  Server FAULT string - when hash tables inexplicably fail, send this
//
char    szServerFault[] = "503 Server Fault\r\n" ;

//
//      Strings that terminate NNTP postings and indicate possible error states
//      etc !
//
//      The end of the header of a message !
//
char    szBodySeparator[] = "\r\n\r\n" ;
//
//      The end of an article !
//
char    szEndArticle[] = "\r\n.\r\n" ;
//
//      Generally we may start matching in the middle
//      of szEndArticle !
//
char    *szInitial = szEndArticle + 2 ;

//
//  This table must be in alhabetical order.
//  We use this table to parse the first argument in each line the client sends us,
//  after recognizing the command, we call a 'make' function which creates the
//  appropriate command object.
//
//  In general, the make commands should do significant amounts of validation, and
//  if there are problems, return a CErrorCmd object. (which prints the right return code.)
//
SCmdLookup  CCmd::table[] = {
    {   "authinfo", (MAKEFUNC)  (CAuthinfoCmd::make),   eAuthinfo,  FALSE,  TRUE    },
    {   "article",  (MAKEFUNC)  CArticleCmd::make,      eArticle,   TRUE,   TRUE    },
    {   "body",     (MAKEFUNC)  CBodyCmd::make,         eBody,      TRUE,   TRUE    },
    {   "check",    (MAKEFUNC)  CCheckCmd::make,        eUnimp,     FALSE,  FALSE   },
    {   "date",     (MAKEFUNC)  CDateCmd::make,         eDate,      TRUE,   FALSE   },
    {   "group",    (MAKEFUNC)  CGroupCmd::make,        eGroup,     TRUE,   FALSE   },
    {   "head",     (MAKEFUNC)  CHeadCmd::make,         eHead,      TRUE,   TRUE    },
    {   "help",     (MAKEFUNC)  CHelpCmd::make,         eHelp,      FALSE,  TRUE    },
    {   "ihave",    (MAKEFUNC)  CIHaveCmd::make,        eIHave,     FALSE,  TRUE    },
    {   "last",     (MAKEFUNC)  CLastCmd::make,         eLast,      TRUE,   FALSE   },
    {   "list",     (MAKEFUNC)  CListCmd::make,         eList,      TRUE,   TRUE    },
    {   "listgroup", (MAKEFUNC) CListgroupCmd::make,    eListgroup, TRUE,   TRUE    },
    {   "mode",     (MAKEFUNC)  CModeCmd::make,         eMode,      FALSE,  FALSE   },
    {   "newgroups",(MAKEFUNC)  CNewgroupsCmd::make,    eNewsgroup, TRUE,   TRUE    },
    {   "newnews",  (MAKEFUNC)  CNewnewsCmd::make,      eNewnews,   TRUE,   TRUE    },
    {   "next",     (MAKEFUNC)  CNextCmd::make,         eNext,      TRUE,   FALSE   },
    {   "over",     (MAKEFUNC)  CXOverCmd::make,        eXOver,     TRUE,   TRUE    },
    {   "pat",      (MAKEFUNC)  CXPatCmd::make,         eXPat,      TRUE,   TRUE    },
    {   "post",     (MAKEFUNC)  CPostCmd::make,         ePost,      TRUE,   TRUE    },
    {   "quit",     (MAKEFUNC)  CQuitCmd::make,         eQuit,      FALSE,  FALSE   },
    {   "search",   (MAKEFUNC)  CSearchCmd::make,       eSearch,    TRUE,   TRUE    },
//    {   "slave",    (MAKEFUNC)  CSlaveCmd::make,        eSlave,     TRUE,   FALSE   },
    {   "stat",     (MAKEFUNC)  CStatCmd::make,         eStat,      FALSE,  FALSE   },
    {   "takethis", (MAKEFUNC)  CTakethisCmd::make,     eIHave,     FALSE,  TRUE    },
    {   "xhdr",     (MAKEFUNC)  CXHdrCmd::make,         eXHdr,      TRUE,   TRUE    },
    {   "xover",    (MAKEFUNC)  CXOverCmd::make,        eXOver,     TRUE,   TRUE    },
    {   "xpat",     (MAKEFUNC)  CXPatCmd::make,         eXPat,      TRUE,   TRUE    },
    {   "xreplic",  (MAKEFUNC)  CXReplicCmd::make,      eXReplic,   FALSE,  TRUE    },
    // must be the last entry, catches all unrecognized strings
    {   NULL,       (MAKEFUNC)  CUnimpCmd::make,        eUnimp,     FALSE,  FALSE   },
} ;

#if 0                                   // BUGBUG: Be sure to renumber these before reenabling them.
SCmdLookup*     rgCommandTable[26] =    {
        &CCmd::table[0],        // a
        &CCmd::table[2],        // b
        &CCmd::table[3],        // c
        &CCmd::table[4],        // d
        &CCmd::table[5],        // e
        &CCmd::table[5],        // f
        &CCmd::table[5],        // g
        &CCmd::table[6],        // h
        &CCmd::table[8],        // i
        &CCmd::table[9],        // j
        &CCmd::table[9],        // k
        &CCmd::table[9],        // l
        &CCmd::table[12],       // m
        &CCmd::table[13],       // n
        &CCmd::table[16],       // o
        &CCmd::table[17],       // p
        &CCmd::table[18],       // q
        &CCmd::table[19],       // r
        &CCmd::table[19],       // s
        &CCmd::table[22],       // t
        &CCmd::table[23],       // u
        &CCmd::table[23],       // v
        &CCmd::table[23],       // w
        &CCmd::table[23],       // x
        &CCmd::table[27],       // y
        &CCmd::table[27]        // z
} ;
#else
SCmdLookup*     rgCommandTable[26] =    {
        &CCmd::table[0],        // a
        &CCmd::table[0],        // b
        &CCmd::table[0],        // c
        &CCmd::table[0],        // d
        &CCmd::table[0],        // e
        &CCmd::table[0],        // f
        &CCmd::table[0],        // g
        &CCmd::table[0],        // h
        &CCmd::table[0],        // i
        &CCmd::table[0],        // j
        &CCmd::table[0],        // k
        &CCmd::table[0],        // l
        &CCmd::table[0],        // m
        &CCmd::table[0],        // n
        &CCmd::table[0],        // o
        &CCmd::table[0],        // p
        &CCmd::table[0],        // q
        &CCmd::table[0],        // r
        &CCmd::table[0],        // s
        &CCmd::table[0],        // t
        &CCmd::table[0],        // u
        &CCmd::table[0],        // v
        &CCmd::table[0],        // w
        &CCmd::table[0],        // x
        &CCmd::table[0],        // y
        &CCmd::table[0]         // z
} ;
#endif



BOOL
GetCommandRange(
    INT argc,
    char **argv,
    PDWORD loRange,
    PDWORD hiRange,
        NRC&    code
    );

BOOL CheckMessageID(char *szMessageID,              // in
                    struct ClientContext &context,  // in
                    GROUPID *pGroupID,              // out
                    ARTICLEID *pArticleID,          // out
                    CGRPPTR *pGroup);               // out

class   CIOExecute*
make(   int cArgs,
            char **argv,
            ECMD&   rCmd,
            CExecutableCommand*& pexecute,
            ClientContext& context,
            BOOL&   fIsLargeResponse,
            CIODriver&  driver,
            LPSTR&  lpstrOperation
            ) {
/*++

Routine Description :

    Create an appropriate command object for the command we are processing.
    To do so, we use a table of strings (CCmd::table) to recognize the first
    word of the command.  Once we've identified the command, we call another
    function to parse the rest of the line and build the appropriate objects.
    Note that the ClientContext is passed around, as the CCmd object is actually
    constructed in place in the ClientContext in most cases.  The ClientContext
    also provides us all the info on what article is currently seleceted etc...

Arguments :

    cArgs - Number of arguments on the command line
    argv -  Array of pointers to NULL terminated command line parms
    rCmd -  A parameter through which we return the command which was recognized.
    NOTE : This parameters should be retired as it is largely unused.
    pexecute - A pointer reference through which we return a pointer to a CExecute
            object if one is constructed.
    psend - A reference through which we return a CIOExecute derived object if
            one is constructed.
    fIsLargeResponse - An OUT parameter - we return a Hint to the caller of whether
            the command will generate a lot or little text to send to the client.
            This can be used when allocating buffers to get a better size.
    NOTE:   Only one of pexecute and psend will be Non Null when we return.

Return Value :

    A Pointer to a CCmd derived object.   Note that we will also return a pointer
    to either a CIOExecute or CExecute derived object through the references.
    We do this so that the caller knows what type of CCmd it is dealing with.

--*/

    //
    //  The base CCmd make function searches the CCmd::table to find the
    //  appropriate function for creating the command object !
    //

        _strlwr( argv[0] ) ;

    _ASSERT( context.m_return.fIsClear() ) ;    // No errors should be set already
    pexecute = 0 ;

        DWORD   dw= *argv[0] - 'a' ;
        if( dw > DWORD('z'-'a') ) {
                dw = DWORD('z'-'a') ;
        }
    for( SCmdLookup *pMake = rgCommandTable[dw];
            pMake->lpstrCmd != NULL;
            pMake++ ) {
        if( strcmp( pMake->lpstrCmd, argv[0] ) == 0 ) {
            break ;
        }
    }
    lpstrOperation = pMake->lpstrCmd ;
    rCmd = pMake->eCmd ;
    fIsLargeResponse = pMake->SizeHint ;

#ifndef DEVELOPER_DEBUG
    if( pMake->LogonRequired &&
        !context.m_securityCtx.IsAuthenticated() &&
        !context.m_encryptCtx.IsAuthenticated() ) {

        context.m_return.fSet( nrcLogonRequired ) ;
        pexecute = new( context )   CErrorCmd( context.m_return ) ;
        fIsLargeResponse = FALSE ;
        return  0 ;
    }
#endif
    return  pMake->make( cArgs, argv, pexecute, context, driver ) ;
}


void
SetDriverError(         CNntpReturn&    nntpret,
                                        ENMCMDIDS               operation,
                                        HRESULT                 hResDriver
                                        )       {
/*++

Routine Description :

        This function exists to convert an NNTP Store Driver's
        failure code into meaningfull data to return to a client.

Arguments :

        nntpret - The object holding the response for the client
        operation - The Command that failed
        hResDriver - The drivers failure code

Return Value :

        None.

--*/

        switch( operation )     {
                case    eArticle :
                case    eBody :
                case    eHead :
                        //
                        //      Did the driver fail to find the article !
                        //
                        if( hResDriver == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) ||
                                hResDriver == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) )      {
                                nntpret.fSet( nrcNoSuchArticle ) ;
                                break ;
                        }       else    if( hResDriver == E_ACCESSDENIED ) {
                                nntpret.fSet( nrcNoAccess ) ;
                                break ;
                        }
                        //
                        //      fall through into default case !
                        //

                default :
                        nntpret.fSet( nrcServerFault ) ;
                        break ;
        }
        //
        //      We must set some error before we exit !
        //
        _ASSERT( !nntpret.fIsClear() ) ;
}







#if 0
BOOL
FValidateMessageId( LPSTR   lpstrMessageId ) {
/*++

Routine Description :

    Check that the string is a legal looking message id.
    Should contain 1 @ sign and at least one none '>' character
    after that '@' sign.

Arguments :

    lpstrMessageId - Message ID to be validated.

Returns

    TRUE if it appears to be legal
    FALSE   otherwise

--*/

    int cb = lstrlen( lpstrMessageId );

    if( lpstrMessageId[0] != '<' || lpstrMessageId[cb-1] != '>' ) {
        return  FALSE ;
    }

    if( lpstrMessageId[1] == '@' )
        return  FALSE ;

    int cAtSigns = 0 ;
    for( int i=1; i<cb-2; i++ ) {
        if( lpstrMessageId[i] == '@' ) {
            cAtSigns++ ;
        }   else if( lpstrMessageId[i] == '<' || lpstrMessageId[i] == '>' ) {
            return  FALSE ;
        }   else if( isspace( (BYTE)lpstrMessageId[i] ) ) {
            return  FALSE ;
        }
    }
    if( lpstrMessageId[i] == '<' || lpstrMessageId[i] == '>' || cAtSigns != 1 ) {
        return  FALSE ;
    }
    return  TRUE ;
}
#endif


BOOL
 CCmd::IsValid( ) {
    return  TRUE ;
}

CExecute::CExecute() : m_pv( 0 ) {
}


unsigned
CExecute::FirstBuffer(  BYTE*   pb,
                    int     cb,
                    ClientContext&  context,
                    BOOL    &fComplete,
                    CLogCollector*  pCollector )    {
/*++

Routine Description :

    Calls the derived class's StartExecute and PartialExecute functions to let them
    fill the buffer that we will send to the client.

Arguments:

    pb - The buffer to be filled
    cb - The number of bytes available in the buffer
    context - The client's context - to be passed to the derived class PartialExecute !
    fComplete - An Out parameter used to indicate whether the command has been completed !

Return Value :

    TRUE if successfull FALSE otherwise (actually, we can't fail!)

--*/

    //
    //  This function builds the first block of text we will send to the client.
    //  We will call out StartExecute() and PartialExecute() functions untill either
    //  the command is complete or our buffer is reasonably full !
    //

    _ASSERT( fComplete == FALSE ) ;

    unsigned    cbRtn = 0 ;

    _ASSERT( cb > 0 ) ;
    _ASSERT( pb != 0 ) ;

    unsigned cbOut = StartExecute( pb, cb, fComplete, m_pv, context, pCollector ) ;
    _ASSERT( cbOut <= (unsigned)cb ) ;
    while( (cb-cbOut) > 50 && !fComplete ) {
        cbOut += cbRtn = PartialExecute( pb+cbOut, cb-cbOut, fComplete, m_pv, context, pCollector ) ;
        if( cbRtn == 0 )
            break ;
        _ASSERT( cbOut <= (unsigned)cb ) ;
    }
    _ASSERT( cbOut != 0 ) ;

    return  cbOut ;
}

unsigned
CExecute::NextBuffer(   BYTE*   pb,
                    int     cb,
                    ClientContext&  context,
                    BOOL    &fComplete,
                    CLogCollector*  pCollector )    {
/*++

Routine Description :

    Calls the derived class's PartialExecute functions to let them
    fill the buffer that we will send to the client.

Arguments:

    pb - The buffer to be filled
    cb - The number of bytes available in the buffer
    context - The client's context - to be passed to the derived class PartialExecute !
    fComplete - An Out parameter used to indicate whether the command has been completed !

Return Value :

    TRUE if successfull FALSE otherwise (actually, we can't fail!)

--*/

    //
    //  This function builds the first block of text we will send to the client.
    //  We will call out StartExecute() and PartialExecute() functions untill either
    //  the command is complete or our buffer is reasonably full !
    //

    _ASSERT( fComplete == FALSE ) ;

    unsigned    cbRtn = 0 ;

    _ASSERT( cb > 0 ) ;
    _ASSERT( pb != 0 ) ;

    unsigned cbOut = PartialExecute( pb, cb, fComplete, m_pv, context, pCollector ) ;
    if( cbOut != 0 ) {
        _ASSERT( cbOut <= (unsigned)cb ) ;
        while( (cb-cbOut) > 50 && !fComplete ) {
            cbOut += cbRtn = PartialExecute( pb+cbOut, cb-cbOut, fComplete, m_pv, context, pCollector ) ;
            if( cbRtn == 0 )
                break ;
            _ASSERT( cbOut <= (unsigned)cb ) ;
        }
        _ASSERT( cbOut != 0 ) ;
    }

    return  cbOut ;
}


//
//  NOTE : The following CExecute functions are not Pure Virtual as
//  a command can get by without implementing them, as it can
//  mark the command as completed etc... before these are called.
//  All of these DebugBreak() however, so derived commands must
//  guarantee that if these are called they are overridden !!
//
int
CExecute::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL &fComplete,
                        void *&pv,
                        ClientContext& context,
                        CLogCollector*  pCollector ) {
    DebugBreak() ;
    return  0 ;
}

int
CExecute::PartialExecute( BYTE* lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext &context,
                            CLogCollector*  pCollector ) {
    DebugBreak() ;
    return  0 ;
}

BOOL
CExecutableCommand::CompleteCommand(  CSessionSocket* pSocket,
                            ClientContext&  context )   {
    _ASSERT( pSocket != 0 ) ;
    return TRUE ;
}

BOOL
CExecute::StartCommand( class   CAcceptNNRPD*   pState,
                                                BOOL                                    fIsLarge,
                                                class   CLogCollector*  pCollector,
                                                class   CSessionSocket* pSocket,
                                                class   CIODriver&              driver
                                                )       {
/*++

Routine Description :

        This function does the necessary work to start a command
        going.  Note that if the command requires async work, we have to
        specially handle it.

Arguments :

        pSocket - the current session
        driver - the CIODriver managing socket IO

Return Value :

        Pointer to a CIOReadLine object if appropriate !
--*/

        _ASSERT( pState != 0 ) ;
        _ASSERT( pSocket != 0 ) ;

        CIOWriteCMD*    pioWrite = new( driver )
                                                                CIOWriteCMD(    pState,
                                                                                                this,
                                                                                                pSocket->m_context,
                                                                                                fIsLarge,
                                                                                                pCollector
                                                                                                ) ;
        if( pioWrite != 0 ) {
                if( !driver.SendWriteIO( pSocket, *pioWrite, TRUE ) ) {
                        driver.UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
                        CIO::Destroy( pioWrite, driver ) ;
                        return  FALSE ;
                }
        }
        return  TRUE ;
}

CAsyncExecute::CAsyncExecute() {
/*++

Routine Description :

        Initialize for invocation by our clients.
        We setup our function pointer to point at the
        FirstBuffer() function

Args :

        None.

Return Value :

        None.

--*/
}

BOOL
CAsyncExecute::StartCommand(
                                                class   CAcceptNNRPD*   pState,
                                                BOOL                                    fIsLarge,
                                                class   CLogCollector*  pCollector,
                                                class   CSessionSocket* pSocket,
                                                class   CIODriver&              driver
                                                )       {
/*++

Routine Description :

        This function does the necessary work to start a command
        going.  Note that if the command requires async work, we have to
        specially handle it.

Arguments :

        pSocket - the current session
        driver - the CIODriver managing socket IO

Return Value :

        Pointer to a CIOReadLine object if appropriate !
--*/

        _ASSERT( pState != 0 ) ;
        _ASSERT( pSocket != 0 ) ;

        CIOWriteAsyncCMD*       pioWrite = new( driver )
                                                                CIOWriteAsyncCMD(
                                                                                                pState,
                                                                                                this,
                                                                                                pSocket->m_context,
                                                                                                fIsLarge,
                                                                                                pCollector
                                                                                                ) ;
        if( pioWrite != 0 ) {
                if( !driver.SendWriteIO( pSocket, *pioWrite, TRUE ) ) {
                        driver.UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;
                        CIO::Destroy( pioWrite, driver ) ;
                        return  FALSE ;
                }
        }
        return  TRUE ;
}





CIOExecute::CIOExecute() : m_pNextRead( 0 ), m_pCollector( 0 ) {
/*++

Routine Description :

    Initializes the base CIOExecute class.

Arguments :

    None.

Return Value :

    None.

--*/
    //
    //  Constructor does nothing but make sure m_pNextRead is illegal
    //

}

CIOExecute::~CIOExecute() {
/*++

Routine Description :

    Destroy a base CIOExecute object
    We must insure that we don't leave a dangling m_pNextRead.

Arguments :

    None.

Return Value :

    None.

--*/
    //
    //  If the next read wasnt used, destroy it !
    //

//  if( m_pNextRead != 0 ) {
//      delete  m_pNextRead ;
//      m_pNextRead = 0 ;
//  }
    //  Destructor will automatically get rid of m_pNextRead

}

void
CIOExecute::SaveNextIO( CIORead*    pRead )     {
/*++

Routine Description :

    Save away a CIORead pointer for future use.

Arguemtns :

    pRead - pointer to the CIORead object that will be issued when the CIOExecute
        command completes all of its IO's.

Return Value :

    None .

--*/
    TraceFunctEnter( "CIOExecute::SaveNextIO" ) ;

    //
    //  This function saves the next IO operation to be issued when this
    //  command completes.  That will always be a CIOReadLine as we will
    //  always be returning to the CAcceptNNRPD state which will want to
    //  get the client's next command !
    //


    _ASSERT( m_pNextRead == 0 ) ;
    _ASSERT( pRead != 0 ) ;

    m_pNextRead = pRead ;

    DebugTrace( (DWORD_PTR)this, "m_pNextRead set to %x", m_pNextRead ) ;
}

CIOREADPTR
CIOExecute::GetNextIO( )    {
    /*++

Routine Description :

    Return a saved CIORead pointer.  We will only return the value once !!!
    So don't call us twice !

Arguemtns :

    None.

Return Value :

    A pointer to a CIORead derived object saved previously with SaveNextIO.

--*/

    TraceFunctEnter( "CIOExecute::GetNextIO" ) ;

    //
    //  Return the previously saved CIO object !
    //  (This function pairs with SaveNextIO())
    //

    _ASSERT( m_pNextRead != 0 ) ;
    CIOREADPTR  pRead = (CIORead*)((CIO*)m_pNextRead) ;
    m_pNextRead = 0 ;

    DebugTrace( (DWORD_PTR)this, "GetNextIO retuning %x m_pNextRead %x", pRead, m_pNextRead ) ;

    return  pRead ;
}

void
CIOExecute::TerminateIOs(   CSessionSocket* pSocket,
                            CIORead*    pRead,
                            CIOWrite*   pWrite )    {
/*++

Routine Description :

    This function is called when we have called the Start() function of
    the derived class, but an error occurs before we can issue the IO's.
    So this function is called so that the appropriate destruction or shutdown
    can be performed.

Arguments :

    pRead - The same CIO pointer returned on the call to Start().
    pWrite - The same CIO pointer returned on the call to Start().

Return Value :

    None.

--*/

    // By default - do nothing

    if( pRead != 0 )
        pRead->DestroySelf() ;

    if( pWrite != 0 )
        pWrite->DestroySelf() ;

}


BOOL
CIOExecute::StartExecute( CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite ) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //

        _ASSERT( 1==0 ) ;
        return  FALSE ;

}





CErrorCmd::CErrorCmd( CNntpReturn&  nntpReturn ) :
    m_return( nntpReturn ) {
/*++

Routine Description :

    Initializes a CErrorCmd object.

Arguemtns :

    nntpReturn - A reference to the CNntpReturn object which we are
                    returning to the client as an error.

Return Value :

    None.

--*/
    //
    //  CErrorCmd objects just send an error message to the client.
    //  We assert that the context's error field is set !!
    //

    _ASSERT( !m_return.fIsClear() ) ;

}

CIOExecute*
CErrorCmd::make(    int cArgs,
                    char **argv,
                    CExecutableCommand*&  pexecute,
                    ClientContext&  context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CErrorCmd object based on the error currently in the Client's context struct.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CErrorCmd object.

--*/
    //
    //  Build a CErrorCmd object using the ClientContext's current error !
    //

    _ASSERT( !context.m_return.fIsClear() ) ;
    CErrorCmd*  pTemp = new( context )  CErrorCmd( context.m_return ) ;
    pexecute = pTemp ;
    return  0 ;
}

int
CErrorCmd::StartExecute(    BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void*&  pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print an error message into a buffer to be sent to a client.
    We assume that we don't have to deal with getting a buffer to small to hold
    the string. (Since we are generally provided 4K buffers that better be true!)

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Attempt to print the error message into the provided buffer
    //

    _ASSERT( m_return.m_nrc != nrcNotSet ) ;
    int cbOut = _snprintf( (char*)lpb, cb, "%03d %s\r\n", m_return.m_nrc, m_return.szReturn() ) ;
    fComplete = TRUE ;

    /*
    if( pCollector != 0 ) {
        pCollector->FillLogData( LOG_TARGET, lpb, cbOut-2 ) ;
    }
    */

    context.m_nrcLast = m_return.m_nrc ;

    if( cbOut > 0 )
        return  cbOut ;
    else
        return   0 ;
}

BOOL
CErrorCmd::CompleteCommand( CSessionSocket  *pSocket,
                            ClientContext&  context ) {
/*++

Routine Description :

    Do whatever processing is necessary once we have completed all sends to a
    client related to this command. In our case, all we do is clear the current
    error code that we have a reference to.

Arguments :

    pSocket -   The socket on which we were sending.
    context -   The user's current state info.

Return Value :

    Always return TRUE.

--*/
    //
    //  When the command completes reset the ClientContext's error value
    //
    context.m_return.fSetClear() ;
    return  TRUE ;
}

CModeCmd::CModeCmd( )
    {
/*++

Routine Description :

    Initialize a CModeCmd object - we just derive from CErrorCmd and let it do
    all of the work !!


Arguments :

    nntpReturn - A nntpReturn object which will hold our response to the Mode cmd.

Return Value :

    None.

--*/
    //
    //  Mode commands do nothing but print a message, so derive from CErrorCmd !
    //
}

CCheckCmd::CCheckCmd(   LPSTR   lpstrMessageID ) :
    m_lpstrMessageID( lpstrMessageID ) {
}

CIOExecute*
CCheckCmd::make(    int cArgs,
                    char** argv,
                    CExecutableCommand*&  pexecute,
                    ClientContext&  context,
                    CIODriver&  driver
                    ) {

    InterlockedIncrementStat( (context.m_pInstance), CheckCommands );

    if( cArgs != 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
    }   else if( !context.m_pInFeed->fIsIHaveLegal() ) {
        context.m_return.fSet( nrcNoAccess ) ;
    }   else if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) ) {
        context.m_return.fSet( nrcSNotAccepting ) ;
    }   else if( !FValidateMessageId( argv[1] ) ) {
        context.m_return.fSet( nrcSAlreadyHaveIt, argv[1] ) ;
    }   else    {
        pexecute = new( context )   CCheckCmd( argv[1] ) ;
        return  0 ;
    }
    pexecute =  new( context )  CErrorCmd( context.m_return ) ;
    return   0 ;
}

int
CCheckCmd::StartExecute(    BYTE *lpb,
                            int cbLimit,
                            BOOL    &fComplete,
                            void*&pv,
                            ClientContext&  context,
                            CLogCollector*  pLogCollector
                            )   {

    static  char    szWantIt[] = "238 " ;
    static  char    szDontWantIt[] = "438 " ;

    int cbOut = sizeof( szWantIt ) - 1 ;

    pv = 0 ;

    WORD    HeaderOffset, HeaderLength ;
    ARTICLEID   ArticleId ;
    GROUPID     GroupId ;

    BOOL    fFoundArticle = FALSE ;
        BOOL    fFoundHistory = FALSE ;

        CStoreId storeid;

    if( !(fFoundArticle =
            (context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                    m_lpstrMessageID,
                                                    HeaderOffset,
                                                    HeaderLength,
                                                    ArticleId,
                                                    GroupId,
                                                                                                        storeid)) &&
        GetLastError() == ERROR_FILE_NOT_FOUND &&
        !(fFoundHistory = (context.m_pInstance)->HistoryTable()->SearchMapEntry( m_lpstrMessageID )) ) {

        CopyMemory( lpb, szWantIt, sizeof( szWantIt ) ) ;
        context.m_nrcLast = nrcSWantArticle ;

    }   else    {

        CopyMemory( lpb, szDontWantIt, sizeof( szDontWantIt ) ) ;
        context.m_nrcLast = nrcSAlreadyHaveIt ;

                //
                //      set dwLast so transaction logs pickup extra code !!
                //

                if( fFoundArticle ) {
                        context.m_dwLast = nrcMsgIDInArticle ;
                }       else    {
                        context.m_dwLast = nrcMsgIDInHistory ;
                }
    }

    int         cbMessageID = lstrlen( m_lpstrMessageID ) ;
    int         cbToCopy = min( cbLimit - cbOut - 2, cbMessageID ) ;
    CopyMemory( lpb + cbOut, m_lpstrMessageID, cbToCopy ) ;
    cbOut += cbToCopy ;
    pv = (void*)(m_lpstrMessageID + cbToCopy) ;

    if( cbToCopy == cbMessageID &&
        cbOut+2 < cbLimit ) {
        lpb[cbOut++] = '\r' ;
        lpb[cbOut++] = '\n' ;
        fComplete = TRUE ;
    }
    return  cbOut ;
}

int
CCheckCmd::PartialExecute(  BYTE    *lpb,
                            int     cbLimit,
                            BOOL&   fComplete,
                            void*&  pv,
                            ClientContext&  context,
                            CLogCollector*  pLogCollector
                            ) {

    char*   szMessageID = (char*)pv ;
    int     cbOut = 0 ;

    int         cbMessageID = lstrlen( szMessageID ) ;
    int         cbToCopy = min( cbLimit - cbOut - 2, cbMessageID ) ;
    CopyMemory( lpb + cbOut, szMessageID, cbToCopy ) ;
    cbOut += cbToCopy ;
    pv = (void*)(szMessageID + cbToCopy) ;

    if( cbToCopy == cbMessageID &&
        cbOut+2 < cbLimit ) {
        lpb[cbOut++] = '\r' ;
        lpb[cbOut++] = '\n' ;
        fComplete = TRUE ;
    }
    return  cbOut ;
}



CIOExecute*
CModeCmd::make( int cArgs,
                char** argv,
                CExecutableCommand*&  pexecute,
                ClientContext&  context,
                CIODriver&  driver ) {
/*++

Routine Description :

    Create a CModeCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CModeCmd object.

--*/


    //
    //  To create a Mode Command - set the context's error code and
    //  create a CErrorCmd() derived object !
    //

    _ASSERT( context.m_return.fIsClear() ) ;

    InterlockedIncrementStat( (context.m_pInstance), ModeCommands );

    if( cArgs == 2 ) {

        if( lstrcmpi( argv[1], "reader" ) == 0 ) {

            CModeCmd*   pTemp = new( context ) CModeCmd( ) ;
            pexecute = pTemp ;
            return  0 ;

        }   else    if( lstrcmpi( argv[1], "stream" ) == 0 ) {

            if( !context.m_pInFeed->fIsIHaveLegal() ) {
                context.m_return.fSet( nrcNotRecognized ) ;
            }   else    {
                context.m_return.fSet( nrcModeStreamSupported ) ;
            }
            pexecute = new( context )   CErrorCmd( context.m_return ) ;
            return  0 ;
        }
    }

    context.m_return.fSet( nrcNotRecognized ) ;
    pexecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

int
CModeCmd::StartExecute( BYTE *lpb,
                        int cbLimit,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pLogCollector ) {
/*++

Routine Description :

    Send the help text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cbLimit != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT(    pv == 0 ) ;

    static  char    szConnectString[] = "200 Posting Allowed\r\n" ;
    DWORD   cb = 0 ;
    char*   szConnect = 0;

    context.m_nrcLast = nrcServerReady ;


    //
    //  Figure out whether we are accepting posts right now.
    //

    if( context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) ) {

        szConnect = (context.m_pInstance)->GetPostsAllowed( cb ) ;

        //
        //  switch this context's feed object type
        //

        if( !context.m_pInFeed->fIsPostLegal() ) {

                    CompleteFeedRequest(
                            context.m_pInstance,
                            (context.m_pInFeed)->feedCompletionContext(),
                            (context.m_pInFeed)->GetSubmittedFileTime(),
                TRUE,   // CAUSE_USERTERM
                            FALSE
                            );

            delete context.m_pInFeed ;
            context.m_pInFeed = NULL ;

            context.m_pInFeed = (context.m_pInstance)->NewClientFeed();
                    if( context.m_pInFeed != 0 ) {
                            (context.m_pInFeed)->fInit(
                                        (PVOID)(context.m_pInstance)->m_pFeedblockClientPostings,
                                                                    (context.m_pInstance)->m_PeerTempDirectory,
                                                                    0,
                                                                    0,
                                                                    0,
                                                                    TRUE,       /* Do security checks on clients */
                                                                    TRUE,       /* allow control messages from clients */
                                                                    (context.m_pInstance)->m_pFeedblockClientPostings->FeedId
                                                                    );
            } else {
                _ASSERT( FALSE );
            }
        }

    }   else    {

        context.m_nrcLast = nrcServerReadyNoPosts ;
        szConnect = (context.m_pInstance)->GetPostsNotAllowed( cb ) ;

    }

    if( !szConnect )    {
        szConnect = szConnectString ;
        cb = sizeof( szConnectString ) - 1 ;
    }


    CopyMemory( lpb, szConnect, cb ) ;
    fComplete = TRUE ;

    /*
    if( pLogCollector ) {
        pLogCollector->FillLogData( LOG_TARGET, (BYTE*)szConnect, 4 ) ;
    }
    */

    return  cb ;
}


int
CModeCmd::PartialExecute(   BYTE *lpb,
                        int cbLimit,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pLogCollector ) {
/*++

Routine Description :

    Send the help text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cbLimit != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT(    pv == 0 ) ;

    //
    //  We expect StartExecute to suffice always !
    //
    _ASSERT( 1==0 ) ;


    return  0 ;
}


CSlaveCmd::CSlaveCmd(   CNntpReturn&    nntpReturn ) :
    CErrorCmd(  nntpReturn ) {
    //
    //  Slave command does nothing but send a string !
    //
}

CIOExecute*
CSlaveCmd::make(    int cArgs,
                    char**  argv,
                    CExecutableCommand*&  pexecute,
                    ClientContext&  context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CSlaveCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CSlaveCmd object.

--*/


    //
    //  Create a SLAVE command response
    //

    context.m_return.fSet( nrcSlaveStatusNoted ) ;
    pexecute = new( context ) CSlaveCmd( context.m_return ) ;
    return  0 ;
}

inline
CStatCmd::CStatCmd( LPSTR   lpstrArg ) :
    m_lpstrArg( lpstrArg )  {
}

CIOExecute*
CStatCmd::make( int cArgs,
                char** argv,
                CExecutableCommand*&  pexecute,
                ClientContext&  context,
                CIODriver&  driver ) {
/*++

Routine Description :

    Create a CStatCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CStatCmd if possible, otherwise a CErrorCmd object
    set to print the appropriate error.

--*/

    InterlockedIncrementStat( (context.m_pInstance), StatCommands );

    //
    //  Create a CStatCmd object if possible,   We use GetArticleInfo
    //  to parse most of the command line, the exact same function used
    //  by article, head, and body commands.
    //

    _ASSERT( lstrcmpi( argv[0], "stat" ) == 0 ) ;

    if( cArgs > 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
        pexecute = new( context )   CErrorCmd( context.m_return ) ;
        return  0 ;
    }
    if( cArgs == 1 ) {
        if( context.m_pCurrentGroup == 0 ) {
            context.m_return.fSet( nrcNoGroupSelected ) ;
        }   else    if( context.m_idCurrentArticle == INVALID_ARTICLEID )   {
            context.m_return.fSet( nrcNoCurArticle ) ;
        }   else    {
            pexecute = new( context )   CStatCmd( 0 ) ;
            return  0 ;
        }
    }   else    {
        if( argv[1][0] == '<' && argv[1][ lstrlen( argv[1] ) -1 ] == '>' ) {
            pexecute = new( context )   CStatCmd( argv[1] ) ;
            return  0 ;
        }   else    {
            if( context.m_pCurrentGroup == 0 ) {
                context.m_return.fSet( nrcNoGroupSelected ) ;
            }   else    {
                for( char *pchValid = argv[1]; *pchValid!=0; pchValid++ ) {
                    if( !isdigit( *pchValid ) ) {
                        break ;
                    }
                }
                if( *pchValid == '\0' ) {
                    pexecute = new( context )   CStatCmd( argv[1] ) ;
                    return  0 ;
                }
            }

        }
    }
    if( context.m_return.fIsClear() ) {
        context.m_return.fSet( nrcSyntaxError ) ;
    }
    pexecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}


int
CStatCmd::StartExecute( BYTE*   lpb,
                        int cb,
                        BOOL&   fComplete,
                        void*&  pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the stat command response into the provided buffer.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Very simple StartExecute - just print a line of text.
    //

    static  char    szNotFound[] = "430 No Such Article found" ;
    static  char    szNotFoundArticleId[] = "423 no such article number in group" ;
    static  char    szStatString[] = "223 " ;

    WORD    HeaderOffset ;
    WORD    HeaderLength ;

    fComplete = TRUE ;
    int cbOut = 4 ;

    CopyMemory( lpb, szStatString, sizeof( szStatString ) ) ;

    if( m_lpstrArg != 0 && *m_lpstrArg == '<' ) {

        /*
        if( pCollector ) {
            pCollector->ReferenceLogData( LOG_TARGET, (BYTE*)m_lpstrArg ) ;
        }
        */

        ARTICLEID   articleid ;
        GROUPID groupid ;
                CStoreId storeid;


        if( (context.m_pInstance)->ArticleTable()->GetEntryArticleId( m_lpstrArg,
                                                        HeaderOffset,
                                                        HeaderLength,
                                                        articleid,
                                                        groupid,
                                                                                                                storeid) &&
            articleid != INVALID_ARTICLEID && groupid != INVALID_ARTICLEID ) {

            lstrcat( (char*)lpb, "0 " ) ;
            lstrcat( (char*)lpb, m_lpstrArg ) ;
            cbOut = lstrlen( (char*)lpb ) ;

            context.m_nrcLast = nrcHeadFollowsRequestBody ;

        }   else if( GetLastError() == ERROR_FILE_NOT_FOUND ||
                     articleid == INVALID_ARTICLEID || groupid == INVALID_ARTICLEID )   {

            context.m_nrcLast = nrcNoSuchArticle ;

            CopyMemory( lpb, szNotFound, sizeof( szNotFound ) - 1 ) ;
            cbOut = sizeof( szNotFound ) - 1 ;
        }   else    {

            context.m_nrcLast = nrcServerFault ;
            context.m_dwLast = GetLastError() ;

            CopyMemory( lpb, szServerFault, sizeof( szServerFault ) - 1 - 2 ) ;
            cbOut = sizeof( szServerFault ) - 1 - 2 ;
        }
    }   else    {
        ARTICLEID   artid = context.m_idCurrentArticle ;
        if( m_lpstrArg == 0 ) {

            _itoa( context.m_idCurrentArticle, (char*)lpb+sizeof( szStatString ) - 1, 10 ) ;

        }   else    {

            lstrcpy( (char*)lpb + sizeof( szStatString ) -1, m_lpstrArg ) ;
            artid = atoi( m_lpstrArg ) ;

        }
        lstrcat( (char*)lpb+sizeof( szStatString ), " " ) ;

        DWORD   cbConsumed = lstrlen( (char*)lpb ) ;
        DWORD   cbUsed = cb - cbConsumed ;
        BOOL        fPrimary ;
        FILETIME    filetime ;
                DWORD           cStoreId = 0;
        if( (context.m_pInstance)->XoverTable()->ExtractNovEntryInfo(
                        context.m_pCurrentGroup->GetGroupId(),
                        artid,
                        fPrimary,
                        HeaderOffset,
                        HeaderLength,
                        &filetime,
                        cbUsed,
                        (char*)lpb+cbConsumed,
                                                cStoreId,
                                                NULL,
                                                NULL) ) {

            cbOut = (int)   (cbUsed + cbConsumed) ;
            context.m_idCurrentArticle = artid ;

            /*
            if( pCollector ) {
                pCollector->FillLogData(    LOG_TARGET, lpb+cbConsumed, cbUsed ) ;
            }
            */

            context.m_nrcLast = nrcHeadFollowsRequestBody ;

        }   else if( GetLastError() == ERROR_FILE_NOT_FOUND )   {

            context.m_nrcLast = nrcNoArticleNumber ;

            CopyMemory( lpb, szNotFoundArticleId, sizeof( szNotFoundArticleId ) - 1 ) ;
            cbOut = sizeof( szNotFoundArticleId ) - 1 ;

        }   else    {

            context.m_nrcLast = nrcServerFault ;
            context.m_dwLast = GetLastError() ;

            CopyMemory( lpb, szServerFault, sizeof( szServerFault ) - 1 ) ;
            cbOut = sizeof( szServerFault ) - 1 ;

        }
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData(    LOG_PARAMETERS, lpb, 4 ) ;
    }
    */

    lpb[cbOut++] = '\r' ;
    lpb[cbOut++] = '\n' ;
    return  cbOut ;
}


char    CArticleCmd::szArticleLog[] = "article" ;
char    CArticleCmd::szBodyLog[] = "body";
char    CArticleCmd::szHeadLog[] = "head" ;


BOOL
CArticleCmd::GetTransferParms(
                        FIO_CONTEXT*    &pFIOContext,
                        DWORD&  ibStart,
                        DWORD&  cbLength ) {


    if( m_pFIOContext != 0 ) {
        pFIOContext = m_pFIOContext ;
        ibStart = m_HeaderOffset ;
        cbLength = m_cbArticleLength ;

        return  TRUE ;
    }
    return  FALSE ;
}


BOOL
CArticleCmd::StartTransfer( FIO_CONTEXT*        pFIOContext,          // File to transmit from
                            DWORD   ibStart,        // Starting offset within file
                            DWORD   cbLength,       // Number of bytes from file to send
                            CSessionSocket* pSocket,// Socket on which to send
                            CDRIVERPTR& pdriver,    // CIODriver object used by socket
                            CIORead*&   pRead,      // Next CIO derived read object
                            CIOWrite*&  pWrite ) {  // Next CIO derived write object to issue
    //
    //  This function is used to start sending an article requested by a client to
    //  the client.  We may be called from derived command objects for the Head and
    //  Body commands - so we have arguments for selecting the portion of the file
    //  to be transmitted.
    //
    if( m_pTransmit->Init(  pdriver, pFIOContext, ibStart, cbLength, m_pbuffer, 0, m_cbOut ) ) {
        pWrite = m_pTransmit ;
        return  TRUE ;
    }
    return  FALSE ;
}

BOOL
CArticleCmd::Start( CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite ) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //

        FIO_CONTEXT*    pFIOContext = 0 ;
    DWORD   ibStart ;
    DWORD   cbLength ;

    if( GetTransferParms( pFIOContext, ibStart, cbLength ) ) {
                _ASSERT( pFIOContext != 0 ) ;
                _ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
        return  StartTransfer( pFIOContext, ibStart, cbLength, pSocket, pdriver, pRead, pWrite ) ;
    }
    return  FALSE ;
}

BOOL
CArticleCmd::StartExecute( CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite ) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //
        m_DriverCompletion.Release() ;
        return  TRUE ;
}



void
CArticleCmd::CArticleCmdDriverCompletion::Destroy()     {
/*++

Routine Description :

        This is called when the last reference to the Article Command Completion
        object is released - meaning that we can now issue an IO !

Arguments :

        None.

Return Value :

        None.

--*/

        CIORead*        pRead = 0 ;

        //
        //      Okay do our work !
        //
        CArticleCmd*    pCmd = (CArticleCmd*)(((BYTE*)this) - ((BYTE*)&(((CArticleCmd*)0)->m_DriverCompletion))) ;
        if(             SUCCEEDED(GetResult()) &&
                        pCmd->m_pFIOContext != 0 &&
                        pCmd->m_pFIOContext->m_hFile != INVALID_HANDLE_VALUE    ) {

                //
                //      Everything should have worked, so update the Current Article Pointer for the session !
                //
                if( m_ArticleIdUpdate != INVALID_ARTICLEID )
                        m_pSocket->m_context.m_idCurrentArticle = m_ArticleIdUpdate ;

                DWORD   cbHigh = 0 ;
                pCmd->m_cbArticleLength = GetFileSizeFromContext( pCmd->m_pFIOContext, &cbHigh ) ;
                if (pCmd->m_HeaderLength == 0) {
                    pCmd->m_HeaderLength = (WORD)pCmd->m_pFIOContext->m_dwHeaderLength;
                    _ASSERT(pCmd->m_HeaderLength != 0);
                }
                _ASSERT( cbHigh == 0 ) ;

                CIOWrite*       pWrite = 0 ;
                //
                //      Start things up !
                //
                if( pCmd->Start(        m_pSocket,
                                                        m_pDriver,
                                                        pRead,
                                                        pWrite
                                                        ) )     {
                        _ASSERT( pRead == 0 ) ;
                        if( m_pDriver->SendWriteIO( m_pSocket, *pWrite, TRUE ) )        {
                                //
                                //      Everything worked out with gravy - this is our best result !
                                //
                                return ;
                        }       else    {
                                //
                                //      KILL the session !
                                //
                                m_pDriver->UnsafeClose( m_pSocket, CAUSE_UNKNOWN, 0 ) ;
                                pCmd->TerminateIOs( m_pSocket, pRead, pWrite ) ;
                                pRead = 0 ;
                                return ;
                        }
                }       else    {

                        //
                        //      This is a failure that should tear down the session - everything
                        //      looked like it was going to be perfect, we must have run out
                        //      of memory or something ugly!
                        //      pCmd->Start() should clean up any CIO objects !
                        //
                        _ASSERT(        pRead == 0 ) ;
                        _ASSERT(        pWrite == 0 ) ;
                        //
                        //      Fall through to error case !
                        //
                }

        }       else    {
                //
                //      Need to send a failure of some sort  - the Store DRIVER failed us,
                //      so we need to send a reasonable error to the client !
                //      We also need to clean up the objects we made with the hope of
                //      being able to send the article to the client !
                //

                //
                //      Setup the context's CNntpReturn structure with our failure code !
                //
                SetDriverError( m_pSocket->m_context.m_return, eArticle, GetResult() ) ;
                m_pSocket->m_context.m_dwLast = GetResult() ;

                //
                //      This buffer was allocated to hold some transmit file stuff - instead
                //      it gets our error code !
                //
                _ASSERT( pCmd->m_pbuffer != 0 ) ;
                pCmd->m_pbuffer = 0 ;
                m_pSocket->m_context.m_nrcLast = m_pSocket->m_context.m_return.m_nrc;

                //
                //      Well now build a CIOWriteLine to send to the client !
                //
                CIOWriteLine*   pWriteLine = new( *m_pDriver ) CIOWriteLine( pCmd ) ;

                //
                //      Now evaluate pWriteLine !
                //
                if( pWriteLine ) {
                        CDRIVERPTR      pDriver = m_pDriver ;

                        if( pWriteLine->InitBuffers( pDriver, 400 ) ) {

                                unsigned        cbLimit =  0;
                                char*   pch = pWriteLine->GetBuff( cbLimit ) ;
                                int     cbOut = _snprintf(      pch,
                                                                                cbLimit,
                                                                                "%03d %s\r\n",
                                                                                m_pSocket->m_context.m_return.m_nrc,
                                                                                m_pSocket->m_context.m_return.szReturn()
                                                                                ) ;


                                //
                                //      We should be using strings that fit in our smallest buffers !
                                //
                                _ASSERT( cbOut < 400 ) ;

                                pWriteLine->AddText(    cbOut ) ;

                                if( m_pDriver->SendWriteIO( m_pSocket, *pWriteLine, TRUE ) )    {
                                        //
                                        //      Well there were problems, but we sent something to the client !
                                        //
                                        //
                                        //      Now destroy this stuff - we do it here so that if the m_pTransmit holds
                                        //      our last reference we don't get blown up before we can send an error message
                                        //      (if we successfully send an error message our last ref goes away!)
                                        //
                                        _ASSERT( pCmd->m_pTransmit != 0 ) ;
                                        CIO::Destroy( pCmd->m_pTransmit, *m_pDriver ) ; //bugbug this line should move !
                                        return ;
                                }       else    {
                                        //
                                        //      KILL the session !
                                        //
                                        m_pDriver->UnsafeClose( m_pSocket, CAUSE_UNKNOWN, 0 ) ;
                                        pCmd->TerminateIOs( m_pSocket, pRead, pWriteLine ) ;
                                        pRead = 0 ;
                                        return ;
                                }
                        }
                }
        }

        //
        //      KILL the session !
        //
        m_pDriver->UnsafeClose( m_pSocket, CAUSE_UNKNOWN, 0 ) ;

        //
        //      Only fall down here if an error occurred !
        //
        //      Ensure that reference counts are cleaned up in Smart Pointers -
        //
        m_pDriver = 0;
        m_pSocket = 0 ;

        //
        //      Now destroy this stuff - we do it here so that if the m_pTransmit holds
        //      our last reference we don't get blown up before we can send an error message
        //      (if we successfully send an error message our last ref goes away!)
        //
        _ASSERT( pCmd->m_pTransmit != 0 ) ;
        CIO::Destroy( pCmd->m_pTransmit, *m_pDriver ) ;
}


void
CArticleCmd::InternalComplete(
                        CSessionSocket* pSocket,
                        CDRIVERPTR& pdriver,
                        TRANSMIT_FILE_BUFFERS*  pbuffers,
                        unsigned cbBytes
                                                ) {
/*++

Routine description :

        Handle the completion and error logging of either a TransmitFile
        or Write to the client !

Arguments :

        pSocket - our socket
        pdriver - the driver handling our IO's

Return's :

        Nothing

--*/

    //
    //  Issue the next Read IO - should return us to CAcceptNNRPD state.
    //

    TraceFunctEnter( "CArticleCmd::InternalComplete" ) ;

    _ASSERT( m_pGroup != 0 ) ;
    _ASSERT( m_lpstr != 0 ) ;


    if( m_pCollector != 0 ) {

        /*
        m_pCollector->ReferenceLogData( LOG_OPERATION, (BYTE*)m_lpstr ) ;
        */

                if(     pbuffers ) {

                unsigned    cb = 0 ;

                _ASSERT(pbuffers->Head != 0 ) ;

                    LPSTR   lpstr = (LPSTR)pbuffers->Head ;
                lpstr[ pbuffers->HeadLength - 2 ] = '\0' ;
                m_pCollector->ReferenceLogData( LOG_TARGET, (BYTE*)lpstr+4 ) ;

                ASSIGNI( m_pCollector->m_cbBytesSent, cbBytes );
                }
            pSocket->TransactionLog( m_pCollector, pSocket->m_context.m_nrcLast, pSocket->m_context.m_dwLast ) ;
    }


    CIOREADPTR  pio = GetNextIO() ;
    _ASSERT( pio != 0 ) ;
        pSocket->m_context.m_return.fSetClear() ;
    pdriver->SendReadIO( pSocket, *pio,    TRUE ) ;
}


CIO*
CArticleCmd::Complete(  CIOWriteLine*   pioWriteLine,
                                                CSessionSocket* pSocket,
                                                CDRIVERPTR&     pdriver
                                                ) {

        InternalComplete( pSocket, pdriver, 0, 0 ) ;
        return  0 ;
}


CIO*
CArticleCmd::Complete(  CIOTransmit*    ptransmit,
                        CSessionSocket* pSocket,
                        CDRIVERPTR& pdriver,
                        TRANSMIT_FILE_BUFFERS*  pbuffers,
                        unsigned cbBytes
                                                ) {

    //
    //  Issue the next Read IO - should return us to CAcceptNNRPD state.
    //

    TraceFunctEnter( "CArticleCmd::Complete CIOTransmit" ) ;

    _ASSERT( m_pGroup != 0 ) ;
    _ASSERT( m_lpstr != 0 ) ;

        InternalComplete( pSocket, pdriver, pbuffers, cbBytes ) ;

    return   0 ;
}

BOOL
CArticleCmd::GetArticleInfo(    char            *szArg,
                                CGRPPTR&    pGroup,
                                struct  ClientContext&  context,
                                char            *szBuff,
                                DWORD           &cbBuff,
                                char            *szOpt,
                                DWORD           cbOpt,
                                OUT FIO_CONTEXT*        &pContext,
                                                                IN      CNntpComplete*  pComplete,
                                OUT WORD    &HeaderOffset,
                                OUT WORD    &HeaderLength,
                                                                OUT     ARTICLEID       &ArticleIdUpdate
                                ) {
/*++

Routine Description :

    This function gets all the information we need to respond to an
    article, head or body command.  We generate the response strings,
    as well as get the necessary file handles etc...

Arguments :


Return  Value :

    TRUE if successfull, FALSE otherwise !
    If we fail the m_return object within the ClientContext will be set
    to an appropriate error message !

--*/
    //
    //  This function attempts to parse a command line sent by a client
    //  and determine what article they wish to retrieve.
    //  If we can get the article we will return a pointer to it,
    //  otherwise we will set the context's error code to something
    //  sensible.
    //

    TraceQuietEnter("CArticleCmd::GetArticleInfo");

    ARTICLEID   artid ;
    GROUPID     groupid ;
    DWORD       cbOut = 0 ;

        ArticleIdUpdate = INVALID_ARTICLEID ;

    if( szArg == 0 ) {
        pGroup = context.m_pCurrentGroup ;
        artid = context.m_idCurrentArticle ;
    }   else    {
        if( szArg[0] == '<' && szArg[ lstrlen( szArg ) -1 ] == '>' ) {

                        CStoreId storeid;

            if( (context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                            szArg,
                                                            HeaderOffset,
                                                            HeaderLength,
                                                            artid,
                                                            groupid,
                                                                                                                        storeid
                                                                                                                        ) &&
                artid != INVALID_ARTICLEID && groupid != INVALID_ARTICLEID ) {
                _ASSERT( artid != INVALID_ARTICLEID ) ;
                pGroup = (context.m_pInstance)->GetTree()->GetGroupById(
                                                            groupid
                                                            ) ;

                if(pGroup == 0) {
                    // this article belongs to a deleted group
                    context.m_return.fSet( nrcNoSuchArticle ) ;
                    return 0 ;
                }

                if( !pGroup->IsGroupAccessible( context.m_securityCtx,
                                                                                context.m_encryptCtx,
                                                context.m_IsSecureConnection,
                                                FALSE,
                                                TRUE ) )   {
                    context.m_return.fSet( nrcNoAccess ) ;
                    return 0 ;
                }

                //cbOut = _snprintf( szBuff, cbBuff, "%s\r\n", szArg ) ;
                if( ((cbOut = lstrlen( szArg )) + 2)+cbOpt > (DWORD)cbBuff )        {
                    context.m_return.fSet( nrcServerFault ) ;
                    return 0 ;
                }

                CopyMemory( szBuff, szOpt, cbOpt ) ;
                CopyMemory( szBuff+cbOpt, szArg, cbOut ) ;
                szBuff[cbOpt+cbOut++] = '\r' ;
                szBuff[cbOpt+cbOut++] = '\n' ;

                //
                //  Note - do not cache articles we get for SSL connections
                //  as our async IO code can't reuse the file handles !
                //

                                pGroup->GetArticle(
                                                                        artid,
                                                                        0,
                                                                        INVALID_ARTICLEID,
                                                                        storeid,
                                                                        &context.m_securityCtx,
                                                                        &context.m_encryptCtx,
                                                                        TRUE,
                                                                        pContext,
                                                                        pComplete
                                                                        ) ;

                cbBuff = cbOut + cbOpt ;
                return  TRUE ;
            }   else if( GetLastError() == ERROR_FILE_NOT_FOUND ||
                         artid == INVALID_ARTICLEID || groupid == INVALID_ARTICLEID )   {
                ErrorTrace(0,"Not in article table5\n");
                context.m_return.fSet( nrcNoSuchArticle ) ;
                return   FALSE ;
            }   else    {
                ErrorTrace(0,"Hash Table failure %x\n", GetLastError() );
                context.m_return.fSet( nrcServerFault ) ;
                return   FALSE ;
            }
        }   else    {

                        artid = 0 ;
            for( char *pchValid = szArg; *pchValid != 0; pchValid ++ )  {
                if( !isdigit( *pchValid ) ) {
                    context.m_return.fSet( nrcSyntaxError ) ;
                    return  FALSE ;
                }       else    {
                                        artid = 10 * artid + (*pchValid - '0') ;
                                }
            }

            if( context.m_pCurrentGroup == 0 ) {
                context.m_return.fSet( nrcNoGroupSelected ) ;
                return  FALSE ;
            }

            pGroup = context.m_pCurrentGroup ;
            //artid = atoi( szArg ) ;
        }

    }
    if( pGroup != 0 ) {
        //
        //  Check that the artid is in a valid range for this newsgroup !
        //
        if( artid >= context.m_pCurrentGroup->GetFirstArticle() &&
            artid <= context.m_pCurrentGroup->GetLastArticle() ) {

            if( szArg != 0 ) {
                lstrcpy( szBuff, szArg ) ;
            }   else    {
                _itoa( artid, szBuff, 10 ) ;
            }
            DWORD   cbOut = lstrlen( szBuff ) ;
            szBuff[ cbOut++ ] = ' ' ;
            DWORD   cbConsumed = cbBuff - cbOut - 1 ; // Reserve Room for NULL Terminator !

            GROUPID groupIdCurrent = context.m_pCurrentGroup->GetGroupId() ;
            GROUPID groupIdPrimary ;
            ARTICLEID   artidPrimary ;
                        CStoreId storeid;

            if( (context.m_pInstance)->XoverTable()->GetPrimaryArticle(
                                            groupIdCurrent,
                                            artid,
                                            groupIdPrimary,
                                            artidPrimary,
                                            cbConsumed,
                                            szBuff + cbOut,
                                            cbConsumed,
                                            HeaderOffset,
                                            HeaderLength,
                                                                                        storeid
                                            ) ) {

                if( groupIdCurrent != groupIdPrimary ) {

                    pGroup = context.m_pInstance->GetTree()->GetGroupById( groupIdPrimary ) ;

                }

                cbOut += cbConsumed ;
                szBuff[ cbOut ++ ] = '\r' ;
                szBuff[ cbOut ++ ] = '\n' ;
                cbBuff = cbOut ;

                //
                //  Let's try to get the actual CArticle object !! -
                //  Note don't cache articles for SSL sessions as our
                //  IO code can't re-use file handles
                //
                if( pGroup != 0 ) {

                                        //                    context.m_idCurrentArticle = artid ;      // this should only be done on a successfull completion !
                                        ArticleIdUpdate = artid ;
                                        pGroup->GetArticle(
                                                                        artidPrimary,
                                                                        context.m_pCurrentGroup,
                                                                        artid,
                                                                        storeid,
                                                                        &context.m_securityCtx,
                                                                        &context.m_encryptCtx,
                                                                        TRUE,
                                                                        pContext,
                                                                        pComplete
                                                                        ) ;

                }   else    {
                    ErrorTrace(0,"Not in article table6\n");
                    context.m_return.fSet( nrcNoArticleNumber ) ;
                    return  FALSE ;
                }
                return  TRUE ;
            }   else if( GetLastError() == ERROR_FILE_NOT_FOUND )   {

                ErrorTrace(0,"Not in article table7");
                context.m_return.fSet( nrcNoArticleNumber ) ;

            }   else    {

                ErrorTrace(0, "Hash table failure %x", GetLastError() ) ;
                context.m_return.fSet( nrcServerFault ) ;

            }
        }   else    {
                        if (artid == INVALID_ARTICLEID) {
                                context.m_return.fSet(nrcNoCurArticle);
                        } else {
                                context.m_return.fSet( nrcNoArticleNumber ) ;
                        }
        }
    }   else    {
        context.m_return.fSet( nrcNoGroupSelected ) ;
    }
    if( context.m_return.fIsClear() )
        context.m_return.fSet( nrcServerFault ) ;
    return  FALSE ;
}

CIOExecute*
CArticleCmd::make(  int cArgs,
                    char **argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    CIODriver&  driver
                                        ) {
/*++

Routine Description :

    Create a CArticleCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CArticleCmd if possible, otherwise a CErrorCmd object
    set to print the appropriate error.

--*/


    //
    //  Create a CArticleCmd object - GetArticleInfo does most of the work
    //

    _ASSERT( lstrcmpi( argv[0], "article" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    static  char    szOpt[] = "0 article " ;


        //
        //      Hack to get the CSessionSocket object
        //
        CSessionSocket* pSocket =       (CSessionSocket*)(((BYTE*)(&context)) - ((BYTE*)&((CSessionSocket*)0)->m_context)) ;

    CArticleCmd* pArtCmd = new  CArticleCmd(context.m_pInstance, driver, pSocket) ;

    InterlockedIncrementStat( (context.m_pInstance), ArticleCommands );

    if( pArtCmd != 0 ) {

                static  char    szCode[4] = { '2', '2', '0', ' ' } ;

        if( !pArtCmd->BuildTransmit(    argv[1], "220 ", szOpt, sizeof( szOpt ) - 1, context, driver ) ) {
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0 ;
        }

        context.m_nrcLast = nrcArticleFollows ;

        return  pArtCmd ;
    }

    context.m_return.fSet( nrcServerFault ) ;
    pExecute =  new( context )  CErrorCmd( context.m_return ) ;
    return  0 ;
}

CArticleCmd::~CArticleCmd() {

    //
    //  the virtual server instance is obtained in the constructor !
    //
    //m_pInstance->NNTPCloseHandle(   m_hArticleFile, m_pArticleFileInfo ) ;

        if( m_pFIOContext ) {
                ReleaseContext( m_pFIOContext ) ;
        }

}

BOOL
CArticleCmd::BuildTransmit( LPSTR   lpstrArg,
                            char        rgchSuccess[4],
                            LPSTR   lpstrOpt,
                            DWORD   cbOpt,
                            ClientContext&  context,
                            class   CIODriver&  driver ) {

    _ASSERT( m_pTransmit == 0 ) ;

    m_pTransmit = new( driver ) CIOTransmit( this ) ;

    if( m_pTransmit != 0 ) {

        m_pbuffer = driver.AllocateBuffer( 4000 ) ;
        DWORD   cbTotal = m_pbuffer->m_cbTotal ;

        if( m_pbuffer != 0 )    {

            //lstrcpy( &m_pbuffer->m_rgBuff[0], lpstrSuccess ) ;
            //m_cbOut = lstrlen( lpstrSuccess ) ;
                        CopyMemory( &m_pbuffer->m_rgBuff[0], rgchSuccess, 4 ) ;
                        m_cbOut = 4 ;
            cbTotal -= m_cbOut ;

            _ASSERT( m_pbuffer->m_rgBuff[m_cbOut -1] == ' ' ) ;

            if( GetArticleInfo( lpstrArg,
                                m_pGroup,
                                context,
                                m_pbuffer->m_rgBuff + 4,
                                cbTotal,
                                lpstrOpt,
                                cbOpt,
                                //m_hArticleFile,
                                //m_pArticleFileInfo,
                                                                m_pFIOContext,
                                                                &m_DriverCompletion,
                                m_HeaderOffset,
                                m_HeaderLength,
                                                                m_DriverCompletion.m_ArticleIdUpdate
                                ) ) {
                m_cbOut += cbTotal ;
                return  TRUE ;
            }
        }
    }
    if( context.m_return.fIsClear() ) {
        context.m_return.fSet( nrcServerFault ) ;
    }
    if( m_pTransmit )
        CIO::Destroy( m_pTransmit, driver ) ;
                                // CIOTransmit has reference to us and will
                                // destroy us when destroyed - no need for clean up
                                // by caller !
    return  FALSE ;
}

CIOExecute*
CHeadCmd::make( int cArgs,
                    char **argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CHeadCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CHeadCmd if possible, otherwise a CErrorCmd object
    set to print the appropriate error.

--*/


    //
    //  Create a CArticleCmd object - GetArticleInfo does most of the work
    //

    _ASSERT( lstrcmpi( argv[0], "head" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    static  char    szOpt[] = "0 head " ;
        //
        //      Hack to get the CSessionSocket object
        //
        CSessionSocket* pSocket =       (CSessionSocket*)(((BYTE*)(&context)) - ((BYTE*)&((CSessionSocket*)0)->m_context)) ;

    CHeadCmd* pHeadCmd = new    CHeadCmd(context.m_pInstance, driver, pSocket) ;

    if( pHeadCmd != 0 ) {

                static  char    szCode[4] = { '2', '2', '1' , ' ' } ;

        if( !pHeadCmd->BuildTransmit(   argv[1], "221 ", szOpt, sizeof( szOpt ) - 1, context, driver ) ) {
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0 ;
        }

        context.m_nrcLast = nrcHeadFollows ;

        return  pHeadCmd ;
    }

    context.m_return.fSet( nrcServerFault ) ;
    pExecute =  new( context )  CErrorCmd( context.m_return ) ;
    return  0 ;
}

BOOL
CHeadCmd::StartTransfer(    FIO_CONTEXT*        pFIOContext,          // File to transmit from
                            DWORD   ibStart,        // Starting offset within file
                            DWORD   cbLength,       // Number of bytes from file to send
                            CSessionSocket* pSocket,// Socket on which to send
                            CDRIVERPTR& pdriver,    // CIODriver object used by socket
                            CIORead*&   pRead,      // Next CIO derived read object
                            CIOWrite*&  pWrite ) {  // Next CIO derived write object to issue
    //
    //  This function is used to start sending an article requested by a client to
    //  the client.  We may be called from derived command objects for the Head and
    //  Body commands - so we have arguments for selecting the portion of the file
    //  to be transmitted.
    //
    if( m_pTransmit->Init(  pdriver, pFIOContext, ibStart, cbLength, m_pbuffer, 0, m_cbOut ) ) {

        static  char    szTail[] = ".\r\n" ;
        CopyMemory( &m_pbuffer->m_rgBuff[m_cbOut], szTail, sizeof( szTail ) -1 ) ;
        m_pTransmit->AddTailText( sizeof( szTail ) - 1 ) ;
        pWrite = m_pTransmit ;
        return  TRUE ;
    }
    return  FALSE ;
}

BOOL
CHeadCmd::GetTransferParms(
                        FIO_CONTEXT*    &pFIOContext,
                        DWORD&      ibOffset,
                        DWORD&      cbLength ) {

        if( m_pFIOContext != 0 ) {

        pFIOContext = m_pFIOContext ;
        ibOffset = m_HeaderOffset ;
        cbLength = m_HeaderLength ;

        return  TRUE ;

    }
    return  FALSE ;
}


CIOExecute*
CBodyCmd::make( int cArgs,
                    char **argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CStatCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    The created CBodyCmd if possible, otherwise a CErrorCmd object
    set to print the appropriate error.

--*/


    //
    //  Create a CArticleCmd object - GetArticleInfo does most of the work
    //

    _ASSERT( lstrcmpi( argv[0], "body" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    static  char    szOpt[] = "0 body " ;
        //
        //      Hack to get the CSessionSocket object
        //
        CSessionSocket* pSocket =       (CSessionSocket*)(((BYTE*)(&context)) - ((BYTE*)&((CSessionSocket*)0)->m_context)) ;

    CBodyCmd* pBodyCmd = new    CBodyCmd(context.m_pInstance, driver, pSocket) ;

    if( pBodyCmd != 0 ) {

                static  char    szCode[4] = { '2', '2', '2', ' ' } ;

        if( !pBodyCmd->BuildTransmit(   argv[1], "222 ", szOpt, sizeof( szOpt ) - 1, context, driver ) ) {
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0 ;
        }

        context.m_nrcLast = nrcBodyFollows ;

        return  pBodyCmd;
    }

    context.m_return.fSet( nrcServerFault ) ;
    pExecute =  new( context )  CErrorCmd( context.m_return ) ;
    return  0 ;
}

BOOL
CBodyCmd::GetTransferParms(
                        FIO_CONTEXT*    &pFIOContext,
                        DWORD&      ibOffset,
                        DWORD&      cbLength ) {

        if( m_pFIOContext ) {

        pFIOContext = m_pFIOContext ;
        ibOffset = m_HeaderOffset + m_HeaderLength ;
        cbLength = m_cbArticleLength - m_HeaderLength ;

        return  TRUE ;
    }
    return  FALSE ;
}

BOOL
CArticleCmd::IsValid( ) {

    return  TRUE ;
}

CIOExecute*
CUnimpCmd::make(    int cArgs,
                    char **argv,
                    CExecutableCommand*&  pexecute,
                    struct ClientContext&   context,
                    CIODriver&  driver ) {
/*++

Routine Description :

    Create a CUnimpCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CErrorCmd object which will print the necessary message !

--*/


    //
    //  Create a CUnimpCmd object - which just reports error 503 !
    //

    context.m_return.fSet( nrcNotRecognized ) ;

    pexecute = new( context ) CErrorCmd( context.m_return ) ;
    return  0 ;
}

int
CUnimpCmd::StartExecute(    BYTE *lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext&,
                            CLogCollector*  pCollector ) {

    static  char    szUnimp[] = "503 - Command Not Recognized\r\n" ;

    CopyMemory( lpb, szUnimp, sizeof( szUnimp ) ) ;
    fComplete = TRUE ;

    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, 4 ) ;
    }

    return  sizeof( szUnimp )  - 1 ;
}


CIOExecute*
CDateCmd::make( int cArgs,
                char    **argv,
                CExecutableCommand*&  pexecute,
                struct ClientContext&   context,
                class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CDateCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CDateCmd object which will print the necessary message !

--*/



    //
    //  Create a CDateCmd object - there's not much to do !
    //

    _ASSERT( lstrcmpi( argv[0], "date" ) == 0 ) ;

    CDateCmd    *pCmd = new( context ) CDateCmd() ;
    pexecute = pCmd ;
    return  0 ;
}

int
CDateCmd::StartExecute( BYTE*   lpb,
                        int     cb,
                        BOOL&   fComplete,
                        void*&  pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the Date response string into the buffer to be sent to the client.
    Assume its short so mark fComplete TRUE after this call.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  This function implements the date command - assume the caller always
    //  provides a large enough buffer.
    //
    //  Just send the current time !
    //

    SYSTEMTIME  systime ;

    GetSystemTime( &systime ) ;

    int cbOut = _snprintf( (char*)lpb, cb, "111 %04d%02d%02d%02d%02d%02d\r\n",
            systime.wYear, systime.wMonth, systime.wDay, systime.wHour, systime.wMinute, systime.wSecond ) ;
    _ASSERT( cbOut > 0 ) ;
    fComplete = TRUE ;

    context.m_nrcLast = nrcDateFollows ;

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, cbOut-2 ) ;
    }
    */

    return  cbOut ;
}



BOOL
GetTimeDateAndDistributions(    int cArgs,
                                char **argv,
                                FILETIME&   filetimeOut,
                                ClientContext&  context ) {

    TraceFunctEnter( "GetTimeDateAndDistributions" ) ;

    //
    //  This function is used by the newnews and newgroups command to parse much of their
    //  command lines.  we basically want to return a FILETIME structure containing a time
    //  corresponding to the request - or set the ClientContext's error code to an appropriate
    //  value !
    //

    FILETIME    filetime ;

    if( cArgs > 4 || cArgs < 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
        return  FALSE ;
    }   else    {

        if( lstrlen( argv[0] ) != 6 || lstrlen( argv[1] ) != 6 ) {
            context.m_return.fSet( nrcSyntaxError ) ;
            return  FALSE ;
        }

        SYSTEMTIME  systime ;
        int cScanned = sscanf( argv[0], "%2hd%2hd%2hd", &systime.wYear,
                                    &systime.wMonth, &systime.wDay) ;

        //systime.wMonth = min( systime.wMonth, 12 ) ;
        //systime.wDay = min( systime.wDay, 32 ) ;
        if( systime.wYear < 50 )
            systime.wYear += 2000 ;
        else
            systime.wYear += 1900 ;

        cScanned += sscanf( argv[1], "%2hd%2hd%2hd", &systime.wHour,
                                    &systime.wMinute, &systime.wSecond) ;
        systime.wDayOfWeek = 0 ;
        //systime.wHour = min( systime.wHour, 23 ) ;
        //systime.wMinute = min( systime.wMinute, 59 ) ;
        //systime.wSecond = min( systime.wSecond, 59 ) ;
        systime.wMilliseconds = 0 ;

        if( cScanned != 6 ) {
            context.m_return.fSet( nrcSyntaxError ) ;
            return  FALSE ;
        }

        FILETIME    localtime ;
        if( !SystemTimeToFileTime( &systime, &localtime) )  {
            context.m_return.fSet( nrcSyntaxError ) ;
            return  FALSE ;
        }
        filetime = localtime ;

        //
        //  We have UTC times both on the files and in the hash tables !
        //  Therefore when the user specified GMT no conversion is needed because
        //  we will be comparing to UTC times, but when they don't specify
        //  GMT we need to take the time they passed us and convert to UTC for
        //  comparison purposes !!!
        //


        if( cArgs == 2 )    {

            //
            //  GMT NOT specified ! - convert our localtime to UTC !!
            //

            if( !LocalFileTimeToFileTime( &localtime, &filetime ) ) {
                    DWORD   dw = GetLastError() ;
                    _ASSERT( 1==0 ) ;
            }

        }   else    {

            //
            //  There's between 2 and 4 arguments - so must be more than 2 !
            //
            _ASSERT( cArgs > 2 ) ;

            //
            //  Did they specify GMT ??
            //
            if( lstrcmp( argv[2], "GMT" ) == 0 ) {
                //
                //  GMT Is specified ! - don't need to convert our localtime to UTC !!
                //

                if( cArgs == 4  ) {
                    // Check for distributions line
                    //context.m_return.fSet( nrcSyntaxError ) ;
                    //return    FALSE ;
                }
            }   else    {
                //
                //  GMT NOT specified ! - convert our localtime to UTC !!
                //

                if( !LocalFileTimeToFileTime( &localtime, &filetime ) ) {
                        DWORD   dw = GetLastError() ;
                        _ASSERT( 1==0 ) ;
                }

                //
                //  Eventually there needs to be logic to deal with distributions here !
                //  but for now ignore the problem !
                //

                if( cArgs == 4 ) {
                    context.m_return.fSet( nrcSyntaxError ) ;
                    return  FALSE ;
                }
            }
        }
#ifdef  DEBUG

    FILETIME    DebugLocalTime ;
    SYSTEMTIME  DebugLocalSystemTime ;
    SYSTEMTIME  DebugUTCTime ;

    FileTimeToLocalFileTime( &filetime, &DebugLocalTime ) ;
    FileTimeToSystemTime( &DebugLocalTime, &DebugLocalSystemTime ) ;
    FileTimeToSystemTime( &filetime, &DebugUTCTime ) ;

    DebugTrace( 0, "Debug Local Time YYMMDD %d %d %d HHMMSS %d %d %d",
            DebugLocalSystemTime.wYear, DebugLocalSystemTime.wMonth, DebugLocalSystemTime.wDay,
            DebugLocalSystemTime.wHour, DebugLocalSystemTime.wMinute, DebugLocalSystemTime.wSecond ) ;

    DebugTrace( 0, "Debug UTC Time YYMMDD %d %d %d HHMMSS %d %d %d",
            DebugUTCTime.wYear, DebugUTCTime.wMonth, DebugUTCTime.wDay,
            DebugUTCTime.wHour, DebugUTCTime.wMinute, DebugUTCTime.wSecond ) ;

#endif
    }
    filetimeOut = filetime ;
    return  TRUE ;
}

CIOExecute*
CNewgroupsCmd::make(    int cArgs,
                        char **argv,
                        class CExecutableCommand*&    pExecute,
                        struct ClientContext&   context,
                        CIODriver&  driver ) {
/*++

Routine Description :

    Create a CNewgroupsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNewgroupsCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Use GetTimeDateAndDistributions to parse the command line, and if that succeeds
    //  create a CNewgroups object !
    //

    _ASSERT( lstrcmpi( argv[0], "newgroups" ) == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), NewgroupsCommands );

    FILETIME    localtime ;

    if( !GetTimeDateAndDistributions( cArgs-1, &argv[1], localtime, context ) ) {
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {
        CGroupIterator* pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                            context.m_IsSecureConnection,   // include secure ?
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        if( pIterator != 0 ) {
            pExecute = new( context ) CNewgroupsCmd( localtime, pIterator ) ;
            if( pExecute == 0 )
                delete  pIterator ;
            else
                return  0 ;
        }
    }
    context.m_return.fSet( nrcServerFault ) ;
    pExecute = new( context ) CErrorCmd( context.m_return ) ;
    return  0 ;
}


CNewgroupsCmd::CNewgroupsCmd(   FILETIME&   time,
                                CGroupIterator* pIter ) :
    m_time( time ), m_pIterator( pIter ) {
    //
    //  This constructor must be provided valid arguments !
    //
}

CNewgroupsCmd::~CNewgroupsCmd() {

    if( m_pIterator != 0 ) {
        delete  m_pIterator ;
    }
}

int
CNewgroupsCmd::StartExecute(    BYTE    *lpb,
                                int cb,
                                BOOL&   fComplete,
                                void*&  pv,
                                ClientContext&  context,
                                CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CNewsgroupsCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Print our initial response line into the buffer !
    //

    static  char    szNewgroups[] = "231 New newsgroups follow.\r\n" ;
    _ASSERT( cb > sizeof( szNewgroups ) ) ;

    context.m_nrcLast = nrcNewgroupsFollow ;

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szNewgroups, 4 ) ;
    }
    */

    CopyMemory( lpb, szNewgroups, sizeof( szNewgroups ) ) ;
    return  sizeof( szNewgroups ) - 1 ;
}

int
CNewgroupsCmd::PartialExecute(  BYTE    *lpb,
                                int     cb,
                                BOOL&   fComplete,
                                void*&  pv,
                                ClientContext&,
                                CLogCollector*  pCollector ) {
/*++

Routine Description :

    Examine each newsgroup in the newsgroup tree and determine whether we should
    send info on it to the client.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Check each newsgroup's Time to the time the client specified, and if necessary send
    //  print the newsgroup info into the supplied buffer !
    //


    fComplete = FALSE ;
    int cbRtn = 0 ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;
                _ASSERT(p != NULL);

                if (p != NULL) {
                FILETIME    grouptime = p->GetGroupTime() ;
                SYSTEMTIME  systime ;
                FileTimeToSystemTime( &grouptime, &systime ) ;
                if( CompareFileTime( &grouptime, &m_time ) > 0 ) {
                    if( cb - cbRtn > 10 ) {
                        int cbTemp = _snprintf( (char*)lpb+cbRtn, cb-cbRtn, "%s %d %d %c\r\n",
                                p->GetNativeName(), p->GetLastArticle(), p->GetFirstArticle(), 'y' ) ;
                        if( cbTemp < 0 ) {
                            return  cbRtn ;
                        }   else    {
                            cbRtn += cbTemp ;
                        }
                    }   else    {
                        return  cbRtn ;
                    }
                }
                }
        m_pIterator->Next() ;
    }
    _ASSERT( cbRtn <= cb ) ;
    if( cb - cbRtn > 3 ) {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    _ASSERT( cbRtn <= cb ) ;
    return  cbRtn ;
}


LPMULTISZ
BuildMultiszFromCommas( LPSTR   lpstr )     {

    char*   pchComma = lpstr ;

    while( (pchComma = strchr( pchComma, ',' )) != 0 ) {
        *pchComma++ = '\0' ;
        char*   pchCommaBegin = pchComma ;
        while( *pchComma == ',' )
            pchComma++ ;

        if( pchComma != pchCommaBegin ) {
            MoveMemory( pchCommaBegin, pchComma, lstrlen( pchComma )+2 ) ;
        }

    }
    return  lpstr ;
}

CIOExecute*
CNewnewsCmd::make(  int cArgs,
                    char **argv,
                    class CExecutableCommand*&    pExecute,
                    struct ClientContext&   context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CNewnewsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNewnewsCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Use GetTimeDataAndDistributions to parse the clients command line
    //  If that succeeds build an iterator which will enumerate all of the
    //  requested newsgroups.  Then create a CNewnewsCmd object.
    //

    _ASSERT( lstrcmpi( argv[0], "newnews" ) == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), NewnewsCommands );

    FILETIME    localtime ;

    if( !(context.m_pInstance)->FAllowNewnews() ) {
        context.m_return.fSet( nrcNoAccess ) ;
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }

    if( !GetTimeDateAndDistributions( cArgs-2, &argv[2], localtime, context ) ) {
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {
        CGroupIterator* pIterator = 0 ;

        //
        //  We need to provide a DOUBLE NULL terminated list to GetIterator() -
        //  we know there must be at least 4 args, so since we're done with the third
        //  arg, zap it to make sure we pass a DOUBLE NULL terminated string !
        //
        *argv[2] = '\0' ;
        if( *argv[1] == '*' && argv[1][1] == '\0' ) {
            pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                    context.m_IsSecureConnection,   // include secure ?
                                                    &context.m_securityCtx,         // client security ctx
                                                    context.m_IsSecureConnection,   // is client conx secure ?
                                                    &context.m_encryptCtx           // client ssl ctx
                                                    ) ;
        } else  {
            LPMULTISZ lpmulti = BuildMultiszFromCommas( argv[1] ) ;
            pIterator = (context.m_pInstance)->GetTree()->GetIterator(  lpmulti,
                                                            context.m_IsSecureConnection,
                                                            FALSE,
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        }

        if( pIterator != 0 ) {
            pExecute = new( context ) CNewnewsCmd( localtime, pIterator, argv[1] ) ;
            if( pExecute == 0 )
                delete  pIterator ;
            else
                return  0 ;
        }
    }
    context.m_return.fSet( nrcServerFault ) ;
    pExecute = new( context ) CErrorCmd( context.m_return ) ;
    return  0 ;
}

CNewnewsCmd::CNewnewsCmd(   FILETIME&   time,
                            CGroupIterator* pIter,
                            LPSTR       lpstrPattern ) :
    m_time( time ),
    m_pIterator( pIter ),
    m_artidCurrent( INVALID_ARTICLEID ),
    m_cMisses( 0 ),
    m_lpstrPattern( lpstrPattern ) {
    //
    //  All constructor args must be valid
    //
}

CNewnewsCmd::~CNewnewsCmd( )    {

    if( m_pIterator != 0 )
        delete  m_pIterator ;

}

CNewnewsCmd::StartExecute(  BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void*&  pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CNewsnewsCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Copy the initial response string into the buffer
    //

    static  char    szNewnews[] = "230 list of new articles by message-id follows.\r\n" ;
    _ASSERT( cb > sizeof( szNewnews) ) ;

    context.m_nrcLast = nrcNewnewsFollows ;

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szNewnews, 4 ) ;
    }
    */

    CopyMemory( lpb, szNewnews, sizeof( szNewnews)-1 ) ;
    return  sizeof( szNewnews ) - 1 ;
}


class   CExtract :  public  IExtractObject  {
public :

    CNewsTree*  m_pTree ;
    LPSTR       m_lpstrGroupName ;
    LPMULTISZ   m_lpmultiGroupPattern ;

    CExtract(   CNewsTree*  pTree,
                LPSTR   lpstrGroup,
                LPMULTISZ   lpmulti ) :
        m_pTree( pTree ),
        m_lpstrGroupName( lpstrGroup ),
        m_lpmultiGroupPattern( lpmulti ) {}

    BOOL
    DoExtract(  GROUPID PrimaryGroup,
                ARTICLEID   PrimaryArticle,
                PGROUP_ENTRY    pGroups,
                DWORD           cGroups ) ;


} ;

BOOL
CExtract::DoExtract(
                GROUPID     PrimaryGroup ,
                ARTICLEID   PrimaryArticle,
                PGROUP_ENTRY    pGroups,
                DWORD       nXPost ) {


    GROUPID xgroup;

    CGRPPTR pGroup;

    _ASSERT(m_lpmultiGroupPattern != NULL);
    _ASSERT(m_lpstrGroupName != NULL ) ;

    //
    // start with the primary group
    //

    xgroup = PrimaryGroup;

    //
    // ok, do the xposted groups
    //

    BOOL fGroupIsPrimary = TRUE;

    do
        {
        pGroup = m_pTree->GetGroupById(xgroup);

        if(pGroup != 0) {
            if ( MatchGroup( m_lpmultiGroupPattern, pGroup->GetName() ) ) {
                if ( lstrcmpi( m_lpstrGroupName, pGroup->GetName() ) == 0 ) {
                     return  TRUE ;
                } else {
                     return  FALSE ;
                }
            }
        } else if( fGroupIsPrimary ) {
            // bail only if group is primary, else skip to next group
            return  FALSE ;
        }

        if ( nXPost > 0 ) {
            xgroup = pGroups->GroupId;
            pGroups++;
            fGroupIsPrimary = FALSE;
        }

    } while ( nXPost-- > 0 );
    return  FALSE ;
}

int
CNewnewsCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )   {
/*++

Routine Description :

    Examine each newsgroup in the newsgroup tree and within that newsgroup
    examine the articles to determine whether they meet the date requirements
    and the article's message id should be sent to the client.
    We use the XOVER table extensively instead of opening individual article files.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The clients state.

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/
    int cbRtn = 0 ;
    fComplete = FALSE ;
    FILETIME    filetime ;
    ARTICLEID   artidFirst ;

    TraceFunctEnter( "CNewnewsCmd::PartialExecute" ) ;

    //
    //  Variables to hold file offsets in articles - we don't need these
    //
    WORD    HeaderOffsetJunk ;
    WORD    HeaderLengthJunk ;


    //
    //  Iterate through all of the requested newsgroups, in each newsgroup use the
    //  XOVER hash table to search all of the article id's to find any articles matching
    //  the time/date requirements.  If they are found print the Message-Id's into the
    //  supplied buffer.
    //  Note : We start looking for matching time/date requirements from the last article id
    //  and work backwards. We will stop looking when 5 articles have not met the requirement.
    //  (as ARTICLEID's will be assigned in almost chronological order.)
    //


    //
    // reserve space for \r\n
    //

    DWORD entrySize = cb - cbRtn - 2;

    //
    // Get the xover information from the database
    //

    while( !m_pIterator->IsEnd() && !(context.m_pInstance)->GetTree()->m_bStoppingTree ) {

        //
        //  Note - iterator only returns those groups matching the pattern
        //  string it was created with when CNewnewsCmd::make was called !
        //
        CGRPPTR p = m_pIterator->Current() ;

        _ASSERT( p!=0 ) ;
        if( m_artidCurrent == INVALID_ARTICLEID ) {
            m_artidCurrent = p->GetLastArticle() ;
            m_cMisses = 0 ;
        }   else    {


        }
        artidFirst = p->GetFirstArticle() ;
        _ASSERT( artidFirst > 0 );

        while( m_artidCurrent >= artidFirst && m_cMisses < 5 && !(context.m_pInstance)->GetTree()->m_bStoppingTree ) {

            BOOL    fPrimary;   // We won't use this - we don't care whether Primary or not !
            CExtract    extractor(  (context.m_pInstance)->GetTree(),
                                    p->GetName(),
                                    m_lpstrPattern
                                    ) ;

                        DWORD cStoreIds = 0;
            if( (context.m_pInstance)->XoverTable()->ExtractNovEntryInfo(
                                            p->GetGroupId(),
                                            m_artidCurrent,
                                            fPrimary,
                                            HeaderOffsetJunk,
                                            HeaderLengthJunk,
                                            &filetime,
                                            entrySize,
                                            (PCHAR)(lpb+cbRtn),
                                                                                        cStoreIds,
                                                                                        NULL,
                                                                                        NULL,
                                            &extractor
                                            )   )   {

                if( entrySize != 0  ) {


#ifdef  DEBUG

                    FILETIME    DebugLocalTime ;
                    SYSTEMTIME  DebugLocalSystemTime ;
                    SYSTEMTIME  DebugUTCTime ;

                    FileTimeToLocalFileTime( &filetime, &DebugLocalTime ) ;
                    FileTimeToSystemTime( &DebugLocalTime, &DebugLocalSystemTime ) ;
                    FileTimeToSystemTime( &filetime, &DebugUTCTime ) ;

                    DebugTrace( 0, "Debug Local Time YYMMDD %d %d %d HHMMSS %d %d %d",
                            DebugLocalSystemTime.wYear, DebugLocalSystemTime.wMonth, DebugLocalSystemTime.wDay,
                            DebugLocalSystemTime.wHour, DebugLocalSystemTime.wMinute, DebugLocalSystemTime.wSecond ) ;

                    DebugTrace( 0, "XOVER - Debug UTC Time YYMMDD %d %d %d HHMMSS %d %d %d",
                            DebugUTCTime.wYear, DebugUTCTime.wMonth, DebugUTCTime.wDay,
                            DebugUTCTime.wHour, DebugUTCTime.wMinute, DebugUTCTime.wSecond ) ;

                    FileTimeToSystemTime( &m_time, &DebugUTCTime ) ;

                    DebugTrace( 0, "TARGET - Debug UTC Time YYMMDD %d %d %d HHMMSS %d %d %d",
                            DebugUTCTime.wYear, DebugUTCTime.wMonth, DebugUTCTime.wDay,
                            DebugUTCTime.wHour, DebugUTCTime.wMinute, DebugUTCTime.wSecond ) ;

#endif

                    if( CompareFileTime( &filetime, &m_time ) < 0 ) {
                        m_cMisses++ ;
                    }   else    {

                        //
                        // send the msg id
                        //

                        cbRtn += entrySize;
                        CopyMemory(  lpb+cbRtn, "\r\n", 2 );
                        cbRtn += 2;
                        if( cb-2 <= cbRtn ) {

                            _ASSERT( cbRtn != 0 ) ;

                            return  cbRtn ;
                        }
                    }
                }
            }   else    if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

                _ASSERT( cbRtn != 0 || cb < 100 ) ;

                return  cbRtn ;
            }

            _ASSERT( (cb-2) > cbRtn ) ;
            _ASSERT( cbRtn <= cb ) ;
            _ASSERT( m_artidCurrent != 0 );
            if ( m_artidCurrent == 0 ) break;
            m_artidCurrent-- ;
            entrySize = cb - cbRtn - 2 ;
        }
        _ASSERT( cbRtn <= cb ) ;
        m_pIterator->Next() ;
        m_artidCurrent = INVALID_ARTICLEID ;
    }
    _ASSERT( cbRtn <= cb || (context.m_pInstance)->GetTree()->m_bStoppingTree ) ;
    _ASSERT( m_cMisses <= 5 || (context.m_pInstance)->GetTree()->m_bStoppingTree ) ;
    _ASSERT( m_artidCurrent >= artidFirst || (context.m_pInstance)->GetTree()->m_bStoppingTree ) ;
    //
    // all done ?
    //
    if ( m_pIterator->IsEnd() || (context.m_pInstance)->GetTree()->m_bStoppingTree ) {
        //
        // add the terminating . if done
        //
        if( cb - cbRtn > 3 )    {
            CopyMemory( lpb+cbRtn, StrTermLine, 3 );
            cbRtn += 3 ;
            fComplete = TRUE;
        }
    }

    _ASSERT( cbRtn != 0 ) ;

    return  cbRtn ;
}



CIOExecute*
CGroupCmd::make(    int    cArgs,
                    char **argv,
                    CExecutableCommand*&  pexecute,
                    struct ClientContext&   context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CGroupCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CGroupCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Create a CGroupCmd object if we can find the specified newsgroup.
    //  otherwise return an error to the client.
    //
    _ASSERT( lstrcmpi( argv[0], "group" ) == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), GroupCommands );

    CGroupCmd*  pCmd = 0 ;
    if( cArgs == 2 ) {
        CGRPPTR p = (context.m_pInstance)->GetTree()->GetGroup( argv[1], lstrlen( argv[1] )+1 ) ;
        if( p!= 0 ) {

            if( p->IsGroupAccessible(   context.m_securityCtx,
                                                                        context.m_encryptCtx,
                                        context.m_IsSecureConnection,
                                        FALSE,
                                        TRUE    ) ) {
                pCmd =  new( context )  CGroupCmd( p ) ;
                pexecute = pCmd ;
                return  0 ;
            }   else    {

                if( context.m_securityCtx.IsAnonymous() ) {

                    context.m_return.fSet( nrcLogonRequired ) ;

                }   else    {

                    context.m_return.fSet( nrcNoAccess ) ;

                }

            }
        }   else    {
            context.m_return.fSet( nrcNoSuchGroup) ;
        }
    }   else    {
        context.m_return.fSet( nrcSyntaxError ) ;
    }
    _ASSERT( !context.m_return.fIsClear() ) ;
    pexecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

CGroupCmd::CGroupCmd( CGRPPTR   p ) : m_pGroup( p ) { }

DWORD
NNTPIToA(
        DWORD   dw,
        char*   pchBuf
        )       {

        char    *pchBegin = pchBuf ;
        DWORD   digval;

        do      {
                digval = dw % 10 ;
                dw /= 10 ;
                *pchBuf++       = (char)(digval + '0') ;
        }       while( dw > 0 ) ;

        DWORD   dwReturn = (DWORD)(pchBuf-pchBegin) ;
        char    *pchLast = pchBuf-1 ;

        do      {
                char    temp = *pchLast ;
                *pchLast = *pchBegin ;
                *pchBegin = temp ;
                --pchLast ;
                pchBegin++ ;
        }       while( pchBegin < pchLast ) ;

        return  dwReturn ;
}

int
CGroupCmd::StartExecute(    BYTE *lpb,
                            int cbSize,
                            BOOL    &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Change the clients context so that they are now operating in a different group.
    We will also print the necessary response string !
    We assume that we will be provided a large enough buffer for whatever we want to print.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Print a string into the supplied buffer and adjust the ClientContext.
    //

    // _ASSERT( IsValid() ) ;
    int cbRtn = 0 ;

    context.m_nrcLast = nrcGroupSelected ;

    if( m_pGroup != 0  )    {
                CopyMemory( lpb, "211 ", 4 ) ;
                cbRtn = 4 ;

                char    szNumBuff[30] ;
                DWORD   cb = NNTPIToA( m_pGroup->GetArticleEstimate(), szNumBuff ) ;
                CopyMemory( lpb+cbRtn, szNumBuff, cb ) ;
                cbRtn += cb ;
                lpb[cbRtn++] = ' ' ;

                cb = NNTPIToA( m_pGroup->GetFirstArticle(), szNumBuff ) ;
                CopyMemory( lpb+cbRtn, szNumBuff, cb ) ;
                cbRtn += cb ;
                lpb[cbRtn++] = ' ' ;

                cb = NNTPIToA( m_pGroup->GetLastArticle(), szNumBuff ) ;
                CopyMemory( lpb+cbRtn, szNumBuff, cb ) ;
                cbRtn += cb ;
                lpb[cbRtn++] = ' ' ;

                cb = m_pGroup->FillNativeName( (char*)lpb+cbRtn, cbSize - cbRtn ) ;
                cbRtn += cb ;

                lpb[cbRtn++] = '\r' ;
                lpb[cbRtn++] = '\n' ;

        if( cbRtn < 0 ) {
            _ASSERT( 1==0 ) ;
            // Not large enough buffer to send the string !!
            return  0 ;
        }
        context.m_pCurrentGroup = m_pGroup ;
        if( m_pGroup->GetArticleEstimate() > 0 )
            context.m_idCurrentArticle = m_pGroup->GetFirstArticle() ;
        else
            context.m_idCurrentArticle = INVALID_ARTICLEID ;
    }   else    {
        _ASSERT( 1==0 ) ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, cbRtn-2 ) ;
    }
    */

    fComplete = TRUE ;
    return  cbRtn ;
}

int
CGroupCmd::PartialExecute(  BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void *&pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {

    //
    //  We assume StartExecute will always succeed since we send such a small string and
    //  the caller always provides large buffers.
    //
    //

    _ASSERT( 1==0 ) ;
    return 0 ;
}


CIOExecute*
CListgroupCmd::make(    int    cArgs,
                    char **argv,
                    CExecutableCommand*&  pexecute,
                    struct ClientContext&   context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CGroupCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CGroupCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Create a CGroupCmd object if we can find the specified newsgroup.
    //  otherwise return an error to the client.
    //
    _ASSERT( lstrcmpi( argv[0], "listgroup" ) == 0 ) ;

    CListgroupCmd*  pCmd = 0 ;
    if( cArgs == 2 ) {
        CGRPPTR p = (context.m_pInstance)->GetTree()->GetGroup( argv[1], lstrlen( argv[1] )+1 ) ;
        if( p!= 0 ) {

            if( p->IsGroupAccessible(   context.m_securityCtx,
                                                                        context.m_encryptCtx,
                                        context.m_IsSecureConnection,
                                        FALSE,
                                        TRUE    ) ) {
                pCmd =  new( context )  CListgroupCmd( p ) ;
                pexecute = pCmd ;
                return  0 ;
            }   else    {

                if( context.m_securityCtx.IsAnonymous() ) {

                    context.m_return.fSet( nrcLogonRequired ) ;

                }   else    {

                    context.m_return.fSet( nrcNoAccess ) ;

                }

            }
        }   else    {
            context.m_return.fSet( nrcNoSuchGroup ) ;
        }
    }   else    if( cArgs == 1 ) {

        if( context.m_pCurrentGroup != 0 ) {

            pCmd = new( context )   CListgroupCmd( context.m_pCurrentGroup ) ;
            pexecute = pCmd ;
            return  0 ;

        }

        context.m_return.fSet( nrcNoListgroupSelected ) ;

    }   else    {
        context.m_return.fSet( nrcSyntaxError ) ;
    }
    _ASSERT( !context.m_return.fIsClear() ) ;
    pexecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

CListgroupCmd::CListgroupCmd( CGRPPTR   p ) : m_pGroup( p ) { }

int
CListgroupCmd::StartExecute(    BYTE *lpb,
                            int cb,
                            BOOL    &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Change the clients context so that they are now operating in a different group.
    We will also print the necessary response string !
    We assume that we will be provided a large enough buffer for whatever we want to print.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/

    //
    //  Print a string into the supplied buffer and adjust the ClientContext.
    //

    // _ASSERT( IsValid() ) ;
    int cbRtn = 0 ;
    static  char    szListGroupResponse[] = "211\r\n" ;

    context.m_nrcLast = nrcGroupSelected ;

    if( m_pGroup != 0  )    {

        m_curArticle = m_pGroup->GetFirstArticle() ;

        CopyMemory( lpb, szListGroupResponse, sizeof( szListGroupResponse ) ) ;
        cbRtn  += sizeof( szListGroupResponse ) - 1 ;
        context.m_pCurrentGroup = m_pGroup ;
        if( m_pGroup->GetArticleEstimate() > 0 )
            context.m_idCurrentArticle = m_curArticle ;
        else
            context.m_idCurrentArticle = INVALID_ARTICLEID ;
    }   else    {
        _ASSERT( 1==0 ) ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, cbRtn-2 ) ;
    }
    */

    return  cbRtn ;
}

int
CListgroupCmd::PartialExecute(  BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void *&pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {

    //
    //  We assume StartExecute will always succeed since we send such a small string and
    //  the caller always provides large buffers.
    //
    //

    DWORD   cbRtn = 0 ;
    ARTICLEID   artidMax = m_pGroup->GetLastArticle() ;
    DWORD cbRemaining = cb;
    ARTICLEID artidTemp = m_curArticle;

    fComplete = FALSE;

    while( artidTemp <= artidMax  && cbRemaining > 20 ) {

        if( context.m_pInstance->XoverTable()->SearchNovEntry( context.m_pCurrentGroup->GetGroupId(),
                                        artidTemp,
                                        0,
                                        0 ) ) {

            //
            //  Change the current Article position.
            //  Send the Command succeeded response.
            //

            _itoa( artidTemp, (char*)lpb + cbRtn, 10 ) ;
            cbRtn += lstrlen( (char*)lpb + cbRtn) ;

            _ASSERT( int(cbRtn + 2) <= cb ) ;
            lpb[cbRtn++] = '\r' ;
            lpb[cbRtn++] = '\n' ;
            cbRemaining = cb - cbRtn ;

        }   else    {
            _ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ;
        }
        artidTemp++ ;
    }
    if( artidTemp >= artidMax ) {
        static  char    szTerm[] = ".\r\n" ;
        if( cbRemaining >= sizeof( szTerm ) - 1 ) {
            CopyMemory( lpb + cbRtn, szTerm, sizeof( szTerm ) - 1 ) ;
            cbRtn += sizeof( szTerm ) -1 ;
            fComplete = TRUE ;
        }
    }
    m_curArticle = artidTemp ;
    return  cbRtn ;

}


CIOExecute*
CListCmd::make( int argc,
                char **argv,
                CExecutableCommand*&    pExecute,
                struct ClientContext& context,
                class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CNewnewsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNewnewsCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/

    TraceFunctEnter( "CListCmd::make" ) ;

    InterlockedIncrementStat( (context.m_pInstance), ListCommands );

    //
    // check to see if they've done a LIST SRCHFIELDS
    //
    // if so they aren't listing groups, so we need to use the
    // CSearchFields object
    //
    if (argc >= 2 && lstrcmpi(argv[1], "srchfields") == 0) {
        return CSearchFieldsCmd::make(argc, argv, pExecute, context, driver);
    }

        //
        // check to see if they've done a LIST OVERVIEW.FMT
        //
        // if so they aren't listing groups, so we need to use the COverviewFmtCmd
        // objects
        //
        if (argc >= 2 && lstrcmpi(argv[1], "overview.fmt") == 0) {
        return COverviewFmtCmd::make(argc, argv, pExecute, context, driver);
        }

        //
        // LIST EXTENSIONS
        //
        if (argc >= 2 && lstrcmpi(argv[1], "extensions") == 0) {
        return CListExtensionsCmd::make(argc, argv, pExecute, context, driver);
        }

        //
    //  create a CListCmd object.
    //  If the user specified 'list active' they may also specify a
    //  3rd argument which should be a wildmat compatible string.
    //  We will pass this 3rd arg to GetIterator() if it exists,
    //  otherwise we will list all active groups.
    //

    CGroupIterator* pIterator = 0 ;
    CListCmd    *p = 0 ;
    if( argc == 1 || lstrcmpi( argv[1], "active" ) == 0 ) {
        if( argc <= 2 ) {
            pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                    context.m_IsSecureConnection,   // include secure ?
                                                    &context.m_securityCtx,         // client security ctx
                                                    context.m_IsSecureConnection,   // is client conx secure ?
                                                    &context.m_encryptCtx           // client ssl ctx
                                                    ) ;
        }   else if( argc == 3 )    {
            LPMULTISZ   multisz = BuildMultiszFromCommas( argv[2] ) ;
            pIterator = (context.m_pInstance)->GetTree()->GetIterator(  multisz,
                                                            context.m_IsSecureConnection,
                                                            FALSE,
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        }   else    {
            context.m_return.fSet( nrcSyntaxError ) ;
            pExecute = new( context )   CErrorCmd( context.m_return ) ;
            return  0 ;
        }
        if( pIterator != 0 ) {
            p = new( context )  CListCmd( pIterator ) ;
            pExecute = p ;
            return  0 ;
        }
    }   else    if( argc >= 2 && lstrcmpi( argv[1], "newsgroups" ) == 0 )     {

        if( argc == 3 ) {
            LPMULTISZ   multisz = BuildMultiszFromCommas( argv[2] ) ;
            pIterator = (context.m_pInstance)->GetTree()->GetIterator(  multisz,
                                                            context.m_IsSecureConnection,
                                                            FALSE,
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        }   else    {
            pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                        context.m_IsSecureConnection,   // include secure ?
                                                        &context.m_securityCtx,         // client security ctx
                                                        context.m_IsSecureConnection,   // is client conx secure ?
                                                        &context.m_encryptCtx           // client ssl ctx
                                                        ) ;
        }
        if( pIterator != 0 ) {
            pExecute = new( context )   CListNewsgroupsCmd( pIterator ) ;
            return 0 ;
        }
    }   else    if( argc >= 2 && lstrcmpi( argv[1], "prettynames" ) == 0 )     {

        if( argc == 3 ) {
            LPMULTISZ   multisz = BuildMultiszFromCommas( argv[2] ) ;
            pIterator = (context.m_pInstance)->GetTree()->GetIterator(  multisz,
                                                            context.m_IsSecureConnection,
                                                            FALSE,
                                                            &context.m_securityCtx,         // client security ctx
                                                            context.m_IsSecureConnection,   // is client conx secure ?
                                                            &context.m_encryptCtx           // client ssl ctx
                                                            ) ;
        }   else    {
            pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                        context.m_IsSecureConnection,   // include secure ?
                                                        &context.m_securityCtx,         // client security ctx
                                                        context.m_IsSecureConnection,   // is client conx secure ?
                                                        &context.m_encryptCtx           // client ssl ctx
                                                        ) ;
        }
        if( pIterator != 0 ) {
            pExecute = new( context )   CListPrettynamesCmd( pIterator ) ;
            return 0 ;
        }
    }   else    if( argc == 2 && lstrcmpi( argv[1], "distributions" ) == 0 )    {
        context.m_return.fSet( nrcServerFault ) ;
        pExecute = new( context )   CErrorCmd( context.m_return ) ;
        return 0 ;
        } else  if (argc >= 2 && lstrcmpi(argv[1], "searchable") == 0) {
                pIterator = (context.m_pInstance)->GetTree()->ActiveGroups(
                                                        context.m_IsSecureConnection,   // include secure ?
                                                        &context.m_securityCtx,         // client security ctx
                                                        context.m_IsSecureConnection,   // is client conx secure ?
                                                        &context.m_encryptCtx           // client ssl ctx
                                                        ) ;
        if( pIterator != 0 ) {
            pExecute = new( context )   CListSearchableCmd( pIterator ) ;
            return 0 ;
        }
    }   else    {
        // NYI Implented
        context.m_return.fSet( nrcSyntaxError ) ;
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }
    context.m_return.fSet( nrcServerFault ) ;
    pExecute = new( context ) CErrorCmd( context.m_return ) ;
    return 0 ;
}

CListCmd::CListCmd( CGroupIterator *p ) :
    m_pIterator( p ) {
}

CListNewsgroupsCmd::CListNewsgroupsCmd( CGroupIterator  *p ) :
    CListCmd( p ) {
}

CListPrettynamesCmd::CListPrettynamesCmd( CGroupIterator  *p ) :
    CListCmd( p ) {
}

CListSearchableCmd::CListSearchableCmd( CGroupIterator  *p ) :
    CListCmd( p ) {
}

CListCmd::~CListCmd( ) {
    delete  m_pIterator ;
}

int
CListCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL &fComplete,
                        void *&pv,
                        ClientContext& context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CListCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  Just print the initial 'more data follows' message and then move on.
    //

    static  char    szStart[] = "215 list of newsgroups follow\r\n"  ;

    context.m_nrcLast = nrcListGroupsFollows ;

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;

    if( cb < sizeof( szStart ) ) {
        // _ASSERT( 1==0 ) ;
        return  0 ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szStart, 4 ) ;
    }
    */

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    return  sizeof( szStart ) - 1 ;
}


int
CListCmd::PartialExecute(   BYTE *lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector )  {
/*++

Routine Description :

    For each newsgroup the iterator provides us print a string describing the newsgroup.
    Note that CListCmd::make will provide the iterator with any pattern matching strings
    required.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   Client's current context (we don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  For each newsgroup the iterator provides print some information into the
    //  supplied buffer until it is full.
    //


    int cbRtn = 0 ;

    fComplete = FALSE ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;
                _ASSERT(p != NULL);

                if (p != NULL) {
                if( cb - cbRtn > 5 ) {
                    //  bugbug ... When security work is completed the last chacater should be
                    //  something reasonable instead of always 'y'.
                    int cbTemp = _snprintf( (char*) lpb + cbRtn, cb-cbRtn, "%s %d %d %c\r\n",
                            p->GetNativeName(),
                            p->GetLastArticle(),
                            p->GetFirstArticle(),
                            p->GetListCharacter() ) ;
                    if( cbTemp < 0 ) {
                        return  cbRtn ;
                    }   else    {
                        cbRtn += cbTemp ;
                    }
                } else  {
                    return  cbRtn ;
                }
                }
        m_pIterator->Next() ;
    }
    if( cb - cbRtn > 3 )    {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    return  cbRtn ;
}

int
CListNewsgroupsCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL &fComplete,
                        void *&pv,
                        ClientContext& context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CListCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  Just print the initial 'more data follows' message and then move on.
    //

    static  char    szStart[] = "215 descriptions follow\r\n"  ;

    context.m_nrcLast = nrcListGroupsFollows ;

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;

    if( cb < sizeof( szStart ) ) {
        // _ASSERT( 1==0 ) ;
        return  0 ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szStart, 4 ) ;
    }
    */

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    return  sizeof( szStart ) - 1 ;
}


int
CListNewsgroupsCmd::PartialExecute(   BYTE *lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector )  {
/*++

Routine Description :

    For each newsgroup the iterator provides us print a string describing the newsgroup.
    Note that CListCmd::make will provide the iterator with any pattern matching strings
    required.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   Client's current context (we don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  For each newsgroup the iterator provides print some information into the
    //  supplied buffer until it is full.
    //


    int cbRtn = 0 ;

    fComplete = FALSE ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;

                _ASSERT(p != NULL);
                if (p != NULL) {
                if( cb - cbRtn > 5 ) {

                    LPCSTR   lpstrName = p->GetNativeName() ;
                    int     cbTemp = lstrlen( lpstrName ) ;
                    int     cbTemp2 = 0 ;
                    if( cbTemp+2 < (cb-cbRtn) ) {
                        CopyMemory( lpb+cbRtn, lpstrName, cbTemp ) ;
                        lpb[cbRtn+cbTemp] = ' ' ;

                        cbTemp2 = p->CopyHelpText( (char*)lpb+cbRtn+cbTemp+1, cb - (cbRtn + cbTemp+2) ) ;
                        if( cbTemp2 == 0 ) {
                            return  cbRtn ;
                        }
                    }   else    {
                        return  cbRtn ;
                    }

                    cbRtn += cbTemp + cbTemp2 + 1  ;
                } else  {
                    return  cbRtn ;
                }
                }
        m_pIterator->Next() ;
    }
    if( cb - cbRtn > 3 )    {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    return  cbRtn ;
}

int
CListPrettynamesCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL &fComplete,
                        void *&pv,
                        ClientContext& context,
                        CLogCollector*  pCollector ) {
/*++

Routine Description :

    Print the initial response string only into the provided buffer.
    CListCmd::PartialExecute will generate the bulk of the text.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  Just print the initial 'more data follows' message and then move on.
    //

    static  char    szStart[] = "215 prettynames for newsgroups\r\n"  ;

    context.m_nrcLast = nrcListGroupsFollows ;

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;

    if( cb < sizeof( szStart ) ) {
        // _ASSERT( 1==0 ) ;
        return  0 ;
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szStart, 4 ) ;
    }
    */

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    return  sizeof( szStart ) - 1 ;
}

int
CListPrettynamesCmd::PartialExecute(   BYTE *lpb,
                            int cb,
                            BOOL &fComplete,
                            void *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector )  {
/*++

Routine Description :

    For each newsgroup the iterator provides us, print the newsgroup prettyname (an addon).
    Note that CListCmd::make will provide the iterator with any pattern matching strings
    required.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   Client's current context (we don't use it.)

Returns Value  :

    Number of bytes placed in buffer - 0 if error occurs.

--*/


    //
    //  For each newsgroup the iterator provides print some information into the
    //  supplied buffer until it is full.
    //


    int cbRtn = 0 ;

    fComplete = FALSE ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;

                _ASSERT(p != NULL);
                if (p != NULL) {
                if( cb - cbRtn > 5 ) {

                    LPCSTR   lpstrName = p->GetNativeName() ;
                    int     cbTemp = lstrlen( lpstrName ) ;
                    int     cbTemp2 = 0 ;
                    if( cbTemp+2 < (cb-cbRtn) ) {
                        CopyMemory( lpb+cbRtn, lpstrName, cbTemp ) ;
                        lpb[cbRtn+cbTemp] = '\t' ;      // TAB delim

                        cbTemp2 = p->CopyPrettyname( (char*)lpb+cbRtn+cbTemp+1, cb - (cbRtn + cbTemp+2) ) ;
                        if( cbTemp2 == 0 ) {
                                return cbRtn ;
                        }
                    }   else    {
                        return  cbRtn ;
                    }

                    cbRtn += cbTemp + cbTemp2 + 1  ;
                } else  {
                    return  cbRtn ;
                }
                }
        m_pIterator->Next() ;
    }
    if( cb - cbRtn > 3 )    {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    return  cbRtn ;
}

int CListSearchableCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{
    TraceFunctEnter("CListSearchableCmd::StartExecute");

    DWORD cbOut;
    char szList[] = "224 Data Follows\r\n"; //* US-ASCII\r\n.\r\n";

    context.m_nrcLast = nrcXoverFollows ;

    _ASSERT(lpb != 0);
    _ASSERT(cb != 0);
    _ASSERT(fComplete == FALSE);

    _ASSERT(cb > sizeof(szList));
    CopyMemory( (char*)lpb, szList, sizeof(szList)-1);
    cbOut = sizeof(szList) - 1;

    fComplete = FALSE;

    return cbOut;
}

int
CListSearchableCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("CListSearchableCmd::PartialExecute");

    //
    //  For each newsgroup the iterator provides print some information into the
    //  supplied buffer until it is full.
    //


    int cbRtn = 0 ;

    fComplete = FALSE ;

    while( !m_pIterator->IsEnd() ) {
        CGRPPTR p = m_pIterator->Current() ;

                _ASSERT(p != NULL);

                if (p != NULL) {
                        //
                        //      LIST SEARCHABLE returns all newsgroups whose content is indexed
                        //      - this is derived from the MD_IS_CONTENT_INDEXED vroot property.
                        //
                        if( p->IsContentIndexed() ) {
                        if( cb - cbRtn > 5 ) {
                        int cbTemp = _snprintf( (char*) lpb + cbRtn, cb-cbRtn, "%s\r\n",
                                    p->GetNativeName() ) ;
                            if( cbTemp < 0 ) {
                            return  cbRtn ;
                            }   else    {
                            cbRtn += cbTemp ;
                            }
                    } else  {
                            return  cbRtn ;
                        }
                }
                }
            m_pIterator->Next() ;
    }
    if( cb - cbRtn > 3 )    {
        CopyMemory( lpb+cbRtn, ".\r\n", sizeof( ".\r\n" ) ) ;
        cbRtn += 3 ;
        fComplete = TRUE ;
    }
    return  cbRtn ;
}

CIOExecute*
CListExtensionsCmd::make( int argc,
                char**  argv,
                CExecutableCommand*&  pExecute,
                ClientContext&  context,
                class   CIODriver&  driver  )   {
/*++

Routine Description :

    Create a CListExtensionsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CListExtensionsCmd object.

--*/


    //
    //  Create a CListExtensionsCmd object
    //

    _ASSERT( pExecute == 0 ) ;

    CListExtensionsCmd *pReturn = new( context ) CListExtensionsCmd() ;
    pExecute = pReturn ;
    return  0 ;
}

char CListExtensionsCmd::szExtensions[] =
        "202 Extensions supported:\r\n"
        " OVER\r\n"
        " SRCH\r\n"
        " PAT\r\n"
//      " PATTEXT\r\n"
//      " LISTGROUP\r\n"
//      " AUTHINFO\r\n"
//      " AUTHINFO-GENERIC\r\n"
        ".\r\n" ;


CListExtensionsCmd::CListExtensionsCmd() : m_cbTotal( sizeof( szExtensions )-1 ) {
}


int
CListExtensionsCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pLogCollector ) {
/*++

Routine Description :

    Send the list extensions text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT(    pv == 0 ) ;
    _ASSERT( m_cbTotal != 0 ) ;
    _ASSERT( m_cbTotal == sizeof( szExtensions )-1 ) ;

    //
    //  Send the extension list text to the client.
    //  Because there may be a lot of text, we will use the provided void*& pv argument
    //  to save our position in case PartialExecute needs to be called.
    //

        context.m_nrcLast =     nrcExtensionsFollow;

        pv = szExtensions;

    DWORD   cbToCopy = min( cb, m_cbTotal ) ;
    CopyMemory( lpb, pv, cbToCopy ) ;
    pv = ((BYTE*)pv + cbToCopy ) ;
    if( cbToCopy != (DWORD)m_cbTotal ) {
        fComplete = FALSE ;
    }   else    {
        fComplete = TRUE ;
    }
    m_cbTotal -= cbToCopy ;

    /*
    if( pLogCollector ) {
        pLogCollector->FillLogData( LOG_TARGET, (BYTE*)szExtensions, 4 ) ;
    }
    */

    return  cbToCopy ;
}


int
CListExtensionsCmd::PartialExecute(   BYTE    *lpb,
                            int cb,
                            BOOL    &fComplete,
                            void    *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Send the rest of the list extensions text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/


    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT( pv != 0 ) ;
    _ASSERT( m_cbTotal != 0 ) ;

    //
    //  Copy extension list text into buffer untill the buffer is full!
    //

    DWORD   cbToCopy = min( cb, m_cbTotal ) ;
    CopyMemory( lpb, pv, cbToCopy ) ;
    pv = ((BYTE*)pv + cbToCopy ) ;
    if( cbToCopy != (DWORD)m_cbTotal ) {
        fComplete = FALSE ;
    }   else    {
        fComplete = TRUE ;
    }
    m_cbTotal -= cbToCopy ;
    return  cbToCopy ;
}

CIOExecute*
CHelpCmd::make( int argc,
                char**  argv,
                CExecutableCommand*&  pExecute,
                ClientContext&  context,
                class   CIODriver&  driver  )   {
/*++

Routine Description :

    Create a CHelpCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CHelpCmd object.

--*/


    //
    //  Create a CHelpCmd object
    //

    _ASSERT( lstrcmpi( argv[0], "help" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), HelpCommands );

    CHelpCmd*   pReturn = new( context )    CHelpCmd() ;
    pExecute = pReturn ;
    return  0 ;
}

char    CHelpCmd::szHelp[] =    "100 Legal commands are : \r\n"
                                "article [MessageID|Number] \r\n"
                                "authinfo [user|pass|generic|transact] <data> \r\n"
                                "body [MessageID|Number]\r\n"
                                "check <message-id>\r\n"
                                "date\r\n"
                                "group newsgroup\r\n"
                                "head [MessageID|Number]\r\n"
                                "help \r\n"
                                "ihave <message-id>\r\n"
                                "last\r\n"
                                "list [active|newsgroups[wildmat]|srchfields|searchable|prettynames[wildmat]]\r\n"
                                "listgroup [newsgroup]\r\n"
                                "mode stream|reader\r\n"
                                "newgroups yymmdd hhmmss [\"GMT\"] [<distributions>]\r\n"
                                "newnews wildmat yymmdd hhmmss [\"GMT\"] [<distributions>]\r\n"
                                "next\r\n"
                                "post\r\n"
                                "quit\r\n"
                                "search\r\n"
//                                "slave\r\n"
                                "stat [MessageID|number]\r\n"
                                "xhdr header [range|MessageID]\r\n"
                                "xover [range]\r\n"
                                "xpat header range|MessageID pat [morepat ...]\r\n"
                                "xreplic newsgroup/message-number[,newsgroup/message-number...]\r\n"
                                "takethis <message-id>\r\n"
                                ".\r\n" ;


CHelpCmd::CHelpCmd() : m_cbTotal( sizeof( szHelp )-1 ) {
}


int
CHelpCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pLogCollector ) {
/*++

Routine Description :

    Send the help text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT(    pv == 0 ) ;
    _ASSERT( m_cbTotal != 0 ) ;
    _ASSERT( m_cbTotal == sizeof( szHelp )-1 ) ;

    //
    //  Send the Help Text to the client.
    //  Because there may be a lot of text, we will use the provided void*& pv argument
    //  to save our position in case PartialExecute needs to be called.
    //

    context.m_nrcLast = nrcHelpFollows ;

    pv = szHelp ;

    DWORD   cbToCopy = min( cb, m_cbTotal ) ;
    CopyMemory( lpb, pv, cbToCopy ) ;
    pv = ((BYTE*)pv + cbToCopy ) ;
    if( cbToCopy != (DWORD)m_cbTotal ) {
        fComplete = FALSE ;
    }   else    {
        fComplete = TRUE ;
    }
    m_cbTotal -= cbToCopy ;

    /*
    if( pLogCollector ) {
        pLogCollector->FillLogData( LOG_TARGET, (BYTE*)szHelp, 4 ) ;
    }
    */

    return  cbToCopy ;
}


int
CHelpCmd::PartialExecute(   BYTE    *lpb,
                            int cb,
                            BOOL    &fComplete,
                            void    *&pv,
                            ClientContext& context,
                            CLogCollector*  pCollector ) {
/*++

Routine Description :

    Send the rest of the help text to the client.

Arguments :

    Same as CErrorCmd::StartExecute.

Returns :

    Number of bytes placed in buffer.

--*/


    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( fComplete == FALSE ) ;
    _ASSERT( pv != 0 ) ;
    _ASSERT( m_cbTotal != 0 ) ;

    //
    //  Copy HelpText into buffer untill the buffer is full!
    //

    DWORD   cbToCopy = min( cb, m_cbTotal ) ;
    CopyMemory( lpb, pv, cbToCopy ) ;
    pv = ((BYTE*)pv + cbToCopy ) ;
    if( cbToCopy != (DWORD)m_cbTotal ) {
        fComplete = FALSE ;
    }   else    {
        fComplete = TRUE ;
    }
    m_cbTotal -= cbToCopy ;
    return  cbToCopy ;
}

CIOExecute*
CNextCmd::make( int argc,
                char**  argv,
                CExecutableCommand*&  pExecute,
                struct ClientContext&   context,
                class   CIODriver&  driver  )   {
/*++

Routine Description :

    Create a CNextCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNextCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/

    //
    //  Build a next command object.
    //  First make sure that this command is legal given the current ClientContext state.
    //

    _ASSERT( lstrcmpi( argv[0], "next" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), NextCommands );

    ARTICLEID   artidMax = INVALID_ARTICLEID ;

    if( context.m_pCurrentGroup == 0 )  {
        context.m_return.fSet( nrcNoGroupSelected ) ;
    }   else    if( context.m_idCurrentArticle == INVALID_ARTICLEID )   {
        context.m_return.fSet( nrcNoCurArticle ) ;
    }   else    if( context.m_idCurrentArticle >=
                (artidMax = context.m_pCurrentGroup->GetLastArticle()) ) {
        context.m_return.fSet( nrcNoNextArticle ) ;
    }   else    {
        _ASSERT( artidMax != INVALID_ARTICLEID ) ;
        pExecute = new( context ) CNextCmd( artidMax ) ;
        return  0 ;
    }

    pExecute = new( context )   CErrorCmd( context.m_return );
    return  0 ;
}

int
CNextCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector )    {
/*++

Routine Description :

    Search the XOVER table going forward from the client's current position untill
    we find an article.  Once thats done, send the article's info to the client
    and adjust the context.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state (selected group etc...)

Return Value :

    Number of bytes placed in buffer.

--*/
    int cbRtn = 0 ;

    _ASSERT( context.m_pCurrentGroup != 0 ) ;
    _ASSERT( context.m_idCurrentArticle != INVALID_ARTICLEID ) ;
    _ASSERT( context.m_idCurrentArticle <= context.m_pCurrentGroup->GetLastArticle() ) ;

    context.m_nrcLast = nrcHeadFollowsRequestBody ;

    BOOL    fPrimary ;  // Don't care !!
    FILETIME    filetime ;  // Don't care
    DWORD   cbRemaining = 0 ;
    DWORD   cbConsumed = 0 ;
    WORD    HeaderOffsetJunk ;
    WORD    HeaderLengthJunk ;

    ARTICLEID   artidTemp = context.m_idCurrentArticle ;

    if( artidTemp < context.m_pCurrentGroup->GetFirstArticle() ) {
        artidTemp = context.m_pCurrentGroup->GetFirstArticle()-1 ;
    }

    fComplete = TRUE ;

    static  char    szNextText[] = "223 " ;
    CopyMemory( lpb, szNextText, sizeof( szNextText )-1 ) ;

    do  {
        artidTemp++ ;

        _itoa( artidTemp, (char*)lpb + sizeof( szNextText ) - 1, 10 ) ;
        cbConsumed = lstrlen( (char*)lpb ) ;
        lpb[cbConsumed ++ ] = ' ' ;
        cbRemaining = cb - cbConsumed ;

                DWORD cStoreIds = 0;
        if( (context.m_pInstance)->XoverTable()->ExtractNovEntryInfo(
                                            context.m_pCurrentGroup->GetGroupId(),
                                            artidTemp,
                                            fPrimary,
                                            HeaderOffsetJunk,
                                            HeaderLengthJunk,
                                            &filetime,
                                            cbRemaining,
                                            (char*)lpb + cbConsumed,
                                                                                        cStoreIds,
                                                                                        NULL,
                                                                                        NULL) ) {
            //
            //  Change the current Article position.
            //  Send the Command succeeded response.
            //

            context.m_idCurrentArticle = artidTemp ;
            cbRtn = cbConsumed + cbRemaining ;
            _ASSERT( cbRtn + 2 <= cb ) ;
            lpb[cbRtn++] = '\r' ;
            lpb[cbRtn++] = '\n' ;

            /*
            if( pCollector )    {
                pCollector->FillLogData( LOG_TARGET, lpb, cbRtn - 2 ) ;
            }
            */
            return  cbRtn ;

        }   else    {
            _ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ;
        }
    }   while( artidTemp <= m_artidMax ) ;

    static  char    szNoNext[] = "421 No next to retrieve\r\n" ;

    context.m_nrcLast = nrcNoNextArticle ;

    cbRtn = sizeof( szNoNext ) - 1 ;
    CopyMemory( lpb, szNoNext, cbRtn ) ;

    /*
    if( pCollector )    {
        pCollector->FillLogData( LOG_TARGET, lpb, cbRtn - 2 ) ;
    }
    */

    return  cbRtn ;
}

int
CNextCmd::PartialExecute(   BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void *&pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {
    //
    //  StartExecute should always be sufficient !!
    //
    _ASSERT( 1==0 ) ;
    return 0 ;
}

CIOExecute*
CLastCmd::make( int argc,
                char**  argv,
                CExecutableCommand*&  pExecute,
                ClientContext&  context,
                class   CIODriver&  driver  )   {
/*++

Routine Description :

    Create a CNewnewsCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CNewnewsCmd object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/


    //
    //  Determine whether the client can legally execute the last command and if so
    //  create a CLastCmd object.
    //
    //

    _ASSERT( lstrcmpi( argv[0], "last" ) == 0 ) ;
    _ASSERT( pExecute == 0 ) ;

    ARTICLEID   artidMin = INVALID_ARTICLEID ;

    InterlockedIncrementStat( (context.m_pInstance), LastCommands );

    if( context.m_pCurrentGroup == 0 )  {
        context.m_return.fSet( nrcNoGroupSelected ) ;
    }   else    if( context.m_idCurrentArticle == INVALID_ARTICLEID )   {
        context.m_return.fSet( nrcNoCurArticle ) ;
    }   else    if( context.m_idCurrentArticle <=
                (artidMin = context.m_pCurrentGroup->GetFirstArticle()) ) {
        context.m_return.fSet( nrcNoPrevArticle ) ;
    }   else    {
        _ASSERT( artidMin != INVALID_ARTICLEID ) ;
        pExecute = new( context )   CLastCmd( artidMin ) ;
        return  0 ;
    }
    _ASSERT( !context.m_return.fIsClear() ) ;
    pExecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

int
CLastCmd::StartExecute( BYTE *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void*&pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector )    {
/*++

Routine Description :

    Search the XOVER table going Backwards from the client's current position untill
    we find an article.  Once thats done, send the article's info to the client
    and adjust the context.

Arguments :

    lpb -   The buffer into which the string is to be stored.
    cb  -   The number of bytes in the buffer we can use
    fComplete - An OUT parameter which lets us indicate whether we have completed
                processing the command.
    pv -    A place for us to store an arbitrary value between calls to
            StartExecute and PartialExecute.  (We don't use it.)
    context -   The client's current state (selected group etc...)

Return Value :

    Number of bytes placed in buffer.

--*/


    int cbRtn = 0 ;

    _ASSERT( context.m_pCurrentGroup != 0 ) ;
    _ASSERT( context.m_idCurrentArticle != INVALID_ARTICLEID ) ;
    _ASSERT( context.m_idCurrentArticle >= m_artidMin ) ;

    ARTICLEID   artidTemp = context.m_idCurrentArticle ;

    BOOL    fPrimary ;  // Don't care !!
    FILETIME    filetime ;  // Don't care
    DWORD   cbRemaining = 0 ;
    DWORD   cbConsumed = 0 ;
    WORD    HeaderOffsetJunk ;
    WORD    HeaderLengthJunk ;

    fComplete = TRUE ;

    context.m_nrcLast = nrcHeadFollowsRequestBody ;

    static  char    szLastText[] = "223 " ;
    CopyMemory( lpb, szLastText, sizeof( szLastText ) ) ;

    do  {
        artidTemp -- ;

        _itoa( artidTemp, (char*)lpb + sizeof( szLastText ) - 1, 10 ) ;
        cbConsumed = lstrlen( (char*)lpb ) ;
        lpb[cbConsumed ++ ] = ' ' ;
        cbRemaining = cb - cbConsumed ;

                DWORD cStoreIds = 0;
        if( (context.m_pInstance)->XoverTable()->ExtractNovEntryInfo(
                                                context.m_pCurrentGroup->GetGroupId(),
                                                artidTemp,
                                                fPrimary,
                                                HeaderOffsetJunk,
                                                HeaderLengthJunk,
                                                &filetime,
                                                cbRemaining,
                                                (char*)lpb + cbConsumed,
                                                                                                cStoreIds,
                                                                                                NULL,
                                                                                                NULL) ) {

            //
            //  Change the current article pointer and then send the success response !
            //

            context.m_idCurrentArticle = artidTemp ;

            cbRtn = cbConsumed + cbRemaining ;
            _ASSERT( cbRtn + 2 <= cb ) ;
            lpb[cbRtn++] = '\r' ;
            lpb[cbRtn++] = '\n' ;

            /*
            if( pCollector )    {
                pCollector->FillLogData( LOG_TARGET, lpb, cbRtn - 2 ) ;
            }
            */
            return  cbRtn ;

        }   else    {
            _ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ;
        }
    }   while( artidTemp >= m_artidMin ) ;

    context.m_nrcLast = nrcNoPrevArticle ;

    static  char    szNoNext[] = "422 No previous article to retrieve\r\n" ;
    cbRtn = sizeof( szNoNext ) - 1 ;
    CopyMemory( lpb, szNoNext, cbRtn ) ;

    /*
    if( pCollector )    {
        pCollector->FillLogData( LOG_TARGET, lpb, cbRtn - 2 ) ;
    }
    */

    return  cbRtn ;

}

int
CLastCmd::PartialExecute(   BYTE    *lpb,
                            int cb,
                            BOOL&   fComplete,
                            void *&pv,
                            ClientContext&  context,
                            CLogCollector*  pCollector ) {
    _ASSERT( 1==0 ) ;
    return 0 ;
}

LPMULTISZ
ConditionArgs(  int cArgs,
                char**  argv,
                BOOL    fZapCommas ) {
/*++

Routine Description :

    Convert argc, argv arguments into a MULTI_SZ
    The cnversion is done in place.   All argv pointers must be in a contiguous buffer.

Arguemtns :

    cArgs - Number of arguments
    argv -  Argument array
    fZapCommas - convert commas to NULLS

Return Value :

    Pointer to MULTI_SZ

--*/

    //
    //  This function takes an argc,argv set of arguments and converts them
    //  to a MULTI_SZ with a single NULL between strings and 2 NULLs at the end.
    //
    //

    char*   pchComma = 0 ;
    char*   pchEnd = argv[cArgs-1] + lstrlen( argv[cArgs-1] ) + 1 ;
    int     c = 0 ;
    for( char*  pch = argv[0], *pchDest = pch; pch < pchEnd; pch ++, pchDest++ ) {
        if( fZapCommas && *pch == ',' ) {
            for( pchComma = pch; *pchComma == ','; pchComma ++ )
                *pchComma = '\0' ;
        }
        if( (*pchDest = *pch) == '\0' ) {
#if 0
            if( ++c == cArgs ) {
                break ;
            }   else    {
                while( pch[1] == '\0' ) pch++ ;
            }
#endif
            while( pch[1] == '\0' && pch < pchEnd )     pch++ ;
        }
    }
    *pchDest++ = '\0' ;
//  *pchDest++ = '\0' ;

    //
    //  Verify that it is double NULL terminated !
    //
    _ASSERT( pchDest[-3] != '\0' ) ;
    _ASSERT( pchDest[-2] == '\0' ) ;
    _ASSERT( pchDest[-1] == '\0' ) ;

    return  argv[0] ;
}

BOOL
FValidateXreplicArgs(   PNNTP_SERVER_INSTANCE pInstance, LPMULTISZ   multisz )   {

    LPSTR   lpstr = multisz ;
    CNewsTree* pTree = pInstance->GetTree();
    while( *lpstr ) {

        //
        //  appears from RFC's that ':' may separate arguments as well as '/''s.
        //
        char*   pchColon = strchr( lpstr, '/' ) ;
        if( pchColon == 0 )
            pchColon = strchr( lpstr, ':' ) ;

        if( pchColon == 0 )
            return  FALSE ;
        else    {
            int i=1 ;
            while( pchColon[i] != '\0' ) {
                if( !isdigit( pchColon[i] ) ) {
                    return  FALSE ;
                }
                i++ ;
            }
            if( i==1 )
                return  FALSE ;
        }

        *pchColon = '\0' ;
        if( !fTestComponents( lpstr ) ) {
            *pchColon = ':' ;
            return  FALSE ;
        } else {
            //
            //  CreateGroup will create this group if it does not exist
            //
            //  BUGBUG: KangYan: don't know what this function is used for,
            //  Whether we should pass NULL / FALSE to give system access rights
            //  or extract htoken / fAnonymous from pInstance
                if( pTree->CreateGroup( lpstr, FALSE, NULL, FALSE ) )   {
#ifdef DEBUG
                                CGRPPTR p = pTree->GetGroupPreserveBuffer(lpstr, lstrlen(lpstr) + 1);
                                _ASSERT(p != NULL);
#endif
                    }
        }
        *pchColon = ':' ;

        lpstr += lstrlen( lpstr ) + 1 ;
    }
    return  TRUE ;
}

CIOExecute*
CXReplicCmd::make(  int cArgs,
                    char**  argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CXReplicCmd object.    CXReplicCmd derives from CReceiveArticle
    which does most of the work.

Arguments :

    Same as CCmd::make.

Return Value :

    A CXReplicCmd if possible, otherwise an appropriate CErrorCmd object.

--*/

    InterlockedIncrementStat( (context.m_pInstance), XReplicCommands );

    //
    //  This function will build a CXReplic command object.
    //  We will use ConditionArgs() to convert the user provided arguments
    //  into something a feed object can take.
    //

    if( cArgs == 1 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
    }   else    if( !context.m_pInFeed->fIsXReplicLegal() )     {
        context.m_return.fSet( nrcNoAccess ) ;
                context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) )  {
        context.m_return.fSet( nrcPostingNotAllowed ) ;
                context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {
        LPMULTISZ   lpstrArgs = ::ConditionArgs( cArgs-1, &argv[1], TRUE ) ;
        if( lpstrArgs == 0 ) {
            context.m_return.fSet( nrcServerFault ) ;
        }

        if( !FValidateXreplicArgs( context.m_pInstance, lpstrArgs ) ) {
            context.m_return.fSet( nrcTransferFailedGiveUp, nrcSyntaxError, "Illegal Xreplic Line" ) ;
        }   else    {
            CXReplicCmd*    pXReplic = new CXReplicCmd( lpstrArgs ) ;

            //
            //  NOTE : if the Init call fails it will delete the CXReplicCmd object
            //  itself !
            //

            if( pXReplic && pXReplic->Init( context, driver ) ) {
                return  pXReplic ;
            }   else    {
                context.m_return.fSet( nrcServerFault ) ;
            }
        }
    }
        context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
    pExecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

CXReplicCmd::CXReplicCmd( LPMULTISZ lpstrArgs ) : CReceiveArticle( lpstrArgs) {
}

char*
CXReplicCmd::GetPostOkString()  {
    //
    //  Return the 'command succeeded send more data' string appropriate to the XREPLIC cmd.
    //
    return  "335 - XReplic accepted - terminate article with period\r\n" ;
}

DWORD
CXReplicCmd::FillLogString( BYTE*   pbCommandLog,   DWORD   cbCommandLog )  {

    _ASSERT( pbCommandLog != 0 ) ;
    _ASSERT( cbCommandLog > 0 ) ;

    static  char    szXreplic[] = "xreplic" ;
    DWORD   cbToCopy = (DWORD)min( cbCommandLog, sizeof( szXreplic )-1 ) ;
    CopyMemory( pbCommandLog, szXreplic, cbToCopy ) ;
    return  cbToCopy ;
}


CIOExecute*
CIHaveCmd::make(    int cArgs,
                    char**  argv,
                    CExecutableCommand*&  pExecute,
                    ClientContext&  context,
                    class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CXReplicCmd object.    CXReplicCmd derives from CReceiveArticle
    which does most of the work.

Arguments :

    Same as CCmd::make.

Return Value :

    A CXReplicCmd if possible, otherwise an appropriate CErrorCmd object.

--*/

    //
    //  This function will build a CXReplic command object.
    //  We will use ConditionArgs() to convert the user provided arguments
    //  into something a feed object can take.
    //

    BOOL    fFoundArticle = FALSE ;
        BOOL    fFoundHistory = FALSE ;

    InterlockedIncrementStat( (context.m_pInstance), IHaveCommands );

    if( cArgs != 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
    }   else    if( !context.m_pInFeed->fIsIHaveLegal() )   {
        context.m_return.fSet( nrcNoAccess ) ;
                context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) )  {
        context.m_return.fSet( nrcPostingNotAllowed ) ;
                context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {

        //if( *argv[1] != '<' || argv[1][ lstrlen( argv[1] ) - 1 ] != '>' ) {
        if( !FValidateMessageId( argv[1] ) ) {

            context.m_return.fSet( nrcNotWanted ) ;

        }   else    {
            ARTICLEID   artid ;
            GROUPID     groupid ;
            WORD        HeaderOffset ;
            WORD        HeaderLength ;
                        CStoreId storeid;

            if( !(fFoundArticle =
                    (context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                            argv[1],
                                                            HeaderOffset,
                                                            HeaderLength,
                                                            artid,
                                                            groupid,
                                                                                                                        storeid)) &&
                GetLastError() == ERROR_FILE_NOT_FOUND &&
                !(fFoundHistory = (context.m_pInstance)->HistoryTable()->SearchMapEntry( argv[1] )) ) {

                LPMULTISZ   lpstrArgs = ::ConditionArgs( cArgs-1, &argv[1] ) ;
                if( lpstrArgs == 0 ) {
                    context.m_return.fSet( nrcServerFault ) ;
                }

                CIHaveCmd*  pIHave = new CIHaveCmd( lpstrArgs ) ;

                //
                //  Note : if the Init() call fails the object will delete itself !
                //

                if( pIHave && pIHave->Init( context, driver ) ) {
                    return  pIHave ;
                }   else    {
                    context.m_return.fSet( nrcServerFault ) ;
                }
            }   else if( fFoundArticle || fFoundHistory )   {

                                //
                                //      set dwLast so transaction logs pickup extra code !!
                                //

                                if( fFoundArticle ) {
                                        context.m_dwLast = nrcMsgIDInArticle ;
                                }       else    {
                                        context.m_dwLast = nrcMsgIDInHistory ;
                                }

                context.m_return.fSet( nrcNotWanted ) ;

            }   else    {

                context.m_return.fSet( nrcServerFault ) ;

            }
        }
    }
        context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
    pExecute = new( context )   CErrorCmd( context.m_return ) ;
    return  0 ;
}

CIHaveCmd::CIHaveCmd( LPMULTISZ lpstrArgs ) : CReceiveArticle( lpstrArgs) {
}

char*
CIHaveCmd::GetPostOkString()    {
    //
    //  Return the 'command succeeded send more data' string appropriate to the XREPLIC cmd.
    //
    return  "335 - Ihave accepted - terminate article with period\r\n" ;
}

DWORD
CIHaveCmd::FillLogString( BYTE* pbCommandLog,   DWORD   cbCommandLog )  {

    _ASSERT( pbCommandLog != 0 ) ;
    _ASSERT( cbCommandLog > 0 ) ;

    static  char    szIhave[] = "ihave" ;
    DWORD   cbToCopy = (DWORD)min( cbCommandLog, sizeof( szIhave )-1 ) ;
    CopyMemory( pbCommandLog, szIhave, cbToCopy ) ;
    return  cbToCopy ;
}

NRC
CIHaveCmd::ExceedsSoftLimit( PNNTP_SERVER_INSTANCE pInstance )  {

    if( m_lpstrCommand ) {
        FILETIME    FileTime ;
        GetSystemTimeAsFileTime( &FileTime ) ;
        pInstance->HistoryTable()->InsertMapEntry(m_lpstrCommand, &FileTime) ;
    }
    return  nrcTransferFailedGiveUp ;
}




CIOExecute*
CPostCmd::make( int cArgs,
                char**  argv,
                CExecutableCommand*&  pExecute,
                ClientContext&  context,
                class   CIODriver&  driver ) {
/*++

Routine Description :

    Create a CPostCmd object.   CPostCmd derives from CReceiveArticle which does most
    of the work.

Arguments :

    Same as CCmd::make.

Return Value :

    A CPostCmd  object if possible, otherwise a CErrorCmd object that will
    print the appropriate error.

--*/

    InterlockedIncrementStat( (context.m_pInstance), PostCommands );

    //
    //  Build a CPostCmd object.
    //

    if( cArgs > 1 ) {
        pExecute = new( context ) CUnimpCmd() ;
                context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), nrcPostFailed);
        return  0 ;
    }   else    if( !context.m_pInFeed->fIsPostLegal() )    {
        context.m_return.fSet( nrcNoAccess ) ;
                context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) )  {
        context.m_return.fSet( nrcPostingNotAllowed ) ;
                context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }   else    {

        CPostCmd*   pPost = new CPostCmd( 0 ) ;

        if( pPost && pPost->Init(   context, driver ) )     {
            return  pPost ;
        }   else    {

            // CPostCmd destroys iteself if Init() fails ... so just send error!

            context.m_return.fSet( nrcServerFault ) ;
                        context.m_pInFeed->IncrementFeedCounter(context.m_pInstance->GetInstanceWrapper(), context.m_return.m_nrc);
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0 ;
        }
    }
        // we shouldn't reach this... all cases are handled above
        _ASSERT(FALSE);
    return  0 ;
}

char*
CPostCmd::GetPostOkString() {
    return  "340 Continue posting - terminate with period \r\n" ;
}

DWORD
CPostCmd::FillLogString( BYTE*  pbCommandLog,   DWORD   cbCommandLog )  {

    _ASSERT( pbCommandLog != 0 ) ;
    _ASSERT( cbCommandLog > 0 ) ;

    static  char    szPost[] = "post" ;
    DWORD   cbToCopy = (DWORD)min( cbCommandLog, sizeof( szPost )-1 ) ;
    CopyMemory( pbCommandLog, szPost, cbToCopy ) ;
    return  cbToCopy ;
}



CReceiveArticle::CReceiveArticle( LPMULTISZ lpstrArgs, BOOL fPartial ) :
    m_fReadArticleInit( FALSE ),
    m_pWriteResponse( 0 ),
    m_cCompleted( -3 ),     // We issue 3 CIO operations - this value is interlocked incremented
                            // and when the final CIO completes (InterlockedIncrement returns 0)
                            // we can move onto the next state !
    m_cFirstSend( -2 ),
    m_pDriver( 0 ),
    m_fPartial( fPartial ),
    m_lpstrCommand( lpstrArgs ),
        m_lpvFeedContext( 0 ),
        m_pContext( 0 ) {

    TraceFunctEnter( "CReceiveArticle::CReceiveArticle" ) ;

    //
    //  This constructor sets all fields to illegal values except m_lpstrCommand and m_fPartial
    //  All other fields should be set up by a call to Init().
    //
}

void
CReceiveArticle::Shutdown(  CIODriver&  driver,
                            CSessionSocket* pSocket,
                            SHUTDOWN_CAUSE  cause,
                            DWORD           dwError ) {

    TraceFunctEnter( "CReceiveArticle::Shutdown" ) ;

    DebugTrace( (DWORD_PTR)this, "Shutdown cause %d pSocket %x driver %x",
        cause, pSocket, &driver ) ;

    if( cause != CAUSE_NORMAL_CIO_TERMINATION && !m_fReadArticleInit )  {

    }
    if( cause != CAUSE_NORMAL_CIO_TERMINATION && pSocket != 0 )
        pSocket->Disconnect( cause, dwError ) ;
}

CReceiveArticle::~CReceiveArticle() {
/*++

Routine Description :

        If we're shutting down and m_lpvFeedContext isn't NULL then
        some kind of fatal error occurred.  Anyways, we need to make
        sure this thing cleans up after itself !


Arguments :

        None.

Return Value :

        None.

--*/

        if( m_lpvFeedContext != 0 ) {
                _ASSERT( m_pContext != 0 ) ;
                DWORD   dwReturn ;
                CNntpReturn     nntpReturn ;
                m_pContext->m_pInFeed->PostCancel(
                                        m_lpvFeedContext,
                                        dwReturn,
                                        nntpReturn
                                        ) ;
        }
}

BOOL
CReceiveArticle::Init(  ClientContext&  context,
                        class   CIODriver&  driver ) {

    //
    //  Create necessary files etc... to place article into as it arrives !
    //

    TraceFunctEnter( "CReceiveArticle::Init" ) ;

    _ASSERT (m_pWriteResponse == NULL);

        m_pContext = &context ;
    m_pWriteResponse = new( driver ) CIOWriteLine( this ) ;

    if( m_pWriteResponse != 0 ) {
        return  TRUE ;
    }
    DebugTrace( (DWORD_PTR)this, "cleanup after error - m_pWriteResponse %x", m_pWriteResponse ) ;
    if( m_pWriteResponse != 0 ) {
        CIO::Destroy( m_pWriteResponse, driver ) ;
    }   else    {
        delete  this ;
    }
    return  FALSE ;
}

void
CReceiveArticle::TerminateIOs(  CSessionSocket* pSocket,
                            CIORead*    pRead,
                            CIOWrite*   pWrite )    {

    if( pWrite != 0 )
        pWrite->DestroySelf() ;

    CIOGetArticle*  pGetArticle = (CIOGetArticle*)pRead ;

    pGetArticle->DestroySelf() ;

}


BOOL
CReceiveArticle::StartExecute(
                                        CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite
                                        ) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //

        if( Start( pSocket, pdriver, pRead, pWrite ) )  {
                if( pWrite ) {
                        if( pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
                                return  TRUE ;
                        }       else    {
                                TerminateIOs( pSocket, pRead, pWrite ) ;
                                pRead = 0 ;
                        }
                }
        }
        return  FALSE ;
}


BOOL
CReceiveArticle::Start( CSessionSocket* pSocket,
                        CDRIVERPTR& pdriver,
                        CIORead*&   pRead,
                        CIOWrite*&  pWrite ) {

    //
    //  This function is required for all CSessionState derived objects -
    //  we provide the initial CIO's which are issued when this state is started.
    //
    //  In our case we will issue a CIOWriteLine containing our 'command ok send more data' string
    //  and a CIOReadArticle operation to get the anticipated article into a file.
    //

    TraceFunctEnter( "CReceiveArticle::Start" ) ;


    CIOGetArticleEx*  pReadArticle = NULL;
    if( m_pWriteResponse->InitBuffers( pdriver, 200 ) ) {

        char    *szPostOk = GetPostOkString() ;
        DWORD   cbPostOk  = lstrlen( szPostOk ) ;

        char*   lpb = m_pWriteResponse->GetBuff() ;
        CopyMemory( lpb, szPostOk, cbPostOk ) ;
        m_pWriteResponse->AddText( cbPostOk ) ;

        DebugTrace( (DWORD_PTR)this, "About to Init FileChannel - start CIOReadArticle !" ) ;

        PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
        pReadArticle = new( *pdriver ) CIOGetArticleEx( this,
                                            pSocket,
                                            pdriver,
                                            pSocket->m_context.m_pInFeed->cbHardLimit( pInst->GetInstanceWrapper() ),
                                                                                        szBodySeparator,
                                                                                        szBodySeparator,
                                                                                        szEndArticle,
                                                                                        (m_fPartial) ? szInitial : szEndArticle
                                                                                        ) ;
        if( pReadArticle != 0 ) {
            m_fReadArticleInit = TRUE ;
            pWrite = m_pWriteResponse ;
            pRead = pReadArticle ;
            m_pDriver = pdriver ;
            if( m_pCollector ) {
                ADDI( m_pCollector->m_cbBytesSent, cbPostOk );
            }
            return  TRUE ;
        }
    }
    DebugTrace( (DWORD_PTR)this, "Error starting state - clean up ! m_pWriteResponse %x"
                            " pReadArticle %x",
                m_pWriteResponse, pReadArticle ) ;
    if( m_pWriteResponse )  {
        CIO::Destroy( m_pWriteResponse, *pdriver ) ;
        m_pWriteResponse = 0 ;
    }
    if( pReadArticle ) {
        _ASSERT( !m_fReadArticleInit ) ;
        CIO::Destroy( pReadArticle, *pdriver ) ;
    }
    return  FALSE ;
}


BOOL
CReceiveArticle::SendResponse(  CSessionSocket* pSocket,
                                CIODriver&  driver,
                                CNntpReturn&    nntpReturn
                                )   {
/*++

Routine Description :

    This function exists to check whether it is a good time to send
    the result code of the post to the client.  Our main concern is to make
    sure that our initial 'Ok' response to the command has completed
    before we try do another send.

Arguments :

    pSocket - The socket on which we will send
    nntpReturn - The result of the post operation

Return Value :
    TRUE if we sent the response - caller should clear the nntpReturn object.


--*/

    TraceFunctEnter( "CReceiveArticle::SendResponse" ) ;

    long sign = InterlockedIncrement( &m_cFirstSend ) ;

    if( sign == 0 ) {

        CIOWriteLine    *pWrite = new( driver ) CIOWriteLine(this);
        if (pWrite == NULL) {
                        m_pDriver->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
                        return FALSE;
        }

        if( !pWrite->InitBuffers( m_pDriver, 200 )  )   {
                        m_pDriver->UnsafeClose( pSocket, CAUSE_OOM, 0 ) ;
                        CIO::Destroy(pWrite, driver);
                        return FALSE;
        }   else    {

            unsigned    cb ;
            char    *lpb = pWrite->GetBuff( cb ) ;

            int cbOut = _snprintf( lpb, cb, "%03d %s\r\n", nntpReturn.m_nrc,
                            nntpReturn.fIsOK() ? "" : nntpReturn.szReturn() ) ;
            if( cbOut > 0 ) {

                if( m_pCollector ) {
                    ADDI( m_pCollector->m_cbBytesSent, cbOut );
                    pSocket->TransactionLog( m_pCollector,
                                            pSocket->m_context.m_nrcLast,
                                            pSocket->m_context.m_dwLast
                                            ) ;
                }

                pWrite->AddText( cbOut ) ;
                if( !m_pDriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
                    ErrorTrace( (DWORD_PTR)(this), "Failure sending pWrite %x", pWrite ) ;
                    CIO::Destroy( pWrite, driver ) ;
                }

            }   else    {
                            m_pDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0 ) ;
                            CIO::Destroy(pWrite, driver);
                            return FALSE;
            }
        }
    }
    return  sign == 0 ;
}


CIO*
CReceiveArticle::Complete(  CIOWriteLine*,
                            CSessionSocket* pSocket,
                            CDRIVERPTR& pdriver
                                                        ) {

    //
    //  One of two CIOWriteLine's issued in this state completed -
    //  Interlock Increment and see whether its time to move onto a new state (CAcceptNNRPD)
    //


    TraceFunctEnter( "CReceiveArticle::Complete CIOWriteLine" ) ;

    if( SendResponse( pSocket, *pdriver, pSocket->m_context.m_return ) )
        pSocket->m_context.m_return.fSetClear() ;

    long    l = InterlockedIncrement( &m_cCompleted ) ;
    _ASSERT( l <= 0 ) ;
    if( l==0 ) {
        _ASSERT( pdriver == m_pDriver ) ;
        CIOREADPTR  pio = GetNextIO() ;

        DebugTrace( (DWORD_PTR)this, "won InterlockedIncrement - pio %x", pio ) ;

        if( !pdriver->SendReadIO( pSocket, *pio, TRUE ) ) {
            /*delete    pio */;
        }
    }
    return  0 ;
}

extern  DWORD
NetscapeHackFunction(
        LPBYTE      lpbBuffer,
        DWORD       cbBuffer,
        DWORD       cbBufferMax,
        DWORD&      cbNewHeader,
        LPBYTE      szHackString,
        BYTE        szRepairString[2]
        ) ;


BOOL
CReceiveArticle::NetscapeHackPost(
                                        CSessionSocket* pSocket,
                                        CBUFPTR&        pBuffer,
                                        HANDLE          hToken,
                                        DWORD           ibStart,
                                        DWORD           cb
                                        )       {
/*++

Routine Description :

        This function deals with postings that apparently don't have
        a body separator.  It may be that they come from badly behaved
        clients that insert LFLF to separate the body instead of
        CRLFCRLF (Netscape does this in one version, with small
        cancel articles).

Arguments :

        pBuffer - the buffer containing the message !
        ibStart - offset into buffer where data starts !
        cb              -       Number of bytes in the article

Return Value :

        NNTP return code !

--*/
        //
        //      The article terminated abruptly with a CRLF.CRLF
        //      This will probably be a failed post, HOWEVER - it
        //      could be that it is a cancel message
        //      from a netscape client.
        //
        NRC             nrcResult = nrcOK ;
        BOOL    fSuccess = FALSE ;
        BOOL    fRtn = FALSE ;
        LPSTR   pchHeader = &pBuffer->m_rgBuff[ibStart] ;
        DWORD   cbTotalBuffer = pBuffer->m_cbTotal - ibStart ;
        DWORD   cbNewHeader = 0 ;
        DWORD   cbNetscape =
                NetscapeHackFunction(
                                                (LPBYTE)pchHeader,
                                                cb,
                                                cbTotalBuffer,
                                                cbNewHeader,
                                                (LPBYTE)"\n\n",
                                                (LPBYTE)"\r\n"
                                                ) ;
        if( cbNetscape != 0 ) {
                //
                //      Attempt to deal with the article - the only thing is
                //      in memory buffers, and we should so if we can process it !
                //
                DWORD   cbArticle = cb ;
                DWORD   cbBody = cbNetscape - cbNewHeader ;
                DWORD   cbAllocated = 0 ;
                LPVOID  lpvPostContext = 0 ;
                CBUFPTR pBody = new( (int)cbBody, cbAllocated ) CBuffer( cbAllocated ) ;
                if( pBody )     {
                        //
                        //      If we get to this point, we've succeeded - we've totally handled the
                        //      post and managed the nntp return codes !
                        //
                        fRtn = TRUE ;
                        //
                        //      Copy the body into this buffer !
                        //
                        CopyMemory(     pBody->m_rgBuff,
                                                &pBuffer->m_rgBuff[ibStart+cbNewHeader],
                                                cbBody
                                                ) ;

                //
                // Allocate room in the log buffer for the list of newsgroups
                // (Max is 256 characters -- we'll grab 200 of them if we can)
                // If we fail, we just pass NULL to PostEarly
                //

                DWORD cbNewsgroups;
                BYTE* pszNewsgroups;
                for (cbNewsgroups=200; cbNewsgroups>0; cbNewsgroups--) {
                    pszNewsgroups = pSocket->m_Collector.AllocateLogSpace(cbNewsgroups);
                    if (pszNewsgroups) {
                        break;
                    }
                }

                        //
                        //      Now post the article !
                        //

                        PNNTP_SERVER_INSTANCE pInstance = pSocket->m_context.m_pInstance;
                        ClientContext*  pContext = &pSocket->m_context ;
                        BOOL    fAnon = pSocket->m_context.m_pInFeed->fDoSecurityChecks() ;
                        DWORD   ibOut = 0 ;
                        DWORD   cbOut = 0 ;
                        FIO_CONTEXT*    pFIOContext = 0 ;
                        fSuccess = pSocket->m_context.m_pInFeed->PostEarly(
                                                        pInstance->GetInstanceWrapper(),
                                                        &pContext->m_securityCtx,
                                                        &pContext->m_encryptCtx,
                                                        pContext->m_securityCtx.IsAnonymous(),
                                                        m_lpstrCommand,
                                                        pBuffer,
                                                        ibStart,
                                                        cbNewHeader,
                                                        &ibOut,
                                                        &cbOut,
                                                        &pFIOContext,
                                                        &lpvPostContext,
                                                        pSocket->m_context.m_dwLast,
                                                        pSocket->GetClientIP(),
                                                        pSocket->m_context.m_return,
                                                        (char*)pszNewsgroups,
                                                        cbNewsgroups
                                                        ) ;

            //
            // Add the list of newsgroups to the log structure
            //

            if (pszNewsgroups) {
                pSocket->m_Collector.ReferenceLogData(LOG_TARGET, pszNewsgroups);
            }

                        pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
                        _ASSERT( (lpvPostContext == 0 && !fSuccess ) || (fSuccess && lpvPostContext != 0) ) ;
                        //
                        //      Looks like we can post the article - if so
                        //      lets try to write it to disk !
                        //
                        if( fSuccess )  {
                                //
                                //      Successfully posted the article - we can now write the bytes !
                                //
                                HANDLE  hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ) ;
                                if( pFIOContext && hEvent )     {
                                        OVERLAPPED      ovl ;
                                        ZeroMemory( &ovl, sizeof( ovl ) ) ;
                                        ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x00000001);
                                        DWORD   cbWritten = 0 ;
                                        BOOL fWrite = WriteFile(
                                                                pFIOContext->m_hFile,
                                                                pBuffer->m_rgBuff + ibOut,
                                                                cbOut,
                                                                &cbWritten,
                                                                &ovl
                                                                ) ;
                                        if( !fWrite && GetLastError() == ERROR_IO_PENDING )     {
                                                fWrite = GetOverlappedResult(   pFIOContext->m_hFile,
                                                                                                                &ovl,
                                                                                                                &cbWritten,
                                                                                                                FALSE
                                                                                                                ) ;
                                        }
                                        if(     fWrite )        {
                                                _ASSERT( cbWritten == cbOut ) ;
                                                ZeroMemory( &ovl, sizeof( ovl ) ) ;
                                                ovl.Offset = cbWritten ;
                                                ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x00000001);
                                                fWrite = WriteFile(     pFIOContext->m_hFile,
                                                                                        pBody->m_rgBuff,
                                                                                        cbBody,
                                                                                        &cbWritten,
                                                                                        &ovl
                                                                                        ) ;
                                                if( !fWrite && GetLastError() == ERROR_IO_PENDING )     {
                                                        fWrite = GetOverlappedResult(   pFIOContext->m_hFile,
                                                                                                                        &ovl,
                                                                                                                        &cbWritten,
                                                                                                                        FALSE
                                                                                                                        ) ;
                                                }
                                        }
                                        //
                                        //      Well we tried to write the posting to disk - complete
                                        //      the posting path for this one
                                        //
                                        if( fWrite )    {
                                                fSuccess = pSocket->m_context.m_pInFeed->PostCommit(
                                                                pSocket->m_context.m_pInstance->GetInstanceWrapper(),
                                                                                lpvPostContext,
                                                                                hToken,
                                                                                pSocket->m_context.m_dwLast,
                                                                                pSocket->m_context.m_return,
                                                                                pSocket->m_context.m_securityCtx.IsAnonymous()
                                                                                ) ;
                                                pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
                                                lpvPostContext = 0 ;
                                        }
                                }
                                //
                                //      Cleanup stuff we don't need anymore !
                                //
                                if( hEvent )
                                        CloseHandle( hEvent ) ;

                        }
                        //
                        //      Fall through to here - if an error occurs cancel the posting
                        //      a successfull run through the above code would set
                        //      lpvPostContext back to NULL !
                        //
                        if( lpvPostContext != 0 )       {
                                fSuccess = pSocket->m_context.m_pInFeed->PostCancel(
                                                                                lpvPostContext,
                                                                                pSocket->m_context.m_dwLast,
                                                                                pSocket->m_context.m_return
                                                                                ) ;
                                pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
                        }
                }
                nrcResult = nrcOK ;
        }
        return  fRtn;
}



CIO*
CReceiveArticle::Complete(  CIOGetArticleEx*  pReadArticle,
                            CSessionSocket* pSocket,
                                                        BOOL    fGoodMatch,
                                                        CBUFPTR&                pBuffer,
                                                        DWORD                   ibStart,
                                                        DWORD                   cb
                                                        )       {
    //
    //  We have completed reading the file sent by the client.
    //  Pass it to the feed object for processing and then send the necessary response.
    //  Finally, check whether its time to move onto a new state.
    //
    //


        _ASSERT( m_pContext != 0 ) ;
        _ASSERT( m_pContext == &pSocket->m_context ) ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOReadArticle" ) ;

    DWORD   cbGroups = 0 ;
    BYTE*   pchGroups = 0 ;
    DWORD   cbMessageId = 0 ;
    BYTE*   pchMessageId = 0 ;

    BOOL    fSuccess= FALSE ;
        DWORD   ibOut = 0 ;
        DWORD   cbOut = 0 ;
        HANDLE  hFile = INVALID_HANDLE_VALUE ;
        HANDLE  hToken = 0 ;

        NRC     nrcResult = nrcOK ;

        if( !fGoodMatch )       {
                nrcResult = nrcArticleIncompleteHeader ;
                pSocket->m_context.m_dwLast = nrcResult ;
                BOOL    fDoBadArticle = TRUE ;
                if( FEnableNetscapeHack() )     {
                        if ( pSocket->m_context.m_encryptCtx.QueryCertificateToken() ) {
                            hToken = pSocket->m_context.m_encryptCtx.QueryCertificateToken();
                        } else {
                            hToken = pSocket->m_context.m_securityCtx.QueryImpersonationToken();
                        }
                        fDoBadArticle = !NetscapeHackPost(      pSocket,
                                                                                        pBuffer,
                                                                                        hToken,
                                                                                        ibStart,
                                                                                        cb
                                                                                        ) ;
                }
                if( fDoBadArticle )     {
                        NRC nrc = BadArticleCode() ;
                        pSocket->m_context.m_return.fSet(   nrc,
                                                                                                nrcResult,
                                                                                                "Bad Article"
                                                                                                ) ;
                        pSocket->m_context.m_nrcLast = nrc ;
                        pSocket->m_context.m_dwLast = nrcResult ;
                }
                //
                //      Everything is done at this point - so
                //      send off error codes etc... to client !
                //
                if( SendResponse(   pSocket, *m_pDriver, pSocket->m_context.m_return ) )
                        pSocket->m_context.m_return.fSetClear() ;
                // After we finish processing the article - issue the next IO operation !
                long    l = InterlockedIncrement( &m_cCompleted ) ;
                _ASSERT( l <= 0 ) ;
                if( l==0 ) {
                        //
                        // The ReadArticle has completed - we can start the next state
                        //
                        CIOREADPTR  pio = GetNextIO() ;
                        DebugTrace( (DWORD_PTR)this, "won InterlockedIncrement - pio %x", pio ) ;
                        return  pio.Release() ;
                }
                return  0 ;
        }

        //
    // Allocate room in the log buffer for the list of newsgroups
        // (Max is 256 characters -- we'll grab 200 of them if we can)
        // If we fail, we just pass NULL to PostEarly
        //

        DWORD cbNewsgroups;
        BYTE* pszNewsgroups;
        for (cbNewsgroups=200; cbNewsgroups>0; cbNewsgroups--) {
        pszNewsgroups = pSocket->m_Collector.AllocateLogSpace(cbNewsgroups);
            if (pszNewsgroups) {
            break;
            }
        }

    PNNTP_SERVER_INSTANCE pInstance = pSocket->m_context.m_pInstance;

    ClientContext*  pContext = &pSocket->m_context ;
    BOOL        fAnon = pSocket->m_context.m_pInFeed->fDoSecurityChecks() ;
        FIO_CONTEXT*    pFIOContext;

    fSuccess = pSocket->m_context.m_pInFeed->PostEarly(
                            pInstance->GetInstanceWrapper(),
                            &pContext->m_securityCtx,
                            &pContext->m_encryptCtx,
                                                        pContext->m_securityCtx.IsAnonymous(),
                            m_lpstrCommand,
                                                        pBuffer,
                                                        ibStart,
                                                        cb,
                                                        &ibOut,
                                                        &cbOut,
                                                        &pFIOContext,
                                                        &m_lpvFeedContext,
                            pSocket->m_context.m_dwLast,
                            pSocket->GetClientIP(),
                            pSocket->m_context.m_return,
                            (char*)pszNewsgroups,
                            cbNewsgroups
                                                        ) ;
    //
    // Add the list of newsgroups to the log structure
    //

    if (pszNewsgroups) {
        pSocket->m_Collector.ReferenceLogData(LOG_TARGET, pszNewsgroups);
    }

        pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;

    //
    //  The CIOReadArticle call usis responsible for deleting the m_pFileChannel,
    //  (because it was successfully init.)
    //  Get rid of our reference as soon as we're done, because after we
    //  return from this function, the CFileChannel could disappear at any second,
    //  and we may yet be called through our Shutdown() function etc....
    //
    DebugTrace( (DWORD_PTR)this, "Result of post is %x", fSuccess ) ;
        _ASSERT(!fSuccess || pFIOContext != NULL);

        pReadArticle->StartFileIO(
                                                pSocket,
                                                pFIOContext,
                                                pBuffer,
                                                ibOut,
                                                cbOut+ibOut,
                                                szEndArticle,
                                                szInitial
                                                ) ;
        return  pReadArticle ;
}


CReceiveArticle*
CReceiveComplete::GetContainer()        {
        return  CONTAINING_RECORD( this, CReceiveArticle, m_PostComplete ) ;
}

void
CReceiveComplete::StartPost(    CSessionSocket* pSocket )       {
        m_pSocket = pSocket ;
        CReceiveArticle*        pContainer = GetContainer() ;
        pContainer->AddRef() ;
}

void
CReceiveComplete::Destroy()     {
        CReceiveArticle*        pContainer = GetContainer() ;
        pContainer->Complete( m_pSocket, SUCCEEDED( GetResult() ) ) ;
        if( pContainer->RemoveRef() < 0 )       {
                delete  pContainer ;
        }
}

void
CReceiveArticle::Complete(  CIOGetArticleEx*    pReadArticle,
                            CSessionSocket*             pSocket,
                                                        FIO_CONTEXT*            pFIOContext,
                                                        DWORD                           cbTransfer
                                                        )       {
    //
    //  We have completed reading the file sent by the client.
    //  Pass it to the feed object for processing and then send the necessary response.
    //  Finally, check whether its time to move onto a new state.
    //
    //

        _ASSERT( pReadArticle != 0 ) ;
        _ASSERT( pSocket != 0 ) ;
        _ASSERT( pFIOContext != 0 ) ;
        _ASSERT( m_lpvFeedContext != 0 ) ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOReadArticle" ) ;

        void*   pvContext = 0 ;
        ClientContext*  pContext = &pSocket->m_context ;
        HANDLE  hToken;

        // Due to some header file problems, I can only pass in
        // a hToken handle here.  Since the post component doens't have
        // type information for client context stuff.
        if ( pContext->m_encryptCtx.QueryCertificateToken() ) {
            hToken = pContext->m_encryptCtx.QueryCertificateToken();
        } else {
            hToken = pContext->m_securityCtx.QueryImpersonationToken();
        }

        m_PostComplete.StartPost( pSocket ) ;

    PNNTP_SERVER_INSTANCE pInstance = ((pSocket->m_context).m_pInstance);
    if ( cbTransfer < pSocket->m_context.m_pInFeed->cbSoftLimit( pInstance->GetInstanceWrapper() ) ||
            pSocket->m_context.m_pInFeed->cbSoftLimit( pInstance->GetInstanceWrapper() ) == 0 ) {
        BOOL    fSuccess = pSocket->m_context.m_pInFeed->PostCommit(
                                pSocket->m_context.m_pInstance->GetInstanceWrapper(),
                                                        m_lpvFeedContext,
                                                        hToken,
                                pSocket->m_context.m_dwLast,
                                pSocket->m_context.m_return,
                                pSocket->m_context.m_securityCtx.IsAnonymous(),
                                                            &m_PostComplete
                                                            ) ;

            if( !fSuccess )     {
                    m_PostComplete.Release() ;
            }
        } else {

            //
            // Cancel the post and set corresponding errors
            //
            pSocket->m_context.m_pInFeed->PostCancel(
                                                                                m_lpvFeedContext,
                                                                                pSocket->m_context.m_dwLast,
                                                                                pSocket->m_context.m_return
                                                                                ) ;
            NRC nrc = ExceedsSoftLimit( pInstance );
            pSocket->m_context.m_return.fSet(   nrc,
                                                nrcArticleTooLarge,
                                                "The Article is too large" );
            pSocket->m_context.m_dwLast = nrcArticleTooLarge;
            m_PostComplete.Release();
        }
}

void
CReceiveArticle::Complete(      CSessionSocket* pSocket,
                                                        BOOL                    fSuccess
                                                        )       {

        TraceFunctEnter( "CReceiveArticle::Complete" ) ;

        pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
        m_lpvFeedContext = 0 ;

        //ReleaseContext( pFIOContext ) ;
    //
    //  The CIOReadArticle call usis responsible for deleting the m_pFileChannel,
    //  (because it was successfully init.)
    //  Get rid of our reference as soon as we're done, because after we
    //  return from this function, the CFileChannel could disappear at any second,
    //  and we may yet be called through our Shutdown() function etc....
    //
    DebugTrace( (DWORD_PTR)this, "Result of post is %x", fSuccess ) ;

    if( SendResponse(   pSocket, *m_pDriver, pSocket->m_context.m_return ) )
        pSocket->m_context.m_return.fSetClear() ;

    // After we finish processing the article - issue the next IO operation !
    long    l = InterlockedIncrement( &m_cCompleted ) ;
    _ASSERT( l <= 0 ) ;
    if( l==0 ) {
        //
        // The ReadArticle has completed - we can start the next state
        //
        CIOREADPTR  pio = GetNextIO() ;

        DebugTrace( (DWORD_PTR)this, "won InterlockedIncrement - pio %x", pio ) ;

        if( !m_pDriver->SendReadIO( pSocket, *pio, TRUE ) ) {
            /*delete    pio */;
        }
    }


}



CIO*
CReceiveArticle::Complete(  CIOGetArticleEx*    pReadArticle,
                            CSessionSocket*             pSocket
                                                        )       {
/*++

Routine Description :

        This function is called when we complete receiving an article
        which has failed to post.
        We just need to send the error code.

Arguments :

        pReadArticle - the CIO used to receive the article
        pSocket - the socket we're working for !

Return Value :

        NULL

--*/

        _ASSERT( pReadArticle != 0 ) ;
        _ASSERT( pSocket != 0 ) ;
        _ASSERT( m_lpvFeedContext == 0 ) ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOGetArticleEx - no article" ) ;

    if( SendResponse(   pSocket, *m_pDriver, pSocket->m_context.m_return ) )
        pSocket->m_context.m_return.fSetClear() ;

        CIOREADPTR      pio = 0 ;
    // After we finish processing the article - issue the next IO operation !
    long    l = InterlockedIncrement( &m_cCompleted ) ;
    _ASSERT( l <= 0 ) ;
    if( l==0 ) {
        //
        // The ReadArticle has completed - we can start the next state
        //
        pio = GetNextIO() ;
        DebugTrace( (DWORD_PTR)this, "won InterlockedIncrement - pio %x", pio ) ;
    }
        return  pio.Release() ;
}

CPostCmd::CPostCmd( LPMULTISZ   lpstrArg    ) : CReceiveArticle( lpstrArg, FALSE )  {
}

CAcceptArticle::CAcceptArticle( LPMULTISZ   lpstrArgs,
                                                                ClientContext*  pContext,
                                BOOL        fPartial ) :
    m_lpstrCommand( lpstrArgs ),
    m_fPartial( fPartial ),
        m_pContext( pContext ),
        m_lpvFeedContext( 0 )    {

        _ASSERT( pContext != 0 ) ;

}

CAcceptArticle*
CAcceptComplete::GetContainer() {
        return  CONTAINING_RECORD( this, CAcceptArticle, m_PostCompletion ) ;
}

void
CAcceptComplete::StartPost(     CSessionSocket* pSocket )       {
        m_pSocket = pSocket ;
        CAcceptArticle* pContainer = GetContainer() ;
        pContainer->AddRef() ;
}

void
CAcceptComplete::Destroy()      {
        CAcceptArticle* pContainer = GetContainer() ;
        pContainer->Complete( m_pSocket, SUCCEEDED( GetResult() ) ) ;
        if( pContainer->RemoveRef() < 0 )       {
                delete  pContainer ;
        }
}






CAcceptArticle::~CAcceptArticle() {
        if( m_lpvFeedContext != 0 ) {
                _ASSERT( m_pContext != 0 ) ;
                DWORD   dwReturn ;
                CNntpReturn     nntpReturn ;
                m_pContext->m_pInFeed->PostCancel(
                                        m_lpvFeedContext,
                                        dwReturn,
                                        nntpReturn
                                        ) ;
        }
}



BOOL
CAcceptArticle::StartExecute(
                                        CSessionSocket* pSocket,
                    CDRIVERPTR& pdriver,
                    CIORead*&   pRead,
                    CIOWrite*&  pWrite
                                        ) {

    //
    //  This is the Start() function which is required of all CSessionState derived objects
    //  Here we will call StartTransfer() to do the brunt of the work of sending an article
    //  to a client.
    //

        if( Start( pSocket, pdriver, pRead, pWrite ) )  {
                if( pWrite ) {
                        if( !pdriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
                                TerminateIOs( pSocket, pRead, pWrite ) ;
                                pRead = 0 ;
                                return  FALSE ;
                        }
                }
                return  TRUE ;
        }
        return  FALSE ;
}


BOOL
CAcceptArticle::Start(  CSessionSocket* pSocket,
                        CDRIVERPTR&     pdriver,
                        CIORead*&       pRead,
                        CIOWrite*&      pWrite
                        ) {

        static  char    szBodySeparator[] = "\r\n\r\n" ;

        _ASSERT( pSocket != 0 ) ;
        _ASSERT( pdriver != 0 ) ;
        _ASSERT( m_pContext != 0 ) ;

    _ASSERT( pRead == 0 ) ;
    _ASSERT( pWrite == 0 ) ;

    m_pDriver = pdriver ;

        //
        //      bugbug - need to handle partial articles and the like here !
        //

    PNNTP_SERVER_INSTANCE pInst = (pSocket->m_context).m_pInstance ;
    pRead = new( *pdriver ) CIOGetArticleEx(
                                                                                this,
                                        pSocket,
                                        pdriver,
                                        pSocket->m_context.m_pInFeed->cbHardLimit( pInst->GetInstanceWrapper() ),
                                                                                szBodySeparator,
                                                                                szBodySeparator,
                                                                                szEndArticle,
                                                                                (m_fPartial) ? szInitial : szEndArticle
                                        ) ;

    return  pRead != 0 ;
}


CIO*
CAcceptArticle::Complete(   CIOWriteLine*,
                            CSessionSocket* pSocket,
                            CDRIVERPTR& pdriver
                                                        ) {

    TraceFunctEnter( "CAcceptArticles::Complete CIOWriteLine" ) ;

    //
    //  Clear any return code we may have had !
    //
    pSocket->m_context.m_return.fSetClear() ;

    CIOREADPTR  pio = GetNextIO() ;
    if( !pdriver->SendReadIO( pSocket, *pio, TRUE ) ) {
        /*delete    pio */;
    }
    return  0 ;
}




CIO*
CAcceptArticle::Complete(       CIOGetArticleEx*  pReadArticle,
                                                        CSessionSocket* pSocket,
                                                        BOOL    fGoodMatch,
                                                        CBUFPTR&                pBuffer,
                                                        DWORD                   ibStart,
                                                        DWORD                   cb
                                                        )       {
    //
    //  We have completed reading the file sent by the client.
    //  Pass it to the feed object for processing and then send the necessary response.
    //  Finally, check whether its time to move onto a new state.
    //
    //

        static  char    szEndArticle[] = "\r\n.\r\n" ;
        static  char    *szInitial = szEndArticle + 2 ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOReadArticle" ) ;

    DWORD   cbGroups = 0 ;
    BYTE*   pchGroups = 0 ;
    DWORD   cbMessageId = 0 ;
    BYTE*   pchMessageId = 0 ;

        if( !fGoodMatch )       {
                NRC     nrcResult = nrcArticleIncompleteHeader ;
                NRC nrc = BadArticleCode() ;
                pSocket->m_context.m_return.fSet(   nrc,
                                                                                        nrcResult,
                                                                                        "Bad Article"
                                                                                        ) ;
                pSocket->m_context.m_nrcLast = nrc ;
                pSocket->m_context.m_dwLast = nrcResult ;
                //
                //      Everything is done at this point - so
                //      send off error codes etc... to client !
                //

                if( !SendResponse(  pSocket,
                                                        *m_pDriver,
                                                        pSocket->m_context.m_return,
                                                        ((pchMessageId && *pchMessageId != '\0') ?
                                                        (LPCSTR)pchMessageId :
                                                                (m_lpstrCommand ? m_lpstrCommand : "NULL" ))
                                                        ) ) {

                        pSocket->m_context.m_return.fSetClear() ;
                        m_pDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, pSocket->m_context.m_return.m_nrc ) ;
                }
                return  0 ;
        }

        //
        // Allocate room in the log buffer for the list of newsgroups
        // (Max is 256 characters -- we'll grab 200 of them if we can)
        // If we fail, we just pass NULL to PostEarly
        //

    DWORD cbNewsgroups;
    BYTE* pszNewsgroups;
    for (cbNewsgroups=200; cbNewsgroups>0; cbNewsgroups--) {
        pszNewsgroups = pSocket->m_Collector.AllocateLogSpace(cbNewsgroups);
        if (pszNewsgroups) {
            break;
        }
        }

    BOOL    fSuccess= FALSE ;
        DWORD   ibOut = 0 ;
        DWORD   cbOut = 0 ;
        PFIO_CONTEXT pFIOContext = 0 ;

    BOOL    fTransfer = FAllowTransfer( pSocket->m_context ) ;
        if( fTransfer )         {
                PNNTP_SERVER_INSTANCE pInstance = pSocket->m_context.m_pInstance;
                ClientContext*  pContext = &pSocket->m_context ;
                BOOL    fAnon = pSocket->m_context.m_pInFeed->fDoSecurityChecks() ;
                fSuccess = pSocket->m_context.m_pInFeed->PostEarly(
                                                        pInstance->GetInstanceWrapper(),
                                                        &pContext->m_securityCtx,
                                                        &pContext->m_encryptCtx,
                                                        pContext->m_securityCtx.IsAnonymous(),
                                                        m_lpstrCommand,
                                                        pBuffer,
                                                        ibStart,
                                                        cb,
                                                        &ibOut,
                                                        &cbOut,
                                                        &pFIOContext,
                                                        &m_lpvFeedContext,
                                                        pSocket->m_context.m_dwLast,
                                                        pSocket->GetClientIP(),
                                                        pSocket->m_context.m_return,
                                                        (char*)pszNewsgroups,
                                                        cbNewsgroups,
                                                        FALSE
                                                        ) ;
        //
        // Add the list of newsgroups to the log structure
        //
        if (pszNewsgroups) {
            pSocket->m_Collector.ReferenceLogData(LOG_TARGET, pszNewsgroups);
        }
                pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;
        }       else    {
                pBuffer = 0 ;
        }

    //
    //  The CIOReadArticle call usis responsible for deleting the m_pFileChannel,
    //  (because it was successfully init.)
    //  Get rid of our reference as soon as we're done, because after we
    //  return from this function, the CFileChannel could disappear at any second,
    //  and we may yet be called through our Shutdown() function etc....
    //
    DebugTrace( (DWORD_PTR)this, "Result of post is %x", fSuccess ) ;

        pReadArticle->StartFileIO(
                                                pSocket,
                                                pFIOContext,
                                                pBuffer,
                                                ibOut,
                                                cbOut+ibOut,
                                                szEndArticle,
                                                szInitial
                                                ) ;
        return  pReadArticle ;
}

void
CAcceptArticle::Complete(       CIOGetArticleEx*        pReadArticle,
                                                        CSessionSocket*         pSocket,
                                                        FIO_CONTEXT*            pFIOContext,
                                                        DWORD                           cbTransfer
                                                        )       {
    //
    //  We have completed reading the file sent by the client.
    //  Pass it to the feed object for processing and then send the necessary response.
    //  Finally, check whether its time to move onto a new state.
    //
    //

        _ASSERT( pReadArticle != 0 ) ;
        _ASSERT( pSocket != 0 ) ;
        _ASSERT( pFIOContext != 0 ) ;
        _ASSERT( m_lpvFeedContext != 0 ) ;

    TraceFunctEnter( "CReceiveArticle::Complete CIOReadArticle" ) ;

        void*   pvContext = 0 ;
        ClientContext*  pContext = &pSocket->m_context ;
        HANDLE  hToken;

        // Due to some header file problems, I can only pass in
        // a hToken handle here.  Since the post component doens't have
        // type information for client context stuff.
        if ( pContext->m_encryptCtx.QueryCertificateToken() ) {
            hToken = pContext->m_encryptCtx.QueryCertificateToken();
        } else {
            hToken = pContext->m_securityCtx.QueryImpersonationToken();
        }

        m_PostCompletion.StartPost( pSocket ) ;

    BOOL        fSuccess = pSocket->m_context.m_pInFeed->PostCommit(
                            pSocket->m_context.m_pInstance->GetInstanceWrapper(),
                                                        m_lpvFeedContext,
                                                        hToken,
                            pSocket->m_context.m_dwLast,
                            pSocket->m_context.m_return,
                            pSocket->m_context.m_securityCtx.IsAnonymous(),
                                                        &m_PostCompletion
                                                        ) ;
        if( !fSuccess )         {
                //
                //      call this guy so that we send the response for the post !
                //
                m_PostCompletion.Release() ;
        }
}

void
CAcceptArticle::Complete(       CSessionSocket* pSocket,
                                                        BOOL    fPostSuccessfull
                                                        )       {
        TraceFunctEnter( "CAcceptArticle::Complete - pSocket, fPost" ) ;
        m_lpvFeedContext = 0 ;
        pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;

    //
    //  The CIOReadArticle call usis responsible for deleting the m_pFileChannel,
    //  (because it was successfully init.)
    //  Get rid of our reference as soon as we're done, because after we
    //  return from this function, the CFileChannel could disappear at any second,
    //  and we may yet be called through our Shutdown() function etc....
    //
    DebugTrace( (DWORD_PTR)this, "Result of post is %x", fPostSuccessfull ) ;

        LPSTR   pchMessageId = 0 ;

    if( !SendResponse(  pSocket,
                        *m_pDriver,
                        pSocket->m_context.m_return,
                                                (m_lpstrCommand ? m_lpstrCommand : "NULL" )
                        ) ) {

        pSocket->m_context.m_return.fSetClear() ;
        m_pDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, pSocket->m_context.m_return.m_nrc ) ;
                return  ;
    }
}

CIO*
CAcceptArticle::Complete(       CIOGetArticleEx*        pReadArticle,
                                                        CSessionSocket*         pSocket
                                                        )       {
/*++

Routine Description :

        This function is called when we complete receiving an article
        which has failed to post.
        We just need to send the error code.

Arguments :

        pReadArticle - the CIO used to receive the article
        pSocket - the socket we're working for !

Return Value :

        NULL

--*/
    TraceFunctEnter( "CReceiveArticle::Complete CIOGetArticleEx - no article" ) ;


        _ASSERT( pSocket != 0 ) ;
        _ASSERT( pReadArticle != 0 ) ;
        _ASSERT( m_lpvFeedContext == 0 ) ;

        LPSTR   pchMessageId = 0 ;
        pSocket->m_context.m_nrcLast = pSocket->m_context.m_return.m_nrc ;

    if( !SendResponse(  pSocket,
                        *m_pDriver,
                        pSocket->m_context.m_return,
                                                ((pchMessageId && *pchMessageId != '\0') ?
                                                        (LPCSTR)pchMessageId :
                                                                (m_lpstrCommand ? m_lpstrCommand : "NULL" ))
                        ) ) {

        pSocket->m_context.m_return.fSetClear() ;
        m_pDriver->UnsafeClose( pSocket, CAUSE_UNKNOWN, pSocket->m_context.m_return.m_nrc ) ;
    }
        return  0 ;
}

BOOL
CAcceptArticle::SendResponse(   CSessionSocket* pSocket,
                                CIODriver&  driver,
                                CNntpReturn&    nntpReturn,
                                                                LPCSTR          szMessageId
                                )   {
/*++

Routine Description :

    This function exists to check whether it is a good time to send
    the result code of the post to the client.  Our main concern is to make
    sure that our initial 'Ok' response to the command has completed
    before we try do another send.

Arguments :

    pSocket - The socket on which we will send
    nntpReturn - The result of the post operation

Return Value :
    TRUE if we sent the response - caller should clear the nntpReturn object.


--*/

    TraceFunctEnter( "CAcceptArticles::SendResponse" ) ;

    _ASSERT( m_pDriver ) ;

    CIOWriteLine    *pWrite = new( driver ) CIOWriteLine(this);

    if (pWrite == NULL) {
        m_pDriver->UnsafeClose(pSocket, CAUSE_OOM, 0);
        return FALSE;
    }

    if( !pWrite->InitBuffers( m_pDriver, 200 )  )   {
        m_pDriver->UnsafeClose(pSocket, CAUSE_OOM, 0);
        CIO::Destroy(pWrite, driver);
        return FALSE;
    }   else    {

        unsigned    cb ;
        char    *lpb = pWrite->GetBuff( cb ) ;

        int cbOut = _snprintf( lpb, cb, "%03d %s %s\r\n", nntpReturn.m_nrc, szMessageId,
                        nntpReturn.fIsOK() ? "" : nntpReturn.szReturn() ) ;
        if( cbOut > 0 ) {

            if( m_pCollector ) {
                ADDI( m_pCollector->m_cbBytesSent, cbOut );
                pSocket->TransactionLog( m_pCollector,
                                        pSocket->m_context.m_nrcLast,
                                        pSocket->m_context.m_dwLast
                                        ) ;
            }


            pWrite->AddText( cbOut ) ;
            if( !m_pDriver->SendWriteIO( pSocket, *pWrite, TRUE ) ) {
                ErrorTrace( (DWORD_PTR)(this), "Failure sending pWrite %x", pWrite ) ;
                CIO::Destroy( pWrite, driver ) ;
            }   else    {
                return  TRUE ;
            }

        }   else    {
            m_pDriver->UnsafeClose(pSocket, CAUSE_UNKNOWN, 0);
            CIO::Destroy(pWrite, driver);
            return FALSE;
        }
    }
    return  FALSE ;
}

void
CAcceptArticle::TerminateIOs(   CSessionSocket* pSocket,
                            CIORead*    pRead,
                            CIOWrite*   pWrite )    {

    if( pWrite != 0 )
        pWrite->DestroySelf() ;

    CIOGetArticle*  pGetArticle = (CIOGetArticle*)pRead ;
    pGetArticle->DestroySelf() ;
}


void
CAcceptArticle::Shutdown(   CIODriver&  driver,
                            CSessionSocket* pSocket,
                            SHUTDOWN_CAUSE  cause,
                            DWORD           dwError ) {

    TraceFunctEnter( "CReceiveArticle::Shutdown" ) ;

    DebugTrace( (DWORD_PTR)this, "Shutdown cause %d pSocket %x driver %x",
        cause, pSocket, &driver ) ;

    if( cause != CAUSE_NORMAL_CIO_TERMINATION && pSocket != 0 )
        pSocket->Disconnect( cause, dwError ) ;
}




CTakethisCmd::CTakethisCmd( LPMULTISZ   lpstrArgs,
                                                        ClientContext*  pContext
                                                        ) :
    CAcceptArticle( lpstrArgs, pContext, TRUE ) {
}

CIOExecute*
CTakethisCmd::make(
                int     cArgs,
                char**  argv,
                CExecutableCommand*&  pExecute,
                struct  ClientContext&  context,
                class   CIODriver&      driver
                ) {

    //
    //  If somebody sends a takethis command it doesn't matter what follows -
    //  we will swallow it whole !!
    //

    InterlockedIncrementStat( (context.m_pInstance), TakethisCommands );

    LPMULTISZ   lpstrArgs = 0 ;
    if( cArgs > 1 )
        lpstrArgs = ::ConditionArgs( cArgs-1, &argv[1] ) ;

    CTakethisCmd*   pTakethis =
        new CTakethisCmd( lpstrArgs, &context ) ;

    if( pTakethis ) {
        return  pTakethis ;
    }
    context.m_return.fSet( nrcServerFault ) ;
    pExecute = new( context )   CErrorCmd( context.m_return ) ;
    return   0 ;
}

DWORD
CTakethisCmd::FillLogString(    BYTE*   pbCommandLog,
                                DWORD   cbCommandLog
                                )   {

    return  0 ;
}

BOOL
CTakethisCmd::FAllowTransfer(   ClientContext&  context )   {

    if( !context.m_pInFeed->fIsIHaveLegal() ) {
        context.m_return.fSet( nrcSArticleRejected, nrcNoAccess, "Access Denied" ) ;
        return  FALSE ;
    }

    if( !context.m_pInFeed->fAcceptPosts( context.m_pInstance->GetInstanceWrapper() ) )   {
        context.m_return.fSet( nrcSNotAccepting ) ;
        return  FALSE ;
    }
    return  TRUE ;
}


CIOExecute*
CQuitCmd::make( int cArgs,
                char**  argv,
                CExecutableCommand*&  pExecute,
                struct ClientContext&   context,
                class   CIODriver&  driver  ) {
/*++

Routine Description :

    Create a CQuitCmd object.

Arguments :

    Same as CCmd::make.

Return Value :

    A CQuitCmd object.

--*/


    //  build a quit command object

    _ASSERT( cArgs >= 1 ) ;
    _ASSERT( lstrcmpi( argv[0], "quit" ) == 0 ) ;

    InterlockedIncrementStat( (context.m_pInstance), QuitCommands );

    CQuitCmd    *pTmp = new( context ) CQuitCmd() ;
    pExecute = pTmp ;
    return  0 ;
}

int
CQuitCmd::StartExecute( BYTE    *lpb,
                        int cb,
                        BOOL    &fComplete,
                        void    *&pv,
                        ClientContext&  context,
                        CLogCollector*  pCollector ) {

    //
    //  Send the response to the command -
    //  we will blow off the session later.
    //

    char    szQuit[] = "205 closing connection - goodbye!\r\n" ;

    context.m_nrcLast = nrcGoodBye ;

    _ASSERT( cb > sizeof( szQuit ) ) ;
    int cbRtn = sizeof( szQuit ) - 1 ;
    CopyMemory( lpb, szQuit, cbRtn ) ;
    fComplete = TRUE ;

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, (BYTE*)szQuit, 4 ) ;
    }
    */

    return  cbRtn ;
}

BOOL
CQuitCmd::CompleteCommand(  CSessionSocket* pSocket,
                            ClientContext&  ) {
    //
    //  Kill the session - this is called when we know our write had completed.
    //
    pSocket->Disconnect() ;
    return  FALSE ;
}



//
// local structures for processing AUTHINFO commands
//

typedef struct _AUTH_TABLE {

    //
    // type of command
    //

    AUTH_COMMAND Command;

    //
    // actual command string
    //

    LPSTR CommandString;

    //
    // number of params expected
    //

    DWORD nParams;

} AUTH_TABLE, *PAUTH_TABLE;


//
// Authinfo commands
//

AUTH_TABLE AuthCommandTable[] = {
    { AuthCommandUser, "USER", 3 },
    { AuthCommandPassword, "PASS", 3 },
    { AuthCommandReverse, "REVERSE", 2 },
    { AuthCommandTransact, "GENERIC", 3 },
    { AuthCommandTransact, "TRANSACT", 3 },
    { AuthCommandInvalid, NULL, 0 }
    };

//
// Reply strings
//

typedef struct _AUTH_REPLY {
    LPSTR Reply;
    DWORD Len;
    NRC   nrc;
} AUTH_REPLY, *PAUTH_REPLY;


AUTH_REPLY SecReplies[] = {
    { "281 Authentication ok\r\n", 0, nrcLoggedOn },
    { "281 Authentication ok.  Logged on as Guest.\r\n", 0, nrcLoggedOn },
    { "381 Protocol supported, proceed\r\n", 0, nrcPassRequired },
    { "381 Waiting for password\r\n", 0, nrcPassRequired },
    { "500 Bad Command\r\n", 0, nrcNotRecognized },
    { "501 Syntax Error\r\n", 0, nrcSyntaxError },
    { "502 Permission denied\r\n", 0, nrcNoAccess },
    { "503 Give username first\r\n", 0, nrcServerFault },
    { "451 System Problem\r\n", 0, nrcLogonFailure  },
    { "480 Authorization required\r\n", 0, nrcLogonRequired },
    { "485 MSN NTLM BASIC\r\n", 0, nrcSupportedProtocols },
    { NULL, 0, nrcServerFault }
    };



CAuthinfoCmd::CAuthinfoCmd() {
    m_authCommand = AuthCommandInvalid;
}

CIOExecute*
CAuthinfoCmd::make(
        int cArgs,
        char **argv,
        CExecutableCommand*& pExecute,
        ClientContext&  context,
        class   CIODriver&  driver
        )
{
    DWORD i;
    CAuthinfoCmd *pTmp = new( context ) CAuthinfoCmd() ;
    ENTER("AuthInfoCmd Make")

    //
    // Has to have at least 1 param
    //

    if ( cArgs < 2 ) {

        ErrorTrace(0,"No params in authinfo\n");
        context.m_return.fSet( nrcSyntaxError ) ;
        goto cleanup;
    }

    DebugTrace(0,"auth info command is %s\n",argv[1]);

    //
    // Check command
    //

    if ( pTmp != NULL ) {

        for (i=0; AuthCommandTable[i].CommandString != NULL ;i++) {
            if( lstrcmpi( AuthCommandTable[i].CommandString, argv[1] ) == 0 ) {
                if ( cArgs < (INT)AuthCommandTable[i].nParams ) {

                    //
                    //  Handle 'Authinfo Transact' in a special manner
                    //
                    if( AuthCommandTable[i].Command == AuthCommandTransact &&
                        cArgs == 2 ) {

                        char    szPackageBuffer[256] ;
                        ZeroMemory( szPackageBuffer, sizeof( szPackageBuffer ) ) ;
                        DWORD   nbytes = sizeof( szPackageBuffer )-1 ;

                                                (context.m_pInstance)->LockConfigRead();
                        if( (context.m_securityCtx).GetInstanceAuthPackageNames( (BYTE*)szPackageBuffer, &nbytes, PkgFmtCrLf ) ) {

                            context.m_return.fSet( nrcLoggedOn, szPackageBuffer ) ;

                        }   else    {

                            context.m_return.fSet( nrcServerFault ) ;

                        }
                                                (context.m_pInstance)->UnLockConfigRead();

                        goto    cleanup ;
                    }

                    ErrorTrace(0,"Insufficient params (%d) in authinfo %s\n",
                        cArgs,argv[1]);

                    context.m_return.fSet( nrcSyntaxError ) ;
                    goto cleanup;
                }

                pTmp->m_authCommand = AuthCommandTable[i].Command;

                break;
            }
        }

        //
        // if command illegal, clean up
        //

        if ( pTmp->m_authCommand == AuthCommandInvalid ) {
            ErrorTrace(0,"Invalid authinfo command %s\n",argv[1]);
            context.m_return.fSet( nrcSyntaxError ) ;
            if ( pTmp != NULL ) {
                goto    cleanup ;
            }
        } else {

            //
            // Get the blob
            //

            pTmp->m_lpstrBlob = argv[2] ;

        }
    }

    pExecute = pTmp ;
    return  0 ;

cleanup:
    delete  pTmp ;
    pExecute = new( context ) CErrorCmd( context.m_return ) ;
    return  0 ;
}

int
CAuthinfoCmd::StartExecute(
        BYTE *lpb,
        int cb,
        BOOL &fComplete,
        void *&pv,
        ClientContext&  context,
        CLogCollector*  pCollector
        )
{
    DWORD nbytes;
    DWORD cbPrefix = 0;
    REPLY_LIST  replyId;
    BOOL        f;

    // Handle default domain case.
    CHAR        szTmp[MAX_USER_NAME_LEN + MAX_DOMAIN_NAME + 2];
    LPSTR       lpTmp = NULL;

    CSecurityCtx *sec = &context.m_securityCtx;
    ENTER("AuthInfoCmd::StartExecute")

    _ASSERT(m_authCommand != AuthCommandInvalid);

    // if no logon domain is present in user name, and default
    // logon domain is set, then prepend default logon domain to username
    if (m_authCommand == AuthCommandUser)
    {
        if (m_lpstrBlob && m_lpstrBlob[0] != '\0' 
            && !strchr(m_lpstrBlob, '/') && !strchr(m_lpstrBlob, '\\') 
            && (context.m_pInstance->QueryAuthentInfo())->strDefaultLogonDomain.QueryCCH() > 0)
        {
            LPSTR lpstr = (context.m_pInstance->QueryAuthentInfo())->strDefaultLogonDomain.QueryStr();

            lpTmp = (LPSTR) szTmp;

            if (lpstr[0] == '\\' && lpstr[1] == '\0')
            {
                // all trusted domains
                wsprintf(lpTmp, "/%s", m_lpstrBlob);
            }
            else
                wsprintf(lpTmp, "%s/%s", lpstr, m_lpstrBlob);
        }
        else
            lpTmp = m_lpstrBlob;
    }
    else
        lpTmp = m_lpstrBlob;    

    //
    // if we're already logged in as some user dec the stats
    // ProcessAuthInfo will reset the session on the first call
    //
    if ( sec->IsAuthenticated() )
    {
        context.DecrementUserStats();
    }

    //
    // Pass this off to our processor
    //
    SetLastError( NO_ERROR ) ;

    nbytes = cb;
    (context.m_pInstance)->LockConfigRead();
    f = sec->ProcessAuthInfo(
                            context.m_pInstance,
                            m_authCommand,
                            lpTmp,
                            lpb + sizeof("381 ") - 1,
                            &nbytes,
                            &replyId
                            );
    (context.m_pInstance)->UnLockConfigRead();

    //
    // if replyID == SecNull we're conversing for challenge/response logon
    //
    if ( replyId == SecNull )
    {
        _ASSERT( nbytes != 0 );
        _ASSERT( nbytes < cb - sizeof("381 \r\n") );

        context.m_nrcLast = nrcPassRequired ;

        //
        // prepend the protocol specific header
        //
        CopyMemory( lpb, "381 ", sizeof("381 ") - 1 );

        //
        // append the CRLF
        //
        lstrcpy( (LPSTR)lpb + sizeof("381 ") - 1 + nbytes, "\r\n" );
        nbytes += sizeof("381 \r\n") - 1;
    }
    //
    // if replyID == SecProtNS respond with supported protocols.
    //
    else if ( replyId == SecProtNS )
    {

        context.m_nrcLast = nrcSupportedProtocols ;

        CopyMemory( lpb, "485 ", sizeof("485 ") - 1 );

        nbytes = cb - sizeof("485 \r\n");
                (context.m_pInstance)->LockConfigRead();
        (context.m_securityCtx).GetAuthPackageNames( lpb + sizeof("485 ") - 1, &nbytes );
                (context.m_pInstance)->UnLockConfigRead();

        lstrcpy( (char*)lpb + sizeof("485 ") - 1 + nbytes, "\r\n" );
        nbytes += sizeof("485 \r\n") - 1;
    }

    else
    {
        _ASSERT( replyId < NUM_SEC_REPLIES );

        lstrcpy( (LPSTR)lpb, SecReplies[replyId].Reply );
        nbytes = lstrlen( (LPSTR)lpb );
        context.m_nrcLast = SecReplies[replyId].nrc ;
        context.m_dwLast = GetLastError() ;

        //
        // inc the perf counters if SecPermissionDenied or proceed prompts
        //
        switch( replyId )
        {
        case SecPermissionDenied:
            IncrementStat( (context.m_pInstance), LogonFailures );
            break;

        case SecProtOk:
        case SecNeedPwd:
            IncrementStat( (context.m_pInstance), LogonAttempts );
            break;
        }
    }

    _ASSERT( nbytes <= (DWORD)cb );

    if ( f == FALSE )
    {
        //
        // if we fail for any reason reset the state to accept user/auth/apop
        //
        sec->Reset();
    }


    //
    // if we're logged in as some user inc the stats
    // ProcessAuthInfo will not set the flag till we're logged on
    //
    if ( sec->IsAuthenticated() )
    {
        context.IncrementUserStats();
    }

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, nbytes-2 ) ;
    }
    */

    fComplete = TRUE ;
    return(nbytes);
}

CIOExecute*
CXOverCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&        pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    CXOverCmd   *pXover;
    CGRPPTR     pGroup;
    //ARTICLEID   artid;
    DWORD       loRange;
    DWORD       hiRange;

    //
    // Has a group been chosen?
    //

    ENTER("XOverCmd::Make")

    InterlockedIncrementStat( (context.m_pInstance), XOverCommands );

    pGroup = context.m_pCurrentGroup ;

    if ( pGroup == 0 ) {

        ErrorTrace(0,"No current group selected\n");
        context.m_return.fSet( nrcNoGroupSelected );
        pExecute = new( context ) CErrorCmd( context.m_return );
        return 0;
    }

    //
    // Get article range
    //

    loRange = pGroup->GetFirstArticle( );
    hiRange = pGroup->GetLastArticle( );

    //
    // See if we have any articles
    //

    if ( pGroup->GetArticleEstimate() == 0 || loRange > hiRange ) {

        ErrorTrace(0,"No articles in group\n");
        context.m_return.fSet( nrcNoCurArticle );
        pExecute = new( context ) CErrorCmd( context.m_return );
        return 0;
    }

    _ASSERT( loRange <= hiRange );

    //
    // Get the article number
    //

    if ( argc == 1 ) {

        //
        // Use current article
        //

        if( context.m_idCurrentArticle != INVALID_ARTICLEID ) {

            if( context.m_idCurrentArticle < loRange ||
                context.m_idCurrentArticle > hiRange ) {
                context.m_return.fSet( nrcNoSuchArticle ) ;
                pExecute = new( context )   CErrorCmd( context.m_return ) ;
                return  0 ;
            }

            pXover = new( context ) CXOverCmd( pGroup ) ;
            if ( pXover == 0 ) {
                ErrorTrace(0,"Cannot allocate XOverCmd\n");
                goto exit;
            }

            pXover->m_Completion.m_currentArticle =
            pXover->m_Completion.m_loArticle =
            pXover->m_Completion.m_hiArticle = context.m_idCurrentArticle;

            pXover->m_pContext = &context;

        }   else    {

            context.m_return.fSet( nrcNoCurArticle ) ;
            pExecute = new( context )   CErrorCmd( context.m_return ) ;
            return  0 ;
        }

        _ASSERT( context.m_idCurrentArticle <= hiRange );
        _ASSERT( context.m_idCurrentArticle >= loRange );

    } else if ( argc == 2 ) {

        //
        // Range is specified, get it
        //
                NRC     code ;

        if ( !GetCommandRange( argc, argv, &loRange, &hiRange, code ) ) {

            //
            // something wrong with the range specified
            //

            ErrorTrace(0,"Range Error %s\n",argv[1]);
                        context.m_return.fSet( code == nrcNotSet ? nrcNoArticleNumber : code );
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return  0;
        }

        pXover = new( context ) CXOverCmd( pGroup ) ;
        if ( pXover == 0 ) {
            ErrorTrace(0,"Cannot allocate XOverCmd\n");
            goto exit;
        }

        pXover->m_Completion.m_currentArticle =
        pXover->m_Completion.m_loArticle = loRange;
        pXover->m_Completion.m_hiArticle = hiRange;

        pXover->m_pContext = &context;

    } else {

        ErrorTrace(0,"Syntax Error\n");
        context.m_return.fSet( nrcSyntaxError ) ;
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;
    }

exit:
    pExecute = (CExecute*)pXover;
    return 0;
}

CXOverAsyncComplete::CXOverAsyncComplete()      :
        m_currentArticle( INVALID_ARTICLEID ),
        m_loArticle( INVALID_ARTICLEID ),
        m_hiArticle( INVALID_ARTICLEID ),
        m_groupHighArticle( INVALID_ARTICLEID ),
        m_lpb( 0 ),
        m_cb( 0 ),
        m_cbPrefix( 0 ) {
}

CXOverCmd*
CXOverAsyncComplete::GetContainer()     {
        return  CONTAINING_RECORD( this, CXOverCmd, m_Completion ) ;
}

void
CXOverAsyncComplete::Destroy()  {
/*++

Routine Description :

        This is called when our last reference goes away.
        We don't destruct ourselves at that point - instead
        we get ready for another round !

        NOTE : We cannot touch any members after calling the
                base classes Complete() function - as we can
                be re-entered for another operation !

Arguments :

        None.


Return Value :

        None

--*/

        if(     SUCCEEDED(GetResult()) ) {

                if(     m_currentArticle > m_hiArticle ) {
                        m_fComplete = TRUE ;
            CopyMemory( m_lpb+m_cbTransfer, StrTermLine, 3 );
            m_cbTransfer += 3 ;
                }
            m_cbTransfer += m_cbPrefix ;
        }

        //
        //      When we reset our state we keep our Article Number
        //      and group info - but this buffer stuff is useless now
        //
        m_lpb = 0 ;
        m_cb = 0 ;
        //
        //      Call our base classes completion function ! -
        //      Note if we're note complete we pass TRUE so that
        //      the base class resets for another operation !
        //
        Complete( !m_fComplete ) ;
}

inline  CGRPPTR&
CXOverAsyncComplete::GetGroup() {
        return          GetContainer()->m_pGroup ;;
}

CXOverAsyncComplete*
CXOverCacheWork::GetContainer() {
        return          CONTAINING_RECORD(      this, CXOverAsyncComplete, m_CacheWork ) ;
}

inline  CGRPPTR&
CXOverCacheWork::GetGroup()     {
        CXOverAsyncComplete*    p = GetContainer() ;
        return          p->GetGroup() ;
}

void
CXOverCacheWork::DoXover(
                                ARTICLEID       articleIdLow,
                                ARTICLEID       articleIdHigh,
                                ARTICLEID*      particleIdNext,
                                LPBYTE          lpb,
                                DWORD           cb,
                                DWORD*          pcbTransfer,
                                class   CNntpComplete*  pComplete
                                )       {

        _ASSERT( particleIdNext != 0 ) ;
        _ASSERT(        lpb != 0 ) ;
        _ASSERT(        pcbTransfer != 0 ) ;
        _ASSERT(        pComplete != 0 ) ;
        //
        //      Okay - issue the Xover command against the real driver !
        //
        CGRPPTR&        pGroup = GetGroup() ;
        _ASSERT(        pGroup != 0 ) ;
        pGroup->FillBufferInternal(     articleIdLow,
                                                                articleIdHigh,
                                                                particleIdNext,
                                                                lpb,
                                                                cb,
                                                                pcbTransfer,
                                                                pComplete
                                                                ) ;
}

//
//      this function is called when the operation completes !
//
void
CXOverCacheWork::Complete(
                        BOOL            fSuccess,
                        DWORD           cbTransferred,
                        ARTICLEID       articleIdNext
                        )       {

    //
    // If we had a successful completion and there were bytes returned, then
    // we go ahead and complete by calling pContainer->Release().  We also do
    // this in the failure case as well.
    //
    // If it was successful, but there weren't any bytes returned, then we don't
    // want to signal the protocol's completion.  Instead, we'll fake up a call
    // back into NextBuffer and let it do its magic.  We do NOT call Release in
    // this case -- instead, we'll let it go through the normal completion path,
    // which will eventually come back in here.
    //

        CXOverAsyncComplete*    pContainer = GetContainer() ;
        pContainer->m_cbTransfer = cbTransferred ;
        pContainer->m_currentArticle = articleIdNext ;

        if(!fSuccess) {
                pContainer->SetResult(E_FAIL);
        pContainer->Release();
        return;
        }

        pContainer->SetResult( S_OK ) ;
        CXOverCmd *pCmd = pContainer->GetContainer();

    if ((cbTransferred + pCmd->m_Completion.m_cbPrefix) != 0 ||
            articleIdNext > pContainer->m_hiArticle) {
                pContainer->Release() ;
        return;
        }


        while (pCmd->m_Completion.ReleaseFillBufferRef()) {

        CGRPPTR& pGroup = GetGroup();

        pCmd->m_Completion.InitFillBufferRefs();

        pGroup->FillBuffer(
                        &pCmd->m_pContext->m_securityCtx,
                        &pCmd->m_pContext->m_encryptCtx,
                        pCmd->m_Completion
                        );

    }

}

        //
        //      Get the arguments for this XOVER operation !
        //
void
CXOverCacheWork::GetArguments(
                                OUT     ARTICLEID&      articleIdLow,
                                OUT     ARTICLEID&      articleIdHigh,
                                OUT     ARTICLEID&      articleIdGroupHigh,
                                OUT     LPBYTE&         lpbBuffer,
                                OUT     DWORD&          cbBuffer
                                )       {

        CXOverAsyncComplete*    pContainer = GetContainer() ;
        articleIdLow = pContainer->m_currentArticle ;
        articleIdHigh = pContainer->m_hiArticle ;
        articleIdGroupHigh = pContainer->m_groupHighArticle ;
        lpbBuffer = pContainer->m_lpb ;
        cbBuffer = pContainer->m_cb ;
}

        //
        //      Get only the range of articles requested for this XOVER op !
        //
void
CXOverCacheWork::GetRange(
                        OUT     GROUPID&        groupId,
                        OUT     ARTICLEID&      articleIdLow,
                        OUT     ARTICLEID&      articleIdHigh,
                        OUT     ARTICLEID&      articleIdGroupHigh
                        )       {
        CXOverAsyncComplete*    pContainer = GetContainer() ;
        articleIdLow = pContainer->m_currentArticle ;
        articleIdHigh = pContainer->m_hiArticle ;
        articleIdGroupHigh = pContainer->m_groupHighArticle ;
        CGRPPTR&        pGroup = GetGroup() ;
        groupId = pGroup->GetGroupId() ;
}




CXOverCmd::CXOverCmd( CGRPPTR&  pGroup ) :
    m_pGroup( pGroup ),
    m_pContext (NULL) {
}

CXOverCmd::~CXOverCmd( ) {
}

CIOWriteAsyncComplete*
CXOverCmd::FirstBuffer(
            BYTE *lpb,
            int cb,
            ClientContext& context,
            CLogCollector*  pCollector
            )
{

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
        _ASSERT( m_Completion.m_lpb == 0 ) ;
        _ASSERT( m_Completion.m_cb == 0 ) ;
    _ASSERT (m_pContext != NULL);

    static  char    szStart[] = "224 Overview information follows\r\n"  ;

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    context.m_nrcLast = nrcXoverFollows ;
        m_Completion.m_cbPrefix = sizeof( szStart ) - 1 ;
        cb -= m_Completion.m_cbPrefix ;
        lpb += m_Completion.m_cbPrefix ;

        m_Completion.m_lpb = lpb ;
        m_Completion.m_cb = cb - 3 ;

    //
    // This FillBuffer doesn't need to be wrapped in a loop as there's
    // data in the buffer already and we can let the protocol's completion
    // fire and call NextBuffer
    //

    m_Completion.InitFillBufferRefs();

        m_pGroup->FillBuffer(
                                        &context.m_securityCtx,
                                        &context.m_encryptCtx,
                                        m_Completion
                                        ) ;

        return  &m_Completion ;

#if 0
    if( cb < sizeof( szStart ) ) {
        return  0 ;
    }
#endif

    /*
    if( pCollector ) {
        pCollector->FillLogData( LOG_TARGET, lpb, 4 ) ;
    }
    */

}

CIOWriteAsyncComplete*
CXOverCmd::NextBuffer(
    BYTE *lpb,
    int cb,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    ENTER("CXOverCmd::NextBuffer")

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
        _ASSERT( m_Completion.m_lpb == 0 ) ;
        _ASSERT( m_Completion.m_cb == 0 ) ;
    _ASSERT (m_pContext != NULL);

    //
    // reserve space for \r\n
    //
    _ASSERT( cb > 2 ) ;

    do {
        m_Completion.InitFillBufferRefs();
            m_Completion.m_lpb = lpb ;
            m_Completion.m_cb = cb - 3 ;
            m_Completion.m_cbPrefix = 0 ;


            m_pGroup->FillBuffer(
                                        &context.m_securityCtx,
                                        &context.m_encryptCtx,
                                        m_Completion
                                        );
        } while (m_Completion.ReleaseFillBufferRef());

        return  &m_Completion ;

}

CIOExecute*
CSearchFieldsCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&        pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter("CSearchFieldsCmd::make");

    CSearchFieldsCmd   *pSearchFieldsCmd;

    // make sure the command syntax is proper
    if (argc != 2) {
        DebugTrace(0, "wrong number of arguments passed into LIST SRCHFIELDS");
        context.m_return.fSet(nrcSyntaxError);
        pExecute = new (context) CErrorCmd(context.m_return);
        return 0;
    }

    pSearchFieldsCmd = new(context) CSearchFieldsCmd();
    if (pSearchFieldsCmd == 0) {
        ErrorTrace(0, "Cannot allocate CSearchFieldsCmd\n");
        context.m_return.fSet(nrcServerFault);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    pSearchFieldsCmd->m_iSearchField = 0;

    pExecute = (CExecute*)pSearchFieldsCmd;
    return 0;
}

CSearchFieldsCmd::CSearchFieldsCmd() {
}

CSearchFieldsCmd::~CSearchFieldsCmd() {
}

int CSearchFieldsCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{
    TraceFunctEnter("CSearchFieldsCmd::Execute");

    DWORD cbOut;
    char szStart[] = "224 Data Follows\r\n";

    context.m_nrcLast = nrcXoverFollows ;

    _ASSERT(lpb != 0);
    _ASSERT(cb != 0);
    _ASSERT(fComplete == FALSE);

    _ASSERT(cb > sizeof(szStart));
    memcpy(lpb, szStart, sizeof(szStart));
    cbOut = sizeof(szStart) - 1;

    return cbOut;
}

int
CSearchFieldsCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("CSearchFieldsCmd::PartialExecute");

    char szEnd[] = ".";
    DWORD cbOut = 0;

    while (!fComplete) {
        char *szFieldName = GetSearchHeader(m_iSearchField);

        // if we get back a NULL then we've listed then all, put the .
        if (szFieldName == NULL) {
            szFieldName = szEnd;
            fComplete = TRUE;
        }

        // make sure there is enough space to write the current fieldname
        DWORD cFieldName = strlen(szFieldName);
        if (cFieldName + 2 > (cb - cbOut)) {
            fComplete = FALSE;
            return cbOut;
        }

        m_iSearchField++;

        memcpy(lpb + cbOut, szFieldName, cFieldName);
        lpb[cbOut + cFieldName] = '\r';
        lpb[cbOut + cFieldName + 1] = '\n';
        cbOut += cFieldName + 2;
    }

    return cbOut;
}

CIOExecute*
COverviewFmtCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&        pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter("COverviewFmtCmd::make");

    COverviewFmtCmd   *pOverviewFmtCmd;

    // make sure the command syntax is proper
    if (argc != 2) {
        DebugTrace(0, "wrong number of arguments passed into LIST OVERVIEW.FMT");
        context.m_return.fSet(nrcSyntaxError);
        pExecute = new (context) CErrorCmd(context.m_return);
        return 0;
    }

    pOverviewFmtCmd = new(context) COverviewFmtCmd();
    if (pOverviewFmtCmd == 0) {
        ErrorTrace(0, "Cannot allocate COverviewFmtCmd\n");
        context.m_return.fSet(nrcServerFault);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    pExecute = (CExecute*)pOverviewFmtCmd;
    return 0;
}

COverviewFmtCmd::COverviewFmtCmd() {
}

COverviewFmtCmd::~COverviewFmtCmd() {
}

int COverviewFmtCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{
    TraceFunctEnter("COverviewFmtCmd::Execute");

    DWORD cbOut;
    char szOverviewFmt[] = "215 Order of fields in overview database.\r\n"
                                                   "Subject:\r\n"
                                                   "From:\r\n"
                                                   "Date:\r\n"
                                                   "Message-ID:\r\n"
                                                   "References:\r\n"
                                                   "Bytes:\r\n"
                                                   "Lines:\r\n"
                                                   "Xref:full\r\n"
                                                   ".\r\n";

    context.m_nrcLast = nrcListGroupsFollows;

    _ASSERT(lpb != 0);
    _ASSERT(cb != 0);
    _ASSERT(fComplete == FALSE);

    _ASSERT(cb > sizeof(szOverviewFmt));
    memcpy(lpb, szOverviewFmt, sizeof(szOverviewFmt));
    cbOut = sizeof(szOverviewFmt) - 1;

        fComplete = TRUE;

    return cbOut;
}

int
COverviewFmtCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("COverviewFmtCmd::PartialExecute");

        // everything is in StartExecute
        _ASSERT(FALSE);

    return 0;
}

LPMULTISZ
ConditionArgsForSearch(
                int cArgs,
                char**  argv,
                BOOL    fZapCommas ) {
/*++

Routine Description :

    Convert argc, argv arguments into a MULTI_SZ
    The cnversion is done in place.   All argv pointers must be in a contiguous buffer.

Arguemtns :

    cArgs - Number of arguments
    argv -  Argument array
    fZapCommas - convert commas to NULLS

Return Value :

    Pointer to MULTI_SZ

--*/

    //
    //  This function takes an argc,argv set of arguments and converts them
    //  to a MULTI_SZ with a single NULL between strings and 2 NULLs at the end.
    //
    //

    char*   pchComma = 0 ;
    char*   pchEnd = argv[cArgs-1] + lstrlen( argv[cArgs-1] ) + 1 ;
    int     c = 0 ;
    for( char*  pch = argv[0], *pchDest = pch; pch < pchEnd; pch ++, pchDest++ ) {
        if( fZapCommas && *pch == ',' ) {
            for( pchComma = pch; *pchComma == ','; pchComma ++ )
                *pchComma = '\0' ;
        }
        if( (*pchDest = *pch) == '\0' ) {
            while( pch[1] == '\0' && pch < pchEnd )     pch++ ;
        }
    }
    *pchDest++ = '\0' ;
    *pchDest++ = '\0' ;

    //
    //  Rebuild the argc argv structure - !
    //
    for( int i=1; i<cArgs; i++ ) {
        argv[i] = argv[i-1]+lstrlen(argv[i-1])+1 ;
    }
    return  argv[0] ;
}

CSearchAsyncComplete::CSearchAsyncComplete() {
}

CSearchCmd::CSearchCmd(const CGRPPTR& pGroup, CHAR* pszSearchString) :
        m_pGroup(pGroup),
        m_pszSearchString(pszSearchString),
        m_VRootList(&CSearchVRootEntry::m_pPrev, &CSearchVRootEntry::m_pNext),
        m_VRootListIter(&m_VRootList),
        m_pSearch(NULL),
        m_pSearchResults(NULL) {
}

CSearchCmd::~CSearchCmd() {
        if (m_pszSearchString)
                XDELETE m_pszSearchString;
        if (m_pSearch)
                m_pSearch->Release();
        if (m_pSearchResults)
                m_pSearchResults->Release();

        TFList<CSearchVRootEntry>::Iterator it(&m_VRootList);
        while (!it.AtEnd()) {
                CSearchVRootEntry *pEntry = it.Current();
                CNNTPVRoot *pRoot = pEntry->m_pVRoot;
                it.RemoveItem();
                pRoot->Release();
                delete pEntry;
        }

}

CIOExecute*
CSearchCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&        pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter("CSearchCmd::make");

    CSearchCmd   *pSearchCmd;
    int i;
    BOOL fInPresent;
    HRESULT hr;

    InterlockedIncrementStat( (context.m_pInstance), SearchCommands );

    //
    // make sure they passed the correct number of args
    //
    if (argc < 2) {
        DebugTrace(0, "SEARCH command received with no args\n");
        context.m_return.fSet(nrcSyntaxError);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

        //
    // See if the "IN" clause has been specified.  If it hasn't, then
    // we have to point to a newsgroup. (Per the spec, IN must be the
    // first word following SEARCH)
    //

    fInPresent = (_stricmp("IN", argv[1]) == 0);

    if (!fInPresent && context.m_pCurrentGroup == 0) {
        ErrorTrace(0, "No current group selected\n");
        context.m_return.fSet(nrcNoGroupSelected);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    //
    // See if there are any available atq threads.  If we don't
    // have a couple laying around, then fail as we might deadlock waiting
    // for a completion.
    //

    if (AtqGetInfo(AtqAvailableThreads) < 1) {
                ErrorTrace(0, "Server too busy");
                context.m_return.fSet(nrcErrorPerformingSearch);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    ConditionArgsForSearch(argc, argv, FALSE);

    //
    // change argv[1] to have the entire query string by converting 0s into
    // ' 's
    //
    for (i = 1; i < argc - 1; i++)
        *((argv[i + 1]) - 1) = ' ';

        CHAR *pszSearchString =  XNEW CHAR[strlen(argv[1]) + 1];
        if (pszSearchString == NULL) {
                ErrorTrace(0, "Could not allocate search string");
                context.m_return.fSet(nrcServerFault);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

        lstrcpy (pszSearchString, argv[1]);

    pSearchCmd = new(context) CSearchCmd(context.m_pCurrentGroup, pszSearchString);
    if (pSearchCmd == 0) {
        ErrorTrace(0, "Cannot allocate CSearchCmd\n");
        XDELETE pszSearchString;
        context.m_return.fSet(nrcServerFault);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    // Save off the list of VRoots.  If fInPresent, then we have to
    // go through all of the VRoots.  Otherwise, only add the current
    // group's VRoot

        if (fInPresent) {
                // "IN" was specified, so all indexed groups should be searched.
                // Enumerate the list of VRoots and add them to the table.
                CNNTPVRootTable *pVRootTable = context.m_pInstance->GetVRTable();
                pVRootTable->EnumerateVRoots(pSearchCmd, VRootCallback);
        } else {
                // No "IN", so only search the current group.  Fake up the callback
                // to add it to the list
                CNNTPVRoot* pVRoot = context.m_pCurrentGroup->GetVRoot();
                VRootCallback(pSearchCmd, pVRoot);
                pVRoot->Release();
        }

    pExecute = (CExecute*)pSearchCmd;
        return 0;

}

void
CSearchCmd::VRootCallback(void *pContext, CVRoot *pVRoot) {

        TraceQuietEnter ("CSearchCmd::VRootCallback");

        HRESULT hr;

        CSearchCmd *pThis = (CSearchCmd *)pContext;
        CNNTPVRoot *pNNTPVRoot = (CNNTPVRoot *)pVRoot;

        // If the VRoot isn't indexed, no reason to do anything...
        if (!pNNTPVRoot->IsContentIndexed())
                return;

        // See if the driver for this VRoot implements the search interface
        // Note that pDriver isn't AddRef()ed, so we don't have to release it.
        INntpDriver *pDriver = pNNTPVRoot->GetDriver();
        if (!pDriver) {
                ErrorTrace((DWORD_PTR)pContext, "Could not locate driver for vroot");
                return;
        }

        INntpDriverSearch *pSearch=NULL;
        hr = pDriver->QueryInterface(IID_INntpDriverSearch, (VOID**)&pSearch);
        if (FAILED(hr)) {
                if (hr == E_NOINTERFACE) {
                        DebugTrace((DWORD_PTR)pContext, "Driver does not implement search");
                } else {
                        ErrorTrace((DWORD_PTR)pContext, "Could not QI for INntpDriverSearch, %x", hr);
                }
                return;
        }

        // Walk the list of VRoots to see if the driver thinks that
        // they are the same as one that's already been seen.

        TFList<CSearchVRootEntry>::Iterator it(&pThis->m_VRootList);
        BOOL fFound = FALSE;
        while (!it.AtEnd()) {
                CSearchVRootEntry *pTestEntry = it.Current();
                CNNTPVRoot *pTestVRoot = pTestEntry->m_pVRoot;
                _ASSERT(pTestVRoot);
                if (pTestVRoot == NULL)
                        continue;
                INntpDriver *pTestDriver = pTestVRoot->GetDriver();
                _ASSERT (pTestDriver);
                if (!pTestDriver) {
                        ErrorTrace((DWORD_PTR)pContext, "Could not locate driver for vroot");
                        continue;
                }

                INntpDriverSearch *pTestSearch=NULL;
                hr = pDriver->QueryInterface(IID_INntpDriverSearch, (VOID**)&pTestSearch);
                _ASSERT(SUCCEEDED(hr));
                if (FAILED(hr))
                        continue;

                fFound = pTestSearch->UsesSameSearchDatabase(pSearch, NULL);
                pTestSearch->Release();
                if (fFound) {
                        DebugTrace((DWORD_PTR)pContext, "Driver already on list");
                        break;
                }

                it.Next();
        }


        if (!fFound) {
                CSearchVRootEntry *pVRootEntry = new CSearchVRootEntry(pNNTPVRoot);
                _ASSERT(pVRootEntry);
                if (pVRootEntry) {
                        pNNTPVRoot->AddRef();
                        pThis->m_VRootList.PushBack(pVRootEntry);
                } else {
                        // All we can do is skip the entry and move on.
                        ErrorTrace((DWORD_PTR)pContext, "Could not allocate vroot ptr");
                }
        }

        // That's all
        pSearch->Release();

}

int CSearchCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{

        HRESULT hr;

    TraceFunctEnter("CSearchCmd::StartExecute");

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT(fComplete == FALSE);
    _ASSERT(m_pSearch == NULL);

        //
        //      Prefer to use the SSL based hToken !
        //
        BOOL fAnonymous = FALSE;
        HANDLE hImpersonate = context.m_encryptCtx.QueryCertificateToken();
        if(hImpersonate == NULL) {
                hImpersonate = context.m_securityCtx.QueryImpersonationToken() ;
                fAnonymous = context.m_securityCtx.IsAnonymous();
        }

        m_cMaxSearchResults = context.m_pInstance->GetMaxSearchResults();

        m_VRootListIter.ResetHeader(&m_VRootList);

        GetNextSearchInterface (hImpersonate, fAnonymous);

    static const char szStart[] = "224 Overview information follows\r\n"  ;

        //      Put out the response code.
    context.m_nrcLast = nrcXoverFollows ;

    DWORD cbRtn = 0;

        // starting to send data
        CopyMemory((char*) lpb, szStart, sizeof(szStart) - 1);
        cbRtn += sizeof(szStart) - 1;

    return cbRtn;
}

int
CSearchCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("CSearchCmd::PartialExecute");

        //
        //      Prefer to use the SSL based hToken !
        //
        BOOL fAnonymous = FALSE;
        HANDLE hImpersonate = context.m_encryptCtx.QueryCertificateToken();
        if(hImpersonate == NULL) {
                hImpersonate = context.m_securityCtx.QueryImpersonationToken() ;
                fAnonymous = context.m_securityCtx.IsAnonymous();
        }

    int cbRtn = 0;                  // number of bytes we've added to lpb

    BOOL fBufferFull = FALSE;
    fComplete = FALSE;
    HRESULT hr;

        //
        // Since this is a Sync event, we'll increase the number of runnable
        // threads in the Atq pool.
        //
        AtqSetInfo(AtqIncMaxPoolThreads, NULL);

    while (!fComplete && !fBufferFull) {
        _ASSERT(m_iResults <= m_cResults);

        //
        // get some data from Search if we don't have anything to send
        //
        if (m_iResults == m_cResults && m_fMore) {
            HRESULT hr;

            // otherwise there is more to get, go get it
            m_iResults = 0;
            DWORD cResults = MAX_SEARCH_RESULTS;

                        CNntpSyncComplete scComplete;

            m_pSearchResults->GetResults(
                &cResults,
                &m_fMore,
                m_pwszGroupName,        //array of names,
                m_pdwArticleID,         //array of ids,
                &scComplete,                    // Completion object
                hImpersonate,           // hToken
                fAnonymous,                     // fAnonymous
                NULL);                          // Context

                        _ASSERT(scComplete.IsGood());
                        hr = scComplete.WaitForCompletion();

            m_cResults = cResults;
            m_cMaxSearchResults -= cResults;

            // check for Search failure
            if (FAILED(hr)) {
                // if we fail here then the best we can do is truncate the
                // list we return
                hr = GetNextSearchInterface(hImpersonate, fAnonymous);
                if (hr != S_OK) {
                        if (cb - cbRtn > 3) {
                                                CopyMemory(lpb + cbRtn, StrTermLine, 3);
                                                cbRtn += 3;
                                                fComplete = TRUE;
                                        } else {
                                                fBufferFull = TRUE;
                                        }
                }
                continue;
            }
        }

        // check to see if we are out of results
        if (!m_fMore && m_iResults == m_cResults) {
                hr = GetNextSearchInterface(hImpersonate, fAnonymous);
            if (hr != S_OK) {
                if (cb - cbRtn > 3) {
                        CopyMemory(lpb + cbRtn, StrTermLine, 3);
                        cbRtn += 3;
                        fComplete = TRUE;
                } else {
                                        fBufferFull = TRUE;
                }
            }
            continue;
        }

        // convert Unicode group name to ASCII (errr, make that UTF8)
        char *szNewsgroup = (char *) lpb + cbRtn;
        // Note, first arg was changed from CP_ACP to CP_UTF8
        // (code page ascii->utf8)
        int cNewsgroup = WideCharToMultiByte(CP_UTF8, 0,
                m_pwszGroupName[m_iResults], -1,
            szNewsgroup, cb - cbRtn, NULL, NULL) - 1;
        // check to see if it could fit
        if (cNewsgroup <= 0) {
            _ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);
            fBufferFull = TRUE;
            continue;
        }
        // we also need to fit the : and still leave room for .\r\n
        if (cb <= (cbRtn + cNewsgroup + 1 + 3)) {
            fBufferFull = TRUE;
            continue;
        }

        // this is a \0 now, it will be converted into a colon in a few lines
        char *szColon = szNewsgroup + cNewsgroup;
        cbRtn += cNewsgroup + 1; // name of newsgroup + colon

        DWORD dwArticleID = m_pdwArticleID[m_iResults];

        // get the group object for this newsgroup
        CGRPPTR pGroup = (context.m_pInstance)->GetTree()->GetGroup(szNewsgroup, cNewsgroup+1);

                if (pGroup != NULL &&
            dwArticleID >= pGroup->GetFirstArticle() &&
            dwArticleID <= pGroup->GetLastArticle())
        {
                        // we set fDoTest to FALSE, since Tripoli already does the ACL
                        // tests for us, and it would be wasteful to do them again.
                        // BUGBUG - this means that we might miss tests with the
                        // hCertToken
                        if (!pGroup->IsGroupAccessible(context.m_securityCtx,
                                                                           context.m_encryptCtx,
                                                   context.m_IsSecureConnection,
                                                                                   FALSE,
                                                                                   FALSE))
                        {
                                // if this group requires SSL and this client doesn't have
                                // SSL then don't show them this article information
                cbRtn -= cNewsgroup + 1;
                        } else {
                // convert \0 to a colon
                *szColon = ':';

                    // get XOVER data...

                                CSearchAsyncComplete scComplete;
                                CNntpSyncComplete asyncComplete;

                                scComplete.m_currentArticle = dwArticleID;
                                scComplete.m_lpb = lpb + cbRtn;
                                scComplete.m_cb = cb - cbRtn - 3;               // Room for the ".\r\n"
                                _ASSERT(cb - cbRtn - 3 > 0);
                                scComplete.m_cbTransfer = 0;
                                scComplete.m_pComplete = &asyncComplete;

                                //
                                // Set vroot to the completion object
                                //
                                CNNTPVRoot *pVRoot = pGroup->GetVRoot();
                                asyncComplete.SetVRoot( pVRoot );

                                pGroup->FillBuffer (
                                        &context.m_securityCtx,
                                        &context.m_encryptCtx,
                                        scComplete);

                                // wait for it to complete
                                _ASSERT( asyncComplete.IsGood() );
                                hr = asyncComplete.WaitForCompletion();

                                pVRoot->Release();

                    if (scComplete.m_cbTransfer == 0) {
                                        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                                // we ran out of buffer space...
                                cbRtn -= cNewsgroup + 1;
                                fBufferFull = TRUE;
                                continue;
                                        } else {
                                                // this doesn't have an entry, so don't return it to the
                                                // user
                                cbRtn -= cNewsgroup + 1;
                                        }
                    } else {
                        cbRtn += scComplete.m_cbTransfer;
                    }
                        }
        } else {
            // the newsgroup object doesn't exist.  this could happen if a
            // newsgroup was deleted, but the index still reflects articles
            // in it.
            // our solution: don't send any index information to the client
            // for this message
            cbRtn -= cNewsgroup + 1;
        }


        // say that we saw this article
        m_iResults++;
    }


        // Return the number of Atq threads back to what it was before we started
        AtqSetInfo(AtqDecMaxPoolThreads, NULL);

    return  cbRtn;
}

HRESULT
CSearchCmd::GetNextSearchInterface(HANDLE hImpersonate, BOOL fAnonymous) {

    TraceFunctEnter("CSearchCmd::GetNextSearchInterface");

    HRESULT hr = S_FALSE;                               // Default to no interfaces left

    m_iResults = 0;
    m_cResults = 0;
    m_fMore = FALSE;

        // MakeSearchQuery trashes the search string, so we need to make a copy of it.
    char *pszSearchString = XNEW char[strlen(m_pszSearchString)+1];
    if (pszSearchString == NULL) {
        ErrorTrace((DWORD_PTR)this, "Could not allocate search string");
                TraceFunctLeave();
        return E_OUTOFMEMORY;
    }

        while (!m_VRootListIter.AtEnd()) {
                CSearchVRootEntry *pVRootEntry = m_VRootListIter.Current();
                CNNTPVRoot *pNNTPVRoot = pVRootEntry->m_pVRoot;
                m_VRootListIter.Next();
                INntpDriver *pDriver = pNNTPVRoot->GetDriver();
                if (pDriver == NULL)
                        continue;

                WCHAR wszColumns[] = L"newsgroup,newsarticleid";

                // If we are holding pointers to the old search interfaces, release them.
                if (m_pSearch) {
                        m_pSearch->Release();
                        m_pSearch = NULL;
                }
                if (m_pSearchResults) {
                        m_pSearchResults->Release();
                        m_pSearchResults = NULL;
                }

                hr = pDriver->QueryInterface(IID_INntpDriverSearch, (VOID**)&m_pSearch);

                if (FAILED(hr)) {
                        if (hr == E_NOINTERFACE)
                                DebugTrace((DWORD_PTR)this, "This driver doesn't support search");
                        else
                                ErrorTrace((DWORD_PTR)this, "Could not QI INntpDriverSearch, %x", hr);
                        continue;
                }

                CNntpSyncComplete scComplete;

                lstrcpy (pszSearchString, m_pszSearchString);

            INNTPPropertyBag *pPropBag = NULL;

        if (m_pGroup) {
                // Note: The property bag is released by the driver
                pPropBag = m_pGroup->GetPropertyBag();
                scComplete.BumpGroupCounter();
                    if ( NULL == pPropBag ) {
                    ErrorTrace( 0, "Get group property bag failed" );
                                m_pSearch->Release();
                                m_pSearch = NULL;
                        continue;
                }
        }

            //
            // Since this is a Sync event, we'll increase the number of runnable
            // threads in the Atq pool.
            //
            AtqSetInfo(AtqIncMaxPoolThreads, NULL);

                m_pSearch->MakeSearchQuery (
                        pszSearchString,
                        pPropBag,
                        TRUE,                                   // Deep Query
                        wszColumns,                             // Columns to return
                        wszColumns,                             // Sort order
                        GetSystemDefaultLCID(), // Locale
                        m_cMaxSearchResults,    // max rows
                        hImpersonate,                   // hToken
                        fAnonymous,                             // fAnonymous
                        &scComplete,                    // INntpComplete *pICompletion
                        &m_pSearchResults,              // INntpSearch *pINntpSearch
                        NULL                                    // LPVOID lpvContext
                        );

                _ASSERT(scComplete.IsGood());
                hr = scComplete.WaitForCompletion();

            // Reset the number of threads
            AtqSetInfo(AtqDecMaxPoolThreads, NULL);

                if (FAILED(hr)) {
                        ErrorTrace((DWORD_PTR)this, "Error calling MakeSearchQuery, %x", hr);
                        m_pSearch->Release();
                        m_pSearch = NULL;
                        continue;
                }

                m_fMore = TRUE;
                break;

    }

        XDELETE pszSearchString;
    TraceFunctLeave();
        return hr;
}

CXpatAsyncComplete::CXpatAsyncComplete() {

}

CIOExecute* CXPatCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&        pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter("CXPatCmd::make");

    CXPatCmd   *pXPatCmd;
    int i;

    InterlockedIncrementStat( (context.m_pInstance), XPatCommands );

    //
    // make sure they have selected a newsgroup
    //
    if (context.m_pCurrentGroup == NULL) {
        DebugTrace(0, "XPAT command received with no current group\n");
        context.m_return.fSet(nrcNoGroupSelected);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

    //
    // make sure they passed enough arguments
    //
    if (argc < 4) {
        DebugTrace(0, "not enough arguments passed into XPAT");
        context.m_return.fSet(nrcSyntaxError);
        pExecute = new (context) CErrorCmd(context.m_return);
        return 0;
    }

    ConditionArgsForSearch(argc, argv, FALSE);

    //
    // change argv[1] to have the entire query string by converting 0s into
    // ' 's
    //
    for (i = 1; i < argc - 1; i++)
        *((argv[i + 1]) - 1) = ' ';


        CHAR *pszSearchString =  XNEW CHAR[strlen(argv[1]) + 1];
        if (pszSearchString == NULL) {
                ErrorTrace(0, "Could not allocate search string");
                context.m_return.fSet(nrcServerFault);
        pExecute = new(context) CErrorCmd(context.m_return);
        return 0;
    }

        lstrcpy (pszSearchString, argv[1]);

        //
        // get a 0 after argv[1] and argv[2]
        //
        *(argv[2] - 1) = 0;
        *(argv[3] - 1) = 0;
        char *szMessageIDArg = argv[2];
        if (*szMessageIDArg == '<') {
            GROUPID GroupID;
            ARTICLEID ArticleID;
            CGRPPTR pGroup;
            // make sure the message ID exists...if not we need to
            // report an error
            if (!CheckMessageID(szMessageIDArg, context, &GroupID,
                               &ArticleID, &pGroup))
            {
                DebugTrace(0, "unknown message ID passed into XPAT");
                XDELETE pszSearchString;
                context.m_return.fSet(nrcNoSuchArticle);
                pExecute = new (context) CErrorCmd(context.m_return);
                return 0;
            }
        } else {
            szMessageIDArg = NULL;
        }

    HRESULT hr;
        CNNTPVRoot *pNNTPVRoot = NULL;
        INntpDriver *pDriver = NULL;
        INntpDriverSearch *pDriverSearch = NULL;
        INntpSearchResults *pSearchResults = NULL;
        DWORD dwLowArticleID, dwHighArticleID;

        //
        //      Prefer to use the SSL based hToken !
        //
        BOOL fAnonymous = FALSE;
        HANDLE hImpersonate = context.m_encryptCtx.QueryCertificateToken();
        if(hImpersonate == NULL) {
                hImpersonate = context.m_securityCtx.QueryImpersonationToken() ;
                fAnonymous = context.m_securityCtx.IsAnonymous();
        }

        //
        // Grab the vroot for the group and perform the query
        //

        pNNTPVRoot = context.m_pCurrentGroup->GetVRoot();
        pDriver = pNNTPVRoot->GetDriver();
        _ASSERT(pDriver);
        if (pDriver == NULL) {
                DebugTrace(0, "Could not locate driver for vroot");
                pNNTPVRoot->Release();
                XDELETE pszSearchString;
                context.m_return.fSet(nrcServerFault);
                pExecute = new (context) CErrorCmd(context.m_return);
                return 0;
        }

        pNNTPVRoot->Release();

        hr = pDriver->QueryInterface(IID_INntpDriverSearch, (VOID**)&pDriverSearch);
        if (FAILED(hr)) {
                if (hr == E_NOINTERFACE) {
                        DebugTrace(0, "This driver doesn't support xpat");
                } else {
                        ErrorTrace(0, "Could not QI INntpDriverSearch, %x", hr);
                }

                XDELETE pszSearchString;
                context.m_return.fSet(nrcServerFault);
                pExecute = new (context) CErrorCmd(context.m_return);
                return 0;

        }

        CNntpSyncComplete scComplete;
        WCHAR wszColumns[] = L"newsgroup,newsarticleid";

        // Note:  The property bag is released by the driver
    INNTPPropertyBag *pPropBag = context.m_pCurrentGroup->GetPropertyBag();
    scComplete.BumpGroupCounter();

        //
        // Since this is a Sync event, we'll increase the number of runnable
        // threads in the Atq pool.
        //
        AtqSetInfo(AtqIncMaxPoolThreads, NULL);

        pDriverSearch->MakeXpatQuery(
                pszSearchString,
                pPropBag,
                TRUE,                                   // Deep Query
                wszColumns,                             // Columns to return
                wszColumns,                             // Sort order
                GetSystemDefaultLCID(), // Locale
                context.m_pInstance->GetMaxSearchResults(),     // max rows
                hImpersonate,                   // hToken
                fAnonymous,                             // fAnonymous
                &scComplete,                    // INntpComplete *pICompletion
                &pSearchResults,                // INntpSearch *pINntpSearch,
                &dwLowArticleID,                // Low article ID
                &dwHighArticleID,               // High article ID
                NULL                                    // Context
                );

        _ASSERT(scComplete.IsGood());
        hr = scComplete.WaitForCompletion();

        // Restore number of threads
    AtqSetInfo(AtqDecMaxPoolThreads, NULL);

        XDELETE pszSearchString;

        if (FAILED(hr)) {
                // Make the Low higher than High to force StartExecute to
                // output an empty results set
                dwLowArticleID = 9;
                dwHighArticleID = 0;
        }

        //
        // allocate the CXPatCmd object
        //
        pXPatCmd = new(context) CXPatCmd(pDriverSearch, pSearchResults);
        if (pXPatCmd == 0) {
                ErrorTrace(0, "Cannot allocate CXPatCmd\n");
                pDriverSearch->Release();
                pSearchResults->Release();
                context.m_return.fSet(nrcServerFault);
                pExecute = new(context) CErrorCmd(context.m_return);
                return 0;
        }

    //
    // the header to search is the first supplied argument
    // (assumes cmd buffer hangs around)
    pXPatCmd->m_szHeader = argv[1];
    pXPatCmd->m_szMessageID = szMessageIDArg;

        pXPatCmd->m_dwLowArticleID = dwLowArticleID;
        pXPatCmd->m_dwHighArticleID = dwHighArticleID;

        pExecute = (CExecute*)pXPatCmd;

        return(0);
}

CXPatCmd::CXPatCmd(INntpDriverSearch *pDriverSearch,
        INntpSearchResults *pSearchResults) :
        m_pSearch(pDriverSearch),
        m_pSearchResults(pSearchResults),
        m_iResults(0),
        m_cResults(0),
        m_fMore(TRUE),
        m_szHeader(NULL),
        m_szMessageID(NULL)     {
        }


CXPatCmd::~CXPatCmd() {
        if (m_pSearch)
                m_pSearch->Release();
        if (m_pSearchResults)
                m_pSearchResults->Release();
}

int CXPatCmd::StartExecute(
            BYTE *lpb,
            int cb,
            BOOL &fComplete,
            void *&pv,
            ClientContext& context,
            CLogCollector*  pCollector)
{
    TraceFunctEnter("CXPatCmd::Execute");

        static const char szStart[] = "221 Headers follow\r\n";
        static const char szNoResults[] = "221 Headers follow\r\n.\r\n";

    _ASSERT(lpb != 0);
    _ASSERT(cb != 0);
    _ASSERT(fComplete == FALSE);

        //      Put out the response code.
        context.m_nrcLast = nrcHeadFollows ;

        DWORD cbRtn = 0;

        // starting to send data
        if (m_dwLowArticleID <= m_dwHighArticleID) {
            _ASSERT(m_pSearch != NULL);
        _ASSERT(m_pSearchResults != NULL);
                CopyMemory((char*) lpb, szStart, sizeof(szStart) - 1);
                cbRtn += sizeof(szStart) - 1;
        } else {
                CopyMemory((char*) lpb, szNoResults, sizeof(szNoResults) - 1);
                cbRtn += sizeof(szNoResults) - 1;
                fComplete = TRUE;
        }

        return cbRtn;

}

//
// this is shared for XPAT and XHDR.  Given a group, article ID, and
// desired header, it prints the article ID and header to lpb.  returns
// the number of bytes written.  If the message ID is given it prints
// the message ID and selected header (it still uses group and article ID
// to find the data).
//
// returns 0 if there isn't enough buffer space for the article, -1
// if the article doesn't exist.
//

int CXPatCmd::GetArticleHeader(CGRPPTR pGroup,
                     DWORD dwArticleID,
                     char *szHeader,
                     ClientContext& context,
                     BYTE *lpb,
                     int cb)
{

        TraceQuietEnter("CXPatCmd::GetArticleHeader");

        int cbOut = 0;
        HRESULT hr;

        // :Text is a special case
        if (_stricmp(szHeader, ":Text") == 0) {
                if (cb > 20) {
                        _itoa(dwArticleID, (char *) lpb, 10);
                        cbOut = lstrlen((char *) lpb);
                        CopyMemory(lpb + cbOut, " TEXT\r\n", 7);
                        cbOut += 7;
                } else {
            SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
            return 0;
                }

                return cbOut;

        }

        // Not :Text, so we call the xhdr code to move the fetch the data.

        CXpatAsyncComplete scComplete;
        CNntpSyncComplete asyncComplete;

        scComplete.m_currentArticle = dwArticleID;
        scComplete.m_lpb = lpb;
        scComplete.m_cb = cb - 3;               // Room for the ".\r\n"
        scComplete.m_cbTransfer = 0;
        scComplete.m_pComplete = &asyncComplete;
        scComplete.m_szHeader = szHeader;

        //
        // Set vroot to the completion object
        //
        CNNTPVRoot *pVRoot = pGroup->GetVRoot();
        asyncComplete.SetVRoot( pVRoot );

        pGroup->FillBuffer (
                &context.m_securityCtx,
                &context.m_encryptCtx,
                scComplete);

        // wait for it to complete
        _ASSERT( asyncComplete.IsGood() );
        hr = asyncComplete.WaitForCompletion();
        pVRoot->Release();

        // check out status and return it
        if (FAILED(hr)) SetLastError(hr);

        if (scComplete.m_cbTransfer > 0)
                return scComplete.m_cbTransfer;

        // we ran out of buffer space...
        if (GetLastError() == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                return 0;

        return -1;

}

int
CXPatCmd::PartialExecute(
    BYTE *lpb,
    int cb,
    BOOL &fComplete,
    void *&pv,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    TraceFunctEnter("CXPatCmd::PartialExecute");

        //
        //      Prefer to use the SSL based hToken !
        //
        BOOL fAnonymous = FALSE;
        HANDLE hImpersonate = context.m_encryptCtx.QueryCertificateToken();
        if(hImpersonate == NULL) {
                hImpersonate = context.m_securityCtx.QueryImpersonationToken() ;
                fAnonymous = context.m_securityCtx.IsAnonymous();
        }

    int cbRtn = 0;                  // number of bytes we've added to lpb

    // these point to the article id and group of the primary group, which
    // might not be our current newsgroup
    DWORD dwPriArticleID;           // article ID for the current row
    char szPriNewsgroup[MAX_PATH];  // newsgroup for the current row
    DWORD dwArticleID;              // article ID in this group
    BOOL fBufferFull = FALSE;

    fComplete = FALSE;

    _ASSERT(m_iResults <= m_cResults);

        //
        // Since this is a Sync event, we'll increase the number of runnable
        // threads in the Atq pool.
        //
        AtqSetInfo(AtqIncMaxPoolThreads, NULL);

    while (!fComplete && !fBufferFull) {
        //
        // get some data from Search if we don't have anything to send
        //
        if (m_iResults == m_cResults && m_fMore) {
            HRESULT hr;

            // otherwise there is more to get, go get it
            m_iResults = 0;
            DWORD cResults = MAX_SEARCH_RESULTS;

                        CNntpSyncComplete scComplete;

                        m_pSearchResults->GetResults(
                                &cResults,
                                &m_fMore,
                                m_pwszGroupName,
                                m_pdwArticleID,
                                &scComplete,
                                hImpersonate,
                                fAnonymous,
                                NULL
                                );

                        _ASSERT(scComplete.IsGood());
                        hr = scComplete.WaitForCompletion();

                        m_cResults = cResults;

            // check for Search failure
            if (FAILED(hr)) {
                // truncate the list
                m_cResults = 0;
                ErrorTrace(0, "GetResults failed, %x", hr);
                _ASSERT(FALSE);
                if (cb - cbRtn > 3) {
                    CopyMemory(lpb + cbRtn, StrTermLine, 3);
                    cbRtn += 3;
                    fComplete = TRUE;
                } else {
                    fBufferFull = TRUE;
                }
                continue;
            }
        }

        if (m_iResults == m_cResults && !m_fMore) {
            // there are no more results, put the .\r\n and return
            if (cb - cbRtn > 3) {
                CopyMemory(lpb + cbRtn, StrTermLine, 3);
                cbRtn += 3;
                fComplete = TRUE;
            } else {
                fBufferFull = TRUE;
            }
            continue;
        }

                // convert Unicode group name to UTF8
                if (WideCharToMultiByte(CP_UTF8, 0, m_pwszGroupName[m_iResults],
                        -1, szPriNewsgroup, sizeof(szPriNewsgroup), NULL, NULL) <= 0)
        {
            _ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);
            m_iResults++;
            continue;
        }

        // convert the filename to an article id
        dwPriArticleID = m_pdwArticleID[m_iResults];

        // if the article's primary group is not this group then find the
        // article ID for this group
        if (lstrcmp(szPriNewsgroup, context.m_pCurrentGroup->GetName()) != 0) {
            // we need to get the list of other groups that this article
            // was crossposted to
            CGRPPTR pPriGroup = 0;

            // get a pointer to the primary group
            pPriGroup = (context.m_pInstance)->GetTree()->
                            GetGroup(szPriNewsgroup, lstrlen(szPriNewsgroup)+1);
            if (pPriGroup == 0) {
                // this could happen if the tripoli cache was out of date
                m_iResults++;
                continue;
            }

            // get the list of crossposts
            DWORD cGroups = 10;
            DWORD cbGroupList = cGroups * sizeof(GROUP_ENTRY);
            PGROUP_ENTRY pGroupBuffer = XNEW GROUP_ENTRY[cGroups];
            if (pGroupBuffer == NULL) {
                // this isn't ideal, it will cause this article to not be
                // returned.  but its hard to do the right thing when you run
                // out of memory.
                _ASSERT(FALSE);
                m_iResults++;
                continue;
            }
            if (!(context.m_pInstance)->XoverTable()->GetArticleXPosts(
                    pPriGroup->GetGroupId(),
                    dwPriArticleID,
                    FALSE,
                    pGroupBuffer,
                    cbGroupList,
                    cGroups))
            {
                XDELETE pGroupBuffer;
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    // reallocate the buffer and try again
                    // GetArticleXPosts() sets cbGroupList to be the number
                    // of bytes required
                    cGroups = (cbGroupList / sizeof(GROUP_ENTRY));
                    pGroupBuffer = XNEW GROUP_ENTRY[cGroups];
                    if (pGroupBuffer == NULL) {
                        ASSERT(FALSE);
                        m_iResults++;
                        continue;
                    }
                    if (!(context.m_pInstance)->XoverTable()->GetArticleXPosts(
                        pPriGroup->GetGroupId(),
                        dwPriArticleID,
                        FALSE,
                        pGroupBuffer,
                        cbGroupList,
                        cGroups))
                    {
                        XDELETE pGroupBuffer;
                        m_iResults++;
                        continue;
                    }
                } else {
                    m_iResults++;
                    continue;
                }
            }

            // at this point pGroupBuffer has the information we need
            // find the current group in the group buffer
            DWORD iGroup;
            for (iGroup = 0; iGroup < cGroups; iGroup++) {
                if (pGroupBuffer[iGroup].GroupId ==
                    context.m_pCurrentGroup->GetGroupId())
                {
                    break;
                }
            }
            if (iGroup == cGroups) {
                // couldn't find the group.  this shouldn't happen.
                // _ASSERT(FALSE);
                // this can occur if XPAT searchs are done in control groups,
                // because the control group won't be listed in the
                // pGroupBuffer
                                XDELETE pGroupBuffer;
                m_iResults++;
                continue;
            }

            // get the article id for the current newsgroup
            dwArticleID = pGroupBuffer[iGroup].ArticleId;

                        XDELETE pGroupBuffer;
        } else {
            dwArticleID = dwPriArticleID;
        }

        // check to see if we are interested in this article ID
        if (dwArticleID >= m_dwLowArticleID && dwArticleID <= m_dwHighArticleID) {
            int x;
            // get the group object for this newsgroup
            CGRPPTR pGroup = context.m_pCurrentGroup;
            _ASSERT(pGroup != NULL);

            // format the output
            x = GetArticleHeader(pGroup, dwArticleID, m_szHeader,
                context, lpb + cbRtn, cb - cbRtn);

            if( x > 0 ) {
                m_iResults++;
                cbRtn += x;
            } else if (x == 0) {
                                fBufferFull = TRUE;
                        } else {
                                m_iResults ++;
                        }
        } else {
            // we don't need to return this article to the user, its out of
            // their supplied range
            m_iResults++;
        }
    }

        // Restore number of threads
        AtqSetInfo(AtqDecMaxPoolThreads, NULL);

        return cbRtn;
}



CXHdrAsyncComplete::CXHdrAsyncComplete()  :
    m_currentArticle( INVALID_ARTICLEID ),
    m_loArticle( INVALID_ARTICLEID ),
    m_hiArticle( INVALID_ARTICLEID ),
    m_lpb( 0 ),
    m_cb( 0 ),
    m_cbPrefix( 0 ) {
}

void
CXHdrAsyncComplete::Destroy()  {
/*++

Routine Description :

    This is called when our last reference goes away.
    We don't destruct ourselves at that point - instead
    we get ready for another round !

    NOTE : We cannot touch any members after calling the
        base classes Complete() function - as we can
        be re-entered for another operation !

Arguments :

    None.


Return Value :

    None

--*/

    if( SUCCEEDED(GetResult()) ) {

        if( m_currentArticle > m_hiArticle ) {
            m_fComplete = TRUE ;
            CopyMemory( m_lpb+m_cbTransfer, StrTermLine, 3 );
            m_cbTransfer += 3 ;
        }
        m_cbTransfer += m_cbPrefix ;
    }

    //
    //  When we reset our state we keep our Article Number
    //  and group info - but this buffer stuff is useless now
    //
    m_lpb = 0 ;
    m_cb = 0 ;
    //
    //  Call our base classes completion function ! -
    //  Note if we're note complete we pass TRUE so that
    //  the base class resets for another operation !
    //
    Complete( !m_fComplete ) ;
}

/*
CXHdrCmd::CXHdrCmd( LPSTR       lpstrHeader,
                    CGRPPTR     pGroup,
                    ARTICLEID   artidLow,
                    ARTICLEID   artidHigh ) :
    m_szHeader( lpstrHeader ),
    m_pGroup( pGroup ),
    m_loArticle( artidLow ),
    m_currentArticle( artidLow ),
    m_hiArticle( artidHigh )    {
}
*/
CXHdrCmd::CXHdrCmd( CGRPPTR&  pGroup ) :
    m_pGroup( pGroup )  {
}

CXHdrCmd::~CXHdrCmd( ) {
}

CIOExecute*
CXHdrCmd::make(
    int argc,
    char **argv,
    CExecutableCommand*&        pExecute,
    struct ClientContext& context,
    class   CIODriver&  driver
    )
{
    TraceFunctEnter( "CXHdrCmd::make" );
    InterlockedIncrementStat( (context.m_pInstance), XHdrCommands );
        NRC     code ;

    if( argc < 2 ) {
        context.m_return.fSet( nrcSyntaxError ) ;
        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return 0 ;
    }

    DWORD   loRange = 0;
    DWORD   hiRange = 0;

    if( context.m_pCurrentGroup != 0 ) {

        loRange = context.m_pCurrentGroup->GetFirstArticle() ;
        hiRange = context.m_pCurrentGroup->GetLastArticle() ;

        if( context.m_pCurrentGroup->GetArticleEstimate() == 0 ||
            loRange > hiRange ) {

            // If this is NOT a query by msg-id, return an error
            if( !( (argc == 3) && (argv[2][0] == '<') ) ) {
                context.m_return.fSet( nrcNoCurArticle ) ;
                pExecute = new( context ) CErrorCmd( context.m_return ) ;
                return 0 ;
            }
        }
    }

    CGRPPTR pGroup = context.m_pCurrentGroup ;

    if( pGroup && argc == 2 ) {

        if( context.m_idCurrentArticle != INVALID_ARTICLEID &&
            context.m_idCurrentArticle >= loRange ) {

            loRange = hiRange = context.m_idCurrentArticle ;

        }   else    {

            if( context.m_idCurrentArticle == INVALID_ARTICLEID )
                context.m_return.fSet( nrcNoCurArticle ) ;
            else
                context.m_return.fSet( nrcNoSuchArticle ) ;
            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return 0 ;
        }

    }   else    if( argc == 3 ) {

        if( argv[2][0] == '<' ) {

            ARTICLEID   artidPrimary ;
            GROUPID     groupidPrimary ;
            WORD        HeaderOffsetJunk ;
            WORD        HeaderLengthJunk ;

                        CStoreId storeid;

            if( (context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                    argv[2],
                                                    HeaderOffsetJunk,
                                                    HeaderLengthJunk,
                                                    artidPrimary,
                                                    groupidPrimary,
                                                                                                        storeid) ) {
                pGroup = (context.m_pInstance)->GetTree()->GetGroupById( groupidPrimary ) ;
                if( pGroup == 0 ) {
                    context.m_return.fSet( nrcServerFault ) ;
                    pExecute = new( context ) CErrorCmd( context.m_return ) ;
                    return 0 ;
                }

                // check client access (client could get xhdr info for ANY group)
                if( !pGroup->IsGroupAccessible(
                                    context.m_securityCtx,
                                                                context.m_encryptCtx,
                                    context.m_IsSecureConnection,
                                    FALSE,
                                    TRUE        ) ) {

                    context.m_return.fSet( nrcNoAccess ) ;
                    pExecute = new( context ) CErrorCmd( context.m_return ) ;
                    return 0 ;
                }

                hiRange = loRange = artidPrimary ;

            }   else if( GetLastError() == ERROR_FILE_NOT_FOUND )   {

                context.m_return.fSet( nrcNoSuchArticle ) ;
                pExecute = new( context ) CErrorCmd( context.m_return ) ;
                return 0 ;

            }   else    {

                context.m_return.fSet( nrcServerFault ) ;
                pExecute = new( context ) CErrorCmd( context.m_return ) ;
                return 0 ;

            }

        }   else    if( !pGroup || !GetCommandRange(    argc-1,
                                                                                                                &argv[1],
                                                                                                                &loRange,
                                                                                                                &hiRange,
                                                                                                                code
                                                                                                                ) ) {

            if( pGroup == 0 ) {
                context.m_return.fSet( nrcNoGroupSelected ) ;
            }
            else {
                context.m_return.fSet( nrcNoSuchArticle ) ;
            }

            pExecute = new( context ) CErrorCmd( context.m_return ) ;
            return 0 ;

        }

    }   else    {

        if( pGroup == 0 ) {
            context.m_return.fSet( nrcNoGroupSelected ) ;
        }
        else {
            context.m_return.fSet( nrcSyntaxError ) ;
        }

        pExecute = new( context ) CErrorCmd( context.m_return ) ;
        return  0 ;

    }

    _ASSERT( pGroup );

    CXHdrCmd*   pXHdrCmd = new( context )   CXHdrCmd( pGroup ) ;
    if ( NULL == pXHdrCmd ) {
        ErrorTrace( 0, "Can not allocate CXHdrCmd" );
        goto exit;
    }

    pXHdrCmd->m_Completion.m_currentArticle =
    pXHdrCmd->m_Completion.m_loArticle = loRange;
    pXHdrCmd->m_Completion.m_hiArticle = hiRange;
    pXHdrCmd->m_Completion.m_szHeader = argv[1];

exit:
    pExecute = pXHdrCmd ;
    return 0 ;
}

CIOWriteAsyncComplete*
CXHdrCmd::FirstBuffer(
            BYTE *lpb,
            int cb,
            ClientContext& context,
            CLogCollector*  pCollector
            )
{

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( m_Completion.m_lpb == 0 ) ;
    _ASSERT( m_Completion.m_cb == 0 ) ;

    static  char    szStart[] = "221 Xhdr information follows\r\n"  ;

    CopyMemory( (char*)lpb, szStart, sizeof( szStart ) - 1 ) ;
    context.m_nrcLast = nrcHeadFollows ;
    m_Completion.m_cbPrefix = sizeof( szStart ) - 1 ;
    cb -= m_Completion.m_cbPrefix ;
    lpb += m_Completion.m_cbPrefix ;

    m_Completion.m_lpb = lpb ;
    m_Completion.m_cb = cb - 3 ;

    m_pGroup->FillBuffer(
                    &context.m_securityCtx,
                    &context.m_encryptCtx,
                    m_Completion
                    ) ;


    return  &m_Completion ;
}

CIOWriteAsyncComplete*
CXHdrCmd::NextBuffer(
    BYTE *lpb,
    int cb,
    ClientContext& context,
    CLogCollector*  pCollector
    )
{
    ENTER("CXHdrCmd::NextBuffer")

    _ASSERT( lpb != 0 ) ;
    _ASSERT( cb != 0 ) ;
    _ASSERT( m_Completion.m_lpb == 0 ) ;
    _ASSERT( m_Completion.m_cb == 0 ) ;

    //
    // reserve space for \r\n
    //
    _ASSERT( cb > 2 ) ;
    m_Completion.m_lpb = lpb ;
    m_Completion.m_cb = cb - 3 ;
    m_Completion.m_cbPrefix = 0 ;


    m_pGroup->FillBuffer(
                    &context.m_securityCtx,
                    &context.m_encryptCtx,
                    m_Completion
                    ) ;

    return  &m_Completion ;
}

BOOL
GetCommandRange(
    INT argc,
    char **argv,
    PDWORD loRange,
    PDWORD hiRange,
        NRC&    code
    )
{
    PCHAR p;
    DWORD lo, hi;

        code = nrcNotSet ;

    //
    // one number
    //

    if ((p = strchr(argv[1], '-')) == NULL) {
        lo = atol(argv[1]);

        //
        // make sure it's within range
        //

        if ( (lo < *loRange) || (lo > *hiRange) ) {
                        code = nrcXoverFollows ;
            return(FALSE);
        }

        *loRange = *hiRange = lo;
        return TRUE;
    }

    //
    // Get the hi + lo part
    //

    *p++ = '\0';
    lo = atol(argv[1]);

    //
    // if lo is
    //

    if ( lo < *loRange ) {
        lo = *loRange;
    }

    //
    // lo number cannot be > than hi limit
    //

    if ( lo > *hiRange ) {
                code = nrcXoverFollows ;
        return(FALSE);
    }

    //
    // if hi is absent, assume hi is the hi limit
    // if hi < lo, return FALSE
    //

    if( *p == '\0' ) {
        hi = *hiRange;
    }
    else if( (hi = atol(p)) < lo ) {
        return(FALSE);
    }

    //
    // if hi > hi limit, assume hi is the hi limit
    //

    if (hi > *hiRange) {
        hi = *hiRange;
    }

    _ASSERT( (*loRange <= lo) && (lo <= hi) && (hi <= *hiRange) );

    *loRange = lo;
    *hiRange = hi;

    return TRUE;

} // GetCommandRange

//
// get GroupID/ArticleID by message ID.  Also checks client permissions...
//
BOOL CheckMessageID(char *szMessageID,              // in
                    struct ClientContext &context,  // in
                    GROUPID *pGroupID,              // out
                    ARTICLEID *pArticleID,          // out
                    CGRPPTR *pGroup)                // out
{
    WORD        HeaderOffsetJunk;
    WORD        HeaderLengthJunk;

        CStoreId storeid;
    if ((context.m_pInstance)->ArticleTable()->GetEntryArticleId(
                                                    szMessageID,
                                                    HeaderOffsetJunk,
                                                    HeaderLengthJunk,
                                                    *pArticleID,
                                                    *pGroupID,
                                                                                                        storeid))
    {
        *pGroup = (context.m_pInstance)->GetTree()->GetGroupById(*pGroupID);
        if (*pGroup == 0) {
            return FALSE;
        }

        // check security
        if (!(*pGroup)->IsGroupAccessible(      context.m_securityCtx,
                                                                        context.m_encryptCtx,
                                                context.m_IsSecureConnection,
                                                FALSE,
                                                TRUE ) )
        {
            return FALSE;
        }

        return TRUE;
    } else {
        return FALSE;
    }
}

const   unsigned    cbMAX_CEXECUTE_SIZE = MAX_CEXECUTE_SIZE ;
const   unsigned    cbMAX_CIOEXECUTE_SIZE = MAX_CIOEXECUTE_SIZE ;


extern "C" int __cdecl  _purecall(void)
{
        DebugBreak() ;
          return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\cservic.cpp ===
//#---------------------------------------------------------------
//  File:       CServic.cpp
//
//  Synopsis:   This file implements the CService class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

#define INCL_INETSRV_INCS
#include    "tigris.hxx"

#include    <stdlib.h>

#ifndef Assert
#define Assert  _ASSERT
#endif

#if 0
#ifdef  PROFILE
#include	"c:\icecap\icapexp.h"
#endif
#endif

//extern  class   NNTP_IIS_SERVICE*  g_pInetSvc ;

DWORD
CBootOptions::ReportPrint(
        LPSTR   lpstr,
        ...
        )   {
/*++

Routine Description :

    Output a printf style string to our report file.

Arguments :

    Standard wsprintf interface.

Return Value :

    Number of bytes output.

--*/

    DWORD   cch = 0 ;
    if( m_hOutputFile != INVALID_HANDLE_VALUE ) {

        char    szOutput[1024] ;

        va_list arglist ;

        va_start( arglist, lpstr ) ;

        cch = wvsprintf( szOutput, lpstr, arglist ) ;
        DWORD   cbWritten = 0 ;

        WriteFile( m_hOutputFile, szOutput, cch, &cbWritten, 0 ) ;

    }
    return  cch ;
}



typedef struct  tagVERTAG {
    LPSTR   pszTag;
} VERTAG, *PVERTAG, FAR *LPVERTAG;



VERTAG  Tags[] = {
    { "FileDescription" },
//  { "OriginalFilename" },
//  { "ProductName" },
    { "ProductVersion" },
//  { "LegalCopyright" },
//  { "LegalCopyright" },
};

#define NUM_TAGS    (sizeof( Tags ) / sizeof( VERTAG ))

DWORD   SetVersionStrings( LPSTR lpszFile, LPSTR lpszTitle, LPSTR   lpstrOut,   DWORD   cbOut   )
{
static char sz[256], szFormat[256], sz2[256];
    int     i;
    UINT    uBytes;
    LPVOID  lpMem;
    DWORD   dw = 0, dwSize;
    HANDLE  hMem;
    LPVOID  lpsz;
    LPDWORD lpLang;
    DWORD   dwLang2;
    BOOL    bRC, bFileFound = FALSE;

    LPSTR   lpstrOrig = lpstrOut ;


    CharUpper( lpszTitle );

    if ( dwSize = GetFileVersionInfoSize( lpszFile, &dw ) ) {
        if ( hMem = GlobalAlloc( GMEM_MOVEABLE|GMEM_ZEROINIT, (UINT)dwSize ) ) {
            lpMem = GlobalLock(hMem);
            if (GetFileVersionInfo( lpszFile, 0, dwSize, lpMem ) &&
                VerQueryValue(  lpMem, "\\VarFileInfo\\Translation",
                                (LPVOID FAR *)&lpLang, &uBytes ) )
            {
                dwLang2 = MAKELONG( HIWORD(lpLang[0]), LOWORD(lpLang[0]) );

                for( i=0; i<NUM_TAGS; i++ ) {

                    lpsz = 0 ;
                    //
                    // need to do the reverse because most winnt files are wrong
                    //
                    wsprintf( sz, "\\StringFileInfo\\%08lx\\%s", lpLang[0], Tags[i].pszTag );
                    wsprintf( sz2, "\\StringFileInfo\\%08lx\\%s", dwLang2, Tags[i].pszTag );
                    bRC =   VerQueryValue( lpMem, sz, &lpsz, &uBytes ) ||
                            VerQueryValue( lpMem, sz2, &lpsz, &uBytes ) ;

                    if( lpsz != 0 )     {

                        if( uBytes+1 < cbOut ) {
                            uBytes = min( (UINT)lstrlen( (char*)lpsz ), uBytes ) ;
                            CopyMemory( lpstrOut, lpsz, uBytes ) ;
                            lpstrOut[uBytes++] = ' ' ;
                            lpstrOut += uBytes ;
                            cbOut -= uBytes ;
                        }   else    {
                            GlobalUnlock( hMem );
                            GlobalFree( hMem );
                            return  (DWORD)(lpstrOut - lpstrOrig) ;
                        }
                    }

                }
                // version info from fixed struct
                bRC = VerQueryValue(lpMem,
                                    "\\",
                                    &lpsz,
                                    &uBytes );

                #define lpvs    ((VS_FIXEDFILEINFO FAR *)lpsz)
                static  char    szVersion[] = "Version: %d.%d.%d.%d" ;

                if ( cbOut > (sizeof( szVersion )*2) ) {

                    CopyMemory( szFormat, szVersion, sizeof( szVersion ) ) ;
                    //LoadString( hInst, IDS_VERSION, szFormat, sizeof(szFormat) );

                    DWORD   cbPrint = wsprintf( lpstrOut, szFormat, HIWORD(lpvs->dwFileVersionMS),
                                LOWORD(lpvs->dwFileVersionMS),
                                HIWORD(lpvs->dwFileVersionLS),
                                LOWORD(lpvs->dwFileVersionLS) );
                    lpstrOut += cbPrint ;

                }
                bFileFound = TRUE;
            }   else    {

            }

            GlobalUnlock( hMem );
            GlobalFree( hMem );
        }       else    {

        }
    }   else    {

    }
    DWORD   dw2 = GetLastError() ;

    return  (DWORD)(lpstrOut - lpstrOrig) ;
}


BOOL
GetRegDword(
        HKEY hKey,
        LPSTR pszValue,
        LPDWORD pdw
        )
/*++

Routine Description :

    Helper function for getting DWORD's out of the registry !

Arguments :

    hKey - registry key to look under
    pszValue - The name of the value
    pdw - Pointer to DWORD to receive value

Return Value :

    TRUE if successfull, false otherwise.

--*/
{
    DWORD   cbData = sizeof( DWORD );
    DWORD   dwType = REG_DWORD;

    return  RegQueryValueEx(hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            (LPBYTE)pdw,
                            &cbData ) == ERROR_SUCCESS && dwType == REG_DWORD;
}

void
StartHintFunction( void ) {
/*++

Routine Description :

    Function provided to hash tables to call during boot up.
    Advances start hints with SCM.

Arguments :

    None.

Return Value :

    None.

--*/

    TraceFunctEnter("StartHintFunction");

    if ( g_pInetSvc && g_pInetSvc->QueryCurrentServiceState() == SERVICE_START_PENDING )
    {
        g_pInetSvc->UpdateServiceStatus(
									SERVICE_START_PENDING,
                                    NO_ERROR,
                                    g_pNntpSvc->m_cStartHints,
                                    SERVICE_START_WAIT_HINT
									) ;

        g_pNntpSvc->m_cStartHints ++ ;
    }
}

void
StopHintFunction( void ) {
/*++

Routine Description :

    Function to call during shutdown
    Advances stop hints with SCM.

Arguments :

    None.

Return Value :

    None.

--*/

    TraceFunctEnter("StopHintFunction");

    if ( g_pInetSvc && g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING )
    {
        g_pInetSvc->UpdateServiceStatus(
									SERVICE_STOP_PENDING,
                                    NO_ERROR,
                                    g_pNntpSvc->m_cStopHints,
                                    SERVICE_STOP_WAIT_HINT
									) ;

        g_pNntpSvc->m_cStopHints ++ ;
    }
}

//+---------------------------------------------------------------
//
//  Function:   EnumUserShutdown
//
//  Synopsis:   Called to teardown active users
//
//  Arguments:  pUser: active CUser instance
//
//  Returns:    void
//
//  History:    gordm       Created         11 Jul 1995
//
//----------------------------------------------------------------
BOOL EnumSessionShutdown( CSessionSocket* pUser, DWORD lParam,  PVOID   lpv )
{
    TraceFunctEnter( "CService::EnumUserShutdown" );

    DebugTrace( (LPARAM)pUser,
                "Terminating CSessionSocket %x", pUser);

    pUser->Disconnect();
    return  TRUE;
}

/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/

APIERR
GetDefaultDomainName(
    STR * pstrDomainName
    )
{

    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    APIERR                      err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

	TraceFunctEnter("GetDefaultDomainName");

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        DebugTrace(0,"cannot open lsa policy, error %08lX\n",NtStatus );
        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {
        DebugTrace(0,"cannot query lsa policy info, error %08lX\n",NtStatus );
        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Compute the required length of the ANSI name.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // dwFlags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  NULL,                 // lpMultiByteStr
                                  0,                    // cchMultiByte
                                  NULL,                 // lpDefaultChar
                                  NULL                  // lpUsedDefaultChar
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Resize the output string as appropriate, including room for the
    //  terminating '\0'.
    //

    if( !pstrDomainName->Resize( (UINT)Result + 1 ) )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  pstrDomainName->QueryStr(),
                                  pstrDomainName->QuerySize() - 1,  // for '\0'
                                  NULL,
                                  NULL
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();

        DebugTrace(0,"cannot convert domain name to ANSI, error %d\n",err );
        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //

    _ASSERT( (DWORD)Result < pstrDomainName->QuerySize() );

    pstrDomainName->QueryStr()[Result] = '\0';

    //
    //  Success!
    //

    _ASSERT( err == 0 );

    DebugTrace(0,"GetDefaultDomainName: default domain = %s\n",pstrDomainName->QueryStr() );

Cleanup:

    if( DomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    return err;

}   // GetDefaultDomainName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\expire.cpp ===
#include "tigris.hxx"

// global ptr to shutdown hint function
SHUTDOWN_HINT_PFN	gpfnHint = NULL;

//
//  Implementation of simple multi-thread safe queue: used for storing rmgroups
//
CQueue::CQueue()
{
	m_pHead = NULL;
	m_pTail = NULL;
    m_cNumElems = 0;

	// Create crit sect to synchronize adds/dels
    InitializeCriticalSection(&m_csQueueLock);
}

CQueue::~CQueue()
{
	QueueElem *pElem;

    LockQ();

	while (m_pHead)
	{
		pElem = m_pHead;
		m_pHead = m_pHead->pNext;
		XDELETE pElem;
        pElem = NULL;
        m_cNumElems--;
	}

    UnlockQ();

    _ASSERT(m_cNumElems == 0);

    DeleteCriticalSection(&m_csQueueLock);
	m_pHead = m_pTail = NULL;
}

// remove an element from the queue
// TRUE if an element was removed successfully - in this case *ppGroup is the element
// FALSE if the queue is empty - in this case *ppGroup is set to NULL
BOOL
CQueue::Dequeue( CGRPPTR *ppGroup)
{
    QueueElem *pElem;

	_ASSERT(ppGroup);

	LockQ();

    if(IsEmpty())
    {
		*ppGroup = NULL;
		UnlockQ();
        return FALSE;
    }

	pElem = m_pHead;
    _ASSERT(pElem);

	*ppGroup = pElem->pGroup;
	m_pHead = m_pHead->pNext;

	// adjust tail if needed
	if(m_pTail == pElem)
		m_pTail = m_pHead;

	XDELETE pElem;
    pElem = NULL;
	m_cNumElems--;

	UnlockQ();

	return TRUE;
}

// TRUE if enqueue succeeds
// FALSE if enqueue fails - it will fail only if we run out of memory
BOOL
CQueue::Enqueue( CGRPPTR pGroup )
{
	LockQ();

	m_cNumElems++;

	if (m_pHead == NULL)
	{
		m_pHead = XNEW QueueElem;
        if(!m_pHead)
		{
			UnlockQ();
            return FALSE;
		}

		m_pTail = m_pHead;
	}
	else
	{
		QueueElem *pElem = m_pTail;
		m_pTail = XNEW QueueElem;
        if(!m_pTail)
		{
			UnlockQ();
            return FALSE;
		}

		pElem->pNext = m_pTail;
	}

	m_pTail->pNext = NULL;
	m_pTail->pGroup = pGroup;

	UnlockQ();

	return TRUE;
}

// TRUE if queue contains a pGroup with lpGroupName - the pGroup object is returned in *ppGroup
// FALSE otherwise - *ppGroup is NULL
BOOL
CQueue::Search(
	CGRPPTR *ppGroup,
	LPSTR lpGroupName
	)
{
	QueueElem  *pElem, *pPrev;

	_ASSERT(ppGroup);
	_ASSERT(lpGroupName);

	LockQ();

	if(IsEmpty())
	{
		*ppGroup = NULL;
		UnlockQ();
		return FALSE;
	}

	BOOL fFound = FALSE;

	pElem = m_pHead;
	pPrev = NULL;
	while (pElem)
	{
		if(!lstrcmp(lpGroupName, pElem->pGroup->GetName()))
		{
			*ppGroup = pElem->pGroup;

			if(pElem == m_pHead)
				m_pHead = m_pHead->pNext;		// first node
			else
				pPrev->pNext = pElem->pNext;	// intermediate or last node

			// adjust tail if needed
			if(pElem == m_pTail)
				m_pTail = pPrev;

			// delete the node
			XDELETE pElem;
			pElem = NULL;
			m_cNumElems--;

			// found this group
			fFound = TRUE;
			break;
		}

		// next node, remember previous one
		pPrev = pElem;
		pElem = pElem->pNext;
	}

	UnlockQ();

	return fFound;
}

//
//	Implementation of CExpire methods !
//

CExpire::CExpire( LPCSTR lpMBPath )
{
	m_ExpireHead = m_ExpireTail = 0 ;
	m_FExpireRunning  = FALSE;
	m_RmgroupQueue = NULL;
    m_cNumExpireBlocks = 0;

	lstrcpy( m_szMDExpirePath, lpMBPath );
	lstrcat( m_szMDExpirePath, "/Expires/" );
}

CExpire::~CExpire()
{
}

BOOL
CExpire::ExpireArticle(
				CNewsTree*		pTree,
				GROUPID			GroupId,
				ARTICLEID		ArticleId,
				STOREID         *pstoreid,
				CNntpReturn &	nntpReturn,
				HANDLE          hToken,
				BOOL            fMustDelete,
				BOOL            fAnonymous,
				BOOL            fFromCancel,
                BOOL            fExtractNovDone,
                LPSTR           lpMessageId
				)
/*++

Routine Description:

	Physically and Logically deletes an article from the news tree. All
    pointers to the article are removed. The MessageID is moved to the
    history table. The file the article resides in is removed immediately or
    moved to a directory where it will be deleted eventually.

Arguments:

	pTree - Newstree to expire article from
    GroupId - newsgroup id
    ArticleId - article id to expire
    storeid - Store id for this article
	nntpReturn - The return value for this function call
	fMustDelete - Should I expire the article even if I cannot delete physical article ?
    fExtractNovDone - ExtractNovEntry has been done, so dont repeat the call
    lpMessageId - MessageId found by calling ExtractNovEntry

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
    BOOL fRet = FALSE;

	TraceFunctEnter( "CExpire::ExpireArticle" );

	nntpReturn.fSetClear(); // clear the return object

    char  szMessageId[MAX_MSGID_LEN];
    DWORD cMessageId = sizeof( szMessageId ) ;
    FILETIME FileTime;
    DWORD   dwErr;

    if( !fExtractNovDone ) {

    	//DebugTrace( DWORD(0), "Expire 1. Get MessageId for (%d,%d)", GroupId, ArticleId ) ;
        // 1. Get MessageId
        //
        BOOL  fPrimary;
	    WORD	HeaderOffset ;
	    WORD	HeaderLength ;
		DWORD cStoreIds = 0;
        if ( !XOVER_TABLE(pTree)->ExtractNovEntryInfo(
                                GroupId,
                                ArticleId,
                                fPrimary,
							    HeaderOffset,
							    HeaderLength,
                                &FileTime,
                                cMessageId,
                                szMessageId,
								cStoreIds,
								NULL,
								NULL)
           )
        {
            // Without a MessageId, we can't remove the article pointers in the ArticleTable or
            // place a record of the article in the HistoryTable.
            //
            // If the data structure are intact, then the caller is deleting something that doesn't
            // exist. If the data structures are corrupt and the caller has a Messageid (perhaps by
            // opening the article file), then we might consider writing a delete function that takes
            // MessageId as an argument.
            //
            DebugTrace( DWORD(0), "Expire: SearchNovEntry Error %d on (%lu/%lu)", GetLastError(), GroupId, ArticleId );
            nntpReturn.fSet( nrcNoSuchArticle );
            return FALSE;
        }
        szMessageId[ cMessageId ] = '\0';
        lpMessageId = szMessageId;
    }

    _ASSERT( lpMessageId );

	//DebugTrace( DWORD(0), "Expire 3. Get all the other news groups" ) ;
    // 3. Get all the other news groups
    //
    DWORD nGroups = INITIAL_NUM_GROUPS;
    DWORD BufferSize = nGroups * sizeof(GROUP_ENTRY);
    PGROUP_ENTRY pGroupBuffer = XNEW GROUP_ENTRY[nGroups];
    if ( NULL == pGroupBuffer ) {
        return FALSE;
    }
    PBYTE rgcStoreCrossposts = XNEW BYTE[nGroups];
    if ( NULL == rgcStoreCrossposts ) {
        XDELETE pGroupBuffer;
        return FALSE;
    }

    if ( !XOVER_TABLE(pTree)->GetArticleXPosts(
                            GroupId,
                            ArticleId,
                            FALSE,
                            pGroupBuffer,
                            BufferSize,
                            nGroups,
                            rgcStoreCrossposts
                            )
       )
    {

        XDELETE pGroupBuffer;
        XDELETE rgcStoreCrossposts;
        if ( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            // Reallocate buffer and try again.
            //
            nGroups = (BufferSize + sizeof(GROUP_ENTRY) - 1)/ sizeof(GROUPID);
            BufferSize = nGroups * sizeof(GROUP_ENTRY);
            pGroupBuffer = XNEW GROUP_ENTRY[nGroups];
            if ( NULL == pGroupBuffer ) {
                return FALSE;
            }
            rgcStoreCrossposts = XNEW BYTE[nGroups];
            if ( NULL == rgcStoreCrossposts ) {
                XDELETE pGroupBuffer;
                return FALSE;
            }

            if ( !XOVER_TABLE(pTree)->GetArticleXPosts(
                                GroupId,
                                ArticleId,
                                FALSE,
                                pGroupBuffer,
                                BufferSize,
                                nGroups,
                                rgcStoreCrossposts
                                ) ) {

                XDELETE pGroupBuffer;
                XDELETE rgcStoreCrossposts;
                return FALSE;
            }

            // SUCCESS on second try.
            //
        }
        else
        {
            // Information is not available at this time.
            //
			ErrorTrace( DWORD(0), "Expire: GetArticleXPosts Error %d on (%lu/%lu)", GetLastError(), GroupId, ArticleId );
            nntpReturn.fSet( nrcNoSuchArticle );
            return FALSE;
        }
    }

    //
    // Now we should loop through all the store's and ask the store wide primary group
    // to delete the physical article.  If the server wide ( the first store wide )
    // primary article is physically deleted, then we'll go ahead and delete hash table entries
    // otherwise we'll stop expiring this article.  As long as the server wide primary
    // article is deleted, all group's will do DeleteLogicArticle to update their
    // watermarks.
    //
    int     iStore = 0;
    CGRPPTR pGroup;
    for ( DWORD i = 0; i < nGroups; i += rgcStoreCrossposts[iStore++] ) {

        //
        // We don't want to get groups if the tree has been stopped
        //
        pGroup = pTree->GetGroupById( pGroupBuffer[i].GroupId, FALSE );

        // pGroup could be 0, if this group has been deleted
        if(pGroup != 0)
        {
            // We should still check if the primary group is in exchange store, if it
            // is, we should not call its deletearticle method
            CNNTPVRoot *pVRoot = pGroup->GetVRoot();
            if ( fFromCancel || pVRoot && !pVRoot->HasOwnExpire() ) {

                // We don't have to save fixed properties for primary group at this time,
                // fixed properties will be saved back to group.lst when the whole group's
                // expiration is completed
                fRet = pGroup->DeletePhysicalArticle( hToken, fAnonymous, pGroupBuffer[i].ArticleId, pstoreid );
                dwErr = GetLastError();
            } else {

                //
                // If it's a exchange vroot, we should always logically delete it
                //
                fRet = TRUE;
            }

            if ( pVRoot ) pVRoot->Release();
        }

        //
        // We only bail if we failed deleting server wide primary article, in
        // this case, either the article has already been deleted or is being
        // used.  If it has already been deleted, somebody else has already
        // taken care of it.  If there is opening sharing violation, we'll leave
        // the next round expire to take care of it
        //
        if ( i == 0 && !fRet && !fMustDelete ) {
            ErrorTrace( 0, "Can not delete server wide article, bail expire %d",
                        GetLastError() );
            nntpReturn.fSet( nrcNoSuchArticle );
            XDELETE pGroupBuffer;
            XDELETE rgcStoreCrossposts;
            return FALSE;
        }
    }

    //
    // We only go ahead and expire the article logically when we
    // have physically deleted it, or when it's an exchange
    // vroot, or the failure didn't occur on a server wide primary article
    //
    //
    // Add history entry here so that if somebody else has already
    // expired this article, we are done
    //
	GetSystemTimeAsFileTime( &FileTime ) ;
    if ( FALSE == HISTORY_TABLE(pTree)->InsertMapEntry( lpMessageId, &FileTime ) )
    {
         //
	     // another thread has already expired this article - bail !
	     // in fact this is very unlikely to happen because if another thread
	     // has already inserted the history entry, he should have already
	     // deleted the primary article and we won't be able to come here.  But
	     // just to be safe ...
	     //
	     DWORD dwError = GetLastError();
	     _ASSERT( ERROR_ALREADY_EXISTS == dwError );

	     ErrorTrace( DWORD(0), "Expire: History.InsertMapEntry Error %d on (%lu/%lu)", dwError, GroupId, ArticleId );
         nntpReturn.fSet( nrcHashSetFailed, lpMessageId, "History", dwError );
         XDELETE pGroupBuffer;
         XDELETE rgcStoreCrossposts;
         return FALSE;
    }

    //DebugTrace( DWORD(0), "Expire 5/6. Delete XoverTable/ArticleTable pointers" ) ;
    // 5. Delete XoverTable pointers using group/article pair.
    // 6. Delete ArticleTable pointers using MessageId.
    //
    if( !XOVER_TABLE(pTree)->DeleteNovEntry( GroupId, ArticleId ) )
	{
		// someone else deleted this entry or hash table shutdown - bail !
		DWORD dwError = GetLastError();
		_ASSERT( ERROR_FILE_NOT_FOUND == dwError );

        DebugTrace( DWORD(0), "Expire: DeleteNovEntry Error %d on (%lu/%lu)", dwError, GroupId, ArticleId );
        nntpReturn.fSet( nrcNoSuchArticle );
		XDELETE pGroupBuffer;
		XDELETE rgcStoreCrossposts;
		return FALSE;
	}

	//
	// Delete logical article for this guy, we do want to get group even
	// if the tree has been stopped, since we already deleted its physical article
	//
	pGroup = pTree->GetGroupById( GroupId, TRUE );
	if ( pGroup ) pGroup->DeleteLogicalArticle( ArticleId );

	//
	// Delete the article table entry, we'll continue even if we failed on this
	//
	ARTICLE_TABLE(pTree)->DeleteMapEntry( lpMessageId );

    //
	//DebugTrace( DWORD(0), "Expire 8. Delete article logically from all the cross-posted newsgroups." ) ;
    // 8. Delete article logically from all the cross-posted newsgroups.
    //
    for ( i = 0; i < nGroups; i++ )
    {
        if ( GROUPID_INVALID != pGroupBuffer[i].GroupId && GroupId != pGroupBuffer[i].GroupId )
        {
			DebugTrace( DWORD(0), "Expire: Deleting (%lu/%lu) logically from cross-posted newsgroups.", pGroupBuffer[i].GroupId, pGroupBuffer[i].ArticleId ) ;

            pGroup = pTree->GetGroupById( pGroupBuffer[i].GroupId, TRUE );

            if ( pGroup != 0 ) {

			    // delete the xover entry for this logical article
		        if( !XOVER_TABLE(pTree)->DeleteNovEntry( pGroupBuffer[i].GroupId, pGroupBuffer[i].ArticleId ) ) {
				    ErrorTrace( DWORD(0), "Expire: DeleteNovEntry Error %d on (%lu/%lu)", GetLastError(), pGroupBuffer[i].GroupId, pGroupBuffer[i].ArticleId );
			    } else {
                    pGroup->DeleteLogicalArticle( pGroupBuffer[i].ArticleId );
                }

                // We have to ask secondary group to save fixed property every time
                // one article has been deleted out of it logically
                pGroup->SaveFixedProperties();
            }
        }
    }

    XDELETE pGroupBuffer;
    XDELETE rgcStoreCrossposts;
    nntpReturn.fSetOK();
    return fRet;
}

BOOL
CExpire::ProcessXixBuffer(
            CNewsTree*  pTree,
            BYTE*       lpb,
            int         cb,
            GROUPID     GroupId,
            ARTICLEID   artidLow,
            ARTICLEID   artidHigh,
            DWORD&      dwXixSize
            )
/*++

Routine Description:

    This function takes an article range and the XIX info for this range
    and expires all articles in this range.

Arguments:

    pTree     -  CNewsTree object
    lpb       -  xix buffer
    cb        -  size of data in xix buffer (including a terminating NULL)
    GroupId   -  group id for xix data
    artidLow  -  low range to expire
    artidHigh -  high range to expire
    dwXixSize -  sum of sizes of all articles expired in this xix file

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
    BOOL fRet = TRUE;
    return fRet;
}

FILETIME
gCalculateExpireFileTime( DWORD dwExpireHorizon )
{

    // Calulcate Expire Horizon
    //
    FILETIME ftCurrentTime;
    ULARGE_INTEGER liCurrentTime, liExpireHorizon;
    GetSystemTimeAsFileTime( &ftCurrentTime );
    LI_FROM_FILETIME( &liCurrentTime, &ftCurrentTime );
    liExpireHorizon.QuadPart  = 1000 * 1000 * 10; // to achieve units of seconds
    liExpireHorizon.QuadPart *= 60 * 60;          // to achieve units of hours
    liExpireHorizon.QuadPart *= dwExpireHorizon;
    liCurrentTime.QuadPart -= liExpireHorizon.QuadPart;
    FILETIME ftExpireHorizon;
    FILETIME_FROM_LI( &ftExpireHorizon, &liCurrentTime );
    return ftExpireHorizon;
}

BOOL
CExpire::DeletePhysicalArticle( CNewsTree* pTree, GROUPID GroupId, ARTICLEID ArticleId, STOREID *pStoreId, HANDLE hToken, BOOL fAnonymous )
{
    BOOL fRet = TRUE;

    CGRPPTR  pGroup = pTree->GetGroupById( GroupId );

    if(pGroup != 0)
        fRet = pGroup->DeletePhysicalArticle( hToken, fAnonymous, ArticleId, pStoreId );
    else
        fRet = FALSE;

    return fRet;
}

//
// Detailed Design
//
// FOR every wild match string in multi_sz registry key,
//    Size = 0
//    Heap = empty
//    FOR every news group in the wild match string
//       FOR every physical article in the news group
//           IF file date of physical article is too old
//               Expire Article
//           ELSE
//               IF Heap is full
//                   Remove youngest article from Heap
//               ENDIF
//               Size += Size of article
//               Insert Article into Heap in oldest to youngest order.
//           ENDIF
//       ENDFOR
//    ENDFOR
//    IF Size is too big
//        Sort Heap
//        WHILE Size is too big AND Heap isn't empty
//            Size -= Size of oldest article
//            Expire oldest article
//            Remove oldest article from Heap
//        ENDWHILE
//        IF Heap is empty
//            Reprocess current wild match string
//        ELSE
//            Process next wild match string
//        ENDIF
//    ELSE
//        Process next wild match string
//    ENDIF
// ENDFOR
//

void
CExpire::ExpireArticlesBySize( CNewsTree* pTree )
{
}

typedef enum _ITER_TURN
{
    itFront,
    itBack
} ITER_TURN;

BOOL
CExpire::MatchGroupExpire( CGRPPTR pGroup )
/*++
    Check if the vroot that the group belongs to does expiration
    itself.
--*/
{
    BOOL    bExpire;

    CNNTPVRoot *pVRoot = pGroup->GetVRoot();
    if ( pVRoot ) {
        bExpire = pVRoot->HasOwnExpire();
        pVRoot->Release();
    } else bExpire = FALSE;

    return !bExpire;
}

BOOL
CExpire::MatchGroupEx(	LPMULTISZ	multiszPatterns,	CGRPPTR pGroup ) {

	Assert( multiszPatterns != 0 ) ;
	LPSTR lpstrGroup = pGroup->GetName();

    if( multiszPatterns == 0 ) {
        return  MatchGroupExpire( pGroup ) ;
    }

	LPSTR	lpstrPattern = multiszPatterns ;

	while( *lpstrPattern != '\0' )	{
		if( *lpstrPattern == '!' ) {
			_strlwr( lpstrPattern+1 );
			if( HrMatchWildmat( lpstrGroup, lpstrPattern+1 ) == ERROR_SUCCESS ) {
				return	FALSE ;
			}
		}	else	{
			_strlwr( lpstrPattern );
			if( HrMatchWildmat( lpstrGroup, lpstrPattern ) == ERROR_SUCCESS ) {
				return	MatchGroupExpire( pGroup ) ;
			}
		}
		lpstrPattern += lstrlen( lpstrPattern ) + 1 ;
	}
	return	FALSE ;
};

//
// Detailed Design
//
//    Make a newsgroup iterator on *
//    FOR every newsgroup in this iterator
//       + Evaluate the group against the list of expire policies
//       and set the most aggressive time policy.
//       + Queue this group on the expire thrdpool
//    ENDFOR
//

void
CExpire::ExpireArticlesByTime( CNewsTree* pTree )
{
    TraceFunctEnter( "CExpire::ExpireArticlesByTime" );

    //
    // No work if number of expire policies == 0
    //
    LockBlockList();
    if( m_cNumExpireBlocks == 0 ) {
        UnlockBlockList();
        return;
    }
    UnlockBlockList();

    //
    // Prepare ftExpireHorizon (TIME) and dwExpireSpace (SIZE)
    // NOTE: This function will process only those policies with
    // dwExpireSpace == 0xFFFFFFFF
    //

    BOOL fDoFileScan = FALSE;
    DWORD cPreTotalArticles = ((pTree->GetVirtualServer())->ArticleTable())->GetEntryCount();
    DWORD cPreArticlesExpired = ((pTree->GetVirtualServer())->m_NntpStats).ArticlesExpired;
    pTree->BeginExpire( fDoFileScan );

    CGroupIterator* pIteratorFront = pTree->ActiveGroups(TRUE, NULL, FALSE, NULL);
    CGroupIterator* pIteratorBack  = pTree->ActiveGroups(TRUE, NULL, FALSE, NULL, TRUE);
    ITER_TURN itTurn = itFront;

    if (pIteratorFront && pIteratorBack) {
	    for ( ;!pIteratorFront->IsEnd() && !pIteratorBack->IsBegin()
            && !pTree->m_bStoppingTree; )
	    {
            CGRPPTR pGroup;
            if( itTurn == itFront ) {
                pGroup = pIteratorFront->Current();
            } else {
                pGroup = pIteratorBack->Current();
            }

            //
            //  Evaluate group against configured expire policies
            //

            BOOL fIsMatch = FALSE;
            FILETIME ftZero = {0};
            FILETIME minft = ftZero;
            LPEXPIRE_BLOCK	expireCurrent = NextExpireBlock( 0 )  ;
            while ( expireCurrent )
            {
                DWORD	cbNewsgroups = 0 ;
                PCHAR   multiszNewsgroups = 0;
                DWORD   dwExpireHorizon;
                DWORD   dwExpireSpace;
                BOOL    fIsRoadKill = FALSE ;
                FILETIME ft;

                if (GetExpireBlockProperties(	expireCurrent,
                                            multiszNewsgroups,
                                            cbNewsgroups,
                                            dwExpireHorizon,
                                            dwExpireSpace,
                                            FALSE,
                                            fIsRoadKill ))
                {
                    _ASSERT( multiszNewsgroups );
                    if (dwExpireSpace == 0xFFFFFFFF) {
	                    if( MatchGroupEx( multiszNewsgroups, pGroup ) ) {
	                        //
	                        //  SetExpireTime should set the most aggressive expire by time
	                        //
	                        ft = gCalculateExpireFileTime( dwExpireHorizon );

	                        //
	                        //  Always set the most aggressive expire horizon.
	                        //
	                        if( CompareFileTime( &ftZero, &minft ) == 0 ) {
	                            minft = ft;
	                        } else if( CompareFileTime( &ft, &minft ) > 0 ) {
	                            minft = ft;
	                        }

	                        fIsMatch = TRUE;
	                    }
                    }

                    FREE_HEAP( multiszNewsgroups ) ;
                    multiszNewsgroups = NULL ;
                }

                expireCurrent = NextExpireBlock( expireCurrent ) ;
            }

            if( fIsMatch && !pGroup->IsDeleted()
                && ( fDoFileScan || !(pGroup->GetFirstArticle() > pGroup->GetLastArticle()))  ) {
                //
                //  ok, now that the group has been evaluated against all the expire policies
                //  on the system, put it on the thrdpool.
                //  NOTE: queue the group id on the thrdpool so it handles groups being deleted
                //  while on the queue.
                //

                _ASSERT( CompareFileTime( &ftZero, &minft ) != 0 );
                pGroup->SetGroupExpireTime( minft );

                DebugTrace(0,"Adding group %s to expire thrdpool", pGroup->GetName());
                if( !g_pNntpSvc->m_pExpireThrdpool->PostWork( (PVOID)(SIZE_T)pGroup->GetGroupId() ) ) {
                    //
                    //  TODO: If PostWork() fails, call WaitForJob() so the queue can be drained
                    //
                    _ASSERT( FALSE );
                }
            }

            // terminating condition - both iterators point at the same group
            if( pIteratorFront->Meet( pIteratorBack ) ) {
                DebugTrace(0,"Front and back iterators converged: group is %s", pGroup->GetName());
                break;
            }

            // advance either the front or back iterator and reverse the turn
            if( itTurn == itFront ) {
                pIteratorFront->Next();
                itTurn = itBack;
            } else {
                pIteratorBack->Prev();
                itTurn = itFront;
            }
        }
    }

    XDELETE pIteratorFront;
    pIteratorFront = NULL;
    XDELETE pIteratorBack;
    pIteratorBack = NULL;

    //
    //  ok, now cool our heels till the expire thrdpool finishes this job !!
    //
    pTree->EndExpire();
    DWORD cPercent = 0;
    //DWORD cPostTotalArticles = ((pTree->GetVirtualServer())->ArticleTable())->GetEntryCount();
    DWORD cPostArticlesExpired = ((pTree->GetVirtualServer())->m_NntpStats).ArticlesExpired;

    //
    // if we expired less than 10% of the total articles in this expire run,
    // we will do file scan on the next expire run.
    // Set pTree->m_cNumExpireByTimes to gNewsTreeFileScanRate, so next time CheckExpire.
    // will set fFileScan to TRUE
    //
    //
    if ((cPreTotalArticles == 0) ||
        (cPercent = (DWORD)( ((float)(cPostArticlesExpired-cPreArticlesExpired) / (float)cPreTotalArticles) * 100 )) < 10 )
    {
        pTree->m_cNumExpireByTimes = gNewsTreeFileScanRate;
        pTree->m_cNumFFExpires++;

        //
        //  caveat to the above comment - every so often (gNewsTreeFileScanRate)
        //  we will ensure that the other scan gets a chance to run...
        //
        if( pTree->m_cNumFFExpires % gNewsTreeFileScanRate == 0 ) {
            pTree->m_cNumExpireByTimes--;
            pTree->m_cNumFFExpires = 1;
        }
    }

    if( cPercent > 0 ) {
	    PCHAR	args[3] ;
        CHAR    szId[10];
        CHAR    szPercent[10];

        _itoa( pTree->GetVirtualServer()->QueryInstanceId(), szId, 10 );
        args[0] = szId;
        args[1] = fDoFileScan ? "HardScan" : "SoftScan";
        _itoa( cPercent, szPercent, 10 );
        args[2] = szPercent;

	    NntpLogEvent(
		    	NNTP_EVENT_EXPIRE_BYTIME_LOG,
			    3,
			    (const char **)args,
			    0
			    ) ;
    }

    DebugTrace( DWORD(0), "Articles Expired by Time" );
}

//
//	Return FALSE on failure. If the failure is fatal, set fFatal to TRUE.
//

BOOL
CExpire::InitializeExpires( SHUTDOWN_HINT_PFN  pfnHint, BOOL& fFatal, DWORD dwInstanceId )
{
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	TraceFunctEnter( "CExpire::InitializeExpires" ) ;

	// set the shutdown hint function
	gpfnHint = pfnHint;

	InitializeCriticalSection( &m_CritExpireList ) ;
	EnterCriticalSection( &m_CritExpireList ) ;

	DWORD	i = 0 ;
	DWORD   error;
    CHAR	Newsgroups[1024];
	CHAR	keyName[METADATA_MAX_NAME_LEN+1];
    DWORD	NewsgroupsSize = sizeof( Newsgroups );
	CHAR	ExpirePolicy[1024];
	DWORD	ExpirePolicySize = sizeof( ExpirePolicy );
	BOOL	fSuccessfull = TRUE ;

    if ( !mb.Open( QueryMDExpirePath(),
			METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {
		error = GetLastError();
		NntpLogEventEx(NNTP_NTERROR_EXPIRE_MBOPEN,
			0,
			NULL,
			error,
			dwInstanceId
			);
		fSuccessfull = FALSE ;

    }	else	{
		while( 1 ) {

		    DWORD	dwExpireHorizon = DEFAULT_EXPIRE_HORIZON;
			DWORD	dwExpireSpace = DEFAULT_EXPIRE_SPACE;

			ZeroMemory( Newsgroups, sizeof( Newsgroups ) ) ;

			if( !mb.EnumObjects( "",
								 keyName,
								 i++ ) )
			{
				// done enumerating feed keys
				error = GetLastError();
				if (error != ERROR_NO_MORE_ITEMS) {
					ErrorTrace(0,"Error %d enumerating feeds\n",error);
					fSuccessfull = FALSE ;
				}

				break ;
			}

			DWORD Value;

			if ( !mb.GetDword(	keyName,
								MD_EXPIRE_SPACE,
								IIS_MD_UT_SERVER,
								&Value ) )
			{
				PCHAR	tmpBuf[2] ;
				tmpBuf[0] = StrExpireSpace ;
				tmpBuf[1] = keyName ;
				error = GetLastError();

				NntpLogEventEx(	NNTP_NTERROR_EXPIRE_VALUE,
								2,
								(const CHAR **)tmpBuf,
								error,
								dwInstanceId
								) ;
				fSuccessfull = FALSE ;

				//
				//	expire policy exists but value is missing
				//

				if( !mb.DeleteObject( keyName ) ) {
					ErrorTrace(0,"Error %d deleting %s", GetLastError(), keyName);
				}

				continue ;

			} else {
				dwExpireSpace = max( 1, Value );
			}

			if ( !mb.GetDword(	keyName,
								MD_EXPIRE_TIME,
								IIS_MD_UT_SERVER,
								&Value ) )
			{
				PCHAR	tmpBuf[2] ;
				tmpBuf[0] = StrExpireHorizon ;
				tmpBuf[1] = keyName ;
				error = GetLastError();

				NntpLogEventEx(	NNTP_NTERROR_EXPIRE_VALUE,
								2,
								(const CHAR **)tmpBuf,
								error,
								dwInstanceId) ;
				fSuccessfull = FALSE ;

				//
				//	expire policy exists but value is missing
				//

				if( !mb.DeleteObject( keyName ) ) {
					ErrorTrace(0,"Error %d deleting %s", GetLastError(), keyName);
				}

				continue ;

			} else {
				dwExpireHorizon = max( 1, Value );
			}

			//
			// Get Newsgroups
			//

			{
				NewsgroupsSize = sizeof( Newsgroups );
				MULTISZ msz( Newsgroups, NewsgroupsSize );
				if( !mb.GetMultisz(	keyName,
									MD_EXPIRE_NEWSGROUPS,
									IIS_MD_UT_SERVER,
									&msz  ) )
				{
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrExpireNewsgroups;
					tmpBuf[1] = keyName ;
					error = GetLastError();

					NntpLogEventEx(	NNTP_NTERROR_EXPIRE_VALUE,
									2,
									(const CHAR **)tmpBuf,
									error,
									dwInstanceId) ;
					fSuccessfull = FALSE ;

					//
					//	expire policy exists but value is missing
					//

					if( !mb.DeleteObject( keyName ) ) {
						ErrorTrace(0,"Error %d deleting %s", GetLastError(), keyName);
					}

					continue ;

				}

                NewsgroupsSize = msz.QueryCCH();
			}

			//
			// Get expire policy
			//

            ExpirePolicySize = sizeof( ExpirePolicy );
			if( !mb.GetString(	keyName,
								MD_EXPIRE_POLICY_NAME,
								IIS_MD_UT_SERVER,
								ExpirePolicy,
								&ExpirePolicySize  ) )
			{
				{
					// default !
					PCHAR	tmpBuf[2] ;

					tmpBuf[0] = StrExpirePolicy ;
					tmpBuf[1] = keyName ;
					error = GetLastError();

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
									2,
									(const CHAR **)tmpBuf,
									error,
									dwInstanceId) ;

					fSuccessfull = FALSE ;

					//
					//	expire policy exists but value is missing
					//

					if( !mb.DeleteObject( keyName ) ) {
						ErrorTrace(0,"Error %d deleting %s", GetLastError(), keyName);
					}

					continue ;
				}
			}

			LPEXPIRE_BLOCK	lpExpire = AllocateExpireBlock(
											keyName,
											dwExpireSpace,
											dwExpireHorizon,
											Newsgroups,
											NewsgroupsSize,
											(PCHAR)ExpirePolicy,
											FALSE ) ;

			if( lpExpire )
				InsertExpireBlock( lpExpire ) ;
			else	{
				fSuccessfull = FALSE ;
				fFatal = TRUE ;
				break ;
			}

		}	// end while(1)

		mb.Close();

	}	// end if

	LeaveCriticalSection( &m_CritExpireList ) ;

	// Expire object is ready for use
	if( fSuccessfull ) {
		m_FExpireRunning = TRUE ;
	}

    if(!InitializeRmgroups()) {
        fSuccessfull = FALSE;
		fFatal = FALSE;
	}

	return	fSuccessfull ;
}

BOOL
CExpire::TerminateExpires( CShareLockNH* pLockInstance )		{

	BOOL	fRtn = FALSE ;

	//
	//	if expire thread is partying on this instance, block
	//	till it finishes. since we have called StopTree() we
	//	should not have to wait for long..
	//

	pLockInstance->ExclusiveLock();
	m_FExpireRunning = FALSE ;
	pLockInstance->ExclusiveUnlock();

	EnterCriticalSection( &m_CritExpireList ) ;

	LPEXPIRE_BLOCK	expire = NextExpireBlock( 0 ) ;

	while( expire ) {

		LPEXPIRE_BLOCK	expireNext = NextExpireBlock( expire ) ;
		CloseExpireBlock( expire ) ;
		expire = expireNext ;
	}

	LeaveCriticalSection( &m_CritExpireList ) ;
	DeleteCriticalSection( &m_CritExpireList ) ;

	return	fRtn ;
}

BOOL
CExpire::CreateExpireMetabase(	LPEXPIRE_BLOCK	expire ) {

	_ASSERT( expire != 0 ) ;
	_ASSERT( expire->m_ExpireId == 0 ) ;

	TraceFunctEnter( "CExpire::CreateExpireMetabase" ) ;

	char	keyName[ EXPIRE_KEY_LENGTH ] ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
	static	int		i = 1 ;
	DWORD	expireId = 0 ;
	BOOL	fSuccessfull = TRUE ;

    _ASSERT(QueryMDExpirePath() != NULL);

	if( !mb.Open( QueryMDExpirePath(), METADATA_PERMISSION_WRITE ) ) {
		ErrorTrace(0,"Error %d opening %s\n",GetLastError(),QueryMDExpirePath());
		return FALSE ;
	}

	while( i > 0 ) {

		//
		// Find a name for this expire
		//

		expireId = i++;
		wsprintf(keyName,"expire%d", expireId);

		DebugTrace(0,"Opening %s\n", keyName);

		if( !mb.AddObject( keyName ) ) {

			if( GetLastError() == ERROR_ALREADY_EXISTS ) {
				continue;	// try the next number
			}

			ErrorTrace(0,"Error %d adding %s\n", GetLastError(), keyName);
			mb.Close();
			return FALSE ;
		} else {
			break ;	// success - added it !
		}
	}

	_VERIFY( mb.Close() );
//	_VERIFY( mb.Save()  );

	expire->m_ExpireId = expireId ;

	if( !SaveExpireMetabaseValues( NULL, expire ) ) {

        ErrorTrace(0,"Update metabase failed. Deleting %s\n",keyName);

#if 0
		if( !mb.DeleteObject( keyName ) ) {
			ErrorTrace(0,"Error %d deleting %s\n",GetLastError(),keyName);
		}
#endif

		fSuccessfull = FALSE ;
	}

	return	fSuccessfull ;
}

BOOL
CExpire::SaveExpireMetabaseValues(
							MB* pMB,
							LPEXPIRE_BLOCK	expire
							) {

	TraceFunctEnter( "CExpire::SaveExpireMetabaseValues" ) ;


	char	keyName[ EXPIRE_KEY_LENGTH ] ;
	LPSTR	regstr ;
	DWORD	error ;
	BOOL	fOpened = FALSE ;
	BOOL	fRet = TRUE ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() ) ;

	_ASSERT( expire->m_ExpireId != 0 ) ;
	wsprintf( keyName, "expire%d", expire->m_ExpireId ) ;

	if( pMB == NULL ) {

		if( !mb.Open( QueryMDExpirePath(), METADATA_PERMISSION_WRITE ) ) {
			error = GetLastError();
            ErrorTrace(0,"Error %d opening %s\n",error,keyName);
			return	FALSE ;
		}

		pMB = &mb;
		fOpened = TRUE;
	}
					
    if( !pMB->SetString(	keyName,
							MD_KEY_TYPE,
							IIS_MD_UT_SERVER,
							NNTP_ADSI_OBJECT_EXPIRE,
							METADATA_NO_ATTRIBUTES
    					) )
	{
		regstr = "KeyType" ;
		fRet = FALSE ;
		goto exit;
	}

	if ( !pMB->SetDword(	keyName,
							MD_EXPIRE_SPACE,
							IIS_MD_UT_SERVER,
							expire->m_ExpireSize ) )
	{
		regstr = StrExpireSpace ;
		fRet = FALSE ;
		goto exit;
	}

	if ( !pMB->SetDword(	keyName,
							MD_EXPIRE_TIME,
							IIS_MD_UT_SERVER,
							expire->m_ExpireHours ) )
	{
		regstr = StrExpireHorizon ;
		fRet = FALSE ;
		goto exit;
	}

	if ( !pMB->SetData(	keyName,
						MD_EXPIRE_NEWSGROUPS,
						IIS_MD_UT_SERVER,
						MULTISZ_METADATA,
						expire->m_Newsgroups[0],
						MultiListSize(expire->m_Newsgroups)
						) )
	{
		regstr = StrExpireNewsgroups ;
		fRet = FALSE ;
	}

	if ( !pMB->SetString(	keyName,
							MD_EXPIRE_POLICY_NAME,
							IIS_MD_UT_SERVER,
							expire->m_ExpirePolicy
							) )
	{
		regstr = StrExpirePolicy ;
		fRet = FALSE ;
	}

exit:

	if( fOpened ) {
		pMB->Close();
		pMB->Save();
	}

	return	fRet ;
}

void
CExpire::MarkForDeletion( LPEXPIRE_BLOCK	expire	) {

	TraceFunctEnter( "CExpire::MarkForDeletion" ) ;

	_ASSERT( expire != 0 ) ;
	char	keyName[ EXPIRE_KEY_LENGTH ] ;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() ) ;
	_ASSERT( expire->m_ExpireId != 0 ) ;

	EnterCriticalSection( &m_CritExpireList ) ;

	if( expire->m_ExpireId != 0 ) {
		wsprintf( keyName, "expire%d", expire->m_ExpireId ) ;

		if( !mb.Open( QueryMDExpirePath(), METADATA_PERMISSION_WRITE ) ) {
			ErrorTrace(0,"Error %d opening %s\n",GetLastError(),QueryMDExpirePath());
			return;
		}

		if( !mb.DeleteObject( keyName ) ) {
			ErrorTrace(0,"Error %d deleting %s\n",GetLastError(),keyName);
		}

		_VERIFY( mb.Close() );
		_VERIFY( mb.Save()  );
	}

	expire->m_fMarkedForDeletion = TRUE ;

	LeaveCriticalSection( &m_CritExpireList ) ;
}


LPEXPIRE_BLOCK
CExpire::AllocateExpireBlock(
				IN	LPSTR	KeyName	OPTIONAL,
				IN	DWORD	ExpireSpace,
				IN	DWORD	ExpireHorizon,
				IN	PCHAR	Newsgroups,
				IN	DWORD	NewsgroupSize,
				IN  PCHAR   ExpirePolicy,
				IN	BOOL	IsUnicode ) {


	LPEXPIRE_BLOCK	expireBlock = 0 ;
	LPSTR ExpirePolicyAscii = NULL;

	if( IsUnicode ) {

		ExpirePolicyAscii =
			(LPSTR)ALLOCATE_HEAP( (wcslen( (LPWSTR)ExpirePolicy ) + 1) * sizeof(WCHAR) ) ;
		if( ExpirePolicyAscii != 0 ) {
			CopyUnicodeStringIntoAscii( ExpirePolicyAscii, (LPWSTR)ExpirePolicy ) ;
		}	else	{
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			return 0;
		}

	}	else	{

		ExpirePolicyAscii =
			(LPSTR)ALLOCATE_HEAP( lstrlen(ExpirePolicy) + 1 ) ;
		if( ExpirePolicyAscii != 0 ) {
			lstrcpy( ExpirePolicyAscii, ExpirePolicy ) ;
		}	else	{
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			return 0;
		}
	}

    LPSTR*	lpstrNewsgroups = AllocateMultiSzTable(
                                            Newsgroups,
                                            NewsgroupSize,
                                            IsUnicode
                                            );
	if( lpstrNewsgroups == 0 ) {
		if( ExpirePolicyAscii ) {
			FREE_HEAP( ExpirePolicyAscii );
		}
		return	0 ;
	}

#if 0
	LPSTR*	plpstrTemp = ReverseMultiSzTable( lpstrNewsgroups ) ;

	if( plpstrTemp != NULL )	{
		FREE_HEAP( lpstrNewsgroups ) ;
		lpstrNewsgroups = plpstrTemp ;
	}	else	{
		FREE_HEAP( lpstrNewsgroups ) ;
		return 0 ;
	}
#endif

	if( lpstrNewsgroups != 0 ) {

		expireBlock = (LPEXPIRE_BLOCK)ALLOCATE_HEAP( sizeof( EXPIRE_BLOCK ) ) ;
		if( expireBlock != NULL ) {

			ZeroMemory( expireBlock, sizeof( *expireBlock ) ) ;

			if( KeyName != 0 ) {
				if( sscanf( KeyName + sizeof("expire")-1, "%d", &expireBlock->m_ExpireId ) != 1 ||
					expireBlock->m_ExpireId == 0 ) {
					FREE_HEAP( expireBlock ) ;
					FREE_HEAP( lpstrNewsgroups ) ;
					FREE_HEAP( ExpirePolicyAscii ) ;
					return 0 ;
				}
			}

			expireBlock->m_ExpireSize = ExpireSpace ;
			expireBlock->m_ExpireHours = ExpireHorizon ;

			//
			// store newsgroup list
			//
			expireBlock->m_Newsgroups = lpstrNewsgroups ;
			expireBlock->m_fMarkedForDeletion = FALSE ;
			expireBlock->m_references = 0 ;
			expireBlock->m_ExpirePolicy = ExpirePolicyAscii ;
		}	else	{
			FREE_HEAP( lpstrNewsgroups ) ;
			FREE_HEAP( ExpirePolicyAscii ) ;
			return 0 ;
		}
	}
	return	expireBlock ;
}

void
CExpire::CloseExpireBlock( LPEXPIRE_BLOCK	expire ) {

	EnterCriticalSection( &m_CritExpireList ) ;

	expire->m_references -- ;

	if( expire->m_references == 0 && expire->m_fMarkedForDeletion ) {

		RemoveExpireBlock( expire ) ;

		if( expire->m_Newsgroups != 0 ) {
			FREE_HEAP( expire->m_Newsgroups ) ;
		}
		if( expire->m_ExpirePolicy != 0 ) {
			FREE_HEAP( expire->m_ExpirePolicy ) ;
		}
		FREE_HEAP( expire ) ;
	}

	LeaveCriticalSection( &m_CritExpireList ) ;
}

DWORD
CExpire::CalculateExpireBlockSize(	LPEXPIRE_BLOCK	expire )	{

	DWORD	cb = sizeof( NNTP_EXPIRE_INFO ) ;

	cb += MultiListSize( expire->m_Newsgroups ) * sizeof( WCHAR ) ;
	cb += (lstrlen( expire->m_ExpirePolicy )+1) * sizeof( WCHAR ) ;

	return	cb ;
}


void
CExpire::InsertExpireBlock(	LPEXPIRE_BLOCK	expire ) {

	_ASSERT( expire != 0 ) ;

	EnterCriticalSection( &m_CritExpireList ) ;

	_ASSERT(expire->m_pNext == 0 ) ;
	_ASSERT(expire->m_pPrev == 0 ) ;

	if( m_ExpireHead == 0 ) {
		_ASSERT( m_ExpireTail == 0 ) ;
		m_ExpireHead = m_ExpireTail = expire ;
	}	else	{
		expire->m_pNext = m_ExpireHead ;
		m_ExpireHead->m_pPrev = expire ;

		m_ExpireHead = expire ;
	}

    m_cNumExpireBlocks++;
	LeaveCriticalSection( &m_CritExpireList ) ;
}

void
CExpire::RemoveExpireBlock(	LPEXPIRE_BLOCK	expire ) {

	_ASSERT( expire != 0 ) ;

	EnterCriticalSection( &m_CritExpireList ) ;

	if( expire->m_pNext != 0 ) {
		expire->m_pNext->m_pPrev = expire->m_pPrev ;
	}

	if( expire->m_pPrev != 0 ) {
		expire->m_pPrev->m_pNext = expire->m_pNext ;
	}

	if( expire == m_ExpireHead ) {
		m_ExpireHead = expire->m_pNext ;
	}

	if( expire == m_ExpireTail ) {
		m_ExpireTail = expire->m_pPrev ;
	}

    m_cNumExpireBlocks--;
	LeaveCriticalSection( &m_CritExpireList ) ;
}

void
CExpire::LockBlockList()
{
    EnterCriticalSection( &m_CritExpireList ) ;
}

void
CExpire::UnlockBlockList()
{
    LeaveCriticalSection( &m_CritExpireList ) ;
}

LPEXPIRE_BLOCK
CExpire::NextExpireBlock(	LPEXPIRE_BLOCK	expire, BOOL fIsLocked ) {

    if( !fIsLocked ) {
	    EnterCriticalSection( &m_CritExpireList ) ;
    }

	LPEXPIRE_BLOCK	expireOut = 0 ;
	if( expire == 0 ) {
		expireOut = m_ExpireHead ;
	}	else	{
		expireOut = expire->m_pNext ;
	}

	if( expire ) {
		CloseExpireBlock( expire ) ;
	}

	if( expireOut ) {
		expireOut->m_references ++ ;
	}

    if( !fIsLocked ) {
	    LeaveCriticalSection( &m_CritExpireList ) ;
    }

	return	expireOut ;
}

LPEXPIRE_BLOCK
CExpire::SearchExpireBlock(	DWORD	ExpireId ) {

	EnterCriticalSection( &m_CritExpireList ) ;

	LPEXPIRE_BLOCK	expire = 0 ;

	expire = m_ExpireHead ;

	while( expire != 0 && expire->m_ExpireId != ExpireId ) {
		expire = expire->m_pNext ;
	}

	if( expire ) {
		expire->m_references ++ ;
	}

	LeaveCriticalSection( &m_CritExpireList ) ;
	return	expire ;
}


BOOL
CExpire::GetExpireBlockProperties(	IN	LPEXPIRE_BLOCK	lpExpireBlock,
							PCHAR&	Newsgroups,
							DWORD&	cbNewsgroups,
							DWORD&	dwHours,
							DWORD&	dwSize,
							BOOL	fWantUnicode,
                            BOOL&   fIsRoadKill )		{


	_ASSERT( lpExpireBlock != 0 ) ;

	BOOL fOK = FALSE;

	EnterCriticalSection( &m_CritExpireList ) ;

	dwHours = lpExpireBlock->m_ExpireHours ;

	dwSize = lpExpireBlock->m_ExpireSize ;

    fIsRoadKill = (strstr( lpExpireBlock->m_ExpirePolicy, "@EXPIRE:ROADKILL" ) != NULL) ;

	DWORD	length = MultiListSize( lpExpireBlock->m_Newsgroups ) ;

	if( fWantUnicode ) {

		length *= sizeof( WCHAR ) ;
		if( length == 0 ) {
			Newsgroups = (char*)ALLOCATE_HEAP( 2*sizeof( WCHAR ) ) ;
			if( Newsgroups ) {
				Newsgroups[0] = L'\0' ;
				Newsgroups[1] = L'\0' ;
				fOK = TRUE ;
			}
		}	else	{
			Newsgroups = (char*)ALLOCATE_HEAP( length ) ;
			if( Newsgroups != 0 ) {
				WCHAR*	dest = (WCHAR*)Newsgroups ;
				char*	src = lpExpireBlock->m_Newsgroups[0] ;
				for( DWORD	 i=0; i<length; i+=2 ) {
					*(dest)++ = (WCHAR) *((BYTE*)src++) ;
				}
				fOK = TRUE ;
			}
		}
	}	else	{

		if( length == 0 ) {
			Newsgroups = (char*)ALLOCATE_HEAP( 2*sizeof( char ) ) ;
			if( Newsgroups != 0 ) {
				Newsgroups[0] = '\0' ;
				Newsgroups[1] = '\0' ;
				fOK = TRUE ;
			}
		}	else	{
			Newsgroups = (char*)ALLOCATE_HEAP( length ) ;
			if( Newsgroups != 0 ) {
				CopyMemory( Newsgroups, lpExpireBlock->m_Newsgroups[0], length ) ;
				fOK = TRUE ;
			}
		}
	}

	if (fOK)
		cbNewsgroups = length ;
	LeaveCriticalSection( &m_CritExpireList ) ;
	return	fOK ;
}

// called by InitializeExpires
BOOL
CExpire::InitializeRmgroups()
{
	_ASSERT( gpfnHint );

    m_RmgroupQueue = XNEW CQueue;
    if(!m_RmgroupQueue)
        return FALSE;

    return TRUE;
}

// called in CService::Stop before pTree->TermTree()
BOOL
CExpire::TerminateRmgroups( CNewsTree* pTree )
{
	_ASSERT( gpfnHint );

    if(m_RmgroupQueue)
    {
		// If the queue containing deferred rmgroup objects is not empty, process it
		// This could happen if the service is stopped before the next expire cycle kicks in
		if(!m_RmgroupQueue->IsEmpty()) {
			ProcessRmgroupQueue( pTree );
		}

        XDELETE m_RmgroupQueue;
        m_RmgroupQueue = NULL;
    }

    return TRUE;
}

// Process the rmgroup queue
// Called by the expire thread and when the service is stopped
void
CExpire::ProcessRmgroupQueue( CNewsTree* pTree )
{
    BOOL	fElem;
	DWORD	dwStartTick = GetTickCount();

    _ASSERT(m_RmgroupQueue);
	_ASSERT( gpfnHint );

    TraceFunctEnter("CExpire::ProcessRmgroupQueue");

    //
    //  Process all elements in the queue
    //  For each element, call DeleteArticles() to delete all articles in this group
    while(!m_RmgroupQueue->IsEmpty())
    {
        DebugTrace((LPARAM)0, "Dequeueing a rmgroup item");

        CGRPPTR pGroup;
        CGRPPTR pTreeGroup;

        fElem = m_RmgroupQueue->Dequeue( &pGroup);

        if(!fElem)
            break;

        _ASSERT(pGroup);

        // Now, delete all articles in the group
        // This includes removing entries in the hash tables and handling cross-posted articles
        if(!pGroup->DeleteArticles( gpfnHint, dwStartTick ))
        {
            // handle error
            ErrorTrace( (LPARAM)0, "Error deleting articles from newsgroup %s", pGroup->GetName());
        }

        //
        // If the group has been re-created, we'll only delete the articles
        // within our range.  Otherwise we'll remove the whole group physically
        //
        if ( pTreeGroup = pTree->GetGroup( pGroup->GetGroupName(),
                                            pGroup->GetGroupNameLen() )) {
            DebugTrace( 0, "We shouldn't remove the physical group" );
        } else {
		    if ( !pTree->RemoveDriverGroup( pGroup ) ) {
			    ErrorTrace( (LPARAM)0, "Error deleting directory: newsgroup %s", pGroup->GetName());
			}
		}

        DebugTrace((LPARAM)0, "Deleted all articles in newsgroup %s", pGroup->GetName());
    }

    TraceFunctLeave();
}

#if 0

//
// Detailed Design
//
// FOR every wild match string in multi_sz registry key,
//    FOR every news group in the wild match string
//       FOR every article from 'low' to 'high' do
//           Get article filetime from xover.hsh
//           IF article is older than expire horizon
//              Expire Article
//           ELSE
//              Stop scanning articles in this group
//           ENDIF
//       ENDFOR
//    ENDFOR
//    Process next wild match string
// ENDFOR
//

void
CExpire::ExpireArticlesByTimeEx( CNewsTree* pTree )
{
    TraceFunctEnter( "CExpire::ExpireArticlesByTime" );

    //
    // Prepare ftExpireHorizon (TIME) and dwExpireSpace (SIZE)
    // NOTE: This function will process only those policies with
    // dwExpireSpace == 0xFFFFFFFF
    //
    DWORD    dwExpireHorizon;
    DWORD    dwExpireSpace;
    IteratorNode* rgIteratorList;
    DWORD    NumIterators = 0;

    //
    //  Lock the expire block list so we can create our iterator array
    //
    LockBlockList();

    if( m_cNumExpireBlocks == 0 ) {
        //  No work to be done !
        UnlockBlockList();
        return;
    }

    //  No need to clean up this array since its off the stack..
    rgIteratorList = (IteratorNode*)_alloca( m_cNumExpireBlocks * sizeof(IteratorNode) );
    ZeroMemory( (PVOID)rgIteratorList, m_cNumExpireBlocks * sizeof(IteratorNode) );

    LPEXPIRE_BLOCK	expireCurrent = NextExpireBlock( 0, TRUE )  ;
    while ( expireCurrent )
    {
        DWORD	cbNewsgroups = 0 ;
        CGroupIterator* pIterator = 0 ;
        BOOL fIsRoadKill = FALSE ;

        if ( (dwExpireSpace == 0xFFFFFFFF) &&
        	GetExpireBlockProperties(	expireCurrent,
                                        rgIteratorList [NumIterators].multiszNewsgroups,
                                        cbNewsgroups,
                                        dwExpireHorizon,
                                        dwExpireSpace,
                                        FALSE,
                                        fIsRoadKill ) )
        {
            pIterator = pTree->GetIterator( (LPMULTISZ)rgIteratorList [NumIterators].multiszNewsgroups, TRUE, TRUE );
            rgIteratorList [NumIterators].pIterator = pIterator;
            rgIteratorList [NumIterators].ftExpireHorizon = gCalculateExpireFileTime( dwExpireHorizon );

        } else if( rgIteratorList[NumIterators].multiszNewsgroups )  {
            _ASSERT( dwExpireSpace != 0xFFFFFFFF ); // policy has expire by size settings
            FREE_HEAP( rgIteratorList[NumIterators].multiszNewsgroups ) ;
            rgIteratorList[NumIterators].multiszNewsgroups = NULL;
        }

        NumIterators++;
        expireCurrent = NextExpireBlock( expireCurrent, TRUE ) ;
    }

    UnlockBlockList();

    //
    //  ok, now that we have the list of expire iterators, we will round-robin
    //  groups from this list into the expire thread pool. this ensures that
    //  admins who configure virtual roots across multiple drives get the max
    //  parallelism from their drives !!
    //
    g_pNntpSvc->m_pExpireThrdpool->BeginJob( (PVOID)pTree );

    BOOL fMoreGroups = FALSE;
    do {
        //
        //  Round-robin between the group iterators as long as any iterator
        //  has more groups to process..
        //
        fMoreGroups = FALSE;
        for( DWORD i=0; i<NumIterators; i++)
        {
            CGroupIterator* pIterator = rgIteratorList[i].pIterator;
            if( pIterator && !pIterator->IsEnd() )
            {
                //  Get the current group of this iterator and put it on the thrdpool
                CGRPPTR  pGroup = pIterator->Current();
                pGroup->SetGroupExpireTime( rgIteratorList[i].ftExpireHorizon );
                DebugTrace(0,"Adding group %s to expire thrdpool", pGroup->GetName());
                g_pNntpSvc->m_pExpireThrdpool->PostWork( (PVOID)pGroup->GetGroupId() );

                //  advance the iterator. ensure we make one more pass thro the iterators
                pIterator->Next();
                fMoreGroups = TRUE;

            } else if( pIterator ) {
                _ASSERT( pIterator->IsEnd() );
                if( rgIteratorList[i].multiszNewsgroups )  {
                    FREE_HEAP( rgIteratorList[i].multiszNewsgroups ) ;
                    rgIteratorList[i].multiszNewsgroups = NULL;
                }
                XDELETE pIterator;
                rgIteratorList[i].pIterator = NULL;
            }
        }

    } while( fMoreGroups && !pTree->m_bStoppingTree );

#ifdef DEBUG
    for( DWORD i=0; i<NumIterators; i++) {
        _ASSERT( rgIteratorList[i].pIterator == NULL );
        _ASSERT( rgIteratorList[i].multiszNewsgroups == NULL );
    }
#endif

    //
    //  ok, now cool our heels till the expire thrdpool finishes this job !!
    //
    DWORD dwWait = g_pNntpSvc->m_pExpireThrdpool->WaitForJob( INFINITE );
    if( WAIT_OBJECT_0 != dwWait ) {
        ErrorTrace(0,"Wait failed - error is %d", GetLastError() );
    }

    DebugTrace( DWORD(0), "Articles Expired" );
}

//
//  !!! Experimental code if we want to expire based on vroots
//

//
// Detailed Design
//
// FOR each virtual root do
//      FOR each newsgroup in virtual root do
//          Set group expire time by evaluating expire policies
//          (This is similar to check in fAddArticleToPushFeeds)
//          IF group has an expire by time setting
//              Add group to expire thrdpool
//          ENDIF
//      ENDFOR
//  ENDFOR
//

void
CExpire::ExpireArticlesByTime2( CNewsTree* pTree )
{
    TraceFunctEnter( "CExpire::ExpireArticlesByTime2" );

    PNNTP_SERVER_INSTANCE pInst = pTree->GetVirtualServer();
    pInst->Reference();
    BOOL fRet = pInst->TsEnumVirtualRoots( CExpire::ProcessVroot, (LPVOID)pInst );
    pInst->Dereference();
}

static
BOOL
CExpire::ProcessVroot(
                PVOID           pvContext,
                MB*             pMB,
                VIRTUAL_ROOT*   pvr
                )
/*++

Routine Description :

	This function is called by TsEnumVirtualRoots with a given vroot.

Arguments :

	pvContext	-	This is the NNTP virtual server instance
	pmb			-	ptr to metabase object
	pvr			-	current virtual root in the iteration

Return Value :

	TRUE if successfull
	FALSE	otherwise.

--*/
{
    PNNTP_SERVER_INSTANCE pInst = (PNNTP_SERVER_INSTANCE)pvContext;
    CNewsTree* pTree = pInst->GetTree();
    CExpire* pExp = pInst->GetExpireObject();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\debug.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains debug stuff

Author:

    Johnson Apacible (JohnsonA)     11-Jan-1996

Revision History:

--*/

#ifndef _NNTPDEBUG_
#define _NNTPDEBUG_


//
// If this is set, then memory debugging is on
//

#define ALLOC_DEBUG     0

extern DWORD numField;
extern DWORD numArticle;
extern DWORD numPCParse;
extern DWORD numPCString;
extern DWORD numDateField;
extern DWORD numCmd;
extern DWORD numFromPeerArt;
extern DWORD numMapFile;

#endif // _NNTPDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\feedq.h ===
/*++

	feedq.h	
	
	This code will maintain queues of GROUPID:ARTICLEID pairs.
	We attempt to provide some robust persistence by regularily saving
	the Queue information to disk.

--*/

#ifndef _FEEDQ_H_
#define _FEEDQ_H_

#ifdef	UNIT_TEST
typedef	DWORD	GROUPID ;
typedef	DWORD	ARTICLEID ;
#define	MAX_ENTRIES	256
#define	MAX_DEAD_BLOCKS	8
#else
#define	MAX_ENTRIES	256
#define	MAX_DEAD_BLOCKS	8
#endif


//
//	A individual entry within the queue
//
struct	ENTRY	{
	GROUPID		m_groupid ;
	ARTICLEID	m_articleid ;

	inline	BOOL	operator == (	ENTRY&	rhs ) ;
	inline	BOOL	operator != (	ENTRY&	rhs ) ;
	inline	ENTRY(	GROUPID,	ARTICLEID ) ;
	inline	ENTRY() {}
} ;


//
//	Structure for keeping track of queue removal and insertion points
//
struct	HEADER	{
	DWORD		m_iRemovalPoint ;
	DWORD		m_iAppendPoint ;
} ;

//
//	Buffer of Queue ENTRY's
//
typedef		ENTRY	BLOCK[MAX_ENTRIES] ;

//
//	The CFeedQ class manages the queue entirely.
//
//	The class uses 2 CQPortion objects, 1 for managing Append() calls and
//	the other for fulfilling Remove() calls.  Each CQPortion has a fraction
//	of the Queue loaded in memory, the remainder sits in a file on the hard disk.
//	The TWO CQPortions may reference the same buffer of ENTRY's if the 
//	removal and append points are close together.
//
//
class	CFeedQ	{
private :

	//
	//	CQPortion - This is a helper class which keeps track of 
	//	'half' of the queue - ie. either the point in the queue where
	//	we are appending or the point where we are removing.
	//
	class	CQPortion	{
	public : 
		ENTRY	*m_pEntries ;
		DWORD	m_iFirstValidEntry ;
		DWORD	m_iLastValidEntry ;
	public : 
		CQPortion( ) ;

		void	Reset() ;
		BOOL	LoadAbsoluteEntry(	HANDLE	hFile,	ENTRY*	pEntry,	DWORD	iFirstValid,	DWORD	iLastValid ) ;
		void	SetEntry(	ENTRY*	pEntry,	DWORD	i ) ;
		void	SetLimits(	DWORD	i ) ;
		void	Clone( CQPortion&	portion ) ;
		BOOL	FlushQPortion(	HANDLE	hFile ) ;

		BOOL	FIsValidOffset( DWORD	i ) ;
		ENTRY&	operator[](	DWORD	i ) ;

		BOOL	GetAbsoluteEntry(	DWORD	iOneBasedOffset, ENTRY&	entry );
		BOOL	AppendAbsoluteEntry(	DWORD	iOffset,	ENTRY&	entry ) ;
		BOOL	FIsSharing(	CQPortion& ) ;
	} ;

	

	//
	//	CQPortion for location where we are appending
	//	
	CQPortion	m_Append ;

	//
	//	CQPortion for location where we are removing
	//
	CQPortion	m_Remove ;

	//
	//	if m_fShared == TRUE then m_Append and m_Remove are using the same
	//	underlying ENTRY buffer
	//
	BOOL		m_fShared ;

	//
	//	Two buffers for holding the portion of the queue we have in memory
	//
	BLOCK		m_rgBlock[2] ;

	//
	//	Index to buffer being used to hold the Removal buffer
	//	If m_fShared==FALSE then the buffer being used to hold
	//	Appends is m_iRewmoveBlock XOR 1, otherwise it is also
	//	m_iRemoveBlock
	//
	int			m_iRemoveBlock ;	// Index to block being used
									// for removals

	//
	//	Keep track of append and removal points
	//
	HEADER		m_header ;

	//
	//	Number of blocks that we have consumed through Remove() calls
	//
	DWORD		m_cDeadBlocks ;

	//
	//	The file which is backing the Queue
	//
	char		m_szFile[ MAX_PATH ] ;

	//
	//	Handle to the file backing the Queue
	//
	HANDLE		m_hFile ;

	//
	//	Critical section for synchronizing Append() operations
	//
	CRITICAL_SECTION	m_critAppends ;

	//
	//	Critical section for synchronizing Remove() operations.
	//	When both critical sections need to be held m_critRemoves must
	//	always be grabbed first .
	//
	CRITICAL_SECTION	m_critRemoves ;

	//
	//	Get rid of Dead Space in the Queue file.
	//
	BOOL	CompactQueue() ;

	//
	//	Utility functions
	//
	DWORD	ComputeEntryOffset(	DWORD	iEntry ) ;
	BOOL	InternalInit(	LPSTR	lpstrFile ) ;

public : 

	static	inline	DWORD	ComputeBlockFileOffset(	DWORD	iEntry ) ;
	static	inline	DWORD	ComputeFirstValid(	DWORD	iEntry ) ;
	static	inline	DWORD	ComputeBlockStart( DWORD iEntry ) ;

	CFeedQ() ;
	~CFeedQ() ;

	//
	//	Open the specified file if it exists and use it to 
	//	start the queue, other wise create an empty queue and save
	//	to the specified file.
	//
	BOOL	Init(	LPSTR	lpstrFile ) ;

	//
	//	Check whether the queue is empty or not !
	//
	BOOL	FIsEmpty() ;

	//
	//	Close all our handles and flush all queue info to disk.
	//
	BOOL	Close( BOOL fDeleteFile = FALSE ) ;

	//
	//	Add an entry - if FALSE is returned a fatal error occurred
	//	accessing the Queue object.
	//
	BOOL	Append(	GROUPID	groupid,	ARTICLEID	artid ) ;

	//
	//	Remove a Queue entry - if FALSE is returned a fatal error occurred
	//	manipulating the Queue file.  If the queue is empty the function 
	//	will return TRUE and groupid and artid will be 0xFFFFFFFF
	//
	BOOL	Remove(	GROUPID&	groupid,	ARTICLEID&	artid ) ;

	//
	//	Dump the Queue To Disk
	//
	BOOL	StartFlush() ;

	//
	//	Finish dumping to disk - let other threads Append() and Remove() !
	//
	void	CompleteFlush() ;
} ;
	
#endif // _FEEDQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\feedmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    feedmgr.h

Abstract:

    This module contains definitions for the Feed Manager.

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

    Kangrong Yan ( KangYan )    28-Feb-1998
        Added prototypes for Feed Config functions.

--*/

#ifndef _FEEDMGR_
#define _FEEDMGR_

#include "infeed.h"

//
// Block states
//

typedef enum _FEED_BLOCK_STATE {

    FeedBlockStateActive,
    FeedBlockStateClosed,
	FeedBlockStateModified

} FEED_BLOCK_STATE;

//
// defines
//

#define FEED_BLOCK_SIGN         0xacbaedfe
#define MIN_FEED_INTERVAL       1   // in minutes
#define DEF_FEED_INTERVAL       5
#define MAX_DOMAIN_NAME         256

//
// client authent class for logging on feeds
//

class	CAuthenticator	{
public : 
	virtual	BOOL	StartAuthentication( BYTE*	lpb,	unsigned	cb,	unsigned	&cbOut ) = 0 ;
	virtual	BOOL	NextAuthentication(	LPSTR	lpResponse,	BYTE*	lpb,	unsigned	cb,	unsigned&	cbOut,	BOOL&	fComplete,	BOOL&	fSuccessfullLogon ) = 0 ;
	virtual	~CAuthenticator() {}
}	;

class	CClearTextAuthenticator : public	CAuthenticator	{
private : 
	LPSTR	m_lpstrAccount ;
	LPSTR	m_lpstrPassword ;
	BOOL	m_fAccountSent ;
	BOOL	m_fPasswordSent ;
public : 
	CClearTextAuthenticator(	LPSTR	lpstrAccount,	LPSTR	lpstrPassword ) ;
	~CClearTextAuthenticator() {}

	virtual	BOOL	StartAuthentication( BYTE*	lpb,	unsigned	cb,	unsigned	&cbOut ) ;
	virtual	BOOL	NextAuthentication(	LPSTR	lpResponse,	BYTE*	lpb,	unsigned	cb,	unsigned&	cbOut,	BOOL&	fComplete,	BOOL&	fSuccessfullLogon ) ;
} ;




//
// Max length of the feed key name
//

#define FEED_KEY_LENGTH         15

//
//
// Basic feed block
//

typedef struct _FEED_BLOCK {

    //
    // Signature of this block
    //

    DWORD Signature;

	/////////////////////////////////////////////////////////////////////
	// FeedManager Thread ONLY members - only the feed scheduler thread should
	//	touch these fields 

    //
    // Number of feeds done so far - this is set to 0 initially and is 
	// used to make sure the server starts the feed ASAP upon boot-up
    //
    DWORD NumberOfFeeds;

	//
	//	Number of failed connection attempts for Push feeds
	//
	DWORD	cFailedAttempts ;

    //
    // The last newsgroup spec Pulled;
    //
    DWORD LastNewsgroupPulled;

    //
    // Resolved IP address
    //
    DWORD IPAddress;

	////////////////////////////////////
	//
	// Fields usefull for any thread !

    //
    // Used to link feedblocks together
    //
    LIST_ENTRY ListEntry;

	//
	//	Used to determine whether a feed is in progress - 
	//	if no feed is in progress then the fields can safely be changed !
	//
	LONG	FeedsInProgress ;

    //
    // Count of references to this block
    //
    DWORD ReferenceCount;

    //
    // Current State of this block
    //
    FEED_BLOCK_STATE State;

	//
	//	Should we delete this block when the references reach 0 ?
	//
	BOOL		MarkedForDelete ;

	//
	//	Pointer to a FEED_BLOCK that we are replacing and we are waiting
	//	for death of !
	//
	struct	_FEED_BLOCK*		ReplacedBy ;	
	struct	_FEED_BLOCK*		Replaces ;

	////////////////////////////////////////////
	//	
	//	Fields constant accross lifetime of object !
	//

    //
    // Type of this feed (push/pull/passive)
    //
    FEED_TYPE FeedType;

    //
    // Name of reg key this feed info is stored under
    //
    CHAR KeyName[FEED_KEY_LENGTH+1];

	//
	//	The Queue used to record outgoing articles for this ACTIVE outgoing feed
	//
	class	CFeedQ*	pFeedQueue ;

    //
    // Unique id for this feed block
    //
    DWORD FeedId;


	////////////////////////////////////////////
	//
	//	The following are referenced by the feed scheduler thread
	//	as well as admin RPC threads !
	//

    //
    // Should we autocreate directories?
    //
    BOOL AutoCreate;

    //
    // Minutes between feeds
    //
    DWORD FeedIntervalMinutes;

    //
    // When to pull
    //
    FILETIME PullRequestTime;

    //
    // Times used for scheduling:
    //
    // If StartTime is 0, then use increment time
    // If StartTime is not 0 and inc is 0, then schedule once
    //      if inc is not 0, set during 1st run, then increment on
    //          subsequent runs
    //
    ULARGE_INTEGER StartTime;
    ULARGE_INTEGER NextActiveTime;

    //
    // Name of the feed server
    //
    LPSTR ServerName;

    //
    // Newsgroups to pull
    //
    LPSTR *Newsgroups;

    //
    // Distributions
    //
    LPSTR *Distribution;

	//
	//	For push and pull feeds - a flag indicating whether the 
	//	feed is currently 'enabled' - TRUE means we should initiate
	//	sessions, FALSE means dont start sessions.
	//
	//	For accepts feeds, FALSE means we treat incoming connections as
	//	regular client connections instead of a "feed". This effectively
	//	disables the passive feed.
	//
	BOOL	fEnabled ;

	//
	//	The name to be used in Path processing 
	//
	LPSTR*	UucpName ;


	//
	//	The directory where we are to store our temp files !
	//
	LPSTR	FeedTempDirectory ;

	//
	//	Maximum number of consecutive failed connect attempts before 
	//	we disable the feed.
	//	
	DWORD	MaxConnectAttempts ;

	//
	//	Number of sessions to create for outbound feeds
	//
	DWORD	ConcurrentSessions ;

	//
	//	Type of security to have
	//
	DWORD	SessionSecurityType ;

	//
	//	Authentication security
	//
	DWORD	AuthenticationSecurity ;

	//
	//	User Account/Password for clear text logons !
	//
	LPSTR	NntpAccount ;
	LPSTR	NntpPassword ;

	//
	//  Allow control messages on this feed ?
	//
	BOOL	fAllowControlMessages;

	//
	//	port to use for outgoing feeds
	//
	DWORD	OutgoingPort;

	//
	//	associated feed pair id
	//
	DWORD	FeedPairId;

	//
	//  counters used for periodic feed information
	//
	LONG	cSuccessfulArticles;
	LONG	cTryAgainLaterArticles;
	LONG	cSoftErrorArticles;
	LONG	cHardErrorArticles;
} FEED_BLOCK, *PFEED_BLOCK;


class	CFeedList	{
//
//	This class is used to keep lists of FEED_BLOCK's.
//	
//	This class will manage all syncrhronization of updates to FEED_BLOCKs.
//	We use a shared/Exclusive lock to protect the list.
//
public : 

	//
	//	Shared Exclusive Lock for the list.
	//
	RESOURCE_LOCK		m_ListLock ;

	//
	//	NT DOubly linked list structure.  Use NT macros 
	//
	LIST_ENTRY			m_ListHead ;


	//
	//	Constructor just creates empty object - call Init to 
	//	initialize resource's etc...
	//
	CFeedList() ;

	//
	//	Initialize RESOURCE_LOCK's
	//
	BOOL			Init() ;

	//
	//	Release RESOURCE_LOCK's.  Somebody should 
	//	walk the list before calling Term() and delete all the elements.
	//
	BOOL			Term() ;

	//
	//	For debug assert's - check that a FEED_BLOCK is in this list.
	//
	BOOL			FIsInList(	PFEED_BLOCK	block ) ;

	//
	//	The following functions just directly access 
	//	the resource_lock 
	//
	void			ShareLock() ;
	void			ShareUnlock() ;
	void			ExclusiveLock() ;
	void			ExclusiveUnlock() ;
	

	//
	//	This Enumerate interface will step through the list 
	//	keeping the lock held in shared mode until we have completely
	//	gone through the list.  While doing this enumeration,
	//	none of the Feed objects can be removed,deleted or changed
	//

	//
	//	Get the first FEED_BLOCK
	//
	PFEED_BLOCK		StartEnumerate() ;
	
	//
	//	Get The next FEED_BLOCK
	//
	PFEED_BLOCK		NextEnumerate(	PFEED_BLOCK	feedBlock ) ;

	//
	//	If caller wishes to finish enumerating without going through 
	//	the whole list call this function with the last FEED_BLOCK
	//	the caller got so that the locks can be properly released
	//
	void			FinishEnumerate(	PFEED_BLOCK	feedBlock ) ;
	
	//
	//	Used by the enum api's - Internal use only
	//
	PFEED_BLOCK		InternalNext( PFEED_BLOCK ) ;

	//
	//	Next grabs the list exclusively, bumps the FEED_BLOCK's
	//	reference count and then release the lock.
	//	This allows the caller to enumerate the FEED_BLOCKs certain
	//	that they won't be deleted while he is enumerating, but without
	//	having to have the lock held for the duration of the enumeration.
	//	This is necessary in the FeedManager thread to prevent dead locks with ATQ.
	//
	PFEED_BLOCK		Next( PNNTP_SERVER_INSTANCE pInstance, PFEED_BLOCK ) ;
	PFEED_BLOCK		Search(	DWORD	FeedId ) ;
	void			FinishWith( PNNTP_SERVER_INSTANCE pInstance, PFEED_BLOCK ) ;

	//
	//	Remove a FEED_BLOCK from the list
	//	Will grab the list exclusively
	//
	PFEED_BLOCK		Remove( PFEED_BLOCK	feed, BOOL	fMarkDead = FALSE ) ;

	//
	//	Insert a new FEED_BLOCK into the list
	//	will grab the list exclusively
	//
	PFEED_BLOCK		Insert( PFEED_BLOCK ) ;

	//
	//	This call will cause one feed block to be replaced with another.
	//	The replacement doesn't occur untill the feed being replaced 
	//	is not in progress (no active sessions using it.)
	//	If the Feed Blocks are enumerated while a feed is in progress
	//	and the feed has been 'updated' the enumeration will return 
	//	the Update FEED_BLOCK - the Original is effectively invisible.
	//
	void			ApplyUpdate( PFEED_BLOCK	Original,	PFEED_BLOCK	Update ) ;

	//
	//	Mark the FEED_BLOCK as in progress - so that ApplyUpdate calls
	//	pput the Update Block in the list and Original is not replaced
	//	until it is no longer in progress.
	//
	long			MarkInProgress( PFEED_BLOCK	block ) ;

	//
	//	Mark the feed as not in progress.
	//
	long			UnmarkInProgress( PNNTP_SERVER_INSTANCE pInstance, PFEED_BLOCK	block ) ;

	//
	//	Mark the feed as deleted - it should be destroyed when any 
	//	feeds that are in progress complete.
	//
	void			MarkForDelete(	PFEED_BLOCK	block ) ;

} ;
	

//
//
// Macros
//

//
// This computes the required size of the feed block
//

#if 0 
#define FEEDBLOCK_SIZE( _fb )                       \
            (sizeof(NNTP_FEED_INFO) +               \
            (lstrlen(feedBlock->ServerName) + 1 +    \
            MultiListSize(feedBlock->Newsgroups) +  \
            MultiListSize(feedBlock->Distribution)) * sizeof(WCHAR))	\
			(lstrlen(FeedTempDirectory) + 1)
#else

DWORD
MultiListSize(
    LPSTR *List
    ) ;

inline	DWORD
FEEDBLOCK_SIZE( PFEED_BLOCK	feedBlock ) {

	DWORD	cb = 
		sizeof( NNTP_FEED_INFO ) ;

	DWORD	cbUnicode = (lstrlen( feedBlock->ServerName ) + 1)  ;
	cbUnicode += MultiListSize(feedBlock->Newsgroups) ;
	cbUnicode += MultiListSize(feedBlock->Distribution) ;
	if( feedBlock->NntpAccount != 0 ) {
		cbUnicode += lstrlen( feedBlock->NntpAccount ) + 1 ;
	}
	if( feedBlock->NntpPassword != 0 ) {
		cbUnicode += lstrlen( feedBlock->NntpPassword ) + 1 ;
	}
	if( feedBlock->FeedTempDirectory != 0 )	{
		cbUnicode += lstrlen( feedBlock->FeedTempDirectory ) + 1 ;
	}
	if( feedBlock->UucpName != 0 ) {
#if 0 
		cbUnicode += lstrlen( feedBlock->UucpName ) + 1 ;
#endif
		cbUnicode += MultiListSize( feedBlock->UucpName ) ;
	}

	cb += cbUnicode * sizeof( WCHAR ) ;
	return	cb ;
}
#endif




//
// Macro to check whether given IP is a master
//

#define IsNntpMaster( _ip )         IsIPInList(NntpMasterIPList,(_ip))

//
// Macro to check whether given IP is a Peer
//

#define IsNntpPeer( _ip )           IsIPInList(NntpPeerIPList,(_ip))

//
//	Utility function - save feed information to registry !
//

BOOL
UpdateFeedMetabaseValues(
			IN PNNTP_SERVER_INSTANCE pInstance,
            IN PFEED_BLOCK FeedBlock,
            IN DWORD Mask
            );




//
// It creates a feed of the correct type based on a socket.
//

CInFeed * pfeedCreateInFeed(
		PNNTP_SERVER_INSTANCE pInstance,
		PSOCKADDR_IN sockaddr,
		BOOL        fRemoteEqualsLocal,
		CInFeed * & pInFeedFromClient,
		CInFeed * & pInFeedFromMaster,
		CInFeed * & pInFeedFromSlave,
		CInFeed * & pInFeedFromPeer
		);

//
// Prototypes for Feed config functions that replace RPCs
//
DWORD SetFeedInformationToFeedBlock( IN NNTP_HANDLE, IN DWORD, IN LPI_FEED_INFO, OUT PDWORD );
DWORD DeleteFeedFromFeedBlock( IN NNTP_HANDLE, IN DWORD, IN DWORD );
DWORD AddFeedToFeedBlock( IN NNTP_HANDLE, IN DWORD, IN LPI_FEED_INFO, IN LPSTR, OUT PDWORD, OUT LPDWORD );

//
// Utility function, increment the feed counters in a feed block based 
// on an NRC
//
void IncrementFeedCounter(struct _FEED_BLOCK *pFeedBlock, DWORD nrc);

#endif // _FEEDMGR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\iterator.inl ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\expire.h ===
#ifndef	_EXPIRE_H_
#define	_EXPIRE_H_

//
//	Forwards
//
// class CNewsTree ;

//
//	Expire data structures - these consist of expire policies, expire heap
//	rmgroup queue etc. Each virtual server instance will contain a set of
//	these structures. The CExpire class will abstract all of this.
//

#define	EXPIRE_KEY_LENGTH	20
#define DEFAULT_EXPIRE_HORIZON (5*24)
#define INITIAL_NUM_GROUPS 10
#define DEFAULT_EXPIRE_SPACE 500

typedef	struct	_EXPIRE_BLOCK	{
public : 

	struct	_EXPIRE_BLOCK*	m_pNext ;
	struct	_EXPIRE_BLOCK*	m_pPrev ;

	long	m_references ;			// only delete when m_refences goes to 0 and marked !
	BOOL	m_fMarkedForDeletion ;	// set to TRUE when RPC delete request is made
	LPSTR*	m_Newsgroups ;			// 
	DWORD	m_ExpireSize ;			// Megabytes
	DWORD	m_ExpireHours ;
	DWORD	m_ExpireId ;			// for use with RPCs
	LPSTR	m_ExpirePolicy ;		// user-friendly names

}	EXPIRE_BLOCK, *LPEXPIRE_BLOCK ;

//
// simple multi-thread safe queue. enqueue/dequeue operations are synchronized
// TODO: smart ptr stuff
//
typedef struct _QueueElem
{
	struct _QueueElem *pNext;
	CGRPPTR pGroup;

} QueueElem;

class CQueue
{
private:

	DWORD               m_cNumElems;        // number of queue elements, 0 == empty
    CRITICAL_SECTION    m_csQueueLock;      // lock to synch access to the queue
	QueueElem           *m_pHead, *m_pTail;
    
    void LockQ(){ EnterCriticalSection(&m_csQueueLock);}
    void UnlockQ(){ LeaveCriticalSection(&m_csQueueLock);}

public:
	CQueue();
	~CQueue();
	BOOL  Dequeue( CGRPPTR *ppGroup );
	BOOL  Enqueue( CGRPPTR  pGroup );
	BOOL  Search( CGRPPTR *ppGroup, LPSTR lpGroupName );
    BOOL  IsEmpty(){ return m_cNumElems == 0;}
};

BOOL	FillExpireInfoBuffer(
					IN	PNNTP_SERVER_INSTANCE pInstance,
					IN	LPEXPIRE_BLOCK	expire,
					IN OUT LPSTR	*FixedPortion,
					IN OUT LPWSTR	*EndOfVariableData 
					) ;

//
//  <Iterator, filetime, multiszNewsgroups> tuple
//  Required to round-robin groups across expire policies into the thrdpool
//

typedef struct _IteratorNode 
{
    CGroupIterator* pIterator;
    FILETIME        ftExpireHorizon;
    PCHAR	        multiszNewsgroups;
} IteratorNode;

//
//	Class CExpire abstracts the expire operations for a virtual NNTP server.
//	There will be one instance of this class per virtual server instance.
//	The expire thread will loop through the list of virtual server instances,
//	and call expire methods using its CExpire object.
//

class CExpire
{
public:

	//
	//	Expire block policies
	//
	LPEXPIRE_BLOCK		m_ExpireHead ;
	LPEXPIRE_BLOCK		m_ExpireTail ;
	CRITICAL_SECTION	m_CritExpireList ;
    DWORD               m_cNumExpireBlocks;
	BOOL				m_FExpireRunning ;
	CHAR				m_szMDExpirePath [MAX_PATH+1];

	//
	//  Remove group processing
	//
	CQueue*				m_RmgroupQueue ;

	//
	//	Member functions
	//
	CExpire( LPCSTR lpMDExpirePath );
	~CExpire();

	BOOL	InitializeExpires( SHUTDOWN_HINT_PFN pfnHint, BOOL& fFatal, DWORD dwInstanceId ) ;
	BOOL	TerminateExpires( CShareLockNH* pLockInstance ) ;
	BOOL	ReadExpiresFromMetabase() ;
	LPEXPIRE_BLOCK	AllocateExpireBlock(
					IN	LPSTR	keyName	OPTIONAL,
					IN	DWORD	dwExpireSize,
					IN	DWORD	dwExpireHours,
					IN	PCHAR	Newsgroups,
					IN	DWORD	cbNewsgroups,
					IN  PCHAR	ExpirePolicy,
					IN	BOOL	IsUnicode ) ;

	void	CloseExpireBlock(	LPEXPIRE_BLOCK	expire ) ;

	DWORD	CalculateExpireBlockSize( LPEXPIRE_BLOCK	expire ) ;
	LPSTR	QueryMDExpirePath() { return m_szMDExpirePath; }

	BOOL	CreateExpireMetabase(	LPEXPIRE_BLOCK	expire ) ;
	BOOL	SaveExpireMetabaseValues(	MB* pMB, LPEXPIRE_BLOCK	expire ) ;

	LPEXPIRE_BLOCK	NextExpireBlock(	LPEXPIRE_BLOCK	lpExpireBlock, BOOL fIsLocked = FALSE ) ;
	void	MarkForDeletion( LPEXPIRE_BLOCK	lpExpireBlock ) ;
    void    LockBlockList();
    void    UnlockBlockList();

	BOOL	GetExpireBlockProperties(	
								IN	LPEXPIRE_BLOCK	lpExpireBlock, 
								IN	PCHAR&	Newsgroups,
								IN	DWORD&	cbNewsgroups,
								IN	DWORD&	dwHours,	
								IN	DWORD&	dwSize,
								IN	BOOL	fWantUnicode,
                                IN  BOOL&   fIsRoadKill ) ;

	void	SetExpireBlockProperties(	
								IN	LPEXPIRE_BLOCK	lpExpireBlock,
								IN	PCHAR	Newsgroups,
								IN	DWORD	cbNewsgroups,
								IN	DWORD	dwHours,
								IN	DWORD	dwSize,
								IN  PCHAR   ExpirePolicy,
								IN	BOOL	fUnicode ) ;

	void	InsertExpireBlock( LPEXPIRE_BLOCK ) ;
	void	RemoveExpireBlock( LPEXPIRE_BLOCK ) ;
	void	ReleaseExpireBlock(	LPEXPIRE_BLOCK	) ;

	LPEXPIRE_BLOCK	SearchExpireBlock(	DWORD	ExpireId ) ;
	void	ExpireArticlesBySize( CNewsTree* pTree );
	void	ExpireArticlesByTime( CNewsTree* pTree );

	BOOL	DeletePhysicalArticle( CNewsTree* pTree, GROUPID GroupId, ARTICLEID ArticleId, STOREID *pStoreId, HANDLE hToken, BOOL fAnonymous );

	BOOL	ExpireArticle(
					CNewsTree*	  pTree,	
					GROUPID       GroupId,
					ARTICLEID     ArticleId,
					STOREID       *pStoreId,
					class	      CNntpReturn & nntpReturn,
					HANDLE        hToken,
					BOOL          fMustDelete,
					BOOL          fAnonymous,
					BOOL          fFromCancel,
                    BOOL          fExtractNovDone = FALSE,
                    LPSTR         lpMessageId = NULL
					);

    BOOL    ProcessXixBuffer(
                    CNewsTree*  pTree,
                    BYTE*       lpb,
                    int         cb,
                    GROUPID     GroupId,
                    ARTICLEID   artidLow,
                    ARTICLEID   artidHigh,
                    DWORD&      dwXixSize
                    );

    BOOL    ExpireXix( 
                    CNewsTree*  pTree, 
                    GROUPID     GroupId, 
                    ARTICLEID   artidBase,
                    DWORD&      dwXixSize 
                    );

	//
	// Queue of rmgroups to be applied before expiry:
	// An RPC to remove a newsgroup or a rmgroup control message adds the newsgroup object
	// to a queue. The expiry thread actually applies these rmgroup commands before each
	// expiry cycle. 
	//
	BOOL	InitializeRmgroups();
	BOOL	TerminateRmgroups( CNewsTree* );
	void	ProcessRmgroupQueue( CNewsTree* );

	BOOL    MatchGroupEx(	LPMULTISZ	,	CGRPPTR  ) ;
	BOOL    MatchGroupExpire( CGRPPTR pGroup );
};

//
//  CThreadPool manages the creation/deletion of threads and the distribution
//  of work items to the thread pool. Derived classes need to implement the
//  virtual WorkCompletion() function which will be called to process a work item.
//
class CExpireThrdpool : public CThreadPool
{
public:
	CExpireThrdpool()  {}
	~CExpireThrdpool() {}

protected:
    //
    //  Routine that does the actual expire work. pvExpireContext is a newsgroup object.
    //
	virtual VOID WorkCompletion( PVOID pvExpireContext );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\feedq.cpp ===
//#ifdef	UNIT_TEST
//#include	<windows.h>
//#include	<limits.h>
//#include	<dbgtrace.h>
//#include	"feedq.h"
//#else
#include	"tigris.hxx"
//#endif

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif


inline	BOOL
ENTRY::operator==( ENTRY&	rhs )	{
/*++

Routine Description :

	Test to see whether two ENTRY's are the same

Arguments :

	The right hand side of the == expression

Return Value :

	TRUE if the two ENTRY's are identical

--*/

	return	memcmp( this, &rhs, sizeof( rhs ) ) == 0 ;

}

inline	BOOL
ENTRY::operator!=( ENTRY&	rhs )	{
/*++

Routine Description

	Test to see whether two ENTRY's are different

Arguments :

	The RHS of the != expression

Return Value :

	TRUE if not equal false otherwise.

--*/

	return	memcmp( this, &rhs, sizeof( rhs ) ) != 0 ;

}


inline
ENTRY::ENTRY(	GROUPID	groupid,	ARTICLEID	artid ) :
/*++

Routine Description :

	Initialize an ENTRY

Arguments :

	groupid and artid to initialize the entry too.

Return Value :

	none.

--*/
	m_groupid( groupid ),
	m_articleid( artid )	{
}

CFeedQ::CFeedQ() :
	m_hFile( INVALID_HANDLE_VALUE ),
	m_fShared( FALSE ),
	m_cDeadBlocks( 0 ),
	m_iRemoveBlock( 0 )	{
/*++

Routine Description :

	Initialize a CFeedQ object - set everything up to an empty state !

Arguments :

	None.

Return Value :

	None.

--*/

	m_header.m_iRemovalPoint = 0 ;
	m_header.m_iAppendPoint = 0 ;

	InitializeCriticalSection(	&m_critAppends ) ;
	InitializeCriticalSection(	&m_critRemoves ) ;

	FillMemory( &m_rgBlock[0][0], sizeof( m_rgBlock ), 0xFF ) ;
}


CFeedQ::~CFeedQ() {
/*++

Routine Description :

	Destroy a CFeedQ object - Close() should be called first if Init() has been called !

Arguments :

	None.

Return Value :

	None.

--*/

	_ASSERT( m_hFile = INVALID_HANDLE_VALUE ) ;

	DeleteCriticalSection( &m_critAppends ) ;
	DeleteCriticalSection( &m_critRemoves ) ;
}


CFeedQ::CQPortion::CQPortion() :
	m_pEntries( 0 ),
	m_iFirstValidEntry( 0xFFFFFFFF ),
	m_iLastValidEntry( 0xFFFFFFFF )	{
}

inline	DWORD
CFeedQ::ComputeBlockFileOffset(	DWORD	iEntry )	{

	DWORD	ibFileOffset = (iEntry) *  sizeof( ENTRY ) ;
	return	ibFileOffset - (ibFileOffset % sizeof( ENTRY )) ;
}

inline	DWORD
CFeedQ::ComputeBlockStart(	DWORD	iEntry )	{

	return	CFeedQ::ComputeBlockFileOffset(	iEntry - (iEntry % MAX_ENTRIES) ) ;
}

inline	DWORD
CFeedQ::ComputeFirstValid(	DWORD	iEntry )	{
	return	(iEntry) - (iEntry) % MAX_ENTRIES ;
}

BOOL
CFeedQ::CQPortion::LoadAbsoluteEntry(	HANDLE	hFile,
							ENTRY*	pEntry,
							DWORD	iFirstValid,
							DWORD	iLastValid ) {
/*++

Routine Description :

	Load a portion of the queue from the file into the specified buffer.
	The desired index starting position into the queue is also passed.

Arguments :

	hFile - File to read from
	pEntry-	Buffer to use to hold data
	iFirstValid -	Index into the Queue as a whole, we want the indexed item
		to end up somewhere in the buffer we read.

Return Value :
	TRUE if successfull.
	FALSE otherwise

--*/

	TraceFunctEnter( "LoadAbsoluteEntry" ) ;

	_ASSERT(	hFile	!= INVALID_HANDLE_VALUE ) ;
	_ASSERT(	pEntry  != 0 ) ;
	_ASSERT(	iLastValid >= iFirstValid ) ;

	DWORD	cbRead = 0 ;

	iFirstValid = ComputeFirstValid( iFirstValid ) ;

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;
	ovl.Offset = ComputeBlockFileOffset(	iFirstValid ) ;

	DebugTrace( (DWORD_PTR)this, "iFirstValid is %x Offset %x", iFirstValid, ovl.Offset ) ;

	if( ReadFile(	hFile,
					pEntry,
					sizeof( BLOCK ),
					&cbRead,
					&ovl ) )	{

		m_pEntries = &(pEntry[0]) ;
		m_iFirstValidEntry = ComputeFirstValid( iFirstValid ) ;
		m_iLastValidEntry = m_iFirstValidEntry + cbRead / sizeof( ENTRY ) ;

		DebugTrace( (DWORD_PTR)this, "m_iFirstValid %x m_iLastValid %x",
			m_iFirstValidEntry, m_iLastValidEntry ) ;

		//
		//	If first block first entry is unused (saved for header.)
		//
		return	TRUE ;
	}

	ErrorTrace( (DWORD_PTR)this, "Read failed - cbRead %x GLE %x", cbRead, GetLastError() ) ;

	return	FALSE ;
}

BOOL
CFeedQ::CQPortion::FlushQPortion(	HANDLE	hFile ) {
/*++

Routine Description :

	Save a portion of the Queue to the specified file.

Arguments :

	hFile	 -	File to save to

REturn Value :

	TRUE if successfull,
	FALSe	otherwise.

--*/

	TraceFunctEnter( "FlushQPortion" ) ;

	_ASSERT( m_pEntries != 0 ) ;
	_ASSERT( m_iLastValidEntry > m_iFirstValidEntry ) ;
	_ASSERT( hFile != INVALID_HANDLE_VALUE ) ;

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;
	ovl.Offset = ComputeBlockFileOffset( m_iFirstValidEntry ) ;

	DWORD	cbToWrite = (m_iLastValidEntry - m_iFirstValidEntry) * sizeof( ENTRY ) ;
	DWORD	cbWrite = 0 ;

	if( WriteFile(	hFile,
					m_pEntries,
					cbToWrite,
					&cbWrite,
					&ovl ) )	{

		if( cbWrite != cbToWrite )
			return	FALSE ;
		else
			return	TRUE ;
	}

	ErrorTrace( (DWORD_PTR)this, "WriteFile failed cbWrite %x cbToWrite %x GLE %x",
		cbWrite, cbToWrite, GetLastError() ) ;

	return	FALSE ;
}

BOOL
CFeedQ::CQPortion::FIsValidOffset(	DWORD	i ) {
	return	(i>=m_iFirstValidEntry) && (i < m_iLastValidEntry) ;
}

ENTRY&
CFeedQ::CQPortion::operator[](	DWORD	i ) {

	_ASSERT( i >= m_iFirstValidEntry ) ;
	_ASSERT( i < m_iLastValidEntry ) ;

	return	m_pEntries[ i - m_iFirstValidEntry ] ;
}

void
CFeedQ::CQPortion::Reset(	void	)	{

	m_pEntries = 0 ;
	m_iFirstValidEntry = 0 ;
	m_iLastValidEntry = 0 ;

}

void
CFeedQ::CQPortion::SetEntry(	ENTRY*	pEntry,	DWORD	i )		{

	m_pEntries = pEntry ;
	m_iFirstValidEntry = i ;
	m_iLastValidEntry = i + MAX_ENTRIES ;
}

void
CFeedQ::CQPortion::SetLimits(	DWORD	i )		{

	m_iFirstValidEntry = ComputeFirstValid( i ) ;
	m_iLastValidEntry = m_iFirstValidEntry + MAX_ENTRIES ;
}


void
CFeedQ::CQPortion::Clone(	CFeedQ::CQPortion&	portion	)	{
	m_pEntries = portion.m_pEntries ;
	m_iFirstValidEntry = portion.m_iFirstValidEntry ;
	m_iLastValidEntry = portion.m_iLastValidEntry ;
}

BOOL
CFeedQ::Init(	LPSTR	lpstrFile )		{

	m_fShared = FALSE ;
	m_cDeadBlocks = 0 ;
	m_iRemoveBlock = 0 ;
	m_header.m_iRemovalPoint = 0 ;
	m_header.m_iAppendPoint = 0 ;

	BOOL fRtn = InternalInit( lpstrFile ) ;
	if( fRtn ) {
		return	fRtn ;
	}	else	if( GetLastError() == ERROR_FILE_CORRUPT ) {
		if(	DeleteFile(	lpstrFile ) )	{
			return	InternalInit( lpstrFile ) ;
		}
	}
	return	fRtn ;
}


BOOL
CFeedQ::InternalInit(	LPSTR	lpstrFile ) {
/*++

Routine Description :

	Create a queue based upon the specified file.
	If the file exists we will try to read it in as a queue,
	if it doesn't we will create a queue and use the file to
	save the queue contents when necessary.

Arguments :

	lpstrFile -	Name of the file to hold queue in

Return Value :

	TRUE	if successfull
	FALSE	otherwise

	if we fail and GetLastError() == ERROR_FILE_CORRUPT
	then the file name specified contains a unrecoverable or invalid queue object.

--*/

	BOOL	fRtn = FALSE ;

	lstrcpy( m_szFile, lpstrFile ) ;

	m_hFile = CreateFile( lpstrFile,
							GENERIC_READ | GENERIC_WRITE,
							FILE_SHARE_READ,
							0,	// No security
							OPEN_ALWAYS,
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
							INVALID_HANDLE_VALUE ) ;

	if( m_hFile != INVALID_HANDLE_VALUE ) {

		BY_HANDLE_FILE_INFORMATION	fileInfo ;
		if( !GetFileInformationByHandle( m_hFile, &fileInfo ) )	{
			_VERIFY( CloseHandle( m_hFile ) );
			return	FALSE ;
		}

		if( fileInfo.nFileSizeLow > 0 ) {
			DWORD	cb = 0 ;
			ENTRY	empty( 0xFFFFFFFF, 0xFFFFFFFF ) ;

			m_header.m_iRemovalPoint = 0 ;
			m_header.m_iAppendPoint = 0 ;
			m_iRemoveBlock = 0 ;

			if( m_Remove.LoadAbsoluteEntry(	m_hFile,
										&m_rgBlock[ m_iRemoveBlock ][0],
										m_header.m_iAppendPoint,
										LONG_MAX ) )	{


				while( m_Remove[ m_header.m_iRemovalPoint ] == empty ) {
					m_header.m_iRemovalPoint ++ ;
					if( !m_Remove.FIsValidOffset( m_header.m_iRemovalPoint ) )	{
						if( !m_Remove.LoadAbsoluteEntry(	m_hFile,
													&m_rgBlock[m_iRemoveBlock][0],
													m_header.m_iRemovalPoint,
													LONG_MAX ) )	{
							DWORD dw = GetLastError() ;
							if( dw == ERROR_HANDLE_EOF ) {
								// The Queue is empty !!

								m_header.m_iRemovalPoint = 0 ;
								m_header.m_iAppendPoint = 0 ;
								m_Remove.SetEntry( &m_rgBlock[m_iRemoveBlock][0], 0 ) ;
								m_Append.Clone( m_Remove ) ;
								m_fShared = TRUE ;
								fRtn = TRUE ;
								_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
								_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

								SetFilePointer( m_hFile, 0, 0, FILE_BEGIN ) ;
								SetEndOfFile( m_hFile ) ;
								return	TRUE ;

							}	else	{
								m_cDeadBlocks ++ ;
								_VERIFY( CloseHandle( m_hFile ) );
								m_hFile = INVALID_HANDLE_VALUE ;
								SetLastError( ERROR_FILE_CORRUPT ) ;
								return	FALSE ;
							}

						}	else	{
							m_cDeadBlocks++ ;
						}
					}
				}
			}	else	{
				_VERIFY( CloseHandle( m_hFile ) );
				m_hFile = INVALID_HANDLE_VALUE ;
				SetLastError( ERROR_FILE_CORRUPT ) ;
				return	FALSE ;
			}

			m_header.m_iAppendPoint = m_header.m_iRemovalPoint ;

			m_Append.Clone( m_Remove ) ;
			m_fShared = TRUE ;

			while(	m_Append[ m_header.m_iAppendPoint ] != empty	) {

				m_header.m_iAppendPoint ++ ;
				if( !m_Append.FIsValidOffset(	m_header.m_iAppendPoint ) )	{
					if( !m_Append.LoadAbsoluteEntry(	m_hFile,
												&m_rgBlock[ m_iRemoveBlock ^ 1 ][0],
												m_header.m_iAppendPoint,
												LONG_MAX ) )	{
						m_fShared = FALSE ;


						if( m_Remove.FIsValidOffset( m_header.m_iAppendPoint ) ) {
							m_Append.Clone( m_Remove ) ;
							m_fShared = TRUE ;
							fRtn = TRUE ;
							break ;
						}	else	{
							m_Append.SetEntry( &m_rgBlock[m_iRemoveBlock^1][0], m_header.m_iAppendPoint ) ;
							m_fShared = FALSE ;
							fRtn = TRUE ;
							_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
							_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;
						}
						break ;
					}	else	{
						m_fShared = FALSE ;
					}

				}
			}
			fRtn = CompactQueue() ;

			_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
			_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

		}	else	{
			m_Remove.SetEntry(	&m_rgBlock[m_iRemoveBlock][0], 0 ) ;
			m_Append.Clone( m_Remove ) ;
			m_fShared = TRUE ;
			fRtn = TRUE ;
			_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
			_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

		}
	}
	if( !fRtn )		{
		if( m_hFile != INVALID_HANDLE_VALUE ) {
			_VERIFY( CloseHandle( m_hFile ) );
			m_hFile = INVALID_HANDLE_VALUE ;
		}
		m_Append.Reset() ;
		m_Remove.Reset() ;
	}
	return	fRtn ;
}

BOOL
CFeedQ::FIsEmpty()	{

	BOOL	fRtn = FALSE ;

	EnterCriticalSection( &m_critRemoves ) ;
	EnterCriticalSection( &m_critAppends ) ;

	fRtn = m_header.m_iRemovalPoint == m_header.m_iAppendPoint ;

	LeaveCriticalSection( &m_critAppends ) ;
	LeaveCriticalSection( &m_critRemoves ) ;

	return	fRtn ;

}

BOOL
CFeedQ::Close( BOOL fDeleteFile )	{
/*++

Routine Description :

	This function saves all of the Queue contents and close all of our handles.

Arguments :

	fDeleteFile -   If TRUE, delete the fdq file

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	EnterCriticalSection( &m_critRemoves ) ;
	EnterCriticalSection( &m_critAppends ) ;

	_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
	_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

	BOOL	fRtn = TRUE ;


	if( !m_Append.FlushQPortion( m_hFile ) )	{
		fRtn = FALSE ;
	}	else	if(	m_fShared || m_Remove.FlushQPortion( m_hFile ) ) {

		fRtn &=	CompactQueue() ;

	}	else	{

		fRtn = FALSE ;

	}

	_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
	_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;


	if( m_hFile != INVALID_HANDLE_VALUE ) {
		fRtn &= CloseHandle( m_hFile ) ;
		m_hFile = INVALID_HANDLE_VALUE ;
		if( fDeleteFile ) {
            fRtn &= DeleteFile( m_szFile );
		}
	}

	LeaveCriticalSection( &m_critAppends ) ;
	LeaveCriticalSection( &m_critRemoves ) ;

	return	fRtn ;
}





BOOL
CFeedQ::Append(	GROUPID	groupid,
				ARTICLEID	artid )	{
/*++

Routine Description :

	This function will append a groupid,article id pair to the queue.

Arguments :

	groupid and artid - the pair to be appended

Return Value :

	TRUE if successfull -
	FALSE - A fatal error occurred manipulating the queue.


--*/

	ENTRY	entry ;
	entry.m_groupid = groupid ;
	entry.m_articleid = artid ;
	BOOL	fRtn = TRUE ;

#ifndef	UNIT_TEST
	_ASSERT( groupid != INVALID_ARTICLEID ) ;
	_ASSERT( artid != INVALID_ARTICLEID ) ;
#endif

	EnterCriticalSection( &m_critAppends ) ;

	if(	m_Append.FIsValidOffset( m_header.m_iAppendPoint ) )	{
		m_Append[ m_header.m_iAppendPoint ] = entry ;
		m_header.m_iAppendPoint ++ ;
	}	else	{

		if( !m_Append.FlushQPortion( m_hFile ) )	{
			fRtn = FALSE ;
		}	else	{
			ENTRY*	pEntries = & m_rgBlock[ m_iRemoveBlock ^ 1 ][0] ;
			FillMemory( pEntries, sizeof( m_rgBlock[0] ), 0xFF ) ;
			m_Append.SetEntry( pEntries, m_header.m_iAppendPoint ) ;
			m_Append[ m_header.m_iAppendPoint ] = entry ;
			m_header.m_iAppendPoint ++ ;
			m_fShared = FALSE ;

			_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
			_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

		}
	}
	LeaveCriticalSection( &m_critAppends ) ;
	return	fRtn ;
}


BOOL
CFeedQ::Remove(	GROUPID&	groupid,
				ARTICLEID&	artid )	{
/*++

Routine Description :

	Remove a groupid artid pair from the queue.  If the queue is empty return
	-1 for groupid and artid and return TRUE.


Arguments :

	groupid, artid - references which will hold the returned values

Return Value :

	TRUE if the queue is OK FALSE if a fatal file error occurred manipulating the queue.

--*/

	TraceFunctEnter( "CFeedQ::Remove" ) ;

	BOOL	fRtn = TRUE ;

	groupid = 0xFFFFFFFF ;
	artid = 0xFFFFFFFF ;

	EnterCriticalSection( &m_critRemoves ) ;

	DebugTrace( (DWORD_PTR)this, "m_iRemovalPoint %x m_iAppendPoint %x",
		m_header.m_iRemovalPoint, m_header.m_iAppendPoint ) ;

	if( m_header.m_iRemovalPoint < m_header.m_iAppendPoint )	{

		if( !m_Remove.FIsValidOffset( m_header.m_iRemovalPoint ) )	{

			m_cDeadBlocks ++ ;

			DebugTrace( (DWORD_PTR)this, "m_cDeadBlocks is now %d", m_cDeadBlocks ) ;

			EnterCriticalSection( &m_critAppends ) ;

			if( m_Append.FIsValidOffset( m_header.m_iRemovalPoint ) ) {

				DebugTrace( (DWORD_PTR)this, "m_iRemoveBlock %x m_fShared was %x", m_iRemoveBlock,
					m_fShared ) ;

				m_iRemoveBlock ^= 1 ;
				m_Remove.Clone( m_Append ) ;
				m_fShared = TRUE ;

			}	else	{
				fRtn = m_Remove.LoadAbsoluteEntry( m_hFile,
											&m_rgBlock[ m_iRemoveBlock ][0],
											m_header.m_iRemovalPoint,
											LONG_MAX ) ;
			}

			if( m_cDeadBlocks > MAX_DEAD_BLOCKS )	{

				CompactQueue() ;

			}

			_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
			_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

			LeaveCriticalSection( &m_critAppends ) ;
		}


		if( m_Remove.FIsValidOffset( m_header.m_iRemovalPoint ) ) {

			DebugTrace( (DWORD_PTR)this, "m_iRemovalPoint now %x", m_header.m_iRemovalPoint ) ;

			ENTRY	entry = m_Remove[ m_header.m_iRemovalPoint ] ;
			groupid = entry.m_groupid ;
			artid =	  entry.m_articleid ;

			_ASSERT( groupid != 0xFFFFFFFF ) ;
			_ASSERT( artid != 0xFFFFFFFF ) ;

			entry.m_groupid = 0xFFFFFFFF ;
			entry.m_articleid = 0XFFFFFFFF ;
			m_Remove[m_header.m_iRemovalPoint] = entry ;
			m_header.m_iRemovalPoint ++ ;
		}

	}
	LeaveCriticalSection( &m_critRemoves ) ;
	return	fRtn ;
}

BOOL
CFeedQ::StartFlush( )	{

	EnterCriticalSection( &m_critRemoves ) ;
	EnterCriticalSection( &m_critAppends ) ;

	return	CompactQueue() ;

}
void
CFeedQ::CompleteFlush()	{

	LeaveCriticalSection( &m_critAppends ) ;
	LeaveCriticalSection( &m_critRemoves ) ;

}


BOOL
CFeedQ::CompactQueue()	{
/*++

Routine Description :

	Remove unused space in the Queue's disk representation.

Arguments :

	None.

Return Value :

	TRUE if successfull
	FALSE if failed - if FALSE the queue is no longer usable.


--*/

	TraceFunctEnter( "CFeedQ::CompactQueue" ) ;

	DWORD	cbRead = 0,	cbWrite = 0 ;
	char	szTempFile[ MAX_PATH ] ;
	BOOL	fSuccess = FALSE ;

	lstrcpy( szTempFile, m_szFile ) ;

	char*	pchEnd = szTempFile + lstrlen( szTempFile ) ;
	while( *pchEnd != '.' && *pchEnd != '\\' && pchEnd > szTempFile ) {
		pchEnd -- ;
	}

	if( *pchEnd == '.' ) {
		lstrcpy( pchEnd +1, "bup" ) ;
	}	else	{
		lstrcat( szTempFile, ".bup" ) ;
	}

	OVERLAPPED	ovl ;
	ZeroMemory( &ovl, sizeof( ovl ) ) ;

	DebugTrace( (DWORD_PTR)this, " szTempFile =%s= m_szFile =%s=", szTempFile, m_szFile ) ;

	if( CopyFile( m_szFile, szTempFile, FALSE ) )	{

		DebugTrace( (DWORD_PTR)this, "m_iRemovalPoint %x m_iAppendPoint %x m_cDeadBlocks %x",
			m_header.m_iRemovalPoint, m_header.m_iAppendPoint, m_cDeadBlocks ) ;

		if( m_header.m_iRemovalPoint == m_header.m_iAppendPoint ) {

			fSuccess = TRUE ;
			fSuccess &= (0==SetFilePointer( m_hFile, 0, 0, FILE_BEGIN )) ;
			fSuccess &= SetEndOfFile( m_hFile ) ;

			DebugTrace( (DWORD_PTR)this, "fSuccess %x", fSuccess ) ;

			if( fSuccess && m_header.m_iRemovalPoint != 0 ) {
				m_header.m_iRemovalPoint = 0 ;
				m_header.m_iAppendPoint = 0 ;
				m_cDeadBlocks = 0 ;
				FillMemory( &m_rgBlock[0][0], sizeof( m_rgBlock ), 0xFF ) ;
				ovl.Offset = 0 ;
				fSuccess = WriteFile( m_hFile, &m_rgBlock[0][0], sizeof( m_rgBlock[0] ), &cbWrite, &ovl ) ;

				m_iRemoveBlock = 0 ;
				m_Append.SetEntry( &m_rgBlock[m_iRemoveBlock][0], 0 ) ;
				m_Remove.Clone( m_Append ) ;
				m_fShared = TRUE ;
			}

		}	else	{

			//
			//	Now we need to copy blocks arround.
			//

			if( m_cDeadBlocks == 0 )	{

				fSuccess = TRUE ;

			}	else	{

				ENTRY	*pEntries = &m_rgBlock[ m_iRemoveBlock ][0] ;

				HANDLE	hTempFile = CreateFile( szTempFile,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ,
										0,	// No security
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
										m_hFile ) ;

				DebugTrace( (DWORD_PTR)this, " hTempFile %x ", hTempFile ) ;

				if( hTempFile != INVALID_HANDLE_VALUE )	{

					DWORD	ibFirst = ComputeBlockStart( m_header.m_iRemovalPoint ) ;
					DWORD	ibLast = ComputeBlockStart( m_header.m_iAppendPoint ) ;
					DWORD	ibStart = ibFirst ;

					_ASSERT( ibLast >= ibFirst ) ;

					if( SetFilePointer( m_hFile, 0, 0, FILE_BEGIN ) == 0 )	{

						do	{

							ZeroMemory( &ovl, sizeof( ovl ) ) ;
							if( ibStart != ibFirst )	{
								ovl.Offset = ibFirst ;
								fSuccess = ReadFile(	hTempFile,
											pEntries,
											sizeof( m_rgBlock[0] ),
											&cbRead,
											&ovl ) ;
							}	else	{
								//
								//	m_head already contains the starting block properly
								//	filled with 0xFFFFFFFF for consumed entries
								//
								cbRead = sizeof( m_rgBlock[0] ) ;
								fSuccess = TRUE ;
							}
							if( fSuccess ) {
								ZeroMemory( &ovl, sizeof( ovl ) ) ;
								fSuccess = WriteFile(	m_hFile,
														pEntries,
														cbRead,
														&cbWrite,
														0 ) ;
								ibFirst += sizeof( m_rgBlock[0] ) ;
							}

							DebugTrace( (DWORD_PTR)this, "fSuccess %x ibFirst %x ibLast %x",
								fSuccess, ibFirst, ibLast  ) ;

						}	while(	fSuccess && ibFirst < ibLast ) ;
						if( fSuccess && !m_fShared ) {

							fSuccess = WriteFile( m_hFile,
													&m_rgBlock[ m_iRemoveBlock ^ 1 ],
													sizeof( m_rgBlock[0] ),
													&cbWrite,
													0 ) ;
						}


						//
						//	Truncate the file !!
						//
						if( fSuccess )
							fSuccess &= SetEndOfFile( m_hFile ) ;

					}

					DebugTrace( (DWORD_PTR)this, "fSuccess %x", fSuccess ) ;

					if( fSuccess )	{
						m_fShared = FALSE ;
						m_header.m_iRemovalPoint -= m_cDeadBlocks * MAX_ENTRIES ;
						m_header.m_iAppendPoint -= m_cDeadBlocks * MAX_ENTRIES ;
						m_cDeadBlocks = 0 ;

						m_Append.SetLimits( m_header.m_iAppendPoint ) ;

						DebugTrace( (DWORD_PTR)this, "m_iRemovalPoint %x m_iAppendPoint %x m_cDeadBlocks %x",
							m_header.m_iRemovalPoint, m_header.m_iAppendPoint, m_cDeadBlocks ) ;

						if( m_Append.FIsValidOffset( m_header.m_iRemovalPoint ) ) {

							DebugTrace( (DWORD_PTR)this, "Cloning Append queue" ) ;

							m_Remove.Clone( m_Append ) ;
							m_fShared = TRUE ;
							if( m_Remove.m_pEntries == &m_rgBlock[0][0] )
								m_iRemoveBlock = 0 ;
							else
								m_iRemoveBlock = 1 ;
							fSuccess = TRUE ;

							_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
							_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

						}	else	{

							if( m_Append.m_pEntries == &m_rgBlock[m_iRemoveBlock][0] ) {
								m_iRemoveBlock ^= 1 ;
							}

							fSuccess = m_Remove.LoadAbsoluteEntry( m_hFile,
														&m_rgBlock[m_iRemoveBlock][0],
														m_header.m_iRemovalPoint,
														LONG_MAX ) ;

							_ASSERT(	m_Remove.m_pEntries == &m_rgBlock[ m_iRemoveBlock ][0] ) ;
							_ASSERT(	(!!m_fShared) ^ (m_Append.m_pEntries == &m_rgBlock[ m_iRemoveBlock ^ 1 ][0]) ) ;

						}
					}

					_VERIFY( CloseHandle( hTempFile ) );
				}
			}
		}

		if( fSuccess ) {

		}

		// we do not need the temp file anymore - delete it !
		_VERIFY( DeleteFile( szTempFile ) );
	}

	DebugTrace( (DWORD_PTR)this, " fSuccess %x ", fSuccess ) ;

	return	fSuccess ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\feedmgr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    feedmgr.cpp

Abstract:

    This module contains code for the feed manager

Author:

    Johnson Apacible (JohnsonA)     12-Nov-1995

Revision History:

    Kangrong Yan ( KangYan ) 24-Feb-1998:

        Feed config rpc goes away.  So the feed config in metabase could be bad.
        Service boot needs to check not to load bad feeds.  Also, make the orginal
        RPCs for feed config internal functions.

--*/

#include <buffer.hxx>
#include "tigris.hxx"
#include "feedmgr.h"

//
// forward prototypes
//

VOID
InsertFeedBlockIntoQueue(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    );

VOID
ComputeNextActiveTime(
		IN PNNTP_SERVER_INSTANCE pInstance,
		IN PFEED_BLOCK FeedBlock,
		IN FILETIME*	NextPullTime,
        IN BOOL SetNextPullTime
        );

VOID
ReferenceFeedBlock(
    PFEED_BLOCK FeedBlock
    );

BOOL
ProcessInstanceFeed(
				PNNTP_SERVER_INSTANCE	pInstance
				);

DWORD
WINAPI
FeedScheduler(
        LPVOID Context
        );

BOOL
InitializeFeedsFromMetabase(
    PNNTP_SERVER_INSTANCE pInstance,
	BOOL& fFatal
    );

BOOL
IsFeedTime(	
	PNNTP_SERVER_INSTANCE pInstance,
	PFEED_BLOCK	feedBlock,	
	ULARGE_INTEGER	liCurrentTime
	) ;

VOID
SetNextPullFeedTime(
	PNNTP_SERVER_INSTANCE pInstance,
	FILETIME*	pNextTime,
    PFEED_BLOCK FeedBlock
    );

BOOL
InitiateOutgoingFeed(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    );

BOOL
ResumePeerFeed(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    );

BOOL
BuildFeedQFileName(	
			char*	szFileOut,	
			DWORD	cbFileOut,	
			char*   szFileIn,
			char*	szPathIn
			);

void
BumpOutfeedCountersUp( PNNTP_SERVER_INSTANCE pInstance );

void
BumpOutfeedCountersDown( PNNTP_SERVER_INSTANCE pInstance );

void
LogFeedAdminEvent(
            DWORD       event,
            PFEED_BLOCK feedBlock,
            DWORD       dwInstanceId
            )   ;

CClearTextAuthenticator::CClearTextAuthenticator(	LPSTR	lpstrAccount,	LPSTR	lpstrPassword ) :
	m_lpstrAccount( lpstrAccount ),
	m_lpstrPassword( lpstrPassword ),
	m_fAccountSent( FALSE ),
	m_fPasswordSent( FALSE )	 {
/*++

Routine Description :

	Initialize a CClearTextAuthentication object -
	we will handle clear text authentication negogtiations.

Arguments :

	lpstrAccount - clear text account to issue in authinfo user command
	lpstrPassword - password to send in authinfo pass command

Return Value :

	None.

--*/
}

BOOL
CClearTextAuthenticator::StartAuthentication(	BYTE*		lpb,	
												unsigned	cb,	
												unsigned&	cbOut )	{	
/*++

Routine Description :

	Send the initial logon request for a clear text account/password logon !

Arguements :

	lpb -	Buffer in which to place send request
	cb	-	Number of bytes of space in buffer
	cbOut - Return the number of bytes used in the buffer
	fComplete - Is the logon Complete
	fComplete - Return whether the logon was successfull !

Return	Value :
	TRUE	if Successfull - FALSE otherwise !

--*/

	const	char	szCommand[] = "authinfo user " ;

	_ASSERT( !m_fAccountSent ) ;
	_ASSERT( !m_fPasswordSent ) ;

	int	cbAccount = lstrlen( m_lpstrAccount ) ;
	cbOut = 0 ;

	if( cb < sizeof( szCommand ) + cbAccount + 2 ) {
		return	FALSE ;
	}	else	{
		
		CopyMemory( lpb, szCommand, sizeof( szCommand ) - 1 ) ;
		cbOut =	sizeof( szCommand ) - 1 ;
		CopyMemory( lpb + cbOut, m_lpstrAccount, cbAccount ) ;
		cbOut += cbAccount ;
		lpb[cbOut++] = '\r' ;
		lpb[cbOut++] = '\n' ;

		m_fAccountSent = TRUE ;

		return	TRUE ;
	}
}

BOOL
CClearTextAuthenticator::NextAuthentication(	LPSTR		multisz,
												BYTE*		lpb,
												unsigned	cb,
												unsigned&	cbOut,
												BOOL&		fComplete,
												BOOL&		fLoggedOn ) {
/*++

Routine Description :

	Process the response of a authinfo user command and send the
	response.

Arguemnts :

	multisz -	The response from the remote server
	lpb -		Output Buffer
	cb	-		Size of output buffer
	cbOut -		OUT parm for number of bytes placed in output buffer
	fComplete -	OUT parm indicating whether the logon has completed
	fLoggedOn - OUT parm indicating whether we were successfully logged on

Return Value :
	TRUE if successfull - FALSE otherwise !

--*/


	const	char	szPassword[] = "authinfo pass " ;
	NRC	code ;

	fComplete = FALSE ;

	if( !m_fPasswordSent ) {

		if( !ResultCode( multisz, code ) ) {
			SetLastError( ERROR_BAD_ARGUMENTS ) ;
			return	FALSE ;
		}	else	{
			
			if( code == nrcPassRequired ) {
				int	cbPassword = lstrlen( m_lpstrPassword ) ;
				if( cb < sizeof( szPassword ) + cbPassword + 2 ) {
					SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
					return	FALSE ;
				}	else	{
					
					CopyMemory( lpb, szPassword, sizeof( szPassword ) - 1 ) ;
					cbOut =	sizeof( szPassword ) - 1 ;
					CopyMemory( lpb + cbOut, m_lpstrPassword, cbPassword ) ;
					cbOut += cbPassword  ;
					lpb[cbOut++] = '\r' ;
					lpb[cbOut++] = '\n' ;
					m_fPasswordSent = TRUE ;
				}
			}	else	{
				SetLastError( ERROR_BAD_ARGUMENTS ) ;
				return	FALSE ;
			}
		}
	}	else	{
		if( !ResultCode( multisz, code ) ) {
			SetLastError( ERROR_BAD_ARGUMENTS ) ;
			return	FALSE ;
		}	else	{		
			if( code == nrcLoggedOn ) {
				fLoggedOn = TRUE ;
			}	else	{
				fLoggedOn = FALSE ;
			}
			fComplete = TRUE ;
		}
	}
	return	TRUE ;
}





CFeedList::CFeedList() {
/*++

Routine Description :

	Set everything to a blank state.

Arguments :

	None.

Return Value :

	None

--*/
	ZeroMemory( &m_ListHead, sizeof( m_ListHead ) ) ;
	ZeroMemory( &m_ListLock, sizeof( m_ListLock ) ) ;
}

BOOL
CFeedList::Init()	{
/*++

Routine Description :

	Put the CFeedList into a usable state.

Arguments :

	None.

Return Value :

	None

--*/
	
	InitializeListHead( &m_ListHead ) ;

	return InitializeResource( &m_ListLock ) ;
}

BOOL
CFeedList::FIsInList(	PFEED_BLOCK	feedBlock ) {
/*++

Routine Description :

	Check whether a feedBlock already exists in the list.
	 ASSUME LOCKS ARE HELD !!

Arguments :

	feedBlock - check for this guy in the list

Return Value :

	TRUE if in list
	FALSE otherwise

--*/

	BOOL	fRtn = FALSE ;
//	AcquireResourceShared( &m_ListLock, TRUE ) ;

	PLIST_ENTRY	listEntry =	m_ListHead.Flink ;
	while( listEntry != &m_ListHead ) {

		PFEED_BLOCK	feedBlockList = CONTAINING_RECORD(	listEntry,
														FEED_BLOCK,
														ListEntry ) ;
		if( feedBlockList == feedBlock ) {
			fRtn = TRUE ;
			break ;
		}
		listEntry = listEntry->Flink ;
	}

//	ReleaseResource( &m_ListLock ) ;
	return	fRtn ;
}

void
CFeedList::ShareLock()	{
/*++

Routine Description :

	Grab the lock in shared mode
	Use this when we want to do several enumerations and
	ensure nothing is added/removed in btwn

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::ShareLock" ) ;

	AcquireResourceShared( &m_ListLock, TRUE ) ;

}

void
CFeedList::ShareUnlock()	{
/*++

Routine Description :

	Release the lock from shared mode
	Use this when we want to do several enumerations and
	ensure nothing is added/removed in btwn

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::ShareUnlock" ) ;
	
	ReleaseResource( &m_ListLock ) ;

}

void
CFeedList::ExclusiveLock()	{
/*++

Routine Description :

	Grab the lock in exclusive mode
	Use this when we want to do several enumerations and
	ensure nothing is added/removed in btwn

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::ExclusiveLock" ) ;

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

}

void
CFeedList::ExclusiveUnlock()	{
/*++

Routine Description :

	Release the lock in exclusive mode
	Use this when we want to do several enumerations and
	ensure nothing is added/removed in btwn

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::ExclusiveUnlock" ) ;
	
	ReleaseResource( &m_ListLock ) ;

}

PFEED_BLOCK
CFeedList::StartEnumerate(	)	{
/*++

Routine Description :

	Grab the lock in shared mode, and keep it
	untill we're finished enumerating.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CFeedList::StateEnumerate" ) ;

	AcquireResourceShared( &m_ListLock, TRUE ) ;

	PFEED_BLOCK	feedOut = 0 ;	
	PLIST_ENTRY	listEntry = m_ListHead.Flink ;

	if( listEntry != &m_ListHead ) {

		feedOut = CONTAINING_RECORD(	listEntry,
										FEED_BLOCK,
										ListEntry ) ;

		if( feedOut->MarkedForDelete )
			feedOut = NextEnumerate( feedOut ) ;

	}	else	{

		ReleaseResource( &m_ListLock ) ;

	}

	if( feedOut != 0 ) {

		DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
				feedOut, feedOut->ReferenceCount, feedOut->State, feedOut->MarkedForDelete,
				feedOut->FeedsInProgress, feedOut->ReplacedBy, feedOut->Replaces ) ;
	}

	return	feedOut ;

}	//	CFeedList::StartEnumerate

PFEED_BLOCK
CFeedList::NextEnumerate(	
					PFEED_BLOCK	current
					) {
/*++

Routine Description :

	This function returns the next FEED_BLOCK in the list.
	StartEnumerate() grabbed the shared lock and returned the
	first element.  When we are about to return NULL, we know
	that the caller has gone through the entire list,
	so we release the lock.

Arguments :

	current - the current position in the enumeration

Return Value :

	The next feed block if there is one, NULL otherwise

--*/

	TraceFunctEnter( "CFeedList::NextEnumerate" ) ;

	_ASSERT( current != 0 ) ;

#ifdef	DEBUG
	_ASSERT( FIsInList( current ) ) ;
#endif

	PFEED_BLOCK	feedOut = 0 ;
	PLIST_ENTRY	listEntry = current->ListEntry.Flink ;
	while( listEntry && listEntry != &m_ListHead ) {

		feedOut = CONTAINING_RECORD(	listEntry,
										FEED_BLOCK,
										ListEntry ) ;

		if( !feedOut->MarkedForDelete ) {
			break ;
		}

		feedOut = 0 ;
		listEntry = listEntry->Flink ;
	}

	if( feedOut == 0 ) {
		
		DebugTrace( 0, "Released Lock" ) ;

		ReleaseResource( &m_ListLock ) ;
	}	else	{
		DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
				feedOut, feedOut->ReferenceCount, feedOut->State, feedOut->MarkedForDelete,
				feedOut->FeedsInProgress, feedOut->ReplacedBy, feedOut->Replaces ) ;
	}

	return	feedOut ;

}	//	CFeedList::NextEnumerate

void
CFeedList::FinishEnumerate(	
			PFEED_BLOCK	feed
			) {
/*++

Routine Description :

	This function is called when somebody has used StartEnumerate()
	to go through the list, however they decide they don't want to
	go to the end.
	This function will drop the shared resource lock, if the
	caller had not reached the end.

Arguments :

	feed - The last pointer the caller got from StartEnumerate()
		or NextEnumerate().  If they had gone through the whole
		list this will be NULL, and in that case there
		lock will have benn dropped.

Return Value :

	None.

--*/

	if( feed != 0 )
		ReleaseResource( &m_ListLock ) ;

}

PFEED_BLOCK
CFeedList::Next(	
			PNNTP_SERVER_INSTANCE pInstance,
			PFEED_BLOCK	feedBlockIn
			) {
/*++

Routine Description :

	This function will enumerate the list, however
	we will not hold any locks between calls to Next().
	This is quite different from NextEnumerate(), where
	because of the shared lock the caller is guaranteed
	that the list doesn't change underneath him
	We will bump the reference count of the returned element
	so that the caller is guaranteed that its memory wont
	be released while he examines it, however the caller
	should use MarkInProgress() to ensure that no other
	thread simultaneously changes memeber variables.
	On each call we will drop the refence count that we
	add from the previous position in the enumeration.
	Additionally as we go through each FEED_BLOCK
	we make sure we don't return to the caller blocks
	which have updates pending etc... (set by ApplyUpdate())

Aguments :

	feedBlockIn -
		The current position in the enumeration.	
		This should be NULL on the first call
		to get the first element in the list.

Return Value :

	The next block if there is one, NULL otherwise.

--*/

	TraceFunctEnter( "CFeedList::Next" ) ;

	PFEED_BLOCK	feedBlock = feedBlockIn ;
	PFEED_BLOCK	feedBlockOut = 0 ;
	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	feedBlockOut = InternalNext( feedBlock ) ;
	while( feedBlockOut &&
			(feedBlockOut->MarkedForDelete ||
			 feedBlockOut->Replaces != 0 ) ) {
		feedBlockOut = InternalNext( feedBlockOut ) ;
	}

	_ASSERT( feedBlockOut == 0 || feedBlockOut->ReplacedBy == 0 ) ;

	if( feedBlockOut != 0 ) {
		
		ReferenceFeedBlock( feedBlockOut ) ;

		DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
				feedBlockOut, feedBlockOut->ReferenceCount, feedBlockOut->State, feedBlockOut->MarkedForDelete,
				feedBlockOut->FeedsInProgress, feedBlockOut->ReplacedBy, feedBlockOut->Replaces ) ;

	}

	ReleaseResource( &m_ListLock ) ;

	//
	//	Try to do all Dereference's outside of locks !!
	//
	if( feedBlockIn != 0 ) {

		DereferenceFeedBlock( pInstance, feedBlockIn ) ;

	}

	return	feedBlockOut ;
}

PFEED_BLOCK
CFeedList::InternalNext(	
			PFEED_BLOCK	feedBlock
			)	{
/*++

Routine Description :

	This function is only for use by CFeedList::Next().
	It essentially advances by only one element.
	CFeedList::Next may advance by more than one if
	the blocks are marked for deletion/update/etc...

Arguments :

	feedBlock - current position

Return Value :

	Next entry in list if present
	NULL otherwise.

--*/

	PFEED_BLOCK	feedOut = 0 ;
	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	PLIST_ENTRY	listEntry ;
	if( feedBlock == 0 ) {
		
		listEntry = m_ListHead.Flink ;
	
	}	else	{

		listEntry = feedBlock->ListEntry.Flink ;

	}

	if( listEntry != 0 && listEntry != &m_ListHead ) {

		feedOut = CONTAINING_RECORD(	listEntry,
										FEED_BLOCK,
										ListEntry ) ;

	}

	ReleaseResource( &m_ListLock ) ;

	return	feedOut ;
}

PFEED_BLOCK
CFeedList::Search(	
			DWORD	FeedId
			) {
/*++

Routine Description :

	Given a feedId scan the list for a feed Block with a
	matching Id.
	We add a reference to the block we return, the caller
	should use FinishWith() to remove that reference.

Arguments :

	FeedId - the id we want to find.

Return Value :

	The feedblock if found, NULL otherwise.

--*/

	TraceFunctEnter( "CFeedList::Search" ) ;

	PFEED_BLOCK	feedBlock = 0 ;
	AcquireResourceShared( &m_ListLock, TRUE ) ;

	PLIST_ENTRY	listEntry =	m_ListHead.Flink ;
	while( listEntry != &m_ListHead ) {

		feedBlock = CONTAINING_RECORD(	listEntry,
										FEED_BLOCK,
										ListEntry ) ;
		if( feedBlock->FeedId == FeedId  && !feedBlock->MarkedForDelete ) {

			ReferenceFeedBlock( feedBlock ) ;

			DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
					feedBlock, feedBlock->ReferenceCount, feedBlock->State, feedBlock->MarkedForDelete,
					feedBlock->FeedsInProgress, feedBlock->ReplacedBy, feedBlock->Replaces ) ;

			break ;
		}
		listEntry = listEntry->Flink ;
		feedBlock = 0 ;
	}

	ReleaseResource( &m_ListLock ) ;

	return	feedBlock ;
}

void
CFeedList::FinishWith(
					PNNTP_SERVER_INSTANCE pInstance,
					PFEED_BLOCK	feedBlock ) {
/*++

Routine Description :

	Indicate that the caller has completed using a block returned from Search().
	When they are done we'll remove a reference Search() added.

Arguments :

	feedBlock - The block the caller completed using

Return Value :

	None.

--*/
	
	_ASSERT( feedBlock != 0 ) ;

	DereferenceFeedBlock( pInstance, feedBlock ) ;

}

PFEED_BLOCK
CFeedList::Insert(
			PFEED_BLOCK		feedBlock
			) {
/*++

Routine description :

	Insert a new feedblock into the head of the list.

Arguments :
	
	feedBlock - the element to insert into the head.

Return Value :
	
	pointer to the element that was inserted.

--*/

	TraceFunctEnter( "CFeedList::Insert" ) ;

	AcquireResourceExclusive(	&m_ListLock, TRUE ) ;

	InsertHeadList( &m_ListHead,
					&feedBlock->ListEntry ) ;

	DebugTrace( (DWORD_PTR)this, "Insert block %x", feedBlock ) ;
	
	ReleaseResource( &m_ListLock ) ;
	return	feedBlock ;
}

PFEED_BLOCK
CFeedList::Remove(	
				PFEED_BLOCK	feedBlock,
				BOOL		fMarkDead
				) {
/*++

Routine Description :

	Remove an element from the list.
	When removed from the list we mark the state as closed so
	that when the last reference is removed the
	destruction of the block is handled correctly.

Agruments :

	feedBlock - block to be removed
	fMarkDead - if TRUE mark the block's state as closed.

Return Value :

	Pointer to the block that was removed.

--*/

	TraceFunctEnter( "CFeedList::Remove" ) ;

#ifdef	DEBUG

	_ASSERT( feedBlock->ListEntry.Flink == 0 || FIsInList( feedBlock ) ) ;

#endif

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	if( feedBlock->ListEntry.Flink != 0 ) {
		RemoveEntryList( &feedBlock->ListEntry );
		feedBlock->ListEntry.Flink = 0 ;
		feedBlock->ListEntry.Blink = 0 ;
	}

	if( fMarkDead ) {
		feedBlock->State = FeedBlockStateClosed ;
	}

	DebugTrace( (DWORD_PTR)this, "feed %x refs %d S %x M %x InProg %x By %x repl %x",
			feedBlock, feedBlock->ReferenceCount, feedBlock->State, feedBlock->MarkedForDelete,
			feedBlock->FeedsInProgress, feedBlock->ReplacedBy, feedBlock->Replaces ) ;

	ReleaseResource( &m_ListLock ) ;

	return	feedBlock ;
}

void
CFeedList::ApplyUpdate(	
				PFEED_BLOCK	Original,	
				PFEED_BLOCK	Updated
				) {
/*++

Routine Description :

	Given an Updated Feed Block make all the changes on the original feed Block.
	Because the Orginal may be 'in use' (which means there is an active
	TCP session for the feed which implies that completion port threads are
	accessing the member variables) we may not make the changes immediately.
	If the original is inuse we add the Updated version to the list, and mark
	the blocks so that when the session for the original completes the Updated
	entry replaces the original.
	In the meantime, the enumeration API's will take care to skip original's.

Arguments :
	Original - The original feed block which is in the list
	Updated - A feed block which copies most members of the Original
		but may vary in some members

Return Value :

	None.

--*/

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	_ASSERT( Original->Signature == Updated->Signature ) ;
	_ASSERT( Original->FeedType == Updated->FeedType ) ;
	_ASSERT( lstrcmp( Original->KeyName, Updated->KeyName ) == 0 ) ;
	_ASSERT( Original->pFeedQueue == Updated->pFeedQueue ) ;
	_ASSERT( Original->FeedId == Updated->FeedId ) ;

	
	Updated->NumberOfFeeds = 0 ;
	Updated->cFailedAttempts = 0 ;
	Updated->LastNewsgroupPulled = 0 ;
	Updated->FeedsInProgress = 0 ;

	if( Original->State == FeedBlockStateActive ) {

		if( Original->FeedsInProgress == 0 ) {
		
			//
			//	Just replace fields - one for one !
			//

			Original->AutoCreate = Updated->AutoCreate ;
			Original->fAllowControlMessages = Updated->fAllowControlMessages ;
			Original->OutgoingPort = Updated->OutgoingPort ;
			Original->FeedPairId = Updated->FeedPairId ;
			Original->FeedIntervalMinutes = Updated->FeedIntervalMinutes ;
			Original->PullRequestTime = Updated->PullRequestTime ;
			Original->StartTime = Updated->StartTime ;
			Original->NextActiveTime = Updated->NextActiveTime ;
			Original->cFailedAttempts = 0 ;
			Original->NumberOfFeeds = 0 ;
			
			if( Original->ServerName != Updated->ServerName ) {
				if( Original->ServerName )
					FREE_HEAP( Original->ServerName ) ;
				Original->ServerName = Updated->ServerName ;
			}
			Updated->ServerName = 0 ;

			if( Original->Newsgroups != Updated->Newsgroups ) {
				if( Original->Newsgroups )
					FREE_HEAP( Original->Newsgroups ) ;
				Original->Newsgroups = Updated->Newsgroups ;
			}
			Updated->Newsgroups = 0 ;

			if( Original->Distribution != Updated->Distribution ) {
				if( Original->Distribution )
					FREE_HEAP( Original->Distribution ) ;
				Original->Distribution = Updated->Distribution ;
			}
			Updated->Distribution = 0 ;

			Original->fEnabled = Updated->fEnabled ;

			if( Original->UucpName != Updated->UucpName ) {
				if( Original->UucpName )
					FREE_HEAP( Original->UucpName ) ;
				Original->UucpName = Updated->UucpName ;
			}

			if( Original->FeedTempDirectory != Updated->FeedTempDirectory ) {
				if( Original->FeedTempDirectory )
					FREE_HEAP( Original->FeedTempDirectory ) ;
				Original->FeedTempDirectory = Updated->FeedTempDirectory ;
			}
				
			Updated->FeedTempDirectory = 0 ;

			Original->MaxConnectAttempts = Updated->MaxConnectAttempts ;
			Original->ConcurrentSessions = Updated->ConcurrentSessions ;
			Original->SessionSecurityType = Updated->SessionSecurityType ;
			Original->AuthenticationSecurity = Updated->AuthenticationSecurity ;
		
			if( Original->NntpAccount != Updated->NntpAccount ) {
				if( Original->NntpAccount )
					FREE_HEAP( Original->NntpAccount ) ;
				Original->NntpAccount = Updated->NntpAccount ;
			}
			Updated->NntpAccount = 0 ;

			if( Original->NntpPassword != Updated->NntpPassword ) {
				if( Original->NntpPassword )
					FREE_HEAP(	Original->NntpPassword ) ;
				Original->NntpPassword = Updated->NntpPassword ;
			}
			Updated->NntpPassword = 0 ;

			FREE_HEAP( Updated ) ;
			
		}	else	{

			//
			//	A feed is in progress - so just remove the current Feed Block
			//	and replace with the new one !
			//

			_ASSERT( Original->ReplacedBy == 0 ) ;
			_ASSERT( Updated->Replaces == 0 ) ;

			Original->ReplacedBy = Updated ;
			Updated->Replaces = Original ;
		
			//
			//	Bump both ref counts so that they wont be
			//	destroyed untill the update is completed !
			//
			ReferenceFeedBlock( Updated ) ;
			//
			//	Bump the udpated guy twice - once for being referenced by Original
			//	and another for just being in the list !
			//
			ReferenceFeedBlock( Updated ) ;
			ReferenceFeedBlock( Original ) ;

			Original->MarkedForDelete = TRUE ;

			Insert( Updated ) ;

		}
	}
	ReleaseResource( &m_ListLock ) ;
}

long
CFeedList::MarkInProgress(	
				PFEED_BLOCK	feedBlock
				) {
/*++

Routine Description :

	Mark a feed block as 'in progress' which ensures that
	none of the member variables that may be used on a completion
	port thread are touched by Updates().
	The function ApplyUpdate() will ensure that updates too
	block happen when the block is no longer in use.

Arguments :

	feedBlock - The guy to be marked as 'in progress'

Return Value ;

	The old 'in progress' value.
	This is a long indicating how many times MarkInProgress()
	has been called.  UnmarkInProgress() must be called
	for each MarkInProgress() call.

--*/

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	_ASSERT( feedBlock->FeedsInProgress >= 0 ) ;

	long	lReturn = feedBlock->FeedsInProgress ++ ;

	ReleaseResource( &m_ListLock ) ;

	return	lReturn ;
}

long
CFeedList::UnmarkInProgress(	
					PNNTP_SERVER_INSTANCE pInstance,
					PFEED_BLOCK	feedBlock
					)	{
/*++

Routine Description :

	This does the opposite of MarkInProgress
	This function must be called once for each call to
	MarkInProgress.

	If ApplyUpdate() had been called while the block
	was marked 'InProgress' this function will find
	the update and replace the orignal with it.

Arguments :

	feedBlock - The block which is no longer in progress

Return Value :

	0 if the block is no longer in progress
	>0 otherwise.

--*/

	PFEED_BLOCK	feedExtraRef = 0 ;
	PFEED_BLOCK	feedRemove2Refs = 0 ;

	AcquireResourceExclusive( &m_ListLock, TRUE ) ;

	feedBlock->FeedsInProgress -- ;
	long	lReturn = feedBlock->FeedsInProgress ;

	if( lReturn == 0 &&
		feedBlock->MarkedForDelete ) {

		//
		//	We may be replaced by another feed with new settings !
		//
	
		_ASSERT( feedBlock->Replaces == 0 ) ;
		_ASSERT( !feedBlock->ReplacedBy || feedBlock->pFeedQueue == feedBlock->ReplacedBy->pFeedQueue ) ;

		feedExtraRef = feedBlock->ReplacedBy ;

        if( feedBlock->State == FeedBlockStateClosed && feedExtraRef) {
    	    feedExtraRef->State = FeedBlockStateClosed ;
		}

        if( feedExtraRef && feedExtraRef->State == FeedBlockStateClosed ) {
            feedBlock->State = FeedBlockStateClosed;
        }

        if( feedBlock->ReplacedBy ) {
		    feedBlock->ReplacedBy->Replaces = 0 ;
        }

		//
		//	So that destruction of this guy doesnt close the queue !!!
		//
		feedBlock->pFeedQueue = 0 ;

		//
		//	Unlink this block
		//
		Remove( feedBlock, TRUE ) ;
		feedRemove2Refs = feedBlock ;

	}
	
	_ASSERT( feedBlock->FeedsInProgress >= 0 ) ;

	ReleaseResource( &m_ListLock) ;

	//
	//	removed the reference on the updating block !
	//
	if( feedExtraRef != 0 )
		DereferenceFeedBlock( pInstance, feedExtraRef ) ;

	//
	//	Remove the reference that the updating block had
	//
	if( feedRemove2Refs != 0 ) {
		DereferenceFeedBlock( pInstance, feedRemove2Refs ) ;

		//
		//	Remove the reference that the list had !	
		//
		DereferenceFeedBlock( pInstance, feedRemove2Refs ) ;
	}

	return	lReturn ;
}


BOOL
CFeedList::Term()	{
	DeleteResource( &m_ListLock ) ;
	return	TRUE ;
}

int
NextLegalSz(	LPSTR*	rgsz,	
				DWORD	iCurrent	) {

	while( rgsz[iCurrent] != 0 ) {
		if( *rgsz[iCurrent] != '!' )
			return	iCurrent ;
		iCurrent++ ;
	}
	return	-1 ;
}

BOOL
InitializeFeedManager(
				PNNTP_SERVER_INSTANCE pInstance,
				BOOL& fFatal
                 )
/*++

Routine Description:

    Initializes feed manager data and threads

Arguments:

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
    ENTER("InitializeFeedManager")

    //
    // Compute initial time
    //
    GetSystemTimeAsFileTime( &pInstance->m_ftCurrentTime );
    LI_FROM_FILETIME( &pInstance->m_liCurrentTime, &pInstance->m_ftCurrentTime );

    //
    // Get metabase values
    //

    if ( !InitializeFeedsFromMetabase( pInstance, fFatal ) ) {
        goto error_exit;
    }

	//
	//	NOTE: setting this member to TRUE makes the instance ready for
	//	feed processing
	//

	if( TRUE ) {
		DebugTrace(0,"Enabling FeedManager");
		pInstance->m_FeedManagerRunning = TRUE;
	}

    LEAVE
    return(TRUE);

error_exit:
	
	NntpLogEvent(	NNTP_BAD_FEED_REGISTRY,	
					0,
					0,
					0 ) ;	

    TerminateFeedManager( pInstance );
    return(FALSE);

} // InitializeFeedManager

VOID
TerminateFeedManager(
				PNNTP_SERVER_INSTANCE pInstance
                )
/*++

Routine Description:

    Shuts down the feed manager

Arguments:

    None.

Return Value:

    None.

--*/
{
    //PLIST_ENTRY listEntry;
    PFEED_BLOCK feedBlock;

    ENTER("TerminateFeedManager")

    //
    // Prepare to shut down
    //

	CShareLockNH* pLockInstance = pInstance->GetInstanceLock();

	//
	//	if feed thread is partying on this instance, block
	//	till it finishes.
	//

	pLockInstance->ExclusiveLock();
    pInstance->m_FeedManagerRunning = FALSE;
	pLockInstance->ExclusiveUnlock();

    //
    // Free lists for this instance
    //

	feedBlock = (pInstance->m_pActiveFeeds)->Next( pInstance, 0 ) ;
	while( feedBlock != 0 ) {

		CloseFeedBlock( pInstance, feedBlock ) ;
		(pInstance->m_pActiveFeeds)->FinishWith( pInstance, feedBlock ) ;
		feedBlock = (pInstance->m_pActiveFeeds)->Next( pInstance, 0 ) ;
	}

	feedBlock = (pInstance->m_pPassiveFeeds)->Next( pInstance, 0 ) ;
	while( feedBlock != 0 ) {

		CloseFeedBlock( pInstance, feedBlock ) ;
		(pInstance->m_pPassiveFeeds)->FinishWith( pInstance, feedBlock ) ;
		feedBlock = (pInstance->m_pPassiveFeeds)->Next( pInstance, 0 ) ;
	}

    LEAVE
    return;

} // TerminateFeedManager

PFEED_BLOCK
AllocateFeedBlock(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN LPSTR	KeyName OPTIONAL,
	IN BOOL		fCleanSetup,	
    IN LPCSTR	ServerName,
    IN FEED_TYPE FeedType,
    IN BOOL		AutoCreate,
    IN PULARGE_INTEGER StartTime,
    IN PFILETIME NextPull,
    IN DWORD	FeedInterval,
    IN PCHAR	Newsgroups,
    IN DWORD	NewsgroupsSize,
    IN PCHAR	Distribution,
    IN DWORD	DistributionSize,
    IN BOOL		IsUnicode,
	IN BOOL		fEnabled,
   	IN LPCSTR	UucpName,
	IN LPCSTR	FeedTempDirectory,
	IN DWORD	MaxConnectAttempts,
	IN DWORD	ConcurrentSessions,
	IN DWORD	SessionSecurityType,
	IN DWORD	AuthenticationSecurityType,
	IN LPSTR	NntpAccount,
	IN LPSTR	NntpPassword,
	IN BOOL		fAllowControlMessages,
	IN DWORD	OutgoingPort,
	IN DWORD	FeedPairId,
	IN DWORD*	ParmErr	
)
/*++

Routine Description:

    Allocate a feed block

Arguments:

    KeyName - Name of the reg key where this feed info resides
	fCleanSetup - if TRUE then we want to start this feed from scratch -
		delete any old queue files that may be around etc...
		if FALSE then this feed has existed in the pass and we want to
		recover any old queue files etc... that were left around
    ServerName - Name of the remote server
    FeedType - Type of the feed.
    AutoCreate - Should we autocreate the tree (ask Neil what this means)
    StartTime - When feed should start
    NextPull - When the next pull should occur
    FeedInterval - Feed interval in minutes
    Newsgroups - list of newsgroup specs
    NewsgroupsSize - size of newsgroup spec list
    Distribution - distribution list
    DistributionSize - size of the distribution list
    IsUnicode - Is the server name in Unicode?
	fEnabled - if TRUE the feed is enabled and we should be scheduled !
	UucpName - The name of the remote server to be used for processing path headers
	FeedTempDirectory - Where to place temp files for the incoming feed
	MaxConnectAttempts - Maximum number of consecutive connect failures
		for an outgoing feed before disabling the feed
	ConcurrentSessions - The number of simultaneous sessions to be
		attempted for an outgoing feed.
	SessionSecurityType - FUTURE USE
	AuthenticationSecurityType - Do we issue authinfo's on outbound feeds ?
	NntpAccount - Account to be used for Authinfo user
	NntpPassword - Password to be used with Authinfo pass
	fAllowControlMessages - Allow control messages for this feed ?
	OutgoingPort - port to be used on outgoing feeds
	FeedPairId - associated feed pair id

Return Value:

    Pointer to the newly allocated feed block.

--*/
{
    PFEED_BLOCK feedBlock = NULL;
	char	queueFile[MAX_PATH] ;
	ZeroMemory( queueFile, sizeof( queueFile ) ) ;
	CFeedQ*	pQueue = 0 ;
	DWORD	parmErr = 0 ;
	LPSTR	ServerNameAscii = 0 ;
	LPSTR*	UucpNameAscii = 0 ;
	LPSTR	FeedTempDirectoryAscii = 0 ;
	LPSTR	NntpAccountAscii = 0 ;
	LPSTR	NntpPasswordAscii = 0 ;

    ENTER("AllocateFeedBlock")

	if( IsUnicode ) {

		ServerNameAscii =
			(LPSTR)ALLOCATE_HEAP( 2 * (wcslen( (LPWSTR)ServerName ) + 1) ) ;
		if( ServerNameAscii != 0 ) {
			CopyUnicodeStringIntoAscii( ServerNameAscii, (LPWSTR) ServerName ) ;
		}	else	{
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			goto	error ;
		}

	}	else	{

		ServerNameAscii =
			(LPSTR)ALLOCATE_HEAP( lstrlen(ServerName) + 1 ) ;
		if( ServerNameAscii != 0 ) {
			lstrcpy( ServerNameAscii, ServerName ) ;
		}	else	{
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			goto	error ;
		}
	}

	if( UucpName != 0 &&
			((IsUnicode && *((LPWSTR)UucpName) != L'\0') ||
			 (!IsUnicode && *UucpName != '\0'))  ) {
		if( IsUnicode ) {
			UucpNameAscii = MultiSzTableFromStrW( (LPWSTR)UucpName ) ;
		}	else	{
			UucpNameAscii = MultiSzTableFromStrA( UucpName ) ;
		}

		if( UucpNameAscii == 0 || *UucpNameAscii == 0 ) {
			SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
			goto	error ;
		}	else if( **UucpNameAscii == '\0' ) {
			SetLastError( ERROR_INVALID_PARAMETER ) ;
			parmErr = FEED_PARM_UUCPNAME ;
			goto	error ;
		}

	}	else	{
		if( FEED_IS_PUSH( FeedType ) ) {

			if( ServerNameAscii == NULL || inet_addr( ServerNameAscii ) != INADDR_NONE ) {
				//
				//	A TCP/IP address was passed as the servername - we cant
				//	use this to produce the Uucp Name !
				//
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				parmErr = FEED_PARM_UUCPNAME ;
				goto	error ;
			}	else	{
				UucpNameAscii = MultiSzTableFromStrA( ServerNameAscii ) ;
				if( UucpNameAscii == 0 ) {
					SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
					goto	error ;
				}
			}
		}	else	{
			//
			//	In this case the UUCP Name may be NULL !
			//
		}
	}

	if( FeedTempDirectory != 0 &&
			((IsUnicode && *((LPWSTR)FeedTempDirectory) != L'\0') ||
			 (!IsUnicode && *FeedTempDirectory != '\0'))  ) {

		if( IsUnicode ) {
			FeedTempDirectoryAscii =
				(LPSTR)ALLOCATE_HEAP( 2 * (wcslen( (LPWSTR)FeedTempDirectory ) + 1) ) ;
			if( FeedTempDirectoryAscii != 0 ) {
				CopyUnicodeStringIntoAscii( FeedTempDirectoryAscii, (LPWSTR)FeedTempDirectory ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}	else	{
			FeedTempDirectoryAscii =
				(LPSTR)ALLOCATE_HEAP( lstrlen( FeedTempDirectory ) + 1 ) ;
			if( FeedTempDirectoryAscii != 0 ) {
				lstrcpy( FeedTempDirectoryAscii, FeedTempDirectory ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}
	}	else	{

		if( FEED_IS_PASSIVE( FeedType ) || FEED_IS_PULL( FeedType ) ) {

			//
			//	Passive feeds must have a feed directory - so pick up a default !
			//
			FeedTempDirectoryAscii = (LPSTR)ALLOCATE_HEAP( lstrlen( pInstance->m_PeerTempDirectory ) + 1 ) ;
			if( FeedTempDirectoryAscii != 0 ) {
				lstrcpy( FeedTempDirectoryAscii, pInstance->m_PeerTempDirectory ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}
	}
	//
	//	Check that the temp directory exists if it was specified !
	//

	if( FeedTempDirectoryAscii != 0 && !CreateDirectory( FeedTempDirectoryAscii, NULL ) ) {
		if( GetLastError() != ERROR_ALREADY_EXISTS ) {
			parmErr = FEED_PARM_TEMPDIR ;
			goto	error ;
		}
	}

	if( AuthenticationSecurityType != AUTH_PROTOCOL_CLEAR &&
		AuthenticationSecurityType != AUTH_PROTOCOL_NONE ) {

		parmErr = FEED_PARM_AUTHTYPE ;
		SetLastError( ERROR_INVALID_PARAMETER ) ;
		goto	error ;
	}

	if( AuthenticationSecurityType == AUTH_PROTOCOL_CLEAR ) {

#if 0
		//
		//	Passive feeds dont need authentication settings !
		//	#if 0 since feeds are now added in pairs, so the
		//	active counterpart will have auth strings.
		//
		if( FEED_IS_PASSIVE( FeedType ) ) {
			parmErr = FEED_PARM_AUTHTYPE ;
			SetLastError( ERROR_INVALID_PARAMETER ) ;
			goto	error ;
		}
#endif

		//
		//	Account & Password must both be non-null if the user
		//	wants clear authentication !
		//
		if( NntpAccount == 0 || * NntpAccount == 0 ) {
			parmErr = FEED_PARM_ACCOUNTNAME ;
			SetLastError( ERROR_INVALID_PARAMETER ) ;
			goto	error ;
		}

		if( NntpPassword == 0 || *NntpPassword == 0 ) {
			parmErr = FEED_PARM_PASSWORD ;
			SetLastError( ERROR_INVALID_PARAMETER ) ;
			goto	error ;
		}

		if( IsUnicode ) {
			NntpAccountAscii =
				(LPSTR)ALLOCATE_HEAP( 2 * (wcslen( (LPWSTR)NntpAccount ) + 1) ) ;
			if( NntpAccountAscii != 0 ) {
				CopyUnicodeStringIntoAscii( NntpAccountAscii , (LPWSTR)NntpAccount ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}	else	{
			NntpAccountAscii =
				(LPSTR)ALLOCATE_HEAP( lstrlen( NntpAccount ) + 1 ) ;
			if( NntpAccountAscii != 0 ) {
				lstrcpy( NntpAccountAscii, NntpAccount ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}

		if( IsUnicode ) {
			NntpPasswordAscii =
				(LPSTR)ALLOCATE_HEAP( 2 * (wcslen( (LPWSTR)NntpPassword ) + 1) ) ;
			if( NntpPasswordAscii != 0 ) {
				CopyUnicodeStringIntoAscii( NntpPasswordAscii, (LPWSTR)NntpPassword ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}	else	{
			NntpPasswordAscii =
				(LPSTR)ALLOCATE_HEAP( lstrlen( NntpPassword ) + 1 ) ;
			if( NntpPasswordAscii != 0 ) {
				lstrcpy( NntpPasswordAscii, NntpPassword ) ;
			}	else	{
				SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
				goto	error ;
			}
		}
	}


	EnterCriticalSection( &pInstance->m_critFeedConfig ) ;

	if( !ValidateFeedType(FeedType) ) {
		parmErr = FEED_PARM_FEEDTYPE ;
		SetLastError(	ERROR_INVALID_PARAMETER ) ;
		goto	error_unlock ;
	}	else	{

		if( FEED_IS_MASTER( FeedType ) ) {
			if( FEED_IS_PASSIVE( FeedType ) ) {

				if( pInstance->m_NumberOfMasters + 1 > 1 ) {
					parmErr = FEED_PARM_FEEDTYPE ;
					SetLastError( ERROR_INVALID_PARAMETER ) ;
					goto	error_unlock ;
				}
			}
		}
		
		if( FEED_IS_MASTER( FeedType ) )	{
			if( pInstance->m_OurNntpRole == RoleMaster ) {
				parmErr = FEED_PARM_FEEDTYPE ;
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				goto	error_unlock ;
			}
		}	else	if( FEED_IS_SLAVE( FeedType ) ) {
			if( pInstance->m_OurNntpRole == RoleSlave ) {
				parmErr = FEED_PARM_FEEDTYPE ;
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				goto	error_unlock ;
			}
		}

		if( pInstance->m_OurNntpRole == RoleSlave ) {
			if( FEED_IS_PULL(FeedType) ||
				(FEED_IS_PEER(FeedType) && FEED_IS_PASSIVE(FeedType)) ){
				parmErr = FEED_PARM_FEEDTYPE ;
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				goto	error_unlock ;
			}
		}	else if( pInstance->m_OurNntpRole == RolePeer &&
				pInstance->m_ConfiguredPeerFeeds != 0 ) {
			if( FEED_IS_MASTER(FeedType) ) {
				parmErr = FEED_PARM_FEEDTYPE ;
				SetLastError( ERROR_INVALID_PARAMETER ) ;
				goto	error_unlock ;
			}
		}
	}

    feedBlock = (PFEED_BLOCK)ALLOCATE_HEAP( sizeof(FEED_BLOCK) );
    if ( feedBlock != NULL ) {

		//
		//	Validate our arguments !?
		//

        ZeroMemory(feedBlock, sizeof(FEED_BLOCK));
        feedBlock->Signature = FEED_BLOCK_SIGN;
        feedBlock->FeedType = FeedType;
        feedBlock->AutoCreate = AutoCreate;
        feedBlock->FeedIntervalMinutes = FeedInterval;
        feedBlock->StartTime.QuadPart = StartTime->QuadPart;
        feedBlock->State = FeedBlockStateActive;
        feedBlock->PullRequestTime = *NextPull;
		feedBlock->LastNewsgroupPulled = 0 ;
		feedBlock->fEnabled = fEnabled ;
		feedBlock->UucpName = UucpNameAscii ;
		feedBlock->FeedTempDirectory = FeedTempDirectoryAscii ;
		feedBlock->MaxConnectAttempts = MaxConnectAttempts ;
		feedBlock->ConcurrentSessions = ConcurrentSessions ;
		feedBlock->AuthenticationSecurity = AuthenticationSecurityType ;
		feedBlock->NntpAccount = NntpAccountAscii ;
		feedBlock->NntpPassword = NntpPasswordAscii ;
		feedBlock->fAllowControlMessages = fAllowControlMessages;
		feedBlock->OutgoingPort = OutgoingPort;
		feedBlock->FeedPairId = FeedPairId;
		feedBlock->cSuccessfulArticles = 0;
		feedBlock->cTryAgainLaterArticles = 0;
		feedBlock->cSoftErrorArticles = 0;
		feedBlock->cHardErrorArticles = 0;

		if( FEED_IS_PUSH(feedBlock->FeedType) && KeyName != 0 ) {

			_ASSERT( FEED_IS_PUSH(feedBlock->FeedType) ) ;

			if( !BuildFeedQFileName( queueFile, sizeof( queueFile ), KeyName, pInstance->QueryGroupListFile()) ) {
				goto	error_unlock ;
			}	else	{

				lstrcat( queueFile, ".fdq" ) ;
				
				if( fCleanSetup )
					DeleteFile( queueFile ) ;

				pQueue= XNEW CFeedQ() ;
				if( pQueue == 0 )	{
					goto	error_unlock ;
				}	else	{
					if( !pQueue->Init( queueFile ) )	{
						XDELETE	pQueue;

						PCHAR	tmpBuf[1] ;
						tmpBuf[0] = KeyName ;

						NntpLogEventEx(	NNTP_CANT_CREATE_QUEUE,
										1,
										(const CHAR **)tmpBuf,
										GetLastError(),
										pInstance->QueryInstanceId() ) ;

						goto	error_unlock ;
					}
				}
			}
		}

		feedBlock->pFeedQueue = pQueue ;

        //
        // Put it in the queue
        //

        if ( KeyName != NULL ) {

            DWORD id = 0;

            lstrcpy( feedBlock->KeyName, KeyName );

            //
            // Compute the feed id
            //

            sscanf(KeyName+4, "%d", &id );

            //
            // Cannot be zero
            //

            if ( id == 0 ) {
                ErrorTrace(0,"Key name %s gave us 0\n",KeyName);
                _ASSERT(FALSE);
                goto error_unlock;
            }

            feedBlock->FeedId = id;
        }

        //
        // refcount
        //  +1 -> in queue
        //  +1 -> being processed
        //

        feedBlock->ReferenceCount = 1;

        //
        // Allocate server name
        //

		_ASSERT( ServerNameAscii != 0 ) ;
		feedBlock->ServerName = ServerNameAscii ;

        //
        // store distribution list
        //

        feedBlock->Distribution = AllocateMultiSzTable(
                                                Distribution,
                                                DistributionSize,
                                                IsUnicode
                                                );

        if ( feedBlock->Distribution == NULL ) {
            goto error_unlock;
        }

        //
        // store newsgroup list
        //

        feedBlock->Newsgroups = AllocateMultiSzTable(
                                                Newsgroups,
                                                NewsgroupsSize,
                                                IsUnicode
                                                );


        if ( feedBlock->Newsgroups == NULL ) {
            goto error_unlock;
        }


        //
        // put it in our global queue
        //

        InsertFeedBlockIntoQueue( pInstance, feedBlock );

		//
		//	At this point - we know we will be successfull so manipulate
		//	globals to reflect the new configuration !
		//
		if( FEED_IS_MASTER( feedBlock->FeedType ) ) {
			pInstance->m_OurNntpRole = RoleSlave ;

			if( FEED_IS_PASSIVE( feedBlock->FeedType ) ) {
				++pInstance->m_NumberOfMasters ;
			}
			pInstance->m_ConfiguredMasterFeeds ++ ;

			_ASSERT( pInstance->m_ConfiguredSlaveFeeds == 0 ) ;
			_ASSERT( pInstance->m_NumberOfMasters <= 1 ) ;	// error check should be done before we get here !
		}	else	if( FEED_IS_SLAVE( feedBlock->FeedType ) ) {

			pInstance->m_OurNntpRole = RoleMaster ;

			if( FEED_IS_PASSIVE( feedBlock->FeedType ) ) {
				++pInstance->m_NumberOfPeersAndSlaves ;
			}
			_ASSERT( pInstance->m_ConfiguredMasterFeeds == 0 ) ;
			pInstance->m_ConfiguredSlaveFeeds ++ ;
		}	else	{

			if( (	FEED_IS_PASSIVE( feedBlock->FeedType ) &&
					FEED_IS_PEER( feedBlock->FeedType )) ||
				FEED_IS_PULL( feedBlock->FeedType ) ) {

				pInstance->m_ConfiguredPeerFeeds ++ ;

			}

		}

    } else {
        ErrorTrace(0,"Unable to allocate feed block\n");
		SetLastError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }

	LeaveCriticalSection( &pInstance->m_critFeedConfig ) ;

    LEAVE
    return(feedBlock);


error_unlock :

	LeaveCriticalSection( &pInstance->m_critFeedConfig ) ;

error:

	DWORD	dw = GetLastError() ;
	if( ParmErr != 0 ) {
		*ParmErr = parmErr ;
	}

	if( feedBlock != NULL ) {
		if ( feedBlock->Newsgroups != NULL ) {
			FREE_HEAP(feedBlock->Newsgroups);
			feedBlock->Newsgroups = 0 ;
		}

		if ( feedBlock->Distribution ) {
			FREE_HEAP(feedBlock->Distribution);
			feedBlock->Distribution = 0 ;
		}
	}

    if ( ServerNameAscii ) {
        FREE_HEAP(ServerNameAscii);
    }

	if( UucpNameAscii ) {
		FREE_HEAP(UucpNameAscii);
	}

	if(FeedTempDirectoryAscii)	{
		FREE_HEAP(FeedTempDirectoryAscii);
	}

	if(NntpAccountAscii)	{
		FREE_HEAP(NntpAccountAscii);
	}

	if(NntpPasswordAscii)	{
		FREE_HEAP(NntpPasswordAscii);
	}

	if( feedBlock != 0 ) {
		FREE_HEAP(feedBlock);
	}

	SetLastError( dw ) ;

    return(NULL);

} // AllocateFeedBlock

VOID
InsertFeedBlockIntoQueue(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Inserts the feed block into the queue

Arguments:

    FeedBlock - Pointer to the feed block to insert

Return Value:

    None.

--*/
{
    //
    // Insert to the correct list
    //

    ENTER("InsertFeedBlockIntoQueue")

    if ( FEED_IS_PASSIVE(FeedBlock->FeedType) ) {

		(pInstance->m_pPassiveFeeds)->Insert( FeedBlock ) ;

    } else {

        //
        // Compute for the next active time
        //

        ComputeNextActiveTime( pInstance, FeedBlock, 0, FALSE );

		(pInstance->m_pActiveFeeds)->Insert( FeedBlock ) ;
    }

    LEAVE
    return;

} // InsertFeedBlockIntoQueue

BOOL
InitializeFeedsFromMetabase(
    PNNTP_SERVER_INSTANCE pInstance,
	BOOL& fFatal
    )
/*++

Routine Description:

    Initializes the feed blocks from the registry

Arguments:

    None

Return Value:

    TRUE, if everything went ok. FALSE, otherwise

--*/
{
    DWORD error, i = 0;
    CHAR serverName[MAX_DOMAIN_NAME+1];
    FEED_TYPE feedType;
    DWORD dataSize, dw;
    DWORD feedInterval = 0;
    PFEED_BLOCK feedBlock= 0 ;
    BOOL autoCreate = FALSE ;
    DWORD temp = 0 ;
	DWORD	ParmErr = 0 ;
	BOOL	fEnabled = TRUE ;
	BOOL	fAllowControlMessages = TRUE;
	DWORD   OutgoingPort = NNTP_PORT;
	DWORD	FeedPairId = 0;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	DWORD	MaxConnectAttempts = 0 ;
	DWORD	ConcurrentSessions = 1 ;
	DWORD	AuthenticationType = AUTH_PROTOCOL_NONE ;

    CHAR	distribution[1024];
    CHAR	Newsgroups[1024];
	CHAR	UucpNameBuff[1024] ;
	CHAR	NntpAccountBuff[512] ;
	CHAR	NntpPasswordBuff[512] ;
	CHAR	FeedTempDirBuff[MAX_PATH];

	LPSTR	UucpName = 0 ;
	LPSTR	NntpAccount = 0 ;
	LPSTR	NntpPassword = 0 ;
	LPSTR	FeedTempDir = 0 ;

    DWORD	NewsgroupsSize = sizeof( Newsgroups );
    DWORD	distributionSize = sizeof( distribution ) ;
	DWORD	UucpNameSize = sizeof( UucpNameBuff ) ;
	DWORD	NntpAccountSize = sizeof( NntpAccountBuff ) ;
	DWORD	NntpPasswordSize = sizeof( NntpPasswordBuff ) ;
	DWORD	FeedTempDirSize = sizeof( FeedTempDirBuff ) ;

	ZeroMemory( distribution, sizeof( distribution ) ) ;
	ZeroMemory( Newsgroups, sizeof( Newsgroups ) ) ;	
	ZeroMemory( UucpNameBuff, sizeof( UucpNameBuff ) ) ;	
	ZeroMemory( NntpAccountBuff, sizeof( NntpAccountBuff ) ) ;	
	ZeroMemory( NntpPasswordBuff, sizeof( NntpPasswordBuff ) ) ;	
	ZeroMemory( FeedTempDirBuff, sizeof( FeedTempDirBuff ) ) ;

    DWORD   dwMask;

    ENTER("InitializeFeedsFromMetabase")

	//
	//	Open the metabase key for this instance and
	//	read all params !
	//

    if ( mb.Open( pInstance->QueryMDFeedPath(),
        METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
	{
		//
		//	PeerGapSize
		//

        if ( !mb.GetDword( "",
                           MD_FEED_PEER_GAP_SIZE,
                           IIS_MD_UT_SERVER,
                           &pInstance->m_PeerGapSize ) )
        {
            // default !
        }

        DebugTrace(0,"PeerGapSize set to %d\n",temp);

		//
		//	PeerTempDirectory
		//

		dataSize = MAX_PATH;
		if( !mb.GetString(	"",
							MD_FEED_PEER_TEMP_DIRECTORY,
							IIS_MD_UT_SERVER,
							pInstance->m_PeerTempDirectory,
							&dataSize  ) )
		{
			// get system default
            _VERIFY( GetTempPath( dataSize, (LPTSTR)pInstance->m_PeerTempDirectory ) );
		}

		DO_DEBUG(REGISTRY) {
			DebugTrace(0,"Peer temp directory set to %s\n", pInstance->m_PeerTempDirectory);
		}

		if ( !CreateDirectory( pInstance->m_PeerTempDirectory, NULL) ) {

			error = GetLastError();
			if ( error != ERROR_ALREADY_EXISTS ) {
				ErrorTrace(0,"Error %d creating temp directory %s\n",
                GetLastError(), pInstance->m_PeerTempDirectory);
			}
		}

		for ( ; ; )
		{
			CHAR keyName[128];
			ULARGE_INTEGER feedStart;
			FILETIME nextPull;

			if( !mb.EnumObjects( "",
								 keyName,
								 i++ ) )
			{
				// done enumerating feed keys
				break ;
			}

#if 0
			if ( error != NO_ERROR ) {
				if (error != ERROR_NO_MORE_ITEMS) {
					ErrorTrace(0,"Error %d enumerating feeds\n",error);
					goto error_exit;
				}
				break;
			}
#endif

            //
            // KangYan:
            // Before loading the feed from metabase, check
            // if it's a bad feed by reading its mask.
            //
            if ( mb.GetDword(  keyName,
                                MD_FEED_ERR_PARM_MASK,
                                IIS_MD_UT_SERVER,
                                &dwMask )) {
                if (dwMask != 0) {
                    continue;
                }
            } else {
                if (!mb.SetDword(keyName,
                    MD_FEED_ERR_PARM_MASK,
                    IIS_MD_UT_SERVER,
                    0)) {
                    ErrorTrace(0, 
                        "Error writing MD_FEED_ERR_PARM_MASK for %s, GLE: %d",
                        keyName, GetLastError());
                }
            }

			//
			// Open the feed key and read in all values
			//

			DO_DEBUG(REGISTRY) {
				DebugTrace(0,"Scanning Feed %s\n",keyName);
			}

			//
			// Default missing values as needed 
			//  

			if (!mb.GetDword(keyName, MD_FEED_ADMIN_ERROR, IIS_MD_UT_SERVER, &dw)) {
			    if (!mb.SetDword(keyName, MD_FEED_ADMIN_ERROR, IIS_MD_UT_SERVER, 0)) {
			        ErrorTrace(0,
			            "Error writing MD_FEED_ADMIN_ERROR for %s, GLE: %d",
                        keyName, GetLastError());
                }
            }

			if (!mb.GetDword(keyName, MD_FEED_HANDSHAKE, IIS_MD_UT_SERVER, &dw)) {
			    if (!mb.SetDword(keyName, MD_FEED_HANDSHAKE, IIS_MD_UT_SERVER, 0)) {
			        ErrorTrace(0,
			            "Error writing MD_FEED_HANDSHAKE for %s, GLE: %d",
                        keyName, GetLastError());
                }
            }


			if ( !mb.GetDword(	keyName,
								MD_FEED_DISABLED,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				fEnabled = TRUE ;   //  Default - allow feeds to post !
			} else {
				fEnabled = !!dw ;
			}

			//
			// Get the values for this feed
			//

			dataSize = MAX_DOMAIN_NAME+1;
			if( !mb.GetString(	keyName,
								MD_FEED_SERVER_NAME,
								IIS_MD_UT_SERVER,
								serverName,
								&dataSize  ) )
			{
				// default !
				PCHAR	tmpBuf[2] ;

				tmpBuf[0] = StrServerName ;
				tmpBuf[1] = keyName ;

				NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;

				goto error_exit;
			}

			DO_DEBUG(REGISTRY) {
				DebugTrace(0,"Server name is %s\n",serverName);
			}

			//
			// Feed Type
			//

			if ( !mb.GetDword(	keyName,
								MD_FEED_TYPE,
								IIS_MD_UT_SERVER,
								&feedType ) )
			{
				// default !
				PCHAR	tmpBuf[2] ;

				tmpBuf[0] = StrFeedType ;
				tmpBuf[1] = keyName ;

				NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;

				goto	error_exit ;
			}

			if ( !ValidateFeedType(feedType) ) {
				PCHAR	tmpBuf[2] ;
				CHAR    szId [20] ;
				_itoa( pInstance->QueryInstanceId(), szId, 10 );
				tmpBuf[0] = szId ;
				tmpBuf[1] = keyName ;
				NntpLogEvent(	NNTP_BAD_FEEDTYPE,
								2,
								(const CHAR **)tmpBuf,
								0) ;
				goto error_exit;
			}

			DO_DEBUG(REGISTRY) {
				DebugTrace(0,"FeedType is %d\n",feedType);
			}

			//
			// Verify the feeds
			//

			if ( FEED_IS_MASTER(feedType) ) {

			{
                //
                // Since we talk to a master, we must be a slave
                //

				if( pInstance->m_OurNntpRole == RoleMaster ) {

					PCHAR args [1];
					CHAR  szId [20];
					_itoa( pInstance->QueryInstanceId(), szId, 10 );
					args [0] = szId;

					NntpLogEvent( NNTP_MASTERSLAVE_CONFLICT, 1, (const CHAR **)args, 0 ) ;
					goto	error_exit ;

				}

				if( FEED_IS_PASSIVE( feedType ) ) {
					if( 1+pInstance->m_NumberOfMasters > 1 ) {

						PCHAR args [1];
						CHAR  szId [20];
						_itoa( pInstance->QueryInstanceId(), szId, 10 );
						args [0] = szId;

						NntpLogEvent( NNTP_TOO_MANY_MASTERS, 1, (const CHAR **)args, 0 ) ;
						goto	error_exit ;

					}
				}
            }

			} else {

				//
				// Not a master.  Reject if there are already masters.
				//

				{


                //
                // If we are talking to a slave, then we must be the master
                //

                if ( FEED_IS_SLAVE(feedType) ) {
					if( pInstance->m_OurNntpRole == RoleSlave ) {

						PCHAR args [1];
						CHAR  szId [20];
						_itoa( pInstance->QueryInstanceId(), szId, 10 );
						args [0] = szId;

						NntpLogEvent( NNTP_MASTERSLAVE_CONFLICT, 1, (const CHAR **)args, 0 ) ;
						goto	error_exit ;

					}
					//OurNntpRole = RoleMaster ;
                    ErrorTrace(0,"Server configured as a master\n");
                }

				}
			}

			//
			// Auto Create
			//

			if ( !mb.GetDword(	keyName,
								MD_FEED_CREATE_AUTOMATICALLY,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				autoCreate = FALSE;
			} else {
				autoCreate = dw ? TRUE : FALSE ;
			}

			//
			// Feed Interval.  Valid only for active feeds.
			//

			nextPull.dwHighDateTime = 0;
			nextPull.dwLowDateTime = 0;

			if ( !FEED_IS_PASSIVE(feedType) )
			{
				if ( !mb.GetDword(	keyName,
									MD_FEED_INTERVAL,
									IIS_MD_UT_SERVER,
									&feedInterval ) )
				{
					feedInterval = DEF_FEED_INTERVAL;
				} else {
					if ( feedInterval < MIN_FEED_INTERVAL ) {
						feedInterval = MIN_FEED_INTERVAL;
					}
				}

				DO_DEBUG(REGISTRY) {
					DebugTrace(0,"Feed interval is %d minutes\n",feedInterval);
				}

				if ( !mb.GetDword(	keyName,
									MD_FEED_START_TIME_HIGH,
									IIS_MD_UT_SERVER,
									&feedStart.HighPart ) ||
					 (feedStart.HighPart == 0)  ||
					 !mb.GetDword(	keyName,
									MD_FEED_START_TIME_LOW,
									IIS_MD_UT_SERVER,
									&feedStart.LowPart ))
				{
					feedStart.QuadPart = 0;
				}

				DO_DEBUG(REGISTRY) {
					DebugTrace(0,"Start time set to %x %x\n",
						feedStart.HighPart, feedStart.LowPart);
				}

				//
				// If pull feed, get the next time for the newnews
				//

				if ( FEED_IS_PULL(feedType) )
				{
					if ( !mb.GetDword(	keyName,
										MD_FEED_NEXT_PULL_HIGH,
										IIS_MD_UT_SERVER,
										&nextPull.dwHighDateTime ) )
					{
						nextPull.dwHighDateTime = 0;
						goto end_time;
					}

					if ( !mb.GetDword(	keyName,
										MD_FEED_NEXT_PULL_LOW,
										IIS_MD_UT_SERVER,
										&nextPull.dwLowDateTime ) )
					{
						nextPull.dwHighDateTime = 0;
						nextPull.dwLowDateTime = 0;
						goto end_time;
					}

					DO_DEBUG(REGISTRY) {
						DebugTrace(0,"Next pull time set to %x %x\n",
							nextPull.dwHighDateTime, nextPull.dwLowDateTime);
					}
				}	

			} else {
				feedStart.QuadPart = 0;
				feedInterval = 0;
			}

end_time:

			//
			// Get Distribution
			//

			{
				distributionSize = sizeof( distribution );
				MULTISZ msz( distribution, distributionSize );
				if( !mb.GetMultisz(	keyName,
									MD_FEED_DISTRIBUTION,
									IIS_MD_UT_SERVER,
									&msz ) )
				{
					PCHAR	tmpBuf[2] ;

					tmpBuf[0] = StrFeedDistribution ;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
									2,	
									(const CHAR **)tmpBuf,
									GetLastError(),
									pInstance->QueryInstanceId()) ;

					goto error_exit;
				}

                distributionSize = msz.QueryCCH();
			}

			//
			// Get Newsgroups
			//

			{
				NewsgroupsSize = sizeof( Newsgroups );
				MULTISZ msz( Newsgroups, NewsgroupsSize );
				if( !mb.GetMultisz(	keyName,
									MD_FEED_NEWSGROUPS,
									IIS_MD_UT_SERVER,
									&msz  ) )
				{
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrFeedNewsgroups ;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
									2,
									(const CHAR **)tmpBuf,
									GetLastError(),
									pInstance->QueryInstanceId()) ;

					goto error_exit;
				}

                NewsgroupsSize = msz.QueryCCH();
			}

			FeedTempDirSize = sizeof( FeedTempDirBuff ) ;
			if( !mb.GetString(	keyName,
								MD_FEED_TEMP_DIRECTORY,
								IIS_MD_UT_SERVER,
								FeedTempDirBuff,
								&FeedTempDirSize  ) )
			{
				DebugTrace(0,"Error in FeedTempDir is %d", GetLastError());

				if( GetLastError() == MD_ERROR_DATA_NOT_FOUND )
				{
					FeedTempDir = 0 ;
				} else {
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrFeedTempDir ;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;
					goto	error_exit ;
				}
			} else {
				FeedTempDir = FeedTempDirBuff ;
			}

			if( FEED_IS_PUSH( feedType ) )
			{
				UucpNameSize = sizeof( UucpNameBuff ) ;
				if( !mb.GetString(	keyName,
									MD_FEED_UUCP_NAME,
									IIS_MD_UT_SERVER,
									UucpNameBuff,
									&UucpNameSize  ) )
				{
					//
					//	Attempt to use the remote server name
					//

					if(  inet_addr( serverName ) == INADDR_NONE ) {
						lstrcpy( UucpName, serverName ) ;
						UucpNameSize = lstrlen( UucpName ) ;
					}	else	{
						PCHAR	tmpBuf[2] ;
						tmpBuf[0] = StrFeedUucpName ;
						tmpBuf[1] = keyName ;

						NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
									2,
									(const CHAR **)tmpBuf,
									GetLastError(),
									pInstance->QueryInstanceId()) ;
						goto	error_exit ;
					}
				}

				UucpName = &UucpNameBuff[0] ;

				if ( !mb.GetDword(	keyName,
									MD_FEED_CONCURRENT_SESSIONS,
									IIS_MD_UT_SERVER,
									&ConcurrentSessions ) )
				{
					goto error_exit;
				}
			}

            if( FEED_IS_PUSH( feedType ) || FEED_IS_PULL( feedType) ) {
				if ( !mb.GetDword(	keyName,
									MD_FEED_MAX_CONNECTION_ATTEMPTS,
									IIS_MD_UT_SERVER,
									&MaxConnectAttempts ) )
				{
					goto error_exit;
				}
            }

			if ( !mb.GetDword(	keyName,
								MD_FEED_AUTHENTICATION_TYPE,
								IIS_MD_UT_SERVER,
								&AuthenticationType ) )
			{
				goto error_exit;
			}

			if( AuthenticationType == AUTH_PROTOCOL_NONE ) {

			}	else if( AuthenticationType == AUTH_PROTOCOL_CLEAR )
			{
				NntpAccountSize = sizeof( NntpAccountBuff ) ;
				if( !mb.GetString(	keyName,
									MD_FEED_ACCOUNT_NAME,
									IIS_MD_UT_SERVER,
									NntpAccountBuff,
									&NntpAccountSize  ) )
				{
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrFeedAuthAccount;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;

					goto error_exit;
				}	else	{
					NntpAccount = NntpAccountBuff ;
				}

				NntpPasswordSize = sizeof( NntpPasswordBuff ) ;
				if( !mb.GetString(	keyName,
									MD_FEED_PASSWORD,
									IIS_MD_UT_SERVER,
									NntpPasswordBuff,
									&NntpPasswordSize,
									METADATA_INHERIT | METADATA_SECURE ) )
				{
					PCHAR	tmpBuf[2] ;
					tmpBuf[0] = StrFeedAuthPassword;
					tmpBuf[1] = keyName ;

					NntpLogEventEx(	NNTP_NTERROR_FEED_VALUE,
								2,
								(const CHAR **)tmpBuf,
								GetLastError(),
								pInstance->QueryInstanceId()) ;

					goto error_exit;
				}	else	{
					NntpPassword = NntpPasswordBuff ;
				}
			}

			//
			// Allow control messages
			//

			if ( !mb.GetDword(	keyName,
								MD_FEED_ALLOW_CONTROL_MSGS,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				fAllowControlMessages = TRUE;
			} else {
				fAllowControlMessages = dw ? TRUE : FALSE ;
			}

			//
			// Outgoing ports
			//

			if ( mb.GetDword(	keyName,
								MD_FEED_OUTGOING_PORT,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				OutgoingPort = dw ;
			}

			//
			// FeedPairId
			//

			if ( mb.GetDword(	keyName,
								MD_FEED_FEEDPAIR_ID,
								IIS_MD_UT_SERVER,
								&dw ) )
			{
				FeedPairId = dw ;
			}

			//
			// OK, now let's create the feed blocks
			//

			feedBlock = AllocateFeedBlock(
							pInstance,
                            keyName,
							FALSE,
                            serverName,
                            feedType,
                            autoCreate,
                            &feedStart,
                            &nextPull,
                            feedInterval,
                            Newsgroups,
                            NewsgroupsSize,
                            distribution,
                            distributionSize,
                            FALSE,       // not unicode
                            fEnabled,
							UucpName,
							FeedTempDir,
							MaxConnectAttempts,
							1,
							0,
							AuthenticationType,
							NntpAccount,
							NntpPassword,
							fAllowControlMessages,
							OutgoingPort,
							FeedPairId,
							&ParmErr
							);
		}	// end for
	}	// end mb.open

	mb.Close();

    LEAVE
    return(TRUE);

error_exit:

	mb.Close();

    LEAVE
    return(FALSE);

} // InitializeFeedsFromMetabase

DWORD
WINAPI
FeedScheduler(
        LPVOID Context
        )
/*++

Routine Description:

    This is the worker routine that schedules feeds.

Arguments:

    Context - unused.

Return Value:

    Bogus

--*/
{
    DWORD status;
    DWORD timeout;
	PNNTP_SERVER_INSTANCE pInstance = NULL ;

    ENTER("FeedScheduler")

    timeout = g_pNntpSvc->m_FeedSchedulerSleepTime * 1000 ;

    //
    // Loop until the termination event is signalled
    //

    while ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_STOP_PENDING ) {

        status = WaitForSingleObject(
                            g_pNntpSvc->m_hFeedEvent,
                            timeout
                            );

#if ALLOC_DEBUG
        ErrorTrace(0,"field %d article %d\n",numField,numArticle);
        ErrorTrace(0,"Datefield %d frompeerArt %d\n",numDateField,numFromPeerArt);
        ErrorTrace(0,"Pcstring %d PCParse %d\n",numPCString,numPCParse);
        ErrorTrace(0,"CCmd %d CMapFile %d\n",numCmd,numMapFile);
#endif

        if (status == WAIT_TIMEOUT )	{

			if( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {
				continue;
			}

			//	Get the min and max instance ids
			DWORD dwMinInstanceId = 0;
			DWORD dwMaxInstanceId = 0;

			if( FindIISInstanceRange( g_pNntpSvc, &dwMinInstanceId, &dwMaxInstanceId ) )
			{
				//
				//	Iterate over all instances
				//
				for( DWORD dwCurrInstance = dwMinInstanceId;
						dwCurrInstance <= dwMaxInstanceId; dwCurrInstance++)
				{
					pInstance = FindIISInstance( g_pNntpSvc, dwCurrInstance, FALSE );
					if( pInstance == NULL ) {
						ErrorTrace(0,"Feed thread: FindIISInstance returned NULL: instance %d", dwCurrInstance);
						continue;
					}

					//
					//	Call method to process feeds for an instance
					//	This call is guarded by a r/w lock. shutdown code
					//	acquires this lock exclusively.
					//

					CShareLockNH* pLockInstance = pInstance->GetInstanceLock();

					pLockInstance->ShareLock();
					if( !ProcessInstanceFeed( pInstance ) ) {
						ErrorTrace(0,"ProcessInstanceFeed %d failed", dwCurrInstance );
					} else {
						DebugTrace(0, "ProcessInstanceFeed %d returned success", dwCurrInstance );
					}
					pLockInstance->ShareUnlock();

					//	Release the ref added by FindIISInstance()
					pInstance->Dereference();

					//	No use continuing the iteration if service is stopping !
					if ( g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING ) break;
				}
			} else {
				ErrorTrace(0, "FindIISInstanceRange failed" );
			}

        }	else if (status == WAIT_OBJECT_0) {

            DebugTrace(0,"Termination event signalled\n");
            break;
        } else {

            ErrorTrace(0,"Unexpected status %d from WaitForSingleEntry\n", status);
            _ASSERT(FALSE);
            break;
        }
    }

    LEAVE
    return 1;

} // FeedScheduler

//
//	Process feeds for a given virtual server instance
//
void GenerateFeedReport(PNNTP_SERVER_INSTANCE pInstance,
						PFEED_BLOCK pFeedBlock)
{
	TraceFunctEnter("GenerateFeedReport");

	if (pFeedBlock == NULL) {
		_ASSERT(FALSE);
		return;
	}

	DWORD cSuccessfulArticles;
	DWORD cTryAgainLaterArticles;
	DWORD cSoftErrorArticles;
	DWORD cHardErrorArticles;
	char szFeedId[32];
	char szFeedPeriod[32];
	char szSuccessfulArticles[32];
	char szTryAgainLaterArticles[32];
	char szSoftErrorArticles[32];
	char szHardErrorArticles[32];
	const char *rgszEventArgs[6] = {
		szFeedId,
		szFeedPeriod,
		szSuccessfulArticles,
		szTryAgainLaterArticles,
		szSoftErrorArticles,
		szHardErrorArticles
	};

	// get the current values and reset the values to 0
	cSuccessfulArticles = InterlockedExchange(&(pFeedBlock->cSuccessfulArticles), 0);
	cTryAgainLaterArticles = InterlockedExchange(&(pFeedBlock->cTryAgainLaterArticles), 0);
	cSoftErrorArticles = InterlockedExchange(&(pFeedBlock->cSoftErrorArticles), 0);
	cHardErrorArticles = InterlockedExchange(&(pFeedBlock->cHardErrorArticles), 0);

	DWORD iMessageId;

	switch (pFeedBlock->FeedId) {
	case (DWORD) -2:
		// directory pickup
		iMessageId = FEED_STATUS_REPORT_PICKUP;
		break;
	case (DWORD) -1:
		// client postings
		iMessageId = FEED_STATUS_REPORT_POSTS;
		break;
	default:
		// a real feed
		// figure out which event log message we want to use
		if (pFeedBlock->FeedType & FEED_TYPE_PASSIVE ||
			pFeedBlock->FeedType & FEED_TYPE_PULL)
		{
			iMessageId = FEED_STATUS_REPORT_INBOUND;
		} else {
			iMessageId = FEED_STATUS_REPORT_OUTBOUND;
		}

		break;
	}

	_ltoa(pFeedBlock->FeedId, szFeedId, 10);
	_ltoa(pInstance->GetFeedReportPeriod(), szFeedPeriod, 10);
	_ltoa(cSuccessfulArticles, szSuccessfulArticles, 10);
	_ltoa(cTryAgainLaterArticles, szTryAgainLaterArticles, 10);
	_ltoa(cSoftErrorArticles, szSoftErrorArticles, 10);
	_ltoa(cHardErrorArticles, szHardErrorArticles, 10);


	// log the event
	NntpLogEventEx(iMessageId, 6, rgszEventArgs, 0,
				   pInstance->QueryInstanceId());

	TraceFunctLeave();	
}

BOOL
ProcessInstanceFeed(
				PNNTP_SERVER_INSTANCE	pInstance
				)
{
	TraceFunctEnter("ProcessInstanceFeed");
	MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

	BOOL fDoFeedReport;

	// bail if service is stopping or instance is not ready for feed processing
	if( (pInstance->QueryServerState() != MD_SERVER_STATE_STARTED)	||
		!pInstance->m_FeedManagerRunning							||
		pInstance->m_BootOptions									||
		(pInstance->QueryServerState() == MD_SERVER_STATE_STOPPING)	||
		(g_pInetSvc->QueryCurrentServiceState() == SERVICE_STOP_PENDING) )
	{
		ErrorTrace(0,"Instance %d cannot process feeds", pInstance->QueryInstanceId());
		return FALSE ;
	}

    PFEED_BLOCK feedBlock;
	BOOL		fInProgress = FALSE ;

    //
    // Compute expiration time
    //

    DO_DEBUG(FEEDMGR) {
        DebugTrace(0,"Wake up\n");
    }

    GetSystemTimeAsFileTime( &pInstance->m_ftCurrentTime );
    LI_FROM_FILETIME( &pInstance->m_liCurrentTime, &pInstance->m_ftCurrentTime );

	//
	// see if its time to do a feed report
	//
	fDoFeedReport = pInstance->IncrementFeedReportTimer();
	if (fDoFeedReport) {
		// go through the passive feeds and do feed reports (active
		// feeds will be reported on in the loop below...)
		feedBlock = (pInstance->m_pPassiveFeeds)->Next(pInstance, NULL);
		GenerateFeedReport(pInstance, pInstance->m_pFeedblockClientPostings);
		GenerateFeedReport(pInstance, pInstance->m_pFeedblockDirPickupPostings);
		while (feedBlock != 0) {
			GenerateFeedReport(pInstance, feedBlock);
			feedBlock = (pInstance->m_pPassiveFeeds)->Next( pInstance, feedBlock ) ;
		}
	}

    //
    // Go through active list and see if we need to party
	//	ActiveFeeds.Next() will add a reference to the feedblock
	//	so it is not deleted while we are using the pointer, but
	//	it does not hold the enumeration lock, so other threads
	//	can do stuff while we enumerate the threads.
    //
	feedBlock = (pInstance->m_pActiveFeeds)->Next( pInstance, NULL ) ;
    while ( feedBlock != 0 ) {
		//
		// check to see if we need to make a feed report about this feed
		//
		if (fDoFeedReport) GenerateFeedReport(pInstance, feedBlock);

		//
		//	If the feed is not already in progress, this will mark it as in
		//	progress.  This ensures that any Admin RPC's which try to
		//	change the Feed Block now and which go through ActiveFeeds.ApplyUpdate()
		//	don't change the Feed Block member variables while we look at them.
		//
		long	lInProgress = (pInstance->m_pActiveFeeds)->MarkInProgress( feedBlock ) ;
        DO_DEBUG(FEEDMGR) {
            DebugTrace(0,"server %s\n",feedBlock->ServerName);
        }

		//
		//	Check if it is really time to start this feed
		//
        if ( !feedBlock->MarkedForDelete  &&
			 !FEED_IS_PASSIVE(feedBlock->FeedType) &&
			 lInProgress == 0 &&
			 feedBlock->fEnabled
             /*(feedBlock->ReferenceCount == 1)*/ ) {

			//
			//	Determine where the time is right for the feed - if this
			//	is the first time since boot, or our time has come - do the feed !
			//

			if( IsFeedTime( pInstance, feedBlock, pInstance->m_liCurrentTime ) ) {
				DO_DEBUG(FEEDMGR) {
					DebugTrace(0,"ok. feed starting for %x\n",feedBlock);
				}
		
				//
				//	Add a reference to the feedBlock.
				//	If we successfully start the socket, then this reference will be
				//	removed when the session completes, for errors we need to remove it
				//	immediately.
				//
				ReferenceFeedBlock( feedBlock );

				//
				//	Try to start a session !
				//
				if ( InitiateOutgoingFeed( pInstance, feedBlock ) ) {

					//
					//	Touch the member varialbles that we know only this thread uses.
					//
					
					fInProgress = TRUE ;
					feedBlock->cFailedAttempts = 0 ;

					feedBlock->NumberOfFeeds ++ ;

					PCHAR	args[2] ;
					CHAR    szId[20];
					_itoa( pInstance->QueryInstanceId(), szId, 10 );
					args[0] = szId;
					args[1] = feedBlock->ServerName ;
					NntpLogEvent(	NNTP_SUCCESSFUL_FEED,
									2,
									(const CHAR **)args,
									0 ) ;

				}	else	{

					//
					//	Grab the critical section that all Feed RPCs must
					//	go through.  We do this to control access to the
					//	cFailedAttempts, MaxConnectAttempts, and Enabled fields !
					//
					//	NOTE : It is important that no other locks be held at this
					//	point so that we don't deadlock with the feed RPCs, fortunately
					//	thats true.
					//

					EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;

					if( GetLastError() != ERROR_NO_DATA ) {

					    ErrorTrace( 0,
					                "Peer feed failed for %s Outgoing %d Error %d\n",
						            feedBlock->ServerName, 
						            feedBlock->OutgoingPort,
						            GetLastError() );

						feedBlock->cFailedAttempts ++ ;
						PCHAR	args[3] ;
						CHAR    szId[20];
						char	szAttempts[20] ;
						_itoa( feedBlock->cFailedAttempts, szAttempts, 10 ) ;
						_itoa( pInstance->QueryInstanceId(), szId, 10 ) ;
						args[0] = szId ;
						args[1] = feedBlock->ServerName ;
						args[2] = szAttempts ;

						//
						//	Log some events about the feed we failed to start.
						//

						if( feedBlock->cFailedAttempts < 5 ) {
							//
							//	Warning event log !
							//
							NntpLogEvent(	NNTP_WARNING_CONNECT,
											2,
											(const CHAR **)args,
											0 ) ;
						}	else	if( feedBlock->cFailedAttempts == 5 ) {
							//	
							//	Error event log !
							//
							NntpLogEvent(	NNTP_ERROR_CONNECT,
											2,
											(const CHAR **)args,
											0 ) ;
						}

						//
						//	Check if we should disable future feeds !!!
						//
						if( feedBlock->cFailedAttempts ==
								feedBlock->MaxConnectAttempts &&
								feedBlock->MaxConnectAttempts != 0xFFFFFFFF )	{


							NntpLogEvent(	NNTP_FEED_AUTO_DISABLED,
											3,
											(const CHAR **)args,
											0
											) ;

							feedBlock->fEnabled = FALSE ;

							UpdateFeedMetabaseValues( pInstance, feedBlock, FEED_PARM_ENABLED ) ;

						}

					} else {

					    ErrorTrace( 0, "Active feed list is empty" );
					}

					LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;

					//
					// Compute next active time
					//
					ComputeNextActiveTime( pInstance, feedBlock, 0, FALSE );

					//
					//	Since we failed to get a session going, we need to
					//	remove the reference we had added before calling
					//	InitiateOutgoingFeed()
					//
					DereferenceFeedBlock( pInstance, feedBlock ) ;
				}
			}
        }
		if( !fInProgress )
			(pInstance->m_pActiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
		fInProgress = FALSE ;
		feedBlock = (pInstance->m_pActiveFeeds)->Next( pInstance, feedBlock ) ;
    }

	TraceFunctLeave();
	return TRUE ;
}

VOID
ReferenceFeedBlock(
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Reference the block.
    *Assumes lock held*

Arguments:

    FeedBlock - Pointer to the Feeds block.

Return Value:

    None.

--*/
{
    DO_DEBUG(FEEDBLOCK) {
        DebugTraceX(0,"Referencing Feed Block %x\n",FeedBlock);
    }
	InterlockedIncrement( (long*)&FeedBlock->ReferenceCount ) ;
    //FeedBlock->ReferenceCount++;

} // ReferenceFeedBlock

VOID
DereferenceFeedBlock(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Dereference the block
    *Assumes lock held*

Arguments:

    FeedBlock - Pointer to the Feeds block.

Return Value:

    None.

--*/
{
    DO_DEBUG(FEEDBLOCK)  {
        DebugTraceX(0,"Dereferencing Feed block %x\n",FeedBlock);
    }

	long	sign = InterlockedDecrement( (long*)&FeedBlock->ReferenceCount ) ;
    if ( /*--FeedBlock->ReferenceCount*/ sign == 0 /*&& FeedBlock->MarkedForDelete*/ ) {

        //
        // Time to go !!
        //

		if( !FEED_IS_PASSIVE( FeedBlock->FeedType ) ) {

			(pInstance->m_pActiveFeeds)->Remove( FeedBlock ) ;

		}	else	{

			(pInstance->m_pPassiveFeeds)->Remove( FeedBlock ) ;

		}

        DO_DEBUG(FEEDMGR) {
            DebugTraceX(0,"Freeing feed block %x\n",FeedBlock);
        }

        _ASSERT( FeedBlock->Signature == FEED_BLOCK_SIGN );
        _ASSERT( FeedBlock->State == FeedBlockStateClosed );

        FeedBlock->Signature = 0xffffffff;

		//
		//	If this block is being deleted because it was replaced by user action
		//	then we do not adjust any of the server config properties.
		//

		if( FeedBlock->ReplacedBy == 0 ) {

			EnterCriticalSection( &pInstance->m_critFeedConfig ) ;

			if( FEED_IS_MASTER( FeedBlock->FeedType ) ) {
				_ASSERT( pInstance->m_OurNntpRole = RoleSlave ) ;
				_ASSERT( pInstance->m_ConfiguredSlaveFeeds == 0 ) ;
				if( FEED_IS_PASSIVE( FeedBlock->FeedType ) ) {
					--pInstance->m_NumberOfMasters ;
				}
				pInstance->m_ConfiguredMasterFeeds -- ;

				if( pInstance->m_ConfiguredMasterFeeds == 0 ) {
					_ASSERT( pInstance->m_NumberOfMasters == 0 ) ;
					pInstance->m_OurNntpRole = RolePeer ;
				}
			}	else	if( FEED_IS_SLAVE( FeedBlock->FeedType ) )	{
				_ASSERT( pInstance->m_OurNntpRole = RoleMaster ) ;
				_ASSERT( pInstance->m_ConfiguredMasterFeeds == 0 ) ;

				pInstance->m_ConfiguredSlaveFeeds -- ;

				if( pInstance->m_ConfiguredSlaveFeeds == 0 ) {
					pInstance->m_OurNntpRole = RolePeer ;
				}
			}	else	{

				if( (	FEED_IS_PASSIVE( FeedBlock->FeedType ) &&
						FEED_IS_PEER( FeedBlock->FeedType )) ||
					FEED_IS_PULL( FeedBlock->FeedType ) ) {

					pInstance->m_ConfiguredPeerFeeds -- ;

				}

			}

			LeaveCriticalSection( &pInstance->m_critFeedConfig ) ;
		}

        //
        // Free everything
        //

        FREE_HEAP( FeedBlock->ServerName );
        FREE_HEAP( FeedBlock->Newsgroups );
        FREE_HEAP( FeedBlock->Distribution );

		if( FeedBlock->pFeedQueue != 0 )	{
			FeedBlock->pFeedQueue->Close(FeedBlock->MarkedForDelete && !FeedBlock->ReplacedBy) ;
			XDELETE	FeedBlock->pFeedQueue ;
		}
		FeedBlock->pFeedQueue = 0 ;

		if( FeedBlock->UucpName != 0 ) {
			FREE_HEAP( FeedBlock->UucpName ) ;
			FeedBlock->UucpName = 0 ;
		}
		if( FeedBlock->FeedTempDirectory != 0 ) {
			FREE_HEAP( FeedBlock->FeedTempDirectory ) ;
			FeedBlock->FeedTempDirectory = 0 ;
		}
		if( FeedBlock->NntpAccount != 0 ) {
			FREE_HEAP( FeedBlock->NntpAccount ) ;
			FeedBlock->NntpAccount = 0 ;
		}
		if( FeedBlock->NntpPassword != 0 ) {
			FREE_HEAP( FeedBlock->NntpPassword ) ;
			FeedBlock->NntpPassword = 0 ;
		}
        FREE_HEAP( FeedBlock );
    }

    return;

} // DereferenceFeedBlock

VOID
CloseFeedBlock(
	PNNTP_SERVER_INSTANCE pInstance,
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Closes the feed block
    *Assumes lock held*

Arguments:

    FeedBlock - Pointer to the Feeds block.

Return Value:

    None.

--*/
{
    if ( FeedBlock->State == FeedBlockStateActive ) {

        //
        // Close it.
        //

        DO_DEBUG(FEEDMGR) {
            DebugTraceX(0,"Closing feed block %x\n",FeedBlock);
        }

		if( !FEED_IS_PASSIVE( FeedBlock->FeedType ) ) {
			(pInstance->m_pActiveFeeds)->Remove( FeedBlock, TRUE ) ;
		}	else	{
			(pInstance->m_pPassiveFeeds)->Remove( FeedBlock, TRUE ) ;
		}
        _ASSERT( FeedBlock->Signature == FEED_BLOCK_SIGN );
        DereferenceFeedBlock( pInstance, FeedBlock );
    }

    return;

} // CloseFeedBlock

VOID
CompleteFeedRequest(
			PNNTP_SERVER_INSTANCE pInstance,
            IN PVOID Context,
			IN FILETIME	NextPullTime,
            BOOL Success,
			BOOL NoData
            )
/*++

Routine Description:

    Completion routine for a pull feed request

Arguments:

    Context - Actually a pointer the feed block being completed
    Success - Whether the pull was successful or not

Return Value:

    None.

--*/
{
    PFEED_BLOCK feedBlock = (PFEED_BLOCK)Context;

    //
    // No feedblock to complete. return.
    //

    if ( feedBlock == NULL ||
		 feedBlock == pInstance->m_pFeedblockClientPostings ||
		 feedBlock == pInstance->m_pFeedblockDirPickupPostings)
	{
        return;
    }

    DO_DEBUG(FEEDMGR) {
        DebugTraceX(0,"Feed Completion called for %x refc %d\n",
            feedBlock, feedBlock->ReferenceCount);
    }

	// Decrement feed conx counters
	BumpOutfeedCountersDown( pInstance );

    //
    // Compute the next Timeout period for this block if we are done
    // with the feed object
    //

    if ( feedBlock->ReferenceCount > 1 ) {

        if ( Success && ResumePeerFeed( pInstance, feedBlock ) ) {

			//
			//	If we successfully resumed the feed,
			//	then return now as we want to leave without
			//	decrementing the reference count !
			//

			return	;
        }	else	{

			ComputeNextActiveTime( pInstance, feedBlock, &NextPullTime, Success );

			if( FEED_IS_PULL(feedBlock->FeedType) && (Success || NoData) ) {
				feedBlock->AutoCreate = FALSE ;
			}

			// Log an event
			PCHAR args [4];
			CHAR  szId[20];
			char szServerName [MAX_DOMAIN_NAME];
			_itoa( pInstance->QueryInstanceId(), szId, 10 );
			args [0] = szId;

			// get the server name *before* we UnmarkInProgress !
			lstrcpy( szServerName, feedBlock->ServerName );
			args [2] = szServerName;

			if( !FEED_IS_PASSIVE( feedBlock->FeedType ) ) {
				(pInstance->m_pActiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
				args [1] = "an active";
			}
			else {
				(pInstance->m_pPassiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
				args [1] = "a passive";
			}

			args[3] = Success ? "SUCCESS" : "FAILURE";
			NntpLogEvent(		
				NNTP_SUCCESSFUL_FEED_COMPLETED,
				4,
				(const CHAR **)args,
				0 ) ;

		}
    }

    DereferenceFeedBlock( pInstance, feedBlock );

} // CompleteFeedRequest

BOOL
IsFeedTime(	
		PNNTP_SERVER_INSTANCE pInstance,
		PFEED_BLOCK	feedBlock,	
		ULARGE_INTEGER	liCurrentTime
		)
{
	BOOL	fReturn = FALSE ;
	EnterCriticalSection( &pInstance->m_critFeedTime ) ;

	fReturn =
		(feedBlock->NumberOfFeeds == 0) ||
		((pInstance->m_liCurrentTime).QuadPart > feedBlock->NextActiveTime.QuadPart) ;

	LeaveCriticalSection( &pInstance->m_critFeedTime ) ;

	return	fReturn ;
}

VOID
ComputeNextActiveTime(
		IN PNNTP_SERVER_INSTANCE pInstance,
        IN PFEED_BLOCK FeedBlock,
		IN FILETIME*	NextPullTime,
        IN BOOL SetNextPullTime
        )
/*++

Routine Description:

    Computes when the next pull should take place

Arguments:

    Context - A pointer the feed block
    SetNextPullTime - Changes next pull time in registry

Return Value:

    None.

--*/
{
    ULARGE_INTEGER liInterval;
	FILETIME ftCurrTime = {0};
	ULARGE_INTEGER liCurrTime = {0};

	// current time
    GetSystemTimeAsFileTime( &ftCurrTime );
    LI_FROM_FILETIME( &liCurrTime, &ftCurrTime );
	
	EnterCriticalSection( &pInstance->m_critFeedTime ) ;

    DWORD interval = FeedBlock->FeedIntervalMinutes;
	
    ENTER("ComputeNextActiveTime")

    //
    // if this is a pull feed, record the time for the next pull
    //

    if ( SetNextPullTime &&
         FEED_IS_PULL(FeedBlock->FeedType) ) {

        SetNextPullFeedTime( pInstance, NextPullTime, FeedBlock );
    }

    //
    // Make sure the interval is at least the minimum
    //

    if ( interval < MIN_FEED_INTERVAL ) {
        interval = MIN_FEED_INTERVAL;
    }

    liInterval.QuadPart = (ULONGLONG)1000 * 1000 * 10 * 60;
    liInterval.QuadPart *= interval;

    if ( FeedBlock->StartTime.QuadPart == 0 ) {

        //
        // Simple scheduling
        //

        FeedBlock->NextActiveTime.QuadPart =
                liCurrTime.QuadPart + liInterval.QuadPart;

    } else {

        //
        // Complicated scheduling
        //

        FeedBlock->NextActiveTime.QuadPart = FeedBlock->StartTime.QuadPart;

        //
        // if interval is zero, that means that the admin want a
        // single scheduled feed.
        //

        if ( FeedBlock->FeedIntervalMinutes != 0  ) {

            //
            // Adjust so we get a time that's later than now.  If they
            // want complex, we'll give them complex.
            //

            while ( liCurrTime.QuadPart >
                    FeedBlock->NextActiveTime.QuadPart ) {

                FeedBlock->NextActiveTime.QuadPart += liInterval.QuadPart;
            }

        } else {

			// the RPC now returns an error for zero interval times
			_ASSERT( FEED_IS_PASSIVE(FeedBlock->FeedType) || (1==0) );

            //
            // if the start time is earlier than the current time,
            // then don't do it.
            //

            if ( FeedBlock->StartTime.QuadPart <  liCurrTime.QuadPart ) {
                FeedBlock->NextActiveTime.HighPart = 0x7fffffff;
            }
        }
    }

	LeaveCriticalSection( &pInstance->m_critFeedTime ) ;

    return;

} // ComputeNextActiveTime

VOID
SetNextPullFeedTime(
	PNNTP_SERVER_INSTANCE pInstance,
	FILETIME*	pNextPullTime,
    PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Sets next pull time in registry

Arguments:

    Context - A pointer the feed block

Return Value:

    None.

--*/
{
    DWORD error;
    MB      mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );

    ENTER("SetNextPullFeedTime")

	if( pNextPullTime != 0 &&
		pNextPullTime->dwLowDateTime != 0 &&
		pNextPullTime->dwHighDateTime != 0 ) {

		FeedBlock->PullRequestTime = *pNextPullTime ;
	
	}	else	{

		FeedBlock->PullRequestTime = pInstance->m_ftCurrentTime;

	}

    //
    //  Avoid saving to the metabase during instance stop !!
    //
    if( pInstance->QueryServerState() != MD_SERVER_STATE_STOPPING ) {

	    if( !mb.Open( pInstance->QueryMDFeedPath(), METADATA_PERMISSION_WRITE ) )
	    {
		    error = GetLastError();
            ErrorTrace(0,"Error %d opening %s\n",error,FeedBlock->KeyName);
            return;
	    }

	    if ( !mb.SetDword(	FeedBlock->KeyName,
						    MD_FEED_NEXT_PULL_HIGH,
						    IIS_MD_UT_SERVER,
						    FeedBlock->PullRequestTime.dwHighDateTime ) )
	    {
		    error = GetLastError();
            ErrorTrace(0,"Error %d setting %s for %s\n",
                error, StrFeedNextPullHigh, FeedBlock->KeyName);
	    }

	    if ( !mb.SetDword(	FeedBlock->KeyName,
						    MD_FEED_NEXT_PULL_LOW,
						    IIS_MD_UT_SERVER,
						    FeedBlock->PullRequestTime.dwLowDateTime ) )
	    {
		    error = GetLastError();
            ErrorTrace(0,"Error %d setting %s for %s\n",
                error, StrFeedNextPullLow, FeedBlock->KeyName);
	    }

        mb.Close();
    }

    return;

} // SetNextPullFeedTime

VOID
ConvertTimeToString(
    IN PFILETIME Ft,
    OUT CHAR Date[],
    OUT CHAR Time[]
    )
/*++

Routine Description:

    Converts a FILETIME into a date and time string

Arguments:

    Ft - the filetime to convert
    Date - points to a buffer to receive the date
    Time - points to a buffer to receive the time string

Return Value:

    None.

--*/
{
    SYSTEMTIME st;
    INT len;

    if ( Ft->dwHighDateTime != 0 ) {

        (VOID)FileTimeToSystemTime( Ft, &st );
        len = wsprintf(Date,"%02d%02d%02d",(st.wYear % 100),st.wMonth,st.wDay);
        _ASSERT(len == 6);

        wsprintf(Time,"%02d%02d%02d",st.wHour,st.wMinute,st.wSecond);
        _ASSERT(len == 6);

    } else {

        //
        // if no date specified, then use today's date + midnight
        //

        GetSystemTime( &st );
        len = wsprintf(Date,"%02d%02d%02d",(st.wYear % 100),st.wMonth,st.wDay);
        _ASSERT(len == 6);
        lstrcpy( Time, DEF_PULL_TIME );
    }

    return;
} // ConvertTimeToString

//!!!Need to generalize to other types of pull feeds
BOOL
InitiateOutgoingFeed(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Initiates a peer feed

Arguments:

    FeedBlock - Pointer to the feed block

Return Value:

    TRUE, if successful. FALSE, otherwise

--*/
{

    DWORD inetAddress;
    IN_ADDR addr;
	SOCKADDR_IN sockaddr;
	CAuthenticator*	pAuthenticator = 0 ;

    INT err;
	DWORD	status = NO_ERROR ;

	SetLastError( NO_ERROR ) ;

    ENTER("InitializePeerFeed")

	inetAddress = inet_addr(FeedBlock->ServerName);
    if ( inetAddress == INADDR_NONE ) {

        PHOSTENT hp;

        //
        // Ask the dns for the address
        //

        hp = gethostbyname( FeedBlock->ServerName );
        if ( hp == NULL ) {
            err = WSAGetLastError();
            ErrorTrace(0,"Error %d in gethostbyname\n",err);
            return(FALSE);
        }

        addr = *((PIN_ADDR)*hp->h_addr_list);

    } else {

        addr.s_addr = inetAddress;
    }

	sockaddr.sin_family = AF_INET;
	sockaddr.sin_port = htons((USHORT)FeedBlock->OutgoingPort); //htons(NNTP_PORT);
	sockaddr.sin_addr = addr;


	if( FeedBlock->AuthenticationSecurity == AUTH_PROTOCOL_CLEAR &&
		FeedBlock->NntpAccount != 0 &&
		FeedBlock->NntpPassword != 0 ) {

		pAuthenticator = XNEW CClearTextAuthenticator( FeedBlock->NntpAccount, FeedBlock->NntpPassword ) ;
		if( pAuthenticator == 0 ) {
			return	FALSE ;
		}

	}	else	{
		
		//
		//	No other types supported for the time being !
		//


	}

    //
    // ok, allocate the Peer feed object
    //

	if(	FEED_IS_PULL(FeedBlock->FeedType) )	{

		_ASSERT(	FeedBlock->pFeedQueue == 0 ) ;

		CFromPeerFeed *	pfeedPeer = new CFromPeerFeed();
		if ( pfeedPeer == NULL ) {
			ErrorTrace(0,"Unable to allocate PeerFeed object\n");
			return(FALSE);
		}

		pfeedPeer->fInit(
				(PVOID)FeedBlock,
				pInstance->m_PeerTempDirectory,
				FeedBlock->Newsgroups[0],
				pInstance->m_PeerGapSize,
				FeedBlock->AutoCreate,
				FALSE,	/* No security checks for pull feeds*/
				FeedBlock->fAllowControlMessages,
				FeedBlock->FeedId
				);

		//
		// Set feedblock data
		//

		int	isz = NextLegalSz( FeedBlock->Newsgroups, 0 ) ;

		if( isz < 0 )	{
			status = ERROR_INVALID_PARAMETER ;
			delete	pfeedPeer ;
			goto	error ;
		}

		FeedBlock->LastNewsgroupPulled = (DWORD)isz ;

		pfeedPeer->SetCurrentGroupString(	FeedBlock->Newsgroups[ FeedBlock->LastNewsgroupPulled ] ) ;
		
		FeedBlock->IPAddress = addr.s_addr;

		//
		// Get the newnews Time/Dates
		//

		ConvertTimeToString(
					&FeedBlock->PullRequestTime,
					pfeedPeer->newNewsDate(),
					pfeedPeer->newNewsTime()
					);

		//
		// Create session socket object
		//

		CSessionSocket *pSocket =
			new CSessionSocket( pInstance, INADDR_NONE, FeedBlock->OutgoingPort, TRUE );

		if ( pSocket == NULL ) {
			status = ERROR_OUTOFMEMORY ;
			delete	pfeedPeer ;
			ErrorTraceX(0,"Unable to create SessionSocket object\n");
			goto error;
		}

		//
		//	We are no longer responsible for destroying pAuthenticator in any
		//	circumstances after calling ConnectSocket()
		//
		if( !pSocket->ConnectSocket( &sockaddr,  pfeedPeer, pAuthenticator ) )	{
			pAuthenticator = 0 ;
			status = ERROR_PIPE_BUSY ;
			IncrementStat( pInstance, OutboundConnectsFailed );
			delete	pfeedPeer ;
			delete	pSocket ;
			goto	error ;
		}
		pAuthenticator = 0 ;

		IncrementStat( pInstance, TotalPullFeeds );
		BumpOutfeedCountersUp( pInstance );

	}	else	{

		if(	FeedBlock->pFeedQueue != 0 ) {

			if( FeedBlock->pFeedQueue->FIsEmpty() )	{

				status = ERROR_NO_DATA ;
				goto	error ;

			}	else	{

				COutFeed*	pOutFeed = 0 ;

				if(FEED_IS_MASTER(FeedBlock->FeedType))	{

					pOutFeed = new	COutToMasterFeed( FeedBlock->pFeedQueue, pInstance) ;

				}	else	if(FEED_IS_SLAVE(FeedBlock->FeedType))	{

					pOutFeed = new	COutToSlaveFeed( FeedBlock->pFeedQueue, pInstance) ;

				}	else	if(FEED_IS_PEER(FeedBlock->FeedType))	{

					pOutFeed = new	COutToPeerFeed( FeedBlock->pFeedQueue, pInstance) ;

				}	else	{

					//
					//	What other type of feed is there ??
					//
					_ASSERT( 1==0 ) ;

				}

				if( pOutFeed != 0 ) {

					pOutFeed->fInit(
							(PVOID)FeedBlock ) ;

					//
					//	Create a CSessionSocket object
					//

					CSessionSocket *pSocket =
						new CSessionSocket( pInstance, INADDR_NONE, FeedBlock->OutgoingPort, TRUE );

					if ( pSocket == NULL ) {
						ErrorTraceX(0,"Unable to create SessionSocket object\n");
						status = ERROR_OUTOFMEMORY ;
						delete	pOutFeed ;
						goto error;
					}

					//
					//	After calling ConnectSocket we are not responsible for
					//	destroying pAuthenticator !
					//
					if( !pSocket->ConnectSocket( &sockaddr,  pOutFeed, pAuthenticator ) )	{
						status = ERROR_PIPE_BUSY ;
						IncrementStat( pInstance, OutboundConnectsFailed );
						delete	pSocket ;
						delete	pOutFeed ;
						pAuthenticator = 0 ;
						goto	error ;
					}
					pAuthenticator = 0 ;
					IncrementStat( pInstance, TotalPushFeeds );
					BumpOutfeedCountersUp(pInstance);

				}	else	{

					status = ERROR_OUTOFMEMORY ;
				}
			}
		}
	}

    return(TRUE);

error:

	if( pAuthenticator )
		XDELETE	pAuthenticator ;

	SetLastError( status ) ;
    return(FALSE);

} // InitiateOutgoingFeed

LPSTR
ServerNameFromCompletionContext(	LPVOID	lpv )	{

	if( lpv != 0 ) {	
		PFEED_BLOCK	FeedBlock = (PFEED_BLOCK)lpv ;

		_ASSERT( FeedBlock->Signature == FEED_BLOCK_SIGN ) ;

		return	FeedBlock->ServerName ;
	}
	return	0 ;
}

BOOL
ResumePeerFeed(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PFEED_BLOCK FeedBlock
    )
/*++

Routine Description:

    Try to resume a peer feed with the next newsgroup

Arguments:

    FeedBlock - Pointer to the feed block

Return Value:

    TRUE, if successful. FALSE, otherwise

--*/
{

    //DWORD inetAddress;
    //IN_ADDR addr;
    SOCKADDR_IN sockaddr;
    CInFeed *infeed = NULL;
    //INT err;
    PCHAR newsgroup;
	CFromPeerFeed*	peerfeed = NULL ;
	CAuthenticator*	pAuthenticator = 0 ;

    ENTER("ResumePeerFeed")

    //
    // See if we have more newsgroups to process
    //

	if( FEED_IS_PULL( FeedBlock->FeedType ) )	{

		_ASSERT( FeedBlock->Newsgroups[ FeedBlock->LastNewsgroupPulled ] != 0 ) ;

		FeedBlock->LastNewsgroupPulled ++ ;
		int	iNextGroup = NextLegalSz( FeedBlock->Newsgroups, FeedBlock->LastNewsgroupPulled ) ;

		if( iNextGroup < 0 ) {

			//
			//	No more newsgroups !!
			//
			return	FALSE ;

		}	else	{

			FeedBlock->LastNewsgroupPulled = (DWORD)iNextGroup ;
			newsgroup = FeedBlock->Newsgroups[ FeedBlock->LastNewsgroupPulled ] ;

		}
	}	else	{

		return	FALSE ;

	}


	if( FeedBlock->AuthenticationSecurity == AUTH_PROTOCOL_CLEAR &&
		FeedBlock->NntpAccount != 0 &&
		FeedBlock->NntpPassword != 0 ) {

		pAuthenticator = XNEW CClearTextAuthenticator( FeedBlock->NntpAccount, FeedBlock->NntpPassword ) ;
		if( pAuthenticator == 0 ) {
			return	FALSE ;
		}

	}	else	{
		
		//
		//	No other types supported for the time being !
		//


	}


	//
	// Fill up the sockaddr structure
	//

	sockaddr.sin_family = AF_INET;
	sockaddr.sin_port = htons((USHORT)FeedBlock->OutgoingPort); //(NNTP_PORT);
	sockaddr.sin_addr.s_addr = FeedBlock->IPAddress;

	//
	// ok, allocate the Peer feed object
	//

	if ( FEED_IS_MASTER(FeedBlock->FeedType) ) {

		infeed = new CFromMasterFeed( );

	} else if ( FEED_IS_PEER(FeedBlock->FeedType) ) {

		infeed = peerfeed =  new CFromPeerFeed( );
	} else {

		infeed = peerfeed = new CFromPeerFeed( );
	}


	if ( infeed == NULL ) {
		ErrorTrace(0,"Unable to allocate CInFeed object\n");
		if( pAuthenticator != 0 )
			XDELETE	pAuthenticator ;
		return(FALSE);
	}

	infeed->fInit(
			(PVOID)FeedBlock,
			pInstance->m_PeerTempDirectory,
			FeedBlock->Newsgroups[0],
			pInstance->m_PeerGapSize,
			FALSE,
			FALSE,	/* No security checks for this feed */
			FeedBlock->fAllowControlMessages,
			FeedBlock->FeedId
			);

	if( peerfeed != 0 ) {

		peerfeed->SetCurrentGroupString( FeedBlock->Newsgroups[ FeedBlock->LastNewsgroupPulled ] ) ;

	}


	//
	// Get the newnews Time/Dates
	//

	ConvertTimeToString(
				&FeedBlock->PullRequestTime,
				infeed->newNewsDate(),
				infeed->newNewsTime()
				);

	//
	// Create session socket object
	//

	CSessionSocket *pSocket =
		new CSessionSocket( pInstance, INADDR_NONE, FeedBlock->OutgoingPort, TRUE );

	if ( pSocket == NULL ) {
		ErrorTraceX(0,"Unable to create SessionSocket object\n");
		goto error;
	}

	//
	//	We are not responsible for destroying pAuthenticator
	//	after calling ConnectSocket !!
	//
	if( !pSocket->ConnectSocket( &sockaddr,  infeed, pAuthenticator ) )	{
		pAuthenticator = 0 ;
		IncrementStat( pInstance, OutboundConnectsFailed );
		delete	pSocket ;
		goto	error ;
	}

	BumpOutfeedCountersUp(pInstance);

	return(TRUE);

error:

	if( pAuthenticator )
		XDELETE	pAuthenticator ;

    delete infeed;
    return(FALSE);

} // ResumePeerFeed

BOOL
ValidateFeedType(
    DWORD FeedType
    )
{

    ENTER("ValidateFeedType")

    //
    // Make sure the values are reasonable
    //

    if ( (FeedType & FEED_ACTION_MASK) > 0x2 ) {
        goto error;
    }

    if ( (FeedType & FEED_REMOTE_MASK) > 0x20 ) {
        goto error;
    }

	if( (FeedType & FEED_ACTION_MASK) == FEED_TYPE_PULL ) {
		if( !FEED_IS_PEER( FeedType ) ) {
			goto	error ;
		}
	}

    return TRUE;

error:

    ErrorTrace(0,"Invalid Feed type %x\n",FeedType);
    return FALSE;

} // ValidFeedType

PFEED_BLOCK
GetRemoteRole(
	IN PNNTP_SERVER_INSTANCE pInstance,
    IN PSOCKADDR_IN SockAddr,
    IN BOOL fRemoteEqualsLocal
    )
{

	INT			err ;
	PFEED_BLOCK	feedBlock = 0 ;
	PFEED_BLOCK	feedBlockNext = 0 ;
	IN_ADDR		addr[2] ;
	PIN_ADDR*	ppaddr = 0 ;

	TraceFunctEnter( "GetRemoteRole" ) ;

	ZeroMemory( addr, sizeof( addr ) ) ;
	PIN_ADDR	paddr[2] ;
	paddr[0] = &addr[0] ;
	paddr[1] = 0 ;

	CHAR* FromIp = inet_ntoa( SockAddr->sin_addr );
	
	for( feedBlockNext = feedBlock = (pInstance->m_pPassiveFeeds)->StartEnumerate();
					feedBlock != 0;
					feedBlock = feedBlockNext = (pInstance->m_pPassiveFeeds)->NextEnumerate( feedBlockNext ) )	{

		_ASSERT( FEED_IS_PASSIVE( feedBlock->FeedType ) ) ;
		if( !feedBlock->fEnabled ) continue;	// Ignore disabled feeds

		if( FEED_IS_PASSIVE( feedBlock->FeedType ) ) {

			addr[0].s_addr = inet_addr( feedBlock->ServerName ) ;

			if( addr[0].s_addr == INADDR_NONE )	{

			    PHOSTENT	hp ;
			
				hp = gethostbyname( feedBlock->ServerName ) ;
				if( hp == NULL ) {
					err = WSAGetLastError() ;
					ErrorTrace( 0, "Error %d in gethostbyname", err ) ;
					feedBlock = 0 ;
					continue ;
				}	else	{
					ppaddr = ((PIN_ADDR*)hp->h_addr_list) ;
				}
			}	else	{

				ppaddr = &paddr[0] ;
				
			}

			while( *ppaddr != 0 ) {
				if( (*ppaddr)->s_addr == SockAddr->sin_addr.s_addr ) {
					break ;
				}
				ppaddr++ ;
			}
			if( *ppaddr != 0 )	{
				//
				//	Add a reference to the feedBlock we are going to return !
				//
				ReferenceFeedBlock( feedBlock ) ;
				(pInstance->m_pPassiveFeeds)->FinishEnumerate( feedBlock ) ;
				break ;
			}
		}
		feedBlock = 0 ;

	}

    return feedBlock ;

} // GetRemoteRole

CInFeed *
pfeedCreateInFeed(
	PNNTP_SERVER_INSTANCE pInstance,
    PSOCKADDR_IN sockaddr,
    BOOL        fRemoteEqualsLocal,
    CInFeed * & pInFeedFromClient,
    CInFeed * & pInFeedFromMaster,
    CInFeed * & pInFeedFromSlave,
    CInFeed * & pInFeedFromPeer
    )

/*++

Routine Description:

	Used to create a feed of the right type given a socket. Also,
	initializes the object.

Arguments:

	sockaddr - address of the the socket of the feed
	pInFeedFromClient - If this is a client, a pointer to the feed, otherwise, NULL
	pInFeedFromMaster - If this is a master, a pointer to the feed, otherwise, NULL
	pIfeedFromSlave - If this is a slave, a pointer to the feed, otherwise, NULL
	pInFeedFromPeer - If this is a peer, a pointer to the feed, otherwise, NULL

Return Value:

	A pointer to the new feed object or NULL

--*/
{
    //NNTP_ROLE remoteRole;
	//char	*szLogString ;
	DWORD	dwMessageId = NNTP_INCOMING_PEER ;


	//
	// Initialize all to Null
	//

	CInFeed * pInFeed = NULL;
		
    pInFeedFromClient = NULL;
    pInFeedFromMaster = NULL;
	pInFeedFromSlave = NULL;
	pInFeedFromPeer = NULL;

	//
	// Here is where we look to find if it is FromMaster, FromPeer, or FromSlave
	//

    FEED_BLOCK*	feedBlock = GetRemoteRole( pInstance, sockaddr, fRemoteEqualsLocal );

	if( feedBlock == 0 ) {


		pInFeedFromClient = pInstance->NewClientFeed();

		pInFeed = pInFeedFromClient;

		if( pInFeed != 0 ) {
			//
			// Init InFeedFromClient feed
			// !!! need to put correct directory, correct netnews pattern, correct
			// !!! gap, and correct user login name.
			//

			//ReferenceFeedBlock( feedBlock ) ;

			pInFeed->fInit( (PVOID)pInstance->m_pFeedblockClientPostings,
							pInstance->m_PeerTempDirectory,
							0,
							0,
							0,
							TRUE,	/* Do security checks on clients */
							TRUE,	/* allow control messages from clients */
							pInstance->m_pFeedblockClientPostings->FeedId
							);
		}

	}	else	{

		_ASSERT( FEED_IS_PASSIVE( feedBlock->FeedType ) ) ;

		DWORD	cbGap = 0 ;

		(pInstance->m_pPassiveFeeds)->MarkInProgress( feedBlock ) ;

		if( FEED_IS_SLAVE( feedBlock->FeedType ) ) {
			pInFeedFromSlave = new CFromPeerFeed( ) ;
			pInFeed = pInFeedFromSlave;
			//Getting a feed from a slave is just like getting one from a peer
			dwMessageId = NNTP_INCOMING_SLAVE ;
		}	else	if(	FEED_IS_MASTER( feedBlock->FeedType ) ) {
			pInFeedFromMaster = new CFromMasterFeed( ) ;
			pInFeed = pInFeedFromMaster;
			dwMessageId = NNTP_INCOMING_MASTER ;
		}	else	if(	FEED_IS_PEER(	feedBlock->FeedType ) ) {
			pInFeedFromPeer = new CFromPeerFeed( ) ;
			pInFeed = pInFeedFromPeer;
			dwMessageId = NNTP_INCOMING_PEER ;
		}

		if( pInFeed != 0 ) {
			//
			// Init InFeedFromClient feed
			// !!! need to put correct directory, correct netnews pattern, correct
			// !!! gap, and correct user login name.
			//

			_ASSERT( feedBlock->FeedTempDirectory != 0 ) ;
			_ASSERT( feedBlock->Newsgroups[0] != 0 ) ;

			pInFeed->fInit( (PVOID)feedBlock,
							feedBlock->FeedTempDirectory,
							feedBlock->Newsgroups[0],
							cbGap,
							feedBlock->AutoCreate,
							FALSE,
							feedBlock->fAllowControlMessages,
							feedBlock->FeedId
							);

			// bump the counter
			IncrementStat( pInstance, TotalPassiveFeeds );

			//
			//	Log the event
			//
			char	*szAddress = inet_ntoa( sockaddr->sin_addr ) ;

			PCHAR	args[3] ;
			CHAR    szId[10];
			_itoa( pInstance->QueryInstanceId(), szId, 10 );

			args [0] = szId ;
			if( szAddress != 0 )
				args[1] = szAddress ;
			else
				args[1] = "UNKNOWN" ;
			args[2] = feedBlock->ServerName ;

			NntpLogEvent(		
				dwMessageId,
				3,
				(const CHAR **)args,
				0 ) ;

		}	else	{
			//
			//	Need to remove the reference GetRemoteRole() added
			//
			(pInstance->m_pPassiveFeeds)->UnmarkInProgress( pInstance, feedBlock ) ;
			DereferenceFeedBlock( pInstance, feedBlock ) ;
		}

	}

	return pInFeed;
}

BOOL
BuildFeedQFileName(	
					char*	szFileOut,	
					DWORD	cbFileOut,	
					char*   szFileIn,
					char*	szPathIn
					)
/*++

Routine Description :

	This function uses the directory passed in to build a full pathname for the feedq files.

Arguments :
	szFileOut - Buffer in which to save path
	cbFileOut - size of output buffer
	szFileIn  - Feedq key name
	szPathIn  - Path name to use as base

Return Value :
	TRUE if successfull, FALSE otherwise.

--*/
{
	DWORD cbPathIn;
	ZeroMemory( szFileOut, cbFileOut ) ;

	if( cbFileOut > (cbPathIn = lstrlen( szPathIn )) )
	{
		lstrcpy( szFileOut, szPathIn );

		char* pch = szFileOut+cbPathIn-1;
		while( pch >= szFileOut && (*pch-- != '\\') );	// skip till we see a \
		if( pch == szFileOut ) return FALSE;

		// null-terminate the path
		*(pch+2) = '\0';

		if( cbFileOut > DWORD(lstrlen( szFileOut ) + lstrlen( szFileIn ) + 1) )
		{
			lstrcat( szFileOut, szFileIn );
			return TRUE;
		}
	}

	return	FALSE ;
}

void
BumpOutfeedCountersUp( PNNTP_SERVER_INSTANCE pInstance )	{

	LockStatistics( pInstance ) ;

	IncrementStat( pInstance, CurrentOutboundConnects ) ;
	IncrementStat( pInstance, TotalOutboundConnects ) ;

#if 0	// NYI
	if( NntpStat.MaxOutboundConnections < NntpStat.CurrentOutboundConnects ) {
		NntpStat.MaxOutboundConnections = NntpStat.CurrentOutboundConnects ;	
	}
#endif

	UnlockStatistics( pInstance ) ;

}

void
BumpOutfeedCountersDown( PNNTP_SERVER_INSTANCE pInstance )	{

	LockStatistics( pInstance ) ;

	if ( (pInstance->m_NntpStats).CurrentOutboundConnects > 0 )
		DecrementStat(	pInstance, CurrentOutboundConnects ) ;

	UnlockStatistics( pInstance ) ;
}

DWORD
AddFeedToFeedBlock(
    IN  NNTP_HANDLE ServerName,
    IN  DWORD       InstanceId,
    IN  LPI_FEED_INFO FeedInfo,
    IN  LPSTR       szKeyName,
    OUT PDWORD ParmErr OPTIONAL,
    OUT LPDWORD pdwFeedId
    )
{
    DWORD err = NERR_Success;
    PFEED_BLOCK feedBlock;
    DWORD parmErr = 0;
    ULARGE_INTEGER liStart;
    BOOL IsUnicode = TRUE;

    BOOL serverNamePresent;
    BOOL distPresent;
    BOOL newsPresent;

    DWORD   feedId = 0;
    *pdwFeedId = 0;

    ENTER("NntprAddFeed");

    ACQUIRE_SERVICE_LOCK_SHARED();

    //
    //  Locate the instance object given id
    //

    PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
    if( pInstance == NULL ) {
        ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //
    // KangYan: This goes away
    /*
    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }*/

    EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;

    //
    // Check feed type
    //

    if ( !ValidateFeedType(FeedInfo->FeedType) ) {
        parmErr = FEED_PARM_FEEDTYPE;
        goto invalid_parm;
    }

    //
    // Check feed interval
    //

    if ( !FEED_IS_PASSIVE(FeedInfo->FeedType) && !FeedInfo->FeedInterval ) {
        parmErr = FEED_PARM_FEEDINTERVAL;
        goto invalid_parm;
    }

    LI_FROM_FILETIME( &liStart, &FeedInfo->StartTime );

    serverNamePresent = ((FeedInfo->ServerName != FEED_STRINGS_NOCHANGE) &&
                         (*FeedInfo->ServerName != L'\0'));

    newsPresent = VerifyMultiSzListW(
                        FeedInfo->Newsgroups,
                        FeedInfo->cbNewsgroups
                        );

    distPresent = VerifyMultiSzListW(
                        FeedInfo->Distribution,
                        FeedInfo->cbDistribution
                        );

    //
    // ok, let's do the new feed stuff first
    //

    if ( !serverNamePresent ) {
        parmErr = FEED_PARM_SERVERNAME;
        goto invalid_parm;
    }

    if ( !newsPresent ) {
        parmErr = FEED_PARM_NEWSGROUPS;
        goto invalid_parm;
    }

    if ( !distPresent ) {
        parmErr = FEED_PARM_DISTRIBUTION;
        goto invalid_parm;
    }

    //
    //  validate all buffer lengths - NOTE: the max lengths allowed are those used
    //  in the registry reading code at startup. we will fail RPCs that attempt to
    //  set a length greater than that used during startup.
    //

    if( ( FeedInfo->ServerName ) &&
            (*FeedInfo->ServerName != L'\0') && wcslen(FeedInfo->ServerName)+1 > MAX_DOMAIN_NAME ) {
        parmErr = FEED_PARM_SERVERNAME;
        goto invalid_parm;
    }

    if( (IsUnicode && FeedInfo->cbNewsgroups > 1024*2) || (!IsUnicode && FeedInfo->cbNewsgroups > 1024) ) {
        parmErr = FEED_PARM_NEWSGROUPS;
        goto invalid_parm;
    }

    if( (IsUnicode && FeedInfo->cbDistribution > 1024*2) || (!IsUnicode && FeedInfo->cbDistribution > 1024) ) {
        parmErr = FEED_PARM_DISTRIBUTION;
        goto invalid_parm;
    }

    if( ( FeedInfo->UucpName ) &&
            (*FeedInfo->UucpName != L'\0') && wcslen((LPWSTR)FeedInfo->UucpName)+1 > 1024 ) {
        parmErr = FEED_PARM_UUCPNAME;
        goto invalid_parm;
    }

    if( ( FeedInfo->NntpAccountName ) &&
            (*FeedInfo->NntpAccountName != L'\0') && wcslen((LPWSTR)FeedInfo->NntpAccountName)+1 > 512 ) {
        parmErr = FEED_PARM_ACCOUNTNAME;
        goto invalid_parm;
    }

    if( ( FeedInfo->NntpPassword ) &&
            (*FeedInfo->NntpPassword != L'\0') && wcslen((LPWSTR)FeedInfo->NntpPassword)+1 > 512 ) {
        parmErr = FEED_PARM_PASSWORD;
        goto invalid_parm;
    }

    if( ( FeedInfo->FeedTempDirectory ) &&
            (*FeedInfo->FeedTempDirectory != L'\0') && wcslen((LPWSTR)FeedInfo->FeedTempDirectory)+1 > MAX_PATH ) {
        parmErr = FEED_PARM_TEMPDIR;
        goto invalid_parm;
    }

    //
    // make sure interval and start times are not both zeros
    //

    if ( !FEED_IS_PASSIVE(FeedInfo->FeedType) &&
         (FeedInfo->FeedInterval == 0) &&
         (liStart.QuadPart == 0) ) {

        parmErr = FEED_PARM_STARTTIME;
        goto invalid_parm;
    }

    /*  This goes away
    if( NO_ERROR != AllocateFeedId( pInstance, keyName, feedId ) ) {
        err = GetLastError() ;
        goto    exit ;
    }*/

    //
    // OK, now let's create the feed blocks
    //

    feedBlock = AllocateFeedBlock(
                        pInstance,
                        szKeyName,
                        TRUE,
                        (PCHAR)FeedInfo->ServerName,
                        FeedInfo->FeedType,
                        FeedInfo->AutoCreate,
                        &liStart,
                        &FeedInfo->PullRequestTime,
                        FeedInfo->FeedInterval,
                        (PCHAR)FeedInfo->Newsgroups,
                        FeedInfo->cbNewsgroups,
                        (PCHAR)FeedInfo->Distribution,
                        FeedInfo->cbDistribution,
                        IsUnicode,   // unicode strings
                        FeedInfo->Enabled,
                        (PCHAR)FeedInfo->UucpName,
                        (PCHAR)FeedInfo->FeedTempDirectory,
                        FeedInfo->MaxConnectAttempts,
                        FeedInfo->ConcurrentSessions,
                        FeedInfo->SessionSecurityType,
                        FeedInfo->AuthenticationSecurityType,
                        (PCHAR)FeedInfo->NntpAccountName,
                        (PCHAR)FeedInfo->NntpPassword,
                        FeedInfo->fAllowControlMessages,
                        FeedInfo->OutgoingPort,
                        FeedInfo->FeedPairId,
                        &parmErr
                        );

    if ( feedBlock == NULL ) {
        err = GetLastError() ;
        //DeleteFeedId( pInstance, szKeyName ) ;
        goto exit;
    }

    //
    // Add the feed into the registry -
    // UpdateFeedMetabaseValues will close 'key' in all circumstances !!
    //
    // KangYan: This operation is cancelled for the new feed admin, because
    //          admin should have already done the metabase part

    /*if( !UpdateFeedMetabaseValues( pInstance, feedBlock, FEED_ALL_PARAMS ) ) {

        //
        // Destroy the feed object
        //

        ErrorTrace(0,"Cannot add feed to registry.\n");
        CloseFeedBlock( pInstance, feedBlock );
        err = NERR_InternalError;
    }   else    { */

        LogFeedAdminEvent( NNTP_FEED_ADDED, feedBlock, pInstance->QueryInstanceId() ) ;

    //}

    // return the feed id allocated
    *pdwFeedId = feedId;

exit:

    LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    if( ParmErr != NULL ) {
        *ParmErr = parmErr ;
    }
    return err;

invalid_parm:

    LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    if ( ParmErr != NULL ) {
        *ParmErr = parmErr;
    }
    return(ERROR_INVALID_PARAMETER);

} // AddFeedToFeedBlock

DWORD
DeleteFeedFromFeedBlock(
    IN  NNTP_HANDLE ServerName,
    IN  DWORD       InstanceId,
    IN  DWORD FeedId
    )
{
    DWORD err = NERR_Success;
    PFEED_BLOCK feedBlock = NULL;
    CFeedList*  pList = 0 ;

    ENTER("NntprDeleteFeed");

    ACQUIRE_SERVICE_LOCK_SHARED();

    //
    //  Locate the instance object given id
    //

    PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
    if( pInstance == NULL ) {
        ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //
    //  KangYan:  This goes away
    //
    /*
    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }*/

    //
    // Check feed id
    //

    if ( FeedId == 0 ) {
        err = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    EnterCriticalSection( &pInstance->m_critFeedRPCs ) ;

    //
    // Look for the feed
    //

    pList = pInstance->m_pActiveFeeds ;
    feedBlock = pList->Search( FeedId ) ;
    if( feedBlock == NULL ) {
        pList = pInstance->m_pPassiveFeeds ;
        feedBlock = pList->Search( FeedId ) ;
    }

    if( feedBlock == NULL ) {

        LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ResourceNotFound);

    }   else    {

        //
        // *Lock still held*
        // Delete the registry
        //
        // KangYan: This operation is cancelled because the new feed admin
        //          should have already done that.

        /*if ( (err = DeleteFeedMetabase( pInstance, feedBlock )) == NO_ERROR ) {*/

            //
            // Delete the block
            //

            LogFeedAdminEvent( NNTP_FEED_DELETED, feedBlock, pInstance->QueryInstanceId() ) ;

            feedBlock->MarkedForDelete = TRUE;
            CloseFeedBlock( pInstance, feedBlock );
        //}

        // Search() should always be matched with FinishWith()
        pList->FinishWith( pInstance, feedBlock ) ;

        LeaveCriticalSection( &pInstance->m_critFeedRPCs ) ;
    }

exit:

    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
    LEAVE
    return(err);

} // DeleteFeedFromFeedBlock

DWORD
SetFeedInformationToFeedBlock(
    IN  NNTP_HANDLE ServerName,
    IN  DWORD       InstanceId,
    IN  LPI_FEED_INFO FeedInfo,
    OUT PDWORD ParmErr OPTIONAL
    )
{
    DWORD err = NERR_Success;
    //PLIST_ENTRY listEntry;
    //PCHAR bufStart;
    //PWCHAR bufEnd;
    PFEED_BLOCK feedBlock;
    DWORD parmErr = 0 ;
    ULARGE_INTEGER liStart;

    BOOL serverNamePresent;
    BOOL distPresent;
    BOOL newsPresent;
    BOOL uucpPresent = FALSE ;
    BOOL acctnamePresent = FALSE ;
    BOOL pswdPresent = FALSE ;
    BOOL tempdirPresent = FALSE ;
    BOOL IsUnicode = TRUE;

    DWORD feedMask = 0;
    PCHAR tempName = NULL;
    LPSTR* tempDist = NULL;
    LPSTR* tempNews = NULL;
    LPSTR*  tempUucp = 0 ;
    PCHAR   tempDir = 0 ;
    PCHAR   tempAccount = 0 ;
    PCHAR   tempPassword = 0 ;

    PFEED_BLOCK Update = 0 ;
    CFeedList*  pList = 0 ;

    ENTER("NntprSetFeedInformation")

    ACQUIRE_SERVICE_LOCK_SHARED();

    //
    //  Locate the instance object given id
    //

    PNNTP_SERVER_INSTANCE pInstance = FindIISInstance( g_pNntpSvc, InstanceId );
    if( pInstance == NULL ) {
        ErrorTrace(0,"Failed to get instance object for instance %d", InstanceId );
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // See if we are up and running
    //

    if ( !pInstance->m_FeedManagerRunning ) {
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return(NERR_ServerNotStarted);
    }

    //
    //  Check for proper access.
    //
    //  KangYan: This goes away
    //
    /*
    err = TsApiAccessCheckEx( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE, TCP_SET_ADMIN_INFORMATION );
    if( err != NO_ERROR ) {
        ErrorTrace(0,"Failed access check, error %lu\n",err );
        pInstance->Dereference();
        RELEASE_SERVICE_LOCK_SHARED();
        return (NET_API_STATUS)err;
    }*/

    err = ERROR_NOT_ENOUGH_MEMORY ;


    //
    // Check feed type
    //

    if ( FeedInfo->FeedType != FEED_FEEDTYPE_NOCHANGE && !ValidateFeedType(FeedInfo->FeedType) ) {
        parmErr = FEED_PARM_FEEDTYPE;
        goto invalid_parm;
    }

    //
    // Check feed interval
    //

    if ( FeedInfo->FeedType != FEED_FEEDINTERVAL_NOCHANGE && !FEED_IS_PASSIVE(FeedInfo->FeedType) && !FeedInfo->FeedInterval ) {
        parmErr = FEED_PARM_FEEDINTERVAL;
        goto invalid_parm;
    }

    LI_FROM_FILETIME( &liStart, &FeedInfo->StartTime );

    serverNamePresent = ((FeedInfo->ServerName != FEED_STRINGS_NOCHANGE) &&
                         (*FeedInfo->ServerName != L'\0'));

    newsPresent = VerifyMultiSzListW(
                        FeedInfo->Newsgroups,
                        FeedInfo->cbNewsgroups
                        );

    distPresent = VerifyMultiSzListW(
                        FeedInfo->Distribution,
                        FeedInfo->cbDistribution
                        );

    uucpPresent = ((FeedInfo->UucpName != FEED_STRINGS_NOCHANGE) &&
                   (*FeedInfo->UucpName != L'\0'));

    acctnamePresent = ((FeedInfo->NntpAccountName != FEED_STRINGS_NOCHANGE) &&
                   (*FeedInfo->NntpAccountName != L'\0'));

    pswdPresent = ((FeedInfo->NntpPassword != FEED_STRINGS_NOCHANGE) &&
                   (*FeedInfo->NntpPassword != L'\0'));

    tempdirPresent = ((FeedInfo->FeedTempDirectory != FEED_STRINGS_NOCHANGE) &&
                   (*FeedInfo->FeedTempDirectory != L'\0'));

    //
    //  validate all buffer lengths - NOTE: the max lengths allowed are those used
    //  in the registry reading code at startup. we will fail RPCs that attempt to
    //  set a length greater than that used during startup.
    //

    if( serverNamePresent ) {
        if( wcslen(FeedInfo->ServerName)+1 > MAX_DOMAIN_NAME ) {
            parmErr = FEED_PARM_SERVERNAME;
            goto invalid_parm;
        }
    }

    if( newsPresent ) {
        if( (IsUnicode && FeedInfo->cbNewsgroups > 1024*2) || (!IsUnicode && FeedInfo->cbNewsgroups > 1024) ) {
            parmErr = FEED_PARM_NEWSGROUPS;
            goto invalid_parm;
        }
    }

    if( distPresent ) {
        if( (IsUnicode && FeedInfo->cbDistribution > 1024*2) || (!IsUnicode && FeedInfo->cbDistribution > 1024) ) {
            parmErr = FEED_PARM_DISTRIBUTION;
            goto invalid_parm;
        }
    }

    if( uucpPresent ) {
        if( wcslen((LPWSTR)FeedInfo->UucpName)+1 > 1024 ) {
            parmErr = FEED_PARM_UUCPNAME;
            goto invalid_parm;
        }
    }

    if( acctnamePresent ) {
        if( wcslen((LPWSTR)FeedInfo->NntpAccountName)+1 > 512 ) {
            parmErr = FEED_PARM_ACCOUNTNAME;
            goto invalid_parm;
        }
    }

    if( pswdPresent ) {
        if( wcslen((LPWSTR)FeedInfo->NntpPassword)+1 > 512 ) {
            parmErr = FEED_PARM_PASSWORD;
            goto invalid_parm;
        }
    }

    if( tempdirPresent ) {
        if( wcslen((LPWSTR)FeedInfo->FeedTempDirectory)+1 > MAX_PATH ) {
            parmErr = FEED_PARM_TEMPDIR;
            goto invalid_parm;
        }
    }

    if( tempdirPresent ) {
        if( !CreateDirectoryW(  (LPWSTR)FeedInfo->FeedTempDirectory, NULL ) ) {
            if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                parmErr = FEED_PARM_TEMPDIR ;
                goto    invalid_parm ;
            }
        }
    }

    //
    // First, go find the feed block
    // NOTE: This prevents a user from changing a feed type from a passive
    // to an active one and vice versa
    //

    pList = pInstance->m_pActiveFeeds ;
    feedBlock = pList->Search( FeedInfo->FeedId ) ;
    if( feedBlock != NULL ) {
        goto    found ;
    }

    pList = pInstance->m_pPassiveFeeds ;
    feedBlock = pList->Search( FeedInfo->FeedId ) ;
    if( feedBlock != NULL ) {
        goto    found ;
    }

    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();
    return  NERR_ResourceNotFound ;

found:

    if( feedBlock->FeedType != FeedInfo->FeedType &&
        FeedInfo->FeedType != FEED_FEEDTYPE_NOCHANGE ) {
        parmErr = FEED_PARM_FEEDTYPE ;
        pList->FinishWith( pInstance, feedBlock ) ;
        goto    invalid_parm ;
    }

    pList->ExclusiveLock() ;

    Update = (PFEED_BLOCK)ALLOCATE_HEAP( sizeof( *feedBlock ) ) ;

    if( Update != 0 ) {
        *Update = *feedBlock ;
        //
        //  Copied the other guys reference count ! - dont want that
        //
        Update->ReferenceCount = 0 ;
    }   else    {
        goto    alloc_error ;
    }

    //
    // *Lock still held*
    //

    if ( serverNamePresent ) {

        feedMask |= FEED_PARM_SERVERNAME;
        tempName = (PCHAR)ALLOCATE_HEAP( 2 * (wcslen(FeedInfo->ServerName) + 1) );
        if ( tempName == NULL ) {
            goto alloc_error;
        }
        CopyUnicodeStringIntoAscii(tempName, FeedInfo->ServerName);
    }   else    {
        tempName = (PCHAR)ALLOCATE_HEAP( lstrlen( feedBlock->ServerName )+1 ) ;
        if( tempName == NULL ) {
            goto    alloc_error ;
        }
        lstrcpy( tempName, feedBlock->ServerName ) ;
    }


    if ( newsPresent ) {

        feedMask |= FEED_PARM_NEWSGROUPS;
        tempNews = AllocateMultiSzTable(
                                (PCHAR)FeedInfo->Newsgroups,
                                FeedInfo->cbNewsgroups,
                                TRUE    // unicode
                                );

        if ( tempNews == NULL ) {
            goto alloc_error;
        }
    }   else    {

        tempNews = AllocateMultiSzTable(
                                (PCHAR)feedBlock->Newsgroups[0],
                                MultiListSize( feedBlock->Newsgroups ),
                                FALSE
                                ) ;
        if( tempNews == NULL ) {
            goto    alloc_error ;
        }
    }

    if ( distPresent ) {

        feedMask |= FEED_PARM_DISTRIBUTION;
        tempDist = AllocateMultiSzTable(
                            (PCHAR)FeedInfo->Distribution,
                            FeedInfo->cbDistribution,
                            TRUE    // unicode
                            );

        if ( tempDist == NULL ) {
            goto alloc_error;
        }
    }   else    {

        tempDist = AllocateMultiSzTable(
                            (PCHAR)feedBlock->Distribution[0],
                            MultiListSize( feedBlock->Distribution ),
                            FALSE ) ;
        if( tempDist == NULL ) {
            goto    alloc_error ;
        }
    }

    if( uucpPresent )   {

        feedMask |= FEED_PARM_UUCPNAME ;

        tempUucp = MultiSzTableFromStrW( (LPWSTR)FeedInfo->UucpName ) ;
        if( tempUucp == 0 ) {
            goto    alloc_error ;
        }   else if( **tempUucp == '\0' ) {
            err = ERROR_INVALID_PARAMETER ;
            parmErr = FEED_PARM_UUCPNAME;
            goto    alloc_error ;
        }

    }   else    {

        if( feedBlock->UucpName != 0 ) {
            tempUucp = CopyMultiList( feedBlock->UucpName ) ;
            if( tempUucp == 0 ) {
                goto    alloc_error ;
            }
        }
    }

    if( tempdirPresent )    {

        feedMask |= FEED_PARM_TEMPDIR ;

        tempDir = (PCHAR)ALLOCATE_HEAP( 2 * (wcslen((LPWSTR)FeedInfo->FeedTempDirectory) + 1) );
        if ( tempDir == NULL ) {
            goto alloc_error;
        }
        CopyUnicodeStringIntoAscii(tempDir, (LPWSTR)FeedInfo->FeedTempDirectory);
    }   else    {

        if( feedBlock->FeedTempDirectory ) {
            tempDir = (PCHAR)ALLOCATE_HEAP( lstrlen( feedBlock->FeedTempDirectory)+1 ) ;
            if( tempDir == NULL ) {
                goto    alloc_error ;
            }
            lstrcpy( tempDir, feedBlock->FeedTempDirectory ) ;
        }
    }

    // auth type could change from clear text to none - if so ignore account / password fields
    if( (FeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_NONE ||
        FeedInfo->AuthenticationSecurityType == AUTH_PROTOCOL_CLEAR) &&
        FeedInfo->AuthenticationSecurityType != Update->AuthenticationSecurity)
    {
        Update->AuthenticationSecurity = FeedInfo->AuthenticationSecurityType ;
        feedMask |= FEED_PARM_AUTHTYPE ;

        if( Update->AuthenticationSecurity == AUTH_PROTOCOL_NONE )
        {
            acctnamePresent = FALSE;
            pswdPresent = FALSE;
        }
    }

    if( acctnamePresent )   {

        feedMask |= FEED_PARM_ACCOUNTNAME ;

        tempAccount = (PCHAR)ALLOCATE_HEAP( 2 * (wcslen((LPWSTR)FeedInfo->NntpAccountName) + 1) );
        if ( tempAccount == NULL ) {
            goto alloc_error;
        }
        CopyUnicodeStringIntoAscii(tempAccount, (LPWSTR)FeedInfo->NntpAccountName);
    }   else    {

        if( feedBlock->NntpAccount && (Update->AuthenticationSecurity != AUTH_PROTOCOL_NONE) ) {
            tempAccount = (PCHAR)ALLOCATE_HEAP( lstrlen( feedBlock->NntpAccount )+1 ) ;
            if( tempAccount == NULL ) {
                goto    alloc_error ;
            }
            lstrcpy( tempAccount, feedBlock->NntpAccount ) ;
        }
    }

    if( pswdPresent)    {

        feedMask |= FEED_PARM_PASSWORD ;

        tempPassword = (PCHAR)ALLOCATE_HEAP( 2 * (wcslen((LPWSTR)FeedInfo->NntpPassword) + 1) );
        if ( tempPassword == NULL ) {
            goto alloc_error;
        }
        CopyUnicodeStringIntoAscii(tempPassword, (LPWSTR)FeedInfo->NntpPassword);
    }   else    {

        if( feedBlock->NntpPassword && (Update->AuthenticationSecurity != AUTH_PROTOCOL_NONE) ) {
            tempPassword = (PCHAR)ALLOCATE_HEAP( lstrlen( feedBlock->NntpPassword )+1 ) ;
            if( tempPassword == NULL ) {
                goto    alloc_error ;
            }
            lstrcpy( tempPassword, feedBlock->NntpPassword ) ;
        }
    }


    if( tempName != NULL )
        Update->ServerName = tempName ;

    if( tempNews != NULL )
        Update->Newsgroups = tempNews ;

    if( tempDist != NULL )
        Update->Distribution = tempDist ;

    if( tempUucp != NULL )
        Update->UucpName = tempUucp ;

    if( tempDir != NULL )
        Update->FeedTempDirectory = tempDir ;

    //if( tempAccount != NULL )
        Update->NntpAccount = tempAccount ;

    //if( tempPassword != NULL )
        Update->NntpPassword = tempPassword ;

    //
    // change the fixed part
    //

    if ( FeedInfo->StartTime.dwHighDateTime != FEED_STARTTIME_NOCHANGE ) {
        feedMask |= FEED_PARM_STARTTIME;
        Update->StartTime.QuadPart = liStart.QuadPart;
    }

    if ( FeedInfo->PullRequestTime.dwHighDateTime != FEED_PULLTIME_NOCHANGE ) {
        feedMask |= FEED_PARM_PULLREQUESTTIME;
        Update->PullRequestTime = FeedInfo->PullRequestTime;
    }

    if ( FeedInfo->FeedInterval != FEED_FEEDINTERVAL_NOCHANGE ) {
        feedMask |= FEED_PARM_FEEDINTERVAL;
        Update->FeedIntervalMinutes = FeedInfo->FeedInterval;
    }

    if ( FeedInfo->AutoCreate != FEED_AUTOCREATE_NOCHANGE ) {
        feedMask |= FEED_PARM_AUTOCREATE;
        Update->AutoCreate = FeedInfo->AutoCreate;
    }

    if ( newsPresent ) {
        feedMask |= FEED_PARM_AUTOCREATE;
        Update->AutoCreate = TRUE;
    }


    {
        feedMask |= FEED_PARM_ALLOW_CONTROL;
        Update->fAllowControlMessages = FeedInfo->fAllowControlMessages;
    }

    if( FeedInfo->MaxConnectAttempts != FEED_MAXCONNECTS_NOCHANGE ) {
        feedMask |= FEED_PARM_MAXCONNECT;
        Update->MaxConnectAttempts = FeedInfo->MaxConnectAttempts;
    }

    {
        feedMask |= FEED_PARM_OUTGOING_PORT;
        Update->OutgoingPort = FeedInfo->OutgoingPort;
    }

    {
        feedMask |= FEED_PARM_FEEDPAIR_ID;
        Update->FeedPairId = FeedInfo->FeedPairId;
    }

    {
        feedMask |= FEED_PARM_ENABLED;
        Update->fEnabled = FeedInfo->Enabled;
    }

    //
    // Write changes to the registry
    //
    // KangYan: This operation is cancelled for new feed admin, because admin
    //          did the metabase update part

    //(VOID)UpdateFeedMetabaseValues( pInstance, Update, feedMask );

    pList->ApplyUpdate( feedBlock, Update ) ;

    LogFeedAdminEvent(  NNTP_FEED_MODIFIED, feedBlock, pInstance->QueryInstanceId() ) ;

    pList->ExclusiveUnlock();

    pList->FinishWith( pInstance, feedBlock ) ;
    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    return NERR_Success;

alloc_error:

    pList->ExclusiveUnlock() ;

    pList->FinishWith( pInstance, feedBlock ) ;
    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    if ( tempName != NULL ) {
        FREE_HEAP(tempName);
    }

    if ( tempDist != NULL ) {
        FREE_HEAP(tempDist);
    }

    if ( tempNews != NULL ) {
        FREE_HEAP(tempNews);
    }

    if( tempUucp != NULL ) {
        FREE_HEAP(tempUucp) ;
    }

    if( tempDir != NULL ) {
        FREE_HEAP( tempDir ) ;
    }

    if( tempAccount != NULL ) {
        FREE_HEAP( tempAccount ) ;
    }

    if( tempPassword != NULL ) {
        FREE_HEAP( tempPassword ) ;
    }

    if( Update != NULL ) {
        FREE_HEAP( Update ) ;
    }

    if ( ParmErr != NULL ) {
        *ParmErr = parmErr;
    }

    return(err);

invalid_parm:

    pInstance->Dereference();
    RELEASE_SERVICE_LOCK_SHARED();

    if ( ParmErr != NULL ) {
        *ParmErr = parmErr;
    }
    return(ERROR_INVALID_PARAMETER);

} // SetFeedInformationToFeedBlock

//
// look at the internal result code from a posting and use it to increment
// the appropriate recieved article counter in the feed block.
//
void IncrementFeedCounter(PFEED_BLOCK pFeedBlock, DWORD nrc) {
	if (pFeedBlock == NULL) {
		_ASSERT(FALSE);
		return;
	}

	switch (nrc) {
		case 0:
		case nrcOK:
		case nrcSTransferredOK:
		case nrcArticleTransferredOK:
		case nrcArticlePostedOK:
		case nrcPostOK:
		case nrcXReplicOK:
		case nrcIHaveOK:
			InterlockedIncrement(&(pFeedBlock->cSuccessfulArticles));
			break;
		// 4xx
		case nrcSTryAgainLater:
		case nrcTransferFailedTryAgain:
			InterlockedIncrement(&(pFeedBlock->cTryAgainLaterArticles));
			break;
		// 4xx
		case nrcSNotAccepting:
		case nrcSAlreadyHaveIt:
		case nrcSArticleRejected:
		case nrcPostingNotAllowed:
		case nrcNoSuchGroup:
		case nrcNoGroupSelected:
		case nrcNoCurArticle:
		case nrcNoNextArticle:
		case nrcNoPrevArticle:
		case nrcNoArticleNumber:
		case nrcNoSuchArticle:
		case nrcNotWanted:
		// 6xx
		case nrcArticleTooManyFieldOccurances:
		case nrcArticleMissingField:
		case nrcArticleBadField:
		case nrcArticleIncompleteHeader:
		case nrcArticleMissingHeader:
		case nrcArticleFieldZeroValues:
		case nrcArticleFieldMessIdNeedsBrack:
		case nrcArticleFieldMissingValue:
		case nrcArticleFieldIllegalNewsgroup:
		case nrcArticleTooManyFields:
		case nrcArticleFieldMessIdTooLong:
		case nrcArticleDupMessID:
		case nrcPathLoop:
		case nrcArticleBadFieldFollowChar:
		case nrcArticleBadChar:
		case nrcDuplicateComponents:
		case nrcArticleFieldIllegalComponent:
		case nrcArticleBadMessageID:
		case nrcArticleFieldBadChar:
		case nrcArticleFieldDateIllegalValue:
		case nrcArticleFieldDate4DigitYear:
		case nrcArticleFieldAddressBad:
		case nrcArticleNoSuchGroups:
		case nrcArticleDateTooOld:
		case nrcArticleTooLarge:
    	case nrcIllegalControlMessage:
    	case nrcBadNewsgroupNameLen:
    	case nrcNewsgroupDescriptionTooLong:
    	case nrcControlMessagesNotAllowed:
		case nrcHeaderTooLarge:
		case nrcServerEventCancelledPost:
		case nrcMsgIDInHistory:
		case nrcMsgIDInArticle:
		case nrcNoAccess:
		case nrcPostModeratedFailed:
		case nrcSystemHeaderPresent:
			InterlockedIncrement(&(pFeedBlock->cSoftErrorArticles));
			break;
		// 4xx
		case nrcTransferFailedGiveUp:
		case nrcPostFailed:
		// 6xx
		case nrcMemAllocationFailed:
		case nrcErrorReadingReg:
		case nrcArticleMappingFailed:
		case nrcArticleAddLineBadEnding:
		case nrcArticleInitFailed:
		case nrcNewsgroupInsertFailed:
		case nrcNewsgroupAddRefToFailed:
		case nrcHashSetArtNumSetFailed:
		case nrcHashSetXrefFailed:
		case nrcOpenFile:
		case nrcArticleXoverTooBig:
		case nrcCreateNovEntryFailed:
		case nrcArticleXrefBadHub:
		case nrcHashSetFailed:
		case nrcArticleTableCantDel:
		case nrcArticleTableError:
		case nrcArticleTableDup:
		case nrcCantAddToQueue:
		case nrcSlaveGroupMissing:
		case nrcInconsistentMasterIds:
		case nrcInconsistentXref:
    	case nrcNotYetImplemented:
    	case nrcControlNewsgroupMissing:
    	case nrcCreateNewsgroupFailed:
    	case nrcGetGroupFailed:
		case nrcNotSet:
		case nrcNotRecognized:
		case nrcSyntaxError:
		case nrcServerFault:
			InterlockedIncrement(&(pFeedBlock->cHardErrorArticles));
			break;
		default:
			_ASSERT(FALSE);
			InterlockedIncrement(&(pFeedBlock->cHardErrorArticles));
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\io.cpp ===
/*++

	io.cpp

	This file contains all the code which manages completion of IO operations.

	There is one class hierarchy which has several branches for all of the below objects :


				CChannel
					
					(This is an abstract base classes -
					A user can issue Read, Writes and Transmits against a
					CChannel and have a specified function called when they complete.

               /                 \                 \
              /                   \                  \
             /                     \                   \

		CHandleChannel		      CIODriver            CIOFileChannel

			Issues reads 		   Can Issue Reads&Writes      Issues Reads and Writes against Files
			and writes against	   Also insures single
			Handles				   thread completion



	The CHandleChannel class has two child classes, CFileChannel for File handles and CSocketChannel
	for sockets.  All of the CHandleChannel derived classes support Read() and Write() APIs for issueing
	async IO's.   CSocketChannel additionally supports Transmit() for issuing Transmit operations.
	Read(), WRite() and Transmit() will all take a CPacket derived class which contains all of the
	parameters of the IO, (ie, buffers, length of data, etc....)

	The CIODriver class als has two child classes.  The main function of CIODriver and child classes
	is to process completed IO requests.  Since all IO operations are represented by CPacket derived
	objects, CIODriver mostly manipulates queues of CPacket objects.
	The CIODriver class will place each completed packet on a queue, and call a completion function for
	that packet.  The CIODriver maintains a pointer to a 'Current CIO' object (object derived from CIO)
	which reflects the current high level IO we are doing (ie. CIOReadArticle - copy an article from
	a socket to a file).  The interface between CIODriver and CIO objects allows the CIO object
	to 'block' and 'unblock' the driver, complete only portions of buffers etc...
	(ie.  When a client connects and sends multiple commands, CIOReadLine will 'block' the CIODriver
	queue after it has parsed one line of text (one command) by setting the CIODriver's current CIO
	pointer to NULL.  This allows whoever is parsing commands to operate irregardless of how many
	commands are sent in one packet.)
	There are two forms of CIODriver's - CIODriverSource and CIODriverSink.
	CIODriverSource's support all of the REad(), Write(), etc... API's that a CChannel does.
	Essentially, a CIODriverSource can be used to massage each packet before it reaches a really
	socket handle. (We use it to do encryption.)
	CIODriverSink objects do not support Read(), Write() etc... and can only be used as a Sink for data.

	Finally CIOFileChannel is similar to CFileChannel (which is derived from CHandleChannel) except
	that it supports both Read()s and Write()s simultaneously.

	CIODriver's are always used in conjunction with another CChannel derived object.
	Generally, a CIODriver is used with either a CSocketChannel or CIOFileChannel.  The CIODriver
	will contain a pointer to its paired CChannel.  All calls to IssuePacket() etc... will eventually
	map to a call to the other CChannel's Read(), Write(), Transmit() interface.
	The other CChannel will be set up to call the owning CIODriver's completion function when
	packets complete.
	When doing encryption, there will be 2 CIODriver's and one CChannel associated -
	There will be a CSocketChannel over which packets are sent, a CIODriverSource which will
	massage the data in the packets and a CIODriverSink which will operate the regular NNTP state
	machines.
	This means that all CIO and CSessionState derived classes can largely ignore encryption issues,
	as the date will be transparently encrypted/decrypted for them.

	Internally, CIODriver's use CStream objects to manage the completion of packets.
	A large portion of the CIODriver interface is inline functions which route to the proper CStream.
	(A CStream exists for each direction of data flow - ie. outgoing (CWritePacket & CTransmitPacket)
	and incoming (CReadPacket))

--*/

#include    "tigris.hxx"

#ifdef  CIO_DEBUG
#include    <stdlib.h>      // For Rand() function
#endif


extern	class	TSVC_INFO*	g_pTsvcInfo ;

//
//	All CChannel derived objects have the following sting stamped in them for debug purposes ....
//
//

#ifdef	CIO_DEBUG
//
//	These variables are never used.
//	They're only declared so that people using decent debuggers can more easily
//	examine arbitrary objects !
//
class	CIODriverSink*		pSinkDebug = 0 ;
class	CIODriverSource*	pSourceDebug = 0 ;
class	CChannel*			pChannelDebug = 0 ;
class	CReadPacket*		pReadDebug = 0 ;
class	CWritePacket*		pWriteDebug = 0 ;
class	CHandleChannel*		pHandleDebug = 0 ;
class	CSocketChannel*		pSocketDebug = 0 ;
class	CFileChannel*		pFileDebug = 0 ;
class	CIOFileChannel*		pIOFileDebug = 0 ;
class	CIO*				pIODebug = 0 ;
class	CIOReadLine*		pReadLineDebug = 0 ;
class	CIOReadArticle*		pReadArticleDebug = 0 ;
class	CIOWriteLine*		pWriteLineDebug = 0 ;
class	CSessionState*		pStateDebug = 0 ;
#endif

const	unsigned	cbMAX_CHANNEL_SIZE	= MAX_CHANNEL_SIZE ;

CPool	CChannel::gChannelPool(CHANNEL_SIGNATURE) ;


BOOL
CChannel::InitClass() {
/*++

Routine Description :

	Initialize the CChannel class - handles all initialization issues for CChannel
	and all derived classes.
	The only thing to do is ReserveMemory in our CPool

Arguments :

	None.

Return Value :

	True if Succesfull, FALSE Otherwise

--*/

#ifdef	CIO_DEBUG
	srand( 10 ) ;
#endif

	return	gChannelPool.ReserveMemory(	MAX_CHANNELS, cbMAX_CHANNEL_SIZE ) ;
}

BOOL
CChannel::TermClass() {
/*++

Routine Description :

	The twin of CChannel::TermClass() - call when all sessions are Dead !

Arguments :

	None.

Return Value :

	True if Succesfull, FALSE Otherwise

--*/

	_ASSERT( gChannelPool.GetAllocCount() == 0 ) ;
	return	gChannelPool.ReleaseMemory() ;
}


//
//
//	The following functions should be overridden by classes derived from CChannel
//
//

BOOL
CChannel::FSupportConnections( ) {
	ChannelValidate() ;

    return  TRUE ;
}

BOOL
CChannel::FRequiresBuffers()    {
	ChannelValidate() ;

    return  TRUE ;
}

BOOL
CChannel::FReadChannel()    {
	ChannelValidate() ;

    return  TRUE ;
}

void
CChannel::GetPaddingValues( unsigned    &cbFront,
							unsigned    &cbTail )   {
	ChannelValidate() ;

    cbFront = 0 ;
    cbTail = 0 ;
}

void
CChannel::CloseSource(	
				CSessionSocket*	pSocket
				) {

	ChannelValidate() ;
	
	_ASSERT(1==0 ) ;
}

void
CChannel::Timeout()	{
}

void
CChannel::ResumeTimeouts()	{
}

#ifdef	CIO_DEBUG
void	CChannel::SetDebug( DWORD	dw ) {
}
#endif

CChannel::~CChannel()   {

	TraceFunctEnter( "CChannel::~CChannel" ) ;
	DebugTrace( (DWORD_PTR)this, "Destroying CChannel" ) ;

	ChannelValidate() ;
}

#define	OwnerValidate()
#define	DriverValidate( driver )


//
//	shutdownState is a special object we use when terminating CIODriver objects.
//	It exists to swallow any outstanding IO's that may be lying around when
//	a CIODriver is destroyed.
//
//

CIOShutdown	CIODriver::shutdownState ;

CStream::CStream(    unsigned    index   ) :
/*++

Routine Description :

	Construct a CStream object.
	Set everything up to a NULL state.

Arguments :

	An index - usually these things are declared as arrays within a CIODriver
	the index is our position in this array.

Return Value :
	
	None.

--*/


	//
	//	Initialize a CStream object.
	//	Two CStream objects exist in each CIODriver object,
	//	one for each direction (outgoing packets - CWritePacket, CTransmitPacket,
	//	and incomint packets CReadPacket )
	//
    m_pSourceChannel( 0 ),			// The CChannel object
	/* m_pIOCurrent( 0 ), */
	m_index( index ),
    m_age( GetTickCount() ),
	m_fRead( FALSE ),
    m_cbFrontReserve( UINT_MAX ),
	m_cbTailReserve( UINT_MAX ),
	m_pOwner( 0 ),
	m_pSpecialPacket( 0 ),
	m_pSpecialPacketInUse( 0 ),
	m_fCreateReadBuffers( TRUE ),
	m_pUnsafePacket( 0 ),
	m_pUnsafeInuse( 0 ),
	m_cShutdowns( 0 ),
	m_fTerminating( FALSE )
#ifdef  CIO_DEBUG
		//
		//	The following are all used in debug asserts - generally to insure
		//	that onlly the expected number of threads are simultaneously executing
		//
        ,m_dwThreadOwner( 0 ),
		m_cThreads( 0 ),
		m_cSequenceThreads( 0 ),
		m_cThreadsSpecial( 0 ),
        m_cNumberSends( 0 )
#endif
{
		TraceFunctEnter( "CStream::CStream" ) ;

		ASSIGNI( m_sequencenoOut, UINT_MAX );
		ASSIGNI( m_iStreamIn, UINT_MAX );
		ASSIGNI( m_sequencenoIn, UINT_MAX );

		DebugTrace( (DWORD_PTR)this, "New CStream size %d index %d", sizeof( *this ), index ) ;
}

CStream::~CStream(   )   {
/*++

Routine Description :

	Destroy a CStream object.

Arguments :

	None.

Return Value :

	None.


--*/

	//
	//	We zap all of our members to illegal values
	//	Hopefully this will help fire _ASSERTs if somebody attempts to
	//	use this after its destroyed.
	//
	//

	TraceFunctEnter( "CStream::~CStream" ) ;
	DebugTrace( (DWORD_PTR)this, "destroying CIODriver" ) ;

    m_pSourceChannel = 0 ;
    /*m_pIOCurrent = 0 ;*/
    ASSIGNI( m_sequencenoOut, UINT_MAX );
    m_age = 0 ;
    ASSIGNI( m_iStreamIn, UINT_MAX );
    ASSIGNI( m_sequencenoIn, UINT_MAX );
    m_fRead = FALSE ;
    m_cbFrontReserve = UINT_MAX ;
    m_cbTailReserve = UINT_MAX ;
    m_pOwner = 0 ;
    m_pSpecialPacket = 0 ;
	m_pSpecialPacketInUse = 0 ;
	m_pUnsafePacket = 0 ;
	m_pUnsafeInuse = 0 ;
	m_cShutdowns = 0 ;
#ifdef  CIO_DEBUG
    m_dwThreadOwner = 0 ;
    m_cThreads = 0 ;
    m_cSequenceThreads = 0 ;
    m_cThreadsSpecial = 0 ;
    m_cNumberSends = 0 ;
#endif

}

CIOStream::CIOStream( CIODriverSource*	pdriver,
								/*CSessionSocket*	pSocket,*/
								unsigned   cid ) :
/*++

Routine Description :

	Initialize a CIOStream object.  Most work is done by our base class
	CStream.

Arguments :

	pdriver - the CIODriverSource we are contained within
	cid -		An index to an array we are within.


Return Value :

	None.

--*/
	//
	//	A CIOStream supports request packets as well completions.
	//	(ie. it is used in CIODriverSource objects.)
	//	Very similar to CStream objects, so let CStream::CStream do the
	//	brunt of the work.
	//
	//

	CStream( cid ),
	m_fAcceptRequests( FALSE ),
	m_fRequireRequests( FALSE ),
	/*( pSocket ),*/ m_pDriver( pdriver ) {

    ASSIGNI(m_sequencenoNext, 1 );
}

CIOStream::~CIOStream( ) {
/*++

Routine Description :

	Destory a CIOStream object.
	Most work done in base class.

Arguments :

	None.

Return Value :

	None.

--*/

	TraceFunctEnter( "CIOStream::~CIOStream" ) ;
	DebugTrace( (DWORD_PTR)this, "destroying CIODriver" ) ;
}


BOOL
CIOStream::Init(   CCHANNELPTR&    pChannel,
							CIODriver&  driver,
							CIOPassThru*    pInitial,
							BOOL fRead,
							CIOPassThru&	pIOReads,
							CIOPassThru&	pIOWrites,
							CIOPassThru&	pIOTransmits,
							CSessionSocket* pSocket,
							unsigned    cbOffset )  {

	if( CStream::Init( pChannel,
				driver,
				fRead,
				pSocket,
				cbOffset ) ) {

		m_pIOCurrent = pInitial ;

		m_fAcceptRequests = TRUE ;

		m_pIOFilter[0] = &pIOReads ;
		m_pIOFilter[1] = &pIOWrites ;
		m_pIOFilter[2] = &pIOTransmits ;

		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIStream::Init(   CCHANNELPTR&    pChannel,
							CIODriver&  driver,
							CIO*    pInitial,
							BOOL fRead,
							CSessionSocket* pSocket,
							unsigned    cbOffset,
							unsigned	cbTrailer )  {


	if( CStream::Init( pChannel,
				driver,
				fRead,
				pSocket,
				cbOffset,
				cbTrailer ) ) {

		m_pIOCurrent = pInitial ;

		return	TRUE ;

	}
	return	FALSE ;
}


BOOL
CStream::Init(   CCHANNELPTR&    pChannel,
							CIODriver&  driver,
							/* CIO*    pInitial, */
							BOOL fRead,
							CSessionSocket* pSocket,
							unsigned    cbOffset,
							unsigned	cbTrailer
							)  {
/*++

Routine Description :

	Initialize a CStream object.
	We set all of our member variables to legal values.

Arguemtns :

	pChannel - The CChannel we will be calling to do actual Read()'s and Write()'s
	pdriver -	The CIODriver we are contained within
	pInitial -	The Initial CIO object which will issue the first IO's
	fRead -		if TRUE this is a read Stream, if FALSE this is an outgoing (Write) stream
	pSocket-	The socket we are associated with
	cbOffset -	The offset at which we are to have data placed in all packets we complete

Return Value :

	TRUE if successfull, FALSE otherwise

--*/

	//
	//	We need to allocate a few special packets
	//	and then set things to legal values.
	//

    BOOL    fRtn = TRUE ;

    #ifdef  CIO_DEBUG
    m_cThreadsSpecial = -1 ;
    m_cNumberSends = -1 ;
    m_dwThreadOwner = 0 ;
    m_cThreads = -1 ;
    m_cSequenceThreads = -1 ;
    #endif

    //  Validate Arguements
    _ASSERT( pChannel != 0 ) ;
    _ASSERT( pSocket != 0 ) ;

    //  Validate State
    _ASSERT( m_fRead == FALSE ) ;
    _ASSERT( !m_pSourceChannel ) ;
/*    _ASSERT( m_pIOCurrent == 0 ) ;*/
    _ASSERT( EQUALSI( m_sequencenoOut, UINT_MAX ) );
    _ASSERT( EQUALSI( m_sequencenoIn, UINT_MAX )  );
    _ASSERT( EQUALSI( m_iStreamIn, UINT_MAX ) );
    #ifdef  CIO_DEBUG
    _ASSERT( m_dwThreadOwner == 0 ) ;
    _ASSERT( InterlockedIncrement( &m_cThreads ) == 0 ) ;
    #endif

    m_pOwner = &driver ;
    ASSIGNI( m_sequencenoOut, 1 );
    ASSIGNI( m_sequencenoIn, 1 );
    ASSIGNI( m_iStreamIn, 0 );
    m_pSourceChannel = pChannel ;
    pChannel->GetPaddingValues( m_cbFrontReserve, m_cbTailReserve ) ;
    m_cbFrontReserve = max( m_cbFrontReserve, cbOffset ) ;
	m_cbTailReserve = max( m_cbTailReserve, cbTrailer ) ;
    m_fRead = fRead ;
/*    m_pIOCurrent = pInitial ;*/

    m_pSpecialPacket =	new	CControlPacket( driver ) ;
	m_pUnsafePacket =	new	CControlPacket( driver ) ;
	m_cShutdowns = -1 ;
	m_fTerminating = FALSE ;

    if( m_pSpecialPacket == 0 || m_pUnsafePacket == 0 )    {
        fRtn = FALSE ;
    }

    _ASSERT( m_pOwner != 0 ) ;
    _ASSERT( !EQUALSI( m_sequencenoOut, 0 ) );
    _ASSERT( !EQUALSI( m_sequencenoIn, 0 ) );

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedDecrement( &m_cThreads ) < 0 ) ;
    #endif

	OwnerValidate() ;

    return  fRtn ;
}

BOOL
CStream::IsValid( ) {
/*++

Routine Description :

	For debug use - determine whether a CStream is in a valid state.
	Call this after calling Init().

Arguments :

	None.

Return Value :

	TRUE if in valid state, FALSE otherwise

--*/

	//
	//	Check whether member variables are internally consistent
	//


	OwnerValidate() ;

    if( m_pSourceChannel == 0 ) {
        _ASSERT( 1==0 ) ;
        return  FALSE ;
    }
#ifdef  CIO_DEBUG
    if( m_dwThreadOwner != GetCurrentThreadId() ) {
        _ASSERT( 1==0 ) ;
        return  FALSE ;
    }
#endif
    if( !m_pOwner->FIsStream( this ) )  {
        return  FALSE ;
    }
    if( GREATER( m_sequencenoIn, m_sequencenoOut ) ) {
        _ASSERT( 1==0 ) ;
        return  FALSE ;
    }
    if( m_cbFrontReserve == UINT_MAX ) {
        return  FALSE ;
    }
    if( m_cbTailReserve == UINT_MAX )   {
        return  FALSE ;
    }
    return  TRUE ;
}

BOOL
CIOStream::IsValid() {
/*++

Routine Description :

	For debug use - determine whether a CIOStream is in a valid state.
	Call this after calling Init().

Arguments :

	None.

Return Value :

	TRUE if in valid state, FALSE otherwise

--*/

	//
	//	Check whether member variables are internally consistent
	//	(for use in _ASSERTs etc...)
	//
    if( !CStream::IsValid() ) {
        return  FALSE ;
    }
    return  TRUE ;
}

void	CIODriver::SourceNotify(	CIODriver*	pdriver,	
									SHUTDOWN_CAUSE	cause,	
									DWORD	dwOpt ) {

	//
	//	This is a place holder function for now - needs more work later.
	//

	//_ASSERT( 1==0 ) ;

}

void
CStream::InsertSource(	CIODriverSource&	source,	
									CSessionSocket*	pSocket,
									unsigned	cbAdditional,
									unsigned	cbTrailer
									) {
/*++

Routine Description :

	This function exists to change the m_pSourceChannel of this CStream.
	We would want to do so if we negogtiate encryption over this CChannel and wish
	to insert a CIODriverSource with state machine to handle encryption/decryption.

Arguments :

	source -	The CIODriverSource which is to replace m_pSourceChannel
	pSocket -	The CSessionSocket we are associated with.
	cbAdditional	-	Additional bytes to reserve in packets

Return Value :

	None.

--*/
	
	//
	//	This function is used in SSL logons etc.... Once
	//	challenge responses are completed we can be used to
	//	place a CIODriverSource between this CIODriver and
	//	a CChannel for encryption purposes.
	//	

	// We are called while completing a packet - so it can be the case that
	// there is one ounstanding packet !!
#ifdef DEBUG
	SEQUENCENO seqTemp; ASSIGN( seqTemp, m_sequencenoOut ); ADDI( seqTemp, 1 );
#endif
	_ASSERT( !GREATER( m_sequencenoOut, seqTemp ) && (!LESSER( m_sequencenoOut, m_sequencenoIn )) ) ;

	//source.GetPaddingValues( m_cbFrontReserve, m_cbTailReserve ) ; 	
	m_cbFrontReserve += cbAdditional ;
	m_cbTailReserve += cbTrailer ;	
	m_pSourceChannel = &source ;
}


#ifdef	CIO_DEBUG
LONG
CIODriver::AddRef()	{

	//
	//	This function exists only for the tracing.
	//

	TraceFunctEnter( "CIODriver::AddRef" ) ;

	LONG	lReturn = CRefCount::AddRef() ;

	DebugTrace( (DWORD_PTR)this, "Added a ref - count is now %d lReturn %d", m_refs, lReturn ) ;

	return	lReturn ;
}

LONG
CIODriver::RemoveRef()	{

	//
	//	This function exists only for the tracing.
	//	otherwise we'd let RemoveRef() be called directly.
	//

	TraceFunctEnter( "CIODriver::RemoveRef" ) ;
	
	LONG	lReturn = CRefCount::RemoveRef() ;

	DebugTrace( (DWORD_PTR)this, "Removed a ref - count is now %d lReturn %d", m_refs, lReturn ) ;

	return	lReturn ;
}
#endif

BOOL
CIODriver::InsertSource(	CIODriverSource&	source,
							CSessionSocket*	pSocket,
							unsigned	cbReadOffset,
							unsigned	cbWriteOffset,
							unsigned	cbReadTailReserve,
							unsigned	cbWriteTailReserve,
							CIOPassThru&	pIOReads,
							CIOPassThru&	pIOWrites,
							CIOPassThru&	pIOTransmits,
							CIOPASSPTR&	pRead,
							CIOPASSPTR&	pWrite ) {
/*++

Routine Description :

	This function exists to change the m_pSourceChannel of the two CStream objects.
	We would want to do so if we negogtiate encryption over this CChannel and wish
	to insert a CIODriverSource with state machine to handle encryption/decryption.

Arguments :

	source -	The CIODriverSource which is to replace m_pSourceChannel
	pSocket -	The CSessionSocket we are associated with.
	cbReadOffset -	Reserve cbReadOffset in the front of packets from now on
	cbWriteOffset - Reserve cbWriteOffset bytes in the front of packets.
	pRead -		The CIOPassThru which starts reading on the CIODriverSource machine
	pWrite -	The CIOPassThru for handling writes

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/


	//
	//	This function is used in SSL logons etc.... Once
	//	challenge responses are completed we can be used to
	//	place a CIODriverSource between this CIODriver and
	//	a CChannel for encryption purposes.
	//	

	BOOL	fRtn = TRUE ;	// We're optimists !
	#ifdef	CIO_DEBUG
	_ASSERT( InterlockedIncrement( &m_cConcurrent ) == 0 ) ;
	#endif

	if( source.Init(	&m_pReadStream->GetChannel(),
						pSocket,
						(PFNSHUTDOWN)SourceNotify,
						this,
						this,
						pIOReads,
						pIOWrites,
						pIOTransmits,
						m_pReadStream->GetFrontReserve(),
						m_pWriteStream->GetFrontReserve() ) ) {

		if( source.Start( pRead, pWrite, pSocket ) )	{

			m_pReadStream->InsertSource( source, pSocket, cbReadOffset, cbReadTailReserve ) ;
			m_pWriteStream->InsertSource( source, pSocket, cbWriteOffset, cbWriteTailReserve ) ;

		}	else	{
			fRtn = FALSE ;
		}
	}
	#ifdef	CIO_DEBUG
	_ASSERT( InterlockedDecrement( &m_cConcurrent ) < 0 ) ;
	#endif
	return	fRtn ;
}



CIODriver::FIsStream(   CStream*    pStream )   {

	//
	//	This function is for debugging use - it checks
	//	that the given CStream object is actually a member
	//	variable of a given CIODriver.
	//

	ChannelValidate() ;

    if( pStream != m_pReadStream && pStream != m_pWriteStream )
        return  FALSE ;
    else
        return  TRUE ;
}

BOOL
CStream::Stop(   )   {
	
	//
	//	Placeholder function.
	//

	OwnerValidate() ;

    return  FALSE ;
}

void
CIStream::SetShutdownState(	CSessionSocket*	pSocket,
										BOOL fCloseSource )	{
/*++

Routine Description :

	Terminate the CStream.   We notify the current CIO object
	of its impending doom, and let it tell us whether it wants to be deleted.
	Then we set m_pIOCurrent to point to a CIO object which will swallow
	all remaining packets.

Arguments :

	pSocket - The socket we are associated with
	fCloseSOurce - TRUE means we should call CloseSource() on our m_pSourceChannel object.

Return Value :

	None.


--*/
	
	//
	//	This function does all the work necessary to start a CIODriver
	//	object on the road to destruction.
	//	After this is executed, the CIODriver will be destroyed when
	//	the last reference is removed (ie. last CPacket completes)
	//

	CIODriver&	Owner = *m_pOwner ;

	TraceFunctEnter( "CStream::SetShutdownState" ) ;

	_ASSERT( pSocket != 0 ) ;
	OwnerValidate() ;

	// Notify the current IO operation that we're going down !!!!!
	if( m_pIOCurrent != 0 )		{
		m_pIOCurrent->DoShutdown(	pSocket,
									Owner,
									Owner.m_cause,
									Owner.m_dwOptionalErrorCode ) ;
	}


	// Remove our reference to our owner !!
	m_pOwner = 0 ;
	// The Reference to our source channel is removed when we destroy ourselves !!
	// Set the state to the shutdown state !!

	if( fCloseSource )
		m_pSourceChannel->CloseSource( pSocket ) ;

	CIO*	pTemp = m_pIOCurrent.Replace( &CIODriver::shutdownState ) ;
	if( pTemp ) {
		CIO::Destroy( pTemp, Owner ) ;
	}
}

void
CIOStream::SetShutdownState(	CSessionSocket*	pSocket,
										BOOL fCloseSource )	{
/*++

Routine Description :

	Terminate the CStream.   We notify the current CIO object
	of its impending doom, and let it tell us whether it wants to be deleted.
	Then we set m_pIOCurrent to point to a CIO object which will swallow
	all remaining packets.

Arguments :

	pSocket - The socket we are associated with
	fCloseSOurce - TRUE means we should call CloseSource() on our m_pSourceChannel object.

Return Value :

	None.


--*/
	
	//
	//	This function does all the work necessary to start a CIODriver
	//	object on the road to destruction.
	//	After this is executed, the CIODriver will be destroyed when
	//	the last reference is removed (ie. last CPacket completes)
	//

	TraceFunctEnter( "CStream::SetShutdownState" ) ;

	_ASSERT( pSocket != 0 ) ;
	OwnerValidate() ;

	// Notify the current IO operation that we're going down !!!!!
	if( m_pIOCurrent != 0 )		{
		m_pIOCurrent->DoShutdown(	pSocket,
									*m_pOwner,
									m_pOwner->m_cause,
									m_pOwner->m_dwOptionalErrorCode ) ;
	}

	// Remove our reference to our owner !!
	m_pOwner = 0 ;
	// The Reference to our source channel is removed when we destroy ourselves !!
	// Set the state to the shutdown state !!

	if( fCloseSource )
		m_pSourceChannel->CloseSource(	pSocket ) ;

	m_pIOCurrent = &CIODriver::shutdownState ;

	m_pIOFilter[0] = &CIODriver::shutdownState ;
	m_pIOFilter[1] = &CIODriver::shutdownState ;
	m_pIOFilter[2] = &CIODriver::shutdownState ;

}


CIStream::CIStream(  unsigned    index ) :
	//
	//	Let base class do work.
	//

	CStream( index ){
}

CIStream::~CIStream( )   {

	//
	//	Let base class do work. We get some usefull tracing here.
	//

	TraceFunctEnter( "CIStream::~CIStream" ) ;
	DebugTrace( (DWORD_PTR)this, "Destroying CIStream" ) ;

}

void
CStream::CleanupSpecialPackets()	{

	CControlPacket*	pPacketTmp = 0 ;

	pPacketTmp = (CControlPacket*)InterlockedExchangePointer( (void**)&m_pUnsafePacket, 0 ) ;
	if( pPacketTmp )	{
		//delete	pPacketTmp ;
		CPacket::DestroyAndDelete( pPacketTmp ) ;
	}
	pPacketTmp = (CControlPacket*)InterlockedExchangePointer( (void**)&m_pSpecialPacket, 0 ) ;
	if( pPacketTmp ) {
		//delete	pPacketTmp ;
		CPacket::DestroyAndDelete( pPacketTmp ) ;
	}
}



void
CIOStream::ProcessPacket(    CPacket*    pPacketCompleted,
                            CSessionSocket* pSocket )   {
/*++

Routine Description :

	All packets which complete must be processed with a call to this function.
	We will handle all the work related to completing a packet.

Arguments :

	pPacketCompleted - the packet that completed.
	pSocket -	The CSessionSocket on which the packet was sent.

Return Value :

	None.

--*/


	TraceFunctEnter( "CIOStream::ProcessPacket" ) ;

	OwnerValidate() ;

	//
	//	Tjos function is the core of CIODriverSource processing.
	//	Each packet that completes is placed on the m_pending Queue.
	//	If no other thread is processing on that queue, we will continue
	//	past the Append().  (And be safe in the knowledge that no other
	//	thread will join us.)
	//	Once we are past the Append() we need to determine whether the
	//	packet we got is the next one we want to process.  To do that
	//	we use a Queue ordered by sequence number.
	//	(All packets are stamped with a sequence number when issued.)
	//
	//	We get two types of packets - requests and completions.
	//	These both need to be processed in sequenceno order.
	//	
	//	There are a couple of special packets which may come our way
	//	which indicate we should do a special operation immediately and
	//	ignore completion order. (ie. Shutdown.)
	//


	CDRIVERPTR	pExtraRef = 0 ;
    CIOPassThru*   pIO = 0 ;

#ifdef	CIO_DEBUG
	if( pPacketCompleted->ControlPointer() == 0 )
		m_pSourceChannel->ReportPacket( pPacketCompleted ) ;
#endif

    //
    //  This is either a read stream, or a write stream.
    //  Read streams accept only CReadPackets, Write Streams accept
    //  CWritePackets and CTransmitPackets
    //
    //_ASSERT( pPacketCompleted->FLegal( m_fRead ) ) ;

    //
    //  We will append a completed packet to the pending Queue.  If this is
    //  the first packet to be appended, then Append will return TRUE.
    //
    if( m_pending.Append( pPacketCompleted ) )  {
        //
        // We will use listForward to Queue up packets which complete so that
        // we can call the other channels AFTER we no longer have the m_pending queue
        // locked.  We do this so that processing within the following channel can
        // overlap with completions occurring in here.
        // (We could alternatively : call immediately, or Post to a completion port.)
        //
        CPACKETLIST listForward ;
        _ASSERT( listForward.IsEmpty() ) ;

		// The owner should not be NULL unless we are terminating.
		_ASSERT( m_pOwner != 0 || m_fTerminating ) ;

        DebugTrace( (DWORD_PTR) this, "Appended Packet ", this ) ;

        CPacket*    pPacket ;
        while( (pPacket = m_pending.RemoveAndRelease( )) != 0 )   {

			DebugTrace( (DWORD_PTR)this, "Got Packet %x sequenceno %d", pPacket, (DWORD)LOW(pPacket->m_sequenceno) ) ;

			if( m_fTerminating )
				pExtraRef = pPacket->m_pOwner ;

            #ifdef  CIO_DEBUG
            m_dwThreadOwner = GetCurrentThreadId() ;
            _ASSERT( InterlockedIncrement( &m_cThreads ) == 0 ) ;
            #endif  //  CIO_DEBUG

			ControlInfo	control ;
			_ASSERT( control.m_type == ILLEGAL ) ;
			_ASSERT( control.m_pioPassThru == 0 ) ;
			_ASSERT( control.m_fStart == FALSE ) ;

            if( pPacket == m_pSpecialPacketInUse )   {
                //
                // This packet includes an IO* pointer !!
                //
 				_ASSERT( !pPacket->m_fRequest ) ;
                _ASSERT( pPacket->ControlPointer() ) ;
                _ASSERT( pPacket->IsValidRequest( m_fRead ) ) ;
                DebugTrace( (DWORD_PTR)this, "Processing Special Packet - CIStream %x", this ) ;

				control = m_pSpecialPacketInUse->m_control ;
				m_pSpecialPacketInUse->Reset() ;
				//
				//	Return The Packet so it can be used again !
				//
				m_pSpecialPacketInUse = 0 ;
				if( m_fTerminating )	{
					//delete	pPacket ;
					pPacket->m_pOwner->DestroyPacket( pPacket ) ;
					pPacket = 0 ;
				}	else
					m_pSpecialPacket = (CControlPacket*)pPacket ;
				#ifdef	CIO_DEBUG
				_ASSERT( InterlockedDecrement( &m_cNumberSends ) < 0 ) ;
				#endif
			}	else	if( pPacket == m_pUnsafeInuse ) {
 				_ASSERT( !pPacket->m_fRequest ) ;
                _ASSERT( pPacket->ControlPointer() ) ;
                _ASSERT( pPacket->IsValidRequest( m_fRead ) ) ;
				_ASSERT( m_pUnsafeInuse->m_control.m_type == SHUTDOWN ) ;
				DebugTrace( (DWORD_PTR)this, "Processing UnSafeInUse packet - %x", m_pUnsafeInuse ) ;
				control = m_pUnsafeInuse->m_control ;
				m_pUnsafeInuse->Reset() ;
				m_pUnsafeInuse = 0 ;
				//delete	pPacket ;
				pPacket->m_pOwner->DestroyPacket( pPacket ) ;
				pPacket = 0 ;
			}	else	{
				if( pPacket->m_fRequest ) {
					m_pendingRequests.Append( pPacket ) ;
				}	else	{
	                m_completePackets.Append( pPacket ) ;
				}
			}
			CControlPacket*	pPacketTmp = 0 ;
			if( control.m_type != ILLEGAL ) {

				if( control.m_type == SHUTDOWN ) {
					m_fTerminating = TRUE ;
					pExtraRef = m_pOwner ;

					CleanupSpecialPackets() ;

					SetShutdownState( pSocket, control.m_fCloseSource ) ;
				}	else	{
					//_ASSERT( m_pIOCurrent == 0 || m_fTerminating ) ;

					if( m_fTerminating ) {
						//
						//	We know that pPacket == m_pSpecialPacket now because this
						//	control structure was set up immediately preceeding this code
						//	using pPacket !
						//
						control.m_pioPassThru->DoShutdown(
								pSocket,
								*pExtraRef,
								pExtraRef->m_cause,
								pExtraRef->m_dwOptionalErrorCode ) ;
						//
						//	This will also have the effect of deleting pPacket since
						//	pPacket == m_pUnsafePacket - InterlockedExchange should not be
						//	necessary but do it for safety's sake !
						//
						CleanupSpecialPackets() ;

					}	else	{
						m_pIOCurrent = control.m_pioPassThru ;
						if( control.m_fStart ) {

							SEQUENCENO liTemp;
							DIFF( m_sequencenoOut, m_sequencenoIn, liTemp );

							if( !m_pIOCurrent->Start( *m_pDriver, pSocket, m_fAcceptRequests, m_fRequireRequests,
									unsigned( LOW(liTemp) ) ) ) {
								// FATAL ERROR !!!
								_ASSERT( 1==0 ) ;
							}		
						}
					}
					control.m_pioPassThru = 0 ;
				}				
			}

			_ASSERT( control.m_pioPassThru == 0 ) ;
			_ASSERT( control.m_pio == 0 ) ;

			//
			//	NOTE MAY DELETE pPacket in Preceding code !!!! DO NOT USE IT !!!!!
			//
            pPacket = 0 ;

            pIO = m_pIOCurrent ;


			CPacket*	pPacketRequest = 0 ;
			CPacket*	pPacketPending = 0 ;

			if( m_fTerminating ) {

				DebugTrace( (DWORD_PTR)this, "TERMINATING - m_pIOCurrent %x", m_pIOCurrent ) ;

				pPacketRequest = m_pendingRequests.GetHead() ;

				DebugTrace( (DWORD_PTR)this, "pPacketRequest - %x", pPacketRequest ) ;

				while( pPacketRequest ) {
					m_pendingRequests.RemoveHead() ;

					DebugTrace( (DWORD_PTR)this, "Closing owner %x source %x",
							pPacketRequest->m_pOwner, pPacketRequest->m_pSource );

					pPacketRequest->m_pOwner->UnsafeClose(	
													pSocket,
													pExtraRef->m_cause,		
													pExtraRef->m_dwOptionalErrorCode
													) ;
					pPacketRequest->m_cbBytes = 0 ;
					pPacketRequest->m_fRequest = FALSE ;
					listForward.Append( pPacketRequest ) ;
					pPacketRequest = m_pendingRequests.GetHead() ;

					DebugTrace( (DWORD_PTR)this, "pPacketRequest - %x", pPacketRequest ) ;

				}
				
				pPacketPending = m_requestPackets.GetHead() ;

				DebugTrace( (DWORD_PTR)this, "pPacketPending - %x", pPacketPending ) ;

				while( pPacketPending ) {
					m_requestPackets.RemoveHead() ;

					DebugTrace( (DWORD_PTR)this, "Closing owner %x source %x",
							pPacketPending->m_pOwner, pPacketPending->m_pSource );

					pPacketPending->m_pOwner->UnsafeClose(	
													pSocket,	
													pExtraRef->m_cause,
													pExtraRef->m_dwOptionalErrorCode ) ;
					pPacketPending->m_cbBytes = 0 ;
					pPacketPending->m_fRequest = FALSE ;
					listForward.Append( pPacketPending ) ;
					pPacketPending = m_requestPackets.GetHead() ;

					DebugTrace( (DWORD_PTR)this, "pPacketPending - %x", pPacketPending ) ;

				}

				pPacketCompleted = m_completePackets.GetHead() ;
		
				DebugTrace( (DWORD_PTR)this, "pPacketCompleted - %x", pPacketCompleted ) ;
	
				while( pPacketCompleted ) {
					m_completePackets.RemoveHead() ;
					pPacketCompleted->m_pOwner->DestroyPacket( pPacketCompleted ) ;
					pPacketCompleted = m_completePackets.GetHead() ;
					INC(m_sequencenoIn);

					DebugTrace( (DWORD_PTR)this, "pPacketCompleted - %x - m_sequncenoIn %x",
						pPacketCompleted, (DWORD)LOW(m_sequencenoIn) ) ;
				}

			}	else	{

				BOOL	fAdvanceRequests = FALSE ;
				BOOL	fAdvanceCompletes = FALSE ;

				pPacketRequest = m_pendingRequests.GetHead() ;

				DebugTrace( (DWORD_PTR)this, "INPROGRESS - pPacketRequest %x", pPacketRequest ) ;

				do	{

					fAdvanceRequests =	m_fAcceptRequests &&
										pPacketRequest &&
										EQUALS( pPacketRequest->m_sequenceno, m_sequencenoNext ) &&
										(m_pIOFilter[pPacketRequest->m_dwPassThruIndex] ==
											m_pIOCurrent || m_pIOCurrent == 0) ;

					DebugTrace(	(DWORD_PTR)this,	"fAdvRqsts %x m_fAcptRqsts %x pPcktRqst %x "
										"pPcktRqst->m_seq %x m_seqNext %x m_pIOCurrent %x "
										"m_pIOFilter[] %x",
						fAdvanceRequests, m_fAcceptRequests, pPacketRequest,
						pPacketRequest ? (DWORD)LOW(pPacketRequest->m_sequenceno) : 0,
						(DWORD)LOW(m_sequencenoNext), m_pIOCurrent,
						pPacketRequest ? (DWORD)pPacketRequest->m_dwPassThruIndex : (DWORD)0xFFFFFFFF
						) ;
						
		

					if( fAdvanceRequests ) {
			
						if( m_pIOCurrent == 0 ) {
							m_pIOCurrent = m_pIOFilter[pPacketRequest->m_dwPassThruIndex] ;
						}
				
						m_pendingRequests.RemoveHead() ;
						if( !pPacketRequest->InitRequest(
											*m_pDriver,
											pSocket,
											m_pIOCurrent,
											m_fAcceptRequests ) )	{

							ErrorTrace( (DWORD_PTR)this, "InitRequest for pPacketRequest %x failed", pPacketRequest ) ;

							// error occurred - we should shutdown !!

							m_pDriver->UnsafeClose(	pSocket, CAUSE_IODRIVER_FAILURE, 0 ) ;

							//
							//	Send this failed reqest back to the originator !
							//

							pPacketRequest->m_cbBytes = 0 ;
							pPacketRequest->m_fRequest = FALSE ;
							listForward.Append( pPacketRequest ) ;


							break ;
			
						}
						m_requestPackets.Append( pPacketRequest ) ;
						INC(m_sequencenoNext);
						pPacketRequest = m_pendingRequests.GetHead() ;

					}	else	{

						pPacketRequest = 0 ;				

						pPacketPending = m_requestPackets.GetHead() ;
						pPacketCompleted = m_completePackets.GetHead() ;
						fAdvanceCompletes =	pPacketCompleted &&
											pPacketPending &&
											EQUALS( pPacketCompleted->m_sequenceno, m_sequencenoIn) &&
											m_pIOCurrent ;

						DebugTrace( (DWORD_PTR)this,	"fAdvComp %x pPcktComp %x pPcktPend %x"
											"pPcktComp->m_seq %x m_seq %x m_pIOCurrent %x",
							fAdvanceCompletes, pPacketCompleted, pPacketPending,
							pPacketCompleted ? (DWORD)LOW(pPacketCompleted->m_sequenceno) : 0,
							(DWORD)LOW(m_sequencenoIn),	m_pIOCurrent
							) ;

						if( fAdvanceCompletes ) {

							BOOL	fCompleteRequest = FALSE ;
							ASSIGN( pPacketCompleted->m_iStream, m_iStreamIn ) ;
					
							unsigned	cbConsumed = pPacketCompleted->Complete( m_pIOCurrent, pSocket, pPacketPending, fCompleteRequest ) ;
							ADDI( m_iStreamIn, cbConsumed );
							pPacketCompleted->m_cbBytes -= cbConsumed ;

							DebugTrace( (DWORD_PTR)this, "pPacketCompleted %x m_cbBytes %x cbConsumed %x fComplete",
								pPacketCompleted, pPacketCompleted->m_cbBytes, cbConsumed, fCompleteRequest ) ;

							if( pPacketCompleted->m_cbBytes == 0 ) {
								m_completePackets.RemoveHead() ;
								pPacketCompleted->m_pOwner->DestroyPacket( pPacketCompleted ) ;
								pPacketCompleted = m_completePackets.GetHead() ;
								INC(m_sequencenoIn);
							}
							if( fCompleteRequest ) {
								pPacketPending->m_fRequest = FALSE ;
								m_requestPackets.RemoveHead() ;
								listForward.Append( pPacketPending ) ;

								pPacketRequest = m_pendingRequests.GetHead() ;
								m_fAcceptRequests = TRUE ;

								if( m_requestPackets.GetHead() == 0 )
									m_pIOCurrent = 0 ;

								DebugTrace( (DWORD_PTR)this, "pPacketRequest %x m_pIOCurrent %x m_fAcceptRequests %x",
									pPacketRequest, m_pIOCurrent, m_fAcceptRequests ) ;

							}							
						}
					}
				}	while( fAdvanceRequests || fAdvanceCompletes ) ;
			}

			#ifdef	CIO_DEBUG
			m_dwThreadOwner = 0 ;
			_ASSERT( InterlockedDecrement( &m_cThreads ) < 0 ) ;
			#endif
		}

        //
        //  Now, all the requests packets that were completed are forwarded to
        //  the channel which originated them.   Because this code falls outside
        //  the GetHead() loop, multiple threads could be executing here for the
        //  same object.  We must be carefull to not touch any member variables.
        //
        while( (pPacket = listForward.RemoveHead()) != 0 ) {
            pPacket->ForwardRequest( pSocket ) ;
        }
        _ASSERT( listForward.IsEmpty() ) ;   // Must empty this queue before leaving !!!
    }
}

void
CIStream::ProcessPacket( CPacket*    pPacketCompleted,
                            CSessionSocket* pSocket )   {

/*++

Routine Description :

	All packets which complete must be processed with a call to this function.
	We will handle all the work related to completing a packet.

Arguments :

	pPacketCompleted - the packet that completed.
	pSocket -	The CSessionSocket on which the packet was sent.

Return Value :

	None.

--*/

    TraceFunctEnter(    "CIStream::ProcessPacket" ) ;

	CDRIVERPTR	pExtraRef = 0 ;	

	//
	//	This function is the heart of CIODriver processing.
	//	We are very similar to CIOStream with the exception being
	//	that we only process completed packets, and get no requests.
	//


    CIO*    pIO = 0 ;

#ifdef	CIO_DEBUG
	if( pPacketCompleted->ControlPointer() == 0 )
		m_pSourceChannel->ReportPacket( pPacketCompleted ) ;
#endif

    //
    //  This is either a read stream, or a write stream.
    //  Read streams accept only CReadPackets, Write Streams accept
    //  CWritePackets and CTransmitPackets
    //
    _ASSERT( !pPacketCompleted->m_fRequest ) ;
    _ASSERT( pPacketCompleted->FLegal( m_fRead ) ) ;

	DebugTrace( (DWORD_PTR)this, "Completing packet %x with sequenceno %d bytes %d owner %x", pPacketCompleted,
		(DWORD)LOW(pPacketCompleted->m_sequenceno),
		pPacketCompleted->m_cbBytes, (CIODriver*)m_pOwner ) ;

    //
    //  We will append a completed packet to the pending Queue.  If this is
    //  the first packet to be appended, then Append will return TRUE.
    //
    if( m_pending.Append( pPacketCompleted ) )  {
        //
        // Each call to GetHead removes an element from the pending queue.
        // When the queue is finally empty, GetHead will return FALSE.  After GetHead
        // returns FALSE another thread calling Append() could get a TRUE value
        // (but as long as GetHead() returns TRUE to US, no one is getting TRUE from
        // Append.  )
        //

		// The owner should not be NULL unless we are terminating.
		_ASSERT( m_pOwner != 0 || m_fTerminating ) ;

        DebugTrace( (DWORD_PTR) this, "Appended Packet ", this ) ;

        CPacket*    pPacket ;
        while( (pPacket = m_pending.RemoveAndRelease( )) != 0  )   {

			DebugTrace( (DWORD_PTR)this, "Got Packet %x sequenceno %d", pPacket, (DWORD)LOW(pPacket->m_sequenceno) ) ;

			if( m_fTerminating )
				pExtraRef = pPacket->m_pOwner ;

            #ifdef  CIO_DEBUG
            m_dwThreadOwner = GetCurrentThreadId() ;
            _ASSERT( InterlockedIncrement( &m_cThreads ) == 0 ) ;
            #endif  //  CIO_DEBUG

			ControlInfo	control ;
			_ASSERT( control.m_type == ILLEGAL ) ;
			_ASSERT( control.m_pio == 0 ) ;
			_ASSERT( control.m_fStart == FALSE ) ;

            if( pPacket == m_pSpecialPacketInUse )   {
                //
                // This packet includes an IO* pointer !!
                //
 				_ASSERT( !pPacket->m_fRequest ) ;
                _ASSERT( pPacket->ControlPointer() ) ;
                _ASSERT( pPacket->IsValidRequest( m_fRead ) ) ;
                DebugTrace( (DWORD_PTR)this, "Processing Special Packet - CIStream %x", this ) ;

				control = m_pSpecialPacketInUse->m_control ;
				m_pSpecialPacketInUse->Reset() ;
				m_pSpecialPacketInUse = 0;
				if( m_fTerminating )	{
					//delete	pPacket ;
					pPacket->m_pOwner->DestroyPacket( pPacket ) ;
					pPacket = 0 ;
				}	else
					m_pSpecialPacket = (CControlPacket*)pPacket ;
				#ifdef	CIO_DEBUG
				_ASSERT( InterlockedDecrement( &m_cNumberSends ) < 0 ) ;
				#endif
			}	else	if( pPacket == m_pUnsafeInuse ) {
 				_ASSERT( !pPacket->m_fRequest ) ;
                _ASSERT( pPacket->ControlPointer() ) ;
                _ASSERT( pPacket->IsValidRequest( m_fRead ) ) ;
				_ASSERT( m_pUnsafeInuse->m_control.m_type == SHUTDOWN ) ;
				DebugTrace( (DWORD_PTR)this, "Processing UnSafeInUse packet - %x", m_pUnsafeInuse ) ;
				control = m_pUnsafeInuse->m_control ;
				m_pUnsafeInuse->Reset() ;
				m_pUnsafeInuse = 0 ;
				//delete	pPacket ;
				pPacket->m_pOwner->DestroyPacket( pPacket ) ;
				pPacket = 0 ;
			}	else	{
				_ASSERT( !pPacket->m_fRequest ) ;
				if( pPacket->m_fSkipQueue ) {
					pIO = m_pIOCurrent ;
					pPacket->Complete( pIO, pSocket ) ;
					_ASSERT( pIO == m_pIOCurrent ) ;
				}	else	{
	                m_completePackets.Append( pPacket ) ;
				}
			}
			if( control.m_type != ILLEGAL ) {

				if( control.m_type == SHUTDOWN ) {
					m_fTerminating = TRUE ;
					pExtraRef = m_pOwner ;

					if( m_fRead ) {
						if( m_pSourceChannel != 0 && pExtraRef != 0 && pExtraRef->m_cause == CAUSE_TIMEOUT )
							m_pSourceChannel->Timeout() ;
					}

					CleanupSpecialPackets() ;
					
					SetShutdownState( pSocket, control.m_fCloseSource ) ;


				}	else	{
					// START_IO's only arrive on m_pSpecialPacket
					//_ASSERT( m_pIOCurrent == 0 || m_fTerminating ) ;


					if( m_fTerminating ) {
						//
						//	We know that pPacket == m_pSpecialPacket now because this
						//	control structure was set up immediately preceeding this code
						//	using pPacket !
						//
						control.m_pio->DoShutdown(
								pSocket,
								*pExtraRef,
								pExtraRef->m_cause,
								pExtraRef->m_dwOptionalErrorCode ) ;
						//
						//	This will also have the effect of deleting pPacket since
						//	pPacket == m_pUnsafePacket - InterlockedExchange should not be
						//	necessary but do it for safety's sake !
						//
						CleanupSpecialPackets() ;

					}	else	{
						m_pIOCurrent = control.m_pio ;
						if( control.m_fStart ) {

							SEQUENCENO seqTemp;
							DIFF( m_sequencenoOut, m_sequencenoIn, seqTemp );

							if( !m_pIOCurrent->Start( *m_pOwner, pSocket,
									unsigned( LOW(seqTemp) ) ) ) {

								//
								//	This is a fatal error - need to drop the session !
								//
								m_pOwner->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;

							}		
						}
					}
					control.m_pio = 0 ;
				}				
			}

			_ASSERT( control.m_pioPassThru == 0 ) ;
			_ASSERT( control.m_pio == 0 ) ;

			//
			//	NOTE MAY DELETE pPacket in Preceding code !!!! DO NOT USE IT !!!!!
			//
            pPacket = 0 ;

            pPacketCompleted = m_completePackets.GetHead() ;
            pIO = m_pIOCurrent ;

            DebugTrace( (DWORD_PTR)this, "Completed %x pIO %x m_sequenceno %d m_sequncenoIn %d", pPacketCompleted, pIO,
				pPacketCompleted ? LOW(pPacketCompleted->m_sequenceno) : 0, LOW(m_sequencenoIn) ) ;

            while( pPacketCompleted &&
                    EQUALS( pPacketCompleted->m_sequenceno, m_sequencenoIn ) &&
                    pIO ) {

                ASSIGN( pPacketCompleted->m_iStream, m_iStreamIn ) ;

                _ASSERT( pIO != 0 ) ;


                unsigned    cbConsumed = 0 ;
				if( pPacketCompleted->m_cbBytes != 0 )
					cbConsumed = pPacketCompleted->Complete( pIO, pSocket ) ;

				// MUST Consume some Bytes !!!!
                _ASSERT( cbConsumed != 0 || m_fTerminating || pPacketCompleted->m_cbBytes == 0  ) ;
                _ASSERT( cbConsumed <= pPacketCompleted->m_cbBytes ) ;
                _ASSERT( (cbConsumed == pPacketCompleted->m_cbBytes) ||
                        pPacketCompleted->FConsumable() ) ; // If the packet is not consumed than
                                                            // it must be a read packet.

                DebugTrace( (DWORD_PTR)this, "Consumed %d bytes of %d total pIO is now %x", cbConsumed, pPacketCompleted->m_cbBytes, pIO ) ;

                ADDI( m_iStreamIn, cbConsumed );
                pPacketCompleted->m_cbBytes -= cbConsumed ;

                if( pPacketCompleted->m_cbBytes == 0 ) {
                    m_completePackets.RemoveHead() ;

					// Note : Since we are reference counted by the packets we destroy
					// we could potentially kill ourselves here.  To fix this we require
					// that a control packet be sent which will prepare ourselves for our
					// own destruction. If a control packet is sent, we will add a
					// reference temporarily (by assigning to pExtraRef which is a smart
					// pointer).
                    //delete  pPacketCompleted ;
					pPacketCompleted->m_pOwner->DestroyPacket( pPacketCompleted ) ;

                    pPacketCompleted = m_completePackets.GetHead() ;
                    INC(m_sequencenoIn);
                }
                _ASSERT( !GREATER( m_sequencenoIn, m_sequencenoOut) ) ;

                if( pIO != m_pIOCurrent )   {
					DebugTrace( (DWORD_PTR)this, "New pIO %x Old %x", pIO, m_pIOCurrent ) ;
                    if( pIO )   {
                        _ASSERT( !((!!m_fRead) ^ (!!pIO->IsRead())) ) ;
						DebugTrace( (DWORD_PTR)this, "Starting pIO %x, m_sequencenoOut %d m_sequencenoIn %d",
							pIO, (DWORD)LOW(m_sequencenoIn), (DWORD)LOW(m_sequencenoOut) ) ;

						SEQUENCENO seqTemp;
						DIFF( m_sequencenoOut, m_sequencenoIn, seqTemp );

                        if( !pIO->Start( *m_pOwner, pSocket, unsigned( LOW(seqTemp) ) ) )    {

							//
							//	We should drop the session, as this is an entirely fatal error !!!
							//
							m_pOwner->UnsafeClose( pSocket, CAUSE_UNKNOWN, 0, TRUE ) ;

                        }
                    }
					CIO*	pTemp = m_pIOCurrent.Replace( pIO ) ;
					if( pTemp ) {
						CIO::Destroy( pTemp, *m_pOwner ) ;
					}
                }
            }
#ifdef  CIO_DEBUG
        m_dwThreadOwner = 0 ;
        _ASSERT( InterlockedDecrement( &m_cThreads ) < 0 ) ;
#endif  //  CIO_DEBUG
        }
        //
        //  Final Call to m_pending.GetHead() should zero pPacket if it returns FALSE.
        //
        _ASSERT( pPacket == 0 ) ;
    }
	// At this point - pExtraRef will be Destroyed - which may destroy EVERYTHING !!
	//	In fact this should be the only point at which we destroy ourselves !!
}


DWORD	CIODriver::iMediumCache = 0 ;
DWORD	CIODriver::cMediumCaches = 128 ;
class	CMediumBufferCache*	CIODriver::pMediumCaches = 0 ;

BOOL
CIODriver::InitClass()	{

	iMediumCache = 0 ;
	cMediumCaches = 128 ;
	pMediumCaches = new	CMediumBufferCache[ cMediumCaches ] ;
	if( pMediumCaches ) {
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CIODriver::TermClass()	{

	XDELETE[]	pMediumCaches ;
	return	TRUE ;
}


CIODriver::CIODriver( class	CMediumBufferCache*	pCache ) :
	//
	//	Create a CIODriver object
	//
	m_pMediumCache( 0 ),
	m_pfnShutdown( 0 ),
	m_pvShutdownArg( 0 ),
	m_cause( CAUSE_UNKNOWN ),
	m_pReadStream( 0 ),
	m_pWriteStream( 0 ),
	m_dwOptionalErrorCode( 0 ),
	m_cShutdowns( -1 )
#ifdef	CIO_DEBUG
	,m_cConcurrent( -1 ),
	m_fSuccessfullInit( FALSE ),
	m_fTerminated( FALSE )
#endif
{

	TraceFunctEnter( "CIODriver::CIODriver" ) ;
	DebugTrace( (DWORD_PTR)this, "just created Driver" ) ;

	if( m_pMediumCache == 0 ) {
		DWORD	iCache = iMediumCache ++ ;
		iCache %= cMediumCaches ;

		m_pMediumCache = &pMediumCaches[iCache] ;
	}

	ChannelValidate() ;
}

CIODriver::~CIODriver()	{

	//
	//	We must call the registered notification function to let somebody know that
	//	we are now gone.  In most instances, this is a function registered by CSessionSocket	
	//	which lets it know when the socket is really dead.
	//

#ifdef	CIO_DEBUG
	_ASSERT( !m_fSuccessfullInit || m_fTerminated ) ;
#endif

	TraceFunctEnter( "CIODriver::~CIODriver" ) ;

	DebugTrace( (DWORD_PTR)this, "destroying driver" ) ;	

	ChannelValidate() ;

	if( m_pfnShutdown ) {
		m_pfnShutdown( m_pvShutdownArg, m_cause, m_dwOptionalErrorCode ) ;
	}
	m_pfnShutdown = 0 ;
	m_pvShutdownArg = 0 ;
	m_dwOptionalErrorCode = 0 ;
	m_cause = CAUSE_UNKNOWN ;
}

CIODriverSink::CIODriverSink( class	CMediumBufferCache*	pCache) :
	CIODriver( pCache ),
	m_ReadStream( 0 ),
	m_WriteStream( 1 )  {

	//
	//	Create a CIODriverSink - we just to need to initialize pointers to
	//	2 CIStream objects.
	//

	TraceFunctEnter( "CIODriverSInk::CIODriverSink" ) ;

	ChannelValidate() ;

	DebugTrace( (DWORD_PTR)this, "New Sink size %d", sizeof( *this )  ) ;

    m_pReadStream = &m_ReadStream ;
    m_pWriteStream = &m_WriteStream ;

}

CIODriverSink::~CIODriverSink()	{

	//
	//	The tracing is usefull for debugging - not much else happens.
	//

	TraceFunctEnter(	"CIODriverSink::~CIODriverSink"  ) ;
	DebugTrace( (DWORD_PTR)this, "Destroying IODriverSink" ) ;
	ChannelValidate() ;
}

BOOL
CIODriverSink::Init(    CChannel    *pSource,
						CSessionSocket  *pSocket,
						PFNSHUTDOWN	pfnShutdown,	
						void*	pvShutdownArg,
						unsigned cbReadOffset,
						unsigned cbWriteOffset,
						unsigned cbTrailer
						) {
/*++

Routine Description :

	Initialize a CIODriverSink object.

Arguments :

	pSource - The CChannel to which all Read()'s and Write()'s should be directed
	pSocket - The CSessionSocket with which we are associated
	pfnShutdown-	A function to call when we die
	pvShutdownArg -	Arguments to pass to pfnShutdown
	cbReadOffset -	Number of bytes to reserve at the head of CReadPacket buffer's
	cbWriteOffset -	Number of bytes to reserve at the head of CWritePacket buffer's

Returns :
	
	TRUE if successfull, FALSE otherwise.

--*/

	//
	//	Initialize our CIStream objects
	//	We add a reference to ourself to force people to call UnsafeCLose() to
	//	shut us down.
	//

	ChannelValidate() ;

	// We add a reference to ourself has we only want to be destoyed through Close()
	AddRef() ;

	m_pfnShutdown = pfnShutdown ;
	m_pvShutdownArg = pvShutdownArg ;

    BOOL    fSuccess = TRUE ;
    fSuccess &= m_ReadStream.Init( CCHANNELPTR(pSource), *this,  0, TRUE, pSocket, cbReadOffset, cbTrailer  ) ;
    if( fSuccess )
        fSuccess &= m_WriteStream.Init( CCHANNELPTR(pSource), *this, 0, FALSE, pSocket, cbWriteOffset, cbTrailer ) ;

#ifdef	CIO_DEBUG
	if( fSuccess )
		m_fSuccessfullInit = TRUE ;
#endif

    return  fSuccess ;
}

void
CIODriver::Close(	CSessionSocket*	pSocket,
					SHUTDOWN_CAUSE	cause,	
					DWORD	dw,
					BOOL fCloseSource	)	{
/*++

Routine Description :

	Same as UnsafeClose()... This function needs to be retired.

Arguments :

	See UnsafeClose(),

Return Value  :

	None.

--*/

	//
	//	This function was intended to be used in certain thread safe situations only
	//	however it is now identical to UnsafeClose() and consequently needs to be retired.
	//

#ifdef	CIO_DEBUG
	_ASSERT( m_fSuccessfullInit ) ;	// Should only be called if successfully init'd
	m_fTerminated = TRUE ;
#endif

	ChannelValidate() ;

	if( InterlockedIncrement( &m_cShutdowns ) == 0 )	{

		m_cause = cause ;
		m_dwOptionalErrorCode = dw ;

		m_pReadStream->UnsafeShutdown( pSocket, fCloseSource ) ;
		m_pWriteStream->UnsafeShutdown( pSocket, fCloseSource ) ;

		// Remove Reference to self - we should disappear shortly after this !!
		if( RemoveRef() < 0 )
			delete	this ;
	}
}

void
CIODriver::UnsafeClose(	CSessionSocket*	pSocket,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dw,
						BOOL fCloseSource )	{
/*++

Routine Description :

	Terminate a CIODriver - force all outstanding packets to complete, notify
	whatever CIO is currently active that we're dieing and wind everything up.

Arguments :

	pSocket -	The socket we're associated with
	cause	-	The reason we're terminating
	dw -		Optional DWORD providing further info on why we're terminating.
	fCloseSource -	TRUE means we should close our the CChannel we were passed on
				out Init() call.

Return Value :

	None.

--*/

	TraceFunctEnter( "CIODriver::UnsafeClose" ) ;
	DebugTrace( (DWORD_PTR)this, "Terminating cause of %d err %d CloseSource %x socket %x",
					cause, dw, fCloseSource, pSocket ) ;

	//
	//	Start a CIODriver on the path to destruction.
	//	NOTE : We can be called many times however there
	//	should only be ONE call that actually does anything.	
	//

#ifdef	CIO_DEBUG
	_ASSERT( m_fSuccessfullInit ) ;	// Should only be called if successfully init'd
	m_fTerminated = TRUE ;
#endif

	ChannelValidate() ;

	if( InterlockedIncrement( &m_cShutdowns ) == 0 )	{

		m_cause	= cause ;
		m_dwOptionalErrorCode = dw ;

		m_pReadStream->UnsafeShutdown( pSocket, fCloseSource ) ;
		m_pWriteStream->UnsafeShutdown( pSocket, fCloseSource ) ;

		if( RemoveRef() < 0 )
			delete	this ;
	}
}

#ifdef	CIO_DEBUG
void	CIODriver::SetChannelDebug( DWORD	dw ) {
	m_pReadStream->SetChannelDebug( dw ) ;
}
#endif



BOOL
CIODriverSink::Start(   CIOPTR&    pRead,
						CIOPTR&	pWrite,
						CSessionSocket* pSocket )   {
/*++

Routine Description :

	Now that the CIODriverSink is all setup, issue the initial CIO's
	to get packet's flowing.

Argurments :

	pRead -	The CIO which will issue CReadPacket's
	pWrite -	The CIO which will issue CWritePacket's
	pSocket -	The Socket we are associated with.

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/

	//
	//	We've got out initial CIO derived objects which want to do
	//	some work.  So start them !
	//

	ChannelValidate() ;
	AddRef() ;

    BOOL    eof = FALSE ;
    BOOL    fSuccess = TRUE ;
    if( fSuccess && pRead )     {
        fSuccess &= pRead->Start( *this, pSocket, 0 ) ;

		if( fSuccess ) {
			fSuccess &= m_ReadStream.SendIO( pSocket, *pRead, FALSE ) ;
			if( !fSuccess )	{
				pRead->DoShutdown( pSocket, *this, m_cause, 0 ) ;
			}
		}
    }
    if( fSuccess && pWrite )    {
        fSuccess &= pWrite->Start( *this, pSocket, 0 ) ;

		if( fSuccess )	{
			fSuccess &= m_WriteStream.SendIO( pSocket, *pWrite, FALSE ) ;
			if( !fSuccess )		{
				pWrite->DoShutdown( pSocket, *this, m_cause, 0 ) ;
			}
		}

    }
    _ASSERT( !eof ) ;

	if( RemoveRef() < 0 )
		delete	this ;
    return  fSuccess ;
}

#ifdef	CIO_DEBUG
void
CStream::SetChannelDebug( DWORD dw ) {
	m_pSourceChannel->SetDebug( dw ) ;
}
#endif

void
CIODriver::DestroyPacket(	CPacket*	pPacket )	{

	//
	//	Reference ourselves so that we don't get destroyed in the middle of this func
	//	in case the packet we are eliminating has the last reference to us.
	//
	CDRIVERPTR	pExtraRef = this ;

	pPacket->ReleaseBuffers( &m_bufferCache, m_pMediumCache ) ;

	m_packetCache.Free( CPacket::Destroy( pPacket ) ) ;

	//
	//	The desctructor of pExtraRef may destroy us at this point !
	//
}

CReadPacket*
CStream::CreateDefaultRead(		CIODriver   &driver,
								unsigned    cbRequest
								) {

	//
	//	CReadPacket's should only be created through appropriate CreateDefaultRead
	//	calls.  We will ensure that the CReadPacket is properly initialized for completion
	//	to THIS CIODriver.  Additionally, we will make sure the buffer is properly padded
	//	for encryption support etc....
	//
	
	DriverValidate( &driver ) ;

    _ASSERT( driver.FIsStream( this ) ) ;
    _ASSERT( m_cbFrontReserve != UINT_MAX ) ;
    _ASSERT( m_cbTailReserve != UINT_MAX ) ;

    CReadPacket*    pPacket = 0 ;
    if( m_fCreateReadBuffers )  {

        DWORD	cbOut = 0 ;

		DWORD	cbAdd = m_cbFrontReserve + m_cbTailReserve ;
		DWORD	cbFront = m_cbFrontReserve ;
		DWORD	cbTail = m_cbTailReserve ;

        CBuffer*    pbuffer = new(	cbRequest+cbAdd,
									cbOut,
									&driver.m_bufferCache,
									driver.m_pMediumCache )     CBuffer( cbOut ) ;
        if( pbuffer == 0 )  {
            return 0 ;
        }
        _ASSERT( cbOut > 0 ) ;
        _ASSERT( unsigned(cbOut) >= cbRequest ) ;

        pPacket = new( &driver.m_packetCache )
									CReadPacket(	driver,
													cbOut,
													cbFront,
													cbTail,
													*pbuffer ) ;
        if( !pPacket )  {
            delete  pbuffer ;
            return  0 ;
        }
        _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    }   else    {
        pPacket = new( &driver.m_packetCache )   CReadPacket( driver ) ;
        _ASSERT( pPacket->IsValidRequest( FALSE ) ) ;
    }
    return  pPacket ;
}

CWritePacket*
CStream::CreateDefaultWrite( CIODriver&  driver,
            CBUFPTR&    pbuffer,
            unsigned    ibStart,
			unsigned    ibEnd,
			unsigned    ibStartData,
			unsigned	ibEndData
			) {

	//
	//	CWritePacket's should only be created through appropriate CreateDefaultWrite calls.
	//	We will ensure that the CWritePacket is properly initialized for completion to
	//	this CIODriver.
	//

	DriverValidate( &driver ) ;

    _ASSERT( driver.FIsStream( this ) ) ;
    _ASSERT( m_cbFrontReserve != UINT_MAX ) ;
    _ASSERT( m_cbTailReserve != UINT_MAX ) ;
    return  new( &driver.m_packetCache )
					CWritePacket(	driver,
									*pbuffer,
									ibStartData,
									ibEndData,
									ibStart,
									ibEnd,
									m_cbTailReserve
									) ;
}

CWritePacket*
CStream::CreateDefaultWrite( CIODriver&  driver,
            unsigned    cbRequest )     {

	//
	//	CWritePacket's should only be created through appropriate CreateDefaultWrite calls.
	//	We will ensure that the CWritePacket is properly initialized for completion to
	//	this CIODriver.
	//

	DriverValidate( &driver ) ;

    _ASSERT( driver.FIsStream( this ) ) ;
    _ASSERT( m_cbFrontReserve != UINT_MAX ) ;
    _ASSERT( m_cbTailReserve != UINT_MAX ) ;

    CWritePacket*   pPacket = 0 ;

    DWORD	cbOut = 0 ;
    CBuffer*    pbuffer = new(	m_cbFrontReserve+m_cbTailReserve+cbRequest,
								cbOut,
								&driver.m_bufferCache,
								driver.m_pMediumCache	)  CBuffer( cbOut ) ;
    if(     pbuffer != 0 )  {
        pPacket = new( &driver.m_packetCache )
								CWritePacket(	driver,
												*pbuffer,
												m_cbFrontReserve,
												cbOut - m_cbTailReserve,
												0,
												cbOut - m_cbTailReserve,
												m_cbTailReserve
												) ;
        if( !pPacket )  {
            delete  pbuffer ;
        }
    }
    return  pPacket ;
}


CTransmitPacket*
CStream::CreateDefaultTransmit(  CIODriver&  driver,
			FIO_CONTEXT*	pFIOContext,
			unsigned		ibOffset,	
			unsigned		cbLength
			)  {

	//
	//	CTransmitPacket's should only be created through appropriate CreateDefaultWrite calls.
	//	We will ensure that the CWritePacket is properly initialized for completion to
	//	this CIODriver.
	//

	DriverValidate( &driver ) ;

    _ASSERT( driver.FIsStream( this ) ) ;
    _ASSERT( m_cbFrontReserve != UINT_MAX ) ;
    _ASSERT( m_cbTailReserve != UINT_MAX ) ;
    return  new( &driver.m_packetCache ) CTransmitPacket( driver, pFIOContext, ibOffset, cbLength ) ;
}

BOOL
CIODriverSink::FSupportConnections()    {

	//
	//	We can not be used as a regular CHandleChannel so return FALSE
	//

	ChannelValidate() ;

    return  FALSE ;
}

void
CIODriverSink::CloseSource(
					CSessionSocket*	pSocket
					)	{
	//
	//	We are not a Source like CHandleChannel is so don't call us as if we were !
	//
	_ASSERT(1==0 ) ;
}


BOOL
CIODriverSink::Read(    CReadPacket*,   CSessionSocket*,
						BOOL& eof  )   {

	//
	//	This function is only supported by CChannel derived objects which can
	//	actually make an IO happen.
	//

	ChannelValidate() ;

    _ASSERT( 1==0 ) ;
    return  FALSE ;
}

BOOL
CIODriverSink::Write(	CWritePacket*,
						CSessionSocket*,
						BOOL&  eof )   {
	//
	//	This function is only supported by CChannel derived objects which can
	//	actually make an IO happen.
	//

	ChannelValidate() ;

    _ASSERT( 1==0 ) ;
    return  FALSE ;
}

BOOL
CIODriverSink::Transmit(    CTransmitPacket*,
							CSessionSocket*,
							BOOL&   eof )   {

	//
	//	This function is only supported by CChannel derived objects which can
	//	actually make an IO happen.
	//

	ChannelValidate() ;

    _ASSERT( 1==0 ) ;
    return  FALSE ;
}

CIODriverSource::CIODriverSource(	
					class	CMediumBufferCache*	pCache
					) :
	CIODriver( pCache ),
	//
	//	Create a CIODriverSource by initializing two CIOStream's.
	//
	//
	m_ReadStream( 0, 0 ),	
	m_WriteStream( 0, 1 )	{

	TraceFunctEnter( "CIODriverSource::CIODriverSource" ) ;

	m_ReadStream.m_pDriver = this ;
	m_WriteStream.m_pDriver = this ;

	m_pReadStream = &m_ReadStream ;
	m_pWriteStream = &m_WriteStream ;

	DebugTrace( (DWORD_PTR)this, "Complete Initialization - sizeof this %d", sizeof( *this ) ) ;

}

CIODriverSource::~CIODriverSource() {

	//
	//	Usefull mainly for the tracing.
	//

	TraceFunctEnter( "CIODriverSource::~CIODriverSource" ) ;
	DebugTrace( (DWORD_PTR)this, "Destroying CIODriverSource" ) ;

}

BOOL
CIODriverSource::Read(  CReadPacket*    pPacket,
						CSessionSocket* pSocket,
						BOOL&   eof )   {

	//
	//	All requests are passed to ProcessPacket so that
	//	we don't have threading issues dealing with these !
	//

	ChannelValidate() ;

    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;

	pPacket->m_dwPassThruIndex = 0 ;

    eof = FALSE ;
    m_pReadStream->ProcessPacket(   pPacket,    pSocket ) ;
    return  TRUE ;
}

BOOL
CIODriverSource::Write( CWritePacket*   pPacket,
						CSessionSocket* pSocket,
						BOOL&   eof )   {

	//
	//	All requests are passed to ProcessPacket so that
	//	we don't have threading issues dealing with these !
	//

	ChannelValidate() ;

    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;

	pPacket->m_dwPassThruIndex = 1 ;

    eof = FALSE ;
    m_pWriteStream->ProcessPacket(  pPacket,    pSocket ) ;
    return  TRUE ;
}

BOOL
CIODriverSource::Transmit(  CTransmitPacket*    pPacket,
							CSessionSocket* pSocket,
							BOOL&   eof )   {

	//
	//	All requests are passed to ProcessPacket so that
	//	we don't have threading issues dealing with these !
	//

	//
	//	Figure out if the source of this HANDLE stored it with a terminating
	//	CRLF.CRLF.  If it didn't, and nobody has specified a termination sequence -
	//	do so now !
	//
	if( !GetIsFileDotTerminated( pPacket->m_pFIOContext ) ) {
		static	char	szTerminator[] = "\r\n.\r\n" ;
		if( pPacket->m_buffers.Tail == 0 ) 	{
			pPacket->m_buffers.Tail = szTerminator ;
			pPacket->m_buffers.TailLength = sizeof( szTerminator ) - 1 ;
		}
	}


    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;

	pPacket->m_dwPassThruIndex = 2 ;

    eof = FALSE ;
    m_pWriteStream->ProcessPacket(  pPacket,    pSocket ) ;
    return  TRUE ;
}


BOOL
CIODriverSource::Init(	CChannel*	pSource,	
						CSessionSocket*	pSocket,	
						PFNSHUTDOWN	pfnShutdown,
						void*	pvShutdownArg,	
						CIODriver*		pOwnerDriver,
						CIOPassThru&	pIOReads,
						CIOPassThru&	pIOWrites,
						CIOPassThru&	pIOTransmits,
						unsigned	cbReadOffset,	
						unsigned	cbWriteOffset ) {


	//
	//	Let the CIOStream objects to most of the work og
	//	initialization.  Add a reference to our self so that the caller
	//	uses UnsafeClose() to destroy us.
	//

	ChannelValidate() ;

	AddRef() ;

	m_pfnShutdown = pfnShutdown ;
	m_pvShutdownArg = pvShutdownArg ;

	BOOL	fSuccess = TRUE ;
	fSuccess &= m_ReadStream.Init(
						CCHANNELPTR(pSource),
						*this,
						0,
						TRUE,
						pIOReads,
						pIOWrites,
						pIOTransmits,
						pSocket,
						cbReadOffset
						) ;
	if( fSuccess )
		fSuccess &= m_WriteStream.Init(
							CCHANNELPTR(pSource),
							*this,
							0,
							FALSE,
							pIOReads,
							pIOWrites,
							pIOTransmits,
							pSocket,
							cbWriteOffset
							) ;

#ifdef	CIO_DEBUG
	if( fSuccess )
		m_fSuccessfullInit = TRUE ;
#endif

	return	fSuccess ;
}

void
CIODriverSource::SetRequestSequenceno(	SEQUENCENO&	sequencenoRead,	
										SEQUENCENO&	sequencenoWrite ) {

	//
	//	Used when we want to match a CIODriverSource with a CIODriver which
	//	has already issued some packets, and we want all new requests to be
	//	properly routed through this CIODriverSource object.
	//

	ASSIGN( m_ReadStream.m_sequencenoNext,  sequencenoRead ) ;
	ASSIGN( m_WriteStream.m_sequencenoNext, sequencenoWrite) ;
}


BOOL
CIODriverSource::Start(	CIOPASSPTR&	pRead,	
						CIOPASSPTR&	pWrite,	
						CSessionSocket*	pSocket )  {

	//
	//	Given initial CIOPassThru derived objects start work !
	//

	ChannelValidate() ;

	BOOL	eof = FALSE ;
	BOOL	fSuccess = TRUE ;

	if( fSuccess && pRead ) {
		fSuccess &= pRead->Start( *this, pSocket, m_ReadStream.m_fAcceptRequests, m_ReadStream.m_fRequireRequests, 0 ) ;
		m_ReadStream.m_pIOCurrent = pRead ;
	}

	if( fSuccess && pWrite ) {
		fSuccess &= pWrite->Start( *this, pSocket, m_WriteStream.m_fAcceptRequests, m_WriteStream.m_fRequireRequests, 0 ) ;
		m_WriteStream.m_pIOCurrent = pWrite ;
	}
	return	fSuccess ;
}

void
CIODriverSource::CloseSource(
				CSessionSocket*	pSocket
				)	{

	UnsafeClose(	pSocket,	
					CAUSE_USERTERM	) ;

}




CHandleChannel::CHandleChannel()    :
	//
	//	Initialize a CHandleChannel object
	//
	m_cAsyncWrites( 0 ),
	m_handle( (HANDLE)INVALID_SOCKET ),
    m_lpv( 0 ),
	m_pPacket( 0 ),
	m_patqContext( NULL )
#ifdef	CIO_DEBUG
	,m_cbMax( 0x10000000 ),
	m_fDoDebugStuff( FALSE )
#endif
{
	TraceFunctEnter( "CHandleChannel::CHandleChannel" ) ;
	DebugTrace( (DWORD_PTR)this, "New Handle Channel size %d", sizeof( *this ) ) ;

	ChannelValidate() ;
}

#ifdef	CIO_DEBUG

//
//	The following code exists for debug purposes -
//	it lets us easily find out what the outstanding IO's may be when we
//	close a CChannel.
//
//


CChannel::CChannel()	{
	ZeroMemory( &m_pOutReads, sizeof( m_pOutReads ) ) ;
	ZeroMemory( &m_pOutWrites, sizeof( m_pOutWrites ) ) ;
}
void
CChannel::RecordRead( CReadPacket*	pRead ) {

	//
	//	Record that we've issued the specified CReadPacket
	//
	for( int i=0; i<sizeof( m_pOutReads ) / sizeof( m_pOutReads[0] ) ; i++ ) {
		if( m_pOutReads[i] == 0 )	{
			m_pOutReads[i] = pRead ;
			break ;
		}
	}
}
void
CChannel::RecordWrite( CWritePacket*	pWrite ) {

	//
	//	Record that we've issued the specified CWritePacket
	//

	for( int i=0; i<sizeof( m_pOutWrites ) / sizeof( m_pOutWrites[0] ) ; i++ ) {
		if( m_pOutWrites[i] == 0 )	{
			m_pOutWrites[i] = pWrite ;
			break ;
		}
	}
}
void
CChannel::RecordTransmit( CTransmitPacket*	pTransmit ) {
	//
	//	Record that we've issued the specified CTransmitPacket
	//

	for( int i=0; i<sizeof( m_pOutWrites ) / sizeof( m_pOutWrites[0] ) ; i++ ) {
		if( m_pOutWrites[i] == 0 )	{
			m_pOutWrites[i] = pTransmit ;
			break ;
		}
	}
}
void
CChannel::ReportPacket( CPacket*	pPacket ) {

	//
	//	Report the completion of a packet and remove it from our records.
	//

	for( int i=0; i<sizeof(m_pOutWrites ) / sizeof( m_pOutWrites[0] ); i++ ) {
		if( m_pOutWrites[i] == pPacket ) {
			m_pOutWrites[i] = 0 ;
			return ;
		}
	}		
	for( i=0; i<sizeof(m_pOutReads) / sizeof( m_pOutReads[0] ); i++ ) {
		if( m_pOutReads[i] == pPacket ) {
			m_pOutReads[i] = 0 ;
			return ;
		}
	}		
	//_ASSERT( 1==0 ) ;
	return	;
}
void
CChannel::CheckEmpty() {

	//
	//	Call this function when you think there should be no CPacket's pending -
	//	it will verify that they've all been reported.
	//

	for( int i=0; i<sizeof(m_pOutReads)/sizeof( m_pOutReads[0]); i++ ) {
		if( m_pOutReads[i] != 0 ) {
			_ASSERT( 1==0 ) ;
		}
	}
	for( i=0; i<sizeof(m_pOutWrites)/sizeof(m_pOutWrites[0]); i++ ) {
		if( m_pOutWrites[i]!=0 ) {
			_ASSERT( 1==0 ) ;
		}
	}
}
#endif

CHandleChannel::~CHandleChannel()       {
	
	//
	//	Close our atq Context if present.	
	//

	TraceFunctEnter( "CHandleChannel::~CHandleChannel" ) ;

	ChannelValidate() ;

	DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

#ifdef	CIO_DEBUG
	CheckEmpty() ;
#endif	

	if( m_patqContext )
		Close() ;

    _ASSERT( m_patqContext == 0 ) ;
    _ASSERT( m_handle == (HANDLE)INVALID_SOCKET ) ;
}

BOOL
CHandleChannel::Init(   BOOL	BuildBreak,
						HANDLE  h,
						void    *pSocket,
						void*	patqContext,
						ATQ_COMPLETION    pfn )       {

	//
	//	This initialization function will call the appropriate ATQ stuff
	//	to get us set up for Async IO.
	//

	TraceFunctEnter( "CHandleChannel::Init" ) ;
	ChannelValidate() ;

	m_lpv = (void*)pSocket ;
	if( patqContext ) {
		m_patqContext = (PATQ_CONTEXT)patqContext ;
		m_handle = h ;

		DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

		AtqContextSetInfo( m_patqContext, ATQ_INFO_COMPLETION, (DWORD_PTR)pfn ) ;
		AtqContextSetInfo( m_patqContext, ATQ_INFO_COMPLETION_CONTEXT, (DWORD_PTR)this )  ;
		return	TRUE ;
	}	else	{
		if( AtqAddAsyncHandle(
					&m_patqContext,
					NULL,				// No endpoint object for outbound sockets and file handles !
					this,
					pfn,
					INFINITE,
					h ) )       {
			m_handle = h ;

			DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

			return  TRUE ;
		}
	}

	DWORD	dwError = GetLastError() ;

	ErrorTrace( (DWORD_PTR)this, "Error calling AtqAddAsyncHandle - %x", dwError ) ;
    return  FALSE ;
}

void
CHandleChannel::Close(	)    {

	//
	//	Close our ATQ Context.
	//

	TraceFunctEnter( "CHandleChannel::Close" ) ;

	_ASSERT( m_handle == INVALID_HANDLE_VALUE ) ;

	ChannelValidate() ;

	DebugTrace( (DWORD_PTR)this, "Freeing m_patqContext %x", m_patqContext ) ;

    AtqFreeContext( m_patqContext, TRUE ) ;
    m_patqContext = 0 ;
}

void
CHandleChannel::CloseSource(	
					CSessionSocket*	pSocket
					)	{

	//
	//	This function closes our handle so that all pending IO's complete,
	//	however it does not discard the ATQ context yet.
	//

	TraceFunctEnter( "CHandleChannel::CloseSource" ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;

	DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

	HANDLE	h = (HANDLE)InterlockedExchangePointer( &m_handle, INVALID_HANDLE_VALUE ) ;

	if(	h != INVALID_HANDLE_VALUE )	{
		// BUGBUG - the handle should be closed by the message object, not
		// the protocol
		AtqCloseFileHandle( m_patqContext ) ;
		//	bugbug .... clean up this debug code someday !
		DWORD	dw = GetLastError() ;
	}
}

HANDLE
CHandleChannel::ReleaseSource()	{

	TraceFunctEnter(	"CHandleChannel::ReleaseSource" ) ;
	DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;
	HANDLE	h = (HANDLE)InterlockedExchangePointer( &m_handle, INVALID_HANDLE_VALUE ) ;
	return	h ;
}

#ifdef	CIO_DEBUG
void
CHandleChannel::SetDebug( DWORD	dw ) {
	m_fDoDebugStuff = TRUE ;
	m_cbMax = dw ;
}
#endif


CSocketChannel::CSocketChannel()	:
	m_fNonBlockingMode( FALSE ),
	m_cbKernelBuff( 0 ) {
}

BOOL
CSocketChannel::Init(	HANDLE	h,	
						void*	lpv,	
						void*	patqContext,
						ATQ_COMPLETION	pfn
						) {

	TraceFunctEnter( "CSocketChannel::Init" ) ;
	BOOL	fRtn = FALSE ;

	if(	CHandleChannel::Init( FALSE, h, lpv, patqContext, pfn ) ) {

		if( g_pNntpSvc->GetSockRecvBuffSize() != BUFSIZEDONTSET ) {

			int	i = g_pNntpSvc->GetSockRecvBuffSize() ;
			if( setsockopt( (SOCKET)h, SOL_SOCKET, SO_RCVBUF,
					(char *)&i, sizeof(i) ) != 0 ) {
				ErrorTrace( (DWORD_PTR)this, "Unable to set recv buf size %i",
						WSAGetLastError() ) ;
			}
		}
		if( g_pNntpSvc->GetSockSendBuffSize() != BUFSIZEDONTSET ) {

			int	i = g_pNntpSvc->GetSockSendBuffSize() ;
			if( setsockopt((SOCKET)h, SOL_SOCKET, SO_SNDBUF,
					(char*) &i, sizeof(i) ) != 0 )	{
			
				ErrorTrace( (DWORD_PTR)this, "Unable to set send buf size %i",
					WSAGetLastError() ) ;
			}
		}
		if( g_pNntpSvc->FNonBlocking() ) {
			ULONG	ul = 1 ;
			if( 0!=ioctlsocket( (SOCKET)h, FIONBIO, &ul ) )	{
				ErrorTrace( (DWORD_PTR)this, "Unable to set non blocking mode %i",
					WSAGetLastError() ) ;
			}	else	{
				m_fNonBlockingMode = TRUE ;
			}
		}

#if 0
		struct	linger	lingerData ;
		DWORD	cblinger = sizeof( lingerData ) ;

		if( 0!=getsockopt( (SOCKET)h, SOL_SOCKET, SO_LINGER, &lingerData, &cblinger ) ) {
			DWORD	dwError = WSAGetLastError() ;
			ErrorTrace( DWORD(this), "Unable to get linger info %d", dwError ) ;
		}

		lingerData.l_onoff = 1 ;
		lingerData.l_linger = 1 ;
		if( 0!=setsockopt( (SOCKET)h, SOL_SOCKET, SO_LINGER, &lingerData, sizeof( lingerData ) ) {
			DWORD	dwError = WSAGetLastError() ;
			ErrorTrace( DWORD(this), "Unable to set linger info %d", dwError ) ;
		}
#endif

		PNNTP_SERVER_INSTANCE pInst = (((CSessionSocket*)lpv)->m_context).m_pInstance ;
		AtqContextSetInfo( m_patqContext, ATQ_INFO_TIMEOUT, pInst->QueryConnectionTimeout() ) ;

		fRtn = TRUE ;
	}

	int		dwSize = sizeof( m_cbKernelBuff ) ;
	if( 0!=getsockopt( (SOCKET)h, SOL_SOCKET, SO_SNDBUF, (char*)&m_cbKernelBuff, &dwSize ) )	{
		ErrorTrace( (DWORD_PTR)this, "Unable to get new kernel send buf size %i",
				WSAGetLastError() ) ;
		m_cbKernelBuff = 0 ;
	}		

	return	fRtn ;
}

BOOL
CSocketChannel::Write(	CWritePacket*	pPacket,	
						CSessionSocket*	pSocket,	
						BOOL&	eof )	{

    _ASSERT( (void*)pSocket == m_lpv) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
	_ASSERT( !pPacket->m_fRead ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

	int	cb = pPacket->m_ibEndData - pPacket->m_ibStartData ;
#ifdef	CIO_DEBUG
	int	cbTemp = cb; // ((rand() > 16000) ? 2 : 1 ) ;
#endif
	int	count = 0 ;
	if( m_fNonBlockingMode && m_cAsyncWrites == 0 && cb < m_cbKernelBuff ) {

		count = send(	(SOCKET)m_handle,
						pPacket->StartData(),
#ifdef	CIO_DEBUG
						cbTemp,
#else
						cb,
#endif
						0 ) ;
		if( count == cb ) {
			//
			//	Complete the packet - it was succcessfully sent !!
			//
			pPacket->m_fRequest = FALSE ;
			pPacket->m_cbBytes = count ;			
			
			pPacket->m_pOwner->CompleteWritePacket( pPacket, pSocket ) ;
			return	TRUE ;
		}	else	if(	count > cb || count <= 0 )	{
			count = 0 ;
			if( WSAGetLastError() != WSAEWOULDBLOCK ) {
				return	FALSE ;
			}
		}
	}
	if( count != 0 ) {
		pPacket->m_cbBytes = count ;
	}
	InterlockedIncrement( &m_cAsyncWrites ) ;
	BOOL	fRtn = AtqWriteFile(	m_patqContext,
									pPacket->StartData()+count,
									cb-count,
									(LPOVERLAPPED)&pPacket->m_ovl.m_ovl ) ;
#ifdef	CIO_DEBUG
	DWORD	dw = GetLastError() ;
#endif
	return	fRtn ;
}	

void
CSocketChannel::CloseSource(
						CSessionSocket*	pSocket
						)	{

	//
	//	This function closes our socket so that all pending IO's (CPackets) complete.
	//

	TraceFunctEnter( "CSocketChannel::CloseSource" ) ;

	DebugTrace( (DWORD_PTR)this, "m_patqContext %x m_handle %x", m_patqContext, m_handle ) ;

	SOCKET	s = (SOCKET)InterlockedExchangePointer( (void**)&m_handle, (void*)INVALID_SOCKET ) ;
	if( s != INVALID_SOCKET )	{
		BOOL f = AtqCloseSocket(	m_patqContext, TRUE ) ;
		_ASSERT( f ) ;
	}
}

void
CSocketChannel::Timeout()	{

	static	char	szTimeout[] = "503 connection timed out \r\n" ;

	if( m_handle != INVALID_HANDLE_VALUE ) {
		send(	(SOCKET)m_handle,
					szTimeout,
					sizeof( szTimeout )-1,
					0 ) ;
	}
}

void
CSocketChannel::ResumeTimeouts()	{

	if( m_patqContext != 0 ) {
		AtqContextSetInfo( m_patqContext, ATQ_INFO_RESUME_IO, 0 ) ;
	}
}

BOOL
CHandleChannel::Read(   CReadPacket*    pPacket,
						CSessionSocket  *pSocket,
						BOOL    &eof )  {

	//
	//	Issue a CReacPacket
	//

	TraceFunctEnter( "CHandleChannel::Read" ) ;

	ChannelValidate() ;

    _ASSERT( (void*)pSocket == m_lpv) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    //_ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;

	DebugTrace( (DWORD_PTR)this, "Issuing IO to context %x handle %x packet %x pSocket %x",
			m_patqContext, m_handle, pPacket, pSocket ) ;


	// Calculate how big a read we can perform !!
	DWORD	cbToRead = pPacket->m_ibEnd - pPacket->m_ibStartData ;

	#ifdef	CIO_DEBUG
	RecordRead( pPacket ) ;
	if( m_fDoDebugStuff ) {
		cbToRead = min( m_cbMax, cbToRead ) ;
	}
	#endif

    eof = FALSE ;
    BOOL fRtn = AtqReadFile(    m_patqContext,
                    pPacket->StartData(),
                    cbToRead,
                    (LPOVERLAPPED)&pPacket->m_ovl.m_ovl
					) ;

    DWORD   dw = GetLastError() ;

	#ifdef	CIO_DEBUG
	if( !fRtn )
		ReportPacket( pPacket ) ;
	#endif

    return  fRtn ;
}

BOOL
CHandleChannel::Write(  CWritePacket*   pPacket,
						CSessionSocket  *pSocket,
						BOOL    &eof )  {

	//
	//	Issue a CWritePacket
	//

	TraceFunctEnter( "CHandleChannel::Write" ) ;

	ChannelValidate() ;

    _ASSERT( (void*)pSocket == m_lpv) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;

	DebugTrace( (DWORD_PTR)this, "Issuing IO to context %x handle %x packet %x pSocket %x",
			m_patqContext, m_handle, pPacket, pSocket ) ;

	#ifdef	CIO_DEBUG
	RecordWrite( pPacket ) ;
	#endif

    eof = FALSE ;
    BOOL	fRtn = AtqWriteFile(   m_patqContext,
                            pPacket->StartData(),
                            pPacket->m_ibEndData - pPacket->m_ibStartData,
                            (LPOVERLAPPED)&pPacket->m_ovl.m_ovl
							) ;

	#ifdef	CIO_DEBUG
	if( !fRtn )
		ReportPacket( pPacket ) ;
	#endif
	return	fRtn ;
}

BOOL
CHandleChannel::Transmit(   CTransmitPacket*    pPacket,
							CSessionSocket* pSocket,
							BOOL    &eof )  {

	//
	//	Issue a CTransmitPacket
	//

	ChannelValidate() ;

    _ASSERT( (void*)pSocket == m_lpv ) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;

    //LARGE_INTEGER   l ;
    //l.QuadPart = 0 ;
	DWORD dwBytesInFile = 0;

	_ASSERT( m_pPacket == 0 ) ;
	m_pPacket = pPacket ;

    eof = FALSE ;

	m_patqContext->Overlapped.Offset = pPacket->m_cbOffset ;
	// l.LowPart = pPacket->m_cbLength ;
	dwBytesInFile = pPacket->m_cbLength ;

	#ifdef	CIO_DEBUG
	RecordTransmit( pPacket ) ;
	#endif

#ifdef DEBUG
    DWORD   dwFileSize = GetFileSize( pPacket->m_pFIOContext->m_hFile, 0 );
#endif

	//
	//	Figure out if the source of this HANDLE stored it with a terminating
	//	CRLF.CRLF.  If it didn't, and nobody has specified a termination sequence -
	//	do so now !
	//
	if( !GetIsFileDotTerminated( pPacket->m_pFIOContext ) ) {
		static	char	szTerminator[] = "\r\n.\r\n" ;
		if( pPacket->m_buffers.Tail == 0 ) 	{
			pPacket->m_buffers.Tail = szTerminator ;
			pPacket->m_buffers.TailLength = sizeof( szTerminator ) - 1 ;
		}
	}

    BOOL	fRtn =   AtqTransmitFile(
								m_patqContext,
                                pPacket->m_pFIOContext->m_hFile,
                                dwBytesInFile, //l,
                                &pPacket->m_buffers, //&pPacket->m_ovl.m_ovl,
                                0 ) ;
	#ifdef	CIO_DEBUG
	if( !fRtn )
		ReportPacket( pPacket ) ;
	#endif
	return	fRtn ;
}

BOOL
CHandleChannel::IsValid()   {
    return  TRUE ;
}

void
CHandleChannel::Completion( CHandleChannel* pChannel,
							DWORD cb,
							DWORD dwStatus,
							ExtendedOverlap *povl ) {

	//
	//	Complete a packet - if an error occurred close the CIODriver.
	//

	CSessionSocket*	pSocket = (CSessionSocket*)pChannel->m_lpv ;
	TraceFunctEnter( "CHandleChannel::Completion" ) ;

	CPacket*	pPacket = 0 ;
	if( povl == 0 ) {
		//
		//	This is an ATQ generated timeout !!
		//
		pSocket->Disconnect( CAUSE_TIMEOUT, 0 ) ;
		return ;
	} else if( (OVERLAPPED*)povl == &pSocket->m_pHandleChannel->m_patqContext->Overlapped ) {
		pPacket = pSocket->m_pHandleChannel->m_pPacket ;
		pSocket->m_pHandleChannel->m_pPacket = 0 ;
		CopyMemory( &pPacket->m_ovl.m_ovl, &povl->m_ovl, sizeof( povl->m_ovl ) ) ;
	}	else	{
		pPacket = povl->m_pHome ;
	}
	if( dwStatus != 0 ) {
		DebugTrace( (DWORD_PTR)pSocket, "Error on IO Completion - %x pSocket %x", dwStatus, pSocket ) ;
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_NTERROR, dwStatus ) ;
	}	else	if( cb == 0 ) {
		DebugTrace( (DWORD_PTR)pSocket, "Zero BYTE IO Completion - %x pSocket %x", dwStatus, pSocket ) ;
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_USERTERM, 0 ) ;
	}
    _ASSERT( pPacket != 0 ) ;
    _ASSERT( pPacket->m_fRequest == TRUE ) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    pPacket->m_fRequest = FALSE ;
    pPacket->m_cbBytes += cb ;

	DebugTrace( 0, "Completing on Socket %x cb %d dwStatus %x povl %x pPacket %x",
		pSocket, cb, dwStatus, povl, pPacket ) ;


    if( pPacket->m_fRead )  {
		AddByteStat( ((pSocket->m_context).m_pInstance), TotalBytesReceived, pPacket->m_cbBytes ) ;
        pPacket->m_pOwner->m_pReadStream->ProcessPacket( pPacket, pSocket ) ;
    }   else    {
		AddByteStat( ((pSocket->m_context).m_pInstance), TotalBytesSent, pPacket->m_cbBytes ) ;
		InterlockedDecrement( &pChannel->m_cAsyncWrites ) ;
        pPacket->m_pOwner->m_pWriteStream->ProcessPacket( pPacket, pSocket ) ;
    }
}



CFileChannel::CFileChannel() :
	//
	//	Initialize a CFileChannel
	//	CFileChannel's do some extra work to keep track of where they
	//	are reading and writing in the file, hence the extra
	//	member variables such as m_cbInitialOffset.
	//	Initalize to all illegal values - user must call Init() before
	//	we'll work.
	//
	//
	m_cbInitialOffset( UINT_MAX ),
    m_cbCurrentOffset( UINT_MAX ),
	m_cbMaxReadSize( UINT_MAX ),
    m_fRead( FALSE ),
	m_pSocket( 0 ),
	m_pFIOContext( 0 ),
	m_pFIOContextRelease( 0 )
#ifdef  CIO_DEBUG
    ,m_cReadIssuers( 0 ),   m_cWriteIssuers( 0 )
#endif
{

	TraceFunctEnter( "CFileChannel::CFileChannel" ) ;
	DebugTrace( (DWORD_PTR)this, "New CFileChannel size %d", sizeof( *this ) ) ;
}

CFileChannel::~CFileChannel()	{
	if( m_pFIOContextRelease )
		ReleaseContext( m_pFIOContextRelease ) ;
}

BOOL
CFileChannel::Init( FIO_CONTEXT*	pFIOContext,
					CSessionSocket* pSocket,
					unsigned    offset,
 					BOOL    fRead,
					unsigned	cbMaxBytes
					) {

	//
	//	Initialize a CFileChannel -
	//	use CHandleChannel to do the grunt work of registering with ATQ,
	//	then figure out where we are in the file etc... and set up
	//	member variables so we start Reads and Writes at the write position.
	//
	//

	TraceFunctEnter( "CFileChannel::Init" ) ;

	ChannelValidate() ;

    _ASSERT( pFIOContext != 0 ) ;
	_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
    _ASSERT( pSocket != 0 ) ;
    _ASSERT( offset != UINT_MAX ) ;

	//
	//	Add a reference to the FIO_CONTEXT so that it does not disappear before
	//	we've completed all of our IO's !
	//
	AddRefContext( pFIOContext ) ;

	m_pFIOContext = pFIOContext ;
	m_pFIOContextRelease = pFIOContext ;
	m_fRead = fRead ;
	m_pSocket = pSocket ;
	m_cbCurrentOffset = m_cbInitialOffset = offset ;
	if( fRead ) 	{

		DWORD	cbHigh ;
		DWORD	cb = GetFileSizeFromContext( pFIOContext, &cbHigh ) ;
		if( cbMaxBytes == 0 ) {
			m_cbMaxReadSize = cb ;
		}	else	{
			_ASSERT( offset+cbMaxBytes <= cb ) ;
			m_cbMaxReadSize = min( offset + cbMaxBytes, cb ) ;
		}
	}

	DebugTrace( (DWORD_PTR)this, "Successfule Init - pSocket %x m_cbCurrentOffset %d",
		pSocket, m_cbCurrentOffset ) ;

    #ifdef  CIO_DEBUG
    m_cReadIssuers = -1 ;
    m_cWriteIssuers = -1 ;
    #endif
    return  TRUE ;
}

BOOL
CFileChannel::FReadChannel( )   {
	//
	//	Does this channel support Read()'s ?
	//
	ChannelValidate() ;

    _ASSERT( m_pFIOContext != 0 ) ;
	_ASSERT( m_pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
    _ASSERT( m_pSocket != 0 ) ;
    _ASSERT( m_cbCurrentOffset != UINT_MAX ) ;

    return  m_fRead ;
}

BOOL
CFileChannel::Reset(    BOOL    fRead,
								unsigned    cbOffset )  {

	//
	//	After this all Read(), Write()'s etc... will start at a new position
	//	in the file.
	//

	ChannelValidate() ;

    _ASSERT( m_pFIOContext != 0 ) ;
	_ASSERT( m_pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
    _ASSERT( m_pSocket != 0 ) ;
    _ASSERT( m_cbCurrentOffset != UINT_MAX ) ;


    m_fRead = fRead ;
    if( m_fRead )   {
		DWORD	cbHigh = 0 ;
		DWORD	cb = GetFileSizeFromContext( m_pFIOContext, &cbHigh ) ;
		m_cbMaxReadSize = cb ;
	}
    m_cbCurrentOffset = m_cbInitialOffset = cbOffset ;
    return  TRUE ;
}

void
CFileChannel::CloseSource(	CSessionSocket*	pSocket	)	{
	CloseNonCachedFile( m_pFIOContextRelease ) ;
}


FIO_CONTEXT*
CFileChannel::ReleaseSource()	{

	TraceFunctEnter(	"CHandleChannel::ReleaseSource" ) ;
	m_lock.ExclusiveLock() ;
	FIO_CONTEXT*	pContext = (FIO_CONTEXT*)InterlockedExchangePointer( (PVOID *)&m_pFIOContext, 0 ) ;
	m_lock.ExclusiveUnlock() ;

	DebugTrace( (DWORD_PTR)this, "p %x m_handle %x", pContext, pContext ? pContext->m_hFile : 0 ) ;
	return	pContext ;
}




void
CFileChannel::Close(    )   {

	//
	//	Use CHandleChannel to do the work.
	//

	ChannelValidate() ;

	TraceFunctEnter( "CFileChannel::CLose" ) ;
	
	//
	//	We have to do our own thing here - the FIO_Context should always be
	//	removed before this !
	//
	_ASSERT( m_pFIOContext == 0 ) ;



	DebugTrace( (DWORD_PTR)this, "Our size is %d ", sizeof( *this ) ) ;
}

BOOL
CFileChannel::Read( CReadPacket*    pPacket,
					CSessionSocket* pSocket,
					BOOL&   eof )   {

	//
	//	Issue a Read into the file.
	//	Setup the overlapped structures so that we get the
	//	correct bytes out of the file.
	//

	TraceFunctEnter( "CFileChannel::Read" ) ;

	ChannelValidate() ;

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedIncrement( &m_cReadIssuers ) == 0 ) ;
    #endif
    _ASSERT( m_fRead ) ;
    _ASSERT( pSocket == m_pSocket ) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	_ASSERT( m_pFIOContext != 0 ) ;
	_ASSERT( m_pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

#ifdef	_IMPLEMENT_LATER_
	_ASSERT( pPacket->m_pFileChannel == 0 ) ;
	pPacket->m_pFileChannel = this ;
#endif

    eof = FALSE ;

    pPacket->m_ovl.m_ovl.Offset = m_cbCurrentOffset ;
    unsigned    cb = pPacket->m_ibEnd - pPacket->m_ibStartData ;

    if( cb > (m_cbMaxReadSize - m_cbCurrentOffset) )    {
        cb = (m_cbMaxReadSize - m_cbCurrentOffset) ;
        eof = TRUE ;
    }
    m_cbCurrentOffset += cb ;

	DebugTrace( (DWORD_PTR)this, "Issuing IO to context %x packet %x pSocket %x",
			m_pFIOContext, pPacket, pSocket ) ;

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedDecrement( &m_cReadIssuers ) < 0 ) ;
    #endif

	pPacket->m_ovl.m_ovl.pfnCompletion = (PFN_IO_COMPLETION)CFileChannel::Completion ;
	pPacket->m_pFileChannel = this ;

	BOOL	fRtn = FALSE ;
	fRtn =	FIOReadFile(	m_pFIOContext,
							pPacket->StartData(),
							cb,
							&pPacket->m_ovl.m_ovl
							) ;

    DWORD   dw = GetLastError() ;
    return  fRtn ;
}

BOOL
CFileChannel::Write(    CWritePacket*   pPacket,
						CSessionSocket* pSocket,
						BOOL&  eof )   {

	//
	//	Issue a Write into the file.
	//	Setup the overlapped structures so that we get the
	//	correct bytes out of the file.
	//

	TraceFunctEnter( "CFileChannel::Write" ) ;

	ChannelValidate() ;

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedIncrement( &m_cWriteIssuers ) == 0 ) ;
    #endif
    _ASSERT( !m_fRead ) ;
    _ASSERT( pSocket == m_pSocket ) ;
    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Internal == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.InternalHigh == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset == 0 ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.OffsetHigh == 0 ) ;
	//_ASSERT( m_handle != INVALID_HANDLE_VALUE ) ;
	_ASSERT( pPacket->m_cbBytes == 0 ) ;

#ifdef	_IMPLEMENT_LATER_
	_ASSERT( pPacket->m_pFileChannel == 0 ) ;
	pPacket->m_pFileChannel = this ;
#endif

    eof = FALSE ;

    pPacket->m_ovl.m_ovl.Offset = m_cbCurrentOffset ;
    unsigned    cb = pPacket->m_ibEndData - pPacket->m_ibStartData ;
    m_cbCurrentOffset += cb ;

	DebugTrace( (DWORD_PTR)this, "Issuing IO to context %x packet %x pSocket %x",
			m_pFIOContext, pPacket, pSocket ) ;

    #ifdef  CIO_DEBUG
    _ASSERT( InterlockedDecrement( &m_cWriteIssuers ) < 0 ) ;
    #endif

	pPacket->m_ovl.m_ovl.pfnCompletion = (PFN_IO_COMPLETION)CFileChannel::Completion ;
	pPacket->m_pFileChannel = this ;

    BOOL    fRtn = FALSE ;
	fRtn =	FIOWriteFileEx(	m_pFIOContext,
							pPacket->StartData(),
							cb,
                            cb,
							&pPacket->m_ovl.m_ovl,
							pPacket->m_dwExtra2 == 1 ? TRUE : FALSE,
							TRUE
							) ;

    DWORD   dw = GetLastError() ;
    return  fRtn ;
}

BOOL
CFileChannel::Transmit( CTransmitPacket*    pPacket,
						CSessionSocket* pSocket,
						BOOL&   eof )   {

	//
	//	Cant do TransmitFile's into a file.
	//

	ChannelValidate() ;

    _ASSERT( 1==0 ) ;
    eof = FALSE ;
    return  FALSE ;
}

void
CFileChannel::Completion(	FIO_CONTEXT*	pFIOContext,
							ExtendedOverlap *povl,
							DWORD cb,
							DWORD dwStatus
							) {

	//
	//	Complete a CPacket which was issued against a file.
	//
	//

	TraceFunctEnter( "CFileChannel::Completion" ) ;

    if( dwStatus == ERROR_SEM_TIMEOUT ) return ;

    CPacket*    pPacket = povl->m_pHome ;

	CFileChannel*	pFileChannel = (CFileChannel*)pPacket->m_pFileChannel ;
	_ASSERT( pFileChannel != 0 ) ;
    //_ASSERT( pFileChannel->m_lpv == (void*)pFileChannel ) ;

    _ASSERT( pPacket != 0 ) ;
    _ASSERT( pPacket->m_fRequest == TRUE ) ;
    _ASSERT( pPacket->m_ovl.m_ovl.Offset >= pFileChannel->m_cbInitialOffset ) ;

	#ifdef	CIO_DEBUG

    //
    //  The calling CStream class will independently track
    //  each packets stream position.  We subtract cbInitialOffset
    //  so that these numbers should be in sync.
    //  This will be checked within the packet IsValidCompletion() functions.
    //
    pPacket->m_ovl.m_ovl.Offset -= pFileChannel->m_cbInitialOffset ;
    pPacket->m_ovl.m_ovl.Offset ++ ;

    //Sleep(    rand() / 1000 ) ;
    #endif
	if( dwStatus != 0 ) {
		DebugTrace( (DWORD_PTR)pFileChannel->m_pSocket, "Error on IO Completion - %x pSocket %x", dwStatus, pFileChannel) ;
		cb = 0 ;
		pPacket->m_pOwner->UnsafeClose( (CSessionSocket*)pFileChannel->m_pSocket, CAUSE_NTERROR, dwStatus ) ;
	}	else	if( cb == 0 ) {
		DebugTrace( (DWORD_PTR)pFileChannel->m_pSocket, "Zero BYTE IO Completion - %x pSocket %x", dwStatus, pFileChannel ) ;
		pPacket->m_pOwner->UnsafeClose( (CSessionSocket*)pFileChannel->m_pSocket, CAUSE_USERTERM, 0 ) ;
	}

    _ASSERT( pPacket->IsValidRequest( TRUE ) ) ;
    pPacket->m_fRequest = FALSE ;
    pPacket->m_cbBytes = cb ;

	DebugTrace( 0, "Completing on FileChannel %x cb %x dwStatus %x povl %x pPacket %x",
		pFileChannel, dwStatus, povl, pPacket ) ;

    if( pPacket->m_fRead )  {
        pPacket->m_pOwner->m_pReadStream->ProcessPacket( pPacket, pFileChannel->m_pSocket ) ;
    }   else    {
        pPacket->m_pOwner->m_pWriteStream->ProcessPacket( pPacket, pFileChannel->m_pSocket ) ;
    }
}

#if 0
BOOL
CIOFileChannel::Init(   HANDLE  hFileIn,
						HANDLE  hFileOut,
						CSessionSocket* pSocket,
						unsigned    cbInputOffset,
						unsigned    cbOutputOffset )    {
	
	//
	//	CIOFileChannel's use two CFileChannel's to support both
	//	directions of IO, and can use a separate file for each direction.
	//	This is usefull for debugging where you want to use a file to simulate
	//	a socket.
	//
	TraceFunctEnter( "CIOFileChannel::Init" ) ;

	ChannelValidate() ;

    if( !m_Reads.Init( hFileIn, pSocket, cbInputOffset, TRUE ) )
        return  FALSE ;

    if( !m_Writes.Init( hFileOut, pSocket, cbOutputOffset, FALSE ) )
        return  FALSE ;

	DebugTrace( (DWORD_PTR)this, "Successfull Initializeation size %d", sizeof( *this ) ) ;

    return  TRUE ;
}
#endif

BOOL
CIOFileChannel::Read(   CReadPacket*    pReadPacket,
						CSessionSocket* pSocket,
						BOOL    &eof )  {

	//
	//	Forward Read to appropriate member
	//

	ChannelValidate() ;

    return  m_Reads.Read(   pReadPacket,    pSocket,    eof ) ;
}

BOOL
CIOFileChannel::Write(  CWritePacket*   pWritePacket,
						CSessionSocket* pSocket,
						BOOL    &eof )  {
	//
	//	Forward Write to appropriate member
	//

	ChannelValidate() ;

    return  m_Writes.Write( pWritePacket,   pSocket, eof ) ;
}

BOOL
CIOFileChannel::Transmit(   CTransmitPacket*    pTransmitPacket,
							CSessionSocket* pSocket,
							BOOL    &eof )  {
	//
	//	Forward Transmit to appropriate member
	//

	ChannelValidate() ;

    return  m_Writes.Transmit(  pTransmitPacket,    pSocket,    eof ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\io.h ===
//
// io.h 
//
//	This file contains the classes implement socket IO used by the NNTP server.
//  We define classes to represent the following : 
//
//     struct OVLEXT - This is an extension to the NT OVERLAPPED structure which 
//        appends a pointer we can use to find NNTP Server data structures.
//
//     class CIO - A base class defining the interface for objects representing socket IO 
//	      operations.
//         
//        subclass CIORead - A subclass of CIO representing a socket read.
//        subclass CIOReadLine - A subclass of CIO representing a socket read which will not 
//                 complete until an entire line has been read.
//        etc.... See subclass definitions below.
//
//     Objects derived from CIO interoperate with three other objects : 
//     CSessionState's, and CBuffer's.
//
//     CSessionState represents the state of a client session.  When an IO object has 
//     completed all of the necessary operations, it will call a Complete function on the
//     CSessionState object.  The CSessionState Object can then create new IO objects
//     based on the state of the session.  
//
//  Implementation Schedule for all classes in this file : 
//      0.5 weeks
//
//  Unit Test Schedule for all classes in this file : 
//      These will be tested as part of the CSessionSocket unit testing.
//


#ifndef	_IO_H_
#define	_IO_H_


//
//	We require the following tigris class - CRefPtr, TLockQueue, CQElement 
//
#include	<limits.h>
#include	"atq.h"
#include	"filehc.h"
#include	"smartptr.h"
#include	"queue.h"
#include	"lockq.h"
#include	"cpool.h"
#include	"pcache.h"


#define	IN
#define	OUT
#define	INOUT

#ifndef	Assert
#define	Assert	_ASSERT
#endif

#ifdef	DEBUG
#define	CIO_DEBUG
#endif

//
// CPool Signature
//

#define CHANNEL_SIGNATURE (DWORD)'2597'


//---------------------------------------------------------
//
// Forward definitions
//
class	CSessionState ;
class	CIO ;
class	CIORead ;
class	CIOWrite ;
class	CIOPassThru ;
class	CChannel ;
class	CFileChannel ;
class	CIODriver ;
class	CIODriverSink ;
class	CBuffer ;
class	CPacket ;
class	CSessionSocket ;
class	CPacket ;
class	CRWPacket ;
class	CReadPacket ;
class	CWritePacket ;
class	CTransmitPacket ;
class	CControlPacket ;
class	CExecutePacket ;
#define	INVALID_SEQUENCENO	(-1)
#define	INVALID_STRMPOSITION	(-1)

#ifndef _X86_		// use LARGE_INTEGER on RISC to avoid alignment exception on __int64

typedef	LARGE_INTEGER		SEQUENCENO ;
typedef	LARGE_INTEGER		STRMPOSITION ;

#define QUAD(x)				(x).QuadPart
#define LOW(x)				(x).LowPart
#define HIGH(x)				(x).HighPart
#define ASSIGN(x,y)			(x).LowPart = (y).LowPart; (x).HighPart = (y).HighPart
#define ASSIGNI(x,y)		(x).LowPart = (y); (x).HighPart = 0
#define SETLO(x,y)			(x).LowPart = (y)
#define SETHI(x,y)			(x).HighPart = (y)
#define INC(x)				ADDI((x),1)
#define ADD( x, y )			if( ((x).LowPart) > ( ULONG_MAX - (ULONG)((y).LowPart) ) ) { (x).HighPart++;} (x).LowPart += (y).LowPart; (x).HighPart += (y).HighPart;
#define ADDI( x, y )		if( ((x).LowPart) > ( ULONG_MAX - (ULONG)(y) ) ) { (x).HighPart++;} (x).LowPart += (y)
#define DIFF( x, y, z )		(z).HighPart = (x).HighPart - (y).HighPart; (z).LowPart = (x).LowPart - (y).LowPart
#define GREATER(x,y)		(((x).HighPart == (y).HighPart) ? ((x).LowPart > (y).LowPart)  : ((x).HighPart > (y).HighPart))
#define LESSER(x,y)			(((x).HighPart == (y).HighPart) ? ((x).LowPart < (y).LowPart)  : ((x).HighPart < (y).HighPart))
#define EQUALS(x, y)		(((x).HighPart == (y).HighPart) ? ((x).LowPart == (y).LowPart) : FALSE)
#define EQUALSI(x, y)		(((x).HighPart) ? FALSE : ((x).LowPart == (y)))

#else	// use native __int64 for x86

typedef	__int64	SEQUENCENO ;
typedef	__int64 STRMPOSITION ;

#define QUAD(x)				(x)
#define LOW(x)				(x)
#define HIGH(x)				(x)
#define ASSIGN(x,y)			x = y
#define ASSIGNI(x,y)		x = y
#define SETLO(x,y)			x = y
#define SETHI(x,y)			x = y
#define INC(x)				x++
#define ADD( x, y )			x += y
#define ADDI( x, y )		x += y
#define DIFF( x, y, z )		z = x - y
#define GREATER(x,y)		(x > y)
#define LESSER(x,y)			(x < y)
#define EQUALS(x, y)		(x == y)
#define EQUALSI(x, y)		(x == y)

#endif

typedef	CRefPtr< CSessionState >	CSTATEPTR ;
typedef	CRefPtr< CSessionSocket >	CSESSPTR ;
typedef	CRefPtr< CBuffer >	CBUFPTR ;
typedef	CRefPtr< CChannel >	CCHANNELPTR ;
typedef	CRefPtr< CIODriver >	CDRIVERPTR ;
typedef	CRefPtr< CIODriverSink >	CSINKPTR ;
typedef	CRefPtr< CFileChannel >	CFILEPTR ;	
typedef	CSmartPtr< CIO >			CIOPTR ;
typedef	CSmartPtr< CIORead >		CIOREADPTR ;
typedef	CSmartPtr< CIOWrite >		CIOWRITEPTR ;
typedef	CSmartPtr< CIOPassThru >	CIOPASSPTR ;

typedef	TLockQueue<	CPacket	>	CPACKETQ ;
typedef	TOrderedList< CPacket >	CPACKETLIST ;

//
//	The CIO derived classes operate with all CIODriver 
//	classes defined in this file - to speed up allocation
//	of CIO objects we define some CIO helper classes here !
//

//
//	Constant used for CPool initialization - all CIO derived objects
//	come out of the same CPool - this is the size of the largest class !
//
extern	const	unsigned	cbMAX_IO_SIZE ;

//
//	Utility classes related to CIO - 
//	classes which let us use the CCache mechanisms to reduce 
//	thread contention when allocating CIO objects !
//
class	CCIOAllocator : public	CClassAllocator	{
//
//	This class wraps the CPool used to allocate CIO objects so that 
//	we can use the CCache classes for low contention allocation of CIO objects !
//
private : 
	//
	//	CIO knows us well
	//
	friend	class	CIO ;

	//
	//	CPool object used to allocate objects derived from CIO 
	//	
	static	CPool	IOPool ;

public : 

	CCIOAllocator() ;

	//
	//	Initialize our CPool !
	//
	static	BOOL	InitClass()	{
			return	IOPool.ReserveMemory( MAX_CHANNELS,	cbMAX_IO_SIZE ) ;
	} 

	//
	//	Terminate our CPool
	//
	static	BOOL	TermClass()	{
			_ASSERT( IOPool.GetAllocCount() == 0 ) ;
			return	IOPool.ReleaseMemory( ) ;
	}
	
	//
	//	The function which gets the memory we wish to use !
	//
	LPVOID	Allocate(	DWORD	cb,	DWORD	&cbOut = CClassAllocator::cbJunk ) {
				cbOut = cb ;	return	IOPool.Alloc() ;
	}

	//
	//	The function which releases allocated memory !
	//
	void	Release(	void*	lpv )	{	
				IOPool.Free( lpv ) ;	
	}

#ifdef	DEBUG
	void	Erase(	void*	lpv ) ;
	BOOL	EraseCheck(	void*	lpv ) ;
	BOOL	RangeCheck( void*	lpv ) ;
	BOOL	SizeCheck(	DWORD	cb ) ;
#endif

} ;

extern	CCIOAllocator	gCIOAllocator ;

class	CCIOCache	:	public	CCache	{
//
//	This class actually cache's CIO objects in the 
//	hopes that we can reduce contention against our allocator !
//
private: 
	//
	//	Keep a pointer to the CClassAllocator derived object
	//	which manages the CPool for us !
	//
	static	CCIOAllocator*	gpCIOAllocator ;

	//
	//	space to hold cache'd pointers
	//
	void*	lpv[3] ;

public : 
	//
	//	Set static pointer - can not fail !
	//
	static	void	InitClass( CCIOAllocator*	pCIOAllocator  )	{
			gpCIOAllocator = pCIOAllocator ;
	}

	//
	//	Create a cache - just let CCache do the work !
	//
	inline	CCIOCache()	:	CCache( lpv, 3 )	{}

	//
	//	Release everything that may have been in the cache !
	//
	inline	~CCIOCache()	{	Empty( gpCIOAllocator ) ;	}

	//
	//	Free a CIO objects memory to the cache if possible 
	//	
	inline	void	Free( void*	lpv )	{	CCache::Free( lpv, gpCIOAllocator ) ;	}

	//
	//	Allocate memory from the cache if possible !
	//
	inline	void*	Alloc(	DWORD	size, DWORD&	cbOut = CCache::cbJunk )	{
			return	CCache::Alloc( size, gpCIOAllocator, cbOut ) ;
	}
} ;




struct	ExtendedOverlap	{
//
//	The ExtendedOverlap structure is used by completion port threads
//	to find the CPacket Derived class which represents the IO just completed.
//	This structure will be embedded in all CPacket objects
//

	//
	//	overlapped structure passed to Atq
	//
	FH_OVERLAPPED	m_ovl ;

	//
	//	Pointer to the packet this is embedded in
	//
	CPacket*	m_pHome ;

	//
	//	Default constructor NULLS stuff out
	//
	inline	ExtendedOverlap() ;
} ;

#define	ChannelValidate()	

class	CChannel : public	CRefCount	{
//
//	This class defines the interface to be followed by 
//	derived classes for doing async IO.  The interface takes
//	packets with embedded overlapped structures which are then
//	passed to a NT Async IO call, or to a sockets call, depending
//	on what the derived class represents.
//
private : 
	//
	//	CPool for handling all allocations 
	//
	static	CPool	gChannelPool ;		// used for allocating all such objects !!

	//
	//	Debug information - the following members and functions
	//	can be used to keep track of pending IO operations.
	//
#ifdef	CIO_DEBUG
public :
	CPacket*		m_pOutReads[6] ;
	CPacket*		m_pOutWrites[6] ;

	void	RecordRead(	CReadPacket*	pRead ) ;
	void	RecordWrite(	CWritePacket*	pWrite ) ;
	void	RecordTransmit(	CTransmitPacket*	pTransmit ) ;
	void	ReportPacket(	CPacket*	pPacket ) ;
	void	CheckEmpty() ;
	CChannel() ;
#endif

public :

	//
	//	Must have a virtual destructor as these are destroyed thru pointers
	//
	virtual	~CChannel() ;

	//
	//	Derived classes will use this to cache packets 
	//
	void	DestroyPacket( CPacket *p ) ;

	//
	//	Interfaces to determine the capacity of a Channel
	//	
	virtual	BOOL	FReadChannel( ) ;
	virtual	BOOL	FSupportConnections() ;	// By Default Return TRUE Always
	virtual	BOOL	FRequiresBuffers() ;

	//
	//	Determine how much space is being reserved in the packets that
	//	are being issued.  Typically space is being reserved so that 
	//	a filter (ie SSL) can do in place modifications (encryption) of the data.
	//
	virtual	void	GetPaddingValues(	unsigned	&cbFront,	unsigned	&cbTail ) ;

	//
	//	Close the underlying handle
	//
	virtual	void	CloseSource(	
							CSessionSocket*	pSocket	
							) ;

#ifdef	CIO_DEBUG
	virtual	void	SetDebug( DWORD	dw ) ;
#endif

	//
	//	Class Initialization - reserve CPool Memory
	//
	static	BOOL	InitClass() ;

	//
	//	Class Termination - release CPool Memory
	//	
	static	BOOL	TermClass() ;

	//
	//	Allocate memory for Channel's from CPool
	//
	inline	void*	operator	new( size_t	size ) ;

	//
	//	Release CChannel's memory to CPool
	//
	inline	void	operator	delete( void *pvv ) ;

	//
	//	The following interface is used to issue IO operations against a channel
	//

	//
	//	Issue an async read - CReadPacket contains the overlapped structure
	//
	virtual	BOOL	Read(	CReadPacket*,	CSessionSocket*, BOOL &eof ) = 0 ;

	//
	//	Issue a sync or async write.  Regardless of how the write is handled
	//	the completion should happen as if async.
	//	(ie. for CSocketChannel's where we may optimize writes by doing 
	//	blocking writes)
	//
	virtual	BOOL	Write( CWritePacket*,	CSessionSocket*, BOOL &eof ) = 0 ;

	//
	//	Issue an async TramsitFile
	//
	virtual	BOOL	Transmit(	CTransmitPacket*,	CSessionSocket*, BOOL &eof ) = 0 ;

	//
	//	Send timeout message to remote end !
	//
	virtual	void	Timeout( ) ;

	//
	//	Make sure Timeout processing continues
	//	
	virtual	void	ResumeTimeouts() ;

} ;


#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC(	CChannel ) 

#endif


//	@class	The CHandleChannel class manages generic NT Handles and allows us to issue 
//	all operations against them (EXCEPT Transmit())
//
//
class	CHandleChannel : public	CChannel	{
protected : 
	//
	//	Number of async writes.  For derived classes which wish to optimize writes
	//	by mixing async and sync versions.
	//
	long	m_cAsyncWrites ;	

	//
	//	The NT handle (Socket of File handle)
	//
	HANDLE	m_handle ;		// NT Handle

	//
	//	m_lpv holds a 'context' that we will pass to ProcessPacket when completing packets.
	//	(this is usually a CSessionSocket pointer)
	//
	void	*m_lpv ;

	//
	//	If a TransmitFile is issued we have to hack around Gibraltars poor support in AtqTransmitFile
	//	this is used for that
	//
	CTransmitPacket*	m_pPacket ;

	//
	//	The ATQ context we are using.
	//
	PATQ_CONTEXT	m_patqContext ;		// ATQ Context 
	//	The follwoing is the completion function we pass to ATQ
	friend	VOID ServiceEntry( DWORD cArgs, LPWSTR pArgs[], PTCPSVCS_GLOBAL_DATA    pGlobalData );	

	//
	//	Function we register with ATQ to get completion notifications.
	//
	static	void	Completion( CHandleChannel*, 
								DWORD cb, 
								DWORD dwStatus, 
								ExtendedOverlap *peo 
								) ;
#ifdef	CIO_DEBUG
	BOOL	m_fDoDebugStuff ;
	DWORD	m_cbMax ;
#endif
public :
	CHandleChannel() ; 
	~CHandleChannel() ;

	//
	//	Init sets up the Atq completion context and gets us ready to go
	//
	virtual	BOOL	Init(	BOOL	BuildBreak,
							HANDLE	h,	
							void	*lpv, 
							void *patqContext = 0,
							ATQ_COMPLETION pfn = (ATQ_COMPLETION)CHandleChannel::Completion 
							) ;

	//
	//	Close() merely releases our Atq context stuff
	//
	virtual	void	Close() ;

	//
	//	CloseSource() will close the underlying handle and force IO's to complete
	//
	void			CloseSource(	
							CSessionSocket*	pSocket 
							) ;

	//
	//	ReleaseSource() will give us the handle for our use, and will enable us to 
	//	tear things down without invalidating the handle
	//
	HANDLE			ReleaseSource() ;

	//
	//	For debug - check everything looks good.
	//
	virtual	BOOL	IsValid() ;

#ifdef	CIO_DEBUG
	void	SetDebug(	DWORD	dw ) ;

#endif

	//
	//	Map CReadPackets onto calls to AtqRead()
	//
	BOOL	Read(	CReadPacket*, CSessionSocket*, BOOL &eof ) ;
	
	//
	//	Map CWritePackets onto calls to AtqWriteFile()
	//
	BOOL	Write(	CWritePacket*,	CSessionSocket*, BOOL &eof ) ;

	//
	//	Map CTransmitPackets onto calls to AtqTransmitFile
	//
	BOOL	Transmit(	CTransmitPacket*,	CSessionSocket*, BOOL &eof ) ;
} ;

//
//	CSocketChannel - 
//	This is used to manage IO to a socket.
//	Our main addition beyond what CHandleChannel does is to provide support for 
//	mixing synchronous and async writes - NOTE : CIODriver as an extra function 
//	CompleteWritePacket which also helps to support sync. writes.
//
class	CSocketChannel	:	public	CHandleChannel	{
private : 
	//
	//	Are we doing Non blocking writes ?
	//
	BOOL	m_fNonBlockingMode ;

	//
	//	Size of the kernel buffers for this socket
	//
	int		m_cbKernelBuff ;
public : 	
	CSocketChannel() ;
	void			CloseSource(
							CSessionSocket*	pSocket
							) ;

	//
	//	Must initialize before use.  We use the same completion function as CHandleChannel.
	//
	BOOL	Init( HANDLE	h,	void	*lpv, void *patqContext = 0,
						ATQ_COMPLETION pfn = (ATQ_COMPLETION)CHandleChannel::Completion ) ;

	//
	//	Override Write() so that we can try blocking IO.
	//
	BOOL	Write(	CWritePacket*,	CSessionSocket*	pSocket,	BOOL&	eof ) ;

	//
	//	Do a blocking send of our Timeout() message.
	//
	void	Timeout() ;

	//
	//	Multiple IO's to gibraltar can cause timeouts to be lost - use this to recover that.
	//
	void	ResumeTimeouts() ;
} ;

//
//	CFileChannel - 
//	this class manages one direction of flow to a NT File.
//	(ie. you can only use it for Reads, or Writes but not both !!)
//
class	CFileChannel	:	public	CChannel	{
private : 
	//
	//	Number of async writes.  For derived classes which wish to optimize writes
	//	by mixing async and sync versions.
	//
	long	m_cAsyncWrites ;	

	//
	//	m_lpv holds a 'context' that we will pass to ProcessPacket when completing packets.
	//	(this is usually a CSessionSocket pointer)
	//
	void	*m_lpv ;

	//
	//	This holds the File Cache Context that we use to do operations !
	//
	FIO_CONTEXT*	m_pFIOContext ;

	//
	//	This holds the File Cache Context that we release in our destruction !
	//
	FIO_CONTEXT*	m_pFIOContextRelease ;

	//
	//	Initial byte offset within the file that we will start reading 
	//	or writing
	//
	unsigned	m_cbInitialOffset ;
	
	//
	//	Current position in the file - we track this as we will modify
	//	the OVERLAPPED structure of async IO's against a file to specify
	//	exactly where the IO should happen
	//
	unsigned	m_cbCurrentOffset ;

	//
	//	Maximum number of bytes we can transfer to/from the file
	//
	unsigned	m_cbMaxReadSize ;

	//
	//	Socket associated with all this IO
	//
	CSessionSocket*	m_pSocket ;

	//
	//	Are we Reading or Writing to the file ?
	//
	BOOL		m_fRead ;

	//
	//	This lock protects access to m_pFIOContext !
	//
	CShareLockNH	m_lock ;

	
#ifdef	CIO_DEBUG
	long		m_cReadIssuers ;		// Number of people doing read operations
	long		m_cWriteIssuers ;		// Number of people doing Write operations
#endif	// CIO_DEBUG

	//	We use our own completion function !!
	static	void	Completion(	FIO_CONTEXT*	pFIOContext, 
								ExtendedOverlap *peo,
								DWORD cb, 
								DWORD dwStatus
								) ;
public :
	CFileChannel() ;
	~CFileChannel() ;
	
	//
	//	Init function - set up ATQ context etc...
	//	NOTE : cbOffset lets us reserve space in the front of the file when doing writes, 
	//	or start reads from an arbitrary position.
	//
	BOOL	Init(	FIO_CONTEXT*	pContext,	
					CSessionSocket*	pSocket, 
					unsigned	cbOffset,	
					BOOL	fRead  = TRUE,
					unsigned	cbMaxBytes = 0
					) ;

	//
	//	CloseSource() will close the underlying handle and force IO's to complete
	//
	void			
	CloseSource(	
			CSessionSocket*	pSocket 
			) ;

	//
	//	File Channels manage these FIO_CONTEXT structures
	//	instead of ATQ thing'a'ma'jigs.
	//
	FIO_CONTEXT*
	ReleaseSource() ;

	//
	//	Closing CFileChannel's needs special work as ATQ is setup to only handle sockets.
	//
	void	Close() ;
	BOOL	FReadChannel( ) ;

	//
	//	Get initial file offset
	//
	DWORD	InitialOffset()		{	return	m_cbInitialOffset ;	}

	//
	//	Reset() lets us start reading from the beginning again.
	//
	BOOL	Reset(	BOOL	fRead,	unsigned	cbOffset = 0 ) ;

	//
	//	Read and Write to the file.
	//
	BOOL	Read(	
					CReadPacket*, 
					CSessionSocket*,	
					BOOL	&eof 
					) ;

	BOOL	Write(	
					CWritePacket*,	
					CSessionSocket*, 
					BOOL	&eof 
					) ;

	//
	//	TransmitFile is non-functional for CFIleChannel's
	//
	BOOL	Transmit(	
					CTransmitPacket*,	
					CSessionSocket*,	
					BOOL	&eof 
					) ;

	//
	//	Map down to NT's FlushFileBuffers()
	//
	inline	void	FlushFileBuffers() ;
} ;


#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CFileChannel ) 

#endif


//
//	CIOFileChannel - 
//	Contains two CFileChannel's, can two file IO's in both
//	directions - would be weird if done at same time !
//
class	CIOFileChannel	:	public	CChannel	{
private : 
	CFileChannel	m_Reads ;
	CFileChannel	m_Writes ;
public : 

	BOOL	Init(	HANDLE	hFileIn,	HANDLE	hFileOut,	CSessionSocket*	pSocket, 
						unsigned cbInputOffset = 0, unsigned cbOutputOffset=0 ) ;
	BOOL	Read(	CReadPacket*,	CSessionSocket*,	BOOL	&eof ) ;
	BOOL	Write(	CWritePacket*,	CSessionSocket*,	BOOL	&eof ) ;
	BOOL	Transmit(	CTransmitPacket*,	CSessionSocket*,	BOOL	&eof ) ;
} ;



//
//	Enumerate the possible reasons a session can be torn down.
//
enum	SHUTDOWN_CAUSE	{
	CAUSE_UNKNOWN = 0,
	CAUSE_FORCEOFF,			// Admin is trying to shut us down
	CAUSE_ILLEGALINPUT,		// We got stuff that we can't make sense of 
	CAUSE_USERTERM,			// User terminated politely (ie. quit command.)
	CAUSE_TIMEOUT,			// Session Timed Out
	CAUSE_LEGIT_CLOSE,		// Somebody killed it for a good reason !
	CAUSE_NODATA,			// Killed for a good reason, but before we accomplished anything
	CAUSE_IODRIVER_FAILURE,	// A CIODriver object failed to initialize
	CAUSE_PROTOCOL_ERROR,	// We got a bad return code upon issuing a NNTP command
	CAUSE_OOM,				// Out of Memory
	CAUSE_NTERROR,			// Hit an error on a call to NT 
	CAUSE_NORMAL_CIO_TERMINATION,	// For use by CIO objects which want to know when they're dieing gracefully !!
	CAUSE_FEEDQ_ERROR,		// Hit an error processing the feed Queue
	CAUSE_LOGON_ERROR,		// We were unable to logon to remote server!
	CAUSE_CIOREADLINE_OVERFLOW,	//	CIOReadLine was given too much data - the command line is too long !
	CAUSE_ARTICLE_LIMIT_EXCEEDED,	// A CIOReadArticle got more bytes for an article than the server allows !
	CAUSE_ENCRYPTION_FAILURE,	// Failed to encrypt something
	CAUSE_ASYNCCMD_FAILURE,		// Something went wrong with an Async Command !
	CAUSE_SERVER_TIMEOUT	// A Timeout occurred on a session we initiated - don't send 502 Timeout !!
} ;



class		CStream	{
//
//	This class keeps track of one direction of IO.
//	ie. We can use this to keep track of all the reads we are issuing, or we may use this to keep
//	track of all the rights we are issuing (to either a socket or a file).
//
//
private : 
	friend	class	CControlPacket ;
	CStream() ;		// Not allowed to build these without providing ID !
public : 
	//
	//	like these up front just for convenience of debugging
	//
	unsigned	m_index ;
	unsigned	m_age ;
	CDRIVERPTR	m_pOwner ;			// The CIODriver derived object we are contained in !
protected : 
	inline	CStream( unsigned	index	) ;	// Derive classes may construct 
	virtual		~CStream( ) ;
	#ifdef	CIO_DEBUG
	DWORD		m_dwThreadOwner ;		// The threadid of the thread processing packets
	long		m_cThreads ;			// Only one thread can be processing Packets
	long		m_cSequenceThreads ;	// Only one thread can be assigning outgoing sequence numbers
	#endif	// CIO_DEBUG

	#ifdef	CIO_DEBUG
	long		m_cThreadsSpecial ;	//Number of threads attempting to use special packet !!
	long		m_cNumberSends ;
	#endif
	CControlPacket*	m_pSpecialPacket ;	// Special Packet reserved for doing control operations !!!
	CControlPacket*	m_pSpecialPacketInUse ;

	long			m_cShutdowns ;		// Count of the number of times we have tried to shutdown the stream.
	CControlPacket*	m_pUnsafePacket ;	// Special Packet reserved for closing the session down - for use by
										// forcefull shutdowns only.
	CControlPacket*	m_pUnsafeInuse ;
	BOOL		m_fTerminating ;

	// The following memeber variables are common to both CIOStream and CIStream !!!!
	// The usage of these is slightly different, see the ProcessPacket calls !!
	BOOL		m_fRead ;		// If TRUE then only read and control packets can be issued
								// If False then only writes, transmits and control packets can be issued
	BOOL		m_fCreateReadBuffers ;	// If TRUE then we must allocate a Buffer for all CReadPackets which 
								// we pass to the m_pSouceChannel !
	CPACKETQ	m_pending ;		// The Queue of recently IO operations
	CPACKETLIST	m_completePackets ;		// A list sorted by sequenceno used to order packet arrival
	SEQUENCENO	m_sequencenoIn ;// The sequenceno of the packet we are waiting for
	STRMPOSITION	m_iStreamIn ;	// The stream position of the next packet we are waiting for
	SEQUENCENO	m_sequencenoOut ;	// The sequenceno of the next packet we will issue
	CCHANNELPTR	m_pSourceChannel ;	// The channel to which we forward Read, Write and Transmit operations
	unsigned	m_cbFrontReserve ;	// Padding to save in front of buffers for SourceChannel's benefit
	unsigned	m_cbTailReserve ;	// Padding to save in tail of buffers for SourceChannel's benefit
	void		CleanupSpecialPackets() ;

public : 

	//
	//	The interface below corresponds very closely to the interface for CIODriver.
	//	
	//	A CIODriver will forward each call to 1 of 2 CStream derived objects.
	//	(Depending on whether a request is a read or a write.)
	//

	virtual	BOOL	IsValid() ;	// Can only be called after calling Child Initialization


	BOOL	Init(	CCHANNELPTR&	pChannel, 
					CIODriver	&driver, 
					BOOL fRead, 
					CSessionSocket* pSocket, 
					unsigned	cbOffset,
					unsigned	cbTrailer = 0 
					) ;

	//
	//	When we want to set up an extra layer of processing - ie.
	//	SSL encryption, use this to get it going.
	//
	void	InsertSource(	
					class	CIODriverSource&	source, 
					CSessionSocket*	pSocket, 
					unsigned	cbAdditional,
					unsigned	cbTrailer
					) ;

	virtual	BOOL	Stop( ) ;

	//
	//	ProcessPacket - this function will do everything to make sure IO's are processed in the 
	//	correct order etc... For any packet that has completed
	//
	virtual	void	ProcessPacket(	
						CPacket*	pPacket,	
						CSessionSocket*	pSocket 
						) = 0 ;

	//
	//	The following functions will call the appropriate 
	//	function in the source channel interface
	//	(Read() or Write() or Transmit() derived from CChannel).
	//	The main thing they do to the packet before doing this
	//	is to give the packet a sequence number to ensure
	//	IO's are processed in the correct order upon completion.
	//
	
	//
	//	Call Read() on the underlying CChannel object
	//
	inline	void	IssuePacket( 
						CReadPacket	*pPacket,	
						CSessionSocket*	pSocket,	
						BOOL&	eof 
						) ;

	//
	//	Call Write() on the underlying CChannel object
	//
	inline	void	IssuePacket( 
						CWritePacket	*pPacket,	
						CSessionSocket*	pSocket,	
						BOOL&	eof 
						) ;

	//
	//	Call Transmit() on the underlying CChannel object
	//
	inline	void	IssuePacket( 
						CTransmitPacket	*pPacket,	
						CSessionSocket*	pSocket,	
						BOOL&	eof 
						) ;

	//
	//	The following functions should be the only way that Packet's are created - 
	//	they initialize the packets correctly so that all our reference counting etc...
	//	will be correct.	
	//	They also take care that if the underlying CChannel is doing extra
	//	processing (ie. encryption) that the packet is set up so this can
	//	be done in place.
	//

	//
	//	Create a Read that can hold at least cbRequest bytes
	//
	CReadPacket*	CreateDefaultRead(	
						CIODriver&,	
						unsigned	int	cbRequest
						) ;

	//
	//	Create a write using the specified buffer and offsets 
	//
	CWritePacket*	CreateDefaultWrite(	
						CIODriver&,	
						CBUFPTR&	pbuffer,	
						unsigned	ibStart,		
						unsigned	ibEnd,
						unsigned	ibStartData,	
						unsigned	ibEndData
						) ;

	//
	//	Create a write that will hold at least cbRequest bytes
	//
	CWritePacket*	CreateDefaultWrite(	
						CIODriver&,	
						unsigned	cbRequest 
						) ;

	//
	//	Create a Transmit packet that will hold use the specified file
	//
	CTransmitPacket*	CreateDefaultTransmit(	
							CIODriver&,	
							FIO_CONTEXT*	pFIOContext,	
							unsigned	ibOffset,	
							unsigned	cbLength 
							) ;

	//
	//	This function will build a control packet which will get the CIO object started.
	//
	inline	BOOL	SendIO(	
							CSessionSocket*	pSocket,	
							CIO&	pio,	
							BOOL	fStart 
							) ;

	//
	//	This function will prepare a control packet for our use !
	//
	inline	CControlPacket*	
					PrepForSendIO(
							CSessionSocket*	pSocket, 
							CIO&	pio,
							BOOL	fStart
							) ;

#ifdef	RETIRED
	inline	void	Shutdown(	CSessionSocket*	pSocket, BOOL	fCloseSource = TRUE ) ;
#endif

	//
	//	Whenever we want to wind down processing call UnsafeShutdown().  This will 
	//	ensure that all our packets etc... are destroyed etc...
	//
	inline	void	UnsafeShutdown( 
							CSessionSocket*	pSocket, 
							BOOL fCloseSource = TRUE 
							) ;

	//
	//	Release the current CIO object and set the state so all pending packets
	//	are swallowed
	//
	virtual	void	SetShutdownState(	
							CSessionSocket*	pSocket, 
							BOOL fCloseSource 
							) = 0 ;


	//
	//	The following functions are used to setup SSL sessions.
	//
	inline	CChannel&	GetChannel()	{	return	*m_pSourceChannel ; }
	inline	unsigned	GetFrontReserve()	{	return	m_cbFrontReserve ; }
	inline	unsigned	GetTailReserve()	{	return	m_cbTailReserve ; }	
	inline	void		ResumeTimeouts()	{	if( m_pSourceChannel != 0 ) { m_pSourceChannel->ResumeTimeouts() ; } }

#ifdef	CIO_DEBUG
	void	SetChannelDebug( DWORD	dw ) ;
#endif
} ;


class		CIOStream : public	CStream 	{
//
//	A CIOStream object is for use in CIODriverSource objects - such an object
//	processes both request and completion packets.
//
	friend	class	CControlPacket ;
public : 
	CPACKETLIST	m_requestPackets ;
	CPACKETLIST	m_pendingRequests ;	// list of request packets
	SEQUENCENO	m_sequencenoNext ;
	BOOL		m_fAcceptRequests ;
	BOOL		m_fRequireRequests ;

	//
	//	Index 0 - reads
	//	Index 1 - writes
	//	Index 2 - TransmitFiles
	//
	CIOPASSPTR	m_pIOFilter[3] ;

	//CPacket*	m_pCurRequest ;		// The current request packet !
	class	CIODriverSource*	m_pDriver ;
	//class	CSessionSocket*		m_pSocket ;
public : 

	CIOStream(	
				class	CIODriverSource*	pDriver,	
				unsigned	index	
				) ;

	~CIOStream() ;

	BOOL	IsValid() ;			// Can only be called after Initialization

	//
	//	There is only one current CIOPassThru object.
	//
	CIOPASSPTR	m_pIOCurrent ;

	//
	//	Initialize a CIOStream object
	//
	BOOL	Init( 
				CCHANNELPTR&	pChannel, 
				CIODriver	&driver, 
				CIOPassThru* pInitial, 
				BOOL fRead, 
				CIOPassThru&	pIOReads,
				CIOPassThru&	pIOWrites,
				CIOPassThru&	pIOTransmits,
				CSessionSocket* pSocket, 
				unsigned	cbOffset 
				) ;

	//
	//	Process a completed IO or a control packet
	//
	void	ProcessPacket( 
				CPacket*	pPacket, 
				CSessionSocket*	pSocket 
				) ;

	//
	//	Set the Stream into a state which will swallow all IO's
	//	and eventually destroy the object.
	//
	void	SetShutdownState(	
				CSessionSocket*	pSocket, 
				BOOL fCloseSource 
				) ;
} ;


class	CIStream : public CStream	{
//
//	A CIStream object if for use by CIODriverSink objects - such an object processes
//	only completions
//

public : 
	friend	class	CControlPacket ;

	//
	//	There is only every 1 CIO operation current
	//
	CIOPTR		m_pIOCurrent ;

	CIStream(	unsigned	index	) ;
	~CIStream( ) ;

	//
	//	Initialize a CIStream has one of two directions
	//	(outbound data - writes and transmitfiles, inbound - reads)
	//
	BOOL	Init( 
					CCHANNELPTR&	pChannel, 
					CIODriver	&driver, 
					CIO* pInitial, 
					BOOL fRead, 
					CSessionSocket* pSocket, 
					unsigned	cbOffset,
					unsigned	cbTrailer = 0
					) ;

	//
	//	Process an IO completion 
	//
	void	ProcessPacket( 
					CPacket*	pPacket,	
					CSessionSocket*	pSocket 
					) ;

	//
	//	Set the current CIO to something that will eat all remaining IO,
	//	and prepare the CIODriver for its doom
	//
	void	SetShutdownState(	
					CSessionSocket*	pSocket, 
					BOOL fCloseSource 
					) ;
} ;



//
//	Shutdown Notification function - 
//	This is the signature of the function a CIODriver will
//	call when it is about to be destoyed.
//	CSessionSocket's and others use this to figure out 
//	when to do their own destruction.
//
typedef	void	(*	PFNSHUTDOWN)(	
						void*,	
						SHUTDOWN_CAUSE	cause,	
						DWORD	dwOptionalError 
						) ;



//
//	The CIODriver class is a base class derived from CChannel which is used
//	to build objects which process IO Completions AND also want to issue operations
//	against this object !!
//
class	CIODriver : public	CChannel	{
private: 
	//
	//	The constructor's and operators are private as we don't
	//	want people to copy CIODriver's
	//
	CIODriver() ;
	CIODriver( CIODriver& ) ;
	CIODriver&	operator=( CIODriver& ) ;

	//
	//	Number of CMediumBufferCache's pointed to by pMediumCaches
	//
	static	DWORD		cMediumCaches ;
	//
	//	Index of the Cache that should be used next time a CIODriver is created
	//
	static	DWORD		iMediumCache ;
	//
	//	Cache's allocated by CIODriver::InitClass()
	//
	static	class		CMediumBufferCache*	pMediumCaches ;

protected : 
	//
	//	Create a CIODriver, using a specified Cache
	//	NOTE : this is protected, as we want people to only
	//	create objects derived from CIODriver.
	//
	CIODriver(	class	CMediumBufferCache*	) ; 

	//
	//	We have a lot of friends !! - People who need to know about the classes
	//	we declare within !
	//
	friend	void	CHandleChannel::Completion( CHandleChannel*, DWORD cb, 
						DWORD dwStatus, ExtendedOverlap *peo ) ;
	friend	void	CFileChannel::Completion(	
								FIO_CONTEXT*, 
								ExtendedOverlap *peo,
								DWORD cb, 
								DWORD dwStatus
								) ;

	
	friend	class	CPacket ;
	friend	class	CStream ;
	friend	class	CIStream;
	friend	class	CIOStream ;


	//
	//	ALL CIODriver's share this one CIO object to do all the 
	//	IO processing when being shutdown.
	//
	static	class	CIOShutdown	shutdownState ;

	//
	//	The CStream derived object which handles reads 
	//
	CStream*	m_pReadStream ;

	//
	//	The CStream derivied object which handles writes
	//
	CStream*	m_pWriteStream ;

	//
	//	Function to call when we are finally destroyed - and some 
	//	arguments to pass to that function
	//
	PFNSHUTDOWN	m_pfnShutdown ;
	void*		m_pvShutdownArg ;
	long		m_cShutdowns ;


	//
	//	We keep some caches of recently used buffers etc... to avoid unnecessary 
	//	block calls to CPool's
	//
	CPacketCache		m_packetCache ;
	CSmallBufferCache	m_bufferCache ;
	CMediumBufferCache	*m_pMediumCache ;
	

#ifdef	CIO_DEBUG
	//
	//	The debug variables will be used in _ASSERT's sprinkled throughout the code.
	//

	//
	//	Ensure only one thread is doing something
	//
	long		m_cConcurrent ;

	//
	//	Ensure our interfaces are called only after we've been successfully initialized
	//
	BOOL		m_fSuccessfullInit ;

	//
	//	Ensure that we have been terminated when we do shutdown stuff.
	//
	BOOL		m_fTerminated ;
#endif


	static	void	SourceNotify(	
							CIODriver*	pdriver,	
							SHUTDOWN_CAUSE	cause,	
							DWORD	dwOpt 
							) ; 

public : 

	//
	//	Initialize this class - this sets up all of our Caching
	//
	static	BOOL	InitClass() ;

	//
	//	Terminate the class - dump out our global caches.
	//
	static	BOOL	TermClass() ;


	//
	//	These should only be accessed by member functions -
	//	Some C++ problems on some platforms with making these accessible to 
	//	CIStream etc... force us to put them here.
	//
	SHUTDOWN_CAUSE	m_cause ;
	DWORD		m_dwOptionalErrorCode ;

	//
	//	Cache for allocating CIO objects !
	//
	CCIOCache	m_CIOCache ;
	
#ifdef	CIO_DEBUG
	//
	//	For debug we override the usual AddRef and RemoveRef so we can get extra tracing
	//	for reference counting problems.
	//
	LONG	AddRef() ;
	LONG	RemoveRef() ;
#endif	

	BOOL	FIsStream( CStream*	pStream ) ;
	virtual	~CIODriver() ;	


	//
	//	The following Interfaces are for the IO operations which execute within our 
	//	framework !!
	//

	//
	//	STOP all IO's and tear everything down !!
	//
	void	Close(	CSessionSocket*	pSocket, SHUTDOWN_CAUSE	cause,	DWORD	dwOptional = 0, BOOL fCloseSource = TRUE ) ;
	void	UnsafeClose(	CSessionSocket*	pSocket,	SHUTDOWN_CAUSE	cause,	DWORD	dwOptional = 0, BOOL fCloseSource = TRUE ) ;


	//
	//	Interface for issuing reads writes and TransmitFiles.
	//
	//	This functions call a matching function on either our 
	//	m_pWriteStream or m_pReadStream CStream objects.
	//
	//	Do a read - redirect this to IssuePacket for our internal m_pReadStream
	//
	inline	void	IssuePacket( 
							CReadPacket	*pPacket,	
							CSessionSocket*	pSocket,	
							BOOL&	eof 
							) ;

	//
	//	Write a packet - call IssuePacket for our internal m_pWriteStream
	//
	inline	void	IssuePacket( 
							CWritePacket	*pPacket,	
							CSessionSocket*	pSocket,	
							BOOL&	eof 
							) ;

	//
	//	Transmit a file - call IssuePacket for our internal m_pWriteStream
	//
	inline	void	IssuePacket( 
							CTransmitPacket	*pPacket,	
							CSessionSocket*	pSocket,	
							BOOL&	eof 
							) ;

	//
	//	Let the CIODriver create all the packets - it keeps a Cache and also 
	//	wants to set things up to reserve space in buffers for SSL encryption etc...
	//	All of the CPacket derived objects created by these functions will have 
	//	a smartptr back to us, and are all set to be issued.
	//
	//	Create a read which can handle at least cbRequest bytes (maybe more!)
	//
	inline	CReadPacket*	CreateDefaultRead( 
								unsigned cbRequest
								) ;

	//
	//	Create a write which will send the specified buffer
	//
	inline	CWritePacket*	CreateDefaultWrite( 
								CBUFPTR&	pbuffer, 
								unsigned	ibStart,	
								unsigned	ibEnd,
								unsigned	ibStartData,	
								unsigned	ibEndData 
								) ;

	//
	//	Create a write packet which can hold at least cbRequired bytes,
	//	although we have yet to fill those bytes in
	//
	inline	CWritePacket*	CreateDefaultWrite(	
								unsigned	cbRequired 
								) ;

	//
	//	Create a write packet we can use to write the bytes we have 
	//	in the completed read packet.
	//
	inline	CWritePacket*	CreateDefaultWrite(	
								CReadPacket*	pRead 
								) ;

	//
	//	Create a Transmit File packet
	//
	inline	CTransmitPacket*	CreateDefaultTransmit(	
									FIO_CONTEXT*	pFIOContext,	
									DWORD	cbOffset,	
									DWORD	cbLength 
									) ;

	//
	//	Create an Execute Packet 
	//
	inline	CExecutePacket*	
	CreateExecutePacket() ;

	//
	//	Process an Execute Packet !
	//
	inline
	void
	ProcessExecute(	CExecutePacket*	pExecute,	
					CSessionSocket*	pSocket 
					) ;


	//
	//	Get the cache being used by one CIODriver, so that we can make
	//	another CIODriver use the same cache
	//
	class	CMediumBufferCache*	GetMediumCache()	{	return	m_pMediumCache ;	}

	//
	//	Allocate a buffer using our cache !
	//
	inline	CBuffer*	AllocateBuffer( DWORD	cbBuffer ) ;


	//
	//	If you have a CIO derived object you want to do something, you need to sent it - 
	//	this will result in all the necessary packets being created and issued.
	//
	inline	BOOL	SendReadIO(	
							CSessionSocket*	pSocket,	
							CIO&		pRead,	
							BOOL fStart = TRUE 
							) ;

	//
	//	Make the specified CIO the current CIO for the write stream
	//
	inline	BOOL	SendWriteIO(
							CSessionSocket*	pSocket,	
							CIO&		pWrite,	
							BOOL fStart = TRUE 
							) ;

	//
	//	If you want an intermediate CIODriverSource object to massage each packet - call this guy !
	//
	//
	BOOL	InsertSource(	
					CIODriverSource&	source,	
					CSessionSocket*	pSocket,
					unsigned	cbReadOffset,	
					unsigned	cbWriteOffset, 
					unsigned	cbTailReadReserve,
					unsigned	cbTailWriteReserve,
					CIOPassThru&	pIOReads,
					CIOPassThru&	pIOWrites,
					CIOPassThru&	pIOTransmits,
					CIOPASSPTR&	pRead,	
					CIOPASSPTR&	pWrite 
					) ;

	//
	//	For use by Source Channel's which can optimize write completions 
	//
	inline	void	CompleteWritePacket(	CWritePacket*	pWritePacket,	CSessionSocket*	pSocket ) ;

	//
	//	To determine how many bytes this CIODriver is reserving in packets
	//
	void	GetReadReserved(	DWORD&	cbFront,	DWORD&	cbTail )		{	
				cbFront = m_pReadStream->GetFrontReserve(); 
				cbTail = m_pReadStream->GetTailReserve() ; 
			}

	void	GetWriteReserved(	DWORD&	cbFront,	DWORD&	cbTail )	{	
				cbFront = m_pWriteStream->GetFrontReserve(); 
				cbTail = m_pWriteStream->GetTailReserve() ; 
			}

	//
	//	This will release the packet to our cache etc...
	//
	void		DestroyPacket(	CPacket*	pPacket ) ;
	

#ifdef	CIO_DEBUG
	void	SetChannelDebug( DWORD	dw ) ;
#endif
} ;

#ifdef	_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CIODriver ) 

#endif


//
//	There are special 'control' packets which we circulate through CIODriver;s
//	(on top of the usual Read Writes and Transmits)
//	These can have one of two functions - either signal that its time to terminate
//	or make a new CIO derived object active.
//
//
enum	CONTROL_TYPES	{
	ILLEGAL		= 0,
	START_IO	= 1,
	SHUTDOWN	= 2,
} ;


//
//	This structure will be embedded in CControlPackets - 
//	This carries all the information we need when we want to start a new CIO object
//
//
struct	ControlInfo	{
	CONTROL_TYPES	m_type ;

	CIOPTR			m_pio ;
	CIOPASSPTR		m_pioPassThru ;
	BOOL			m_fStart ;

	BOOL			m_fCloseSource ;

	ControlInfo() : m_type(ILLEGAL)	{
		m_fStart = FALSE ;
		m_fCloseSource = FALSE ;
	}
} ;		

//
//	CIODriverSource - 
//	Used for SSL processing.  A CIODriverSource will issue IO's to a lower level
//	object as well as get requests from a CIODriverSink.
//
class	CIODriverSource : public	CIODriver	{
protected : 
	//
	//	Stream used to process reads
	//
	CIOStream	m_ReadStream ;

	//
	//	Stream used to process Writes and TransmitFiles
	//
	CIOStream	m_WriteStream ;

public : 
	CIODriverSource( 
				class	CMediumBufferCache*	pCache
				) ;

	~CIODriverSource() ;

	//
	//	Most of the below functions override virtual functions in the CChannel class ...
	//


	BOOL	Init(	
				CChannel*	pSource, 
				CSessionSocket*	pSocket,	
				PFNSHUTDOWN	pfnShutdown, 
				void*	pvShutdownArg, 
				CIODriver*		driverOwner,
				CIOPassThru&	pIOReads,
				CIOPassThru&	pIOWrites,
				CIOPassThru&	pIOTransmits,
				unsigned	cbReadOffset = 0,	
				unsigned	cbWriteOffset = 0 
				) ;

	BOOL	Start(	
				CIOPASSPTR&	pRead,	
				CIOPASSPTR&	pWrite,	
				CSessionSocket*	pSocket 
				) ;

	//
	//	Occasionally we need to make copies of some packets - here are some convenient functions for 
	//	doing so.
	//
	//
	inline	CReadPacket*	Clone(	CReadPacket *pRead ) ;
	inline	CWritePacket*	Clone(	CWritePacket*	pWrite ) ;
	inline	CTransmitPacket*	Clone(	CTransmitPacket*	pTransmit ) ;


	//
	//	This is the interface that will be called when somebody has a packet they want encrypted 
	//	or whatever.
	//
	BOOL	Read(	
				CReadPacket*,	
				CSessionSocket	*pSocket, 
				BOOL	&eof 
				) ;

	BOOL	Write(	
				CWritePacket*,	
				CSessionSocket	*pSocket, 
				BOOL	&eof 
				) ;

	BOOL	Transmit(	
				CTransmitPacket*,	
				CSessionSocket*	pSocket, 
				BOOL	&eof 
				) ;

	//void	GetPaddingValues(	unsigned	
	void	SetRequestSequenceno(	
				SEQUENCENO&	sequencenoRead,	
				SEQUENCENO&	sequencenoWrite 
				) ;

	void	CloseSource(
				CSessionSocket*	pSocket
				) ;

	
} ;


//
//	CIODriverSink
//
//
class	CIODriverSink : public	CIODriver	{
protected : 
	CIStream	m_ReadStream ;
	CIStream	m_WriteStream ;

public : 
	BOOL	FSupportConnections() ;		// return FALSE always

	void	CloseSource(	
					CSessionSocket*	pSocket	
					) ;

	//
	// Following All DebugBreak() - these are not supported by CIODriverSink's
	//
	BOOL	Read(	CReadPacket*,	
					CSessionSocket*,	
					BOOL	&eof 
					) ;

	BOOL	Write(	CWritePacket*,	
					CSessionSocket*,	
					BOOL	&eof 
					) ;

	BOOL	Transmit(	CTransmitPacket*,	
						CSessionSocket*,	
						BOOL	&eof 
						) ;

	CIODriverSink( class	CMediumBufferCache*	pCache ) ;
	~CIODriverSink() ;

	//
	//	To Initialize we require a 'source' - a CChannel derived object who's Read() Write() etcc
	//	functions we will be calling.
	//
	BOOL	Init(	CChannel*	pSource,	
					CSessionSocket*	pSocket, 
					PFNSHUTDOWN	pfnShutdown,	
					void	*pvShutdownArg,	
					unsigned cbReadOffset = 0, 
					unsigned cbWriteOffset = 0,
					unsigned cbTrailer = 0
					) ;

	//
	//	Issue the first bunch of CIO's.  This should only be called once, after that 
	//	the SendReadIO and SendWriteIO functions should be used by that state machines to keep
	//	things moving.
	//
	BOOL	Start(	CIOPTR&	pRead,	
					CIOPTR&	pWrite,	
					CSessionSocket*	pSocket 
					) ;

	//
	//	There are some situations where ATQ can lose track of timeouts - use this function
	//	to make sure that doesn't happen
	//
	void	ResumeTimeouts()	{	m_ReadStream.ResumeTimeouts() ;	}

} ;

#ifdef		_NO_TEMPLATES_

DECLARE_SMARTPTRFUNC( CIODriverSink ) 

#endif


#define	MAX_CHANNEL_SIZE	max(	sizeof( CChannel ),				\
							max(	sizeof( CHandleChannel ),		\
							max(	sizeof(	CSocketChannel ),		\
							max(	sizeof(	CFileChannel ),			\
							max(	sizeof(	CIOFileChannel ),		\
							max(	sizeof(	CIODriver ),			\
							max(	sizeof( CIODriverSource ),		\
									sizeof(	CIODriverSink ) ) ) ) ) ) ) ) 

extern	const	unsigned	cbMAX_CHANNEL_SIZE ;


#include	"packet.h"
#include	"cio.h"

#include	"packet.inl"
#include	"io.inl"
#include	"cio.inl"


#endif	// _IO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\iisnntp.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        iisnntp.cxx

   Abstract:

        This module defines the NNTP_IIS_SERVICE class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996

--*/

#include "tigris.hxx"
#include <aclapi.h>

extern DWORD
WINAPI
FeedScheduler(
        LPVOID Context
        );

extern BOOL fSuccessfullInitIDirectoryNotification;

VOID WINAPI
NotifyCert11Touched(
    VOID
    )
/*++

Routine Description:

    Notification function called when any Cert11 mapper modified in metabase

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    //
    // If someone has asked to be notified for SSL events, forward notification
    //

    if ( g_pSslKeysNotify )
    {
        (g_pSslKeysNotify)( SIMSSL_NOTIFY_MAPPER_CERT11_TOUCHED, NULL );
    }
}


BOOL
NNTP_IIS_SERVICE::AddInstanceInfo(
                     IN DWORD dwInstance,
                     IN BOOL fMigrateRoots
                     )
{
    PNNTP_SERVER_INSTANCE pInstance = NULL;
    DWORD   err = NO_ERROR;
    CHAR    szInstance [20];
	MB      mb( (IMDCOM*) QueryMDObject() );

	TraceFunctEnter("NNTP_IIS_SERVICE::AddInstanceInfo");

    DebugTrace(0, "AddInstanceInfo: instance %d reg %s\n", dwInstance, QueryRegParamKey() );

	//
	//  Validate instance parameters -
	//  If <nntpfile>, <nntproot> directories do not exist, create them
	//

	if( !ValidateNewInstance( dwInstance ) ) {
	    ErrorTrace(0, "Failed to validate new instance %d", dwInstance );
	    SetLastError( ERROR_FILE_NOT_FOUND );
	    goto err_exit;
    }

    //
    //	Create the new instance
	//	Use different ports per virtual server as defaults
	//	The IIS_SERVER_INSTANCE constructor will read the IP bindings
	//	from the metabase !
    //

    pInstance = XNEW NNTP_SERVER_INSTANCE(
                                this,
                                dwInstance,
                                IPPORT_NNTP, // +(USHORT)dwInstance-1,
                                QueryRegParamKey(),
                                NNTP_ANONYMOUS_SECRET_W,
                                NNTP_ROOT_SECRET_W,
                                fMigrateRoots
                                );

    if ( (pInstance == NULL) ||
		 (pInstance->QueryServerState() == MD_SERVER_STATE_INVALID) )
    {
        FatalTrace(0, "Cannot allocate new server instance or constructor failed");
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
		goto err_exit;
	}

#if 0				// Never force instance to be autostart
	if ( !pInstance->IsAutoStart() )
	{
	    //
	    //  instance is not auto-start - make it !
	    //
	
    	if( mb.Open( pInstance->QueryMDPath(), METADATA_PERMISSION_WRITE ) )
    	{
			if(	!mb.SetDword( "", MD_SERVER_AUTOSTART, IIS_MD_UT_SERVER, 1) )
			{
				//
				//	failed to make server auto-start
				//
				ErrorTrace(0,"Failed to make server autostart\n");
			}
    	    mb.Close();
   	    }

	    if( dwInstance != 1 ) {
			DebugTrace(0,"Is not autostart\n");
			SetLastError( ERROR_SERVICE_DISABLED );
			LEAVE
			return FALSE ;
		}
	}
#endif

	//
	//	The helper function associates the instance with the service.
	//	Associating an instance with the service starts off the ATQ engine
	//	ie. the flood-gates are open for this instance. This also calls
	//	the StartInstance() method.
	//

    if( !AddInstanceInfoHelper( pInstance ) )
	{
		PCHAR args[1];
		_itoa( dwInstance, szInstance, 10 );
		args[0] = szInstance;
		NntpLogEventEx(NNTP_ADD_INSTANCE_FAILED,
			1,
			(const char **) args,
			GetLastError(),
			dwInstance);
		FatalTrace(0,"AddInstanceInfoHelper failed: Instance %d\n", dwInstance );
		SetLastError( ERROR_SERVICE_DISABLED );
		LEAVE
		return FALSE ;
	}

	LEAVE
	return TRUE ;

err_exit:

    //
    //  Set win32err code in metabase if create fails
    //

   	if( mb.Open( "/LM/Nntpsvc/", METADATA_PERMISSION_WRITE ) )
   	{
   	    _itoa( dwInstance, szInstance, 10 );
		if(	!mb.SetDword( szInstance, MD_WIN32_ERROR, IIS_MD_UT_SERVER, GetLastError(), METADATA_VOLATILE ) )
		{
			//
			//	failed to set win32 error code
			//
			ErrorTrace(0,"Failed to set win32 error code");
		}
   	    mb.Close();
    }

    LEAVE
    return FALSE;

} // NNTP_IIS_SERVICE::AddInstanceInfo

DWORD
NNTP_IIS_SERVICE::DisconnectUsersByInstance(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Virtual callback invoked by IIS_SERVER_INSTANCE::StopInstance() to
    disconnect all users associated with the given instance.

    Arguments:

        pInstance - All users associated with this instance will be
            forcibly disconnected.

--*/
{
	PNNTP_SERVER_INSTANCE pNntpInstance = (PNNTP_SERVER_INSTANCE)pInstance;
	CSocketList* pInUseList = pNntpInstance->m_pInUseList;

	TraceFunctEnter("NNTP_IIS_SERVICE::DisconnectUsersByInstance");

	//
	// wait for all pickup operations to complete
	//
	pNntpInstance->WaitForPickupThreads();

	//
	//	Call the session shutdown enumerator on the session socket list
	//	This is called by StopInstance() and CloseInstance().	
	//
	if( pInUseList ) {

		DWORD  cSessions = pInUseList->GetListCount() ;

		//
		// enumerate all users to call their Disconnect method
		//
		pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
		//
		// Tell crawler threads to abbreviate their work.
		//	NOTE : Do this after we make a first try of dropping all of our sessions,
		//	because we want any Newnews commands which are in progress to just drop with no
		//	further bytes sent.  The complication is that a thread can spin looking for
		//	message-id's even though we've dropped the socket, and the CNewnewsCmd::PartialExecute
		//	function will need to provide some bytes in case of early termination.
		//	So, when we bail out of newnews commands early, we have to provide some
		//	bytes, so we will send the terminating ".\r\n" from the newnews command.
		//	However, clients probably won't get these because the socket will already
		//	be dead due to the EnumSessionShutdown().  This is the behaviour we want !
		//
		if( pNntpInstance->GetTree() ) {
			pNntpInstance->GetTree()->StopTree() ;
		}

        //
        //  This lock is grabbed shared by the feed & expire thread when
        //  either one processes an instance. We need to grab this exclusive
        //  so we can cleanup any outbound sockets initiated by the feed thread.
        //  Since the instance state is now MD_SERVER_STATE_STOPPING, the feed
        //  thread will skip this instance when we release the exclusive lock.
        //  NOTE: Since we called StopTree(), the expire thread will eventually
        //  release its read lock.
        //
        CShareLockNH* pLockInstance = pNntpInstance->GetInstanceLock();
	    pLockInstance->ExclusiveLock();
        pNntpInstance->m_FeedManagerRunning = FALSE;
	    pLockInstance->ExclusiveUnlock();

		//
		//  Use j just to figure out when to do StopHint()'s
		//
		DWORD   j = 0 ;

		if( cSessions ) {
			Sleep( 1000 );
			StopHintFunction() ;
		}

		cSessions = pInUseList->GetListCount() ;
        if( cSessions ) {
            //  This should catch any sessions that snuck in past the
            //  call to EnumAllSess() before we locked out the feed thread..
		    pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
        }

		for( int i=0; cSessions && i<120; i++, j++ )
		{
			Sleep( 1000 );
			DebugTrace( (LPARAM)this, "Shutdown sleep %d seconds. Count: %d", i,
						pInUseList->GetListCount() );

			if( (j%10) == 0 ) {
				StopHintFunction() ;
			}

			//
			//  If we make progress, then reset i.  This will mean that the server
			//  wont stop until 2 minutes after we stop making progress.
			//
			DWORD   cSessionsNew = pInUseList->GetListCount() ;
			if( cSessions != cSessionsNew ) {
				i = 0 ;
            } else {
                // We are not making progress - might as well have a shot at
                // shutting down these sessions...
                pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
            }

			cSessions = cSessionsNew ;
		}

		if ( pInUseList->GetListCount() )
		{
			pInUseList->EnumAllSess( EnumSessionShutdown, 0, 0 );
		}

		_ASSERT( i<1200 );
	}

    return NO_ERROR;

}   // NNTP_IIS_SERVICE::DisconnectUsersByInstance

NNTP_IIS_SERVICE::NNTP_IIS_SERVICE(
        IN  LPCSTR                           pszServiceName,
        IN  LPCSTR                           pszModuleName,
        IN  LPCSTR                           pszRegParamKey,
        IN  DWORD                            dwServiceId,
        IN  ULONGLONG                        SvcLocId,
        IN  BOOL                             MultipleInstanceSupport,
        IN  DWORD                            cbAcceptExRecvBuffer,
        IN  ATQ_CONNECT_CALLBACK             pfnConnect,
        IN  ATQ_COMPLETION                   pfnConnectEx,
        IN  ATQ_COMPLETION                   pfnIoCompletion
        ) : IIS_SERVICE( pszServiceName,
                         pszModuleName,
                         pszRegParamKey,
                         dwServiceId,
                         SvcLocId,
                         MultipleInstanceSupport,
                         cbAcceptExRecvBuffer,
                         pfnConnect,
                         pfnConnectEx,
                         pfnIoCompletion
                         ),
			m_cStartHints( 2 ),     // Gibraltar sets the hint to 1 before they call us !?!
			m_cStopHints( 2 ),
			m_SockRecvBufSize( BUFSIZEDONTSET ),
			m_SockSendBufSize( BUFSIZEDONTSET ),
			m_fNonBlocking( TRUE ),
			m_FeedSchedulerSleepTime( 60 ),
			m_pRebuildThread( NULL ),
            m_pExpireThrdpool( NULL ),
			m_hFeedEvent( NULL ),
			m_hFeedThread( NULL ) 
{
    //
    //	Init global version strings
    //
    InitializeServerStrings();

	//
	//	This context is passed to simssl for use in retrieving mapper objects
	//
	m_smcMapContext.ServerSupportFunction = ServerMapperCallback;

#if 0
    //
    // Set the notification function in NSEP for mapping ( NSEPM )
    //

    if ( QueryMDNseObject() != NULL ) {

        MB mbx( (IMDCOM*)QueryMDNseObject() );

        if ( mbx.Open( "", METADATA_PERMISSION_WRITE ) ) {

            mbx.SetDword(
                      "",
                      MD_NOTIFY_CERT11_TOUCHED,
                      IIS_MD_UT_SERVER,
                      (DWORD)::NotifyCert11Touched
                    );

            mbx.Close();
        }
    }
#endif	

} // NNTP_IIS_SERVICE::NNTP_IIS_SERVICE

NNTP_IIS_SERVICE::~NNTP_IIS_SERVICE()
{

#if 0
    //
    // Reset the notification function in NSEP for mapping ( NSEPM )
    //

    if ( QueryMDNseObject() != NULL ) {

        MB mbx( (IMDCOM*)QueryMDNseObject() );

        if ( mbx.Open( "", METADATA_PERMISSION_WRITE ) )
        {
            mbx.SetDword("",
                         MD_NOTIFY_CERT11_TOUCHED,
                         IIS_MD_UT_SERVER,
                         (DWORD)NULL
                         );

            mbx.Close();
        }
    }
#endif
}

VOID
NNTP_IIS_SERVICE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this service

  Arguments:

    hMDHandle - Metabase handle generating the change notification
    pcoChangeList - path and id that has changed

--*/
{
    DWORD   i;
    BOOL    fSslModified = FALSE;

    AcquireServiceLock();

    IIS_SERVICE::MDChangeNotify( pcoChangeList );

    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {
        case 0:     // place holder
            break;

        case MD_SSL_PUBLIC_KEY:
        case MD_SSL_PRIVATE_KEY:
        case MD_SSL_KEY_PASSWORD:
            fSslModified = TRUE;
            break;

        default:
            break;
        }
    }

    if ( !fSslModified && g_pSslKeysNotify )
    {
        if ( strlen( (LPSTR)pcoChangeList->pszMDPath ) >= sizeof("/LM/NNTPSVC/SSLKeys" )-1 &&
             !_memicmp( pcoChangeList->pszMDPath,
                        "/LM/NNTPSVC/SSLKeys",
                        sizeof("/LM/NNTPSVC/SSLKeys" )-1 ) )
        {
            fSslModified = TRUE;
        }
    }

    if ( fSslModified && g_pSslKeysNotify )
    {
        (g_pSslKeysNotify)( SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED, this );
    }

    ReleaseServiceLock();
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::InitializeServerThreads
//
//  Synopsis:   Kick off server wide threads
//
//  Arguments:
//
//  Returns:    FALSE on failure - this is a fatal error !
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_IIS_SERVICE::InitiateServerThreads()
{
	TraceFunctEnter("NNTP_IIS_SERVICE::InitializeServerThreads");

    //
    //  Initialize the thrdpool class - used by nntpbld and expire
    //

	if( !CWorkerThread::InitClass( 1 ) ) {
		ErrorTrace(0,"Failed to init thrdpool class - error %d", GetLastError());
		return FALSE ;
	}

	//
	//	create the expire thread - this will expire articles in all
	//  server instances that are in the MD_SERVER_STARTED state !
	//
	CNewsTree::m_hTermEvent = CreateEvent( 0, TRUE, FALSE, 0 ) ;
	if ( CNewsTree::m_hTermEvent == 0 )
	{
		ErrorTrace( (DWORD_PTR)this, "CreateEvent Failed %d", GetLastError() ) ;
		return FALSE ;
	}
	else
	{
		DWORD	tid ;
		CNewsTree::m_hCrawlerThread = CreateThread( 0, 0, CNewsTree::NewsTreeCrawler, 0, 0, &tid ) ;
		if ( CNewsTree::m_hCrawlerThread == 0 )
		{
			ErrorTrace( (DWORD_PTR)this, "CreateThread Failed %d", GetLastError() ) ;
			return FALSE ;
		}
	}		

    //
    //  create the expire thread pool
    //

    if( (m_pExpireThrdpool = XNEW CExpireThrdpool) == NULL ) {
        ErrorTrace( (DWORD_PTR)this,"Failed to create an expire thrdpool object");
        return FALSE ;
    } else {
        if( !m_pExpireThrdpool->Initialize( dwNumExpireThreads, dwNumExpireThreads*2, dwNumExpireThreads ) ) {
            ErrorTrace( (DWORD_PTR)this,"Failed to initialize expire thrdpool");
            return FALSE ;
        }
    }

	//
	//	create the feed scheduler thread - this will initiate outgoing
	//	feeds on all server instances !
	//

	// Create Termination event
	m_hFeedEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
	if ( m_hFeedEvent == NULL ) {
		ErrorTrace(0,"Error %d on CreateEvent\n",GetLastError());
		return FALSE ;
	}

	m_hFeedThread = NULL ;

	//
	// Start threads
	//

    DWORD threadId;
	m_hFeedThread = CreateThread(
						NULL,               // attributes
						0,                  // stack size
						FeedScheduler,      // thread start
						NULL,
						0,
						&threadId
						);

	if ( m_hFeedThread == NULL ) {
		ErrorTrace(0,"Error %d on CreateThread\n",GetLastError());
		return FALSE ;
	}

	TraceFunctLeave();
	return TRUE ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::TerminateServerThreads
//
//  Synopsis:   Shutdown server wide threads
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_IIS_SERVICE::TerminateServerThreads()
{
	TraceFunctEnter("NNTP_IIS_SERVICE::TerminateServerThreads");

	//
	//	Before shutting down, we need to signal server threads to stop
	//	any work they are doing. We do this by setting the m_bStoppingTree
	//	member of each instance's newstree to TRUE. This is checked in
	//	all big loops in the server.
	//

	//	Get the min and max instance ids
	DWORD dwMinInstanceId = 0;
	DWORD dwMaxInstanceId = 0;
	CNewsTree* pTree = NULL ;
	PNNTP_SERVER_INSTANCE pInstance = NULL;

	StopHintFunction();

	if( FindIISInstanceRange( this, &dwMinInstanceId, &dwMaxInstanceId ) )
	{
		//
		//	Iterate over all instances
		//
		for( DWORD dwCurrInstance = dwMinInstanceId;
				dwCurrInstance <= dwMaxInstanceId; dwCurrInstance++)
		{
			pInstance = ::FindIISInstance( this, dwCurrInstance, FALSE );
			if( pInstance == NULL ) {
				ErrorTrace(0,"Expire thread: FindIISInstance returned NULL: instance %d", dwCurrInstance);
				continue;
			}

			//	Stop the newstree
			pTree = pInstance->GetTree() ;
			if( pTree ) {
				pTree->StopTree();
			}

			//	Release the ref added by FindIISInstance()
			pInstance->Dereference();
		}
	} else {
		ErrorTrace(0, "FindIISInstanceRange failed" );
	}

	StopHintFunction();

	//
	// shutdown directory notification retry queue thread
	//
	if( fSuccessfullInitIDirectoryNotification ) {
		IDirectoryNotification::GlobalShutdown();
		fSuccessfullInitIDirectoryNotification = FALSE;
	}

	//
	//	Shutdown the expire thread
	//
	if ( CNewsTree::m_hTermEvent != 0 )
		SetEvent( CNewsTree::m_hTermEvent );

	if ( CNewsTree::m_hCrawlerThread != 0 ) {
		WaitForSingleObject( CNewsTree::m_hCrawlerThread, INFINITE );
	}

	StopHintFunction();

	if ( CNewsTree::m_hTermEvent != 0 )
	{
		_VERIFY( CloseHandle( CNewsTree::m_hTermEvent ) );
		CNewsTree::m_hTermEvent = 0;
	}

	if ( CNewsTree::m_hCrawlerThread != 0 )
	{
		_VERIFY( CloseHandle( CNewsTree::m_hCrawlerThread ) );
		CNewsTree::m_hCrawlerThread = 0;
	}

	StopHintFunction();

    //
    //  Shutdown the expire thrdpool
    //  Since the expire thread is gone, we should have no work items
    //  pending on this pool.
    //

    if( m_pExpireThrdpool ) {
        _VERIFY( m_pExpireThrdpool->Terminate() );
        XDELETE m_pExpireThrdpool;
        m_pExpireThrdpool = NULL;
    }

	//
	//	Shutdown the feed scheduler thread
	//

	if ( m_hFeedThread != NULL ) {

		_ASSERT( m_hFeedEvent != NULL );
		SetEvent(m_hFeedEvent);

		DebugTrace(0,"Waiting for thread to terminate\n");
		(VOID)WaitForSingleObject( m_hFeedThread, INFINITE );
		_VERIFY( CloseHandle( m_hFeedThread ) );
		m_hFeedThread = NULL;
	}

	//
	// Close event handle
	//

	if ( m_hFeedEvent != NULL ) {

		_VERIFY( CloseHandle( m_hFeedEvent ) );
		m_hFeedEvent = NULL;
	}

	StopHintFunction();

	//
	//	Shutdown the rebuild thread if required !
	//

	if( m_pRebuildThread ) {
		// base class destructor will shutdown and cleanup rebuild thread
		XDELETE m_pRebuildThread ;
		m_pRebuildThread = NULL ;
	}

	//
	//	Call base class TermClass
	//
	_VERIFY( CWorkerThread::TermClass() );

	TraceFunctLeave();
	return TRUE ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::ValidateNewInstance
//
//  Synopsis:   Check for existence of new instance directories
//
//  Arguments:  DWORD dwInstance
//
//  Returns:    TRUE on success and FALSE on failure
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_IIS_SERVICE::ValidateNewInstance(DWORD dwInstance)
{
	TraceFunctEnter("NNTP_IIS_SERVICE::ValidateNewInstance");
	MB      mb( (IMDCOM*) QueryMDObject() );
	BOOL    fRet = TRUE ;
	CHAR	szFile [1024];
	CHAR	szDropDirectory [1024];
    char*   pchSlash = NULL;
	HRESULT hr;

    DWORD dwRes, dwDisposition;
    PSID pEveryoneSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS ea[2];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;
    LONG lRes;
	DWORD dwSize = 1024 ;

    wsprintf( szFile, "/LM/nntpsvc/%d/", dwInstance );
    if( !mb.Open( szFile, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {
        FatalTrace(0,"Failed to open mb path %s", szFile );
        return FALSE ;
    }

    // Create a security descriptor for the files

    // Create a well-known SID for the Everyone group.

    if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                 SECURITY_WORLD_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &pEveryoneSID) ) 
    {
        fRet = FALSE;
        goto Exit;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ZeroMemory(&ea, 2*sizeof(EXPLICIT_ACCESS));
    ea[0].grfAccessPermissions = GENERIC_ALL;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

    ea[1].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
    ea[1].grfAccessMode = DENY_ACCESS;
    ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[1].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

    // Create a new ACL that contains the new ACEs.

    dwRes = SetEntriesInAcl(2, ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes) 
    {
        fRet = FALSE;
        goto Exit;
    }

    // Initialize a security descriptor.  
 
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                         SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL) 
    {
        fRet = FALSE;
        goto Exit; 
    }
 
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) 
    {
        fRet = FALSE;
        goto Exit; 
    }
 
    // Add the ACL to the security descriptor. 
 
    if (!SetSecurityDescriptorDacl(pSD, 
        TRUE,     // fDaclPresent flag   
        pACL, 
        FALSE))   // not a default DACL 
    {
        fRet = FALSE;
        goto Exit; 
    }

    // Initialize a security attributes structure.

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;

	if( !mb.GetString(	"",
						MD_ARTICLE_TABLE_FILE,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		//
		//	Path to article table file does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to article table file missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

    //  Truncate file name from path
    pchSlash = strrchr( szFile, '\\' );
    if( !pchSlash ) {
		fRet = FALSE ;
		goto Exit;
    } else {
        *pchSlash = '\0';
    }

	//
	//  Now we have the path to the article hash table - check for existence !
	//  if dir does not exist - create it
	//

    if( !CreateDirectory( szFile, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS && GetLastError() != ERROR_BUSY) {

            //
            // Be careful when a drive letter is given
            //
            if ( *szFile && *(szFile+strlen(szFile)-1) == ':' ) {

                //
                // Check for accessibility
                //
                HANDLE hTemp = CreateFile(	szFile,
		    					GENERIC_READ | GENERIC_WRITE,
			    				FILE_SHARE_READ | FILE_SHARE_WRITE,
				    			&sa,
					    		OPEN_ALWAYS,
						    	FILE_FLAG_BACKUP_SEMANTICS,
							    INVALID_HANDLE_VALUE
        						) ;
                if ( INVALID_HANDLE_VALUE == hTemp ) {
                    FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szFile);
		            fRet = FALSE ;
	    	        goto Exit;
	    	    }

	    	    _VERIFY( CloseHandle( hTemp ) );
	    	} else {
	    	    FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szFile);
		        fRet = FALSE ;
	    	    goto Exit;
            }
        }
    }
    
	dwSize = 1024 ;
	if( !mb.GetString(	"/Root",
						MD_VR_PATH,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		//
		//	Path to nntproot does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to nntproot missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

#if 0
	//
	//  Now we have the path to the nntproot - check for existence !
	//  if dir does not exist - create it
	//

    if( !CreateDirectory( szFile, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS &&
			GetLastError() != ERROR_ACCESS_DENIED &&
			szFile[0] != '\\' ) {
            FatalTrace(0,"Instance %d: Could not create directory %s  error %x", dwInstance, szFile, GetLastError());
    		fRet = FALSE ;
	    	goto Exit;
        }
    }
#endif

    //
    //  Create pickup, failedpickup and drop dirs
    //

	dwSize = 1024 ;
	if( !mb.GetString(	"",
						MD_PICKUP_DIRECTORY,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		//
		//	Path to pickup dir does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to pickup dir missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

    if( !CreateDirectory( szFile, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS && GetLastError() != ERROR_BUSY) {
            FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szFile);
    		fRet = FALSE ;
	    	goto Exit;
        }
    }
	
	dwSize = 1024 ;
	if( !mb.GetString(	"",
						MD_FAILED_PICKUP_DIRECTORY,
						IIS_MD_UT_SERVER,
						szFile,
						&dwSize  ) )
	{
		//
		//	Path to pickup dir does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to failed pickup dir missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

    if( !CreateDirectory( szFile, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS && GetLastError() != ERROR_BUSY) {
            FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szFile);
    		fRet = FALSE ;
	    	goto Exit;
        }
    }

	dwSize = 1024 ;
	if( !mb.GetString(	"",
						MD_DROP_DIRECTORY,
						IIS_MD_UT_SERVER,
						szDropDirectory,
						&dwSize  ) )
	{
		//
		//	Path to pickup dir does not exist - fail !!
		//

		FatalTrace(0,"Instance id %d: Path to drop dir missing", dwInstance);
		fRet = FALSE ;
		goto Exit;
	}

    if( !CreateDirectory( szDropDirectory, &sa ) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS && GetLastError() != ERROR_BUSY) {
            FatalTrace(0,"Instance %d: Could not create directory %s", dwInstance, szDropDirectory);
    		fRet = FALSE ;
	    	goto Exit;
        }
    }

    //
    //	Create ADSI keys for nntp objects
    //

    if( !mb.SetString( 	"/Feeds",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_FEEDS,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for feeds: error is %d", GetLastError());
	}
    					
    if( !mb.SetString( 	"/Expires",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_EXPIRES,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for expires: error is %d", GetLastError());
	}

    if( !mb.SetString( 	"/Groups",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_GROUPS,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for groups: error is %d", GetLastError());
	}

    if( !mb.SetString( 	"/Sessions",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_SESSIONS,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for sessions: error is %d", GetLastError());
	}

    if( !mb.SetString( 	"/Rebuild",
    					MD_KEY_TYPE,
    					IIS_MD_UT_SERVER,
    					NNTP_ADSI_OBJECT_REBUILD,
    					METADATA_NO_ATTRIBUTES
    					) )
	{
		ErrorTrace(0,"Failed to set adsi key type for rebuild: error is %d", GetLastError());
	}

Exit:
    if (pEveryoneSID) 
            FreeSid(pEveryoneSID);
    if (pACL) 
        LocalFree(pACL);
    if (pSD) 
        LocalFree(pSD);

    if( !fRet ) {
        ErrorTrace(0,"GetLastError is : %d", GetLastError());
    }
	mb.Close();

	if (fRet) {
		//
		// do the server events registration
		//
		hr = RegisterSEOInstance(dwInstance, szDropDirectory);
		if (FAILED(hr)) {
	   	    ErrorTrace(0,"Instance %d: RegisterServerEvents returned %x",
				dwInstance, hr);
			_ASSERT(FALSE);
			NntpLogEventEx(SEO_REGISTER_INSTANCE_FAILED,
						   0,
						   (const char **) NULL,
						   hr,
						   dwInstance);
		}
	}


	TraceFunctLeave();
    return fRet ;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::InitializeServerStrings
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL
NNTP_IIS_SERVICE::InitializeServerStrings( VOID )
{
	CHAR szServerPath [MAX_PATH+1];

    CopyMemory( szServerPath, "c:\\", sizeof( "c:\\" ) ) ;
    HMODULE hModule = GetModuleHandle( NNTP_MODULE_NAME ) ;
    if( hModule != 0 ) {
        if( !GetModuleFileName( hModule, szServerPath, sizeof( szServerPath ) ) )   {
            CopyMemory( szServerPath, "c:\\", sizeof( "c:\\" ) ) ;
        }   else    {
            SetVersionStrings(  szServerPath, szTitle, szVersionString, 128 );
        }
    }

	return TRUE;
}

//+---------------------------------------------------------------
//
//  Function:   NNTP_IIS_SERVICE::ServerMapperCallback
//
//  Synopsis:   Callback to return mapper object for an instance
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//----------------------------------------------------------------

BOOL WINAPI NNTP_IIS_SERVICE::ServerMapperCallback(
	PVOID pInstance,
	PVOID pData,
	DWORD dwPropId )
{
	PNNTP_SERVER_INSTANCE pNntpInst = (PNNTP_SERVER_INSTANCE)pInstance;

	TraceFunctEnter("NNTP_IIS_SERVICE::ServerMapperCallback");

	switch( dwPropId )
	{
		case SIMSSL_PROPERTY_MTCERT11:
			if( pNntpInst ) {
				*(LPVOID*) pData = pNntpInst->QueryMapper( MT_CERT11 );
			}
			break;
				
		case SIMSSL_PROPERTY_MTCERTW:
			if( pNntpInst ) {
				*(LPVOID*) pData = pNntpInst->QueryMapper( MT_CERTW );
			}
			break;

        case SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED:
        case SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED:
            return SetFlushMapperNotify( dwPropId, (PFN_SF_NOTIFY)pData );

        case SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED:
            return SetSllKeysNotify( (PFN_SF_NOTIFY)pData );
			
		default:
			ErrorTrace(0,"Invalid property id - no such mapper");
			SetLastError( ERROR_INVALID_PARAMETER );
			return FALSE ;
	}

	return TRUE;
	
	SetLastError( ERROR_INVALID_PARAMETER );
	return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\lockq.cpp ===
//
//	LOCKQ.CPP
//
//	This file contains classes which define a queue mechanism which will
//	safely synchronize additions and removals from the queue, where every
//	thread which appends to the Queue must be prepared to deal with owning the
//	queue.  Additionally, elements will come off the queue in the same order
//	that they are appended.
//
//	The structure of a thread using this stuff should be the following :
//
//	class	CUsefull : public CQElement { } ;
//	template	CLockQueue< CUsefull >	UsefullQ ;
//
//
//		if( UsefullQ.Append( pUsefull ) ) {
//
//			while( UsefullQ.GetHead( &pUsefullWorkItem )  ) {
//				/* Do some usefull work. */
//
//				UsefullQ.Remove() ;
//			}
//		}
//
//	Implementation Schedule for all classes defined in this file :
//		1 day
//
//	Unit Test schedule for all classes defined in this file :
//		1 day
//		Unit Testing should consist of a multi theaded appli
//
//

//
//	K2_TODO: move this into an independent lib
//
#define _TIGRIS_H_
#include "tigris.hxx"

#include    <windows.h>
#ifndef	UNIT_TEST
#include    <dbgtrace.h>
#else
#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif
#endif

#ifdef  PPC
#define _NO_TEMPLATES_
#endif

#include	"qbase.h"
#include	"lockq.h"



CQueueLockV1::CQueueLockV1( ) : m_pHead( &m_special ), m_pTail( &m_special ) {

	//
	// This function initializes the queue to an empty state.
	// In the empty state the queue contains one element which
	// has a Next pointer of 'LOCKVAL'.
	// The next pointer is initialized to LOCKVAL so that the first
	// append to the Queue owns the removal lock.
	//
 	m_special.m_pNext = (CQElement*)((SIZE_T)LOCKVAL) ;

#ifdef	LOCKQ_DEBUG
	m_dwOwningThread = 0 ;
	m_lock = -1 ;
#endif

}


CQueueLockV1::~CQueueLockV1( ) {
	_ASSERT( m_pHead == m_pTail ) ;
	_ASSERT( m_pHead == &m_special ) ;
#ifdef	LOCKQ_DEBUG
//	_ASSERT( m_dwOwningThread == 0 || m_dwOwningThread == GetCurrentThreadId() ) ;
#endif

}

CQElement*
CQueueLockV1::GetFront( ) {

	//
	// This is an internally used function only.
	// This function will set the m_pHead pointer to point
	// to the first legal element.
	// The function assumes there is at least one valid element
	// in the queue.
	//


	_ASSERT( m_pHead != 0 ) ;	// Check head pointer is valid.
#ifdef	LOCKQ_DEBUG
	_ASSERT( m_dwOwningThread == GetCurrentThreadId() ) ;
	_ASSERT( InterlockedIncrement( &m_lock ) > 0 ) ;
#endif

	if( m_pHead == &m_special ) {

		// There is one valid element in queue, so this must be TRUE.
		_ASSERT( m_pHead->m_pNext != 0 ) ;

		CQElement*	pTemp = m_pHead ;
		m_pHead = pTemp->m_pNext ;
		pTemp->m_pNext = 0 ;
		// We ignore the return code of Append() as the caller must already
		// have the remove lock.
		Append( pTemp ) ;

#ifdef	LOCKQ_DEBUG
		_ASSERT( InterlockedDecrement( &m_lock ) == 0 ) ;
#endif
		if( !OfferOwnership( m_pHead ) )
			return	0 ;
	}	else	{
#ifdef	LOCKQ_DEBUG
		_ASSERT( InterlockedDecrement( &m_lock ) == 0 ) ;
#endif
	}

	return	m_pHead ;
}


BOOL
CQueueLockV1::OfferOwnership( CQElement* p ) {

	BOOL	fRtn = TRUE ;
	//
	// This function implementes our InterlockedExchange protocol with the
	// appending thread.  We place LOCKVAL into the Next pointer.  If we get
	// NULL back, some other thread is going to get LOCKVAL so we lost the
	// removal lock.
	//

	// The if() is not necessary but maybe eliminates some redundant InterlockedExchanges.
	_ASSERT( p->m_pNext != (CQElement*)((SIZE_T)LOCKVAL) ) ;
	if( p->m_pNext == 0 || p->m_pNext == (CQElement*)((SIZE_T)LOCKVAL) ) {
		CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (void**)&(p->m_pNext), (void*)LOCKVAL ) ;
		_ASSERT( pTemp != (CQElement*)((SIZE_T)LOCKVAL) ) ;
		if( pTemp == 0 || pTemp == (CQElement*)((SIZE_T)LOCKVAL) ) {
			fRtn = FALSE ;
		}	else	{
			p->m_pNext = pTemp ;
		}
	}
	return	fRtn ;
}

void
CQueueLockV1::Remove( ) {
	//
	//	GetHead() must have been called before this.   Calling GetHead will ensure
	//	that the Head Elements next pointer is NOT NULL.
	//
	_ASSERT( m_pHead->m_pNext != 0 ) ;	// We owned the lock so this should be non-null
	_ASSERT( m_pHead != &m_special ) ;	// A prior GetHead() call should leave us
										// pointing at something other than the special element.

#ifdef	LOCKQ_DEBUG
	_ASSERT( m_dwOwningThread == GetCurrentThreadId() ) ;
	_ASSERT( InterlockedIncrement( &m_lock ) == 0 ) ;

#endif

	CQElement*	p = m_pHead ;
	_ASSERT( p->m_pNext != 0 ) ;
	m_pHead = m_pHead->m_pNext ;
	p->m_pNext = 0 ;
#ifdef	LOCKQ_DEBUG
	_ASSERT( InterlockedDecrement( &m_lock ) < 0 ) ;
#endif
}

BOOL
CQueueLockV1::RemoveAndRelease( ) {

#ifdef	LOCKQ_DEBUG
	_ASSERT( InterlockedIncrement( &m_lock ) == 0 ) ;
	_ASSERT( m_dwOwningThread == GetCurrentThreadId() ) ;
#endif

	_ASSERT( m_pHead->m_pNext != 0 ) ;
	_ASSERT( m_pHead != &m_special ) ;
	m_pHead = m_pHead->m_pNext ;

#ifdef	LOCKQ_DEBUG
	_ASSERT( InterlockedDecrement( &m_lock ) < 0 ) ;
#endif
	BOOL	fRtn = OfferOwnership( m_pHead ) ;

	return	fRtn ;
}


BOOL
CQueueLockV1::GetHead( CQElement*& pFront ) {
	//
	// This function will return the element that is at the head of the
	// Queue as long as this thread continues to own the Remove Lock.
	//


	BOOL	fRtn = FALSE ;

	pFront = 0 ;
	if( OfferOwnership( m_pHead ) ) {
#ifdef	LOCKQ_DEBUG
		_ASSERT( m_dwOwningThread == GetCurrentThreadId() ) ;
		_ASSERT( InterlockedIncrement( &m_lock ) == 0 ) ;
#endif
		pFront = GetFront( ) ;
		if( pFront != 0 )
			fRtn = TRUE ;

#ifdef	LOCKQ_DEBUG
		_ASSERT( InterlockedDecrement( &m_lock ) < 0 ) ;
#endif

	}

	return	fRtn ;
}

BOOL
CQueueLockV1::Append( CQElement*	pAppend ) {
	//
	// We must set the Next pointer to NULL so that the next
	//	we come to append the tail pointer is properly set up.
	//
	_ASSERT( pAppend->m_pNext == 0 ) ;
	pAppend->m_pNext = 0 ;

	// Get the old tail pointer.  This guy won't be touched by the
	// remove thread if his next pointer is still NULL.
	CQElement*	pTemp = (CQElement*)InterlockedExchangePointer( (PVOID *)&m_pTail, pAppend ) ;

	// After we set the old tail pointer's next pointer to NON NULL
	// he becomes fair game for whoever is removing from the queue.
	// We may become the thread removing from the queue if whoever was
	// previously removing got to the last element and changed its next pointer
	// to LOCKVAL.
	//
	// NOTE : This thread and any thread doing removals should be the only
	//	threads touching the pNext field of the pTemp element.
	//
	PVOID l = InterlockedExchangePointer( (PVOID *)&(pTemp->m_pNext), pAppend ) ;


#ifdef	LOCKQ_DEBUG
	if( l== (PVOID)LOCKVAL ) {
		_ASSERT( InterlockedIncrement( &m_lock ) == 0 ) ;
		m_dwOwningThread = GetCurrentThreadId() ;
		_ASSERT( InterlockedDecrement( &m_lock ) < 0 ) ;
	}
#endif


	return	l == (PVOID)LOCKVAL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\makefile.inc ===
$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfilt.h $(O)\nntpfilt_i.c : $(STAXNNTP)\core\include\nntpfilt.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfilt_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfilt_i.c \
    -header $@ \
    -tlb $(O)\nntpfilt.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpsvc.h $(O)\nntpsvc_s.c : ..\..\nntpsvc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -oldnames \
    -client none \
    -sstub $(O)\nntpsvc_s.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpmsg.h $(O)\nntpmsg.rc $(O)\msg00001.bin: nntpmsg.mc ..\..\..\..\inc\inetamsg.mc
    copy /a ..\..\..\..\inc\inetamsg.mc + /a nntpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\nntpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\nntpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\io.inl ===
/*++
	io.inl

	This file contains the inline functions specified in io.h
	These are generally all helper functions which forward their calls with some
	argument massaging.

--*/


inline	void*
CChannel::operator	new(	size_t	size )	{

	//
	//	This function routes all allocations of any CChannel derived object
	//	into our CPool which exists just for that purpose


	Assert( size <= cbMAX_CHANNEL_SIZE ) ;
	void*	pv = gChannelPool.Alloc() ;
	return	pv ;
}

inline	void
CChannel::operator	delete(	void*	pv ) {
	//
	//	All deletions of CChannel derived objects go into our CPool as well
	//
	gChannelPool.Free( pv ) ;
}	

void	CFileChannel::FlushFileBuffers()	{
	m_lock.ShareLock() ;
	if( m_pFIOContext )
		::FlushFileBuffers( m_pFIOContext->m_hFile ) ;
	m_lock.ShareUnlock() ;
}

inline	void	CStream::IssuePacket(	CReadPacket*	pPacket,	
													CSessionSocket	*pSocket,
													BOOL& eof )	{

	//
	//	Stamp this packet with a sequence number and
	//	then send to the Source Channel to be issued.
	//	NOTE : This function should only be called by one thread at a time
	//	for a given CStream !
	//

	TraceFunctEnter( "CStream::IssuePacket" ) ;

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cSequenceThreads ) == 0 ) ;
	#endif
	Assert( m_fRead ) ;
	Assert( pPacket->m_pOwner == m_pOwner || m_pOwner == 0 ) ;

	ASSIGN(pPacket->m_sequenceno, m_sequencenoOut);
	INC(m_sequencenoOut);

	DebugTrace( (DWORD_PTR)this, "Issuing Packet %x, pPacket->m_sequenceno %d m_sequencenoOut %d", pPacket, LOW(pPacket->m_sequenceno),
			LOW(m_sequencenoOut) ) ;

	#ifdef	CIO_DEBUG
	Assert(	InterlockedDecrement( &m_cSequenceThreads ) < 0 ) ;
	Assert( m_cSequenceThreads == -1 ) ;
	#endif

	BOOL	fRtn = m_pSourceChannel->Read( pPacket,	pSocket, eof ) ;

	if( !fRtn ) {
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_NTERROR, GetLastError() ) ;
		//delete	pPacket ;
		//pPacket->m_pOwner->DestroyPacket( pPacket ) ;
		pPacket->m_fRequest = FALSE;
		pPacket->m_pOwner->m_pReadStream->ProcessPacket( pPacket, pSocket ) ;
	}
}

inline	void	CStream::IssuePacket(	CWritePacket*	pPacket,	
													CSessionSocket	*pSocket,
													BOOL&	eof )	{

	//
	//	Stamp this packet with a sequence number and
	//	then send to the Source Channel to be issued.
	//	NOTE : This function should only be called by one thread at a time
	//	for a given CStream !
	//

	TraceFunctEnter( "CStream::IssuePacket" ) ;

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cSequenceThreads ) == 0 ) ;
	#endif
	Assert( !m_fRead ) ;
	Assert( pPacket->m_pOwner == m_pOwner || m_pOwner == 0  ) ;

	ASSIGN(pPacket->m_sequenceno, m_sequencenoOut);
	INC(m_sequencenoOut);

	DebugTrace( (DWORD_PTR)this, "Issuing Packet %x, pPacket->m_sequenceno %d m_sequencenoOut %d", pPacket, LOW(pPacket->m_sequenceno),
		LOW(m_sequencenoOut) ) ;

	#ifdef	CIO_DEBUG
	Assert(	InterlockedDecrement( &m_cSequenceThreads ) < 0 ) ;
	Assert( m_cSequenceThreads == -1 ) ;
	#endif
	BOOL	fRtn = m_pSourceChannel->Write( pPacket,	pSocket, eof ) ;
	if( !fRtn ) {
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_NTERROR, GetLastError() ) ;
		//delete	pPacket ;
		//pPacket->m_pOwner->DestroyPacket( pPacket ) ;
		pPacket->m_fRequest = FALSE;
		pPacket->m_pOwner->m_pWriteStream->ProcessPacket( pPacket, pSocket ) ;
	}
}	

inline	void	CStream::IssuePacket(	CTransmitPacket*	pPacket,	
													CSessionSocket	*pSocket,
													BOOL&	eof )	{

	//
	//	Stamp this packet with a sequence number and
	//	then send to the Source Channel to be issued.
	//	NOTE : This function should only be called by one thread at a time
	//	for a given CStream !
	//

	TraceFunctEnter( "CStream::IssuePacket" ) ;

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cSequenceThreads ) == 0 ) ;
	#endif
	Assert( !m_fRead ) ;
	Assert( pPacket->m_pOwner == m_pOwner || m_pOwner == 0  ) ;

	ASSIGN(pPacket->m_sequenceno, m_sequencenoOut);
	INC(m_sequencenoOut);

	DebugTrace( (DWORD_PTR)this, "Issuing Packet %x, pPacket->m_sequenceno %d m_sequencenoOut %d", pPacket, LOW(pPacket->m_sequenceno),
			LOW(m_sequencenoOut) ) ;

	#ifdef	CIO_DEBUG
	Assert(	InterlockedDecrement( &m_cSequenceThreads ) < 0 ) ;
	Assert( m_cSequenceThreads == -1 ) ;
	#endif

	BOOL	fRtn = m_pSourceChannel->Transmit( pPacket,	pSocket, eof ) ;
	if( !fRtn ) {
		pPacket->m_pOwner->UnsafeClose( pSocket, CAUSE_NTERROR, GetLastError() ) ;
		//delete	pPacket ;
		pPacket->m_pOwner->DestroyPacket( pPacket ) ;
	}
}

inline	BOOL	CStream::SendIO(	CSessionSocket*	pSocket,	
											CIO&	pio,	
											BOOL	fStart )	{

	//
	//	This function will set the m_pIOCurrent member variable to pio
	//	However, since we want the CIO objects to be called on only
	//	one thread for all Start calls and Completion calls, we will
	//	use ProcessPacket to slip this object in.
	//	ProcessPacket will ensure that only one thread mucks with m_pIOCurrent.
	//

//	Assert( !((!!m_fRead) ^ (!!pio->IsRead())) ) ;

	TraceFunctEnter( "CStream::SendIO" ) ;

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cNumberSends ) == 0 ) ;
	#endif

	CControlPacket*	pSpecialPacket = (CControlPacket*)InterlockedExchangePointer( (void**)&m_pSpecialPacket, 0 ) ;

	if( pSpecialPacket != 0 )		{

		DebugTrace( (DWORD_PTR)this, "m_pSpecialPacket %x", m_pSpecialPacket ) ;

		Assert( pSpecialPacket->m_control.m_type == ILLEGAL ) ;
#if 0
		Assert( pSpecialPacket->m_control.m_StartIO.m_pio == 0 ) ;
		Assert( pSpecialPacket->m_control.m_StartIO.m_fStart == FALSE ) ;
#else
		_ASSERT( pSpecialPacket->m_control.m_pio == 0 ) ;
		_ASSERT( pSpecialPacket->m_control.m_pioPassThru == 0 ) ;
		_ASSERT( pSpecialPacket->m_control.m_fStart == FALSE ) ;
#endif
	
		m_pSpecialPacketInUse = pSpecialPacket ;		

		pSpecialPacket->StartIO( pio, fStart ) ;
		ProcessPacket(	pSpecialPacket, pSocket ) ;	

	}	else	{

		// An error occurred - should we call the IO objects Shutdown function !?!?
		// Let the caller handle the problem !
		
		return	FALSE ;
	}
	return	TRUE ;
}

#ifdef	RETIRED
inline	void	CStream::Shutdown(	CSessionSocket*	pSocket,
												BOOL	fCloseSource )		{

	//
	//	This function exists to Shutdown a driver -
	//	This should be retired and replaced by UnsafeShutdown().
	//

	#ifdef	CIO_DEBUG
	Assert( InterlockedIncrement( &m_cThreadsSpecial ) == 0 ) ;
	#endif

	Assert( m_pSpecialPacket->m_control.m_type == ILLEGAL ) ;
	Assert( m_pSpecialPacket->m_control.m_StartIO.m_pio == 0 ) ;
	Assert( m_pSpecialPacket->m_control.m_StartIO.m_fStart == FALSE ) ;

	if( InterlockedIncrement( &m_cShutdowns ) > 0 ) {
		// somebody has already shut the system down !!
		// It must be somebody forcing the session closed !!
	}	else	{
		m_pSpecialPacket->Shutdown( fCloseSource ) ;
		ProcessPacket(	m_pSpecialPacket,	pSocket ) ;
	}

	#ifdef	CIO_DEBUG
	Assert( InterlockedDecrement( &m_cThreadsSpecial ) < 0 ) ;
	Assert(	m_cThreadsSpecial >= -1 ) ;
	#endif
}
#endif

inline	void	CStream::UnsafeShutdown(	CSessionSocket*	pSocket,
													BOOL fCloseSource )	{

	//
	//	UnsafeShutdown will send exactly 1 packet to the CStream
	//	which when processed will tell the CStream to shut itself down.
	//	We can be called by multiple threads.
	//

	CControlPacket*	pShutdownPacket = (CControlPacket*)InterlockedExchangePointer( (void**)&m_pUnsafePacket, 0 ) ;
	if( pShutdownPacket ) {
 		if( InterlockedIncrement( &m_cShutdowns ) > 0 ) {
			// somebody has already shut the system down !
			//delete	pShutdownPacket ;
			CPacket::DestroyAndDelete( pShutdownPacket ) ;
		}	else	{
			// we get to shut the socket down !
			m_pUnsafeInuse = pShutdownPacket ;
			pShutdownPacket->Shutdown( fCloseSource ) ;
			ProcessPacket( m_pUnsafeInuse, pSocket ) ;
		}
	}	
}


inline	BOOL
CIODriver::SendReadIO(	CSessionSocket*	pSocket,	
						CIO&			pRead,	
						BOOL	fStart )		{

	//
	//	This function sends CIORead derived objects to the
	//	appropriate CStream object.
	//

	if( !m_pReadStream->SendIO( pSocket, pRead, fStart ) ) {
		pRead.DoShutdown( pSocket, *this,  m_cause, 0 ) ;
		return	FALSE ;
	}
	return	TRUE ;
}		

inline	BOOL	
CIODriver::SendWriteIO(	CSessionSocket*	pSocket,	
						CIO&	pWrite,	
						BOOL	fStart )	{

	//
	//	This function sends CIOWrite derived objects to the
	//	appropriate CStream object.
	//	We use CStream::SendIO to do the brunt of the work.
	//

	if( !m_pWriteStream->SendIO( pSocket, pWrite, fStart ) ) {
		pWrite.DoShutdown( pSocket, *this, m_cause, 0 ) ;
		return	FALSE ;
	}
	return	TRUE ;
}

inline	void
CIODriver::CompleteWritePacket(	CWritePacket*	pPacket,	CSessionSocket*	pSocket ) {
/*++

Routine Description :

	This function is for use by CChannel's which can optimize Write's and
	complete them immediately.  We call ProcessPacket(), the grunt worker of
	processing packets.

Arguments :

	pPacket -	The Completed packet
	pSocket-	The socket associated with this packet

Return Value :

	None.

--*/

	m_pWriteStream->ProcessPacket( pPacket, pSocket ) ;

}

inline	CReadPacket*
CIODriver::CreateDefaultRead(	unsigned	cbRequest
								)	{
	//
	//	Route the CreateDefaultRead call to the CStream object
	//	which handles Reads for this stream.
	//	All the work will happen there.
	//
	return	m_pReadStream->CreateDefaultRead( *this,	cbRequest ) ;
}

inline	CWritePacket*
CIODriver::CreateDefaultWrite(	unsigned	cbRequest )		{
	//
	//	Route this call to the CStream object which handles all writes
	//
	return	m_pWriteStream->CreateDefaultWrite( *this, cbRequest ) ;
}

inline	CWritePacket*
CIODriver::CreateDefaultWrite(	CBUFPTR&	pbuffer,	
								unsigned	ibStart,	
								unsigned	ibEnd,	
								unsigned	ibStartData,	
								unsigned	ibEndData )	{

	//
	//	Route this call to the CStream object which handles all writes
	//
	return	m_pWriteStream->CreateDefaultWrite(	*this,	pbuffer,
													ibStart,	ibEnd,
													ibStartData,	ibEndData ) ;
}

inline	CWritePacket*	
CIODriver::CreateDefaultWrite(	CReadPacket*	pRead )		{
	//
	//	Route this call to the CStream object which handles all writes
	//
	return	m_pWriteStream->CreateDefaultWrite( *this, pRead->m_pbuffer, pRead->m_ibStart,
									pRead->m_ibEnd, pRead->m_ibStartData, pRead->m_ibEndData ) ;
}

inline	CTransmitPacket*	
CIODriver::CreateDefaultTransmit(	FIO_CONTEXT*	pFIOContext,	
									DWORD	ibOffset,	
									DWORD	cbLength ) {
	//
	//	Route this call to the CStream object which handles all writes
	//
	return	m_pWriteStream->CreateDefaultTransmit( *this, pFIOContext, ibOffset, cbLength ) ;
}

inline	CExecutePacket*
CIODriver::CreateExecutePacket(	)	{
	return	new(	&m_packetCache )	CExecutePacket( *this ) ;
}

inline	void
CIODriver::ProcessExecute(	CExecutePacket*	pExecute,
							CSessionSocket*	pSocket
							)	{
	pExecute->m_fRequest = FALSE ;
	m_pWriteStream->ProcessPacket(	pExecute, pSocket ) ;	
}

inline	CReadPacket*	
CIODriverSource::Clone(		CReadPacket*	pRead ) {
	//
	//	Makes a copy of a CReadPacket
	//
	return	new CReadPacket( *this, *pRead ) ;
}

inline	CWritePacket*	
CIODriverSource::Clone(		CWritePacket*	pWrite ) {
	//
	//	Makes a copy of a CWritePacket
	//
	return	new CWritePacket( *this, *pWrite ) ;
}

inline	CTransmitPacket*	
CIODriverSource::Clone(	CTransmitPacket*	pTransmit ) {
	return	new	CTransmitPacket(	*this, *pTransmit ) ;
}


inline	void	
CIODriver::IssuePacket(	CReadPacket	*pPacket,	
						CSessionSocket	*pSocket,	
						BOOL&	eof )	{

	//
	//	Route this call to the CStream object which handles all reads
	//
	m_pReadStream->IssuePacket( pPacket,	pSocket,	eof ) ;
}

inline	void	
CIODriver::IssuePacket(	CWritePacket *pPacket,	
						CSessionSocket	*pSocket,	
						BOOL&	eof )	{

	//
	//	Route this call to the CStream object which handles all writes
	//
	m_pWriteStream->IssuePacket( pPacket,	pSocket,	eof ) ;
}

inline	void	
CIODriver::IssuePacket(	CTransmitPacket	*pPacket,	
						CSessionSocket	*pSocket,	
						BOOL&	eof )	{

	//
	//	Route this call to the CStream object which handles all writes
	//
	m_pWriteStream->IssuePacket( pPacket,	pSocket,	eof ) ;
}

inline	CBuffer*
CIODriver::AllocateBuffer(	DWORD	cbBuffer	) {


	DWORD	cbOut = 0 ;
	CBuffer*	pbuffer = new(	cbBuffer,
								cbOut,
								&m_bufferCache,
								m_pMediumCache )
								CBuffer( cbOut ) ;

	return	pbuffer ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the W3 Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        JohnL   ????
        MuraliK     11-July-1995 Used Ipc() functions from Inetsvcs.dll

*/

#define INCL_INETSRV_INCS
#include "tigris.hxx"

#define HEAP_INIT_SIZE (KB * KB)

//
// RPC related includes
//

extern "C" {
#include <inetinfo.h>
#include <nntpsvc.h>
};

#include "isrpcexp.h"

//
//  Private globals.
//

DEFINE_TSVC_INFO_INTERFACE();
DECLARE_DEBUG_PRINTS_OBJECT( );
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisNntpServerGuid, 
0x784d8906, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif

BOOL ServiceBooted      = FALSE;
BOOL g_fRpcInitialized  = FALSE;

//
//	Global startup named event
//
HANDLE              ghStartupEvent = INVALID_HANDLE_VALUE;
PNNTP_IIS_SERVICE   g_pNntpSvc = NULL ;

//
// The following critical section synchronizes execution in ServiceEntry().
// This is necessary because the NT Service Controller may reissue a service
// start notification immediately after we have set our status to stopped.
// This can lead to an unpleasant race condition in ServiceEntry() as one
// thread cleans up global state as another thread is initializing it.
//

CRITICAL_SECTION g_csServiceEntryLock;

//
//  Private prototypes.
//

APIERR 
InitializeService( 
			LPVOID pContext 
			);

APIERR 
TerminateService( 
			LPVOID pContext 
			);

//
//	Dll entry point
//

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

BOOL	WINAPI
DllEntryPoint( 
			HINSTANCE	hinstDll,	
			DWORD		dwReason,	
			LPVOID		lpvReserved ) {

	switch( dwReason ) {

		case	DLL_PROCESS_ATTACH :

#ifdef _NO_TRACING_
            CREATE_DEBUG_PRINT_OBJECT(NNTP_MODULE_NAME);
            SET_DEBUG_FLAGS(0);
#else
            CREATE_DEBUG_PRINT_OBJECT(NNTP_MODULE_NAME, IisNntpServerGuid);
#endif

			_Module.Init(ObjectMap, hinstDll);

			//
			// To help performance, cancel thread attach and detach notifications
			//
			DisableThreadLibraryCalls((HMODULE) hinstDll );
            InitializeCriticalSection( &g_csServiceEntryLock );
			break ;

		case	DLL_THREAD_ATTACH : 
			break ;

		case	DLL_THREAD_DETACH : 
			break ;

		case	DLL_PROCESS_DETACH : 

			_Module.Term();

			if( ghStartupEvent != INVALID_HANDLE_VALUE ) {
				_VERIFY( CloseHandle( ghStartupEvent ) );
			}

            DELETE_DEBUG_PRINT_OBJECT();
            DeleteCriticalSection( &g_csServiceEntryLock );
            
			break ;

	}
	return	TRUE ;
}


BOOL	WINAPI
DllMain(	HANDLE	hInst,
			ULONG	dwReason,
			LPVOID	lpvReserve )	{

	return	DllEntryPoint( (HINSTANCE)hInst, dwReason, lpvReserve ) ;

}

//
//  Public functions.
//

VOID ServiceEntry( DWORD                cArgs,
                   LPWSTR               pArgs[],
                   PTCPSVCS_GLOBAL_DATA    pGlobalData     // unused 
                    )

/*++

Routine Description : 

	This function is the first thing called by the service control
	manager during boot up.
	The server can boot into one of 2 modes : 

		1) Normal operations - 
			In this case we want start everything, start listening
			for client connections and do the regular NNTP stuff.

		2) Recovery Boot -
			In this case we are being launched by a companion tool
			(nntpbld.exe) and are being provided with a bunch of
			arguments.  Those arguments specify what kind of 
			error recovery we want to do.  In this mode the 
			server does not accept clients, RPC's or anything - 
			we attempt to rebuild disk base data structures.

	K2 NOTE: This is not true anymore - we will always boot in normal mode !

Arguments : 

	cArgs - Number of args passed to service. If more than
		1 we assume we are doing a Recovery Boot.

	pArgs - Array of arguments.

	pGlobalData - Gibraltar data.

Return Value : 

	No return value.
	If an error occurs during, we will return immediately.

--*/
{
    APIERR err = NO_ERROR;
    BOOL fInitSvcObject = FALSE;
    BOOL fHeapCreated;

    OutputDebugString( "\n*** Entering NNTPSVC ServiceEntry function!\n");

    EnterCriticalSection( &g_csServiceEntryLock );

    //
    // Initialize the global heap
    //
    _VERIFY( fHeapCreated = CreateGlobalHeap( NUM_EXCHMEM_HEAPS, 0, HEAP_INIT_SIZE, 0 ) );
    if ( !fHeapCreated ) {
        OutputDebugString( "\n Failed to initialize exchmem \n" );
        err = ERROR_NOT_ENOUGH_MEMORY;
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    //
    //	Initialize atq etc
    //
    if( !InitCommonDlls() ) {
        _VERIFY( DestroyGlobalHeap() );
        OutputDebugString( "\n Failed to Init common Dlls \n");
        err = GetLastError();
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    InitAsyncTrace();
    //ENTER("ServiceEntry")

    //
    //  Initialize the service status structure.
    //

    g_pInetSvc = new NNTP_IIS_SERVICE( 
                                    NNTP_SERVICE_NAME_A,        // Service name
                                    NNTP_MODULE_NAME,           // Module name
                                    NNTP_PARAMETERS_KEY_A,      // Param reg key
                                    INET_NNTP_SVC_ID,           // Service Id
                                    INET_NNTP_SVCLOC_ID,        // Service locator Id
                                    TRUE,                       // Multiple instances supported
                                    0,                          // Default recv buffer for AcceptEx - pass 0 to disable !
                                    NntpOnConnect,              // Connect callback
                                    NntpOnConnectEx,            // Connect callback on AcceptEx
                                    (ATQ_COMPLETION)&CHandleChannel::Completion	// ATQ I/O completion routine
									);

    //
    //  If we couldn't allocate memory for the service info struct, then the
    //  machine is really hosed
    //

    if ( (g_pInetSvc != NULL) && g_pInetSvc->IsActive() )
    {
        fInitSvcObject = TRUE;

        //
        //	Use this as the global service ptr
        //
        g_pNntpSvc = (PNNTP_IIS_SERVICE)g_pInetSvc ;

        //
        //  This blocks until the service is shutdown
        //

        DebugTraceX( 0, "ServiceEntry success: Blocking on StartServiceOperation");
        err = g_pInetSvc->StartServiceOperation(
                                    SERVICE_CTRL_HANDLER(),
                                    InitializeService,
                                    TerminateService
                                    );

        if ( err )
        {
                //
                //  The event has already been logged
                //
                ErrorTraceX( 0, "StartServiceOperation returned %d", err);
        }
    } else if ( g_pInetSvc == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        err = g_pInetSvc->QueryCurrentServiceError();
    }

    //
    //	Cleanup stuff !
    //
    if ( g_pInetSvc != NULL ) {
        //
        //	NOTE: this bumps a ref count down which will cause g_pInetSvc to be deleted !
        //
        g_pInetSvc->CloseService( );
        g_pNntpSvc = NULL ;
    }

    //LEAVE
    TermAsyncTrace();

    //
    //	Cleanup Rpcs, atq etc
    //
    _VERIFY( TerminateCommonDlls() );
    _VERIFY( DestroyGlobalHeap() );
    LeaveCriticalSection( &g_csServiceEntryLock );    

    OutputDebugString( "*** Exiting NNTPSVC ServiceEntry function!\n\n");

notify_scm:
    //
    // We need to tell the Service Control Manager that the service
    // is stopped if we haven't called g_pInetSvc->StartServiceOperation.
    //  1) InitCommonDlls fails, or
    //  2) InitializeGlobals failed, or
    //  3) new operator failed, or
    //  4) NNTP_IIS_SERVICE constructor couldn't initialize properly
    //

    if ( !fInitSvcObject ) {
        SERVICE_STATUS_HANDLE hsvcStatus;
        SERVICE_STATUS svcStatus;

        hsvcStatus = RegisterServiceCtrlHandler( NNTP_SERVICE_NAME,
                                                 SERVICE_CTRL_HANDLER() );

        if ( hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
            svcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            svcStatus.dwCurrentState = SERVICE_STOPPED;
            svcStatus.dwWin32ExitCode = err;
            svcStatus.dwServiceSpecificExitCode = err;
            svcStatus.dwControlsAccepted = 0;
            svcStatus.dwCheckPoint = 0;
            svcStatus.dwWaitHint = 0;

            SetServiceStatus( hsvcStatus, (LPSERVICE_STATUS) &svcStatus );
        }
    }

}  // ServiceEntry

//
//  Private functions.
//


APIERR
InitializeService( 
            LPVOID pContext 
			)
/*++

Routine description : 

	This function initializes all the gibraltar stuff we need.

Arguments : 

	pContext - Gibraltar stuff

Return Value : 

	0 if successfull, ERROR code otherwise.

--*/
{
    APIERR err = ERROR_SERVICE_DISABLED;
    PNNTP_IIS_SERVICE psi = (PNNTP_IIS_SERVICE) pContext;

    ENTER("InitializeService")

    //
    //	Create a startup named event. If this already exists, refuse to boot !!
    //
    HANDLE hEvent = CreateEvent( NULL, FALSE, FALSE, "MicrosoftInternetNewsServerVersion2BootCheckEvent" );
    if( !hEvent || GetLastError() != 0 ) {
    	if( hEvent && GetLastError() == ERROR_ALREADY_EXISTS ) {
	    	_VERIFY( CloseHandle( hEvent ) );
        }

        NntpLogEvent(	NNTP_BOOT_ERROR, 
	        			0, 
		        		(const char **)NULL, 
			        	ERROR_SERVICE_ALREADY_RUNNING
				        ) ;

    	g_pInetSvc->ShutdownService( );
	    return ERROR_SERVICE_ALREADY_RUNNING ;
    }

    //	set the global startup event. this is closed when our DLL_PROCESS_DETACH is called
    ghStartupEvent = hEvent;
    ServiceBooted  = TRUE;

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.  Globals should be
    //  initialized first, then the event logger.  After
    //  the event logger is initialized, the other components
    //  may be initialized in any order with one exception.
    //  InitializeSockets must be the last initialization
    //  routine called.  It kicks off the main socket connection
    //  thread.
    //

    if( ( err = InitializeGlobals() ) ) { 

        //
        //  We set ServiceBooted to FALSE to avoid unnecessary cleanup
        //  in TerminateService(). Need to call TerminateGlobals() in
        //  order to cleanup stuff initialized in InitializeGlobals().
        //

        g_pInetSvc->ShutdownService( );
        TerminateGlobals();
        ServiceBooted = FALSE;

        return	err ;
    }

    //
    //	If we are doing some kind of recovery boot, don't initialize this stuff !!
    //
    if( ( err = psi->InitializeDiscovery())		||
	    ( err = psi->InitializeSockets()  ) )	
    {
	    FatalTrace(0,"Cannot initialize service %d\n",err);
    	g_pInetSvc->ShutdownService( );
	    LEAVE
    	return err;
    }

    //
    // Read and activate all the instances configured
    //

    if( (err = InitializeInstances( psi ) ) ) {
	    g_pInetSvc->ShutdownService( );
    	return err ;
    }

    //
    // Initialize RPCs after booting instances
    //

    if( !InitializeServiceRpc( NNTP_SERVICE_NAME, nntp_ServerIfHandle ) ) 
    {
        NntpLogEvent(	NNTP_INIT_RPC_FAILED, 
	        			0, 
		        		(const char **)NULL, 
			        	GetLastError()
				        ) ;
        g_pInetSvc->ShutdownService( );
        return ERROR_SERVICE_DISABLED;
    }

	g_fRpcInitialized = TRUE ;

    //
    //  Success!
    //

    DebugTrace(0,"InitializeService Successful\n");

    LEAVE
    return NO_ERROR;

}   // InitializeService

APIERR 
TerminateService( 
			LPVOID pContext 
			)
/*++

Routine Description : 

	This function is called when the service is stopped - 
	it tears down all of our data structures and 
	release everything.

Arguments : 

	pContext - Context for Gibraltar stuff.

Return Value : 

	0 if successfull,
	otherwise NT error code.

--*/
{
    PNNTP_IIS_SERVICE psi = (PNNTP_IIS_SERVICE)pContext;
    PCHAR args [1];
    DWORD err;

    ENTER("terminating service\n")

    //
    //	Check that the service booted - if not return
    //
    if( !ServiceBooted ) {
	    return NO_ERROR;
    }
    ServiceBooted = FALSE ;

    TerminateInstances( psi );

    //
    //  Components should be terminated in reverse
    //  initialization order.
    //

    g_pInetSvc->ShutdownService( );
    (VOID)psi->CleanupSockets( );

    if ( (err = psi->TerminateDiscovery()) != NO_ERROR) {
        ErrorTrace(0, "TerminateDiscovery() failed. Error = %u\n", err);
    }

    if(	g_fRpcInitialized ) {
	    CleanupServiceRpc();
    }

    TerminateGlobals();
#ifdef EXEXPRESS
	TsFlushMetaCache(METACACHE_NNTP_SERVER_ID, TRUE);
#endif

    // Log a successful stop event !
    args [0] = szVersionString;
    NntpLogEvent( NNTP_EVENT_SERVICE_STOPPED, 1, (const char**)args, 0) ;

    if (ghStartupEvent != INVALID_HANDLE_VALUE) {
    	CloseHandle (ghStartupEvent);
    	ghStartupEvent = INVALID_HANDLE_VALUE;
    }    	

    LEAVE
    return NO_ERROR;

}  // TerminateService

VOID
NntpLogEvent(
    IN DWORD  idMessage,              // id for log message
    IN WORD   cSubStrings,            // count of substrings
    IN const CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode                 // error code if any
    )
/*++

Routine Description : 

	Log an NT event.
	This function wraps the call to the Gibraltar NT Event Log interface.

Arguments : 

	idMessage - The Message-Id from the .mc file
	cSubStrings - Number of args to log
	apszSubStrings - Strings to be logged
	errCode - a DWORD that will end up in the Event Data.

Return Value : 

	None.

--*/
{
    //
    // Use the Gibraltar logging facility
    //

    g_pInetSvc->LogEvent(  
					idMessage,
                    cSubStrings,
                    apszSubStrings,
                    errCode
                    );

    return;

} // NntpLogEvent

VOID
NntpLogEventEx(
    IN DWORD  idMessage,               // id for log message
    IN WORD   cSubStrings,             // count of substrings
    IN const  CHAR * apszSubStrings[], // substrings in the message
    IN DWORD  errCode,                 // error code if any
	IN DWORD  dwInstanceId			   // virtual server instance id 
    )
/*++

Routine Description : 

	Log an NT event. Use FormatMessage() to print descriptive strings for NT error codes.
	This function wraps the call to NntpLogEvent()

Arguments : 

	idMessage - The Message-Id from the .mc file
	cSubStrings - Number of args to log
	apszSubStrings - Strings to be logged
	errCode - a DWORD that will end up in the Event Data.

Return Value : 

	None.

--*/
{
    //
    // Use FormatMessage() to get the descriptive text
    //
	LPVOID lpMsgBuf;
	CHAR   szId [20];

	TraceFunctEnter( "NntpLogEventEx" );

    if( !FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        errCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
        ) ) 
    {
        DWORD dwError = GetLastError();
        ErrorTrace(0, "FormatMessage error : %d", dwError );
        lpMsgBuf = (LPVOID)LocalAlloc( LPTR, 20 );
        if( lpMsgBuf == NULL ) return;
        wsprintf( (LPTSTR)lpMsgBuf, "%d", dwError );
    }

    PCHAR* args = new PCHAR [cSubStrings+2];
    if( args ) {
        //	Get the instance id
        _itoa( dwInstanceId, szId, 10 );
        args [0] = szId;

        for(int i=1; i<cSubStrings+1; i++)
        {
            args [i] = (PCHAR)apszSubStrings [i-1];
        }

        //	NT error description
        args [i] = (PCHAR)lpMsgBuf;

        NntpLogEvent( idMessage,
                      cSubStrings+2,
                      (const char**)args,
                      errCode
                    );

        delete [] args;
    }

    LocalFree( lpMsgBuf );
    TraceFunctLeave();

    return;

} // NntpLogEventEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\server\newsgrp.cpp ===
/*++

	newsgrp.cpp

	This file contains the code implementing the CNewsGroup class.

	Each CNewsGroup object represents a newsgroup on the hard disk.
	Newsgroup information is saved in a file (group.lst) between boots.
	
	CNewsGroup objects are referenced 3 ways :

	Through a Hash Table which hashes newsgroup names
	Through a Hash Table which hashes group id's
	Through a Doubly Linked list sorted by newsgroup name

	Each Hash Table contains reference counting pointers to the
	newsgroup lists.  Also, anybody who searches for a newsgroup
	gets a reference counting pointer to the newsgroup.
	The only reference to CNewsGroup objects which is not referenced counted
	are those of the doubly linked list. Consequently, when the last reference
	to a newsgroup is removed, the destructor of the newsgroup will
	unlink the doubly linked lists.

--*/

#include    "tigris.hxx"

#include	<ctype.h>
#include	<stdlib.h>

#ifdef	DEBUG
#ifndef	NEWSGRP_DEBUG
#define	NEWSGRP_DEBUG
#endif
#endif

#ifdef DEBUG
DWORD g_cDelete = 0;
#endif

//
//	Error recovery constant - number of article id's to check before
//	assuming that a newsgroup's m_artHigh field is valid.
//
const	int	MAX_FILE_TESTS = 3 ;

const	char	*szArticleFileExtNoDot = "nws" ;
const	char	szArticleFileExtension[] = ".nws" ;

void
BuildVirtualPath(	
			LPSTR	lpstrOut,	
			LPSTR	lpstrGroupName
			) {
/*++

Routine Description -

	Given a newsgroup name generate a path string suitable
	for use with Gibralatar virtual root api's.

Arguments :

	lpstrOut - place to store path
	lpstrGroupName - newsgroup name

Return Value :

	Nothin

--*/

	lstrcpy(lpstrOut, lpstrGroupName);
}

VOID
CExpireThrdpool::WorkCompletion( PVOID pvExpireContext )
{
    GROUPID GroupId  = (GROUPID) ((DWORD_PTR)pvExpireContext);
    CNewsTree* pTree = (CNewsTree*)QueryJobContext();

    TraceFunctEnter("CExpireThrdpool::WorkCompletion");
    _ASSERT( pTree );

    //
    //  Process this group - expire articles that are older than the time horizon
    //

    CGRPPTR pGroup = pTree->GetGroupById( GroupId );
    if( pGroup ) {

        // We need bump the reference of vroot, to avoid the vroot going
        // away or changing while we are doing expiration work.
        // MatchGroupExpire is checked again due to the time window before
        // our last check
        CNNTPVRoot *pVRoot = pGroup->GetVRoot();
        if ( pVRoot && !pVRoot->HasOwnExpire()) {
            DebugTrace(0,"ThreadId 0x%x : expiring articles in group %s", GetCurrentThreadId(), pGroup->GetName());

            //
            //  Special case expiry of large groups - additional threads will be
            //  spawned if the number of articles in this group exceeds a threshold !
            //
            if( ( (lstrcmp( pGroup->GetName(), g_szSpecialExpireGroup ) == 0) ||
                  (lstrcmp( g_szSpecialExpireGroup, "" ) == 0) ) &&
                    (pGroup->GetArticleEstimate() > gSpecialExpireArtCount) ) {
                DebugTrace(0,"Special case expire triggered for %s: art count is %d", pGroup->GetName(), pGroup->GetArticleEstimate());
                if( pGroup->ExpireArticlesByTimeSpecialCase( pGroup->GetGroupExpireTime() ) ) {
                    pVRoot->Release();
                    return;
                }
                DebugTrace(0,"Group %s: Falling thro to normal expire: Low is %d High is %d", pGroup->GetName(), pGroup->GetFirstArticle(), pGroup->GetLastArticle());
            }

            //
            //  Articles in a group can be expired either by walking the article watermarks
            //  or the physical files on disk. Every Xth (X is a reg key) time we will do a
            //  FindFirst/Next so that orphaned files are cleaned up.
            //

            BOOL fDoFileScan = FALSE;
            pTree->CheckExpire( fDoFileScan );
            if( !fDoFileScan ) {
                //  Expires based on watermarks
                pGroup->ExpireArticlesByTime( pGroup->GetGroupExpireTime() );

                // Save fixed properties
                pGroup->SaveFixedProperties();
            } else {
              //  Expires based on FindFirst/Next
              pGroup->ExpireArticlesByTimeEx( pGroup->GetGroupExpireTime() );
            }

            _ASSERT( pVRoot );
            //pVRoot->Release();
        } else {
            DebugTrace( 0, "Vroot changed, we don't need to expire anymore" );
        }

        if ( pVRoot ) pVRoot->Release();

    } else {
        DebugTrace(0,"ThreadId 0x%x : GroupId %d group not found", GetCurrentThreadId(), GroupId );
    }

    TraceFunctLeave();
}

//       FOR every physical article in the news group
//           IF file date of physical article is too old
//               Expire Article
//           ELSE
//               IF Heap is full
//                   Remove youngest article from Heap
//               ENDIF
//               Size += Size of article
//               Insert Article into Heap in oldest to youngest order.
//           ENDIF
//       ENDFOR

BOOL
CNewsGroup::ExpireArticles(
					FILETIME ftExpireHorizon,
					CArticleHeap& ArtHeap,
                    CXIXHeap& XixHeap,
					DWORD& dwSize
					)
/*++

Routine Description :

	Expire articles in a newsgoroup.

Arguments :

	dwSize - In/Out parameter - accumulates size in KB !!

--*/
{
	return FALSE;
}

//       Binary search a range of old article from xover hash table
//       FOR every logical article in the news group
//           IF file date of article is too old
//               Expire Article
//           ENDIF
//       ENDFOR

BOOL
CNewsGroup::ExpireArticlesByTime(
					FILETIME ftExpireHorizon
					)
/*++

Routine Description :

	Expire articles in a newsgoroup.

Arguments :

--*/
{
    TraceFunctEnter( "CNewsGroup::ExpireArticlesByTime" );

    char  szMessageId[MAX_MSGID_LEN];
    DWORD cMessageId = sizeof( szMessageId ) ;
    PNNTP_SERVER_INSTANCE pInst = ((CNewsTree*)m_pNewsTree)->GetVirtualServer();

    //
    // Lock for group access
    //
    ExclusiveLock();

    ARTICLEID LowId = m_iLowWatermark, HighId = m_iHighWatermark;


    DebugTrace((LPARAM)this,"Fast expire - LowId is %d HighId is %d", LowId, HighId );

	if( !m_fAllowExpire || m_fDeleted || (LowId > HighId) || ((CNewsTree*)m_pNewsTree)->m_bStoppingTree) {
	    ExclusiveUnlock();
		return FALSE;
    }

    //
    //  Probe the *real* low mark ie first id with valid NOV entry.
    //  This call to SearchNovEntry() will delete orphaned logical entries...
    //

    while( LowId <= HighId && !pInst->XoverTable()->SearchNovEntry( m_dwGroupId, LowId, 0, 0, TRUE ) ) {
        if( GetLastError() != ERROR_FILE_NOT_FOUND ) break;
        LowId++;
    }

    //
    //  Fix the low watermark if we found a new low.
    //  This handles cases where the low mark is stuck on an orphaned id.
    //

	//EnterCriticalSection( &(m_pNewsTree->m_critLowAllocator) ) ;
	
    if( LowId > m_iLowWatermark ) {
        ErrorTrace((LPARAM)this,"Moving low watermark up from %d to %d ", 
                    m_iLowWatermark, 
                    LowId );
        m_iLowWatermark = LowId;
#ifdef DEBUG
        VerifyGroup();
#endif
    }
	//LeaveCriticalSection( &(m_pNewsTree->m_critLowAllocator) ) ;
	ExclusiveUnlock();

    //
    //  Start a linear sweep from LowId to HighId. If we find an article whose filetime is
    //  younger than the expire time horizon, we stop the scan.
    //

    DebugTrace((LPARAM)this,"Fast Expire - Scanning range %d to %d", LowId, HighId );
    for( ARTICLEID iCurrId = LowId; iCurrId <= HighId && !((CNewsTree*)m_pNewsTree)->m_bStoppingTree; iCurrId++ ) {

        BOOL  fPrimary;
        FILETIME FileTime;
        WORD	HeaderOffset ;
        WORD	HeaderLength ;
        DWORD   cMessageId = sizeof( szMessageId ) ;
        DWORD cStoreId = 0;

        if ( pInst->XoverTable()->ExtractNovEntryInfo(
                                        m_dwGroupId,
                                        iCurrId,
                                        fPrimary,
    			    		            HeaderOffset,
					    	            HeaderLength,
                                        &FileTime,
                                        cMessageId,
                                        szMessageId,
                                        cStoreId,
                                        NULL,
                                        NULL ) ) {

            szMessageId[ cMessageId ] = '\0';
            if ( CompareFileTime( &FileTime, &ftExpireHorizon ) > 0 ) {
                // Current article has a filetime younger than the expire horizon - stop scan
                DebugTrace((LPARAM)this,"article %d is younger than expire horizon - bailing", iCurrId);
                break;
            } else {
	            CNntpReturn NntpReturn;
	            _ASSERT( g_hProcessImpersonationToken );
	            // We are using the process context to do expire
	            if (  pInst->ExpireObject()->ExpireArticle( (CNewsTree*)m_pNewsTree,
	                                                        m_dwGroupId,
	                                                        iCurrId,
	                                                        NULL,
	                                                        NntpReturn,
	                                                        NULL,
	                                                        FALSE,  // fMustDelete
	                                                        FALSE,
	                                                        FALSE,
	                                                        TRUE,
	                                                        szMessageId )
	                /* don't delete the physical article, we'll come back and
	                    expire this article the next round - if we delete the
	                    physical article now, the hash tables are going to
	                    grow wildly
	                || DeletePhysicalArticle(   NULL,
	                                            FALSE,
	                                            iCurrId,
	                                            NULL ) */
	                )
	            {
		            DebugTrace((LPARAM)0,"Expired/deleted on time basis article %d group %d", iCurrId, m_dwGroupId );
		            continue;
	            }
	            else
	            {
		            ErrorTrace((LPARAM)0,"Failed to expire/delete article %d group %d", iCurrId, m_dwGroupId );
	            }
            }
        } else {
            DWORD dwError = GetLastError();
            DebugTrace(0,"ExtractNovEntryInfo returned error %d", dwError );
        }
    }

    return TRUE;
}

//
//       FOR every physical article in the news group
//           IF file date of article is too old
//               Expire Article
//           ENDIF
//       ENDFOR

BOOL
CNewsGroup::ExpireArticlesByTimeEx(
					FILETIME ftExpireHorizon
					)
/*++

Routine Description :

	Expire articles in a newsgoroup.

Arguments :

--*/
{
	return FALSE;
}

//
//  Context for each thread
//

typedef struct _EXPIRE_CONTEXT_ {
    //
    //  Group object
    //
    CNewsGroup* pGroup;

    //
    //  LowId of this threads range
    //
    ARTICLEID   LowId;

    //
    //  HighId of this threads range
    //
    ARTICLEID   HighId;

    //
    //  FILETIME to use
    //
    FILETIME    ftExpireHorizon;
} EXPIRE_CONTEXT,*PEXPIRE_CONTEXT;

DWORD	__stdcall
SpecialExpireWorker( void	*lpv );

//
//  Spawn X threads with divvied up range and wait for all threads to complete
//

BOOL
CNewsGroup::ExpireArticlesByTimeSpecialCase(
					FILETIME ftExpireHorizon
					)
/*++

Routine Description :

	Special case expire for large groups like control.cancel

Arguments :

--*/
{
    BOOL fRet = TRUE;
    ARTICLEID LowId = GetFirstArticle(), HighId = GetLastArticle();
    PNNTP_SERVER_INSTANCE pInst = ((CNewsTree*)m_pNewsTree)->GetVirtualServer();

    TraceFunctEnter( "CNewsGroup::ExpireArticlesByTimeSpecialCase" );
    DebugTrace((LPARAM)this,"Special case expire - LowId is %d HighId is %d", LowId, HighId );

	if(IsDeleted() || (LowId > HighId) || ((CNewsTree*)m_pNewsTree)->m_bStoppingTree)
		return FALSE;

	HANDLE* rgExpireThreads;
    PEXPIRE_CONTEXT rgExpContexts;
	DWORD dwThreadId, cThreads, dwRange, CurrentLow;
    DWORD dwWait, i;
    PCHAR	args[5] ;
    CHAR    szId[10], szHigh[10], szLow[10];
    CHAR    szThreads[10];

    //
    //  Arrays of thread handles and expire contexts per thread. This is allocated
    //  off the stack as the total size is expected to be small...
    //
    rgExpireThreads = (HANDLE*) _alloca( gNumSpecialCaseExpireThreads * sizeof(HANDLE) );
    rgExpContexts = (PEXPIRE_CONTEXT) _alloca( gNumSpecialCaseExpireThreads * sizeof(EXPIRE_CONTEXT) );

    _ASSERT( rgExpireThreads );
    _ASSERT( rgExpContexts );

    //
    //  Instead of using the group HighId as the high part of the range, we want
    //  to "guess" an id between LowId and HighId that better approximates the
    //  range to be expired. This is done by CalcHighExpireId().
    //

    HighId = CalcHighExpireId( LowId, HighId, ftExpireHorizon, gNumSpecialCaseExpireThreads );
    if( HighId <= LowId ) {
        return FALSE;
    }

    dwRange = (HighId - LowId) / gNumSpecialCaseExpireThreads;
    CurrentLow = LowId;
	for( cThreads = 0; cThreads < gNumSpecialCaseExpireThreads; cThreads++ ) {
		rgExpireThreads [cThreads] = NULL;

        //
        //  Setup the contexts for each thread ie divvy up the range
        //
        rgExpContexts [cThreads].pGroup = this;
        rgExpContexts [cThreads].LowId = CurrentLow;
        rgExpContexts [cThreads].HighId = CurrentLow + dwRange - 1;
        rgExpContexts [cThreads].ftExpireHorizon = ftExpireHorizon;
        CurrentLow += dwRange;
	}

    //
    //  Override HighId of last entry
    //
    rgExpContexts [cThreads-1].HighId = HighId;

	//
    //  Spawn X worker threads
    //
	for( cThreads = 0; cThreads < gNumSpecialCaseExpireThreads; cThreads++ )
	{
        PVOID pvContext = (PVOID) &rgExpContexts [cThreads];
		rgExpireThreads [cThreads] = CreateThread(
										NULL,				// pointer to thread security attributes
										0,					// initial thread stack size, in bytes
										SpecialExpireWorker,// pointer to thread function
										(LPVOID)pvContext,	// argument for new thread
										CREATE_SUSPENDED,	// creation flags
										&dwThreadId			// pointer to returned thread identifier
										) ;

		if( rgExpireThreads [cThreads] == NULL ) {
            ErrorTrace(0,"CreateThread failed %d",GetLastError());
            fRet = FALSE;
			goto Cleanup;
		}
	}

    //
    //  Log an event warning admin about huge group
    //

    _itoa( ((CNewsTree*)m_pNewsTree)->GetVirtualServer()->QueryInstanceId(), szId, 10 );
    args[0] = szId;
    args[1] = GetNativeName();
    _itoa( cThreads, szThreads, 10 );
    args[2] = szThreads;
    _itoa( LowId, szLow, 10 );
    _itoa( HighId, szHigh, 10 );
    args[3] = szLow;
    args[4] = szHigh;

    NntpLogEvent(
	    	NNTP_EVENT_EXPIRE_SPECIAL_CASE_LOG,
		    5,
		    (const char **)args,
		    0
		    ) ;

	//
	//	Resume all threads and wait for threads to terminate
	//
	for( i=0; i<cThreads; i++ ) {
		_ASSERT( rgExpireThreads[i] );
		DWORD dwRet = ResumeThread( rgExpireThreads[i] );
		_ASSERT( 0xFFFFFFFF != dwRet );
	}

	//
	//	Wait for all threads to finish
	//
	dwWait = WaitForMultipleObjects( cThreads, rgExpireThreads, TRUE, INFINITE );

	if( WAIT_FAILED == dwWait ) {
		DebugTrace(0,"WaitForMultipleObjects failed: error is %d", GetLastError());
		fRet = FALSE;
	}

    //
    //  Check to see how good our guess was....
    //  If it turns out that HighId+1 needs to be expired,
    //  there is more work to be done in this group ie we fall thro to normal expire..
    //
    fRet = !ProbeForExpire( HighId+1, ftExpireHorizon );

Cleanup:

    //
	//	Cleanup
	//
	for( i=0; i<cThreads; i++ ) {
        if( rgExpireThreads [i] != NULL ) {
		    _VERIFY( CloseHandle( rgExpireThreads[i] ) );
		    rgExpireThreads [i] = NULL;
        }
	}

    return fRet;
}

DWORD	__stdcall
SpecialExpireWorker( void	*lpv )
/*++

Routine Description :

	Expire articles in a newsgroup in a given range

Arguments :

--*/
{
    PEXPIRE_CONTEXT pExpContext = (PEXPIRE_CONTEXT)lpv;
    CNewsGroup* pGroup = pExpContext->pGroup;
    ARTICLEID LowId = pExpContext->LowId, HighId = pExpContext->HighId;
    CNewsTree* pTree = (CNewsTree*)(pGroup->GetTree());
    PNNTP_SERVER_INSTANCE pInst = pTree->GetVirtualServer();
    char  szMessageId[MAX_MSGID_LEN];
    DWORD cMessageId = sizeof( szMessageId ) ;

    TraceFunctEnter( "SpecialExpireWorker" );
    DebugTrace(0,"special case expire - LowId is %d HighId is %d", LowId, HighId );

	if( (LowId > HighId) || pTree->m_bStoppingTree)
		return 0;

    //
    //  Start a linear sweep from LowId to HighId. If we find an article whose filetime is
    //  younger than the expire time horizon, we stop the scan.
    //

    DebugTrace((LPARAM)pGroup,"Special Case Expire - Scanning range %d to %d", LowId, HighId );
    for( ARTICLEID iCurrId = LowId; iCurrId <= HighId && !pTree->m_bStoppingTree; iCurrId++ ) {

        BOOL  fPrimary;
        FILETIME FileTime;
        WORD	HeaderOffset ;
        WORD	HeaderLength ;
        DWORD   cMessageId = sizeof( szMessageId ) ;
        DWORD   cStoreId = 0;

        if ( pInst->XoverTable()->ExtractNovEntryInfo(
                                        pGroup->GetGroupId(),
                                        iCurrId,
                                        fPrimary,
    			    		            HeaderOffset,
					    	            HeaderLength,
                                        &FileTime,
                                        cMessageId,
                                        szMessageId,
                                        cStoreId,
                                        NULL,
                                        NULL ) ) {

            szMessageId[ cMessageId ] = '\0';
            if ( CompareFileTime( &FileTime, &pExpContext->ftExpireHorizon ) > 0 ) {
                // Current article has a filetime younger than the expire horizon - stop scan
                DebugTrace((LPARAM)pGroup,"article %d is younger than expire horizon - bailing", iCurrId);
                break;
            } else {
	            CNntpReturn NntpReturn;

	            // We use the process imperonation token to do expire
	            _ASSERT( g_hProcessImpersonationToken );
	            if (  pInst->ExpireObject()->ExpireArticle( pTree,
	                                                        pGroup->GetGroupId(),
	                                                        iCurrId,
	                                                        NULL,
	                                                        NntpReturn,
	                                                        NULL,
	                                                        FALSE,
	                                                        FALSE,
	                                                        FALSE,
	                                                        TRUE,
	                                                        szMessageId ) /*
	                || ((CNewsGroup*)pGroup)->DeletePhysicalArticle(   NULL,
	                                                    FALSE,
	                                                    iCurrId,
	                                                    NULL )*/
	                )
	            {
		            DebugTrace((LPARAM)0,"Expired/deleted on time basis article %d group %d", iCurrId, pGroup->GetGroupId() );
		            continue;
	            }
	            else
	            {
		            ErrorTrace((LPARAM)0,"Failed to expire/delete article %d group %d", iCurrId, pGroup->GetGroupId() );
	            }
            }
        } else {
            DWORD dwError = GetLastError();
            DebugTrace(0,"ExtractNovEntryInfo returned error %d", dwError );
        }
    }

    return 0;
}

BOOL
CNewsGroup::ProbeForExpire(
                       ARTICLEID ArtId,
                       FILETIME ftExpireHorizon
                       )
/*++

Routine Description :

	Return TRUE if ArtId needs to be expired, FALSE otherwise

Arguments :

--*/

{
#if 0
    PNNTP_SERVER_INSTANCE pInst = GetTree()->GetVirtualServer();
    BOOL  fPrimary;
    FILETIME FileTime;
    WORD	HeaderOffset ;
    WORD	HeaderLength ;
    char    szMessageId[MAX_MSGID_LEN];
    DWORD   cMessageId = sizeof( szMessageId ) ;

    if ( pInst->XoverTable()->ExtractNovEntryInfo(
                                    GetGroupId(),
                                    ArtId,
                                    fPrimary,
    			    		        HeaderOffset,
					    	        HeaderLength,
                                    &FileTime,
                                    cMessageId,
                                    szMessageId ) ) {

        szMessageId[ cMessageId ] = '\0';
        if ( CompareFileTime( &FileTime, &ftExpireHorizon ) > 0 ) {
            //  article need not be expired
            return FALSE;
        } else {
            //  article needs to be expired
            return TRUE;
        }
    }

    return TRUE;
#else
	return FALSE;
#endif
}

ARTICLEID
CNewsGroup::CalcHighExpireId(
                       ARTICLEID LowId,
                       ARTICLEID HighId,
                       FILETIME  ftExpireHorizon,
                       DWORD     NumThreads
                       )
/*++

Routine Description :

	Calculate an estimate of the highest id that needs to be expired.
    This is done per following formula:

    T1 = timestamp of LowId
    T2 = timestamp of HighId
    TC = current timestamp
    E  = expire horizon

    Average# of articles per time unit = (HighId - LowId) / (T2 - T1)

    if (TC - T1) < E => No work to do since oldest article is < horizon
    if (TC - T1) > E => (TC - T1) - E = Number of time units we are behind

    So, calculated high expire id = LowId + ((Avg# per time unit) * (TC - T1 - E))
    Note that we are given ftExpireHorizon which is (TC - E)

Arguments :

--*/

{
#if 0
    PNNTP_SERVER_INSTANCE pInst = GetTree()->GetVirtualServer();
    ULARGE_INTEGER liT1, liT2, liHorizon, liBacklog, liTimeRange, liResult;
    DWORD dwRange, CurrentLow, cThreads;

    BOOL  fPrimary;
    FILETIME ft1, ft2;
    WORD	HeaderOffset ;
    WORD	HeaderLength ;
    char    szMessageId[MAX_MSGID_LEN];

    //
    //  Default is 50% ie LowId + (HighId - LowId)/2;
    //
    DWORD CalcHighId = LowId + ( (HighId-LowId)/2 );

    //
    //  Get timestamp of LowId ie T1
    //

    DWORD cMessageId = sizeof( szMessageId ) ;
    if ( !pInst->XoverTable()->ExtractNovEntryInfo(
                                    GetGroupId(),
                                    LowId,
                                    fPrimary,
    			    		        HeaderOffset,
					    	        HeaderLength,
                                    &ft1,
                                    cMessageId,
                                    szMessageId ) ) {
        goto fixup_guess;
    } else if ( CompareFileTime( &ft1, &ftExpireHorizon ) > 0 ) {
        //  article need not be expired
        return LowId;
    }

    //
    //  Get timestamp of HighId ie T2
    //

    cMessageId = sizeof( szMessageId ) ;
    if ( !pInst->XoverTable()->ExtractNovEntryInfo(
                                    GetGroupId(),
                                    HighId,
                                    fPrimary,
    			    		        HeaderOffset,
					    	        HeaderLength,
                                    &ft2,
                                    cMessageId,
                                    szMessageId ) ) {
        goto fixup_guess;
    }

    //
    // ok, now lets do the math...
    //

    LI_FROM_FILETIME( &liT1, &ft1 );
    LI_FROM_FILETIME( &liT2, &ft2 );
    LI_FROM_FILETIME( &liHorizon, &ftExpireHorizon );

    //  (TC - T1 - E) * (High - Low)
    liBacklog.QuadPart = liHorizon.QuadPart - liT1.QuadPart;
    liBacklog.QuadPart  /= 1000 * 1000 * 10; // to achieve units of seconds
    liBacklog.QuadPart  /= 60 * 60; // to achieve units of hours
    liBacklog.QuadPart *= (HighId - LowId);

    //  T2 - T1
    liTimeRange.QuadPart = liT2.QuadPart - liT1.QuadPart;
    liTimeRange.QuadPart  /= 1000 * 1000 * 10; // to achieve units of seconds
    liTimeRange.QuadPart  /= 60 * 60; // to achieve units of hours

    //  Result = (Backlog / Range) if Range != 0
    if( liTimeRange.QuadPart != 0 ) {
        liResult.QuadPart = liBacklog.QuadPart / liTimeRange.QuadPart ;
        CalcHighId = LowId + liResult.LowPart;
    } else {
        //  HighId and LowId are within the same hour !!
        CalcHighId = HighId;
    }

fixup_guess:

    // ensure we are not too high...
    if( CalcHighId > HighId ) {
        CalcHighId = HighId;
    }

    //
    //  Now that we have a good starting guess, we will do a few hash table probes
    //  to further tune the calculated high id..
    //

    dwRange = (CalcHighId - LowId) / NumThreads;
    CurrentLow = LowId;
	for( cThreads = 0; cThreads < NumThreads; cThreads++ ) {
        //
        //  Probe CurrentLow for expire..
        //
        if( !ProbeForExpire( CurrentLow, ftExpireHorizon ) ) {
            //  CurrentLow need not be expired
            CalcHighId = CurrentLow - 1;
            break;
        }

        CurrentLow += dwRange;
	}

    return CalcHighId;
#else
	return 0;
#endif
}

//       FOR every physical article in the news group in our range
//               Expire Article
//       ENDFOR
//       FOR every xover index file in the news group in our range
//               Delete the index file
//       ENDFOR
//		 NOTE: This function will DELETE all xover index files (in our range) in this directory !

BOOL
CNewsGroup::DeleteArticles(
					SHUTDOWN_HINT_PFN	pfnHint,
					DWORD				dwStartTick
					)
/*++

Routine Description :

	Delete all articles in a newsgroup. This function could be called with a
	NULL value for pfnHint. In this case, the function will bail if the service
	is stopped (a global is checked for this). Once the service is stopped,
	this function should not spend more than dwShutdownLatency amount of time
	deleting articles. (use dwStartTick as the base)

Arguments :

	pfnHint			-	pointer to stop hint function
	dwStartTick		-	timestamp of start of shutdown process

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/
{
    char szFile[ MAX_PATH*2 ];
	//WIN32_FIND_DATA FileStats;
	//HANDLE hFind;
	ARTICLEID iArticleId;
	BOOL fRet = TRUE;
	szFile[0] = '\0' ;

    TraceFunctEnter( "CNewsGroup::DeleteArticles" );

	CNewsTree* ptree = (CNewsTree *) GetTree();
	DWORD iFreq = 0;
	PNNTP_SERVER_INSTANCE pInstance = ptree->GetVirtualServer() ;

	//
	//	First delete all articles in the group
	//

	// Expire/Delete articles ONLY if it is within our range - we dont want to delete
	// new articles in a re-created avtar of this group
	for( iArticleId = m_iLowWatermark; iArticleId <= m_iHighWatermark; iArticleId++, iFreq++ )
	{
		CNntpReturn NntpReturn;

		// If we need to bail on service stop, do so. Else give stop hints if needed
		if( ptree->m_bStoppingTree ) {
			if( !pfnHint ) {
				return FALSE;
			} else if( (iFreq%200) == 0 ) {
				pfnHint() ;
				if( (GetTickCount() - dwStartTick) > dwShutdownLatency ) {
					return FALSE;	// upper bound on shutdown latency
				}
			}
		}

		GROUPID groupidPrimary;
		ARTICLEID artidPrimary;
		DWORD DataLen;
		WORD HeaderOffset, HeaderLength;
		CStoreId storeid;

		if (pInstance->XoverTable()->GetPrimaryArticle(GetGroupId(),
														iArticleId,
														groupidPrimary,
														artidPrimary,
														0,
														NULL,
														DataLen,
														HeaderOffset,
														HeaderLength,
														storeid) &&
			(pInstance->ExpireObject()->ExpireArticle(ptree,
													  GetGroupId(),
													  iArticleId,
													  &storeid,
													  NntpReturn,
													  NULL,
													  TRUE, //fMustDelete
													  FALSE,
													  FALSE ) /*||
			 DeletePhysicalArticle(NULL, FALSE, iArticleId, &storeid)*/))
		{
			DebugTrace((LPARAM)this, "Expired/deleted article group:%d article:%d", GetGroupId(), iArticleId);
			continue;
		}
		else
		{
			// error
			ErrorTrace((LPARAM)this, "Error deleting article: group %d article %d", GetGroupId(), iArticleId);
		}
	}

	//
	//	Now delete all xover indices (*.xix) files in the newsgroup
	//	Flush all entries for this group from the xover cache so all file handles are closed
	//
	if(!FlushGroup())
	{
		// If this fails, DeleteFile may fail !
		ErrorTrace((LPARAM)this,"Error flushing xover cache entries" );
	}

	char	szCachePath[MAX_PATH*2] ;
	BOOL	fFlatDir ;
	if( ComputeXoverCacheDir( szCachePath, fFlatDir ) )	{
		ARTICLEID	artNewLow ;
		BOOL	fSuccess =
			XOVER_CACHE(((CNewsTree*)m_pNewsTree))->ExpireRange(	
										m_dwGroupId,
										szCachePath,
										fFlatDir,
										m_artXoverExpireLow,
										m_iHighWatermark+256,	// ADD MAGIC NUMBER - This ensures we delete all the .XIX files !
										artNewLow
										) ;
		if( fSuccess )
			m_artXoverExpireLow = artNewLow ;
	}

    return fRet;
}

//
// This must be the primary group for the Article.
//
BOOL
CNewsGroup::DeletePhysicalArticle(
                                HANDLE hToken,
                                BOOL    fAnonymous,
								ARTICLEID ArticleId,
								STOREID *pStoreId
									)
/*++

Routine Description :

	Delete an article file within a newsgroup.

Arguments :

	ArticleId - id of the article to be deleted.
	pStoreId  - Pointer to the store id

Return Value :

	TRUE if successfull, FALSE otherwise.

--*/
{
    TraceFunctEnter( "CNewsGroup::DeletePhysicalArticle" );


    HRESULT hr = S_OK;
    CNntpSyncComplete scComplete;
    INNTPPropertyBag *pPropBag = NULL;

    // get vroot
    CNNTPVRoot *pVRoot = GetVRoot();
    if ( pVRoot == NULL ) {
        ErrorTrace( 0, "Vroot doesn't exist" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Set vroot to completion object
    //
    scComplete.SetVRoot( pVRoot );

    // Get the property bag
    pPropBag = GetPropertyBag();
    if ( NULL == pPropBag ) {
        ErrorTrace( 0, "Get group property bag failed" );
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Call the vroot wrapper
    pVRoot->DeleteArticle(  pPropBag,
                            1,
                            &ArticleId,
                            pStoreId,
                            hToken,
                            NULL,
                            &scComplete,
                            fAnonymous );

    // Wait for it to complete
    _ASSERT( scComplete.IsGood() );
    hr = scComplete.WaitForCompletion();

    // Property bag should have already been released
    pPropBag = NULL;

Exit:

    if ( pVRoot ) pVRoot->Release();
    if ( pPropBag ) pPropBag->Release();

    if ( FAILED( hr ) ) SetLastError( hr );
    else {
        // this cast should be safe
        PNNTP_SERVER_INSTANCE pInst = ((CNewsTree*)m_pNewsTree)->GetVirtualServer() ;
        InterlockedIncrementStat( pInst, ArticlesExpired );
    }

    TraceFunctLeave();
    return SUCCEEDED( hr );
}

BOOL
CNewsGroup::DeleteLogicalArticle(
							ARTICLEID ArticleId
							)
/*++

Routine Description :

	Advance the newsgroups high and low water marks.
	If an article is deleted from the newsgroup
	we scan the xover table to determine whether there
	is a consecutive run of articles now gone from
	the group so that we can advance the low water mark
	considerably.

Arguments :

	ArticleId - id of the deleted article.

Return Value :

	TRUE if successfull (always successfull)

--*/
{
#ifdef DEBUG
    g_cDelete++;
#endif
    TraceFunctEnter( "CNewsGroup::DeleteLogicalArticle" );

    _ASSERT( m_cMessages > 0 );

    // Possibley update m_artLow
    //
    // Expiry will always delete articles in ArticleId order, but control message won't, so we have'ta
    // consider the case where deleting the m_artLow'th article will cause m_artLow to increase by more
    // than one article (up to and equal to m_artHigh).
    //
    // However, m_artHigh should never be decremented because two different articles would be assigned
    // the same ArticleId.
    //
    //

	ExclusiveLock();

	m_cMessages--;

    if ( ArticleId == m_iLowWatermark )
    {
        for ( m_iLowWatermark++; m_iLowWatermark <= m_iHighWatermark; m_iLowWatermark++ )
        {
            if ( TRUE == (((CNewsTree*)m_pNewsTree)->GetVirtualServer()->XoverTable())->SearchNovEntry( m_dwGroupId, m_iLowWatermark, 0, 0, TRUE ) )
            {
                // Next ArticleId is known valid.
                //
                break;
            }
            if ( ERROR_FILE_NOT_FOUND == GetLastError() )
            {
                // Next ArticleId is known invalid.
                //
                continue;
            }
            // We cannot make any decisions about the next ArticleId, so update
            // of m_artLow will wait. The expiry thread will start with m_artLow
            // next time. That activity should also bump m_artLow up. There could
            // be a conflict if the expiry thread and a control message try to
            // update m_artLow at the same time.
            //
            break;
        }
    }

	//LeaveCriticalSection( &(m_pNewsTree->m_critLowAllocator) ) ;
	ExclusiveUnlock();

	DebugTrace((LPARAM)this, "Deleting xover data for (%lu/%lu)", m_dwGroupId, ArticleId );

	DeleteXoverData( ArticleId ) ;
	ExpireXoverData() ;	

    return TRUE;
}

BOOL
CNewsGroup::RemoveDirectory()
{

	return FALSE;
}

DWORD	
ScanWS(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ' ' || pchBegin[i] == '\t' ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
Scan(	char*	pchBegin,	char	ch,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == ch ) {
			return i+1 ;			
		}		
	}
	return	0 ;
}

DWORD	
ScanEOL(	char*	pchBegin,	DWORD	cb ) {
	//
	//	This is a utility used when reading a newsgroup
	//	info. from disk.
	//

	for( DWORD	i=0; i < cb; i++ ) {
		if( pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
			i++ ;
			return i ;			
		}		
	}
	return	0 ;
}

DWORD	
ScanEOLEx(	char*	pchBegin,	DWORD	cb ) {
    //
    //  This is a utility used when reading a newsgroup
    //  info. from disk.
    //  This utility handles special cases of the active.txt
    //  file when the last newsgroup name is not ended with CRLF.
	//

    for( DWORD	i=0; i < cb; i++ ) {
        if( pchBegin[i] == '\n' || pchBegin[i] == '\r' ) {
            i++ ;
            return i ;			
        }		
    }
    return	i ;
}

DWORD	
ScanTab(	char*	pchBegin,	DWORD	cb ) {
    //
    //  This is a utility used when reading a newsgroup
    //  info. from disk.
    //  This utility handles special cases of the active.txt
    //  file when the last newsgroup name is not ended with CRLF.
	//

    for( DWORD	i=0; i < cb; i++ ) {
        if( pchBegin[i] == '\n' || pchBegin[i] == '\r' || pchBegin[i] == '\t' ) {
            i++ ;
            return i ;			
        }		
    }
    return	0 ;
}

DWORD
ScanNthTab( char* pchBegin, DWORD nTabs ) {

    char *pchCurrent, *pch;
    pch = pchCurrent = pchBegin;
    for( DWORD i=1; i<=nTabs && pch; i++ ) {
        pch = strchr( pchCurrent, '\t' );
        if( pch )
            pchCurrent = pch+1;
    }

    return (DWORD)(pchCurrent-pchBegin);
}

BOOL
CNewsGroup::Init(	
			char	*szVolume,	
			char	*szGroup,
			char	*szNativeGroup,
			char	*szVirtualPath,
			GROUPID	groupid,
			DWORD	dwAccess,
			HANDLE	hImpersonation,
			DWORD	dwFileSystem,
			DWORD	dwSslAccess,
			DWORD	dwContentIndexFlag
			) {
/*++

Routine Description :

	Intialize a newly created newsgroup.

Arguments :

	szVolume - path to the newsgroup
	szGroup - name of the group
	szVirtualPath - The String to use for doing Virtual Root Lookups
	groupid - groupid of the group
	dwAccess - Access as figured out by a call to LookupVirtualRoot
	hImpersonation - Impersonation Handle for this newsgroup
	dwFileSystem - File system tyep
	dwSslAccess - SSL access mask
	dwContentIndexFlag - Is content indexed ?

Return Value :

	TRUE if successfull.

--*/

	return FALSE;
}

BOOL
CNewsGroup::SetArticleWatermarks()
/*++

Routine Description :

	This should be called for a newsgroup being re-created ie. created after a recent
	delete. This function will search the newsgroups directory for existing article
	files and set its low and high watermarks past the highest article id found in the
	directory. This handles the case where a previous delete of the group failed to remove
	old article fails (ie. DeleteFile failed for some reason).

Arguments :


Return Value :

	TRUE if successfull.

--*/

{
	return FALSE;
}

FILETIME
CNewsGroup::GetGroupTime() {
/*++

Routine Description :

	Get the time the newsgroup was created.

Arguments :

	None.

Return Value :

	Time group was created.

--*/

	return	GetCreateDate() ;
}

void
CNewsGroup::SetGroupTime(FILETIME time) {
/*++

Routine Description :

	Set the time the newsgroup was created.

Arguments :

	time - the new group creation time

Return Value :

	none.

--*/
}

BOOL			
CNewsGroup::GetArticle(	IN	ARTICLEID	artid,
						IN	CNewsGroup*	pCurrentGroup,
						IN	ARTICLEID	artidCurrentGroup,
						IN	STOREID&	storeid,
						IN	class	CSecurityCtx*	pSecurity,
						IN	class	CEncryptCtx*	pEncrypt,
						IN	BOOL	fCacheIn,
						OUT	FIO_CONTEXT*	&pContext,
						IN	CNntpComplete*	pComplete						
						)	{
/*++

Routine Description :

	This function retrieves an article from the Driver.
	This should be called on the primary group object !

Arguments :

	artid - The id of the article we want to get
	pSecurity - the Session's NTLM bassed security context
	pEncrypt - the Session's SSL based security context
	fCacheIn - do we want this handle to reside in the cache ? - IGNORED
	hFile - the location that gets the file handle
	pContext - the address that gets the context pointer
	dwFileLength

Return Value :

	TRUE if operation successfully pended
	FALSE otherwise !


--*/

	DWORD	dwFileLengthHigh ;

	pContext = 0 ;

	TraceFunctEnter( "CNewsGroup::GetArticle" ) ;

	char	szFile[ MAX_PATH * 2 ] ;

	ShareLock() ;

	DWORD	dwError = 0 ;

	HANDLE	hImpersonate = NULL ;
	BOOL	fCache = fCacheIn ;
    BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
        fAnonymous = pSecurity->IsAnonymous();

	}

	fCache = fCache && fCacheIn ;

	m_pVRoot->GetArticle(	this,
							pCurrentGroup,
							artid,
							artidCurrentGroup,
							storeid,
							&pContext,
					        hImpersonate,		
							pComplete,
                            fAnonymous
							) ;
	ShareUnlock() ;

	return	TRUE ;
}



void
CNewsGroup::FillBufferInternal(
				IN	ARTICLEID	articleIdLow,
				IN	ARTICLEID	articleIdHigh,
				IN	ARTICLEID*	particleIdNext,
				IN	LPBYTE		lpb,
				IN	DWORD		cbIn,
				IN	DWORD*		pcbOut,
				IN	CNntpComplete*	pComplete
				)	{
/*++

Routine Description :

	Get Xover data from the index files.

Arguments :

	lpb - buffer where we are to store xover data
	cb -	number of bytes available in the buffer
	artidStart - First article we want in the query results
	artidFinish - Last article we want in the query results (inclusive)
	artidLast - Next article id we should query for
	hXover - Handle which will optimize future queries

Return Value :

	Number of bytes placed in the buffer.

--*/

	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	m_pVRoot->GetXover(	
				this,
				articleIdLow,
				articleIdHigh,
				particleIdNext,
				(char*)lpb,
				cbIn,
				pcbOut,
				hImpersonate,
				pComplete,
				fAnonymous
				) ;
}




void
CNewsGroup::FillBuffer(
				IN	class	CSecurityCtx*	pSecurity,
				IN	class	CEncryptCtx*	pEncrypt,
				IN	class	CXOverAsyncComplete&	complete
				)	{
/*++

Routine Description :

	Get Xover data from the index files.

Arguments :

	lpb - buffer where we are to store xover data
	cb -	number of bytes available in the buffer
	artidStart - First article we want in the query results
	artidFinish - Last article we want in the query results (inclusive)
	artidLast - Next article id we should query for
	hXover - Handle which will optimize future queries

Return Value :

	Number of bytes placed in the buffer.

--*/

	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
		fAnonymous = pSecurity->IsAnonymous();

	}

	HitCache() ;

	if(	ShouldCacheXover() )	{

		char	szPath[MAX_PATH*2] ;
		BOOL	fFlatDir ;

		HXOVER	hXover ;

		if(	ComputeXoverCacheDir( szPath, fFlatDir ) 	)	{

			complete.m_groupHighArticle = GetHighWatermark() ;

            //
            // Pend a FillBuffer operation.  If it fails, fall thru
            // to the old way of getting xover data
            //
			if (XOVER_CACHE(((CNewsTree*)m_pNewsTree))->FillBuffer(
			        &complete.m_CacheWork,
					szPath,
					fFlatDir,
					hXover
				)) {
				return;
			}
		}
	}	
	m_pVRoot->GetXover(	
				this,
				complete.m_currentArticle,
				complete.m_hiArticle,
				&complete.m_currentArticle,
				(char*)complete.m_lpb,
				complete.m_cb,
				&complete.m_cbTransfer,
				hImpersonate,
				&complete,
				fAnonymous
				) ;
	
#if 0
	DWORD	cbReturn =

	XOVER_CACHE(m_pTree)->FillBuffer(	
									lpb,
									cb,
									m_groupid,
									m_lpstrPath,
									artidStart,
									artidFinish,
									artidLast,
									hXover	
									) ;
#endif
}

void
CNewsGroup::FillBuffer(
				IN	class	CSecurityCtx*	pSecurity,
				IN	class	CEncryptCtx*	pEncrypt,
				IN	class	CXHdrAsyncComplete&	complete
				)	{
/*++

Routine Description :

	Get Xhdr data from the index files.

Arguments :

    CSecurityCtx    *pSecurity  - Security context
    CEncryptCtx     *pEncrypt   - Encrypt context
    CXHdrAsyncComplete& complete - Completion object

Return Value :

	Number of bytes placed in the buffer.

--*/

	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
		fAnonymous = pSecurity->IsAnonymous();

	}

	m_pVRoot->GetXhdr(	
				this,
				complete.m_currentArticle,
				complete.m_hiArticle,
				&complete.m_currentArticle,
				complete.m_szHeader,
				(char*)complete.m_lpb,
				complete.m_cb,
				&complete.m_cbTransfer,
				hImpersonate,
				&complete,
				fAnonymous
				) ;
}

void
CNewsGroup::FillBuffer(
				IN	class	CSecurityCtx*	pSecurity,
				IN	class	CEncryptCtx*	pEncrypt,
				IN	class	CSearchAsyncComplete&	complete
				)	{


	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
		fAnonymous = pSecurity->IsAnonymous();

	}

	m_pVRoot->GetXover(	
				this,
				complete.m_currentArticle,
				complete.m_currentArticle,
				&complete.m_currentArticle,
				(char*)complete.m_lpb,
				complete.m_cb,
				&complete.m_cbTransfer,
				hImpersonate,
				complete.m_pComplete,
				fAnonymous
				) ;
	
}

void
CNewsGroup::FillBuffer(
				IN	class	CSecurityCtx*	pSecurity,
				IN	class	CEncryptCtx*	pEncrypt,
				IN	class	CXpatAsyncComplete&	complete
				)	{
/*++

Routine Description :

	Get Xhdr data from the index files for search.

Arguments :

    CSecurityCtx    *pSecurity  - Security context
    CEncryptCtx     *pEncrypt   - Encrypt context
    CXHdrAsyncComplete& complete - Completion object

Return Value :

	Number of bytes placed in the buffer.

--*/

	HANDLE	hImpersonate = NULL ;
	BOOL    fAnonymous = FALSE;

	if( pEncrypt && pEncrypt->QueryCertificateToken() ) {

		//
		//	Prefer to use the SSL based hToken !
		//
		hImpersonate = pEncrypt->QueryCertificateToken() ;

	}	else	if( pSecurity ) {

		hImpersonate = pSecurity->QueryImpersonationToken() ;
		fAnonymous = pSecurity->IsAnonymous();

	}

	m_pVRoot->GetXhdr(	
				this,
				complete.m_currentArticle,
				complete.m_currentArticle,
				&complete.m_currentArticle,
				complete.m_szHeader,
				(char*)complete.m_lpb,
				complete.m_cb,
				&complete.m_cbTransfer,
				hImpersonate,
				complete.m_pComplete,
				fAnonymous
				) ;
}


CTOCLIENTPTR
CNewsGroup::GetArticle(
				ARTICLEID		artid,
				IN	STOREID&	storeid,
				CSecurityCtx*	pSecurity,
				CEncryptCtx*	pEncrypt,
				BOOL			fCacheIn
				)	{
/*++

Routine Description :

	given an articleid create a CArticle derived object which
	can be used to send the article to a client.

Arguments :

	artid - id of the article we want to open
	pSecurity - The CSecurityCtx which logged on the client.
		In the case of feeds etc, we may be passed NULL which indicates
		that we should not bother with any impersonation.
	fCache - TRUE if we want the article to reside in the cache

Return Value :

	Smart pointer to a CArticle object
	Will be NULL if call failed.

--*/

	CToClientArticle	*pArticle = NULL;

	TraceFunctEnter( "CNewsGroup::GetArticle" ) ;
	CNntpSyncComplete	complete ;
	if( complete.IsGood() ) 	{
		FIO_CONTEXT*	pFIOContext = 0 ;
		GetArticle(	artid,
					0,
					INVALID_ARTICLEID,
					storeid,
					pSecurity,
					pEncrypt,
					fCacheIn,
					pFIOContext,
					&complete
					) ;

        _ASSERT( complete.IsGood() );
		HRESULT	hr = complete.WaitForCompletion() ;
		if( hr == S_OK 	&&	pFIOContext != 0 )	{
			_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
			
			pArticle = new CToClientArticle;
			if ( pArticle ) {
				//
				// Create allocator for storing parsed header values
				// Must last longer than the article that uses it.
				//
				const DWORD cchMaxBuffer = 1 * 1024;
				char rgchBuffer[cchMaxBuffer];
				CAllocator allocator(rgchBuffer, cchMaxBuffer);
				CNntpReturn	nntpReturn ;
				if ( ! pArticle->fInit( pFIOContext, nntpReturn, &allocator ) ) {
					DebugTrace( 0, "Initialize article object failed %d",
								GetLastError() );
	
					// But I will still try to loop thru other articles
					ReleaseContext( pFIOContext ) ;
					delete pArticle;
					pArticle = NULL;
				}	else	{
					return	pArticle ;
				}
			}
		}
	}
	return	0 ;
}

CToClientArticle *
CNewsGroup::GetArticle(
                CNntpServerInstanceWrapper  *pInstance,
				ARTICLEID		            artid,
				IN	STOREID&	            storeid,
				CSecurityCtx*	            pSecurity,
				CEncryptCtx*	            pEncrypt,
				CAllocator                  *pAllocator,
				BOOL			            fCacheIn
				)	{
/*++

Routine Description :

	given an articleid create a CArticle object which
	can be used to send the article to moderator.

Arguments :

    pInstance   - Instance wrapper
	artid       - id of the article we want to open
	pSecurity   - The CSecurityCtx which logged on the client.
		            In the case of feeds etc, we may be passed NULL which indicates
		            that we should not bother with any impersonation.
	fCache      - TRUE if we want the article to reside in the cache

Return Value :

	Smart pointer to a CArticle object
	Will be NULL if call failed.

--*/

	CToClientArticle	*pArticle = NULL;

	TraceFunctEnter( "CNewsGroup::GetArticle" ) ;
	CNntpSyncComplete	complete ;
	if( complete.IsGood() ) 	{
		FIO_CONTEXT*	pFIOContext = 0 ;
		GetArticle(	artid,
					0,
					INVALID_ARTICLEID,
					storeid,
					pSecurity,
					pEncrypt,
					fCacheIn,
					pFIOContext,
					&complete
					) ;

        _ASSERT( complete.IsGood() );
		HRESULT	hr = complete.WaitForCompletion() ;
		if( hr == S_OK 	&&	pFIOContext != 0 )	{
			_ASSERT( pFIOContext->m_hFile != INVALID_HANDLE_VALUE ) ;
			
			pArticle = new CToClientArticle;
			if ( pArticle ) {
				//
				// Create allocator for storing parsed header values
				// Must last longer than the article that uses it.
				//
				CNntpReturn	nntpReturn ;
				if ( ! pArticle->fInit( NULL,
	                                    nntpReturn,
	                                    pAllocator,
	                                    pInstance,
	                                    pFIOContext->m_hFile,
	                                    0,
	                                    TRUE
	                                   ) ){
					DebugTrace( 0, "Initialize article object failed %d",
								GetLastError() );
	
					ReleaseContext( pFIOContext ) ;
					delete pArticle;
					pArticle = NULL;
				}	else	{
					return	pArticle ;
				}
			}
		}
	}
	return	0 ;
}

DWORD
CNewsGroup::CopyHelpText(	
		char*	pchDest,	
		DWORD	cbDest
		) {
/*++

Routine Description :

	Copy the string specifying the help text for the newsgroup
	into the provided buffer.
	We will also copy in the terminating CRLF for the line.

Arguments :

	pchDest - buffer to store string in
	cbDest - size of output buffer

Return Value :

	Number of bytes copied.
	0 if the buffer is to small to hold the help text.
	Since we always put in the CRLF, a 0 return unambiguously
	indicates that the callers buffer is to small.
	
--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;

	static	char	szEOL[] = "\r\n" ;

	DWORD cchHelpText;
	const char *pszHelpText = GetHelpText(&cchHelpText);
	if (GetHelpText(&cchHelpText) != NULL ) {
		if (cbDest >= cchHelpText + sizeof(szEOL)) {
			CopyMemory(pchDest, pszHelpText, cchHelpText);
			cbRtn = cchHelpText;
		} else {
			return	0;
		}
	}	

	CopyMemory( pchDest+cbRtn, szEOL, sizeof( szEOL ) - 1 ) ;
	cbRtn += sizeof( szEOL ) - 1 ;

	return	cbRtn ;
}


DWORD
CNewsGroup::CopyHelpTextForRPC(	
		char*	pchDest,	
		DWORD	cbDest
		) {
/*++

Routine Description :

	Copy the string specifying the help text for the newsgroup
	into the provided buffer.
	We will NOT place a terminting CRLF into the buffer

Arguments :

	pchDest - buffer to store string in
	cbDest - size of output buffer

Return Value :

	Number of bytes copied.
	0 if the buffer is to small to hold the help text.
	Since we always put in the CRLF, a 0 return unambiguously
	indicates that the callers buffer is to small.
	
--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;

	DWORD cchHelpText;
	const char *pszHelpText = GetHelpText(&cchHelpText);
	if (GetHelpText(&cchHelpText) != NULL ) {
		if (cbDest >= cchHelpText) {
			CopyMemory(pchDest, pszHelpText, cchHelpText);
			cbRtn = cchHelpText;
		} else {
			return	0;
		}
	}	

	return	cbRtn ;
}

DWORD
CNewsGroup::CopyModerator(	
		char*	pchDest,	
		DWORD	cbDest
		)	{
/*++

Routine Description :

	This function retrieves the name of the moderator for a newsgroup.
	If there is no moderator, we return 0, otherwise we return the
	number of bytes copied into the provided buffer.

Arguments :

	pchDest - Buffer to store moderator name
	cbDest -  Number of bytes in destination buffer

Return Value :

	0 == No Moderator
	Non zero - number of bytes in moderator name

--*/

	_ASSERT( pchDest != 0 ) ;
	_ASSERT( cbDest > 0 ) ;

	DWORD	cbRtn = 0 ;

	DWORD cchModerator;
	const char *pszModerator = GetModerator(&cchModerator);
	if (GetModerator(&cchModerator) != NULL ) {
		if (cbDest >= cchModerator) {
			CopyMemory(pchDest, pszModerator, cchModerator);
			cbRtn = cchModerator;
		} else {
			return	0;
		}
	}	

	return	cbRtn ;
}

DWORD
CNewsGroup::CopyPrettynameForRPC(	
		char*	pchDest,	
		DWORD	cbDest
		)	{
/*++

Routine Description :

	This function retrieves the prettyname for a newsgroup.
	If there is no prettyname, we return 0, otherwise we return the
	number of bytes copied into the provided buffer.
	We will NOT place a terminting CRLF into the buffer

Arguments :

	pchDest - Buffer to store prettyname
	cbDest -  Number of bytes in destination buffer

Return Value :

	0 == No Prettyn