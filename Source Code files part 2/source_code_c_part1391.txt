o open it now.
                // (We will see if the associations are installed)
                hr = _OpenEmailApp();
            }
            else
            {
                hr = E_FAIL;
            }

            if (FAILED(hr))
            {
                hr = _DisplayDialogAndAutoDiscover();
                if (SUCCEEDED(hr))  // If we got the protocol, then open the app
                {
                    hr = _OpenEmailApp();
                }

                ATOMICRELEASE(m_pMailAutoDiscovery);
            }
        }
    }
    else
    {
            CoUninitialize();
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
STDMETHODIMP CMailBoxProcess::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CMailBoxProcess, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}                                             

STDMETHODIMP_(DWORD) CMailBoxProcess::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(DWORD) CMailBoxProcess::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



//===========================
// *** Class Methods ***
//===========================
CMailBoxProcess::CMailBoxProcess()
{
    DllAddRef();

    m_szNextText[0] = 0;
    m_szEmailAddress[0] = 0;
    m_fAutoDiscoveryFailed = FALSE;
    m_hwndDialog = NULL;
    m_pMailAutoDiscovery = NULL;
    m_pszMailApp = NULL;
    m_pszURL = NULL;

    m_fGetDefaultAccount = FALSE;
    m_fShowGetEmailAddressPage = FALSE;
    m_fCreateNewEmailAccount = FALSE;

    _InitComCtl32();    // So we can use the ICC_ANIMATE_CLASS common controls.

    m_cRef = 1;
}

CMailBoxProcess::~CMailBoxProcess()
{
    ATOMICRELEASE(m_pMailAutoDiscovery);
    Str_SetPtr(&m_pszMailApp, NULL);
    Str_SetPtr(&m_pszURL, NULL);

    DllRelease();
}







//===========================
// *** Non-Class Functons ***
//===========================
int AutoDiscoverAndOpenEmail(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[MAX_EMAIL_ADDRESSS];

    szCmdLine[0] = 0;
    if (lpCmdLine)
    {
        // TODO: Either support Unicode or tounel thru UTF8
        SHAnsiToTChar((LPCSTR)lpCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));
    }

    CMailBoxProcess mailboxProcess;

    if (SUCCEEDED(mailboxProcess.ParseCmdLine(szCmdLine)))
    {
        mailboxProcess.Run();
    }

    return 0;
}



#else // FEATURE_MAILBOX
int AutoDiscoverAndOpenEmail(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    return 0;
}

#endif // FEATURE_MAILBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\makefile.inc ===
!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

!if !defined(CLEANINF)
# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)
!endif

resource.rc : $(SDK_LIB_PATH)\AutoDiscovery.tlb $(O)\selfreg.inf


$(O)\selfreg.inf : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\objctors.h ===
#ifndef _OBJCTORS_H_
#define _OBJCTORS_H_


#endif // ! _OBJCTORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\objcache.h ===
/*****************************************************************************\
    FILE: objcache.h

    DESCRIPTION:
        This is a lightweight API that will cache an object so the class factory
    will return the same object each time for every call in this process.  If the
    caller is on another thread, they will get a marshalled stub to the real
    McCoy.
    
    To Add an Object:
    1. classfactory.cpp calls CachedObjClassFactoryCreateInstance().  Add your
       object's CLSID to that if statement for that call.
    2. Copy the section in CachedObjClassFactoryCreateInstance() that looks
       for a CLSID and calls the correct xxx_CreateInstance() method.
    3. Your object's IUnknown::Release() needs to call CachedObjCheckRelease()
       at the top of your Release() method.  It may reduce your m_cRef to 1 so
       it will go to zero after ::Release() decrements it.  The object cache
       will hold two references to the object.  CachedObjCheckRelease() will check
       if the last caller (3rd ref) is releasing, and then it will give up it's 2
       refs and clean up it's internal state.  The Release() then decrements
       the callers ref and it's released because it hit zero.

    BryanSt 12/9/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef __OBJCACHE_H_
#define __OBJCACHE_H_

//////////////////////////////////////////////
// Object Caching API
//////////////////////////////////////////////
extern CRITICAL_SECTION g_hCachedObjectSection;

STDAPI CachedObjClassFactoryCreateInstance(CLSID clsid, REFIID riid, void ** ppvObj);
STDAPI CachedObjCheckRelease(CLSID clsid, int * pnRef);
STDAPI PurgeObjectCache(void);


#endif //__OBJCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\mbdeskbar.cpp ===
/*****************************************************************************\
    FILE: MBDeskBar.cpp

    DESCRIPTION:
        This is the Desktop Toolbar code used to host the "MailBox" feature UI.

    BryanSt 2/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#include "MailBox.h"





#ifdef FEATURE_MAILBOX
/**************************************************************************
   CLASS: CMailBoxDeskBand
**************************************************************************/
class CMailBoxDeskBand : public IDeskBand, 
                  public IInputObject, 
                  public IObjectWithSite,
                  public IPersistStream,
                  public IContextMenu
{
public:
   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID*);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IOleWindow methods
   STDMETHOD (GetWindow)(HWND*);
   STDMETHOD (ContextSensitiveHelp)(BOOL);

   //IDockingWindow methods
   STDMETHOD (ShowDW)(BOOL fShow);
   STDMETHOD (CloseDW)(DWORD dwReserved);
   STDMETHOD (ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

   //IDeskBand methods
   STDMETHOD (GetBandInfo)(DWORD, DWORD, DESKBANDINFO*);

   //IInputObject methods
   STDMETHOD (UIActivateIO)(BOOL, LPMSG);
   STDMETHOD (HasFocusIO)(void);
   STDMETHOD (TranslateAcceleratorIO)(LPMSG);

   //IObjectWithSite methods
   STDMETHOD (SetSite)(IUnknown*);
   STDMETHOD (GetSite)(REFIID, LPVOID*);

   //IPersistStream methods
   STDMETHOD (GetClassID)(LPCLSID);
   STDMETHOD (IsDirty)(void);
   STDMETHOD (Load)(LPSTREAM);
   STDMETHOD (Save)(LPSTREAM, BOOL);
   STDMETHOD (GetSizeMax)(ULARGE_INTEGER*);

   //IContextMenu methods
   STDMETHOD (QueryContextMenu)(HMENU, UINT, UINT, UINT, UINT);
   STDMETHOD (InvokeCommand)(LPCMINVOKECOMMANDINFO);
   STDMETHOD (GetCommandString)(UINT_PTR, UINT, LPUINT, LPSTR, UINT);

private:
    CMailBoxDeskBand();
    ~CMailBoxDeskBand();

    // Private Member Variables
    DWORD m_cRef;

	HWND m_hwndParent;                  // The hwnd of the DeskBar (the host with all the bars)
    HWND m_hwndMailBox;                 // The child hwnd that displayed the Label, Editbox, and "Go" button.
    IInputObjectSite *m_pSite;
    CMailBoxUI * m_pMailBoxUI;

    // Private Member Functions
    HRESULT _CreateWindow(void);

	static LRESULT CALLBACK MailBoxDeskBarWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend HRESULT CMailBoxDeskBand_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
};





//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CMailBoxDeskBand::_CreateWindow(void)
{
    HRESULT hr = S_OK;

    //If the window doesn't exist yet, create it now.
    if (!m_hwndMailBox)
    {
        ATOMICRELEASE(m_pMailBoxUI);

        m_pMailBoxUI = new CMailBoxUI();
        if (m_pMailBoxUI)
        {
            hr = m_pMailBoxUI->CreateWindowMB(m_hwndParent, &m_hwndMailBox);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//===========================
// *** IOleWindow Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::GetWindow(HWND *phWnd)
{
    *phWnd = m_hwndMailBox;
    return S_OK;
}

STDMETHODIMP CMailBoxDeskBand::ContextSensitiveHelp(BOOL fEnterMode)
{
    // TODO: Add help here.
    return S_OK;
}


//===========================
// *** IDockingWindow Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::ShowDW(BOOL fShow)
{
    TraceMsg(0, "::ShowDW %x", fShow);
    if (m_hwndMailBox)
    {
        if (fShow)
            ShowWindow(m_hwndMailBox, SW_SHOW);
        else
            ShowWindow(m_hwndMailBox, SW_HIDE);
        return S_OK;
    }
    return E_FAIL;
}


STDMETHODIMP CMailBoxDeskBand::CloseDW(DWORD dwReserved)
{
    TraceMsg(0, "::CloseDW", 0);
    ShowDW(FALSE);

    if (m_pMailBoxUI)
    {
        m_pMailBoxUI->CloseWindowMB();
        ATOMICRELEASE(m_pMailBoxUI);
    }

    return S_OK;
}

STDMETHODIMP CMailBoxDeskBand::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkSite, BOOL fReserved)
{
    // This method is never called for Band Objects.
    return E_NOTIMPL;
}


//===========================
// *** IInputObject Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
    TraceMsg(0, "::UIActivateIO %x", fActivate);
    if (fActivate)
        SetFocus(m_hwndMailBox);
    return S_OK;
}

STDMETHODIMP CMailBoxDeskBand::HasFocusIO(void)
{
// If this window or one of its decendants has the focus, return S_OK. Return 
//  S_FALSE if we don't have the focus.
    TraceMsg(0, "::HasFocusIO", NULL);
    HWND hwnd = GetFocus();
    if (hwnd && ((hwnd == m_hwndMailBox) ||
        (GetParent(hwnd) == m_hwndMailBox) ||
        (GetParent(GetParent(hwnd)) == m_hwndMailBox)))
    {
        return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CMailBoxDeskBand::TranslateAcceleratorIO(LPMSG pMsg)
{
    // If the accelerator is translated, return S_OK or S_FALSE otherwise.
    return S_FALSE;
}


//===========================
// *** IObjectWithSite Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::SetSite(IUnknown* punkSite)
{
    HRESULT hr = S_OK;

    //If a site is being held, release it.
    ATOMICRELEASE(m_pSite);

    //If punkSite is not NULL, a new site is being set.
    if (punkSite)
    {
        // Get the parent window.
        m_hwndParent = NULL;
        IUnknown_GetWindow(punkSite, &m_hwndParent);

        if (m_hwndParent)
        {
            hr = _CreateWindow();
            if (SUCCEEDED(hr))
            {
                // Get and keep the IInputObjectSite pointer.
                hr = punkSite->QueryInterface(IID_PPV_ARG(IInputObjectSite, &m_pSite));
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CMailBoxDeskBand::GetSite(REFIID riid, LPVOID *ppvReturn)
{
    *ppvReturn = NULL;

    if (m_pSite)
        return m_pSite->QueryInterface(riid, ppvReturn);

    return E_FAIL;
}


//===========================
// *** IDeskBand Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::GetBandInfo(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi)
{
    if (pdbi)
    {
        if (pdbi->dwMask & DBIM_MINSIZE)
        {
            pdbi->ptMinSize.x = 0;
            pdbi->ptMinSize.y = 0;
        }

        if (pdbi->dwMask & DBIM_MODEFLAGS)
        {
            pdbi->dwModeFlags = DBIMF_FIXEDBMP;
        }

        bool fVertical = (((dwViewMode & (DBIF_VIEWMODE_VERTICAL | DBIF_VIEWMODE_FLOATING)) != 0) ? true : false);
        if (true == fVertical)
        {
            if (pdbi->dwMask & DBIM_MODEFLAGS)
            {
                pdbi->dwModeFlags |= DBIMF_VARIABLEHEIGHT;
            }
        }
        else
        {
            if (m_pMailBoxUI)
            {
                HWND hwndEdit;

                if (SUCCEEDED(m_pMailBoxUI->GetEditboxWindow(&hwndEdit)))
                {
                    RECT rcEditbox;

                    // TODO: We need to find the real height of the editbox with
                    //   one row of text plus 2 pixels on top and bottom.
                    GetWindowRect(hwndEdit, &rcEditbox);
                    pdbi->ptMinSize.y = RECTHEIGHT(rcEditbox);

                    // TODO: Find out how to calc the appropriate size of the editbox.
                    pdbi->ptMinSize.y = 0x1A;
                }
            }
        }

        if (pdbi->dwMask & DBIM_MAXSIZE)
        {
            if (true == fVertical)
            {
                pdbi->ptMaxSize.y = -1;
            }
        }

        if (pdbi->dwMask & DBIM_INTEGRAL)
        {
            if (true == fVertical)
            {
                pdbi->ptIntegral.y = 1;
            }
        }

        if (pdbi->dwMask & DBIM_TITLE)
        {
            LoadStringW(HINST_THISDLL, IDS_MAILBOX_DESKBAR_LABEL, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
        }

        if (pdbi->dwMask & DBIM_BKCOLOR)
        {
            //Use the default background color by removing this flag.
            pdbi->dwMask &= ~DBIM_BKCOLOR;
        }

        return S_OK;
    }

    return E_INVALIDARG;
}


//===========================
// *** IPersistStream Interface ***
//===========================
#define MAILBOX_PERSIST_SIGNATURE           0xF0AB8915          // Random signature.
#define MAILBOX_PERSIST_VERSION             0x00000000          // This is version 0.

typedef struct {
    DWORD cbSize;
    DWORD dwSig;                // from MAILBOX_PERSIST_SIGNATURE
    DWORD dwVer;                // from MAILBOX_PERSIST_VERSION
} MAILBOX_PERSISTHEADERSTRUCT;

STDMETHODIMP CMailBoxDeskBand::GetClassID(LPCLSID pClassID)
{
    *pClassID = CLSID_MailBoxDeskBar;
    return S_OK;
}


STDMETHODIMP CMailBoxDeskBand::IsDirty(void)
{
    // We currently never get dirty because we don't have state.
    return S_FALSE;
}


STDMETHODIMP CMailBoxDeskBand::Load(IStream* pStream)
{
    DWORD cbRead;
    MAILBOX_PERSISTHEADERSTRUCT mailboxPersistHeader;
    HRESULT hr = pStream->Read(&mailboxPersistHeader, sizeof(mailboxPersistHeader), &cbRead);

    if (SUCCEEDED(hr) &&
        (sizeof(mailboxPersistHeader) == cbRead) &&
        (MAILBOX_PERSIST_SIGNATURE == mailboxPersistHeader.dwSig) &&
        (mailboxPersistHeader.cbSize > 0))
    {
        void * pPersistHeader = (void *) LocalAlloc(NONZEROLPTR, mailboxPersistHeader.cbSize);

        if (pPersistHeader)
        {
            // We read it simply to support future versions.
            hr = pStream->Read(pPersistHeader, mailboxPersistHeader.cbSize, NULL);
            LocalFree(pPersistHeader);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP CMailBoxDeskBand::Save(IStream* pStream, BOOL fClearDirty)
{
    MAILBOX_PERSISTHEADERSTRUCT mailboxPersistHeader = {0, MAILBOX_PERSIST_SIGNATURE, MAILBOX_PERSIST_VERSION};

//    if (fClearDirty)
//        m_bDirty = FALSE;

    return pStream->Write(&mailboxPersistHeader, sizeof(mailboxPersistHeader), NULL);
}


STDMETHODIMP CMailBoxDeskBand::GetSizeMax(ULARGE_INTEGER *pul)
{
    HRESULT hr = E_INVALIDARG;

    if (pul)
    {
        pul->QuadPart = sizeof(MAILBOX_PERSISTHEADERSTRUCT);
        hr = S_OK;
    }

    return hr;
}


//===========================
// *** IContextMenu Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::QueryContextMenu( HMENU hMenu,
                                          UINT indexMenu,
                                          UINT idCmdFirst,
                                          UINT idCmdLast,
                                          UINT uFlags)
{
    if (CMF_DEFAULTONLY & uFlags)
        return S_OK;

    // We don't currently add any context menu items.
    return S_OK;
}


STDMETHODIMP CMailBoxDeskBand::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    return E_INVALIDARG;
}


STDMETHODIMP CMailBoxDeskBand::GetCommandString(UINT_PTR idCommand, UINT uFlags, LPUINT lpReserved, LPSTR lpszName, UINT uMaxNameLen)
{
    HRESULT  hr = E_INVALIDARG;

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
STDMETHODIMP CMailBoxDeskBand::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMailBoxDeskBand, IOleWindow),
        QITABENT(CMailBoxDeskBand, IDockingWindow),
        QITABENT(CMailBoxDeskBand, IInputObject),
        QITABENT(CMailBoxDeskBand, IObjectWithSite),
        QITABENT(CMailBoxDeskBand, IDeskBand),
        QITABENT(CMailBoxDeskBand, IPersist),
        QITABENT(CMailBoxDeskBand, IPersistStream),
        QITABENT(CMailBoxDeskBand, IContextMenu),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}                                             

STDMETHODIMP_(DWORD) CMailBoxDeskBand::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(DWORD) CMailBoxDeskBand::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



//===========================
// *** Class Methods ***
//===========================
CMailBoxDeskBand::CMailBoxDeskBand()
{
    DllAddRef();

    m_pSite = NULL;
    m_pMailBoxUI = NULL;
    
    m_hwndMailBox = NULL;
    m_hwndParent = NULL;
    m_cRef = 1;
}

CMailBoxDeskBand::~CMailBoxDeskBand()
{
    ATOMICRELEASE(m_pSite);
    ATOMICRELEASE(m_pMailBoxUI);

    DllRelease();
}


HRESULT CMailBoxDeskBand_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;
    if (ppvObj)
    {
        *ppvObj = NULL;
        if (NULL == punkOuter)
        {
            CMailBoxDeskBand * pmf = new CMailBoxDeskBand();
            if (pmf)
            {
                hr = pmf->QueryInterface(riid, ppvObj);
                pmf->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}












#endif // FEATURE_MAILBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#define DECL_CRTFREE
#include <crtfree.h>

#define COMPILE_MULTIMON_STUBS
#include <multimon.h>

/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////

HINSTANCE g_hinst;              // My instance handle



#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0;
DWORD g_TLSliStopWatchStartLo = 0;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;
    
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));

//    ASSERT(!liStopWatchStart.QuadPart); // If you hit this, then the stopwatch is nested.
    QueryPerformanceFrequency(&g_liStopWatchFreq);
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, IntToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, IntToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);
    
    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG






/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////
#undef SysAllocStringA
BSTR SysAllocStringA(LPCSTR pszStr)
{
    BSTR bstrOut = NULL;

    if (pszStr)
    {
        DWORD cchSize = (lstrlenA(pszStr) + 1);
        LPWSTR pwszThunkTemp = (LPWSTR) LocalAlloc(LPTR, (sizeof(pwszThunkTemp[0]) * cchSize));  // assumes INFOTIPSIZE number of chars max

        if (pwszThunkTemp)
        {
            SHAnsiToUnicode(pszStr, pwszThunkTemp, cchSize);
            bstrOut = SysAllocString(pwszThunkTemp);
            LocalFree(pwszThunkTemp);
        }
    }

    return bstrOut;
}


HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocStringA(pszSource);
        if (pszSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


LPSTR AllocStringFromBStr(BSTR bstr)
{
    USES_CONVERSION;        // atlbase.h

    char *a = W2A((bstr ? bstr : L""));
    int len = 1 + lstrlenA(a);

    char *p = (char *)LocalAlloc(LPTR, len);
    if (p)
    {
        StrCpyA(p, a);
    }

    return p;
}


HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstr)
{
    STATSTG statStg = {0};
    HRESULT hr = pStream->Stat(&statStg, STATFLAG_NONAME);

    if (S_OK == hr)
    {
        DWORD cchSize = statStg.cbSize.LowPart;
        *pbstr = SysAllocStringLen(NULL, cchSize + 4);

        if (*pbstr)
        {
            LPSTR pszTemp = (LPSTR) LocalAlloc(LPTR, sizeof(pszTemp[0]) * (cchSize + 4));

            if (pszTemp)
            {
                ULONG cbRead;

                hr = pStream->Read(pszTemp, cchSize, &cbRead);
                pszTemp[cchSize] = 0;
                SHAnsiToUnicode(pszTemp, *pbstr, (cchSize + 1));

                LocalFree(pszTemp);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStream
// --------------------------------------------------------------------------------
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        hr = pstmIn->Read(buf, sizeof(buf), &cbRead);
        if (FAILED(hr) || cbRead == 0)
        {
            break;
        }
        hr = pstmOut->Write(buf, cbRead, NULL);
        if (FAILED(hr))
        {
            break;
        }
        cbTotal += cbRead;
    }
    while (cbRead == sizeof(buf));
 
    if (pcb && SUCCEEDED(hr))
        *pcb = cbTotal;

    return hr;
}


HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString)
{
    HRESULT hr = E_INVALIDARG;

    if (pvar)
    {
        pvar->bstrVal = SysAllocString(pwszString);
        if (pvar->bstrVal)
        {
            pvar->vt = VT_BSTR;
            hr = S_OK;
        }
        else
        {
            pvar->vt = VT_EMPTY;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped)
{
    HRESULT hr = HrSysAllocString(bstrEscaped, pbstrUnEscaped);

    if (SUCCEEDED(hr))
    {
        // Find %xx and replace.
        LPWSTR pwszEscapedSequence = StrChrW(*pbstrUnEscaped, CH_HTML_ESCAPE);
        WCHAR wzEscaped[5] = L"0xXX";

        while (pwszEscapedSequence && (3 <= lstrlenW(pwszEscapedSequence)))
        {
            int nCharCode;

            wzEscaped[2] = pwszEscapedSequence[1];
            wzEscaped[3] = pwszEscapedSequence[2];
            StrToIntExW(wzEscaped, STIF_SUPPORT_HEX, &nCharCode);

            // Replace the '%' with the real char.
            pwszEscapedSequence[0] = (WCHAR) nCharCode;

            pwszEscapedSequence = CharNextW(pwszEscapedSequence);   // Skip pasted the replaced char.

            // Over write the 0xXX value.
            StrCpyW(pwszEscapedSequence, &pwszEscapedSequence[2]);

            // Next...
            pwszEscapedSequence = StrChrW(pwszEscapedSequence, CH_HTML_ESCAPE);
        }
    }

    return hr;
}



/*****************************************************************************\
    PARAMETERS:
        If fBoolean is TRUE, return "True" else "False".
\*****************************************************************************/
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrValue)
    {
        LPCWSTR pwszValue;

        *pbstrValue = NULL;
        if (TRUE == fBoolean)
        {
            pwszValue = SZ_QUERYDATA_TRUE;
        }
        else
        {
            pwszValue = SZ_QUERYDATA_FALSE;
        }

        hr = HrSysAllocString(pwszValue, pbstrValue);
    }

    return hr;
}



#define SZ_VALID_XML      L"<?xml"

/////////////////////////////////////////////////////////////////////
// XML Related Helpers
/////////////////////////////////////////////////////////////////////
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = E_FAIL;
    
    // We don't even want to
    // bother passing it to the XML DOM because they throw exceptions.  These
    // are caught and handled but we still don't want this to happen.  We try
    // to get XML from the web server, but we get HTML instead if the web server
    // fails or the web proxy returns HTML if the site isn't found.
    if (!StrCmpNIW(SZ_VALID_XML, bstrXML, (ARRAYSIZE(SZ_VALID_XML) - 1)))
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDoc));

        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL fIsSuccessful;

            // NOTE: This will throw an 0xE0000001 exception in MSXML if the XML is invalid.
            //    This is not good but there isn't much we can do about it.  The problem is
            //    that web proxies give back HTML which fails to parse.
            hr = (*ppXMLDoc)->loadXML(bstrXML, &fIsSuccessful);
            if (SUCCEEDED(hr))
            {
                if (VARIANT_TRUE != fIsSuccessful)
                {
                    hr = E_FAIL;
                }
            }
        }

        if (FAILED(hr))
        {
            (*ppXMLDoc)->Release();
            *ppXMLDoc = NULL;
        }
    }

    return hr;
}


HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML)
{
    IStream * pStream;
    HRESULT hr = pXMLDoc->QueryInterface(IID_PPV_ARG(IStream, &pStream)); // check the return value

    if (S_OK == hr)
    {
        hr = BSTRFromStream(pStream, pbstrXML);
        pStream->Release();
    }

    return hr;
}


HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend)
{
    IXMLDOMNode * pXMLNodeRoot;
    HRESULT hr = pXMLElementRoot->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeRoot));

    if (SUCCEEDED(hr))
    {
        IXMLDOMNode * pXMLNodeToAppend;
        
        hr = pXMLElementToAppend->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeToAppend));
        if (SUCCEEDED(hr))
        {
            hr = pXMLNodeRoot->appendChild(pXMLNodeToAppend, NULL);
            pXMLNodeToAppend->Release();
        }

        pXMLNodeRoot->Release();
    }

    return hr;
}


HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc)
{
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDOMDoc));

    if (SUCCEEDED(hr))
    {
        VARIANT xmlSource;

        xmlSource.vt = VT_BSTR;
        xmlSource.bstrVal = SysAllocString(pwzPath);

        if (xmlSource.bstrVal)
        {
            VARIANT_BOOL fIsSuccessful = VARIANT_TRUE;

            hr = (*ppXMLDOMDoc)->load(xmlSource, &fIsSuccessful);
            if ((S_FALSE == hr) || (VARIANT_FALSE == fIsSuccessful))
            {
                // This happens when the file isn't a valid XML file.
                hr = E_FAIL;
            }

            VariantClear(&xmlSource);
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppXMLDOMDoc);
        }
    }

    return hr;
}


HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName)
{
    BSTR bstrTagName;
    HRESULT hr = pXMLElementMessage->get_tagName(&bstrTagName);

    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    else if (SUCCEEDED(hr))
    {
        if (!bstrTagName || !pwszTagName || StrCmpIW(bstrTagName, pwszTagName))
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}

HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList)
{
    BSTR bstrTagName = SysAllocString(pwszTagName);
    HRESULT hr = E_OUTOFMEMORY;

    *ppNodeList = NULL;
    if (bstrTagName)
    {
        hr = pXMLElementMessage->getElementsByTagName(bstrTagName, ppNodeList);
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}


HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue)
{
    BSTR bstrAttributeName = SysAllocString(pwszAttributeName);
    HRESULT hr = E_OUTOFMEMORY;

    *pbstrValue = NULL;
    if (bstrAttributeName)
    {
        IXMLDOMNamedNodeMap * pNodeAttributes;

        hr = pXMLNode->get_attributes(&pNodeAttributes);
        if (S_FALSE == hr)  hr = E_FAIL;
        if (SUCCEEDED(hr))
        {
            IXMLDOMNode * pTypeAttribute;

            hr = pNodeAttributes->getNamedItem(bstrAttributeName, &pTypeAttribute);
            if (S_FALSE == hr)  hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            if (SUCCEEDED(hr))
            {
                VARIANT varAtribValue = {0};

                hr = pTypeAttribute->get_nodeValue(&varAtribValue);
                if (S_FALSE == hr)  hr = E_FAIL;
                if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
                {
                    *pbstrValue = SysAllocString(varAtribValue.bstrVal);
                }

                VariantClear(&varAtribValue);
                pTypeAttribute->Release();
            }

            pNodeAttributes->Release();
        }

        SysFreeString(bstrAttributeName);
    }

    return hr;
}


HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode)
{
    HRESULT hr = E_INVALIDARG;

    *ppChildNode = NULL;
    if (pXMLNode)
    {
        IXMLDOMElement * pXMLElement;

        hr = pXMLNode->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElement));
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList * pNodeList;

            hr = XMLElem_GetElementsByTagName(pXMLElement, pwszTagName, &pNodeList);
            if (SUCCEEDED(hr))
            {
                hr = XMLNodeList_GetChild(pNodeList, 0, ppChildNode);
                pNodeList->Release();
            }

            pXMLElement->Release();
        }
    }

    return hr;
}


HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue)
{
    DOMNodeType nodeType = NODE_TEXT;
    HRESULT hr = pXMLNode->get_nodeType(&nodeType);

    *pbstrValue = NULL;

    if (S_FALSE == hr)  hr = E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (NODE_TEXT == nodeType)
        {
            VARIANT varAtribValue = {0};

            hr = pXMLNode->get_nodeValue(&varAtribValue);
            if (S_FALSE == hr)  hr = E_FAIL;
            if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
            {
                *pbstrValue = SysAllocString(varAtribValue.bstrVal);
            }

            VariantClear(&varAtribValue);
        }
        else
        {
            hr = pXMLNode->get_text(pbstrValue);
        }
    }

    return hr;
}


HRESULT XMLNodeList_GetChild(IN IXMLDOMNodeList * pNodeList, IN DWORD dwIndex, OUT IXMLDOMNode ** ppXMLChildNode)
{
    HRESULT hr = pNodeList->get_item(dwIndex, ppXMLChildNode);

    if (S_FALSE == hr)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue)
{
    IXMLDOMNode * pNodeType;
    HRESULT hr = XMLNode_GetChildTag(pXMLNode, bstrChildTag, &pNodeType);

    if (SUCCEEDED(hr))
    {
        hr = XMLNode_GetTagText(pNodeType, pbstrValue);
        pNodeType->Release();
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean)
{
    BSTR bstr;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstr);

    if (SUCCEEDED(hr))
    {
        if (!StrCmpIW(bstr, L"on"))
        {
            *pfBoolean = TRUE;
        }
        else
        {
            *pfBoolean = FALSE;
        }

        SysFreeString(bstr);
    }

    return hr;
}


BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText)
{
    BOOL fIsChildTagTextEqual = FALSE;
    BSTR bstrChildText;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstrChildText);

    if (SUCCEEDED(hr))
    {
        // Is this <TYPE>email</TYPE>?
        if (!StrCmpIW(bstrChildText, bstrText))
        {
            // No, so keep looking.
            fIsChildTagTextEqual = TRUE;
        }

        SysFreeString(bstrChildText);
    }

    return fIsChildTagTextEqual;
}




/////////////////////////////////////////////////////////////////////
// Wininet Wrapping Helpers
/////////////////////////////////////////////////////////////////////
#define EMPTYSTR_FOR_NULL(str)      ((!str) ? TEXT("") : (str))

/*****************************************************************************\
    FUNCTION: InternetConnectWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 144ms - 250ms (Min: 2; Max: 1,667ms)
        To: rigel.cyberpass.net <San Diego, CA>: 717ms - 1006ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 2609ms - 14,012ms

    COMMON ERROR VALUES:
        These are the return values in these different cases:
    ERROR_INTERNET_NAME_NOT_RESOLVED: No Proxy & DNS Lookup failed.
    ERROR_INTERNET_CANNOT_CONNECT: Some Auth Proxies and Netscape's Web/Auth Proxy
    ERROR_INTERNET_NAME_NOT_RESOLVED: Web Proxy
    ERROR_INTERNET_TIMEOUT: Invalid or Web Proxy blocked IP Address
    ERROR_INTERNET_INCORRECT_PASSWORD: IIS & UNIX, UserName may not exist or password for the user may be incorrect on.
    ERROR_INTERNET_LOGIN_FAILURE: Too many Users on IIS.
    ERROR_INTERNET_INCORRECT_USER_NAME: I haven't seen it.
    ERROR_INTERNET_EXTENDED_ERROR: yahoo.com exists, but ftp.yahoo.com doesn't.
\*****************************************************************************/
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetConnect(hInternet, pszServerName, nServerPort, pszUserName, pszPassword, dwService, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetConnect(%#08lx, \"%ls\", \"%ls\", \"%ls\") returned %u. Time=%lums", hInternet, pszServerName, EMPTYSTR_FOR_NULL(pszUserName), EMPTYSTR_FOR_NULL(pszPassword), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        Destination not applicable. 677-907ms
\*****************************************************************************/
HRESULT InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetOpen(\"%ls\") returned %u. Time=%lums", pszAgent, dwError, DebugStopWatch()));

    return hr;
}


HRESULT InternetCloseHandleWrap(HINTERNET hInternet)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!InternetCloseHandle(hInternet))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetCloseHandle(%#08lx) returned %u. Time=%lums", hInternet, dwError, DebugStopWatch()));

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenUrlWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 29ms
        To: rigel.cyberpass.net <San Diego, CA>: ???????
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetOpenUrl(%#08lx, \"%ls\") returned %u. Time=%lums", hInternet, pszUrl, dwError, DebugStopWatch()));

    return hr;
}


HRESULT HttpOpenRequestWrap(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion, 
                            IN LPCSTR lpszReferer, IN LPCSTR FAR * lpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext,
                            LPDWORD pdwNumberOfBytesRead, HINTERNET * phConnectionHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phConnectionHandle = HttpOpenRequestA(hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferer, lpszAcceptTypes, dwFlags, dwContext);
    if (!*phConnectionHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "HttpOpenRequest(%#08lx, \"%ls\") returned %u. Time=%lums", *phConnectionHandle, lpszVerb, dwError, DebugStopWatch()));

    return hr;
}


HRESULT HttpSendRequestWrap(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,  IN DWORD dwHeadersLength, IN LPVOID lpOptional, DWORD dwOptionalLength)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!HttpSendRequestA(hRequest, lpszHeaders,  dwHeadersLength, lpOptional, dwOptionalLength))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!InternetReadFile(hFile, pvBuffer, dwNumberOfBytesToRead, pdwNumberOfBytesRead))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}


HRESULT CreateUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN DWORD dwExpectedFileSize, IN LPCTSTR lpszFileExtension, OUT LPTSTR lpszFileName, IN DWORD dwReserved)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!CreateUrlCacheEntry(lpszUrlName, dwExpectedFileSize, lpszFileExtension, lpszFileName, dwReserved))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}


HRESULT CommitUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN LPCTSTR lpszLocalFileName, IN FILETIME ExpireTime, IN FILETIME LastModifiedTime,
                                IN DWORD CacheEntryType, IN LPWSTR lpHeaderInfo, IN DWORD dwHeaderSize, IN LPCTSTR lpszFileExtension, IN LPCTSTR lpszOriginalUrl)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!CommitUrlCacheEntryW(lpszUrlName, lpszLocalFileName, ExpireTime, LastModifiedTime, CacheEntryType, lpHeaderInfo, dwHeaderSize, lpszFileExtension, lpszOriginalUrl))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}



#define SIZE_COPY_BUFFER                    (32 * 1024)     // 32k

HRESULT InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML)
{
    BYTE byteBuffer[SIZE_COPY_BUFFER];
    DWORD cbRead = SIZE_COPY_BUFFER;
    DWORD cchSize = 0;
    HRESULT hr = S_OK;

    *pbstrXML = NULL;
    while (SUCCEEDED(hr) && cbRead)
    {
        hr = InternetReadFileWrap(hInternetRead, byteBuffer, sizeof(byteBuffer), &cbRead);
        if (SUCCEEDED(hr) && cbRead)
        {
            BSTR bstrOld = *pbstrXML;
            BSTR bstrEnd;

            // The string may not be terminated.
            byteBuffer[cbRead] = 0;

            cchSize += ARRAYSIZE(byteBuffer);
            *pbstrXML = SysAllocStringLen(NULL, cchSize);
            if (*pbstrXML)
            {
                if (bstrOld)
                {
                    StrCpy(*pbstrXML, bstrOld);
                }
                else
                {
                    (*pbstrXML)[0] = 0;
                }

                bstrEnd = *pbstrXML + lstrlenW(*pbstrXML);

                SHAnsiToUnicode((LPCSTR) byteBuffer, bstrEnd, ARRAYSIZE(byteBuffer));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SysFreeString(bstrOld);
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
// File System Wrapping Helpers
/////////////////////////////////////////////////////////////////////
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle)
{
    HRESULT hr = S_OK;
    HANDLE hTemp = NULL;
    DWORD dwError = 0;

    if (!phFileHandle)
        phFileHandle = &hTemp;

    *phFileHandle = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (hTemp)
        CloseHandle(hTemp);

    return hr;
}


HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT DeleteFileHrWrap(LPCWSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!DeleteFileW(pszPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
    HRESULT hr = S_OK;
    DWORD chGot = GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);

    // What else can indicate an error value?
    if (0 == chGot)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    return hr;
}





/////////////////////////////////////////////////////////////////////
// Other Helpers
/////////////////////////////////////////////////////////////////////

HRESULT HrRewindStream(IStream * pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}



#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))





// PERFPERF 
// This routine used to copy 512 bytes at a time, but that had a major negative perf impact.
// I have measured a 2-3x speedup in copy times by increasing this buffer size to 16k.
// Yes, its a lot of stack, but it is memory well spent.                    -saml
#define STREAM_COPY_BUF_SIZE        16384
#define STREAM_PROGRESS_INTERVAL    (100*1024/STREAM_COPY_BUF_SIZE) // display progress after this many blocks

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi)
{
    BYTE buf[STREAM_COPY_BUF_SIZE];
    ULONG cbRead;
    HRESULT hres = NOERROR;
    int nSection = 0;         // How many buffer sizes have we copied?
    ULARGE_INTEGER uliNewCompleted;

    if (ppi)
    {
        uliNewCompleted.QuadPart = ppi->uliBytesCompleted.QuadPart;
    }

    while (cb.QuadPart)
    {
        if (ppi && ppi->ppd)
        {
            if (0 == (nSection % STREAM_PROGRESS_INTERVAL))
            {
                ppi->ppd->SetProgress64(uliNewCompleted.QuadPart, ppi->uliBytesTotal.QuadPart);

                if (ppi->ppd->HasUserCancelled())
                {
                    hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }
            }
        }

        hres = pstmFrom->Read(buf, min(cb.LowPart, sizeof(buf)), &cbRead);
        if (FAILED(hres) || (cbRead == 0))
        {
            //  sometimes we are just done.
            if (SUCCEEDED(hres))
                hres = S_OK;
            break;
        }


        if (ppi)
        {
            uliNewCompleted.QuadPart += (ULONGLONG) cbRead;
        }

        cb.QuadPart -= cbRead;

        hres = pstmTo->Write(buf, cbRead, &cbRead);
        if (FAILED(hres) || (cbRead == 0))
            break;

        nSection++;
    }

    return hres;
}

/*
// These are needed for COM/COM+ interop

void __stdcall
_com_raise_error(HRESULT hr, IErrorInfo* perrinfo) throw(_com_error)
{
        throw _com_error(hr, perrinfo);
}

void __stdcall
_com_issue_error(HRESULT hr) throw(_com_error)
{
        _com_raise_error(hr, NULL);
}

void __stdcall
_com_issue_errorex(HRESULT hr, IUnknown* punk, REFIID riid) throw(_com_error)
{
        IErrorInfo* perrinfo = NULL;
        if (punk == NULL) {
                goto exeunt;
        }
        ISupportErrorInfo* psei;
        if (FAILED(punk->QueryInterface(__uuidof(ISupportErrorInfo),
                           (void**)&psei))) {
                goto exeunt;
        }
        HRESULT hrSupportsErrorInfo;
        hrSupportsErrorInfo = psei->InterfaceSupportsErrorInfo(riid);
        psei->Release();
        if (hrSupportsErrorInfo != S_OK) {
                goto exeunt;
        }
        if (GetErrorInfo(0, &perrinfo) != S_OK) {
                perrinfo = NULL;
        }
exeunt:
        _com_raise_error(hr, perrinfo);
}
*/
// needed by smtpserv:

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;
    LARGE_INTEGER  liOrigin = {0,0};

    // Create H Global Stream
    hr = CreateStreamOnHGlobal (NULL, TRUE, lppstm);
    if (FAILED(hr))
        goto exit;

    // Write String
    hr = (*lppstm)->Write (lpb, cb, NULL);
    if (FAILED(hr))
        goto exit;

    // Rewind the steam
    hr = (*lppstm)->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return hr;
}

const char szDayOfWeekArray[7][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" } ;
const char szMonthOfYearArray[12][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" } ;

void GetDateString(char * szSentDateString, ULONG stringLen)
{
    // Sent Date
    SYSTEMTIME stSentTime;
    CHAR szMonth[10], szWeekDay[12] ; 

    GetSystemTime(&stSentTime);

    lstrcpynA(szWeekDay, szDayOfWeekArray[stSentTime.wDayOfWeek], ARRAYSIZE(szWeekDay)) ;
    lstrcpynA(szMonth, szMonthOfYearArray[stSentTime.wMonth-1], ARRAYSIZE(szMonth)) ;

    wnsprintfA(szSentDateString, stringLen, "%s, %u %s %u %2d:%02d:%02d ", (LPSTR) szWeekDay, stSentTime.wDay, 
                                (LPSTR) szMonth, stSentTime.wYear, stSentTime.wHour, 
                                stSentTime.wMinute, stSentTime.wSecond) ;
}


/*****************************************************************************\
    PARAMETERS:
        RETURN: Win32 HRESULT (Not Script Safe).
            SUCCEEDED(hr) for OK and out params filled in.
            FAILED(hr) for all errors.
\*****************************************************************************/
HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData)
{
    HRESULT hr = E_FAIL;
    LPCWSTR pwszIterate = bstrURL;

    pwszIterate = StrChrW(pwszIterate, L'?');   // Advance to Query part of URL.
    while (pwszIterate && pwszIterate[0])
    {
        pwszIterate++;  // Start at first value
        
        LPCWSTR pwszEndOfValue = StrChrW(pwszIterate, L'=');
        if (!pwszEndOfValue)
            break;
        
        int cchValueSize = (INT)(UINT)(pwszEndOfValue - pwszIterate);
        if (0 == StrCmpNIW(pwszValue, pwszIterate, cchValueSize))
        {
            int cchSizeToCopy = cchSizeData;  // Copy rest of line by default.

            pwszIterate = StrChrW(pwszEndOfValue, L'&');
            if (pwszIterate)
            {
                cchSizeToCopy = (INT)(UINT)(pwszIterate - pwszEndOfValue);
            }

            // It matches, now get the Data.
            StrCpyNW(pwszData, (pwszEndOfValue + 1), cchSizeToCopy);
            hr = S_OK;
            break;
        }
        else
        {
            pwszIterate = StrChrW(pwszEndOfValue, L'&');
        }
    }

    return hr;
}



// BUGBUG: This makes this object ways safe.  When the MailApps security design is
//    complete, this needs to be removed for the permanate security solution.
HRESULT MarkObjectSafe(IUnknown * punk)
{
    HRESULT hr = S_OK;
    IObjectSafety * pos;

    hr = punk->QueryInterface(IID_PPV_ARG(IObjectSafety, &pos));
    if (SUCCEEDED(hr))
    {
        // BUGBUG: This makes this object ways safe.  When the MailApps security design is
        //    complete, this needs to be removed for the permanate solution.
        pos->SetInterfaceSafetyOptions(IID_IDispatch, (INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA), 0);
        pos->Release();
    }

    return hr;
}


BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = (ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES);
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
    ULARGE_INTEGER uiResult;

    uiResult.QuadPart = (ULONGLONG) ShellExecute(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);
    if (32 < uiResult.QuadPart)
    {
        uiResult.LowPart = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(uiResult.LowPart);
}


HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszTempLastHalf = NULL;
    LPTSTR pszNextToken = pszString;

    while (pszNextToken = StrStrI(pszNextToken, pszToken))
    {
        // We found one.
        LPTSTR pszPastToken = pszNextToken + lstrlen(pszToken);

        Str_SetPtr(&pszTempLastHalf, pszPastToken);      // Keep a copy because we will overwrite it.

        pszNextToken[0] = 0;    // Remove the rest of the string.
        StrCatBuff(pszString, pszReplaceValue, cchSize);
        StrCatBuff(pszString, pszTempLastHalf, cchSize);

        pszNextToken += lstrlen(pszReplaceValue);
    }

    Str_SetPtr(&pszTempLastHalf, NULL);

    return hr;
}


BOOL IsOSNT(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return (VER_PLATFORM_WIN32_NT == osVerInfoA.dwPlatformId);
}


DWORD GetOSVer(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return osVerInfoA.dwMajorVersion;
}


int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData)
{
    if (p)
    {
        LocalFree(p);
    }

    return 1;
}


// lParam can be: 0 == do a case sensitive search.  1 == do a case insensitive search.
int DPA_StringCompareCB(LPVOID pvString1, LPVOID pvString2, LPARAM lParam)
{
    // return < 0 for pvPidl1 before pvPidl2.
    // return == 0 for pvPidl1 equals pvPidl2.
    // return > 0 for pvPidl1 after pvPidl2.
    int nSort = 0;      // Default to equal

    if (pvString1 && pvString2)
    {
        nSort = StrCmp((LPCTSTR)pvString1, (LPCTSTR)pvString2);
    }

    return nSort;
}



HRESULT AddHDPA_StrDup(IN LPCWSTR pszString, IN HDPA * phdpa)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (!*phdpa)
    {
        *phdpa = DPA_Create(2);
    }

    if (*phdpa)
    {
        LPWSTR pszStringCopy = StrDup(pszString);

        if (pszStringCopy)
        {
            if (-1 == DPA_SortedInsertPtr(*phdpa, pszStringCopy, 0, DPA_StringCompareCB, NULL, DPAS_INSERTBEFORE, pszStringCopy))
            {
                // We failed so free the memory
                LocalFree(pszStringCopy);
            }
            else
            {
                hr = S_OK;
            }
        }
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\priv.h ===
/*****************************************************************************\
    FILE: priv.h

    DESCRIPTION:
        This is the precompiled header for autodisc.dll.

    BryanSt 8/12/1999
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#ifndef _PRIV_H_
#define _PRIV_H_


/*****************************************************************************\
      Global Includes
\*****************************************************************************/
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN

#define NOIME
#define NOSERVICE

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif // WINVER

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _ATL_DLL
#undef _ATL_DLL_IMPL
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache

#define _SHSEMIP_H_             /* _UNDOCUMENTED_: Internal header */


#define POST_IE5_BETA
#include <w95wraps.h>

#include <windows.h>

#include <windowsx.h>

#include "resource.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <exdisp.h>
#include <objidl.h>

#include <shlwapi.h>
#include <shlwapip.h>

// HACKHACK: For the life of me, I can't get shlwapip.h to include the diffinitions of these.
//    I'm giving up and putting them inline.  __IOleAutomationTypes_INTERFACE_DEFINED__ and
//    __IOleCommandTarget_INTERFACE_DEFINED__ need to be defined, which requires oaidl.h,
//    which requires hlink.h which requires rpcndr.h to come in the right order.  Once I got that
//    far I found it still didn't work and a lot of more stuff is needed.  The problem
//    is that shlwapi (exdisp/dspsprt/expdsprt/cnctnpt) or ATL will provide impls for
//    IConnectionPoint & IConnectionPointContainer, but one will conflict with the other.
LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp, DISPID dispidMember, DISPPARAMS * pdispparams);
LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid);
LWSTDAPIV IUnknown_CPContainerInvokeParam(IUnknown *punk, REFIID riidCP, DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...);

#include <shellapi.h>
#include "crtfree.h"            // We copied this from \shell\inc\ because it sure is nice to have.

#include <ole2ver.h>
#include <olectl.h>
#include <isguids.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <msident.h>
#include <msxml.h>
#include <AutoDiscovery.h>          // For IAutoDiscovery interfaces
#include <dispex.h>                 // IDispatchEx
#include <perhist.h>
#include <regapix.h>


#include <help.h>
#include <multimon.h>
#include <urlhist.h>
#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>
#include <propset.h>        // BUGBUG (scotth): remove this once OLE adds an official header

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <prsht.h>

// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>


#include <shlobjp.h>
#include <fromshell.h>
#include <dspsprt.h>
#include <cowsite.h>
#include <cobjsafe.h>
#include <guids.h>
#include "dpa.h"                // We have a copy of the header since it isn't public

// Trace flags
#define TF_WMAUTODISCOVERY  0x00000100      // AutoDiscovery
#define TF_WMTRANSPORT      0x00000200      // Transport Layer
#define TF_WMOTHER          0x00000400      // Other
#define TF_WMSMTP_CALLBACK  0x00000800      // SMTP Callback



/*****************************************************************************\
   Global Helper Macros/Typedefs
\*****************************************************************************/
EXTERN_C HINSTANCE g_hinst;   // My instance handle
#define HINST_THISDLL g_hinst

#define WizardNext(hwnd, to)          SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)to)

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

#define CALLWNDPROC WNDPROC

#include "idispids.h"


/*****************************************************************************\
    Global state management.
    DLL reference count, DLL critical section.
\*****************************************************************************/
void DllAddRef(void);
void DllRelease(void);

#define NULL_FOR_EMPTYSTR(str)          (((str) && (str)[0]) ? str : NULL)
typedef void (*LISTPROC)(UINT flm, LPVOID pv);


/*****************************************************************************\
    Local Includes
\*****************************************************************************/
typedef unsigned __int64 QWORD, * LPQWORD;

// This is defined in WININET.CPP
typedef LPVOID HINTERNET;
typedef HGLOBAL HIDA;

#define QW_MAC              0xFFFFFFFFFFFFFFFF

#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

#define MAX_EMAIL_ADDRESSS              MAX_URL_STRING



//  Features (This is where they are turned on and off)
//#define FEATURE_MAILBOX             // This is the editbox in the shell where an email address can be opened.
//#define FEATURE_EMAILASSOCIATIONS   // This is the API that will track Email Associations.

// Testing Options
#define TESTING_IN_SAME_DIR



// String Constants
// Registry
#define SZ_REGKEY_IDENTITIES        "Identities"
#define SZ_REGKEY_IEMAIN            TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define SZ_REGKEY_OE50_PART2        "Software\\Microsoft\\Outlook Express\\5.0"
#define SZ_REGKEY_INTERNET_ACCT     "Software\\Microsoft\\Internet Account Manager"
#define SZ_REGKEY_ACCOUNTS          "Accounts"
#define SZ_REGKEY_MAILCLIENTS       TEXT("Software\\Clients\\Mail")
#define SZ_REGKEY_EXPLOREREMAIL     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Email")
#define SZ_REGKEY_SHELLOPENCMD      TEXT("Shell\\open\\command")
#define SZ_REGKEY_MAILTRANSPORT     TEXT("MailTransport")

#define SZ_REGVALUE_USE_GOBUTTON    TEXT("ShowGoButton")
#define SZ_REGVALUE_DEFAULT_MAIL_ACCT       "Default Mail Account"
#define SZ_REGVALUE_MAIL_ADDRESS    "SMTP Email Address"
#define SZ_REGVALUE_STOREROOT       "Store Root"
#define SZ_REGVALUE_LASTUSERID      "Last User ID"
#define SZ_REGVALUE_LAST_MAILBOX_EMAILADDRESS TEXT("Last MailBox Email address")
#define SZ_REGVALUE_READEMAILPATH   TEXT("ReadEmailPath")
#define SZ_REGVALUE_READEMAILCMDLINE   TEXT("ReadEmailCmdLine")

#define SZ_REGVALUE_WEB             L"WEB"
#define SZ_REGVALUE_URL             L"URL"
#define SZ_REGVALUE_MAILPROTOCOLS   L"MailProtocols"
#define SZ_REGVALUE_MAILPROTOCOL    L"MailProtocol"
#define SZ_REGVALUE_PREFERREDAPP    L"Preferred App"

#define SZ_REGDATA_WEB              L"WEB"

#define SZ_TOKEN_EMAILADDRESS       L"<EmailAddress>"

// Just Works, AutoDiscovery
#define SZ_REGKEY_AUTODISCOVERY     L"Software\\Microsoft\\Windows\\CurrentVersion\\JustWorks\\AutoDiscovery"
#define SZ_REGKEY_GLOBALSERVICES    SZ_REGKEY_AUTODISCOVERY L"\\GlobalServices"
#define SZ_REGKEY_SERVICESALLOWLIST SZ_REGKEY_GLOBALSERVICES L"\\AllowList"
#define SZ_REGKEY_EMAIL_MRU         SZ_REGKEY_AUTODISCOVERY L"\\EmailMRU"

#define SZ_REGVALUE_SERVICES_POLICY L"Use Global Services"      // If FALSE (SZ_REGKEY_AUTODISCOVERY), then the global services won't be used.
#define SZ_REGVALUE_MS_ONLY_ADDRESSES L"Service On List"        // If TRUE (SZ_REGKEY_AUTODISCOVERY), then only use the global services if the email domain is in the list.
#define SZ_REGVALUE_TEST_INTRANETS  L"Test Intranets"           // If TRUE (SZ_REGKEY_AUTODISCOVERY), then we will still hit the secondary servers for intranet email addresses.

// XML Elements
#define SZ_XMLELEMENT_AUTODISCOVERY L"AUTODISCOVERY"

#define SZ_XMLELEMENT_REQUEST       L"REQUEST"
#define SZ_XMLELEMENT_ACCOUNT       L"ACCOUNT"
#define SZ_XMLELEMENT_TYPE          L"TYPE"
#define SZ_XMLELEMENT_VERSION       L"VERSION"
#define SZ_XMLELEMENT_RESPONSEVER   L"RESPONSEVER"
#define SZ_XMLELEMENT_LANG          L"LANG"
#define SZ_XMLELEMENT_EMAIL         L"EMAIL"

#define SZ_XMLELEMENT_RESPONSE      L"RESPONSE"
#define SZ_XMLELEMENT_USER          L"USER"
#define SZ_XMLELEMENT_INFOURL       L"INFOURL"
#define SZ_XMLELEMENT_DISPLAYNAME   L"DISPLAYNAME"
#define SZ_XMLELEMENT_ACTION        L"ACTION"
#define SZ_XMLELEMENT_PROTOCOL      L"PROTOCOL"
#define SZ_XMLELEMENT_SERVER        L"SERVER"
#define SZ_XMLELEMENT_PORT          L"PORT"
#define SZ_XMLELEMENT_LOGINNAME     L"LOGINNAME"
#define SZ_XMLELEMENT_SPA           L"SPA"
#define SZ_XMLELEMENT_SSL           L"SSL"
#define SZ_XMLELEMENT_AUTHREQUIRED  L"AUTHREQUIRED"
#define SZ_XMLELEMENT_USEPOPAUTH    L"USEPOPAUTH"
#define SZ_XMLELEMENT_POSTHTML      L"PostHTML"
#define SZ_XMLELEMENT_REDIRURL      L"URL"

#define SZ_XMLTEXT_EMAIL            L"EMAIL"
#define SZ_XMLTEXT_SETTINGS         L"settings"
#define SZ_XMLTEXT_REDIRECT         L"REDIRECT"






// getXML() Querys & Actions
#define SZ_QUERYDATA_TRUE           L"True"
#define SZ_QUERYDATA_FALSE          L"False"




// AutoDiscovery
#define SZ_SERVERPORT_DEFAULT       L"Default"
#define SZ_HTTP_VERB_POST           "POST"

// Parsing Characters
#define CH_ADDRESS_SEPARATOR       L';'
#define CH_ADDRESS_QUOTES          L'"'
#define CH_EMAIL_START             L'<'
#define CH_EMAIL_END               L'>'
#define CH_EMAIL_AT                L'@'
#define CH_EMAIL_DOMAIN_SEPARATOR  L'.'
#define CH_HTML_ESCAPE             L'%'
#define CH_COMMA                   L','






/*****************************************************************************\
    Local Includes
\*****************************************************************************/
#include "dllload.h"
#include "util.h"


/*****************************************************************************\
    Object Constructors
\*****************************************************************************/
HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);
STDAPI CAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
STDAPI CMailAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
STDAPI CACLEmail_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj);
STDAPI CEmailAssociations_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj);


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\resource.h ===
/*****************************************************************************\
    FILE: resource.h

    DESCRIPTION:
        Header file for the resource file

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include <commctrl.h>

// String Resource IDs (0x1000 - 0x10000)
#define IDS_MAILBOX_DESKBAR_LABEL                       1000
#define IDS_MAILBOXUI_GOBUTTON_LABEL                    1001
#define IDS_ASSOC_GETEMAILADDRESS                       1002
#define IDS_AUTODISCOVER_WIZARD_CAPTION                 1003
#define IDS_AUTODISCOVER_PROGRESS                       1004
#define IDS_AUTODISCOVER_PROGRESS_SUB                   1005
#define IDS_MANUALLY_CHOOSE_APP                         1006
#define IDS_MANUALLY_CHOOSE_APP_SUB                     1007
#define IDS_SKIP_BUTTON                                 1008
#define IDS_CHOOSEAPP_FAILED_RESULTS                    1009
#define IDS_ASSOC_GETEMAILADDRESS_SUB                   1010


// These are the strings we share with OE's acctres.dll    
#define IDS_STATUS_CONNECTING_TO                        40398
#define IDS_STATUS_DOWNLOADING                          40399

// Error Strings
#define IDS_MAILBOXUI_ERR_INVALID_EMAILADDR             2000
#define IDS_MAILBOXUI_ERR_INVALID_EMAILADDR_TITLE       2001




// Dialogs  (100 - 400)




// Wizard Pages  (401 - 600)
#define IDD_AUTODISCOVER_PROGRESS_PAGE  400
#define IDD_MANUALLY_CHOOSE_APP_PAGE    401
#define IDC_CHOOSEAPP_WEBURL_EDIT       402
#define IDC_CHOOSEAPP_WEB_RADIO         403
#define IDC_CHOOSEAPP_OTHERAPP_RADIO    404
#define IDC_CHOOSEAPP_DESC              405
#define IDC_AUTODISCOVERY_ANIMATION     406
#define IDC_CHOOSEAPP_APPLIST           407

#define IDD_ASSOC_GETEMAILADDRESS_PAGE  408
#define IDC_GETEMAILADDRESS_EDIT        409



// Bitmap Resource IDs (601 - 700)
#define IDB_GO                          601
#define IDB_GOHOT                       602
#define IDB_PSW_BANNER                  603


// Icons IDs (701 - 800)


// AVI Resource IDs (801 - 900)
#define IDA_DOWNLOADINGSETTINGS         801
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\objcache.cpp ===
/*****************************************************************************\
    FILE: objcache.cpp

    DESCRIPTION:
        This is a lightweight API that will cache an object so the class factory
    will return the same object each time for every call in this process.  If the
    caller is on another thread, they will get a marshalled stub to the real
    McCoy.
    
    To Add an Object:
    1. classfactory.cpp calls CachedObjClassFactoryCreateInstance().  Add your
       object's CLSID to that if statement for that call.
    2. Copy the section in CachedObjClassFactoryCreateInstance() that looks
       for a CLSID and calls the correct xxx_CreateInstance() method.
    3. Your object's IUnknown::Release() needs to call CachedObjCheckRelease()
       at the top of your Release() method.  It may reduce your m_cRef to 1 so
       it will go to zero after ::Release() decrements it.  The object cache
       will hold two references to the object.  CachedObjCheckRelease() will check
       if the last caller (3rd ref) is releasing, and then it will give up it's 2
       refs and clean up it's internal state.  The Release() then decrements
       the callers ref and it's released because it hit zero.

    BryanSt 12/9/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "objcache.h"

//////////////////////////////////////////////
// Object Caching API
//////////////////////////////////////////////
HDPA g_hdpaObjects = NULL;
CRITICAL_SECTION g_hCachedObjectSection;

typedef struct
{
    CLSID clsid;
    IStream * pStream;
    IUnknown * punk;
    DWORD dwThreadID;
} CACHEDOBJECTS;


STDAPI _GetObjectCacheArray(void)
{
    HRESULT hr = S_OK;

    if (!g_hdpaObjects)
    {
        g_hdpaObjects = DPA_Create(1);
        if (!g_hdpaObjects)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

// This is the number of references that are used by the cache list
// (One for punk & one for pStream).  If we hit this number,
// then there aren't any outstanding refs.
#define REF_RELEASE_POINT    3

int CALLBACK HDPAFindCLSID(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    CLSID * pClsidToFind = (CLSID *)p1;
    CACHEDOBJECTS * pCachedObjects = (CACHEDOBJECTS *)p2;
    int nReturn = 0;

    // Are they of different types?
    if (pCachedObjects->clsid.Data1 < pClsidToFind->Data1) nReturn = -1;
    else if (pCachedObjects->clsid.Data1 > pClsidToFind->Data1) nReturn = 1;
    else if (pCachedObjects->clsid.Data2 < pClsidToFind->Data2) nReturn = -1;
    else if (pCachedObjects->clsid.Data2 > pClsidToFind->Data2) nReturn = 1;
    else if (pCachedObjects->clsid.Data3 < pClsidToFind->Data3) nReturn = -1;
    else if (pCachedObjects->clsid.Data3 > pClsidToFind->Data3) nReturn = 1;
    else if (*(ULONGLONG *)&pCachedObjects->clsid.Data4 < *(ULONGLONG *)&pClsidToFind->Data4) nReturn = -1;
    else if (*(ULONGLONG *)&pCachedObjects->clsid.Data4 > *(ULONGLONG *)&pClsidToFind->Data4) nReturn = 1;

    return nReturn;
}


STDAPI ObjectCache_GetObject(CLSID clsid, REFIID riid, void ** ppvObj)
{
    HRESULT hr = S_OK;

    hr = _GetObjectCacheArray();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        int nIndex = DPA_Search(g_hdpaObjects, &clsid, 0, HDPAFindCLSID, NULL, DPAS_SORTED);

        if (0 <= nIndex)
        {
            CACHEDOBJECTS * pCurrentObject = (CACHEDOBJECTS *) DPA_GetPtr(g_hdpaObjects, nIndex);

            if (pCurrentObject)
            {
                if (GetCurrentThreadId() == pCurrentObject->dwThreadID)
                {
                    // No Marshalling needed.
                    hr = pCurrentObject->punk->QueryInterface(riid, ppvObj);
                }
                else
                {
                    // We do need to marshal it.  So read it out of the stream.
                    // But first we want to store our place in the stream so
                    // we can rewrind for the next schmooo.
                    LARGE_INTEGER liZero;
                    ULARGE_INTEGER uli;

                    liZero.QuadPart = 0;
                    hr = pCurrentObject->pStream->Seek(liZero, STREAM_SEEK_CUR, &uli);
                    if (SUCCEEDED(hr))
                    {
                        LARGE_INTEGER li;
                        
                        li.QuadPart = uli.QuadPart;
                        hr = CoUnmarshalInterface(pCurrentObject->pStream, riid, ppvObj);
                        if (SUCCEEDED(hr))
                        {
                            pCurrentObject->pStream->Seek(li, STREAM_SEEK_SET, NULL);
                        }
                    }

                }
            }
        }
    }

    return hr;
}

// WARNING: DllGetClassObject/CoGetClassObject
//   may be much better to use than rolling our own thread safe
//   code.


STDAPI ObjectCache_SetObject(CLSID clsid, REFIID riid, IUnknown * punk)
{
    HRESULT hr = _GetObjectCacheArray();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        int nIndex = DPA_Search(g_hdpaObjects, &clsid, 0, HDPAFindCLSID, NULL, DPAS_SORTED);

        // If it's not in the list.
        if (0 > nIndex)
        {
            CACHEDOBJECTS * pcoCurrentObject = (CACHEDOBJECTS *) LocalAlloc(LPTR, sizeof(CACHEDOBJECTS));

            if (pcoCurrentObject)
            {
                pcoCurrentObject->dwThreadID = GetCurrentThreadId();
                pcoCurrentObject->clsid = clsid;

                punk->AddRef();     // Ref now equals 2 (The structure will own this ref)
                IStream * pStream = SHCreateMemStream(NULL, 0);
                if (pStream)
                {
                    hr = CoMarshalInterface(pStream, riid, punk, MSHCTX_INPROC, NULL, MSHLFLAGS_NORMAL);
                    if (SUCCEEDED(hr))  // Ref now equals 3
                    {
                        LARGE_INTEGER liZero;

                        // Reset the Stream to the beginning.
                        liZero.QuadPart = 0;
                        hr = pStream->Seek(liZero, STREAM_SEEK_SET, NULL);
                        if (SUCCEEDED(hr))
                        {
                            pcoCurrentObject->punk = punk;
                            pcoCurrentObject->pStream = pStream;

                            if (-1 == DPA_SortedInsertPtr(g_hdpaObjects, &clsid, 0, HDPAFindCLSID, NULL, (DPAS_SORTED | DPAS_INSERTBEFORE), pcoCurrentObject))
                            {
                                // It failed.
                                hr = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr))
                {
                    LocalFree(pcoCurrentObject);
                    punk->Release();
                    ATOMICRELEASE(pStream);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}



STDAPI CachedObjClassFactoryCreateInstance(CLSID clsid, REFIID riid, void ** ppvObj)
{
    HRESULT hr;

    EnterCriticalSection(&g_hCachedObjectSection);
    hr = ObjectCache_GetObject(clsid, riid, ppvObj);
    if (FAILED(hr))
    {
        /*
        if (IsEqualCLSID(clsid, CLSID_MailApp))
        {
            hr = CMailAppOM_CreateInstance(NULL, riid, ppvObj);
        }
*/
        if (SUCCEEDED(hr))
        {
            // ObjectCache_SetObject will fail in some
            // multi-threaded cases.
            hr = ObjectCache_SetObject(clsid, riid, (IUnknown *) *ppvObj);
        }
    }
    LeaveCriticalSection(&g_hCachedObjectSection);

    return hr;
}


int ObjectCache_DestroyCB(LPVOID pv, LPVOID pvData)
{
    CACHEDOBJECTS * pCachedObjects = (CACHEDOBJECTS *)pv;

    AssertMsg((NULL != pCachedObjects), "Why would this be NULL?");
    if (pCachedObjects)
    {
        SAFERELEASE(pCachedObjects->punk);
        SAFERELEASE(pCachedObjects->pStream);
        LocalFree(pCachedObjects);
    }

    return TRUE;
}


STDAPI CachedObjCheckRelease(CLSID clsid, int * pnRef)
{
    HRESULT hr = E_INVALIDARG;

    if (pnRef)
    {
        hr = S_OK;
        if (REF_RELEASE_POINT == *pnRef)
        {
            EnterCriticalSection(&g_hCachedObjectSection);
            if (REF_RELEASE_POINT == *pnRef)
            {
                hr = _GetObjectCacheArray();
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                    int nIndex = DPA_Search(g_hdpaObjects, &clsid, 0, HDPAFindCLSID, NULL, DPAS_SORTED);

                    if (0 <= nIndex)
                    {
                        CACHEDOBJECTS * pCurrentObject = (CACHEDOBJECTS *) DPA_GetPtr(g_hdpaObjects, nIndex);

                        if (pCurrentObject)
                        {
                            // We need to delete the pointer from the array before
                            // we release the object or it will recurse infinitely.
                            // The problem is that when ObjectCache_DestroyCB() releases
                            // the object, the Release() function will call CachedObjCheckRelease().
                            // And since the ref hasn't change -yet-, we need the
                            // search to fail to stop the recursion.
                            DPA_DeletePtr(g_hdpaObjects, nIndex);
                            ObjectCache_DestroyCB(pCurrentObject, NULL);
                        }
                    }
                }
            }
            LeaveCriticalSection(&g_hCachedObjectSection);
        }
    }

    return hr;
}


STDAPI PurgeObjectCache(void)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_hCachedObjectSection);
    if (g_hdpaObjects)
    {
        DPA_DestroyCallback(g_hdpaObjects, ObjectCache_DestroyCB, NULL);
        g_hdpaObjects = NULL;
    }
    LeaveCriticalSection(&g_hCachedObjectSection);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "dllload.h"
#define HINST_THISDLL       g_hinst


// String Helpers
HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest);
HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstrXML);
LPSTR AllocStringFromBStr(BSTR bstr);
HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString);
HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);

#ifdef UNICODE
#define SysAllocStringT(pszString)    SysAllocString(pszString)
#else
extern BSTR SysAllocStringA(LPCSTR pszString);
#define SysAllocStringT(pszString)    SysAllocStringA(pszString)
#endif

HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData);
HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped);
HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize);


// XML Related Helpers
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc);
HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML);
HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend);
HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc);
HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName);
HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList);
HRESULT XMLNodeList_GetChild(IXMLDOMNodeList * pNodeList, DWORD dwIndex, IXMLDOMNode ** ppXMLChildNode);
HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode);
HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean);
BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText);




// Wininet Helpers
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle);
HRESULT InternetCloseHandleWrap(HINTERNET hInternet);
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead);
HRESULT HttpOpenRequestWrap(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion, 
                            IN LPCSTR lpszReferer, IN LPCSTR FAR * lpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext,
                            LPDWORD pdwNumberOfBytesRead, HINTERNET * phConnectionHandle);
HRESULT HttpSendRequestWrap(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,  IN DWORD dwHeadersLength, IN LPVOID lpOptional, DWORD dwOptionalLength);
HRESULT CreateUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN DWORD dwExpectedFileSize, IN LPCTSTR lpszFileExtension, OUT LPTSTR lpszFileName, IN DWORD dwReserved);
HRESULT CommitUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN LPCTSTR lpszLocalFileName, IN FILETIME ExpireTime, IN FILETIME LastModifiedTime,
                                IN DWORD CacheEntryType, IN LPWSTR lpHeaderInfo, IN DWORD dwHeaderSize, IN LPCTSTR lpszFileExtension, IN LPCTSTR lpszOriginalUrl);
HRESULT InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML);


// File System Helpers
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle);
HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
HRESULT DeleteFileHrWrap(LPCWSTR pszPath);


// DPA Helpers
int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData);
int DPA_StringCompareCB(LPVOID pvString1, LPVOID pvString2, LPARAM lParam);
HRESULT AddHDPA_StrDup(IN LPCWSTR pszString, IN HDPA * phdpa);

// Other Helpers
HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
HRESULT MarkObjectSafe(IUnknown * punk);
BOOL _InitComCtl32();
DWORD GetOSVer(void);
BOOL IsOSNT(void);





// Other Wrappers
HRESULT HrRewindStream(IStream * pstm);
HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);




typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO, * LPPROGRESSINFO;

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi);

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
void    GetDateString(char * szSentDateString, ULONG stringLen);



#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\wizard.h ===
/*****************************************************************************\
    FILE: wizard.h

    DESCRIPTION:
        This file implements the wizard used to "AutoDiscover" the data that
    matches an email address to a protocol.  It will also provide other UI
    needed in that process.

    BryanSt 3/5/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _WIZARD_H
#define _WIZARD_H
#ifdef FEATURE_MAILBOX


STDAPI DisplayMailBoxWizard(LPARAM lParam, BOOL fShowGetEmailPage);



#endif // FEATURE_MAILBOX
#endif // _WIZARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\wizard.cpp ===
/*****************************************************************************\
    FILE: wizard.cpp

    DESCRIPTION:
        This file implements the wizard used to "AutoDiscover" the data that
    matches an email address to a protocol.  It will also provide other UI
    needed in that process.

    BryanSt 3/5/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#include "wizard.h"
#include "mailbox.h"

#ifdef FEATURE_MAILBOX

#define WIZDLG(name, dlgproc, dwFlags)   \
            { MAKEINTRESOURCE(IDD_##name##_PAGE), dlgproc, MAKEINTRESOURCE(IDS_##name##), MAKEINTRESOURCE(IDS_##name##_SUB), dwFlags }

// The wizard pages we are adding
struct
{
    LPCWSTR idPage;
    DLGPROC pDlgProc;
    LPCWSTR pHeading;
    LPCWSTR pSubHeading;
    DWORD dwFlags;
}
g_pages[] =
{
    WIZDLG(ASSOC_GETEMAILADDRESS,       GetEmailAddressDialogProc,       0),
    WIZDLG(AUTODISCOVER_PROGRESS,       MailBoxProgressDialogProc,       0),
    WIZDLG(MANUALLY_CHOOSE_APP,         ChooseAppDialogProc,      0),
};


//-----------------------------------------------------------------------------
//  Main entry point used to invoke the wizard.
//-----------------------------------------------------------------------------
/*
static WNDPROC _oldDlgWndProc;

LRESULT CALLBACK _WizardSubWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // on WM_WINDOWPOSCHANGING and the window is moving then lets centre it onto the
    // desktop window.  unfortunately setting the DS_CENTER bit doesn't buy us anything
    // as the wizard is resized after creation.
    //

    if ( uMsg == WM_WINDOWPOSCHANGING )
    {
        LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;
        RECT rcDlg, rcDesktop;

        GetWindowRect(hwnd, &rcDlg);
        GetWindowRect(GetDesktopWindow(), &rcDesktop);

        lpwp->x = ((rcDesktop.right-rcDesktop.left)-(rcDlg.right-rcDlg.left))/2;
        lpwp->y = ((rcDesktop.bottom-rcDesktop.top)-(rcDlg.bottom-rcDlg.top))/2;
        lpwp->flags &= ~SWP_NOMOVE;
    }

    return _oldDlgWndProc(hwnd, uMsg, wParam, lParam);        
}
*/


int CALLBACK _PropSheetCB(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    switch (uMsg)
    {
    // in pre-create lets set the window styles accorindlgy
    //      - remove the context menu and system menu
    case PSCB_PRECREATE:
    {
        DLGTEMPLATE *pdlgtmp = (DLGTEMPLATE*)lParam;
        pdlgtmp->style &= ~(DS_CONTEXTHELP|WS_SYSMENU);
        break;
    }

    // we now have a dialog, so lets sub class it so we can stop it being
    // move around.
    case PSCB_INITIALIZED:
    {
        // TODO: David, why do this?
//            if ( g_uWizardIs != NAW_NETID )
//                _oldDlgWndProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)_WizardSubWndProc);

        break;
    }
 
    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case LVN_GETDISPINFO:
            uMsg++;
            break;
        }
    }
    default:
        TraceMsg(TF_ALWAYS, "_PropSheetCB(uMsg = %d)", uMsg);
        break;
    }

    return FALSE;
}


STDAPI DisplayMailBoxWizard(LPARAM lParam, BOOL fShowGetEmailPage)
{
    HWND hwndParent = NULL;
    HRESULT hr = S_OK;
    PROPSHEETHEADER psh = { 0 };
    HPROPSHEETPAGE rghpage[ARRAYSIZE(g_pages)];
    INT_PTR nResult;
    int nCurrentPage;
    int nPages;
    int nFirstPage;

    if (fShowGetEmailPage)
    {
        nFirstPage = 0;
        nPages = ARRAYSIZE(g_pages);
    }
    else
    {
        nFirstPage = 1;
        nPages = ARRAYSIZE(g_pages) - 1;
    }
    
    // build the pages for the wizard.
    for (nCurrentPage = 0; nCurrentPage < ARRAYSIZE(g_pages) ; nCurrentPage++ )
    {                           
        PROPSHEETPAGE psp = { 0 };
        WCHAR szBuffer[MAX_PATH] = { 0 };

        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.hInstance = HINST_THISDLL;
        psp.lParam = lParam;
        psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER | g_pages[nCurrentPage + nFirstPage].dwFlags; // Do we want: PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | (PSP_USECALLBACK | )
        psp.pszTemplate = g_pages[nCurrentPage + nFirstPage].idPage;
        psp.pfnDlgProc = g_pages[nCurrentPage + nFirstPage].pDlgProc;
        psp.pszTitle = MAKEINTRESOURCE(IDS_AUTODISCOVER_WIZARD_CAPTION);
        psp.pszHeaderTitle = g_pages[nCurrentPage + nFirstPage].pHeading;
        psp.pszHeaderSubTitle = g_pages[nCurrentPage + nFirstPage].pSubHeading;

        rghpage[nCurrentPage] = CreatePropertySheetPage(&psp);
    }

    // wizard pages are ready, so lets display the wizard.
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.hwndParent = hwndParent;
    psh.hInstance = HINST_THISDLL;

    // TODO: We will want to add this PSH_HASHELP, PSH_USEICONID 
    psh.dwFlags = PSH_NOCONTEXTHELP | PSH_WIZARD | PSH_WIZARD_LITE | PSH_NOAPPLYNOW | PSH_USECALLBACK;  // PSH_WATERMARK
//    psh.pszbmHeader = MAKEINTRESOURCE(IDB_PSW_BANNER);
//    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_PSW_WATERMARK);
    psh.nPages = nPages;
    psh.phpage = rghpage;
    psh.pfnCallback = _PropSheetCB;

    nResult = PropertySheet(&psh);

    return hr;
}


#endif // FEATURE_MAILBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\test\adstress\resource.h ===
// Resource IDs for FTPFOLDR
//


/*****************************************************************************
 *
 *      Dialogs (and dialog controls)
 *
 *****************************************************************************/
#define IDD_MAINDLG                         1000

#define IDD_MAINDLG                         1000
#define ID_OPEN                             (IDD_MAINDLG + 1)
#define ID_OPENMULTIPLE                     (IDD_MAINDLG + 2)
#define ID_SAVE                             (IDD_MAINDLG + 3)
#define IDC_STATUS                          (IDD_MAINDLG + 4)
#define ID_SAVEAS                           (IDD_MAINDLG + 5)
#define IDC_DOCTEXT                         (IDD_MAINDLG + 6)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\certfram.cpp ===
#include        "pch.hxx"
#ifndef WIN16
#include        <commctrl.h>
#endif // !WIN16
#include        "demand.h"

////////////////////////////////////////////////////////

CCertFrame::CCertFrame(PCCERT_CONTEXT pccert) {
        m_pccert = CertDuplicateCertificateContext(pccert);
        m_pcfNext = NULL;
        m_cParents = 0;
        m_dwFlags = 0;
        m_cTrust = 0;
        m_rgTrust = NULL;
        m_fSelfSign = FALSE;
        m_fRootStore = FALSE;
        m_fLeaf = FALSE;
        m_fExpired = FALSE;
    }

CCertFrame::~CCertFrame(void)
{
    int     i;
    CertFreeCertificateContext(m_pccert);
    for (i=0; i<m_cParents; i++) {
        delete m_rgpcfParents[i];
    }
    for (i=0; i<m_cTrust; i++) {
        delete m_rgTrust[i].pbTrustData;
    }
    delete m_rgTrust;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\test\adstress\debug.cpp ===
// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "WINMAIL"
#define SZ_MODULE           "WINMAIL"
#define DECLARE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\test\adstress\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 2/8/2000
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////

HINSTANCE g_hinst;              // My instance handle



#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0;
DWORD g_TLSliStopWatchStartLo = 0;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;
    
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));

//    ASSERT(!liStopWatchStart.QuadPart); // If you hit this, then the stopwatch is nested.
    QueryPerformanceFrequency(&g_liStopWatchFreq);
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, UlongToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, UlongToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);
    
    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG


void StartTaskWatch(IN LARGE_INTEGER * pliTaskStart, IN LARGE_INTEGER * pliTaskFreq)
{
    QueryPerformanceFrequency(pliTaskFreq);
    QueryPerformanceCounter(pliTaskStart);
}

DWORD StopTaskWatch(IN LARGE_INTEGER * pliTaskStart, IN LARGE_INTEGER * pliTaskFreq)
{
    LARGE_INTEGER liDiff;
    
    QueryPerformanceCounter(&liDiff);
    liDiff.QuadPart -= pliTaskStart->QuadPart;

    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / pliTaskFreq->QuadPart);
    
    pliTaskStart->QuadPart = 0;

    return dwTime;
}




/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////
#undef SysAllocStringA
BSTR SysAllocStringA(LPCSTR pszStr)
{
    BSTR bstrOut = NULL;

    if (pszStr)
    {
        DWORD cchSize = (lstrlenA(pszStr) + 1);
        LPWSTR pwszThunkTemp = (LPWSTR) LocalAlloc(LPTR, (sizeof(pwszThunkTemp[0]) * cchSize));  // assumes INFOTIPSIZE number of chars max

        if (pwszThunkTemp)
        {
            SHAnsiToUnicode(pszStr, pwszThunkTemp, cchSize);
            bstrOut = SysAllocString(pwszThunkTemp);
            LocalFree(pwszThunkTemp);
        }
    }

    return bstrOut;

}


HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocStringA(pszSource);
        if (pszSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


LPSTR AllocStringFromBStr(BSTR bstr)
{
    int nLength = 1 + lstrlenW(bstr);

    LPSTR pszNew = (LPSTR)LocalAlloc(LPTR, nLength);
    if (pszNew)
    {
        SHUnicodeToAnsi((bstr ? bstr : L""), pszNew, nLength);
    }

    return pszNew;
}


HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstr)
{
    STATSTG statStg = {0};
    HRESULT hr = pStream->Stat(&statStg, STATFLAG_NONAME);

    if (S_OK == hr)
    {
        DWORD cchSize = statStg.cbSize.LowPart;
        *pbstr = SysAllocStringLen(NULL, cchSize + 4);

        if (*pbstr)
        {
            LPSTR pszTemp = (LPSTR) LocalAlloc(LPTR, sizeof(pszTemp[0]) * (cchSize + 4));

            if (pszTemp)
            {
                ULONG cbRead;

                hr = pStream->Read(pszTemp, cchSize, &cbRead);
                pszTemp[cchSize] = 0;
                SHAnsiToUnicode(pszTemp, *pbstr, (cchSize + 1));

                LocalFree(pszTemp);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStream
// --------------------------------------------------------------------------------
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        hr = pstmIn->Read(buf, sizeof(buf), &cbRead);
        if (FAILED(hr) || cbRead == 0)
        {
            break;
        }
        hr = pstmOut->Write(buf, cbRead, NULL);
        if (FAILED(hr))
        {
            break;
        }
        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));
 
    if (pcb && SUCCEEDED(hr))
        *pcb = cbTotal;

    return hr;
}


HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString)
{
    HRESULT hr = E_INVALIDARG;

    if (pvar)
    {
        pvar->bstrVal = SysAllocString(pwszString);
        if (pvar->bstrVal)
        {
            pvar->vt = VT_BSTR;
            hr = S_OK;
        }
        else
        {
            pvar->vt = VT_EMPTY;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped)
{
    HRESULT hr = HrSysAllocString(bstrEscaped, pbstrUnEscaped);

    if (SUCCEEDED(hr))
    {
        // Find %xx and replace.
        LPWSTR pwszEscapedSequence = StrChrW(*pbstrUnEscaped, CH_HTML_ESCAPE);
        WCHAR wzEscaped[5] = L"0xXX";

        while (pwszEscapedSequence && (3 <= lstrlenW(pwszEscapedSequence)))
        {
            int nCharCode;

            wzEscaped[2] = pwszEscapedSequence[1];
            wzEscaped[3] = pwszEscapedSequence[2];
            StrToIntExW(wzEscaped, STIF_SUPPORT_HEX, &nCharCode);

            // Replace the '%' with the real char.
            pwszEscapedSequence[0] = (WCHAR) nCharCode;

            pwszEscapedSequence = CharNextW(pwszEscapedSequence);   // Skip pasted the replaced char.

            // Over write the 0xXX value.
            StrCpyW(pwszEscapedSequence, &pwszEscapedSequence[2]);

            // Next...
            pwszEscapedSequence = StrChrW(pwszEscapedSequence, CH_HTML_ESCAPE);
        }
    }

    return hr;
}



/*****************************************************************************\
    PARAMETERS:
        If fBoolean is TRUE, return "True" else "False".
\*****************************************************************************/
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrValue)
    {
        LPCWSTR pwszValue;

        *pbstrValue = NULL;
        if (TRUE == fBoolean)
        {
            pwszValue = SZ_QUERYDATA_TRUE;
        }
        else
        {
            pwszValue = SZ_QUERYDATA_FALSE;
        }

        hr = HrSysAllocString(pwszValue, pbstrValue);
    }

    return hr;
}




/////////////////////////////////////////////////////////////////////
// XML Related Helpers
/////////////////////////////////////////////////////////////////////
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void **)ppXMLDoc);

    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL fIsSuccessful;

        // NOTE: This will throw an 0xE0000001 exception in MSXML if the XML is invalid.
        //    This is not good but there isn't much we can do about it.  The problem is
        //    that web proxies give back HTML which fails to parse.
        hr = (*ppXMLDoc)->loadXML(bstrXML, &fIsSuccessful);
        if (SUCCEEDED(hr))
        {
            if (VARIANT_TRUE != fIsSuccessful)
            {
                hr = E_FAIL;
            }
        }
    }

    if (FAILED(hr))
    {
        (*ppXMLDoc)->Release();
        ppXMLDoc = NULL;
    }

    return hr;
}


HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML)
{
    IStream * pStream;
    HRESULT hr = pXMLDoc->QueryInterface(IID_IStream, (void **)&pStream); // check the return value

    if (S_OK == hr)
    {
        hr = BSTRFromStream(pStream, pbstrXML);
        pStream->Release();
    }

    return hr;
}


HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend)
{
    IXMLDOMNode * pXMLNodeRoot;
    HRESULT hr = pXMLElementRoot->QueryInterface(IID_IXMLDOMNode, (void **)&pXMLNodeRoot);

    if (SUCCEEDED(hr))
    {
        IXMLDOMNode * pXMLNodeToAppend;
        
        hr = pXMLElementToAppend->QueryInterface(IID_IXMLDOMNode, (void **)&pXMLNodeToAppend);
        if (SUCCEEDED(hr))
        {
            hr = pXMLNodeRoot->appendChild(pXMLNodeToAppend, NULL);
            pXMLNodeToAppend->Release();
        }

        pXMLNodeRoot->Release();
    }

    return hr;
}


HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc)
{
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void **)ppXMLDOMDoc);

    if (SUCCEEDED(hr))
    {
        VARIANT xmlSource;

        xmlSource.vt = VT_BSTR;
        xmlSource.bstrVal = SysAllocString(pwzPath);

        if (xmlSource.bstrVal)
        {
            VARIANT_BOOL fIsSuccessful = VARIANT_TRUE;

            hr = (*ppXMLDOMDoc)->load(xmlSource, &fIsSuccessful);
            if ((S_FALSE == hr) || (VARIANT_FALSE == fIsSuccessful))
            {
                // This happens when the file isn't a valid XML file.
                hr = E_FAIL;
            }

            VariantClear(&xmlSource);
        }

        if (FAILED(hr) && *ppXMLDOMDoc)
        {
            (*ppXMLDOMDoc)->Release();
        }
    }

    return hr;
}


HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName)
{
    BSTR bstrTagName;
    HRESULT hr = pXMLElementMessage->get_tagName(&bstrTagName);

    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    else if (SUCCEEDED(hr))
    {
        if (!bstrTagName || !pwszTagName || StrCmpIW(bstrTagName, pwszTagName))
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}

HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList)
{
    BSTR bstrTagName = SysAllocString(pwszTagName);
    HRESULT hr = E_OUTOFMEMORY;

    *ppNodeList = NULL;
    if (bstrTagName)
    {
        hr = pXMLElementMessage->getElementsByTagName(bstrTagName, ppNodeList);
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}


HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue)
{
    BSTR bstrAttributeName = SysAllocString(pwszAttributeName);
    HRESULT hr = E_OUTOFMEMORY;

    *pbstrValue = NULL;
    if (bstrAttributeName)
    {
        IXMLDOMNamedNodeMap * pNodeAttributes;

        hr = pXMLNode->get_attributes(&pNodeAttributes);
        if (S_FALSE == hr)  hr = E_FAIL;
        if (SUCCEEDED(hr))
        {
            IXMLDOMNode * pTypeAttribute;

            hr = pNodeAttributes->getNamedItem(bstrAttributeName, &pTypeAttribute);
            if (S_FALSE == hr)  hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            if (SUCCEEDED(hr))
            {
                VARIANT varAtribValue = {0};

                hr = pTypeAttribute->get_nodeValue(&varAtribValue);
                if (S_FALSE == hr)  hr = E_FAIL;
                if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
                {
                    *pbstrValue = SysAllocString(varAtribValue.bstrVal);
                }

                VariantClear(&varAtribValue);
                pTypeAttribute->Release();
            }

            pNodeAttributes->Release();
        }

        SysFreeString(bstrAttributeName);
    }

    return hr;
}


HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode)
{
    HRESULT hr = E_INVALIDARG;

    *ppChildNode = NULL;
    if (pXMLNode)
    {
        IXMLDOMElement * pXMLElement;

        hr = pXMLNode->QueryInterface(IID_IXMLDOMElement, (void **)&pXMLElement);
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList * pNodeList;

            hr = XMLElem_GetElementsByTagName(pXMLElement, pwszTagName, &pNodeList);
            if (SUCCEEDED(hr))
            {
                hr = XMLNodeList_GetChild(pNodeList, 0, ppChildNode);
                pNodeList->Release();
            }

            pXMLElement->Release();
        }
    }

    return hr;
}


HRESULT XMLNodeList_GetChild(IXMLDOMNodeList * pNodeList, DWORD dwIndex, IXMLDOMNode ** ppXMLChildNode)
{
    HRESULT hr = pNodeList->get_item(dwIndex, ppXMLChildNode);

    if (S_FALSE == hr)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}




/////////////////////////////////////////////////////////////////////
// Wininet Wrapping Helpers
/////////////////////////////////////////////////////////////////////
#define EMPTYSTR_FOR_NULL(str)      ((!str) ? TEXT("") : (str))

/*****************************************************************************\
    FUNCTION: InternetConnectWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 144ms - 250ms (Min: 2; Max: 1,667ms)
        To: rigel.cyberpass.net <San Diego, CA>: 717ms - 1006ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 2609ms - 14,012ms

    COMMON ERROR VALUES:
        These are the return values in these different cases:
    ERROR_INTERNET_NAME_NOT_RESOLVED: No Proxy & DNS Lookup failed.
    ERROR_INTERNET_CANNOT_CONNECT: Some Auth Proxies and Netscape's Web/Auth Proxy
    ERROR_INTERNET_NAME_NOT_RESOLVED: Web Proxy
    ERROR_INTERNET_TIMEOUT: Invalid or Web Proxy blocked IP Address
    ERROR_INTERNET_INCORRECT_PASSWORD: IIS & UNIX, UserName may not exist or password for the user may be incorrect on.
    ERROR_INTERNET_LOGIN_FAILURE: Too many Users on IIS.
    ERROR_INTERNET_INCORRECT_USER_NAME: I haven't seen it.
    ERROR_INTERNET_EXTENDED_ERROR: yahoo.com exists, but ftp.yahoo.com doesn't.
\*****************************************************************************/
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetConnect(hInternet, pszServerName, nServerPort, pszUserName, pszPassword, dwService, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (fAssertOnFailure)
    {
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        Destination not applicable. 677-907ms
\*****************************************************************************/
HRESULT InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetOpen(\"%ls\") returned %u. Time=%lums", pszAgent, dwError, DebugStopWatch()));

    return hr;
}


HRESULT InternetCloseHandleWrap(HINTERNET hInternet)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!InternetCloseHandle(hInternet))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetCloseHandle(%#08lx) returned %u. Time=%lums", hInternet, dwError, DebugStopWatch()));

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenUrlWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 29ms
        To: rigel.cyberpass.net <San Diego, CA>: ???????
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetOpenUrl(%#08lx, \"%ls\") returned %u. Time=%lums", hInternet, pszUrl, dwError, DebugStopWatch()));

    return hr;
}


HRESULT HttpOpenRequestWrap(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion, 
                            IN LPCSTR lpszReferer, IN LPCSTR FAR * lpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext,
                            LPDWORD pdwNumberOfBytesRead, HINTERNET * phConnectionHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phConnectionHandle = HttpOpenRequestA(hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferer, lpszAcceptTypes, dwFlags, dwContext);
    if (!*phConnectionHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "HttpOpenRequest(%#08lx, \"%ls\") returned %u. Time=%lums", *phConnectionHandle, lpszVerb, dwError, DebugStopWatch()));

    return hr;
}


HRESULT HttpSendRequestWrap(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,  IN DWORD dwHeadersLength, IN LPVOID lpOptional, DWORD dwOptionalLength)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!HttpSendRequestA(hRequest, lpszHeaders,  dwHeadersLength, lpOptional, dwOptionalLength))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!InternetReadFile(hFile, pvBuffer, dwNumberOfBytesToRead, pdwNumberOfBytesRead))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}


HRESULT CreateUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN DWORD dwExpectedFileSize, IN LPCTSTR lpszFileExtension, OUT LPTSTR lpszFileName, IN DWORD dwReserved)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!CreateUrlCacheEntry(lpszUrlName, dwExpectedFileSize, lpszFileExtension, lpszFileName, dwReserved))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}


HRESULT CommitUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN LPCTSTR lpszLocalFileName, IN FILETIME ExpireTime, IN FILETIME LastModifiedTime,
                                IN DWORD CacheEntryType, IN UCHAR * lpHeaderInfo, IN DWORD dwHeaderSize, IN LPCTSTR lpszFileExtension, IN LPCTSTR lpszOriginalUrl)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!CommitUrlCacheEntry(lpszUrlName, lpszLocalFileName, ExpireTime, LastModifiedTime, CacheEntryType, lpHeaderInfo, dwHeaderSize, lpszFileExtension, lpszOriginalUrl))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WMAUTODISCOVERY, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    return hr;
}



#define SIZE_COPY_BUFFER                    (32 * 1024)     // 32k

HRESULT InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML)
{
    BYTE byteBuffer[SIZE_COPY_BUFFER];
    DWORD cbRead = SIZE_COPY_BUFFER;
    DWORD cchSize = 0;
    HRESULT hr = S_OK;

    *pbstrXML = NULL;
    while (SUCCEEDED(hr) && cbRead)
    {
        hr = InternetReadFileWrap(hInternetRead, byteBuffer, sizeof(byteBuffer), &cbRead);
        if (SUCCEEDED(hr) && cbRead)
        {
            BSTR bstrOld = *pbstrXML;
            BSTR bstrEnd;

            // The string may not be terminated.
            byteBuffer[cbRead] = 0;

            cchSize += ARRAYSIZE(byteBuffer);
            *pbstrXML = SysAllocStringLen(NULL, cchSize);
            if (*pbstrXML)
            {
                if (bstrOld)
                {
                    StrCpyW(*pbstrXML, bstrOld);
                }
                else
                {
                    (*pbstrXML)[0] = 0;
                }

                bstrEnd = *pbstrXML + lstrlenW(*pbstrXML);

                SHAnsiToUnicode((LPCSTR) byteBuffer, bstrEnd, ARRAYSIZE(byteBuffer));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SysFreeString(bstrOld);
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
// File System Wrapping Helpers
/////////////////////////////////////////////////////////////////////
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle)
{
    HRESULT hr = S_OK;
    HANDLE hTemp = NULL;
    DWORD dwError = 0;

    if (!phFileHandle)
        phFileHandle = &hTemp;

    *phFileHandle = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (hTemp)
        CloseHandle(hTemp);

    return hr;
}


HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT DeleteFileHrWrap(LPCWSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!DeleteFileW(pszPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
    HRESULT hr = S_OK;
    DWORD chGot = GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);

    // What else can indicate an error value?
    if (0 == chGot)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    return hr;
}





/////////////////////////////////////////////////////////////////////
// Other Helpers
/////////////////////////////////////////////////////////////////////

HRESULT HrRewindStream(IStream * pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}



#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))



const char szDayOfWeekArray[7][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" } ;
const char szMonthOfYearArray[12][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" } ;

void GetDateString(char * szSentDateString, ULONG stringLen)
{
    // Sent Date
    SYSTEMTIME stSentTime;
    CHAR szMonth[10], szWeekDay[12] ; 

    GetSystemTime(&stSentTime);

    lstrcpynA(szWeekDay, szDayOfWeekArray[stSentTime.wDayOfWeek], ARRAYSIZE(szWeekDay)) ;
    lstrcpynA(szMonth, szMonthOfYearArray[stSentTime.wMonth-1], ARRAYSIZE(szMonth)) ;

    wnsprintfA(szSentDateString, stringLen, "%s, %u %s %u %2d:%02d:%02d ", (LPSTR) szWeekDay, stSentTime.wDay, 
                                (LPSTR) szMonth, stSentTime.wYear, stSentTime.wHour, 
                                stSentTime.wMinute, stSentTime.wSecond) ;
}


/*****************************************************************************\
    PARAMETERS:
        RETURN: Win32 HRESULT (Not Script Safe).
            SUCCEEDED(hr) for OK and out params filled in.
            FAILED(hr) for all errors.
\*****************************************************************************/
HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, DWORD cchSizeData)
{
    HRESULT hr = E_FAIL;
    LPCWSTR pwszIterate = bstrURL;

    pwszIterate = StrChrW(pwszIterate, L'?');   // Advance to Query part of URL.
    while (pwszIterate && pwszIterate[0])
    {
        pwszIterate++;  // Start at first value
        
        LPCWSTR pwszEndOfValue = StrChrW(pwszIterate, L'=');
        if (!pwszEndOfValue)
            break;
        
        int cchValueSize = (INT) (pwszEndOfValue - pwszIterate);
        if (0 == StrCmpNIW(pwszValue, pwszIterate, cchValueSize))
        {
            int cchSizeToCopy = cchSizeData;  // Copy rest of line by default.

            pwszIterate = StrChrW(pwszEndOfValue, L'&');
            if (pwszIterate)
            {
                cchSizeToCopy = (INT) (pwszIterate - pwszEndOfValue);
            }

            // It matches, now get the Data.
            StrCpyNW(pwszData, (pwszEndOfValue + 1), cchSizeToCopy);
            hr = S_OK;
            break;
        }
        else
        {
            pwszIterate = StrChrW(pwszEndOfValue, L'&');
        }
    }

    return hr;
}



// BUGBUG: This makes this object ways safe.  When the MailApps security design is
//    complete, this needs to be removed for the permanate security solution.
HRESULT MarkObjectSafe(IUnknown * punk)
{
    HRESULT hr = S_OK;
    IObjectSafety * pos;

    hr = punk->QueryInterface(IID_IObjectSafety, (void **)&pos);
    if (SUCCEEDED(hr))
    {
        // BUGBUG: This makes this object ways safe.  When the MailApps security design is
        //    complete, this needs to be removed for the permanate solution.
        pos->SetInterfaceSafetyOptions(IID_IDispatch, (INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA), 0);
        pos->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\test\adstress\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 2/8/2000
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include <wininet.h>

// String Helpers
HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest);
HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstrXML);
LPSTR AllocStringFromBStr(BSTR bstr);
HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString);
HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);

#ifdef UNICODE
#define SysAllocStringT(pszString)    SysAllocString(pszString)
#else
extern BSTR SysAllocStringA(LPCSTR pszString);
#define SysAllocStringT(pszString)    SysAllocStringA(pszString)
#endif

HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, DWORD cchSizeData);
HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped);


// XML Related Helpers
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc);
HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML);
HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend);
HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc);
HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName);
HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList);
HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue);
HRESULT XMLNodeList_GetChild(IXMLDOMNodeList * pNodeList, DWORD dwIndex, IXMLDOMNode ** ppXMLChildNode);
HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode);




// Wininet Helpers
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle);
HRESULT InternetCloseHandleWrap(HINTERNET hInternet);
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead);
HRESULT HttpOpenRequestWrap(IN HINTERNET hConnect, IN LPCSTR lpszVerb, IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion, 
                            IN LPCSTR lpszReferer, IN LPCSTR FAR * lpszAcceptTypes, IN DWORD dwFlags, IN DWORD_PTR dwContext,
                            LPDWORD pdwNumberOfBytesRead, HINTERNET * phConnectionHandle);
HRESULT HttpSendRequestWrap(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,  IN DWORD dwHeadersLength, IN LPVOID lpOptional, DWORD dwOptionalLength);
HRESULT CreateUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN DWORD dwExpectedFileSize, IN LPCTSTR lpszFileExtension, OUT LPTSTR lpszFileName, IN DWORD dwReserved);
HRESULT CommitUrlCacheEntryWrap(IN LPCTSTR lpszUrlName, IN LPCTSTR lpszLocalFileName, IN FILETIME ExpireTime, IN FILETIME LastModifiedTime,
                                IN DWORD CacheEntryType, IN UCHAR * lpHeaderInfo, IN DWORD dwHeaderSize, IN LPCTSTR lpszFileExtension, IN LPCTSTR lpszOriginalUrl);
HRESULT InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML);


// File System Helpers
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle);
HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
HRESULT DeleteFileHrWrap(LPCWSTR pszPath);

// Other Helpers
HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
HRESULT MarkObjectSafe(IUnknown * punk);
DWORD StopTaskWatch(IN LARGE_INTEGER * pliTaskStart, IN LARGE_INTEGER * pliTaskFreq);
void StartTaskWatch(IN LARGE_INTEGER * pliTaskStart, IN LARGE_INTEGER * pliTaskFreq);





// Other Helpers
HRESULT HrRewindStream(IStream * pstm);




typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO, * LPPROGRESSINFO;

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi);

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
void    GetDateString(char * szSentDateString, ULONG stringLen);



#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\test\adstress\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_


/*****************************************************************************
 *
 *      Magic comments:
 *
 *      BUGBUG: Something that needs to be fixed before being released.
 *
 *      _UNDOCUMENTED_: Something that is not documented in the SDK.
 *
 *      _UNOBVIOUS_: Some unusual feature that isn't obvious from the
 *      documentation.  A candidate for a "Tips and Tricks" chapter.
 *
 *      _HACKHACK_: Something that is gross but necessary.
 *
 *      _CHARSET_: Character set issues.
 *
 *      Magic ifdefs:
 *
  *****************************************************************************/


// WHH 05/10/99
//#define USE_IMONIKER_HELPER 1

#undef _WIN32_IE
#define _WIN32_IE 0x0600

/*****************************************************************************
 *
 *      Global Includes
 *
 *****************************************************************************/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0500

#ifndef WINVER
#define WINVER              0x0500
#endif // WINVER

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache
#define STRICT

#define POST_IE5_BETA
#include <w95wraps.h>

#include <windows.h>

#ifdef  RC_INVOKED              /* Define some tags to speed up rc.exe */
#define __RPCNDR_H__            /* Don't need RPC network data representation */
#define __RPC_H__               /* Don't need RPC */
#include <oleidl.h>             /* Get the DROPEFFECT stuff */
#define _OLE2_H_                /* But none of the rest */
#define _WINDEF_
#define _WINBASE_
#define _WINGDI_
#define NONLS
#define _WINCON_
#define _WINREG_
#define _WINNETWK_
#define _INC_COMMCTRL
#define _INC_SHELLAPI
#define _SHSEMIP_H_             /* _UNDOCUMENTED_: Internal header */
#else // RC_INVOKED
#include <windowsx.h>
#endif // RC_INVOKED


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#include "resource.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
//#include <wininet.h>
//#include <urlmon.h>
#include <shlobj.h>
#include <shlobjp.h>             // For IProgressDialog
#include <exdisp.h>
#include <objidl.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include <shellapi.h>
#include <shlapip.h>

#include "..\..\client\crtfree.h"

#include <ole2ver.h>
#include <olectl.h>
#include <isguids.h>
#include <hlguids.h>
#include <dispex.h>     // IDispatchEx
#include <perhist.h>


#include <help.h>
//#include <krnlcmn.h>    // GetProcessDword

#include <multimon.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
//#include <debug.h>

#include <urlhist.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
//#include <ccstock.h>
//#include <port32.h>

#include <commctrl.h>


// Trace flags
#define TF_WMAUTODISCOVERY  0x00000100      // AutoDiscovery
#define TF_WMTRANSPORT      0x00000200      // Transport Layer
#define TF_WMOTHER          0x00000400      // Other
#define TF_WMSMTP_CALLBACK  0x00000800      // SMTP Callback



/*****************************************************************************
 *
 *      Global Helper Macros/Typedefs
 *
 *****************************************************************************/


// shorthand
#ifndef ATOMICRELEASE
#define ATOMICRELEASET(p,type) { type* punkT=p; p=NULL; punkT->Release(); }

// doing this as a function instead of inline seems to be a size win.
//
#endif // ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif // SAFERELEASE
#define SAFERELEASE(p) ATOMICRELEASE(p)


#define IsInRange               InRange

// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
//

#ifdef  UNICODE
   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;
#endif /* UNICODE */



extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst


// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))


/*****************************************************************************
 *
 *      Baggage - Stuff I carry everywhere
 *
 *****************************************************************************/

// Convert an array name (A) to a generic count (c).
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


#ifdef DEBUG
#define DEBUG_CODE(x)            x
#else // DEBUG
#define DEBUG_CODE(x)
#endif // DEBUG




/*****************************************************************************\
      Wrappers and other quickies
\*****************************************************************************/

#define HRESULT_FROM_SUCCESS_VALUE(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))


 /*****************************************************************************\
      Static globals:
\*****************************************************************************/

extern HINSTANCE                g_hinst;              /* My instance handle */



#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)


// Just Works, AutoDiscovery
#define SZ_REGKEY_GLOBALSERVICES    L"Software\\Microsoft\\Windows\\CurrentVersion\\JustWorks\\AutoDiscovery\\GlobalServices"

#define SZ_QUERYDATA_TRUE           L"True"
#define SZ_QUERYDATA_FALSE          L"False"



// AutoDiscovery
#define SZ_SERVERPORT_DEFAULT       L"Default"
#define SZ_QUERYDATA_TRUE           L"True"
#define SZ_QUERYDATA_FALSE          L"False"
#define SZ_HTTP_VERB_POST           "POST"

// Parsing Characters
#define CH_ADDRESS_SEPARATOR       L';'
#define CH_ADDRESS_QUOTES          L'"'
#define CH_EMAIL_START             L'<'
#define CH_EMAIL_END               L'>'
#define CH_EMAIL_AT                L'@'
#define CH_EMAIL_DOMAIN_SEPARATOR  L'.'
#define CH_HTML_ESCAPE             L'%'





/*****************************************************************************\
      Local Includes
\*****************************************************************************/

#include "util.h"



#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\test\adstress\main.cpp ===
/*****************************************************************************\
    FILE: main.cpp

    DESCRIPTION:
        This program is used to test the AutoDiscovery APIs and to test how
    well the server scales.

    BryanSt 2/2/2000: Created
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

//#define _WIN32_IE 0x500

#include "priv.h"

#include <shlwapi.h>
#include <stdio.h>
#include <winioctl.h>
#include <autodiscovery.h>
#include <wininet.h>

#define SZ_EXE_HEADER       "Microsoft (R) Account AutoDiscovery Stress Tool Version 0.0.0001 (NT)\n" \
                            "Copyright (C) Microsoft Corp 2000-2000. All rights reserved.\n\n"

#define SZ_HELP_MESSAGE     " USAGE: ADStress.exe <params>\n" \
                            " PARAMS:\n" \
                            " [-? | -h | -help]: Display this help\n" \
                            " [-mail | -VPN]: Lookup email or VPN settings.  -mail is default.\n" \
                            " [-t | -threads <n>]: Create <n> threads to carry out the requests.\n" \
                            " [-S | Stress <n>]: Stress the Service Server.  Call <n> times, default is 1.  Use <domain>.\n" \
                            " [-ST | StressTime <n>]: Stress the Service Server.  Continue stress for <n> seconds, default is 120.  Use <domain>.\n" \
                            " [-C | Count]: Don't Count Stress Successes and Failures.  A little faster when off.\n" \
                            " <email> | <domain>: The email or domain name to lookup.\n" \
                            "               Email is required if -mail is used.\n" \
                            "             Example email: JoeUser@yahoo.com,   Example domain: yahoo.com\n" \
                            " -VPN: Lookup VPN settings.  This requires <email> or <domain> to be specified.\n"

#define SZ_ERR_NOEMAIL      "\nERROR: No <email> or <domain> parameter was specified\n" \

// Other params: -st/StressTime <nSeconds>, -v/Verbose





class CAutoDiscoveryTestApp
{
public:
    HRESULT ParseCmdLine(int argc, LPTSTR argv[]);
    HRESULT Run(void);

    CAutoDiscoveryTestApp();
    virtual ~CAutoDiscoveryTestApp(void);

private:
    HRESULT GetAPIInfo(void);
    HRESULT StressAPI(void);
    HRESULT DiscoverMail(bool fDisplayInfo);
    HRESULT DiscoverVPN(bool fDisplayInfo);
    HRESULT _VerifyBStrIsXML(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc);
    HRESULT StressAPIThreadN(void);

    static DWORD _StressAPIThreadNThreadProc(LPVOID lpThis);

    // Private Member Variables
    IMailAutoDiscovery *    m_pAutoDiscovery;
    BOOL                    m_fDisplayHelp;
    BOOL                    m_fMail;
    BOOL                    m_fStress;
    BOOL                    m_fCount;
    BOOL                    m_fForTime;
    ULONG                   m_nThreads;
    LONG                    m_nThreadsRunning;
    LONG                    m_nHits;
    LONG                    m_nHitsRemaining;
    LONG                    m_nSuccesses;
    LPCTSTR                 m_pszEDomain;
};


CAutoDiscoveryTestApp::CAutoDiscoveryTestApp()
{
    m_fDisplayHelp = TRUE;
    m_fMail = TRUE;
    m_fStress = FALSE;
    m_fCount = TRUE;
    m_fForTime = FALSE;
    m_nThreads = 1;
    m_nHits = 1;
    m_nHitsRemaining = 0;
    m_nSuccesses = 0;
    m_pszEDomain = NULL;
}



CAutoDiscoveryTestApp::~CAutoDiscoveryTestApp()
{
}


BOOL IsFlagSpecified(IN LPCTSTR pwzFlag, IN LPCTSTR pszArg)
{
    BOOL fIsFlagSpecified = FALSE;

    if ((TEXT('/') == pszArg[0]) ||
        (TEXT('-') == pszArg[0]))
    {
        if (0 == lstrcmpi(pwzFlag, &pszArg[1]))
        {
            fIsFlagSpecified = TRUE;
        }
    }

    return fIsFlagSpecified;
}


#define SZ_NULL_TO_UNKNOWN(str)             ((str) ? (str) : L"<Unknown>")
#define SZ_FROM_VARIANT_BOOL(varBoolean)    (((varBoolean) == VARIANT_TRUE) ? L"On" : L"Off")


HRESULT CAutoDiscoveryTestApp::DiscoverMail(bool fDisplayInfo)
{
    BSTR bstrEDomain;
    HRESULT hr = HrSysAllocStringA(m_pszEDomain, &bstrEDomain);

    if (SUCCEEDED(hr))
    {
        hr = m_pAutoDiscovery->DiscoverMail(bstrEDomain);
        if (SUCCEEDED(hr))
        {
            BSTR bstrDisplayName = NULL;
            BSTR bstrPreferedProtocol;
            BSTR bstrServer1Name = NULL;
            BSTR bstrPortNum1 = NULL;
            BSTR bstrLogin1 = NULL;
            BSTR bstrServer2Name = NULL;
            BSTR bstrPortNum2 = NULL;
            BSTR bstrLogin2 = NULL;
            VARIANT_BOOL fUseSSL1 = VARIANT_FALSE;
            VARIANT_BOOL fUseSSL2 = VARIANT_FALSE;
            VARIANT_BOOL fUseSPA1 = VARIANT_FALSE;
            VARIANT_BOOL fUseSPA2 = VARIANT_FALSE;
            VARIANT_BOOL fIsAuthRequired = VARIANT_FALSE;
            VARIANT_BOOL fUsePOP3Auth = VARIANT_FALSE;

            m_nSuccesses++;

            // We ignore hr because getting the display name is optinal.
            m_pAutoDiscovery->get_DisplayName(&bstrDisplayName);

            hr = m_pAutoDiscovery->get_PreferedProtocolType(&bstrPreferedProtocol);
            if (SUCCEEDED(hr))
            {
                VARIANT varIndex;
                IMailProtocolADEntry * pMailProtocol;

                varIndex.vt = VT_BSTR;
                varIndex.bstrVal = bstrPreferedProtocol;

                hr = m_pAutoDiscovery->get_item(varIndex, &pMailProtocol);
                if (SUCCEEDED(hr))
                {
                    hr = pMailProtocol->get_ServerName(&bstrServer1Name);
                    if (SUCCEEDED(hr))
                    {
                        // Having a custom port number is optional.
                        pMailProtocol->get_ServerPort(&bstrPortNum1);

                        pMailProtocol->get_UseSPA(&fUseSPA1);
                        pMailProtocol->get_UseSSL(&fUseSSL1);
                        pMailProtocol->get_LoginName(&bstrLogin1);
                    }

                    pMailProtocol->Release();
                }

                // TODO: Add get_PostHTML

                // Is this one of the protocols that requires a second server?
                if (!StrCmpIW(bstrPreferedProtocol, STR_PT_POP) ||
                    !StrCmpIW(bstrPreferedProtocol, STR_PT_IMAP))
                {
                    varIndex.bstrVal = STR_PT_SMTP;

                    hr = m_pAutoDiscovery->get_item(varIndex, &pMailProtocol);
                    if (SUCCEEDED(hr))
                    {
                        hr = pMailProtocol->get_ServerName(&bstrServer2Name);
                        if (SUCCEEDED(hr))
                        {
                            // Having a custom port number is optional.
                            pMailProtocol->get_ServerPort(&bstrPortNum2);

                            pMailProtocol->get_UseSSL(&fUseSSL2);
                            pMailProtocol->get_UseSPA(&fUseSPA2);
                            pMailProtocol->get_IsAuthRequired(&fIsAuthRequired);
                            pMailProtocol->get_SMTPUsesPOP3Auth(&fUsePOP3Auth);
                            pMailProtocol->get_LoginName(&bstrLogin2);
                        }

                        pMailProtocol->Release();
                    }
                }
            }

            if (true == fDisplayInfo)
            {
                printf("Email AutoDiscovery Settings for: %ls\n", bstrEDomain);
                printf("   Display Name: %ls       Prefered Protocol:%ls\n", SZ_NULL_TO_UNKNOWN(bstrDisplayName), SZ_NULL_TO_UNKNOWN(bstrPreferedProtocol));
                printf("   %ls: Server:%ls    Port:%ls\n", SZ_NULL_TO_UNKNOWN(bstrPreferedProtocol), SZ_NULL_TO_UNKNOWN(bstrServer1Name), SZ_NULL_TO_UNKNOWN(bstrPortNum1));
                printf("         Login:%ls     SPA:%ls     SSL:%ls\n", SZ_NULL_TO_UNKNOWN(bstrLogin1), SZ_FROM_VARIANT_BOOL(fUseSPA1), SZ_FROM_VARIANT_BOOL(fUseSSL1));

                if (!StrCmpIW(bstrPreferedProtocol, STR_PT_POP) ||
                    !StrCmpIW(bstrPreferedProtocol, STR_PT_IMAP))
                {
                    printf("   SMTP: Server:%ls    Port:%ls\n", SZ_NULL_TO_UNKNOWN(bstrServer2Name), SZ_NULL_TO_UNKNOWN(bstrPortNum2));
                    printf("         Login:%ls     SPA:%ls     SSL:%ls\n", SZ_NULL_TO_UNKNOWN(bstrLogin2), SZ_FROM_VARIANT_BOOL(fUseSPA2), SZ_FROM_VARIANT_BOOL(fUseSSL2));
                    printf("         AuthRequired:%ls  Use POP3 Auth:%ls\n", SZ_FROM_VARIANT_BOOL(fIsAuthRequired), SZ_FROM_VARIANT_BOOL(fUsePOP3Auth));
                }
            }

            SysFreeString(bstrDisplayName);
            SysFreeString(bstrPreferedProtocol);
            SysFreeString(bstrServer1Name);
            SysFreeString(bstrPortNum1);
            SysFreeString(bstrLogin1);
            SysFreeString(bstrServer2Name);
            SysFreeString(bstrPortNum2);
            SysFreeString(bstrLogin2);
        }
        else
        {
            if (true == fDisplayInfo)
            {
                printf("Email AutoDiscovery for %ls failed.  hr=%#08lx.\n", m_pszEDomain, hr);
            }
        }

        SysFreeString(bstrEDomain);
    }

    return hr;
}


HRESULT CAutoDiscoveryTestApp::DiscoverVPN(bool fDisplayInfo)
{
    HRESULT hr = S_OK;

    if (true == fDisplayInfo)
    {
        printf("VPN AutoDiscovery not yet implemented.\n");
    }

    return hr;
}


HRESULT CAutoDiscoveryTestApp::GetAPIInfo(void)
{
    HRESULT hr = S_OK;
    HRESULT hrOle = CoInitialize(NULL);

    // We need to make sure that the API is installed and
    // accessible before we can continue.
    if (SUCCEEDED(hrOle))
    {
        hr = CoCreateInstance(CLSID_MailAutoDiscovery, NULL, CLSCTX_INPROC_SERVER, IID_IMailAutoDiscovery, (void **) &m_pAutoDiscovery);
        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; nIndex < m_nHits; nIndex++)
            {
                if (m_fMail)
                {
                    hr = DiscoverMail((0 == nIndex) ? true : false);
                }
                else
                {
                    hr = DiscoverVPN((0 == nIndex) ? true : false);
                }
            }

            if (m_nHits > 1)
            {
                printf("\nTotal: %ld,  Failures: %ld\n", m_nHits, (m_nHits - m_nSuccesses));
            }

            m_pAutoDiscovery->Release();
            m_pAutoDiscovery = NULL;
        }
    }

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
// XML Related Helpers
/////////////////////////////////////////////////////////////////////
HRESULT CAutoDiscoveryTestApp::_VerifyBStrIsXML(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = S_OK;

    if (!*ppXMLDoc)
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void **)ppXMLDoc);
    }

    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL fIsSuccessful;

        // NOTE: This will throw an 0xE0000001 exception in MSXML if the XML is invalid.
        //    This is not good but there isn't much we can do about it.  The problem is
        //    that web proxies give back HTML which fails to parse.
        hr = (*ppXMLDoc)->loadXML(bstrXML, &fIsSuccessful);
        if (SUCCEEDED(hr))
        {
            if (VARIANT_TRUE != fIsSuccessful)
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CAutoDiscoveryTestApp::StressAPI(void)
{
    HRESULT hr = S_OK;
    LARGE_INTEGER g_liTaskStart;
    LARGE_INTEGER g_liTaskFreq = {0};

    StartTaskWatch(&g_liTaskStart, &g_liTaskFreq);
    printf("\n\nRunning Stress test.  Tests: %ld, Threads: %ld\n", m_nHits, m_nThreads);

    m_nThreadsRunning = 0;
    m_nHitsRemaining = m_nHits;
    for (UINT nIndex = 0; nIndex < m_nThreads; nIndex++)
    {
        HANDLE hHandle = CreateThread(NULL, 0, _StressAPIThreadNThreadProc, this, NORMAL_PRIORITY_CLASS, NULL);

        if (hHandle)
        {
            InterlockedIncrement(&m_nThreadsRunning);
            CloseHandle(hHandle);
        }
    }

    while (m_nThreadsRunning > 0)
    {
        Sleep(1000);   // Sleep and give the threads a chance to do more work.
    }

    DWORD dwMilliSeconds = StopTaskWatch(&g_liTaskStart, &g_liTaskFreq);
    double dMilliSeconds = (double) dwMilliSeconds;
    double dSeconds = (dMilliSeconds / 1000.0);
    double dRate = (m_nHits / dSeconds);       // How many requests per second?
    if (m_fCount)
    {
        printf("Completed. Total: %ld. Fails: %ld. Time: %f seconds (%ld ms). Rate: %f reqs/second.\n", m_nHits, (m_nHits - m_nSuccesses), dSeconds, dwMilliSeconds, dRate);
    }
    else
    {
        printf("Completed. Total: %ld. Time: %f seconds (%ld ms) Rate: %f reqs/second.\n", m_nHits, (dwMilliSeconds / 1000), dSeconds, dRate);
    }
    Sleep((1 + (m_nThreads / 10)) * 1000);   // Sleep so the threads can clean up and finish.

    return hr;
}


DWORD CAutoDiscoveryTestApp::_StressAPIThreadNThreadProc(LPVOID lpThis)
{
    CAutoDiscoveryTestApp * pAutoDiscTest = (CAutoDiscoveryTestApp *) lpThis;
    HRESULT hrOle = OleInitialize(0);
    
    if (pAutoDiscTest)
    {
        pAutoDiscTest->StressAPIThreadN();
    }

    if (SUCCEEDED(hrOle))
    {
        OleUninitialize();
    }

    return 0;
}


// Just Works, AutoDiscovery
#define SZ_WININET_AGENT_AUTO_DISCOVER      TEXT("Mozilla/4.0 (compatible; MSIE.5.01; Windows.NT.5.0)")

HRESULT CAutoDiscoveryTestApp::StressAPIThreadN(void)
{
    HRESULT hr = E_FAIL;
    HINTERNET hInternetOpen = InternetOpen(SZ_WININET_AGENT_AUTO_DISCOVER, PRE_CONFIG_INTERNET_ACCESS, NULL, NULL, 0);
    IXMLDOMDocument * pXMLDoc = NULL;

    if (hInternetOpen)
    {
        HKEY hKey;
        DWORD dwError = RegOpenKeyExW(HKEY_LOCAL_MACHINE, SZ_REGKEY_GLOBALSERVICES, 0, KEY_READ, &hKey);

        hr = HRESULT_FROM_WIN32(dwError);
        if (SUCCEEDED(hr))
        {
            int nIndex = 0;

            do
            {
                WCHAR szValue[MAX_PATH];
                DWORD cchValueSize = ARRAYSIZE(szValue);
                DWORD dwType = REG_SZ;
                WCHAR szServiceURL[MAX_PATH];
                DWORD cbDataSize = sizeof(szServiceURL);

                dwError = RegEnumValueW(hKey, nIndex, szValue, &cchValueSize, NULL, &dwType, (unsigned char *)szServiceURL, &cbDataSize);
                hr = HRESULT_FROM_WIN32(dwError);
                if (SUCCEEDED(hr))
                {
                    HINTERNET hOpenUrlSession;
                    TCHAR szURL[MAX_URL_STRING];

                    wnsprintf(szURL, ARRAYSIZE(szURL), TEXT("%lsDomain=%s"), szServiceURL, m_pszEDomain);

                    while (0 <= InterlockedDecrement(&m_nHitsRemaining))
                    {
                        // We use INTERNET_FLAG_RELOAD in order to by pass the cache and stress the server.
                        hOpenUrlSession = InternetOpenUrl(hInternetOpen, szURL, NULL, 0, (INTERNET_FLAG_RELOAD | INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS), NULL);
                        if (hOpenUrlSession)
                        {
                            if (m_fCount)
                            {
                                BSTR bstrXML;

                                hr = InternetReadIntoBSTR(hOpenUrlSession, &bstrXML);
                                if (SUCCEEDED(hr))
                                {
                                    if (SUCCEEDED(_VerifyBStrIsXML(bstrXML, &pXMLDoc)))
                                    {
                                        InterlockedIncrement(&m_nSuccesses);
                                    }

                                    SysFreeString(bstrXML);
                                }
                            }
                            InternetCloseHandle(hOpenUrlSession);
                        }

//                        Sleep(3);
                    }
                }
                else
                {
                    break;
                }

                nIndex++;
            }
            while (1);

            CloseHandle(hKey);
        }

        InternetCloseHandle(hInternetOpen);
    }

    if (pXMLDoc)
    {
        pXMLDoc->Release();
    }

    InterlockedDecrement(&m_nThreadsRunning);
    return hr;
}


HRESULT CAutoDiscoveryTestApp::ParseCmdLine(int argc, LPTSTR argv[])
{
    for (int nIndex = 1; (nIndex < argc) && (argc > 1); nIndex++)
    {
        if (IsFlagSpecified(TEXT("?"), argv[nIndex]) || 
            IsFlagSpecified(TEXT("h"), argv[nIndex]) ||
            IsFlagSpecified(TEXT("help"), argv[nIndex]))
        {
            m_fDisplayHelp = TRUE;
            break;
        }

        if (IsFlagSpecified(TEXT("c"), argv[nIndex]) || 
            IsFlagSpecified(TEXT("count"), argv[nIndex]))
        {
            m_fCount = FALSE;
            continue;
        }

        if (IsFlagSpecified(TEXT("st"), argv[nIndex]) || 
            IsFlagSpecified(TEXT("StressTime"), argv[nIndex]))
        {
            m_fForTime = TRUE;
            if ((TEXT('/') == argv[nIndex + 1][0]) ||
                (TEXT('-') == argv[nIndex + 1][0]))
            {
            }
            else
            {
                m_nHits = StrToInt(argv[nIndex + 1]);
                nIndex++;
            }
            continue;
        }

        if (IsFlagSpecified(TEXT("t"), argv[nIndex]) || 
            IsFlagSpecified(TEXT("threads"), argv[nIndex]))
        {
            m_nThreads = StrToInt(argv[nIndex + 1]);
            nIndex++;
            continue;
        }

        if (IsFlagSpecified(TEXT("s"), argv[nIndex]) || 
            IsFlagSpecified(TEXT("stress"), argv[nIndex]))
        {
            m_fStress = TRUE;
            if ((TEXT('/') == argv[nIndex + 1][0]) ||
                (TEXT('-') == argv[nIndex + 1][0]))
            {
            }
            else
            {
                m_nHits = StrToInt(argv[nIndex + 1]);
                nIndex++;
            }
            continue;
        }

        if (IsFlagSpecified(TEXT("VPN"), argv[nIndex]))
        {
            m_fMail = FALSE;
            continue;
        }

        if (nIndex == (argc - 1))
        {
            if ((TEXT('/') == argv[nIndex][0]) ||
                (TEXT('-') == argv[nIndex][0]))
            {
            }
            else
            {
                m_fDisplayHelp = FALSE;
                m_pszEDomain = argv[nIndex];
            }
        }
    }

    return S_OK;
}


HRESULT CAutoDiscoveryTestApp::Run(void)
{
    printf(SZ_EXE_HEADER);
    if (m_fDisplayHelp || !m_pszEDomain)
    {
        printf(SZ_HELP_MESSAGE);
        if (!m_pszEDomain)
        {
            printf(SZ_ERR_NOEMAIL);
        }
    }
    else
    {
        if (m_fStress)
        {
            StressAPI();
        }
        else
        {
            GetAPIInfo();
        }
    }

    return S_OK;
}


//int __cdecl main(int argc, LPSTR argv[])
#ifdef UNICODE
// extern "C"
int __cdecl main(int argc, wchar_t* argv[])
#else // UNICODE
int __cdecl main(int argc, char* argv[])
#endif // UNICODE
{
    CAutoDiscoveryTestApp testApp;

    testApp.ParseCmdLine(argc, argv);
    testApp.Run();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\internal.h ===
#include "richedit.h"

//////////////////////////////////////////////////////////
#ifdef MAC
#define wszCRLF     L"\n\r"
#define szCRLF      "\n\r"
#define wchCR       L'\n'
#define wchLF       L'\r'
#define chCR        '\n'
#define chLF        '\r'
#else   // !MAC
#ifndef WIN16
#define wszCRLF     L"\r\n"
#define szCRLF      "\r\n"
#define wchCR       L'\r'
#define wchLF       L'\n'
#define chCR        '\r'
#define chLF        '\n'
#else
#define wszCRLF     "\r\n"
#define szCRLF      "\r\n"
#define wchCR       '\r'
#define wchLF       '\n'
#define chCR        '\r'
#define chLF        '\n'
#endif // !WIN16
#endif  // MAC

#ifndef MAC
BOOL IsWin95(void);
#endif  // !MAC
extern BOOL FIsWin95;

#ifndef WIN16

#undef SetWindowLong
#define SetWindowLong SetWindowLongA
#undef GetWindowLong
#define GetWindowLong GetWindowLongA
#undef SetWindowLongPtr
#define SetWindowLongPtr SetWindowLongPtrA
#undef GetWindowLongPtr
#define GetWindowLongPtr GetWindowLongPtrA
#undef SendMessage
#define SendMessage SendMessageA

#else // WIN16

#define TEXTMETRICA TEXTMETRIC
#define TEXTRANGEA TEXTRANGE
#define CHARFORMATA CHARFORMAT
#define PROPSHEETHEADERA PROPSHEETHEADER
#define PROPSHEETPAGEA PROPSHEETPAGE

#define TVN_SELCHANGEDA TVN_SELCHANGED
#define TVM_SETITEMA TVM_SETITEM
#define TVM_GETITEMA TVM_GETITEM

#define GetTextExtentPointA GetTextExtentPoint
#define SetDlgItemTextA SetDlgItemText
#define GetTextMetricsA GetTextMetrics
#define SendDlgItemMessageA SendDlgItemMessage
#define LoadBitmapA LoadBitmap
#define PropertySheetA PropertySheet
#define WinHelpA WinHelp

#endif // !WIN16

LRESULT MySendDlgItemMessageW(HWND hwnd, int id, UINT msg, WPARAM w, LPARAM l);
BOOL MySetDlgItemTextW(HWND hwnd, int id, LPCWSTR pwsz);
UINT MyGetDlgItemTextW(HWND hwnd, int id, LPWSTR pwsz, int nMax);
DWORD MyFormatMessageW(DWORD dwFlags, LPCVOID pbSource, DWORD dwMessageId,
                    DWORD dwLangId, LPWSTR lpBuffer, DWORD nSize,
                    va_list * args);
int MyLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cbBuffer);
#ifndef WIN16
BOOL MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                            LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags);
#else
BOOL WINAPI MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                          LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags);
#endif // !WIN16
BOOL MyWinHelpW(HWND hWndMain, LPCWSTR szHelp,UINT uCommand, ULONG_PTR dwData);


DWORD TruncateToWindowA(HWND hwndDlg, int id, LPSTR psz);
DWORD TruncateToWindowW(HWND hwndDlg, int id, LPWSTR pwsz);

BOOL FinePrint(PCCERT_CONTEXT pccert, HWND hwndParent);

//
//  Formatting algorithms for the common dialogs
//

BOOL FormatAlgorithm(HWND /*hwnd*/, UINT /*id*/, PCCERT_CONTEXT /*pccert*/);
BOOL FormatBinary(HWND hwnd, UINT id, LPBYTE pb, DWORD cb);
BOOL FormatCPS(HWND hwnd, UINT id, PCCERT_CONTEXT pccert);
BOOL FormatDate(HWND hwnd, UINT id, FILETIME ft);
BOOL FormatIssuer(HWND hwnd, UINT id, PCCERT_CONTEXT pccert,
                  DWORD dwFlags = CERT_SIMPLE_NAME_STR);
BOOL FormatSerialNo(HWND hwnd, UINT id, PCCERT_CONTEXT pccert);
BOOL FormatSubject(HWND hwnd, UINT id, PCCERT_CONTEXT pccert,
                   DWORD dwFlags = CERT_SIMPLE_NAME_STR);
BOOL FormatThumbprint(HWND hwnd, UINT id, PCCERT_CONTEXT pccert);
BOOL FormatValidity(HWND hwnd, UINT id, PCCERT_CONTEXT pccert);

//
//  These routines extract and pretty print fields in the certs.  The
//      routines use crt to allocate and return a buffer
//

LPWSTR PrettySubject(PCCERT_CONTEXT pccert);
LPWSTR PrettyIssuer(PCCERT_CONTEXT pccert);
LPWSTR PrettySubjectIssuer(PCCERT_CONTEXT pccert);

//

LPWSTR FindURL(PCCERT_CONTEXT pccert);
BOOL LoadStringInWindow(HWND hwnd, UINT id, HMODULE hmod, UINT id2);
BOOL LoadStringsInWindow(HWND hwnd, UINT id, HMODULE hmod, UINT *pidStrings);

//

typedef struct {
    DWORD       dw1;
    DWORD       dw2;
} HELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                   HELPMAP const * rgCtxMap);

VOID RecognizeURLs(HWND hwndRE);
#ifdef MAC
EXTERN_C BOOL FNoteDlgNotifyLink(HWND hwndDlg, ENLINK * penlink, LPSTR szURL);
#else   // !MAC
BOOL FNoteDlgNotifyLink(HWND hwndDlg, ENLINK * penlink, LPSTR szURL);
#endif  // MAC


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

const MaxCertificateParents = 5;
extern const GUID GuidCertValidate;

LPWSTR FormatValidityFailures(DWORD);

typedef struct {
#ifndef NT5BUILD
    LPSTR       szOid;
#endif  // !NT5BUILD
    DWORD       fRootStore:1;
    DWORD       fExplicitTrust:1;       // This item is explicity Trusted
    DWORD       fExplicitDistrust:1;    // This item is explicity Distructed
    DWORD       fTrust:1;               // Ancestor is explicity Trusted
    DWORD       fDistrust:1;            // Ancestor is explicity Distrusted
    DWORD       fError:1;
    DWORD       newTrust:2;             // 0 - not modified
                                        // 1 - now explicit Distrust
                                        // 2 - now inherit
                                        // 3 - now explicit trust
    DWORD       cbTrustData;
    LPBYTE      pbTrustData;
} STrustDesc;

typedef class CCertFrame * PCCertFrame;

class CCertFrame {
public:
    CCertFrame(PCCERT_CONTEXT pccert);
    ~CCertFrame(void);

    int                 m_fSelfSign:1;          // Is Cert self signed?
    int                 m_fRootStore:1;         // Cert can from a root store
    int                 m_fLeaf:1;              // Leaf Cert
    int                 m_fExpired:1;           // Cert has expired
    PCCERT_CONTEXT      m_pccert;               // Certificate in this frame
    PCCertFrame         m_pcfNext;              //
    DWORD               m_dwFlags;              // Flags from GetIssuer
    int                 m_cParents;             // Count of parents
    PCCertFrame         m_rgpcfParents[MaxCertificateParents];  // Assume there are
                                                // a limited number of parents
                                                // to list
    int                 m_cTrust;               // size of array trust
    STrustDesc *        m_rgTrust;              // Array of trust
};

HRESULT HrDoTrustWork(PCCERT_CONTEXT pccertToCheck, DWORD dwControl,
                      DWORD dwValidityMask,
                      DWORD cPurposes, LPSTR * rgszPurposes, HCRYPTPROV,
                      DWORD cRoots, HCERTSTORE * rgRoots,
                      DWORD cCAs, HCERTSTORE * rgCAs,
                      DWORD cTrust, HCERTSTORE * rgTrust,
                      PFNTRUSTHELPER pfn, DWORD lCustData,
                      PCCertFrame * ppcfRoot, DWORD * pcNodes,
                      PCCertFrame * rgpcfResult,
                      HANDLE * phReturnStateData); // optional: return WinVerifyTrust state handle here

void FreeWVTHandle(HANDLE hWVTState);

BOOL FModifyTrust(HWND hwnd, PCCERT_CONTEXT pccert, DWORD dwNewTrust,
                  LPSTR szPurpose);


//////////////////////////////////////////////////////

LPVOID PVCryptDecode(LPCSTR, DWORD, LPBYTE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\demand.cpp ===
/*
**	d e m a n d . c p p
**	
**	Purpose: implement the loader functions for defer/demand -loaded libraries
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#include <pch.hxx>

// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

#ifndef MAC
////////////////////////////////////////////////////////////////////////////
//
//  Macros

#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
        temp = (TYP_##fn) GetProcAddress(h, #fn);   \
        if (temp)                                   \
            VAR_##fn = temp;                        \
        else                                        \
            {                                       \
            AssertSz(VAR_##fn" failed to load");    \
            goto error;                             \
            }

#define RESET(fn)                                   \
        VAR_##fn = LOADER_##fn;

#define GET_PROC_ADDR(h, fn) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        if(NULL == VAR_##fn ) { \
            VAR_##fn  = LOADER_##fn; \
        }
            

#define GET_PROC_ADDR3(h, fn, varname) \
        VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
        //        Assert(VAR_##varname != NULL);

////////////////////////////////////////////////////////////////////////////
//
//  Variables

static HMODULE          s_hCrypt = 0;
static HMODULE          s_hAdvApi = 0;
static HMODULE          s_hShell32 = 0;
static HMODULE          s_hCryptUI = 0;
#if 0 // JLS
static HMODULE          s_hShLWAPI = 0;
static HMODULE          s_hURLMon = 0;
static HMODULE          s_hVersion = 0;
static HMODULE          s_hWinINET = 0;
static HMODULE          s_hComctl32 = 0;
static HMODULE          s_hPstoreC = 0;
static HMODULE          s_hMAPI = 0;
static HMODULE          s_hWSOCK = 0;
static HMODULE          s_hOLEAUT = 0;
static HMODULE          s_hKernel = 0;
#endif // 0 // JLS

#ifdef USE_CRITSEC
static CRITICAL_SECTION cs = {0};
#endif

#ifdef DEBUG
static BOOL             s_fInit = FALSE;
#endif

////////////////////////////////////////////////////////////////////////////
//
//  Management functions

void InitDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    InitializeCriticalSection(&cs);
#endif
#ifdef DEBUG
    s_fInit = TRUE;
#endif
}

void FreeDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
    if (s_hCrypt)
        FreeLibrary(s_hCrypt);
    if (s_hAdvApi)
        FreeLibrary(s_hAdvApi);
    if (s_hShell32)
        FreeLibrary(s_hShell32);
    if (s_hCryptUI)
        FreeLibrary(s_hCryptUI);
#if 0 //JLS
    if (s_hShLWAPI)
        FreeLibrary(s_hShLWAPI);
    if (s_hURLMon)
        FreeLibrary(s_hURLMon);
    if (s_hOLEAUT)
        FreeLibrary(s_hOLEAUT);
    if (s_hMAPI)
        FreeLibrary(s_hMAPI);
    if (s_hWSOCK)
        FreeLibrary(s_hWSOCK);
    if (s_hPstoreC)
        FreeLibrary(s_hPstoreC);
    if (s_hKernel)
        FreeLibrary(s_hKernel);
#endif // JLS
#ifdef DEBUG
    s_fInit = FALSE;
#endif
#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
    DeleteCriticalSection(&cs);
#endif
}

#if 0 // JLS
////////////////////////////////////////////////////////////////////////////
//
//  Loader functions

/* sample loader with critical proc addrs
** but not thread-safe
BOOL DemandLoadFoo()
{
    FARPROC fp;

    if (0 == g_hFoo)
        {
        g_hFoo = LoadLibrary("FOO.DLL");

        if (0 == g_hFoo)
            return FALSE;

        CRIT_GET_PROC_ADDR(NeededFunction1, fp);
        CRIT_GET_PROC_ADDR(NeededFunction2, fp);
        GET_PROC_ADDR(OptionalFunction);
        }
    return TRUE;

error:
    FreeLibrary(g_hFoo);
    g_hFoo = NULL;
    RESET(NeededFunction1)
    RESET(NeededFunction2)
    RESET(OptionalFunction)
    return FALSE;
}
*/
#endif // 0

BOOL DemandLoadCrypt32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCrypt) {
        s_hCrypt = LoadLibraryA("CRYPT32.DLL");
        // AssertSz((BOOL)s_hCrypt, TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else {
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertFindExtension)
            GET_PROC_ADDR(s_hCrypt, CryptFormatObject)
            GET_PROC_ADDR(s_hCrypt, CertNameToStrW)
            GET_PROC_ADDR(s_hCrypt, CertStrToNameA)
            GET_PROC_ADDR(s_hCrypt, CertRDNValueToStrW)
            GET_PROC_ADDR(s_hCrypt, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt, CryptRegisterOIDFunction)
            GET_PROC_ADDR(s_hCrypt, CryptUnregisterOIDFunction)
            GET_PROC_ADDR(s_hCrypt, CertSetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertVerifyCTLUsage)
            GET_PROC_ADDR(s_hCrypt, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CertFreeCTLContext)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCTLToStore)
            GET_PROC_ADDR(s_hCrypt, CryptMsgEncodeAndSignCTL)
            GET_PROC_ADDR(s_hCrypt, CertFindCTLInStore)
            GET_PROC_ADDR(s_hCrypt, CryptSignAndEncodeCertificate)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CryptExportPublicKeyInfo)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateStore)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCertificateToStore);
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity);
            GET_PROC_ADDR(s_hCrypt, CertFindSubjectInCTL);
            GET_PROC_ADDR(s_hCrypt, CertVerifySubjectCertificateContext);
            GET_PROC_ADDR(s_hCrypt, CertGetEnhancedKeyUsage);
            GET_PROC_ADDR(s_hCrypt, CryptInstallDefaultContext);
            GET_PROC_ADDR(s_hCrypt, CryptUninstallDefaultContext);
            GET_PROC_ADDR(s_hCrypt, CertDeleteCertificateFromStore);
            GET_PROC_ADDR(s_hCrypt, CertGetSubjectCertificateFromStore);

            GET_PROC_ADDR(s_hCrypt, CertGetCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertAddStoreToCollection);
            GET_PROC_ADDR(s_hCrypt, CertAddCertificateContextToStore);
            GET_PROC_ADDR(s_hCrypt, CertControlStore);

        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


BOOL DemandLoadCryptUI()
{
    static BOOL         fRet = FALSE;
    static BOOL         fAttempt = FALSE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCryptUI && ! fAttempt) {
        s_hCryptUI = LoadLibraryA("CRYPTUI.DLL");
        // AssertSz((BOOL)s_hCryptUI, TEXT("LoadLibrary failed on CRYPTUI.DLL"));

        fAttempt = TRUE;

        if (s_hCryptUI) {
            fRet = TRUE;
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgViewCertificateW)
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgViewCertificateA)

            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgViewCertificatePropertiesW)
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgViewCertificatePropertiesA)

            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgSelectCertificateW)
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgSelectCertificateA)
#ifdef OLD_STUFF
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgCertMgr)
#endif // OLD_STUFF
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


BOOL CryptUIAvailable(void) {
    return(DemandLoadCryptUI());
}


BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hAdvApi) {
        s_hAdvApi = LoadLibraryA("ADVAPI32.DLL");
        //  AssertSz((BOOL)s_hAdvApi, TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else {
            if (FIsWin95) {
                VAR_CryptAcquireContextW = MyCryptAcquireContextW;
            }
            else {
                GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW);
            }
#if 0
            GET_PROC_ADDR(s_hAdvApi, CryptGetProvParam)
            GET_PROC_ADDR(s_hAdvApi, CryptReleaseContext)
            GET_PROC_ADDR(s_hAdvApi, CryptGenKey)
            GET_PROC_ADDR(s_hAdvApi, CryptDestroyKey)
#endif // 0
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

#ifndef WIN16

BOOL DemandLoadUser32()
{
    BOOL                fRet = TRUE;

    //    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
#undef SendDlgitemMessageW
#undef SetDlgItemTextW
#undef GetDlgItemTextW
#undef LoadStringW
#undef FormatMessageW

    if (0 == s_hShell32) {
        if (FIsWin95) {
            VAR_SendDlgItemMessageW = MySendDlgItemMessageW;
            VAR_SetDlgItemTextW = MySetDlgItemTextW;
            VAR_GetDlgItemTextW = MyGetDlgItemTextW;
            VAR_LoadStringW = MyLoadStringW;
            VAR_FormatMessageW = MyFormatMessageW;
            VAR_WinHelpW = MyWinHelpW;
        }
        else {
            s_hShell32 = LoadLibraryA("kernel32.dll");
            GET_PROC_ADDR(s_hShell32, FormatMessageW);
            FreeLibrary(s_hShell32);

            s_hShell32 = LoadLibraryA("USER32.DLL");
            GET_PROC_ADDR(s_hShell32, SendDlgItemMessageW);
            GET_PROC_ADDR(s_hShell32, SetDlgItemTextW);
            GET_PROC_ADDR(s_hShell32, GetDlgItemTextW);
            GET_PROC_ADDR(s_hShell32, LoadStringW);
            GET_PROC_ADDR(s_hShell32, WinHelpW);
        }
    }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


#endif // !WIN16

#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\trust.cpp ===
#include        "pch.hxx"

BOOL CertConfigureTrustA(void)
{
    return FALSE;
}

BOOL CertConfigureTrustW(void)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\fineprnt.cpp ===
//
//  File:       select.cpp
//
//  Description: This file contains the implmentation code for the
//      "Certificate Select" dialog.
//

#pragma warning (disable: 4201)         // nameless struct/union
#pragma warning (disable: 4514)         // remove inline functions
#pragma warning (disable: 4127)         // conditional expression is constant

#include "pch.hxx"
#include "demand.h"

extern HINSTANCE       HinstDll;
#ifndef MAC
extern HMODULE         HmodRichEdit;
#endif  // !MAC

INT_PTR CALLBACK FinePrintDlgProc(HWND hwndDlg, UINT msg,
                               WPARAM wParam, LPARAM lParam)
{
#if 0
    int                 c;
    CERT_VIEWPROPERTIES_STRUCT_W        cvps;
    DWORD               dw;
    int                 i;
    DWORD               iStore;
    LPWSTR              pwsz;
    PCERT_SELECT_STRUCT pcss;
#endif // 0
    BOOL                f;
    PCCERT_CONTEXT      pccert;
    
    switch (msg) {
    case WM_INITDIALOG:
        //  Center the dialog on its parent
        //        CenterThisDialog(hwndDlg);

        //
        pccert = (PCCERT_CONTEXT) lParam;

        FormatSubject(hwndDlg, IDC_ISSUED_TO, pccert);
        FormatIssuer(hwndDlg, IDC_ISSUED_BY, pccert);
        
        //
        //  Setup the CPS if we can find one
        //

        if (FormatCPS(hwndDlg, IDC_TEXT, pccert)) {
            RecognizeURLs(GetDlgItem(hwndDlg, IDC_TEXT));
            SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETEVENTMASK, 0,
                               ENM_LINK);
        }

        //  Grey out the rich edit boxs
        SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETBKGNDCOLOR, 0,
                           GetSysColor(COLOR_3DFACE));
        SendDlgItemMessage(hwndDlg, IDC_ISSUED_TO, EM_SETBKGNDCOLOR, 0,
                           GetSysColor(COLOR_3DFACE));
        SendDlgItemMessage(hwndDlg, IDC_ISSUED_BY, EM_SETBKGNDCOLOR, 0,
                           GetSysColor(COLOR_3DFACE));
        break;

    case WM_NOTIFY:
        if (((NMHDR FAR *) lParam)->code == EN_LINK) {
            if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN) {
                f = FNoteDlgNotifyLink(hwndDlg, (ENLINK *) lParam, NULL);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, f);
                return f;
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            EndDialog(hwndDlg, IDOK);
            return TRUE;
        }
        break;

        //
        //  Use the default handler -- we don't do anything for it
        //
        
    default:
        return FALSE;
    }

    return TRUE;
}                               // FinePrint()


BOOL FinePrint(PCCERT_CONTEXT pccert, HWND hwndParent)
{
    int         ret;

    //  We use the common controls -- so make sure they have been loaded

#ifndef WIN16
#ifndef MAC
    if (FIsWin95) {
        if (HmodRichEdit == NULL) {
            HmodRichEdit = LoadLibraryA("RichEd32.dll");
            if (HmodRichEdit == NULL) {
                return FALSE;
            }
        }
    }
    else {
        if (HmodRichEdit == NULL) {
            HmodRichEdit = LoadLibrary(L"RichEd32.dll");
            if (HmodRichEdit == NULL) {
                return FALSE;
            }
        }
    }
    //  Now launch the dialog

    if (FIsWin95) {
#endif  // !MAC
        ret = (int) DialogBoxParamA(HinstDll, (LPSTR) MAKEINTRESOURCE(IDD_FINE_PRINT),
                             hwndParent, FinePrintDlgProc,
                             (LPARAM) pccert);
#ifndef MAC
    }
    else {
        ret = (int) DialogBoxParamW(HinstDll, MAKEINTRESOURCE(IDD_FINE_PRINT),
                              hwndParent, FinePrintDlgProc,
                              (LPARAM) pccert);
    }
#endif  // !MAC

#else // WIN16
    if (HmodRichEdit == NULL) {
        HmodRichEdit = LoadLibrary("RichEd.dll");
        if (HmodRichEdit == NULL) {
            return FALSE;
        }
    }
    //  Now launch the dialog

    ret = (int) DialogBoxParam(HinstDll, MAKEINTRESOURCE(IDD_FINE_PRINT),
                          hwndParent, FinePrintDlgProc,
                          (LPARAM) pccert);
#endif // !WIN16

    return (ret == IDOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptdlg.rc
//

// For dialogs, the range of numbers you should use
// are from 130 through 149.
#define IDD_CERTPROP_GENERAL            130
#define IDD_CERTPROP_DETAILS            131
#define IDD_CERTPROP_TRUST              132
#define IDD_CERTPROP_ADVANCED           133
#define IDD_SELECT_DIALOG               134
#define IDD_TRUST                       135
#define IDD_FINE_PRINT                  136
#define IDD_CRYPTUI_CERTPROP_TRUST      137

// For bitmaps, the range of numbers you should use
// are from 300 through 319.
#define IDB_TICK                        300
#define IDB_CROSS                       301
#define IDB_TREE_IMAGES                 302

// For strings, the range of numbers you should use
// are from 3184 through 3503.
#define IDS_GENERAL_TICK                3184
#define IDS_GENERAL_CROSS               3185
#define IDS_GENERAL_INFO                3186
#define IDS_GENERAL_FRIENDLY            3187
#define IDS_ADV_VERSION                 3188
#define IDS_ADV_SER_NUM                 3189
#define IDS_ADV_SIG_ALG                 3190
#define IDS_ADV_ISSUER                  3191
#define IDS_ADV_NOTBEFORE               3192
#define IDS_ADV_NOTAFTER                3193
#define IDS_ADV_SUBJECT                 3194
#define IDS_ADV_PUBKEY                  3195
#define IDS_SELECT_INFO                 3196
#define IDS_DETAIL_VALID_TICK           3197
#define IDS_DETAIL_VALID_CROSS          3198
#define IDS_DETAIL_TRUST_TICK           3199
#define IDS_DETAIL_TRUST_CROSS          3200
#define IDS_WHY_NOT_YET                 3201
#define IDS_WHY_EXPIRED                 3202
#define IDS_WHY_CERT_SIG                3203
#define IDS_WHY_NO_PARENT               3204
#define IDS_WHY_REVOKED                 3205
#define IDS_WHY_KEY_USAGE               3206
#define IDS_WHY_BASIC_CONS              3207
#define IDS_WHY_EXTEND_USE              3208
#define IDS_WHY_NAME_CONST              3209
#define IDS_WHY_NO_CRL                  3210
#define IDS_WHY_CRL_EXPIRED             3211
#define IDS_WHY_CRITICAL_EXT            3212
#define IDS_TRUST_DESC                  3213
#define IDS_GENERAL_DESC                3214
#define IDS_VIEW_TITLE                  3215
#define IDS_VALIDITY_FORMAT             3216
#define IDS_GENERAL_DESC2               3217
#define IDS_GENERAL_DESC3               3218
#define IDS_GENERAL_DESC4               3219
#define IDS_GENERAL_DESC5               3220
#define IDS_GENERAL_DESC6               3221
#define IDS_TRUST_DESC2                 3222
#define IDS_TRUST_DESC3                 3223
#define IDS_TRUST_DESC4                 3224
#define IDS_ROOT_ADD_STRING             3225
#define IDS_ROOT_ADD_TITLE              3226
#define IDS_EMAIL_DESC                  3227

// Added for WXP
#define IDS_WHY_POLICY                  3228


//  Select Certificate control ids
//      Note all of these are also defined in cryptdlg.h --- don't change them.
#define IDC_CS_PROPERTIES               100
#define IDC_CS_FINEPRINT                101
#define IDC_CS_CERTLIST                 102

#define IDC_CS_INFO                     103
#define IDC_CS_VALIDITY                 104
#define IDC_CS_ALGORITHM                105
#define IDC_CS_SERIAL_NUMBER            106
#define IDC_CS_THUMBPRINT               107

//  View Properties Dialog Pages

//  View General Page

#define IDC_CERT_STATUS                 100
#define IDC_CERT_STATUS_IMAGE           101
#define IDC_GENERAL_DESC                102

//  View Details

#define IDC_ISSUED_TO                   100
#define IDC_ISSUED_BY                   101
#define IDC_VIEW_ISSUER                 102
#define IDC_FRIENDLY_NAME               103
#define IDC_VALIDITY                    104
#define IDC_SERIAL_NUMBER               105
#define IDC_ALGORITHM                   106
#define IDC_TRUST_GROUP                 107
#define IDC_IS_TRUSTED                  108
#define IDC_IS_VALID                    109
#define IDC_WHY                         110
#define IDC_THUMBPRINT                  111
#define IDC_TRUST_IMAGE                 112

//  View Trust Page

#define IDC_TRUST_DESC                  100
#define IDC_TRUST_LIST                  101
#define IDC_TRUST_TREE                  102
#define IDC_TRUST_EDIT_GROUP            103
#define IDC_TRUST_NO                    104
#define IDC_TRUST_INHERIT               105
#define IDC_TRUST_YES                   106
#define IDC_TRUST_EDIT                  107
#define IDC_TRUST_VIEW                  108

//

#define IDC_TRUST_ICON                  1004
#define IDC_LIST1                       1014
#define IDC_LIST2                       1015
#define IDC_EDIT1                       1016
#define IDC_PROPERTIES                  1017
#define IDC_CA_CERT_ADD                 1019
#define IDC_CA_CERT_REMOVE              1020
#define IDC_CA_CERT_PROPS               1021
#define IDC_INDIV_CERT_ADD              1022
#define IDC_INDIV_CERT_REMOVE           1023
#define IDC_INDIV_CERT_PROPS            1024
#define IDC_DISTRUST                    1025
#define IDC_CA_CERT_LIST                1026
#define IDC_INDIV_CERT_LIST             1027
#define IDC_FINE_PRINT                  1028
#define IDC_TEXT                        1029
#define IDC_POLICY                      1030
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        3217
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



#define IDH_CS_CERTLIST                 (1000+IDC_CS_CERTLIST)
#define IDH_CS_PROPERTIES               (1000+IDC_CS_CERTLIST)
#define IDH_CS_ALGORITHM                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_STATUS                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_FINEPRINT                (1000+IDC_CS_CERTLIST)
#define IDH_VSG_TEXT                (1000+IDC_CS_CERTLIST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\ltrust.cpp ===
#include "pch.hxx"
#ifndef WIN16
#include <wintrust.h>
#endif // !WIN16
#include "demand.h"
#include <stdio.h>

#pragma warning(disable: 4127)          // conditional expression is constant

#ifndef CPD_REVOCATION_CHECK_NONE
#define CPD_REVOCATION_CHECK_NONE                0x00010000
#define CPD_REVOCATION_CHECK_END_CERT            0x00020000
#define CPD_REVOCATION_CHECK_CHAIN               0x00040000
#define CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT  0x00080000
#endif
#define CPD_REVOCATION_MASK     (CPD_REVOCATION_CHECK_NONE | \
                                    CPD_REVOCATION_CHECK_END_CERT | \
                                    CPD_REVOCATION_CHECK_CHAIN | \
                                    CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT)
                                    
#define TIME_DELTA_SECONDS 600          // 10 minutes in seconds
#define FILETIME_SECOND    10000000     // 100ns intervals per second

const char SzOID_CTL_ATTR_YESNO_TRUST[] = szOID_YESNO_TRUST_ATTR;
const char SzOID_KP_CTL_USAGE_SIGNING[] = szOID_KP_CTL_USAGE_SIGNING;
const BYTE RgbTrustYes[] = {2, 1, 1};
const BYTE RgbTrustNo[] = {2, 1, 2};
const BYTE RgbTrustParent[] = {2, 1, 0};
const char SzOID_OLD_CTL_YESNO_TRUST[] = "1.3.6.1.4.1.311.1000.1.1.2";
const char SzTrustListSigner[] = "Trust List Signer";
const char SzTrustDN[] = "cn=%s, cn=Trust List Signer, cn=%s";
const char SzPolicyKey[] = 
    "SOFTWARE\\Microsoft\\Cryptography\\"szCERT_CERTIFICATE_ACTION_VERIFY;
const char SzPolicyData[] = "PolicyFlags";

const DWORD CTL_MODIFY_ERR_NOT_YET_PROCESSED = (DWORD) -1;
extern HINSTANCE        HinstDll;

PCCERT_CONTEXT CreateTrustSigningCert(HWND hwnd, HCERTSTORE hcertstoreRoot, BOOL);

const int       COtherProviders = 2;
#ifndef WIN16
LPWSTR          RgszProvider[] = {
    L"CA", L"MY"
};
#else // WIN16
LPWSTR          RgszProvider[] = {
    "CA", "MY"
};
#endif // !WIN16

#ifdef NT5BUILD

typedef struct {
    DWORD               cbSize;
    DWORD               dwFlags;
    DWORD               cRootStores;
    HCERTSTORE *        rghRootStores;
    DWORD               cTrustStores;
    HCERTSTORE *        rghTrustStores;
    LPCSTR              pszUsageOid;
    HCRYPTDEFAULTCONTEXT hdefaultcontext;        // from CryptInstallDefaultContext
} INTERNAL_DATA, * PINTERNAL_DATA;

const GUID      MyGuid = CERT_CERTIFICATE_ACTION_VERIFY;

#pragma message("Building for NT5")

void FreeWVTHandle(HANDLE hWVTState) {
    if (hWVTState) {
        HRESULT hr;
        WINTRUST_DATA data = {0};

        data.cbStruct = sizeof(WINTRUST_DATA);
        data.pPolicyCallbackData = NULL;
        data.pSIPClientData = NULL;
        data.dwUIChoice = WTD_UI_NONE;
        data.fdwRevocationChecks = WTD_REVOKE_NONE;
        data.dwUnionChoice = WTD_CHOICE_BLOB;
        data.pBlob = NULL;      // &blob;
        data.dwStateAction = WTD_STATEACTION_CLOSE;
        data.hWVTStateData = hWVTState;
        hr = WinVerifyTrust(NULL, (GUID *)&GuidCertValidate, &data);
    }
}


HRESULT HrDoTrustWork(PCCERT_CONTEXT pccertToCheck, DWORD dwControl,
                      DWORD dwValidityMask,
                      DWORD /*cPurposes*/, LPSTR * rgszPurposes, HCRYPTPROV hprov,
                      DWORD cRoots, HCERTSTORE * rgRoots,
                      DWORD cCAs, HCERTSTORE * rgCAs,
                      DWORD cTrust, HCERTSTORE * rgTrust,
                      PFNTRUSTHELPER pfn, DWORD lCustData,
                      PCCertFrame *  /*ppcf*/, DWORD * pcNodes,
                      PCCertFrame * rgpcfResult,
                      HANDLE * phReturnStateData)   // optional: return WinVerifyTrust state handle here
{
    DWORD                               cbData;
    DWORD                               cCerts = 0;
    WINTRUST_BLOB_INFO                  blob = {0};
    WINTRUST_DATA                       data = {0};
    DWORD                               dwErrors;
    BOOL                                f;
    HRESULT                             hr;
    int                                 i;
    DWORD                               j;
    PCCERT_CONTEXT *                    rgCerts = NULL;
    DWORD *                             rgdwErrors = NULL;
    DATA_BLOB *                         rgblobTrust = NULL;
    CERT_VERIFY_CERTIFICATE_TRUST       trust;
    UNALIGNED CRYPT_ATTR_BLOB *pVal = NULL;

    data.cbStruct = sizeof(WINTRUST_DATA);
    data.pPolicyCallbackData = NULL;
    data.pSIPClientData = NULL;
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;
    if (phReturnStateData) {
        data.dwStateAction = WTD_STATEACTION_VERIFY;
    }

    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.pcwszDisplayName = NULL;
    blob.cbMemObject = sizeof(trust);
    blob.pbMemObject = (LPBYTE) &trust;

    trust.cbSize = sizeof(trust);
    trust.pccert = pccertToCheck;
    trust.dwFlags = (CERT_TRUST_DO_FULL_SEARCH |
                     CERT_TRUST_PERMIT_MISSING_CRLS |
                     CERT_TRUST_DO_FULL_TRUST | dwControl);
    trust.dwIgnoreErr = dwValidityMask;
    trust.pdwErrors = &dwErrors;
    //    Assert(cPurposes == 1);
    if (rgszPurposes != NULL) {
        trust.pszUsageOid = rgszPurposes[0];
    }
    else {
        trust.pszUsageOid = NULL;
    }
    trust.hprov = hprov;
    trust.cRootStores = cRoots;
    trust.rghstoreRoots = rgRoots;
    trust.cStores = cCAs;
    trust.rghstoreCAs = rgCAs;
    trust.cTrustStores = cTrust;
    trust.rghstoreTrust = rgTrust;
    trust.lCustData = lCustData;
    trust.pfnTrustHelper = pfn;
    trust.pcChain = &cCerts;
    trust.prgChain = &rgCerts;
    trust.prgdwErrors = &rgdwErrors;
    trust.prgpbTrustInfo = &rgblobTrust;

    hr = WinVerifyTrust(NULL, (GUID *) &GuidCertValidate, &data);
    if ((TRUST_E_CERT_SIGNATURE == hr) ||
        (CERT_E_REVOKED == hr) ||
        (CERT_E_REVOCATION_FAILURE == hr)) {
        hr = S_OK;
    }
    else if (FAILED(hr)) {
            return hr;
    }
    if (cCerts == 0) {
        return(E_INVALIDARG);
    }

    if (phReturnStateData) {
        *phReturnStateData = data.hWVTStateData;    // Caller must use WinVerifyTrust to free
    }

    //Assert( cCerts <= 20);
    *pcNodes = cCerts;
    for (i=cCerts-1; i >= 0; i--) {
        rgpcfResult[i] = new CCertFrame(rgCerts[i]);

        if(!rgpcfResult[i])
        {
            hr=E_OUTOFMEMORY;
            goto ExitHere;
        }

        rgpcfResult[i]->m_dwFlags = rgdwErrors[i];
        if (rgszPurposes == NULL) {
            continue;
        }
        rgpcfResult[i]->m_cTrust = 1;
        rgpcfResult[i]->m_rgTrust = new STrustDesc[1];
        memset(rgpcfResult[i]->m_rgTrust, 0, sizeof(STrustDesc));

        //
        //  We are going to fill in the trust information which we use
        //  to fill in the fields of the dialog box.
        //
        //  Start with the question of the cert being self signed
        //

        rgpcfResult[i]->m_fSelfSign = WTHelperCertIsSelfSigned(X509_ASN_ENCODING, rgCerts[i]->pCertInfo);

        //
        //  We may or may not have trust data information returned, we now
        //      build up the trust info for a single cert
        //
        //  If we don't have any explicit data, then we just chain the data
        //      down from the next level up.
        //

        if (rgblobTrust[i].cbData == 0) {
            //        chain:
            rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = FALSE;
            rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = FALSE;

            //
            //  We return a special code to say that we found it in the root store
            //

            rgpcfResult[i]->m_rgTrust[0].fRootStore = rgpcfResult[i]->m_fRootStore =
                (rgblobTrust[i].pbData == (LPBYTE) 1);

            if (i != (int) (cCerts-1)) {
                rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i+1]->m_rgTrust[0].fTrust;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= rgpcfResult[i+1]->m_rgTrust[0].fDistrust;
            } else {
                //  Oops -- there is no level up one, so just make some
                //      good defaults
                //
                rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i]->m_fRootStore;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= FALSE;
            }
        }
        else {
            //
            //

            f = CryptDecodeObject(X509_ASN_ENCODING, "1.3.6.1.4.1.311.16.1.1",
                                  rgblobTrust[i].pbData, rgblobTrust[i].cbData,
                                  0, NULL, &cbData);
            if (!f || (cbData == 0)) {
            chain:
                rgpcfResult[i]->m_fRootStore = FALSE;
                rgpcfResult[i]->m_rgTrust[0].fRootStore = rgpcfResult[i]->m_fRootStore;
                rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = FALSE;
                rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = FALSE;
                if (i != (int) (cCerts-1)) {
                    rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i+1]->m_rgTrust[0].fTrust;
                    rgpcfResult[i]->m_rgTrust[0].fDistrust = rgpcfResult[i+1]->m_rgTrust[0].fDistrust;
                }
                else {
                    rgpcfResult[i]->m_rgTrust[0].fTrust = FALSE;
                    rgpcfResult[i]->m_rgTrust[0].fDistrust= FALSE;
                }
            }
            else {
                PCRYPT_ATTRIBUTES       pattrs;

                pattrs = (PCRYPT_ATTRIBUTES) malloc(cbData);
                if (pattrs == NULL) {
                    goto chain;
                }

                CryptDecodeObject(X509_ASN_ENCODING, "1.3.6.1.4.1.311.16.1.1",
                                  rgblobTrust[i].pbData, rgblobTrust[i].cbData,
                                  0, pattrs, &cbData);

                for (j=0; j<pattrs->cAttr; j++) {
                    if ((strcmp(pattrs->rgAttr[j].pszObjId, SzOID_CTL_ATTR_YESNO_TRUST) == 0) ||
                        (strcmp(pattrs->rgAttr[j].pszObjId, SzOID_OLD_CTL_YESNO_TRUST) == 0)) 
                    {

                        pVal = &(pattrs->rgAttr[j].rgValue[0]);

                        if ((pVal->cbData == sizeof(RgbTrustYes)) &&
                            (memcmp(pVal->pbData,
                                    RgbTrustYes, sizeof(RgbTrustYes)) == 0)) {
                            rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = TRUE;
                            rgpcfResult[i]->m_rgTrust[0].fTrust = TRUE;
                            break;
                        }
                        else if ((pVal->cbData == sizeof(RgbTrustNo)) &&
                                 (memcmp(pVal->pbData,
                                    RgbTrustNo, sizeof(RgbTrustNo)) == 0)) {
                            rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = TRUE;
                            rgpcfResult[i]->m_rgTrust[0].fDistrust= TRUE;
                            break;
                        }
                        else if ((pVal->cbData == sizeof(RgbTrustParent)) &&
                                 (memcmp(pVal->pbData,
                                    RgbTrustParent, sizeof(RgbTrustParent)) == 0)) {
                            goto chain;
                        }
                        else {
                            goto chain;
                        }
                    }
                }
                if (j == pattrs->cAttr) {
                    goto chain;
                }
            }
        }
    }

    //
    //  Clean up all returned values
    //

ExitHere:
    if (rgCerts != NULL) {
        //bobn If the loop has been broken because "new" failed, free what we allocated so far...
        for ((hr==E_OUTOFMEMORY?i++:i=0); i< (int) cCerts; i++) {
            //@ REVIEW check CertFreeCertificateContext to see if it will accept a null pointer
            //if it will, we can remove the E_OUTOFMEMORY test above.
            CertFreeCertificateContext(rgCerts[i]);
            }
        LocalFree(rgCerts);
    }
    if (rgdwErrors != NULL) LocalFree(rgdwErrors);
    if (rgblobTrust != NULL) {
        for (i=0; i<(int) cCerts; i++) {
            if (rgblobTrust[i].cbData > 0) {
                LocalFree(rgblobTrust[i].pbData);
            }
        }
        LocalFree(rgblobTrust);
    }

    return hr;
}


HRESULT CertTrustInit(PCRYPT_PROVIDER_DATA pdata)
{
    DWORD                               cbSize;
    DWORD                               dwPolicy = 0;
    DWORD                               dwType;
    HKEY                                hkPolicy;
    HCERTSTORE                          hstore;
    DWORD                               i;
    PCERT_VERIFY_CERTIFICATE_TRUST      pcerttrust;
    CRYPT_PROVIDER_PRIVDATA             privdata;
    PINTERNAL_DATA                      pmydata;

    //
    //  Make sure all of the fields we want are there.  If not then it is a
    //  complete fatal error.
    //

    if (! WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pdata->cbStruct, pszUsageOID)) {
        return(E_FAIL);
    }

    if (pdata->pWintrustData->pBlob->cbStruct < sizeof(WINTRUST_BLOB_INFO)) {
        pdata->dwError = ERROR_INVALID_PARAMETER;
        return S_FALSE;
    }

    pcerttrust = (PCERT_VERIFY_CERTIFICATE_TRUST)
        pdata->pWintrustData->pBlob->pbMemObject;
    if ((pcerttrust == NULL) ||
        (pcerttrust->cbSize < sizeof(*pcerttrust))) {
        pdata->dwError = ERROR_INVALID_PARAMETER;
        return S_FALSE;
    }

    if (pdata->dwError != 0) {
        return S_FALSE;
    }

    for (i=TRUSTERROR_STEP_FINAL_WVTINIT; i<TRUSTERROR_STEP_FINAL_CERTCHKPROV; i++) {
        if (pdata->padwTrustStepErrors[i] != 0) {
            return S_FALSE;
        }
    }

    //
    //  Allocate the space to hold the internal data we use to talk to ourselfs with
    //

    cbSize = sizeof(INTERNAL_DATA) + (pcerttrust->cRootStores + 1 +
                                      pcerttrust->cTrustStores + 1)  * sizeof(HCERTSTORE);
    pmydata = (PINTERNAL_DATA)pdata->psPfns->pfnAlloc(cbSize);
    if (! pmydata) {
        return(E_OUTOFMEMORY);
    }
    memset(pmydata, 0, sizeof(*pmydata));
    pmydata->cbSize = sizeof(*pmydata);
    pmydata->rghRootStores = (HCERTSTORE *) (((LPBYTE) pmydata) + sizeof(*pmydata));
    pmydata->rghTrustStores = &pmydata->rghRootStores[pcerttrust->cRootStores+1];

    privdata.cbStruct = sizeof(privdata);
    memcpy(&privdata.gProviderID, &MyGuid, sizeof(GUID));
    privdata.cbProvData = cbSize;
    privdata.pvProvData = pmydata;

    pdata->psPfns->pfnAddPrivData2Chain(pdata, &privdata);

    pmydata->pszUsageOid = pcerttrust->pszUsageOid;
    pmydata->dwFlags = pcerttrust->dwFlags;

    //
    //  Set the restriction OID back into the full provider information to
    //  make sure chaining is correct
    //

    pdata->pszUsageOID = pcerttrust->pszUsageOid;

    //
    //  Retrieve the default revocation check from the policy flags in the
    //  registry.
    //

    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, SzPolicyKey, 0, KEY_READ,
                      &hkPolicy) == ERROR_SUCCESS) {
        cbSize = sizeof(dwPolicy);
        if ((ERROR_SUCCESS != RegQueryValueExA(hkPolicy,
                                               SzPolicyData, 
                                               0, &dwType,
                                               (LPBYTE)&dwPolicy,
                                               &cbSize)) ||
            (REG_DWORD != dwType)) {
            dwPolicy = 0;
        }                        
        RegCloseKey(hkPolicy);
    }

    //
    //  Set the default revocation check level
    //

    if (dwPolicy & ACTION_REVOCATION_DEFAULT_ONLINE) {
        // Allow full online revocation checking

        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_CHAIN;
    }
    else if (dwPolicy & ACTION_REVOCATION_DEFAULT_CACHE) {
        // Allow local revocation checks only, do not hit the network

        // NOTE: Currently not supported by NT Crypto, default to none

        //Assert(!dwPolicy & ACTION_REVOCATION_DEFAULT_CACHE)
        
        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_NONE;
    }
    else {
        // For backwards compatibility default to no revocation

        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_NONE;
    }

    // 
    //  Update the revocation state based on what the user has specifically
    //  requested.
    //

    if (pcerttrust->dwFlags & CRYPTDLG_REVOCATION_ONLINE) {
        // Allow full online revocation checking

        pdata->dwProvFlags &= ~CPD_REVOCATION_MASK;
        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_CHAIN;
    }
    else if (pcerttrust->dwFlags & CRYPTDLG_REVOCATION_CACHE) {
        // Allow local revocation checks only, do not hit the network.

        // NOTE: Currently not supported by NT, for now we just ignore
        //  the revocakation
        
        // Assert(!pcerttrust->dwFlags & CRYPTDLG_REVOCATION_CACHE);
        pdata->dwProvFlags &= ~CPD_REVOCATION_MASK;
        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_NONE;
    }
    else if (pcerttrust->dwFlags & CRYPTDLG_REVOCATION_NONE) {
        // Allow full online revocation checking

        pdata->dwProvFlags &= ~CPD_REVOCATION_MASK;
        pdata->dwProvFlags |= CPD_REVOCATION_CHECK_NONE;
    }
    
    //
    //  Set the default crypt provider so we can make sure that ours is used
    //

    if (pcerttrust->hprov != NULL) {
        if (!CryptInstallDefaultContext(pcerttrust->hprov, 
                                        CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                                        szOID_OIWSEC_md5RSA, 0, NULL,
                                        &pmydata->hdefaultcontext)) {
            return S_FALSE;
        }
                                       
    }

    //
    //  Setup the stores to be used by the search step.
    //
    //  Root ("God") stores
    //

    if (pcerttrust->cRootStores != 0) {
        for (i=0; i<pcerttrust->cRootStores; i++) {
            if (!pdata->psPfns->pfnAddStore2Chain(pdata,
                                                  pcerttrust->rghstoreRoots[i])) {
                pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
                return S_FALSE;
            }
            pmydata->rghRootStores[i] = CertDuplicateStore(pcerttrust->rghstoreRoots[i]);
        }
        pmydata->cRootStores = i;
    }
    else {
        hstore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                               pcerttrust->hprov, CERT_SYSTEM_STORE_CURRENT_USER |
                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                               L"Root");
        if (hstore == NULL) {
            pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ::GetLastError();
            return S_FALSE;
        }
        if (!pdata->psPfns->pfnAddStore2Chain(pdata, hstore)) {
            CertCloseStore(hstore, 0);
            pmydata->rghRootStores[0] = CertDuplicateStore(pcerttrust->rghstoreRoots[i]);
            return S_FALSE;
        }
        pmydata->rghRootStores[0] = CertDuplicateStore(hstore);
        pmydata->cRootStores = 1;
        CertCloseStore(hstore, 0);
    }

    //  "Trust" stores

    if (pcerttrust->cTrustStores != 0) {
        for (i=0; i<pcerttrust->cTrustStores; i++) {
            pmydata->rghTrustStores[i] = CertDuplicateStore(pcerttrust->rghstoreTrust[i]);
        }
        pmydata->cTrustStores = i;
    }
    else {
        hstore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                               pcerttrust->hprov, CERT_SYSTEM_STORE_CURRENT_USER |
                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                               L"Trust");
        if (hstore == NULL) {
            pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ::GetLastError();
            return S_FALSE;
        }
        pmydata->rghTrustStores[0] = CertDuplicateStore(hstore);
        pmydata->cTrustStores = 1;
        CertCloseStore(hstore, 0);
    }

    //  "CA" stores


    if (pcerttrust->cStores != 0) {
        for (i=0; i<pcerttrust->cStores; i++) {
            if (!pdata->psPfns->pfnAddStore2Chain(pdata,
                                                  pcerttrust->rghstoreCAs[i])) {
                pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
                return S_FALSE;
            }
        }
    }

    if ((pcerttrust->cStores == 0) ||
        (pcerttrust->dwFlags & CERT_TRUST_ADD_CERT_STORES)) {
        for (i=0; i<COtherProviders; i++) {
            hstore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                   pcerttrust->hprov, CERT_SYSTEM_STORE_CURRENT_USER |
                                   CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                   RgszProvider[i]);
            if (hstore == NULL) {
                pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ::GetLastError();
                return S_FALSE;
            }
            if (!pdata->psPfns->pfnAddStore2Chain(pdata, hstore)) {
                CertCloseStore(hstore, 0);
                pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
                return S_FALSE;
            }
            CertCloseStore(hstore, 0);
        }
    }

    //
    //  We have exactly one signature object to be added in, that is the certificate
    //  that we are going to verify.
    //

    CRYPT_PROVIDER_SGNR         sgnr;

    memset(&sgnr, 0, sizeof(sgnr));
    sgnr.cbStruct = sizeof(sgnr);
    GetSystemTimeAsFileTime(&sgnr.sftVerifyAsOf);
    //    memcpy(&sgnr.sftVerifyAsOf, &pcerttrust->pccert->pCertInfo->NotBefore,
    //           sizeof(FILETIME));
    // sgnr.csCertChain = 0;
    // sgnr.pasCertChain = NULL;
    // sgnr.dwSignerType = 0;
    // sgnr.psSigner = NULL;
    // sgnr.dwError = 0;
    // sgnr.csCounterSigners = 0;
    // sgnr.pasCounterSigners = NULL;

    if (!pdata->psPfns->pfnAddSgnr2Chain(pdata, FALSE, 0, &sgnr)) {
        pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
        return S_FALSE;
    }

    if (!pdata->psPfns->pfnAddCert2Chain(pdata, 0, FALSE, 0, pcerttrust->pccert)) {
        pdata->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_INITPROV] = ERROR_NOT_ENOUGH_MEMORY;
        return S_FALSE;
    }

    return S_OK;
}


#ifdef DEBUG
void DebugFileTime(FILETIME ft) {
    SYSTEMTIME st = {0};
    TCHAR szBuffer[256];

    FileTimeToSystemTime(&ft, &st);
    wsprintf(szBuffer, L"%02d/%02d/%04d  %02d:%02d:%02d\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
    OutputDebugString(szBuffer);
}
#endif


LONG CertVerifyTimeValidityWithDelta(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo, ULONG ulOffset) {
    LONG lRet;
    FILETIME ftNow;
    FILETIME ftDelta;
    __int64  i64Delta;
    __int64  i64Offset;

    lRet = CertVerifyTimeValidity(pTimeToVerify, pCertInfo);

    if (lRet < 0) {
        if (! pTimeToVerify) {
            // Get the current time in filetime format so we can add the offset
            GetSystemTimeAsFileTime(&ftNow);
            pTimeToVerify = &ftNow;
        }

#ifdef DEBUG
        DebugFileTime(*pTimeToVerify);
#endif

        i64Delta = pTimeToVerify->dwHighDateTime;
        i64Delta = i64Delta << 32;
        i64Delta += pTimeToVerify->dwLowDateTime;

        // Add the offset into the original time to get us a new time to check
        i64Offset = FILETIME_SECOND;
        i64Offset *= ulOffset;
        i64Delta += i64Offset;

        ftDelta.dwLowDateTime = (ULONG)i64Delta & 0xFFFFFFFF;
        ftDelta.dwHighDateTime = (ULONG)(i64Delta >> 32);

#ifdef DEBUG
        DebugFileTime(ftDelta);
#endif

        lRet = CertVerifyTimeValidity(&ftDelta, pCertInfo);
    }

    return(lRet);
}


////    FCheckCTLCert
//
//  Description:
//      This function is called when we find a CTL signed by a certificate.  At this
//      point we are going to check to see if we believe in the cert which was
//      used to sign the CTL.
//
//      We know that the certificate was already one of the ROOT stores and is
//      therefore explicity trusted as this is enforced by the caller.
//

BOOL FCheckCTLCert(PCCERT_CONTEXT pccert)
{
    DWORD               cbData;
    BOOL                f;
    FILETIME            ftZero;
    DWORD               i;
    PCERT_ENHKEY_USAGE  pUsage;

    memset(&ftZero, 0, sizeof(ftZero));

    //
    //  Start by checking the time validity of the cert.  We are going to
    //  allow two special cases as well as the time being valid.
    //
    //  1.  The start and end time are the same -- and indication that we
    //          made this in an earlier incarnation, or
    //  2.  The end time is 0.
    //

    if ((memcmp(&pccert->pCertInfo->NotBefore, &pccert->pCertInfo->NotAfter,
               sizeof(FILETIME)) == 0) ||
         memcmp(&pccert->pCertInfo->NotAfter, &ftZero, sizeof(FILETIME)) == 0) {
        DWORD           err;
        HCERTSTORE      hcertstore;
        HKEY            hkey;
        PCCERT_CONTEXT  pccertNew;
        PCCERT_CONTEXT  pccertOld;

        err = RegOpenKeyExA(HKEY_CURRENT_USER,
                            "Software\\Microsoft\\SystemCertificates\\ROOT",
                            0, KEY_ALL_ACCESS, &hkey);
        hcertstore = CertOpenStore(CERT_STORE_PROV_REG, X509_ASN_ENCODING,
                                   NULL, 0, hkey);
        if (hcertstore != NULL) {
            pccertOld = CertGetSubjectCertificateFromStore(hcertstore,
                                  X509_ASN_ENCODING, pccert->pCertInfo);
            pccertNew = CreateTrustSigningCert(NULL, hcertstore, FALSE);
            CertFreeCertificateContext(pccertNew);

            if (pccertOld != NULL) {
                CertDeleteCertificateFromStore(pccertOld);
            }
            CertCloseStore(hcertstore, 0);
        }
        RegCloseKey(hkey);
    }
    else if (CertVerifyTimeValidityWithDelta(NULL, pccert->pCertInfo,
                                             TIME_DELTA_SECONDS) != 0) {
        return FALSE;
    }

    //
    //  Must have a correct enhanced key usage to be viable.
    //
    //  Crack the usage on the cert

    f = CertGetEnhancedKeyUsage(pccert, 0, NULL, &cbData);
    if (!f || (cbData == 0)) {
        return FALSE;
    }

    pUsage = (PCERT_ENHKEY_USAGE) malloc(cbData);
    if (pUsage == NULL) {
        return FALSE;
    }

    if (!CertGetEnhancedKeyUsage(pccert, 0, pUsage, &cbData)) {
        free(pUsage);
        return FALSE;
    }

    //
    //  Look for the CTL_USAGE_SIGNING purpose on the cert.  If its not there
    //  then we don't allow it to be used.
    //

    for (i=0; i<pUsage->cUsageIdentifier; i++) {
        if (strcmp(pUsage->rgpszUsageIdentifier[i],
                   szOID_KP_CTL_USAGE_SIGNING) == 0) {
            break;
        }
    }
    if (i == pUsage->cUsageIdentifier) {
        free(pUsage);
        return FALSE;
    }
    free(pUsage);

    //
    //  Add any other tests.
    //

    return TRUE;
}

////    CertTrustCertPolicy
//
//   Description:
//      This code looks for trust information and puts it into the certificate
//      chain.  The behavior that we follow is going to depend on what type of
//      searching we are going to look for.
//
//      If we are just looking for trust, then we follow up the CTL looking for
//      trust information.
//

BOOL CertTrustCertPolicy(PCRYPT_PROVIDER_DATA pdata, DWORD, BOOL, DWORD)
{
    DWORD                       cb;
    BOOL                        f;
    BOOL                        fContinue = TRUE;
    DWORD                       i;
    CTL_VERIFY_USAGE_STATUS     vus;
    CTL_VERIFY_USAGE_PARA       vup;
    PCCTL_CONTEXT               pctlTrust = NULL;
    PCRYPT_PROVIDER_CERT        ptcert;
    CTL_USAGE                   ctlusage;
    PCCERT_CONTEXT              pccert = NULL;
    PCRYPT_PROVIDER_SGNR        psigner;
    PINTERNAL_DATA              pmydata;
    PCRYPT_PROVIDER_PRIVDATA    pprivdata;
    BYTE                        rgbHash[20];
    CRYPT_HASH_BLOB             blob;

    //
    //  Make sure all of the fields we want are there.  If not then it is a
    //  complete fatal error.
    //


    if (! WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pdata->cbStruct, pszUsageOID)) {
        fContinue = FALSE;
        goto Exit;
    }

    if (pdata->pWintrustData->pBlob->cbStruct < sizeof(WINTRUST_BLOB_INFO)) {
        pdata->dwError = ERROR_INVALID_PARAMETER;
        fContinue = FALSE;
        goto Exit;
    }

    //
    //  Look to see if we already have an error to deal with
    //

    if (pdata->dwError != 0) {
        fContinue = FALSE;
        goto Exit;
    }

    for (i=TRUSTERROR_STEP_FINAL_WVTINIT; i<TRUSTERROR_STEP_FINAL_CERTCHKPROV; i++) {
        if (pdata->padwTrustStepErrors[i] != 0) {
            fContinue = FALSE;
            goto Exit;
        }
    }

    //
    //  Get our internal data structure
    //

    pprivdata = WTHelperGetProvPrivateDataFromChain(pdata, (LPGUID) &MyGuid);
    if (pprivdata)
        pmydata = (PINTERNAL_DATA)pprivdata->pvProvData;
    else
    {
        fContinue = FALSE;
        goto Exit;
    }


    //
    //  We only work with a single signer --

    psigner = WTHelperGetProvSignerFromChain(pdata, 0, FALSE, 0);
    if (psigner == NULL)
    {
        fContinue = FALSE;
        goto Exit;
    }

    //
    //  Extract the certificate at the top of the stack
    //

    ptcert = WTHelperGetProvCertFromChain(psigner, psigner->csCertChain-1);

    //
    //  Does this certificate meet the definitions of "TRUSTED".
    //
    //  Definition #1.  It exists in a Root store
    //

    blob.cbData = sizeof(rgbHash);
    blob.pbData = rgbHash;
    cb = sizeof(rgbHash);
    CertGetCertificateContextProperty(ptcert->pCert, CERT_SHA1_HASH_PROP_ID,
                                      rgbHash, &cb);
    for (i=0; i<pmydata->cRootStores; i++) {
        pccert = CertFindCertificateInStore(pmydata->rghRootStores[i], X509_ASN_ENCODING,
                                            0, CERT_FIND_SHA1_HASH, &blob, NULL);
        if (pccert != NULL) {
            ptcert->fTrustedRoot = TRUE;
            fContinue = FALSE;
            goto Exit;
        }
    }

    //
    //  Build up the structures we will use to do a search in the
    //  trust stores
    //

    memset(&ctlusage, 0, sizeof(ctlusage));
    ctlusage.cUsageIdentifier = 1;
    ctlusage.rgpszUsageIdentifier = (LPSTR *) &pmydata->pszUsageOid;

    memset(&vup, 0, sizeof(vup));
    vup.cbSize = sizeof(vup);
    vup.cCtlStore = pmydata->cTrustStores;
    vup.rghCtlStore = pmydata->rghTrustStores;
    vup.cSignerStore = pmydata->cRootStores;
    vup.rghSignerStore = pmydata->rghRootStores;

    memset(&vus, 0, sizeof(vus));
    vus.cbSize = sizeof(vus);
    vus.ppCtl = &pctlTrust;
    vus.ppSigner = &pccert;

    //
    //  Now search for the CTL on this certificate,  if we don't find anything then
    //  we return TRUE to state that we want the search to continue
    //
    //

    f = CertVerifyCTLUsage(X509_ASN_ENCODING, CTL_CERT_SUBJECT_TYPE,
                           (LPVOID) ptcert->pCert, &ctlusage,
                           CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG |
                           CERT_VERIFY_NO_TIME_CHECK_FLAG |
                           CERT_VERIFY_TRUSTED_SIGNERS_FLAG, &vup, &vus);

    if (!f) {
        goto Exit;
    }

    //
    //  We found a CTL for this certificate.  First step is to see if the signing
    //  certificate is one which we can respect.  We know that the cert is in
    //  a root store, since we told the system it could only accept root store
    //  certs
    //

    if (!FCheckCTLCert(pccert)) {
        f = FALSE;
        goto Exit;
    }

    //  OK -- the signing cert passed it sanity check -- so see if the CTL contains
    //  relevent information or is just a "keep looking" CTL.
    //

    ptcert->pTrustListContext = (PCTL_CONTEXT) pctlTrust;
    pctlTrust = NULL;

    //
    //   We we are trying to do a full trust verification, then we need to
    //  just skip to the next cert without bothering to look at the ctl
    //

    if (pmydata->dwFlags & CERT_TRUST_DO_FULL_SEARCH) {
        goto Exit;
    }

    //
    //  Look to see if this is a "pass" item.  If it is then we need to
    //  continue looking, if it is not then we have reached the
    //  decision point
    //

    PCTL_ENTRY  pentry;
    pentry = &ptcert->pTrustListContext->pCtlInfo->rgCTLEntry[vus.dwCtlEntryIndex];
    for (i=0; i<pentry->cAttribute; i++) {
        if ((strcmp(pentry->rgAttribute[i].pszObjId, SzOID_CTL_ATTR_YESNO_TRUST) == 0) ||
            (strcmp(pentry->rgAttribute[i].pszObjId, SzOID_OLD_CTL_YESNO_TRUST) == 0)) {
            if ((pentry->rgAttribute[i].rgValue[0].cbData == sizeof(RgbTrustParent)) &&
                (memcmp(pentry->rgAttribute[i].rgValue[0].pbData,
                        RgbTrustParent, sizeof(RgbTrustParent)) == 0)) {
                //  Defer to parent
                goto Exit;
            }
            //
            //  We have the decision point, push the signer onto the the stack
            //

            fContinue = !!(pmydata->dwFlags & CERT_TRUST_DO_FULL_TRUST);
            goto Exit;
        }

    }

Exit:
    if (pccert != NULL) CertFreeCertificateContext(pccert);
    if (pctlTrust != NULL) CertFreeCTLContext(pctlTrust);
    return fContinue;
}

////    HrCheckPolicies
//
//  Description:
//      Given an array of certificates, figure out what errors we have
//
//      We enforce the following set of extensions
//
//      enhancedKeyUsage
//      basicConstraints
//      keyUsage
//      nameConstraints
//

HRESULT HrCheckPolicies(PCRYPT_PROVIDER_SGNR psigner, DWORD cChain,
                        DWORD * rgdwErrors, LPCSTR pszUsage)
{
    DWORD                       cbData;
    DWORD                       cExt;
    DWORD                       dwPolicy = 0;
    DWORD                       dwType;
    HKEY                        hkPolicy;
    DWORD                       i;
    DWORD                       iCert;
    DWORD                       iExt;
    PCRYPT_PROVIDER_CERT        ptcert;
    PCERT_EXTENSION             rgExt;
    
    // Retrieve policy information from the registry
    
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, SzPolicyKey, 0, KEY_READ,
        &hkPolicy) == ERROR_SUCCESS) {
        cbData = sizeof(dwPolicy);
        if ((ERROR_SUCCESS != RegQueryValueExA(hkPolicy,
            SzPolicyData, 
            0, &dwType,
            (LPBYTE)&dwPolicy,
            &cbData)) ||
            (REG_DWORD != dwType)) {
            dwPolicy = 0;
        }                        
        RegCloseKey(hkPolicy);
    }
    
    // Check the policy on each cert in the chain
    
    for (iCert=0; iCert<cChain; iCert++) {
        //
        //  Get the next cert to examine
        //
        
        ptcert = WTHelperGetProvCertFromChain(psigner, iCert);
        
        //
        //  Setup to process the certs extensions
        //
        
        if (!ptcert || !(ptcert->pCert) || !(ptcert->pCert->pCertInfo))
            continue;

        cExt = ptcert->pCert->pCertInfo->cExtension;
        rgExt = ptcert->pCert->pCertInfo->rgExtension;
        
        //
        //  Process the extensions
        //
        
ProcessExtensions:
        for (iExt=0; iExt<cExt; iExt++) {
            if (strcmp(rgExt[iExt].pszObjId, szOID_ENHANCED_KEY_USAGE) == 0) {
                if (pszUsage == NULL) {
                    continue;
                }
                PCERT_ENHKEY_USAGE      pUsage;
                pUsage = (PCERT_ENHKEY_USAGE) PVCryptDecode(rgExt[iExt].pszObjId,
                    rgExt[iExt].Value.cbData,
                    rgExt[iExt].Value.pbData);
                if ((pUsage == NULL) && rgExt[iExt].fCritical) {
                    rgdwErrors[iCert] |= CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION;
                    continue;
                }
                
                if(pUsage)
                {
                    for (i=0; i<pUsage->cUsageIdentifier; i++) {
                        if (strcmp(pUsage->rgpszUsageIdentifier[i], pszUsage) == 0) {
                            break;
                        }
                    }
                    if (i == pUsage->cUsageIdentifier) {
                        rgdwErrors[iCert] |= CERT_VALIDITY_EXTENDED_USAGE_FAILURE;
                    }
                    
                    free(pUsage);
                }
            }
            else if (strcmp(rgExt[iExt].pszObjId, szOID_BASIC_CONSTRAINTS2) == 0) {
                PCERT_BASIC_CONSTRAINTS2_INFO   p;
                
                // If Basic Constraints is not marked critical (in opposition
                //  to PKIX) we allow the administrator to overrule our 
                //  processing to deal with bad NT CertSrv SP1 hierarchies
                //  used with Exchange KMS.
                
                if ((dwPolicy & POLICY_IGNORE_NON_CRITICAL_BC) &&
                    !(rgExt[iExt].fCritical)) {
                    continue;
                }
                
                // Verify the basic constraint extension
                
                p = (PCERT_BASIC_CONSTRAINTS2_INFO)
                    PVCryptDecode(rgExt[iExt].pszObjId,
                    rgExt[iExt].Value.cbData,
                    rgExt[iExt].Value.pbData);
                if ((p == NULL) && rgExt[iExt].fCritical) {
                    rgdwErrors[iCert] |= CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION;
                    continue;
                }
                
                if(p)
                {
                    if ((!p->fCA) && (iCert > 0) && (iCert < cChain-1)) {
                        rgdwErrors[iCert] |= CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                    }
                    
                    if (p->fPathLenConstraint) {
                        if (p->dwPathLenConstraint+1 < iCert) {
                            rgdwErrors[iCert] |= CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                        }
                    }
                    
                    free(p);
                }
            }
            else if (strcmp(rgExt[iExt].pszObjId, szOID_KEY_USAGE) == 0) {
                PCERT_KEY_ATTRIBUTES_INFO    p;
                p = (PCERT_KEY_ATTRIBUTES_INFO)
                    PVCryptDecode(rgExt[iExt].pszObjId,
                    rgExt[iExt].Value.cbData,
                    rgExt[iExt].Value.pbData);
                if ((p == NULL) && rgExt[iExt].fCritical) {
                    rgdwErrors[iCert] |= CERT_VALIDITY_KEY_USAGE_EXT_FAILURE;
                    continue;
                }
                
                if(p)
                {
                    if (p->IntendedKeyUsage.cbData >= 1) {
                        if (iCert != 0) {
#if 0
                            if (!((*p->IntendedKeyUsage.pbData) & CERT_KEY_CERT_SIGN_KEY_USAGE)) {
                                rgdwErrors[iCert] |= CERT_VALIDITY_KEY_USAGE_EXT_FAILURE;
                            }
#endif // 0
                        }
                    }
                    free(p);
                }
            }
            else if ((strcmp(rgExt[iExt].pszObjId, szOID_SUBJECT_ALT_NAME2) == 0) ||
            (strcmp(rgExt[iExt].pszObjId, szOID_CRL_DIST_POINTS) == 0)/* ||
                                                                      (strcmp(rgExt[iExt].pszObjId, szOID_CERT_POLICIES) == 0) ||
                                                                      (strcmp(rgExt[iExt].pszObjId, "2.5.29.30") == 0) ||
                                                                      (strcmp(rgExt[iExt].pszObjId, "2.5.29.36") == 0)*/) {
                                                                      ;
            }
            else if (rgExt[iExt].fCritical) {
                rgdwErrors[iCert] |= CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION;
            }
        }
        
        //
        //  If we have a CTL for this cert, and we have not already done so
        //      then process the extensions that it has.
        //
        
        if ((ptcert->pTrustListContext != NULL) &&
            (rgExt != ptcert->pTrustListContext->pCtlInfo->rgExtension)) {
            cExt = ptcert->pTrustListContext->pCtlInfo->cExtension;
            rgExt = ptcert->pTrustListContext->pCtlInfo->rgExtension;
            goto ProcessExtensions;
        }
        
        //
        //  Need to support turn off of certificates
        //
        
        if (CertGetEnhancedKeyUsage(ptcert->pCert, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
            NULL, &cbData)) {
            BOOL                fFound = FALSE;
            PCERT_ENHKEY_USAGE  pUsage;
            pUsage = (PCERT_ENHKEY_USAGE) malloc(cbData);
            CertGetEnhancedKeyUsage(ptcert->pCert, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
                pUsage, &cbData);
            
            for (i=0; i<pUsage->cUsageIdentifier; i++) {
                if ((pszUsage != NULL) &&
                    strcmp(pUsage->rgpszUsageIdentifier[i], pszUsage) == 0) {
                    fFound = TRUE;
                }
                else if (strcmp(pUsage->rgpszUsageIdentifier[i], szOID_YESNO_TRUST_ATTR) == 0) {
                    rgdwErrors[iCert] |= CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                    break;
                }
            }
            
            if ((pszUsage != NULL) && !fFound) {
                rgdwErrors[iCert] |= CERT_VALIDITY_EXTENDED_USAGE_FAILURE;
            }
            
            free(pUsage);
        }
        
        //
        //  If we jump past a CTL, then we need to change our purpose
        //
        
        if (ptcert->pCtlContext != NULL) {
            pszUsage = SzOID_KP_CTL_USAGE_SIGNING;
        }
    }
    return S_OK;
}

//// GetErrorFromCert
//
//   Description:
//      Get the internal error from the provider certificate
//
DWORD GetErrorFromCert(PCRYPT_PROVIDER_CERT pCryptProviderCert)
{
    //
    // if this is true then the cert is OK
    //
    if ((pCryptProviderCert->dwError == 0)                              &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_SIG)        &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIME)       &&
        (pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIMENEST)   &&
        (!pCryptProviderCert->fIsCyclic))
    {
        return 0;
    }


    if (pCryptProviderCert->dwError == CERT_E_REVOKED)
    {
        return CERT_VALIDITY_CERTIFICATE_REVOKED;
    }
    else if (pCryptProviderCert->dwError == CERT_E_REVOCATION_FAILURE)
    {
        return CERT_VALIDITY_NO_CRL_FOUND;
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_SIG) ||
             (pCryptProviderCert->dwError == TRUST_E_CERT_SIGNATURE))
    {
        return CERT_VALIDITY_SIGNATURE_FAILS;
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIME) ||
             (pCryptProviderCert->dwError == CERT_E_EXPIRED))
    {
        return CERT_VALIDITY_AFTER_END;
    }
    else if (!(pCryptProviderCert->dwConfidence & CERT_CONFIDENCE_TIMENEST) ||
             (pCryptProviderCert->dwError == CERT_E_VALIDITYPERIODNESTING))
    {         
        return CERT_VALIDITY_PERIOD_NESTING_FAILURE;
    }
    else if (pCryptProviderCert->dwError == CERT_E_WRONG_USAGE)
    {
        return CERT_VALIDITY_KEY_USAGE_EXT_FAILURE;
    }
    else if (pCryptProviderCert->dwError == TRUST_E_BASIC_CONSTRAINTS)
    {
        return CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
    }
    else if (pCryptProviderCert->dwError == CERT_E_PURPOSE)
    {
        return CERT_VALIDITY_EXTENDED_USAGE_FAILURE;
    }
    else if (pCryptProviderCert->dwError == CERT_E_CHAINING)
    {
        return CERT_VALIDITY_NO_ISSUER_CERT_FOUND;
    }
    else if (pCryptProviderCert->dwError == TRUST_E_EXPLICIT_DISTRUST)
    {
        return CERT_VALIDITY_EXPLICITLY_DISTRUSTED;
    }
    else if (pCryptProviderCert->fIsCyclic)
    {
        return CERT_VALIDITY_ISSUER_INVALID;
    }
    else
    {
        //
        // this is not an error we know about, so call return general error
        //
        return CERT_VALIDITY_OTHER_ERROR;
    }

}

//// MapErrorToTrustError
//
//   Description:
//      Map the internal error value to a WINTRUST recognized value.
//      The CryptUI dialogs recognize these values:
//          CERT_E_UNTRUSTEDROOT
//          CERT_E_REVOKED
//          TRUST_E_CERT_SIGNATURE
//          CERT_E_EXPIRED
//          CERT_E_VALIDITYPERIODNESTING
//          CERT_E_WRONG_USAGE
//          TRUST_E_BASIC_CONSTRAINTS
//          CERT_E_PURPOSE
//          CERT_E_REVOCATION_FAILURE
//          CERT_E_CHAINING  - this is set if a full chain cannot be built
//
//
HRESULT MapErrorToTrustError(DWORD dwInternalError) {
    HRESULT hrWinTrustError = S_OK;

    // Look at them in decreasing order of importance
    if (dwInternalError) {
        if (dwInternalError & CERT_VALIDITY_EXPLICITLY_DISTRUSTED) {
            hrWinTrustError = /*TRUST_E_EXPLICIT_DISTRUST*/ 0x800B0111;
        } else if (dwInternalError & CERT_VALIDITY_SIGNATURE_FAILS) {
            hrWinTrustError = TRUST_E_CERT_SIGNATURE;
        } else if (dwInternalError & CERT_VALIDITY_CERTIFICATE_REVOKED) {
            hrWinTrustError = CERT_E_REVOKED;
        } else if (dwInternalError & CERT_VALIDITY_BEFORE_START || dwInternalError & CERT_VALIDITY_AFTER_END) {
            hrWinTrustError = CERT_E_EXPIRED;
        } else if (dwInternalError & CERT_VALIDITY_ISSUER_DISTRUST) {
            hrWinTrustError = CERT_E_UNTRUSTEDROOT;
        } else if (dwInternalError & CERT_VALIDITY_ISSUER_INVALID) {
            hrWinTrustError = CERT_E_UNTRUSTEDROOT;
        } else if (dwInternalError & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
            hrWinTrustError = CERT_E_CHAINING;
        } else if (dwInternalError & CERT_VALIDITY_NO_CRL_FOUND) {
            hrWinTrustError = CERT_E_REVOCATION_FAILURE;
        } else if (dwInternalError & CERT_VALIDITY_PERIOD_NESTING_FAILURE) {
            hrWinTrustError = CERT_E_VALIDITYPERIODNESTING;
        } else if (dwInternalError & CERT_VALIDITY_EXTENDED_USAGE_FAILURE) {
            hrWinTrustError = CERT_E_WRONG_USAGE;
        } else if (dwInternalError & CERT_VALIDITY_OTHER_ERROR) {
            hrWinTrustError = TRUST_E_FAIL;     // BUGBUG: Will this give a good error?;
        } else if (dwInternalError & CERT_VALIDITY_NO_TRUST_DATA) {
            hrWinTrustError = CERT_E_UNTRUSTEDROOT;
        } else {
            hrWinTrustError = TRUST_E_FAIL;     // BUGBUG: Will this give a good error?;
        }
    }

    // CERT_E_UNTRUSTEDROOT
    // CERT_E_REVOKED
    // TRUST_E_CERT_SIGNATURE
    // CERT_E_EXPIRED
    // X CERT_E_VALIDITYPERIODNESTING
    // X CERT_E_WRONG_USAGE
    // TRUST_E_BASIC_CONSTRAINTS
    // CERT_E_PURPOSE
    // CERT_E_REVOCATION_FAILURE    What is this?
    // CERT_E_CHAINING  - this is set if a full chain cannot be built


    return(hrWinTrustError);
}



////    CertTrustFinalPolicy
//
//  Description:
//      This code does the enforcement of all restrictions on the certificate
//      chain that we understand.
//

HRESULT CertTrustFinalPolicy(PCRYPT_PROVIDER_DATA pdata)
{
    int                         cChain = 0;
    DWORD                       dwFlags;
    FILETIME                    ftZero = {0, 0};
    HRESULT                     hr;
    HRESULT                     hrStepError = S_OK;
    int                         i;
    DWORD                       j;
    PCERT_VERIFY_CERTIFICATE_TRUST pcerttrust;
    PINTERNAL_DATA              pmydata;
    PCRYPT_PROVIDER_PRIVDATA    pprivdata;
    PCRYPT_PROVIDER_SGNR        psigner;
    PCRYPT_PROVIDER_CERT        ptcert = NULL;
    PCRYPT_PROVIDER_CERT        ptcertIssuer;
    DATA_BLOB *                 rgblobTrustInfo = NULL;
    LPBYTE                      rgbTrust = NULL;
    DWORD *                     rgdwErrors = NULL;
    PCCERT_CONTEXT *            rgpccertChain = NULL;
    int                         iExplicitlyTrusted;

    //
    //  Make sure all of the fields we want are there.  If not then it is a
    //  complete fatal error.
    //


    if (! WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pdata->cbStruct, pszUsageOID)) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    if (pdata->pWintrustData->pBlob->cbStruct < sizeof(WINTRUST_BLOB_INFO)) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    pcerttrust = (PCERT_VERIFY_CERTIFICATE_TRUST)
        pdata->pWintrustData->pBlob->pbMemObject;
    if ((pcerttrust == NULL) ||
        (pcerttrust->cbSize < sizeof(*pcerttrust))) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    //
    //  Get our internal data structure
    //

    pprivdata = WTHelperGetProvPrivateDataFromChain(pdata, (LPGUID) &MyGuid);
    if (pprivdata == NULL) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    pmydata = (PINTERNAL_DATA) pprivdata->pvProvData;

    //
    //  Check for an existing error -- If so then skip to any UI
    //

    if (pdata->dwError != 0) {
        hr = pdata->dwError;
        goto XXX;
    }

    for (i=TRUSTERROR_STEP_FINAL_WVTINIT; i<TRUSTERROR_STEP_FINAL_POLICYPROV; i++) {
        if (pdata->padwTrustStepErrors[i] != 0) {
            // for these errors we still want to continue processing
            if ((TRUST_E_CERT_SIGNATURE == pdata->padwTrustStepErrors[i]) ||
                (CERT_E_REVOKED == pdata->padwTrustStepErrors[i]) ||
                (CERT_E_REVOCATION_FAILURE == pdata->padwTrustStepErrors[i])) {
                hrStepError = pdata->padwTrustStepErrors[i];
            }
            else {
                hr = pdata->padwTrustStepErrors[i];
                goto XXX;
            }
        }
    }

    //
    //  We only work with a single signer --

    psigner = WTHelperGetProvSignerFromChain(pdata, 0, FALSE, 0);
    if (psigner == NULL) {
        hr = E_INVALIDARG;
        goto XXX;
    }

    //
    //   If we are not getting a full chain, then build up the set of
    //  certs and pass it to the validator
    //

    if (!(pmydata->dwFlags & CERT_TRUST_DO_FULL_SEARCH)) {

    }

    //
    //  We are going to compute some return values at this point
    //  either a full chain or a full chain with complete trust.
    //
    //  Allocate space to return the chain of certs back to the caller.
    //  We allocate space for the full chain, even though we may not
    //  actually use it.
    //

    cChain = psigner->csCertChain;

    rgpccertChain = (PCCERT_CONTEXT *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                  cChain * sizeof(PCCERT_CONTEXT));
    rgdwErrors = (DWORD *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cChain * sizeof(DWORD));
    rgblobTrustInfo = (DATA_BLOB *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cChain * sizeof(DATA_BLOB));
    rgbTrust = (BYTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cChain*sizeof(BLOB));

    if ((rgpccertChain == NULL) || (rgdwErrors == NULL) ||
        (rgblobTrustInfo == NULL) || (rgbTrust == NULL)) {
        hr = E_OUTOFMEMORY;
        goto XXX;
    }

    //
    //  Build the first set of returned values.  At this
    //  point we are creating the arrays to return both
    //  the relevent trust information and the chain of
    //  certificates in
    //

    for (i=0; i<cChain; i++) {
        //
        //  Start by duplicating the certificate into the return
        //      location
        //

        ptcert = WTHelperGetProvCertFromChain(psigner, i);
        rgpccertChain[i] = CertDuplicateCertificateContext(ptcert->pCert);
        if (i < cChain-1) {
            ptcertIssuer = WTHelperGetProvCertFromChain(psigner, i+1);
        }
        else {
            ptcertIssuer = NULL;
            if (!ptcert->fSelfSigned) {
                rgdwErrors[i] |= CERT_VALIDITY_NO_ISSUER_CERT_FOUND;
            }
        }

        //
        //  Check for some simple items
        //

        dwFlags = CertVerifyTimeValidityWithDelta(NULL, 
                                                  ptcert->pCert->pCertInfo, 
                                                  TIME_DELTA_SECONDS);
        if (((LONG)dwFlags) < 0) {
            rgdwErrors[i] |= CERT_VALIDITY_BEFORE_START;
        }
        else if (dwFlags > 0) {
            if (!ptcert->fTrustListSignerCert ||
                memcmp(&ptcert->pCert->pCertInfo->NotAfter, &ftZero, 
                       sizeof(ftZero)) != 0) {
                rgdwErrors[i] |= CERT_VALIDITY_AFTER_END;
            }
            else {
                if (!(ptcert->dwConfidence & CERT_CONFIDENCE_TIME)) {
                    ptcert->dwConfidence |= CERT_CONFIDENCE_TIME;
                }            
                if (ptcert->dwError == CERT_E_EXPIRED) {
                    ptcert->dwError = S_OK;
                }
           }
        }

        //
        // Check for error in Certificate
        //
        rgdwErrors[i] |= GetErrorFromCert(ptcert);

        //
        //  If we find an issuer, then lets go after the questions we have
        //      about CRLs.
        //
        //  Question -- do we get everything here?  How do we know if the
        //      CRL is out of date.
        //

        if ((ptcertIssuer != NULL) && (ptcert->pCtlContext == NULL)) {
            dwFlags = CERT_STORE_SIGNATURE_FLAG;
            if ((pdata->dwProvFlags & CPD_REVOCATION_CHECK_NONE) ||
                (psigner->pChainContext == NULL))
                dwFlags |= CERT_STORE_REVOCATION_FLAG;
            if (CertVerifySubjectCertificateContext(ptcert->pCert, ptcertIssuer->pCert, &dwFlags) &&
                (dwFlags != 0)) {
                if (dwFlags & CERT_STORE_SIGNATURE_FLAG) {
                    rgdwErrors[i] |= CERT_VALIDITY_SIGNATURE_FAILS;
                }
                if (dwFlags & CERT_STORE_REVOCATION_FLAG) {
                    if (dwFlags & CERT_STORE_NO_CRL_FLAG) {
                        rgdwErrors[i] |= CERT_VALIDITY_NO_CRL_FOUND;
                    }
                    else {
                        rgdwErrors[i] |= CERT_VALIDITY_CERTIFICATE_REVOKED;
                    }
                }
            }

            // If both CRL not found and revoked are set, choose the most
            //  conservative state- the cert is revoked.
            
            if ((CERT_VALIDITY_NO_CRL_FOUND & rgdwErrors[i]) &&
                (CERT_VALIDITY_CERTIFICATE_REVOKED & rgdwErrors[i])) {
                rgdwErrors[i] &= ~CERT_VALIDITY_NO_CRL_FOUND;
            }                
        }

        //
        //
        //

        if (ptcert->fTrustedRoot) {
            rgblobTrustInfo[i].cbData = 0;
            rgblobTrustInfo[i].pbData = (LPBYTE) 1;
            rgbTrust[i] = 1;
        }
        else if (ptcert->pTrustListContext != NULL) {
            CRYPT_ATTRIBUTES    attrs;
            DWORD               cbData;
            BOOL                f;
            LPBYTE              pb;
            PCTL_ENTRY          pctlentry;

            pctlentry = CertFindSubjectInCTL(X509_ASN_ENCODING, CTL_CERT_SUBJECT_TYPE,
                                             (LPVOID) ptcert->pCert, ptcert->pTrustListContext,
                                             0);
            attrs.cAttr = pctlentry->cAttribute;
            attrs.rgAttr = pctlentry->rgAttribute;

            for (j=0; j<attrs.cAttr; j++) {
                if ((strcmp(attrs.rgAttr[j].pszObjId, SzOID_CTL_ATTR_YESNO_TRUST) == 0) ||
                    (strcmp(attrs.rgAttr[j].pszObjId, SzOID_OLD_CTL_YESNO_TRUST) == 0)) {

                    if ((attrs.rgAttr[j].rgValue[0].cbData == sizeof(RgbTrustYes)) &&
                        (memcmp(attrs.rgAttr[j].rgValue[0].pbData,
                                RgbTrustYes, sizeof(RgbTrustYes)) == 0)) {
                        rgbTrust[i] = 2;
                        break;
                    }
                    else if ((attrs.rgAttr[j].rgValue[0].cbData == sizeof(RgbTrustNo)) &&
                             (memcmp(attrs.rgAttr[j].rgValue[0].pbData,
                                     RgbTrustNo, sizeof(RgbTrustNo)) == 0)) {
                        rgdwErrors[i] |= CERT_VALIDITY_EXPLICITLY_DISTRUSTED;
                        rgbTrust[i] = (BYTE) -1;
                        break;
                    }
                    else if ((attrs.rgAttr[j].rgValue[0].cbData == sizeof(RgbTrustParent)) &&
                             (memcmp(attrs.rgAttr[j].rgValue[0].pbData,
                                     RgbTrustParent, sizeof(RgbTrustParent)) == 0)) {
                        rgbTrust[i] = 0;
                        break;
                    }
                    else {
                        rgdwErrors[i] |= CERT_VALIDITY_NO_TRUST_DATA;
                        rgbTrust[i] = (BYTE) -2;
                        break;
                    }
                }
            }
            if (j == attrs.cAttr) {
                rgbTrust[i] = 0;
            }

            f = CryptEncodeObject(X509_ASN_ENCODING, "1.3.6.1.4.1.311.16.1.1",
                              &attrs, NULL, &cbData);
            if (f && (cbData != 0)) {
                pb = (LPBYTE) LocalAlloc(LMEM_FIXED, cbData);
                if (pb != NULL) {
                    f = CryptEncodeObject(X509_ASN_ENCODING, "1.3.6.1.4.1.311.16.1.1",
                                          &attrs, pb, &cbData);
                    rgblobTrustInfo[i].cbData = cbData;
                    rgblobTrustInfo[i].pbData = pb;
                }
            }
        }
    }

    //
    //
    //

    DWORD       rgiCert[32];
    for (i=0; i<cChain; i++) {
        rgiCert[i] = i;
    }

    //
    //   Apply policies to it
    //

    hr = HrCheckPolicies(psigner, cChain, rgdwErrors, pcerttrust->pszUsageOid);
    if (FAILED(hr)) {
        goto XXX;
    }

    //
    //  Mask out the bits which the caller says are un-important
    //

    if (pcerttrust->pdwErrors != NULL) {
        *pcerttrust->pdwErrors = 0;
    }

    // Find the lowest index explicitly trusted cert in chain
    iExplicitlyTrusted = cChain;    // > index of root cert
    for (i = 0; i < cChain; i++) {
        if (rgbTrust[i] == 2) {
            iExplicitlyTrusted = i;
            break;
        }
    }

    for (i=cChain-1; i>=0; i--) {
        //
        //  Build a better idea of basic trust
        //

        switch (rgbTrust[i]) {
            //  We are explicity trusted -- clear out any trust errors which may
            //  have been located for this certificate  They are no longer
            //  relevent.
        case 1:         // Explicitly trusted (root)
        case 2:         // Explicitly trusted (CTL)
            rgdwErrors[i] &= ~(CERT_VALIDITY_MASK_TRUST |
                               CERT_VALIDITY_CERTIFICATE_REVOKED);
            break;

        case -2:        // Unknown CTL data
        case -1:        // Explicitly distrusted (CTL)
            rgdwErrors[i] |= CERT_VALIDITY_EXPLICITLY_DISTRUSTED;
            break;

        case 0:         // Chain trusted (CTL or no CTL)
            if (i == cChain-1) {
                rgdwErrors[i] |= CERT_VALIDITY_NO_TRUST_DATA;
            }
            break;
        }

        rgdwErrors[i] &= ~pcerttrust->dwIgnoreErr;

        if (i > 0) {
            if (rgdwErrors[i] & CERT_VALIDITY_MASK_VALIDITY) {
                rgdwErrors[i-1] |= CERT_VALIDITY_ISSUER_INVALID;
            }
            if (rgdwErrors[i] & CERT_VALIDITY_MASK_TRUST) {
                rgdwErrors[i-1] |= CERT_VALIDITY_ISSUER_DISTRUST;
            }
        }

        if (pcerttrust->pdwErrors != NULL) {
            DWORD dwThisTrust = rgdwErrors[i];

            if (i >= iExplicitlyTrusted) {
                // If we have an explicitly trusted cert or one of it's issuer's,
                // we assume trust all the way up the chain.
                dwThisTrust &= ~(CERT_VALIDITY_MASK_TRUST | CERT_VALIDITY_CERTIFICATE_REVOKED);
            }

            *pcerttrust->pdwErrors |= dwThisTrust;
        }

        // Set the trust state for this chain cert
        if (WVT_ISINSTRUCT(CRYPT_PROVIDER_CERT, ptcert->cbStruct, dwError)) {
            ptcert = WTHelperGetProvCertFromChain(psigner, i);
            ptcert->dwError = (DWORD)MapErrorToTrustError(rgdwErrors[i]);
        }
    }

    if (rgdwErrors[0] != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    if (WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pdata->cbStruct, dwFinalError)) {
        pdata->dwFinalError = (DWORD)MapErrorToTrustError(rgdwErrors[0]);

        if (pdata->dwFinalError) {
           // Assert(hr != S_OK);
        }
    }

    //
    //  We have succeded and are finished.
    //  Setup the return values
    //

    if (pcerttrust->pcChain != NULL) {
        *pcerttrust->pcChain = cChain;
    }
    if (pcerttrust->prgChain != NULL) {
        *pcerttrust->prgChain = rgpccertChain;
        rgpccertChain = NULL;
    }
    if (pcerttrust->prgdwErrors != NULL) {
        *pcerttrust->prgdwErrors = rgdwErrors;
        rgdwErrors = NULL;
    }
    if (pcerttrust->prgpbTrustInfo != NULL) {
        *pcerttrust->prgpbTrustInfo = rgblobTrustInfo;
        rgblobTrustInfo = NULL;
    }

XXX:
    if (rgpccertChain != NULL) {
        for (i=0; i<cChain; i++) {
            CertFreeCertificateContext(rgpccertChain[i]);
            }
        LocalFree(rgpccertChain);
    }
    if (rgdwErrors != NULL) LocalFree(rgdwErrors);
    if (rgblobTrustInfo != NULL) {
        for (i=0; i<cChain; i++) {
            if (rgblobTrustInfo[i].cbData > 0) {
                LocalFree(rgblobTrustInfo[i].pbData);
            }
        }
        LocalFree(rgblobTrustInfo);
    }
    if (rgbTrust != NULL) LocalFree(rgbTrust);
    // If everything worked then reurn any step error we ignored
    if (FAILED(hrStepError) && SUCCEEDED(hr))
        hr = hrStepError;
    return hr;
}

////    CertTrustCleanup
//
//  Description:
//      This code knows how to cleanup all allocated data we have.
//

HRESULT CertTrustCleanup(PCRYPT_PROVIDER_DATA pdata)
{
    DWORD                       i;
    PCRYPT_PROVIDER_PRIVDATA    pprivdata;
    PINTERNAL_DATA              pmydata;

    //
    //  Get our internal data structure
    //

    pprivdata = WTHelperGetProvPrivateDataFromChain(pdata, (LPGUID) &MyGuid);
    if (pprivdata == NULL) {
        return S_OK;
    }

    pmydata = (PINTERNAL_DATA) pprivdata->pvProvData;

    //
    //  Release all of the stores we have cached here
    //

    for (i=0; i<pmydata->cRootStores; i++) {
        CertCloseStore(pmydata->rghRootStores[i], 0);
    }

    for (i=0; i<pmydata->cTrustStores; i++) {
        CertCloseStore(pmydata->rghTrustStores[i], 0);
    }

    //
    //  If we installed a default crypt context, uninstall it now
    //

    i = CryptUninstallDefaultContext(pmydata->hdefaultcontext, 0, NULL);
    // Assert(i == TRUE);

    return S_OK;
}


#else  // !NT5BUILD
#pragma message("Building for IE")

////    HrCheckTrust
//
//  Description:
//

HRESULT HrCheckTrust(PCCertFrame  pcf, int iTrust)
{
    HRESULT     hr;
    HRESULT     hrRet = S_OK;
    int         i;

    //
    //  If this node has trust information on it, then compute the trust at this
    //  point.  If we either succeed or fail then return the indication.
    //

    if ((pcf->m_rgTrust != NULL) && (pcf->m_rgTrust[iTrust].szOid != NULL)) {
        if (pcf->m_fRootStore) {
            pcf->m_rgTrust[iTrust].fExplicitTrust = TRUE;
            pcf->m_rgTrust[iTrust].fTrust = TRUE;
            return S_OK;
        }
        if ((strcmp(pcf->m_rgTrust[iTrust].szOid, SzOID_CTL_ATTR_YESNO_TRUST) == 0) ||
            (strcmp(pcf->m_rgTrust[iTrust].szOid, SzOID_OLD_CTL_YESNO_TRUST) == 0)){
            if ((pcf->m_rgTrust[iTrust].cbTrustData == 3) &&
                memcmp(pcf->m_rgTrust[iTrust].pbTrustData, RgbTrustYes, 3) == 0) {
                pcf->m_rgTrust[iTrust].fExplicitTrust = TRUE;
                pcf->m_rgTrust[iTrust].fTrust = TRUE;
                return S_OK;
            }
            else if ((pcf->m_rgTrust[iTrust].cbTrustData == 3) &&
                     memcmp(pcf->m_rgTrust[iTrust].pbTrustData,
                            RgbTrustParent, 3) == 0) {
                //  Need to ceck with the parent to find out what is going on.
            }
            else {
                // Assume it must be RgbTrustNo
                pcf->m_rgTrust[iTrust].fExplicitDistrust = TRUE;
                pcf->m_rgTrust[iTrust].fDistrust = TRUE;
                return S_FALSE;
            }
        }
        else {
            pcf->m_rgTrust[iTrust].fError = TRUE;
            return S_FALSE;
        }
    }

    if (pcf->m_fRootStore) {
        pcf->m_rgTrust[iTrust].fExplicitTrust = TRUE;
        pcf->m_rgTrust[iTrust].fTrust = TRUE;
        return S_OK;
    }

    //
    //  We are marked as inherit -- so start asking all of our parents
    //

    if (pcf->m_cParents == 0) {
        // No parents -- so not trusted.
        hrRet = S_FALSE;
    }
    else {
        for (i=0; i<pcf->m_cParents; i++) {
            hr = HrCheckTrust(pcf->m_rgpcfParents[i], iTrust);
            if (FAILED(hr)) {
                pcf->m_rgTrust[iTrust].fError = TRUE;
                return hr;
            }
            pcf->m_rgTrust[iTrust].fTrust = pcf->m_rgpcfParents[i]->m_rgTrust[iTrust].fTrust;
            pcf->m_rgTrust[iTrust].fDistrust = pcf->m_rgpcfParents[i]->m_rgTrust[iTrust].fDistrust;
            if (hr != S_OK) {
                hrRet = S_FALSE;
            }
        }
    }

    return hrRet;
}

////    HrCheckValidity
//
//  Description:
//      This function will walk through the tree of certificates looking
//      for the invalid certificates.  It masks in the fact that the issuer
//      certificate is invalid as necessary

HRESULT HrCheckValidity(PCCertFrame  pcf)
{
    HRESULT     hr;
    int         i;

    //
    //  If we do not have an issuer certificate, then our parent cannot possibly
    //  be invalid
    //

    if (pcf->m_cParents > 0) {
        for (i=0; i<pcf->m_cParents; i++) {
            hr = HrCheckValidity(pcf->m_rgpcfParents[i]);
            // Assert(SUCCEEDED(hr));
            if (hr != S_OK) {
                pcf->m_dwFlags |= CERT_VALIDITY_ISSUER_INVALID;
                return hr;
            }
        }
    }
    return (pcf->m_dwFlags == 0) ? S_OK : S_FALSE;
}

////    HrPerformUserCheck
//

HRESULT HrPerformUserCheck(PCCertFrame  pcf, BOOL fComplete,
                           DWORD * pcNodes, int iDepth, PCCertFrame * rgpcf)
{
    int iTrust = 0;

    //
    //  We can only deal with up to 20-nodes in the chain of trust
    //

    if (iDepth == 20) {
        return E_OUTOFMEMORY;
    }

    //
    //  Put our node in so we can do array process checking
    //

    rgpcf[iDepth] = pcf;

    //
    //  Handle the case where we don't have a trust usage
    //  User should still have a chance to invalidate the cert
    //

    if (NULL == pcf->m_rgTrust) {
        if (pcf->m_cParents != 0) {
            return HrPerformUserCheck(pcf->m_rgpcfParents[0], fComplete, pcNodes,
                           iDepth+1, rgpcf);
        }
        *pcNodes = iDepth+1;
        return S_OK;
    }

    //
    //  If trust is really bad -- don't bother asking, just fail
    //

    if (pcf->m_rgTrust[iTrust].fError) {
        return E_FAIL;
    }

    //
    //  See what the trust on this node is, if we explicity trust the node
    //  then ask the user his option on the entire array
    //

    if (pcf->m_rgTrust[iTrust].fExplicitTrust) {
        if (fComplete && (pcf->m_cParents != 0)) {
            HrPerformUserCheck(pcf->m_rgpcfParents[0], fComplete, pcNodes,
                               iDepth+1, rgpcf);
        }
        else {
            //  M00TODO Insert check to the user's function at this point

            //  Found nirvana
            *pcNodes = iDepth+1;
        }
        return S_OK;
    }

    if ((pcf->m_rgTrust[iTrust].fExplicitDistrust) ||
        (pcf->m_rgTrust[iTrust].fDistrust)) {
        if (fComplete && (pcf->m_cParents != 0)) {
            HrPerformUserCheck(pcf->m_rgpcfParents[0], fComplete, pcNodes,
                               iDepth+1, rgpcf);
        }
        else {
            //  I don't think we should be here -- but the result is a NO trust
            //      decision
            *pcNodes = iDepth+1;
        }
        return S_FALSE;
    }

    //
    //  If we get here -- we should have inheritence trust.  Continue
    //  walking up the tree and make sure
    //

    if (pcf->m_cParents == 0) {
        *pcNodes = iDepth+1;
        return S_FALSE;
    }

    // M00BUG -- need to check multliple parents?

    return HrPerformUserCheck(pcf->m_rgpcfParents[0], fComplete, pcNodes,
                              iDepth+1, rgpcf);
}

////    HrDoTrustWork
//
//  Description:
//      This function does the core code of determining if a certificate
//      can be trusted.  This needs to be moved to a WinTrust provider in
//      the near future.
//

HRESULT HrDoTrustWork(PCCERT_CONTEXT pccertToCheck, DWORD dwControl,
                      DWORD dwValidityMask,
                      DWORD cPurposes, LPSTR * rgszPurposes, HCRYPTPROV hprov,
                      DWORD cRoots, HCERTSTORE * rgRoots,
                      DWORD cCAs, HCERTSTORE * rgCAs,
                      DWORD cTrust, HCERTSTORE * rgTrust,
                      PFNTRUSTHELPER /*pfn*/, DWORD /*lCustData*/,
                      PCCertFrame *  ppcf, DWORD * pcNodes,
                      PCCertFrame * rgpcfResult,
                      HANDLE * phReturnStateData)   // optional: return WinVerifyTrust state handle here
{
    DWORD               dwFlags;
    HRESULT             hr;
    HCERTSTORE          hstoreRoot=NULL;
    HCERTSTORE          hstoreTrust=NULL;
    DWORD               i;
    int                 iParent;
    PCCERT_CONTEXT      pccert;
    PCCERT_CONTEXT      pccert2;
    PCCertFrame         pcf;
    PCCertFrame         pcf2;
    PCCertFrame         pcf3;
    PCCertFrame         pcfLeaf = NULL;
    HCERTSTORE          rghcertstore[COtherProviders+30] = {NULL};


    Assert(!phReturnStateData); // How would I support this without the WinVerifyTrust call?
    //
    //   We may need to open some stores at this point.  Check to see if we do
    //  and open new stores as required.
    //

    //  Check for Root stores

    if (cRoots == 0) {
#ifndef WIN16
        hstoreRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                        hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                        L"Root");
#else
        hstoreRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                        hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                        "Root");
#endif // !WIN16
        if (hstoreRoot == NULL) {
            hr = E_FAIL;
            goto ExitHere;
        }
        cRoots = 1;
        rgRoots = &hstoreRoot;
    }

    //  Check for Trust stores

    if (cTrust == 0) {
#ifndef WIN16
        hstoreTrust = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                    hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                    L"Trust");
#else
        hstoreTrust = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                    hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                    "Trust");
#endif // !WIN16
        if (hstoreTrust == NULL) {
            hr = E_FAIL;
            goto ExitHere;
        }
        cTrust = 1;
        rgTrust = &hstoreTrust;
    }

    //  Check for Random CA stores

    for (i=0; i<cCAs; i++) {
        rghcertstore[i] = CertDuplicateStore(rgCAs[i]);
    }

    if ((cCAs == 0) || (dwControl & CM_ADD_CERT_STORES)) {
        for (i=0; i<COtherProviders; i++) {
            rghcertstore[cCAs] = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                     hprov, CERT_SYSTEM_STORE_CURRENT_USER,
                                     RgszProvider[i]);
            if (rghcertstore[cCAs] == NULL) {
                hr = E_FAIL;
                goto ExitHere;
            }
            cCAs += 1;
        }
    }

    rgCAs = rghcertstore;

    //
    //  Find the graph of issuer nodes
    //

    pcfLeaf = new CCertFrame(pccertToCheck);

    if(!pcfLeaf)
    {
        hr=E_OUTOFMEMORY;
        goto ExitHere;
    }

    //
    //  Process every certificate that we found in the ancestor graph
    //

    for (pcf = pcfLeaf; pcf != NULL; pcf = pcf->m_pcfNext) {
        //
        //  Check the time validity on the certificate
        //

        i = CertVerifyTimeValidityWithDelta(NULL, pcf->m_pccert->pCertInfo, TIME_DELTA_SECONDS);
        if (((LONG)i) < 0) {
            pcf->m_dwFlags |= CERT_VALIDITY_BEFORE_START;
        }
        else if (i > 0) {
            pcf->m_dwFlags |= CERT_VALIDITY_AFTER_END;
        }

        //
        //  For Every Certificate Store we are going to search
        //

        for (i=0; i<cCAs+cRoots; i++) {
            pccert2 = NULL;
            do {
                //
                //  Ask the store to find the next cert for us to examine
                //

                dwFlags = (CERT_STORE_SIGNATURE_FLAG |
                           CERT_STORE_REVOCATION_FLAG);
                pccert = CertGetIssuerCertificateFromStore(
                                i < cRoots ? rgRoots[i] : rgCAs[i-cRoots],
                                pcf->m_pccert, pccert2,
                                &dwFlags);

                //
                //  If no cert is found, then we should move to the next store
                //

                if (pccert == NULL) {
                    //  Check to see if this cert was self-signed
                    if (GetLastError() == CRYPT_E_SELF_SIGNED) {
                        pcf->m_fSelfSign = TRUE;
                    }
                    break;
                }

                //
                //  Deterimine all of the failue modes for the certificate
                //      validity.
                //
                //  Start by looking for the ones that WinCrypt gives to
                //      us for free.
                //

                if (dwFlags != 0) {
                    if (dwFlags & CERT_STORE_SIGNATURE_FLAG) {
                        pcf->m_dwFlags |= CERT_VALIDITY_SIGNATURE_FAILS;
                    }
                    if (dwFlags & CERT_STORE_REVOCATION_FLAG) {
                        if (dwFlags & CERT_STORE_NO_CRL_FLAG) {
                            pcf->m_dwFlags |= CERT_VALIDITY_NO_CRL_FOUND;
                        }
                        else {
                            pcf->m_dwFlags |= CERT_VALIDITY_CERTIFICATE_REVOKED;
                        }
                    }
                }

                //
                //  Setup to find the next possible parent, we may continue out
                //      of the loop at a later time
                //

                pccert2 = pccert;

                //
                //  Check to see this cert is already a found parent of the
                //      current node
                //

                for (iParent = 0; iParent < pcf->m_cParents; iParent++) {
                    if (CertCompareCertificate(X509_ASN_ENCODING, pccert->pCertInfo,
                                 pcf->m_rgpcfParents[iParent]->m_pccert->pCertInfo)){
                        break;
                    }
                }

                if (iParent != pcf->m_cParents) {
                    //  Duplicate found -- go to next possible parent
                    continue;
                }

                if (iParent == MaxCertificateParents) {
                    //  To many parents -- go to next possible parent
                    continue;
                }

                //
                //  Build a node to hold the cert we found and shove it onto the
                //      end of the list.  We want to eleminate work so combine
                //      the same nodes if found.
                //

                for (pcf3 = pcf2 = pcfLeaf; pcf2 != NULL;
                     pcf3 = pcf2, pcf2 = pcf2->m_pcfNext) {
                    if (CertCompareCertificate(X509_ASN_ENCODING,
                                               pccert->pCertInfo,
                                               pcf2->m_pccert->pCertInfo)) {
                        break;
                    }
                }
                if (pcf2 == NULL) {
                    pcf3->m_pcfNext = new CCertFrame(pccert);
                    if (pcf3->m_pcfNext == NULL) {
                        //  Out of memory during processing -- do the best one
                        //      can to deal with it.
                        continue;
                    }

                    //
                    //  Add in the parent to the structure
                    //

                    pcf->m_rgpcfParents[pcf->m_cParents++] = pcf3->m_pcfNext;
                    if (i < cRoots) {
                        pcf3->m_pcfNext->m_fRootStore = TRUE;
                    }
                }
            } while (pccert2 != NULL);
        }
    }

    //
    //  Nix off errors the caller wants us to ignore
    //

    for (pcf = pcfLeaf; pcf != NULL; pcf = pcf->m_pcfNext) {
        pcf->m_dwFlags &= dwValidityMask;
    }

    //
    //   Need to check the complete set of validity on all certificates.
    //

    hr = HrCheckValidity(pcfLeaf);
    if (FAILED(hr)) {
        goto ExitHere;
    }

    //
    //  If there are validity problems with the root cert, and we are not
    //  asked to do a compelete check.  We are done and the operation was
    //  not successful.
    //

    if ((pcfLeaf->m_dwFlags != 0) && !(dwControl & CERT_TRUST_DO_FULL_SEARCH)) {
        hr = S_FALSE;
        *ppcf = pcfLeaf;
        pcfLeaf = NULL; // don't want it freed

        // BUGBUG: should we return at least the root in the chain var?
        *pcNodes = 0;
        goto ExitHere;
    }

    //
    //  Ok -- we have the graph of roots, now lets start looking for all of the
    //          different possible trust problems
    //

    if (cPurposes)
        {
        CTL_VERIFY_USAGE_PARA       vup;
        memset(&vup, 0, sizeof(vup));
        vup.cbSize = sizeof(vup);
        vup.cCtlStore = cTrust;
        vup.rghCtlStore = rgTrust;          // "TRUST"
        vup.cSignerStore = cRoots;
        vup.rghSignerStore = rgRoots;       // "Roots"

        CTL_VERIFY_USAGE_STATUS     vus;
        PCCTL_CONTEXT               pctlTrust;

        pctlTrust = NULL;

        memset(&vus, 0, sizeof(vus));
        vus.cbSize = sizeof(vus);
        vus.ppCtl = &pctlTrust;

        for (i=0; i<cPurposes; i++) {
            CTL_USAGE       ctlusage;
            BOOL            f;

            ctlusage.cUsageIdentifier = 1;
            ctlusage.rgpszUsageIdentifier = &rgszPurposes[i];

            for (pcf = pcfLeaf; pcf != NULL; pcf = pcf->m_pcfNext) {
                if (pcf->m_rgTrust == NULL) {
                    pcf->m_rgTrust = new STrustDesc[cPurposes];
                    if (pcf->m_rgTrust == NULL) {
                        continue;
                    }
                    memset(pcf->m_rgTrust, 0, cPurposes * sizeof(STrustDesc));
                }

                if (pcf->m_fRootStore) {
                    continue;
                }

                f = CertVerifyCTLUsage(X509_ASN_ENCODING, CTL_CERT_SUBJECT_TYPE,
                                       (LPVOID) pcf->m_pccert, &ctlusage,
                                       CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG |
                                       CERT_VERIFY_NO_TIME_CHECK_FLAG |
                                       CERT_VERIFY_TRUSTED_SIGNERS_FLAG, &vup, &vus);
                if (f) {
                    PCTL_ENTRY      pentry;
                    pentry = &pctlTrust->pCtlInfo->rgCTLEntry[vus.dwCtlEntryIndex];
                    pcf->m_rgTrust[i].szOid = _strdup(pentry->rgAttribute[0].pszObjId);
                    // Assert(pentry->rgAttribute[0].cAttr == 1);
                    pcf->m_rgTrust[i].cbTrustData =
                        pentry->rgAttribute[0].rgValue[0].cbData;
                    pcf->m_rgTrust[i].pbTrustData =
                        (LPBYTE) malloc(pcf->m_rgTrust[i].cbTrustData);
                    memcpy(pcf->m_rgTrust[i].pbTrustData,
                           pentry->rgAttribute[0].rgValue[0].pbData,
                           pentry->rgAttribute[0].rgValue[0].cbData);
                }
            }
        }

        //
        //  We have all of the data needed to make a trust decision.  See if we
        //  do trust
        //

        if (cPurposes == 1) {
            hr = HrCheckTrust(pcfLeaf, 0);
            if (FAILED(hr)) {
                goto ExitHere;
            }
            if ((hr == S_FALSE) && !(dwControl & CERT_TRUST_DO_FULL_SEARCH)) {
                *pcNodes = 0;
                pcfLeaf->m_dwFlags |= (CERT_VALIDITY_NO_TRUST_DATA & dwValidityMask);
                *ppcf = pcfLeaf;
                pcfLeaf = NULL;
                goto ExitHere;
            }
        }
        else {
            for (i=0; i<cPurposes; i++) {
                HrCheckTrust(pcfLeaf, i);
            }
        }
    }

    //
    //  Now let the user have his crack at the tree and build the final
    //  trust path at the same time.  If the user did not provide a check
    //  function then all certs are acceptable
    //

    hr = HrPerformUserCheck(pcfLeaf, TRUE, pcNodes, 0, rgpcfResult);
    if (FAILED(hr)) {
        goto ExitHere;
    }

    *ppcf = pcfLeaf;
    pcfLeaf = NULL;

    //
    //  We jump here on a failure and fall in on success.  Clean up the items we
    //  have created.
    //

ExitHere:
    if (hstoreRoot && rgRoots == &hstoreRoot) {
        CertCloseStore(hstoreRoot, 0);
    }

    if (hstoreTrust && rgTrust == &hstoreTrust) {
        CertCloseStore(hstoreTrust, 0);
    }

    if (rgCAs == rghcertstore) {
        for (i=0; i<cCAs; i++) {
            if (rgCAs[i] != NULL) {
                CertCloseStore(rgCAs[i], 0);
            }
        }
    }

    if (pcfLeaf != NULL) {
        delete pcfLeaf;
    }

    return hr;
}




////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
//   TRUST PROVIDER INTERFACE
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

VOID ClientUnload(LPVOID /*pTrustProviderInfo*/)
{
    ;
}

VOID SubmitCertificate(LPWIN_CERTIFICATE /*pCert*/)
{
    ;
}

////    VerifyTrust
//
//  Description:
//      This is the core program in a trust system.
//

HRESULT WINAPI VerifyTrust(HWND /*hwnd*/, GUID * pguid, LPVOID pv)
{
    DWORD                       cFrames;
    HRESULT                     hr;
    DWORD                       i;
    PCCertFrame                 pcfLeaf = NULL;
    PCERT_VERIFY_CERTIFICATE_TRUST  pinfo = (PCERT_VERIFY_CERTIFICATE_TRUST) pv;
    DWORD *                     rgdwErrors = NULL;
    LPBYTE *                    rgpbTrust = NULL;
    PCCERT_CONTEXT *            rgpccert = NULL;
    PCCertFrame                 rgpcf[20];

    //
    //  Ensuer that we got called appropriately for our data
    //

    if (memcmp(pguid, &GuidCertValidate, sizeof(GuidCertValidate)) != 0) {
        return E_FAIL;
    }

    //
    //  Make sure we have some data to play with
    //

    if ((pinfo->cbSize != sizeof(*pinfo)) || (pinfo->pccert == NULL)) {
        return E_INVALIDARG;
    }

    //
    //  Call the core trust routine to do all of the intersting work
    //

    hr = HrDoTrustWork(pinfo->pccert, pinfo->dwFlags, ~(pinfo->dwIgnoreErr),
                       (pinfo->pszUsageOid != NULL ? 1 : 0),
                       &pinfo->pszUsageOid, pinfo->hprov,
                       pinfo->cRootStores, pinfo->rghstoreRoots,
                       pinfo->cStores, pinfo->rghstoreCAs,
                       pinfo->cTrustStores, pinfo->rghstoreTrust,
                       pinfo->pfnTrustHelper, pinfo->lCustData, &pcfLeaf,
                       &cFrames, rgpcf, NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  We succeeded in getting some type of answer from the trust system, so
    //  format and return answers if any are requested.
    //

    if (pinfo->pdwErrors != NULL) {
        *pinfo->pdwErrors = pcfLeaf->m_dwFlags;
    }

    if (pinfo->pcChain != NULL) {
        *pinfo->pcChain = cFrames;
    }

    if (pinfo->prgChain != NULL) {
        rgpccert = (PCCERT_CONTEXT*) LocalAlloc(LMEM_FIXED,
                                                cFrames * sizeof(PCCERT_CONTEXT));
        if (rgpccert == NULL) {
            hr = E_OUTOFMEMORY;
            goto ExitHere;
        }

        for (i=0; i<cFrames; i++) {
            rgpccert[i] = CertDuplicateCertificateContext(rgpcf[i]->m_pccert);
        }
    }

    if (pinfo->prgdwErrors != NULL) {
        rgdwErrors = (DWORD *) LocalAlloc(LMEM_FIXED,
                                         (*pinfo->pcChain)*sizeof(DWORD));
        if (rgdwErrors == NULL) {
            hr = E_OUTOFMEMORY;
            goto ExitHere;
        }

        for (i=0; i<cFrames; i++) {
            rgdwErrors[i] = rgpcf[i]->m_dwFlags;
        }
    }

    if (pinfo->prgpbTrustInfo != NULL) {
        rgpbTrust = (LPBYTE *) LocalAlloc(LMEM_FIXED,
                                          (*pinfo->pcChain)*sizeof(LPBYTE));
        if (rgpbTrust == NULL) {
            hr = E_OUTOFMEMORY;
            goto ExitHere;
        }

        rgpbTrust[0] = NULL;
    }

ExitHere:
    if (FAILED(hr)) {
#ifndef WIN16
        if (rgpccert != NULL) LocalFree(rgpccert);
        if (rgpbTrust != NULL) LocalFree(rgpbTrust);
        if (rgdwErrors != NULL) LocalFree(rgdwErrors);
#else
        if (rgpccert != NULL) LocalFree((HLOCAL)rgpccert);
        if (rgpbTrust != NULL) LocalFree((HLOCAL)rgpbTrust);
        if (rgdwErrors != NULL) LocalFree((HLOCAL)rgdwErrors);
#endif // !WIN16
    }
    else {
        if (rgpccert != NULL) *pinfo->prgChain = rgpccert;
        if (rgdwErrors != NULL) *pinfo->prgdwErrors = rgdwErrors;
        if (rgpbTrust != NULL) *pinfo->prgpbTrustInfo = (DATA_BLOB *) rgpbTrust;
    }

    delete pcfLeaf;

    return hr;
}

extern const GUID rgguidActions[];

#if !defined(WIN16) && !defined(MAC)
WINTRUST_PROVIDER_CLIENT_SERVICES WinTrustProviderClientServices = {
    ClientUnload, VerifyTrust, SubmitCertificate
};

const WINTRUST_PROVIDER_CLIENT_INFO ProvInfo = {
    WIN_TRUST_REVISION_1_0, &WinTrustProviderClientServices,
    1, (GUID *) &GuidCertValidate
};

////    WinTrustProviderClientInitialize
//
//  Description:
//      Client initialization routine.  Called by WinTrust when the dll
//      is loaded.
//
//  Parameters:
//      dwWinTrustRevision - Provides revision information
//      lpWinTrustInfo - Provides a list of services available to the
//                      trust provider from WinTrust
//      lpProvidername - Supplies a null terminated string representing the
//                      provider's name.  Shouldb passed back to WinTrust
//                      when required without modification.
//      lpTrustProviderInfo - Used to return trust provider information.
//
//  Returns:
//      TRUE on success and FALSE on failure.  Must set last error on failure.
//

BOOL WINAPI WinTrustProviderClientInitialize(DWORD /*dwWinTrustRevision*/,
                                LPWINTRUST_CLIENT_TP_INFO /*pWinTrustInfo*/,
                                LPWSTR /*lpProviderName*/,
                                LPWINTRUST_PROVIDER_CLIENT_INFO * ppTrustProvInfo)
{
    *ppTrustProvInfo = (LPWINTRUST_PROVIDER_CLIENT_INFO) &ProvInfo;
    return TRUE;
}
#endif // !WIN16 && !MAC
#endif // NT5BUILD

LPWSTR FormatValidityFailures(DWORD dwFlags)
{
    DWORD       cch = 0;
    LPWSTR      pwsz = NULL;
    WCHAR       rgwch[200];

    if (dwFlags == 0) {
        return NULL;
    }

    pwsz = (LPWSTR) malloc(100);
    cch = 100;
    if (pwsz == NULL) {
        return NULL;
    }
    if (dwFlags & CERT_VALIDITY_BEFORE_START) {
        LoadString(HinstDll, IDS_WHY_NOT_YET, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        wcscpy(pwsz, rgwch);
    } else {
        wcscpy(pwsz, L"");
    }

    if (dwFlags & CERT_VALIDITY_AFTER_END) {
        LoadString(HinstDll, IDS_WHY_EXPIRED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_SIGNATURE_FAILS) {
        LoadString(HinstDll, IDS_WHY_CERT_SIG, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
        LoadString(HinstDll, IDS_WHY_NO_PARENT, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_NO_CRL_FOUND) {
        LoadString(HinstDll, IDS_WHY_NO_CRL, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_CERTIFICATE_REVOKED) {
        LoadString(HinstDll, IDS_WHY_REVOKED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_CRL_OUT_OF_DATE) {
        LoadString(HinstDll, IDS_WHY_CRL_EXPIRED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_KEY_USAGE_EXT_FAILURE) {
        LoadString(HinstDll, IDS_WHY_KEY_USAGE, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_EXTENDED_USAGE_FAILURE) {
        LoadString(HinstDll, IDS_WHY_EXTEND_USE, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE) {
        LoadString(HinstDll, IDS_WHY_NAME_CONST, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION) {
        LoadString(HinstDll, IDS_WHY_CRITICAL_EXT, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwsz = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwsz == NULL) {
                return pwsz;
            }
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    return pwsz;
}

//////////////////////////////////////////////////////////////////////////////////


HRESULT CTLModifyHelper(int cCertsToModify, PCTL_MODIFY_REQUEST rgCertMods,
                                      LPCSTR szPurpose, HWND /*hwnd*/,
                                      HCERTSTORE hcertstorTrust,
                                      PCCERT_CONTEXT pccertSigner)
{
    DWORD               cb;
    DWORD               cbData;
    DWORD               cbOut;
    CTL_INFO            ctlInfo;
    CTL_USAGE           ctlUsage;
    DWORD               dwOne = 1;
    HCRYPTPROV          hprov = NULL;
    HRESULT             hr = S_OK;
    DWORD               i;
    int                 iCert;
    LPBYTE              pbEncode = NULL;
    LPBYTE              pbHash;
    PCCTL_CONTEXT       pcctl = NULL;
    PCRYPT_KEY_PROV_INFO pprovinfo = NULL;
    CTL_ENTRY *         rgctlEntry = NULL;

    //
    //  Build the attributes blob which says that we actually trust/distrust a certificate.
    //

    CRYPT_ATTRIBUTE         attributeYes;
    CRYPT_ATTR_BLOB         attrBlobYes;
    CRYPT_ATTRIBUTE         attributeNo;
    CRYPT_ATTR_BLOB         attrBlobNo;
    CRYPT_ATTRIBUTE         attributeParent;
    CRYPT_ATTR_BLOB         attrBlobParent;

    attributeYes.pszObjId = (LPSTR) SzOID_CTL_ATTR_YESNO_TRUST;
    attributeYes.cValue = 1;
    attributeYes.rgValue = &attrBlobYes;

    attrBlobYes.cbData = sizeof(RgbTrustYes);                // MUST BE ASN
    attrBlobYes.pbData = (LPBYTE) RgbTrustYes;

    attributeNo.pszObjId = (LPSTR) SzOID_CTL_ATTR_YESNO_TRUST;
    attributeNo.cValue = 1;
    attributeNo.rgValue = &attrBlobNo;

    attrBlobNo.cbData = sizeof(RgbTrustNo);                // MUST BE ASN
    attrBlobNo.pbData = (LPBYTE) RgbTrustNo;

    attributeParent.pszObjId = (LPSTR) SzOID_CTL_ATTR_YESNO_TRUST;
    attributeParent.cValue = 1;
    attributeParent.rgValue = &attrBlobParent;

    attrBlobParent.cbData = sizeof(RgbTrustParent);        // MUST BE ASN
    attrBlobParent.pbData = (LPBYTE) RgbTrustParent;

    //
    //  Get the crypt provider for the certificate we are going to use in the trust
    //

    if (!CertGetCertificateContextProperty(pccertSigner, CERT_KEY_PROV_INFO_PROP_ID,
                                           NULL, &cbData)) {
        hr = E_FAIL;
        goto Exit;
    }

    pprovinfo = (PCRYPT_KEY_PROV_INFO) malloc(cbData);
    CertGetCertificateContextProperty(pccertSigner, CERT_KEY_PROV_INFO_PROP_ID,
                                      pprovinfo, &cbData);

    if (!CryptAcquireContextW(&hprov, pprovinfo->pwszContainerName,
                              pprovinfo->pwszProvName,
                              pprovinfo->dwProvType, 0)) {
        hr = GetLastError();
        goto Exit;
    }

    //
    //  We have a certificate and a provider to use for signing purposes.
    //  Look for a possible CTL to be emended by us.
    //

    //
    //  Search for a CTL signed by this cert and for the requested usage
    //

    CTL_FIND_USAGE_PARA         ctlFind;
    ctlFind.cbSize = sizeof(ctlFind);
    ctlFind.SubjectUsage.cUsageIdentifier = 1;
    ctlFind.SubjectUsage.rgpszUsageIdentifier = (LPSTR *) &szPurpose;
    ctlFind.ListIdentifier.cbData = 0;
    ctlFind.ListIdentifier.pbData = 0;
    ctlFind.pSigner = pccertSigner->pCertInfo;

    pcctl = CertFindCTLInStore(hcertstorTrust, X509_ASN_ENCODING, 0,
                               CTL_FIND_USAGE, &ctlFind, NULL);
    if (pcctl == NULL) {
        //
        //  No CTL currently exists, so build one from scratch
        //

        //
        //  Allocate space to hold the CTL entries
        //
        //      size = (sizeof CTL_ENTRY + sizeof of SHA1 hash) * # certs to add
        //

        cb = cCertsToModify * (sizeof(CTL_ENTRY) + 20);
        rgctlEntry = (PCTL_ENTRY) malloc(cb);
        memset(rgctlEntry, 0, cb);
        pbHash = ((LPBYTE) rgctlEntry) + (cCertsToModify * sizeof(CTL_ENTRY));

        //
        //  Get the identifier for each of the certs and setup the Trust List
        //      entry for each of the certs.  Note that they all point
        //      to the same attribute, this is possible since we are going to
        //      have the exact same amount of trust on each cert -- YES!!!! --
        //

        for (iCert = 0; iCert < cCertsToModify; iCert++, pbHash += 20) {
            rgctlEntry[iCert].SubjectIdentifier.cbData = 20;
            rgctlEntry[iCert].SubjectIdentifier.pbData = pbHash;
            rgctlEntry[iCert].cAttribute = 1;

            cb = 20;
            CertGetCertificateContextProperty(rgCertMods[iCert].pccert,
                                              CERT_SHA1_HASH_PROP_ID, pbHash, &cb);
            rgCertMods[iCert].dwError = 0;

            switch (rgCertMods[iCert].dwOperation) {
            case CTL_MODIFY_REQUEST_ADD_TRUSTED:
                rgctlEntry[iCert].rgAttribute = &attributeYes;
                break;

            case CTL_MODIFY_REQUEST_REMOVE:
                rgctlEntry[iCert].rgAttribute = &attributeParent;
                break;

            case CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED:
                rgctlEntry[iCert].rgAttribute = &attributeNo;
                break;

            default:
                rgCertMods[iCert].dwError = (DWORD) E_FAIL;
                iCert -= 1;             // Don't include this one
                break;
            }

        }

        //
        //  Now setup the the overall structure of the Trust List for later
        //      encoding and signing.
        //

        ctlUsage.cUsageIdentifier = 1;
        ctlUsage.rgpszUsageIdentifier = (LPSTR *) &szPurpose;

        memset(&ctlInfo, 0, sizeof(ctlInfo));
        ctlInfo.dwVersion = 0;
        ctlInfo.SubjectUsage = ctlUsage;
        // ctlInfo.ListIdentifier = 0;
        ctlInfo.SequenceNumber.cbData = sizeof(dwOne);
        ctlInfo.SequenceNumber.pbData = (LPBYTE) &dwOne;
        GetSystemTimeAsFileTime(&ctlInfo.ThisUpdate);
        // ctlInfo.NextUpdate = 0;
        ctlInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;
        // ctlInfo.SubjectAlgorithm.Parameters.cbData = 0;
        ctlInfo.cCTLEntry = cCertsToModify;
        ctlInfo.rgCTLEntry = rgctlEntry;
        // ctlInfo.cExtension = 0;
        // ctlInfo.rgExtension = NULL;

    }
    else {
        BOOL    fRewrite;

        memcpy(&ctlInfo, pcctl->pCtlInfo, sizeof(ctlInfo));

        //
        //  We found a CTL with the right usage, now lets see if we need to add
        //      certificate to it.
        //
        //  Start by assuming that we will need to add to the CTL so allocate
        //      space to hold the new set of Trust Entries
        //

        cb = (pcctl->pCtlInfo->cCTLEntry * sizeof(CTL_ENTRY) +
              cCertsToModify * (sizeof(CTL_ENTRY) + 20));
        rgctlEntry = (PCTL_ENTRY) malloc(cb);
        memset(rgctlEntry, 0, cb);
        pbHash = (((LPBYTE) rgctlEntry) +
                  (cCertsToModify + pcctl->pCtlInfo->cCTLEntry) * sizeof(CTL_ENTRY));
        memcpy(rgctlEntry, pcctl->pCtlInfo->rgCTLEntry,
               pcctl->pCtlInfo->cCTLEntry * sizeof(CTL_ENTRY));
        ctlInfo.rgCTLEntry = rgctlEntry;

        //
        //  For each certificate, see if the certificate is already in the list
        //      and append it to the end if it isn't
        //

        fRewrite = FALSE;
        for (iCert = 0; iCert < cCertsToModify; iCert++) {
            rgCertMods[iCert].dwError = 0;

            cb = 20;
            CertGetCertificateContextProperty(rgCertMods[iCert].pccert,
                                              CERT_SHA1_HASH_PROP_ID, pbHash, &cb);

            for (i=0; i<pcctl->pCtlInfo->cCTLEntry; i++) {
                if (memcmp(pbHash, rgctlEntry[i].SubjectIdentifier.pbData, 20) == 0){
                    break;
                }
            }

            //
            //  If we did not find a matching item, then add a new one to the
            //  end of the list
            //
            if (i == pcctl->pCtlInfo->cCTLEntry) {
                rgctlEntry[i].SubjectIdentifier.cbData = 20;
                rgctlEntry[i].SubjectIdentifier.pbData = pbHash;
                rgctlEntry[i].cAttribute = 1;

                pbHash += 20;
                ctlInfo.cCTLEntry += 1;
                fRewrite = TRUE;


                switch (rgCertMods[iCert].dwOperation) {
                case CTL_MODIFY_REQUEST_ADD_TRUSTED:
                    rgctlEntry[i].rgAttribute = &attributeYes;
                    break;

                case CTL_MODIFY_REQUEST_REMOVE:
                    rgctlEntry[i].rgAttribute = &attributeParent;
                    break;

                case CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED:
                    rgctlEntry[i].rgAttribute = &attributeNo;
                    break;

                default:
                    rgCertMods[i].dwError = (DWORD) E_FAIL;
                    ctlInfo.cCTLEntry -= 1;           // Don't include this one
                    break;
                }
            }
            //
            //  If we did find a matching, then put the new attribute into the
            //  list (may replace trust with distrust)
            //
            else {
                switch (rgCertMods[iCert].dwOperation) {
                case CTL_MODIFY_REQUEST_ADD_TRUSTED:
                    rgctlEntry[i].rgAttribute = &attributeYes;
                    break;

                case CTL_MODIFY_REQUEST_REMOVE:
                    rgctlEntry[i].rgAttribute = &attributeParent;
                    break;

                default:
                case CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED:
                    rgctlEntry[i].rgAttribute = &attributeNo;
                    break;
                }
                fRewrite = TRUE;
            }
        }

        //
        //  Nothing to be added at this time -- exit and say success
        //

        if (!fRewrite) {
            hr = S_OK;
            goto Exit;
        }

        //
        //   Increment the sequence number
        //
        // M00MAC -- this may be cheating, however I think that we can use it
        //      one the mac without change, I don't really care that the sequence
        //      is understandable at this point, as long as it does sequence.
        //

        dwOne = 0;
        memcpy(&dwOne, ctlInfo.SequenceNumber.pbData,
               ctlInfo.SequenceNumber.cbData);
        dwOne += 1;

        ctlInfo.SequenceNumber.cbData = sizeof(dwOne);
        ctlInfo.SequenceNumber.pbData = (LPBYTE) &dwOne;
    }

    //
    //  OK --- We have the basic information built up for a Cert Trust List,
    //  now we just need to encode and sign the blasted thing
    //

    CMSG_SIGNER_ENCODE_INFO signer1;
    memset(&signer1, 0, sizeof(signer1));
    signer1.cbSize = sizeof(signer1);
    signer1.pCertInfo = pccertSigner->pCertInfo;
    signer1.hCryptProv = hprov;
    signer1.dwKeySpec = AT_SIGNATURE;
    signer1.HashAlgorithm.pszObjId = szOID_OIWSEC_sha1;
    // signer1.HashAlgorithm.Parameters.cbData = 0;
    // signer1.pvHashAuxInfo = 0;
    // signer1.cAuthAttrib = 0;
    // signer1.cUnauthAttr = 0;

    CMSG_SIGNED_ENCODE_INFO signinfo;
    memset(&signinfo, 0, sizeof(signinfo));
    signinfo.cbSize = sizeof(signinfo);
    signinfo.cSigners = 1;
    signinfo.rgSigners = &signer1;
    signinfo.cCertEncoded = 0;
    signinfo.cCrlEncoded = 0;

    if (!CryptMsgEncodeAndSignCTL(PKCS_7_ASN_ENCODING, &ctlInfo, &signinfo,
                                  0, NULL, &cbOut)) {
        hr = GetLastError();
        goto Exit;
    }

    pbEncode = (LPBYTE) malloc(cbOut);
    if (!CryptMsgEncodeAndSignCTL(PKCS_7_ASN_ENCODING, &ctlInfo, &signinfo,
                                  0, pbEncode, &cbOut)) {
        hr = GetLastError();
        goto Exit;
    }

    //
    // Now put it into the trust store
    //

    if (!CertAddEncodedCTLToStore(hcertstorTrust, PKCS_7_ASN_ENCODING,
                                  pbEncode, cbOut,
                                  CERT_STORE_ADD_REPLACE_EXISTING, NULL)) {
        //
        // If we fail, and we in debug mode then create an output file so
        //      we can figure out what we did wrong.
        //

#ifdef DEBUG
        HANDLE      hfile;

        hfile = CreateFileA("c:\\output.t", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                            0, 0);
        WriteFile(hfile, pbEncode, cbOut, &cb, NULL);
        CloseHandle(hfile);
#endif // DEBUG

        hr = GetLastError();
        goto Exit;
    }

    //
    //  We succeeded in the operation
    //

    hr = S_OK;

    //
    //  A single point of clean up and exit for everything.
    //
Exit:
    if (rgctlEntry != NULL) free(rgctlEntry);
    if (pprovinfo != NULL) free(pprovinfo);
    if (pcctl != NULL) CertFreeCTLContext(pcctl);
    if (pbEncode != NULL) free(pbEncode);
    if (hprov != NULL) CryptReleaseContext(hprov, 0);

    if (SUCCEEDED(hr) && (hr != S_OK)) hr = E_FAIL;
    return hr;
}

PCCERT_CONTEXT CreateTrustSigningCert(HWND hwnd, HCERTSTORE hcertstoreRoot,
                                      BOOL fDialog)
{
    BYTE                bSerialNumber = 1;
    DWORD               cb;
    CERT_INFO           certInfo;
    DWORD               dw;
    HCRYPTKEY           hkey;
    HCRYPTPROV          hprov = NULL;
    HRESULT             hr = S_OK;
    CERT_NAME_BLOB      nameblob = {0, NULL};
    LPBYTE              pbEncode = NULL;
    PCCERT_CONTEXT      pccert = NULL;
    PCERT_PUBLIC_KEY_INFO pkeyinfo = NULL;
    CRYPT_KEY_PROV_INFO provinfo;
    LPSTR               psz;
    char                rgchTitle[256];
    char                rgchMsg[256];
    char                rgch[256];
    char                rgch1[256];
    char                rgch2[256];
    CERT_EXTENSION      rgExt[1] = {0};
    SYSTEMTIME          st;


    //
    //  We always use RSA base for this purpose.  We should never run
    //  across a system where rsabase does not exist.
    //
    //  We assume that we need to create a new keyset and fallback to
    //  openning the existing keyset in the event that it already exists
    //

    if (!CryptAcquireContextA(&hprov, SzTrustListSigner, NULL, PROV_RSA_FULL, 0)) {
        hr = GetLastError();
        if ((hr != NTE_NOT_FOUND) && (hr != NTE_BAD_KEYSET)) {
            goto ExitHere;
        }
        hr = S_OK;
        if (!CryptAcquireContextA(&hprov, SzTrustListSigner, NULL, PROV_RSA_FULL,
                                  CRYPT_NEWKEYSET)) {
            hr = GetLastError();
            goto ExitHere;
        }
    }

    //
    //  Now we need to create the signing key in the keyset.  Again
    //  we assume that we just created the keyset so we attempt to create
    //  the key in all cases.  Note we don't need to open the key in the
    //  event we fail to create it as we never directly use it.
    //
    //  Since we want security.  We first try for a 1024-bit key before
    //  using the default (usually 512-bit) size.
    //

    if (!CryptGetUserKey(hprov, AT_SIGNATURE, &hkey)) {
        dw = MAKELONG(0, 1024);
    retry_keygen:
        if (!CryptGenKey(hprov, AT_SIGNATURE, 0, &hkey)) {
#ifndef WIN16
            hr = ::GetLastError();
#else
            hr = GetLastError();
#endif // !WIN16
            if ((hr == ERROR_INVALID_PARAMETER) && (dw != 0)) {
                dw = 0;
                goto retry_keygen;
            }
            if (hr != NTE_EXISTS) {
                goto ExitHere;
            }
        }
    }
    CryptDestroyKey(hkey);

    //
    //  Now we need to create a certificate which corresponds to the
    //  signing key we just created.
    //
    //  Start by creating the DN to be stored in the certificate.  The
    //  DN we are going to use is of the following format.
    //
    //  cn=<machine name>/cn=Trust List Signer/cn=<user name>
    //
    //  We make the simplifying assumption that neither machine names
    //  or user names can contain commas.
    //

    dw = sizeof(rgch1);
    GetUserNameA(rgch1, &dw);
    dw = sizeof(rgch2);
    GetComputerNameA(rgch2, &dw);
    sprintf(rgch, SzTrustDN, rgch2, rgch1);

    if (!CertStrToNameA(X509_ASN_ENCODING, rgch,
                        CERT_X500_NAME_STR | CERT_NAME_STR_COMMA_FLAG, NULL,
                        NULL, &cb, NULL)) {
        hr = E_FAIL;
        goto ExitHere;
    }

    nameblob.pbData = (LPBYTE) malloc(cb);
    nameblob.cbData = cb;
    CertStrToNameA(X509_ASN_ENCODING, rgch,
                   CERT_X500_NAME_STR | CERT_NAME_STR_COMMA_FLAG, NULL,
                   nameblob.pbData, &nameblob.cbData, NULL);

    //
    //  Extract the public portion of the signing key and ASN encode it
    //

    if (!CryptExportPublicKeyInfo(hprov, AT_SIGNATURE, X509_ASN_ENCODING,
                                  NULL, &cb)) {
        goto ExitHere;
    }
    pkeyinfo = (PCERT_PUBLIC_KEY_INFO) malloc(cb);
    if (!CryptExportPublicKeyInfo(hprov, AT_SIGNATURE, X509_ASN_ENCODING,
                                  pkeyinfo, &cb)) {
        goto ExitHere;
    }

    //
    //  We are going to sign the certificate using SHA-1/RSA
    //

    CRYPT_ALGORITHM_IDENTIFIER      sigalg;
    memset(&sigalg, 0, sizeof(sigalg));
    sigalg.pszObjId = szOID_OIWSEC_sha1RSASign;
    // sigalg.Parameters.cbData = 0;
    // sigalg.Parameters.pbData = NULL;

    //
    //  We are putting one critical section on the extension. Enhanced
    //  key usage is CTL signing.  Note that this is the only use that
    //  we are going to allow for this key.
    //

    rgExt[0].pszObjId = szOID_ENHANCED_KEY_USAGE;
    rgExt[0].fCritical = TRUE;

    CTL_USAGE       ctlUsage2;
    ctlUsage2.cUsageIdentifier = 1;
    ctlUsage2.rgpszUsageIdentifier = &psz;
    psz = (LPSTR) SzOID_KP_CTL_USAGE_SIGNING;

    CryptEncodeObject(X509_ASN_ENCODING, X509_ENHANCED_KEY_USAGE, &ctlUsage2,
                      NULL, &cb);
    rgExt[0].Value.pbData = (LPBYTE) malloc(cb);
    rgExt[0].Value.cbData = cb;
    CryptEncodeObject(X509_ASN_ENCODING, X509_ENHANCED_KEY_USAGE, &ctlUsage2,
                      rgExt[0].Value.pbData, &rgExt[0].Value.cbData);


    //
    //  Now we can setup the rest of the certifiate information and
    //  encode it.
    //

    memset(&certInfo, 0, sizeof(certInfo));
    // certInfo.dwVersion = 0;
    certInfo.SerialNumber.cbData = 1;
    certInfo.SerialNumber.pbData = &bSerialNumber;
    certInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;
    // certInfo.SignatureAlgorithm.Parameter.cbData = 0;
    // certInfo.SignatureAlgorithm.Parameter.pbData = NULL;
    certInfo.Issuer = nameblob;
    GetSystemTimeAsFileTime(&certInfo.NotBefore);
    //    certInfo.NotAfter = certInfo.NotBefore;
    // M00BUG -- must increase the NotAfter date by some amount.
    FileTimeToSystemTime(&certInfo.NotBefore, &st);
    st.wYear += 50;
    SystemTimeToFileTime(&st, &certInfo.NotAfter);
    certInfo.Subject = nameblob;
    certInfo.SubjectPublicKeyInfo = *pkeyinfo;
    // certInfo.IssuerUniqueId = ;
    // certInfo.SubjectUniqueId = ;
    certInfo.cExtension = 1;
    certInfo.rgExtension = rgExt;

    if (!CryptSignAndEncodeCertificate(hprov, AT_SIGNATURE,
                                       X509_ASN_ENCODING,
                                       X509_CERT_TO_BE_SIGNED, &certInfo,
                                       &sigalg, NULL, NULL, &cb)) {
#ifndef WIN16
        hr = ::GetLastError();
#else
        hr = GetLastError();
#endif // !WIN16
        goto ExitHere;
    }

    pbEncode = (LPBYTE) malloc(cb);
    if (!CryptSignAndEncodeCertificate(hprov, AT_SIGNATURE,
                                       X509_ASN_ENCODING,
                                       X509_CERT_TO_BE_SIGNED, &certInfo,
                                       &sigalg, NULL, pbEncode, &cb)) {
#ifndef WIN16
        hr = ::GetLastError();
#else
        hr = GetLastError();
#endif // !WIN16
        goto ExitHere;
    }

    //
    //  M00TODO Print the GOD IS ABOUT TO STRIKE message
    //

    if (fDialog) {
        LoadStringA(HinstDll, IDS_ROOT_ADD_STRING, rgchMsg,
                    sizeof(rgchMsg)/sizeof(rgchMsg[0]));
        LoadStringA(HinstDll, IDS_ROOT_ADD_TITLE, rgchTitle,
                    sizeof(rgchTitle)/sizeof(rgchTitle[0]));
        MessageBoxA(hwnd, rgchMsg, rgchTitle, MB_APPLMODAL | MB_OK |
                    MB_ICONINFORMATION);
    }

    //
    //  Now we have warned the user, save our new cert in the root store
    //

    if (!CertAddEncodedCertificateToStore(hcertstoreRoot, X509_ASN_ENCODING,
                                          pbEncode, cb,
                                          CERT_STORE_ADD_REPLACE_EXISTING,
                                          &pccert)) {
#ifndef WIN16
        hr = ::GetLastError();
#else
        hr = GetLastError();
#endif // !WIN16
        goto ExitHere;
    }

    //
    //  Set the key-info property on the store so we can reference it later
    //

    memset(&provinfo, 0, sizeof(provinfo));
#ifndef WIN16
    provinfo.pwszContainerName = L"Trust List Signer";
#else
    provinfo.pwszContainerName = "Trust List Signer";
#endif // !WIN16
    // provinfo.pwszProvName = NULL;
    provinfo.dwProvType = PROV_RSA_FULL;
    // provinfo.dwFlags = 0;
    // provinfo.cProvParam = 0;
    provinfo.dwKeySpec = AT_SIGNATURE;

    CertSetCertificateContextProperty(pccert, CERT_KEY_PROV_INFO_PROP_ID,
                                      0, &provinfo);

ExitHere:
    if (hprov != NULL) CryptReleaseContext(hprov, 0);
    if (nameblob.pbData != NULL) free(nameblob.pbData);
    if (pkeyinfo != NULL) free(pkeyinfo);
    if (rgExt[0].Value.pbData != NULL) free(rgExt[0].Value.pbData);
    if (pbEncode != NULL) free(pbEncode);
    if (FAILED(hr) && (pccert != NULL)) {
        CertFreeCertificateContext(pccert);
        pccert = NULL;
    }
    return pccert;
}


////    CertModifyCertificatesToTrust
//
//  Description:
//      This routine is used to build the Certificate Trust List for
//      a purpose.  It is possible that we will need to create the root
//      signing key for this.
//

HRESULT CertModifyCertificatesToTrust(int cCertsToModify, PCTL_MODIFY_REQUEST rgCertMods,
                                      LPCSTR szPurpose, HWND hwnd, HCERTSTORE hcertstorTrust,
                                      PCCERT_CONTEXT pccertSigner)
{
    HCERTSTORE          hcertstorRoot = NULL;
    HRESULT     hr = E_FAIL;
    int         i;

    //
    // Some quick parameter checking
    //

    if (szPurpose == NULL) {
        return E_INVALIDARG;
    }

    //
    //  Add a reference to the cert store, so we can just release it on exit.
    //

    if (hcertstorTrust != NULL) {
        CertDuplicateStore(hcertstorTrust);
    }
    if (pccertSigner != NULL) {
        CertDuplicateCertificateContext(pccertSigner);
    }

    //
    //  Open a trust store if we don't have one yet.
    //

    if (hcertstorTrust == NULL) {
#ifndef WIN16
        hcertstorTrust = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                       NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                       L"Trust");
#else
        hcertstorTrust = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                       NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                       "Trust");
#endif // !WIN16
        if (hcertstorTrust == NULL) {
            hr = GetLastError();
            goto ExitHere;
        }
    }

    //
    //  Clear out errors and mark each item as not yet processed
    //

    for (i=0; i<cCertsToModify; i++) {
        rgCertMods[i].dwError = CTL_MODIFY_ERR_NOT_YET_PROCESSED;
    }

    //
    //  If we were given a specific cert to sign with, then call the helper routine with
    //  that specific certificate
    //

    if (pccertSigner != NULL) {
        hr = CTLModifyHelper(cCertsToModify, rgCertMods, szPurpose, hwnd, hcertstorTrust,
                             pccertSigner);
    }
    else {
        DWORD           cbData;
        CTL_USAGE       ctlUsage;
        BOOL            fSomeCertFound;
        LPSTR           psz;

        //
        //  Walk through the list of certificates in the root store testing againist each
        //      valid cert for trust signing abilities and key material
        //

        //
        //  Open the root store, this is the only place we can store a signing
        //      cert that we can fully trust.  The gods have decreed that items
        //      in this store cannot be corrupted or modified without user
        //      consent.
        //      Note: the previous statement is propaganda and should not be taken
        //      as having any relationship to the truth.
        //

#ifndef WIN16
        hcertstorRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      L"Root");
#else
        hcertstorRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      "Root");
#endif // !WIN16
        if (hcertstorRoot == NULL) {
            hr = E_FAIL;
            goto ExitHere;
        }
        //
        //  To be accepted, the cert must have the ability to sign trust lists
        //  and have key material
        //

        ctlUsage.cUsageIdentifier = 1;
        ctlUsage.rgpszUsageIdentifier = &psz;
        psz = (LPSTR) SzOID_KP_CTL_USAGE_SIGNING;
        fSomeCertFound = FALSE;

        while (TRUE) {
            pccertSigner = CertFindCertificateInStore(hcertstorRoot, X509_ASN_ENCODING,
                                                0, CERT_FIND_CTL_USAGE, &ctlUsage,
                                                pccertSigner);
            if (pccertSigner == NULL) {
                //  No certs found
                break;
            }

            //
            //  The certificate must also have an associated set of key provider
            //  information, or we must reject it.

            if (CertGetCertificateContextProperty(pccertSigner, CERT_KEY_PROV_INFO_PROP_ID,
                                                  NULL, &cbData) && (cbData > 0)) {
                fSomeCertFound = TRUE;
                hr = CTLModifyHelper(cCertsToModify, rgCertMods, szPurpose, hwnd,
                                     hcertstorTrust, pccertSigner);
            }
        }

        if (!fSomeCertFound) {
            pccertSigner = CreateTrustSigningCert(hwnd, hcertstorRoot, TRUE);
            if (pccertSigner != NULL) {
                hr = CTLModifyHelper(cCertsToModify, rgCertMods, szPurpose, hwnd,
                                     hcertstorTrust, pccertSigner);
            }
            else {
                hr = E_FAIL;
                goto ExitHere;
            }
        }

    }

    //
    //  Check for errors returned
    //

    for (i=0; i<cCertsToModify; i++) {
        if (rgCertMods[i].dwError == CTL_MODIFY_ERR_NOT_YET_PROCESSED) {
            rgCertMods[i].dwError = (DWORD) E_FAIL;
        }
        if (FAILED(rgCertMods[i].dwError)) {
            hr = S_FALSE;
        }
    }

    ExitHere:
    //
    //  Release the items we have created
    //

    if (hcertstorTrust != NULL) CertCloseStore(hcertstorTrust, 0);
    if (pccertSigner != NULL) CertFreeCertificateContext(pccertSigner);
    if (hcertstorRoot != NULL) CertCloseStore(hcertstorRoot, 0);

    return hr;
}

BOOL FModifyTrust(HWND hwnd, PCCERT_CONTEXT pccert, DWORD dwNewTrust,
                  LPSTR szPurpose)
{
    HRESULT     hr;
    CTL_MODIFY_REQUEST  certmod;

    certmod.pccert = pccert;
    certmod.dwOperation = dwNewTrust;

    hr = CertModifyCertificatesToTrust(1, &certmod, szPurpose, hwnd, NULL, NULL);
    return (hr == S_OK) && (certmod.dwError == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __DEMAND_H
#define __DEMAND_H

#ifndef MAC
//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY ARE CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS INSTEAD.
//

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define USE_CRITSEC

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;
#if 0
// my 1st attempt
#define DemandLoadDLL_GENERATOR(fnsuffix, dllname, handle, procaddrlist) \
    BOOL DemandLoad##fnsuffix()                     \
    {                                               \
        BOOL                fRet = TRUE;            \
                                                    \
        Assert(fInit);                              \
        EnterCriticalSection(&cs);                  \
                                                    \
        if (0 == handle)                            \
            {                                       \
            handle = LoadLibrary(#dllname);         \
                                                    \
            if (0 == handle)                        \
                fRet = FALSE;                       \
            else                                    \
                {                                   \
                procaddrlist                        \
                }                                   \
            }                                       \
                                                    \
        LeaveCriticalSection(&cs);                  \
        return fRet;                                \
    }
#endif

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;
#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#if 0
#define DemandLoadDLL_GENERATOR(fnsuffix, dllname, handle, procaddrlist) \
        BOOL DemandLoad##fnsuffix(void);
#endif

#endif // IMPLEMENT_LOADER_FUNCTIONS

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

BOOL DemandLoadCrypt32(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef ULONG_PTR HCRYPTPROV;
typedef struct _CERT_INFO *PCERT_INFO;

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    FALSE, Crypt32)
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( BOOL, CertDeleteCertificateFromStore,
    (PCCERT_CONTEXT pccert),
    (pccert),
    FALSE, Crypt32)
#define CertDeleteCertificateFromStore VAR_CertDeleteCertificateFromStore

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv,
     DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, DWORD dwFlags, void * pvStructInfo, DWORD * pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags,
     pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( PCERT_EXTENSION, CertFindExtension,
    (LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[]),
    (pszObjId, cExtensions, rgExtensions),
    NULL, Crypt32)
#define CertFindExtension VAR_CertFindExtension

LOADER_FUNCTION( BOOL, CryptFormatObject,
    (DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType,
     void * pFormatStruct, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, void * pbFormat, DWORD * pcbFormat),
    (dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct,
     lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat),
    FALSE, Crypt32)
#define CryptFormatObject VAR_CryptFormatObject

LOADER_FUNCTION( DWORD, CertNameToStrW,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType,
     LPWSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz),
    0, Crypt32)
#define CertNameToStrW VAR_CertNameToStrW

LOADER_FUNCTION( BOOL, CertStrToNameA,
    (DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved,
     BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError),
    (dwCertEncodingType, pszX500, dwStrType, pvReserved,
     pbEncoded, pcbEncoded, ppszError),
     FALSE, Crypt32)
#define CertStrToNameA VAR_CertStrToNameA

LOADER_FUNCTION( DWORD, CertRDNValueToStrW,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz),
    (dwValueType, pValue, psz, csz),
    0, Crypt32)
#define CertRDNValueToStrW VAR_CertRDNValueToStrW

LOADER_FUNCTION( PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CryptRegisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll,
     LPCSTR pszOverrideFuncName),
    (dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName),
    FALSE, Crypt32)
#define CryptRegisterOIDFunction VAR_CryptRegisterOIDFunction

LOADER_FUNCTION( BOOL, CryptUnregisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID),
    (dwEncodingType, pszFuncName, pszOID),
    FALSE, Crypt32)
#define CryptUnregisterOIDFunction VAR_CryptUnregisterOIDFunction

LOADER_FUNCTION( BOOL, CertSetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void * pvData),
    (pCertContext, dwPropId, dwFlags, pvData),
    FALSE, Crypt32)
#define CertSetCertificateContextProperty VAR_CertSetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertVerifyCTLUsage,
    (DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject,
     PCTL_USAGE pSubjectUsage, DWORD dwFlags,
     PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
     PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus),
    (dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags,
     pVerifyUsagePara, pVerifyUsageStatus),
    0, Crypt32)
#define CertVerifyCTLUsage VAR_CertVerifyCTLUsage

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext,
     PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertFreeCTLContext,
    (PCCTL_CONTEXT pCtlContext),
    (pCtlContext),
    FALSE, Crypt32)
#define CertFreeCTLContext VAR_CertFreeCTLContext

LOADER_FUNCTION( BOOL, CertAddEncodedCTLToStore,
    (HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded,
     DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext),
    (hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded,
     dwAddDisposition, ppCtlContext),
    FALSE, Crypt32)
#define CertAddEncodedCTLToStore VAR_CertAddEncodedCTLToStore

LOADER_FUNCTION( BOOL, CryptMsgEncodeAndSignCTL,
    (DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo,
     DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded),
    (dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptMsgEncodeAndSignCTL VAR_CryptMsgEncodeAndSignCTL

LOADER_FUNCTION( PCCTL_CONTEXT, CertFindCTLInStore,
    (HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags,
     DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext),
    (hCertStore, dwMsgAndCertEncodingType, dwFindFlags,
     dwFindType, pvFindPara, pPrevCtlContext),
    NULL, Crypt32)
#define CertFindCTLInStore VAR_CertFindCTLInStore

LOADER_FUNCTION( PCCTL_CONTEXT, CryptSignAndEncodeCertificate,
    (HCRYPTPROV hCryptProv, DWORD dwKeySpec, DWORD dwCertEncodingType,
     LPCSTR lpszStructType, const void *pvStructInfo,
     PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
     const void *pvHashAuxInfo, PBYTE pbEncoded, DWORD *pcbEncoded),
    (hCryptProv, dwKeySpec, dwCertEncodingType, lpszStructType,
     pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded,
     pcbEncoded),
    NULL, Crypt32)
#define CryptSignAndEncodeCertificate VAR_CryptSignAndEncodeCertificate

LOADER_FUNCTION( BOOL, CryptEncodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo,
     BYTE *pbEncoded, DWORD *pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded,pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObject VAR_CryptEncodeObject

LOADER_FUNCTION( BOOL, CryptExportPublicKeyInfo,
    (HCRYPTPROV hCryptProv, DWORD dwKeySpec, DWORD dwCertEncodingType,
     PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo),
    (hCryptProv, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo),
    FALSE, Crypt32)
#define CryptExportPublicKeyInfo VAR_CryptExportPublicKeyInfo

LOADER_FUNCTION( HCERTSTORE, CertDuplicateStore,
    (HCERTSTORE hCertStore),
    (hCertStore),
    NULL, Crypt32)
#define CertDuplicateStore VAR_CertDuplicateStore

LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded,
     DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded,
     cbCertEncoded, dwAddDisposition, ppCertContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    +1, Crypt32)                // Return AFTER by default
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( PCTL_ENTRY, CertFindSubjectInCTL,
    (DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject,
     PCCTL_CONTEXT pCtlContext, DWORD dwFlags),
    (dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags),
    NULL, Crypt32)
#define CertFindSubjectInCTL VAR_CertFindSubjectInCTL

LOADER_FUNCTION( BOOL, CertVerifySubjectCertificateContext,
    (PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags),
    (pSubject, pIssuer, pdwFlags),
    FALSE, Crypt32)
#define CertVerifySubjectCertificateContext VAR_CertVerifySubjectCertificateContext

LOADER_FUNCTION( BOOL, CertGetEnhancedKeyUsage,
    (PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage,
     DWORD *pcbUsage),
    (pCertContext, dwFlags, pUsage, pcbUsage),
    FALSE, Crypt32)
#define CertGetEnhancedKeyUsage VAR_CertGetEnhancedKeyUsage

LOADER_FUNCTION( BOOL, CryptDecodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObjectEx VAR_CryptDecodeObjectEx

LOADER_FUNCTION( BOOL, CryptEncodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObjectEx VAR_CryptEncodeObjectEx


LOADER_FUNCTION( BOOL, CertGetCertificateChain,
    (
        HCERTCHAINENGINE hChainEngine,
        PCCERT_CONTEXT pCertContext,
        LPFILETIME pTime,
        HCERTSTORE hAdditionalStore,
        PCERT_CHAIN_PARA pChainPara,
        DWORD dwFlags,
        LPVOID pvReserved,
        PCCERT_CHAIN_CONTEXT* ppChainContext
    ),
    (
        hChainEngine,
        pCertContext,
        pTime,
        hAdditionalStore,
        pChainPara,
        dwFlags,
        pvReserved,
        ppChainContext
    ),
    FALSE, Crypt32)
#define CertGetCertificateChain VAR_CertGetCertificateChain

LOADER_FUNCTION( BOOL, CertFreeCertificateChain,
    (
        PCCERT_CHAIN_CONTEXT pChainContext
    ),
    (
        pChainContext
    ),
    FALSE, Crypt32)
#define CertFreeCertificateChain VAR_CertFreeCertificateChain

LOADER_FUNCTION( PCCERT_CHAIN_CONTEXT, CertDuplicateCertificateChain,
    (
        PCCERT_CHAIN_CONTEXT pChainContext
    ),
    (
        pChainContext
    ),
    NULL, Crypt32)
#define CertDuplicateCertificateChain VAR_CertDuplicateCertificateChain

LOADER_FUNCTION( BOOL, CertAddStoreToCollection,
    (
        HCERTSTORE hCollectionStore,
        HCERTSTORE hSiblingStore,
        DWORD dwUpdateFlags,
        DWORD dwPriority
    ),
    (
        hCollectionStore,
        hSiblingStore,
        dwUpdateFlags,
        dwPriority
    ),
    FALSE, Crypt32)
#define CertAddStoreToCollection VAR_CertAddStoreToCollection

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (
        HCERTSTORE hCertStore,
        PCCERT_CONTEXT pCertContext,
        DWORD dwAddDisposition,
        PCCERT_CONTEXT *ppStoreContext
    ),
    (
        hCertStore,
        pCertContext,
        dwAddDisposition,
        ppStoreContext
    ),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore

LOADER_FUNCTION( BOOL, CertControlStore,
    (
        HCERTSTORE hCertStore,
        DWORD dwFlags,
        DWORD dwCtrlType,
        void const *pvCtrlPara
    ),
    (
        hCertStore,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
    ),
    FALSE, Crypt32)
#define CertControlStore VAR_CertControlStore

#if 0
LOADER_FUNCTION( BOOL, ,
    (),
    (),
    FALSE, Crypt32)
#define X VAR_
#endif // 0


/////////////////////////////////////
// CRYPTUI.DLL

BOOL DemandLoadCryptUI(void);
BOOL CryptUIAvailable(void);

#ifdef OLD_STUFF
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;

typedef const struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTW *PCCRYPTUI_VIEWCERTIFICATE_STRUCTW;
typedef const struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTA *PCCRYPTUI_VIEWCERTIFICATE_STRUCTA;

typedef const struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;
typedef const struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;

typedef const struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTW *PCCRYPTUI_SELECTCERTIFICATE_STRUCTW;
typedef const struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTA *PCCRYPTUI_SELECTCERTIFICATE_STRUCTA;
#endif


LOADER_FUNCTION(BOOL, CryptUIDlgViewCertificateW,
   (IN PCCRYPTUI_VIEWCERTIFICATE_STRUCTW pCertViewInfo, OUT BOOL *pfPropertiesChanged),
   (pCertViewInfo, pfPropertiesChanged),
   FALSE, CryptUI)
#define CryptUIDlgViewCertificateW VAR_CryptUIDlgViewCertificateW

LOADER_FUNCTION(BOOL, CryptUIDlgViewCertificateA,
   (IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTA pCertViewInfo, OUT BOOL *pfPropertiesChanged),
   (pCertViewInfo, pfPropertiesChanged),
   FALSE, CryptUI)
#define CryptUIDlgViewCertificateA VAR_CryptUIDlgViewCertificateA


LOADER_FUNCTION(BOOL, CryptUIDlgViewCertificatePropertiesW,
   (IN PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp, OUT BOOL *pfPropertiesChanged),
   (pcsp, pfPropertiesChanged),
   FALSE, CryptUI)
#define CryptUIDlgViewCertificatePropertiesW VAR_CryptUIDlgViewCertificatePropertiesW

LOADER_FUNCTION(BOOL, CryptUIDlgViewCertificatePropertiesA,
   (IN PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp, OUT BOOL *pfPropertiesChanged),
   (pcsp, pfPropertiesChanged),
   FALSE, CryptUI)
#define CryptUIDlgViewCertificatePropertiesA VAR_CryptUIDlgViewCertificatePropertiesA


LOADER_FUNCTION(PCCERT_CONTEXT, CryptUIDlgSelectCertificateW,
    (IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc),
    (pcsc),
    NULL, CryptUI)
#define CryptUIDlgSelectCertificateW VAR_CryptUIDlgSelectCertificateW

LOADER_FUNCTION(PCCERT_CONTEXT, CryptUIDlgSelectCertificateA,
    (IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTA pcsc),
    (pcsc),
    NULL, CryptUI)
#define CryptUIDlgSelectCertificateA VAR_CryptUIDlgSelectCertificateA

LOADER_FUNCTION( BOOL, CryptInstallDefaultContext,
    (HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara,
     DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext),
    (hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, 
     phDefaultContext),
    FALSE, Crypt32)
#define CryptInstallDefaultContext VAR_CryptInstallDefaultContext

LOADER_FUNCTION( BOOL, CryptUninstallDefaultContext,
    (HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved),
    (hDefaultContext, dwFlags, pvReserved),
    FALSE, Crypt32)
#define CryptUninstallDefaultContext VAR_CryptUninstallDefaultContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetSubjectCertificateFromStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId),
    (hCertStore, dwCertEncodingType, pCertId),
    NULL, Crypt32)
#define CertGetSubjectCertificateFromStore VAR_CertGetSubjectCertificateFromStore

#if 0
LOADER_FUNCTION( BOOL, ,
    (),
    (),
    FALSE, Crypt32)
#define X VAR_
#endif // 0


/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif
typedef ULONG_PTR HCRYPTKEY;

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

#if 0
LOADER_FUNCTION( BOOL, CryptGetProvParam,
    (HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags),
    (hProv, dwParam, pbData, pdwDataLen, dwFlags),
    FALSE, AdvApi32)
#define CryptGetProvParam VAR_CryptGetProvParam

LOADER_FUNCTION( BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags),
    (hProv, dwFlags),
    FALSE, AdvApi32)
#define CryptReleaseContext VAR_CryptReleaseContext

LOADER_FUNCTION( BOOL, CryptGenKey,
    (HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey),
    (hProv, Algid, dwFlags, phKey),
    FALSE, AdvApi32)
#define CryptGenKey VAR_CryptGenKey

LOADER_FUNCTION( BOOL, CryptDestroyKey,
    (HCRYPTKEY hKey),
    (hKey),
    FALSE, AdvApi32)
#define CryptDestroyKey VAR_CryptDestroyKey
#endif // 0


#ifndef WIN16

/////////////////////////////////////
// USER32.DLL

BOOL DemandLoadUser32();

LOADER_FUNCTION( LRESULT, SendDlgItemMessageW,
    (HWND hwnd, int idCtl, UINT msg, WPARAM wparam, LPARAM lparam),
    (hwnd, idCtl, msg, wparam, lparam),
    -1, User32)
#define SendDlgItemMessageW VAR_SendDlgItemMessageW

LOADER_FUNCTION( BOOL, SetDlgItemTextW,
    (HWND hwnd, int idCtl, LPCWSTR psz),
    (hwnd, idCtl, psz),
    FALSE, User32)
#define SetDlgItemTextW VAR_SetDlgItemTextW

LOADER_FUNCTION( UINT, GetDlgItemTextW,
    (HWND hwnd, int idCtl, LPWSTR psz, int nMax),
    (hwnd, idCtl, psz, nMax),
    FALSE, User32)
#define GetDlgItemTextW VAR_GetDlgItemTextW

LOADER_FUNCTION( int, LoadStringW,
    (HINSTANCE hinst, UINT idStr, LPWSTR rgwch, int cwch),
    (hinst, idStr, rgwch, cwch),
    0, User32)
#define LoadStringW VAR_LoadStringW

LOADER_FUNCTION( DWORD, FormatMessageW,
    (DWORD dwFlags, LPCVOID pbSource, DWORD dwMessageId,
     DWORD dwLangId, LPWSTR lpBuffer, DWORD nSize, va_list * args),
    (dwFlags, pbSource, dwMessageId, dwLangId, lpBuffer, nSize, args),
    0, User32)
#define FormatMessageW VAR_FormatMessageW

LOADER_FUNCTION( BOOL, WinHelpW,
    (HWND hWndMain, LPCWSTR szHelp, UINT uCommand, ULONG_PTR dwData),
    (hWndMain, szHelp, uCommand, dwData),
    FALSE, User32)
#define WinHelpW VAR_WinHelpW

#endif // !WIN16

#else   // MAC
#define SendDlgItemMessageW MySendDlgItemMessageW
#define SetDlgItemTextW     MySetDlgItemTextW
#define GetDlgItemTextW     MyGetDlgItemTextW
#define LoadStringW         MyLoadStringW
#define FormatMessageW      MyFormatMessageW
#define WinHelpW            MyWinHelpW
#define SendMessageW        SendMessageA
#undef CertOpenStore
EXTERN_C WINCRYPT32API HCERTSTORE WINAPI MacCertOpenStore(LPCSTR lpszStoreProvider,
                                                 DWORD dwEncodingType,
                                                 HCRYPTPROV hCryptProv,
                                                 DWORD dwFlags,
                                                 const void *pvPara);
#define CertOpenStore   MacCertOpenStore
#endif  // !MAC
#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\select.cpp ===
//
//  File:       select.cpp
//
//  Description: This file contains the implmentation code for the
//      "Certificate Select" dialog.
//

//
//  M00BUG -- Mutli-Select is not implemented
//

#include        "pch.hxx"
#include        "demand.h"


#define REIDK_PRIVATE   TRUE

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

#pragma warning (disable: 4201)         // nameless struct/union
#pragma warning (disable: 4514)         // remove inline functions
#pragma warning (disable: 4127)         // conditional expression is constant

//#include <wchar.h>

#ifdef MAC
#include <stdio.h>
#else   // !MAC
HMODULE         HmodRichEdit = NULL;
#endif  // !MAC
HINSTANCE       HinstDll;
BOOL            FIsWin95 = TRUE;
const HELPMAP RgctxSelect[] = {
    {IDC_CS_CERTLIST,                   IDH_CS_CERTLIST},
    {IDC_CS_PROPERTIES,                 IDH_CS_PROPERTIES},
    {IDC_CS_ALGORITHM,                  IDH_CS_ALGORITHM}};

#ifdef WIN16
#define LPCDLGTEMPLATE_X HGLOBAL
#else
#define LPCDLGTEMPLATE_X LPCDLGTEMPLATE
#endif

//
//  Generic DLL Main function,  we need to get our own hinstance handle.
//
//  We don't need to get thread attaches however.

#ifndef WIN16

#ifdef MAC
BOOL WINAPI FormatPKIXEmailProtection(
    DWORD /*dwCertEncodingType*/, DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/, void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/, const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/, void * pbFormat, DWORD * pcbFormat);

static const CRYPT_OID_FUNC_ENTRY SpcFormatFuncTable[] =
{
    szOID_PKIX_KP_EMAIL_PROTECTION,     FormatPKIXEmailProtection,
};
#define SPC_FORMAT_FUNC_COUNT (sizeof(SpcFormatFuncTable) / sizeof(SpcFormatFuncTable[0]))

BOOL WINAPI CryptDlgASNDllMain(HINSTANCE hInst, ULONG ulReason,
                               LPVOID)
{
    BOOL    fRet = TRUE;

    switch (ulReason) {
        case DLL_PROCESS_ATTACH:
            fRet = CryptInstallOIDFunctionAddress(hInst, X509_ASN_ENCODING,
                                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                                  SPC_FORMAT_FUNC_COUNT,
                                                  SpcFormatFuncTable, 0);
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:
        default:
            break;
    }
    return fRet;
}
#endif  // MAC


// DLL Entry point

#ifdef MAC
EXTERN_C BOOL WINAPI CryptDlg_DllMain(HANDLE hInst, ULONG ulReason, LPVOID pv)
#else   // !MAC


extern
BOOL
WINAPI
WXP_CertTrustDllMain(
    HINSTANCE hInst,
    ULONG ulReason,
    LPVOID
    );

BOOL WINAPI DllMain(HANDLE hInst, ULONG ulReason, LPVOID pv)
#endif  // MAC
{
    switch( ulReason ) {
    case DLL_PROCESS_ATTACH:
        HinstDll = (HINSTANCE) hInst;

        //  Kill all thread attach and detach messages
        DisableThreadLibraryCalls(HinstDll);

#ifndef MAC
        //  Are we running in Win95 or something equally bad
        FIsWin95 = IsWin95();

        InitDemandLoadedLibs();
#endif  // !MAC
        break;

    case DLL_PROCESS_DETACH:
#ifndef MAC
        FreeDemandLoadedLibs();

        //  If the rich edit dll was loaded, then unload it now
        if (HmodRichEdit != NULL) {
            FreeLibrary(HmodRichEdit);
        }
#endif  // !MAC
        break;
    }
#ifndef MAC
    return WXP_CertTrustDllMain((HINSTANCE) hInst, ulReason, pv);
    
#else   // MAC
    // Handle the ASN OID functions

    return CryptDlgASNDllMain((HINSTANCE)hInst, ulReason, pv);
#endif  // !MAC
}

#else // WIN16

BOOL FAR PASCAL
LibMain (HINSTANCE hDll,
         WORD wDataSeg,
         WORD cbHeapSize,
         LPSTR lpszCmdLine)
{

    HinstDll = (HINSTANCE) hDll;

    InitDemandLoadedLibs();

    // Done
    return TRUE;
}

int CALLBACK WEP(int x)
{

    FreeDemandLoadedLibs();

    //  If the rich edit dll was loaded, then unload it now
    if (HmodRichEdit != NULL) {
        FreeLibrary(HmodRichEdit);
    }

    return 1;
}

#endif // !WIN16

#ifndef WIN16
DWORD ComputeExtent(HWND hwnd, int id)
{
    int         c;
    ULONG       cb;
    ULONG       cbMax = 0;
    DWORD       dwExtent;
    DWORD       dwExtentMax = 0;
    HDC         hdc;
    HFONT       hfontOld;
    HFONT       hfontNew;
    int         i;
    LPWSTR      psz = NULL;
    SIZE        sz;
#ifndef MAC
    TEXTMETRICW tmW={0};
#endif  // !MAC
    TEXTMETRICA tmA={0};

    hdc = GetDC(hwnd);
    hfontNew = (HFONT) SendMessage(hwnd, WM_GETFONT, NULL, NULL);
    hfontOld = (HFONT) SelectObject(hdc, hfontNew);
    if (FIsWin95) {
        GetTextMetricsA(hdc, &tmA);
    }
#ifndef MAC
    else {
        GetTextMetricsW(hdc, &tmW);
    }
#endif  // !MAC

    c = (int) SendDlgItemMessage(hwnd, id, LB_GETCOUNT, 0, 0);
    for (i=0; i<c; i++) {
        cb =  (ULONG) SendDlgItemMessage(hwnd, id, LB_GETTEXTLEN, i, 0);
        if (cb > cbMax) {
            free(psz);
            cbMax = cb + 100;
            psz = (LPWSTR) malloc(cbMax*sizeof(WCHAR));
            if (psz == NULL) {
                break;
            }
        }
#ifndef MAC
        if (FIsWin95) {
#endif  // !MAC
            SendDlgItemMessageA(hwnd, id, LB_GETTEXT, i, (LPARAM) psz);
            GetTextExtentPointA(hdc, (LPSTR) psz, strlen((LPSTR) psz), &sz);
            dwExtent = sz.cx + tmA.tmAveCharWidth;
#ifndef MAC
        }
        else {
            SendDlgItemMessageW(hwnd, id, LB_GETTEXT, i, (LPARAM) psz);
            GetTextExtentPointW(hdc, psz, wcslen(psz), &sz);
            dwExtent = sz.cx + tmW.tmAveCharWidth;
        }
#endif  // !MAC
        if (dwExtent > dwExtentMax) {
            dwExtentMax = dwExtent;
        }
    }

    free(psz);
    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);

    return dwExtentMax;
}
#else // WIN16
DWORD ComputeExtent(HWND hwnd, int id)
{
    int         c;
    int         cb;
    int         cbMax = 0;
    DWORD       dwExtent;
    DWORD       dwExtentMax = 0;
    HDC         hdc;
    HFONT       hfontOld;
    HFONT       hfontNew;
    int         i;
    LPWSTR      psz = NULL;
    SIZE        sz;
    TEXTMETRIC  tm;

    hdc = GetDC(hwnd);
    hfontNew = (HFONT) SendMessage(hwnd, WM_GETFONT, NULL, NULL);
    hfontOld = (HFONT) SelectObject(hdc, hfontNew);

    GetTextMetrics(hdc, &tm);

    c = SendDlgItemMessage(hwnd, id, LB_GETCOUNT, 0, 0);
    for (i=0; i<c; i++) {
        cb = SendDlgItemMessage(hwnd, id, LB_GETTEXTLEN, i, 0);
        if (cb > cbMax) {
            free(psz);
            cbMax = cb + 100;
            psz = (LPWSTR) malloc(cbMax*sizeof(WCHAR));
            if (psz == NULL) {
                break;
            }
        }

        SendDlgItemMessage(hwnd, id, LB_GETTEXT, i, (LONG) psz);
        GetTextExtentPoint(hdc, (LPSTR) psz, strlen((LPSTR) psz), &sz);
        dwExtent = sz.cx + tm.tmAveCharWidth;

        if (dwExtent > dwExtentMax) {
            dwExtentMax = dwExtent;
        }
    }

    free(psz);
    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);

    return dwExtentMax;
}
#endif // !WIN16

BOOL FillInFields(HWND hwnd, PCCERT_CONTEXT pccert)
{
    LPWSTR      pwsz;
    WCHAR       rgwch[200];
    LPWSTR      rgpwsz[3];
    rgpwsz[2] = (LPWSTR)-1;               // Sentinal Value

    FormatAlgorithm(hwnd, IDC_CS_ALGORITHM, pccert);
    FormatSerialNo(hwnd, IDC_CS_SERIAL_NUMBER, pccert);
    FormatThumbprint(hwnd, IDC_CS_THUMBPRINT, pccert);
    FormatValidity(hwnd, IDC_CS_VALIDITY, pccert);

    rgpwsz[0] = PrettySubject(pccert);
    rgpwsz[1] = PrettyIssuer(pccert);

    LoadString(HinstDll, IDS_SELECT_INFO, rgwch, ARRAYSIZE(rgwch));
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_STRING |
                  FORMAT_MESSAGE_ARGUMENT_ARRAY, rgwch, 0, 0,
                  (LPWSTR) &pwsz, 0, (va_list *) rgpwsz);

#ifndef WIN16
    TruncateToWindowW(hwnd, IDC_CS_INFO, pwsz);
#else
    TruncateToWindowA(hwnd, IDC_CS_INFO, pwsz);
#endif // !WIN16
    SetDlgItemText(hwnd, IDC_CS_INFO, pwsz);
    free(rgpwsz[0]);
    free(rgpwsz[1]);
    LocalFree((HLOCAL)pwsz);
    return TRUE;
}

INT_PTR CALLBACK SelectCertDlgProc(HWND hwndDlg, UINT msg,
                                WPARAM wParam, LPARAM lParam)
{
    int		            c;
    CTL_USAGE           ctlUsage;
    PCERT_CONTEXT       pcertctx;
    BOOL                f;
    int                 i;
    DWORD               iStore;
    LPWSTR              pwsz;
    PCCERT_CONTEXT      pccert;
    PCERT_SELECT_STRUCT pcss;

    pcss = (PCERT_SELECT_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);

    //
    //  If a hook proc has been registered for this dialog, then we need
    //  to call the hook proc.  Notice that if the hook proc returns TRUE
    //  then we don't do normal processing
    //

    if ((pcss != NULL) && (pcss->dwFlags & CSS_ENABLEHOOK) &&
        (pcss->pfnHook != 0)) {
        f = pcss->pfnHook(hwndDlg, msg, wParam, lParam);
        if (f) {
            return f;
        }
    }

    //

    switch (msg) {
    case WM_INITDIALOG:
        //  Center the dialog on its parent
        //        CenterThisDialog(hwndDlg);

        //  Save the pointer to the control structure for later use.
        SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);

        //
        pcss = (PCERT_SELECT_STRUCT) lParam;

        //
        //  Is there a title to be displayed?
        //

        if (pcss->szTitle != NULL) {
            if (FIsWin95) {
                SendMessageA(hwndDlg, WM_SETTEXT, 0, (LPARAM) pcss->szTitle);
            }
#ifndef WIN16
#ifndef MAC
            else {
                SendMessageW(hwndDlg, WM_SETTEXT, 0, (LPARAM) pcss->szTitle);
            }
#endif  // !MAC
#endif // !WIN16
        }

        //
        //  If we want a help button, then show it
        //

        if (pcss->dwFlags & CSS_SHOW_HELP) {
            ShowWindow(GetDlgItem(hwndDlg, IDHELP), SW_SHOW);
        }

        //
        //  Check to see if the properties button should be suppressed
        //

        if (pcss->dwFlags & CSS_HIDE_PROPERTIES) {
            ShowWindow(GetDlgItem(hwndDlg, IDC_CS_PROPERTIES), SW_HIDE);
        }

        //
        //  Let populate the list box, walk through the list of stores
        //      to populate the list
        //

        if (pcss->szPurposeOid != NULL) {
            ctlUsage.cUsageIdentifier = 1;
            ctlUsage.rgpszUsageIdentifier = (LPSTR *) &pcss->szPurposeOid;
        }


        for (iStore = 0; iStore < pcss->cCertStore; iStore++) {
            pccert = NULL;

            if (!pcss->arrayCertStore[iStore])
                continue;

            while (TRUE) {
                //
                //  Get the next certificate in the current store.  If
                //      we are finished then move on to the next store
                //

                if (pcss->szPurposeOid != NULL) {
                    pccert = CertFindCertificateInStore(
                                     pcss->arrayCertStore[iStore],
                                     CRYPT_ASN_ENCODING,
                                     CERT_FIND_OPTIONAL_CTL_USAGE_FLAG,
                                     CERT_FIND_CTL_USAGE, &ctlUsage, pccert);

                }
                else {
                    pccert = CertEnumCertificatesInStore(
                                                  pcss->arrayCertStore[iStore],
                                                  pccert);
                }

                if (pccert == NULL) {
                    break;
                }

                //
                //  Filter the certificate according to the purpse desired
                //

                //
                //  If we have a filter set, then call back and see if
                //      the filter approves the certificate.  If it is not
                //      approved then move onto the next certificate in this
                //      store.
                //

                if (pcss->pfnFilter != NULL) {
                    if (!pcss->pfnFilter(pccert, pcss->lCustData, 0, 0)) {
                        continue;
                    }
                }
                //
                //  If there is no filter function, then kill all V1 certs
                //
                else {
                    if (pccert->pCertInfo->dwVersion < 2) {
                        continue;
                    }
                }

                //
                //  Convert the certificate subject to a name
                //

                pwsz = PrettySubjectIssuer(pccert);

                i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_ADDSTRING, 0,
                                       (LPARAM) pwsz);
                SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_SETITEMDATA, i,
                                   (LPARAM) CertDuplicateCertificateContext(pccert));

                free(pwsz);

            }
        }

        SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_SETHORIZONTALEXTENT,
                           ComputeExtent(hwndDlg, IDC_CS_CERTLIST), 0);

        c = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCOUNT, 0, 0);
        if (c != 0 && pcss->arrayCertContext[0] != NULL) {
            for (i=0; i<c; i++) {
                pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                        i, 0);
                if (CertCompareCertificate(X509_ASN_ENCODING,
                                           pcss->arrayCertContext[0]->pCertInfo,
                                           pcertctx->pCertInfo)) {
                    SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_SETCURSEL,
                                       i, 0);
                    pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST,
                                            LB_GETITEMDATA, i, 0);
                    FillInFields(hwndDlg, pcertctx);
                    break;
                }
            }
        }
        else {
            // no certs at all or no default certificate,
            // so there is no selection in the listbox

            EnableWindow(GetDlgItem(hwndDlg, IDC_CS_PROPERTIES), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CS_FINEPRINT), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
        }

        if ((pcss->dwFlags & CSS_ENABLEHOOK) && (pcss->pfnHook != 0)) {
            f = pcss->pfnHook(hwndDlg, msg, wParam, lParam);
            if (f) {
                return f;
            }
        }
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCURSEL, 0, 0);
            if (i != LB_ERR) {
                //  Free the old cert if there is one
                if (pcss->arrayCertContext[0] != NULL) {
                    CertFreeCertificateContext(pcss->arrayCertContext[0]);
                }

                //  Get the new cert from the system.
                pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                        i, 0);

                //  Put the new cert into the location
                pcss->cCertContext = 1;
                pcss->arrayCertContext[0] =
                    CertDuplicateCertificateContext(pcertctx);
            }
            else {
                pcss->cCertContext = 0;
            }
            EndDialog(hwndDlg, IDOK);
            return TRUE;

        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            return TRUE;

        case IDHELP:
            if (FIsWin95) {
                WinHelpA(hwndDlg, (LPSTR) pcss->szHelpFileName,
                         HELP_CONTEXT, pcss->dwHelpId);
            }
#ifndef MAC
            else {
                WinHelp(hwndDlg, pcss->szHelpFileName,
                        HELP_CONTEXT, pcss->dwHelpId);
            }
#endif  // !MAC
            return TRUE;

        case IDC_CS_PROPERTIES:
            i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCURSEL, 0, 0);
            if (i == LB_ERR) {
                return TRUE;
            }
            pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                    i, 0);

            f = TRUE;
            if (FIsWin95) {
                CERT_VIEWPROPERTIES_STRUCT_A        cvps;

                memset(&cvps, 0, sizeof(cvps));
                cvps.dwSize = sizeof(cvps);
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pcertctx;

                pcss = (PCERT_SELECT_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);
                if (pcss->szPurposeOid != NULL) {
                    cvps.cArrayPurposes = 1;
                    cvps.arrayPurposes = (LPSTR *) &pcss->szPurposeOid;
                }

                if (pcss->dwSize > (DWORD_PTR) &((PCERT_SELECT_STRUCT_A) 0)->hprov) {
                    cvps.hprov = pcss->hprov;
                }

                f = CertViewPropertiesA(&cvps);
            }
#ifndef WIN16
#ifndef MAC
            else {
                CERT_VIEWPROPERTIES_STRUCT_W        cvps;

                memset(&cvps, 0, sizeof(cvps));
                cvps.dwSize = sizeof(cvps);
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pcertctx;

                pcss = (PCERT_SELECT_STRUCT) GetWindowLongPtr(hwndDlg, DWLP_USER);
                if (pcss->szPurposeOid != NULL) {
                    cvps.cArrayPurposes = 1;
                    cvps.arrayPurposes = (LPSTR *) &pcss->szPurposeOid;
                }
                if (pcss->dwSize > (DWORD_PTR) &((PCERT_SELECT_STRUCT_W) 0)->hprov) {
                    cvps.hprov = pcss->hprov;
                }

                f = CertViewPropertiesW(&cvps);
            }
#endif  // !MAC
#endif  // !WIN16
            if (f) {
                // M00BUG -- repopulate the line.  The friendly name
                //      may have changed.
            }
            return TRUE;

        case IDC_CS_FINEPRINT:
            i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCURSEL, 0, 0);
            if (i == LB_ERR) {
                return TRUE;
            }
            pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                    i, 0);
            FinePrint(pcertctx, hwndDlg);
            return TRUE;

        case IDC_CS_CERTLIST:
            if (HIWORD(wParam) == LBN_SELCHANGE) {
                i = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCARETINDEX,
                                       0, 0);
                pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA,
                                        i, 0);
                FillInFields(hwndDlg, pcertctx);

                if (!(pcss->dwFlags & CSS_HIDE_PROPERTIES)) {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_CS_PROPERTIES), TRUE);
                }
                EnableWindow(GetDlgItem(hwndDlg, IDC_CS_FINEPRINT), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDOK), TRUE);
            }
            return TRUE;
        }

        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxSelect);
#endif  // !MAC

    case WM_DESTROY:
        c = (int) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETCOUNT, 0, 0);
        for (i=0; i<c; i++) {
            pcertctx = (PCERT_CONTEXT) SendDlgItemMessage(hwndDlg, IDC_CS_CERTLIST, LB_GETITEMDATA, i, 0);
            CertFreeCertificateContext(pcertctx);
        }
        return FALSE;

        //
        //  Use the default handler -- we don't do anything for it
        //

    default:
        return FALSE;
    }

    return TRUE;
}                               // SelectCertDialogProc()


BOOL WINAPI MyCryptFilter(PCCERT_CONTEXT pccert, BOOL * pfSelect, void * pv)
{
    PCERT_SELECT_STRUCT_W      pcssW = (PCERT_SELECT_STRUCT_W) pv;
    PCERT_EXTENSION            pExt;

    //  Test purpose

    if (pcssW->szPurposeOid != NULL) {
        pExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                 pccert->pCertInfo->cExtension,
                                 pccert->pCertInfo->rgExtension);
        if (pExt != NULL) {
            BOOL                f;
            DWORD               i;
            PCERT_ENHKEY_USAGE  pUsage;

            pUsage = (PCERT_ENHKEY_USAGE) PVCryptDecode(szOID_ENHANCED_KEY_USAGE,
                                                        pExt->Value.cbData,
                                                        pExt->Value.pbData);
            if (pUsage == NULL) {
                return FALSE;
            }

            for (i=0, f=FALSE; i<pUsage->cUsageIdentifier; i++) {
                if (strcmp(pcssW->szPurposeOid, pUsage->rgpszUsageIdentifier[i]) == 0) {
                    break;
                }
            }

            if (i == pUsage->cUsageIdentifier) {
                free(pUsage);
                return FALSE;
            }

            free(pUsage);
        }
    }

    //  Let them filter if they want

    if (pcssW->pfnFilter != NULL) {
        if (!pcssW->pfnFilter(pccert, pcssW->lCustData, 0, 0)) {
            return FALSE;
        }
    }
    else if (pccert->pCertInfo->dwVersion < 2) {
        return FALSE;
    }
    

    if ((pfSelect != NULL) && (pcssW->arrayCertContext[0] != NULL)) {
        *pfSelect = CertCompareCertificate(X509_ASN_ENCODING, pccert->pCertInfo,
                                           pcssW->arrayCertContext[0]->pCertInfo);
    }
    return TRUE;
}

BOOL WINAPI MyDisplay(PCCERT_CONTEXT pccert, HWND hwnd, void * pv)
{
    CERT_VIEWPROPERTIES_STRUCT_A        cvps = {0};
    PCERT_SELECT_STRUCT_W               pcss = (PCERT_SELECT_STRUCT_W) pv;

    cvps.dwSize = sizeof(cvps);
    cvps.hwndParent = hwnd;
    cvps.pCertContext = pccert;
    if (pcss->szPurposeOid != NULL) {
        cvps.cArrayPurposes = 1;
        cvps.arrayPurposes = (LPSTR *) &pcss->szPurposeOid;
    }
    if (pcss->dwSize > (DWORD_PTR) &((PCERT_SELECT_STRUCT_A) 0)->hprov) {
        cvps.hprov = pcss->hprov;
    }

    CertViewPropertiesA(&cvps);
    return TRUE;
}

BOOL CallCryptUISelect(BOOL fWide, PCERT_SELECT_STRUCT_W pcssW)
{
    CRYPTUI_SELECTCERTIFICATE_STRUCTW       cscs = {0};
    PCCERT_CONTEXT                          pccert;

    cscs.dwSize = sizeof(cscs);
    cscs.hwndParent = pcssW->hwndParent;
    // cscs.dwFlags = 0;
    cscs.szTitle = pcssW->szTitle;
    if (pcssW->szPurposeOid != NULL) {
        cscs.dwDontUseColumn = /*CRYPTUI_SELECT_INTENDEDUSE_COLUMN |*/
            CRYPTUI_SELECT_LOCATION_COLUMN;
    }
    else {
        cscs.dwDontUseColumn = CRYPTUI_SELECT_LOCATION_COLUMN;
    }            
    // cscs.szDisplayString = NULL;
    cscs.pFilterCallback = MyCryptFilter;
    cscs.pDisplayCallback = MyDisplay;
    cscs.pvCallbackData = pcssW;
    cscs.cDisplayStores = pcssW->cCertStore;
    cscs.rghDisplayStores = pcssW->arrayCertStore;
    // cscs.cStores = 0;
    // cscs.rghStores = NULL;
    // cscs.cPropSheetPages = 0;
    // cscs.rgPropSheetPages = NULL;

    if (fWide) {
        pccert = CryptUIDlgSelectCertificateW(&cscs);
    }
    else {
        pccert = CryptUIDlgSelectCertificateA((PCRYPTUI_SELECTCERTIFICATE_STRUCTA) &cscs);
    }
    
    if (pccert != NULL) {
        if (pcssW->cCertContext == 1) {
            CertFreeCertificateContext(pcssW->arrayCertContext[0]);
        }
        
        pcssW->cCertContext = 1;
        pcssW->arrayCertContext[0] = pccert;
        return TRUE;
    }
    return FALSE;
}


extern "C" BOOL APIENTRY CertSelectCertificateA(PCERT_SELECT_STRUCT_A pcssA)
{
    if (CryptUIAvailable()) {
        return CallCryptUISelect(FALSE, (PCERT_SELECT_STRUCT_W) pcssA);
    }
    
    HCERTSTORE                  hCertStore = NULL;
    int							ret = FALSE;
    CERT_SELECT_STRUCT_W        cssW = {0};
#ifndef MAC
    int                         cch;
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_LISTVIEW_CLASSES
#ifndef WIN16
          | ICC_NATIVEFNTCTL_CLASS
#endif  // ! WIN16
    };
#endif  // ! MAC

    if (pcssA->cCertStore == 0) {
        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                   NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                   L"MY");
        if (hCertStore == NULL) {
            ret = -1;
            goto Exit;
        }
        pcssA->cCertStore = 1;
        pcssA->arrayCertStore = &hCertStore;
    }
    //
    //  Size of the object must be acceptable in order to copy it over
    //

    if (pcssA->dwSize > sizeof(cssW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (FIsWin95) {
        //
        //  Deal with some DBCS issues
        //

#ifndef MAC
        InitCommonControlsEx(&initcomm);
#endif  // !MAC

        //
        //  Launch the dialog
        //

        if (pcssA->dwFlags & CSS_ENABLETEMPLATEHANDLE) {
            ret = (int) DialogBoxIndirectParamA(pcssA->hInstance,
                                  (LPCDLGTEMPLATE_X) pcssA->pTemplateName,
                                  pcssA->hwndParent, SelectCertDlgProc,
                                  (LPARAM) pcssA);
        }
        else if (pcssA->dwFlags & CSS_ENABLETEMPLATE) {
            ret = (int) DialogBoxParamA(pcssA->hInstance, pcssA->pTemplateName,
                                  pcssA->hwndParent, SelectCertDlgProc,
                                  (LPARAM) pcssA);
        }
        else {
            ret = (int) DialogBoxParamA(HinstDll,
                                  (LPSTR) MAKEINTRESOURCE(IDD_SELECT_DIALOG),
                                  pcssA->hwndParent, SelectCertDlgProc,
                                  (LPARAM) pcssA);
        }
    }
#if ! defined(WIN16) && ! defined (MAC)
    else {
        //
        //  Do a bulk copy of the passed in structure then we fix up the
        //  individual fields to go from the A to the W version of the structure
        //

        memcpy(&cssW, pcssA, pcssA->dwSize);

        if (pcssA->szTitle != NULL) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcssA->szTitle, -1,
                                      NULL, 0);
            cssW.szTitle = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cssW.szTitle == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcssA->szTitle, -1,
                                (LPWSTR) cssW.szTitle, cch+1);
        }

        if (pcssA->szHelpFileName != NULL) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                      pcssA->szHelpFileName, -1, NULL, 0);
            cssW.szHelpFileName = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cssW.szHelpFileName == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcssA->szHelpFileName, -1,
                                (LPWSTR) cssW.szHelpFileName, cch+1);
        }

        if (pcssA->dwFlags & CSS_ENABLETEMPLATE) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                      pcssA->pTemplateName, -1, NULL, 0);
            cssW.pTemplateName = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cssW.pTemplateName == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcssA->pTemplateName, -1,
                                (LPWSTR) cssW.pTemplateName, cch+1);
        }

        //
        //  Call Wide char version of the function now
        //

        ret = CertSelectCertificateW(&cssW);
        pcssA->cCertContext = cssW.cCertContext;


        //
        //  If we allocated buffers to hold data, free them now
        //

ExitW:
        if (cssW.szTitle != NULL) free((LPWSTR) cssW.szTitle);
        if (cssW.szHelpFileName != NULL) free((LPWSTR) cssW.szHelpFileName);
        if (pcssA->dwFlags & CSS_ENABLETEMPLATE) {
            free((LPWSTR) cssW.pTemplateName);
        }

        //
        //  return the return value of the original function
        //
    }
#endif  // !WIN16 and !MAC

Exit:
    if (hCertStore != NULL) {
        CertCloseStore(hCertStore, 0);
        pcssA->cCertStore = 0;
        pcssA->arrayCertStore = NULL;
    }
    return (ret == IDOK);
}

#ifndef WIN16
#ifndef MAC

BOOL APIENTRY CertSelectCertificateW(PCERT_SELECT_STRUCT_W pcssW)
{
    if (CryptUIAvailable()) {
        return CallCryptUISelect(TRUE, pcssW);
    }
    
    HCERTSTORE                  hCertStore = NULL;
    int		                    ret = FALSE;
#ifndef MAC
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES
    };
#endif  // !MAC

    //
    //  If cCertStore == 0, then default to using the "MY" cert store
    //

    if (pcssW->cCertStore == 0) {
        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                   NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                   L"MY");
        if (hCertStore == NULL) {
            ret = -1;
            goto Exit;
        }
        pcssW->cCertStore = 1;
        pcssW->arrayCertStore = &hCertStore;
    }

    //
    //  Deal with some DBCS issues
    //

    InitCommonControlsEx(&initcomm);

    //
    //  Launch the dialog
    //

    if (pcssW->dwFlags & CSS_ENABLETEMPLATEHANDLE) {
        ret = (int) DialogBoxIndirectParam(pcssW->hInstance,
                                     (LPCDLGTEMPLATE_X) pcssW->pTemplateName,
                                     pcssW->hwndParent, SelectCertDlgProc,
                                     (LPARAM) pcssW);
    }
    else if (pcssW->dwFlags & CSS_ENABLETEMPLATE) {
        ret = (int) DialogBoxParam(pcssW->hInstance, pcssW->pTemplateName,
                             pcssW->hwndParent, SelectCertDlgProc,
                             (LPARAM) pcssW);
    }
    else {
        ret = (int) DialogBoxParam(HinstDll, MAKEINTRESOURCE(IDD_SELECT_DIALOG),
                             pcssW->hwndParent, SelectCertDlgProc,
                             (LPARAM) pcssW);
    }

Exit:
    if (hCertStore != NULL) {
        CertCloseStore(hCertStore, 0);
        pcssW->cCertStore = 0;
        pcssW->arrayCertStore = NULL;
    }

    return (ret == IDOK);
}
#endif  // !MAC
#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\build\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDOCOBJ -DDBCS_DIVIDE -DBCC -D_WINDLL
WIN32_IE_VERSION=0x0500

INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(R)\res; \
    $(R)\inc; \
    $(R)\inc\$(O); \
    $(R)\dll; \
    $(R)\engine; \
    $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1

PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch

PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\build\makefile.inc ===
$O\directdb.res : selfreg.inf

selfreg.inf : selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\dll\dllmain.cpp ===
// --------------------------------------------------------------------------------
// Dllmain.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#define DEFINE_STRCONST
#include "strconst.h"
#include "listen.h"
#include "shared.h"

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
CRITICAL_SECTION    g_csDllMain={0};
CRITICAL_SECTION    g_csDBListen={0};
SYSTEM_INFO         g_SystemInfo={0};
LONG                g_cRef=0;
LONG                g_cLock=0;
HINSTANCE           g_hInst=NULL;
IMalloc            *g_pMalloc=NULL;
BOOL                g_fAttached = FALSE;
BOOL                g_fIsWinNT=FALSE;

// --------------------------------------------------------------------------------
// Win32 Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Locals
    OSVERSIONINFO Version;

    // Process Attach
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        // Set g_hInst
        g_hInst = hInst;

        // Get Mall
        CoGetMalloc(1, &g_pMalloc);

        // Set Version
        Version.dwOSVersionInfoSize = sizeof(Version);

        // Get Version
        if (GetVersionEx(&Version) && Version.dwPlatformId == VER_PLATFORM_WIN32_NT)
            g_fIsWinNT = TRUE;
        else
            g_fIsWinNT = FALSE;

        // Initialize Global Critical Sections
        InitializeCriticalSection(&g_csDllMain);
        InitializeCriticalSection(&g_csDBListen);
        g_fAttached =  TRUE;

        // Get System Info
        GetSystemInfo(&g_SystemInfo);

        // Don't tell me about thread attaches/detaches
        SideAssert(DisableThreadLibraryCalls(hInst));
    }

    // Otherwise, process detach
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        // Delete Global Critical Sections
        g_fAttached =  FALSE;
        DeleteCriticalSection(&g_csDllMain);
        DeleteCriticalSection(&g_csDBListen);
    }

    // Done
    return(TRUE);
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    TraceCall("DllAddRef");
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    TraceCall("DllRelease");
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    // Tracing
    TraceCall("DllCanUnloadNow");

    if(!g_fAttached)    // critacal sections was deleted (or not created): we defently can be unloaded
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Can We Unload
    HRESULT hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // Trace
    TraceCall("DllRegisterServer");

    // Register
    return(CallRegInstall(g_hInst, g_hInst, c_szReg, NULL));
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    // Trace
    TraceCall("DllUnregisterServer");

    // UnRegister
    return(CallRegInstall(g_hInst, g_hInst, c_szUnReg, NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\test\test.cpp ===
#include        <windows.h>
#include        <stdio.h>
#include        <cryptdlg.h>

int     IFilter = 0;

BOOL FILTER(PCCERT_CONTEXT pccert, long, DWORD, DWORD)
{
    switch (IFilter) {
    case 1:
        return TRUE;

    case 2:
        return (pccert->pCertInfo->dwVersion == 0);
    }
    return TRUE;
}

void PrintUsage()
{
    printf("test options are:\n");
    printf("    -h      print help\n");
    printf("    -A      open AddressBook cert store\n");
    printf("    -C      open CA cert store\n");
    printf("    -M      open My cert store\n");
    printf("    -R      open ROOT cert store\n");
    printf("    -F#     filter number to apply\n");
    printf("            1 - view all certs\n");
    printf("            2 - view V1 certs only\n");
    printf("    -S<name> open <name> cert store\n");
}

int __cdecl  main(int argc, char * argv[])
{
    BOOL                fWide = FALSE;
    HCERTSTORE          hcertstor = NULL;
    int                 i;
    PCCERT_CONTEXT      pccert = NULL;
    char *              szPurposeOid = "1.3.6.1.5.5.7.3.4";

    for (i=1; i<argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            switch(argv[i][1]) {
            case 'h':
                PrintUsage();
                exit(0);

            case 'A':
                hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                          NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                          L"AddressBook");
                break;

            case 'M':
                hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                          NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                          L"My");
                break;

            case 'R':
                hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                          NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                          L"ROOT");
                break;

            case 'C':
                hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                          NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                          L"CA");
                break;

            case 'F':
                IFilter = atoi(&argv[i][2]);
                break;

            case 'P':
                if (argv[i][2] != 0) {
                    szPurposeOid = &argv[i][2];
                }
                else
                    szPurposeOid = NULL;
                break;

            case 'W':
                fWide = TRUE;
                break;

            default:
                PrintUsage();
                exit(1);
            }
        }
        else {
            PrintUsage();
            exit(1);
        }
    }

    if (hcertstor == NULL) {
        hcertstor = CertOpenStore(sz_CERT_STORE_PROV_SYSTEM_W, X509_ASN_ENCODING,
                                  NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                  L"MY");
    }

    if (fWide) {
        CERT_SELECT_STRUCT_W  css = {0};

        css.dwSize = sizeof(css);
        css.szPurposeOid = szPurposeOid;
        css.hwndParent = NULL;
        css.hInstance = NULL;
        css.pTemplateName = NULL;
        css.dwFlags = CSS_SHOW_HELP;
        css.szTitle = NULL;
        css.cCertStore = 1;
        css.arrayCertStore = &hcertstor;
        css.cCertContext = 0;
        css.arrayCertContext = &pccert;
        css.lCustData = 0;
        css.pfnHook = NULL;
        if (IFilter > 0) {
            css.pfnFilter = FILTER;
        }
        else {
            css.pfnFilter = NULL;
        }
        css.szHelpFileName = L"Help File";
        css.dwHelpId = 100;

        if (CertSelectCertificateW(&css)) {

            CERT_VIEWPROPERTIES_STRUCT_W cvp;
            memset(&cvp, 0, sizeof(cvp));

            cvp.dwSize = sizeof(cvp);
            cvp.pCertContext = pccert;
            cvp.dwFlags |= CM_SHOW_HELP;
            cvp.cArrayPurposes = 1;
            cvp.arrayPurposes = (LPSTR *) &css.szPurposeOid;
            cvp.szHelpFileName = L"Help File";
            cvp.dwHelpId = 100;

            CertViewPropertiesW(&cvp);
        }
    }
    else {
        CERT_SELECT_STRUCT_A  css = {0};

        css.dwSize = sizeof(css);
        css.szPurposeOid = szPurposeOid;
        css.hwndParent = NULL;
        css.hInstance = NULL;
        css.pTemplateName = NULL;
        css.dwFlags = CSS_SHOW_HELP;
        css.szTitle = NULL;
        css.cCertStore = 1;
        css.arrayCertStore = &hcertstor;
        css.cCertContext = 0;
        css.arrayCertContext = &pccert;
        css.lCustData = 0;
        css.pfnHook = NULL;
        if (IFilter > 0) {
            css.pfnFilter = FILTER;
        }
        else {
            css.pfnFilter = NULL;
        }
        css.szHelpFileName = "Help File";
        css.dwHelpId = 100;

        if (CertSelectCertificateA(&css)) {

            CERT_VIEWPROPERTIES_STRUCT_A cvp;
            memset(&cvp, 0, sizeof(cvp));

            cvp.dwSize = sizeof(cvp);
            cvp.pCertContext = pccert;
            cvp.dwFlags |= CM_SHOW_HELP;
            cvp.cArrayPurposes = 1;
            cvp.arrayPurposes = (LPSTR *) &css.szPurposeOid;
            cvp.szHelpFileName = "Help File";
            cvp.dwHelpId = 100;

            CertViewPropertiesA(&cvp);
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\view.cpp ===
#include        "pch.hxx"
#ifndef WIN16
#include        <commctrl.h>
#endif // !WIN16
#include        <stdio.h>
#include        <limits.h>
#ifndef WIN16
#include        "wintrust.h"
#endif // !WIN16
#include        "demand.h"
#include        <iehelpid.h>



#ifndef WIN16
//  Fix a Win95 problem
#undef TVM_SETITEM
#define TVM_SETITEM TVM_SETITEMA
#undef TVM_GETITEM
#define TVM_GETITEM TVM_GETITEMA
#endif // !WIN16

extern HINSTANCE        HinstDll;
#ifndef MAC
extern HMODULE          HmodRichEdit;
#endif  // !MAC
BOOL CertViewPropertiesX(PCERT_VIEWPROPERTIES_STRUCT_W pcvp);

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

#define VIEW_HELPER_SENTRY  0x424A4800
typedef struct {
    DWORD                               dwSentry;   // Must be set to value of VIEW_HELPER_SENTRY
    PCERT_VIEWPROPERTIES_STRUCT_W       pcvp;
    DWORD                               ccf;        // Count of frames
    PCCertFrame                         rgpcf[20];  // Array of frames
    HTREEITEM                           hItem;      // Leaf item in trust view
    HANDLE                              hWVTState;  // WinVerifyTrust state handle

    // CryptUI version only
    PCCERT_CONTEXT                      pccert;     // Cert context goes here
    ULONG                               icf;        // index in rgpcf of this cert.
} VIEW_HELPER;

typedef struct {
    DLGPROC                             pfnDlgProc;
    LPARAM                              lParam;
} VIEW_CALLBACK_HELPER;

const HELPMAP RgctxGeneral[] = {
    {IDC_FINE_PRINT,                    IDH_CERTVWPROP_GEN_FINEPRINT}
};

const HELPMAP RgctxDetails[] = {
    {IDC_ISSUED_BY,                     IDH_CERTVWPROP_DET_ISSUER_CERT},
    {IDC_FRIENDLY_NAME,                 IDH_CERTVWPROP_DET_FRIENDLY},
    {IDC_TRUST_IMAGE,                   IDH_CERTVWPROP_DET_STATUS},
    {IDC_IS_TRUSTED,                    IDH_CERTVWPROP_DET_STATUS},
    {IDC_IS_VALID,                      IDH_CERTVWPROP_DET_STATUS}
};


const HELPMAP RgctxTrust[] = {
    {IDC_TRUST_LIST,                    IDH_CERTVWPROP_TRUST_PURPOSE},
    {IDC_TRUST_TREE,                    IDH_CERTVWPROP_TRUST_HIERAR},
    {IDC_TRUST_VIEW,                    IDH_CERTVWPROP_TRUST_VIEWCERT},
    {IDC_TRUST_INHERIT,                 IDH_CERTVWPROP_TRUST_INHERIT},
    {IDC_TRUST_YES,                     IDH_CERTVWPROP_TRUST_EXPLICIT_TRUST},
    {IDC_TRUST_NO,                      IDH_CERTVWPROP_TRUST_EXPLICIT_DISTRUST}
};

const HELPMAP RgctxAdvanced[] = {
    {IDC_LIST1,                         IDH_CERTVWPROP_ADV_FIELD},
    {IDC_EDIT1,                         IDH_CERTVWPROP_ADV_DETAILS}
};


////////////////////////////////////////////////////////

VIEW_HELPER * GetViewHelperFromPropSheetPage(PROPSHEETPAGE *ps) {
    VIEW_HELPER * pviewhelp;
    ULONG i;

    pviewhelp = (VIEW_HELPER *)(ps->lParam);
    if (pviewhelp->dwSentry != VIEW_HELPER_SENTRY) {
        // Assume that CryptUI has passed us a wrapped lparam/cert pair
        // typedef struct tagCRYPTUI_INITDIALOG_STRUCT {
        //    LPARAM          lParam;
        //    PCCERT_CONTEXT  pCertContext;
        // } CRYPTUI_INITDIALOG_STRUCT, *PCRYPTUI_INITDIALOG_STRUCT;

        PCRYPTUI_INITDIALOG_STRUCT pCryptUIInitDialog = (PCRYPTUI_INITDIALOG_STRUCT)pviewhelp;
        pviewhelp = (VIEW_HELPER *)pCryptUIInitDialog->lParam;
        if (pviewhelp->dwSentry != VIEW_HELPER_SENTRY) {
            // Bad lparam
            return(NULL);
        }
        pviewhelp->pccert = pCryptUIInitDialog->pCertContext;

        // Find the correct frame in the array
        pviewhelp->icf = 0;
        for (i = 0; i < pviewhelp->ccf; i++) {
            if (CertCompareCertificate(X509_ASN_ENCODING,
              pviewhelp->rgpcf[i]->m_pccert->pCertInfo, pviewhelp->pccert->pCertInfo)) {
                pviewhelp->icf = i;
                break;
            }
        }
    }
    return(pviewhelp);
}


void ShowHelp(HWND hwnd, VIEW_HELPER * pviewhelp) {
    if (FIsWin95) {
        WinHelpA(hwnd, (LPSTR)pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
          pviewhelp->pcvp->dwHelpId);
    }
#if !defined( MAC ) && !defined( WIN16 )
    else {
        WinHelpW(hwnd, pviewhelp->pcvp->szHelpFileName, HELP_CONTEXT,
          pviewhelp->pcvp->dwHelpId);
    }
#endif  // !MAC && !WIN16
}


INT_PTR CALLBACK ViewPageGeneral(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fTrust;
    HANDLE              hGraphic;
    int                 i1;
    DWORD               i;
    PCCERT_CONTEXT      pccert;
    ENLINK *            penlink;
    PROPSHEETPAGE *     ps;
    VIEW_HELPER *       pviewhelp;
    LPWSTR              pwsz;
    WCHAR               rgwch[200];
    LPWSTR              rgpwsz[4];
    UINT                rguiStrings[7];

    switch ( msg ) {
    case WM_INITDIALOG:
        //
        //  Stash the item in the header
        //

        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);

        //
        //  Pick up and format the general message texts
        //

        rguiStrings[0] = IDS_GENERAL_DESC;
        rguiStrings[1] = IDS_GENERAL_DESC2;
        rguiStrings[2] = IDS_GENERAL_DESC3;
        rguiStrings[3] = IDS_GENERAL_DESC4;
        rguiStrings[4] = IDS_GENERAL_DESC5;
        rguiStrings[5] = IDS_GENERAL_DESC6;
        rguiStrings[6] = UINT_MAX;
        LoadStringsInWindow(hwndDlg, IDC_GENERAL_DESC, HinstDll, rguiStrings);

        rgpwsz[0] = PrettySubject(pccert);
        rgpwsz[1] = PrettyIssuer(pccert);
        //        rgpwsz[2] = FindURL(pccert);
        rgpwsz[2] = NULL;
        rgpwsz[3] = (LPWSTR) -1;               // Sentinal Value

        LoadString(HinstDll, IDS_GENERAL_INFO, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY, rgwch,
                      0, 0, (LPWSTR) &pwsz, 0, (va_list *) rgpwsz);

        SetDlgItemText(hwndDlg, IDC_TEXT, pwsz);

        if (rgpwsz[2] != NULL) {
            i1 = (int) (wcsstr(pwsz, rgpwsz[1]) - pwsz);
            if (i1 >= 0) {
                CHARFORMATA  cf = {sizeof(cf), CFM_UNDERLINE | CFM_LINK,
                                   CFE_UNDERLINE | CFE_LINK};
                SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETSEL,
                                   i1, i1+wcslen(rgpwsz[1]));
                SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETCHARFORMAT,
                                   SCF_SELECTION, (LPARAM) &cf);
                SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETEVENTMASK, 0,
                                   ENM_LINK);
                SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETSEL, 0, 0);
            }
        }

        //  Grey out the rich edit box

        SendDlgItemMessage(hwndDlg, IDC_TEXT, EM_SETBKGNDCOLOR, 0,
                           GetSysColor(COLOR_3DFACE));

        //
        //  Now that we have determined what the trust status is, display the
        //      correct string and image
        //

        if (pviewhelp->rgpcf[0]->m_dwFlags == 0) {
            if (pviewhelp->pcvp->cArrayPurposes == 0) {
                fTrust = TRUE;
            }
            else {
                for (i=0, fTrust = TRUE; i<pviewhelp->pcvp->cArrayPurposes; i++) {
                    fTrust &= pviewhelp->rgpcf[0]->m_rgTrust[i].fTrust;
                }
            }
        }
        else {
            fTrust = FALSE;
        }

#ifndef WIN16
        hGraphic = LoadImageA(HinstDll, (LPSTR) MAKEINTRESOURCE(IDB_TICK+!fTrust),
                       IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
#else
        hGraphic = LoadBitmap(HinstDll,
                              (LPSTR) MAKEINTRESOURCE(IDB_TICK+!fTrust));
#endif
        SendDlgItemMessageA(hwndDlg, IDC_CERT_STATUS_IMAGE, STM_SETIMAGE,
                            IMAGE_BITMAP, (LPARAM) hGraphic);
        LoadStringInWindow(hwndDlg, IDC_CERT_STATUS, HinstDll,
                           IDS_GENERAL_TICK + !fTrust);


        //


        //  Free out the buffers
#ifndef WIN16
        LocalFree(pwsz);
#else
        LocalFree((HLOCAL)pwsz);
#endif
        if (rgpwsz[0])
            free(rgpwsz[0]);
        if (rgpwsz[1])
            free(rgpwsz[1]);
        if (rgpwsz[2])
            free(rgpwsz[2]);

        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case EN_LINK:
            penlink = (ENLINK *) lParam;
            if (penlink->msg == WM_LBUTTONUP) {
                break;
            }
            break;

        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

    case WM_COMMAND:
        if (LOWORD(wParam) == IDC_FINE_PRINT) {
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            FinePrint(pviewhelp->pcvp->pCertContext, hwndDlg);
            return TRUE;
        }
        else if (LOWORD(wParam) == IDHELP) {
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxGeneral);
#endif  // !MAC
    }

    return FALSE;
}

INT_PTR CALLBACK ViewPageDetails(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CRYPT_DATA_BLOB     blob;
    DWORD               cch;
    BOOL                fNotTrust;
    BOOL                fInvalid;
    BOOL                f;
    HANDLE              h;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    VIEW_HELPER *       pviewhelp;
    LPWSTR              pwsz;

    switch ( msg ) {
    case WM_INITDIALOG:
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);
        pccert = pviewhelp->pcvp->pCertContext;

        FormatSubject(hwndDlg, IDC_ISSUED_TO, pccert);
        FormatIssuer(hwndDlg, IDC_ISSUED_BY, pccert);

        FormatValidity(hwndDlg, IDC_VALIDITY, pccert);
        FormatAlgorithm(hwndDlg, IDC_ALGORITHM, pccert);
        FormatSerialNo(hwndDlg, IDC_SERIAL_NUMBER, pccert);
        FormatThumbprint(hwndDlg, IDC_THUMBPRINT, pccert);

        pwsz = PrettySubject(pccert);
        SetDlgItemText(hwndDlg, IDC_FRIENDLY_NAME, pwsz);
        free(pwsz);

        if (pviewhelp->pcvp->dwFlags & CM_NO_NAMECHANGE) {
            SendDlgItemMessageA(hwndDlg, IDC_FRIENDLY_NAME, EM_SETREADONLY,
                                1, 0);
        }

        //
        //  Play with the validity and trust items at the bottom of the page.
        //

        fInvalid = (pviewhelp->rgpcf[0]->m_dwFlags != 0);
        if (pviewhelp->rgpcf[0]->m_rgTrust == NULL) {
            fNotTrust = FALSE;
            ShowWindow(GetDlgItem(hwndDlg, IDC_IS_TRUSTED), FALSE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_IS_TRUSTED), FALSE);
        }
        else {
            fNotTrust = !pviewhelp->rgpcf[0]->m_rgTrust[0].fTrust;
        }

#ifndef WIN16
        h = LoadImageA(HinstDll,
                       (LPSTR) MAKEINTRESOURCE(IDB_TICK+(fNotTrust||fInvalid)),
                       IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
#else
        h = LoadBitmap(HinstDll,
                       (LPSTR) MAKEINTRESOURCE(IDB_TICK+(fNotTrust||fInvalid)));
#endif
        SendDlgItemMessageA(hwndDlg, IDC_TRUST_IMAGE, STM_SETIMAGE,
                            IMAGE_BITMAP, (LPARAM) h);
        LoadStringInWindow(hwndDlg, IDC_IS_VALID, HinstDll,
                           IDS_DETAIL_VALID_TICK + fInvalid);
        LoadStringInWindow(hwndDlg, IDC_IS_TRUSTED, HinstDll,
                           IDS_DETAIL_TRUST_TICK + fNotTrust);

#ifdef MAC
        if (fInvalid) {
            HWND        hwnd;
            hwnd = CreateWindowA(TOOLTIPS_CLASSA, NULL, TTS_ALWAYSTIP,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                hwndDlg, NULL, HinstDll, NULL);
            TOOLINFO    ti;
            ti.cbSize = sizeof(TOOLINFO);
            ti.uFlags = TTF_SUBCLASS;
            ti.hwnd = hwndDlg;
            ti.hinst = HinstDll;
            GetWindowRect(GetDlgItem(hwndDlg, IDC_TRUST_GROUP), &ti.rect);
            ti.uId = 0;
            ti.lpszText = FormatValidityFailures(pviewhelp->rgpcf[0]->m_dwFlags);
            SendMessageA(hwnd, TTM_ADDTOOL, 0, (LPARAM) &ti);

        }

        if (pviewhelp->ccf < 2) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_VIEW_ISSUER), FALSE);
        }
        SendDlgItemMessageA(hwndDlg, IDC_ISSUED_TO, EM_SETSEL, 0,0);
#else   // !MAC
        if (fInvalid) {
            HWND        hwnd;
            hwnd = CreateWindow(TOOLTIPS_CLASS, NULL, TTS_ALWAYSTIP,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                hwndDlg, NULL, HinstDll, NULL);
            TOOLINFO    ti;
            ti.cbSize = sizeof(TOOLINFO);
            ti.uFlags = TTF_SUBCLASS;
            ti.hwnd = hwndDlg;
            ti.hinst = HinstDll;
            GetWindowRect(GetDlgItem(hwndDlg, IDC_TRUST_GROUP), &ti.rect);
            ti.uId = 0;
            ti.lpszText = FormatValidityFailures(pviewhelp->rgpcf[0]->m_dwFlags);
            SendMessage(hwnd, TTM_ADDTOOL, 0, (LPARAM) &ti);

        }

        if (pviewhelp->ccf < 2) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_VIEW_ISSUER), FALSE);
        }
        SendDlgItemMessage(hwndDlg, IDC_ISSUED_TO, EM_SETSEL, 0,0);
#endif  // MAC

        SetFocus(GetDlgItem(hwndDlg, IDC_FRIENDLY_NAME));

        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
        return FALSE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            //  Only thing to do is to write back the Friendly name
            f = FALSE;
            cch = (DWORD) SendDlgItemMessage(hwndDlg, IDC_FRIENDLY_NAME,
                                     WM_GETTEXTLENGTH, 0, 0);
            if (cch) {
                // Must have a name!
                pwsz = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
                if (pwsz) {
                    GetDlgItemText(hwndDlg, IDC_FRIENDLY_NAME, pwsz, cch+1);

                    pccert = ((VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER))->pcvp->pCertContext;
                    if (pccert) {
                        blob.pbData = (LPBYTE) pwsz;
                        blob.cbData = (cch+1)*sizeof(WCHAR);
                        f = CertSetCertificateContextProperty(pccert,
                                                              CERT_FRIENDLY_NAME_PROP_ID, 0,
                                                              &blob);
                    }
                    free(pwsz);
                }
            }

            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR) f);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            //  Only thing to do is to write back the Friendly name
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);

#if 0
            pccert = ((VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER))->pcvp->pCertContext;
            pwsz = PrettySubject(pccert);
            SetDlgItemText(hwndDlg, IDC_FRIENDLY_NAME, pwsz);
            free(pwsz);
#endif // 0
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_FRIENDLY_NAME:
            //  If they edit the friendly name, let us know
            if (HIWORD(wParam) == EN_CHANGE) {
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDC_VIEW_ISSUER:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (FIsWin95) {
                CERT_VIEWPROPERTIES_STRUCT_A        cvps;

                memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pviewhelp->rgpcf[1]->m_pccert;

                CertViewPropertiesA(&cvps);
            }
#ifndef WIN16
#ifndef MAC
            else {
                CERT_VIEWPROPERTIES_STRUCT_W        cvps;

                memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = pviewhelp->rgpcf[1]->m_pccert;

                CertViewPropertiesW(&cvps);
            }
#endif  // !MAC
#endif // !WIN16
            return TRUE;

        case IDC_WHY:
            break;

        case IDHELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxDetails);
#endif  // !MAC
    }

    return FALSE;
}

INT_PTR CALLBACK ViewPageTrust(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               cb;
    BOOL                f;
    HBITMAP             hBmp;
    HIMAGELIST          hIml;
    HTREEITEM           hItem;
    int                 i;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    VIEW_HELPER *       pviewhelp;
    LPWSTR              pwsz;
    TV_ITEM             tvi;
    TV_INSERTSTRUCT     tvins;
    UINT                rguiStrings[5];
    WCHAR               rgwch[256];

    switch ( msg ) {
    case WM_INITDIALOG:
        //  Pick up the parameter so we have all of the data
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pviewhelp);

        //  Put the long text into the window
        rguiStrings[0] = IDS_TRUST_DESC;
        rguiStrings[1] = IDS_TRUST_DESC2;
        rguiStrings[2] = IDS_TRUST_DESC4;
        rguiStrings[3] = IDS_TRUST_DESC4;
        rguiStrings[4] = UINT_MAX;
        LoadStringsInWindow(hwndDlg, IDC_TRUST_DESC, HinstDll, rguiStrings);

        //  Populate the trust line
        if (pviewhelp->pcvp->cArrayPurposes == 1) {
            cb = sizeof(rgwch);
            f = CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL,
                                  pviewhelp->pcvp->arrayPurposes[0],
                                  NULL, 0, rgwch, &cb);
            if (f && (rgwch[0] != 0)) {
                SetDlgItemText(hwndDlg, IDC_TRUST_EDIT, rgwch);
            }
            else {
                SetDlgItemTextA(hwndDlg, IDC_TRUST_EDIT,
                                pviewhelp->pcvp->arrayPurposes[0]);
            }
        }
        else {
            ShowWindow(GetDlgItem(hwndDlg, IDC_TRUST_LIST), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_TRUST_EDIT), SW_HIDE);
        }

        //  Build up the image list for the control

        hIml = ImageList_Create(16, 16, FALSE, 6, 0);
        hBmp = LoadBitmapA(HinstDll, (LPSTR) MAKEINTRESOURCE(IDB_TREE_IMAGES));
        ImageList_Add(hIml, hBmp, NULL);
        DeleteObject(hBmp);

        TreeView_SetImageList(GetDlgItem(hwndDlg, IDC_TRUST_TREE), hIml, 0);

        //  Populate the tree control

        tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
        hItem = TVI_ROOT;

        for (i=pviewhelp->ccf-1; i>= 0; i--) {
            tvins.hParent = hItem;
            tvins.hInsertAfter = TVI_FIRST;
            pwsz = PrettySubject(pviewhelp->rgpcf[i]->m_pccert);
            tvins.item.pszText = pwsz;
            tvins.item.cchTextMax = lstrlen(pwsz);
            if (pviewhelp->rgpcf[i]->m_rgTrust[0].fTrust) {
                tvins.item.iImage = 2;
            }
            else if (pviewhelp->rgpcf[i]->m_rgTrust[0].fDistrust) {
                tvins.item.iImage = 0;
            }
            else {
                tvins.item.iImage = 1;
            }
            if (pviewhelp->rgpcf[i]->m_fSelfSign) {
                tvins.item.iImage += 3;
            }
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (LPARAM) pviewhelp->rgpcf[i]->m_pccert;
            hItem = (HTREEITEM) SendDlgItemMessage(hwndDlg, IDC_TRUST_TREE,
                                                   TVM_INSERTITEM, 0,
                                                   (LPARAM) &tvins);
            if (i != (int) (pviewhelp->ccf-1)) {
                TreeView_Expand(GetDlgItem(hwndDlg, IDC_TRUST_TREE),
                                tvins.hParent, TVE_EXPAND);
            }
        }

        pviewhelp->hItem = hItem;

        //
        //  If the leaf cert is in the root store, then disable all items
        //

        if (pviewhelp->rgpcf[0]->m_fRootStore) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_NO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_YES), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_INHERIT), FALSE);
        }
        else {
            //
            //  Populate the radio button from the leaf cert
            //

            if (pviewhelp->rgpcf[0]->m_rgTrust[0].fExplicitDistrust) {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_NO, BM_SETCHECK, 1, 0);
            }
            else if (pviewhelp->rgpcf[0]->m_rgTrust[0].fExplicitTrust) {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_YES, BM_SETCHECK, 1, 0);
            }
            else {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_INHERIT, BM_SETCHECK, 1, 0);
                if (pviewhelp->rgpcf[0]->m_fSelfSign) {
                    pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust = 4;
                }
            }

            if (pviewhelp->rgpcf[0]->m_fSelfSign) {
                EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_INHERIT), FALSE);
            }
        }
        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            //
            //  We have been asked to save any changes we have.  The only possible
            //  item that the trust on the leaf has been changed.  Check to see
            //  if this was done and do the appropriate thing
            //

            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust != 0) {
                if (pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust == 4) {
                    f = FALSE;
                }
                else {
                    f = FModifyTrust(hwndDlg, pviewhelp->rgpcf[0]->m_pccert,
                                     pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust,
                                     pviewhelp->pcvp->arrayPurposes[0]);
                }
            }
            else {
                f = TRUE;
            }
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR) f);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            break;

        case TVN_SELCHANGEDA:
#ifndef WIN16
        case TVN_SELCHANGEDW:
#endif // !WIN16
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_VIEW),
                       ((NM_TREEVIEW *) lParam)->itemNew.hItem != pviewhelp->hItem);
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_TRUST_INHERIT:
        case IDC_TRUST_NO:
        case IDC_TRUST_YES:
            //
            //  The explicit trust has been changed for the leaf, make the
            //  appropriate change to the tree control for the modification
            //

            if (HIWORD(wParam) == BN_CLICKED) {
                pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

                pviewhelp->rgpcf[0]->m_rgTrust[0].newTrust = (LOWORD(wParam) -
                                                              IDC_TRUST_NO) + 1;

                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

                tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_HANDLE;
                tvi.hItem = pviewhelp->hItem;
                if (LOWORD(wParam) == IDC_TRUST_INHERIT) {
                    if (pviewhelp->rgpcf[0]->m_rgTrust[0].fTrust) {
                        tvi.iImage = 2;
                    }
                    else if (pviewhelp->rgpcf[0]->m_rgTrust[0].fDistrust) {
                        tvi.iImage = 0;
                    }
                    else {
                        tvi.iImage = 1;
                    }
                }
                else if (LOWORD(wParam) == IDC_TRUST_YES) {
                    tvi.iImage = 2;
                }
                else {
                    tvi.iImage = 0;
                }
                tvi.iSelectedImage = tvi.iImage;

                TreeView_SetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
            }
            break;

        case IDC_TRUST_VIEW:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);

            hItem = TreeView_GetSelection(GetDlgItem(hwndDlg, IDC_TRUST_TREE));

            tvi.mask = TVIF_HANDLE | TVIF_PARAM;
            tvi.hItem = hItem;
            TreeView_GetItem(GetDlgItem(hwndDlg, IDC_TRUST_TREE), &tvi);
#ifndef MAC
            if (FIsWin95) {
#endif  // !MAC
                CERT_VIEWPROPERTIES_STRUCT_A        cvps;

                memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = (PCCERT_CONTEXT) tvi.lParam;

                i = CertViewPropertiesA(&cvps);
#ifndef MAC
            }
#ifndef WIN16
            else {
                CERT_VIEWPROPERTIES_STRUCT_W        cvps;

                memcpy(&cvps, pviewhelp->pcvp, sizeof(cvps));
                cvps.hwndParent = hwndDlg;
                cvps.pCertContext = (PCCERT_CONTEXT) tvi.lParam;

                i = CertViewPropertiesW(&cvps);
            }
#endif // !WIN16
#endif  // !MAC

            //
            if (i) {
                // M00BUG -- must rebuild all trust lists
            }
            return TRUE;

        case IDHELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxTrust);
#endif  // !MAC
    }

    return FALSE;
}

INT_PTR CALLBACK ViewPageAdvanced(HWND hwndDlg, UINT msg, WPARAM wParam,
                               LPARAM lParam)
{
    DWORD               cb;
    BOOL                f;
    DWORD               i;
    PROPSHEETPAGE *     ps;
    PCCERT_CONTEXT      pccert;
    VIEW_HELPER *       pviewhelp;
    LPWSTR              pwsz;
    WCHAR               rgwch[200];

    switch ( msg ) {
    case WM_INITDIALOG:
        ps = (PROPSHEETPAGE *) lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }
        pccert = pviewhelp->pcvp->pCertContext;
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pccert);

        //
        //  Stick the "normal" items into the list
        //

        for (i=IDS_ADV_VERSION; i<= IDS_ADV_PUBKEY; i++) {
            LoadString(HinstDll, i, rgwch, sizeof(rgwch)/sizeof(WCHAR));
            SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0,
                               (LPARAM) rgwch);
        }

        //
        //  Stick the extensions into the list
        //

        for (i=0; i<pccert->pCertInfo->cExtension; i++) {
            if (FIsWin95) {
                SendDlgItemMessageA(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0,
                              (LPARAM) pccert->pCertInfo->rgExtension[i].pszObjId);
            }
#ifndef MAC
            else {
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                    pccert->pCertInfo->rgExtension[i].pszObjId, -1,
                                    rgwch, sizeof(rgwch)/sizeof(WCHAR));
                SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0,
                                   (LPARAM) rgwch);
            }
#endif  // !MAC
        }

        SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_SETCURSEL, 0, 0);
        ViewPageAdvanced(hwndDlg, WM_COMMAND,
                         MAKELONG(IDC_LIST1, LBN_SELCHANGE), 0);

        SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_SETEVENTMASK, 0, ENM_LINK);
        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            break;

        case EN_LINK:
            if (((ENLINK FAR *) lParam)->msg == WM_LBUTTONDOWN) {
                f = FNoteDlgNotifyLink(hwndDlg, (ENLINK *) lParam, NULL);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR) f);
                return f;
            }
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_LIST1:
            if (HIWORD(wParam) == LBN_SELCHANGE) {
                pccert = (PCERT_CONTEXT) GetWindowLongPtr(hwndDlg, DWLP_USER);

                i = (int) SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_GETCARETINDEX,
                                       0, 0);
                if (i <= IDS_ADV_PUBKEY - IDS_ADV_VERSION) {
                    switch (i + IDS_ADV_VERSION) {
                    case IDS_ADV_VERSION:         // Version
                        rgwch[0] = L'V';
                        rgwch[1] = (WCHAR) ('0' + pccert->pCertInfo->dwVersion+1);
                        rgwch[2] = 0;
                        SetDlgItemText(hwndDlg, IDC_EDIT1, rgwch);
                        break;

                    case IDS_ADV_SER_NUM:       // Serial Number
                        FormatSerialNo(hwndDlg, IDC_EDIT1, pccert);
                        break;

                    case IDS_ADV_SIG_ALG:       // Signature Alg
                        FormatAlgorithm(hwndDlg, IDC_EDIT1, pccert);
                        break;

                    case IDS_ADV_ISSUER:        // Issuer
                        FormatIssuer(hwndDlg, IDC_EDIT1, pccert,
                                     CERT_X500_NAME_STR);
                        break;

                    case IDS_ADV_SUBJECT:       // Subject
                        FormatSubject(hwndDlg, IDC_EDIT1, pccert,
                                      CERT_X500_NAME_STR);
                        break;

                    case IDS_ADV_PUBKEY:        // Public Key
                        FormatBinary(hwndDlg, IDC_EDIT1,
                         pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                         pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);
                        break;

                    case IDS_ADV_NOTBEFORE:     // Effective Date
                        FormatDate(hwndDlg, IDC_EDIT1,
                                   pccert->pCertInfo->NotBefore);
                        break;

                    case IDS_ADV_NOTAFTER:      // Expiration Date
                        FormatDate(hwndDlg, IDC_EDIT1,
                                   pccert->pCertInfo->NotAfter);
                        break;
                    }
                }
                else {
                    i -= (IDS_ADV_PUBKEY - IDS_ADV_VERSION + 1);
                    // Assert( i < pccert->pCertInfo->cExtension );

                    cb = 0;
                    f = CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL,
                                    pccert->pCertInfo->rgExtension[i].pszObjId,
                                    pccert->pCertInfo->rgExtension[i].Value.pbData,
                                    pccert->pCertInfo->rgExtension[i].Value.cbData,
                                    0, &cb);
                    if (f && (cb > 0)) {
                        pwsz = (LPWSTR) malloc(cb * sizeof(WCHAR));
                        pwsz[0] = 0;
                        CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL,
                                    pccert->pCertInfo->rgExtension[i].pszObjId,
                                    pccert->pCertInfo->rgExtension[i].Value.pbData,
                                    pccert->pCertInfo->rgExtension[i].Value.cbData,
                                    pwsz, &cb);
                        SetDlgItemText(hwndDlg, IDC_EDIT1, pwsz);

                        RecognizeURLs(GetDlgItem(hwndDlg, IDC_EDIT1));
                        free(pwsz);
                    }
                    else {
                        SetDlgItemTextA(hwndDlg, IDC_EDIT1, "");
                    }
                }
            }
            break;

        case IDHELP:
            pviewhelp = (VIEW_HELPER *) GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxAdvanced);
#endif  // !MAC
    }

    return FALSE;
}


INT_PTR CALLBACK ViewPageTrustCryptUI(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD               cb;
    BOOL                f;
    PROPSHEETPAGE *     ps;
    VIEW_HELPER *       pviewhelp;
    UINT                rguiStrings[5];
    WCHAR               rgwch[256];

    switch ( msg ) {
    case WM_INITDIALOG:
        //  Pick up the parameter so we have all of the data
        ps = (PROPSHEETPAGE *)lParam;
        pviewhelp = GetViewHelperFromPropSheetPage(ps);
        if (! pviewhelp) {
            return(FALSE);
        }

        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pviewhelp);

        //  Put the long text into the window
        rguiStrings[0] = IDS_TRUST_DESC;
        rguiStrings[1] = IDS_TRUST_DESC2;
        rguiStrings[2] = IDS_TRUST_DESC4;
        rguiStrings[3] = IDS_TRUST_DESC4;
        rguiStrings[4] = UINT_MAX;
        LoadStringsInWindow(hwndDlg, IDC_TRUST_DESC, HinstDll, rguiStrings);

        //  Populate the trust line
        if (pviewhelp->pcvp->cArrayPurposes == 1) {
            cb = sizeof(rgwch);
            f = CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL,
                                  pviewhelp->pcvp->arrayPurposes[0],
                                  NULL, 0, rgwch, &cb);
            if (f && (rgwch[0] != 0)) {
                SetDlgItemText(hwndDlg, IDC_TRUST_EDIT, rgwch);
            }
            else {
                SetDlgItemTextA(hwndDlg, IDC_TRUST_EDIT,
                                pviewhelp->pcvp->arrayPurposes[0]);
            }
        }
        else {
            ShowWindow(GetDlgItem(hwndDlg, IDC_TRUST_LIST), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_TRUST_EDIT), SW_HIDE);
        }

        //
        //  If the leaf cert is in the root store, then disable all items
        //
        if (pviewhelp->rgpcf[pviewhelp->icf]->m_fRootStore ||
                !pviewhelp->rgpcf[pviewhelp->icf]->m_fLeaf) {
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_NO), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_YES), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_INHERIT), FALSE);
        }
        else {
            //
            //  Populate the radio button from the leaf cert
            //

            if (pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].fExplicitDistrust) {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_NO, BM_SETCHECK, 1, 0);
            }
            else if (pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].fExplicitTrust) {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_YES, BM_SETCHECK, 1, 0);
            }
            else {
                SendDlgItemMessage(hwndDlg, IDC_TRUST_INHERIT, BM_SETCHECK, 1, 0);
                if (pviewhelp->rgpcf[pviewhelp->icf]->m_fSelfSign) {
                    pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust = 4;
                }
            }

            if (pviewhelp->rgpcf[pviewhelp->icf]->m_fSelfSign) {
                EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_INHERIT), FALSE);
            }

            if (pviewhelp->rgpcf[pviewhelp->icf]->m_fExpired) {
                EnableWindow(GetDlgItem(hwndDlg, IDC_TRUST_YES), FALSE);
            }
        }
        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            //
            //  We have been asked to save any changes we have.  The only possible
            //  item that the trust on the leaf has been changed.  Check to see
            //  if this was done and do the appropriate thing
            //

            pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);
            if (pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust != 0) {
                if (pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust == 4) {
                    f = FALSE;
                }
                else {
                    f = FModifyTrust(hwndDlg, pviewhelp->rgpcf[pviewhelp->icf]->m_pccert,
                                     pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust,
                                     pviewhelp->pcvp->arrayPurposes[0]);
                }
            }
            else {
                f = TRUE;
            }
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR) f);
            break;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;

        case PSN_RESET:
            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
            break;

        case PSN_HELP:
            pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_TRUST_INHERIT:
        case IDC_TRUST_NO:
        case IDC_TRUST_YES:
            //
            //  The explicit trust has been changed for the cert.
            //
            if (HIWORD(wParam) == BN_CLICKED) {
                pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);

                pviewhelp->rgpcf[pviewhelp->icf]->m_rgTrust[0].newTrust = (LOWORD(wParam) - IDC_TRUST_NO) + 1;

                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }
            break;

        case IDHELP:
            pviewhelp = (VIEW_HELPER *)GetWindowLongPtr(hwndDlg, DWLP_USER);
            ShowHelp(hwndDlg, pviewhelp);
            return TRUE;
        }
        break;

#ifndef MAC
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, RgctxTrust);
#endif  // !MAC
    }

    return FALSE;
}


HRESULT HrDoViewPropsTrustWork(PCERT_VIEWPROPERTIES_STRUCT_W pcvp,
                               VIEW_HELPER * pviewhelp, BOOL fGetState) {
    HRESULT hr;
    CCertFrame * pcfRoot = NULL;

    pviewhelp->pcvp = pcvp;

    //
    //  Lets go out and try to find out what we can on the trust and validity
    //  of this message.   This is done by calling the trust provider that is
    //  around and going to town with it
    //

    hr = HrDoTrustWork(pcvp->pCertContext, 
                       (CERT_TRUST_DO_FULL_SEARCH | 
                            (pcvp->dwFlags & 
                                (CM_ADD_CERT_STORES | ~CM_VIEWFLAGS_MASK))),
// Why would we want to mask out these errors ?????
                       (DWORD) (CERT_VALIDITY_CRL_OUT_OF_DATE |
                                CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION |
                                CERT_VALIDITY_NO_CRL_FOUND // |
                                // CERT_VALIDITY_NO_TRUST_DATA
                        ),

                       pcvp->cArrayPurposes, pcvp->arrayPurposes, pcvp->hprov,
                       pcvp->cRootStores, pcvp->rghstoreRoots,
                       pcvp->cStores, pcvp->rghstoreCAs,
                       pcvp->cTrustStores, pcvp->rghstoreTrust, NULL, 0, &pcfRoot,
                       &pviewhelp->ccf, pviewhelp->rgpcf,
                       fGetState ? &pviewhelp->hWVTState : NULL);

    if (pcfRoot) {
        delete pcfRoot;
    }

    return(hr);
}


BOOL LoadRichEdit(void) {
    //  We use the common controls -- so make sure they have been loaded
    if (HmodRichEdit == NULL) {
        HmodRichEdit = LoadLibraryA("RichEd32.dll");
        if (HmodRichEdit == NULL) {
            return(FALSE);
        }
    }
    return(TRUE);
}


BOOL CertViewPropertiesX(PCERT_VIEWPROPERTIES_STRUCT_W pcvp);


INT_PTR CALLBACK CertViewPageSubClassProc(HWND hWndDlg,  UINT nMsg,
                                       WPARAM wParam, LPARAM lParam)
{
    INT_PTR                     iReturn = FALSE;
    CRYPTUI_INITDIALOG_STRUCT*  pcids;
    PROPSHEETPAGEW*             ppsp;
    PROPSHEETPAGEW              pspTemp;
    VIEW_CALLBACK_HELPER*       pviewcbhelp;

    // For WM_INITDIALOG make sure the property sheet gets what it expects
    //  as the lParam

    if (WM_INITDIALOG == nMsg) {
        ppsp = (PROPSHEETPAGE*)lParam;
        pcids = (CRYPTUI_INITDIALOG_STRUCT*)(ppsp->lParam);
        pviewcbhelp = (VIEW_CALLBACK_HELPER*)(pcids->lParam);
        memcpy(&pspTemp, ppsp, sizeof(PROPSHEETPAGE));
        pspTemp.pfnDlgProc = pviewcbhelp->pfnDlgProc;
        pspTemp.lParam = pviewcbhelp->lParam;
        iReturn = pviewcbhelp->pfnDlgProc(hWndDlg, nMsg, wParam, 
                                          (LPARAM)&pspTemp);
        SetWindowLongPtr(hWndDlg, DWLP_DLGPROC, (LONG_PTR)pviewcbhelp->pfnDlgProc);
    }
    return iReturn;
}


BOOL CertViewUI(BOOL fWide, PCERT_VIEWPROPERTIES_STRUCT_W pcvp)
{
    ULONG                               cPages = pcvp->cArrayPropSheetPages + 1;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW     cvcs = {0};
    HRESULT                             hrTrust = E_FAIL;
    DWORD                               i;
    DWORD                               iPage;
    PROPSHEETPAGEW *                    ppsp;
    BOOL                                ret;
    VIEW_HELPER                         viewhelp = {0};
    VIEW_CALLBACK_HELPER*               pviewcbhelp = NULL;
    VIEW_CALLBACK_HELPER*               pviewcbhelp2;

    // Allocate space to hold the property sheet information to hand to 
    //  CryptUI
    
    ppsp = (PROPSHEETPAGEW *) malloc(cPages * sizeof(PROPSHEETPAGEW));

    // CryptUI insists on passing back a CRYPTUI_INITDIALOG_STRUCT when
    //  it calls the property sheet pages which breaks the existing 
    //  CryptDlg implementations.  To get around this we force everything
    //  that says it knows nothing of CryptUI to call through a local DlgProc
    //  first so that we can safely forward the lParam onto the real 
    //  property pages DlgProc.  

    // Allocate space to hold the re-direction information

    if (!(pcvp->dwFlags & CERTVIEW_CRYPTUI_LPARAM)) {
        pviewcbhelp = (VIEW_CALLBACK_HELPER*)malloc(cPages * 
                                                sizeof(VIEW_CALLBACK_HELPER));
    }                                                

    // Fill out the property sheet information
    
    if ((NULL != ppsp) && 
        ((pcvp->dwFlags & CERTVIEW_CRYPTUI_LPARAM) || (NULL != pviewcbhelp))) {

        viewhelp.dwSentry = VIEW_HELPER_SENTRY;
        hrTrust = HrDoViewPropsTrustWork(pcvp, &viewhelp, TRUE);

        if (FAILED(hrTrust)) {
            return FALSE;
        }

        if (pcvp->cArrayPurposes == 0) {
            pcvp->dwFlags |= CM_HIDE_TRUSTPAGE;
        }

        memset(ppsp, 0, cPages * sizeof(PROPSHEETPAGEW));
        iPage = 0;
        cPages = 0;
        
        if (!(pcvp->dwFlags & CM_HIDE_TRUSTPAGE)) {
            ppsp[iPage].dwSize = sizeof(ppsp[0]);
            ppsp[iPage].dwFlags = 0;    // fHelp ? PSP_HASHELP : 0;
            ppsp[iPage].hInstance = HinstDll;
            ppsp[iPage].pszTemplate = MAKEINTRESOURCE(IDD_CRYPTUI_CERTPROP_TRUST);
            ppsp[iPage].hIcon = 0;
            ppsp[iPage].pszTitle = NULL;
            ppsp[iPage].pfnDlgProc = ViewPageTrustCryptUI;
            ppsp[iPage].lParam = (LPARAM)&viewhelp;
            ppsp[iPage].pfnCallback = 0;
            ppsp[iPage].pcRefParent = NULL;
            iPage++;
            cPages++;
        }

        //
        //  Copy over the users pages
        //
        if (pcvp->cArrayPropSheetPages) {
            memcpy(&ppsp[iPage], pcvp->arrayPropSheetPages,
                   pcvp->cArrayPropSheetPages * sizeof(PROPSHEETPAGEW));
            cPages += pcvp->cArrayPropSheetPages;                   
        }

        // If the user knows nothing about the CryptUI structures, subclass
        //  the DlgProc so that they get what they expect.
        
        if (!(pcvp->dwFlags & CERTVIEW_CRYPTUI_LPARAM)) {
            for (pviewcbhelp2 = pviewcbhelp; iPage < cPages;
                 iPage++, pviewcbhelp2++) {
                pviewcbhelp2->pfnDlgProc = ppsp[iPage].pfnDlgProc;
                pviewcbhelp2->lParam = ppsp[iPage].lParam;
                ppsp[iPage].pfnDlgProc = CertViewPageSubClassProc;
                ppsp[iPage].lParam = (LPARAM)pviewcbhelp2;
            }
        }            
    } 
    else {
        // That's an error, but we'll ignore it and just not use them
        cPages = 0;
    }

    cvcs.dwSize = sizeof(cvcs);
    cvcs.hwndParent = pcvp->hwndParent;
    cvcs.dwFlags = CRYPTUI_DISABLE_ADDTOSTORE;
    if (!(pcvp->dwFlags & CM_NO_NAMECHANGE)) {
        cvcs.dwFlags |= CRYPTUI_ENABLE_EDITPROPERTIES;
    }
    cvcs.szTitle = pcvp->szTitle;
    cvcs.pCertContext = pcvp->pCertContext;
    cvcs.cPurposes = pcvp->cArrayPurposes;
    cvcs.rgszPurposes = (LPCSTR *) pcvp->arrayPurposes;
    cvcs.hWVTStateData = viewhelp.hWVTState;
    cvcs.fpCryptProviderDataTrustedUsage = hrTrust;
    // cvcs.idxSigner = 0;
    // cvcs.idxCert = 0;
    // cvcs.fCounterSigner = FALSE;
    // cvcs.idxCounterSigner = 0;
    
    cvcs.cStores = pcvp->cStores;
    cvcs.rghStores = pcvp->rghstoreCAs;
    cvcs.cPropSheetPages = cPages;
    cvcs.rgPropSheetPages = ppsp;

    //  Pages are:
    //  0 - General     - 0
    //  1 - Detail      - 1
    //  2 - Edit Trust  - 0x8000
    //  3 - Advanced    - 2
    switch (pcvp->nStartPage) {
    case 0:
    case 1:
        cvcs.nStartPage = pcvp->nStartPage;
        break;
    case 3:
        cvcs.nStartPage = 2;
	break;
    case 2:
        cvcs.nStartPage = 0x8000;
        break;
    default:
        // Add-on page, set the high bit
        if (pcvp->dwFlags & CM_HIDE_TRUSTPAGE) {
            cvcs.nStartPage = (pcvp->nStartPage - 2) | 0x8000;
        }
        else {
            cvcs.nStartPage = (pcvp->nStartPage - 3) | 0x8000;
        }
        break;
    }

// BUGBUG: CryptUI does not allow for these CryptDlg parameters:
//        pcvp->cRootStores
//        pcvp->rghstoreRoots
//        pcvp->cTrustStores
//        pcvp->rghstoreTrust
//        pcvp->hprov
//        pcvp->lCustData
//        pcvp->szHelpFileName
//        pcvp->szHelpId

    if (fWide) {
        ret = CryptUIDlgViewCertificateW(&cvcs, NULL);
    }
    else {
        ret = CryptUIDlgViewCertificateA((PCRYPTUI_VIEWCERTIFICATE_STRUCTA) &cvcs, NULL);
    }
    FreeWVTHandle(viewhelp.hWVTState);

    if (ppsp) {
        free(ppsp);
    }

    if (pviewcbhelp) {
        free(pviewcbhelp);
    }

    if (viewhelp.rgpcf != NULL) {
        for (i=0; i<viewhelp.ccf; i++) {
            delete viewhelp.rgpcf[i];
        }
    }
    
    return ret;
}

BOOL APIENTRY CertViewPropertiesA(PCERT_VIEWPROPERTIES_STRUCT_A pcvp)
{
    if (CryptUIAvailable()) {
        return CertViewUI(FALSE, (PCERT_VIEWPROPERTIES_STRUCT_W) pcvp);
    }
    

#ifndef MAC
    DWORD       cch;
#endif  // !MAC
    BOOL        ret = FALSE;
    CERT_VIEWPROPERTIES_STRUCT_W        cvpw = {0};

    if (! (LoadRichEdit())) {
        return(FALSE);
    }

    //
    //  Need to do some Wide Charactoring to move to unicode
    //

    memcpy(&cvpw, pcvp, pcvp->dwSize);

#ifndef MAC
    if (!FIsWin95) {
        if (cvpw.szTitle != NULL) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcvp->szTitle, -1,
                                      NULL, 0);
            cvpw.szTitle = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cvpw.szTitle == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }

            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcvp->szTitle, -1,
                                (LPWSTR) cvpw.szTitle, cch+1);
        }

        if (cvpw.szHelpFileName != NULL) {
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcvp->szHelpFileName, -1,
                                      NULL, 0);
            cvpw.szHelpFileName = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
            if (cvpw.szHelpFileName == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto ExitW;
            }

            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcvp->szHelpFileName, -1,
                                (LPWSTR) cvpw.szHelpFileName, cch+1);
        }
    }
#endif  // !MAC

    ret = CertViewPropertiesX(&cvpw);

#ifndef MAC
ExitW:
    if (!FIsWin95)
        {
        if (cvpw.szTitle != NULL) free((LPWSTR) cvpw.szTitle);
        if (cvpw.szHelpFileName != NULL) free((LPWSTR) cvpw.szHelpFileName);
        }
#endif  // !MAC

    return ret;
}


#ifndef WIN16
#ifndef MAC
////    CertViewPropertiesW
//
//  Description:
//      This routine will display the property view dialog for the given
//      certificate
//

BOOL CertViewPropertiesW(PCERT_VIEWPROPERTIES_STRUCT_W pcvp)
{
    if (CryptUIAvailable()) {
        return CertViewUI(TRUE, pcvp);
    }
    
    if (! (LoadRichEdit())) {
        return(FALSE);
    }

    return CertViewPropertiesX(pcvp);
}
#endif  // !MAC
#endif  // !WIN16

BOOL CertViewPropertiesX(PCERT_VIEWPROPERTIES_STRUCT_W pcvp)
{
    int                 cPages = 4;
    BOOL                fHelp;
    BOOL                fRetValue = FALSE;
    HRESULT             hr;
    PROPSHEETPAGE *     ppage = NULL;
    int                 ret;
    WCHAR               rgwch[100];
    VIEW_HELPER         viewhelp = {0};
#ifndef MAC
#ifndef WIN16
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES
    };
#else
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_LISTVIEW_CLASSES
    };
#endif // !WIN16
#endif  // !MAC

    if (pcvp->dwSize < sizeof(CERT_VIEWPROPERTIES_STRUCT_W)) {
        return FALSE;
    }

    viewhelp.dwSentry = VIEW_HELPER_SENTRY;
    //
    hr = HrDoViewPropsTrustWork(pcvp, &viewhelp, FALSE);

    if (FAILED(hr)) {
        return FALSE;
    }

    if (pcvp->cArrayPurposes == 0) {
        pcvp->dwFlags |= CM_HIDE_TRUSTPAGE;
    }

    //

    fHelp = pcvp->dwFlags & CM_SHOW_HELP;

    //
    //  Deal with some DBCS issues
    //
#ifndef MAC
    InitCommonControlsEx(&initcomm);
#endif  // !MAC

    //
    //  Build up the list of pages we are going to use in the dialog
    //

    cPages += pcvp->cArrayPropSheetPages;
    ppage = (PROPSHEETPAGE *) malloc(cPages * sizeof(PROPSHEETPAGE));
    if (ppage == NULL) {
        goto Exit;
    }

    memset(ppage, 0, cPages * sizeof(PROPSHEETPAGE));

    ppage[0].dwSize = sizeof(ppage[0]);
    ppage[0].dwFlags = fHelp ? PSP_HASHELP : 0;
    ppage[0].hInstance = HinstDll;
    ppage[0].pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_GENERAL);
    ppage[0].hIcon = 0;
    ppage[0].pszTitle = NULL;
    ppage[0].pfnDlgProc = ViewPageGeneral;
    ppage[0].lParam = (LPARAM) &viewhelp;
    ppage[0].pfnCallback = 0;
    ppage[0].pcRefParent = NULL;
    cPages = 1;

    if (!(pcvp->dwFlags & CM_HIDE_DETAILPAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = fHelp ? PSP_HASHELP : 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_DETAILS);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageDetails;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }

    if (!(pcvp->dwFlags & CM_HIDE_TRUSTPAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = fHelp ? PSP_HASHELP : 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_TRUST);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageTrust;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }

    if (!(pcvp->dwFlags & CM_HIDE_ADVANCEPAGE)) {
        ppage[cPages].dwSize = sizeof(ppage[0]);
        ppage[cPages].dwFlags = fHelp ? PSP_HASHELP : 0;
        ppage[cPages].hInstance = HinstDll;
        ppage[cPages].pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_ADVANCED);
        ppage[cPages].hIcon = 0;
        ppage[cPages].pszTitle = NULL;
        ppage[cPages].pfnDlgProc = ViewPageAdvanced;
        ppage[cPages].lParam = (LPARAM) &viewhelp;
        ppage[cPages].pfnCallback = 0;
        ppage[cPages].pcRefParent = NULL;
        cPages += 1;
    }

    //
    //  Copy over the users pages
    //

    memcpy(&ppage[cPages], pcvp->arrayPropSheetPages,
           pcvp->cArrayPropSheetPages * sizeof(PROPSHEETPAGE));
    cPages += pcvp->cArrayPropSheetPages;

#ifndef MAC
    if (FIsWin95) {
#endif  // !MAC
        PROPSHEETHEADERA     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = /*sizeof(hdr)*/ 0x28;
        hdr.dwFlags = PSH_PROPSHEETPAGE;
        hdr.hwndParent = pcvp->hwndParent;
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvp->szTitle != NULL) {
            hdr.pszCaption = (LPSTR) pcvp->szTitle;
        }
        else {
            LoadStringA(HinstDll, IDS_VIEW_TITLE, (LPSTR) rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = (LPSTR) rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = pcvp->nStartPage;
        hdr.ppsp = (PROPSHEETPAGEA *) ppage;
        hdr.pfnCallback = NULL;

        ret = (int) PropertySheetA(&hdr);
#ifndef MAC
    }
#ifndef WIN16
    else {
        PROPSHEETHEADERW     hdr;

        memset(&hdr, 0, sizeof(hdr));
        hdr.dwSize = /*sizeof(hdr)*/ 0x28;
        hdr.dwFlags = PSH_PROPSHEETPAGE;
        hdr.hwndParent = pcvp->hwndParent;
        hdr.hInstance = HinstDll;
        hdr.hIcon = NULL;
        if (pcvp->szTitle != NULL) {
            hdr.pszCaption = pcvp->szTitle;
        }
        else {
            LoadStringW(HinstDll, IDS_VIEW_TITLE, rgwch, ARRAYSIZE(rgwch));
            hdr.pszCaption = rgwch;
        }
        hdr.nPages = cPages;
        hdr.nStartPage = pcvp->nStartPage;
        hdr.ppsp = ppage;
        hdr.pfnCallback = NULL;

        ret = (int) PropertySheetW(&hdr);
    }
#endif  // !WIN16
#endif  // !MAC


    fRetValue = (ret == IDOK);

Exit:
    if (ppage)
        free(ppage);
    return fRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\util.cpp ===
#include        "pch.hxx"
#include        "demand.h"
#include        <string.h>
#include        <shellapi.h>
#include        <commctrl.h>
#include        <limits.h>

//WIn64 macros
#ifdef _WIN64
#if defined (_AMD64_) || defined (_IA64_)
#define ALIGNTYPE			LARGE_INTEGER
#else
#define ALIGNTYPE			DWORD
#endif
#define	ALIGN				((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)	(((lcb) + ALIGN) & ~ALIGN)
#define PbAlignPb(pb)		((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))
#define	MYALIGN				((POINTER_64_INT) (sizeof(ALIGNTYPE) - 1))
#define MyPbAlignPb(pb)		((LPBYTE) ((((POINTER_64_INT) (pb)) + MYALIGN) & ~MYALIGN))
#else //!WIN64
#define LcbAlignLcb(lcb)	(lcb)
#define PbAlignPb(pb)		(pb)
#define MyPbAlignPb(pb)		(pb)
#endif 

#define szOID_MICROSOFT_Encryption_Key_Preference "1.3.6.1.4.1.311.16.4"
typedef struct {
    DWORD               unused;
    CERT_NAME_BLOB      Issuer;
    CRYPT_INTEGER_BLOB  SerialNumber;
} CRYPT_RECIPIENT_ID, * PCRYPT_RECIPIENT_ID;

#if 0
//  From mssip.h

//  SPC_LINK_STRUCT
//  pvStructInfo points to SPC_LINK.
//
typedef BYTE SPC_UUID[16];
typedef struct _SPC_SERIALIZED_OBJECT
{
    SPC_UUID    ClassId;
    CRYPT_DATA_BLOB   SerializedData;
} SPC_SERIALIZED_OBJECT, *PSPC_SERIALIZED_OBJECT;


typedef struct _SPC_LINK
{
    DWORD dwLinkChoice;
    union
    {
        LPWSTR                  pwszUrl;
        SPC_SERIALIZED_OBJECT   Moniker;
        LPWSTR                  pwszFile;
    };
} SPC_LINK, *PSPC_LINK;

#define SPC_URL_LINK_CHOICE         1
#define SPC_MONIKER_LINK_CHOICE     2
#define SPC_FILE_LINK_CHOICE        3
#endif
#ifndef WIN16
#include        "wintrust.h"
#endif // !WIN16
#ifdef MAC
#include        <stdio.h>

EXTERN_C INT CALLBACK CreateDate(LPSYSTEMTIME lpst, CHAR * szOutStr, BOOL fNoYear);
EXTERN_C INT CreateTime(LPSYSTEMTIME lpst, CHAR *szOutStr, BOOL fNoSeconds);
HRESULT TdxFormatMessageVa (IN LPCSTR rgchFormat, OUT CHAR * rgchBuffer, OUT ULONG * pucReqSize, va_list marker);

#endif  // MAC

extern HINSTANCE        HinstDll;

/////////////////////////////////////////////////////////

#ifndef MAC
BOOL IsWin95()
{
    BOOL        f;
    OSVERSIONINFOA       ver;
    ver.dwOSVersionInfoSize = sizeof(ver);
    f = GetVersionExA(&ver);
    return !f || (ver.dwPlatformId == 1);
}
#endif  // !MAC

#ifndef WIN16
LRESULT MySendDlgItemMessageW(HWND hwnd, int id, UINT msg, WPARAM w, LPARAM l)
{
    char                rgch[4096];
    LPTV_INSERTSTRUCTW   ptvinsW;
    TV_INSERTSTRUCTA     tvins;

    if (msg == LB_ADDSTRING) {
        WideCharToMultiByte(CP_ACP, 0, (LPWSTR) l, -1, rgch, sizeof(rgch),
                            NULL, NULL);
        l = (LPARAM) rgch;
    }
    else if (msg == TVM_INSERTITEMW) {
        msg = TVM_INSERTITEMA;
        ptvinsW = (LPTV_INSERTSTRUCTW) l;
        memcpy(&tvins, ptvinsW, sizeof(tvins));
        WideCharToMultiByte(CP_ACP, 0, ptvinsW->item.pszText, -1, rgch,
                            sizeof(rgch), NULL, NULL);
        tvins.item.pszText = rgch;
        l = (LPARAM) &tvins;
    }

    return SendDlgItemMessageA(hwnd, id, msg, w, l);
}

BOOL MySetDlgItemTextW(HWND hwnd, int id, LPCWSTR pwsz)
{
    char        rgch[4096];

    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, rgch, sizeof(rgch), NULL, NULL);
    return SetDlgItemTextA(hwnd, id, rgch);
}

UINT MyGetDlgItemTextW(HWND hwnd, int id, LPWSTR pwsz, int nMax)
{
    UINT        cch;
    char        rgch[4096];
    cch = GetDlgItemTextA(hwnd, id, rgch, nMax);
    rgch[cch+1] = 0;

    cch = MultiByteToWideChar(CP_ACP, 0, rgch, cch+1, pwsz, nMax);

    return cch;
}

DWORD MyFormatMessageW(DWORD dwFlags, LPCVOID pbSource, DWORD dwMessageId,
                    DWORD dwLangId, LPWSTR lpBuffer, DWORD nSize,
                    va_list * args)
{
    DWORD       cch;
    int         i;
    LPSTR       pchDest;
    DWORD_PTR * pdw;
    LPWSTR      pwchOut;
    char        rgchSource[128];
    DWORD_PTR   rgdwArgs[10];
    int         cArgs = 10;
#ifdef MAC
    HRESULT     hr;
#endif  // MAC

    if (!(dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY)) {
#ifdef DEBUG
        DebugBreak();
#endif // DEBUG
        return 0;
    }

    //
    //  We need to figure out how many arguments are in the array.
    //  All Arrays are to be terminated by -1 in order for this to work.
    //

    pdw = (DWORD_PTR *) args;
    for (i=0; i<cArgs; i++) {
        if (pdw[i] == 0xffffffff) {
            cArgs = i-1;
            break;
        }
        if (pdw[i] <= 0xffff) {
            rgdwArgs[i] = pdw[i];
        }
        else {
            cch = wcslen((LPWSTR) pdw[i]);
            rgdwArgs[i] = (DWORD_PTR) malloc((cch+1));
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR) pdw[i], -1,
                                (LPSTR) rgdwArgs[i], cch+1, NULL, NULL);
        }
    }

    if (dwFlags & FORMAT_MESSAGE_FROM_STRING) {
        WideCharToMultiByte(CP_ACP, 0, (LPWSTR) pbSource, -1,
                            rgchSource, sizeof(rgchSource), NULL, NULL);
        pbSource = rgchSource;
    }
#ifdef MAC
    dwLangId;       // Unused
    dwMessageId;    // Unused

    hr = TdxFormatMessageVa ((LPCSTR) pbSource, NULL, &cch, (va_list) rgdwArgs);
    if (FAILED(hr))
    {
        return 0;
    }

    pchDest = (LPSTR) LocalAlloc(LMEM_FIXED, cch + 1);
    if (NULL == pchDest)
    {
        return 0;
    }

    hr = TdxFormatMessageVa ((LPCSTR) pbSource, pchDest, &cch, (va_list) rgdwArgs);
    if (FAILED(hr))
    {
        LocalFree(pchDest);
        return 0;
    }
#else   // !MAC
    cch = FormatMessageA(dwFlags | FORMAT_MESSAGE_ALLOCATE_BUFFER, pbSource,
                         dwMessageId, dwLangId, (LPSTR) &pchDest, 0,
                         (va_list *) rgdwArgs);
#endif  // MAC

    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
        cch = MultiByteToWideChar(CP_ACP, 0, pchDest, -1, NULL, 0);
        pwchOut = (LPWSTR) LocalAlloc(LMEM_FIXED, (cch+1)*sizeof(WCHAR));
        cch = MultiByteToWideChar(CP_ACP, 0, pchDest, -1, pwchOut, cch);
        *((LPWSTR *) lpBuffer) = pwchOut;
    }
    else {
        cch = MultiByteToWideChar(CP_ACP, 0, pchDest, -1, lpBuffer, nSize);
    }

    for (i=0; i<cArgs; i++) {
        if (rgdwArgs[i] > 0xffff) {
            free((LPVOID) rgdwArgs[i]);
        }
    }
    LocalFree(pchDest);

    return cch;
}

int MyLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cbBuffer)
{
    DWORD       cch;
    char        rgch[256];

#ifndef MAC
    if (!FIsWin95) {
        return LoadStringW(hInstance, uID, lpBuffer, cbBuffer);
    }
#endif  // !MAC

    cch = LoadStringA(hInstance, uID, rgch, sizeof(rgch));
    cch = MultiByteToWideChar(CP_ACP, 0, rgch, -1, lpBuffer, cbBuffer);
    return cch;
}

#endif // !WIN16

BOOL MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                            LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags)
{
    char        rgch1[256];
    char        rgch2[256];

    if (pszContainer != NULL) {
        WideCharToMultiByte(CP_ACP, 0, pszContainer, -1, rgch1, sizeof(rgch1),
                            NULL, NULL);
        pszContainer = (LPWSTR) rgch1;
    }
    if (pszProvider != NULL) {
        WideCharToMultiByte(CP_ACP, 0, pszProvider, -1, rgch2, sizeof(rgch2),
                            NULL, NULL);
        pszProvider = (LPWSTR) rgch2;
    }

    return CryptAcquireContextA(phProv, (LPCSTR) pszContainer, (LPCSTR) pszProvider,
                                dwProvType, dwFlags);
}

BOOL MyWinHelpW(HWND hWndMain, LPCWSTR szHelp, UINT uCommand, ULONG_PTR dwData)
{
    char        rgch[4096];

    WideCharToMultiByte(CP_ACP, 0, szHelp, -1, rgch, sizeof(rgch), NULL, NULL);
    return WinHelpA(hWndMain, rgch, uCommand, dwData);
}

////////////////////////////////////////////////////////////////

DWORD TruncateToWindowA(HWND hwndDlg, int id, LPSTR psz)
{
    int         cch = strlen(psz);
    int         cchMax;
    int         cchMid;
    int         cchMin;
    HDC         hdc;
    HFONT       hfontOld;
    HFONT       hfontNew;
    HWND        hwnd;
    SIZE        siz;
    SIZE        sizDots;
    RECT        rt;
    TEXTMETRICA tmA;

    hwnd = GetDlgItem(hwndDlg, id);
    hdc = GetDC(hwnd);
    hfontNew = (HFONT) SendMessage(hwnd, WM_GETFONT, NULL, NULL);
    if (NULL == hfontNew) {
        goto Error;
    }

    hfontOld = (HFONT) SelectObject(hdc, hfontNew);

    GetTextMetricsA(hdc, &tmA);
    GetWindowRect(hwnd, &rt);
    rt.right -= rt.left;
    GetTextExtentPointA(hdc, psz, cch, &siz);
    if (rt.right < siz.cx) {

        GetTextExtentPointA(hdc, "...", 3, &sizDots);
        rt.right -= sizDots.cx;

        for (cchMin=0, cchMax=cch, cchMid = (cchMin + cchMax + 1)/2;
             cchMin < cchMax;
             cchMid = (cchMin + cchMax + 1)/2) {
            GetTextExtentPointA(hdc, psz, cchMid, &siz);
            if (rt.right == siz.cx) {
                break;
            }
            else if (rt.right > siz.cx) {
                cchMin = cchMid;
            }
            else {
                cchMax = cchMid-1;
            }
        }

        // Make certain that we don't overflow the buffer.
        if (cchMin + 3 > cch) {     // 3 = number of characters in "...".
            cchMin = cch - 3;
        }
        strcpy(&psz[cchMin], "...");
    }

    SelectObject(hdc, hfontOld);

Error:
    ReleaseDC(hwnd, hdc);

    return TRUE;
}

DWORD TruncateToWindowW(HWND hwndDlg, int id, WCHAR * pwsz)
{
    if (FIsWin95) {
        DWORD   cch;
        char    rgch[4096];

        cch = wcslen(pwsz)+1;
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, rgch, sizeof(rgch), NULL, NULL);
        TruncateToWindowA(hwndDlg, id, rgch);
        MultiByteToWideChar(CP_ACP, 0, rgch, -1, pwsz, cch);
        return TRUE;
    }
#ifndef WIN16
#ifndef MAC
    int         cch = wcslen(pwsz);
    int         cchMax;
    int         cchMid;
    int         cchMin;
    HDC         hdc;
    HFONT       hfontOld;
    HFONT       hfontNew;
    HWND        hwnd;
    SIZE        siz;
    SIZE        sizDots;
    RECT        rt;
    TEXTMETRICW tmW;

    hwnd = GetDlgItem(hwndDlg, id);
    hdc = GetDC(hwnd);
    hfontNew = (HFONT) SendMessage(hwnd, WM_GETFONT, NULL, NULL);
    hfontOld = (HFONT) SelectObject(hdc, hfontNew);

    GetTextMetricsW(hdc, &tmW);
    GetWindowRect(hwnd, &rt);
    rt.right -= rt.left;
    GetTextExtentPointW(hdc, pwsz, cch, &siz);
    if (rt.right < siz.cx) {

        GetTextExtentPointW(hdc, L"...", 3, &sizDots);
        rt.right -= sizDots.cx;

        for (cchMin=0, cchMax=cch, cchMid = (cchMin + cchMax + 1)/2;
             cchMin < cchMax;
             cchMid = (cchMin + cchMax + 1)/2) {
            GetTextExtentPointW(hdc, pwsz, cchMid, &siz);
            if (rt.right == siz.cx) {
                break;
            }
            else if (rt.right > siz.cx) {
                cchMin = cchMid;
            }
            else {
                cchMax = cchMid-1;
            }
        }

        // Make certain that we don't overflow the buffer.
        if (cchMin + 3 > cch) {     // 3 = number of characters in L"...".
            cchMin = cch - 3;
        }
        wcscpy(&pwsz[cchMin], L"...");
    }

    SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);
#endif  // !MAC
#endif // !WIN16

    return TRUE;
}

////////////////////////////////////////////////////////////////////



#if 0
//  From authcode.h

//+-------------------------------------------------------------------------
//  SPC_SP_AGENCY_INFO_STRUCT
//  pvStructInfo points to SPC_SP_AGENCY_INFO.
//
typedef struct _SPC_IMAGE {
    PSPC_LINK             pImageLink;
    CRYPT_DATA_BLOB       Bitmap;
    CRYPT_DATA_BLOB       Metafile;
    CRYPT_DATA_BLOB       EnhancedMetafile;
    CRYPT_DATA_BLOB       GifFile;
} SPC_IMAGE, *PSPC_IMAGE;

typedef struct _SPC_SP_AGENCY_INFO {
    PSPC_LINK       pPolicyInformation;
    LPWSTR          pwszPolicyDisplayText;
    PSPC_IMAGE      pLogoImage;
    PSPC_LINK       pLogoLink;
} SPC_SP_AGENCY_INFO, *PSPC_SP_AGENCY_INFO;
#endif // 0

///////////////////////////////////////////////////////

BOOL LoadStringInWindow(HWND hwnd, UINT idCtrl, HMODULE hmod, UINT idString)
{
    WCHAR       rgwch[1024];

    if (FIsWin95) {
        LoadStringA(hmod, idString, (LPSTR) rgwch, sizeof(rgwch));

        SetDlgItemTextA(hwnd, idCtrl, (LPSTR)rgwch);
    }
#ifndef WIN16
#ifndef MAC
    else {
        LoadStringW(hmod, idString, rgwch, sizeof(rgwch)/sizeof(rgwch[0]));

        SetDlgItemText(hwnd, idCtrl, rgwch);
    }
#endif  // !MAC
#endif  // !WIN16

    return TRUE;
}

BOOL LoadStringsInWindow(HWND hwnd, UINT idCtrl, HMODULE hmod, UINT *pidStrings)
{
    BOOL    fRet = FALSE;

    if (FIsWin95) {
        UINT        cchOut;
        UINT        cbOut;
        CHAR *      pszOut;

        cbOut = 1024 * sizeof(CHAR);
        pszOut = (CHAR *) malloc(cbOut);
        if (NULL == pszOut) {
            goto ret;
        }

        for (*pszOut = '\0', cchOut = 1; *pidStrings != UINT_MAX; pidStrings++) {
            UINT        cchBuff;
            CHAR        rgchBuff[1024];

            cchBuff = LoadStringA(hmod, *pidStrings, rgchBuff, sizeof(rgchBuff));
            if (0 == cchBuff) {
                goto ErrorA;
            }

            cchOut += cchBuff;

            if (cchOut > (cbOut / sizeof(CHAR))) {
                CHAR *      pszNew;

                cbOut *= 2;

                pszNew = (CHAR *) realloc(pszOut, cbOut);
                if (NULL == pszNew) {
                    goto ErrorA;
                }

                pszOut = pszNew;
            }

            lstrcatA(pszOut, rgchBuff);
        }

        SetDlgItemTextA(hwnd, idCtrl, pszOut);
        fRet = TRUE;
ErrorA:
        free(pszOut);
    }
#if !defined( MAC ) && !defined( WIN16 )
    else {
        UINT        cwchOut;
        UINT        cbOut;
        WCHAR *     pwszOut;

        cbOut = 1024 * sizeof(WCHAR);
        pwszOut = (WCHAR *) malloc(cbOut);
        if (NULL == pwszOut) {
            goto ret;
        }

        for (*pwszOut = L'\0', cwchOut = 1; *pidStrings != UINT_MAX; pidStrings++) {
            UINT        cwchBuff;
            WCHAR       rgwchBuff[1024];

            cwchBuff = LoadStringW(hmod, *pidStrings, rgwchBuff, sizeof(rgwchBuff) / sizeof(WCHAR));
            if (0 == cwchBuff) {
                goto ErrorW;
            }

            cwchOut += cwchBuff;

            if (cwchOut > (cbOut / sizeof(WCHAR))) {
                WCHAR *      pwszNew;

                cbOut *= 2;

                pwszNew = (WCHAR *) realloc(pwszOut, cbOut);
                if (NULL == pwszNew) {
                    goto ErrorW;
                }

                pwszOut = pwszNew;
            }

            lstrcatW(pwszOut, rgwchBuff);
        }

        SetDlgItemTextW(hwnd, idCtrl, pwszOut);
        fRet = TRUE;
ErrorW:
        free(pwszOut);
    }
#endif  // !MAC && !WIN16
ret:
    return fRet;
}
///////////////////////////////////////////////////////

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

const CHAR      RgchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                             '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};


#if 0
LPWSTR FindURL(PCCERT_CONTEXT pccert)
{
    DWORD                       cbInfo;
    PCERT_EXTENSION             pExt;
    PSPC_SP_AGENCY_INFO         pInfo;
    LPWSTR                      pwsz;


    pExt = CertFindExtension("1.3.6.1.4.311.2.1.10", pccert->pCertInfo->cExtension, pccert->pCertInfo->rgExtension);
    if (pExt == NULL) {
        return NULL;
    }

    CryptDecodeObject(X509_ASN_ENCODING, (LPCSTR) 2000, pExt->Value.pbData, pExt->Value.cbData, 0, NULL, &cbInfo);
    if (cbInfo == 0) {
        return NULL;
    }
    pInfo = (PSPC_SP_AGENCY_INFO) malloc(cbInfo);
    if (!CryptDecodeObject(X509_ASN_ENCODING,  (LPCSTR) 2000, pExt->Value.pbData, pExt->Value.cbData, 0, pInfo, &cbInfo)) {
        free (pInfo);
        return NULL;
    }

    if (pInfo->pPolicyInformation->dwLinkChoice != SPC_URL_LINK_CHOICE) {
        free (pInfo);
        return NULL;
    }

#ifndef WIN16
    pwsz = _wcsdup(pInfo->pPolicyInformation->pwszUrl);
#else
    pwsz = _strdup(pInfo->pPolicyInformation->pwszUrl);
#endif // !WIN16
    free (pInfo);
    return pwsz;
}
#endif // 0


BOOL FormatAlgorithm(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    int       cch;
    LPWSTR    pszMsg;
    LPSTR     psz = pccert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
    LPWSTR    pwsz;
    DWORD_PTR rgdw[3];
#ifdef MAC
    CHAR      rgch[17];
#endif  // MAC
    WCHAR     rgwch[17];
    rgdw[2] = (DWORD) -1;               // Sentinal Value

    rgdw[1] = pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData * 8;

    if (strcmp(psz, szOID_RSA_RSA) == 0) {
        rgdw[0] = (DWORD_PTR) L"RSA";
        rgdw[1] &= 0xffffff80;          // M00BUG

#ifdef MAC
        sprintf(rgch, "%d", rgdw[1]);

        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, rgch, -1, rgwch, sizeof(rgwch) / sizeof(rgwch[0]));
#else   // !MAC
#ifndef WIN16
        _ltow((LONG) rgdw[1], rgwch, 10);
#else
        _ltoa(rgdw[1], rgwch, 10);
#endif // !WIN16
#endif  // MAC
        rgdw[1] = (DWORD_PTR) rgwch;
    }
    else {
        cch = strlen(psz)+1;
        pwsz = (LPWSTR) malloc((cch+1)*sizeof(WCHAR));
        if (pwsz == NULL) {
            return FALSE;
        }

        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, psz, cch, pwsz, cch+1);
        SetDlgItemText(hwnd, id, pwsz);
        free(pwsz);
        return TRUE;
    }

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER,
                  L"%1 (%2 bits)", 0, 0, (LPWSTR) &pszMsg, 0, (va_list *) rgdw);

    SetDlgItemText(hwnd, id, pszMsg);
#ifndef WIN16
    LocalFree((LPVOID) pszMsg);
#else
    LocalFree((HLOCAL) pszMsg);
#endif // !WIN16
    return TRUE;
}

BOOL FormatBinary(HWND hwnd, UINT id, LPBYTE pb, DWORD cb)
{
    DWORD                 i;
    LPWSTR                pwch;

    pwch = (LPWSTR) malloc( (cb*2+1)*sizeof(WCHAR));
    if (pwch == NULL) {
        return FALSE;
    }

    for (i=0; i < cb; i++, pb++) {
        pwch[i*2] = RgwchHex[(*pb & 0xf0) >> 4];
        pwch[i*2+1] = RgwchHex[*pb & 0x0f];
    }
    pwch[i*2] = 0;

    SetDlgItemText(hwnd, id, pwch);
    free(pwch);
    return TRUE;
}

////    FormatCPS
//
//  Description:
//      Look for a Certificate Policy Statment in the certificate.
//      We recognize as CPSs the following items:
//      1.  What ever PKIX comes up with
//      2.  The magic Verisign one
//

BOOL FormatCPS(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    DWORD               cb;
    BOOL                f;
    PCERT_EXTENSION     pExt;
    LPWSTR              pwsz;

    pExt = CertFindExtension("2.5.29.32", pccert->pCertInfo->cExtension,
                             pccert->pCertInfo->rgExtension);
    if (pExt != NULL) {
        cb = 0;
        f = CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL, pExt->pszObjId,
                              pExt->Value.pbData, pExt->Value.cbData, 0, &cb);
        if (f && (cb > 0)) {
            pwsz = (LPWSTR) malloc(cb * sizeof(WCHAR));
            CryptFormatObject(X509_ASN_ENCODING, 0, 0, NULL, pExt->pszObjId,
                              pExt->Value.pbData, pExt->Value.cbData,
                              pwsz, &cb);
            SetDlgItemText(hwnd, id, pwsz);

            free(pwsz);
        }
        return TRUE;
    }
    return FALSE;
}

BOOL FormatDate(HWND hwnd, UINT id, FILETIME ft)
{
    int                 cch;
    int                 cch2;
    LPWSTR              pwsz;
    SYSTEMTIME          st;
#ifdef MAC
    CHAR                rgch[256];
#else   // !MAC
    LPSTR               psz;
#endif  // MAC

    if (!FileTimeToSystemTime(&ft, &st)) {
        return FALSE;
    }

#ifdef MAC
    cch = CreateDate(&st, rgch, FALSE);
    pwsz = (LPWSTR) malloc((cch + 2)*sizeof(WCHAR));
    if (pwsz == NULL) {
        return FALSE;
    }
    cch2 = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, rgch, -1, pwsz, cch + 2);
    if (0 == cch2)
    {
        free(pwsz);
        return FALSE;
    }
    pwsz[cch2++] = L' ';

    cch = CreateTime(&st, rgch, FALSE);
    pwsz = (LPWSTR) realloc(pwsz, (cch + cch2 + 1)*sizeof(WCHAR));
    if (pwsz == NULL) {
        return FALSE;
    }
    cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, rgch, -1, pwsz + cch2, cch + 1);
    if (0 == cch)
    {
        free(pwsz);
        return FALSE;
    }
    SetDlgItemText(hwnd, id, pwsz);

#else   // !MAC
    if (FIsWin95) {
        cch = (GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) +
               GetDateFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) + 5);

        psz = (LPSTR) malloc(cch+5);
        if (psz == NULL) {
            return FALSE;
        }

        cch2 = GetDateFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, psz, cch);
        cch2 -= 1;
        psz[cch2++] = ' ';

        GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL,
                       &psz[cch2], cch-cch2);
        SetDlgItemTextA(hwnd, id, psz);
        free(psz);
        return TRUE;
    }

    cch = (GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) +
           GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0) + 5);

    pwsz = (LPWSTR) malloc((cch+5)*sizeof(WCHAR));
    if (pwsz == NULL) {
        return FALSE;
    }

    cch2 = GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, pwsz, cch);
    cch2 -= 1;
    pwsz[cch2++] = ' ';

    GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, &pwsz[cch2], cch-cch2);

#ifndef WIN16
    SetDlgItemTextW(hwnd, id, pwsz);
#else
    SetDlgItemText(hwnd, id, pwsz);
#endif // !WIN16
#endif  // MAC


    free(pwsz);
    return TRUE;
}

BOOL FormatIssuer(HWND hwnd, UINT id, PCCERT_CONTEXT pccert, DWORD dwFlags)
{
    DWORD       cch;
    LPWSTR      psz;

    cch = CertNameToStrW(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Issuer,
                         dwFlags | CERT_NAME_STR_CRLF_FLAG,
                         NULL, 0);
    psz = (LPWSTR) malloc(cch*sizeof(TCHAR));
    CertNameToStrW(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Issuer,
                   dwFlags | CERT_NAME_STR_CRLF_FLAG,
                   psz, cch);
    SetDlgItemText(hwnd, id, psz);
    free(psz);
    return TRUE;
}

BOOL FormatSerialNo(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    DWORD                 i;
    CRYPT_INTEGER_BLOB *  pblob;
    LPBYTE                pb;
    WCHAR                 rgwch[128];

    pblob = &pccert->pCertInfo->SerialNumber;
    for (i=0, pb = &pblob->pbData[pblob->cbData-1];
         i < pblob->cbData; i++, pb--) {
        rgwch[i*2] = RgwchHex[(*pb & 0xf0) >> 4];
        rgwch[i*2+1] = RgwchHex[*pb & 0x0f];
    }
    rgwch[i*2] = 0;

    TruncateToWindowW(hwnd, id, rgwch);
    SetDlgItemText(hwnd, id, rgwch);
    return TRUE;
}

BOOL FormatSubject(HWND hwnd, UINT id, PCCERT_CONTEXT pccert, DWORD dwFlags)
{
    DWORD       cch;
    LPWSTR      psz;

    cch = CertNameToStrW(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Subject,
                         dwFlags | CERT_NAME_STR_CRLF_FLAG,
                         NULL, 0);
    psz = (LPWSTR) malloc(cch*sizeof(WCHAR));
    CertNameToStrW(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Subject,
                   dwFlags | CERT_NAME_STR_CRLF_FLAG,
                   psz, cch);
    SetDlgItemText(hwnd, id, psz);
    free(psz);
    return TRUE;
}

BOOL FormatThumbprint(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    DWORD       cb;
    DWORD       i;
    BYTE        rgb[20];
    WCHAR       rgwch[61];
    WCHAR *     pwch;

    cb = sizeof(rgb);
    if (!CertGetCertificateContextProperty(pccert, CERT_MD5_HASH_PROP_ID,
                                           rgb, &cb)) {
        return FALSE;
    }

    for (i=0, pwch = rgwch; i<cb; i++, pwch += 2) {
        pwch[0] = RgwchHex[(rgb[i] & 0xf0) >> 4];
        pwch[1] = RgwchHex[rgb[i] & 0x0f];
        if (((i % 4) == 3) && (i != cb-1)) {
            pwch[2] = ':';
            pwch++;
        }
    }
    *pwch = 0;

    TruncateToWindowW(hwnd, id, rgwch);
    SetDlgItemText(hwnd, id, rgwch);
    return TRUE;
}

BOOL FormatValidity(HWND hwnd, UINT id, PCCERT_CONTEXT pccert)
{
    DWORD_PTR           rgdw[3];
    WCHAR               rgwchFormat[128];
    WCHAR               rgwchNotAfter[128];
    WCHAR               rgwchNotBefore[128];
    WCHAR               rgwchValidity[256];
    SYSTEMTIME          stNotAfter;
    SYSTEMTIME          stNotBefore;
    rgdw[2] = (DWORD) -1;               // Sentinal Value

    FileTimeToSystemTime(&pccert->pCertInfo->NotBefore, &stNotBefore);
    FileTimeToSystemTime(&pccert->pCertInfo->NotAfter, &stNotAfter);

    if (FIsWin95) {
        LoadStringA(HinstDll, IDS_VALIDITY_FORMAT,
                    (LPSTR) rgwchFormat, sizeof(rgwchFormat));
#ifdef MAC
        CreateDate(&stNotBefore, (LPSTR) rgwchNotBefore, FALSE);
        CreateDate(&stNotAfter, (LPSTR) rgwchNotAfter, FALSE);


        _snprintf((LPSTR) rgwchValidity, sizeof(rgwchNotAfter),
                  (LPSTR) rgwchFormat, rgwchNotBefore, rgwchNotAfter);
#else   // !MAC
        GetDateFormatA(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stNotBefore,
                      NULL, (LPSTR) rgwchNotBefore, sizeof(rgwchNotBefore));
        GetDateFormatA(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stNotAfter,
                      NULL, (LPSTR) rgwchNotAfter, sizeof(rgwchNotAfter));

        rgdw[0] = (DWORD_PTR) rgwchNotBefore;
        rgdw[1] = (DWORD_PTR) rgwchNotAfter;

        FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       rgwchFormat, 0,  0,
                       (LPSTR) rgwchValidity, sizeof(rgwchValidity),
                       (va_list *) rgdw);
#endif  // MAC

        SetDlgItemTextA(hwnd, id, (LPSTR) rgwchValidity);
        return TRUE;
    }
#ifndef MAC
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stNotBefore,
                  NULL, rgwchNotBefore, sizeof(rgwchNotBefore)/sizeof(WCHAR));
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stNotAfter,
                  NULL, rgwchNotAfter, sizeof(rgwchNotAfter)/sizeof(WCHAR));
    LoadString(HinstDll, IDS_VALIDITY_FORMAT, rgwchFormat,
               sizeof(rgwchFormat)/sizeof(WCHAR));

    rgdw[0] = (DWORD_PTR) rgwchNotBefore;
    rgdw[1] = (DWORD_PTR) rgwchNotAfter;

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  rgwchFormat, 0,  0,
                  rgwchValidity, sizeof(rgwchValidity)/sizeof(WCHAR),
                  (va_list *) rgdw);

    SetDlgItemText(hwnd, id, rgwchValidity);
#endif  // !MAC
    return TRUE;
}


////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//  Find the szOID_COMMON_NAME extension.
//
//  If found, allocates and converts to a WCHAR string
//
//  Returned WCHAR string needs to be CoTaskMemFree'ed.
//--------------------------------------------------------------------------
static LPWSTR GetCommonNameExtension(
    IN PCCERT_CONTEXT pCert
    )
{
    LPWSTR pwsz = NULL;
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    PCERT_NAME_VALUE pNameValue = NULL;
    PCERT_EXTENSION pExt;

    pExt = CertFindExtension(
        szOID_COMMON_NAME,
        pCertInfo->cExtension,
        pCertInfo->rgExtension
        );
    if (pExt) {
        DWORD cbInfo = 0;
        PCERT_RDN_VALUE_BLOB pValue;
        DWORD dwValueType;
        DWORD cwsz;

        CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_NAME_VALUE,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0,                      // dwFlags
            NULL,                   // pNameValue
            &cbInfo
            );
        if (cbInfo == 0) goto CommonReturn;
        if (NULL == (pNameValue = (PCERT_NAME_VALUE) /*CoTaskMemAlloc(cbInfo)))*/ malloc(cbInfo)))
            goto CommonReturn;
        if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_NAME_VALUE,
                pExt->Value.pbData,
                pExt->Value.cbData,
                0,                              // dwFlags
                pNameValue,
                &cbInfo)) goto CommonReturn;
        dwValueType = pNameValue->dwValueType;
        pValue = &pNameValue->Value;

        cwsz = CertRDNValueToStrW(
            dwValueType,
            pValue,
            NULL,               // pwsz
            0                   // cwsz
            );
        if (cwsz > 1) {
            pwsz = (LPWSTR) /*CoTaskMemAlloc(cwsz * sizeof(WCHAR))*/ malloc(cwsz*sizeof(WCHAR));
            if (pwsz)
                CertRDNValueToStrW(
                    dwValueType,
                    pValue,
                    pwsz,
                    cwsz
                    );
        }
    }

CommonReturn:
    if (pNameValue)
        /* CoTaskMemFree(pNameValue);*/ free(pNameValue);

    return pwsz;
}

//+-------------------------------------------------------------------------
//  Searches the name attributes for the first specified ObjId.
//
//  If found, allocates and converts to a WCHAR string
//
//  Returned WCHAR string needs to be CoTaskMemFree'ed.
//--------------------------------------------------------------------------
static LPWSTR GetRDNAttrWStr(
    IN LPCSTR pszObjId,
    IN PCERT_NAME_BLOB pNameBlob
    )
{
    LPWSTR pwsz = NULL;
    PCERT_NAME_INFO pNameInfo = NULL;
    PCERT_RDN_ATTR pRDNAttr;
    DWORD cbInfo = 0;

    CryptDecodeObject(
        X509_ASN_ENCODING,
        X509_NAME,
        pNameBlob->pbData,
        pNameBlob->cbData,
        0,                      // dwFlags
        NULL,                   // pNameInfo
        &cbInfo
        );
    if (cbInfo == 0) goto CommonReturn;
    if (NULL == (pNameInfo = (PCERT_NAME_INFO) /*CoTaskMemAlloc(cbInfo)*/ malloc(cbInfo)))
        goto CommonReturn;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_NAME,
            pNameBlob->pbData,
            pNameBlob->cbData,
            0,                              // dwFlags
            pNameInfo,
            &cbInfo)) goto CommonReturn;
    pRDNAttr = CertFindRDNAttr(pszObjId, pNameInfo);
    if (pRDNAttr) {
        PCERT_RDN_VALUE_BLOB pValue = &pRDNAttr->Value;
        DWORD dwValueType = pRDNAttr->dwValueType;
        DWORD cwsz;
        cwsz = CertRDNValueToStrW(
            dwValueType,
            pValue,
            NULL,               // pwsz
            0                   // cwsz
            );
        if (cwsz > 1) {
            pwsz = (LPWSTR) /*CoTaskMemAlloc(cwsz * sizeof(WCHAR))*/ malloc(cwsz * sizeof(WCHAR));
            if (pwsz)
                CertRDNValueToStrW(
                    dwValueType,
                    pValue,
                    pwsz,
                    cwsz
                    );
        }
    }

CommonReturn:
    if (pNameInfo)
        /*CoTaskMemFree(pNameInfo);*/ free(pNameInfo);

    return pwsz;
}


LPWSTR PrettySubject(PCCERT_CONTEXT pccert)
{
    DWORD       cb;
    DWORD       cch;
    BOOL        f;
    LPWSTR      pwsz;

    //
    //  If the user has put a friendly name onto a certificate, then we
    //  should display that as the pretty name for the certificate.
    //

    f = CertGetCertificateContextProperty(pccert, CERT_FRIENDLY_NAME_PROP_ID,
                                          NULL, &cb);
    // cb includes terminating NULL
    if (f && (cb > sizeof(TCHAR))) {
        pwsz = (LPWSTR) malloc(cb);
        CertGetCertificateContextProperty(pccert, CERT_FRIENDLY_NAME_PROP_ID,
                                          pwsz, &cb);
        return pwsz;
    }

    pwsz = GetCommonNameExtension(pccert);
    if (pwsz != NULL) {
        return pwsz;
    }
    pwsz = GetRDNAttrWStr(szOID_COMMON_NAME, &pccert->pCertInfo->Subject);
    if (pwsz != NULL) {
        return pwsz;
    }

    pwsz = GetRDNAttrWStr(szOID_RSA_emailAddr, &pccert->pCertInfo->Subject);
    if (pwsz != NULL) {
        return pwsz;
    }

    cch = CertNameToStr(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Subject,
                        CERT_SIMPLE_NAME_STR, NULL, 0);
    pwsz = (LPTSTR) malloc(cch*sizeof(TCHAR));
    CertNameToStr(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Subject,
                        CERT_SIMPLE_NAME_STR, pwsz, cch);
    return pwsz;

}

LPWSTR PrettyIssuer(PCCERT_CONTEXT pccert)
{
    DWORD       cch;
    LPWSTR      pwsz;

    //    pwsz = GetCommonNameExtension(pccert);
    //    if (pwsz != NULL) {
    //        return pwsz;
    //    }
    pwsz = GetRDNAttrWStr(szOID_COMMON_NAME, &pccert->pCertInfo->Issuer);
    if (pwsz != NULL) {
        return pwsz;
    }

    cch = CertNameToStr(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Issuer,
                        CERT_SIMPLE_NAME_STR, NULL, 0);
    pwsz = (LPTSTR) malloc(cch*sizeof(TCHAR));
    CertNameToStr(CRYPT_ASN_ENCODING, &pccert->pCertInfo->Issuer,
                        CERT_SIMPLE_NAME_STR, pwsz, cch);
    return pwsz;
}

LPWSTR PrettySubjectIssuer(PCCERT_CONTEXT pccert)
{
    int         cwsz;
    LPWSTR      pwsz;
    LPWSTR      pwszIssuer;
    LPWSTR      pwszSubject;

    pwszSubject = PrettySubject(pccert);
    pwszIssuer = PrettyIssuer(pccert);

    cwsz = wcslen(pwszSubject) + wcslen(pwszIssuer) + 20;
    pwsz = (LPWSTR) malloc(cwsz*sizeof(WCHAR));

    wcscpy(pwsz, pwszSubject);
#ifndef WIN16
    wcscat(pwsz, L" (");
    wcscat(pwsz, pwszIssuer);
    wcscat(pwsz, L")");
#else
    wcscat(pwsz, " (");
    wcscat(pwsz, pwszIssuer);
    wcscat(pwsz, ")");
#endif

    free(pwszSubject);
    free(pwszIssuer);
    return pwsz;
}


#ifndef MAC
BOOL OnContextHelp(HWND /*hwnd*/, UINT uMsg, WPARAM wParam, LPARAM lParam,
                   HELPMAP const * rgCtxMap)
{
    if (uMsg == WM_HELP) {
        LPHELPINFO lphi = (LPHELPINFO) lParam;
        if (lphi->iContextType == HELPINFO_WINDOW) {   // must be for a control
#ifndef WIN16
            WinHelp ((HWND)lphi->hItemHandle, L"iexplore.hlp", HELP_WM_HELP,
                     (ULONG_PTR)(LPVOID)rgCtxMap);
#else
            WinHelp ((HWND)lphi->hItemHandle, "iexplore.hlp", HELP_WM_HELP,
                     (ULONG_PTR)(LPVOID)rgCtxMap);
#endif // !WIN16
        }
        return (TRUE);
    }
    else if (uMsg == WM_CONTEXTMENU) {
#ifndef WIN16
        WinHelp ((HWND) wParam, L"iexplore.hlp", HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPVOID)rgCtxMap);
#else
        WinHelp ((HWND) wParam, "iexplore.hlp", HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPVOID)rgCtxMap);
#endif // !WIN16
        return (TRUE);
    }

    return FALSE;
}
#endif // MAC


/////////////////////////////////////////////////////////////////////////

////    GetFriendlyNameOfCertA
//
//  Description:
//      This routine is an exported routine which can be used to get
//      a friendly name from a certificate.  The function uses the
//      buffer supplied by the caller to store the formated name in.
//      This is the ANSI half of the function pair.
//

DWORD GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pch, DWORD cch)
{
    DWORD       cch2;
    LPWSTR      pwsz;

    //
    //  Now do the normal pretty printing functionality.  This allocates and
    //  returns a buffer to the caller (us).
    //

    pwsz = PrettySubject(pccert);

    //
    //   Convert the returned string from a Unicode string to an ANSI string
    //

    cch2 = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);

    if ((pch != NULL) && (cch2 <= cch)) {
        cch2 = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, pch, cch, NULL, NULL);
    }
    else if (pch != NULL) {
        SetLastError(ERROR_MORE_DATA);
    }

    free(pwsz);
    return cch2;
}

////    GetFriendlyNameOfCertW
//
//  Description:
//      This routine is an exported routine which can be used to get
//      a friendly name from a certificate.  The function uses the
//      buffer supplied by the caller to store the formated name in.
//      This is the UNICODE half of the function pair.
//

DWORD GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pwch, DWORD cwch)
{
    DWORD       cwch2;
    LPWSTR      pwsz;

    //
    //  Now do the normal pretty printing functionality.  This allocates and
    //  returns a buffer to the caller (us).
    //

    pwsz = PrettySubject(pccert);
    cwch2 = wcslen(pwsz) + 1;

    //
    //  Duplicate the string into the provided buffer.
    //

    if ((pwch != NULL) && (cwch2 <= cwch)) {
        wcscpy(pwch, pwsz);
    }
    else if (pwch != NULL) {
        SetLastError(ERROR_MORE_DATA);
    }

    free(pwsz);
    return cwch2;
}


const BYTE mpchfLegalForURL[] =
{
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 0
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 16
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x11, 0x00, 0x11,   0x01, 0x01, 0x01, 0x01,	// 32
    0x01, 0x11, 0x01, 0x01,   0x11, 0x01, 0x11, 0x01,

    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 48
    0x01, 0x01, 0x11, 0x01,   0x00, 0x01, 0x00, 0x11,


    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 64
    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 80
    0x01, 0x01, 0x01, 0x00,   0x01, 0x00, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 96
    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01,   0x01, 0x01, 0x01, 0x01,	// 112
    0x01, 0x01, 0x01, 0x00,   0x01, 0x00, 0x11, 0x00,


    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 128
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 144
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 160
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 176
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,


    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 192
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 208
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 224
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,	// 240
    0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00,
};

const char szURLSep[] = ":";
const char szURLCloseBrace[] = ">";
const char chURLOpenBrace = '<';

// ordered by match probability and string length

const char g_szURLDefaultPrefixs[] =
        "http"   "\0"
        "file"   "\0"
        "ftp"    "\0"
        "news"   "\0"
        "mailto" "\0"
        "https"  "\0"
        "gopher" "\0"
        "telnet" "\0"
        "nntp"   "\0"
        "wais"   "\0"
        "prospero\0\0";

LPSTR g_pszURLPrefixs = (LPSTR) g_szURLDefaultPrefixs;

#define cchURLPrefixMost 28

BOOL g_fLoadBrowserRegistry = 1;
TCHAR   g_szBrowser[MAX_PATH];
COLORREF        g_crLink = RGB(0, 0, 255);

/*
 *  NoteRecognizeURLs
 *
 *  Purpose:
 *      Change the charformat of text in the richedit control
 *      for text that begins with http: ftp: or other.
 *
 *  Arguments:
 *      HWND        			A handle to the richedit control
 *		fLoadBrowserRegistry	Should we read the registry ?
 *
 *  Returns:
 *      VOID        That would be nothing
 *
 *  Notes:
 *
 *      g_fLoadBrowserRegistry must be true on the first call
 *      this may change g_szBrowser, g_crLink, and or g_pszURLPrefixs
 *      g_pszURLPrefixs must equal g_szURLDefaultPrefixs, and must not be NULL
 *
 *      if g_szBrowser, the path to the browser, is not found in the registry,
 *      it will be defaulted to one of three things: !, url.dll, or iexplore
 *
 */

VOID RecognizeURLs(HWND hwndRE)
{
    int isz;
    LONG cchBrace;
    LONG cpBraceSearch;
    LONG cpMatch;
    LONG cpSep;
    LONG cpEnd;
    LPSTR pch;
    CHARRANGE chrgSave;
    FINDTEXTEX ft;
    TEXTRANGEA tr;
    CHARFORMATA cf;
    char szBuff[MAX_PATH]; // szBuff must be at least cchURLPrefixMost
    LPSTR szT;
    LPARAM lNotifSuppression;

#if MAX_PATH < cchURLPrefixMost
#error MAX_PATH < cchURLPrefixMost
#endif

    if (g_fLoadBrowserRegistry) {
        //        INT cch; // signed to compare against 0

        // hopefully we will not have to re-read
        // from the registry again, but a winini change
        // will force another read - see mlview shell.c

        g_fLoadBrowserRegistry = 0;

#if 0
        // if they change the default charformat
        // compute the hex stored color ref

        cch = GetMailRegistryString(imkeyURLColor, NULL, g_szBrowser, sizeof(g_szBrowser));
        if (cch > 0) {
            LPTSTR psz = g_szBrowser;

            g_crLink = 0;
            for (; cch > 0; --cch, psz++) {
                g_crLink *= 16;
                if (*psz <= '9')
                    g_crLink += *psz - TEXT('0');
                else if (*psz <= 'F')
                    g_crLink += *psz - TEXT('A') + 10;
                else
                    g_crLink += *psz - TEXT('a') + 10;
            }
        }
#endif // 0

#if 0
        // grab the path to their browser, and
        // set the disable flag if appropriate

        cch = GetMailRegistryString(imkeyBrowser, NULL, g_szBrowser, sizeof(g_szBrowser));
        if (cch <= 0) {
#endif // 0
#ifndef MAC
            lstrcpy(g_szBrowser, TEXT("c:\\inetsrv\\iexplore\\iexplore.exe"));
#else	// MAC
            lstrcpy(g_szBrowser, TEXT(":MSIE:APPL"));
#endif	// !MAC			
#if 0
        }
#endif // 0
    }

    // Prepare a few local variables for use

    szT = szBuff;
    cf.cbSize = sizeof(cf);
    ft.chrg.cpMin = 0;
    ft.chrg.cpMax = -1;              // search the entire message body
    ft.lpstrText = (LPTSTR) szURLSep; // for a colon
    tr.lpstrText = szBuff;
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_LINK;
    cf.dwEffects = 0;
    cpBraceSearch = 0;

    SendMessage(hwndRE, EM_EXGETSEL, 0, (LPARAM) &chrgSave);
    SendMessage(hwndRE, EM_HIDESELECTION, TRUE, FALSE);

    lNotifSuppression = SendMessage(hwndRE,EM_GETEVENTMASK,0,0);
    SendMessage(hwndRE, EM_SETEVENTMASK, (WPARAM) 0, 0);

    // remove existing link bits so that the user does not
    // get hosed when he/she saves text that was mistakenly marked
    // as linked ... gee, this SCF_ALL flag is a big perf win

    SendMessage(hwndRE, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &cf);

    // loop all the way to the bottom of the note
    // one iteration per find of a potential match
    // when we locate a colon

    for (;;) {
        LONG cpLast = 0;

        // find the colon

        cpSep = (LONG) SendMessage(hwndRE, EM_FINDTEXTEX, 0, (LPARAM) &ft);
        if (cpSep < 0)
            break;
        cpEnd = ft.chrgText.cpMax;
        ft.chrg.cpMin = cpEnd;

        // make sure the word to the left of the colon
        // is present and of a reasonable size

        cpMatch = (LONG) SendMessage(hwndRE, EM_FINDWORDBREAK, WB_MOVEWORDLEFT, ft.chrgText.cpMin);
        if (cpMatch == cpSep)
            continue;

        // sender of message is just being a jerk
        // so, do a quick check to avoid pathological cases

        if (cpMatch < cpSep - cchURLPrefixMost) {
            ft.chrg.cpMin = (LONG) SendMessage(hwndRE, EM_FINDWORDBREAK, WB_MOVEWORDRIGHT, cpSep);
            //            Assert(ft.chrg.cpMin > cpSep);
            continue;
        }

        // pull the text of the keyword out into szBuff
        // to compare against our word list ... also grab
        // the character to the left in case we are
        // enclosed in matching braces

        cchBrace = 0;
        tr.chrg.cpMin = cpMatch - cchBrace;
        tr.chrg.cpMax = cpSep;
        if (!SendMessage(hwndRE, EM_GETTEXTRANGE, 0, (LPARAM) &tr))
            goto end;

        // compare to each word in our list

        for (isz = 0; g_pszURLPrefixs[isz]; isz+=lstrlenA(g_pszURLPrefixs+isz)+1) {
            if (0 == lstrcmpiA(szBuff + cchBrace, &g_pszURLPrefixs[isz]))
                goto match;
        }
        continue;

    match:
        ft.chrgText.cpMin = cpMatch;
        cpLast = cpEnd; // assume that we will stop after the colon

        // check to see if this is the brace character

        if (cchBrace && chURLOpenBrace == szBuff[0]) {
            FINDTEXTEX ft;
            LONG cpBraceClose;

            ft.chrg.cpMin = max(cpEnd, cpBraceSearch);
            ft.chrg.cpMax = cpEnd + MAX_PATH;
            ft.lpstrText = (LPTSTR) szURLCloseBrace;

            cpBraceClose = (LONG) SendMessage(hwndRE, EM_FINDTEXTEX, 0, (LPARAM) &ft);
            if (cpBraceClose >= 0) {
                tr.chrg.cpMin = cpEnd;
                tr.chrg.cpMax = cpEnd + 1;
                if (!SendMessage(hwndRE, EM_GETTEXTRANGE, 0, (LPARAM) &tr) || ' ' == szBuff[0])
                    goto end;

                cpLast = cpEnd = ft.chrgText.cpMin;
                cpBraceSearch = cpLast + 1;
                goto end;
            }
            else {
                cpBraceSearch = ft.chrg.cpMax;
            }
        }

        // loop through chunks of the URL in
        // steps of sizeof(szBuff) looking for a terminator
        // set cpLast to the last terminator byte that is legal according to us

        for (;;) {
            tr.chrg.cpMin = cpLast = cpEnd;
            tr.chrg.cpMax = cpEnd + sizeof(szBuff) - 1;
            if (!SendMessage(hwndRE, EM_GETTEXTRANGE, 0, (LPARAM) &tr))
                goto end;

            for (pch = szBuff; *pch; pch++, cpEnd++) {
                const BYTE fb = mpchfLegalForURL[*pch];
#ifdef DBCS
                if (!fb || FGLeadByte(*pch))
#else	// DBCS
                    if (!fb)
#endif	// DBCS
                        {
                            goto end;
                        }
                if(!(fb & 0x10)) {
                    cpLast = cpEnd + 1;
                }
            }
        }

    end:
        if (cpLast == cpSep + 1) // hmmm... just "http:" then terminator
            continue;            // must have argument to be legal

        // select the entire URL including the http colon,
        // mark it as linked, and change the charformat if appropriate

        ft.chrgText.cpMax = cpLast;
        SendMessage(hwndRE, EM_EXSETSEL, 0, (LPARAM) &ft.chrgText);
        cf.dwMask = CFM_LINK | CFM_UNDERLINE | CFM_COLOR;
        if (((LONG)g_crLink) < 0)
            cf.dwMask &= ~CFM_UNDERLINE;   /* high bit turns off underline */
        if (((LONG)g_crLink) & 0x40000000)
            cf.dwMask &= ~CFM_COLOR;       /* next bit turns off color */
        cf.dwEffects = CFE_LINK | CFE_UNDERLINE;
        cf.crTextColor = g_crLink;
        SendMessage(hwndRE, EM_SETCHARFORMAT, SCF_SELECTION,
                    (LPARAM) &cf);

        // no need to re-search through the URL
        // so, just advance past the last totally cool URL character

        ft.chrg.cpMin = cpLast + 1;

    }   // end loop through richedit text

    SendMessage(hwndRE, EM_EXSETSEL, 0, (LPARAM) &chrgSave);
    SendMessage(hwndRE, EM_HIDESELECTION, FALSE, FALSE);
    SendMessage(hwndRE, EM_SETEVENTMASK, (WPARAM) 0, (LPARAM) lNotifSuppression);
    return;
}



#if 0
/*
 *	FFindBrowser
 *
 *	Purpose:
 *		Browses for the executable to launch on EN_LINK notifications
 *
 *	Arguments:
 *		HWND		Window handle of the parent to the common dialog
 *		LPTSTR		Pointer to the string to be filled
 *		UINT		Length of string to be filled in
 *
 *	Returns:
 *		BOOL		FALSE if we cancel or fail, else TRUE
 *
 */

BOOL FFindBrowser(HWND hwnd, LPSTR sz, UINT cch)
{
#ifndef MAC
    static const char szFilter[] = "*.EXE\0*.EXE\0\0";
#else
    static const char szFilter[] = "Applications\0APPL\0\0";
#endif
    TCHAR szTitle[256] = {0};
    OPENFILENAME ofn = {0};
    BOOL fRet;
#ifdef USECTL3D
    BOOL			fActivateCtl3d = FALSE;
#endif	

    if (!FLoadCommdlg())
        return 0;

    SideAssert(LoadString(g_hinstDLL, STR_FileOpenLocateBrowserTitle, szTitle, sizeof(szTitle)));
    Assert(!g_fDisableBrowserFeature && sz);

    ofn.lStructSize = sizeof(ofn);
    ofn.lpstrTitle  = szTitle;
    ofn.hwndOwner   = hwnd;
    ofn.lpstrFile   = sz;
    ofn.nMaxFile	= cch;
    ofn.lpstrFilter	= szFilter;
    ofn.Flags		= OFN_HIDEREADONLY;

#ifdef USECTL3D
    // Make sure CTL3D is on
    if (CTL3D_GetVer() >= 0x220 && !CTL3D_IsAutoSubclass()) {
        fActivateCtl3d = TRUE;
        CTL3D_AutoSubclass(g_hinstDLL);
    }
#endif	// USECTL3D
#ifdef WIN16
    sz[0] = 0; // On Win16, GetOpenFileName() will return zero for path not found, so, no path
#endif

    fRet = INST(pfngetopenfile(&ofn));

#ifdef USECTL3D
    // Turn off CTL3D
    if (fActivateCtl3d)
        CTL3D_UnAutoSubclass();
#endif	// USECTL3D

    if (!fRet) {
#ifdef DEBUG
        DWORD dwError = INST(pfnexterr());
#endif
        // we fail silently on all common file dialog failures
        // this is currently by design, this path is also cancel code

        return 0;
    }

#ifdef MAC
    // On the Mac we save the creator and type information, rather than a
    //	full path name.  This allows people to move the browser around without
    //	actually messing up our link.

    {
        LPTSTR		szMacInfo;

        szMacInfo = SzMacInfoFromFileName(sz);
        _tcscpy(sz, szMacInfo);
    }
#endif
	
    (void) WriteMailRegistryString(imkeyBrowser, sz); //$REVIEW: write to ini file for stomp?
    return TRUE;
}
#endif // 0



#ifndef MAC
/*
 *	FNoteDlgNotifyLink
 *
 *	Purpose:
 *		Handle the user clicking on a link
 *
 *	Arguments:
 *		hwndDlg			Parent dialog
 *		penlink			Link notification structure
 *		szURL			URL to launch
 *
 *	Returns:
 *		BOOL			TRUE if we processed message, else FALSE
 */

BOOL FNoteDlgNotifyLink(HWND hwndDlg, ENLINK * penlink, LPSTR szURL)
{
    //    BOOL fShift;
    LONG cch;
    TEXTRANGEA tr;
    char szCmd[2*MAX_PATH + 2];
#ifdef MAC
    BOOL fPickedBrowser = FALSE;
#endif	
    HCURSOR hcursor;

    // eat the double click - just activate on single click

    if (WM_LBUTTONDBLCLK == penlink->msg) {
        return TRUE;
    }

    // if we got this far, we are enabled so assert that the path
    // does not explicitly say we should be disabled

    // below this point, we return true meaning that
    // we handled this message, and richedit should do nothing

#if 0
    // if the path to the browser is NULL, or
    // the user uses the shift key to invoke a path edit,
    // we throw up a common file dialog to find the browser

    fShift = !!(GetAsyncKeyState(VK_SHIFT) & 0x8000);
    if (fShift) {
    pick:
        if (!FFindBrowser(hwndDlg, g_szBrowser, sizeof(g_szBrowser)) || fShift) {
            return TRUE;
        }
#ifdef MAC
        // If Internet Config is installed we want to register this as the
        //  appropriate helper for this type of internet protocol

        if (INST(picinstIConfig) != NULL) {
            // Retrieve the URL from RichEdit

            cch = 0;
            szCmd[0] = TEXT('\0');
            tr.chrg.cpMin = penlink->chrg.cpMin;
            tr.chrg.cpMax = min((LONG) (tr.chrg.cpMin + sizeof(szCmd) - cch - 1), penlink->chrg.cpMax);
            tr.lpstrText = szCmd;
            if (szURL) {
            	cch = lstrlen(szURL);
            	lstrcpy(tr.lpstrText, szURL);
            }
            else {
            	cch = SendMessage(penlink->nmhdr.hwndFrom, EM_GETTEXTRANGE, 0, (LPARAM) &tr);
            }

            // If we retrieved a URL, use the protocol to set the helper

            if (cch > 0) {
                ICAppSpec       icappHelper = { 0 };
                FSSpec          fssBrowser = { 0 };
                OSErr           errLaunch;
                OSType          ostBrowser;
                OSType          ostType;
                Str255          strHelper = kICHelper;
                TCHAR*          pchHelper;
                TCHAR*          pchURL;

                // Locate the end of the Helper string and add the protocol
                //  from the URL

                pchHelper = strHelper + (sizeof(kICHelper) - 1);
                pchURL = tr.lpstrText;
                while ((*pchURL != TEXT('\0')) && (*pchURL != TEXT(':'))) {
                    *pchHelper = *pchURL;
                    pchURL++;
                    pchHelper++;
                    strHelper[0]++;
                }

                // Locate the helper to use since we don't get it back
                //  from FFindBrowser

                SideAssert(FMacSignatureFromMacInfo(g_szBrowser, NULL,
                                                    &ostBrowser, &ostType));
                errLaunch = ErrFindFileFromSignature(ostBrowser, ostType,
                                                     &fssBrowser);
                if (errLaunch != noErr) {
                    // Do nothing on errors- just fail quietly

                    goto Exit;
                }

                // Use the information in the FSSpec to fill the ICAppSpec

                icappHelper.fCreator = ostBrowser;
                PLstrcpy(icappHelper.name, fssBrowser.name);

                // Call Internet Config to set this helper app to what
                //  the user just chose...

                errLaunch = (OSErr)ICSetPref(INST(picinstIConfig), strHelper,
                                             ICattr_no_change,
                                             (LPVOID)&icappHelper,
                                             sizeof(ICAppSpec));
                if (errLaunch != noErr) {
                    // Fail quietly on error

                    goto Exit;
                }
            }
        }
#endif  // MAC
    }
#endif // 0

    hcursor = SetCursor(LoadCursorA(NULL, (LPSTR) IDC_WAIT));

#ifndef MAC
    // prepare szCmd for use as the parameter to execution
    //    AssertSz(sizeof(szCmd) > sizeof(g_szBrowser), "cat may overwrite");
    wsprintfA(szCmd, "%s ", g_szBrowser);
    cch = lstrlenA(szCmd);
    tr.chrg.cpMin = penlink->chrg.cpMin;
    tr.chrg.cpMax = min((LONG) (tr.chrg.cpMin + sizeof(szCmd) - cch - 1), penlink->chrg.cpMax);
    tr.lpstrText = &szCmd[cch];
#else
    cch = 0;
    szCmd[0] = TEXT('\0');
    tr.chrg.cpMin = penlink->chrg.cpMin;
    tr.chrg.cpMax = min((LONG) (tr.chrg.cpMin + sizeof(szCmd) - cch - 1), penlink->chrg.cpMax);
    tr.lpstrText = szCmd;
#endif	

    // add the web path to the command line

    if (szURL) {
        cch = lstrlenA(szURL);
        lstrcpyA(tr.lpstrText, szURL);
    }
    else {
        cch = (LONG) SendMessage(penlink->nmhdr.hwndFrom, EM_GETTEXTRANGE, 0, (LPARAM) &tr);
    }
	
    if (cch > 0)
#ifndef MAC
	{
            HINSTANCE hinst;
            UINT ui;
#if 0
            HWND hwndActive;
            TCHAR szCaption[MAX_PATH];

            // Prompt the user to see if we can open the URL safely

            hwndActive = GetActiveWindow();
            if (!GetWindowTextA(hwndActive, szCaption,
                               (sizeof(szCaption) / sizeof(TCHAR)))) {
                szCaption[0] = TEXT('\0');
            }
            if (!FIsSafeURL(hwndActive, tr.lpstrText, szCaption)) {
                SetCursor(hcursor);
                return TRUE;
            }
#endif

#if defined(WIN32) && !defined(MAC)
            SetProcessWorkingSetSize(GetCurrentProcess(), 0xffffffff, 0xffffffff);
#endif	
            // execute the browser, however the current operating system wants to ...
            hinst = ShellExecuteA(hwndDlg, NULL, tr.lpstrText, NULL, NULL, SW_SHOWNORMAL);
            if ((UINT_PTR) hinst > 32) {
                SetCursor(hcursor);
                return TRUE;
            }

            // the operating system failed to launch the browser, let me try ...
            ui = WinExec(szCmd, SW_SHOW);
            if (ui < 32) {
                // perhaps they moved or deleted their executable regardless
                // of the error, we will just browse for a path
                // this is currently by design

                MessageBeep(MB_OK);
                SetCursor(hcursor);
#if 0
                goto pick;
#else
                return FALSE;
#endif
            }
		
	}
    SetCursor(hcursor);
    return TRUE;
#else	// MAC
    {
        HWND                hwndActive;
        ProcessSerialNumber psn;
        AppleEvent			aeEvent = { 0 };
        AppleEvent          aeReply = { 0 };
        AEAddressDesc		aedAddr = { 0 };
        AEEventClass        aecOpenURL = 'WWW!';
        AEEventID           aeidOpenURL = 'OURL';
        OSErr				errLaunch = icPrefNotFoundErr;
        OSType				ostBrowser;
        OSType				ostType;
        SCODE				sc = S_OK;
        TCHAR               szCaption[MAX_PATH];

        // Prompt the user to see if we can open the URL safely

        hwndActive = GetActiveWindow();
        if (!GetWindowText(hwndActive, szCaption,
                           (sizeof(szCaption) / sizeof(TCHAR)))) {
            szCaption[0] = TEXT('\0');
        }
        if (!FIsSafeURL(hwndActive, tr.lpstrText, szCaption)) {
            goto Exit;
        }

        // See if we have an Internet Config instance

        if (INST(picinstIConfig) != NULL) {
            ICAppSpec       icappHelper = { 0 };
            ICAttr          icattr;
            LONG            lSize;
            Str255          strHelper = kICHelper;
            TCHAR*          pchHelper;
            TCHAR*          pchURL;

            // Locate the end of the Helper string and add the protocol
            //  from the URL

            pchHelper = strHelper + (sizeof(kICHelper) - 1);
            pchURL = tr.lpstrText;
            while ((*pchURL != TEXT('\0')) && (*pchURL != TEXT(':'))) {
                *pchHelper = *pchURL;
                pchURL++;
                pchHelper++;
                strHelper[0]++;
            }

            // Call Internet Config to see if we have a helper for this
            //  protocol defined

            lSize = sizeof(ICAppSpec);
            errLaunch = (OSErr)ICGetPref(INST(picinstIConfig), strHelper,
                                         &icattr, (LPBYTE)&icappHelper,
                                         &lSize);
            if (errLaunch == noErr) {
                // Got a helper application, extract the information needed
                //  to launch the correct helper with a GURL event

                ostBrowser = icappHelper.fCreator;
                aecOpenURL = 'GURL';
                aeidOpenURL = 'GURL';
            }
        }

        // If we do not have an error at this point that means that Internet
        //  Config found the helper.  Otherwise, we need to look in the
        //  standard preferences for the browser.

        if (errLaunch != noErr) {
            // Create a Mac OSType from the browser string

            if (!FMacSignatureFromMacInfo(g_szBrowser, NULL, &ostBrowser,
                                          &ostType)) {
                goto Exit;
            }
        }

        // If Exchange is the designated helper we want to avoid the expense
        //  of using AppleEvents

        if (ostBrowser != 'EXCH') {
            // Set up the AppleEvent

    	    errLaunch = AECreateDesc(typeApplSignature, &ostBrowser,
                                     sizeof(OSType), &aedAddr);
            if (errLaunch != noErr) {
                goto CleanupAEvent;
            }

            // Create the AppleEvent to send to the web browser

            errLaunch = AECreateAppleEvent(aecOpenURL, aeidOpenURL, &aedAddr,
                                           kAutoGenerateReturnID,
                                           kAnyTransactionID, &aeEvent);
            if (errLaunch != noErr) {
                goto CleanupAEvent;
            }

            // Add the URL as the direct parameter

            errLaunch = AEPutParamPtr(&aeEvent, keyDirectObject, typeChar,
                                      tr.lpstrText, _tcslen(tr.lpstrText));
            if (errLaunch != noErr) {
                goto CleanupAEvent;
            }
    	
            // Get a running instance of the browser so that we have something
            //	to actually process our event and send it the open command.

            errLaunch = ErrLaunchCreatorEx(ostBrowser,
                                           launchContinue | launchUseMinimum,
                                           &aeEvent,
                                           kAEWaitReply | kAEAlwaysInteract,
                                           &aeReply, NULL, &psn);
            if (errLaunch != noErr) {
#if 0
                // If we could not launch the browser because it was not
                //  found, we need to try and choose a browser to use,
                //  otherwise we just ignore the error and fail gracefully.

                if ((errLaunch == fnfErr) && (!fPickedBrowser)) {
                    fPickedBrowser = TRUE;
    	            SetCursor(hcursor);
                    goto pick;
                }
#endif // 0
                goto CleanupAEvent;
            }

            ErrSetFrontProcess(&psn);
    		
        CleanupAEvent:
            AEDisposeDesc(&aeEvent);
            AEDisposeDesc(&aeReply);
            AEDisposeDesc(&aedAddr);
        }
        else {
            LPIEDATA        pieData = NULL;
            LPTSTR          pszURL = NULL;
            LONG            iProtocol;

            // Allocate a buffer to store the URL in

            pszURL = PvAlloc(((_tcslen(tr.lpstrText) * sizeof(TCHAR)) + 1),
                             fZeroFill);
            if (pszURL == NULL) {
                goto CleanupIEData;
            }
            _tcscpy(pszURL, tr.lpstrText);

            // Make sure this is a protocol supported by Exchange

            for (iProtocol = 0; iProtocol < g_lNumIESupProtocols; iProtocol++) {
                if (_tcsncmp(pszURL, g_iesupMac[iProtocol].szProtocol,
                             _tcslen(g_iesupMac[iProtocol].szProtocol)) == 0) {
                    // Found a match

                    break;
                }
            }

            if (iProtocol == g_lNumIESupProtocols) {
                // No match found

                goto CleanupIEData;
            }
		
            // Create the appropriate IEDATA structure

            pieData = PvAlloc(sizeof(IEDATA), fZeroFill);
            if (pieData == NULL) {
                goto CleanupIEData;
            }
            pieData->szURL = pszURL;
            pieData->idxProtocol = iProtocol;

            // Post an internal message to ourselves to actually do the
            //  processing

            PostMessage(INST(hwndCentral), EXIE_OPENURL, 0, (LPARAM)pieData);
            goto Exit;

        CleanupIEData:
            if (pszURL != NULL) {
                FreePv(pszURL);
            }
            if (pieData != NULL) {
                FreePv(pieData);
            }
        }
    }
	
Exit:	
    SetCursor(hcursor);
    return TRUE;
#endif	// !MAC
}
#endif  // !MAC

/////////////////////////////////////////////////////////////////////////
//
//   This code provides the first cut of the Verisign Cert Policy Statement
//      implemenation code.   This should be replaced in the next version by
//      the correct version of this code.  It is suppose to read a multi-
//      language file and pick up the correct version according to
//      the machine's lanaguage
//

#ifndef WIN16

WCHAR   RgwchVerisign[] =
L"This certificate incorporates by reference, and its use is strictly subject "
L"to, the VeriSign Certification Practice Statement (CPS), available in the "
L"VeriSign repository at: https://www.verisign.com by E-mail at "
L"CPS-requests@verisign.com; or by mail at VeriSign, Inc., 1390 Shorebird "
L"Way, Mountain View, CA 94043 USA Copyright (c)1997 VeriSign, Inc.  All "
L"Rights Reserved. CERTAIN WARRANTIES DISCLAIMED AND LIABILITY LIMITED.\n"
L"\n"
L"WARNING: USE OF THIS CERTIFICATE IS STRICTLY SUBJECT TO THE VERISIGN "
L"CERTIFICATION PRACTICE STATEMENT.  THE ISSUING AUTHORITY DISCLAIMS CERTAIN "
L"IMPLIED AND EXPRESS WARRANTIES, INCLUDING WARRANTIES OF MERCHANTABILITY OR "
L"FITNESS FOR A PARTICULAR PURPOSE, AND WILL NOT BE LIABLE FOR CONSEQUENTIAL, "
L"PUNITIVE, AND CERTAIN OTHER DAMAGES. SEE THE CPS FOR DETAILS.\n"
L"\n"
L"Contents of the VeriSign registered nonverifiedSubjectAttribute extension "
L"value shall not be considered as information confirmed by the IA.";

#else

WCHAR   RgwchVerisign[] =
"This certificate incorporates by reference, and its use is strictly subject "
"to, the VeriSign Certification Practice Statement (CPS), available in the "
"VeriSign repository at: https://www.verisign.com; by E-mail at "
"CPS-requests@verisign.com; or by mail at VeriSign, Inc., 1390 Shorebird "
"Way, Mountain View, CA 94043 USA Copyright (c)1997 VeriSign, Inc.  All "
"Rights Reserved. CERTAIN WARRANTIES DISCLAIMED AND LIABILITY LIMITED.\n"
"\n"
"WARNING: USE OF THIS CERTIFICATE IS STRICTLY SUBJECT TO THE VERISIGN "
"CERTIFICATION PRACTICE STATEMENT.  THE ISSUING AUTHORITY DISCLAIMS CERTAIN "
"IMPLIED AND EXPRESS WARRANTIES, INCLUDING WARRANTIES OF MERCHANTABILITY OR "
"FITNESS FOR A PARTICULAR PURPOSE, AND WILL NOT BE LIABLE FOR CONSEQUENTIAL, "
"PUNITIVE, AND CERTAIN OTHER DAMAGES. SEE THE CPS FOR DETAILS.\n"
"\n"
"Contents of the VeriSign registered nonverifiedSubjectAttribute extension "
"value shall not be considered as information confirmed by the IA.";

#endif // !WIN16

BOOL WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/, DWORD /*dwFormatType*/, DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/, LPCSTR /*lpszStructType*/, const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/, void * pbFormat, DWORD * pcbFormat)
{
    if (pbFormat == NULL) {
        *pcbFormat = sizeof(RgwchVerisign);
        return TRUE;
    }

    if (*pcbFormat < sizeof(RgwchVerisign)) {
        *pcbFormat = sizeof(RgwchVerisign);
        return FALSE;
    }

    memcpy(pbFormat, RgwchVerisign, sizeof(RgwchVerisign));
    return TRUE;
}

BOOL WINAPI FormatPKIXEmailProtection(
    DWORD /*dwCertEncodingType*/, DWORD /*dwFormatType*/, DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/, LPCSTR /*lpszStructType*/, const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/, void * pbFormat, DWORD * pcbFormat)
{
    DWORD       cch;
    WCHAR       rgwch[256];

    cch = LoadString(HinstDll, IDS_EMAIL_DESC, rgwch, sizeof(rgwch)/sizeof(WCHAR));

    if (pbFormat == NULL) {
        *pcbFormat = (cch+1)*sizeof(WCHAR);
        return TRUE;
    }

    if (*pcbFormat < (cch+1)*sizeof(WCHAR)) {
        *pcbFormat = (cch+1)*sizeof(WCHAR);
        return FALSE;
    }

    memcpy(pbFormat, rgwch, (cch+1)*sizeof(WCHAR));
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//   This is an encoder which should really be in crypt32 -- however I don't
//      want to force a drop of crypt32 just to get it.
//

BOOL WINAPI
EncodeAttrSequence(DWORD /*dwType*/, LPCSTR /*lpszStructType*/,
                   const void * pv, LPBYTE pbEncode, DWORD * pcbEncode)
{
    DWORD                       cb;
    DWORD                       dw;
    BOOL                        fRet;
    DWORD                       i;
    PCRYPT_ATTRIBUTES           pattrs = (PCRYPT_ATTRIBUTES) pv;
    LPBYTE                      pb = NULL;
    CRYPT_SEQUENCE_OF_ANY       seq = {0};
    UNALIGNED void * pAttr = NULL;
    //
    //  Allocate something to hold the result of each attribute's encoding
    //

    seq.rgValue = (PCRYPT_DER_BLOB) malloc(pattrs->cAttr *
                                           sizeof(CRYPT_DER_BLOB));
    if (seq.rgValue == NULL) {
        dw = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    //
    //  Now encode each of the attributes in turn
    //

    for (i=0; i<pattrs->cAttr; i++) {

        pAttr =((UNALIGNED void *) &(pattrs->rgAttr[i]));

        if (!CryptEncodeObject(X509_ASN_ENCODING, PKCS_ATTRIBUTE,
                               pAttr, NULL, &cb) || (cb == 0)) {
            fRet = FALSE;
            goto Clean;
        }

        pb = (LPBYTE) malloc(LcbAlignLcb(cb));
        if (!CryptEncodeObject(X509_ASN_ENCODING, PKCS_ATTRIBUTE,
                               pAttr, pb, &cb)) {
            fRet = FALSE;
            goto Clean;
        }

        seq.cValue = i+1;
        seq.rgValue[i].cbData = cb;
        seq.rgValue[i].pbData = pb;
        pb = NULL;
    }

    //
    //  Now lets encode the sequence
    //

    fRet = CryptEncodeObject(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                             &seq, pbEncode, pcbEncode);

Clean:
    for (i=0; i<seq.cValue; i++) free(seq.rgValue[i].pbData);
    if (seq.rgValue != NULL) free(seq.rgValue);
    if (pb != NULL) free(pb);
    return fRet;

ErrorExit:
    SetLastError(dw);
    fRet = FALSE;
    goto Clean;
}

BOOL WINAPI
DecodeAttrSequence(DWORD /*dwType*/, LPCSTR /*lpszStructType*/,
                   const BYTE * pbEncoded, DWORD cbEncoded,
                   DWORD /*dwFlags*/, void * pvStruct,
                   DWORD * pcbStruct)
{
    DWORD                       cb;
    DWORD                       cbMax = 0;
    DWORD                       cbOut;
    BOOL                        fRet = FALSE;
    DWORD                       i;
    DWORD                       i1;
    PCRYPT_ATTRIBUTE            pattr = NULL;
    PCRYPT_ATTRIBUTES           pattrs = (PCRYPT_ATTRIBUTES) pvStruct;
    LPBYTE                      pbOut = NULL;
    PCRYPT_SEQUENCE_OF_ANY      pseq = NULL;
#ifdef _WIN64
    UNALIGNED CRYPT_ATTR_BLOB *pVal = NULL;
#endif

    //
    //  Decode the top level sequence
    //

    if (!CryptDecodeObject(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                           pbEncoded, cbEncoded, 0, NULL, &cb)) {
        goto Exit;
    }

    pseq = (PCRYPT_SEQUENCE_OF_ANY) malloc(cb);
    if (pseq == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                           pbEncoded, cbEncoded, 0, pseq, &cb)) {
        goto Exit;
    }

    //
    //  Decode each attribute for length
    //

    cbOut = sizeof(CRYPT_ATTRIBUTES);

    for (i=0; i<pseq->cValue; i++) {
        if (!CryptDecodeObject(X509_ASN_ENCODING, PKCS_ATTRIBUTE,
                               pseq->rgValue[i].pbData,
                               pseq->rgValue[i].cbData, 0, NULL, &cb)) {
            fRet = FALSE;
            goto Exit;
        }
        cb = LcbAlignLcb(cb);
        if (cb > cbMax) cbMax = cb;
        cbOut += cb;
    }

    if (pvStruct == NULL) {
        *pcbStruct = cbOut;
        fRet = TRUE;
        goto Exit;
    }

    if (*pcbStruct < cbOut) {
        *pcbStruct = cbOut;
        SetLastError(ERROR_MORE_DATA);
        goto Exit;
    }

    //
    //  Now we are going to actually try and compute the real data.
    //
    //  First we need a buffer to put each attribute in as we are looking at it
    //

    pattr = (PCRYPT_ATTRIBUTE) malloc(LcbAlignLcb(cbMax));
    if (pattr == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }
    pattrs->cAttr = pseq->cValue;
    pattrs->rgAttr = (PCRYPT_ATTRIBUTE) (((LPBYTE) pvStruct) +
                                         sizeof(CRYPT_ATTRIBUTES));

    pbOut = ((LPBYTE) pvStruct + LcbAlignLcb(sizeof(CRYPT_ATTRIBUTES) +
             pseq->cValue * sizeof(CRYPT_ATTRIBUTE)));

    for (i=0; i<pseq->cValue; i++) {
        //
        //  Decode one attribute
        //

        cb = cbMax;
        if (!CryptDecodeObject(X509_ASN_ENCODING, PKCS_ATTRIBUTE,
                               pseq->rgValue[i].pbData, pseq->rgValue[i].cbData,
                               0, pattr, &cb)) {
            goto Exit;
        }

        //
        //  Copy to real output buffer
        //

        pattrs->rgAttr[i].pszObjId = (LPSTR) pbOut;
        cb = lstrlenA(pattr->pszObjId) + 1;
        memcpy(pbOut, pattr->pszObjId, cb);

        pbOut += LcbAlignLcb(cb);

        pattrs->rgAttr[i].cValue = pattr->cValue;
        pattrs->rgAttr[i].rgValue = (PCRYPT_ATTR_BLOB) pbOut;
        pbOut += LcbAlignLcb(sizeof(CRYPT_ATTR_BLOB) * pattr->cValue);

        for (i1=0; i1<pattr->cValue; i1++) {
#ifndef _WIN64
            pattrs->rgAttr[i].rgValue[i1].cbData = pattr->rgValue[i1].cbData;
            pattrs->rgAttr[i].rgValue[i1].pbData = pbOut;
#else
            pVal = &(pattrs->rgAttr[i].rgValue[i1]);
            pVal->cbData = pattr->rgValue[i1].cbData;
            pVal->pbData = pbOut;
#endif //_WIN64
            memcpy(pbOut, pattr->rgValue[i1].pbData, pattr->rgValue[i1].cbData);
            pbOut += LcbAlignLcb(pattr->rgValue[i1].cbData);
        }
    }


    fRet = TRUE;
Exit:
    if (pattr != NULL) free(pattr);
    if (pseq != NULL) free(pseq);
    return fRet;
}

//      OIDs    1.3.6.1.4.1.311.16.4

BOOL WINAPI EncodeRecipientID(DWORD dwType, LPCSTR /*lpszStructType*/,
                              const void * pv, LPBYTE pbEncode, 
                              DWORD * pcbEncode)
{
    DWORD                       cbInt;
    BOOL                        f;
    LPBYTE                      pbInt = NULL;
    CRYPT_RECIPIENT_ID *        prid = (CRYPT_RECIPIENT_ID *) pv;
    CRYPT_DER_BLOB              rgValue[2];
    CRYPT_SEQUENCE_OF_ANY       seq = {0, rgValue};

    if (prid->unused != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    f = CryptEncodeObject(dwType, X509_MULTI_BYTE_INTEGER, 
                          &prid->SerialNumber, NULL, &cbInt);
    if (!f) goto ExitHere;

    pbInt = (LPBYTE) malloc(cbInt);
    if (pbInt == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        f = FALSE;
        goto ExitHere;
    }

    f = CryptEncodeObject(dwType, X509_MULTI_BYTE_INTEGER, 
                          &prid->SerialNumber, pbInt, &cbInt);
        
    seq.cValue = 2;
    seq.rgValue[0].cbData = prid->Issuer.cbData;
    seq.rgValue[0].pbData = prid->Issuer.pbData;

    seq.rgValue[1].cbData = cbInt;
    seq.rgValue[1].pbData = pbInt;

    f = CryptEncodeObject(dwType, X509_SEQUENCE_OF_ANY, &seq,
                          pbEncode, pcbEncode);

ExitHere:
    if (pbInt != NULL) free(pbInt);
    return f;
        
}

BOOL WINAPI DecodeRecipientID(DWORD dwType, LPCSTR /*lpszStructType*/,
                              const BYTE * pbEncoded, DWORD cbEncoded,
                              DWORD dwFlags, void * pvStruct, DWORD * pcbStruct)
{
    DWORD                       cb;
    DWORD                       cbOut;
    BOOL                        fRet = FALSE;
    CRYPT_INTEGER_BLOB *        pInt = NULL;
    CRYPT_RECIPIENT_ID *        prid = (CRYPT_RECIPIENT_ID *) pvStruct;
    CRYPT_SEQUENCE_OF_ANY *     pseq = NULL;

    //  Decode the top level sequence first

    fRet = CryptDecodeObjectEx(dwType, X509_SEQUENCE_OF_ANY, pbEncoded, 
                            cbEncoded, dwFlags | CRYPT_ENCODE_ALLOC_FLAG, 
                            NULL, &pseq, &cb);
    if (!fRet) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

    //    Assert(pseq->cValue == 2);

    //  Decode integer
    fRet = CryptDecodeObjectEx(dwType, X509_MULTI_BYTE_INTEGER,
                               pseq->rgValue[1].pbData, pseq->rgValue[1].cbData,
                               dwFlags | CRYPT_ENCODE_ALLOC_FLAG, NULL,
                               &pInt, &cb);
    if (!fRet) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }
    
    //  Compute length needed for the return value

    cbOut = (sizeof(CRYPT_RECIPIENT_ID) + pseq->rgValue[0].cbData +
             pInt->cbData);
    if ((*pcbStruct < cbOut) || (pvStruct == NULL)) {
        *pcbStruct = cbOut;
        SetLastError(ERROR_MORE_DATA);
        fRet = (pvStruct == NULL);
        goto Exit;
    }

    //  Now copy the data over

    prid->unused = 0;
    prid->Issuer.cbData = pseq->rgValue[0].cbData;
    prid->Issuer.pbData = sizeof(*prid) + (LPBYTE) prid;
    memcpy(prid->Issuer.pbData, pseq->rgValue[0].pbData, prid->Issuer.cbData);

    prid->SerialNumber.cbData = pInt->cbData;
    prid->SerialNumber.pbData = prid->Issuer.pbData + prid->Issuer.cbData;
    memcpy(prid->SerialNumber.pbData, pInt->pbData, pInt->cbData);

    fRet = TRUE;
    
Exit:
    if (pInt != NULL) LocalFree(pInt);
    if (pseq != NULL) LocalFree(pseq);
    return fRet;
}

////////////////////////////////////////////////////////////////////////////

extern const GUID rgguidActions[] = {
    CERT_CERTIFICATE_ACTION_VERIFY
};

#define REGSTR_PATH_SERVICES    "System\\CurrentControlSet\\Services"

#ifdef NT5BUILD
#else  // NT5BUILD
const char      SzRegPath[] = REGSTR_PATH_SERVICES "\\WinTrust\\TrustProviders\\Email Trust";
const char      SzActionIds[] = "$ActionIDs";
const char      SzDllName[] = "$DLL";
#endif // !NT5BUILD

extern const GUID GuidCertValidate = CERT_CERTIFICATE_ACTION_VERIFY;


#ifndef MAC
STDAPI DllRegisterServer(void)
{
#ifdef NT5BUILD
    HRESULT     hr = S_OK;
#else  // !NT5BUILD
    DWORD       dwDisposition;
    HKEY        hkey;
    UINT        cchSystemDir;
    BOOL        fIsWinNt = FALSE;       // M00BUG
    HRESULT     hr = S_OK;
    LPSTR       psz;
    CHAR        rgchLibName[] = "cryptdlg.dll";
    CHAR        rgchPathName[MAX_PATH + sizeof(rgchLibName)];
#endif // NT5BUILD


    //
    //  First we register the funny one time function which is currently
    //  hard-coded to go to a fixed verisign statement.  This should be removed
    //  if we can get a general purpose one running.
    //

#ifndef WIN16
    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                  "2.5.29.32",
                                  L"cryptdlg.dll",
                                  "FormatVerisignExtension")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                  szOID_PKIX_KP_EMAIL_PROTECTION,
                                  L"cryptdlg.dll",
                                  "FormatPKIXEmailProtection")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_ENCODE_OBJECT_FUNC,
                                  "1.3.6.1.4.1.311.16.1.1",
                                  L"cryptdlg.dll",
                                  "EncodeAttrSequence")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_DECODE_OBJECT_FUNC,
                                  "1.3.6.1.4.1.311.16.1.1",
                                  L"cryptdlg.dll",
                                  "DecodeAttrSequence")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING, 
                                  CRYPT_OID_ENCODE_OBJECT_FUNC,
                                  szOID_MICROSOFT_Encryption_Key_Preference,
                                  L"cryptdlg.dll", "EncodeRecipientID")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING, 
                                  CRYPT_OID_DECODE_OBJECT_FUNC,
                                  szOID_MICROSOFT_Encryption_Key_Preference,
                                  L"cryptdlg.dll", "DecodeRecipientID")) {
        return E_FAIL;
    }

#else
    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                  "2.5.29.32",
                                  "cryptdlg.dll",
                                  "FormatVerisignExtension")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_FORMAT_OBJECT_FUNC,
                                  szOID_PKIX_KP_EMAIL_PROTECTION,
                                  "cryptdlg.dll",
                                  "FormatPKIXEmailProtection")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_ENCODE_OBJECT_FUNC,
                                  "1.3.6.1.4.1.311.16.1.1",
                                  "cryptdlg.dll",
                                  "EncodeAttrSequence")) {
        return E_FAIL;
    }

    if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                  CRYPT_OID_DECODE_OBJECT_FUNC,
                                  "1.3.6.1.4.1.311.16.1.1",
                                  "cryptdlg.dll",
                                  "DecodeAttrSequence")) {
        return E_FAIL;
    }
#endif // !WIN16


#ifdef NT5BUILD
    CRYPT_REGISTER_ACTIONID     regdata;
    regdata.cbStruct = sizeof(regdata);
    regdata.sInitProvider.cbStruct = sizeof(regdata.sInitProvider);
    regdata.sInitProvider.pwszDLLName = L"Cryptdlg.dll";
    regdata.sInitProvider.pwszFunctionName = L"CertTrustInit";

    regdata.sObjectProvider.cbStruct = sizeof(regdata.sObjectProvider);
    regdata.sObjectProvider.pwszDLLName = NULL;
    regdata.sObjectProvider.pwszFunctionName = NULL;

    regdata.sSignatureProvider.cbStruct = sizeof(regdata.sSignatureProvider);
    regdata.sSignatureProvider.pwszDLLName = NULL;
    regdata.sSignatureProvider.pwszFunctionName = NULL;

    regdata.sCertificateProvider.cbStruct = sizeof(regdata.sCertificateProvider);
    regdata.sCertificateProvider.pwszDLLName = WT_PROVIDER_DLL_NAME;
    regdata.sCertificateProvider.pwszFunctionName = WT_PROVIDER_CERTTRUST_FUNCTION;

    regdata.sCertificatePolicyProvider.cbStruct = sizeof(regdata.sCertificatePolicyProvider);
    regdata.sCertificatePolicyProvider.pwszDLLName = L"Cryptdlg.dll";
    regdata.sCertificatePolicyProvider.pwszFunctionName = L"CertTrustCertPolicy";

    regdata.sFinalPolicyProvider.cbStruct = sizeof(regdata.sFinalPolicyProvider);
    regdata.sFinalPolicyProvider.pwszDLLName = L"Cryptdlg.dll";
    regdata.sFinalPolicyProvider.pwszFunctionName = L"CertTrustFinalPolicy";

    regdata.sTestPolicyProvider.cbStruct = sizeof(regdata.sTestPolicyProvider);
    regdata.sTestPolicyProvider.pwszDLLName = NULL;
    regdata.sTestPolicyProvider.pwszFunctionName = NULL;

    regdata.sCleanupProvider.cbStruct = sizeof(regdata.sCleanupProvider);
    regdata.sCleanupProvider.pwszDLLName = L"Cryptdlg.dll";
    regdata.sCleanupProvider.pwszFunctionName = L"CertTrustCleanup";

    WintrustAddActionID((GUID *) &GuidCertValidate, 0, &regdata);
#else  // !NT5BUILD
    //
    //  Next register the fact that we are also a wintrust provider for
    //  validating certificates
    //

    hr = RegCreateKeyExA(HKEY_LOCAL_MACHINE, SzRegPath, 0, NULL,
                         REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                         &hkey, &dwDisposition);
    if (hr != ERROR_SUCCESS) {
        goto RetHere;
    }

    // BUGBUG Win95 does not support REG_EXPAND_SZ, so we must do it
    if (fIsWinNt) {
        psz = "%SystemRoot%\\system32\\cryptdlg.dll";
    }
    else {
        //  Compose the path as <system_dir>\cryptdlg.dll
#ifndef WIN16
        cchSystemDir = GetSystemDirectoryA(rgchPathName, MAX_PATH);
#else
        cchSystemDir = GetSystemDirectory(rgchPathName, MAX_PATH);
#endif // !WIN16
        if (cchSystemDir == 0) {
            hr = E_FAIL;
            goto RetHere;
        }
        else if (cchSystemDir > MAX_PATH) {
            hr = ERROR_INSUFFICIENT_BUFFER;
            goto RetHere;
        }

        rgchPathName[cchSystemDir] = '\\';      // system dir can't be a root
        strcpy(&rgchPathName[cchSystemDir+1], rgchLibName);
        psz = rgchPathName;
    }

#ifndef WIN16
    hr = RegSetValueExA(hkey, SzDllName, 0, fIsWinNt ? REG_EXPAND_SZ : REG_SZ,
                        (LPBYTE) psz, strlen(psz)+1);
#else
    hr = RegSetValueExA(hkey, SzDllName, 0, REG_SZ, (LPBYTE) psz, strlen(psz)+1);
#endif // !WIN16
    if (hr != ERROR_SUCCESS) {
        goto RetHere;
    }

    hr = RegSetValueExA(hkey, SzActionIds, 0, REG_BINARY,
                        (LPBYTE) rgguidActions, sizeof(rgguidActions));
    if (hr != ERROR_SUCCESS) {
        goto RetHere;
    }


RetHere:
    // NB - Don't do RegCloseKey on these hkey's since we want to be small
    //      and this code is only ever called by REGSRV32.EXE, so we don't
    //      care about a minor leak.

#endif // NT5BUILD
    return hr;
}

STDAPI DllUnregisterServer(void)
{
#ifndef NT5BUILD
    DWORD       dw;
    HKEY        hkey;
#endif // NT5BUILD
    HRESULT     hr = S_OK;

    //
    //  Unregister the formatting routine we wrote
    //

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_FORMAT_OBJECT_FUNC,
                                    "2.5.29.32")) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_FORMAT_OBJECT_FUNC,
                                    szOID_PKIX_KP_EMAIL_PROTECTION)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_ENCODE_OBJECT_FUNC,
                                    "1.3.6.1.4.1.311.16.1.1")) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_DECODE_OBJECT_FUNC,
                                    "1.3.6.1.4.1.311.16.1.1")) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_ENCODE_OBJECT_FUNC,
                                    szOID_MICROSOFT_Encryption_Key_Preference)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }

    if (!CryptUnregisterOIDFunction(X509_ASN_ENCODING,
                                    CRYPT_OID_DECODE_OBJECT_FUNC,
                                    szOID_MICROSOFT_Encryption_Key_Preference)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            hr = E_FAIL;
        }
    }


#ifdef NT5BUILD
    WintrustRemoveActionID((GUID *) &GuidCertValidate);
#else  // !NT5BUILD
    //
    //  Now unregister the WinTrust provider
    //

    hr = RegCreateKeyExA(HKEY_LOCAL_MACHINE, SzRegPath, 0, NULL,
                         REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw);
    if (FAILED(hr)) {
        goto RetHere;
    }

    RegDeleteValueA(hkey, SzDllName);
    RegDeleteValueA(hkey, SzActionIds);


RetHere:
    // NB - Don't do RegCloseKey on these hkey's since we want to be small
    //      and this code is only ever called by REGSRV32.EXE, so we don't
    //      care about a minor leak.
#endif // NT5BUILD

    return hr;
}
#else   // MAC

/***
*wchar_t *wcsstr(string1, string2) - search for string2 in string1
*       (wide strings)
*
*Purpose:
*       finds the first occurrence of string2 in string1 (wide strings)
*
*Entry:
*       wchar_t *string1 - string to search in
*       wchar_t *string2 - string to search for
*
*Exit:
*       returns a pointer to the first occurrence of string2 in
*       string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl WchCryptDlgWcsStr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        )
{
        wchar_t *cp = (wchar_t *) wcs1;
        wchar_t *s1, *s2;

        while (*cp)
        {
                s1 = cp;
                s2 = (wchar_t *) wcs2;

                while ( *s1 && *s2 && !(*s1-*s2) )
                        s1++, s2++;

                if (!*s2)
                        return(cp);

                cp++;
        }

        return(NULL);
}
#endif  // !MAC


///////////////////////////////////////////////////////////////////////

LPVOID PVCryptDecode(LPCSTR szOid, DWORD cbEncode, LPBYTE pbEncode)
{
    DWORD       cbData;
    BOOL        f;
    LPVOID      pv;

    f = CryptDecodeObject(X509_ASN_ENCODING, szOid, pbEncode, cbEncode,
                          0, NULL, &cbData);
    if (!f) {
        return NULL;
    }

    pv = malloc(cbData);
    if (pv == NULL) {
        return NULL;
    }

    f = CryptDecodeObject(X509_ASN_ENCODING, szOid, pbEncode, cbEncode,
                          0, pv, &cbData);
    if (!f) {
        free(pv);
        return NULL;
    }

    return pv;
}

void * __cdecl operator new(size_t cb )
{
    LPVOID  lpv = 0;

    lpv = malloc(cb);
    if (lpv)
    {
        memset(lpv, 0, cb);
    }
    return lpv;
}

void __cdecl operator delete(LPVOID pv )
{
    free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\cryptdlg\wxptrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       wxptrust.cpp
//
//  Contents:   Windows XP version of the Outlook WinVerify Trust Provider
//
//  Functions:  WXP_CertTrustDllMain
//              CertTrustInit
//              CertTrustCertPolicy     - shouldn't be called
//              CertTrustFinalPolicy
//              CertTrustCleanup        - shouldn't be called
//
//              CertModifyCertificatesToTrust
//              FModifyTrust
//              FreeWVTHandle
//              HrDoTrustWork
//              FormatValidityFailures
//
//  History:    11-Feb-2001 philh      created (rewrite to use chain APIs)
//
//--------------------------------------------------------------------------
#include "pch.hxx"
#include <wintrust.h>
#include "demand.h"
#include <stdio.h>

// The following should be moved to cryptdlg.h

#define CERT_VALIDITY_POLICY_FAILURE            0x00001000
#define CERT_VALIDITY_BASIC_CONSTRAINTS_FAILURE 0x00002000

const char SzPolicyKey[] = 
    "SOFTWARE\\Microsoft\\Cryptography\\" szCERT_CERTIFICATE_ACTION_VERIFY;
const char SzPolicyData[] = "PolicyFlags";
const char SzUrlRetrievalTimeoutData[] = "UrlRetrievalTimeout"; // milliseconds


#define EXPLICIT_TRUST_NONE     0
#define EXPLICIT_TRUST_YES      1
#define EXPLICIT_TRUST_NO       2

#define MAX_HASH_LEN            20
#define MIN_HASH_LEN            16


// ExplictTrust is encoded as a SEQUENCE OF Attribues. We are only
// interested in encoding one attribute with one value. We will only change
// the last byte. It contains the trust value. It can be: 0-NONE, 1-YES, 2-NO.
const BYTE rgbEncodedExplictTrust[] = {
    0x30, 0x13,             // SEQUENCE OF
      0x30, 0x11,           //   SEQUENCE
        0x06, 0x0a,         //     OID: 1.3.6.1.4.1.311.10.4.1
          0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x04, 0x01,
        0x31, 0x03,         //     SET OF
          0x02, 0x01, 0x00  //       INTEGER: 0-NONE, 1-YES, 2-NO
};

HINSTANCE g_hCertTrustInst;
HCERTSTORE g_hStoreTrustedPeople;
HCERTSTORE g_hStoreDisallowed;

// Cached Chain. We remember the last built chain context and try to re-use.
// Outlook calls us 2 or 3 times to build a chain for the same certificate
// context.
CRITICAL_SECTION g_CachedChainCriticalSection;
DWORD g_dwCachedCreateChainFlags;
PCCERT_CHAIN_CONTEXT g_pCachedChainContext;
FILETIME g_ftCachedChain;

#define CACHED_CHAIN_SECONDS_DURATION   30

BOOL
WINAPI
WXP_CertTrustDllMain(
    HINSTANCE hInst,
    ULONG ulReason,
    LPVOID
    )
{
    BOOL fResult = TRUE;

    switch (ulReason) {
        case DLL_PROCESS_ATTACH:
            g_hCertTrustInst = hInst;

            __try {
                InitializeCriticalSection(&g_CachedChainCriticalSection);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                SetLastError(GetExceptionCode());
                fResult = FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_hStoreTrustedPeople)
                CertCloseStore(g_hStoreTrustedPeople, 0);
            if (g_hStoreDisallowed)
                CertCloseStore(g_hStoreDisallowed, 0);

            if (g_pCachedChainContext)
                CertFreeCertificateChain(g_pCachedChainContext);
            DeleteCriticalSection(&g_CachedChainCriticalSection);
            break;
        case DLL_THREAD_DETACH:
        default:
            break;
    }
    
    return fResult;
}

HCERTSTORE
I_OpenCachedHKCUStore(
    IN OUT HCERTSTORE *phStoreCache,
    IN LPCWSTR pwszStore
    )
{
    HCERTSTORE hStore;

    hStore = *phStoreCache;
    if (NULL == hStore) {
        hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            NULL,
            CERT_SYSTEM_STORE_CURRENT_USER |
                CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                CERT_STORE_SHARE_CONTEXT_FLAG,
            (const void *) pwszStore
            );

        if (hStore) {
            HCERTSTORE hPrevStore;

            CertControlStore(
                hStore,
                0,                  // dwFlags
                CERT_STORE_CTRL_AUTO_RESYNC,
                NULL                // pvCtrlPara
                );

            hPrevStore = InterlockedCompareExchangePointer(
                phStoreCache, hStore, NULL);

            if (hPrevStore) {
                CertCloseStore(hStore, 0);
                hStore = hPrevStore;
            }
        }
    }

    if (hStore)
        hStore = CertDuplicateStore(hStore);

    return hStore;
}

HCERTSTORE
I_OpenTrustedPeopleStore()
{
    return I_OpenCachedHKCUStore(&g_hStoreTrustedPeople, L"TrustedPeople");
}

HCERTSTORE
I_OpenDisallowedStore()
{
    return I_OpenCachedHKCUStore(&g_hStoreDisallowed, L"Disallowed");
}

// We use signature hash. For untrusted, this will find certificates with
// altered signature content.
PCCERT_CONTEXT
I_FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || MIN_HASH_LEN > HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SIGNATURE_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

// Returns:
//   +1 - Cert was successfully deleted
//    0 - Cert wasn't found
//   -1 - Delete failed     (GetLastError() for failure reason)
//
LONG
I_DeleteCertificateFromOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    LONG lDelete;
    PCCERT_CONTEXT pOtherCert;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = MAX_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || MIN_HASH_LEN > HashBlob.cbData)
        return 0;

    // Note, there is a possibility that multiple certs can have
    // the same signature hash. For example, the signature algorithm
    // parameters may have been altered. Change empty NULL : {0x05, 0x00} to
    // empty OCTET : {0x04, 0x00}.
    lDelete = 0;
    pOtherCert = NULL;
    while (pOtherCert = CertFindCertificateInStore(
            hOtherStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SIGNATURE_HASH,
            (const void *) &HashBlob,
            pOtherCert
            )) {
        CertDuplicateCertificateContext(pOtherCert);
        if (CertDeleteCertificateFromStore(pOtherCert)) {
            if (0 == lDelete)
                lDelete = 1;
        } else
            lDelete = -1;
    }

    return lDelete;
}



HRESULT
I_CheckExplicitTrust(
    IN PCCERT_CONTEXT pCert,
    IN LPFILETIME pftCurrent,
    OUT BYTE *pbExplicitTrust
    )
{
    HRESULT hr;
    BYTE bExplicitTrust = EXPLICIT_TRUST_NONE;
    HCERTSTORE hStoreDisallowed = NULL;
    HCERTSTORE hStoreTrustedPeople = NULL;
    PCCERT_CONTEXT pFindCert = NULL;

    hStoreDisallowed = I_OpenDisallowedStore();
    if (NULL == hStoreDisallowed)
        goto OpenDisallowedStoreError;

    pFindCert = I_FindCertificateInOtherStore(hStoreDisallowed, pCert);
    if (pFindCert) {
        bExplicitTrust = EXPLICIT_TRUST_NO;
        goto SuccessReturn;
    }

    hStoreTrustedPeople = I_OpenTrustedPeopleStore();
    if (NULL == hStoreTrustedPeople)
        goto SuccessReturn;

    pFindCert = I_FindCertificateInOtherStore(hStoreTrustedPeople, pCert);
    if (pFindCert) {
        // Must be time valid to trust
        if (0 == CertVerifyTimeValidity(pftCurrent, pCert->pCertInfo))
            bExplicitTrust = EXPLICIT_TRUST_YES;
        else
            // Remove the expired cert. Just in case there are
            // altered certificates having the same signature hash, do
            // the following delete.
            I_DeleteCertificateFromOtherStore(hStoreTrustedPeople, pFindCert);
    }

SuccessReturn:
    hr = S_OK;
CommonReturn:
    if (pFindCert)
        CertFreeCertificateContext(pFindCert);
    if (hStoreDisallowed)
        CertCloseStore(hStoreDisallowed, 0);
    if (hStoreTrustedPeople)
        CertCloseStore(hStoreTrustedPeople, 0);

    *pbExplicitTrust = bExplicitTrust;
    return hr;

OpenDisallowedStoreError:
    // Most likely unable to access
    hr = E_ACCESSDENIED;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Subtract two filetimes and return the number of seconds.
//
//  The second filetime is subtracted from the first. If the first filetime
//  is before the second, then, 0 seconds is returned.
//
//  Filetime is in units of 100 nanoseconds.  Each second has
//  10**7 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
DWORD
WINAPI
I_SubtractFileTimes(
    IN LPFILETIME pftFirst,
    IN LPFILETIME pftSecond
    )
{
    DWORDLONG qwDiff;

    if (0 >= CompareFileTime(pftFirst, pftSecond))
        return 0;

    qwDiff = *(((DWORDLONG UNALIGNED *) pftFirst)) -
        *(((DWORDLONG UNALIGNED *) pftSecond));

    return (DWORD) (qwDiff / 10000000i64);
}

PCCERT_CHAIN_CONTEXT
I_CheckCachedChain(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwCreateChainFlags
    )
{
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    FILETIME ftCurrent;

    EnterCriticalSection(&g_CachedChainCriticalSection);

    if (NULL == g_pCachedChainContext)
        goto CommonReturn;

    if (g_pCachedChainContext->rgpChain[0]->rgpElement[0]->pCertContext !=
            pCert)
        goto CommonReturn;

    if (dwCreateChainFlags == g_dwCachedCreateChainFlags)
        ;
    else {
        if ((dwCreateChainFlags & g_dwCachedCreateChainFlags) !=
                dwCreateChainFlags)
            goto CommonReturn;

        if (g_pCachedChainContext->TrustStatus.dwErrorStatus &
                (CERT_TRUST_IS_REVOKED | CERT_TRUST_REVOCATION_STATUS_UNKNOWN))
            goto CommonReturn;
    }

    GetSystemTimeAsFileTime(&ftCurrent);
    if (CACHED_CHAIN_SECONDS_DURATION <
            I_SubtractFileTimes(&ftCurrent, &g_ftCachedChain)) {
        CertFreeCertificateChain(g_pCachedChainContext);
        g_pCachedChainContext = NULL;
        goto CommonReturn;
    }

    pChainContext = CertDuplicateCertificateChain(g_pCachedChainContext);
    

CommonReturn:
    LeaveCriticalSection(&g_CachedChainCriticalSection);
    return pChainContext;
}

void
I_SetCachedChain(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwCreateChainFlags
    )
{
    if (pChainContext->TrustStatus.dwErrorStatus &
            (CERT_TRUST_IS_NOT_SIGNATURE_VALID |
                CERT_TRUST_IS_PARTIAL_CHAIN))
        return;

    EnterCriticalSection(&g_CachedChainCriticalSection);

    if (g_pCachedChainContext)
        CertFreeCertificateChain(g_pCachedChainContext);

    g_pCachedChainContext = CertDuplicateCertificateChain(pChainContext);
    g_dwCachedCreateChainFlags = dwCreateChainFlags;
    GetSystemTimeAsFileTime(&g_ftCachedChain);


    LeaveCriticalSection(&g_CachedChainCriticalSection);
}


// Assumption: the message store is included in the rghstoreCAs array.
// Will ignore the rghstoreRoots and rghstoreTrust store arrays. These
// certs should already be opened and cached in the chain engine.
HCERTSTORE
I_GetChainAdditionalStore(
    IN PCERT_VERIFY_CERTIFICATE_TRUST pCertTrust
    )
{
    if (0 == pCertTrust->cStores)
        return NULL;

    if (1 < pCertTrust->cStores) {
        HCERTSTORE hCollectionStore;

        if (hCollectionStore = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )) {
            DWORD i;
            for (i = 0; i < pCertTrust->cStores; i++)
                CertAddStoreToCollection(
                    hCollectionStore,
                    pCertTrust->rghstoreCAs[i],
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
        }
        return hCollectionStore;
    } else
        return CertDuplicateStore(pCertTrust->rghstoreCAs[0]);
}


HRESULT
I_BuildChain(
    IN PCERT_VERIFY_CERTIFICATE_TRUST pCertTrust,
    IN LPFILETIME pftCurrent,
    IN DWORD dwPolicy,
    IN DWORD dwUrlRetrievalTimeout,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    HRESULT hr;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD dwCreateChainFlags = 0;
    CERT_CHAIN_PARA ChainPara;
    HCERTSTORE hAdditionalStore = NULL;
    HCRYPTDEFAULTCONTEXT hDefaultContext = NULL;

    // Update the revocation flags to be used for chain building
    if (pCertTrust->dwFlags & CRYPTDLG_REVOCATION_ONLINE) {
        // Allow full online revocation checking
        dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (pCertTrust->dwFlags & CRYPTDLG_REVOCATION_CACHE) {
        // Allow local revocation checks only, do not hit the network.
        dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN |
            CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    } else if (pCertTrust->dwFlags & CRYPTDLG_REVOCATION_NONE) {
        ;
    } else if (dwPolicy & ACTION_REVOCATION_DEFAULT_ONLINE) {
        // Allow full online revocation checking
        dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    } else if (dwPolicy & ACTION_REVOCATION_DEFAULT_CACHE) {
        // Allow local revocation checks only, do not hit the network
        dwCreateChainFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN |
            CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    }

    // Enable LRU caching of the end certificate. Also, set an upper limit
    // for all CRL URL fetches.
    dwCreateChainFlags |= CERT_CHAIN_CACHE_END_CERT |
        CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT;

    pChainContext = I_CheckCachedChain(
        pCertTrust->pccert,
        dwCreateChainFlags
        );
    if (NULL != pChainContext)
        goto SuccessReturn;
    
    if (pCertTrust->hprov != NULL) {
        // Set the default crypt provider so we can make sure that ours is used
        if (!CryptInstallDefaultContext(pCertTrust->hprov, 
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                szOID_OIWSEC_md5RSA, 0, NULL, &hDefaultContext))
            goto InstallDefaultContextError;
    }

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (pCertTrust->pszUsageOid && '\0' != pCertTrust->pszUsageOid[0]) {
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
            &pCertTrust->pszUsageOid;
    }
    ChainPara.dwUrlRetrievalTimeout = dwUrlRetrievalTimeout;

    hAdditionalStore = I_GetChainAdditionalStore(pCertTrust);


    if (!CertGetCertificateChain (
            HCCE_CURRENT_USER,
            pCertTrust->pccert,
            pftCurrent,
            hAdditionalStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                       // pvReserved,
            &pChainContext
            ))
        goto GetChainError;

    I_SetCachedChain(pChainContext, dwCreateChainFlags);

SuccessReturn:
    hr = S_OK;
CommonReturn:
    if (hDefaultContext)
        CryptUninstallDefaultContext(hDefaultContext, 0, NULL);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);

    *ppChainContext = pChainContext;

    return hr;

GetChainError:
InstallDefaultContextError:
    pChainContext = NULL;
    hr = TRUST_E_SYSTEM_ERROR;
    goto CommonReturn;
}

DWORD
I_MapValidityErrorsToTrustError(
    IN DWORD dwErrors
    )
{
    DWORD dwTrustError = S_OK;

    // Look at them in decreasing order of importance
    if (dwErrors) {
        if (dwErrors & CERT_VALIDITY_EXPLICITLY_DISTRUSTED) {
            dwTrustError = TRUST_E_EXPLICIT_DISTRUST;
        } else if (dwErrors & CERT_VALIDITY_SIGNATURE_FAILS) {
            dwTrustError = TRUST_E_CERT_SIGNATURE;
        } else if (dwErrors & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
            dwTrustError = CERT_E_CHAINING;
        } else if (dwErrors & CERT_VALIDITY_NO_TRUST_DATA) {
            dwTrustError = CERT_E_UNTRUSTEDROOT;
        } else if (dwErrors & CERT_VALIDITY_CERTIFICATE_REVOKED) {
            dwTrustError = CERT_E_REVOKED;
        } else if (dwErrors & CERT_VALIDITY_EXTENDED_USAGE_FAILURE) {
            dwTrustError = CERT_E_WRONG_USAGE;
        } else if (dwErrors & 
                (CERT_VALIDITY_BEFORE_START | CERT_VALIDITY_AFTER_END)) {
            dwTrustError = CERT_E_EXPIRED;
        } else if (dwErrors & CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE) {
            dwTrustError = CERT_E_INVALID_NAME;
        } else if (dwErrors & CERT_VALIDITY_POLICY_FAILURE) {
            dwTrustError = CERT_E_INVALID_POLICY;
        } else if (dwErrors & CERT_VALIDITY_BASIC_CONSTRAINTS_FAILURE) {
            dwTrustError = TRUST_E_BASIC_CONSTRAINTS;
        } else if (dwErrors & CERT_VALIDITY_NO_CRL_FOUND) {
            dwTrustError = CERT_E_REVOCATION_FAILURE;
        } else if (dwErrors & (CERT_VALIDITY_ISSUER_INVALID |
                CERT_VALIDITY_ISSUER_DISTRUST)) {
            dwTrustError = CERT_E_UNTRUSTEDROOT;
        } else {
            dwTrustError = TRUST_E_FAIL;
        }
    }

    return dwTrustError;
}

HRESULT
I_UpdateCertProvFromExplicitTrust(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwAllErrors
    )
{
    CRYPT_PROVIDER_SGNR Sgnr;
    PCRYPT_PROVIDER_SGNR pSgnr;
    PCRYPT_PROVIDER_CERT pProvCert;

    memset(&Sgnr, 0, sizeof(Sgnr));
    Sgnr.cbStruct = sizeof(Sgnr);

    if (!pProvData->psPfns->pfnAddSgnr2Chain(
            pProvData,
            FALSE,              // fCounterSigner
            0,                  // idwSigner
            &Sgnr
            ))
        return TRUST_E_SYSTEM_ERROR;

    if (!pProvData->psPfns->pfnAddCert2Chain(
            pProvData,
            0,                  // idxSigner
            FALSE,              // fCounterSigner
            0,                  // idxCounterSigner
            pCert
            ))
        return TRUST_E_SYSTEM_ERROR;

    pSgnr = WTHelperGetProvSignerFromChain(
        pProvData,
        0,                      // idxSigner
        FALSE,                  // fCounterSigner
        0                       // idxCounterSigner
        );
    if (NULL == pSgnr)
        return TRUST_E_SYSTEM_ERROR;

    pProvCert = WTHelperGetProvCertFromChain(
        pSgnr,
        0                       // idxCert
        );
    if (NULL == pProvCert)
        return TRUST_E_SYSTEM_ERROR;

    pSgnr->dwError = pProvCert->dwError =
        I_MapValidityErrorsToTrustError(dwAllErrors);

    // Map to IE4Trust confidence
    pProvCert->dwConfidence |=
        CERT_CONFIDENCE_SIG |
        CERT_CONFIDENCE_TIMENEST |
        CERT_CONFIDENCE_AUTHIDEXT |
        CERT_CONFIDENCE_HYGIENE
        ;

    if (!(dwAllErrors &
            (CERT_VALIDITY_BEFORE_START | CERT_VALIDITY_AFTER_END)))
        pProvCert->dwConfidence |= CERT_CONFIDENCE_TIME;

    return S_OK;
}

HRESULT
I_UpdateCertProvChain(
    IN OUT PCRYPT_PROVIDER_DATA pProvData,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD cTrustCert,
    IN DWORD rgdwErrors[],
    IN DWORD dwAllErrors
    )
{
    CRYPT_PROVIDER_SGNR Sgnr;
    PCRYPT_PROVIDER_SGNR pSgnr;
    DWORD iTrustCert;
    DWORD i;

    memset(&Sgnr, 0, sizeof(Sgnr));
    Sgnr.cbStruct = sizeof(Sgnr);

    if (!pProvData->psPfns->pfnAddSgnr2Chain(
            pProvData,
            FALSE,              // fCounterSigner
            0,                  // idwSigner
            &Sgnr
            ))
        return TRUST_E_SYSTEM_ERROR;

    pSgnr = WTHelperGetProvSignerFromChain(
        pProvData,
        0,                      // idxSigner
        FALSE,                  // fCounterSigner
        0                       // idxCounterSigner
        );
    if (NULL == pSgnr)
        return TRUST_E_SYSTEM_ERROR;

    pSgnr->pChainContext = CertDuplicateCertificateChain(pChainContext);
    pSgnr->dwError = I_MapValidityErrorsToTrustError(dwAllErrors);

    iTrustCert = 0;
    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
            DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
            DWORD dwEleInfo = pEle->TrustStatus.dwInfoStatus;
            PCRYPT_PROVIDER_CERT pProvCert;

            if (iTrustCert >= cTrustCert)
                return TRUST_E_SYSTEM_ERROR;

            if (!pProvData->psPfns->pfnAddCert2Chain(
                    pProvData,
                    0,                  // idxSigner
                    FALSE,              // fCounterSigner
                    0,                  // idxCounterSigner
                    pEle->pCertContext
                    ))
                return TRUST_E_SYSTEM_ERROR;

            pProvCert = WTHelperGetProvCertFromChain(
                pSgnr,
                iTrustCert
                );
            if (NULL == pProvCert)
                return TRUST_E_SYSTEM_ERROR;

            //DSIE: 12-Oct-2000 added pChainElement to CRYPT_PROVIDER_CERT.
            if (WVT_ISINSTRUCT(CRYPT_PROVIDER_CERT, pProvCert->cbStruct,
                    pChainElement))
                pProvCert->pChainElement = pEle;

            pProvCert->fSelfSigned =
                0 != (dwEleInfo & CERT_TRUST_IS_SELF_SIGNED) &&
                0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID);

            pProvCert->fTrustedRoot =
                pProvCert->fSelfSigned &&
                i == pChainContext->cChain - 1 &&
                j == pChain->cElement - 1 &&
                0 == (dwEleError & CERT_TRUST_IS_UNTRUSTED_ROOT);


            // First Element in all but the first simple chain
            pProvCert->fTrustListSignerCert = (0 < i && 0 == j);

            pProvCert->fIsCyclic = (0 != (dwEleError & CERT_TRUST_IS_CYCLIC));

            // Map to IE4Trust confidence
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_SIG;
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_TIME_VALID))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_TIME;

            // On Sep 10, 1998 Trevor/Brian wanted time nesting checks to
            // be disabled
            // if (0 == (dwEleError & CERT_TRUST_IS_NOT_TIME_NESTED))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_TIMENEST;

            if (0 != (dwEleInfo & CERT_TRUST_HAS_EXACT_MATCH_ISSUER))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_AUTHIDEXT;
            if (0 == (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID) &&
                    0 != (dwEleInfo & CERT_TRUST_HAS_EXACT_MATCH_ISSUER))
                pProvCert->dwConfidence |= CERT_CONFIDENCE_HYGIENE;

            if (pEle->pRevocationInfo) {
                pProvCert->dwRevokedReason =
                    pEle->pRevocationInfo->dwRevocationResult;
            }

            pProvCert->dwError = I_MapValidityErrorsToTrustError(
                rgdwErrors[iTrustCert]);

            // If last element in simple chain, check if it was in a
            // CTL and update CryptProvData if it was.
            if (j == pChain->cElement - 1 && pChain->pTrustListInfo &&
                    pChain->pTrustListInfo->pCtlContext) {
                DWORD dwChainError = pChain->TrustStatus.dwErrorStatus;

                // Note, don't need to AddRef since we already hold an
                // AddRef on the ChainContext.
                pProvCert->pCtlContext = pChain->pTrustListInfo->pCtlContext;

                if (dwChainError & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID) {
                    pProvCert->dwCtlError = TRUST_E_CERT_SIGNATURE;
                } else if (dwChainError & CERT_TRUST_CTL_IS_NOT_TIME_VALID) {
                    pProvCert->dwCtlError = CERT_E_EXPIRED;
                } else if (dwChainError &
                        CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE) {
                    pProvCert->dwCtlError = CERT_E_WRONG_USAGE;
                }
            }

            iTrustCert++;
        }
    }

    return S_OK;
}

HRESULT
CertTrustFinalPolicy(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    HRESULT hr;
    PCERT_VERIFY_CERTIFICATE_TRUST pCertTrust;
    DWORD dwPolicy = 0;
    DWORD dwUrlRetrievalTimeout = 0;
    FILETIME ftCurrent;
    BYTE bExplicitTrust = EXPLICIT_TRUST_NONE;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD cTrustCert = 0;
    PCCERT_CONTEXT *rgpTrustCert = NULL;
    DWORD *rgdwErrors = NULL;
    DATA_BLOB *rgBlobTrustInfo = NULL;
    DWORD dwAllErrors = 0;

    // Verify we are called by a version of WVT having all of the fields we will
    // be using.
    if (!WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwFinalError))
        return E_INVALIDARG;

    // Continue checking that we have everything we need.
    if (pProvData->pWintrustData->pBlob->cbStruct <
            sizeof(WINTRUST_BLOB_INFO))
        goto InvalidProvData;

    pCertTrust = (PCERT_VERIFY_CERTIFICATE_TRUST)
        pProvData->pWintrustData->pBlob->pbMemObject;
    if ((pCertTrust == NULL) ||
            (pCertTrust->cbSize < sizeof(*pCertTrust)))
        goto InvalidProvData;

    // If present, retrieve policy flags and URL retrieval timeout from
    // the registry
    {
        HKEY hKeyPolicy;

        if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE, SzPolicyKey,
                0, KEY_READ, &hKeyPolicy)) {
            DWORD dwType;
            DWORD cbSize;

            cbSize = sizeof(dwPolicy);
            if (ERROR_SUCCESS != RegQueryValueExA(hKeyPolicy, SzPolicyData, 
                    0, &dwType, (LPBYTE) &dwPolicy, &cbSize)
                            || 
                    REG_DWORD != dwType)
                dwPolicy = 0;

            cbSize = sizeof(dwUrlRetrievalTimeout);
            if (ERROR_SUCCESS != RegQueryValueExA(
                    hKeyPolicy, SzUrlRetrievalTimeoutData, 
                    0, &dwType, (LPBYTE) &dwUrlRetrievalTimeout, &cbSize)
                            || 
                    REG_DWORD != dwType)
                dwUrlRetrievalTimeout = 0;

            RegCloseKey(hKeyPolicy);
        }
    }

    // Get current time to be used
    GetSystemTimeAsFileTime(&ftCurrent);

    hr = I_CheckExplicitTrust(
        pCertTrust->pccert,
        &ftCurrent,
        &bExplicitTrust
        );
    if (S_OK != hr)
        goto CheckExplicitTrustError;

    if (EXPLICIT_TRUST_NONE != bExplicitTrust) {
        // No need to build the chain, the trust decision has already been
        // made
        cTrustCert = 1;
    } else {
        DWORD i;

        hr = I_BuildChain(
            pCertTrust,
            &ftCurrent,
            dwPolicy,
            dwUrlRetrievalTimeout,
            &pChainContext
            );
        if (S_OK != hr)
            goto BuildChainError;

        cTrustCert = 0;
        for (i = 0; i < pChainContext->cChain; i++)
            cTrustCert += pChainContext->rgpChain[i]->cElement;

        if (0 == cTrustCert)
            goto InvalidChainContext;
    }

    // Allocate the memory to contain the errors for each cert in the chain
    rgdwErrors = (DWORD *) LocalAlloc(
        LMEM_FIXED | LMEM_ZEROINIT, cTrustCert * sizeof(DWORD));
    if (NULL == rgdwErrors)
        goto OutOfMemory;

    // If the caller requests the chain certs and/or the encoded trust
    // information, then, allocate the arrays
    if (pCertTrust->prgChain) {
        rgpTrustCert = (PCCERT_CONTEXT *) LocalAlloc(
            LMEM_FIXED | LMEM_ZEROINIT, cTrustCert * sizeof(PCCERT_CONTEXT));
        if (NULL == rgpTrustCert)
            goto OutOfMemory;
    }

    if (pCertTrust->prgpbTrustInfo) {
        rgBlobTrustInfo = (DATA_BLOB *) LocalAlloc(
            LMEM_FIXED | LMEM_ZEROINIT, cTrustCert * sizeof(DATA_BLOB));
        if (NULL == rgBlobTrustInfo)
            goto OutOfMemory;
    }

    if (EXPLICIT_TRUST_NONE != bExplicitTrust) {
        // We have a single cert without a chain

        if (rgpTrustCert)
            rgpTrustCert[0] =
                CertDuplicateCertificateContext(pCertTrust->pccert);

        if (rgBlobTrustInfo) {
            // Update the returned encoded trust info

            const DWORD cb = sizeof(rgbEncodedExplictTrust);
            BYTE *pb;

            pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pb)
                goto OutOfMemory;
            memcpy(pb, rgbEncodedExplictTrust, cb);
            pb[cb-1] = bExplicitTrust;
            rgBlobTrustInfo[0].cbData = cb;
            rgBlobTrustInfo[0].pbData = pb;
        }

        if (EXPLICIT_TRUST_YES != bExplicitTrust) {
            LONG lValidity;

            dwAllErrors |= CERT_VALIDITY_EXPLICITLY_DISTRUSTED;

            lValidity = CertVerifyTimeValidity(&ftCurrent,
                pCertTrust->pccert->pCertInfo);
            if (0 > lValidity)
                dwAllErrors |= CERT_VALIDITY_BEFORE_START;
            else if (0 < lValidity)
                dwAllErrors |= CERT_VALIDITY_AFTER_END;
        }

        dwAllErrors &= ~pCertTrust->dwIgnoreErr;
        rgdwErrors[0] = dwAllErrors;

        if (WTD_STATEACTION_VERIFY == pProvData->pWintrustData->dwStateAction) {
            hr = I_UpdateCertProvFromExplicitTrust(
                pProvData,
                pCertTrust->pccert,
                dwAllErrors
                );
            if (S_OK != hr)
                goto UpdateCertProvFromExplicitTrustError;
        }

    } else {
        DWORD i;
        DWORD iTrustCert = 0;

        // Get the cert trust info from the chain context elements
        for (i = 0; i < pChainContext->cChain; i++) {
            DWORD j;
            PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];
            DWORD dwChainError = pChain->TrustStatus.dwErrorStatus;

            for (j = 0; j < pChain->cElement; j++) {
                PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
                DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
                DWORD dwErrors = 0;

                if (iTrustCert >= cTrustCert)
                    goto InvalidChainContext;

                if (0 != dwEleError) {
                    if (dwEleError & CERT_TRUST_IS_NOT_TIME_VALID) {
                        // Check if after or before
                        if (0 > CertVerifyTimeValidity(&ftCurrent,
                                pEle->pCertContext->pCertInfo))
                            dwErrors |= CERT_VALIDITY_BEFORE_START;
                        else
                            dwErrors |= CERT_VALIDITY_AFTER_END;
                    }

                    if (dwEleError & CERT_TRUST_IS_NOT_SIGNATURE_VALID)
                        dwErrors |= CERT_VALIDITY_SIGNATURE_FAILS;

                    if (dwEleError & CERT_TRUST_IS_REVOKED) {
                        dwErrors |= CERT_VALIDITY_CERTIFICATE_REVOKED;
                    } else if (dwEleError & CERT_TRUST_IS_OFFLINE_REVOCATION)
                        dwErrors |= CERT_VALIDITY_NO_CRL_FOUND;

                    if (dwEleError & CERT_TRUST_IS_NOT_VALID_FOR_USAGE)
                        dwErrors |= CERT_VALIDITY_EXTENDED_USAGE_FAILURE;

                    if (dwEleError &
                            (CERT_TRUST_INVALID_POLICY_CONSTRAINTS |
                                CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY))
                        // We added POLICY_FAILURE on 02-13-01
                        dwErrors |= CERT_VALIDITY_POLICY_FAILURE |
                            CERT_VALIDITY_OTHER_EXTENSION_FAILURE;

                    if (dwEleError & CERT_TRUST_INVALID_BASIC_CONSTRAINTS) {
                        BOOL fEnableBasicConstraints = TRUE;

                        if (dwPolicy & POLICY_IGNORE_NON_CRITICAL_BC) {
                            // Disable if we don't have a critical extension

                            PCERT_EXTENSION pExt;
                            
                            pExt = CertFindExtension(
                                szOID_BASIC_CONSTRAINTS2,
                                pEle->pCertContext->pCertInfo->cExtension,
                                pEle->pCertContext->pCertInfo->rgExtension
                                );
                            if (NULL == pExt || !pExt->fCritical)
                                fEnableBasicConstraints = FALSE;
                        }

                        if (fEnableBasicConstraints)
                            // We added BASIC_CONSTRAINTS_FAILURE on 02-13-01
                            dwErrors |=
                                CERT_VALIDITY_BASIC_CONSTRAINTS_FAILURE |
                                CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                    }

                    if (dwEleError & CERT_TRUST_INVALID_EXTENSION)
                        dwErrors |= CERT_VALIDITY_OTHER_EXTENSION_FAILURE;

                    if (dwEleError &
                            (CERT_TRUST_INVALID_NAME_CONSTRAINTS |
                                CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT |
                                CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT |
                                CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT |
                                CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT))
                        dwErrors |= CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE |
                            CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                }

                if (0 == j) {
                    // End cert
                    if (dwChainError & CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY)
                        // We added POLICY_FAILURE on 02-13-01
                        dwErrors |= CERT_VALIDITY_POLICY_FAILURE |
                            CERT_VALIDITY_OTHER_EXTENSION_FAILURE;
                }

                if (iTrustCert == cTrustCert - 1) {
                    // Top cert. Should be the root.
                    if (dwChainError & (CERT_TRUST_IS_PARTIAL_CHAIN |
                                CERT_TRUST_IS_CYCLIC))
                        dwErrors |= CERT_VALIDITY_NO_ISSUER_CERT_FOUND |
                            CERT_VALIDITY_NO_TRUST_DATA;
                    else if (dwEleError & CERT_TRUST_IS_UNTRUSTED_ROOT)
                        dwErrors |= CERT_VALIDITY_NO_TRUST_DATA;
                    else if (NULL != rgBlobTrustInfo)
                        rgBlobTrustInfo[iTrustCert].pbData = (BYTE *) 1;
                }

                dwErrors &= ~pCertTrust->dwIgnoreErr;
                dwAllErrors |= dwErrors;

                rgdwErrors[iTrustCert] = dwErrors;
                if (rgpTrustCert)
                    rgpTrustCert[iTrustCert] =
                        CertDuplicateCertificateContext(pEle->pCertContext);
                iTrustCert++;
            }

            // CTL chain errors
            if (dwChainError &
                    (CERT_TRUST_CTL_IS_NOT_TIME_VALID |
                        CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID |
                        CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE)) {
                if (dwChainError & CERT_TRUST_CTL_IS_NOT_TIME_VALID)
                    dwAllErrors |= CERT_VALIDITY_AFTER_END;
                if (dwChainError & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID)
                    dwAllErrors |= CERT_VALIDITY_SIGNATURE_FAILS;
                if (dwChainError & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE)
                    dwAllErrors |= CERT_VALIDITY_EXTENDED_USAGE_FAILURE;

                dwAllErrors &= ~pCertTrust->dwIgnoreErr;
            }
        }

        
        if (dwAllErrors) {
            // If the issuer has errors, set an issuer error on the subject
            for (iTrustCert = cTrustCert - 1; iTrustCert > 0; iTrustCert--) {
                if (rgdwErrors[iTrustCert] & CERT_VALIDITY_MASK_VALIDITY)
                    rgdwErrors[iTrustCert - 1] |= CERT_VALIDITY_ISSUER_INVALID;
                if (rgdwErrors[iTrustCert] & CERT_VALIDITY_MASK_TRUST)
                    rgdwErrors[iTrustCert - 1] |= CERT_VALIDITY_ISSUER_DISTRUST;

                rgdwErrors[iTrustCert - 1] &= ~pCertTrust->dwIgnoreErr;
                dwAllErrors |= rgdwErrors[iTrustCert - 1];
            }
        }

        if (WTD_STATEACTION_VERIFY == pProvData->pWintrustData->dwStateAction) {
            hr = I_UpdateCertProvChain(
                pProvData,
                pChainContext,
                cTrustCert,
                rgdwErrors,
                dwAllErrors
                );
            if (S_OK != hr)
                goto UpdateCertProvChainError;
        }

    }

    pProvData->dwFinalError = I_MapValidityErrorsToTrustError(dwAllErrors);

    switch (pProvData->dwFinalError) {
        // For backwards compatibility, only the following HRESULTs are
        // returned.
        case S_OK:
//        case TRUST_E_CERT_SIGNATURE:
//        case CERT_E_REVOKED:
//        case CERT_E_REVOCATION_FAILURE:
            hr = pProvData->dwFinalError;
            break;
        default:
            hr = S_FALSE;
    }

    // Update the returned cert trust info

    if (NULL != pCertTrust->pdwErrors) {
        *pCertTrust->pdwErrors = dwAllErrors;
    }

    if (NULL != pCertTrust->pcChain) {
        *pCertTrust->pcChain = cTrustCert;
    }
    if (NULL != pCertTrust->prgChain) {
        *pCertTrust->prgChain = rgpTrustCert;
        rgpTrustCert = NULL;
    }
    if (NULL != pCertTrust->prgdwErrors) {
        *pCertTrust->prgdwErrors = rgdwErrors;
        rgdwErrors = NULL;
    }
    if (NULL != pCertTrust->prgpbTrustInfo) {
        *pCertTrust->prgpbTrustInfo = rgBlobTrustInfo;
        rgBlobTrustInfo = NULL;
    }

CommonReturn:
    if (pChainContext)
        CertFreeCertificateChain(pChainContext);

    if (NULL != rgpTrustCert) {
        DWORD i;

        for (i = 0; i < cTrustCert; i++) {
            if (NULL != rgpTrustCert[i])
                CertFreeCertificateContext(rgpTrustCert[i]);
        }
        LocalFree(rgpTrustCert);
    }

    if (NULL != rgBlobTrustInfo) {
        DWORD i;

        for (i = 0; i < cTrustCert; i++) {
            if (0 < rgBlobTrustInfo[i].cbData)
                LocalFree(rgBlobTrustInfo[i].pbData);
        }
        LocalFree(rgBlobTrustInfo);
    }

    if (NULL != rgdwErrors)
        LocalFree(rgdwErrors);

    return hr;


CheckExplicitTrustError:
BuildChainError:
UpdateCertProvFromExplicitTrustError:
UpdateCertProvChainError:
ErrorReturn:
    if (SUCCEEDED(hr))
        hr = TRUST_E_SYSTEM_ERROR;
    goto CommonReturn;

InvalidProvData:
    hr = E_INVALIDARG;
    goto ErrorReturn;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto ErrorReturn;

InvalidChainContext:
    hr = TRUST_E_SYSTEM_ERROR;
    goto ErrorReturn;
}

HRESULT
CertTrustInit(
    IN OUT PCRYPT_PROVIDER_DATA pProvData
    )
{
    // Verify we are called by a version of WVT having all of the fields we will
    // be using.
    if (!WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, pProvData->cbStruct, dwFinalError))
        return E_INVALIDARG;

    // We are going to do all of our stuff in the pfFinalPolicy
    // callback.  NULL all of the remaining provider callbacks to
    // inhibit them from being called.
    if (!WVT_ISINSTRUCT(CRYPT_PROVIDER_FUNCTIONS,
            pProvData->psPfns->cbStruct, pfnCleanupPolicy))
        return E_INVALIDARG;

    pProvData->psPfns->pfnObjectTrust = NULL;
    pProvData->psPfns->pfnSignatureTrust = NULL;
    pProvData->psPfns->pfnCertificateTrust = NULL;
    pProvData->psPfns->pfnFinalPolicy = CertTrustFinalPolicy;
    pProvData->psPfns->pfnCertCheckPolicy = NULL;
    pProvData->psPfns->pfnTestFinalPolicy = NULL;
    pProvData->psPfns->pfnCleanupPolicy = NULL;

    return S_OK;
}


// The following function should never be called.
BOOL
CertTrustCertPolicy(PCRYPT_PROVIDER_DATA, DWORD, BOOL, DWORD)
{
    return FALSE;
}

// The following function should never be called.
HRESULT
CertTrustCleanup(PCRYPT_PROVIDER_DATA)
{
    return TRUST_E_FAIL;
}


// In WXP this API was changed not to use CTLs. Instead, the "TrustedPeople" and
// "Disallowed" certificate stores are used.

HRESULT CertModifyCertificatesToTrust(int cCertsToModify, PCTL_MODIFY_REQUEST rgCertMods,
                                      LPCSTR szPurpose, HWND hwnd, HCERTSTORE hcertstorTrust,
                                      PCCERT_CONTEXT pccertSigner)
{
    HRESULT hr = S_OK;
    HCERTSTORE hStoreDisallowed = NULL;
    HCERTSTORE hStoreTrustedPeople = NULL;
    int i;

    hStoreDisallowed = I_OpenDisallowedStore();
    if (NULL == hStoreDisallowed)
        goto OpenDisallowedStoreError;
    hStoreTrustedPeople = I_OpenTrustedPeopleStore();
    if (NULL == hStoreTrustedPeople)
        goto OpenTrustedPeopleStoreError;

    for (i = 0; i < cCertsToModify; i++) {
        PCCERT_CONTEXT pCert = rgCertMods[i].pccert;
        DWORD dwError = S_OK;

        switch(rgCertMods[i].dwOperation) {
            case CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED:
                if (0 > I_DeleteCertificateFromOtherStore(
                            hStoreTrustedPeople, pCert))
                    dwError = GetLastError();
                if (!CertAddCertificateContextToStore(
                        hStoreDisallowed,
                        pCert,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL
                        ))
                    dwError = GetLastError();
                break;

            case CTL_MODIFY_REQUEST_REMOVE:
                if (0 > I_DeleteCertificateFromOtherStore(
                            hStoreDisallowed, pCert))
                    dwError = GetLastError();
                if (0 > I_DeleteCertificateFromOtherStore(
                            hStoreTrustedPeople, pCert))
                    dwError = GetLastError();
                break;

            case CTL_MODIFY_REQUEST_ADD_TRUSTED:
                if (0 > I_DeleteCertificateFromOtherStore(
                            hStoreDisallowed, pCert))
                    dwError = GetLastError();
                if (!CertAddCertificateContextToStore(
                        hStoreTrustedPeople,
                        pCert,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL
                        ))
                    dwError = GetLastError();
                break;

            default:
                dwError = E_INVALIDARG;
        }

        dwError = HRESULT_FROM_WIN32(dwError);
        rgCertMods[i].dwError = dwError;
        if (FAILED(dwError))
            hr = S_FALSE;
    }

CommonReturn:
    if (hStoreDisallowed)
        CertCloseStore(hStoreDisallowed, 0);
    if (hStoreTrustedPeople)
        CertCloseStore(hStoreTrustedPeople, 0);

    return hr;

OpenDisallowedStoreError:
OpenTrustedPeopleStoreError:
    // Most likely unable to access
    hr = E_ACCESSDENIED;
    goto CommonReturn;
}


BOOL FModifyTrust(HWND hwnd, PCCERT_CONTEXT pccert, DWORD dwNewTrust,
                  LPSTR szPurpose)
{
    HRESULT     hr;
    CTL_MODIFY_REQUEST  certmod;

    certmod.pccert = pccert;
    certmod.dwOperation = dwNewTrust;

    hr = CertModifyCertificatesToTrust(1, &certmod, szPurpose, hwnd, NULL, NULL);
    return (hr == S_OK) && (certmod.dwError == 0);
}


void FreeWVTHandle(HANDLE hWVTState) {
    if (hWVTState) {
        HRESULT hr;
        WINTRUST_DATA data = {0};

        data.cbStruct = sizeof(WINTRUST_DATA);
        data.pPolicyCallbackData = NULL;
        data.pSIPClientData = NULL;
        data.dwUIChoice = WTD_UI_NONE;
        data.fdwRevocationChecks = WTD_REVOKE_NONE;
        data.dwUnionChoice = WTD_CHOICE_BLOB;
        data.pBlob = NULL;      // &blob;
        data.dwStateAction = WTD_STATEACTION_CLOSE;
        data.hWVTStateData = hWVTState;
        hr = WinVerifyTrust(NULL, (GUID *)&GuidCertValidate, &data);
    }
}

HRESULT HrDoTrustWork(PCCERT_CONTEXT pccertToCheck, DWORD dwControl,
                      DWORD dwValidityMask,
                      DWORD /*cPurposes*/, LPSTR * rgszPurposes, HCRYPTPROV hprov,
                      DWORD cRoots, HCERTSTORE * rgRoots,
                      DWORD cCAs, HCERTSTORE * rgCAs,
                      DWORD cTrust, HCERTSTORE * rgTrust,
                      PFNTRUSTHELPER pfn, DWORD lCustData,
                      PCCertFrame *  /*ppcf*/, DWORD * pcNodes,
                      PCCertFrame * rgpcfResult,
                      HANDLE * phReturnStateData)   // optional: return WinVerifyTrust state handle here
{
    DWORD                               cbData;
    DWORD                               cCerts = 0;
    WINTRUST_BLOB_INFO                  blob = {0};
    WINTRUST_DATA                       data = {0};
    DWORD                               dwErrors;
    BOOL                                f;
    HRESULT                             hr;
    int                                 i;
    DWORD                               j;
    PCCERT_CONTEXT *                    rgCerts = NULL;
    DWORD *                             rgdwErrors = NULL;
    DATA_BLOB *                         rgblobTrust = NULL;
    CERT_VERIFY_CERTIFICATE_TRUST       trust;
    UNALIGNED CRYPT_ATTR_BLOB *pVal = NULL;

    FILETIME ftCurrent;

    data.cbStruct = sizeof(WINTRUST_DATA);
    data.pPolicyCallbackData = NULL;
    data.pSIPClientData = NULL;
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;
    if (phReturnStateData) {
        data.dwStateAction = WTD_STATEACTION_VERIFY;
    }

    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.pcwszDisplayName = NULL;
    blob.cbMemObject = sizeof(trust);
    blob.pbMemObject = (LPBYTE) &trust;

    trust.cbSize = sizeof(trust);
    trust.pccert = pccertToCheck;
    trust.dwFlags = (CERT_TRUST_DO_FULL_SEARCH |
                     CERT_TRUST_PERMIT_MISSING_CRLS |
                     CERT_TRUST_DO_FULL_TRUST | dwControl);
    trust.dwIgnoreErr = dwValidityMask;
    trust.pdwErrors = &dwErrors;
    //    Assert(cPurposes == 1);
    if (rgszPurposes != NULL) {
        trust.pszUsageOid = rgszPurposes[0];
    }
    else {
        trust.pszUsageOid = NULL;
    }
    trust.hprov = hprov;
    trust.cRootStores = cRoots;
    trust.rghstoreRoots = rgRoots;
    trust.cStores = cCAs;
    trust.rghstoreCAs = rgCAs;
    trust.cTrustStores = cTrust;
    trust.rghstoreTrust = rgTrust;
    trust.lCustData = lCustData;
    trust.pfnTrustHelper = pfn;
    trust.pcChain = &cCerts;
    trust.prgChain = &rgCerts;
    trust.prgdwErrors = &rgdwErrors;
    trust.prgpbTrustInfo = &rgblobTrust;

    hr = WinVerifyTrust(NULL, (GUID *) &GuidCertValidate, &data);
    if ((TRUST_E_CERT_SIGNATURE == hr) ||
        (CERT_E_REVOKED == hr) ||
        (CERT_E_REVOCATION_FAILURE == hr)) {
        hr = S_OK;
    }
    else if (FAILED(hr)) {
            return hr;
    }
    if (cCerts == 0) {
        return(E_INVALIDARG);
    }

    if (phReturnStateData) {
        *phReturnStateData = data.hWVTStateData;    // Caller must use WinVerifyTrust to free
    }

    GetSystemTimeAsFileTime(&ftCurrent);

    //Assert( cCerts <= 20);
    *pcNodes = cCerts;
    for (i=cCerts-1; i >= 0; i--) {
        rgpcfResult[i] = new CCertFrame(rgCerts[i]);

        if(!rgpcfResult[i])
        {
            hr=E_OUTOFMEMORY;
            goto ExitHere;
        }

        rgpcfResult[i]->m_dwFlags = rgdwErrors[i];
        if (rgszPurposes == NULL) {
            continue;
        }
        rgpcfResult[i]->m_cTrust = 1;
        rgpcfResult[i]->m_rgTrust = new STrustDesc[1];
        memset(rgpcfResult[i]->m_rgTrust, 0, sizeof(STrustDesc));

        if (0 == i)
            rgpcfResult[i]->m_fLeaf = TRUE;
        else
            rgpcfResult[i]->m_fLeaf = FALSE;

        if (0 == CertVerifyTimeValidity(&ftCurrent, rgCerts[i]->pCertInfo))
            rgpcfResult[i]->m_fExpired = FALSE;
        else
            rgpcfResult[i]->m_fExpired = TRUE;

        

        //
        //  We are going to fill in the trust information which we use
        //  to fill in the fields of the dialog box.
        //
        //  Start with the question of the cert being self signed
        //

        rgpcfResult[i]->m_fSelfSign = WTHelperCertIsSelfSigned(X509_ASN_ENCODING, rgCerts[i]->pCertInfo);

        //
        //  We may or may not have trust data information returned, we now
        //      build up the trust info for a single cert
        //
        //  If we don't have any explicit data, then we just chain the data
        //      down from the next level up.
        //

        if (rgblobTrust[i].cbData == 0) {
            //        chain:
            rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = FALSE;
            rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = FALSE;

            //
            //  We return a special code to say that we found it in the root store
            //

            rgpcfResult[i]->m_rgTrust[0].fRootStore = rgpcfResult[i]->m_fRootStore =
                (rgblobTrust[i].pbData == (LPBYTE) 1);

            if (i != (int) (cCerts-1)) {
                rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i+1]->m_rgTrust[0].fTrust;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= rgpcfResult[i+1]->m_rgTrust[0].fDistrust;
            } else {
                //  Oops -- there is no level up one, so just make some
                //      good defaults
                //
                rgpcfResult[i]->m_rgTrust[0].fTrust = rgpcfResult[i]->m_fRootStore;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= FALSE;
            }
        }
        else {
            // Explicit trust is contained in the last byte
            if (EXPLICIT_TRUST_YES ==
                    rgblobTrust[i].pbData[rgblobTrust[i].cbData - 1]) {
                rgpcfResult[i]->m_rgTrust[0].fExplicitTrust = TRUE;
                rgpcfResult[i]->m_rgTrust[0].fTrust = TRUE;
            } else {
                rgpcfResult[i]->m_rgTrust[0].fExplicitDistrust = TRUE;
                rgpcfResult[i]->m_rgTrust[0].fDistrust= TRUE;
            }
        }
    }

    //
    //  Clean up all returned values
    //

ExitHere:
    if (rgCerts != NULL) {
        //bobn If the loop has been broken because "new" failed, free what we allocated so far...
        for ((hr==E_OUTOFMEMORY?i++:i=0); i< (int) cCerts; i++) {
            CertFreeCertificateContext(rgCerts[i]);
        }
        LocalFree(rgCerts);
    }
    if (rgdwErrors != NULL) LocalFree(rgdwErrors);
    if (rgblobTrust != NULL) {
        for (i=0; i<(int) cCerts; i++) {
            if (rgblobTrust[i].cbData > 0) {
                LocalFree(rgblobTrust[i].pbData);
            }
        }
        LocalFree(rgblobTrust);
    }

    return hr;
}

LPWSTR FormatValidityFailures(DWORD dwFlags)
{
    DWORD       cch = 0;
    LPWSTR      pwsz = NULL;
    LPWSTR      pwszT;
    WCHAR       rgwch[200];

    if (dwFlags == 0) {
        return NULL;
    }

    pwsz = (LPWSTR) malloc(100);
    cch = 100;
    if (pwsz == NULL) {
        return NULL;
    }
    if (dwFlags & CERT_VALIDITY_BEFORE_START) {
        LoadString(g_hCertTrustInst, IDS_WHY_NOT_YET, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        wcscpy(pwsz, rgwch);
    } else {
        wcscpy(pwsz, L"");
    }

    if (dwFlags & CERT_VALIDITY_AFTER_END) {
        LoadString(g_hCertTrustInst, IDS_WHY_EXPIRED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_SIGNATURE_FAILS) {
        LoadString(g_hCertTrustInst, IDS_WHY_CERT_SIG, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) {
        LoadString(g_hCertTrustInst, IDS_WHY_NO_PARENT, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_NO_CRL_FOUND) {
        LoadString(g_hCertTrustInst, IDS_WHY_NO_CRL, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_CERTIFICATE_REVOKED) {
        LoadString(g_hCertTrustInst, IDS_WHY_REVOKED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_CRL_OUT_OF_DATE) {
        LoadString(g_hCertTrustInst, IDS_WHY_CRL_EXPIRED, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_EXTENDED_USAGE_FAILURE) {
        LoadString(g_hCertTrustInst, IDS_WHY_EXTEND_USE, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE) {
        LoadString(g_hCertTrustInst, IDS_WHY_NAME_CONST, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_POLICY_FAILURE) {
        LoadString(g_hCertTrustInst, IDS_WHY_POLICY, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    if (dwFlags & CERT_VALIDITY_BASIC_CONSTRAINTS_FAILURE) {
        LoadString(g_hCertTrustInst, IDS_WHY_BASIC_CONS, rgwch, sizeof(rgwch)/sizeof(WCHAR));
        if (wcslen(pwsz) + wcslen(rgwch) + 2 > cch) {
            pwszT = (LPWSTR) realloc(pwsz, cch + 200);
            if (pwszT == NULL) {
                free(pwsz);
                return NULL;
            }
            pwsz = pwszT;
        }
        if (wcslen(pwsz) > 0) wcscat(pwsz, wszCRLF);
        wcscat(pwsz, rgwch);
    }

    return pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\dll\dllmain.h ===
//--------------------------------------------------------------------------
// Dllmain.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
extern CRITICAL_SECTION     g_csDllMain;
extern CRITICAL_SECTION     g_csDBListen;
extern LONG                 g_cRef;
extern LONG                 g_cLock;
extern HINSTANCE            g_hInst;
extern SYSTEM_INFO          g_SystemInfo;
extern BOOL                 g_fIsWinNT;

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\dll\factory.h ===
//----------------------------------------------------------------------
// Factory.h
//----------------------------------------------------------------------
#pragma once

//----------------------------------------------------------------------
// Forward Decls
//----------------------------------------------------------------------
class CClassFactory;

//----------------------------------------------------------------------
// Object Flags
//----------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

//----------------------------------------------------------------------
// Object Creation Prototypes
//----------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

//----------------------------------------------------------------------
// InetComm ClassFactory
//----------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    //----------------------------------------------------------------------
    // Public Data
    //----------------------------------------------------------------------
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    //----------------------------------------------------------------------
    // IUnknown members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IClassFactory members
    //----------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\dll\factory.cpp ===
//--------------------------------------------------------------------------
// Factory.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include "session.h"

//--------------------------------------------------------------------------
// Pretty
//--------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

//--------------------------------------------------------------------------
// Global Object Info Table
//--------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_DatabaseSession,    OBJTYPE1, (PFCREATEINSTANCE)CreateDatabaseSession),
};
                 
//--------------------------------------------------------------------------
// DllGetClassObject
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CClassFactory::CClassFactory
//--------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

//--------------------------------------------------------------------------
// CClassFactory::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

//--------------------------------------------------------------------------
// CClassFactory::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

//--------------------------------------------------------------------------
// CClassFactory::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

//--------------------------------------------------------------------------
// CClassFactory::CreateInstance
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TrapError(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

//--------------------------------------------------------------------------
// CClassFactory::LockServer
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else       InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\query.cpp ===
//--------------------------------------------------------------------------
// Query.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "database.h"
#include "query.h"
#include "shlwapi.h"
#include "strconst.h"

//--------------------------------------------------------------------------
// OPERATORTYPE
//--------------------------------------------------------------------------
typedef enum tagOPERATORTYPE {
    OPERATOR_LEFTPAREN,
    OPERATOR_RIGHTPAREN,
    OPERATOR_EQUAL,
    OPERATOR_NOTEQUAL,
    OPERATOR_LESSTHANEQUAL,
    OPERATOR_LESSTHAN,
    OPERATOR_GREATERTHANEQUAL,
    OPERATOR_GREATERTHAN,
    OPERATOR_AND,
    OPERATOR_BITWISEAND,
    OPERATOR_OR,
    OPERATOR_BITWISEOR,
    OPERATOR_STRSTRI,
    OPERATOR_STRSTR,
    OPERATOR_LSTRCMPI,
    OPERATOR_LSTRCMP,
    OPERATOR_ADD,
    OPERATOR_SUBTRACT,
    OPERATOR_MULTIPLY,
    OPERATOR_DIVIDE,
    OPERATOR_MOD,
    OPERATOR_LAST
} OPERATORTYPE;

//--------------------------------------------------------------------------
// TOKENTYPE
//--------------------------------------------------------------------------
typedef enum tagTOKENTYPE {
    TOKEN_INVALID,
    TOKEN_OPERATOR,
    TOKEN_OPERAND
} TOKENTYPE;

//--------------------------------------------------------------------------
// OPERANDTYPE
//--------------------------------------------------------------------------
typedef enum tagOPERANDTYPE {
    OPERAND_INVALID,
    OPERAND_COLUMN,
    OPERAND_STRING,
    OPERAND_DWORD,
    OPERAND_METHOD,
    OPERAND_LAST
} OPERANDTYPE;

//--------------------------------------------------------------------------
// OPERANDINFO
//--------------------------------------------------------------------------
typedef struct tagOPERANDINFO {
    OPERANDTYPE         tyOperand;
    DWORD               iSymbol;
    LPVOID              pRelease;
    union {
        COLUMNORDINAL   iColumn;        // OPERAND_COLUMN
        LPSTR           pszString;      // OPERAND_STRING
        DWORD           dwValue;        // OPERAND_DWORD
        METHODID        idMethod;       // OPERAND_METHOD
    };
    DWORD               dwReserved;
} OPERANDINFO, *LPOPERANDINFO;

//--------------------------------------------------------------------------
// QUERYTOKEN
//--------------------------------------------------------------------------
typedef struct tagQUERYTOKEN *LPQUERYTOKEN;
typedef struct tagQUERYTOKEN {
    TOKENTYPE           tyToken;
    DWORD               cRefs;
    union {
        OPERATORTYPE    tyOperator;     // TOKEN_OPERATOR
        OPERANDINFO     Operand;        // TOKEN_OPERAND
    };
    LPQUERYTOKEN        pNext;
    LPQUERYTOKEN        pPrevious;
} QUERYTOKEN;

//--------------------------------------------------------------------------
// PFNCOMPAREOPERAND - Compares Two Operands of the same type
//--------------------------------------------------------------------------
typedef INT (APIENTRY *PFNCOMPAREOPERAND)(LPVOID pDataLeft, LPVOID pDataRight);
#define PCOMPARE(_pfn) ((PFNCOMPAREOPERAND)_pfn)

//--------------------------------------------------------------------------
// CompareOperandString
//--------------------------------------------------------------------------
INT CompareOperandString(LPVOID pDataLeft, LPVOID pDataRight) {
    return(lstrcmpi((LPSTR)pDataLeft, (LPSTR)pDataRight));
}

//--------------------------------------------------------------------------
// CompareOperandDword
//--------------------------------------------------------------------------
INT CompareOperandDword(LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) - *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// g_rgpfnCompareOperand
//--------------------------------------------------------------------------
const static PFNCOMPAREOPERAND g_rgpfnCompareOperand[OPERAND_LAST] = {
    NULL,                           // OPERAND_INVALID        
    NULL,                           // OPERAND_COLUMN
    PCOMPARE(CompareOperandString), // OPERAND_STRING
    PCOMPARE(CompareOperandDword)   // OPERAND_DWORD
};

//--------------------------------------------------------------------------
// CompareOperands
//--------------------------------------------------------------------------
#define CompareOperands(_tyOperand, _pDataLeft, _pDataRight) \
    (*(g_rgpfnCompareOperand[_tyOperand]))(_pDataLeft, _pDataRight)

//--------------------------------------------------------------------------
// PFNEVALUATEOPERATOR - Compares data in two flat records.
//--------------------------------------------------------------------------
typedef DWORD (APIENTRY *PFNEVALUATEOPERATOR)(OPERANDTYPE tyOperand, 
    LPVOID pDataLeft, LPVOID pDataRight);
#define PEVAL(_pfn) ((PFNEVALUATEOPERATOR)_pfn)

//--------------------------------------------------------------------------
// Evaluate Operator Prototypes
//--------------------------------------------------------------------------
DWORD EvaluateEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateNotEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateLessThanEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateLessThan(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateGreaterThanEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateGreaterThan(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateAnd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateBitwiseAnd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateOr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateBitwiseOr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateStrStrI(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateStrStr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateStrcmpi(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateStrcmp(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateAdd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateSubtract(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateMultiply(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateDivide(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);
DWORD EvaluateModula(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight);

//--------------------------------------------------------------------------
// OPERATORINFO
//--------------------------------------------------------------------------
typedef struct tagOPERATORINFO {
    LPCSTR              pszName;
    BYTE                bISP;
    BYTE                bICP;
    PFNEVALUATEOPERATOR pfnEvaluate;
} OPERATORINFO, *LPOPERATORINFO;

//--------------------------------------------------------------------------
// Operator Precedence Table
//--------------------------------------------------------------------------
static const OPERATORINFO g_rgOperator[OPERATOR_LAST] = {
    // Name         ISP     ICP     Function
    { "(",          6,      0,      NULL                                }, // OPERATOR_LEFTPAREN
    { ")",          1,      1,      NULL                                }, // OPERATOR_RIGHTPAREN
    { "==",         5,      5,      PEVAL(EvaluateEqual)                }, // OPERATOR_EQUAL
    { "!=",         5,      5,      PEVAL(EvaluateNotEqual)             }, // OPERATOR_NOTEQUAL
    { "<=",         5,      5,      PEVAL(EvaluateLessThanEqual)        }, // OPERATOR_LESSTHANEQUAL
    { "<",          5,      5,      PEVAL(EvaluateLessThan)             }, // OPERATOR_LESSTHAN
    { ">=",         5,      5,      PEVAL(EvaluateGreaterThanEqual)     }, // OPERATOR_GREATERTHANEQUAL
    { ">",          5,      5,      PEVAL(EvaluateGreaterThan)          }, // OPERATOR_GREATERTHAN
    { "&&",         4,      4,      PEVAL(EvaluateAnd)                  }, // OPERATOR_AND
    { "&",          3,      3,      PEVAL(EvaluateBitwiseAnd)           }, // OPERATOR_BITWISEAND
    { "||",         4,      4,      PEVAL(EvaluateOr)                   }, // OPERATOR_OR
    { "|",          3,      3,      PEVAL(EvaluateBitwiseOr)            }, // OPERATOR_BITWISEOR
    { "containsi",  5,      5,      PEVAL(EvaluateStrStrI)              }, // OPERATOR_STRSTRI
    { "contains",   5,      5,      PEVAL(EvaluateStrStr)               }, // OPERATOR_STRSTR
    { "comparei",   5,      5,      PEVAL(EvaluateStrcmpi)              }, // OPERATOR_LSTRCMPI
    { "compare",    5,      5,      PEVAL(EvaluateStrcmp)               }, // OPERATOR_LSTRCMP
    { "+",          4,      4,      PEVAL(EvaluateAdd)                  }, // OPERATOR_ADD,
    { "-",          4,      4,      PEVAL(EvaluateSubtract)             }, // OPERATOR_SUBTRACT,
    { "*",          3,      3,      PEVAL(EvaluateMultiply)             }, // OPERATOR_MULTIPLY,
    { "/",          3,      3,      PEVAL(EvaluateDivide)               }, // OPERATOR_DIVIDE,
    { "%",          3,      3,      PEVAL(EvaluateModula)               }, // OPERATOR_MOD,
};

//--------------------------------------------------------------------------
// EvaluateOperator
//--------------------------------------------------------------------------
#define EvaluateOperator(_tyOperator, _tyOperand, _pDataLeft, _pDataRight) \
    (*(g_rgOperator[_tyOperator].pfnEvaluate))(_tyOperand, _pDataLeft, _pDataRight)

//--------------------------------------------------------------------------
// MAPCOLUMNTYPE
//--------------------------------------------------------------------------
typedef void (APIENTRY *PFNMAPCOLUMNTYPE)(LPOPERANDINFO pOperand, 
    LPCTABLECOLUMN pColumn, LPVOID pBinding, LPVOID *ppValue);
#define PMAP(_pfn) ((PFNMAPCOLUMNTYPE)_pfn)

//--------------------------------------------------------------------------
// MapColumnString
//--------------------------------------------------------------------------
void MapColumnString(LPOPERANDINFO pOperand, LPCTABLECOLUMN pColumn, 
    LPVOID pBinding, LPVOID *ppValue) {
    (*ppValue) = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
}

//--------------------------------------------------------------------------
// MapColumnByte
//--------------------------------------------------------------------------
void MapColumnByte(LPOPERANDINFO pOperand, LPCTABLECOLUMN pColumn, 
    LPVOID pBinding, LPVOID *ppValue) {
    pOperand->dwReserved = *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding));
    (*ppValue) = (LPVOID)&pOperand->dwReserved;
}

//--------------------------------------------------------------------------
// MapColumnDword
//--------------------------------------------------------------------------
void MapColumnDword(LPOPERANDINFO pOperand, LPCTABLECOLUMN pColumn, 
    LPVOID pBinding, LPVOID *ppValue) {
    pOperand->dwReserved = *((DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    (*ppValue) = (LPVOID)&pOperand->dwReserved;
}

//--------------------------------------------------------------------------
// MapColumnWord
//--------------------------------------------------------------------------
void MapColumnWord(LPOPERANDINFO pOperand, LPCTABLECOLUMN pColumn, 
    LPVOID pBinding, LPVOID *ppValue) {
    pOperand->dwReserved = *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    (*ppValue) = (LPVOID)&pOperand->dwReserved;
}

//--------------------------------------------------------------------------
// COLUMNTYPEINFO
//--------------------------------------------------------------------------
typedef struct tagCOLUMNTYPEINFO {
    OPERANDTYPE         tyOperand;
    PFNMAPCOLUMNTYPE    pfnMapColumnType;
} COLUMNTYPEINFO, *LPCOLUMNTYPEINFO;

//--------------------------------------------------------------------------
// g_rgColumnTypeInfo
//--------------------------------------------------------------------------
static const COLUMNTYPEINFO g_rgColumnTypeInfo[CDT_LASTTYPE] = {
    { OPERAND_INVALID, NULL                     }, // CDT_FILETIME,
    { OPERAND_STRING,  PMAP(MapColumnString)    }, // CDT_FIXSTRA,
    { OPERAND_STRING,  PMAP(MapColumnString)    }, // CDT_VARSTRA,
    { OPERAND_DWORD,   PMAP(MapColumnByte)      }, // CDT_BYTE,
    { OPERAND_DWORD,   PMAP(MapColumnDword)     }, // CDT_DWORD,
    { OPERAND_DWORD,   PMAP(MapColumnWord)      }, // CDT_WORD,
    { OPERAND_DWORD,   PMAP(MapColumnDword)     }, // CDT_STREAM,
    { OPERAND_INVALID, NULL                     }, // CDT_VARBLOB,
    { OPERAND_INVALID, NULL                     }, // CDT_FIXBLOB,
    { OPERAND_DWORD,   PMAP(MapColumnDword)     }, // CDT_FLAGS,
    { OPERAND_DWORD,   PMAP(MapColumnDword)     }, // CDT_UNIQUE
};

//--------------------------------------------------------------------------
// MapColumnType
//--------------------------------------------------------------------------
#define MapColumnType(_tyColumn, _pOperand, _pColumn, _pBinding, _ppValue) \
    (*(g_rgColumnTypeInfo[_tyColumn].pfnMapColumnType))(_pOperand, _pColumn, _pBinding, _ppValue)

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT GetNextQueryToken(LPSTR *ppszT, LPCTABLESCHEMA pSchema, LPQUERYTOKEN *ppToken, CDatabase *pDB);
HRESULT LinkToken(LPQUERYTOKEN pToken, LPQUERYTOKEN *ppHead, LPQUERYTOKEN *ppTail);
HRESULT ReleaseTokenList(BOOL fReverse, LPQUERYTOKEN *ppHead, CDatabase *pDB);
HRESULT ReleaseToken(LPQUERYTOKEN *ppToken, CDatabase *pDB);
HRESULT ParseStringLiteral(LPCSTR pszStart, LPOPERANDINFO pOperand, LPSTR *ppszEnd, CDatabase *pDB);
HRESULT ParseNumeric(LPCSTR pszT, LPOPERANDINFO pOperand, LPSTR *ppszEnd);
HRESULT ParseSymbol(LPCSTR pszT, LPCTABLESCHEMA pSchema, LPOPERANDINFO pOperand, LPSTR *ppszEnd, CDatabase *pDB);
HRESULT PushStackToken(LPQUERYTOKEN pToken, LPQUERYTOKEN *ppStackTop);
HRESULT PopStackToken(LPQUERYTOKEN *ppToken, LPQUERYTOKEN *ppStackTop);
HRESULT EvaluateClause(OPERATORTYPE tyOperator, LPVOID pBinding, LPCTABLESCHEMA pSchema, LPQUERYTOKEN *ppStackTop, CDatabase *pDB, IDatabaseExtension *pExtension);
IF_DEBUG(HRESULT DebugDumpExpression(LPCSTR pszQuery, LPCTABLESCHEMA pSchema, LPQUERYTOKEN pPostfixHead));

//--------------------------------------------------------------------------
// ISP inline
//--------------------------------------------------------------------------
inline BYTE ISP(LPQUERYTOKEN pToken)
{
    // Validate
    Assert(TOKEN_OPERATOR == pToken->tyToken && pToken->tyOperator < OPERATOR_LAST);

    // Return ISP
    return (g_rgOperator[pToken->tyOperator].bISP);
}

//--------------------------------------------------------------------------
// ICP inline
//--------------------------------------------------------------------------
inline BYTE ICP(LPQUERYTOKEN pToken)
{
    // Validate
    Assert(TOKEN_OPERATOR == pToken->tyToken && pToken->tyOperator < OPERATOR_LAST);

    // Return ISP
    return (g_rgOperator[pToken->tyOperator].bICP);
}

// --------------------------------------------------------------------------
// DBIsDigit
// --------------------------------------------------------------------------
int DBIsDigit(LPSTR psz)
{
    WORD wType;
    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return(wType & C1_DIGIT);
}

//--------------------------------------------------------------------------
// EvaluateQuery
//--------------------------------------------------------------------------
HRESULT EvaluateQuery(HQUERY hQuery, LPVOID pBinding, LPCTABLESCHEMA pSchema,
    CDatabase *pDB, IDatabaseExtension *pExtension)
{
    // Locals
    HRESULT         hr=S_OK;
    LPQUERYTOKEN    pToken;
    LPQUERYTOKEN    pResult=NULL;
    LPQUERYTOKEN    pStackTop=NULL;

    // Trace
    TraceCall("EvaluateQuery");

    // Assert
    Assert(hQuery && pBinding && pSchema);

    // Walk through the tokens
    for (pToken=(LPQUERYTOKEN)hQuery; pToken!=NULL; pToken=pToken->pNext)
    {
        // If this is an operand, append to the stack
        if (TOKEN_OPERAND == pToken->tyToken)
        {
            // LinkStackToken
            PushStackToken(pToken, &pStackTop);
        }

        // Otherwise, must be an operator
        else
        {
            // Operator ?
            Assert(TOKEN_OPERATOR == pToken->tyToken && g_rgOperator[pToken->tyOperator].pfnEvaluate != NULL);

            // EvaluateOperator
            IF_FAILEXIT(hr = EvaluateClause(pToken->tyOperator, pBinding, pSchema, &pStackTop, pDB, pExtension));
        }
    }

    // Pop the stack
    PopStackToken(&pResult, &pStackTop);

    // No Token and Stack should now be empty..
    Assert(pResult && NULL == pStackTop && pResult->tyToken == TOKEN_OPERAND && pResult->Operand.tyOperand == OPERAND_DWORD);

    // 0 or not zero
    hr = (pResult->Operand.dwValue == 0) ? S_FALSE : S_OK;

exit:
    // Cleanup
    ReleaseToken(&pResult, pDB);
    ReleaseTokenList(TRUE, &pStackTop, pDB);

    // Done
    return(SUCCEEDED(hr) ? hr : S_FALSE);
}

//--------------------------------------------------------------------------
// ParseQuery
//--------------------------------------------------------------------------
HRESULT ParseQuery(LPCSTR pszQuery, LPCTABLESCHEMA pSchema, LPHQUERY phQuery,
    CDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszT=(LPSTR)pszQuery;
    LPQUERYTOKEN    pCurrent;
    LPQUERYTOKEN    pPrevious;
    LPQUERYTOKEN    pToken=NULL;
    LPQUERYTOKEN    pPostfixHead=NULL;
    LPQUERYTOKEN    pPostfixTail=NULL;
    LPQUERYTOKEN    pStackTop=NULL;

    // Trace
    TraceCall("ParseQuery");

    // Invalid Args
    if (NULL == pszQuery || NULL == pSchema || NULL == phQuery)
        return TraceResult(E_INVALIDARG);

    // Initialize
    (*phQuery) = NULL;

    // Start the Parsing Loop
    while(1)
    {
        // Parse next Token
        IF_FAILEXIT(hr = GetNextQueryToken(&pszT, pSchema, &pToken, pDB));

        // Done
        if (S_FALSE == hr)
            break;

        // If this was an operand, append to postfix expression
        if (TOKEN_OPERAND == pToken->tyToken)
        {
            // LinkToken
            LinkToken(pToken, &pPostfixHead, &pPostfixTail);

            // Don't pToken
            ReleaseToken(&pToken, pDB);
        }

        // Otherwise, must be an operator
        else
        {
            // Must be an operator
            Assert(TOKEN_OPERATOR == pToken->tyToken);
        
            // If Right Paren
            if (OPERATOR_RIGHTPAREN == pToken->tyOperator)
            {
                // Pop all the items from the stack and link into the postfix expression
                while (pStackTop && OPERATOR_LEFTPAREN != pStackTop->tyOperator)
                {
                    // Save pPrevious
                    pPrevious = pStackTop->pPrevious;

                    // Otherwise
                    LinkToken(pStackTop, &pPostfixHead, &pPostfixTail);

                    // Releae
                    ReleaseToken(&pStackTop, pDB);

                    // Goto Previuos
                    pStackTop = pPrevious;
                }

                // If not a left parent was found, then we failed
                if (OPERATOR_LEFTPAREN != pStackTop->tyOperator)
                {
                    hr = TraceResult(DB_E_UNMATCHINGPARENS);
                    goto exit;
                }

                // Save pPrevious
                pPrevious = pStackTop->pPrevious;

                // Free pStackTop
                ReleaseToken(&pStackTop, pDB);

                // Reset pStackTop
                pStackTop = pPrevious;

                // Free pToken
                ReleaseToken(&pToken, pDB);
            }

            // Otherwise
            else
            {
                // Pop all the items into the postfix expression according to a cool little priority rule
                while (pStackTop && ISP(pStackTop) <= ICP(pToken))
                {
                    // Save pPrevious
                    pPrevious = pStackTop->pPrevious;

                    // Otherwise
                    LinkToken(pStackTop, &pPostfixHead, &pPostfixTail);

                    // Releae
                    ReleaseToken(&pStackTop, pDB);

                    // Goto Previuos
                    pStackTop = pPrevious;
                }

                // Append pToken to the Stack
                LinkToken(pToken, NULL, &pStackTop);

                // Don't pToken
                ReleaseToken(&pToken, pDB);
            }
        }
    }

    // Pop all the items from the stack and link into the postfix expression
    while (pStackTop)
    {
        // Save pPrevious
        pPrevious = pStackTop->pPrevious;

        // Append to Postfix Expression
        LinkToken(pStackTop, &pPostfixHead, &pPostfixTail);

        // Releae
        ReleaseToken(&pStackTop, pDB);

        // Goto Previuos
        pStackTop = pPrevious;
    }

    // lets write the postfix notation...
    //IF_DEBUG(DebugDumpExpression(pszQuery, pSchema, pPostfixHead));

    // Success
    (*phQuery) = (HQUERY)pPostfixHead;

exit:
    // Cleanup On Failure
    if (FAILED(hr))
    {
        // Free pToken
        ReleaseToken(&pToken, pDB);

        // Free the Stack
        ReleaseTokenList(TRUE, &pStackTop, pDB);

        // Free the Postfix Expression
        ReleaseTokenList(FALSE, &pPostfixHead, pDB);
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// DebugDumpExpression
//--------------------------------------------------------------------------
#ifdef DEBUG
HRESULT DebugDumpExpression(LPCSTR pszQuery, LPCTABLESCHEMA pSchema, 
    LPQUERYTOKEN pPostfixHead)
{
    // Locals
    LPQUERYTOKEN pToken;

    // Trace
    TraceCall("DebugDumpExpression");

    // Write Infix
    DebugTrace("ParseQuery (Infix)   : %s\n", pszQuery);

    // Write Postfix header
    DebugTrace("ParseQuery (Postfix) : ");

    // Loop through the tokens
    for (pToken=pPostfixHead; pToken!=NULL; pToken=pToken->pNext)
    {
        // Operator
        if (TOKEN_OPERATOR == pToken->tyToken)
        {
            // Write the Operator
            DebugTrace("%s", g_rgOperator[pToken->tyOperator].pszName);
        }

        // Operand
        else if (TOKEN_OPERAND == pToken->tyToken)
        {
            // Column Operand
            if (OPERAND_COLUMN == pToken->Operand.tyOperand)
            {
                // Must have an iSymbol
                Assert(0xffffffff != pToken->Operand.iSymbol);

                // Write the Symbol
                DebugTrace("Column: %d (%s)", pToken->Operand.dwValue, pSchema->pSymbols->rgSymbol[pToken->Operand.iSymbol].pszName);
            }

            // String Operand
            else if (OPERAND_STRING == pToken->Operand.tyOperand)
            {
                // Write the Symbol
                DebugTrace("<%s>", pToken->Operand.pszString);
            }

            // Dword Operand
            else if (OPERAND_DWORD == pToken->Operand.tyOperand)
            {
                // Has a iSymbol
                if (0xffffffff != pToken->Operand.iSymbol)
                {
                    // Write the Symbol
                    DebugTrace("%d (%s)", pToken->Operand.dwValue, pSchema->pSymbols->rgSymbol[pToken->Operand.iSymbol].pszName);
                }

                // Otherwise, just write the value
                else
                {
                    // Write the Symbol
                    DebugTrace("%d", pToken->Operand.dwValue);
                }
            }

            // Method 
            else if (OPERAND_METHOD == pToken->Operand.tyOperand)
            {
                // Validate Symbol Type
                Assert(SYMBOL_METHOD == pSchema->pSymbols->rgSymbol[pToken->Operand.iSymbol].tySymbol);

                // Write the Method
                DebugTrace("Method: %d (%s)", pToken->Operand.idMethod, pSchema->pSymbols->rgSymbol[pToken->Operand.iSymbol].pszName);
            }
        }

        // Bad
        else
            Assert(FALSE);

        // Write Delimiter
        DebugTrace(", ");
    }

    // Wrap the line
    DebugTrace("\n");

    // Done
    return(S_OK);
}
#endif // DEBUG

//--------------------------------------------------------------------------
// CompareSymbol
//--------------------------------------------------------------------------
HRESULT CompareSymbol(LPSTR pszT, LPCSTR pszName, LPSTR *ppszEnd)
{
    // Locals
    LPSTR       pszName1;
    LPSTR       pszName2;

    // Trace
    TraceCall("CompareSymbol");

    // Set pszName
    pszName1 = (LPSTR)pszName;

    // Set pszName2
    pszName2 = pszT;

    // Compare pszTo to Operator pszName...
    while ('\0' != *pszName2 && *pszName1 == *pszName2)
    {
        // Increment
        pszName1++;
        pszName2++;

        // Reached the End of pszName1, must be a match
        if ('\0' == *pszName1)
        {
            // Set ppszEnd
            *ppszEnd = pszName2;

            // Done
            return(S_OK);
        }
    }

    // Done
    return(S_FALSE);
}

//--------------------------------------------------------------------------
// GetNextQueryToken
//--------------------------------------------------------------------------
HRESULT GetNextQueryToken(LPSTR *ppszT, LPCTABLESCHEMA pSchema,
    LPQUERYTOKEN *ppToken, CDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_FALSE;
    LPSTR           pszT=(*ppszT);
    LPSTR           pszEnd;
    DWORD           i;
    LPQUERYTOKEN    pToken=NULL;

    // Trace
    TraceCall("GetNextQueryToken");

    // Allocate a Token
    IF_NULLEXIT(pToken = (LPQUERYTOKEN)pDB->PHeapAllocate(HEAP_ZERO_MEMORY, sizeof(QUERYTOKEN)));

    // Set Reference Count
    pToken->cRefs = 1;

    // No Token foundyet
    pToken->tyToken = TOKEN_INVALID;

    // Invalid Symbol Index
    pToken->Operand.iSymbol = 0xffffffff;

    // Skip White Space...
    while(*pszT && (*pszT == ' ' || *pszT == '\t'))
        pszT++;

    // Done
    if ('\0' == *pszT)
        goto exit;
    
    // Check for the Start of an Operator...
    for (i=0; i<OPERATOR_LAST; i++)
    {
        // Does pszT point to the start of an operator ?
        if (S_OK == CompareSymbol(pszT, g_rgOperator[i].pszName, &pszEnd))
        {
            // Update pszT
            pszT = pszEnd;

            // We found an operator
            pToken->tyToken = TOKEN_OPERATOR;

            // Set the operator type
            pToken->tyOperator = (OPERATORTYPE)i;

            // Done
            break;
        }
    }

    // No Token Yet ?
    if (TOKEN_INVALID == pToken->tyToken)
    {
        // Start of a String Literal ?
        if ('"' == *pszT)
        {
            // ParseStringLiteral
            IF_FAILEXIT(hr = ParseStringLiteral(pszT, &pToken->Operand, &pszEnd, pDB));
        }

        // Otherwise, start of a number
        else if (DBIsDigit(pszT))
        {
            // ParseNumeric
            IF_FAILEXIT(hr = ParseNumeric(pszT, &pToken->Operand, &pszEnd));
        }

        // Start of a Symbol
        else
        {
            // ParseSymbol
            IF_FAILEXIT(hr = ParseSymbol(pszT, pSchema, &pToken->Operand, &pszEnd, pDB));
        }

        // Must have been an operand
        pToken->tyToken = TOKEN_OPERAND;

        // Set pszT
        pszT = pszEnd;
    }

    // Set ppszT
    *ppszT = pszT;

    // Success
    hr = S_OK;

    // Return the Token
    *ppToken = pToken;

    // Don't Free the Token
    pToken = NULL;

exit:
    // Cleanup
    ReleaseToken(&pToken, pDB);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// ParseStringLiteral
//--------------------------------------------------------------------------
HRESULT ParseStringLiteral(LPCSTR pszStart, LPOPERANDINFO pOperand, 
    LPSTR *ppszEnd, CDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszValue;
    DWORD           cchString;
    LPSTR           pszT=(LPSTR)pszStart;
    
    // Trace
    TraceCall("ParseStringLiteral");

    // Validate Args
    Assert(*pszT == '"' && pOperand && ppszEnd);

    // Increment over "
    pszT++;

    // Find the End of the Quoted String
    while(*pszT)
    {
        // DBCS Lead Byte
        if (IsDBCSLeadByte(*pszT) || '\\' == *pszT)
        {
            pszT+=2;
            continue;
        }

        // If Escaped Quote..
        if ('"' == *pszT)
        {
            // Set ppszEnd
            *ppszEnd = pszT + 1;

            // Done
            break;
        }

        // Increment pszT
        pszT++;
    }

    // Not Found
    if ('\0' == *pszT)
    {
        hr = TraceResult(DB_E_UNMATCHINGQUOTES);
        goto exit;
    }

    // Get Size
    cchString = (DWORD)(pszT - (pszStart + 1));

    // Duplicate the String
    IF_NULLEXIT(pszValue = (LPSTR)pDB->PHeapAllocate(NOFLAGS, cchString + 1));

    // Copy the String
    CopyMemory(pszValue, pszStart + 1, cchString);

    // Set the Null
    pszValue[cchString] = '\0';

    // Set Operand Type
    pOperand->tyOperand = OPERAND_STRING;

    // Release
    pOperand->pRelease = (LPVOID)pszValue;

    // Set Value
    pOperand->pszString = pszValue;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// ParseNumeric
//--------------------------------------------------------------------------
HRESULT ParseNumeric(LPCSTR pszStart, LPOPERANDINFO pOperand, LPSTR *ppszEnd)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwValue;
    CHAR            szNumber[255];
    DWORD           dwIncrement=0;
    LPSTR           pszT=(LPSTR)pszStart;
    DWORD           cchNumber;
    
    // Trace
    TraceCall("ParseNumeric");

    // Validate Args
    Assert(DBIsDigit(pszT) && pOperand && ppszEnd);

    // Is Hex: 0x
    if ('0' == *pszT && '\0' != *(pszT + 1) && 'X' == TOUPPERA(*(pszT + 1)))
    {
        // IsHex
        dwIncrement = 2;

        // Set pszT
        pszT += 2;
    }

    // Find the End of the Number
    while (*pszT && DBIsDigit(pszT))
    {
        // Increment
        pszT++;
    }

    // Get Length
    cchNumber = (DWORD)(pszT - (pszStart + dwIncrement));

    // Too Frickin Big
    if (cchNumber >= ARRAYSIZE(szNumber))
    {
        hr = TraceResult(DB_E_NUMBERTOOBIG);
        goto exit;
    }

    // Copy into szNumber
    CopyMemory(szNumber, pszStart + dwIncrement, cchNumber);

    // Set Null
    szNumber[cchNumber] = '\0';

    // If Is Hex, convert to integer
    if (FALSE == StrToIntEx(szNumber, dwIncrement ? STIF_SUPPORT_HEX : STIF_DEFAULT, (INT *)&dwValue))
    {
        hr = TraceResult(DB_E_BADNUMBER);
        goto exit;
    }

    // Set Operand Type
    pOperand->tyOperand = OPERAND_DWORD;

    // Set Value
    pOperand->dwValue = dwValue;

    // Return ppszEnd
    *ppszEnd = pszT;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// ParseSymbol
//--------------------------------------------------------------------------
HRESULT ParseSymbol(LPCSTR pszT, LPCTABLESCHEMA pSchema, LPOPERANDINFO pOperand, 
    LPSTR *ppszEnd, CDatabase *pDB)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPSYMBOLINFO    pSymbol;
    LPSTR           pszEnd;
    
    // Trace
    TraceCall("ParseSymbol");

    // No Symbols
    if (NULL == pSchema->pSymbols)
    {
        hr = TraceResult(DB_E_NOSYMBOLS);
        goto exit;
    }

    // Check for the Start of an Operator...
    for (i=0; i<pSchema->pSymbols->cSymbols; i++)
    {
        // Readability
        pSymbol = (LPSYMBOLINFO)&pSchema->pSymbols->rgSymbol[i];

        // Does pszT point to the start of an operator ?
        if (S_OK == CompareSymbol((LPSTR)pszT, pSymbol->pszName, &pszEnd))
        {
            // Update pszT
            *ppszEnd = pszEnd;

            // Save iSymbol
            pOperand->iSymbol = i;

            // Is Column Symbol
            if (SYMBOL_COLUMN == pSymbol->tySymbol)
            {
                // Validate the Ordinal
                if (pSymbol->dwValue > pSchema->cColumns)
                {
                    hr = TraceResult(DB_E_INVALIDCOLUMN);
                    goto exit;
                }

                // Convert to OPERANDTYPE
                pOperand->tyOperand = OPERAND_COLUMN;

                // Save the Column
                pOperand->iColumn = (COLUMNORDINAL)pSymbol->dwValue;
            }

            // Otherwise, is a method ?
            else if (SYMBOL_METHOD == pSymbol->tySymbol)
            {
                // Convert to OPERANDTYPE
                pOperand->tyOperand = OPERAND_METHOD;

                // Save the Column
                pOperand->idMethod = pSymbol->dwValue;
            }

            // Otherwise, just a dword value
            else
            {
                // Dword
                pOperand->tyOperand = OPERAND_DWORD;

                // Set the operator type
                pOperand->dwValue = pSymbol->dwValue;
            }

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = TraceResult(DB_E_INVALIDSYMBOL);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CloseQuery
//--------------------------------------------------------------------------
HRESULT CloseQuery(LPHQUERY phQuery, CDatabase *pDB)
{
    // Trace
    TraceCall("CloseQuery");

    // ReleaseTokenList
    ReleaseTokenList(FALSE, (LPQUERYTOKEN *)phQuery, pDB);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// PushStackToken
//--------------------------------------------------------------------------
HRESULT PushStackToken(LPQUERYTOKEN pToken, LPQUERYTOKEN *ppStackTop)
{
    // Trace
    TraceCall("PushStackToken");

    // Set pStackPrevious
    pToken->pPrevious = (*ppStackTop);

    // Update Stack Top
    (*ppStackTop) = pToken;

    // AddRef the Token
    pToken->cRefs++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// PopStackToken
//--------------------------------------------------------------------------
HRESULT PopStackToken(LPQUERYTOKEN *ppToken, LPQUERYTOKEN *ppStackTop)
{
    // Trace
    TraceCall("PopStackToken");

    // Validate
    Assert(ppToken && ppStackTop);

    // No more tokens...
    if (NULL == *ppStackTop)
        return TraceResult(DB_E_BADEXPRESSION);

    // Set Token
    *ppToken = (*ppStackTop);

    // Goto Previous
    (*ppStackTop) = (*ppToken)->pPrevious;

    // Release the Token
    //(*ppToken)->cRefs--;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// LinkToken
//--------------------------------------------------------------------------
HRESULT LinkToken(LPQUERYTOKEN pToken, LPQUERYTOKEN *ppHead, LPQUERYTOKEN *ppTail)
{
    // Trace
    TraceCall("LinkToken");

    // Invalid Args
    Assert(pToken && ppTail);

    // No Next and No Previous
    pToken->pNext = pToken->pPrevious = NULL;

    // No Head yet ?
    if (ppHead && NULL == *ppHead)
    {
        // Set the Head and Tail
        *ppHead = pToken;
    }

    // Otherwise, append to the end
    else if (*ppTail)
    {
        // Set ppTail->pNext
        (*ppTail)->pNext = pToken;

        // Set Previous
        pToken->pPrevious = (*ppTail);
    }

    // Update the Tail
    *ppTail = pToken;

    // AddRef the Token
    pToken->cRefs++;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// ReleaseToken
//--------------------------------------------------------------------------
HRESULT ReleaseToken(LPQUERYTOKEN *ppToken, CDatabase *pDB)
{
    // Trace
    TraceCall("ReleaseToken");

    // Token
    if (*ppToken)
    {
        // Validate Reference Count
        Assert((*ppToken)->cRefs);

        // Decrement Reference Count
        (*ppToken)->cRefs--;

        // No more refs...
        if (0 == (*ppToken)->cRefs)
        {
            // Free pData
            pDB->HeapFree((*ppToken)->Operand.pRelease);

            // Free pElement
            pDB->HeapFree((*ppToken));
        }

        // Don't Release Again
        *ppToken = NULL;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// ReleaseTokenList
//--------------------------------------------------------------------------
HRESULT ReleaseTokenList(BOOL fReverse, LPQUERYTOKEN *ppHead, CDatabase *pDB)
{
    // Locals
    LPQUERYTOKEN    pNext;
    LPQUERYTOKEN    pToken=(*ppHead);

    // Trace
    TraceCall("ReleaseTokenList");

    // Walk the Linked List
    while (pToken)
    {
        // Save Next
        pNext = (fReverse ? pToken->pPrevious : pToken->pNext);

        // Free this token
        ReleaseToken(&pToken, pDB);

        // Goto Next
        pToken = pNext;
    }

    // Don't Free Again
    *ppHead = NULL;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// PGetOperandData
//--------------------------------------------------------------------------
LPVOID PGetOperandData(OPERANDTYPE tyOperand, LPOPERANDINFO pOperand, 
    LPVOID pBinding, LPCTABLESCHEMA pSchema, CDatabase *pDB, 
    IDatabaseExtension *pExtension)
{
    // Locals
    LPVOID      pValue=NULL;

    // Trace
    TraceCall("PGetOperandData");

    // OPERAND_COLUMN
    if (OPERAND_COLUMN == pOperand->tyOperand)
    {
        // Get the Tag 
        LPCTABLECOLUMN pColumn = &pSchema->prgColumn[pOperand->iColumn];

        // MapColumnType
        MapColumnType(pColumn->type, pOperand, pColumn, pBinding, &pValue);
    }

    // OPERAND_STRING
    else if (OPERAND_STRING == pOperand->tyOperand)
    {
        // Better want a string out
        Assert(OPERAND_STRING == tyOperand);

        // Return Data Pointer
        pValue = pOperand->pszString;
    }

    // OPERAND_DWORD
    else if (OPERAND_DWORD == pOperand->tyOperand)
    {
        // Better want a dword out
        Assert(OPERAND_DWORD == tyOperand);

        // Return Data Pointer
        pValue = (LPVOID)&pOperand->dwValue;
    }

    // OPERAND_METHOD
    else if (OPERAND_METHOD == pOperand->tyOperand && pExtension)
    {
        // Better want a dword out
        Assert(OPERAND_DWORD == tyOperand);

        // Call the Method on the Extension
        pExtension->OnExecuteMethod(pOperand->idMethod, pBinding, &pOperand->dwReserved);

        // Return Data Pointer
        pValue = (LPVOID)&pOperand->dwReserved;
    }

    // No Data ?
    if (NULL == pValue)
    {
        // What type of operand was wanted
        switch(tyOperand)
        {
        case OPERAND_STRING:
            pValue = (LPVOID)c_szEmpty;
            break;

        case OPERAND_DWORD:
            pOperand->dwReserved = 0;
            pValue = (LPVOID)&pOperand->dwReserved;
            break;

        default:
            AssertSz(FALSE, "While go ahead and Jimmy my buffet..");
            break;
        }
    }

    // Done
    return(pValue);
}

//--------------------------------------------------------------------------
// GetCommonOperandType
//--------------------------------------------------------------------------
OPERANDTYPE GetCommonOperandType(LPOPERANDINFO pLeft, LPOPERANDINFO pRight,
    LPCTABLESCHEMA pSchema)
{
    // Locals
    OPERANDTYPE tyLeft = (OPERAND_STRING == pLeft->tyOperand ? OPERAND_STRING : OPERAND_DWORD);
    OPERANDTYPE tyRight = (OPERAND_STRING == pRight->tyOperand ? OPERAND_STRING : OPERAND_DWORD);

    // Trace
    TraceCall("GetCommonOperandType");

    // Left is a column
    if (OPERAND_COLUMN == pLeft->tyOperand)
    {
        // Maps to a string
        if (OPERAND_STRING == g_rgColumnTypeInfo[pSchema->prgColumn[pLeft->iColumn].type].tyOperand)
            tyLeft = OPERAND_STRING;
    }

    // Right is a string
    if (OPERAND_COLUMN == pRight->tyOperand)
    {
        // Maps to a String ?
        if (OPERAND_STRING == g_rgColumnTypeInfo[pSchema->prgColumn[pRight->iColumn].type].tyOperand)
            tyRight = OPERAND_STRING;
    }

    // Better be the Same
    Assert(tyLeft == tyRight);

    // Return tyLeft since they are the same
    return(tyLeft);
}

//--------------------------------------------------------------------------
// EvaluateClause
//--------------------------------------------------------------------------
HRESULT EvaluateClause(OPERATORTYPE tyOperator, LPVOID pBinding,
    LPCTABLESCHEMA pSchema, LPQUERYTOKEN *ppStackTop, CDatabase *pDB,
    IDatabaseExtension *pExtension)
{
    // Locals
    HRESULT         hr=S_OK;
    LPVOID          pDataLeft=NULL;
    LPVOID          pDataRight=NULL;
    LPQUERYTOKEN    pTokenResult=NULL;
    LPQUERYTOKEN    pTokenRight=NULL;
    LPQUERYTOKEN    pTokenLeft=NULL;
    OPERANDTYPE     tyOperand;
    INT             nCompare;

    // Trace
    TraceCall("EvaluateClause");

    // Pop the right token
    IF_FAILEXIT(hr = PopStackToken(&pTokenRight, ppStackTop));

    // Pop the left token
    IF_FAILEXIT(hr = PopStackToken(&pTokenLeft, ppStackTop));

    // Better have Data
    Assert(TOKEN_OPERAND == pTokenLeft->tyToken && TOKEN_OPERAND == pTokenRight->tyToken);

    // Compute Operand type
    tyOperand = GetCommonOperandType(&pTokenLeft->Operand, &pTokenRight->Operand, pSchema);

    // Get Left Data
    pDataLeft = PGetOperandData(tyOperand, &pTokenLeft->Operand, pBinding, pSchema, pDB, pExtension);

    // Get Right Data
    pDataRight = PGetOperandData(tyOperand, &pTokenRight->Operand, pBinding, pSchema, pDB, pExtension);

    // Create new Token to push back onto the stack
    IF_NULLEXIT(pTokenResult = (LPQUERYTOKEN)pDB->PHeapAllocate(HEAP_ZERO_MEMORY, sizeof(QUERYTOKEN)));

    // Set Reference Count
    pTokenResult->cRefs = 1;

    // No Token foundyet
    pTokenResult->tyToken = TOKEN_OPERAND;

    // Invalid Symbol Index
    pTokenResult->Operand.iSymbol = 0xffffffff;

    // Set Result
    pTokenResult->Operand.tyOperand = OPERAND_DWORD;

    // EvaluateData
    pTokenResult->Operand.dwValue = EvaluateOperator(tyOperator, tyOperand, pDataLeft, pDataRight);

    // Push the result operand
    PushStackToken(pTokenResult, ppStackTop);
   
exit:
    // Cleanup
    ReleaseToken(&pTokenLeft, pDB);
    ReleaseToken(&pTokenRight, pDB);
    ReleaseToken(&pTokenResult, pDB);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// EvaluateEqual
//--------------------------------------------------------------------------
DWORD EvaluateEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (0 == CompareOperands(tyOperand, pDataLeft, pDataRight) ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateNotEqual
//--------------------------------------------------------------------------
DWORD EvaluateNotEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (0 != CompareOperands(tyOperand, pDataLeft, pDataRight) ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateLessThanEqual
//--------------------------------------------------------------------------
DWORD EvaluateLessThanEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (CompareOperands(tyOperand, pDataLeft, pDataRight) <= 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateLessThan
//--------------------------------------------------------------------------
DWORD EvaluateLessThan(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (CompareOperands(tyOperand, pDataLeft, pDataRight) < 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateGreaterThanEqual
//--------------------------------------------------------------------------
DWORD EvaluateGreaterThanEqual(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (CompareOperands(tyOperand, pDataLeft, pDataRight) >= 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateGreaterThan
//--------------------------------------------------------------------------
DWORD EvaluateGreaterThan(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (CompareOperands(tyOperand, pDataLeft, pDataRight) > 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateAnd
//--------------------------------------------------------------------------
DWORD EvaluateAnd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) && *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateBitwiseAnd
//--------------------------------------------------------------------------
DWORD EvaluateBitwiseAnd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) & *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateOr
//--------------------------------------------------------------------------
DWORD EvaluateOr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) || *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateBitwiseOr
//--------------------------------------------------------------------------
DWORD EvaluateBitwiseOr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) | *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateStrStrI
//--------------------------------------------------------------------------
DWORD EvaluateStrStrI(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (NULL == StrStrIA((LPCSTR)pDataLeft, (LPCSTR)pDataRight) ? FALSE : TRUE);
}

//--------------------------------------------------------------------------
// EvaluateStrStr
//--------------------------------------------------------------------------
DWORD EvaluateStrStr(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (NULL == StrStrA((LPCSTR)pDataLeft, (LPCSTR)pDataRight) ? FALSE : TRUE);
}

//--------------------------------------------------------------------------
// EvaluateStrcmpi
//--------------------------------------------------------------------------
DWORD EvaluateStrcmpi(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (lstrcmpi((LPCSTR)pDataLeft, (LPCSTR)pDataRight) == 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateStrcmp
//--------------------------------------------------------------------------
DWORD EvaluateStrcmp(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (lstrcmp((LPCSTR)pDataLeft, (LPCSTR)pDataRight) == 0 ? TRUE : FALSE);
}

//--------------------------------------------------------------------------
// EvaluateAdd
//--------------------------------------------------------------------------
DWORD EvaluateAdd(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) + *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateSubtract
//--------------------------------------------------------------------------
DWORD EvaluateSubtract(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) - *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateMultiply
//--------------------------------------------------------------------------
DWORD EvaluateMultiply(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) * *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateDivide
//--------------------------------------------------------------------------
DWORD EvaluateDivide(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) / *((DWORD *)pDataRight));
}

//--------------------------------------------------------------------------
// EvaluateModula
//--------------------------------------------------------------------------
DWORD EvaluateModula(OPERANDTYPE tyOperand, LPVOID pDataLeft, LPVOID pDataRight) {
    return (INT)(*((DWORD *)pDataLeft) % *((DWORD *)pDataRight));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\database.h ===
//--------------------------------------------------------------------------
// Database.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include "utility.h"
#include "query.h"
#include "listen.h"

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CDatabaseQuery;

//--------------------------------------------------------------------------
// DwordAlign
//--------------------------------------------------------------------------
inline DWORD DwordAlign(DWORD cb) { 
    DWORD dw = (cb % 4); return(0 == dw ? 0 : (4 - dw));
}

//--------------------------------------------------------------------------
// String Constants
//--------------------------------------------------------------------------
#define CCHMAX_DB_FILEPATH      (MAX_PATH + MAX_PATH)

//--------------------------------------------------------------------------
// DESCENDING
//--------------------------------------------------------------------------
#define DESCENDING(_nCompare)   ((_nCompare < 0) ? 1 : -1)
typedef DWORD TICKCOUNT;

//--------------------------------------------------------------------------
// Version and Signatures
//--------------------------------------------------------------------------
#define BTREE_SIGNATURE         0xfe12adcf
#define BTREE_VERSION           5

//--------------------------------------------------------------------------
// B-Tree Chain Sizes
//--------------------------------------------------------------------------
#define BTREE_ORDER             50
#define BTREE_MIN_CAP           25

//--------------------------------------------------------------------------
// Upper Limit on Various Resources
//--------------------------------------------------------------------------
#define CMAX_OPEN_STREAMS       512
#define CMAX_OPEN_ROWSETS       32
#define CMAX_RECIPIENTS         15
#define CMAX_CLIENTS            32

//--------------------------------------------------------------------------
// Block Allocate Page Sizes
//--------------------------------------------------------------------------
#define CB_CHAIN_PAGE           15900
#define CB_STREAM_PAGE          63360
#define CB_VARIABLE_PAGE        49152
#define CB_STREAM_BLOCK         512
#define CC_MAX_BLOCK_TYPES      16

//--------------------------------------------------------------------------
// Variable Length Block Allocation Sizes
//--------------------------------------------------------------------------
#define CB_ALIGN_LARGE          1024
#define CB_FREE_BUCKET          4
#define CC_FREE_BUCKETS         2048
#define CB_MIN_FREE_BUCKET      32
#define CB_MAX_FREE_BUCKET      (CB_MIN_FREE_BUCKET + (CB_FREE_BUCKET * CC_FREE_BUCKETS))

//--------------------------------------------------------------------------
// Heap Block Cache
//--------------------------------------------------------------------------
#define CB_HEAP_BUCKET          8
#define CC_HEAP_BUCKETS         1024
#define CB_MAX_HEAP_BUCKET      (CB_HEAP_BUCKET * CC_HEAP_BUCKETS)

//--------------------------------------------------------------------------
// Other Constants
//--------------------------------------------------------------------------
#define MEMORY_GUARD_SIGNATURE  0xdeadbeef
#define DELETE_ON_CLOSE         TRUE

//--------------------------------------------------------------------------
// File Mapping Constants
//--------------------------------------------------------------------------
#define CB_MAPPED_VIEW          10485760

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CProgress;
class CDatabase;
class CDatabaseStream;

//--------------------------------------------------------------------------
// Locking Values
//--------------------------------------------------------------------------
#define LOCK_VALUE_NONE     0
#define LOCK_VALUE_WRITER   -1

//--------------------------------------------------------------------------
// STREAMINDEX
//--------------------------------------------------------------------------
typedef WORD STREAMINDEX;
typedef LPWORD LPSTREAMINDEX;
#define INVALID_STREAMINDEX 0xffff

//--------------------------------------------------------------------------
// ROWSETORDINAL
//--------------------------------------------------------------------------
typedef BYTE ROWSETORDINAL;

//--------------------------------------------------------------------------
// FILEADDRESS
//--------------------------------------------------------------------------
typedef DWORD FILEADDRESS;
typedef LPDWORD LPFILEADDRESS;

//--------------------------------------------------------------------------
// NODEINDEX
//--------------------------------------------------------------------------
typedef BYTE NODEINDEX;
typedef BYTE *LPNODEINDEX;
#define INVALID_NODEINDEX 0xff

//--------------------------------------------------------------------------
// BLOCKTYPE
//--------------------------------------------------------------------------
typedef enum tagBLOCKTYPE {
    BLOCK_RECORD,
    BLOCK_STRING,
    BLOCK_RESERVED1,
    BLOCK_TRANSACTION,
    BLOCK_CHAIN,
    BLOCK_STREAM,
    BLOCK_FREE,
    BLOCK_ENDOFPAGE,
    BLOCK_RESERVED2,
    BLOCK_RESERVED3,
    BLOCK_LAST
} BLOCKTYPE;

//--------------------------------------------------------------------------
// CHAINDELETETYPE
//--------------------------------------------------------------------------
typedef enum tagCHAINDELETETYPE {
    CHAIN_DELETE_SHARE,
    CHAIN_DELETE_COALESCE
} CHAINDELETETYPE;

//--------------------------------------------------------------------------
// CHAINSHARETYPE
//--------------------------------------------------------------------------
typedef enum tagCHAINSHARETYPE {
    CHAIN_SHARE_LEFT,
    CHAIN_SHARE_RIGHT
} CHAINSHARETYPE;

//--------------------------------------------------------------------------
// OPERATIONTYPE - Specifies how _UnlinkRecordFromTable from table works
//--------------------------------------------------------------------------
typedef enum tagOPERATIONTYPE {
	OPERATION_DELETE,
	OPERATION_UPDATE,
    OPERATION_INSERT
} OPERATIONTYPE;

//--------------------------------------------------------------------------
// INVOKETYPE
//--------------------------------------------------------------------------
typedef enum tagINVOKETYPE {
    INVOKE_RELEASEMAP       = 100,
    INVOKE_CREATEMAP        = 101,
    INVOKE_CLOSEFILE        = 102,
    INVOKE_OPENFILE         = 103,
    INVOKE_OPENMOVEDFILE    = 104
} INVOKETYPE;

//--------------------------------------------------------------------------
// FINDRESULT
//--------------------------------------------------------------------------
typedef struct tagFINDRESULT {
    FILEADDRESS         faChain;
    NODEINDEX           iNode;
    BYTE                fChanged;
    BYTE                fFound;
    INT                 nCompare;
} FINDRESULT, *LPFINDRESULT;

//--------------------------------------------------------------------------
// ALLOCATEPAGE
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagALLOCATEPAGE {
	FILEADDRESS			faPage;
	DWORD				cbPage;
	DWORD				cbUsed;
} ALLOCATEPAGE, *LPALLOCATEPAGE;
#pragma pack()

//--------------------------------------------------------------------------
// TABLEHEADER
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagTABLEHEADER {
    DWORD               dwSignature;                        // 4
    CLSID               clsidExtension;                     // 20
    DWORD               dwMinorVersion;                     // 24
    DWORD               dwMajorVersion;                     // 28
    DWORD               cbUserData;                         // 32
    FILEADDRESS         faCatalogOld;                       // 36
    ALLOCATEPAGE        AllocateRecord;                     // 48
    ALLOCATEPAGE		AllocateChain;                      // 60
    ALLOCATEPAGE		AllocateStream;                     // 72
    FILEADDRESS         faFreeStreamBlock;                  // 76
    FILEADDRESS         faFreeChainBlock;                   // 80
    FILEADDRESS         faFreeLargeBlock;                   // 84
    DWORD               cbAllocated;                        // 88
    DWORD               cbFreed;                            // 92
    DWORD               dwNextId;                           // 96
    DWORD               fCorrupt;                           // 100
    DWORD               fCorruptCheck;                      // 104
    DWORD               cActiveThreads;                     // 108
    FILEADDRESS         faTransactHead;                     // 112
    FILEADDRESS         faTransactTail;                     // 116
    DWORD               cTransacts;                         // 120
    DWORD               cBadCloses;                         // 124
    FILEADDRESS         faNextAllocate;                     // 128
    DWORD               cIndexes;                           // 132
    FILEADDRESS         rgfaFilter[CMAX_INDEXES];           // 164
    DWORD               rgbReserved5[8];                    // 196
    DWORD               rgcRecords[CMAX_INDEXES];           // 228
    FILEADDRESS         rgfaIndex[CMAX_INDEXES];            // 260
    INDEXORDINAL        rgiIndex[CMAX_INDEXES];             // 292
    BYTE                rgbReserved4[116];                  // 408
    BYTE                fReserved;                          // 409
    DWORD               rgbReserved6[8];                    // 196
    BYTE                rgdwReserved2[192];                 // 637
    DWORD               rgcbAllocated[CC_MAX_BLOCK_TYPES];  // 701
    FILEADDRESS         rgfaFreeBlock[CC_FREE_BUCKETS];     // 8893
    TABLEINDEX          rgIndexInfo[CMAX_INDEXES];          // 9293
    WORD                wTransactSize;                      // 9405
    BYTE                rgdwReserved3[110];
} TABLEHEADER, *LPTABLEHEADER;
#pragma pack()

//--------------------------------------------------------------------------
// BLOCKHEADER
//-------------------------------------------------------------------------- 
#pragma pack(4)
typedef struct tagBLOCKHEADER {
    FILEADDRESS         faBlock;
    DWORD               cbSize;
} BLOCKHEADER, *LPBLOCKHEADER;
#pragma pack()

//--------------------------------------------------------------------------
// FREEBLOCK
//-------------------------------------------------------------------------- 
#pragma pack(4)
typedef struct tagFREEBLOCK : public BLOCKHEADER {
    DWORD               cbBlock;
    DWORD               dwReserved;
    FILEADDRESS         faNext;
} FREEBLOCK, *LPFREEBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// CHAINNODE
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagCHAINNODE {
    FILEADDRESS         faRecord;
    FILEADDRESS         faRightChain;
    DWORD               cRightNodes;
} CHAINNODE, *LPCHAINNODE;
#pragma pack()

//--------------------------------------------------------------------------
// CHAINBLOCK - 636
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagCHAINBLOCK : public BLOCKHEADER {
    FILEADDRESS         faLeftChain;
    FILEADDRESS         faParent;
    BYTE                iParent;
    BYTE                cNodes;
    WORD                wReserved;
    DWORD               cLeftNodes;
    CHAINNODE           rgNode[BTREE_ORDER + 1];
} CHAINBLOCK, *LPCHAINBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// STREAMBLOCK
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagSTREAMBLOCK : public BLOCKHEADER {
    DWORD               cbData;
    FILEADDRESS         faNext;
} STREAMBLOCK, *LPSTREAMBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// RECORDBLOCK
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagRECORDBLOCK : public BLOCKHEADER {
    WORD                wReserved;
    BYTE                cTags;
    BYTE                bVersion;
} RECORDBLOCK, *LPRECORDBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// COLUMNTAG
//--------------------------------------------------------------------------
#define TAG_DATA_MASK 0xFF800000
#pragma pack(4)
typedef struct tagCOLUMNTAG {
    unsigned            iColumn  : 7;
    unsigned            fData    : 1;
    unsigned            Offset   : 24;
} COLUMNTAG, *LPCOLUMNTAG;
#pragma pack()

//--------------------------------------------------------------------------
// RECORDMAP
//--------------------------------------------------------------------------
typedef struct tagRECORDMAP {
    LPCTABLESCHEMA      pSchema;
    BYTE                cTags;
    LPCOLUMNTAG         prgTag;
    DWORD               cbTags;
    DWORD               cbData;
    LPBYTE              pbData;
} RECORDMAP, *LPRECORDMAP;

//--------------------------------------------------------------------------
// OPENSTREAM
//--------------------------------------------------------------------------
typedef struct tagOPENSTREAM {
    BYTE                fInUse;
    FILEADDRESS         faStart;
    FILEADDRESS         faMoved;
    DWORD               cOpenCount;
    LONG                lLock;
    BYTE                fDeleteOnClose;
} OPENSTREAM, *LPOPENSTREAM;

//--------------------------------------------------------------------------
// NOTIFYRECIPIENT
//--------------------------------------------------------------------------
typedef struct tagNOTIFYRECIPIENT {
    HWND                hwndNotify;
    DWORD               dwThreadId;
    DWORD_PTR           dwCookie;
    BYTE                fSuspended;
    BYTE                fRelease;
    BYTE                fOrdinalsOnly;
    DWORD_PTR           pNotify;
    INDEXORDINAL        iIndex;
} NOTIFYRECIPIENT, *LPNOTIFYRECIPIENT;

//--------------------------------------------------------------------------
// CLIENTENTRY
//--------------------------------------------------------------------------
typedef struct tagCLIENTENTRY {
    HWND                hwndListen;
    DWORD               dwProcessId;
    DWORD               dwThreadId;
    DWORD_PTR           pDB;
    DWORD               cRecipients;
    NOTIFYRECIPIENT     rgRecipient[CMAX_RECIPIENTS];
} CLIENTENTRY, *LPCLIENTENTRY;

//--------------------------------------------------------------------------
// TRANSACTIONBLOCK
//--------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagTRANSACTIONBLOCK : public BLOCKHEADER {
    TRANSACTIONTYPE     tyTransaction;
    WORD                cRefs;
    INDEXORDINAL        iIndex;
    ORDINALLIST         Ordinals;
    FILEADDRESS         faRecord1;
    FILEADDRESS         faRecord2;
    FILEADDRESS         faNext;
    FILEADDRESS         faPrevious;
    FILEADDRESS         faNextInBatch;
} TRANSACTIONBLOCK, *LPTRANSACTIONBLOCK;
#pragma pack()

//--------------------------------------------------------------------------
// ROWSETINFO
//--------------------------------------------------------------------------
typedef struct tagROWSETINFO {
    ROWSETORDINAL       iRowset;
    INDEXORDINAL        iIndex;
    ROWORDINAL          iRow;
} ROWSETINFO, *LPROWSETINFO;

//--------------------------------------------------------------------------
// ROWSETTABLE
//--------------------------------------------------------------------------
typedef struct tagROWSETTABLE {
    BYTE                fInitialized;
    BYTE                cFree;
    BYTE                cUsed;
    ROWSETORDINAL       rgiFree[CMAX_OPEN_ROWSETS];
    ROWSETORDINAL       rgiUsed[CMAX_OPEN_ROWSETS];
    ROWSETINFO          rgRowset[CMAX_OPEN_ROWSETS];
} ROWSETTABLE, *LPROWSETTABLE;

//--------------------------------------------------------------------------
// SHAREDDATABASE
//--------------------------------------------------------------------------
typedef struct tagSHAREDDATABASE {
    WCHAR               szFile[CCHMAX_DB_FILEPATH];
    LONG                cWaitingForLock;
    BYTE                fCompacting;
    DWORD               dwVersion;
    DWORD               dwQueryVersion;
    DWORD               cNotifyLock;
    FILEADDRESS         faTransactLockHead;
    FILEADDRESS         faTransactLockTail;
    OPENSTREAM          rgStream[CMAX_OPEN_STREAMS];
    DWORD               cClients;
    DWORD               cNotifyOrdinalsOnly;
    DWORD               cNotifyWithData;
    DWORD               cNotify;
    DWORD               rgcIndexNotify[CMAX_INDEXES];
    CLIENTENTRY         rgClient[CMAX_CLIENTS];
    ROWSETTABLE         Rowsets;
    IF_DEBUG(BYTE       fRepairing;)
} SHAREDDATABASE, *LPSHAREDDATABASE;

//--------------------------------------------------------------------------
// INVOKEPACKAGE
//--------------------------------------------------------------------------
typedef struct tagINVOKEPACKAGE {
    INVOKETYPE          tyInvoke;
    DWORD_PTR           pDB;
} INVOKEPACKAGE, *LPINVOKEPACKAGE;

//--------------------------------------------------------------------------
// MARKBLOCK
//--------------------------------------------------------------------------
typedef struct tagMARKBLOCK {
    DWORD               cbBlock;
} MARKBLOCK, *LPMARKBLOCK;

//--------------------------------------------------------------------------
// FILEVIEW
//--------------------------------------------------------------------------
typedef struct tagFILEVIEW *LPFILEVIEW;
typedef struct tagFILEVIEW {
    FILEADDRESS         faView;
    LPBYTE              pbView;
    DWORD               cbView;
    LPFILEVIEW          pNext;
} FILEVIEW, *LPFILEVIEW;

//--------------------------------------------------------------------------
// STORAGEINFO
//--------------------------------------------------------------------------
typedef struct tagSTORAGEINFO {
    LPWSTR              pszMap;
    HANDLE              hFile;
    HANDLE              hMap;
    HANDLE              hShare;
    DWORD               cbFile;
#ifdef BACKGROUND_MONITOR
    TICKCOUNT           tcMonitor;
#endif
    DWORD               cbMappedViews;
    DWORD               cbMappedSpecial;
    DWORD               cAllocated;
    DWORD               cSpecial;
    LPFILEVIEW          prgView;
    LPFILEVIEW          pSpecial;
} STORAGEINFO, *LPSTORAGEINFO;

//--------------------------------------------------------------------------
// MEMORYTAG
//--------------------------------------------------------------------------
typedef struct tagMEMORYTAG {
    DWORD               dwSignature;
    DWORD               cbSize;
    LPVOID              pNext;
} MEMORYTAG, *LPMEMORYTAG;

//--------------------------------------------------------------------------
// CORRUPTREASON
//--------------------------------------------------------------------------
typedef enum tagCORRUPTREASON {
    REASON_BLOCKSTARTOUTOFRANGE             = 10000,
    REASON_UMATCHINGBLOCKADDRESS            = 10002,
    REASON_BLOCKSIZEOUTOFRANGE              = 10003,
    REASON_INVALIDFIRSTRECORD               = 10035,
    REASON_INVALIDLASTRECORD                = 10036,
    REASON_INVALIDRECORDMAP                 = 10037
} CORRUPTREASON;

//--------------------------------------------------------------------------
// CDatabase
//--------------------------------------------------------------------------
class CDatabase : public IDatabase
{
public:
    //----------------------------------------------------------------------
    // Construction - Destruction
    //----------------------------------------------------------------------
    CDatabase(void);
    ~CDatabase(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IDatabase Members
    //----------------------------------------------------------------------
    HRESULT Open(LPCWSTR pszFile, OPENDATABASEFLAGS dwFlags, LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension);

    //----------------------------------------------------------------------
    // Locking Methods
    //----------------------------------------------------------------------
    STDMETHODIMP Lock(LPHLOCK phLock);
    STDMETHODIMP Unlock(LPHLOCK phLock);

    //----------------------------------------------------------------------
    // Data Manipulation Methods
    //----------------------------------------------------------------------
    STDMETHODIMP InsertRecord(LPVOID pBinding);
    STDMETHODIMP UpdateRecord(LPVOID pBinding);
    STDMETHODIMP DeleteRecord(LPVOID pBinding);
    STDMETHODIMP FindRecord(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pBinding, LPROWORDINAL piRow);
    STDMETHODIMP GetRowOrdinal(INDEXORDINAL iIndex, LPVOID pBinding, LPROWORDINAL piRow);
    STDMETHODIMP FreeRecord(LPVOID pBinding);
    STDMETHODIMP GetUserData(LPVOID pvUserData, ULONG cbUserData);
    STDMETHODIMP SetUserData(LPVOID pvUserData, ULONG cbUserData);
    STDMETHODIMP GetRecordCount(INDEXORDINAL iIndex, LPDWORD pcRecords);

    //----------------------------------------------------------------------
    // Indexing Methods
    //----------------------------------------------------------------------
    STDMETHODIMP GetIndexInfo(INDEXORDINAL iIndex, LPSTR *ppszFilter, LPTABLEINDEX pIndex);
    STDMETHODIMP ModifyIndex(INDEXORDINAL iIndex, LPCSTR pszFilter, LPCTABLEINDEX pIndex);
    STDMETHODIMP DeleteIndex(INDEXORDINAL iIndex);

    //----------------------------------------------------------------------
    // Rowset Methods
    //----------------------------------------------------------------------
    STDMETHODIMP CreateRowset(INDEXORDINAL iIndex, CREATEROWSETFLAGS dwFlags, LPHROWSET phRowset);
    STDMETHODIMP SeekRowset(HROWSET hRowset, SEEKROWSETTYPE tySeek, LONG cRows, LPROWORDINAL piRowNew);
    STDMETHODIMP QueryRowset(HROWSET hRowset, LONG cWanted, LPVOID *prgpBinding, LPDWORD pcObtained);
    STDMETHODIMP CloseRowset(LPHROWSET phRowset);

    //----------------------------------------------------------------------
    // Streaming Methods
    //----------------------------------------------------------------------
    STDMETHODIMP CreateStream(LPFILEADDRESS pfaStart);
    STDMETHODIMP DeleteStream(FILEADDRESS faStart);
    STDMETHODIMP CopyStream(IDatabase *pDst, FILEADDRESS faStream, LPFILEADDRESS pfaNew);
    STDMETHODIMP OpenStream(ACCESSTYPE tyAccess, FILEADDRESS faStart, IStream **ppStream);
    STDMETHODIMP ChangeStreamLock(IStream *pStream, ACCESSTYPE tyAccessNew);

    //----------------------------------------------------------------------
    // Notification Methods
    //----------------------------------------------------------------------
    STDMETHODIMP RegisterNotify(INDEXORDINAL iIndex, REGISTERNOTIFYFLAGS dwFlags, DWORD_PTR dwCookie, IDatabaseNotify *pNotify);
    STDMETHODIMP DispatchNotify(IDatabaseNotify *pNotify);
    STDMETHODIMP SuspendNotify(IDatabaseNotify *pNotify);
    STDMETHODIMP ResumeNotify(IDatabaseNotify *pNotify);
    STDMETHODIMP UnregisterNotify(IDatabaseNotify *pNotify);
    STDMETHODIMP LockNotify(LOCKNOTIFYFLAGS dwFlags, LPHLOCK phLock);
    STDMETHODIMP UnlockNotify(LPHLOCK phLock);
    STDMETHODIMP GetTransaction(LPHTRANSACTION phTransaction, LPTRANSACTIONTYPE ptyTransaction, LPVOID pRecord1, LPVOID pRecord2, LPINDEXORDINAL piIndex, LPORDINALLIST pOrdinals);

    //----------------------------------------------------------------------
    // Maintenence Methods
    //----------------------------------------------------------------------
    STDMETHODIMP MoveFile(LPCWSTR pszFilePath);
    STDMETHODIMP SetSize(DWORD cbSize);
    STDMETHODIMP GetFile(LPWSTR *ppszFile);
    STDMETHODIMP GetSize(LPDWORD pcbFile, LPDWORD pcbAllocated, LPDWORD pcbFreed, LPDWORD pcbStreams);
    STDMETHODIMP Repair(void) { return _CheckForCorruption(); }

    //----------------------------------------------------------------------
    // Fast-Heap Methods
    //----------------------------------------------------------------------
    STDMETHODIMP HeapFree(LPVOID pvBuffer);
    STDMETHODIMP HeapAllocate(DWORD dwFlags, DWORD cbSize, LPVOID *ppBuffer) {
        *ppBuffer = PHeapAllocate(dwFlags, cbSize);
        return(*ppBuffer ? S_OK : E_OUTOFMEMORY);
    }

    //----------------------------------------------------------------------
    // General Utility Methods
    //----------------------------------------------------------------------
    STDMETHODIMP Compact(IDatabaseProgress *pProgress, COMPACTFLAGS dwFlags);
    STDMETHODIMP GenerateId(LPDWORD pdwId);
    STDMETHODIMP GetClientCount(LPDWORD pcClients);

    //----------------------------------------------------------------------
    // CDatabase Members
    //----------------------------------------------------------------------
    HRESULT StreamCompareDatabase(CDatabaseStream *pStream, IDatabase *pDatabase);
    HRESULT GetStreamAddress(CDatabaseStream *pStream, LPFILEADDRESS pfaStream);
    HRESULT StreamRead(CDatabaseStream *pStream, LPVOID pvData, ULONG cbWanted, ULONG *pcbRead);
    HRESULT StreamWrite(CDatabaseStream *pStream, const void *pvData, ULONG cb, ULONG *pcbWrote);
    HRESULT StreamSeek(CDatabaseStream *pStream, LARGE_INTEGER liMove, DWORD dwOrigin, ULARGE_INTEGER *pulNew);
    HRESULT StreamRelease(CDatabaseStream *pStream);
    HRESULT StreamGetAddress(CDatabaseStream *pStream, LPFILEADDRESS pfaStart);
    HRESULT DoInProcessInvoke(INVOKETYPE tyInvoke);
#ifdef BACKGROUND_MONITOR
    HRESULT DoBackgroundMonitor(void);
#endif
    HRESULT BindRecord(LPRECORDMAP pMap, LPVOID pBinding);
    LPVOID  PHeapAllocate(DWORD dwFlags, DWORD cbSize);

    //----------------------------------------------------------------------
    // AllocateBinding
    //----------------------------------------------------------------------
    HRESULT AllocateBinding(LPVOID *ppBinding) {
        *ppBinding = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding);
        return(*ppBinding ? S_OK : E_OUTOFMEMORY);
    }

private:
    //----------------------------------------------------------------------
    // General Btree Methods
    //----------------------------------------------------------------------
    HRESULT _IsLeafChain(LPCHAINBLOCK pChain);
    HRESULT _AdjustParentNodeCount(INDEXORDINAL iIndex, FILEADDRESS faChain, LONG lCount);
    HRESULT _ValidateFileVersions(OPENDATABASEFLAGS dwFlags);
    HRESULT _ResetTableHeader(void);
    HRESULT _RemoveClientFromArray(DWORD dwProcessId, DWORD_PTR pDB);
    HRESULT _BuildQueryTable(void);
    HRESULT _StreamSychronize(CDatabaseStream *pStream);
    HRESULT _InitializeExtension(OPENDATABASEFLAGS dwFlags, IDatabaseExtension *pExtension);
    HRESULT _GetRecordMap(BOOL fGoCorrupt, LPRECORDBLOCK pBlock, LPRECORDMAP pMap);

    //----------------------------------------------------------------------
    // File Mapping / View Utilities
    //----------------------------------------------------------------------
    HRESULT _InitializeFileViews(void);
    HRESULT _CloseFileViews(BOOL fFlush);
    HRESULT _AllocateSpecialView(FILEADDRESS faView, DWORD cbView, LPFILEVIEW *ppSpecial);

    //----------------------------------------------------------------------
    // Btree Search / Virtual Scrolling
    //----------------------------------------------------------------------
    HRESULT _GetChainByIndex(INDEXORDINAL iIndex, ROWORDINAL iRow, LPFILEADDRESS pfaChain, LPNODEINDEX piNode);
    HRESULT _CompareBinding(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pBinding, FILEADDRESS faRecord, INT *pnCompare);
    HRESULT _IsVisible(HQUERY hQuery, LPVOID pBinding);
    HRESULT _PartialIndexCompare(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pBinding, LPCHAINBLOCK *ppChain, LPNODEINDEX piNode, LPROWORDINAL piRow);
    HRESULT _FindRecord(INDEXORDINAL iIndex, DWORD cColumns, LPVOID pBinding, LPFILEADDRESS pfaChain, LPNODEINDEX piNode, LPROWORDINAL piRow=NULL, INT *pnCompare=NULL);

    //----------------------------------------------------------------------
    // Btree Deletion Methods
    //----------------------------------------------------------------------
    HRESULT _CollapseChain(LPCHAINBLOCK pChain, NODEINDEX iDelete);
    HRESULT _ExpandChain(LPCHAINBLOCK pChain, NODEINDEX iNode);
    HRESULT _IndexDeleteRecord(INDEXORDINAL iIndex, FILEADDRESS faDelete, NODEINDEX iDelete);
    HRESULT _GetRightSibling(FILEADDRESS faCurrent, LPCHAINBLOCK *ppSibling);
    HRESULT _GetLeftSibling(FILEADDRESS faCurrent, LPCHAINBLOCK *ppSibling);
    HRESULT _GetInOrderSuccessor(FILEADDRESS faStart, NODEINDEX iDelete, LPCHAINBLOCK *ppSuccessor);
    HRESULT _DecideHowToDelete(LPFILEADDRESS pfaShare, FILEADDRESS faDelete, CHAINDELETETYPE *ptyDelete, CHAINSHARETYPE *ptyShare);
    HRESULT _ChainDeleteShare(INDEXORDINAL iIndex, FILEADDRESS faDelete, FILEADDRESS faShare, CHAINSHARETYPE tyShare);
    HRESULT _ChainDeleteCoalesce(INDEXORDINAL iIndex, FILEADDRESS faDelete, FILEADDRESS faShare, CHAINSHARETYPE tyShare);

    //----------------------------------------------------------------------
    // Btree Insertion Methods
    //----------------------------------------------------------------------
    HRESULT _IndexInsertRecord(INDEXORDINAL iIndex, FILEADDRESS faChain, FILEADDRESS faRecord, LPNODEINDEX piNode, INT nCompare);
    HRESULT _ChainInsert(INDEXORDINAL iIndex, LPCHAINBLOCK pChain, LPCHAINNODE pNode, LPNODEINDEX piNodeIndex);
    HRESULT _SplitChainInsert(INDEXORDINAL iIndex, FILEADDRESS faLeaf);

    //----------------------------------------------------------------------
    // Record Persistence Methods
    //----------------------------------------------------------------------
    HRESULT _GetRecordSize(LPVOID pBinding, LPRECORDMAP pMap);
    HRESULT _SaveRecord(LPRECORDBLOCK pBlock, LPRECORDMAP pMap, LPVOID pBinding);
    HRESULT _ReadRecord(FILEADDRESS faRecord, LPVOID pBinding, BOOL fInternal=FALSE);
    HRESULT _LinkRecordIntoTable(LPRECORDMAP pMap, LPVOID pBinding, BYTE bVersion, LPFILEADDRESS pfaRecord);

    //----------------------------------------------------------------------
    // Notification / Invoke Methods
    //----------------------------------------------------------------------
    HRESULT _DispatchInvoke(INVOKETYPE tyInvoke);
    HRESULT _DispatchNotification(HTRANSACTION hTransaction);
    HRESULT _LogTransaction(TRANSACTIONTYPE tyTransaction, INDEXORDINAL iIndex, LPORDINALLIST pOrdinals, FILEADDRESS faRecord1, FILEADDRESS faRecord2);
    HRESULT _CloseNotificationWindow(LPNOTIFYRECIPIENT pRecipient);
    HRESULT _FindClient(DWORD dwProcessId, DWORD_PTR dwDB, LPDWORD piClient, LPCLIENTENTRY *ppClient);
    HRESULT _FindNotifyRecipient(DWORD iClient, IDatabaseNotify *pNotify, LPDWORD piRecipient,  LPNOTIFYRECIPIENT *ppRecipient);
    HRESULT _DispatchPendingNotifications(void);
    HRESULT _AdjustNotifyCounts(LPNOTIFYRECIPIENT pRecipient, LONG lChange);

    //----------------------------------------------------------------------
    // Rowset Support Methods
    //----------------------------------------------------------------------
    HRESULT _AdjustOpenRowsets(INDEXORDINAL iIndex, ROWORDINAL iRow, OPERATIONTYPE tyOperation);

    //----------------------------------------------------------------------
    // Alloctation Methods
    //----------------------------------------------------------------------
    HRESULT _MarkBlock(BLOCKTYPE tyBlock, FILEADDRESS faBlock, DWORD cbBlock, LPVOID *ppvBlock);
    HRESULT _ReuseFixedFreeBlock(LPFILEADDRESS pfaFreeHead, BLOCKTYPE tyBlock, DWORD cbBlock, LPVOID *ppvBlock);
    HRESULT _FreeRecordStorage(OPERATIONTYPE tyOperation, FILEADDRESS faRecord);
    HRESULT _FreeStreamStorage(FILEADDRESS faStart);
    HRESULT _SetStorageSize(DWORD cbSize);
    HRESULT _AllocateBlock(BLOCKTYPE tyBlock, DWORD cbExtra, LPVOID *ppBlock);
    HRESULT _AllocateFromPage(BLOCKTYPE tyBlock, LPALLOCATEPAGE pPage, DWORD cbPage, DWORD cbBlock, LPVOID *ppvBlock);
    HRESULT _FreeBlock(BLOCKTYPE tyBlock, FILEADDRESS faBlock);
    HRESULT _AllocatePage(DWORD cbPage, LPFILEADDRESS pfaAddress);
    HRESULT _FreeIndex(FILEADDRESS faChain);
    HRESULT _CopyRecord(FILEADDRESS faRecord, LPFILEADDRESS pfaCopy);
    HRESULT _FreeTransactBlock(LPTRANSACTIONBLOCK pTransact);
    HRESULT _CleanupTransactList(void);

    //----------------------------------------------------------------------
    // Compaction Helpers
    //----------------------------------------------------------------------
    HRESULT _CompactMoveRecordStreams(CDatabase *pDstDB, LPVOID pBinding);
    HRESULT _CompactMoveOpenDeletedStreams(CDatabase *pDstDB);
    HRESULT _CompactTransferFilters(CDatabase *pDstDB);
    HRESULT _CompactInsertRecord(LPVOID pBinding);

    //----------------------------------------------------------------------
    // Index Management
    //----------------------------------------------------------------------
    HRESULT _ValidateIndex(INDEXORDINAL iIndex, FILEADDRESS faChain, ULONG cLeftNodes, ULONG *pcRecords);
    HRESULT _RebuildIndex(INDEXORDINAL iIndex);
    HRESULT _RecursiveRebuildIndex(INDEXORDINAL iIndex, FILEADDRESS faCurrent, LPVOID pBinding, LPDWORD pcRecords);

    //----------------------------------------------------------------------
    // Corruption Validation and Repair Methods
    //----------------------------------------------------------------------
    HRESULT _HandleOpenMovedFile(void);
    HRESULT _SetCorrupt(BOOL fGoCorrupt, INT nLine, CORRUPTREASON tyReason, BLOCKTYPE tyBlock, FILEADDRESS faExpected, FILEADDRESS faActual, DWORD cbBlock);
    HRESULT _CheckForCorruption(void);
    HRESULT _GetBlock(BLOCKTYPE tyExpected, FILEADDRESS faBlock, LPVOID *ppvBlock, LPMARKBLOCK pMark=NULL, BOOL fGoCorrupt=TRUE);
    HRESULT _ValidateAndRepairRecord(LPRECORDMAP pMap);
    HRESULT _ValidateStream(FILEADDRESS faStart);

    //----------------------------------------------------------------------
    // Private Debug Methods
    //----------------------------------------------------------------------
    IF_DEBUG(HRESULT _DebugValidateRecordFormat(void));
    IF_DEBUG(HRESULT _DebugValidateUnrefedRecord(FILEADDRESS farecord));
    IF_DEBUG(HRESULT _DebugValidateIndexUnrefedRecord(FILEADDRESS faChain, FILEADDRESS faRecord));

private:
    //----------------------------------------------------------------------
    // Prototypes
    //----------------------------------------------------------------------
    LONG                    m_cRef;
    LONG                    m_cExtRefs;
    HANDLE                  m_hMutex;
#ifdef BACKGROUND_MONITOR
    HMONITORDB              m_hMonitor;
#endif
    DWORD                   m_dwProcessId;
    BOOL                    m_fDirty;
    LPCTABLESCHEMA          m_pSchema;
    LPSTORAGEINFO           m_pStorage;
    LPTABLEHEADER           m_pHeader;
    LPSHAREDDATABASE        m_pShare;
    HANDLE                  m_hHeap;
    BYTE                    m_fDeconstruct;
    BYTE                    m_fInMoveFile;
    BYTE                    m_fExclusive;
    BYTE                    m_fCompactYield;
    DWORD                   m_dwQueryVersion;
    HQUERY                  m_rghFilter[CMAX_INDEXES];
    IDatabaseExtension     *m_pExtension;
    IUnknown               *m_pUnkRelease;
    LPBYTE                  m_rgpRecycle[CC_HEAP_BUCKETS];
    CRITICAL_SECTION        m_csHeap;
    IF_DEBUG(DWORD          m_cbHeapAlloc);
    IF_DEBUG(DWORD          m_cbHeapFree);

    //----------------------------------------------------------------------
    // Friend
    //----------------------------------------------------------------------
    friend CDatabaseQuery;
};

//--------------------------------------------------------------------------
// CDatabaseQuery
//--------------------------------------------------------------------------
class CDatabaseQuery : public IDatabaseQuery
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CDatabaseQuery(void) {
        TraceCall("CDatabaseQuery::CDatabaseQuery");
        m_cRef = 1;
        m_hQuery = NULL;
        m_pDatabase = NULL;
    }

    //----------------------------------------------------------------------
    // De-Construction
    //----------------------------------------------------------------------
    ~CDatabaseQuery(void) {
        TraceCall("CDatabaseQuery::~CDatabaseQuery");
        CloseQuery(&m_hQuery, m_pDatabase);
        SafeRelease(m_pDatabase);
    }

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) {
        TraceCall("CDatabaseQuery::QueryInterface");
        *ppv = NULL;
        if (IID_IUnknown == riid)
            *ppv = (IUnknown *)this;
        else if (IID_IDatabaseQuery == riid)
            *ppv  = (IDatabaseQuery *)this;
        else
            return TraceResult(E_NOINTERFACE);
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    //----------------------------------------------------------------------
    // IDatabaseQuery::AddRef
    //----------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(void) {
        TraceCall("CDatabaseQuery::AddRef");
        return InterlockedIncrement(&m_cRef);
    }

    //----------------------------------------------------------------------
    // IDatabaseQuery::Release
    //----------------------------------------------------------------------
    STDMETHODIMP_(ULONG) Release(void) {
        TraceCall("CDatabaseQuery::Release");
        LONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
            delete this;
        return (ULONG)cRef;
    }

    //----------------------------------------------------------------------
    // CDatabaseQuery::Initialize
    //----------------------------------------------------------------------
    HRESULT Initialize(IDatabase *pDatabase, LPCSTR pszQuery) {
        TraceCall("CDatabaseQuery::Initialize");
        pDatabase->QueryInterface(IID_CDatabase, (LPVOID *)&m_pDatabase);
        return(ParseQuery(pszQuery, m_pDatabase->m_pSchema, &m_hQuery, m_pDatabase));
    }

    //----------------------------------------------------------------------
    // CDatabaseQuery::Evaluate
    //----------------------------------------------------------------------
    STDMETHODIMP Evaluate(LPVOID pBinding) {
        TraceCall("CDatabaseQuery::Evaluate");
        return(EvaluateQuery(m_hQuery, pBinding, m_pDatabase->m_pSchema, m_pDatabase, m_pDatabase->m_pExtension));
    }

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG        m_cRef;
    HQUERY      m_hQuery;
    CDatabase  *m_pDatabase;
};

//--------------------------------------------------------------------------
// PTagFromOrdinal
//--------------------------------------------------------------------------
inline LPCOLUMNTAG PTagFromOrdinal(LPRECORDMAP pMap, COLUMNORDINAL iColumn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\listen.h ===
//--------------------------------------------------------------------------
// Listen.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CDatabase;

//--------------------------------------------------------------------------
// HMONITORDBDB
//--------------------------------------------------------------------------
#ifdef BACKGROUND_MONITOR
DECLARE_HANDLE(HMONITORDB);
typedef HMONITORDB *LPHMONITORDB;
#endif

//--------------------------------------------------------------------------
// Notification Window Messages
//--------------------------------------------------------------------------
#define WM_ONTRANSACTION (WM_USER + 100)

//--------------------------------------------------------------------------
// Window Class Names
//--------------------------------------------------------------------------
extern const LPSTR g_szDBListenWndProc;
extern const LPSTR g_szDBNotifyWndProc;

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
ULONG ListenThreadAddRef(void);
ULONG ListenThreadRelease(void);
HRESULT CreateListenThread(void);
HRESULT GetListenWindow(HWND *phwndListen);
HRESULT CreateNotifyWindow(CDatabase *pDB, IDatabaseNotify *pNotify, HWND *phwndThunk);
#ifdef BACKGROUND_MONITOR
HRESULT RegisterWithMonitor(CDatabase *pDB, LPHMONITORDB phMonitor);
HRESULT UnregisterFromMonitor(CDatabase *pDB, LPHMONITORDB phMonitor);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\database.cpp ===
//--------------------------------------------------------------------------
// Database.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "database.h"
#include "stream.h"
#include "types.h"
#include "listen.h"
#include "resource.h"
#include "shlwapi.h"
#include "strconst.h"
#include "query.h"
#include "wrapwide.h"

//--------------------------------------------------------------------------
// Use Heap and/or Cache
//--------------------------------------------------------------------------
//#ifndef DEBUG
#define USEHEAP                 1
#define HEAPCACHE               1
//#endif  // DEBUG

//--------------------------------------------------------------------------
// Storage Block Access Macros
//--------------------------------------------------------------------------
#define PSTRING(_pBlock)        ((LPSTR)((LPBYTE)_pBlock + sizeof(BLOCKHEADER)))
#define PUSERDATA(_pHeader)     (LPBYTE)((LPBYTE)_pHeader + sizeof(TABLEHEADER))

//--------------------------------------------------------------------------
// g_rgcbBlockSize - Block Sizes
//--------------------------------------------------------------------------
const static WORD g_rgcbBlockSize[BLOCK_LAST] = {
    sizeof(RECORDBLOCK),        // BLOCK_RECORD
    sizeof(BLOCKHEADER),        // BLOCK_FILTER
    0,                          // BLOCK_RESERVED1
    sizeof(TRANSACTIONBLOCK),   // BLOCK_TRANSACTION
    sizeof(CHAINBLOCK),         // BLOCK_CHAIN
    sizeof(STREAMBLOCK),        // BLOCK_STREAM
    sizeof(FREEBLOCK),          // BLOCK_FREE
    sizeof(BLOCKHEADER),        // BLOCK_ENDOFPAGE
    0,                          // BLOCK_RESERVED2
    0                           // BLOCK_RESERVED3
};

//--------------------------------------------------------------------------
// ZeroBlock
//--------------------------------------------------------------------------
inline void ZeroBlock(LPBLOCKHEADER pBlock, DWORD cbSize) {
    ZeroMemory((LPBYTE)pBlock + sizeof(BLOCKHEADER), cbSize - sizeof(BLOCKHEADER));
}

//--------------------------------------------------------------------------
// CopyBlock
//--------------------------------------------------------------------------
inline void CopyBlock(LPBLOCKHEADER pDest, LPBLOCKHEADER pSource, DWORD cbSize) {
    CopyMemory((LPBYTE)pDest + sizeof(BLOCKHEADER), (LPBYTE)pSource + sizeof(BLOCKHEADER), cbSize - sizeof(BLOCKHEADER));
}

//--------------------------------------------------------------------------
// SafeFreeBinding
//--------------------------------------------------------------------------
#define SafeFreeBinding(_pBinding) \
    if (_pBinding) { \
        FreeRecord(_pBinding); \
        HeapFree(_pBinding); \
        _pBinding = NULL; \
    } else

//--------------------------------------------------------------------------
// SafeHeapFree
//--------------------------------------------------------------------------
#define SafeHeapFree(_pvBuffer) \
    if (_pvBuffer) { \
        HeapFree(_pvBuffer); \
        _pvBuffer = NULL; \
    } else

//--------------------------------------------------------------------------
// UnmapViewOfFileWithFlush
//--------------------------------------------------------------------------
inline void UnmapViewOfFileWithFlush(BOOL fFlush, LPVOID pView, DWORD cbView) 
{
    // If we have a view
    if (pView) 
    {
        // Flush It ?
        if (fFlush)
        {
            // Flush
            SideAssert(0 != FlushViewOfFile(pView, cbView));
        }

        // UnMap It
        SideAssert(0 != UnmapViewOfFile(pView));
    }
}

//--------------------------------------------------------------------------
// PTagFromOrdinal
//--------------------------------------------------------------------------
inline LPCOLUMNTAG PTagFromOrdinal(LPRECORDMAP pMap, COLUMNORDINAL iColumn)
{
    // Locals
    LONG        lLower=0;
    LONG        lUpper=pMap->cTags-1;
    LONG        lCompare;
    WORD        wMiddle;
    LPCOLUMNTAG pTag;

    // Do binary search / insert
    while (lLower <= lUpper)
    {
        // Set lMiddle
        wMiddle = (WORD)((lLower + lUpper) / 2);

        // Compute middle record to compare against
        pTag = &pMap->prgTag[(WORD)wMiddle];

        // Get string to compare against
        lCompare = (iColumn - pTag->iColumn);

        // If Equal, then were done
        if (lCompare == 0)
            return(pTag);

        // Compute upper and lower 
        if (lCompare > 0)
            lLower = (LONG)(wMiddle + 1);
        else 
            lUpper = (LONG)(wMiddle - 1);
    }       

    // Not Found
    return(NULL);
}

//--------------------------------------------------------------------------
// CDatabase::CDatabase
//--------------------------------------------------------------------------
CDatabase::CDatabase(void)
{
    TraceCall("CDatabase::CDatabase");
    Assert(9404 == sizeof(TABLEHEADER));
    IF_DEBUG(DWORD dw);
    IF_DEBUG(dw = offsetof(TABLEHEADER, rgdwReserved2));
    IF_DEBUG(dw = offsetof(TABLEHEADER, rgIndexInfo));
    IF_DEBUG(dw = offsetof(TABLEHEADER, rgdwReserved3));
    Assert(offsetof(TABLEHEADER, rgdwReserved2) == 444);
    Assert(offsetof(TABLEHEADER, rgIndexInfo) == 8892);
    Assert(offsetof(TABLEHEADER, rgdwReserved3) == 9294);
    m_cRef = 1;
    m_cExtRefs = 0;
    m_pSchema = NULL;
    m_pStorage = NULL;
    m_pShare = NULL;
    m_hMutex = NULL;
    m_pHeader = NULL;
    m_hHeap = NULL;
    m_fDeconstruct = FALSE;
    m_fInMoveFile = FALSE;
    m_fExclusive = FALSE;
    m_dwProcessId = GetCurrentProcessId();
    m_dwQueryVersion = 0;
    m_pExtension = NULL;
    m_pUnkRelease = NULL;
    m_fDirty = FALSE;
#ifdef BACKGROUND_MONITOR
    m_hMonitor = NULL;
#endif
    m_fCompactYield = FALSE;
    ZeroMemory(m_rgpRecycle, sizeof(m_rgpRecycle));
    ZeroMemory(&m_rghFilter, sizeof(m_rghFilter));
    InitializeCriticalSection(&m_csHeap);
    IF_DEBUG(m_cbHeapFree = m_cbHeapAlloc = 0);
    ListenThreadAddRef();
    DllAddRef();
}

//--------------------------------------------------------------------------
// CDatabase::~CDatabase
//--------------------------------------------------------------------------
CDatabase::~CDatabase(void)
{
    // Locals
    DWORD cClients=0;
    DWORD i;

    // Trace
    TraceCall("CDatabase::~CDatabase");

    // Release the Extension
    SafeRelease(m_pUnkRelease);

    // Decrement Thread Count
    if (NULL == m_hMutex)
        goto exit;

#ifdef BACKGROUND_MONITOR
    // UnRegister...
    if (m_hMonitor)
    {
        // Unregister
        SideAssert(SUCCEEDED(UnregisterFromMonitor(this, &m_hMonitor)));
    }
#endif

    // Wait for the Mutex
    WaitForSingleObject(m_hMutex, INFINITE);

    // If I have a m_pShare
    if (m_pStorage)
    {
        // If we have an m_pShare
        if (m_pShare)
        {
            // Decrement the thread Count
            if (m_pHeader && m_pHeader->cActiveThreads > 0)
            {
                // Decrement Thread Count
                m_pHeader->cActiveThreads--;
            }

            // Set State that we are de-constructing
            m_fDeconstruct = TRUE;

            // Remove Client From Array
            SideAssert(SUCCEEDED(_RemoveClientFromArray(m_dwProcessId, (DWORD_PTR)this)));

            // Save Client Count
            cClients = m_pShare->cClients;

            // No more client
            Assert(0 == cClients ? 0 == m_pShare->Rowsets.cUsed : TRUE);
        }

        // _CloseFileViews
        _CloseFileViews(FALSE);

        // Close the File
        SafeCloseHandle(m_pStorage->hMap);

        // Unmap the view of the memory mapped file
        SafeUnmapViewOfFile(m_pShare);

        // Unmap the view of the memory mapped file
        SafeCloseHandle(m_pStorage->hShare);

        // Close the File
        if(m_pStorage->hFile /*&& m_fDirty*/)
        {
            FILETIME systime;
            GetSystemTimeAsFileTime(&systime);
    
            SetFileTime(m_pStorage->hFile, NULL, &systime, &systime);
        }

        SafeCloseHandle(m_pStorage->hFile);

        // Free the mapping name
        SafeMemFree(m_pStorage->pszMap);

        // Free m_pStorage
        SafeMemFree(m_pStorage);
    }

    // Close all the Query Handles
    for (i=0; i<CMAX_INDEXES; i++)
    {
        // Close the Query
        CloseQuery(&m_rghFilter[i], this);
    }

    // Free the Heap Cache
    for (i=0; i<CC_HEAP_BUCKETS; i++)
    {
        // Locals
        LPMEMORYTAG pTag;
        LPVOID      pNext;
        LPVOID      pCurrent=(LPVOID)m_rgpRecycle[i];

        // While we have something to free
        while(pCurrent)
        {
            // Set Tag
            pTag = (LPMEMORYTAG)pCurrent;

            // Debug
            IF_DEBUG(m_cbHeapFree += pTag->cbSize);

            // Save Next
            pNext = pTag->pNext;

            // Free Current
#ifdef USEHEAP
            ::HeapFree(m_hHeap, HEAP_NO_SERIALIZE, pCurrent);
#else
            g_pMalloc->Free(pCurrent);
#endif

            // Set Current
            pCurrent = pNext;
        }

        // Null It
        m_rgpRecycle[i] = NULL;
    }

    // Leaks ?
    Assert(m_cbHeapAlloc == m_cbHeapFree);

    // Release the Heap
    if (m_hHeap)
    {
        // HeapDestroy
        HeapDestroy(m_hHeap);

        // Don't free again
        m_hHeap = NULL;
    }

    // Reset Locals
    m_pSchema = NULL;

    // Release the mutex
    ReleaseMutex(m_hMutex);

    // Close the Table Mutex
    CloseHandle(m_hMutex);

    // Delete Crit Sect.
    DeleteCriticalSection(&m_csHeap);

exit:
    // Release the listen thread
    ListenThreadRelease();

    // Release Dll
    DllRelease();

    // Done
    return;
}

//--------------------------------------------------------------------------
// CDatabase::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabase::AddRef(void)
{
    // Trace
    TraceCall("CDatabase::AddRef");

    // AddRef the Extension...
    if (m_pExtension && NULL == m_pUnkRelease)
    {
        // Keep Track of how many times I have addref'ed the extension
        InterlockedIncrement(&m_cExtRefs);

        // AddRef It
        m_pExtension->AddRef();
    }

    // Increment My Ref Count
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CDatabase::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabase::Release(void)
{
    // Trace
    TraceCall("CDatabase::Release");

    // Release the Extension...
    if (m_pExtension && NULL == m_pUnkRelease && m_cExtRefs > 0)
    {
        // Keep Track of how many times I have addref'ed the extension
        InterlockedDecrement(&m_cExtRefs);

        // AddRef It
        m_pExtension->Release();
    }

    // Do My Release
    LONG cRef = InterlockedDecrement(&m_cRef);

    // If zero, delete
    if (0 == cRef)
        delete this;

    // Return Ref Count
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CDatabase::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CDatabase::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IDatabase *)this;
    else if (IID_IDatabase == riid)
        *ppv = (IDatabase *)this;
    else if (IID_CDatabase == riid)
        *ppv = (CDatabase *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::Open
//--------------------------------------------------------------------------
HRESULT CDatabase::Open(LPCWSTR pszFile, OPENDATABASEFLAGS dwFlags,
    LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pszShare=NULL;
    LPWSTR          pszMutex=NULL;
    LPWSTR          pszFilePath=NULL;
    BOOL            fNewShare;
    BOOL            fNewFileMap;
    BOOL            fFileCreated;
    BOOL            fFileCorrupt = FALSE;
    DWORD           cbInitialSize;
    DWORD           cbMinFileSize;
    DWORD           cchFilePath;
    LPCLIENTENTRY   pClient;

    // Trace
    TraceCall("CDatabase::Open");

    // Invalid Args
    Assert(pszFile && pSchema);

    // Already Open ?
    if (m_hMutex)
        return(TraceResult(DB_E_ALREADYOPEN));

    // Get the Full Path
    IF_FAILEXIT(hr = DBGetFullPath(pszFile, &pszFilePath, &cchFilePath));

    // Failure
    if (cchFilePath >= CCHMAX_DB_FILEPATH)
    {
        SafeMemFree(pszFilePath);
        return(TraceResult(E_INVALIDARG));
    }

    // Don't use pszFile again
    pszFile = NULL;

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(pszFilePath, L"_DirectDBMutex", &pszMutex));

    // Create the Mutex
    IF_NULLEXIT(m_hMutex = CreateMutexWrapW(NULL, FALSE, pszMutex));

    // Wait for the Mutex
    WaitForSingleObject(m_hMutex, INFINITE);

    // Create the Heap
    IF_NULLEXIT(m_hHeap = HeapCreate(0, 8096, 0));

    // No Listen Window Yet ?
    IF_FAILEXIT(hr = CreateListenThread());

    // Save the Record Format, this should be global const data, so no need to duplicate it
    m_pSchema = pSchema;
    cbMinFileSize = sizeof(TABLEHEADER) + m_pSchema->cbUserData;

    // Validate
    IF_DEBUG(_DebugValidateRecordFormat());

    // Allocate m_pStorage
    IF_NULLEXIT(m_pStorage = (LPSTORAGEINFO)ZeroAllocate(sizeof(STORAGEINFO)));

    // Exclusive
    m_fExclusive = (ISFLAGSET(dwFlags, OPEN_DATABASE_EXCLUSEIVE) ? TRUE : FALSE);

    // Open the File
    IF_FAILEXIT(hr = DBOpenFile(pszFilePath, ISFLAGSET(dwFlags, OPEN_DATABASE_NOCREATE), m_fExclusive, &fFileCreated, &m_pStorage->hFile));

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(pszFilePath, L"_DirectDBShare", &pszShare));

    // Open the file mapping
    IF_FAILEXIT(hr = DBOpenFileMapping(INVALID_HANDLE_VALUE, pszShare, sizeof(SHAREDDATABASE), &fNewShare, &m_pStorage->hShare, (LPVOID *)&m_pShare));

    // New Share
    if (TRUE == fNewShare)
    {
        // Zero Out m_pShare
        ZeroMemory(m_pShare, sizeof(SHAREDDATABASE));

        // Copy the file name
        StrCpyW(m_pShare->szFile, pszFilePath);

        // Fixup the Query Table Version
        m_pShare->dwQueryVersion = 1;
    }

    // Too Many clients ?
    if (m_pShare->cClients == CMAX_CLIENTS)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Readability
    pClient = &m_pShare->rgClient[m_pShare->cClients];

    // Initialize the Entry
    ZeroMemory(pClient, sizeof(CLIENTENTRY));

    // Get the listen window
    GetListenWindow(&pClient->hwndListen);

    // Register Myself
    pClient->dwProcessId = m_dwProcessId;
    pClient->pDB = (DWORD_PTR)this;

    // Incrment Count
    m_pShare->cClients++;

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(m_pShare->szFile, L"_DirectDBFileMap", &m_pStorage->pszMap));

    // Get the file size
    IF_FAILEXIT(hr = DBGetFileSize(m_pStorage->hFile, &cbInitialSize));

    // If the file is too small to handle the header, then we either have a corrupt file
    // that is way too corrupt to be saved, or we have an invalid file. Take some
    // defensive measures to make sure we can continue
    if (!fFileCreated && (cbInitialSize < cbMinFileSize))
    {
        fFileCorrupt = TRUE;

        // If we can't reset or create, then must exit 
        if (ISFLAGSET(dwFlags, OPEN_DATABASE_NORESET) || ISFLAGSET(dwFlags, OPEN_DATABASE_NOCREATE))
        {
            IF_FAILEXIT(hr = HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT));
        }
        // If we can reset, let's make sure the mapping file is the appropriate size
        else
        {
            cbInitialSize = 0;
        }
    }

    // Validate
    Assert(fFileCreated ? 0 == cbInitialSize : TRUE);

    // If zero, must be a new file or corrupt one(lets create with 1 byte header)
    if (0 == cbInitialSize)
    {
        Assert(fFileCorrupt || fFileCreated);

        // Initial Size
        m_pStorage->cbFile = cbMinFileSize;
    }

    // Otherwise, Set m_pStorage->cbFile
    else
        m_pStorage->cbFile = cbInitialSize;

    // Open the file mapping
    IF_FAILEXIT(hr = DBOpenFileMapping(m_pStorage->hFile, m_pStorage->pszMap, m_pStorage->cbFile, &fNewFileMap, &m_pStorage->hMap, NULL));

    // _InitializeFileViews
    IF_FAILEXIT(hr = _InitializeFileViews());

    // New File or corrupt?
    if (fFileCreated || fFileCorrupt)
    {
        // Validate
        Assert ((fFileCreated && fNewFileMap) || fFileCorrupt);

        // Reset Table Header
        IF_FAILEXIT(hr = _ResetTableHeader());
    }

    // Otherwise
    else
    {
        // Adjust pHeader->faNextAllocate for previous versions...
        if (0 == m_pHeader->faNextAllocate)
        {
            // The next storage grow address
            m_pHeader->faNextAllocate = m_pStorage->cbFile;
        }

        // faNextAllocate is Invalid
        else if (m_pHeader->faNextAllocate > m_pStorage->cbFile)
        {
            // Assert
            AssertSz(FALSE, "m_pHeader->faNextAllocate is beyond the end of the file.");

            // The next storage grow address
            m_pHeader->faNextAllocate = m_pStorage->cbFile;

            // Check for Corruption
            m_pHeader->fCorruptCheck = FALSE;
        }
    }

    // Validate File Versions and Signatures
    IF_FAILEXIT(hr = _ValidateFileVersions(dwFlags));

    // Reload query table
    IF_FAILEXIT(hr = _BuildQueryTable());

    // No Indexes, must need to initialize index info
    if (0 == m_pHeader->cIndexes)
    {
        // Copy Primary Index Information...
        CopyMemory(&m_pHeader->rgIndexInfo[IINDEX_PRIMARY], m_pSchema->pPrimaryIndex, sizeof(TABLEINDEX));

        // We now have one index
        m_pHeader->cIndexes = 1;

        // Validate
        Assert(IINDEX_PRIMARY == m_pHeader->rgiIndex[0] && 0 == m_pHeader->rgcRecords[IINDEX_PRIMARY] && 0 == m_pHeader->rgfaIndex[IINDEX_PRIMARY]);
    }

    // Otherwise, if definition of primary index has changed!!!
    else if (S_FALSE == CompareTableIndexes(&m_pHeader->rgIndexInfo[IINDEX_PRIMARY], m_pSchema->pPrimaryIndex))
    {
        // Copy Primary Index Information...
        CopyMemory(&m_pHeader->rgIndexInfo[IINDEX_PRIMARY], m_pSchema->pPrimaryIndex, sizeof(TABLEINDEX));

        // Rebuild the Primary Index...
        IF_FAILEXIT(hr = _RebuildIndex(IINDEX_PRIMARY));
    }

    // New Share
    if (TRUE == fNewFileMap)
    {
        // Don't Free Transact list if transaction block size has changed
        if (m_pHeader->wTransactSize == sizeof(TRANSACTIONBLOCK))
        {
            // Transaction Trail should be free
            _CleanupTransactList();
        }

        // Reset Everything
        m_pHeader->faTransactHead = m_pHeader->faTransactTail = m_pHeader->cTransacts = 0;

        // Set Transaction Block Size
        m_pHeader->wTransactSize = sizeof(TRANSACTIONBLOCK);

        // Bad close ?
        if (m_pHeader->cActiveThreads > 0)
        {
            // Increment Bad Close Count
            m_pHeader->cBadCloses++;

            // Reset Process Count
            m_pHeader->cActiveThreads = 0;
        }
    }

    // Otherwise, if the corrupt bit is set, run the repair code
    if (TRUE == m_pHeader->fCorrupt || FALSE == m_pHeader->fCorruptCheck)
    {
        // Lets validate the tree
        IF_FAILEXIT(hr = _CheckForCorruption());

        // Better not be corrupt
        Assert(FALSE == m_pHeader->fCorrupt);

        // Checked for Corruption
        m_pHeader->fCorruptCheck = TRUE;
    }

    // Initialize Database Extension
    _InitializeExtension(dwFlags, pExtension);

#ifdef BACKGROUND_MONITOR
    // If nomonitor is not set
    if (!ISFLAGSET(dwFlags, OPEN_DATABASE_NOMONITOR))
    {
        // Keep on eye on me...
        IF_FAILEXIT(hr = RegisterWithMonitor(this, &m_hMonitor));
    }
#endif

    // Increment Number of Processes
    m_pHeader->cActiveThreads++;

exit:
    // Release the Mutex
    if (m_hMutex)
        ReleaseMutex(m_hMutex);

    // Cleanup
    SafeMemFree(pszShare);
    SafeMemFree(pszMutex);
    SafeMemFree(pszFilePath);

    // Done
    return(hr);
}

#ifdef BACKGROUND_MONITOR
//--------------------------------------------------------------------------
// CDatabase::DoBackgroundMonitor
//--------------------------------------------------------------------------
HRESULT CDatabase::DoBackgroundMonitor(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPFILEVIEW      pView;
    LPFILEVIEW      pNext;
    BOOL            fUnmapViews=TRUE;

    // bobn, 7/8/99
    // Occasionally, m_pSchema can be invalid due to a race condition in SMAPI
    // We need to protect against that.  We are too close to ship to 
    // find the race condition and re-architect the product to fix completely
    // this corner case.
    if (IsBadReadPtr(m_pSchema, sizeof(TABLESCHEMA)))
        return(TraceResult(E_FAIL));

    // No Mutex
    if (NULL == m_hMutex)
        return(TraceResult(E_FAIL));

    // Leave Spin Lock
    if (WAIT_OBJECT_0 != WaitForSingleObject(m_hMutex, 500))
        return(S_OK);

    // No Header ?
    if (NULL == m_pHeader)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // No Storage
    if (NULL == m_pStorage)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

#if 0
    // Un-map file views ?
    if (0 == m_pStorage->tcMonitor)
    {
        // I will unmap all views
        fUnmapViews = FALSE;
    }
#endif

    // Always Flush the header
    m_fDirty = TRUE;
    if (0 == FlushViewOfFile(m_pHeader, sizeof(TABLEHEADER) + m_pSchema->cbUserData))
    {
        hr = TraceResult(DB_E_FLUSHVIEWOFFILE);
        goto exit;
    }

    // Walk through prgView
    for (i=0; i<m_pStorage->cAllocated; i++)
    {
        // Readability
        pView = &m_pStorage->prgView[i];

        // Is Mapped ?
        if (pView->pbView)
        {
            // Flush the header
            if (0 == FlushViewOfFile(pView->pbView, pView->cbView))
            {
                hr = TraceResult(DB_E_FLUSHVIEWOFFILE);
                goto exit;
            }

            // Flush and UnMap the Views...
            if (TRUE == fUnmapViews)
            {
                // Unmap 
                UnmapViewOfFile(pView->pbView);

                // No view
                pView->pbView = NULL;

                // No view
                pView->faView = pView->cbView = 0;
            }
        }
    }

    // Walk through pSpecial
    pView = m_pStorage->pSpecial;

    // While we have a Current
    while (pView)
    {
        // Save pNext
        pNext = pView->pNext;

        // Is Mapped ?
        if (pView->pbView)
        {
            // Flush the header
            if (0 == FlushViewOfFile(pView->pbView, pView->cbView))
            {
                hr = TraceResult(DB_E_FLUSHVIEWOFFILE);
                goto exit;
            }

            // Flush and UnMap the Views...
            if (TRUE == fUnmapViews)
            {
                // Unmap 
                UnmapViewOfFile(pView->pbView);

                // No view
                pView->pbView = NULL;

                // No view
                pView->faView = pView->cbView = 0;

                // Free pView
                HeapFree(pView);
            }
        }

        // Goto Next
        pView = pNext;
    }

    // Reset Head
    if (TRUE == fUnmapViews)
    {
        // No more special views
        m_pStorage->pSpecial = NULL;

        // No more special views
        m_pStorage->cSpecial = 0;

        // No Mapped Views
        m_pStorage->cbMappedViews = 0;

        // No Mapped Special Views
        m_pStorage->cbMappedSpecial = 0;
    }

    // Save tcMonitor
    m_pStorage->tcMonitor = GetTickCount();

exit:
    // Release the Mutex
    ReleaseMutex(m_hMutex);

    // Done
    return(hr);
}
#endif

//--------------------------------------------------------------------------
// CDatabase::_CloseFileViews
//--------------------------------------------------------------------------
HRESULT CDatabase::_CloseFileViews(BOOL fFlush)
{
    // Locals
    LPFILEVIEW  pCurrent;
    LPFILEVIEW  pNext;
    DWORD       i;

    // Trace
    TraceCall("CDatabase::_CloseFileViews");

    // Unmap the view of the header
    UnmapViewOfFileWithFlush(fFlush, m_pHeader, sizeof(TABLEHEADER) + m_pSchema->cbUserData);

    // Walk through prgView
    for (i = 0; i < m_pStorage->cAllocated; i++)
    {
        // Readability
        pCurrent = &m_pStorage->prgView[i];

        // Unmap with possible flush
        UnmapViewOfFileWithFlush(fFlush, pCurrent->pbView, pCurrent->cbView);
    }

    // Free prgView
    SafeHeapFree(m_pStorage->prgView);

    // No Views are mapped
    m_pStorage->cbMappedViews = 0;

    // Zero cAllocate
    m_pStorage->cAllocated = 0;

    // Walk through pSpecial
    pCurrent = m_pStorage->pSpecial;

    // While we have a Current
    while (pCurrent)
    {
        // Save pNext
        pNext = pCurrent->pNext;

        // Unmap the view
        UnmapViewOfFileWithFlush(fFlush, pCurrent->pbView, pCurrent->cbView);

        // Free pCurrent
        HeapFree(pCurrent);

        // Goto Next
        pCurrent = pNext;
    }

    // Reset Head
    m_pStorage->pSpecial = NULL;

    // No Special Mapped
    m_pStorage->cbMappedSpecial = 0;

    // No Special
    m_pStorage->cSpecial = 0;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_InitializeFileViews
//--------------------------------------------------------------------------
HRESULT CDatabase::_InitializeFileViews(void)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faView;
    DWORD           cbView;

    // Trace
    TraceCall("CDatabase::_InitializeFileViews");

    // Validate State
    Assert(NULL == m_pStorage->prgView && NULL == m_pStorage->pSpecial);

    // Set cAllocated
    m_pStorage->cAllocated = (m_pStorage->cbFile / CB_MAPPED_VIEW) + 1;

    // Allocate prgView
    IF_NULLEXIT(m_pStorage->prgView = (LPFILEVIEW)PHeapAllocate(HEAP_ZERO_MEMORY, sizeof(FILEVIEW) * m_pStorage->cAllocated));

    // Set faView
    faView = 0;

    // Set cbView
    cbView = (sizeof(TABLEHEADER) + m_pSchema->cbUserData);

    // Map m_pHeader into its own view...
    IF_FAILEXIT(hr = DBMapViewOfFile(m_pStorage->hMap, m_pStorage->cbFile, &faView, &cbView, (LPVOID *)&m_pHeader));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_InitializeExtension
//--------------------------------------------------------------------------
HRESULT CDatabase::_InitializeExtension(OPENDATABASEFLAGS dwFlags,
    IDatabaseExtension *pExtension)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CDatabase::_InitializeExtension");

    // Extension Allowed
    if (ISFLAGSET(dwFlags, OPEN_DATABASE_NOEXTENSION))
        goto exit;

    // Doesn't have an extension ?
    if (FALSE == ISFLAGSET(m_pSchema->dwFlags, TSF_HASEXTENSION))
        goto exit;

    // Create the Extension Object
    if (pExtension)
    {
        // Assume It
        m_pExtension = pExtension;

        // Can I add ref it ?
        if (FALSE == ISFLAGSET(dwFlags, OPEN_DATABASE_NOADDREFEXT))
        {
            // Release It
            IF_FAILEXIT(hr = m_pExtension->QueryInterface(IID_IUnknown, (LPVOID *)&m_pUnkRelease));
        }
    }

    // Otherwise, CoCreate... the extension
    else
    {
        // CoCreate the Extension Object
        IF_FAILEXIT(hr = CoCreateInstance(*m_pSchema->pclsidExtension, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseExtension, (LPVOID *)&m_pExtension));

        // Release It
        IF_FAILEXIT(hr = m_pExtension->QueryInterface(IID_IUnknown, (LPVOID *)&m_pUnkRelease));

        // Release m_pExtension
        m_pExtension->Release();
    }

    // Initialize the Extension
    m_pExtension->Initialize(this);

exit:
    // Must have succeeded
    Assert(SUCCEEDED(hr));

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetClientCount
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetClientCount(LPDWORD pcClients)
{
    // Trace
    TraceCall("CDatabase::GetClientCount");

    // Multiple Clients ?
    if (m_pShare)
        *pcClients = m_pShare->cClients;
    else
        *pcClients = 0;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::Lock
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::Lock(LPHLOCK phLock)
{
    // Locals
    HRESULT         hr=S_OK;
    BYTE            fDecWaiting=FALSE;

    // Trace
    TraceCall("CDatabase::Lock");

    // Initialize
    *phLock = NULL;

    // If Compacting...
    if (TRUE == m_pShare->fCompacting)
    {
        // Increment Waiting for Lock
        InterlockedIncrement(&m_pShare->cWaitingForLock);

        // fDecWaiting
        fDecWaiting = TRUE;
    }

    // Leave Spin Lock
    WaitForSingleObject(m_hMutex, INFINITE);

    // Decrement Waiting for lock ?
    if (fDecWaiting)
    {
        // Increment Waiting for Lock
        InterlockedDecrement(&m_pShare->cWaitingForLock);
    }

    // No Header ?
    if (NULL == m_pHeader)
    {
        // Try to re-open the file
        hr = DoInProcessInvoke(INVOKE_CREATEMAP);

        // Failure
        if (FAILED(hr))
        {
            // Leave Spin Lock
            ReleaseMutex(m_hMutex);

            // Trace
            TraceResult(hr);

            // Done
            goto exit;
        }
    }

    // Extension
    if (m_pExtension)
    {
        // OnLock Extension...
        m_pExtension->OnLock();
    }

    // Check for Corruption...
    if (TRUE == m_pHeader->fCorrupt)
    {
        // Try to Repair Corruption
        hr = _CheckForCorruption();

        // Failure
        if (FAILED(hr))
        {
            // Leave Spin Lock
            ReleaseMutex(m_hMutex);

            // Trace
            TraceResult(hr);

            // Done
            goto exit;
        }
    }

    // Need to reload quieries
    if (m_dwQueryVersion != m_pShare->dwQueryVersion)
    {
        // Reload query table
        IF_FAILEXIT(hr = _BuildQueryTable());
    }

    // Increment Queue Notify count
    m_pShare->cNotifyLock++;

#ifdef BACKGROUND_MONITOR
    // Reset tcMonitor
    m_pStorage->tcMonitor = 0;
#endif

    // Don't Unlock Again
    *phLock = (HLOCK)m_hMutex;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::Unlock
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::Unlock(LPHLOCK phLock)
{
    // Trace
    TraceCall("CDatabase::Unlock");

    // Not Null
    if (*phLock)
    {
        // Extension
        if (m_pExtension)
        {
            // OnUnlock Extension...
            m_pExtension->OnUnlock();
        }

        // Unlock Notify
        m_pShare->cNotifyLock--;

        // If there are still refs, don't send notifications yet...
        if (0 == m_pShare->cNotifyLock && FALSE == m_pHeader->fCorrupt)
        {
            // Dispatch Pending
            _DispatchPendingNotifications();
        }

        // Validate phLock
        Assert(*phLock == (HLOCK)m_hMutex);

        // Leave Spin Lock
        ReleaseMutex(m_hMutex);

        // Don't Unlock Again
        *phLock = NULL;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_BuildQueryTable
//--------------------------------------------------------------------------
HRESULT CDatabase::_BuildQueryTable(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    INDEXORDINAL    iIndex;
    LPBLOCKHEADER   pBlock;

    // Trace
    TraceCall("CDatabase::_BuildQueryTable");

    // Versions should be different
    Assert(m_dwQueryVersion != m_pShare->dwQueryVersion);

    // Collapse the Ordinal Array
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Set iIndex
        iIndex = m_pHeader->rgiIndex[i];

        // Close the Current Filters
        CloseQuery(&m_rghFilter[iIndex], this);

        // Filter
        if (m_pHeader->rgfaFilter[iIndex])
        {
            // Validate File Address
            IF_FAILEXIT(hr = _GetBlock(BLOCK_STRING, m_pHeader->rgfaFilter[iIndex], (LPVOID *)&pBlock));

            // Load the Query String
            if (FAILED(ParseQuery(PSTRING(pBlock), m_pSchema, &m_rghFilter[iIndex], this)))
            {
                // Null
                m_rghFilter[iIndex] = NULL;
            }
        }
    }

    // Save New Version
    m_dwQueryVersion = m_pShare->dwQueryVersion;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ResetTableHeader
//--------------------------------------------------------------------------
HRESULT CDatabase::_ResetTableHeader(void)
{
    // Locals
    HRESULT         hr=S_OK;

    // Trace
    TraceCall("CDatabase::_ResetTableHeader");

    // Zero out the Table Header + UserData
    ZeroMemory(m_pHeader, sizeof(TABLEHEADER) + m_pSchema->cbUserData);

    // Set the File Signature
    m_pHeader->dwSignature = BTREE_SIGNATURE;

    // Set the Major Version
    m_pHeader->dwMajorVersion = BTREE_VERSION;

    // Store the size of the user data
    m_pHeader->cbUserData = m_pSchema->cbUserData;

    // Set faNextAllocate
    m_pHeader->faNextAllocate = sizeof(TABLEHEADER) + m_pSchema->cbUserData;

    // Initialize ID Generator
    m_pHeader->dwNextId = 1;

    // No need to do the corruption check, its a new file...
    m_pHeader->fCorruptCheck = TRUE;

    // Store the clsidExtension
    CopyMemory(&m_pHeader->clsidExtension, m_pSchema->pclsidExtension, sizeof(CLSID));

    // Store the Version
    m_pHeader->dwMinorVersion = m_pSchema->dwMinorVersion;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_ValidateFileVersions
//--------------------------------------------------------------------------
HRESULT CDatabase::_ValidateFileVersions(OPENDATABASEFLAGS dwFlags)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CDatabase::_ValidateFileVersions");

    // Signature better match
    if (m_pHeader->dwSignature != BTREE_SIGNATURE)
    {
        hr = TraceResult(DB_E_INVALIDFILESIGNATURE);
        goto exit;
    }

    // Validate the Major Version
    if (m_pHeader->dwMajorVersion != BTREE_VERSION)
    {
        hr = TraceResult(DB_E_BADMAJORVERSION);
        goto exit;
    }

    // Validate the Minor Version
    if (m_pHeader->dwMinorVersion != m_pSchema->dwMinorVersion)
    {
        hr = TraceResult(DB_E_BADMINORVERSION);
        goto exit;
    }

    // Validate the Minor Version
    if (FALSE == IsEqualCLSID(m_pHeader->clsidExtension, *m_pSchema->pclsidExtension))
    {
        hr = TraceResult(DB_E_BADEXTENSIONCLSID);
        goto exit;
    }

exit:
    // Can I Reset
    if (FALSE == ISFLAGSET(dwFlags, OPEN_DATABASE_NORESET))
    {
        // Failed and reset if bad version ?
        if (FAILED(hr) && ISFLAGSET(m_pSchema->dwFlags, TSF_RESETIFBADVERSION))
        {
            // Reset the Table Header
            hr = _ResetTableHeader();
        }
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::PHeapAllocate
//--------------------------------------------------------------------------
LPVOID CDatabase::PHeapAllocate(DWORD dwFlags, DWORD cbSize)
{
    // Locals
    LPMEMORYTAG pTag;

    // Trace
    TraceCall("CDatabase::PHeapAllocate");

    // Increment the Size Enough to Store a Header
    cbSize += sizeof(MEMORYTAG);

    // Block is a too big to recycle ?
#ifdef HEAPCACHE
    if (cbSize >= CB_MAX_HEAP_BUCKET)
    {
#endif
        // Thread Safety
        EnterCriticalSection(&m_csHeap);

        // Allocate the Block
#ifdef USEHEAP
        LPVOID pBlock = HeapAlloc(m_hHeap, dwFlags | HEAP_NO_SERIALIZE, cbSize);
#else
        LPVOID pBlock = ZeroAllocate(cbSize);
#endif

        // Debug
        IF_DEBUG(m_cbHeapAlloc += cbSize);

        // Thread Safety
        LeaveCriticalSection(&m_csHeap);

        // Set pTag
        pTag = (LPMEMORYTAG)pBlock;

#ifdef HEAPCACHE
    }

    // Otherwise
    else
    {
        // Compute Free Block Bucket
        WORD iBucket = ((WORD)(cbSize / CB_HEAP_BUCKET));

        // Decrement iBucket ?
        if (0 == (cbSize % CB_HEAP_BUCKET))
        {
            // Previous Bucket
            iBucket--;
        }

        // Adjust cbBlock to fit completly into it's bucket
        cbSize = ((iBucket + 1) * CB_HEAP_BUCKET);

        // Thread Safety
        EnterCriticalSection(&m_csHeap);

        // Is there a block in this Bucket ?
        if (m_rgpRecycle[iBucket])
        {
            // Use this block
            pTag = (LPMEMORYTAG)m_rgpRecycle[iBucket];

            // Validate Size
            Assert(cbSize == pTag->cbSize);

            // Fixup m_rgpRecycle
            m_rgpRecycle[iBucket] = (LPBYTE)pTag->pNext;

            // Zero
            if (ISFLAGSET(dwFlags, HEAP_ZERO_MEMORY))
            {
                // Zero
                ZeroMemory((LPBYTE)pTag, cbSize);
            }
        }

        // Otherwise, allocate
        else
        {
            // Allocate the Block
#ifdef USEHEAP
            LPVOID pBlock = HeapAlloc(m_hHeap, dwFlags | HEAP_NO_SERIALIZE, cbSize);
#else
            LPVOID pBlock = ZeroAllocate(cbSize);
#endif

            // Debug
            IF_DEBUG(m_cbHeapAlloc += cbSize);

            // Set pTag
            pTag = (LPMEMORYTAG)pBlock;
        }

        // Thread Safety
        LeaveCriticalSection(&m_csHeap);
    }
#endif

    // No pTag
    if (NULL == pTag)
        return(NULL);

    // Fixup the Block Size
    pTag->cbSize = cbSize;

    // Set Signature
    pTag->dwSignature = MEMORY_GUARD_SIGNATURE;

    // Done
    return((LPBYTE)pTag + sizeof(MEMORYTAG));
}

//--------------------------------------------------------------------------
// CDatabase::HeapFree
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::HeapFree(LPVOID pBlock)
{
    // Locals
    LPMEMORYTAG pTag;

    // Trace
    TraceCall("CDatabase::HeapFree");

    // No Buffer
    if (NULL == pBlock)
        return(S_OK);

    // Set pTag
    pTag = (LPMEMORYTAG)((LPBYTE)pBlock - sizeof(MEMORYTAG));

    // Is Valid Block ?
    Assert(pTag->dwSignature == MEMORY_GUARD_SIGNATURE);

    // Block is a too big to recycle ?
#ifdef HEAPCACHE
    if (pTag->cbSize >= CB_MAX_HEAP_BUCKET)
    {
#endif
        // Thread Safety
        EnterCriticalSection(&m_csHeap);

        // Debug
        IF_DEBUG(m_cbHeapFree += pTag->cbSize);

        // Allocate the Block
#ifdef USEHEAP
        ::HeapFree(m_hHeap, HEAP_NO_SERIALIZE, pTag);
#else
        g_pMalloc->Free(pTag);
#endif

        // Thread Safety
        LeaveCriticalSection(&m_csHeap);

#ifdef HEAPCACHE
    }

    // Otherwise, cache It
    else
    {
        // Compute Free Block Bucket
        WORD iBucket = ((WORD)(pTag->cbSize / CB_HEAP_BUCKET)) - 1;

        // Must be an integral size of a bucket
        Assert((pTag->cbSize % CB_HEAP_BUCKET) == 0);

        // Thread Safety
        EnterCriticalSection(&m_csHeap);

        // Set Next
        pTag->pNext = m_rgpRecycle[iBucket];

        // Set the Head
        m_rgpRecycle[iBucket] = (LPBYTE)pTag;

        // Thread Safety
        LeaveCriticalSection(&m_csHeap);
    }
#endif

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::GetIndexInfo
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetIndexInfo(INDEXORDINAL iIndex, LPSTR *ppszFilter,
    LPTABLEINDEX pIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    HLOCK           hLock=NULL;
    LPBLOCKHEADER   pBlock;

    // Trace
    TraceCall("CDatabase::GetIndexInfo");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Collapse the Ordinal Array
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Get iIndex
        if (iIndex == m_pHeader->rgiIndex[i])
        {
            // Copy the Index Information
            CopyMemory(pIndex, &m_pHeader->rgIndexInfo[iIndex], sizeof(TABLEINDEX));

            // Get the Filters ?
            if (ppszFilter && m_pHeader->rgfaFilter[iIndex])
            {
                // Corrupt
                IF_FAILEXIT(hr = _GetBlock(BLOCK_STRING, m_pHeader->rgfaFilter[iIndex], (LPVOID *)&pBlock));

                // Duplicate
                IF_NULLEXIT(*ppszFilter = DuplicateStringA(PSTRING(pBlock)));
            }

            // Done
            goto exit;
        }
    }

    // Failure
    hr = E_FAIL;

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::ModifyIndex
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::ModifyIndex(INDEXORDINAL iIndex, LPCSTR pszFilter,
    LPCTABLEINDEX pIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;
    HQUERY          hFilter=NULL;
    FILEADDRESS     faFilter=0;
    LPBLOCKHEADER   pFilter=NULL;
    BOOL            fFound=FALSE;
    DWORD           i;
    DWORD           cb;
    BOOL            fVersionChange=FALSE;

    // Trace
    TraceCall("CDatabase::ModifyIndex");

    // Invalid Args
    if (IINDEX_PRIMARY == iIndex || iIndex > CMAX_INDEXES || NULL == pIndex || pIndex->cKeys > CMAX_KEYS)
        return TraceResult(E_INVALIDARG);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Filter
    if (pszFilter)
    {
        // Parse the Query
        IF_FAILEXIT(hr = ParseQuery(pszFilter, m_pSchema, &hFilter, this));

        // Initialize the String Block
        cb = lstrlen(pszFilter) + 1;

        // Try to Store the Query String
        IF_FAILEXIT(hr = _AllocateBlock(BLOCK_STRING, cb, (LPVOID *)&pFilter));

        // Write the String
        CopyMemory(PSTRING(pFilter), pszFilter, cb);

        // Set faFilter
        faFilter = pFilter->faBlock;

        // Query Version Change
        fVersionChange = TRUE;
    }

    // Free This Index
    IF_FAILEXIT(hr = DeleteIndex(iIndex));

    // Copy the Index Information
    CopyMemory(&m_pHeader->rgIndexInfo[iIndex], pIndex, sizeof(TABLEINDEX));

    // Filter
    if (hFilter)
    {
        // Validate
        Assert(NULL == m_rghFilter[iIndex] && 0 == m_pHeader->rgfaFilter[iIndex] && hFilter && faFilter);

        // Store the hFilter
        m_rghFilter[iIndex] = hFilter;

        // Don't Free hFilter
        hFilter = NULL;

        // Store filter string address
        m_pHeader->rgfaFilter[iIndex] = faFilter;

        // Don't Free the Filter
        faFilter = 0;
    }

    // Update Query Versions
    if (fVersionChange)
    {
        // Update the Shared Query Version Count
        m_pShare->dwQueryVersion++;

        // I'm Up-to-date
        m_dwQueryVersion = m_pShare->dwQueryVersion;
    }

    // Is iIndex already in rgiIndex ?
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Is this it ?
        if (iIndex == m_pHeader->rgiIndex[i])
        {
            // Its already in there
            fFound = TRUE;

            // Done
            break;
        }
    }

    // No Found
    if (FALSE == fFound)
    {
        // Insert into Index Ordinal Array
        m_pHeader->rgiIndex[m_pHeader->cIndexes] = iIndex;

        // Increment Count
        m_pHeader->cIndexes++;
    }

    // Rebuild the Index
    IF_FAILEXIT(hr = _RebuildIndex(iIndex));

exit:
    // Close Filters
    CloseQuery(&hFilter, this);

    // Free faFilter1
    if (0 != faFilter)
    {
        // Free the block
        SideAssert(SUCCEEDED(_FreeBlock(BLOCK_STRING, faFilter)));
    }

    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::DeleteIndex
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::DeleteIndex(INDEXORDINAL iIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    BOOL            fFound=FALSE;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::DeleteIndex");

    // Invalid Args
    if (IINDEX_PRIMARY == iIndex || iIndex > CMAX_INDEXES)
        return TraceResult(E_INVALIDARG);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Collapse the Ordinal Array
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Is this the Index to delete ?
        if (m_pHeader->rgiIndex[i] == iIndex)
        {
            // Found
            fFound = TRUE;

            // Collapse the Array
            MoveMemory(&m_pHeader->rgiIndex[i], &m_pHeader->rgiIndex[i + 1], sizeof(INDEXORDINAL) * (m_pHeader->cIndexes - (i + 1)));

            // Decrement Index Count
            m_pHeader->cIndexes--;

            // Done
            break;
        }
    }

    // Not Found
    if (FALSE == fFound)
    {
        // No Filter and no Exception
        Assert(0 == m_pHeader->rgfaFilter[iIndex]);

        // No Filter Handle
        Assert(NULL == m_rghFilter[iIndex]);

        // No Record
        Assert(0 == m_pHeader->rgcRecords[iIndex]);

        // Done
        goto exit;
    }

    // If this Index is Currently In Use...
    if (m_pHeader->rgfaIndex[iIndex])
    {
        // Free This Index
        _FreeIndex(m_pHeader->rgfaIndex[iIndex]);

        // Null It Out
        m_pHeader->rgfaIndex[iIndex] = 0;

        // No Record
        m_pHeader->rgcRecords[iIndex] = 0;
    }

    // Delete Filter
    if (m_pHeader->rgfaFilter[iIndex])
    {
        // Free the Block
        IF_FAILEXIT(hr = _FreeBlock(BLOCK_STRING, m_pHeader->rgfaFilter[iIndex]));

        // Close the filter handle
        CloseQuery(&m_rghFilter[iIndex], this);

        // Set to NULL
        m_pHeader->rgfaFilter[iIndex] = 0;

        // Update the Shared Query Version Count
        m_pShare->dwQueryVersion++;
    }

    // I'm Up-to-date
    m_dwQueryVersion = m_pShare->dwQueryVersion;

    // Handle Should be closed
    Assert(NULL == m_rghFilter[iIndex]);

    // Send Notifications ?
    if (m_pShare->rgcIndexNotify[iIndex] > 0)
    {
        // Build the Update Notification Package
        _LogTransaction(TRANSACTION_INDEX_DELETED, iIndex, NULL, 0, 0);
    }

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GenerateId
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GenerateId(LPDWORD pdwId)
{
    // Locals
    HRESULT     hr=S_OK;
    HLOCK       hLock=NULL;

    // Trace
    TraceCall("CDatabase::GenerateId");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Loop Until I create a valid Id ?
    while (1)
    {
        // Increment next id
        m_pHeader->dwNextId++;

        // Invalid Id ?
        if (0 == m_pHeader->dwNextId)
            continue;

        // In Invalid Range
        if (m_pHeader->dwNextId >= RESERVED_ID_MIN && m_pHeader->dwNextId <= RESERVED_ID_MAX)
            continue;

        // Its Good
        break;
    }

    // Set pdwId
    *pdwId = m_pHeader->dwNextId;

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetFile
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetFile(LPWSTR *ppszFile)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::GetFile");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Dupp
    IF_NULLEXIT(*ppszFile = DuplicateStringW(m_pShare->szFile));

exit:
    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DispatchNotification 
//--------------------------------------------------------------------------
HRESULT CDatabase::_DispatchNotification(HTRANSACTION hTransaction)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               iClient;
    LPCLIENTENTRY       pClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;

    // Trace
    TraceCall("CDatabase::_DispatchNotification");

    // Walk through the List
    for (iClient=0; iClient<m_pShare->cClients; iClient++)
    {
        // De-reference the client
        pClient = &m_pShare->rgClient[iClient];

        // Loop through cNotify
        for (iRecipient=0; iRecipient<pClient->cRecipients; iRecipient++)
        {
            // De-Ref pEntry
            pRecipient = &pClient->rgRecipient[iRecipient];

            // If the Recipient isn't suspending...
            if (FALSE == pRecipient->fSuspended)
            {
                // Should have a Thunking Window
                Assert(pRecipient->hwndNotify && IsWindow(pRecipient->hwndNotify));

                // Post the Notification
                if (0 == PostMessage(pRecipient->hwndNotify, WM_ONTRANSACTION, (WPARAM)pRecipient->dwCookie, (LPARAM)hTransaction))
                {
                    hr = TraceResult(E_FAIL);
                    goto exit;
                }
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::DoInProcessInvoke
//--------------------------------------------------------------------------
HRESULT CDatabase::DoInProcessInvoke(INVOKETYPE tyInvoke)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fNew;

    // Trace
    TraceCall("CDatabase::DoInProcessNotify");

    // INVOKE_RELEASEMAP
    if (INVOKE_RELEASEMAP == tyInvoke)
    {
        // Validate
        _CloseFileViews(FALSE);

        // Close the File
        SafeCloseHandle(m_pStorage->hMap);
    }

    // INVOKE_CREATEMAP
    else if (INVOKE_CREATEMAP == tyInvoke)
    {
        // Validation
        Assert(NULL == m_pStorage->hMap);

        // Get the file size
        IF_FAILEXIT(hr = DBGetFileSize(m_pStorage->hFile, &m_pStorage->cbFile));

        // Open the file mapping
        IF_FAILEXIT(hr = DBOpenFileMapping(m_pStorage->hFile, m_pStorage->pszMap, m_pStorage->cbFile, &fNew, &m_pStorage->hMap, NULL));

        // Initialize File Views
        IF_FAILEXIT(hr = _InitializeFileViews());
    }

    // INVOKE_CLOSEFILE
    else if (INVOKE_CLOSEFILE == tyInvoke)
    {
        // Validate
        _CloseFileViews(TRUE);

        // Close the File
        if(m_pStorage->hFile /*&& m_fDirty*/)
        {
            FILETIME systime;
            GetSystemTimeAsFileTime(&systime);
    
            SetFileTime(m_pStorage->hFile, NULL, &systime, &systime);
        }
        SafeCloseHandle(m_pStorage->hMap);

        // Close the file
        SafeCloseHandle(m_pStorage->hFile);
    }

    // INVOKE_OPENFILE
    else if (INVOKE_OPENFILE == tyInvoke || INVOKE_OPENMOVEDFILE == tyInvoke)
    {
        // Validation
        Assert(NULL == m_pStorage->hFile && NULL == m_pStorage->hMap);

        // Open Moved File ?
        if (INVOKE_OPENMOVEDFILE == tyInvoke)
        {
            // _HandleOpenMovedFile
            IF_FAILEXIT(hr = _HandleOpenMovedFile());
        }

        // Open the File
        IF_FAILEXIT(hr = DBOpenFile(m_pShare->szFile, FALSE, m_fExclusive, &fNew, &m_pStorage->hFile));

        // Better not be new
        Assert(FALSE == fNew);

        // Get the file size
        IF_FAILEXIT(hr = DBGetFileSize(m_pStorage->hFile, &m_pStorage->cbFile));

        // Open the file mapping
        IF_FAILEXIT(hr = DBOpenFileMapping(m_pStorage->hFile, m_pStorage->pszMap, m_pStorage->cbFile, &fNew, &m_pStorage->hMap, NULL));

        // Initialize File Views
        IF_FAILEXIT(hr = _InitializeFileViews());
    }

    // Uhoh
    else
        AssertSz(FALSE, "Invalid invoke type passed into CDatabase::DoInProcessInvoke");

exit:

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_HandleOpenMovedFile
//--------------------------------------------------------------------------
HRESULT CDatabase::_HandleOpenMovedFile(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszMutex=NULL;
    LPWSTR      pszShare=NULL;
    BOOL        fNewShare;
    WCHAR       szFile[CCHMAX_DB_FILEPATH];

    // Trace
    TraceCall("CDatabase::_HandleOpenMovedFile");

    // Save New File Path
    StrCpyW(szFile, m_pShare->szFile);

    // Free pszMap
    SafeMemFree(m_pStorage->pszMap);

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(szFile, L"_DirectDBFileMap", &m_pStorage->pszMap));

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(szFile, L"_DirectDBMutex", &pszMutex));

    // Close the current mutex
    SafeCloseHandle(m_hMutex);

    // Create the Mutex
    IF_NULLEXIT(m_hMutex = CreateMutexWrapW(NULL, FALSE, pszMutex));

    // If not in move file
    if (FALSE == m_fInMoveFile)
    {
        // Create the Mutex Object
        IF_FAILEXIT(hr = CreateSystemHandleName(szFile, L"_DirectDBShare", &pszShare));

        // Unmap the view of the memory mapped file
        SafeUnmapViewOfFile(m_pShare);

        // Unmap the view of the memory mapped file
        SafeCloseHandle(m_pStorage->hShare);

        // Open the file mapping
        IF_FAILEXIT(hr = DBOpenFileMapping(INVALID_HANDLE_VALUE, pszShare, sizeof(SHAREDDATABASE), &fNewShare, &m_pStorage->hShare, (LPVOID *)&m_pShare));
    
        // Better not be new
        Assert(!fNewShare);
    }
    else
        Assert(StrCmpW(szFile, m_pShare->szFile) == 0);
        
exit:
    // Cleanup
    SafeMemFree(pszMutex);
    SafeMemFree(pszShare);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DispatchInvoke
//--------------------------------------------------------------------------
HRESULT CDatabase::_DispatchInvoke(INVOKETYPE tyInvoke)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               iClient=0;
    LPCLIENTENTRY       pClient;
    DWORD_PTR           dwResult;
    DWORD               dwThreadId=GetCurrentThreadId();
    INVOKEPACKAGE       Package;
    COPYDATASTRUCT      CopyData;

    // Trace
    TraceCall("CDatabase::_DispatchInvoke");

    // Set Invoke Type
    Package.tyInvoke = tyInvoke;

    // Walk through the List
    while (iClient < m_pShare->cClients)
    {
        // Readability
        pClient = &m_pShare->rgClient[iClient++];

        // Better have one
        Package.pDB = pClient->pDB;

        // Is this entry in my process ?
        if (m_dwProcessId == pClient->dwProcessId)
        {
            // Do In Process Notification
            CDatabase *pDB = (CDatabase *)pClient->pDB;

            // Do It
            IF_FAILEXIT(hr = pDB->DoInProcessInvoke(tyInvoke));
        }

        // Otherwise, just process the package
        else
        {
            // If the listener is good
            if (pClient->hwndListen && IsWindow(pClient->hwndListen))
            {
                // Initialize copy data struct
                CopyData.dwData = 0;

                // Store the Size of the Package
                CopyData.cbData = sizeof(INVOKEPACKAGE);

                // Store the Package
                CopyData.lpData = &Package;

                // Send It
                if (0 == SendMessageTimeout(pClient->hwndListen, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&CopyData, SMTO_ABORTIFHUNG, 5000, &dwResult))
                {
                    // Remove this client from the list
                    SideAssert(SUCCEEDED(_RemoveClientFromArray(pClient->dwProcessId, pClient->pDB)));

                    // Decrement iClient
                    iClient--;
                }
            }

            // Remove this client
            else
            {
                // Remove this client from the list
                SideAssert(SUCCEEDED(_RemoveClientFromArray(pClient->dwProcessId, pClient->pDB)));

                // Decrement iClient
                iClient--;
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_RemoveClientFromArray
//--------------------------------------------------------------------------
HRESULT CDatabase::_RemoveClientFromArray(DWORD dwProcessId, 
    DWORD_PTR dwDB)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    DWORD               cClients=0;
    DWORD               iClient;
    LPCLIENTENTRY       pClient;

    // Trace
    TraceCall("CDatabase::_RemoveClientFromArray");

    // Initialize i
    iClient = 0;

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(dwProcessId, dwDB, &iClient, &pClient));

    // Release Registered Notification Objects
    for (iRecipient=0; iRecipient<pClient->cRecipients; iRecipient++)
    {
        // Readability
        pRecipient = &pClient->rgRecipient[iRecipient];

        // Same Process ?
        if (dwProcessId == m_dwProcessId)
        {
            // Remove and messages from the notificaton queue
            _CloseNotificationWindow(pRecipient);

            // Release ?
            if (TRUE == pRecipient->fRelease)
            {
                // Cast pNotify
                IDatabaseNotify *pNotify = (IDatabaseNotify *)pRecipient->pNotify;

                // Cast to pRecipient
                pNotify->Release();
            }
        }

        // If Not Suspended
        if (FALSE == pRecipient->fSuspended)
        {
            // _AdjustNotifyCounts
            _AdjustNotifyCounts(pRecipient, -1);
        }
    }

    // Remove MySelf
    MoveMemory(&m_pShare->rgClient[iClient], &m_pShare->rgClient[iClient + 1], sizeof(CLIENTENTRY) * (m_pShare->cClients - (iClient + 1)));

    // Decrement Client Count
	m_pShare->cClients--;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CloseNotificationWindow
//--------------------------------------------------------------------------
HRESULT CDatabase::_CloseNotificationWindow(LPNOTIFYRECIPIENT pRecipient)
{
    // Trace
    TraceCall("CDatabase::_CloseNotificationWindow");

    // Kill the Window
    DestroyWindow(pRecipient->hwndNotify);

    // Null it Count
    pRecipient->hwndNotify = NULL;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_FindClient
//--------------------------------------------------------------------------
HRESULT CDatabase::_FindClient(DWORD dwProcessId, DWORD_PTR dwDB, 
    LPDWORD piClient,  LPCLIENTENTRY *ppClient)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;

    // Trace
    TraceCall("CDatabase::_FindThisClient");

    // Find myself in the client list
    for (iClient=0; iClient<m_pShare->cClients; iClient++)
    {
        // Readability
        pClient = &m_pShare->rgClient[iClient];

        // Is this me ?
        if (dwProcessId == pClient->dwProcessId && dwDB == pClient->pDB)
        {
            *piClient = iClient;
            *ppClient = pClient;
            goto exit;
        }
    }

    // Not Found
    hr = TraceResult(DB_E_NOTFOUND);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FindNotifyRecipient
//--------------------------------------------------------------------------
HRESULT CDatabase::_FindNotifyRecipient(DWORD iClient, IDatabaseNotify *pNotify,
    LPDWORD piRecipient,  LPNOTIFYRECIPIENT *ppRecipient)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;

    // Trace
    TraceCall("CDatabase::_FindNotifyRecipient");

    // Readability
    pClient = &m_pShare->rgClient[iClient];

    // Walk through client's registered notification entries
    for (iRecipient = 0; iRecipient < m_pShare->rgClient[iClient].cRecipients; iRecipient++)
    {
        // Readability
        pRecipient = &pClient->rgRecipient[iRecipient];

        // Is this me ?
        if ((DWORD_PTR)pNotify == pRecipient->pNotify)
        {
            // This is It
            *piRecipient = iRecipient;
            *ppRecipient = pRecipient;
            goto exit;
        }
    }

    // Not Found
    hr = DB_E_NOTFOUND;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DispatchPendingNotifications
//--------------------------------------------------------------------------
HRESULT CDatabase::_DispatchPendingNotifications(void)
{
    // Are there pending notifications
    if (m_pShare->faTransactLockHead)
    {
        // Dispatch Invoke
        _DispatchNotification((HTRANSACTION)IntToPtr(m_pShare->faTransactLockHead));

        // Null It Out
        m_pShare->faTransactLockTail = m_pShare->faTransactLockHead = 0;
    }

    // Otherwise, validate
    else
    {
        // Tail must be Null
        Assert(0 == m_pShare->faTransactLockTail);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::DispatchNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::DispatchNotify(IDatabaseNotify *pNotify)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    HLOCK               hLock=NULL;
    MSG                 msg;

    // Trace
    TraceCall("CDatabase::DispatchNotify");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // Find this recipient
    IF_FAILEXIT(hr = _FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient));

    // Need to dish out pending notifications....
    _DispatchPendingNotifications();

    // Processing the Pending Notifications for this recipient...
    if (pRecipient->dwThreadId != GetCurrentThreadId())
    {
        Assert(FALSE);
        hr = TraceResult(DB_E_WRONGTHREAD);
        goto exit;
    }

    // Pump Messages
    while (PeekMessage(&msg, pRecipient->hwndNotify, WM_ONTRANSACTION, WM_ONTRANSACTION, PM_REMOVE))
    {
        // Translate the Message
        TranslateMessage(&msg);

        // Dispatch the Message
        DispatchMessage(&msg);
    }

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::SuspendNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::SuspendNotify(IDatabaseNotify *pNotify)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    HLOCK               hLock=NULL;
    MSG                 msg;

    // Trace
    TraceCall("CDatabase::SuspendNotify");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // Find this recipient
    IF_FAILEXIT(hr = _FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient));

    // If Not Suspended yet
    if (pRecipient->fSuspended)
        goto exit;

    // Need to dish out pending notifications....
    _DispatchPendingNotifications();

    // Processing the Pending Notifications for this recipient...
    if (pRecipient->dwThreadId == GetCurrentThreadId())
    {
        // Pump Messages
        while (PeekMessage(&msg, pRecipient->hwndNotify, WM_ONTRANSACTION, WM_ONTRANSACTION, PM_REMOVE))
        {
            // Translate the Message
            TranslateMessage(&msg);

            // Dispatch the Message
            DispatchMessage(&msg);
        }
    }

    // Otherwise, can't pump out pending notifications...
    else
        Assert(FALSE);

    // Set Suspended
    pRecipient->fSuspended = TRUE;

    // Adjust Notify Counts
    _AdjustNotifyCounts(pRecipient, -1);

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::ResumeNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::ResumeNotify(IDatabaseNotify *pNotify)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    HLOCK               hLock=NULL;

    // Trace
    TraceCall("CDatabase::ResumeNotify");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // Find this recipient
    IF_FAILEXIT(hr = _FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient));

    // If Not Suspended yet
    if (FALSE == pRecipient->fSuspended)
        goto exit;

    // Need to dish out pending notifications....
    _DispatchPendingNotifications();

    // Remove fSuspended
    pRecipient->fSuspended = FALSE;

    // Adjust Notify Counts
    _AdjustNotifyCounts(pRecipient, 1);

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AdjustNotifyCounts
//--------------------------------------------------------------------------
HRESULT CDatabase::_AdjustNotifyCounts(LPNOTIFYRECIPIENT pRecipient, 
    LONG lChange)
{
    // Trace
    TraceCall("CDatabase::_AdjustNotifyCounts");

    // Ordinals Only
    if (pRecipient->fOrdinalsOnly)
    {
        // Validate the Count
        Assert((LONG)(m_pShare->cNotifyOrdinalsOnly + lChange) >= 0);

        // Update Ordinals Only Count
        m_pShare->cNotifyOrdinalsOnly += lChange;
    }

    // Otherwise, update notify with data count
    else
    {
        // Validate the Count
        Assert((LONG)(m_pShare->cNotifyWithData + lChange) >= 0);

        // Update
        m_pShare->cNotifyWithData += lChange;
    }

    // Validate the Count
    Assert((LONG)(m_pShare->cNotify + lChange) >= 0);

    // Update Total cNotify
    m_pShare->cNotify += lChange;

    // Validate the Count
    Assert((LONG)(m_pShare->rgcIndexNotify[pRecipient->iIndex] + lChange) >= 0);

    // Decrement Number of Recipients for Index
    m_pShare->rgcIndexNotify[pRecipient->iIndex] += lChange;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::UnregisterNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::UnregisterNotify(IDatabaseNotify *pNotify)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;

    // Trace
    TraceCall("CDatabase::UnregisterNotify");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // Find this recipient
    hr = _FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto exit;
    }

    // Remove and messages from the notificaton queue
    _CloseNotificationWindow(pRecipient);

    // Release ?
    if (TRUE == pRecipient->fRelease)
    {
        // Cast to pRecipient
        pNotify->Release();
    }

    // If Not Suspended
    if (FALSE == pRecipient->fSuspended)
    {
        // _AdjustNotifyCounts
        _AdjustNotifyCounts(pRecipient, -1);
    }

    // Remove MySelf
    MoveMemory(&pClient->rgRecipient[iRecipient], &pClient->rgRecipient[iRecipient + 1], sizeof(NOTIFYRECIPIENT) * (pClient->cRecipients - (iRecipient + 1)));

    // Decrement Client Count
	pClient->cRecipients--;

exit:
    // Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::RegisterNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::RegisterNotify(INDEXORDINAL iIndex,
    REGISTERNOTIFYFLAGS dwFlags, DWORD_PTR dwCookie, 
    IDatabaseNotify *pNotify)

{
    // Locals
    HRESULT             hr=S_OK;
    LPCLIENTENTRY       pClient;
    DWORD               iClient;
    DWORD               iRecipient;
    LPNOTIFYRECIPIENT   pRecipient;
    HLOCK               hLock=NULL;

    // Trace
    TraceCall("CDatabase::RegisterNotify");

    // Invalid Args
    if (NULL == pNotify || iIndex > CMAX_INDEXES)
        return TraceResult(E_INVALIDARG);

    // If Deconstructing, just return
    if (m_fDeconstruct)
        return(S_OK);

    // Thread Safety
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find this Client
    IF_FAILEXIT(hr = _FindClient(m_dwProcessId, (DWORD_PTR)this, &iClient, &pClient));

    // See if this client is already registered...
    if (SUCCEEDED(_FindNotifyRecipient(iClient, pNotify, &iRecipient, &pRecipient)))
    {
        hr = TraceResult(DB_E_ALREADYREGISTERED);
        goto exit;
    }

    // Need to dish out pending notifications....
    _DispatchPendingNotifications();

    // Room for one more
    if (pClient->cRecipients + 1 >= CMAX_RECIPIENTS)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Readability
    pRecipient = &pClient->rgRecipient[pClient->cRecipients];

    // Store the ThreadId
    pRecipient->dwThreadId = GetCurrentThreadId();

    // Save the Cookie
    pRecipient->dwCookie = dwCookie;

    // Get a Thunking Window for that thread
    IF_FAILEXIT(hr = CreateNotifyWindow(this, pNotify, &pRecipient->hwndNotify));

    // Only addref if the client wants me to
    if (!ISFLAGSET(dwFlags, REGISTER_NOTIFY_NOADDREF))
    {
        // AddRef the notification object
        pNotify->AddRef();

        // Release it
        pRecipient->fRelease = TRUE;
    }

    // Register It
    pRecipient->pNotify = (DWORD_PTR)pNotify;

    // Save the Index that they are intereseted in
    pRecipient->iIndex = iIndex;

    // Increment Notify Count
    pClient->cRecipients++;

    // Ordinals Only
    pRecipient->fOrdinalsOnly = (ISFLAGSET(dwFlags, REGISTER_NOTIFY_ORDINALSONLY) ? TRUE : FALSE);

    // _AdjustNotifyCounts
    _AdjustNotifyCounts(pRecipient, 1);

exit:
    // Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_SetStorageSize
//--------------------------------------------------------------------------
HRESULT CDatabase::_SetStorageSize(DWORD cbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrCreate;

    // Trace
    TraceCall("CDatabase::_SetStorageSize");

    // Only if sizes are different
    if (cbSize == m_pStorage->cbFile)
        return(S_OK);

    // Do It
    _DispatchInvoke(INVOKE_RELEASEMAP);

    // Set the File Pointer
    if (0xFFFFFFFF == SetFilePointer(m_pStorage->hFile, cbSize, NULL, FILE_BEGIN))
    {
        hr = TraceResult(DB_E_SETFILEPOINTER);
        goto exit;
    }

    // Set End of file
    if (0 == SetEndOfFile(m_pStorage->hFile))
    {
        // Get LastError
        DWORD dwLastError = GetLastError();

        // Access Denied ?
        if (ERROR_ACCESS_DENIED == dwLastError)
        {
            hr = TraceResult(DB_E_ACCESSDENIED);
            goto exit;
        }

        // Otherwise, assume disk is full
        else
        {
            hr = TraceResult(DB_E_DISKFULL);
            goto exit;
        }
    }

exit:
    // Do It
    hrCreate = _DispatchInvoke(INVOKE_CREATEMAP);

    // Done
    return(SUCCEEDED(hr) ? hrCreate : hr);
}

//--------------------------------------------------------------------------
// CDatabase::SetSize
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::SetSize(DWORD cbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::SetSize");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Size can only be larger than my current size
    if (cbSize < m_pStorage->cbFile)
        goto exit;

    // If the size of the file is currently zero...
    IF_FAILEXIT(hr = _SetStorageSize(cbSize));

exit:
    // Invalid Args
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AllocatePage
//--------------------------------------------------------------------------
HRESULT CDatabase::_AllocatePage(DWORD cbPage, LPFILEADDRESS pfaAddress)
{
    // Locals
    HRESULT hr=S_OK;

    // Trace
    TraceCall("CDatabase::_AllocatePage");

    // Quick Validation
    Assert(m_pHeader->faNextAllocate && m_pHeader->faNextAllocate <= m_pStorage->cbFile);

    // Need to grow the file ?
    if (m_pStorage->cbFile - m_pHeader->faNextAllocate < cbPage)
    {
        // Compute cbNeeded
        DWORD cbNeeded = cbPage - (m_pStorage->cbFile - m_pHeader->faNextAllocate);

        // Grow in at least 64k chunks.
        cbNeeded = max(cbNeeded, 65536);

        // If the size of the file is currently zero...
        IF_FAILEXIT(hr = _SetStorageSize(m_pStorage->cbFile + cbNeeded));
    }

    // Return this address
    *pfaAddress = m_pHeader->faNextAllocate;

    // Adjust faNextAllocate
    m_pHeader->faNextAllocate += cbPage;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_MarkBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_MarkBlock(BLOCKTYPE tyBlock, FILEADDRESS faBlock,
    DWORD cbBlock, LPVOID *ppvBlock)
{
    // Locals
    HRESULT         hr=S_OK;
    MARKBLOCK       Mark;
    LPBLOCKHEADER   pBlock;

    // Trace
    TraceCall("CDatabase::_MarkBlock");

    // Validate
    Assert(cbBlock >= g_rgcbBlockSize[tyBlock]);

    // Set Mark
    Mark.cbBlock = cbBlock;

    // De-Ref the Header
    IF_FAILEXIT(hr = _GetBlock(tyBlock, faBlock, (LPVOID *)&pBlock, &Mark));

    // Zero the Header
    ZeroBlock(pBlock, g_rgcbBlockSize[tyBlock]);

    // Return ppvBlock
    if (ppvBlock)
        *ppvBlock = (LPVOID)pBlock;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AllocateFromPage
//--------------------------------------------------------------------------
HRESULT CDatabase::_AllocateFromPage(BLOCKTYPE tyBlock, LPALLOCATEPAGE pPage,
    DWORD cbPage, DWORD cbBlock, LPVOID *ppvBlock)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cbLeft;
    FILEADDRESS faBlock;
    DWORD       iBucket;

    // Trace
    TraceCall("CDatabase::_AllocateFromPage");

    // Is Page Valid ?
    if (pPage->faPage + pPage->cbPage > m_pStorage->cbFile)
    {
        // Kill the page
        ZeroMemory(pPage, sizeof(ALLOCATEPAGE));
    }

    // Otherwise
    else
    {
        // Compute cbLeft
        cbLeft = pPage->cbPage - pPage->cbUsed;
    }

    // Requesting a large block
    if (cbBlock > cbPage || (cbLeft > 0 && cbLeft < cbBlock && cbLeft >= CB_MAX_FREE_BUCKET))
    {
        // Allocate space in the file
        IF_FAILEXIT(hr = _AllocatePage(cbBlock, &faBlock));

        // Mark the block
        IF_FAILEXIT(hr = _MarkBlock(tyBlock, faBlock, cbBlock, ppvBlock));
    }

    // Invalid Page ?
    else 
    {
        // Block is too small...
        if (cbLeft > 0 && cbLeft < cbBlock)
        {
            // Must be a BLOCK_RECORD
            Assert(BLOCK_STREAM != tyBlock && BLOCK_CHAIN != tyBlock);

            // Better fit into block
            Assert(cbLeft <= CB_MAX_FREE_BUCKET && cbLeft >= CB_MIN_FREE_BUCKET && (cbLeft % 4) == 0);

            // Mark the block
            IF_FAILEXIT(hr = _MarkBlock(BLOCK_ENDOFPAGE, (pPage->faPage + pPage->cbUsed), cbLeft, NULL));

            // Increment cbAllocated
            m_pHeader->cbAllocated += cbLeft;

            // Increment
            m_pHeader->rgcbAllocated[BLOCK_ENDOFPAGE] += cbLeft;

            // Lets Free This block
            IF_FAILEXIT(hr = _FreeBlock(BLOCK_ENDOFPAGE, (pPage->faPage + pPage->cbUsed)));

            // Nothgin Left
            cbLeft = 0;
        }

        // Use the entire page
        else if (cbLeft != cbBlock && cbLeft - cbBlock < CB_MIN_FREE_BUCKET)
        {
            // Must be a BLOCK_RECORD
            Assert(BLOCK_STREAM != tyBlock && BLOCK_CHAIN != tyBlock);
            
            // Adjust cbBlock
            cbBlock += (cbLeft - cbBlock);
        }

        // Need to allocate a page
        if (0 == pPage->faPage || 0 == cbLeft)
        {
            // Kill the page
            ZeroMemory(pPage, sizeof(ALLOCATEPAGE));

            // Allocate space in the file
            IF_FAILEXIT(hr = _AllocatePage(cbPage, &pPage->faPage));

            // Set cbChainPageLeft
            pPage->cbPage = cbPage;
        }

        // Mark the block
        IF_FAILEXIT(hr = _MarkBlock(tyBlock, (pPage->faPage + pPage->cbUsed), cbBlock, ppvBlock));

        // Set Next Allocation
        pPage->cbUsed += cbBlock;

        // Validate
        Assert(pPage->cbUsed <= pPage->cbPage);
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_SetCorrupt
//--------------------------------------------------------------------------
HRESULT CDatabase::_SetCorrupt(BOOL fGoCorrupt, INT nLine, 
    CORRUPTREASON tyReason, BLOCKTYPE tyBlock, FILEADDRESS faExpected, 
    FILEADDRESS faActual, DWORD cbBlock)
{
    // Trace
    TraceCall("CDatabase::_SetCorrupt");

    // Go Corrupt
    if (fGoCorrupt)
    {
        // Store it in the header
        m_pHeader->fCorrupt = TRUE;
    }

    // Done - This is always return to get the calling operation to abort
    return(DB_E_CORRUPT);
}

//--------------------------------------------------------------------------
// CDatabase::_AllocateSpecialView
//--------------------------------------------------------------------------
HRESULT CDatabase::_AllocateSpecialView(FILEADDRESS faView, 
    DWORD cbView, LPFILEVIEW *ppSpecial)
{
    // Locals
    HRESULT     hr=S_OK;
    LPFILEVIEW  pView=NULL;

    // Trace
    TraceCall("CDatabase::_AllocateSpecialView");

    // Try to find existing special view where faView / cbView fits...
    for (pView = m_pStorage->pSpecial; pView != NULL; pView = pView->pNext)
    {
        // Fit into this view ?
        if (faView >= pView->faView && faView + cbView <= pView->faView + pView->cbView)
        {
            // This is good...
            *ppSpecial = pView;

            // Don't Freep
            pView = NULL;

            // Done
            goto exit;
        }
    }

    // Create a Special View
    IF_NULLEXIT(pView = (LPFILEVIEW)PHeapAllocate(0, sizeof(FILEVIEW)));

    // Set faView
    pView->faView = faView;

    // Set cbView
    pView->cbView = cbView;

    // Map the View
    IF_FAILEXIT(hr = DBMapViewOfFile(m_pStorage->hMap, m_pStorage->cbFile, &pView->faView, &pView->cbView, (LPVOID *)&pView->pbView));

    // Increment Statistic
    m_pStorage->cSpecial++;

    // Increment cbMappedSpecial
    m_pStorage->cbMappedSpecial += pView->cbView;

    // Link pView into Special List
    pView->pNext = m_pStorage->pSpecial;

    // Set pSpecial
    m_pStorage->pSpecial = pView;

    // Set Return
    *ppSpecial = pView;

    // Don't Free It
    pView = NULL;

exit:
    // Cleanup
    SafeHeapFree(pView);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetBlock(BLOCKTYPE tyExpected, FILEADDRESS faBlock,
    LPVOID *ppvBlock, LPMARKBLOCK pMark /* =NULL */, BOOL fGoCorrupt /* TRUE */)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           iViewStart;
    DWORD           iViewEnd;
    LPFILEVIEW      pView;
    DWORD           cbBlock;
    LPBLOCKHEADER   pBlock;
    LPFILEVIEW      pSpecial=NULL;

    // Trace
    TraceCall("CDatabase::_CheckBlock");

    // Invalid Args
    IxpAssert(faBlock > 0 && ppvBlock);

    // Storage is Setup ?
    IxpAssert(m_pStorage->hMap && m_pStorage->prgView);

    // faBlock is Out-of-Range
    if (faBlock + sizeof(BLOCKHEADER) >= m_pStorage->cbFile)
    {
        hr = _SetCorrupt(fGoCorrupt, __LINE__, REASON_BLOCKSTARTOUTOFRANGE, tyExpected, faBlock, 0xFFFFFFFF, 0xFFFFFFFF);
        goto exit;
    }

    // Determine iView
    iViewStart = (faBlock / CB_MAPPED_VIEW);

    // Set iViewend
    iViewEnd = (faBlock + sizeof(BLOCKHEADER)) / CB_MAPPED_VIEW;

    // If the Header Straddles a view boundary...
    if (iViewStart != iViewEnd)
    {
        // Allocate a Special View
        IF_FAILEXIT(hr = _AllocateSpecialView(faBlock, g_SystemInfo.dwAllocationGranularity, &pSpecial));

        // Set pView
        pView = pSpecial;
    }

    // Otherwise, use a view
    else
    {
        // Validate iView
        IxpAssert(iViewStart < m_pStorage->cAllocated);

        // Readability
        pView = &m_pStorage->prgView[iViewStart];

        // Is this View Mapped yet ?
        if (NULL == pView->pbView)
        {
            // Validate the Entry
            IxpAssert(0 == pView->faView && 0 == pView->cbView && NULL == pView->pNext);

            // Set faView
            pView->faView = (iViewStart * CB_MAPPED_VIEW);

            // Set cbView
            pView->cbView = min(m_pStorage->cbFile - pView->faView, CB_MAPPED_VIEW);

            // Map the View
            IF_FAILEXIT(hr = DBMapViewOfFile(m_pStorage->hMap, m_pStorage->cbFile, &pView->faView, &pView->cbView, (LPVOID *)&pView->pbView));

            // Increment cbMappedSpecial
            m_pStorage->cbMappedViews += pView->cbView;
        }
    }

    // De-Ref the Block (Offset from start of the view)
    pBlock = (LPBLOCKHEADER)(pView->pbView + (faBlock - pView->faView));

    // Mark the block
    if (pMark)
    {
        // Set the Address
        pBlock->faBlock = faBlock;

        // Set cbBlock
        cbBlock = pMark->cbBlock;

        // Adjust cbSize
        pBlock->cbSize = cbBlock - g_rgcbBlockSize[tyExpected];
    }

    // Otherwise, validate the block
    else 
    {
        // Get Block Size
        cbBlock = pBlock->cbSize + g_rgcbBlockSize[tyExpected];

        // Check the Block Start Address
        if (faBlock != pBlock->faBlock)
        {
            hr = _SetCorrupt(fGoCorrupt, __LINE__, REASON_UMATCHINGBLOCKADDRESS, tyExpected, faBlock, pBlock->faBlock, cbBlock);
            goto exit;
        }

        // Size of Block is Out-of-range
        if (pBlock->faBlock + cbBlock > m_pStorage->cbFile)
        {
            hr = _SetCorrupt(fGoCorrupt, __LINE__, REASON_BLOCKSIZEOUTOFRANGE, tyExpected, faBlock, pBlock->faBlock, cbBlock);
            goto exit;
        }
    }

    // Compute iViewEnd
    iViewEnd = ((faBlock + cbBlock) / CB_MAPPED_VIEW);

    // Does this block end within the same view, or is the block larger than my view size ?
    if (iViewStart != iViewEnd)
    {
        // If I already allocated a special view...
        if (pSpecial)
        {
            // Validate
            IxpAssert(pView == pSpecial);

            // Does faBlock + cbBlock fit into pSpecial ?
            if ((faBlock - pView->faView) + cbBlock > pView->cbView)
            {
                // Validate
                IxpAssert(pView->pbView);

                // Lets Flush It
                FlushViewOfFile(pView->pbView, 0);

                // Unmap this view
                SafeUnmapViewOfFile(pView->pbView);

                // Decrement cbMappedSpecial
                m_pStorage->cbMappedSpecial -= pView->cbView;

                // Set faView
                pView->faView = faBlock;

                // Set cbView
                pView->cbView = cbBlock;

                // Map the View
                IF_FAILEXIT(hr = DBMapViewOfFile(m_pStorage->hMap, m_pStorage->cbFile, &pView->faView, &pView->cbView, (LPVOID *)&pView->pbView));

                // Increment cbMappedSpecial
                m_pStorage->cbMappedSpecial += pView->cbView;
            }
        }

        // Otherwise, create a special view
        else
        {
            // Allocate a Special View
            IF_FAILEXIT(hr = _AllocateSpecialView(faBlock, cbBlock, &pSpecial));

            // Set pView
            pView = pSpecial;
        }
    }

    // Validate
    IxpAssert((faBlock - pView->faView) + cbBlock <= pView->cbView);

    // Return the Block (offset from start of block)
    *ppvBlock = (LPVOID)(pView->pbView + (faBlock - pView->faView));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ReuseFixedFreeBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_ReuseFixedFreeBlock(LPFILEADDRESS pfaFreeHead, 
    BLOCKTYPE tyBlock, DWORD cbExpected, LPVOID *ppvBlock)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faHead=(*pfaFreeHead);
    DWORD           cbBlock;
    LPFREEBLOCK     pFree;

    // Is there a free block
    if (0 == faHead)
        return(S_OK);

    // Get the Free Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_FREE, faHead, (LPVOID *)&pFree));

    // Validate
    Assert(cbExpected == pFree->cbBlock);

    // Set *ppHeader
    *ppvBlock = (LPVOID)pFree;

    // Set the New Head Free Chain Block
    *pfaFreeHead = pFree->faNext;

    // Change the Size
    pFree->cbSize = cbExpected - g_rgcbBlockSize[tyBlock];

    // Mark the Block
    *ppvBlock = (LPVOID)pFree;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AllocateBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_AllocateBlock(BLOCKTYPE tyBlock, DWORD cbExtra,
    LPVOID *ppvBlock)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBlock;
    DWORD           iBucket;

    // Trace
    TraceCall("CDatabase::_AllocateBlock");

    // Invalid State
    Assert(ppvBlock && BLOCK_ENDOFPAGE != tyBlock && BLOCK_FREE != tyBlock);

    // Initialize
    *ppvBlock = NULL;

    // Add Space Needed to store tyBlock
    cbBlock = (g_rgcbBlockSize[tyBlock] + cbExtra);

    // Dword Align
    cbBlock += DwordAlign(cbBlock);

    // Allocating a Chain Block ?
    if (BLOCK_CHAIN == tyBlock)
    {
        // Reuse Free Block...
        IF_FAILEXIT(hr = _ReuseFixedFreeBlock(&m_pHeader->faFreeChainBlock, BLOCK_CHAIN, cbBlock, ppvBlock));
    }

    // Allocating a Stream Block ?
    else if (BLOCK_STREAM == tyBlock)
    {
        // Append Stream Block Size
        cbBlock += CB_STREAM_BLOCK;

        // Reuse Free Block...
        IF_FAILEXIT(hr = _ReuseFixedFreeBlock(&m_pHeader->faFreeStreamBlock, BLOCK_STREAM, cbBlock, ppvBlock));
    }

    // Otherwise, allocating a record block
    else if (cbBlock <= CB_MAX_FREE_BUCKET)
    {
        // Adjust cbBlock
        if (cbBlock < CB_MIN_FREE_BUCKET)
            cbBlock = CB_MIN_FREE_BUCKET;

        // Compute Free Block Bucket
        iBucket = ((cbBlock - CB_MIN_FREE_BUCKET) / CB_FREE_BUCKET);

        // Validate
        Assert(iBucket < CC_FREE_BUCKETS);

        // Is there a Free Block in this bucket
        if (m_pHeader->rgfaFreeBlock[iBucket])
        {
            // PopFreeBlock
            _ReuseFixedFreeBlock(&m_pHeader->rgfaFreeBlock[iBucket], tyBlock, cbBlock, ppvBlock);
        }
    }

    // Otherwise
    else
    {
        // Locals
        FILEADDRESS     faCurrent;
        LPFREEBLOCK     pCurrent;
        LPFREEBLOCK     pPrevious=NULL;

        // Adjust cbBlock to the next 1k Boundary
        cbBlock = (((cbBlock / CB_ALIGN_LARGE) + 1) * CB_ALIGN_LARGE);

        // Set faCurrent
        faCurrent = m_pHeader->faFreeLargeBlock;

        // Loop through free large blocks (Sorted from smallest to largest)
        while (faCurrent)
        {
            // Get the Current Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_FREE, faCurrent, (LPVOID *)&pCurrent));

            // If this block is too small...
            if (cbBlock <= pCurrent->cbBlock)
            {
                // Set Next Free Chain Address
                if (NULL == pPrevious)
                {
                    // Set First Free Chain
                    m_pHeader->faFreeLargeBlock = pCurrent->faNext;
                }

                // Otherwise, relink free chains
                else
                {
                    // Set the next block
                    pPrevious->faNext = pCurrent->faNext;
                }

                // Reset the Block Types
                IF_FAILEXIT(hr = _MarkBlock(tyBlock, faCurrent, cbBlock, ppvBlock));

                // Done
                break;
            }

            // Save Previous
            pPrevious = pCurrent;

            // Set Current
            faCurrent = pCurrent->faNext;
        }
    }

    // Didn't find a block to allocate
    if (0 == *ppvBlock)
    {
        // Is there a page with some space on it...
        if (BLOCK_CHAIN == tyBlock)
        {
            // Allocate From Page
            ALLOCATEPAGE AllocatePage=m_pHeader->AllocateChain;

            // Allocate From Page
            IF_FAILEXIT(hr = _AllocateFromPage(BLOCK_CHAIN, &AllocatePage, CB_CHAIN_PAGE, cbBlock, ppvBlock));

            // Restore the page info
            m_pHeader->AllocateChain = AllocatePage;
        }

        // Stream Block
        else if (BLOCK_STREAM == tyBlock)
        {
            // Allocate From Page
            ALLOCATEPAGE AllocatePage=m_pHeader->AllocateStream;

            // Allocate From Page
            IF_FAILEXIT(hr = _AllocateFromPage(BLOCK_STREAM, &AllocatePage, CB_STREAM_PAGE, cbBlock, ppvBlock));

            // Restore the page info
            m_pHeader->AllocateStream = AllocatePage;
        }

        // Record Block
        else
        {
            // Allocate From Page
            ALLOCATEPAGE AllocatePage=m_pHeader->AllocateRecord;

            // Allocate From Page
            IF_FAILEXIT(hr = _AllocateFromPage(tyBlock, &AllocatePage, CB_VARIABLE_PAGE, cbBlock, ppvBlock));

            // Restore the page info
            m_pHeader->AllocateRecord = AllocatePage;
        }

        // Metrics
        m_pHeader->cbAllocated += cbBlock;
    }

    // Otherwise
    else
    {
        // Metrics
        m_pHeader->cbFreed -= cbBlock;
    }

    // Increment
    m_pHeader->rgcbAllocated[tyBlock] += cbBlock;

exit:
    // We should have found something
    Assert(SUCCEEDED(hr) ? *ppvBlock > 0 : TRUE);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeBlock(BLOCKTYPE tyBlock, FILEADDRESS faAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           iBucket;
    DWORD           cbBlock;
    LPFREEBLOCK     pFree;

    // Trace
    TraceCall("CDatabase::_FreeBlock");

    // Invalid Args
    Assert(BLOCK_FREE != tyBlock);

    // Never Free faAddress 0?
    if (0 == faAddress)
    {
        Assert(FALSE);
        hr = TraceResult(E_FAIL);
        goto exit;
    }

#ifdef DEBUG
#ifdef FREBLOCK_VALIDATION
    if (BLOCK_RECORD == tyBlock)
        _DebugValidateUnrefedRecord(faAddress);
#endif // FREBLOCK_VALIDATION
#endif // DEBUG

    // Get the Block
    IF_FAILEXIT(hr = _GetBlock(tyBlock, faAddress, (LPVOID *)&pFree));

    // Save Block Size
    cbBlock = pFree->cbSize + g_rgcbBlockSize[tyBlock];

    // Mark Block as Free
    pFree->cbSize = cbBlock - g_rgcbBlockSize[BLOCK_FREE];

    // Set Block Size
    pFree->cbBlock = cbBlock;

    // Initialize
    pFree->faNext = 0;

    // BLOCK_CHAIN
    if (BLOCK_CHAIN == tyBlock)
    {
        // Fill free node header
        pFree->faNext = m_pHeader->faFreeChainBlock;

        // Set new iFreeChain
        m_pHeader->faFreeChainBlock = pFree->faBlock;
    }

    // BLOCK_STREAM
    else if (BLOCK_STREAM == tyBlock)
    {
        // Fill free node header
        pFree->faNext = m_pHeader->faFreeStreamBlock;

        // Set new iFreeChain
        m_pHeader->faFreeStreamBlock = pFree->faBlock;
    }

    // Other types of variable length blocks
    else if (pFree->cbBlock <= CB_MAX_FREE_BUCKET)
    {
        // Validate
        Assert(pFree->cbBlock >= CB_MIN_FREE_BUCKET && (pFree->cbBlock % 4) == 0);

        // Compute Free Block Bucket
        iBucket = ((pFree->cbBlock - CB_MIN_FREE_BUCKET) / CB_FREE_BUCKET);

        // Fill free node header
        pFree->faNext = m_pHeader->rgfaFreeBlock[iBucket];

        // Set new iFreeChain
        m_pHeader->rgfaFreeBlock[iBucket] = pFree->faBlock;
    }

    // Otherwise, freeing a large block
    else
    {
        // Must be an integral size of a a large block
        Assert((pFree->cbBlock % CB_ALIGN_LARGE) == 0);

        // If there are no blocks yet
        if (0 == m_pHeader->faFreeLargeBlock)
        {
            // Set the Head
            m_pHeader->faFreeLargeBlock = pFree->faBlock;
        }

        // Otherwise, link into the sorted list
        else
        {
            // Put this block in sorted order from smallest to the largest...
            FILEADDRESS     faCurrent;
            LPFREEBLOCK     pCurrent;
            LPFREEBLOCK     pPrevious=NULL;

            // Set faCurrent
            faCurrent = m_pHeader->faFreeLargeBlock;

            // Loop through free large blocks (Sorted from smallest to largest)
            while (faCurrent)
            {
                // Get the Current Block
                IF_FAILEXIT(hr = _GetBlock(BLOCK_FREE, faCurrent, (LPVOID *)&pCurrent));

                // If pBlock is less than pCurrent, then insert after pPreviuos but before pCurrent
                if (pFree->cbBlock <= pCurrent->cbBlock)
                {
                    // Previous
                    if (pPrevious)
                    {
                        // Validate
                        Assert(pPrevious->faNext == faCurrent);

                        // Set Next
                        pPrevious->faNext = pFree->faBlock;
                    }

                    // Otherwise, adjust the head
                    else
                    {
                        // Validate
                        Assert(m_pHeader->faFreeLargeBlock == faCurrent);

                        // Set the Head
                        m_pHeader->faFreeLargeBlock = pFree->faBlock;
                    }

                    // Set pBlock Next
                    pFree->faNext = faCurrent;

                    // Done
                    break;
                }

                // Next Block is Null ?
                else if (0 == pCurrent->faNext)
                {
                    // Append to the End
                    pCurrent->faNext = pFree->faBlock;

                    // Done
                    break;
                }

                // Save Previous
                pPrevious = pCurrent;

                // Set Current
                faCurrent = pCurrent->faNext;
            }
        }
    }

    // Increment
    m_pHeader->rgcbAllocated[tyBlock] -= pFree->cbBlock;

    // Metrics
    m_pHeader->cbFreed += pFree->cbBlock;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetSize
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetSize(LPDWORD pcbFile, LPDWORD pcbAllocated, 
    LPDWORD pcbFreed, LPDWORD pcbStreams)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::GetSize");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Return pcbFile
    if (pcbFile)
        *pcbFile = m_pStorage->cbFile;

    // Return pcbAllocated
    if (pcbAllocated)
        *pcbAllocated = m_pHeader->cbAllocated;

    // Return pcbFreed
    if (pcbFreed)
        *pcbFreed = (m_pHeader->cbFreed + (m_pStorage->cbFile - m_pHeader->faNextAllocate));

    // Return pcbStreams
    if (pcbStreams)
        *pcbStreams = m_pHeader->rgcbAllocated[BLOCK_STREAM];

exit:
    // Unlock the Heap
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetRecordCount
//--------------------------------------------------------------------------
HRESULT CDatabase::GetRecordCount(INDEXORDINAL iIndex, ULONG *pcRecords)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // TraceCall
    TraceCall("CDatabase::GetRecordCount");

    // Invalid Args
    Assert(pcRecords && iIndex < CMAX_INDEXES);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Return the Count
    *pcRecords = m_pHeader->rgcRecords[iIndex];

exit:
    // Unlock the Heap
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::UpdateRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::UpdateRecord(LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrVisible;
    INT             nCompare;
    DWORD           i;
    INDEXORDINAL    iIndex;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    ROWORDINAL      iRow;
    FILEADDRESS     faOldRecord=0;
    FILEADDRESS     faNewRecord=0;
    BYTE            bVersion;
    LPVOID          pBindingOld=NULL;
    LPRECORDBLOCK   pRecord;
    ORDINALLIST     Ordinals;
    LPCHAINBLOCK    pChain;
    RECORDMAP       RecordMap;
    HLOCK           hLock=NULL;
    DWORD           cNotify=0;
    FINDRESULT      rgResult[CMAX_INDEXES];

    // Trace
    TraceCall("CDatabase::UpdateRecord");

    // Invalid Args
    Assert(pBinding);

    // Initialize Ordinals (Initializes everything to INVALID_ROWORDINAL)
    FillMemory(&Ordinals, sizeof(ORDINALLIST), 0xFF);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Primary Index Can not change
    rgResult[0].fChanged = FALSE;

    // Try to find the existing record
    IF_FAILEXIT(hr = _FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, pBinding, &rgResult[0].faChain, &rgResult[0].iNode, &Ordinals.rgiRecord1[IINDEX_PRIMARY]));

    // If not found, you can't update it. Use Insert
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Primary Index Can not change
    rgResult[0].fFound = TRUE;

    // Cast pChain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, rgResult[0].faChain, (LPVOID *)&pChain));

    // De-Reference the Record
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, pChain->rgNode[rgResult[0].iNode].faRecord, (LPVOID *)&pRecord));

    // Get the Version
    bVersion = *((BYTE *)((LPBYTE)pBinding + m_pSchema->ofVersion));

    // Version Difference ?
    if (pRecord->bVersion != bVersion)
    {
        hr = TraceResult(DB_E_RECORDVERSIONCHANGED);
        goto exit;
    }

    // More than one index ?
    if (m_pHeader->cIndexes > 1 || m_pExtension)
    {
        // Allocate a Binding
        IF_NULLEXIT(pBindingOld = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

        // Read the Record
        IF_FAILEXIT(hr = _ReadRecord(pRecord->faBlock, pBindingOld));
    }

    // Call Extension
    if (m_pExtension)
    {
        // Extend Record Updates
        m_pExtension->OnRecordUpdate(OPERATION_BEFORE, NULL, pBindingOld, pBinding);
    }

    // Loop through the indexes
    for (i = 1; i < m_pHeader->cIndexes; i++)
    {
        // Get iIndex
        iIndex = m_pHeader->rgiIndex[i];

        // Try to find the existing record
        IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBindingOld, &rgResult[i].faChain, &rgResult[i].iNode, &Ordinals.rgiRecord1[iIndex]));

        // If not found, you can't update it. Use Insert
        if (DB_S_FOUND == hr)
        {
            // We Found the Record
            rgResult[i].fFound = TRUE;

            // Did Record's Key Change for this Index ?
            IF_FAILEXIT(hr = _CompareBinding(iIndex, COLUMNS_ALL, pBinding, pRecord->faBlock, &nCompare));

            // Not the Same ?
            if (0 != nCompare)
            {
                // Changed
                rgResult[i].fChanged = TRUE;

                // Otherwise: Decide Where to insert
                IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &faChain, &iNode, &iRow));

                // If pBinding is already in this index, then its going to be a duplicate
                if (DB_S_FOUND == hr)
                {
                    hr = TraceResult(DB_E_DUPLICATE);
                    goto exit;
                }
            }

            // Otherwise, the index hasn't changed
            else
            {
                // Assume the Index is Unchanged
                rgResult[i].fChanged = FALSE;
            }
        }

        // Otherwise, not found
        else
        {
            // This Index Must be Filtered
            Assert(m_rghFilter[iIndex]);

            // Not Found
            rgResult[i].fFound = FALSE;

            // Changed
            rgResult[i].fChanged = TRUE;

            // First Record Never Existed
            Ordinals.rgiRecord1[iIndex] = INVALID_ROWORDINAL;

            // See if the new record already exists in this index
            IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &faChain, &iNode, &iRow));

            // If pBinding is already in this index, then its going to be a duplicate
            if (DB_S_FOUND == hr)
            {
                hr = TraceResult(DB_E_DUPLICATE);
                goto exit;
            }
        }
    }

    // Save the old node
    faOldRecord = pRecord->faBlock;

    // Get the Record Size
    IF_FAILEXIT(hr = _GetRecordSize(pBinding, &RecordMap));

    // Record Shrunk or stayed the same...?
    if (RecordMap.cbData + RecordMap.cbTags <= pRecord->cbSize && 0 == m_pShare->cNotifyWithData)
    {
        // Persist the Record
        IF_FAILEXIT(hr = _SaveRecord(pRecord, &RecordMap, pBinding));

        // Set faNewRecord
        faNewRecord = pRecord->faBlock;

        // Validate the Version
        Assert(bVersion + 1 == pRecord->bVersion || bVersion + 1 == 256);
    }

    // Otherwise, record grew in size
    else
    {
        // Don't Use This Again
        pRecord = NULL;

        // Link the new record into the table
        IF_FAILEXIT(hr = _LinkRecordIntoTable(&RecordMap, pBinding, bVersion, &faNewRecord));
    }

    // Update all the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Adjustment for filtered indexes
        hrVisible = _IsVisible(m_rghFilter[iIndex], pBinding);

        // Not Changed ?
        if (S_OK == hrVisible && FALSE == rgResult[i].fChanged && TRUE == rgResult[i].fFound)
        {
            // Record Changed Locations ?
            if (faOldRecord != faNewRecord)
            {
                // Just Update the Address of the New Record
                IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, rgResult[i].faChain, (LPVOID *)&pChain));

                // Update the Chain
                pChain->rgNode[rgResult[i].iNode].faRecord = faNewRecord;
            }

            // Ordinal is Unchanged
            Ordinals.rgiRecord2[iIndex] = Ordinals.rgiRecord1[iIndex];

            // If Index changed and somebody wanted notifications about this index
            cNotify += m_pShare->rgcIndexNotify[iIndex];
        }

        // Otherwise...
        else
        {
            // If the Record was found, delete it
            if (TRUE == rgResult[i].fFound)
            {
                // Delete the Record from the index
                IF_FAILEXIT(hr = _IndexDeleteRecord(iIndex, rgResult[i].faChain, rgResult[i].iNode));

                // Adjust Open Rowsets
                _AdjustOpenRowsets(iIndex, Ordinals.rgiRecord1[iIndex], OPERATION_DELETE);

                // Update Record Count
                m_pHeader->rgcRecords[iIndex]--;

                // If Index changed and somebody wanted notifications about this index
                cNotify += m_pShare->rgcIndexNotify[iIndex];
            }

            // Visible ?
            if (S_OK == hrVisible)
            {
                // Otherwise: Decide Where to insert
                IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &rgResult[i].faChain, &rgResult[i].iNode, &Ordinals.rgiRecord2[iIndex], &rgResult[i].nCompare));

                // Not Found
                Assert(DB_S_NOTFOUND == hr);

                // Do the Insertion
                IF_FAILEXIT(hr = _IndexInsertRecord(iIndex, rgResult[i].faChain, faNewRecord, &rgResult[i].iNode, rgResult[i].nCompare));

                // Update Record Count
                m_pHeader->rgcRecords[iIndex]++;

                // Adjust iRow
                Ordinals.rgiRecord2[iIndex] += (rgResult[i].iNode + 1);

                // Adjust Open Rowsets
                _AdjustOpenRowsets(iIndex, Ordinals.rgiRecord2[iIndex], OPERATION_INSERT);

                // If Index changed and somebody wanted notifications about this index
                cNotify += m_pShare->rgcIndexNotify[iIndex];
            }

            // Otherwise...
            else
            {
                // Doesn't Exist
                Ordinals.rgiRecord2[iIndex] = INVALID_ROWORDINAL;
            }
        }
    }

    // Send Notifications ?
    if (cNotify > 0)
    {
        // Send Notifications ?
        if (0 == m_pShare->cNotifyWithData)
        {
            // Build the Update Notification Package
            _LogTransaction(TRANSACTION_UPDATE, INVALID_INDEX_ORDINAL, &Ordinals, 0, 0);
        }

        // Otherwise...
        else
        {
            // Must have copied...
            Assert(faOldRecord != faNewRecord);

            // Build the Update Notification Package
            _LogTransaction(TRANSACTION_UPDATE, INVALID_INDEX_ORDINAL, &Ordinals, faOldRecord, faNewRecord);
        }
    }

    // Otherwise, free the old record
    else if (faOldRecord != faNewRecord)
    {
        // De-allocate the record from the file
        IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_UPDATE, faOldRecord));
    }

    // Update the Version
    bVersion++;

    // Store the Version back into the record
    *((WORD *)((LPBYTE)pBinding + m_pSchema->ofVersion)) = bVersion;

    // Version Change
    m_pShare->dwVersion++;

    // Call Extension
    if (m_pExtension)
    {
        // Extend Record Updates
        m_pExtension->OnRecordUpdate(OPERATION_AFTER, &Ordinals, pBindingOld, pBinding);
    }

exit:
    // Cleanup
    SafeFreeBinding(pBindingOld);

    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_LinkRecordIntoTable
//--------------------------------------------------------------------------
HRESULT CDatabase::_LinkRecordIntoTable(LPRECORDMAP pMap, LPVOID pBinding,
    BYTE bVersion, LPFILEADDRESS pfaRecord)
{
    // Locals
    HRESULT         hr=S_OK;
    LPRECORDBLOCK   pCurrent;
    LPRECORDBLOCK   pPrevious;

    // Trace
    TraceCall("CDatabase::_LinkRecordIntoTable");

    // Invalid Args
    Assert(pBinding && pfaRecord);

    // Allocate a block in the file for the record
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_RECORD, pMap->cbData + pMap->cbTags, (LPVOID *)&pCurrent));

    // Set the Version
    pCurrent->bVersion = bVersion;

    // Persist the Record
    IF_FAILEXIT(hr = _SaveRecord(pCurrent, pMap, pBinding));

    // Return *pfaRecord
    *pfaRecord = pCurrent->faBlock;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AdjustParentNodeCount
//--------------------------------------------------------------------------
HRESULT CDatabase::_AdjustParentNodeCount(INDEXORDINAL iIndex, 
    FILEADDRESS faChain, LONG lCount)
{
    // De-ref
    HRESULT         hr=S_OK;
    LPCHAINBLOCK    pParent;
    LPCHAINBLOCK    pCurrent;

    // Trace
    TraceCall("CDatabase::_AdjustParentNodeCount");

    // Invalid Arg
    Assert(faChain && (1 == lCount || -1 == lCount));

    // Set pCurrent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pCurrent));

    // Goto the Parent...
    while (1)
    {
        // Goto the Parent
        if (0 == pCurrent->faParent)
        {
            // Better be the root
            Assert(pCurrent->faBlock == m_pHeader->rgfaIndex[iIndex] && 0 == pCurrent->iParent);

            // Done
            break;
        }

        // Set pCurrent
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pCurrent->faParent, (LPVOID *)&pParent));

        // Validate
        Assert(pCurrent->iParent < pParent->cNodes);

        // 0 Node
        if (0 == pCurrent->iParent && pParent->faLeftChain == pCurrent->faBlock)
        {
            // Increment or Decrement Count
            pParent->cLeftNodes += lCount;
        }

        // Otherwise, increment cRightNodes
        else
        {
            // Validate
            Assert(pParent->rgNode[pCurrent->iParent].faRightChain == pCurrent->faBlock);

            // Increment Right Node Count
            pParent->rgNode[pCurrent->iParent].cRightNodes += lCount;
        }

        // Update pCurrent
        pCurrent = pParent;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::LockNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::LockNotify(LOCKNOTIFYFLAGS dwFlags, LPHLOCK phLock)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::LockNotify");

    // Invalid Args
    if (NULL == phLock)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *phLock = NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Increment Queue Notify count
    m_pShare->cNotifyLock++;

    // Store Some Non-null value
    *phLock = (HLOCK)m_hMutex;

exit:
    // Unlock
    Unlock(&hLock);
    
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::UnlockNotify
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::UnlockNotify(LPHLOCK phLock)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::UnlockNotify");

    // Invalid Args
    if (NULL == phLock)
        return TraceResult(E_INVALIDARG);

    // Nothing to Unlock?
    if (NULL == *phLock)
        return(S_OK);

    // Store Some Non-null value
    Assert(*phLock == (HLOCK)m_hMutex);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Increment Queue Notify count
    m_pShare->cNotifyLock--;

    // No more Lock
    *phLock = NULL;

    // If there are still refs, don't send notifications yet...
    if (m_pShare->cNotifyLock)
        goto exit;

    // Dispatch Pending Notifications
    _DispatchPendingNotifications();

exit:
    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetTransaction
//--------------------------------------------------------------------------
HRESULT CDatabase::GetTransaction(LPHTRANSACTION phTransaction, 
    LPTRANSACTIONTYPE ptyTransaction, LPVOID pRecord1, LPVOID pRecord2, 
    LPINDEXORDINAL piIndex, LPORDINALLIST pOrdinals)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPTRANSACTIONBLOCK  pTransaction;
    FILEADDRESS         faTransaction;

    // Trace
    TraceCall("CDatabase::GetTransaction");

    // Validate
    Assert(phTransaction && ptyTransaction && pOrdinals);

    // No Transaction
    if (NULL == *phTransaction)
        return TraceResult(E_INVALIDARG);

    // Setup faTransaction
    faTransaction = (FILEADDRESS)PtrToUlong((*phTransaction));

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get the Transaction Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, faTransaction, (LPVOID *)&pTransaction));

    // Validate
    IxpAssert(pTransaction->cRefs > 0);

    // Set tyTransaction
    *ptyTransaction = pTransaction->tyTransaction;

    // Copy Index
    *piIndex = pTransaction->iIndex;

    // Copy Ordinals
    CopyMemory(pOrdinals, &pTransaction->Ordinals, sizeof(ORDINALLIST));

    // Set hNext
    (*phTransaction) = (HTRANSACTION)IntToPtr(pTransaction->faNextInBatch);

    // Did the caller want Record 1
    if (pRecord1 && pTransaction->faRecord1)
    {
        // Free pRecord1
        FreeRecord(pRecord1);

        // Read Record 1
        IF_FAILEXIT(hr = _ReadRecord(pTransaction->faRecord1, pRecord1));
    }

    // Read Second Record
    if (pRecord2 && pTransaction->faRecord2)
    {
        // Must be an Update
        Assert(TRANSACTION_UPDATE == pTransaction->tyTransaction);

        // Free pRecord1
        FreeRecord(pRecord2);

        // Read Record 2
        IF_FAILEXIT(hr = _ReadRecord(pTransaction->faRecord2, pRecord2));
    }

    // Decrement Refs on this item
    pTransaction->cRefs--;

    // If hit zero, release it
    if (pTransaction->cRefs > 0)
        goto exit;

    // Free Transact Block
    IF_FAILEXIT(hr = _FreeTransactBlock(pTransaction));

exit:
    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeTransactBlock
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeTransactBlock(LPTRANSACTIONBLOCK pTransaction)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTRANSACTIONBLOCK  pPrevious;
    LPTRANSACTIONBLOCK  pNext;

    // Trace
    TraceCall("CDatabase::_FreeTransactBlock");

    // Better be Zero
    IxpAssert(0 == pTransaction->cRefs);
    IxpAssert(m_pHeader->cTransacts > 0);

    // Previous ?
    if (pTransaction->faPrevious)
    {
        // Get the Previous
        IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, pTransaction->faPrevious, (LPVOID *)&pPrevious));

        // Set Previous Next
        pPrevious->faNext = pTransaction->faNext;
    }

    // Otherwise, adjust head
    else
    {
        // Validate
        IxpAssert(pTransaction->faBlock == m_pHeader->faTransactHead);

        // Adjust Head
        m_pHeader->faTransactHead = pTransaction->faNext;
    }

    // Next ?
    if (pTransaction->faNext)
    {
        // Get the Previous
        IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, pTransaction->faNext, (LPVOID *)&pNext));

        // Set Previous Next
        pNext->faPrevious = pTransaction->faPrevious;
    }

    // Otherwise, adjust head
    else
    {
        // Validate
        IxpAssert(pTransaction->faBlock == m_pHeader->faTransactTail);

        // Adjust Head
        m_pHeader->faTransactTail = pTransaction->faPrevious;
    }

    // Decrement cTransacts
    m_pHeader->cTransacts--;

    // If there is a record 1
    if (pTransaction->faRecord1)
    {
        // TRANSACTION_DELETE gets specail case
        if (TRANSACTION_DELETE == pTransaction->tyTransaction)
        {
            // Free the record, we don't need it
            IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_DELETE, pTransaction->faRecord1));
        }

        // Otherwise, basic freeblock
        else
        {
            // Free Record 1
            IF_FAILEXIT(hr = _FreeBlock(BLOCK_RECORD, pTransaction->faRecord1));
        }
    }

    // Read Second Record
    if (pTransaction->faRecord2)
    {
        // Read Record 2
        IF_FAILEXIT(hr = _FreeBlock(BLOCK_RECORD, pTransaction->faRecord2));
    }

    // Free this block
    IF_FAILEXIT(hr = _FreeBlock(BLOCK_TRANSACTION, pTransaction->faBlock));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CleanupTransactList
//--------------------------------------------------------------------------
HRESULT CDatabase::_CleanupTransactList(void)
{
    // Locals
    HRESULT             hr=S_OK;
    FILEADDRESS         faCurrent;
    LPTRANSACTIONBLOCK  pTransaction;

    // Trace
    TraceCall("CDatabase::_CleanupTransactList");

    // Validate
    Assert(0 == m_pHeader->faTransactHead ? 0 == m_pHeader->faTransactTail && 0 == m_pHeader->cTransacts : TRUE);

    // Set faCurrent
    faCurrent = m_pHeader->faTransactHead;

    // While we have a current
    while (faCurrent)
    {
        // Get Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, faCurrent, (LPVOID *)&pTransaction));

        // Set faCurrent
        faCurrent = pTransaction->faNext;

        // Set cRefs to Zero
        pTransaction->cRefs = 0;

        // Free It
        IF_FAILEXIT(hr = _FreeTransactBlock(pTransaction));
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CopyRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_CopyRecord(FILEADDRESS faRecord, LPFILEADDRESS pfaCopy)
{
    // Locals
    HRESULT         hr=S_OK;
    LPRECORDBLOCK   pRecordSrc;
    LPRECORDBLOCK   pRecordDst;

    // Trace
    TraceCall("CDatabase::_CopyRecord");

    // Get Soruce
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pRecordSrc));

    // Allocate a New block
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_RECORD, pRecordSrc->cbSize, (LPVOID *)&pRecordDst));

    // Get Soruce
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pRecordSrc));

    // Set Version
    pRecordDst->bVersion = pRecordSrc->bVersion;

    // Set cTags
    pRecordDst->cTags = pRecordSrc->cTags;

    // Copy Data
    CopyMemory((LPBYTE)pRecordDst + sizeof(RECORDBLOCK), (LPBYTE)pRecordSrc + sizeof(RECORDBLOCK), pRecordSrc->cbSize);

    // Return Address
    *pfaCopy = pRecordDst->faBlock;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_LogTransaction
//--------------------------------------------------------------------------
HRESULT CDatabase::_LogTransaction(TRANSACTIONTYPE tyTransaction, 
    INDEXORDINAL iIndex, LPORDINALLIST pOrdinals, FILEADDRESS faInRecord1, 
    FILEADDRESS faInRecord2)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTRANSACTIONBLOCK  pTransaction;
    LPTRANSACTIONBLOCK  pTail;
    FILEADDRESS         faRecord1=0;
    FILEADDRESS         faRecord2=0;

    // Trace
    TraceCall("CDatabase::_LogTransaction");

    // Nobody is registered
    if (0 == m_pShare->cNotify)
        return(S_OK);

    // If there are people who actually want some data...
    if (m_pShare->cNotifyWithData > 0)
    {
        // Initialize
        faRecord1 = faInRecord1;
        faRecord2 = faInRecord2;

        // TRANSACTION_INSERT
        if (TRANSACTION_INSERT == tyTransaction)
        {
            // Copy Record 2
            IF_FAILEXIT(hr = _CopyRecord(faInRecord1, &faRecord1));
        }

        // TRANSACTION_UPDATE
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Copy Record 2
            IF_FAILEXIT(hr = _CopyRecord(faInRecord2, &faRecord2));
        }
    }

    // Otherwise, free some stuff...
    else if (faInRecord1 > 0)
    {
        // TRANSACTION_DELETE
        if (TRANSACTION_DELETE == tyTransaction)
        {
            // Free the record, we don't need it
            IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_DELETE, faInRecord1));
        }

        // TRANSACTION_UPDATE
        else if (TRANSACTION_UPDATE == tyTransaction)
        {
            // Free the record, we don't need it
            IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_UPDATE, faInRecord1));
        }
    }

    // Allocate Notification Block
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_TRANSACTION, 0, (LPVOID *)&pTransaction));

    // Set tyTransaction
    pTransaction->tyTransaction = tyTransaction;

    // Set cRefs
    pTransaction->cRefs = (WORD)m_pShare->cNotify;

    // Copy iIndex
    pTransaction->iIndex = iIndex;

    // If there are ordinals
    if (pOrdinals)
    {
        // Save Sequence
        CopyMemory(&pTransaction->Ordinals, pOrdinals, sizeof(ORDINALLIST));
    }

    // Otherwise, fill ordinals with record counts
    else
    {
        // Validate Transaction Type
        Assert(TRANSACTION_INDEX_CHANGED == tyTransaction || TRANSACTION_INDEX_DELETED == tyTransaction || TRANSACTION_COMPACTED == tyTransaction);

        // Save Sequence
        ZeroMemory(&pTransaction->Ordinals, sizeof(ORDINALLIST));
    }

    // Set the Record Addresses
    pTransaction->faRecord1 = faRecord1;
    pTransaction->faRecord2 = faRecord2;

    // Link Into the Transaction List
    pTransaction->faNext = pTransaction->faPrevious = pTransaction->faNextInBatch = 0;

    // No Head yet
    if (0 == m_pHeader->faTransactHead)
    {
        // Set Head and Tail
        m_pHeader->faTransactHead = pTransaction->faBlock;
    }

    // Otherwise, append to tail
    else
    {
        // Get the Transaction Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, m_pHeader->faTransactTail, (LPVOID *)&pTail));

        // Link Into the Transaction List
        pTail->faNext = pTransaction->faBlock;

        // Set Previous
        pTransaction->faPrevious = pTail->faBlock;
    }

    // Set the Tail
    m_pHeader->faTransactTail = pTransaction->faBlock;

    // Increment cTransacts
    m_pHeader->cTransacts++;

    // Are we Queueing Notifications...
    if (0 == m_pShare->cNotifyLock)
    {
        // Validate
        IxpAssert(0 == m_pShare->faTransactLockHead && 0 == m_pShare->faTransactLockTail);

        // Dispatch Invoke
        IF_FAILEXIT(hr = _DispatchNotification((HTRANSACTION)IntToPtr(pTransaction->faBlock)));
    }

    // Otherwise, build the transaction lock list
    else
    {
        // Set LockHead
        if (0 == m_pShare->faTransactLockHead)
        {
            // Set the header of the locked transactions
            m_pShare->faTransactLockHead = pTransaction->faBlock;
        }

        // Otherwise, append to tail
        else
        {
            // Get the Transaction Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_TRANSACTION, m_pShare->faTransactLockTail, (LPVOID *)&pTail));

            // Link Into the Transaction List
            pTail->faNextInBatch = pTransaction->faBlock;
        }

        // Set the Tail
        m_pShare->faTransactLockTail = pTransaction->faBlock;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_AdjustOpenRowsets
//--------------------------------------------------------------------------
HRESULT CDatabase::_AdjustOpenRowsets(INDEXORDINAL iIndex,
    ROWORDINAL iRow, OPERATIONTYPE tyOperation)
{
    // Locals
    LPROWSETINFO    pRowset;
    DWORD           j;

    // Trace
    TraceCall("CDatabase::_AdjustOpenRowsets");

    // Invalid Args
    Assert(OPERATION_DELETE == tyOperation || OPERATION_INSERT == tyOperation);

    // Update open rowsets
    for (j=0; j<m_pShare->Rowsets.cUsed; j++)
    {
        // Set iRowset
        pRowset = &m_pShare->Rowsets.rgRowset[m_pShare->Rowsets.rgiUsed[j]];

        // Does this rowset reference this index ?
        if (pRowset->iIndex == iIndex)
        {
            // How does the newly insert/deleted record affect the current position of this rowset ?
            if (iRow <= pRowset->iRow)
            {
                // lAdjust is negative
                if (OPERATION_DELETE == tyOperation && pRowset->iRow > 1)
                    pRowset->iRow--;

                // Otherwise, Increment iRow so that we don't duplicate rows...
                else
                    pRowset->iRow += 1;
            }
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::InsertRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::InsertRecord(LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faRecord;
    RECORDMAP       RecordMap;
    DWORD           i;
    DWORD           cNotify=0;
    INDEXORDINAL    iIndex;
    HLOCK           hLock=NULL;
    FINDRESULT      rgResult[CMAX_INDEXES];
    ORDINALLIST     Ordinals;
    LPRECORDBLOCK   pRecord;

    // Trace
    TraceCall("CDatabase::InsertRecord");

    // Invalid Args
    Assert(pBinding);

    // Initialize Ordinals (Initializes everything to INVALID_ROWORDINAL)
    FillMemory(&Ordinals, sizeof(ORDINALLIST), 0xFF);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Watch for Maximum Unique Id ?
    if (0xFFFFFFFF != m_pSchema->ofUniqueId)
    {
        // Get Id
        DWORD dwId = *((DWORD *)((LPBYTE)pBinding + m_pSchema->ofUniqueId));

        // Reset dwNextId if dwId isn't in the invalid range
        if (0 != dwId && dwId > m_pHeader->dwNextId && dwId < RESERVED_ID_MIN)
            m_pHeader->dwNextId = dwId;
    }

    // IDatabaseExtension
    if (m_pExtension)
    {
        // Extend Insert
        m_pExtension->OnRecordInsert(OPERATION_BEFORE, NULL, pBinding);
    }

    // Loop through all the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Otherwise: Decide Where to insert
        IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &rgResult[i].faChain, &rgResult[i].iNode, &Ordinals.rgiRecord1[iIndex], &rgResult[i].nCompare));

        // If key already exist, cache list and return
        if (DB_S_FOUND == hr)
        {
            hr = TraceResult(DB_E_DUPLICATE);
            goto exit;
        }
    }

    // Get the Record Size
    IF_FAILEXIT(hr = _GetRecordSize(pBinding, &RecordMap));

    // Link Record Into the Table
    IF_FAILEXIT(hr = _LinkRecordIntoTable(&RecordMap, pBinding, 0, &faRecord));

    // Version Change
    m_pShare->dwVersion++;

    // Insert into the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Visible in live index
        if (S_OK == _IsVisible(m_rghFilter[iIndex], pBinding))
        {
            // Do the Insertion
            IF_FAILEXIT(hr = _IndexInsertRecord(iIndex, rgResult[i].faChain, faRecord, &rgResult[i].iNode, rgResult[i].nCompare));

            // Update Record Count
            m_pHeader->rgcRecords[iIndex]++;

            // Adjust iRow
            Ordinals.rgiRecord1[iIndex] += (rgResult[i].iNode + 1);

            // AdjustOpenRowsets
            _AdjustOpenRowsets(iIndex, Ordinals.rgiRecord1[iIndex], OPERATION_INSERT);

            // Notification Required ?
            cNotify += m_pShare->rgcIndexNotify[iIndex];
        }

        // Otherwise, adjust the ordinal to indicate that its not in the index
        else
        {
            // Can't be primary
            Assert(IINDEX_PRIMARY != iIndex);

            // Ordinals.rgiRecord1[iIndex]
            Ordinals.rgiRecord1[iIndex] = INVALID_ROWORDINAL;
        }
    }

    // Set the Version
    *((DWORD *)((LPBYTE)pBinding + m_pSchema->ofVersion)) = 1;

    // Build the Notification Package
    if (cNotify > 0)
    {
        // Build the Package
        _LogTransaction(TRANSACTION_INSERT, INVALID_INDEX_ORDINAL, &Ordinals, faRecord, 0);
    }

    // IDatabaseExtension
    if (m_pExtension)
    {
        // Extend Insert
        m_pExtension->OnRecordInsert(OPERATION_AFTER, &Ordinals, pBinding);
    }

exit:
    // Finish the Operation
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_IndexInsertRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_IndexInsertRecord(INDEXORDINAL iIndex, 
    FILEADDRESS faChain, FILEADDRESS faRecord, LPNODEINDEX piNode,
    INT nCompare)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAINNODE       Node={0};
    LPCHAINBLOCK    pChain;

    // Trace
    TraceCall("CDatabase::_IndexInsertRecord");

    // Invalid Args
    Assert(faRecord > 0);
    Assert(nCompare > 0 || nCompare < 0);

    // If we have a root chain, find a place to insert the new record, or see if the record already exists
    if (0 == m_pHeader->rgfaIndex[iIndex])
    {
        // We should not write into 0
        IF_FAILEXIT(hr = _AllocateBlock(BLOCK_CHAIN, 0, (LPVOID *)&pChain));

        // zero out the block
        ZeroBlock(pChain, sizeof(CHAINBLOCK));

        // Set faStart
        m_pHeader->rgfaIndex[iIndex] = pChain->faBlock;

        // Number of nodes in the chain
        pChain->cNodes = 1;

        // Setup the first node
        pChain->rgNode[0].faRecord = faRecord;

        // Validate piNode
        IxpAssert(*piNode == 0);

        // Return piNode
        *piNode = 0;
    }

    // Otherwise
    else
    {
        // De-ref
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Initialize Node
        Node.faRecord = faRecord;

        // This is very a special increment and has to do with the way a BinarySearch can
        // determine the correct insertion point for a node that did not exist in the 
        // array in which a binary search was performed on.
        if (nCompare > 0)
            (*piNode)++;

        // Expand the Chain
        IF_FAILEXIT(hr = _ExpandChain(pChain, (*piNode)));

        // Copy the Node
        CopyMemory(&pChain->rgNode[(*piNode)], &Node, sizeof(CHAINNODE));

        // If Node is FULL, we must do a split insert
        if (pChain->cNodes > BTREE_ORDER)
        {
            // Split the chain
            IF_FAILEXIT(hr = _SplitChainInsert(iIndex, faChain));
        }

        // Mark Chain as dirty, cause we are about to cache it away
        else
        {
            // Increment Parent Record Count
            IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, faChain, 1));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::DeleteRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::DeleteRecord(LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;
    FILEADDRESS     faRecord=0;
    LPVOID          pBindingOld=NULL;
    DWORD           cNotify=0;
    FINDRESULT      rgResult[CMAX_INDEXES];
    ORDINALLIST     Ordinals;
    DWORD           i;
    INDEXORDINAL    iIndex;
    LPCHAINBLOCK    pChain;

    // Trace
    TraceCall("CDatabase::DeleteRecord");

    // Invalid Args
    Assert(pBinding);

    // Initialize Ordinals (Initializes everything to INVALID_ROWORDINAL)
    FillMemory(&Ordinals, sizeof(ORDINALLIST), 0xFF);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Otherwise: Decide Where to insert
    IF_FAILEXIT(hr = _FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, pBinding, &rgResult[0].faChain, &rgResult[0].iNode, &Ordinals.rgiRecord1[IINDEX_PRIMARY]));

    // If not found, you can't update it. Use Insert
    if (DB_S_NOTFOUND == hr)
    {
        hr = TraceResult(DB_E_NOTFOUND);
        goto exit;
    }

    // Primary Index Can not change
    rgResult[0].fFound = TRUE;

    // Cast pChain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, rgResult[0].faChain, (LPVOID *)&pChain));

    // Set faRecord
    faRecord = pChain->rgNode[rgResult[0].iNode].faRecord;

    // If this was the first index and there are more indexes, then read the origina record so that indexes are updated correctly
    if (m_pHeader->cIndexes > 1 || m_pExtension)
    {
        // Allocate a Record
        IF_NULLEXIT(pBindingOld = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

        // Read the Record
        IF_FAILEXIT(hr = _ReadRecord(faRecord, pBindingOld));
    }

    // IDatabaseExtension
    if (m_pExtension)
    {
        // Extend Delete
        m_pExtension->OnRecordDelete(OPERATION_BEFORE, NULL, pBindingOld);
    }

    // Loop through the indexes
    for (i=1; i<m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Otherwise: Decide Where to insert
        IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBindingOld, &rgResult[i].faChain, &rgResult[i].iNode, &Ordinals.rgiRecord1[iIndex]));

        // The, record wasn't found, there must be a filter on the index
        if (DB_S_NOTFOUND == hr)
        {
            // Not found
            rgResult[i].fFound = FALSE;

            // Invalid Ordinal
            Ordinals.rgiRecord1[iIndex] = INVALID_ROWORDINAL;
        }

        // Otherwise
        else
        {
            // Found
            rgResult[i].fFound = TRUE;

            // Get the Chain
            Assert(SUCCEEDED(_GetBlock(BLOCK_CHAIN, rgResult[i].faChain, (LPVOID *)&pChain)));

            // Validation
            Assert(faRecord == pChain->rgNode[rgResult[i].iNode].faRecord);
        }
    }

    // Loop through the indexes
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Found ?
        if (rgResult[i].fFound)
        {
            // Lets remove the link from the index first
            IF_FAILEXIT(hr = _IndexDeleteRecord(iIndex, rgResult[i].faChain, rgResult[i].iNode));

            // Validate Record Count
            Assert(m_pHeader->rgcRecords[iIndex] > 0);

            // Update Record Count
            m_pHeader->rgcRecords[iIndex]--;

            // AdjustOpenRowsets
            _AdjustOpenRowsets(iIndex, Ordinals.rgiRecord1[iIndex], OPERATION_DELETE);

            // Does somebody want a notification about this index ?
            cNotify += m_pShare->rgcIndexNotify[iIndex];
        }
    }

    // Notify Somebody ?
    if (cNotify > 0)
    {
        // Build the Update Notification Package
        _LogTransaction(TRANSACTION_DELETE, INVALID_INDEX_ORDINAL, &Ordinals, faRecord, 0);
    }

    // Otherwise, free the record
    else
    {
        // De-allocate the record from the file
        IF_FAILEXIT(hr = _FreeRecordStorage(OPERATION_DELETE, faRecord));
    }

    // Version Change
    m_pShare->dwVersion++;

    // IDatabaseExtension
    if (m_pExtension)
    {
        // Extend Delete
        m_pExtension->OnRecordDelete(OPERATION_AFTER, &Ordinals, pBindingOld);
    }

exit:
    // Cleanup
    SafeFreeBinding(pBindingOld);

    // Unlock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::FindRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::FindRecord(INDEXORDINAL iIndex, DWORD cColumns,
    LPVOID pBinding, LPROWORDINAL piRow)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    LPCHAINBLOCK    pChain;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::FindRecord");

    // Invalid Args
    Assert(pBinding);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Find the Record
    IF_FAILEXIT(hr = _FindRecord(iIndex, cColumns, pBinding, &faChain, &iNode, piRow));

    // If Found, Copy the record
    if (DB_S_FOUND == hr)
    {
        // Get the Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Open the Record into pBinding
        IF_FAILEXIT(hr = _ReadRecord(pChain->rgNode[iNode].faRecord, pBinding));

        // Found It
        hr = DB_S_FOUND;

        // Done
        goto exit;
    }

    // Not Found
    hr = DB_S_NOTFOUND;

exit:
    // Unlock the index
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetChainByIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetChainByIndex(INDEXORDINAL iIndex, ROWORDINAL iRow,
    LPFILEADDRESS pfaChain, LPNODEINDEX piNode)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faChain;
    LPCHAINBLOCK    pChain;
    DWORD           cLeftNodes=0;
    NODEINDEX       i;

    // Trace
    TraceCall("CDatabase::_GetChainByIndex");

    // Invalid Args
    Assert(pfaChain && piNode);

    // Initialize
    faChain = m_pHeader->rgfaIndex[iIndex];

    // Loop
    while (faChain)
    {
        // Corrupt
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Are there left nodes ?
        if (pChain->cLeftNodes > 0 && iRow <= (cLeftNodes + pChain->cLeftNodes))
        {
            // Goto the left
            faChain = pChain->faLeftChain;
        }

        // Otherwise...
        else
        {
            // Increment cLeftNodes
            cLeftNodes += pChain->cLeftNodes;

            // Loop throug right chains
            for (i=0; i<pChain->cNodes; i++)
            {
                // Failure
                if (cLeftNodes + 1 == iRow)
                {
                    // We found the Chain
                    *pfaChain = faChain;

                    // Return the Node Index
                    *piNode = i;

                    // Done
                    goto exit;
                }

                // Increment cLeftNodes
                cLeftNodes++;

                // Goto the Right ?
                if (iRow <= (cLeftNodes + pChain->rgNode[i].cRightNodes))
                {
                    // Goto the Right
                    faChain = pChain->rgNode[i].faRightChain;

                    // Break
                    break;
                }

                // First Node ?
                cLeftNodes += pChain->rgNode[i].cRightNodes;
            }

            // Nothing found...
            if (i == pChain->cNodes)
                break;
        }
    }

    // Not Found
    hr = E_FAIL;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::CreateRowset
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::CreateRowset(INDEXORDINAL iIndex,
    CREATEROWSETFLAGS dwFlags, LPHROWSET phRowset)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWSETORDINAL   iRowset;
    LPROWSETTABLE   pTable;
    LPROWSETINFO    pRowset;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::CreateRowset");

    // Invalid Args
    Assert(iIndex < CMAX_INDEXES && phRowset);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // De-Ref the RowsetTable
    pTable = &m_pShare->Rowsets;

    // Init Rowset Table
    if (FALSE == pTable->fInitialized)
    {
        // Init the rgiFree Array
        for (iRowset=0; iRowset<CMAX_OPEN_ROWSETS; iRowset++)
        {
            // set rgiFree
            pTable->rgiFree[iRowset] = iRowset;

            // Set rgRowset
            pTable->rgRowset[iRowset].iRowset = iRowset;
        }

        // Set cFree
        pTable->cFree = CMAX_OPEN_ROWSETS;

        // Initialized
        pTable->fInitialized = TRUE;
    }

    // No free Rowsets ?
    if (0 == pTable->cFree)
    {
        hr = TraceResult(DB_E_TOOMANYOPENROWSETS);
        goto exit;
    }

    // Get a Free Rowset...
    iRowset = pTable->rgiFree[pTable->cFree - 1];

    // Set phRowset (Need to Add one so that I don't return a NULL
    *phRowset = (HROWSET)IntToPtr(iRowset + 1);

    // Set pRowset...
    pRowset = &pTable->rgRowset[iRowset];

    // Validate iRowset
    Assert(pRowset->iRowset == iRowset);

    // Zero the Roset
    ZeroMemory(pRowset, sizeof(ROWSETINFO));

    // Set iRowset
    pRowset->iRowset = iRowset;

    // set iRow
    pRowset->iRow = 1;

    // Set Index
    pRowset->iIndex = iIndex;

    // Remove iRowset from rgiFree
    pTable->cFree--;

    // Put iRowset into rgiUsed
    pTable->rgiUsed[pTable->cUsed] = iRowset;

    // Increment cUsed
    pTable->cUsed++;

exit:
    // Enter Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::CloseRowset
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::CloseRowset(LPHROWSET phRowset)
{
    // Locals
    HRESULT         hr=S_OK;
    BYTE            i;
    LPROWSETTABLE   pTable;
    HLOCK           hLock=NULL;
    ROWSETORDINAL   iRowset=((ROWSETORDINAL)(*phRowset) - 1);
    LPROWSETINFO    pRowset;

    // Nothing ?
    if (NULL == *phRowset)
        return(S_OK);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get the Rowset
    pRowset = &m_pShare->Rowsets.rgRowset[iRowset];

    // Validate
    Assert(iRowset == pRowset->iRowset);

    // De-Ref the RowsetTable
    pTable = &m_pShare->Rowsets;

    // Search rgiUsed
    for (i=0; i<pTable->cUsed; i++)
    {
        // Is this It ?
        if (pTable->rgiUsed[i] == pRowset->iRowset)
        {
            // Remove this Rowset
            MoveMemory(&pTable->rgiUsed[i], &pTable->rgiUsed[i + 1], sizeof(ROWSETORDINAL) * (pTable->cUsed - (i + 1)));

            // Decrement cUsed
            pTable->cUsed--;

            // Put iRowset into the free list
            pTable->rgiFree[pTable->cFree] = pRowset->iRowset;

            // Increment cFree
            pTable->cFree++;

            // Done
            break;
        }
    }

    // Don't Free Again
    *phRowset = NULL;

exit:
    // Enter Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetRowOrdinal
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::GetRowOrdinal(INDEXORDINAL iIndex, 
    LPVOID pBinding, LPROWORDINAL piRow)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::GetRowOrdinal");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Arg
    Assert(pBinding && piRow && iIndex < CMAX_INDEXES);

    // Simply do a find record...
    IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &faChain, &iNode, piRow));

    // No Found
    if (DB_S_NOTFOUND == hr)
    {
        hr = DB_E_NOTFOUND;
        goto exit;
    }

exit:
    // Process / Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::SeekRowset
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::SeekRowset(HROWSET hRowset, SEEKROWSETTYPE tySeek, 
    LONG cRows, LPROWORDINAL piRowNew)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;
    ROWORDINAL      iRowNew;
    ROWSETORDINAL   iRowset=((ROWSETORDINAL)(hRowset) - 1);
    LPROWSETINFO    pRowset;

    // Trace
    TraceCall("CDatabase::SeekRowset");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get the Rowset
    pRowset = &m_pShare->Rowsets.rgRowset[iRowset];

    // Validate
    Assert(iRowset == pRowset->iRowset);

    // If there are no records, then seek operation is meaningless
    if (0 == m_pHeader->rgcRecords[pRowset->iIndex])
    {
        hr = DB_E_NORECORDS;
        goto exit;
    }

    // Seek From Beginning
    if (SEEK_ROWSET_BEGIN == tySeek)
    {
        // Set iRow (and remember 0th row from beginning is row #1)
        iRowNew = (cRows + 1);
    }

    // Seek From Current Position
    else if (SEEK_ROWSET_CURRENT == tySeek)
    {
        // Adjust iRow
        iRowNew = (pRowset->iRow + cRows);
    }

    // SEEK_ROWSET_END
    else if (SEEK_ROWSET_END == tySeek)
    {
        // Adjust iRow
        iRowNew = m_pHeader->rgcRecords[pRowset->iIndex] + cRows;
    }

    // Error
    if (iRowNew > m_pHeader->rgcRecords[pRowset->iIndex] || iRowNew <= 0)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Set New iRow
    pRowset->iRow = iRowNew;

    // Return piRowNew ?
    if (piRowNew)
        *piRowNew = pRowset->iRow;

exit:
    // Process / Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::QueryRowset
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::QueryRowset(HROWSET hRowset, LONG lWanted,
    LPVOID *prgpRecord, LPDWORD pcObtained)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cRead=0;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    LPCHAINBLOCK    pChain;
    DWORD           cWanted=abs(lWanted);
    HLOCK           hLock=NULL;
    LONG            lDirection=(lWanted < 0 ? -1 : 1);
    ROWSETORDINAL   iRowset=((ROWSETORDINAL)(hRowset) - 1);
    LPROWSETINFO    pRowset;

    // Trace
    TraceCall("CDatabase::GetRows");

    // Invalid Args
    Assert(prgpRecord && hRowset);

    // Initialize
    if (pcObtained)
        *pcObtained = 0;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get the Rowset
    pRowset = &m_pShare->Rowsets.rgRowset[iRowset];

    // Validate
    Assert(iRowset == pRowset->iRowset);

    // Invalid ?
    if (0 == pRowset->iRow || pRowset->iRow > m_pHeader->rgcRecords[pRowset->iIndex])
    {
        hr = S_FALSE;
        goto exit;
    }

    // While we have a record address
    while (cRead < cWanted)
    {
        // Get the chain from the index
        if (FAILED(_GetChainByIndex(pRowset->iIndex, pRowset->iRow, &faChain, &iNode)))
        {
            // Done
            pRowset->iRow = 0xffffffff;

            // Done
            break;
        }

        // De-reference the Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Open the Record into pBinding
        IF_FAILEXIT(hr = _ReadRecord(pChain->rgNode[iNode].faRecord, ((LPBYTE)prgpRecord + (m_pSchema->cbBinding * cRead))));

        // Increment cRead
        cRead++;

        // Validate
        Assert(pRowset->iRow > 0 && pRowset->iRow <= m_pHeader->rgcRecords[pRowset->iIndex]);

        // Increment Index
        pRowset->iRow += lDirection;

        // If this is a child chain, I can walk all the nodes
        if (0 == pChain->faLeftChain)
        {
            // Better not have any left nodes
            Assert(0 == pChain->cLeftNodes);

            // Forward ?
            if (lDirection > 0)
            {
                // Loop 
                for (NODEINDEX i=iNode + 1; i<pChain->cNodes && cRead < cWanted; i++)
                {
                    // Better not have a right chain or any right nodes
                    Assert(0 == pChain->rgNode[i].faRightChain && 0 == pChain->rgNode[i].cRightNodes);

                    // Open the Record into pBinding
                    IF_FAILEXIT(hr = _ReadRecord(pChain->rgNode[i].faRecord, ((LPBYTE)prgpRecord + (m_pSchema->cbBinding * cRead))));

                    // Increment cRead
                    cRead++;

                    // Increment Index
                    pRowset->iRow += 1;
                }
            }

            // Otherwise, backwards
            else
            {
                // Loop 
                for (LONG i=iNode - 1; i>=0 && cRead < cWanted; i--)
                {
                    // Better not have a right chain or any right nodes
                    Assert(0 == pChain->rgNode[i].faRightChain && 0 == pChain->rgNode[i].cRightNodes);

                    // Open the Record into pBinding
                    IF_FAILEXIT(hr = _ReadRecord(pChain->rgNode[i].faRecord, ((LPBYTE)prgpRecord + (m_pSchema->cbBinding * cRead))));

                    // Increment cRead
                    cRead++;

                    // Increment Index
                    pRowset->iRow -= 1;
                }
            }
        }
    }

    // Set pcbObtained
    if (pcObtained)
        *pcObtained = cRead;

    // Set hr
    hr = (cRead > 0) ? S_OK : S_FALSE;

exit:
    // Enter Lock
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::FreeRecord
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::FreeRecord(LPVOID pBinding)
{
    // Locals
    LPVOID      pFree;

    // Trace
    TraceCall("CDatabase::FreeRecord");

    // Invalid Args
    Assert(pBinding);

    // Get the pointer to free
    pFree = *((LPVOID *)((LPBYTE)pBinding + m_pSchema->ofMemory));

    // Not NULL
    if (pFree)
    {
        // Don't Free again
        *((LPVOID *)((LPBYTE)pBinding + m_pSchema->ofMemory)) = NULL;

        // Free This
        HeapFree(pFree);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_GetRecordSize
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetRecordSize(LPVOID pBinding, LPRECORDMAP pMap)
{
    // Locals
    DWORD           i;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("CDatabase::_GetRecordSize");

    // Invalid Args
    Assert(pBinding && pMap);

    // Initialize
    ZeroMemory(pMap, sizeof(RECORDMAP));

    // Walk through the members in the structure
    for (i=0; i<m_pSchema->cColumns; i++)
    {
        // Readability
        pColumn = &m_pSchema->prgColumn[i];

        // Is Data Set ?
        if (FALSE == DBTypeIsDefault(pColumn, pBinding))
        {
            // Compute Amount of Data to Store
            pMap->cbData += DBTypeGetSize(pColumn, pBinding);

            // Count Tags
            pMap->cTags++;
            
            // Compute Amount of Tags to Store
            pMap->cbTags += sizeof(COLUMNTAG);
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_SaveRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_SaveRecord(LPRECORDBLOCK pRecord, LPRECORDMAP pMap,
    LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    DWORD           cbOffset=0;
    DWORD           cTags=0;
    LPCTABLECOLUMN  pColumn;
    LPCOLUMNTAG     pTag;

    // Trace
    TraceCall("CDatabase::_SaveRecord");

    // Invalid Args
    Assert(pRecord && pRecord->faBlock > 0 && pBinding);

    // Better have enough space
    Assert(pMap->cbData + pMap->cbTags <= pRecord->cbSize && pMap->cbTags == (pMap->cTags * sizeof(COLUMNTAG)));

    // Set prgTag
    pMap->prgTag = (LPCOLUMNTAG)((LPBYTE)pRecord + sizeof(RECORDBLOCK));

    // Set pbData
    pMap->pbData = (LPBYTE)((LPBYTE)pRecord + sizeof(RECORDBLOCK) + pMap->cbTags);

    // Walk through the members in the structure
    for (i=0; i<m_pSchema->cColumns; i++)
    {
        // Readability
        pColumn = &m_pSchema->prgColumn[i];

        // Is Data Set ?
        if (FALSE == DBTypeIsDefault(pColumn, pBinding))
        {
            // Compute Hash
            pTag = &pMap->prgTag[cTags];

            // Set Tag Id
            pTag->iColumn = pColumn->iOrdinal;

            // Assume pTag Doesn't Contain Data
            pTag->fData = 0;

            // Store the Offset
            pTag->Offset = cbOffset;

            // WriteBindTypeData
            cbOffset += DBTypeWriteValue(pColumn, pBinding, pTag, pMap->pbData + cbOffset);

            // Count Tags
            cTags++;

            // Validate
            Assert(cbOffset <= pMap->cbData);

            // Done ?
            if (cTags == pMap->cTags)
            {
                // Should have Wrote Everything
                Assert(cbOffset == pMap->cbData);

                // Done
                break;
            }
        }
    }

    // Increment Record Version
    pRecord->bVersion++;

    // Write the number of columns
    pRecord->cTags = pMap->cTags;

    // Validate
    Assert(cTags == pMap->cTags && pRecord->cTags > 0);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_ReadRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_ReadRecord(FILEADDRESS faRecord, LPVOID pBinding,
    BOOL fInternal /* = FALSE */)
{
    // Locals
    HRESULT         hr=S_OK;
    LPBYTE          pbData=NULL;
    LPCTABLECOLUMN  pColumn;
    LPCOLUMNTAG     pTag;
    WORD            iTag;
    RECORDMAP       Map;
    LPRECORDBLOCK   pRecord;

    // Trace
    TraceCall("CDatabase::_ReadRecord");

    // Invalid Args
    Assert(faRecord > 0 && pBinding);

    // Zero pBinding
    ZeroMemory(pBinding, m_pSchema->cbBinding);

    // Bad Chain Node
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pRecord));

    // Get Record Map
    IF_FAILEXIT(hr = _GetRecordMap(TRUE, pRecord, &Map));

    // Not Internal
    if (FALSE == fInternal)
    {
        // Allocate a record
        IF_NULLEXIT(pbData = (LPBYTE)PHeapAllocate(0, Map.cbData));

        // Just read the Record
        CopyMemory(pbData, Map.pbData, Map.cbData);

        // Copy Data From pbData...
        Map.pbData = pbData;
    }

    // Walk through the Tags of the Record
    for (iTag=0; iTag<Map.cTags; iTag++)
    {
        // Readability
        pTag = &Map.prgTag[iTag];

        // Validate the Tag
        if (pTag->iColumn < m_pSchema->cColumns)
        {
            // De-ref the Column
            pColumn = &m_pSchema->prgColumn[pTag->iColumn];

            // Read the Data
            DBTypeReadValue(pColumn, pTag, &Map, pBinding);
        }
    }

    // Store the version of the record into the binding
    *((BYTE *)((LPBYTE)pBinding + m_pSchema->ofVersion)) = pRecord->bVersion;

    // Store a point to the blob and free it later
    *((LPVOID *)((LPBYTE)pBinding + m_pSchema->ofMemory)) = (LPVOID)pbData;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::BindRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::BindRecord(LPRECORDMAP pMap, LPVOID pBinding)
{
    // Locals
    WORD            iTag;
    LPCOLUMNTAG     pTag;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("CDatabase::BindRecord");

    // Zero Out the Binding
    ZeroMemory(pBinding, m_pSchema->cbBinding);

    // Walk through the Tags of the Record
    for (iTag=0; iTag<pMap->cTags; iTag++)
    {
        // Readability
        pTag = &pMap->prgTag[iTag];

        // Validate the Tag
        Assert(pTag->iColumn < m_pSchema->cColumns);

        // De-ref the Column
        pColumn = &m_pSchema->prgColumn[pTag->iColumn];

        // Read the Data
        DBTypeReadValue(pColumn, pTag, pMap, pBinding);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_IsVisible (S_OK = Show, S_FALSE = Hide)
//--------------------------------------------------------------------------
HRESULT CDatabase::_IsVisible(HQUERY hQuery, LPVOID pBinding)
{
    // Trace
    TraceCall("CDatabase::_IsVisible");

    // No hQuery, the record must be visible
    if (NULL == hQuery)
        return(S_OK);

    // Evaluate the Query
    return(EvaluateQuery(hQuery, pBinding, m_pSchema, this, m_pExtension));
}

//--------------------------------------------------------------------------
// CDatabase::_CompareBinding
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompareBinding(INDEXORDINAL iIndex, DWORD cColumns, 
    LPVOID pBinding, FILEADDRESS faRecord, INT *pnCompare)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cKeys;
    LPRECORDBLOCK   pBlock;
    RECORDMAP       Map;
    LPCOLUMNTAG     pTag;
    DWORD           iKey;
    LPTABLEINDEX    pIndex;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("CDatabase::_CompareBinding");

    // Initialize
    *pnCompare = 1;

    // Get the Right Record Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pBlock));

    // Get the Right Node Data
    IF_FAILEXIT(hr = _GetRecordMap(TRUE, pBlock, &Map));

    // De-Ref the Index
    pIndex = &m_pHeader->rgIndexInfo[iIndex];

    // Compute Number of keys to match (possible partial index search)
    cKeys = min(cColumns, pIndex->cKeys);

    // Loop through the key members
    for (iKey=0; iKey<cKeys; iKey++)
    {
        // Readability
        pColumn = &m_pSchema->prgColumn[pIndex->rgKey[iKey].iColumn];

        // Get Tag From Column Ordinal
        pTag = PTagFromOrdinal(&Map, pColumn->iOrdinal);

        // Compare Types
        *pnCompare = DBTypeCompareBinding(pColumn, &pIndex->rgKey[iKey], pBinding, pTag, &Map);

        // Done
        if (0 != *pnCompare)
            break;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_PartialIndexCompare
//--------------------------------------------------------------------------
HRESULT CDatabase::_PartialIndexCompare(INDEXORDINAL iIndex, DWORD cColumns, 
    LPVOID pBinding, LPCHAINBLOCK *ppChain, LPNODEINDEX piNode, LPROWORDINAL piRow)
{
    // Locals
    HRESULT         hr=S_OK;
    ROWORDINAL      iRow=(piRow ? *piRow : 0xffffffff);
    LONG            iNode=(*piNode);
    LPCHAINBLOCK    pChain=(*ppChain);
    FILEADDRESS     faChain;
    INT             nCompare=0;
    BYTE            fFirstLoop;

    // Trace
    TraceCall("CDatabase::_PartialIndexCompare");

    // Invalid Args
    Assert(pBinding && pChain && piNode && *piNode < pChain->cNodes);

    // Loop
    while (1)
    {
        // Assume no more chains
        faChain = 0;

        // First Loop
        fFirstLoop = TRUE;

        // Loop through Current
        while (1)
        {
            // Validate iNode
            Assert(iNode >= 0 && iNode < BTREE_ORDER);

            // Only do this on every iteration except the first
            if (FALSE == fFirstLoop)
            {
                // Decrement iRow
                iRow -= pChain->rgNode[iNode].cRightNodes;
            }

            // Compare with first node in this chain
            IF_FAILEXIT(hr = _CompareBinding(iIndex, cColumns, pBinding, pChain->rgNode[iNode].faRecord, &nCompare));

            // Validate nCompare
            Assert(0 == nCompare || nCompare > 0);

            // pBinding == Node
            if (0 == nCompare)
            {
                // Set new Found iNode
                *piNode = (NODEINDEX)iNode;

                // Set pFound
                *ppChain = pChain;

                // Update piRow
                if (piRow)
                {
                    // Update piRow
                    (*piRow) = iRow;
                }

                // Should we goto the left ?
                if (0 == iNode)
                {
                    // Set faNextChain
                    faChain = pChain->faLeftChain;

                    // Updating piRow
                    if (piRow)
                    {
                        // Decrement iRow
                        iRow -= pChain->cLeftNodes;

                        // Decrement One More ?
                        iRow--;
                    }

                    // Done
                    break;
                }
            }

            // If pBinding > Node
            else if (nCompare > 0)
            {
                // Set faNextChain
                faChain = pChain->rgNode[iNode].faRightChain;

                // Done
                break;
            }

            // Decrement iNode
            iNode--;

            // Decrement iRow
            iRow--;

            // No Longer the First Loop
            fFirstLoop = FALSE;
        }

        // Done
        if (0 == faChain)
            break;

        // Get the Current Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Reset iNode
        iNode = pChain->cNodes - 1;

        // Update piRow
        if (piRow)
        {
            // Increment piRow with cLeftNodes
            iRow += pChain->cLeftNodes;

            // Include this node
            iRow++;

            // Loop
            for (NODEINDEX i = 1; i <= pChain->cNodes - 1; i++)
            {
                // Increment with cRightNodes
                iRow += pChain->rgNode[i - 1].cRightNodes;

                // Include this node
                iRow++;
            }
        }
    }

#ifdef DEBUG
#ifdef PARTIAL_COMPARE_VALIDATE
    if (piRow)
    {
        ROWORDINAL iOrdinal;
        LPVOID pTmpBind = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding);
        IxpAssert(pTmpBind);
        IxpAssert(SUCCEEDED(_ReadRecord((*ppChain)->rgNode[(*piNode)].faRecord, pTmpBind)));
        IxpAssert(SUCCEEDED(GetRowOrdinal(iIndex, pTmpBind, &iOrdinal)));
        IxpAssert(*piRow == iOrdinal);
        SafeFreeBinding(pTmpBind);
        IxpAssert(SUCCEEDED(_CompareBinding(iIndex, cColumns, pBinding, &(*ppChain)->rgNode[(*piNode)], &nCompare)));
        IxpAssert(0 == nCompare);
    }
#endif
#endif

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FindRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_FindRecord(INDEXORDINAL iIndex, DWORD cColumns,
    LPVOID pBinding, LPFILEADDRESS pfaChain, LPNODEINDEX piNode, 
    LPROWORDINAL piRow /*=NULL*/, INT *pnCompare /*=NULL*/)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lLower;
    LONG            lUpper;
    LONG            lMiddle=0;
    LONG            lLastMiddle;
    INT             nCompare=-1;
    DWORD           iKey;
    BOOL            fPartial;
    LPCHAINBLOCK    pChain;
    FILEADDRESS     faChain;

    // Trace
    TraceCall("CDatabase::_FindRecord");

    // Invalid Args
    Assert(pBinding && pfaChain && piNode && iIndex < CMAX_INDEXES);

    // Partial Index Search ?
    fPartial = (COLUMNS_ALL == cColumns || cColumns == m_pHeader->rgIndexInfo[iIndex].cKeys) ? FALSE : TRUE;

    // Initialize
    *pfaChain = 0;
    *piNode = 0;

    // Start chain address
    faChain = m_pHeader->rgfaIndex[iIndex];

    // Row Ordinal
    if (piRow)
        *piRow = 0;

    // Loop
    while (faChain)
    {
        // Get the Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

        // Set *pfaChain
        *pfaChain = pChain->faBlock;

        // Compute initial upper and lower bounds
        lLower = 0;
        lUpper = pChain->cNodes - 1;

        // Do binary search / insert
        while (lLower <= lUpper)
        {
            // Compute middle record to compare against
            lMiddle = (BYTE)((lLower + lUpper) / 2);

            // Do the Comparison
            IF_FAILEXIT(hr = _CompareBinding(iIndex, cColumns, pBinding, pChain->rgNode[lMiddle].faRecord, &nCompare));

            // Partial Index Searching
            if (0 == nCompare)
            {
                // Validate
                Assert(lMiddle >= 0 && lMiddle <= BTREE_ORDER);

                // Set the found node
                *piNode = (BYTE)lMiddle;

                // Return *pnCompare
                if (pnCompare)
                    *pnCompare = 0;

                // Compute piRow
                if (piRow)
                {
                    // Increment piRow with cLeftNodes
                    (*piRow) += pChain->cLeftNodes;

                    // Include this node
                    (*piRow)++;

                    // Loop
                    for (NODEINDEX iNode=1; iNode<=lMiddle; iNode++)
                    {
                        // Increment with cRightNodes
                        (*piRow) += pChain->rgNode[iNode - 1].cRightNodes;

                        // Include this node
                        (*piRow)++;
                    }
                }

                // Partial Search
                if (fPartial)
                {
                    // Handle Partial Search
                    IF_FAILEXIT(hr = _PartialIndexCompare(iIndex, cColumns, pBinding, &pChain, piNode, piRow));

                    // Set *pfaChain
                    *pfaChain = pChain->faBlock;
                }

                // We found it
                hr = DB_S_FOUND;

                // Done
                goto exit;
            }

            // Save last middle position
            lLastMiddle = lMiddle;

            // Compute upper and lower
            if (nCompare > 0)
                lLower = lMiddle + 1;
            else
                lUpper = lMiddle - 1;
        }

        // No match was found, is lpSearchKey less than last middle ?
        if (nCompare < 0 && 0 == lLastMiddle)
        {
            // Goto the left, there is no need to update piRow
            faChain = pChain->faLeftChain;
        }

        // Otherwise
        else
        {
            // If nCompare is less than zero, then...
            if (nCompare < 0)
                lLastMiddle--;

            // Compute piRow
            if (piRow && pChain->rgNode[lLastMiddle].faRightChain)
            {
                // Increment piRow with cLeftNodes
                (*piRow) += pChain->cLeftNodes;

                // Include this node
                (*piRow)++;

                // Loop
                for (NODEINDEX iNode=1; iNode<=lLastMiddle; iNode++)
                {
                    // Increment with cRightNodes
                    (*piRow) += pChain->rgNode[iNode - 1].cRightNodes;

                    // Include this node
                    (*piRow)++;
                }
            }

            // Goto the Right
            faChain = pChain->rgNode[lLastMiddle].faRightChain;
        }
    }

    // Set piNode
    *piNode = (NODEINDEX)lMiddle;

    // Return *pnCompare
    if (pnCompare)
        *pnCompare = nCompare;

    // We didn't find it
    hr = DB_S_NOTFOUND;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ExpandChain
//--------------------------------------------------------------------------
HRESULT CDatabase::_ExpandChain(LPCHAINBLOCK pChain, NODEINDEX iNodeBase)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            iNode;
    LPCHAINBLOCK    pRightChain;

    // Trace
    TraceCall("CDatabase::_ExpandChain");

    // Invalid Args
    Assert(pChain && pChain->cNodes > 0 && pChain->cNodes < BTREE_ORDER + 1);
    Assert(iNodeBase <= pChain->cNodes);

    // Loop from iNode to cNodes
    for (iNode = pChain->cNodes - 1; iNode >= iNodeBase; iNode--)
    {
        // Propagate this node up one level
        CopyMemory(&pChain->rgNode[iNode + 1], &pChain->rgNode[iNode], sizeof(CHAINNODE));

        // If there is a right chain
        if (pChain->rgNode[iNode].faRightChain)
        {
            // Get the Right Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pChain->rgNode[iNode].faRightChain, (LPVOID *)&pRightChain));

            // Validate the current Parent
            Assert(pRightChain->faParent == pChain->faBlock);

            // Validate the current index
            Assert(pRightChain->iParent == iNode);

            // Reset the Parent
            pRightChain->iParent = iNode + 1;
        }
    }

    // Increment Node Count
    pChain->cNodes++;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ChainInsert
//--------------------------------------------------------------------------
HRESULT CDatabase::_ChainInsert(INDEXORDINAL iIndex, LPCHAINBLOCK pChain, 
    LPCHAINNODE pNodeLeft, LPNODEINDEX piNodeIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            iNode;
    DWORD           iKey;
    INT             nCompare;
    LPRECORDBLOCK   pBlock;
    LPCHAINNODE     pNodeRight;
    LPCOLUMNTAG     pTagLeft;
    LPCOLUMNTAG     pTagRight;
    RECORDMAP       MapLeft;
    RECORDMAP       MapRight;
    LPTABLEINDEX    pIndex;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("CDatabase::_ChainInsert");

    // Invalid Args
    Assert(pChain && pNodeLeft && pChain->cNodes > 0);

    // Get the Record Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, pNodeLeft->faRecord, (LPVOID *)&pBlock));

    // Get the Record Map
    IF_FAILEXIT(hr = _GetRecordMap(TRUE, pBlock, &MapLeft));

    // De-Reference the Index
    pIndex = &m_pHeader->rgIndexInfo[iIndex];

    // Insert into chain
    for (iNode = pChain->cNodes - 1; iNode >= 0; iNode--)
    {
        // Set pNodeRight
        pNodeRight = &pChain->rgNode[iNode];

        // Get the Record Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_RECORD, pNodeRight->faRecord, (LPVOID *)&pBlock));

        // Get the Left Node
        IF_FAILEXIT(hr = _GetRecordMap(TRUE, pBlock, &MapRight));

        // Loop through the key members
        for (iKey=0; iKey<pIndex->cKeys; iKey++)
        {
            // Readability
            pColumn = &m_pSchema->prgColumn[pIndex->rgKey[iKey].iColumn];

            // Get Left Tag
            pTagLeft = PTagFromOrdinal(&MapLeft, pColumn->iOrdinal);

            // Get the Right Tag
            pTagRight = PTagFromOrdinal(&MapRight, pColumn->iOrdinal);

            // Compare Types
            nCompare = DBTypeCompareRecords(pColumn, &pIndex->rgKey[iKey], pTagLeft, pTagRight, &MapLeft, &MapRight);

            // Done
            if (0 != nCompare)
                break;
        }

        // Insert in this node ?
        if (nCompare >= 0)
            break;
    }

    // Expand the Chain
    IF_FAILEXIT(hr = _ExpandChain(pChain, iNode + 1));

    // Final Insert
    CopyMemory(&pChain->rgNode[iNode + 1], pNodeLeft, sizeof(CHAINNODE));

    // Node
    *piNodeIndex = iNode + 1;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_SplitChainInsert
//--------------------------------------------------------------------------
HRESULT CDatabase::_SplitChainInsert(INDEXORDINAL iIndex, FILEADDRESS faSplit)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    NODEINDEX       iNode;
    CHAINBLOCK      Split;
    DWORD           cLeftNodes;
    DWORD           cRightNodes;
    FILEADDRESS     faChain;
    FILEADDRESS     faLeftChain;
    FILEADDRESS     faRightChain;
    LPCHAINBLOCK    pLeft;
    LPCHAINBLOCK    pRight;
    LPCHAINBLOCK    pParent;
    LPCHAINBLOCK    pSplit;

    // Trace
    TraceCall("CDatabase::_SplitChainInsert");

    // Allocate Space for this chain
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_CHAIN, 0, (LPVOID *)&pLeft));

    // Set faLeftChain
    faLeftChain = pLeft->faBlock;

    // Zero Allocate
    ZeroBlock(pLeft, sizeof(CHAINBLOCK));

    // Get Split Chain Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faSplit, (LPVOID *)&pSplit));

    // Deref the Chain
    CopyMemory(&Split, pSplit, sizeof(CHAINBLOCK));

    // Set faRigthChain
    faRightChain = faSplit;

    // Get Right Chain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faRightChain, (LPVOID *)&pRight));

    // Zero pRight
    ZeroBlock(pRight, sizeof(CHAINBLOCK));

    // Both new child chains will be half filled
    pLeft->cNodes = pRight->cNodes = BTREE_MIN_CAP;

    // Set the Right Chains, left pointer to the middle's right pointer
    pRight->faLeftChain = Split.rgNode[BTREE_MIN_CAP].faRightChain;

    // Adjust faRightChains Parent
    if (pRight->faLeftChain)
    {
        // Locals
        LPCHAINBLOCK pLeftChain;

        // Get Left Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pRight->faLeftChain, (LPVOID *)&pLeftChain));

        // Validate the Current Parent
        Assert(pLeftChain->faParent == pRight->faBlock);

        // Validate the index
        Assert(pLeftChain->iParent == BTREE_MIN_CAP);

        // Reset the Parent Index
        pLeftChain->iParent = 0;
    }

    // Set Left Node Count
    pRight->cLeftNodes = Split.rgNode[BTREE_MIN_CAP].cRightNodes;

    // Set the left chains left chain address to the left chain left chain address
    pLeft->faLeftChain = Split.faLeftChain;

    // Adjust Parents
    if (pLeft->faLeftChain)
    {
        // Locals
        LPCHAINBLOCK pLeftChain;

        // Get Left Chain
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pLeft->faLeftChain, (LPVOID *)&pLeftChain));

        // Validate the index
        Assert(pLeftChain->iParent == 0);

        // Reset faParent
        pLeftChain->faParent = pLeft->faBlock;
    }

    // Set Left Nodes
    pLeft->cLeftNodes = Split.cLeftNodes;

    // Initialize cRightNodes
    cRightNodes = (BTREE_MIN_CAP + pRight->cLeftNodes);

    // Initialize cLeftNodes
    cLeftNodes = (BTREE_MIN_CAP + pLeft->cLeftNodes);

    // This splits the chain
    for (i=0; i<BTREE_MIN_CAP; i++)
    {
        // Copy Right Node
        CopyMemory(&pRight->rgNode[i], &Split.rgNode[i + BTREE_MIN_CAP + 1], sizeof(CHAINNODE));

        // Adjust the Child's iParent ?
        if (pRight->rgNode[i].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Left Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pRight->rgNode[i].faRightChain, (LPVOID *)&pRightChain));

            // Validate the Current Parent
            Assert(pRightChain->faParent == pRight->faBlock);

            // Validate the index
            Assert(pRightChain->iParent == i + BTREE_MIN_CAP + 1);

            // Reset the Parent
            pRightChain->iParent = i;
        }

        // Count All Child Nodes on the Right
        cRightNodes += pRight->rgNode[i].cRightNodes;

        // Copy Left Node
        CopyMemory(&pLeft->rgNode[i], &Split.rgNode[i], sizeof(CHAINNODE));

        // If there is a right chain
        if (pLeft->rgNode[i].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Left Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pLeft->rgNode[i].faRightChain, (LPVOID *)&pRightChain));

            // Validate the Old Parent
            Assert(pRightChain->faParent == Split.faBlock);

            // Validate the index
            Assert(pRightChain->iParent == i);

            // Reset the Parent
            pRightChain->faParent = pLeft->faBlock;
        }

        // Count All Child Nodes on the Left
        cLeftNodes += pLeft->rgNode[i].cRightNodes;
    }

    // Set the middle nodes right chain address to the right chain's start address
    Split.rgNode[BTREE_MIN_CAP].faRightChain = faRightChain;

    // Set Right Nodes
    Split.rgNode[BTREE_MIN_CAP].cRightNodes = cRightNodes;

    // Done with pLeft and pRight
    pLeft = pRight = NULL;

    // Elevate the middle leaf node - Create new root chain, then were done
    if (0 == Split.faParent)
    {
        // Allocate Space for this chain
        IF_FAILEXIT(hr = _AllocateBlock(BLOCK_CHAIN, 0, (LPVOID *)&pParent));

        // ZeroInit
        ZeroBlock(pParent, sizeof(CHAINBLOCK));

        // Set Node count
        pParent->cNodes = 1;

        // Set Left Chain
        pParent->faLeftChain = faLeftChain;

        // Set Left Node Count
        pParent->cLeftNodes = cLeftNodes;

        // Copy the Root Node
        CopyMemory(&pParent->rgNode[0], &Split.rgNode[BTREE_MIN_CAP], sizeof(CHAINNODE));

        // New Root Chain Address
        m_pHeader->rgfaIndex[iIndex] = pParent->faBlock;

        // Get pLeft
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faLeftChain, (LPVOID *)&pLeft));

        // Get Right
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faRightChain, (LPVOID *)&pRight));

        // Set faLeft's faParent
        pRight->faParent = pLeft->faParent = pParent->faBlock;

        // Set faLeft's iParent
        pRight->iParent = pLeft->iParent = 0;
    }

    // Otherwise, locate chainNodeMiddle's parent chain list!
    else
    {
        // De-Reference
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, Split.faParent, (LPVOID *)&pParent));

        // Insert leaf's middle record into the parent
        IF_FAILEXIT(hr = _ChainInsert(iIndex, pParent, &Split.rgNode[BTREE_MIN_CAP], &iNode));

        // Get pLeft
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faLeftChain, (LPVOID *)&pLeft));

        // Get Right
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faRightChain, (LPVOID *)&pRight));

        // Set faLeft's faParent
        pRight->faParent = pLeft->faParent = pParent->faBlock;

        // Update Surrounding Nodes
        if (iNode > 0)
        {
            // Set faRight Chain
            pParent->rgNode[iNode - 1].faRightChain = faLeftChain;

            // Set cRightNodes
            pParent->rgNode[iNode - 1].cRightNodes = cLeftNodes;
        
            // Set faLeft's iParent
            pRight->iParent = (BYTE)iNode;
            
            // Set Left Parent
            pLeft->iParent = iNode - 1;
        }

        // iNode is first node
        else if (iNode == 0)
        {
            // Set faLeftChain
            pParent->faLeftChain = faLeftChain;

            // Set cLeftNodes
            pParent->cLeftNodes = cLeftNodes;

            // Set faLeft's iParent
            pRight->iParent = pLeft->iParent = 0;
        }

        // If Node is FULL, we must do a split insert
        if (pParent->cNodes > BTREE_ORDER)
        {
            // Recursive Split
            IF_FAILEXIT(hr = _SplitChainInsert(iIndex, Split.faParent));
        }

        // Other wise, simply write the updated chain list
        else
        {
            // Increment Parent Record Count
            IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, Split.faParent, 1));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeRecordStorage
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeRecordStorage(OPERATIONTYPE tyOperation,
    FILEADDRESS faRecord)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               i;
    LPVOID              pBinding=NULL;
    LPCTABLECOLUMN      pColumn;

    // Trace
    TraceCall("CDatabase::_FreeRecordStorage");

    // Invalid Args
    Assert(faRecord > 0);

    // Does the record have streams
    if (OPERATION_DELETE == tyOperation && ISFLAGSET(m_pSchema->dwFlags, TSF_HASSTREAMS))
    {
        // Allocate a Record
        IF_NULLEXIT(pBinding = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

        // Load the Record from the file
        IF_FAILEXIT(hr = _ReadRecord(faRecord, pBinding));

        // Walk through the members in the structure
        for (i=0; i<m_pSchema->cColumns; i++)
        {
            // Readability
            pColumn = &m_pSchema->prgColumn[i];

            // Variable Length Member ?
            if (CDT_STREAM == pColumn->type)
            {
                // Get the Starting address of the stream
                FILEADDRESS faStart = *((FILEADDRESS *)((LPBYTE)pBinding + pColumn->ofBinding));

                // Release Stream Storage...
                if (faStart > 0)
                {
                    // Delete the Stream
                    DeleteStream(faStart);
                }
            }
        }
    }

    // Free the base record
    IF_FAILEXIT(hr = _FreeBlock(BLOCK_RECORD, faRecord));

exit:
    // Cleanup
    SafeFreeBinding(pBinding);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::DeleteStream
//--------------------------------------------------------------------------
HRESULT CDatabase::DeleteStream(FILEADDRESS faStart)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    HLOCK           hLock=NULL;
    BOOL            fFound=FALSE;

    // Trace
    TraceCall("CDatabase::DeleteStream");

    // See if this stream is currently open any where...
    if (0 == faStart)
        return TraceResult(E_INVALIDARG);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Look for faStart in the stream table
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Is this it ?
        if (faStart == m_pShare->rgStream[i].faStart)
        {
            // The Stream Must be Open
            Assert(m_pShare->rgStream[i].cOpenCount > 0);

            // Mark the stream for delete on close
            m_pShare->rgStream[i].fDeleteOnClose = TRUE;

            // Not that I found It
            fFound = TRUE;

            // Done
            break;
        }
    }

    // If we didn't find it, then lets free the storage
    if (FALSE == fFound)
    {
        // Free the Stream Storage
        IF_FAILEXIT(hr = _FreeStreamStorage(faStart));
    }

    // Update the Version
    m_pShare->dwVersion++;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_StreamSychronize
//--------------------------------------------------------------------------
HRESULT CDatabase::_StreamSychronize(CDatabaseStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    LPOPENSTREAM    pInfo;
    LPSTREAMBLOCK   pBlock;
    DWORD           iBlock=0;
    BOOL            fFound=FALSE;
    IF_DEBUG(DWORD  cbOffset=0;)
    FILEADDRESS     faCurrent;

    // Trace
    TraceCall("CDatabase::_StreamSychronize");

    // Invalid Args
    Assert(pStream);

    // Get Stream Info
    pInfo = &m_pShare->rgStream[pStream->m_iStream];

    // Validate
    if (pInfo->faStart == pStream->m_faStart)
        goto exit;

    // Set faCurrent
    faCurrent = pInfo->faStart;

    // Loop until I find pStream->m_iCurrent
    while (faCurrent > 0)
    {
        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faCurrent, (LPVOID *)&pBlock));

        // Validate
        Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

        // Is this It ?
        if (iBlock == pStream->m_iCurrent)
        {
            // We Found It
            fFound = TRUE;

            // Save m_faCurrent
            pStream->m_faCurrent = faCurrent;

            // Validate Size
            Assert(pStream->m_cbCurrent <= pBlock->cbData && cbOffset + pStream->m_cbCurrent == pStream->m_cbOffset);

            // Done
            break;
        }

        // Goto Next
        faCurrent = pBlock->faNext;

        // Increment iBlock
        iBlock++;

        // Increment cbOffset
        IF_DEBUG(cbOffset += pBlock->cbData;)
    }

    // If not found...
    if (FALSE == fFound)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Reset Start Address
    pStream->m_faStart = pInfo->faStart;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamCompareDatabase
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamCompareDatabase(CDatabaseStream *pStream, 
    IDatabase *pDatabase)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLockSrc=NULL;
    HLOCK           hLockDst=NULL;
    CDatabase      *pDB=NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLockSrc));

    // Lock the Dst
    IF_FAILEXIT(hr = pDatabase->Lock(&hLockDst));

    // QI for CDatabase
    IF_FAILEXIT(hr = pDatabase->QueryInterface(IID_CDatabase, (LPVOID *)&pDB));

    // Compare m_pStorage->pszMap
    hr = (0 == StrCmpIW(m_pStorage->pszMap, pDB->m_pStorage->pszMap)) ? S_OK : S_FALSE;

exit:
    // Cleanup
    SafeRelease(pDB);

    // Mutal Exclusion
    Unlock(&hLockSrc);
    pDatabase->Unlock(&hLockDst);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetStreamAddress
//--------------------------------------------------------------------------
HRESULT CDatabase::GetStreamAddress(CDatabaseStream *pStream, 
    LPFILEADDRESS pfaStream)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Get the address
    *pfaStream = pStream->m_faStart;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamRead
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamRead(CDatabaseStream *pStream, LPVOID pvData,
    ULONG cbWanted, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;
    LPBYTE          pbMap;
    DWORD           cbRead=0;
    DWORD           cbGet;
    LPSTREAMBLOCK   pBlock;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::_StreamRead");

    // Init pcbRead
    if (pcbRead)
        *pcbRead = 0;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Args
    Assert(pStream && pvData);

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Loop and Read
    while (cbRead < cbWanted)
    {
        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pStream->m_faCurrent, (LPVOID *)&pBlock));

        // Time to go to the next block ?
        if (pStream->m_cbCurrent == pBlock->cbData && 0 != pBlock->faNext)
        {
            // Set m_faCurrent
            pStream->m_faCurrent = pBlock->faNext;

            // Increment m_iCurrent
            pStream->m_iCurrent++;

            // Reset offset into current block
            pStream->m_cbCurrent = 0;

            // Valid stream Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pStream->m_faCurrent, (LPVOID *)&pBlock));
        }

        // Validate
        Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

        // Validate the Offset
        Assert(pStream->m_cbCurrent <= pBlock->cbData);

        // Determine how much we can read from the current block ?
        cbGet = min(cbWanted - cbRead, pBlock->cbData - pStream->m_cbCurrent);

        // Nothing left to get
        if (cbGet == 0)
            break;

        // Read some bytes
        pbMap = ((LPBYTE)pBlock + sizeof(STREAMBLOCK));

        // Copy the Data
        CopyMemory((LPBYTE)pvData + cbRead, pbMap + pStream->m_cbCurrent, cbGet);

        // Increment Amount of Data Read
        cbRead += cbGet;

        // Increment Offset within Current Block
        pStream->m_cbCurrent += cbGet;

        // Global Offset
        pStream->m_cbOffset += cbGet;
    }

    // Init pcbRead
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamWrite
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamWrite(CDatabaseStream *pStream, const void *pvData,
    ULONG cb, ULONG *pcbWrote)
{
    // Locals
    HRESULT         hr=S_OK;
    LPBYTE          pbMap;
    DWORD           cbWrote=0;
    DWORD           cbPut;
    LPSTREAMBLOCK   pBlock;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::StreamWrite");

    // Init pcbRead
    if (pcbWrote)
        *pcbWrote = 0;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Args
    Assert(pStream && pStream->m_tyAccess == ACCESS_WRITE && pvData);

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Loop and Read
    while (cbWrote < cb)
    {
        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pStream->m_faCurrent, (LPVOID *)&pBlock));

        // Validate
        Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

        // Validation
        Assert(pStream->m_cbCurrent <= pBlock->cbData);

        // Have we written to the end of the current block and there are more blocks
        if (pStream->m_cbCurrent == pBlock->cbSize)
        {
            // Are there more blocks
            if (0 == pBlock->faNext)
            {
                // Locals
                LPSTREAMBLOCK pBlockNew;

                // Allocate a block in the tree
                IF_FAILEXIT(hr = _AllocateBlock(BLOCK_STREAM, 0, (LPVOID *)&pBlockNew));

                // Get the Current Stream Block
                IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pStream->m_faCurrent, (LPVOID *)&pBlock));

                // Set the next block address on the current block
                pBlock->faNext = pBlockNew->faBlock;

                // Access the block
                pBlock = pBlockNew;

                // Initial 0 data
                pBlock->cbData = 0;

                // No next block
                pBlock->faNext = 0;
            }

            // Otherwise, move to the next block
            else
            {
                // Save faBlcok
                IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, pBlock->faNext, (LPVOID *)&pBlock));
            }

            // Set m_faCurrent
            pStream->m_faCurrent = pBlock->faBlock;

            // Increment the block index
            pStream->m_iCurrent++;

            // Reset the Current Block Offset
            pStream->m_cbCurrent = 0;

            // Validate
            Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);
        }

        // Compute how much of the cb we can write
        cbPut = min(cb - cbWrote, pBlock->cbSize - pStream->m_cbCurrent);

        // Read some bytes
        pbMap = ((LPBYTE)pBlock + sizeof(STREAMBLOCK));

        // Check memory
        //Assert(FALSE == IsBadWritePtr(pbMap, cbPut));

        // Check memory
        //Assert(FALSE == IsBadReadPtr((LPBYTE)pvData + cbWrote, cbPut));

        // Copy the Data
        CopyMemory(pbMap + pStream->m_cbCurrent, (LPBYTE)pvData + cbWrote, cbPut);

        // Increment the Offset within the current block
        pStream->m_cbCurrent += cbPut;

        // Increment the Offset within the current block
        pStream->m_cbOffset += cbPut;

        // Increment the Amount that has been wrote
        cbWrote += cbPut;

        // Increment the amount of data in the block only if we are expanding its size
        if (0 == pBlock->faNext && pStream->m_cbCurrent > pBlock->cbData)
        {
            // Set the Amount of Data in this block
            pBlock->cbData = pStream->m_cbCurrent;
        }

        // Otherwise, the block should be full
        else
            Assert(pBlock->cbData == pBlock->cbSize);
    }

    // Init pcbRead
    if (pcbWrote)
        *pcbWrote = cbWrote;

    // Update Version
    m_pShare->dwVersion++;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamSeek
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamSeek(CDatabaseStream *pStream, LARGE_INTEGER liMove,
    DWORD dwOrigin, ULARGE_INTEGER *pulNew)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbNewOffset;
    LONG            lOffset;
    DWORD           cbSize=0;
    FILEADDRESS     faBlock;
    LPSTREAMBLOCK   pBlock;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::StreamSeek");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Args
    Assert(pStream && 0 == liMove.HighPart);

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Cast lowpart
    lOffset = (LONG)liMove.LowPart;

    // STREAM_SEEK_CUR
    if (STREAM_SEEK_CUR == dwOrigin)
    {
        // Validate
        if (lOffset < 0 && (DWORD)(0 - lOffset) > pStream->m_cbOffset)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Set new Offset...
        cbNewOffset = (pStream->m_cbOffset + lOffset);
    }

    // STREAM_SEEK_END
    else if (STREAM_SEEK_END == dwOrigin)
    {
        // Compute Size...from current offset
        faBlock = pStream->m_faCurrent;

        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faBlock, (LPVOID *)&pBlock));

        // Validate
        Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

        // Validation
        Assert(pStream->m_cbCurrent <= pBlock->cbData && pStream->m_cbCurrent <= pBlock->cbSize);

        // Set cbSize
        cbSize = pStream->m_cbOffset + (pBlock->cbData - pStream->m_cbCurrent);

        // Goto the next block
        faBlock = pBlock->faNext;

        // While
        while (faBlock > 0)
        {
            // Valid stream Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faBlock, (LPVOID *)&pBlock));

            // Validate
            Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

            // Increment cbSize
            cbSize += pBlock->cbData;

            // Set faBlock
            faBlock = pBlock->faNext;
        }

        // If lOffset is negative and absolutely larger than the size of the stream
        if (lOffset > 0 || (lOffset < 0 && (DWORD)(0 - lOffset) > cbSize))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Save new offset
        cbNewOffset = cbSize + lOffset;
    }

    // STREAM_SEEK_SET
    else
    {
        // Can't be negative
        if (lOffset < 0)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Save new offset
        cbNewOffset = lOffset;
    }

    // Did the offset change
    if (cbNewOffset != pStream->m_cbOffset)
    {
        // Reset Current Position
        pStream->m_faCurrent = pStream->m_faStart;
        pStream->m_cbCurrent = 0;
        pStream->m_iCurrent = 0;
        pStream->m_cbOffset = 0;

        // Initialize the loop
        faBlock = pStream->m_faStart;

        // Lets seek from the start of the stream to the new offset
        while (faBlock > 0)
        {
            // Valid stream Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faBlock, (LPVOID *)&pBlock));

            // Validate
            Assert(0 == pBlock->faNext ? TRUE : pBlock->cbData == pBlock->cbSize);

            // Save some stuff
            pStream->m_faCurrent = pBlock->faBlock;

            // Is this the block we want ?
            if (pStream->m_cbOffset + pBlock->cbData >= cbNewOffset)
            {
                // Compute m_cbCurrent
                pStream->m_cbCurrent = (cbNewOffset - pStream->m_cbOffset);

                // Set m_cbOffset
                pStream->m_cbOffset += pStream->m_cbCurrent;

                // Done
                break;
            }

            // Set m_cbCurrent
            pStream->m_cbCurrent = pBlock->cbData;

            // Increment global offset
            pStream->m_cbOffset += pBlock->cbData;

            // Increment Index
            pStream->m_iCurrent++;

            // Goto Next
            faBlock = pBlock->faNext;
        }
    }

    // Return Position
    if (pulNew)
        pulNew->LowPart = pStream->m_cbOffset;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamGetAddress
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamGetAddress(CDatabaseStream *pStream, LPFILEADDRESS pfaStart)
{
    // Locals
    HRESULT         hr=S_OK;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::StreamGetAddress");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Invalid Args
    Assert(pStream);

    // StreamSychronize
    IF_FAILEXIT(hr = _StreamSychronize(pStream));

    // Return the Address
    *pfaStart = pStream->m_faStart;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::StreamRelease
//--------------------------------------------------------------------------
HRESULT CDatabase::StreamRelease(CDatabaseStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    LPOPENSTREAM    pInfo;
    HLOCK           hLock=NULL;

    // Trace
    TraceCall("CDatabase::StreamRelease");

    // Invalid Args
    Assert(pStream);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Validate
    Assert(m_pShare->rgStream);

    // Cast iStream
    pInfo = &m_pShare->rgStream[pStream->m_iStream];

    // Better have a reference count
    Assert(pInfo->cOpenCount > 0);

    // Decrement cOpenCount
    pInfo->cOpenCount--;

    // Reset the Lock Count based on the access type
    if (ACCESS_WRITE == pStream->m_tyAccess)
    {
        // Validate the lLock
        Assert(LOCK_VALUE_WRITER == pInfo->lLock && 0 == pInfo->cOpenCount);

        // Set to none
        pInfo->lLock = LOCK_VALUE_NONE;
    }

    // Otherwise, must have been locked for a read
    else
    {
        // Validate
        Assert(ACCESS_READ == pStream->m_tyAccess && pInfo->lLock > 0);

        // Validate Lock count
        pInfo->lLock--;
    }

    // If this was the last reference...
    if (0 == pInfo->cOpenCount)
    {
        // If the stream is marked for deletion
        if (TRUE == pInfo->fDeleteOnClose)
        {
            // Validate Start Address
            Assert(pInfo->faStart > 0);

            // Free the Storage
            IF_FAILEXIT(hr = _FreeStreamStorage(pInfo->faStart));
        }

        // Zero Out This Entry
        ZeroMemory(pInfo, sizeof(OPENSTREAM));
    }

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeStreamStorage
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeStreamStorage(FILEADDRESS faStart)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAMBLOCK   pBlock;
    FILEADDRESS     faCurrent;

    // Trace
    TraceCall("CDatabase::_FreeStreamStorage");

    // Invalid Args
    Assert(faStart > 0);

    // Initialize Loop
    faCurrent = faStart;

    // Read through all of the blocks (i.e. verify headers and count the number of chains)
    while (faCurrent)
    {
        // Valid stream Block
        IF_FAILEXIT(hr = _GetBlock(BLOCK_STREAM, faCurrent, (LPVOID *)&pBlock));

        // Set faCurrent
        faCurrent = pBlock->faNext;

        // Read the header
        IF_FAILEXIT(hr = _FreeBlock(BLOCK_STREAM, pBlock->faBlock));
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::CreateStream
//--------------------------------------------------------------------------
HRESULT CDatabase::CreateStream(LPFILEADDRESS pfaStream)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faStart=0;
    HLOCK           hLock=NULL;
    LPSTREAMBLOCK   pStream;

    // Trace
    TraceCall("CDatabase::CreateStream");

    // Invalid Arg
    Assert(pfaStream);

    // Initialize
    *pfaStream = NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Allocate the first 512 block of the stream
    IF_FAILEXIT(hr = _AllocateBlock(BLOCK_STREAM, 0, (LPVOID *)&pStream));

    // Write the Initialize Header
    pStream->cbData = 0;
    pStream->faNext = 0;

    // Return the block
    *pfaStream = pStream->faBlock;

    // Modify the Version
    m_pShare->dwVersion++;

exit:
    // Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::CopyStream
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::CopyStream(IDatabase *pDatabase, FILEADDRESS faStream,
    LPFILEADDRESS pfaNew)
{
    // Locals
    HRESULT             hr=S_OK;
    FILEADDRESS         faNew=0;
    DWORD               cbRead;
    HLOCK               hLock=NULL;
    BYTE                rgbBuffer[4096];
    IStream            *pStmDst=NULL;
    IStream            *pStmSrc=NULL;

    // Trace
    TraceCall("CDatabase::CopyStream");

    // Invalid Arg
    if (NULL == pDatabase || 0 == faStream || NULL == pfaNew)
        return(TraceResult(E_INVALIDARG));

    // Initialize
    *pfaNew = NULL;

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Allocate a Stream in the Destination Database
    IF_FAILEXIT(hr = pDatabase->CreateStream(&faNew));

    // Open It Dst
    IF_FAILEXIT(hr = pDatabase->OpenStream(ACCESS_WRITE, faNew, &pStmDst));

    // Open It Src
    IF_FAILEXIT(hr = OpenStream(ACCESS_READ, faStream, &pStmSrc));

    // Read and Write...
    while (1)
    {
        // Read a Block From the Source
        IF_FAILEXIT(hr = pStmSrc->Read(rgbBuffer, sizeof(rgbBuffer), &cbRead));

        // Done
        if (0 == cbRead)
            break;

        // Write It
        IF_FAILEXIT(hr = pStmDst->Write(rgbBuffer, cbRead, NULL));

        // Yield Compacting
        if (m_pShare->fCompacting && m_fCompactYield)
        {
            // Give up a timeslice
            Sleep(0);
        }
    }

    // Comit the Dest
    IF_FAILEXIT(hr = pStmDst->Commit(STGC_DEFAULT));

    // Modify the Version
    *pfaNew = faNew;

    // Don't Free It
    faNew = 0;

exit:
    // Cleanup
    SafeRelease(pStmDst);
    SafeRelease(pStmSrc);

    // Failure
    if (faNew)
    {
        // Delete the Stream
        SideAssert(SUCCEEDED(pDatabase->DeleteStream(faNew)));
    }

    // Thread Safety
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::ChangeStreamLock
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::ChangeStreamLock(IStream *pStream, ACCESSTYPE tyAccessNew)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPOPENSTREAM        pInfo;
    CDatabaseStream    *pDBStream=NULL;

    // Trace
    TraceCall("CDatabase::ChangeStreamLock");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Get Private Stream
    IF_FAILEXIT(hr = pStream->QueryInterface(IID_CDatabaseStream, (LPVOID *)&pDBStream));

    // Get Stream Info
    pInfo = &m_pShare->rgStream[pDBStream->m_iStream];

    // Going to Writer
    if (ACCESS_WRITE == tyAccessNew)
    {
        // Already Locked for Write
        if (LOCK_VALUE_WRITER == pInfo->lLock)
        {
            Assert(ACCESS_WRITE == pDBStream->m_tyAccess);
            goto exit;
        }

        // If more than one reader
        if (pInfo->lLock > 1)
        {
            hr = TraceResult(DB_E_LOCKEDFORREAD);
            goto exit;
        }

        // Change Lock Type
        pInfo->lLock = LOCK_VALUE_WRITER;

        // Write Access
        pDBStream->m_tyAccess = ACCESS_WRITE;
    }

    // Otherwise, change to read...
    else
    {
        // Validate
        Assert(ACCESS_READ == tyAccessNew);

        // If already locked for read
        if (LOCK_VALUE_WRITER != pInfo->lLock)
        {
            Assert(ACCESS_READ == pDBStream->m_tyAccess);
            goto exit;
        }

        // Change to 1 reader
        pInfo->lLock = 1;

        // Read Access
        pDBStream->m_tyAccess = ACCESS_READ;
    }

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Cleanup
    SafeRelease(pDBStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::OpenStream
//--------------------------------------------------------------------------
HRESULT CDatabase::OpenStream(ACCESSTYPE tyAccess, FILEADDRESS faStart,
    IStream **ppStream)
{
    // Locals
    HRESULT          hr=S_OK;
    STREAMINDEX      i;
    STREAMINDEX      iStream=INVALID_STREAMINDEX;
    STREAMINDEX      iFirstUnused=INVALID_STREAMINDEX;
    LPOPENSTREAM     pInfo;
    HLOCK            hLock=NULL;
    CDatabaseStream *pStream=NULL;

    // Trace
    TraceCall("CDatabase::OpenStream");

    // Invalid Arg
    if (0 == faStart || NULL == ppStream)
        return TraceResult(E_INVALIDARG);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Validate
    Assert(m_pShare->rgStream);

    // Does the faStart Stream Exist in my stream table
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Is this the stream
        if (faStart == m_pShare->rgStream[i].faStart)
        {
            // This must already be locked for write or read
            Assert(LOCK_VALUE_WRITER == m_pShare->rgStream[i].lLock || m_pShare->rgStream[i].lLock > 0);

            // Get Access
            if (ACCESS_WRITE == tyAccess)
            {
                hr = TraceResult(DB_E_LOCKEDFORREAD);
                goto exit;
            }

            // Otheriwise, get read lock
            else
            {
                // If Locked for a write
                if (LOCK_VALUE_WRITER == m_pShare->rgStream[i].lLock)
                {
                    hr = TraceResult(DB_E_LOCKEDFORWRITE);
                    goto exit;
                }
            }

            // Set iStream
            iStream = i;

            // Increment Open Count for this stream
            m_pShare->rgStream[i].cOpenCount++;

            // I Must have got a read lock
            Assert(ACCESS_READ == tyAccess && m_pShare->rgStream[i].lLock > 0);

            // Increment Reader Count
            m_pShare->rgStream[i].lLock++;
        }

        // If this entry is unused, lets remember it
        if (FALSE == m_pShare->rgStream[i].fInUse && INVALID_STREAMINDEX == iFirstUnused)
            iFirstUnused = i;
    }

    // If we didn't find faStart in the stream table, append an entry ?
    if (INVALID_STREAMINDEX == iStream)
    {
        // Is there enought space
        if (INVALID_STREAMINDEX == iFirstUnused)
        {
            hr = TraceResult(DB_E_STREAMTABLEFULL);
            goto exit;
        }

        // Set iStream
        iStream = iFirstUnused;

        // Readability
        pInfo = &m_pShare->rgStream[iStream];

        // This entry is now in use
        pInfo->fInUse = TRUE;

        // Register the starting address of this stream
        pInfo->faStart = faStart;

        // Reader or Writer ?
        pInfo->lLock = (ACCESS_WRITE == tyAccess) ? LOCK_VALUE_WRITER : (m_pShare->rgStream[i].lLock + 1);

        // Set Open count
        pInfo->cOpenCount++;
    }

    // Allocate an Object Database Stream
    IF_NULLEXIT(pStream = new CDatabaseStream(this, iStream, tyAccess, faStart));

    // Return
    *ppStream = (IStream *)pStream;
    pStream = NULL;

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Cleanup
    SafeRelease(pStream);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CollapseChain
//--------------------------------------------------------------------------
HRESULT CDatabase::_CollapseChain(LPCHAINBLOCK pChain, NODEINDEX iDelete)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;

    // Trace
    TraceCall("CDatabase::_CollapseChain");

    // Simply set node[i] = node[i+1]; cNodes -= 1; Write the Chain !
    for (i=iDelete; i<pChain->cNodes - 1; i++)
    {
        // Copy i + 1 chain node down one
        CopyMemory(&pChain->rgNode[i], &pChain->rgNode[i + 1], sizeof(CHAINNODE));

        // If there is a right chain
        if (pChain->rgNode[i].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Right Chain block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pChain->rgNode[i].faRightChain, (LPVOID *)&pRightChain));

            // Validate the current Parent
            Assert(pRightChain->faParent == pChain->faBlock);

            // Validate the current index
            Assert(pRightChain->iParent == i + 1);

            // Reset the Parent
            pRightChain->iParent = i;
        }
    }

    // Decrement count
    pChain->cNodes--;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_IndexDeleteRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_IndexDeleteRecord(INDEXORDINAL iIndex, 
    FILEADDRESS faDelete, NODEINDEX iDelete)
{
    // Locals
    HRESULT           hr=S_OK;
    HRESULT           hrIsLeafChain;
    NODEINDEX         i;
    LPCHAINBLOCK      pDelete;
    CHAINSHARETYPE    tyShare;
    CHAINDELETETYPE   tyDelete;
    FILEADDRESS       faShare;
    LPCHAINBLOCK      pSuccessor;
    FILEADDRESS       faRecord;

    // Trace
    TraceCall("CDatabase::_IndexDeleteRecord");

    // Invalid Args
    Assert(iDelete < BTREE_ORDER);

    // Get Block
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faDelete, (LPVOID *)&pDelete));

    // Is this a leaf node
    hrIsLeafChain = _IsLeafChain(pDelete);

    // Case 1: Deleting a leaf node that does not violate the minimum capcity constraint
    if (S_OK == hrIsLeafChain && (pDelete->cNodes - 1 >= BTREE_MIN_CAP || 0 == pDelete->faParent))
    {
        // Collapse the Chain
        _CollapseChain(pDelete, iDelete);

        // Update the Parent Node Count
        IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, faDelete, -1));

        // Did we just delete the root chain
        if (0 == pDelete->faParent && 0 == pDelete->cNodes)
        {
            // Add pShare to free list
            IF_FAILEXIT(hr = _FreeBlock(BLOCK_CHAIN, faDelete));

            // Update the header, we don't have any more nodes
            m_pHeader->rgfaIndex[iIndex] = 0;
        }
    }

    // Case 2: Deleting from a nonleaf node and replacing that record with a record from a leaf node that does not violate the minimum capacity contstraint.
    else if (S_FALSE == hrIsLeafChain)
    {
        // Get Inorder Successor
        IF_FAILEXIT(hr = _GetInOrderSuccessor(faDelete, iDelete, &pSuccessor));

        // Free Tree Block
        faRecord = pDelete->rgNode[iDelete].faRecord;

        // Free Tree Block
        pDelete->rgNode[iDelete].faRecord = pSuccessor->rgNode[0].faRecord;

        // Delete pSuccessor->rgNode[0] - and the record which we just replaced
        pSuccessor->rgNode[0].faRecord = faRecord;

        // Delete this node
        IF_FAILEXIT(hr = _IndexDeleteRecord(iIndex, pSuccessor->faBlock, 0));
    }

    // Case 3: Deleting from a leaf node that causes a minimum capacity constraint violation that can be corrected by redistributing the records with an adjacent sibling node.
    else
    {
        // Decide if I need to do a shared or coalesce type delete
        IF_FAILEXIT(hr = _DecideHowToDelete(&faShare, faDelete, &tyDelete, &tyShare));

        // Collapse the Chain
        _CollapseChain(pDelete, iDelete);

        // If NULL, then do a coalesc
        if (CHAIN_DELETE_SHARE == tyDelete)
        {
            // Adjust the Parent's Parents
            IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, faDelete, -1));

            // Do a shared deleted
            IF_FAILEXIT(hr = _ChainDeleteShare(iIndex, faDelete, faShare, tyShare));
        }

        // Coalesce Type Delete
        else
        {
            // Validate the delete type
            Assert(faShare && CHAIN_DELETE_COALESCE == tyDelete && pDelete->faParent != 0);

            // Adjust the Parent's Parents
            IF_FAILEXIT(hr = _AdjustParentNodeCount(iIndex, pDelete->faParent, -1));

            // Do a coalescing delete
            IF_FAILEXIT(hr = _ChainDeleteCoalesce(iIndex, faDelete, faShare, tyShare));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_IsLeafChain
//--------------------------------------------------------------------------
HRESULT CDatabase::_IsLeafChain(LPCHAINBLOCK pChain)
{
    // If Left Chain is NULL, then all chains must be null
    return (0 == pChain->faLeftChain) ? S_OK : S_FALSE;
}

//--------------------------------------------------------------------------
// CDatabase::_ChainDeleteShare
//--------------------------------------------------------------------------
HRESULT CDatabase::_ChainDeleteShare(INDEXORDINAL iIndex,
    FILEADDRESS faDelete, FILEADDRESS faShare, CHAINSHARETYPE tyShare)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    NODEINDEX       iInsert;
    NODEINDEX       iParent;
    FILEADDRESS     faParentRightChain;
    DWORD           cParentRightNodes;
    DWORD           cCopyNodes;
    LPCHAINBLOCK    pDelete;
    LPCHAINBLOCK    pShare;
    LPCHAINBLOCK    pParent;

    // Trace
    TraceCall("CDatabase::_ChainDeleteShare");

    // Invalid ARgs
    Assert(faDelete && faShare);

    // Get pShare
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faShare, (LPVOID *)&pShare));

    // Get the Parent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pShare->faParent, (LPVOID *)&pParent));

    // Get pDelete
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faDelete, (LPVOID *)&pDelete));

    // Validation
    Assert(pShare->faParent == pDelete->faParent);

    // Setup iParent
    iParent = (CHAIN_SHARE_LEFT == tyShare) ? pDelete->iParent : pShare->iParent;

    // Save Paren't Right Chain, we are going to replace iParent with the last left or first right node
    faParentRightChain = pParent->rgNode[iParent].faRightChain;

    // Save the cParentRightNodes
    cParentRightNodes = pParent->rgNode[iParent].cRightNodes;

    // Insert Parent Node into lpChainFound - Parent Pointers stay the same
    pParent->rgNode[iParent].faRightChain = 0;

    // Reset cRightNodes
    pParent->rgNode[iParent].cRightNodes = 0;

    // Insert the parent node into the chain that we are deleting from
    IF_FAILEXIT(hr = _ChainInsert(iIndex, pDelete, &pParent->rgNode[iParent], &iInsert));

    // If promoting from the Left, promote Node: cNodes-1 to parent
    if (CHAIN_SHARE_LEFT == tyShare)
    {
        // Should have inserted at position zero
        Assert(0 == iInsert);

        // Promote Node: 0 to from the deletion node into the parent node
        pDelete->rgNode[0].faRightChain = pDelete->faLeftChain;

        // Propagate cLeftNodes to cRightNodes
        pDelete->rgNode[0].cRightNodes = pDelete->cLeftNodes;

        // Update Left Chain Address
        pDelete->faLeftChain = pShare->rgNode[pShare->cNodes - 1].faRightChain;

        // Update the left chain's parent
        if (pDelete->faLeftChain)
        {
            // Locals
            LPCHAINBLOCK pLeftChain;

            // Get Left
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->faLeftChain, (LPVOID *)&pLeftChain));

            // Set faParent
            pLeftChain->faParent = pDelete->faBlock;

            // Set iParent
            pLeftChain->iParent = 0;
        }

        // Update Left Chain Node count
        pDelete->cLeftNodes = pShare->rgNode[pShare->cNodes - 1].cRightNodes;

        // Save cCopyNodes
        cCopyNodes = pDelete->cLeftNodes + 1;

        // Copy the node from the left share chain into the parent's spot
        CopyMemory(&pParent->rgNode[iParent], &pShare->rgNode[pShare->cNodes - 1], sizeof(CHAINNODE));

        // Reset the right chain on the parent
        pParent->rgNode[iParent].faRightChain = faParentRightChain;

        // Reset the right node count on the parent
        pParent->rgNode[iParent].cRightNodes = cParentRightNodes;

        // Decrement number of nodes in the share chain
        pShare->cNodes--;
    
        // Special case, pShare is to the left of the first node of the parent chain
        if (0 == iParent)
        {
            // Can not be the left chain, otherwise, we wouldn't be sharing from the right
            Assert(pShare->faBlock == pParent->faLeftChain && pParent->cLeftNodes > cCopyNodes);

            // Decrement Right Node Count
            pParent->cLeftNodes -= cCopyNodes;

            // Increment
            pParent->rgNode[0].cRightNodes += cCopyNodes;
        }

        // Otherwise, Decrement cRightNodes
        else
        {
            // Validate share left chain
            Assert(pShare->faBlock == pParent->rgNode[iParent - 1].faRightChain && pParent->rgNode[iParent - 1].cRightNodes > cCopyNodes);

            // Decrement Right Nodes Count
            pParent->rgNode[iParent - 1].cRightNodes -= cCopyNodes;

            // Validate Right Chain
            Assert(pParent->rgNode[iParent].faRightChain == pDelete->faBlock && iParent == pDelete->iParent && pDelete->iParent < pParent->cNodes);

            // Increment Right Nodes Count
            pParent->rgNode[iParent].cRightNodes += cCopyNodes;
        }
    }

    // Otherwise, share from the right
    else
    {
        // Verify the share type
        Assert(CHAIN_SHARE_RIGHT == tyShare && pDelete->cNodes - 1 == iInsert);

        // Promote Node: 0 to parent
        pDelete->rgNode[pDelete->cNodes - 1].faRightChain = pShare->faLeftChain;

        // Update the Right Chain's Parent
        if (pDelete->rgNode[pDelete->cNodes - 1].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Right Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->rgNode[pDelete->cNodes - 1].faRightChain, (LPVOID *)&pRightChain));

            // Set faParent
            pRightChain->faParent = pDelete->faBlock;

            // Set iParent
            pRightChain->iParent = (pDelete->cNodes - 1);
        }

        // Set cRightNodes Count
        pDelete->rgNode[pDelete->cNodes - 1].cRightNodes = pShare->cLeftNodes;

        // Save cCopyNodes
        cCopyNodes = pDelete->rgNode[pDelete->cNodes - 1].cRightNodes + 1;

        // Tree Shift
        pShare->faLeftChain = pShare->rgNode[0].faRightChain;

        // Tree Shift
        pShare->cLeftNodes = pShare->rgNode[0].cRightNodes;

        // Copy the node from the share chain to the parent
        CopyMemory(&pParent->rgNode[iParent], &pShare->rgNode[0], sizeof(CHAINNODE));

        // Collapse this Chain
        _CollapseChain(pShare, 0);

        // Reset the right chain on the parent
        pParent->rgNode[iParent].faRightChain = faParentRightChain;

        // Reset the right node count on the parent
        pParent->rgNode[iParent].cRightNodes = cParentRightNodes;

        // Special case, pShare is to the left of the first node of the parent chain
        if (0 == iParent)
        {
            // Can not be the left chain, otherwise, we wouldn't be sharing from the right
            Assert(pParent->rgNode[0].faRightChain == pShare->faBlock && pParent->rgNode[0].cRightNodes > cCopyNodes);

            // Decrement Right Node Count
            pParent->rgNode[0].cRightNodes -= cCopyNodes;

            // Validate
            Assert(pParent->faLeftChain == pDelete->faBlock);

            // Increment
            pParent->cLeftNodes += cCopyNodes;
        }

        // Otherwise, Decrement cRightNodes
        else
        {
            // Validate share left chain
            Assert(pShare->faBlock == pParent->rgNode[iParent].faRightChain && pParent->rgNode[iParent].cRightNodes > 0);

            // Decrement Right Node Count
            pParent->rgNode[iParent].cRightNodes -= cCopyNodes;

            // Validate
            Assert(pParent->rgNode[iParent - 1].faRightChain == pDelete->faBlock);

            // Increment Left Sibling
            pParent->rgNode[iParent - 1].cRightNodes += cCopyNodes;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ChainDeleteCoalesce
//--------------------------------------------------------------------------
HRESULT CDatabase::_ChainDeleteCoalesce(INDEXORDINAL iIndex,
    FILEADDRESS faDelete, FILEADDRESS faShare, CHAINSHARETYPE tyShare)
{
    // Locals
    HRESULT             hr=S_OK;
    NODEINDEX           i;
    NODEINDEX           iInsert;
    NODEINDEX           iParent;
    LPCHAINBLOCK        pParent;
    LPCHAINBLOCK        pDelete;
    LPCHAINBLOCK        pShare;
    FILEADDRESS         faShareAgain;
    CHAINDELETETYPE     tyDelete;
    DWORD               cRightNodes;

    // Trace
    TraceCall("CDatabase::_ChainDeleteCoalesce");

    // Invalid ARgs
    Assert(faDelete && faShare);

    // Get pShare
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faShare, (LPVOID *)&pShare));

    // Get the Parent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pShare->faParent, (LPVOID *)&pParent));

    // Get pDelete
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faDelete, (LPVOID *)&pDelete));

    // Validation
    Assert(pShare->faParent == pDelete->faParent);

    // Setup iParent
    iParent = (CHAIN_SHARE_LEFT == tyShare) ? pDelete->iParent : pShare->iParent;

    // Insert the Parent
    IF_FAILEXIT(hr = _ChainInsert(iIndex, pDelete, &pParent->rgNode[iParent], &iInsert));

    // Set newly inserted nodes pointers
    if (CHAIN_SHARE_LEFT == tyShare)
    {
        // Validate
        Assert(0 == iInsert);

        // Adjust the right Chain
        pDelete->rgNode[0].faRightChain = pDelete->faLeftChain;

        // Adjust the right node count
        pDelete->rgNode[0].cRightNodes = pDelete->cLeftNodes;

        // Adjust the left chain
        pDelete->faLeftChain = pShare->faLeftChain;

        // Update faLeftChain
        if (pDelete->faLeftChain)
        {
            // Locals
            LPCHAINBLOCK pLeftChain;

            // Get Block
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->faLeftChain, (LPVOID *)&pLeftChain));

            // Set faParent
            pLeftChain->faParent = pDelete->faBlock;

            // Set iParent
            pLeftChain->iParent = 0;
        }

        // Adjust the left chain node count
        pDelete->cLeftNodes = pShare->cLeftNodes;
    }

    // Share from the right
    else
    {
        // Verify Share Type
        Assert(CHAIN_SHARE_RIGHT == tyShare && pDelete->cNodes - 1 == iInsert);

        // Adjust the right chain
        pDelete->rgNode[pDelete->cNodes - 1].faRightChain = pShare->faLeftChain;

        // Update the Right Chain's Parent
        if (pDelete->rgNode[pDelete->cNodes - 1].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get the right chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->rgNode[pDelete->cNodes - 1].faRightChain, (LPVOID *)&pRightChain));

            // Set faParent
            pRightChain->faParent = pDelete->faBlock;

            // Set iParent
            pRightChain->iParent = (pDelete->cNodes - 1);
        }

        // Adjust the right Node Count
        pDelete->rgNode[pDelete->cNodes - 1].cRightNodes = pShare->cLeftNodes;
    }

    // Combine pShare Nodes into pDelete
    for (i=0; i<pShare->cNodes; i++)
    {
        // Insert the Share
        IF_FAILEXIT(hr = _ChainInsert(iIndex, pDelete, &pShare->rgNode[i], &iInsert));

        // Need to update...
        if (pDelete->rgNode[iInsert].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Right Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pDelete->rgNode[iInsert].faRightChain, (LPVOID *)&pRightChain));

            // Set faParent
            pRightChain->faParent = pDelete->faBlock;

            // Set iParent
            pRightChain->iParent = iInsert;
        }
    }

    // Don't use pShare any more
    pShare = NULL;

    // We can't possible need pShare anymore since we just copied all of its nodes into pDelete
    IF_FAILEXIT(hr = _FreeBlock(BLOCK_CHAIN, faShare));

    // Collapse the Parent chain
    _CollapseChain(pParent, iParent);

    // If Parent is less than zero, then lets hope that it was the root node!
    if (pParent->cNodes == 0)
    {
        // This is a bug
        Assert(0 == pParent->faParent && m_pHeader->rgfaIndex[iIndex] == pParent->faBlock);

        // Add pParent to free list
        IF_FAILEXIT(hr = _FreeBlock(BLOCK_CHAIN, pParent->faBlock));

        // Kill faParent Link
        pDelete->faParent = pDelete->iParent = 0;

        // We have a new root chain
        m_pHeader->rgfaIndex[iIndex] = pDelete->faBlock;

        // No more parent
        goto exit;
    }

    // Compute cRightNodes
    cRightNodes = pDelete->cNodes + pDelete->cLeftNodes;

    // Loop and count all children
    for (i=0; i<pDelete->cNodes; i++)
    {
        // Increment Node Count
        cRightNodes += pDelete->rgNode[i].cRightNodes;
    }

    // Reset new parent to found node
    if (CHAIN_SHARE_LEFT == tyShare)
    {
        // Readjust new parent node of coalesced chain
        if (iParent > pParent->cNodes - 1)
        {
            // What is happening here
            iParent = pParent->cNodes - 1;
        }

        // We should be replace pShare
        Assert(pParent->rgNode[iParent].faRightChain == faShare);

        // Update Parent for pDelete
        pParent->rgNode[iParent].faRightChain = pDelete->faBlock;

        // Adjust Right Chain's Parent
        if (pParent->rgNode[iParent].faRightChain)
        {
            // Locals
            LPCHAINBLOCK pRightChain;

            // Get Right Chain
            IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->rgNode[iParent].faRightChain, (LPVOID *)&pRightChain));

            // Set faParent
            Assert(pRightChain->faParent == pParent->faBlock);

            // Set the Parent Index
            pRightChain->iParent = iParent;
        }

        // Compute cRightNodes
        pParent->rgNode[iParent].cRightNodes = cRightNodes;
    }

    // Otherwise, adjust for CHAIN_SHARE_RIGHT
    else
    {
        // Validation
        Assert(pDelete->faParent == pParent->faBlock);

        // First Node
        if (0 == iParent)
        {
            // Must be left chain
            Assert(pParent->faLeftChain == pDelete->faBlock);

            // Validate my Parent
            Assert(pDelete->iParent == 0);

            // Set Left Node Count
            pParent->cLeftNodes = cRightNodes;
        }

        // Otherwise
        else
        {
            // Validate iParent
            Assert(pParent->rgNode[iParent - 1].faRightChain == pDelete->faBlock);

            // Validation
            Assert(pDelete->iParent == iParent - 1);

            // Set cRightNodes
            pParent->rgNode[iParent - 1].cRightNodes = cRightNodes;
        }
    }

    // Move up the chain, until lpChainPrev == NULL, lpChainPrev->cNodes can not be less than /2
    if (0 == pParent->faParent)
        goto exit;

    // Min capacity
    if (pParent->cNodes < BTREE_MIN_CAP)
    {
        // Decide if I need to do a shared or coalesce type delete
        IF_FAILEXIT(hr = _DecideHowToDelete(&faShareAgain, pParent->faBlock, &tyDelete, &tyShare));

        // Can't Share, we must coalesc again
        if (CHAIN_DELETE_SHARE == tyDelete)
        {
            // Do a shared delete
            IF_FAILEXIT(hr = _ChainDeleteShare(iIndex, pParent->faBlock, faShareAgain, tyShare));
        }

        // Coalesce type delete
        else
        {
            // Validate
            Assert(faShareAgain && CHAIN_DELETE_COALESCE == tyDelete);

            // Recursive Coalescing
            IF_FAILEXIT(hr = _ChainDeleteCoalesce(iIndex, pParent->faBlock, faShareAgain, tyShare));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DecideHowToDelete
//--------------------------------------------------------------------------
HRESULT CDatabase::_DecideHowToDelete(LPFILEADDRESS pfaShare,
    FILEADDRESS faDelete, CHAINDELETETYPE *ptyDelete, 
    CHAINSHARETYPE *ptyShare)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrRight;
    HRESULT             hrLeft;
    LPCHAINBLOCK        pRight=NULL;
    LPCHAINBLOCK        pLeft=NULL;

    // Trace
    TraceCall("CDatabase::_DecideHowToDelete");

    // Initialize
    *pfaShare = NULL;

    // Get the right sibling
    IF_FAILEXIT(hr = _GetRightSibling(faDelete, &pRight));

    // Set hrRight
    hrRight = hr;

    // Did we get a right parent that has nodes that I can steal from ?
    if (DB_S_FOUND == hrRight && pRight->cNodes - 1 >= BTREE_MIN_CAP)
    {
        // Set Delete Type
        *ptyDelete = CHAIN_DELETE_SHARE;

        // Set Share Type
        *ptyShare = CHAIN_SHARE_RIGHT;

        // Set Share Link
        *pfaShare = pRight->faBlock;
    }
    else
    {
        // Try to get the left sibling
        IF_FAILEXIT(hr = _GetLeftSibling(faDelete, &pLeft));

        // Set hrRight
        hrLeft = hr;

        // Did I get a left sibling that has nodes that I can steal from ?
        if (DB_S_FOUND == hrLeft && pLeft->cNodes - 1 >= BTREE_MIN_CAP)
        {
            // Set Delete Type
            *ptyDelete = CHAIN_DELETE_SHARE;

            // Set Share Type
            *ptyShare = CHAIN_SHARE_LEFT;

            // Set Share Link
            *pfaShare = pLeft->faBlock;
        }
    }

    // Did we find a Share ?
    if (0 == *pfaShare)
    {
        // Were are going to coalesce
        *ptyDelete = CHAIN_DELETE_COALESCE;

        // Coalesce and share from the right?
        if (DB_S_FOUND == hrRight)
        {
            // Set Share Type
            *ptyShare = CHAIN_SHARE_RIGHT;

            // Set Share Link
            *pfaShare = pRight->faBlock;
        }

        // Coalesce and share from the left?
        else
        {
            // Validation
            Assert(DB_S_FOUND == hrLeft);

            // Set Share Type
            *ptyShare = CHAIN_SHARE_LEFT;

            // Set Share Link
            *pfaShare = pLeft->faBlock;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetInOrderSuccessor
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetInOrderSuccessor(FILEADDRESS faStart,
    NODEINDEX iDelete, LPCHAINBLOCK *ppSuccessor)
{
    // Locals
    HRESULT         hr=S_OK;
    FILEADDRESS     faCurrent;
    LPCHAINBLOCK    pCurrent;
    LPCHAINBLOCK    pStart;

    // Trace
    TraceCall("CDatabase::_GetInOrderSuccessor");

    // Invalid Args
    Assert(ppSuccessor);

    // Initialize
    *ppSuccessor = NULL;

    // Get Start
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faStart, (LPVOID *)&pStart));

    // Next Chain Address
    faCurrent = pStart->rgNode[iDelete].faRightChain;

    // Can't be zero
    Assert(faCurrent != 0);

    // Go until left chain is -1
    while (faCurrent)
    {
        // Get Current
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faCurrent, (LPVOID *)&pCurrent));

        // If leaf node, then return
        if (S_OK == _IsLeafChain(pCurrent))
        {
            // Set Successor
            *ppSuccessor = pCurrent;

            // Done
            goto exit;
        }

        // Otherwise, goto the left
        faCurrent = pCurrent->faLeftChain;
    }

    // Not Found
    hr = TraceResult(E_FAIL);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetLeftSibling
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetLeftSibling(FILEADDRESS faCurrent,
    LPCHAINBLOCK *ppSibling)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCHAINBLOCK    pCurrent;
    LPCHAINBLOCK    pParent;

    // Trace
    TraceCall("CDatabase::_GetLeftSibling");

    // Invalid Args
    Assert(faCurrent && ppSibling);

    // Get Current
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faCurrent, (LPVOID *)&pCurrent));

    // Get Parent
    Assert(pCurrent->faParent);

    // Get the Parent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pCurrent->faParent, (LPVOID *)&pParent));

    // Validate iparent
    Assert(pCurrent->iParent < pParent->cNodes);

    // iParent is zero
    if (0 == pCurrent->iParent)
    {
        // If pCurrent is the faRightChain ?
        if (pCurrent->faBlock != pParent->rgNode[0].faRightChain)
            return(DB_S_NOTFOUND);

        // Get the Sibling
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->faLeftChain, (LPVOID *)ppSibling));

        // Validate
        Assert((*ppSibling)->iParent == 0);
    }

    // iParent is greater than zero ?
    else
    {
        // Validate
        Assert(pParent->rgNode[pCurrent->iParent].faRightChain == pCurrent->faBlock);

        // Get the Sibling
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->rgNode[pCurrent->iParent - 1].faRightChain, (LPVOID *)ppSibling));

        // Validate
        Assert((*ppSibling)->iParent == pCurrent->iParent - 1);
    }

    // Better have a left sibling
    Assert(0 != *ppSibling);

    // Found
    hr = DB_S_FOUND;

exit:
    // Set hr
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_GetRightSibling
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetRightSibling(FILEADDRESS faCurrent,
    LPCHAINBLOCK *ppSibling)
{
    // Locals
    HRESULT           hr=S_OK;
    LPCHAINBLOCK      pParent;
    LPCHAINBLOCK      pCurrent;

    // Trace
    TraceCall("CDatabase::_GetRightSibling");

    // Invalid Args
    Assert(faCurrent && ppSibling);

    // Get Current
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faCurrent, (LPVOID *)&pCurrent));

    // Get Parent
    Assert(pCurrent->faParent);

    // Get the Parent
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pCurrent->faParent, (LPVOID *)&pParent));

    // Validate iparent
    Assert(pCurrent->iParent < pParent->cNodes);

    // iParent is zero
    if (0 == pCurrent->iParent && pCurrent->faBlock == pParent->faLeftChain)
    {
        // Get the Sibling
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->rgNode[0].faRightChain, (LPVOID *)ppSibling));

        // Validate
        Assert((*ppSibling)->iParent == 0);
    }

    // iParent is greater than zero ?
    else
    {
        // No more Right chains
        if (pCurrent->iParent + 1 == pParent->cNodes)
            return DB_S_NOTFOUND;

        // Get the Sibling
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pParent->rgNode[pCurrent->iParent + 1].faRightChain, (LPVOID *)ppSibling));

        // Validate
        Assert((*ppSibling)->iParent == pCurrent->iParent + 1);
    }

    // Better have a left sibling
    Assert(0 != *ppSibling);

    // Found
    hr = DB_S_FOUND;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::GetUserData
//--------------------------------------------------------------------------
HRESULT CDatabase::GetUserData(LPVOID pvUserData, 
    ULONG cbUserData)
{
    // Locals
    HRESULT hr=S_OK;
    HLOCK   hLock=NULL;

    // Trace
    TraceCall("CDatabase::GetUserData");

    // Invalid Args
    Assert(pvUserData);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Copy the data
    CopyMemory(pvUserData, PUSERDATA(m_pHeader), cbUserData);

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::SetUserData
//--------------------------------------------------------------------------
HRESULT CDatabase::SetUserData(LPVOID pvUserData, 
    ULONG cbUserData)
{
    // Locals
    HRESULT hr=S_OK;
    HLOCK   hLock=NULL;

    // Trace
    TraceCall("CDatabase::SetUserData");

    // Invalid Args
    Assert(pvUserData);

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // Copy the data
    CopyMemory(PUSERDATA(m_pHeader), pvUserData, cbUserData);

exit:
    // Mutal Exclusion
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CompactMoveRecordStreams
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompactMoveRecordStreams(CDatabase *pDstDB,
    LPVOID pBinding)
{
    // Locals
    HRESULT             hr=S_OK;
    COLUMNORDINAL       iColumn;
    FILEADDRESS         faSrcStart;
    FILEADDRESS         faDstStart;
    LPOPENSTREAM        pInfo;
    DWORD               i;

    // Trace
    TraceCall("CDatabase::_CompactMoveRecordStreams");

    // Walk through the format
    for (iColumn=0; iColumn<m_pSchema->cColumns; iColumn++)
    {
        // Is this a stream
        if (CDT_STREAM != m_pSchema->prgColumn[iColumn].type)
            continue;

        // Get the source stream starting address
        faSrcStart = *((FILEADDRESS *)((LPBYTE)pBinding + m_pSchema->prgColumn[iColumn].ofBinding));

        // Is there a stream
        if (0 == faSrcStart)
            continue;

        // Move the Stream
        IF_FAILEXIT(hr = CopyStream((IDatabase *)pDstDB, faSrcStart, &faDstStart));

        // Store the stream address in the record
        *((FILEADDRESS *)((LPBYTE)pBinding + m_pSchema->prgColumn[iColumn].ofBinding)) = faDstStart;

        // Loop through the stream table and adjust the start address of all open streams
        for (i=0; i<CMAX_OPEN_STREAMS; i++)
        {
            // Readability
            pInfo = &m_pShare->rgStream[i];

            // Is In use...
            if (TRUE == pInfo->fInUse && faSrcStart == pInfo->faStart)
            {
                // Change the Address
                pInfo->faMoved = faDstStart;

                // Break;
                break;
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CompactMoveOpenDeletedStreams
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompactMoveOpenDeletedStreams(CDatabase *pDstDB)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    LPOPENSTREAM    pInfo;

    // Trace
    TraceCall("CDatabase::_CompactMoveOpenDeletedStreams");

    // Loop through the stream table and adjust the start address of all open streams
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Readability
        pInfo = &m_pShare->rgStream[i];

        // Is In use...
        if (FALSE == pInfo->fInUse || FALSE == pInfo->fDeleteOnClose)
            continue;

        // Move the Stream
        IF_FAILEXIT(hr = CopyStream((IDatabase *)pDstDB, pInfo->faStart, &pInfo->faMoved));
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CompactTransferFilters
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompactTransferFilters(CDatabase *pDstDB)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               i;
    LPBLOCKHEADER       pStringSrc;
    LPBLOCKHEADER       pStringDst;

    // Trace
    TraceCall("CDatabase::_CompactTransferFilters");

    // Must have a Catalog
    Assert(pDstDB->m_pHeader);

    // Zero Out the Query String Addresses
    for (i=0; i<CMAX_INDEXES; i++)
    {
        // Zero Filter1
        pDstDB->m_pHeader->rgfaFilter[i] = 0;

        // Copy Filter1
        if (m_pHeader->rgfaFilter[i] && SUCCEEDED(_GetBlock(BLOCK_STRING, m_pHeader->rgfaFilter[i], (LPVOID *)&pStringSrc)))
        {
            // Try to Store the Query String
            IF_FAILEXIT(hr = pDstDB->_AllocateBlock(BLOCK_STRING, pStringSrc->cbSize, (LPVOID *)&pStringDst));

            // Write the String
            CopyMemory(PSTRING(pStringDst), PSTRING(pStringSrc), pStringSrc->cbSize);

            // String the String Address
            pDstDB->m_pHeader->rgfaFilter[i] = pStringDst->faBlock;
        }
    }

    // Change the Version so that it doesn't assert
    pDstDB->m_dwQueryVersion = 0xffffffff;

    // Rebuild the Query Table
    IF_FAILEXIT(hr = pDstDB->_BuildQueryTable());

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CompactInsertRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_CompactInsertRecord(LPVOID pBinding)
{
    // Locals
    HRESULT         hr=S_OK;
    FINDRESULT      rgResult[CMAX_INDEXES];
    INDEXORDINAL    iIndex;
    DWORD           i;
    RECORDMAP       RecordMap;
    FILEADDRESS     faRecord;

    // Trace
    TraceCall("CDatabase::InsertRecord");

    // Invalid Args
    Assert(pBinding);

    // Loop through all the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Otherwise: Decide Where to insert
        IF_FAILEXIT(hr = _FindRecord(iIndex, COLUMNS_ALL, pBinding, &rgResult[i].faChain, &rgResult[i].iNode, NULL, &rgResult[i].nCompare));

        // If key already exist, cache list and return
        if (DB_S_FOUND == hr)
        {
            hr = TraceResult(DB_E_DUPLICATE);
            goto exit;
        }
    }

    // Get the Record Size
    IF_FAILEXIT(hr = _GetRecordSize(pBinding, &RecordMap));

    // Link Record Into the Table
    IF_FAILEXIT(hr = _LinkRecordIntoTable(&RecordMap, pBinding, 0, &faRecord));

    // Version Change
    m_pShare->dwVersion++;

    // Insert into the indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Visible in live index
        if (S_OK == _IsVisible(m_rghFilter[iIndex], pBinding))
        {
            // Do the Insertion
            IF_FAILEXIT(hr = _IndexInsertRecord(iIndex, rgResult[i].faChain, faRecord, &rgResult[i].iNode, rgResult[i].nCompare));

            // Update Record Count
            m_pHeader->rgcRecords[iIndex]++;
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::MoveFile
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::MoveFile(LPCWSTR pszFile)
{
    // Locals
    HRESULT             hr=S_OK;
    HLOCK               hLock=NULL;
    LPWSTR              pszFilePath=NULL;
    LPWSTR              pszShare=NULL;
    DWORD               cchFilePath;
    HANDLE              hMutex=NULL;
    BOOL                fNeedOpenFile=FALSE;
    BOOL                fNewShare;
    SHAREDDATABASE      Share;

    // Trace
    TraceCall("CDatabase::MoveFile");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // In move File
    m_fInMoveFile = TRUE;

    // Get the Full Path
    IF_FAILEXIT(hr = DBGetFullPath(pszFile, &pszFilePath, &cchFilePath));

    // Don't use pszFile again
    pszFile = NULL;

    // Failure
    if (cchFilePath >= CCHMAX_DB_FILEPATH)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Do It
    IF_FAILEXIT(hr = _DispatchInvoke(INVOKE_CLOSEFILE));

    // Need a remap..
    fNeedOpenFile = TRUE;

    // Move the file from the temp location to my current location
    if (0 == MoveFileWrapW(m_pShare->szFile, pszFilePath))
    {
        hr = TraceResult(DB_E_MOVEFILE);
        goto exit;
    }

    // Save the new file path...(other clients will remap to this file...)
    StrCpyW(m_pShare->szFile, pszFilePath);

    // Save the Current Share
    CopyMemory(&Share, m_pShare, sizeof(SHAREDDATABASE));

    // Save Current Mutex
    hMutex = m_hMutex;

    // Clear m_hMutex so that we don't free it
    m_hMutex = NULL;

    // Create the Mutex Object
    IF_FAILEXIT(hr = CreateSystemHandleName(pszFilePath, L"_DirectDBShare", &pszShare));

    // Unmap the view of the memory mapped file
    SafeUnmapViewOfFile(m_pShare);

    // Unmap the view of the memory mapped file
    SafeCloseHandle(m_pStorage->hShare);

    // Open the file mapping
    IF_FAILEXIT(hr = DBOpenFileMapping(INVALID_HANDLE_VALUE, pszShare, sizeof(SHAREDDATABASE), &fNewShare, &m_pStorage->hShare, (LPVOID *)&m_pShare));

    // Should be new
    Assert(fNewShare);

    // Save the Current Share
    CopyMemory(m_pShare, &Share, sizeof(SHAREDDATABASE));

    // Get all clients to re-open the new file
    IF_FAILEXIT(hr = _DispatchInvoke(INVOKE_OPENMOVEDFILE));

    // Validate Mutex Changed
    Assert(m_hMutex && hMutex != m_hMutex);

    // Enter New Mutex
    WaitForSingleObject(m_hMutex, INFINITE);

    // Fix hLock
    hLock = (HLOCK)m_hMutex;

    // Release hMutex
    ReleaseMutex(hMutex);

    // Free hMutex
    SafeCloseHandle(hMutex);

    // Sucess
    fNeedOpenFile = FALSE;

exit:
    // Not In Move File
    m_fInMoveFile = FALSE;

    // If Need Open File
    if (fNeedOpenFile)
    {
        // Try to re-open the file..
        _DispatchInvoke(INVOKE_OPENFILE);
    }

    // Unlock
    Unlock(&hLock);

    // Cleanup
    SafeMemFree(pszFilePath);
    SafeMemFree(pszShare);
    
    // done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::Compact
//--------------------------------------------------------------------------
STDMETHODIMP CDatabase::Compact(IDatabaseProgress *pProgress, COMPACTFLAGS dwFlags)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               i;
    DWORD               dwVersion;
    DWORDLONG           dwlFree;
    DWORD               cDuplicates=0;
    DWORD               cRecords=0;
    DWORD               cbDecrease;
    LPVOID              pBinding=NULL;
    DWORD               dwNextId;
    DWORD               cbWasted;
    HLOCK               hLock=NULL;
    HLOCK               hDstLock=NULL;
    DWORD               cActiveThreads;
    LPWSTR              pszDstFile=NULL;
    HROWSET             hRowset=NULL;
    DWORD               cch;
    CDatabase          *pDstDB=NULL;

    // Trace
    TraceCall("CDatabase::Compact");

    // Lock
    IF_FAILEXIT(hr = Lock(&hLock));

    // If Compacting...
    if (TRUE == m_pShare->fCompacting)
    {
        // Leave Spin Lock
        Unlock(&hLock);

        // Trace
        return(TraceResult(DB_E_COMPACTING));
    }

    // I am compacting
    m_pShare->fCompacting = TRUE;

    // Yield
    if (ISFLAGSET(dwFlags, COMPACT_YIELD))
    {
        // Yield ?
        m_fCompactYield = TRUE;
    }

    // Get Length
    cch = lstrlenW(m_pShare->szFile);

    //Bug #101511: (erici) Debug shlwapi validates it to MAX_PATH characters 
    if( (cch+15) < MAX_PATH)
    {
        cch = MAX_PATH-15;
    }

    // Create .dbt file
    IF_NULLEXIT(pszDstFile = AllocateStringW(cch + 15));

    // Copy File Name
    StrCpyW(pszDstFile, m_pShare->szFile);

    // Change the Extension
    PathRenameExtensionW(pszDstFile, L".dbt");

    // Delete that file
    DeleteFileWrapW(pszDstFile);

    // Delete my Current File
    if (PathFileExistsW(pszDstFile))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Loop through the stream table and see if there are any streams open for a write
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Is In use...
        if (TRUE == m_pShare->rgStream[i].fInUse && LOCK_VALUE_WRITER == m_pShare->rgStream[i].lLock)
        {
            hr = TraceResult(DB_E_COMPACT_PREEMPTED);
            goto exit;
        }
    }

    // If there are pending notifications...
    if (m_pHeader->cTransacts > 0)
    {
        hr = TraceResult(DB_E_DATABASE_CHANGED);
        goto exit;
    }

    // Is there enought disk space where pDstDB is located
    IF_FAILEXIT(hr = GetAvailableDiskSpace(m_pShare->szFile, &dwlFree));

    // Compute cbWasted
    cbWasted = (m_pHeader->cbFreed + (m_pStorage->cbFile - m_pHeader->faNextAllocate));

    // Is there enough disk space ?
    if (dwlFree <= ((DWORDLONG) (m_pStorage->cbFile - cbWasted)))
    {
        hr = TraceResult(DB_E_DISKFULL);
        goto exit;
    }

    // Create the Object Database Object
    IF_NULLEXIT(pDstDB = new CDatabase);

    // Open the Table
    IF_FAILEXIT(hr = pDstDB->Open(pszDstFile, OPEN_DATABASE_NOEXTENSION | OPEN_DATABASE_NOMONITOR, m_pSchema, NULL));

    // Lock the Destination Database
    IF_FAILEXIT(hr = pDstDB->Lock(&hDstLock));

    // Get user info from current tree
    if (m_pSchema->cbUserData)
    {
        // Set the user data
        IF_FAILEXIT(hr = pDstDB->SetUserData(PUSERDATA(m_pHeader), m_pSchema->cbUserData));
    }

    // I'm going to grow the destination to be as big as the current file (I will truncate when finished)
    IF_FAILEXIT(hr = pDstDB->SetSize(m_pStorage->cbFile - cbWasted));

    // Set number of indexes
    pDstDB->m_pHeader->cIndexes = m_pHeader->cIndexes;

    // Copy Index Information...
    CopyMemory((LPBYTE)pDstDB->m_pHeader->rgIndexInfo, (LPBYTE)m_pHeader->rgIndexInfo, sizeof(TABLEINDEX) * CMAX_INDEXES);

    // Copy Index Information...
    CopyMemory((LPBYTE)pDstDB->m_pHeader->rgiIndex, (LPBYTE)m_pHeader->rgiIndex, sizeof(INDEXORDINAL) * CMAX_INDEXES);

    // Transfer Query Table...
    IF_FAILEXIT(hr = _CompactTransferFilters(pDstDB));

    // Allocate a Record
    IF_NULLEXIT(pBinding = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

    // Create a Rowset
    IF_FAILEXIT(hr = CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset));

    // Save new Version
    dwVersion = m_pShare->dwVersion;

    // While we have a node address
    while (S_OK == QueryRowset(hRowset, 1, (LPVOID *)pBinding, NULL))
    {
        // Can Preempt
        if (ISFLAGSET(dwFlags, COMPACT_PREEMPTABLE) && m_pShare->cWaitingForLock > 0)
        {
            hr = TraceResult(DB_E_COMPACT_PREEMPTED);
            goto exit;
        }

        // If the record has streams
        if (ISFLAGSET(m_pSchema->dwFlags, TSF_HASSTREAMS))
        {
            // Compact Move Record Streams
            IF_FAILEXIT(hr = _CompactMoveRecordStreams(pDstDB, pBinding));
        }

        // Insert Record Into Destination
        hr = pDstDB->_CompactInsertRecord(pBinding);

        // Duplicate
        if (DB_E_DUPLICATE == hr)
        {
            // Trace
            TraceResult(DB_E_DUPLICATE);

            // Reset Hr
            hr = S_OK;

            // Count
            cDuplicates++;
        }

        // Failed ?
        else if (FAILED (hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Count
        cRecords++;

        // Free this Record
        FreeRecord(pBinding);

        // Update the Progress...
        if (pProgress)
        {
            // Call into the progress object
            IF_FAILEXIT(hr = pProgress->Update(1));

            // Version Change ?
            if (dwVersion != m_pShare->dwVersion || m_pHeader->cTransacts > 0)
            {
                hr = TraceResult(DB_E_DATABASE_CHANGED);
                goto exit;
            }
        }

        // Yield
        if (ISFLAGSET(dwFlags, COMPACT_YIELD))
        {
            // this will force this thread to give up a time-slice
            Sleep(0);
        }
    }

    // Duplicates ?
    AssertSz(cDuplicates == 0, "Duplicates were found in the tree. They have been eliminated.");

    // Copy over deleted streams that are currently open...
    IF_FAILEXIT(hr = _CompactMoveOpenDeletedStreams(pDstDB));

    // Number of records better be equal
    AssertSz(cRecords == m_pHeader->rgcRecords[0], "Un-expected number of records compacted");

    // Save dwNextId
    dwNextId = m_pHeader->dwNextId;

    // Save Active Threads
    cActiveThreads = m_pHeader->cActiveThreads;

    // Compute amount to decrease the file by
    cbDecrease = (pDstDB->m_pStorage->cbFile - pDstDB->m_pHeader->faNextAllocate);

    // Reduce the Size of myself...
    IF_FAILEXIT(hr = pDstDB->_SetStorageSize(pDstDB->m_pStorage->cbFile - cbDecrease));

    // Unlock da bitch
    pDstDB->Unlock(&hDstLock);

    // Release pDstDB
    SafeRelease(pDstDB);

    // Do It
    IF_FAILEXIT(hr = _DispatchInvoke(INVOKE_CLOSEFILE));

    // Delete my Current File
    if (0 == DeleteFileWrapW(m_pShare->szFile))
    {
        // Failure
        hr = TraceResult(E_FAIL);

        // Try to re-open the file..
        _DispatchInvoke(INVOKE_OPENFILE);

        // Done
        goto exit;
    }

    // Move the file from the temp location to my current location
    if (0 == MoveFileWrapW(pszDstFile, m_pShare->szFile))
    {
        // Trace
        hr = TraceResult(DB_E_MOVEFILE);

        // Try to re-open the file..
        _DispatchInvoke(INVOKE_OPENFILE);

        // Done
        goto exit;
    }

    // Do It
    IF_FAILEXIT(hr = _DispatchInvoke(INVOKE_OPENFILE));

    // Reset Active Thread Count
    m_pHeader->cActiveThreads = cActiveThreads;

    // Reset dwNextId
    m_pHeader->dwNextId = dwNextId;

    // Reset Notification Queue
    Assert(0 == m_pHeader->faTransactHead && 0 == m_pHeader->faTransactTail);

    // Reset Transaction List
    m_pHeader->faTransactHead = m_pHeader->faTransactTail = m_pHeader->cTransacts = 0;

    // Reset Share Transacts
    m_pShare->faTransactLockHead = m_pShare->faTransactLockTail = 0;

    // Loop through the stream table and adjust the start address of all open streams
    for (i=0; i<CMAX_OPEN_STREAMS; i++)
    {
        // Is In use...
        if (TRUE == m_pShare->rgStream[i].fInUse)
        {
            // Change the Address
            m_pShare->rgStream[i].faStart = m_pShare->rgStream[i].faMoved;
        }
    }

    // Build the Update Notification Package
    _LogTransaction(TRANSACTION_COMPACTED, INVALID_INDEX_ORDINAL, NULL, 0, 0);

exit:
    // Close my rowset
    CloseRowset(&hRowset);

    // Release Dst Lock
    if (pDstDB && hDstLock)
        pDstDB->Unlock(&hDstLock);

    // Release the memory mapped pointers
    SafeRelease(pDstDB);

    // Free the Record
    SafeFreeBinding(pBinding);

    // No Longer compacting
    m_pShare->fCompacting = FALSE;

    // Delete pszDstFile
    if (pszDstFile)
    {
        // Delete the file
        DeleteFileWrapW(pszDstFile);

        // Remaining Cleanup
        SafeMemFree(pszDstFile);
    }

    // Reset Yield
    m_fCompactYield = FALSE;

    // Release Locks
    Unlock(&hLock);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_CheckForCorruption
//--------------------------------------------------------------------------
HRESULT CDatabase::_CheckForCorruption(void)
{
    // Locals
    HRESULT                  hr=S_OK;
    ULONG                    cRecords;
    DWORD                    i;
    HRESULT                  rghrCorrupt[CMAX_INDEXES]={0};
    DWORD                    cCorrupt=0;
    INDEXORDINAL             iIndex;

    // Trace
    TraceCall("CDatabase::_CheckForCorruption");

    // We should not be currently repairing
    Assert(FALSE == m_pShare->fRepairing);

    // We are now repairing
    IF_DEBUG(m_pShare->fRepairing = TRUE);

    // Walk Through the Indexes
    for (i = 0; i < m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Zero Out cRecords
        cRecords = 0;

        // Assume all is good
        rghrCorrupt[iIndex] = S_OK;

        // Start at the root 
        if (m_pHeader->rgfaIndex[iIndex])
        {
            // Validate the Index
            rghrCorrupt[iIndex] = _ValidateIndex(iIndex, m_pHeader->rgfaIndex[iIndex], 0, &cRecords);
        }

        // If Not Corrupt, validate the record counts
        if (DB_E_CORRUPT != rghrCorrupt[iIndex] && m_pHeader->rgcRecords[iIndex] != cRecords)
        {
            // Its Corrupt
            rghrCorrupt[iIndex] = TraceResult(DB_E_CORRUPT);
        }

        // If Corrupt
        if (DB_E_CORRUPT == rghrCorrupt[iIndex])
        {
            // Count Number of Corrupted records
            cCorrupt += m_pHeader->rgcRecords[iIndex];
        }
    }

    // Are the Corrupt Records
    if (cCorrupt > 0 || m_pHeader->fCorrupt)
    {
        // I'm going to nuke the free block tables since they may also be corrupted...
        ZeroMemory(m_pHeader->rgfaFreeBlock, sizeof(FILEADDRESS) * CC_FREE_BUCKETS);

        // Reset Fixed blocks
        m_pHeader->faFreeStreamBlock = m_pHeader->faFreeChainBlock = m_pHeader->faFreeLargeBlock = 0;

        // Nuke the Transaction List
        m_pHeader->cTransacts = m_pHeader->faTransactHead = m_pHeader->faTransactTail = 0;

        // Nuke The Fixed Block Allocation Pages
        ZeroMemory(&m_pHeader->AllocateRecord, sizeof(ALLOCATEPAGE));
        ZeroMemory(&m_pHeader->AllocateChain, sizeof(ALLOCATEPAGE));
        ZeroMemory(&m_pHeader->AllocateStream, sizeof(ALLOCATEPAGE));

        // Reset rgcbAllocated
        ZeroMemory(m_pHeader->rgcbAllocated, sizeof(DWORD) * CC_MAX_BLOCK_TYPES);

        // Reset faNextAllocate
        m_pHeader->faNextAllocate = m_pStorage->cbFile;

        // Walk Through the Indexes
        for (i = 0; i < m_pHeader->cIndexes; i++)
        {
            // Get Index Ordinal
            iIndex = m_pHeader->rgiIndex[i];

            // If Corrupt
            if (DB_E_CORRUPT == rghrCorrupt[iIndex])
            {
                // Not Corrupt
                m_pHeader->fCorrupt = TRUE;

                // Rebuild the Index
                IF_FAILEXIT(hr = _RebuildIndex(iIndex));
            }
        }
    }

    // Not Corrupt
    m_pHeader->fCorrupt = FALSE;

    // This causes all current file views to be flushed and released. Insures we are in a good state.
#ifdef BACKGROUND_MONITOR
    DoBackgroundMonitor();
#else
    CloseFileViews(TRUE);
#endif

exit:
    // We are now repairing
    IF_DEBUG(m_pShare->fRepairing = FALSE);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_FreeIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_FreeIndex(FILEADDRESS faChain)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    LPCHAINBLOCK    pChain;

    // Trace
    TraceCall("CDatabase::_FreeIndex");

    // Nothing to validate
    if (0 == faChain)
        return(S_OK);

    // Validate faChain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

    // Go to the left
    IF_FAILEXIT(hr = _FreeIndex(pChain->faLeftChain));

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Validate the Right Chain
        IF_FAILEXIT(hr = _FreeIndex(pChain->rgNode[i].faRightChain));
    }

    // Free this Chain
    IF_FAILEXIT(hr = _FreeBlock(BLOCK_CHAIN, faChain));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_ValidateIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_ValidateIndex(INDEXORDINAL iIndex, 
    FILEADDRESS faChain, ULONG cLeftNodes, ULONG *pcRecords)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    LPCHAINBLOCK    pChain;
    LPRECORDBLOCK   pRecord;
    DWORD           cLeafs=0;
    DWORD           cNodes;
    RECORDMAP       Map;

    // Trace
    TraceCall("CDatabase::_ValidateIndex");

    // Nothing to validate
    Assert(0 != faChain);

    // Get Chain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

    // Validate Minimum Filled Constraint
    if (pChain->cNodes < BTREE_MIN_CAP && pChain->faBlock != m_pHeader->rgfaIndex[iIndex])
        return TraceResult(DB_E_CORRUPT);

    // Validate faParent
    if (pChain->faParent)
    {
        // Locals
        LPCHAINBLOCK pParent;

        // Get Parent
        IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, pChain->faParent, (LPVOID *)&pParent));

        // Validate iParent
        if (pChain->iParent >= pParent->cNodes)
            return TraceResult(DB_E_CORRUPT);

        // Validate the Parent Pointer
        if (0 == pChain->iParent)
        {
            // Validation
            if (pParent->rgNode[pChain->iParent].faRightChain != pChain->faBlock && pParent->faLeftChain != pChain->faBlock)
                return TraceResult(DB_E_CORRUPT);
        }

        // Otherwise
        else if (pParent->rgNode[pChain->iParent].faRightChain != pChain->faBlock)
            return TraceResult(DB_E_CORRUPT);
    }

    // Otherwise, iParent should be zero...
    else
    {
        // This is the root chain
        if (m_pHeader->rgfaIndex[iIndex] != pChain->faBlock)
            return TraceResult(DB_E_CORRUPT);

        // iParent should be 0
        Assert(pChain->iParent == 0);
    }

    // Do the Left
    if (pChain->faLeftChain)
    {
        // Go to the left
        IF_FAILEXIT(hr = _ValidateIndex(iIndex, pChain->faLeftChain, cLeftNodes, pcRecords));
    }

    // cNodes
    cNodes = pChain->cLeftNodes;

    // Validate the Records in this chain
    for (i=0; i<pChain->cNodes; i++)
    {
        // Count the number of leaf nodes
        cLeafs += (0 == pChain->rgNode[i].faRightChain) ? 1 : 0;

        // cNodes
        cNodes += pChain->rgNode[i].cRightNodes;
    }

    // Validate the Number of Leafs
    if (cLeafs > 0 && cLeafs != (DWORD)pChain->cNodes)
        return TraceResult(DB_E_CORRUPT);

    // No leafs, but their are child nodes, or vice vera...
    if ((0 != cLeafs && 0 != cNodes) || (0 == cLeafs && 0 == cNodes))
        return TraceResult(DB_E_CORRUPT);

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Try to get the record, if the block is invalid, we will throw away the record
        if (SUCCEEDED(_GetBlock(BLOCK_RECORD, pChain->rgNode[i].faRecord, (LPVOID *)&pRecord, FALSE)))
        {
            // Validate Block...
            if (SUCCEEDED(_GetRecordMap(FALSE, pRecord, &Map)))
            {
                // Validate and Repair the Record
                if (S_OK == _ValidateAndRepairRecord(&Map))
                {
                    // Count Records
                    (*pcRecords)++;
                }
            }
        }

        // First Node ?
        if (0 == i)
        {
            // Increment cLeft Nodes
            cLeftNodes += pChain->cLeftNodes;
        }

        // Otherwise
        else 
        {
            // Increment cLeftNodes
            cLeftNodes += pChain->rgNode[i - 1].cRightNodes;
        }

        // Failure
        if ((*pcRecords) != cLeftNodes + 1)
            return TraceResult(DB_E_CORRUPT);

        // Increment cLeftNodes
        cLeftNodes++;

        // Do the Right
        if (pChain->rgNode[i].faRightChain)
        {
            // Validate the Right Chain
            IF_FAILEXIT(hr = _ValidateIndex(iIndex, pChain->rgNode[i].faRightChain, cLeftNodes, pcRecords));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_RebuildIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_RebuildIndex(INDEXORDINAL iIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    LPVOID          pBinding=NULL;
    DWORD           cRecords=0;
    FILEADDRESS     faPrimary;

    // Trace
    TraceCall("CDatabase::_RebuildIndex");

    // Allocate a record
    IF_NULLEXIT(pBinding = PHeapAllocate(HEAP_ZERO_MEMORY, m_pSchema->cbBinding));

    // Save Primary Index Starting Address
    faPrimary = m_pHeader->rgfaIndex[IINDEX_PRIMARY];

    // Reset rgfaIndex[iIndex]
    m_pHeader->rgfaIndex[iIndex] = 0;

    // Is there a root chain ?
    if (faPrimary)
    {
        // Recursively Rebuild this index
        IF_FAILEXIT(hr = _RecursiveRebuildIndex(iIndex, faPrimary, pBinding, &cRecords));
    }

    // Fixup Record Count
    m_pHeader->rgcRecords[iIndex] = cRecords;

    // Send Notifications ?
    if (m_pShare->rgcIndexNotify[iIndex] > 0)
    {
        // Build the Update Notification Package
        _LogTransaction(TRANSACTION_INDEX_CHANGED, iIndex, NULL, 0, 0);
    }

exit:
    // Cleanup
    SafeFreeBinding(pBinding);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_RecursiveRebuildIndex
//--------------------------------------------------------------------------
HRESULT CDatabase::_RecursiveRebuildIndex(INDEXORDINAL iIndex, 
    FILEADDRESS faCurrent, LPVOID pBinding, LPDWORD pcRecords)
{
    // Locals
    NODEINDEX       i;
    FILEADDRESS     faRecord;
    FILEADDRESS     faChain;
    NODEINDEX       iNode;
    CHAINBLOCK      Chain;
    LPCHAINBLOCK    pChain;
    INT             nCompare;
    BOOL            fGoodRecord=TRUE;
    RECORDMAP       Map;
    LPRECORDBLOCK   pRecord;

    // Trace
    TraceCall("CDatabase::_RecursiveRebuildIndex");

    // Nothing to validate
    Assert(0 != faCurrent);

    // Validate faChain
    if (FAILED(_GetBlock(BLOCK_CHAIN, faCurrent, (LPVOID *)&pChain)))
        return(S_OK);

    // Copy This
    CopyMemory(&Chain, pChain, sizeof(CHAINBLOCK));

    // Do the left
    if (Chain.faLeftChain)
    {
        // Go to the left
        _RecursiveRebuildIndex(iIndex, Chain.faLeftChain, pBinding, pcRecords);
    }

    // Loop throug right chains
    for (i=0; i<Chain.cNodes; i++)
    {
        // Set faRecord
        faRecord = Chain.rgNode[i].faRecord;

        // Get the Block
        if (SUCCEEDED(_GetBlock(BLOCK_RECORD, faRecord, (LPVOID *)&pRecord, NULL, FALSE)))
        {
            // Rebuilding Primary Index ?
            if (IINDEX_PRIMARY == iIndex)
            {
                // Assume this is a bad record
                fGoodRecord = FALSE;

                // Try to get the record map
                if (SUCCEEDED(_GetRecordMap(FALSE, pRecord, &Map)))
                {
                    // Validate Map ?
                    if (S_OK == _ValidateAndRepairRecord(&Map))
                    {
                        // Good Record
                        fGoodRecord = TRUE;
                    }
                }
            }

            // Good Record ?
            if (fGoodRecord)
            {
                // Load the Record
                if (SUCCEEDED(_ReadRecord(faRecord, pBinding, TRUE)))
                {
                    // Reset hrVisible
                    if (S_OK == _IsVisible(m_rghFilter[iIndex], pBinding))
                    {
                        // Otherwise: Decide Where to insert
                        if (DB_S_NOTFOUND == _FindRecord(iIndex, COLUMNS_ALL, pBinding, &faChain, &iNode, NULL, &nCompare))
                        {
                            // Insert the Record
                            if (SUCCEEDED(_IndexInsertRecord(iIndex, faChain, faRecord, &iNode, nCompare)))
                            {
                                // Increment Record Count
                                (*pcRecords)++;
                            }
                        }
                    }
                }
            }
        }

        // Do the Right
        if (Chain.rgNode[i].faRightChain)
        {
            // Index the Right Chain
            _RecursiveRebuildIndex(iIndex, Chain.rgNode[i].faRightChain, pBinding, pcRecords);
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_ValidateStream
//--------------------------------------------------------------------------
HRESULT CDatabase::_ValidateStream(FILEADDRESS faStart)
{
    // Locals
    LPSTREAMBLOCK   pStream;
    FILEADDRESS     faCurrent;

    // Trace
    TraceCall("CDatabase::_ValidateStream");

    // No Stream
    if (0 == faStart)
        return(S_OK);

    // Initialize Loop
    faCurrent = faStart;

    // Read through all of the blocks (i.e. verify headers and count the number of chains)
    while (faCurrent)
    {
        // Valid stream Block
        if (FAILED(_GetBlock(BLOCK_STREAM, faCurrent, (LPVOID *)&pStream)))
            return(S_FALSE);

        // Validate cbData
        if (pStream->cbData > pStream->cbSize)
            return(S_FALSE);

        // Set faCurrent
        faCurrent = pStream->faNext;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_ValidateAndRepairRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_ValidateAndRepairRecord(LPRECORDMAP pMap)
{
    // Locals
    LPCTABLECOLUMN  pColumn;
    LPCOLUMNTAG     pTag;
    WORD            iTag;

    // Trace
    TraceCall("CDatabase::_ValidateAndRepairRecord");

    // Walk through the Tags of the Record
    for (iTag=0; iTag<pMap->cTags; iTag++)
    {
        // Readability
        pTag = &pMap->prgTag[iTag];

        // Validate the Tag
        if (pTag->iColumn >= m_pSchema->cColumns)
            return(S_FALSE);

        // De-ref the Column
        pColumn = &m_pSchema->prgColumn[pTag->iColumn];

        // Read the Data
        if (S_FALSE == DBTypeValidate(pColumn, pTag, pMap))
            return(S_FALSE);

        // Is this a stream ?
        if (CDT_STREAM == pColumn->type)
        {
            // Locals
            FILEADDRESS faStream;

            // Get the faStream
            if (1 == pTag->fData) 
                faStream = pTag->Offset;
            else
                faStream = *((DWORD *)(pMap->pbData + pTag->Offset));

            // Validate this stream...
            if (S_FALSE == _ValidateStream(faStream))
            {
                // Kill the stream address...
                if (1 == pTag->fData) 
                    pTag->Offset = 0;
                else
                    *((DWORD *)(pMap->pbData + pTag->Offset)) = 0;
            }
        }

        // Unique Key ?
        if (CDT_UNIQUE == pColumn->type)
        {
            // Locals
            DWORD dwUniqueID;

            // Get the dwUniqueID
            if (1 == pTag->fData) 
                dwUniqueID = pTag->Offset;
            else
                dwUniqueID = *((DWORD *)(pMap->pbData + pTag->Offset));

            // Adjust the id in the header ?
            if (dwUniqueID >= m_pHeader->dwNextId)
                m_pHeader->dwNextId = dwUniqueID + 1;
        }
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabase::_GetRecordMap
//--------------------------------------------------------------------------
HRESULT CDatabase::_GetRecordMap(BOOL fGoCorrupt, LPRECORDBLOCK pBlock, 
    LPRECORDMAP pMap)
{
    // Trace
    TraceCall("CDatabase::_GetRecordMap");

    // Invalid Args
    Assert(pBlock && pMap);

    // Set pSchema
    pMap->pSchema = m_pSchema;

    // Store Number of Tags
    pMap->cTags = min(pBlock->cTags, m_pSchema->cColumns);

    // Set prgTag
    pMap->prgTag = (LPCOLUMNTAG)((LPBYTE)pBlock + sizeof(RECORDBLOCK));

    // Compute Size of Tags
    pMap->cbTags = (pBlock->cTags * sizeof(COLUMNTAG));

    // Compute Size of Data
    pMap->cbData = (pBlock->cbSize - pMap->cbTags);

    // Set pbData
    pMap->pbData = (LPBYTE)((LPBYTE)pBlock + sizeof(RECORDBLOCK) + pMap->cbTags);

    // No Tags - this is usually the sign of a freeblock that was reused but not allocated
    if (0 == pMap->cTags)
        return _SetCorrupt(fGoCorrupt, __LINE__, REASON_INVALIDRECORDMAP, BLOCK_RECORD, pBlock->faBlock, pBlock->faBlock, pBlock->cbSize);

    // Too many tags
    if (pMap->cTags > m_pSchema->cColumns)
        return _SetCorrupt(fGoCorrupt, __LINE__, REASON_INVALIDRECORDMAP, BLOCK_RECORD, pBlock->faBlock, pBlock->faBlock, pBlock->cbSize);

    // cbTags is too large ?
    if (pMap->cbTags > pBlock->cbSize)
        return _SetCorrupt(fGoCorrupt, __LINE__, REASON_INVALIDRECORDMAP, BLOCK_RECORD, pBlock->faBlock, pBlock->faBlock, pBlock->cbSize);

    // Done
    return(S_OK);
}

#ifdef DEBUG
//--------------------------------------------------------------------------
// DBDebugValidateRecordFormat
//--------------------------------------------------------------------------
HRESULT CDatabase::_DebugValidateRecordFormat(void)
{
    // Locals
    ULONG           i;
    DWORD           dwOrdinalPrev=0;
    DWORD           dwOrdinalMin=0xffffffff;
    DWORD           dwOrdinalMax=0;

    // Validate memory buffer binding offset
    Assert(0xFFFFFFFF != m_pSchema->ofMemory && m_pSchema->ofMemory < m_pSchema->cbBinding);

    // Validate version binding offset
    Assert(0xFFFFFFFF != m_pSchema->ofVersion && m_pSchema->ofVersion < m_pSchema->cbBinding);

    // Validate Extension
    Assert(*m_pSchema->pclsidExtension != CLSID_NULL);

    // Validate Version
    Assert(m_pSchema->dwMinorVersion != 0);

    // Check Number of Indexes
    Assert(m_pSchema->pPrimaryIndex);

    // Loop through they Keys
    for (i=0; i<m_pSchema->cColumns; i++)
    {
        // This Ordinal better be larger than the previous
        if (i > 0)
            Assert(m_pSchema->prgColumn[i].iOrdinal > dwOrdinalPrev);

        // Save Min Ordinal
        if (m_pSchema->prgColumn[i].iOrdinal < dwOrdinalMin)
            dwOrdinalMin = m_pSchema->prgColumn[i].iOrdinal;

        // Save Max Ordinal
        if (m_pSchema->prgColumn[i].iOrdinal > dwOrdinalMax)
            dwOrdinalMax = m_pSchema->prgColumn[i].iOrdinal;

        // Save the Previous Ordinal
        dwOrdinalPrev = m_pSchema->prgColumn[i].iOrdinal;
    }

    // Min ordinal must be one
    Assert(dwOrdinalMin == 0);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// _DebugValidateUnrefedRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_DebugValidateUnrefedRecord(FILEADDRESS faRecord)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    INDEXORDINAL    iIndex;

    // Trace
    TraceCall("CDatabase::_DebugValidateUnrefedRecord");

    // Walk Through the Indexes
    for (i=0; i<m_pHeader->cIndexes; i++)
    {
        // Get Index Ordinal
        iIndex = m_pHeader->rgiIndex[i];

        // Start at the root 
        if (m_pHeader->rgfaIndex[iIndex])
        {
            // Validate the Index
            IF_FAILEXIT(hr = _DebugValidateIndexUnrefedRecord(m_pHeader->rgfaIndex[iIndex], faRecord));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabase::_DebugValidateIndexUnrefedRecord
//--------------------------------------------------------------------------
HRESULT CDatabase::_DebugValidateIndexUnrefedRecord(FILEADDRESS faChain,
    FILEADDRESS faRecord)
{
    // Locals
    HRESULT         hr=S_OK;
    NODEINDEX       i;
    LPCHAINBLOCK    pChain;

    // Trace
    TraceCall("CDatabase::_DebugValidateIndexUnrefedRecord");

    // Nothing to validate
    Assert(0 != faChain);

    // Validate faChain
    IF_FAILEXIT(hr = _GetBlock(BLOCK_CHAIN, faChain, (LPVOID *)&pChain));

    // Do the left
    if (pChain->faLeftChain)
    {
        // Go to the left
        IF_FAILEXIT(hr = _DebugValidateIndexUnrefedRecord(pChain->faLeftChain, faRecord));
    }

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Set faRecord
        if (faRecord == pChain->rgNode[i].faRecord)
        {
            IxpAssert(FALSE);
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Do the Right
        if (pChain->rgNode[i].faRightChain)
        {
            // Index the Right Chain
            IF_FAILEXIT(hr = _DebugValidateIndexUnrefedRecord(pChain->rgNode[i].faRightChain, faRecord));
        }
    }

exit:
    // Done
    return(hr);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\listen.cpp ===
//--------------------------------------------------------------------------
// Listen.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "listen.h"
#include "utility.h"
#include "database.h"

//--------------------------------------------------------------------------
// Strings
//--------------------------------------------------------------------------
const LPSTR g_szDBListenWndProc = "DirectDBListenWndProc";
const LPSTR g_szDBNotifyWndProc = "DirectDBNotifyWndProc";

#ifdef BACKGROUND_MONITOR
//--------------------------------------------------------------------------
// Monitor Kicks in every 30 Seconds
//--------------------------------------------------------------------------
#define IDT_MONITOR                 8567
#define C_MILLISECONDS_MONITOR      (1000 * 10)
#endif

//--------------------------------------------------------------------------
// LISTENTHREADCREATE
//--------------------------------------------------------------------------
typedef struct tagLISTENTHREADCREATE {
    HRESULT             hrResult;
    HANDLE              hEvent;
} LISTENTHREADCREATE, *LPLISTENTHREADCREATE;

//--------------------------------------------------------------------------
// NOTIFYWINDOW
//--------------------------------------------------------------------------
typedef struct tagNOTIFYWINDOW {
    CDatabase          *pDB;
    IDatabaseNotify    *pNotify;
} NOTIFYWINDOW, *LPNOTIFYWINDOW;

#ifdef BACKGROUND_MONITOR
//--------------------------------------------------------------------------
// MONITORENTRY
//--------------------------------------------------------------------------
typedef struct tagMONITORENTRY *LPMONITORENTRY;
typedef struct tagMONITORENTRY {
    CDatabase          *pDB;
    LPMONITORENTRY      pPrevious;
    LPMONITORENTRY      pNext;
} MONITORENTRY;
#endif

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
static HWND             g_hwndListen=NULL;
static HANDLE           g_hListenThread=NULL;
static DWORD            g_dwListenThreadId=0;
static LONG             g_cListenRefs=0;

#ifdef BACKGROUND_MONITOR
static DWORD            g_cMonitor=0;
static LPMONITORENTRY   g_pMonitorHead=NULL;
static LPMONITORENTRY   g_pMonitorPoll=NULL;
#endif

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
DWORD ListenThreadEntry(LPDWORD pdwParam);
LRESULT CALLBACK ListenThreadWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK NotifyThunkWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//--------------------------------------------------------------------------
// GetListenWindow
//--------------------------------------------------------------------------
HRESULT GetListenWindow(HWND *phwndListen)
{
    // Trace
    TraceCall("GetListenWindow");

    // Validate Listen Window Handle
    Assert(g_hwndListen && IsWindow(g_hwndListen));

    // Return
    *phwndListen = g_hwndListen;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CreateListenThread
//--------------------------------------------------------------------------
HRESULT CreateListenThread(void)
{
    // Locals
    HRESULT             hr=S_OK;
    LISTENTHREADCREATE  Create={0};

    // Trace
    TraceCall("CreateListenThread");

    // Thread Safety
    EnterCriticalSection(&g_csDBListen);

    // Already Running ?
    if (NULL != g_hListenThread)
        goto exit;

    // Initialize
    Create.hrResult = S_OK;

    // Create an Event to synchonize creation
    IF_NULLEXIT(Create.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL));

    // Create the inetmail thread
    IF_NULLEXIT(g_hListenThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ListenThreadEntry, &Create, 0, &g_dwListenThreadId));

    // Wait for StoreCleanupThreadEntry to signal the event
    WaitForSingleObject(Create.hEvent, INFINITE);

    // Failure
    if (FAILED(Create.hrResult))
    {
        // Close
        SafeCloseHandle(g_hListenThread);

        // Reset Globals
        g_dwListenThreadId = 0;

        // Null Window
        g_hwndListen = NULL;

        // Return
        hr = TraceResult(Create.hrResult);

        // Done
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csDBListen);

    // Cleanup
    SafeCloseHandle(Create.hEvent);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// ListenThreadAddRef
//--------------------------------------------------------------------------
ULONG ListenThreadAddRef(void)
{
    TraceCall("ListenThreadAddRef");
    return InterlockedIncrement(&g_cListenRefs);
}

//--------------------------------------------------------------------------
// ListenThreadRelease
//--------------------------------------------------------------------------
ULONG ListenThreadRelease(void)
{
    // Trace
    TraceCall("ListenThreadRelease");

    // Decrement
    LONG cRef = InterlockedDecrement(&g_cListenRefs);

    // If still refs, just return
    if (g_cListenRefs > 0)
        return(g_cListenRefs);

    // Invalid Arg
    if (NULL == g_hListenThread)
        goto exit;

    // Assert
    Assert(g_dwListenThreadId && g_hListenThread);

    // Post quit message
    PostThreadMessage(g_dwListenThreadId, WM_QUIT, 0, 0);

    // Wait for event to become signaled
    WaitForSingleObject(g_hListenThread, INFINITE);

    // Validate
    Assert(NULL == g_hwndListen);

    // Close the thread handle
    CloseHandle(g_hListenThread);

    // Reset Globals
    g_hListenThread = NULL;
    g_dwListenThreadId = 0;

    // Un-Register Window Classes
    UnregisterClass(g_szDBListenWndProc, g_hInst);
    UnregisterClass(g_szDBNotifyWndProc, g_hInst);

exit:
    // Done
    return(0);
}

#ifdef BACKGROUND_MONITOR

// --------------------------------------------------------------------------------
// RegisterWithMonitor
// --------------------------------------------------------------------------------
HRESULT RegisterWithMonitor(CDatabase *pDB, LPHMONITORDB phMonitor)
{
    // Locals
    HRESULT             hr=S_OK;
    LPMONITORENTRY      pMonitor=NULL;

    // Trace
    TraceCall("RegisterWithMonitor");

    // Invalid Args
    Assert(pDB && phMonitor);

    // Allocate a new monitor entry
    IF_NULLEXIT(pMonitor = (LPMONITORENTRY)ZeroAllocate(sizeof(MONITORENTRY)));

    // Store the Database
    pMonitor->pDB = pDB;

    // Thread Safety
    EnterCriticalSection(&g_csDBListen);

    // Set pNext
    pMonitor->pNext = g_pMonitorHead;

    // pPrevious
    if (g_pMonitorHead)
        g_pMonitorHead->pPrevious = pMonitor;

    // Reset Head
    g_pMonitorHead = pMonitor;

    // Count Number in Monitor
    g_cMonitor++;

    // Thread Safety
    LeaveCriticalSection(&g_csDBListen);

    // Return phMonitor
    *phMonitor = (HMONITORDB)pMonitor;

    // Don't Free
    pMonitor = NULL;

exit:
    // Cleanup
    SafeMemFree(pMonitor);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// UnregisterFromMonitor
// --------------------------------------------------------------------------------
HRESULT UnregisterFromMonitor(CDatabase *pDB, LPHMONITORDB phMonitor)
{
    // Locals
    LPMONITORENTRY pMonitor;

    // Trace
    TraceCall("UnregisterFromMonitor");

    // Invalid Args
    Assert(pDB && phMonitor);

    // Nothing ?
    if (NULL == *phMonitor)
        return(S_OK);

    // Set pMonitor
    pMonitor = (LPMONITORENTRY)(*phMonitor);

    // Validate
    Assert(pMonitor->pDB == pDB);

    // Thread Safety
    EnterCriticalSection(&g_csDBListen);

    // Fixup Next->Previous
    if (pMonitor->pNext)
    {
        Assert(pMonitor->pNext->pPrevious == pMonitor);
        pMonitor->pNext->pPrevious = pMonitor->pPrevious;
    }

    // Fixup Previous->Next
    if (pMonitor->pPrevious)
    {
        Assert(pMonitor->pPrevious->pNext == pMonitor);
        pMonitor->pPrevious->pNext = pMonitor->pNext;
    }

    // Otherwise, pMonitor must be the head
    else
    {
        // Validate
        Assert(g_pMonitorHead == pMonitor);

        // Set new Head
        g_pMonitorHead = pMonitor->pNext;
    }

    // Adjust g_pMonitorPoll
    if (g_pMonitorPoll == pMonitor)
    {
        // Goto Next
        g_pMonitorPoll = pMonitor->pNext;
    }

    // Count Number in Monitor
    g_cMonitor--;

    // Thread Safety
    LeaveCriticalSection(&g_csDBListen);

    // Free pMonitor
    g_pMalloc->Free(pMonitor);

    // Null the Handle
    *phMonitor = NULL;

    // Done
    return(S_OK);
}
#endif

// --------------------------------------------------------------------------------
// ListenThreadEntry
// --------------------------------------------------------------------------------
DWORD ListenThreadEntry(LPDWORD pdwParam) 
{  
    // Locals
    HRESULT                 hr=S_OK;
    MSG                     msg;
    DWORD                   dw;
    DWORD                   cb;
#ifdef BACKGROUND_MONITOR
    UINT_PTR                uTimer;
#endif
    LPLISTENTHREADCREATE    pCreate;

    // Trace
    TraceCall("ListenThreadEntry");

    // We better have a parameter
    Assert(pdwParam);

    // Cast to create info
    pCreate = (LPLISTENTHREADCREATE)pdwParam;

    // Registery the window class
    IF_FAILEXIT(hr = RegisterWindowClass(g_szDBListenWndProc, ListenThreadWndProc));

    // Create the notification window
    IF_FAILEXIT(hr = CreateNotifyWindow(g_szDBListenWndProc, NULL, &g_hwndListen));

#ifdef BACKGROUND_MONITOR
    // Start the Montior Timer
    uTimer = SetTimer(g_hwndListen, IDT_MONITOR, C_MILLISECONDS_MONITOR, NULL);

    // Failure
    if (0 == uTimer)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }
#endif

    // Success
    pCreate->hrResult = S_OK;

    // Set Event
    SetEvent(pCreate->hEvent);

    // Pump Messages
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // Translate the Message
        TranslateMessage(&msg);

        // Dispatch the Message
        DispatchMessage(&msg);
    }

#ifdef BACKGROUND_MONITOR
    // Validate
    IxpAssert(NULL == g_pMonitorHead && 0 == g_cMonitor);
#endif

#if 0
    // If there are still open databases, we need to force close them so that they get closed propertly
    while (g_pMonitorHead)
    {
        // Unregister...
        if (g_pMonitorHead)
        {
            // Delete pDB
            delete g_pMonitorHead->pDB;
        }
    }
#endif

#ifdef BACKGROUND_MONITOR
    // Kill the Timer
    KillTimer(g_hwndListen, uTimer);
#endif

    // Kill the Window
    DestroyWindow(g_hwndListen);

    // Null It Out
    g_hwndListen = NULL;

exit:
    // Failure
    if (FAILED(hr))
    {
        // Set the Failure Code
        pCreate->hrResult = hr;

        // Trigger the Event
        SetEvent(pCreate->hEvent);
    }

    // Done
    return(1);
}

// --------------------------------------------------------------------------------
// CreateNotifyWindow
// --------------------------------------------------------------------------------
HRESULT CreateNotifyWindow(CDatabase *pDB, IDatabaseNotify *pNotify, HWND *phwndThunk)
{
    // Locals
    HRESULT             hr=S_OK;
    NOTIFYWINDOW    WindowInfo={0};

    // Trace
    TraceCall("CreateNotifyWindow");

    // Registery the window class
    IF_FAILEXIT(hr = RegisterWindowClass(g_szDBNotifyWndProc, NotifyThunkWndProc));

    // Set WindowInfo
    WindowInfo.pDB = pDB;
    WindowInfo.pNotify = pNotify;

    // Create the notification window
    IF_FAILEXIT(hr = CreateNotifyWindow(g_szDBNotifyWndProc, &WindowInfo, phwndThunk));

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// ListenThreadWndProc - Used ONLY for Cross-Process Thunking
// --------------------------------------------------------------------------------
LRESULT CALLBACK ListenThreadWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Trace
    TraceCall("ListenThreadWndProc");

    // Handle WM_COPYDATA Messages
    if (WM_COPYDATA == msg)
    {
        // Cast the Copy Data Structure
        PCOPYDATASTRUCT pCopyData=(PCOPYDATASTRUCT)lParam;

        // Validate dwData
        Assert(0 == pCopyData->dwData);

        // Cast the pPackage Structure
        LPINVOKEPACKAGE pPackage=(LPINVOKEPACKAGE)pCopyData->lpData;

        // Validate the Size
        Assert(pCopyData->cbData == sizeof(INVOKEPACKAGE));

        // Cast the CDatabase
        CDatabase *pDB=(CDatabase *)pPackage->pDB;

        // Process the Package
        pDB->DoInProcessInvoke(pPackage->tyInvoke);

        // Done
        return 1;
    }

#ifdef BACKGROUND_MONITOR
    // Timer
    else if (WM_TIMER == msg && IDT_MONITOR == wParam)
    {
        // Thread Safety
        EnterCriticalSection(&g_csDBListen);

        // Get pMonitor
        LPMONITORENTRY pMonitor = g_pMonitorPoll ? g_pMonitorPoll : g_pMonitorHead;

        // Set Current
        if (pMonitor)
        {
            // Validate
            Assert(pMonitor->pDB);

            // Background Monitor
            pMonitor->pDB->DoBackgroundMonitor();

            // Set g_pMonitorPoll
            g_pMonitorPoll = pMonitor->pNext;
        }
        
        // Thread Safety
        LeaveCriticalSection(&g_csDBListen);
    }
#endif

    // Deletegate
    return(DefWindowProc(hwnd, msg, wParam, lParam));
}

// --------------------------------------------------------------------------------
// NotifyThunkWndProc
// --------------------------------------------------------------------------------
LRESULT CALLBACK NotifyThunkWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPNOTIFYWINDOW  pWindow;

    // Trace
    TraceCall("NotifyThunkWndProc");

    // WM_ONTRANSACTION
    if (WM_ONTRANSACTION == msg)
    {
        // Get Window Info
        pWindow = (LPNOTIFYWINDOW)GetWndThisPtr(hwnd);

        // Deliver the Notification
        pWindow->pNotify->OnTransaction((HTRANSACTION)lParam, (DWORD)wParam, pWindow->pDB);

        // Done
        return(TRUE);
    }

    // Create ?
    else if (WM_CREATE == msg)
    {
        // Create Struct
        LPCREATESTRUCT pCreate = (LPCREATESTRUCT)lParam;

        // Create Params
        LPNOTIFYWINDOW pCreateInfo = (LPNOTIFYWINDOW)pCreate->lpCreateParams;

        // Validate
        Assert(pCreateInfo->pDB && pCreateInfo->pNotify);

        // Allocate NOTIFYWINDOW
        pWindow = (LPNOTIFYWINDOW)ZeroAllocate(sizeof(NOTIFYWINDOW));

        // Failure ?
        if (NULL == pWindow)
            return(-1);

        // Copy the Create Information
        CopyMemory(pWindow, pCreateInfo, sizeof(NOTIFYWINDOW));

        // Store pInfo into this
        SetWndThisPtr(hwnd, pWindow);

        // Done
        return(FALSE);
    }

    // Destroy
    else if (WM_DESTROY == msg)
    {
        // Get Window Info
        pWindow = (LPNOTIFYWINDOW)GetWndThisPtr(hwnd);

        // Free It
        g_pMalloc->Free(pWindow);

        // Store pInfo into this
        SetWndThisPtr(hwnd, NULL);
    }

    // Deletegate
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\query.h ===
//--------------------------------------------------------------------------
// Query.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CDatabase;
typedef struct tagRECORDMAP *LPRECORDMAP;

//--------------------------------------------------------------------------
// HQUERY
//--------------------------------------------------------------------------
DECLARE_HANDLE(HQUERY);
typedef HQUERY *LPHQUERY;

//--------------------------------------------------------------------------
// BuildQueryTree
//--------------------------------------------------------------------------
HRESULT EvaluateQuery(HQUERY hQuery, LPVOID pBinding, LPCTABLESCHEMA pSchema, CDatabase *pDB, IDatabaseExtension *pExtension);
HRESULT ParseQuery(LPCSTR pszQuery, LPCTABLESCHEMA pSchema, LPHQUERY phQuery, CDatabase *pDB);
HRESULT CloseQuery(LPHQUERY phQuery, CDatabase *pDB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\repair.h ===
//--------------------------------------------------------------------------
// dbrepair.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// REPAIRSTATE
//--------------------------------------------------------------------------
typedef enum tagREPAIRSTATE {
    REPAIR_VERIFYING,
    REPAIR_FIXING
} REPAIRSTATE;

//--------------------------------------------------------------------------
// CDatabaseRepairUI
//--------------------------------------------------------------------------
class CDatabaseRepairUI : public IUnknown
{
public:
    //----------------------------------------------------------------------
    // Construction - Destruction
    //----------------------------------------------------------------------
    CDatabaseRepairUI(void);
    ~CDatabaseRepairUI(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return(E_NOTIMPL); }
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // CDatabaseRepairUI Members
    //----------------------------------------------------------------------
    HRESULT Initialize(LPCSTR pszFilePath, DWORD cMax);
    HRESULT IncrementProgress(REPAIRSTATE tyState, DWORD cIncrement);
    HRESULT SetProgress(REPAIRSTATE tyState, DWORD cCurrent);
    HRESULT Reset(REPAIRSTATE tyState, DWORD cMax);

    //----------------------------------------------------------------------
    // Thread Entry
    //----------------------------------------------------------------------
    static DWORD ThreadEntry(LPDWORD pdwParam);
    static INT_PTR CALLBACK ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    //----------------------------------------------------------------------
    // Private Members
    //----------------------------------------------------------------------
    void _Update(REPAIRSTATE tyState);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG            m_cRef;
    LPSTR           m_pszFile;
    DWORD           m_cMax;
    DWORD           m_cCurrent;
    DWORD           m_cPercent;
    HANDLE          m_hThread;
    DWORD           m_dwThreadId;
    HWND            m_hwnd;
    REPAIRSTATE     m_tyState;
    HRESULT         m_hrResult;
    HANDLE          m_hEvent;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\repair.cpp ===
//--------------------------------------------------------------------------
// Repair.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "repair.h"
#include "strconst.h"
#include <commctrl.h>
#include "utility.h"
#include "resource.h"

//--------------------------------------------------------------------------
// Custom Messages
//--------------------------------------------------------------------------
#define WM_UPDATESTATUS     (WM_USER + 1)

//--------------------------------------------------------------------------
// CDatabaseRepairUI::CDatabaseRepairUI
//--------------------------------------------------------------------------
CDatabaseRepairUI::CDatabaseRepairUI(void)
{
    TraceCall("CDatabaseRepairUI::CDatabaseRepairUI");
    m_cRef = 1;
    m_pszFile = NULL;
    m_cMax = 0;
    m_cCurrent = 0;
    m_hThread = NULL;
    m_dwThreadId = 0;
    m_cPercent = 0;
    m_hwnd = NULL;
    m_tyState = REPAIR_VERIFYING;
    m_hrResult = S_OK;
    m_hEvent = NULL;
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::~CDatabaseRepairUI
//--------------------------------------------------------------------------
CDatabaseRepairUI::~CDatabaseRepairUI(void)
{
    // Trace
    TraceCall("CDatabaseRepairUI::~CDatabaseRepairUI");

    // Free the file..
    SafeMemFree(m_pszFile);

    // Thread has not been closed yet ?
    if (m_hThread)
    {
        // Must have threadid
        Assert(m_dwThreadId);

        // Post quit message
        if (0 != PostThreadMessage(m_dwThreadId, WM_QUIT, 0, 0))
        {
            // Wait for event to become signaled
            if (WAIT_OBJECT_0 != WaitForSingleObject(m_hThread, 2000))
                TerminateThread(m_hThread, 0);  // opie made me put this code in!
        }

        // Otherwise, error
        else
            TraceResult(E_FAIL);

        // Close the thread handle
        CloseHandle(m_hThread);
    }

    // Close m_hEvent
    SafeCloseHandle(m_hEvent);
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabaseRepairUI::AddRef(void)
{
    TraceCall("CDatabaseRepairUI::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabaseRepairUI::Release(void)
{
    TraceCall("CDatabaseRepairUI::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::Initialize
//--------------------------------------------------------------------------
HRESULT CDatabaseRepairUI::Initialize(LPCSTR pszFilePath, DWORD cMax)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("CDatabaseRepairUI::Initialize");

    // Get the filename
    IF_NULLEXIT(m_pszFile = DuplicateString(PathFindFileName(pszFilePath)));

    // Save cMax
    m_cMax = cMax;

    // Create an Event to Wait On
    IF_NULLEXIT(m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL));
    
    // Create a thread to display the actual dialog box on...
    IF_NULLEXIT(m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CDatabaseRepairUI::ThreadEntry, this, 0, &m_dwThreadId));

    // Wait for StoreCleanupThreadEntry to signal the event
    WaitForSingleObject(m_hEvent, INFINITE);

    // Failure
    if (FAILED(m_hrResult))
    {
        // Close
        SafeCloseHandle(m_hThread);

        // Reset Globals
        m_dwThreadId = 0;

        // Null Window
        m_hwnd = NULL;

        // Return
        hr = TraceResult(m_hrResult);

        // Done
        goto exit;
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::IncrementProgress
//--------------------------------------------------------------------------
HRESULT CDatabaseRepairUI::IncrementProgress(REPAIRSTATE tyState, DWORD cIncrement)
{
    // Trace
    TraceCall("CDatabaseRepairUI::IncrementProgress");

    // Increment Progress
    m_cCurrent += cIncrement;

    // Update
    _Update(tyState);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::SetProgress
//--------------------------------------------------------------------------
HRESULT CDatabaseRepairUI::SetProgress(REPAIRSTATE tyState, DWORD cCurrent)
{
    // Trace
    TraceCall("CDatabaseRepairUI::SetProgress");

    // Increment Progress
    m_cCurrent = cCurrent;

    // Update
    _Update(tyState);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::SetProgress
//--------------------------------------------------------------------------
HRESULT CDatabaseRepairUI::Reset(REPAIRSTATE tyState, DWORD cMax)
{
    // Trace
    TraceCall("CDatabaseRepairUI::SetProgress");

    // Increment Progress
    m_cCurrent = 0;

    // Reset max
    m_cMax = cMax;

    // Update
    _Update(tyState);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::_Update
//--------------------------------------------------------------------------
void CDatabaseRepairUI::_Update(REPAIRSTATE tyState)
{
    // Locals
    DWORD cPercent;

    // Trace
    TraceCall("CDatabaseRepairUI::_Update");

    // Max
    if (0 == m_cMax)
        m_cCurrent = cPercent = 0;
    else
        cPercent = (DWORD)((m_cCurrent) * 100 / m_cMax);

    // Difference
    if (cPercent != m_cPercent || 0 == m_cCurrent || tyState != m_tyState)
    {
        // Save State
        m_tyState = tyState;

        // Save It
        m_cPercent = cPercent;

        // Update status
        SendMessage(m_hwnd, WM_UPDATESTATUS, 0, 0);
    }
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::ThreadEntry
//--------------------------------------------------------------------------
DWORD CDatabaseRepairUI::ThreadEntry(LPDWORD pdwParam)
{
    // Locals
    HRESULT             hr=S_OK;
    MSG                 msg;
    CDatabaseRepairUI  *pThis = (CDatabaseRepairUI *)pdwParam;

    // Validate
    Assert(pThis);

    // Create the modeless dialog window
    IF_NULLEXIT(pThis->m_hwnd = CreateDialogParam(g_hInst, MAKEINTRESOURCE(IDD_REPAIR), NULL, CDatabaseRepairUI::ProgressDlgProc, (LPARAM)pThis));

    // Set Event
    SetEvent(pThis->m_hEvent);

    // Success
    pThis->m_hrResult = S_OK;

    // Pump Messages
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // Translate the Message
        TranslateMessage(&msg);

        // Dispatch the Message
        DispatchMessage(&msg);
    }

    // Nuke the Window
    DestroyWindow(pThis->m_hwnd);

exit:
    // Failure
    if (FAILED(hr))
    {
        // Nuke the Window
        if (pThis->m_hwnd)
            DestroyWindow(pThis->m_hwnd);

        // Set the Failure Code
        pThis->m_hrResult = hr;

        // Trigger the Event
        SetEvent(pThis->m_hEvent);
    }

    // Success
    Assert(SUCCEEDED(hr));

    // Done
    return(1);
}

//--------------------------------------------------------------------------
// CDatabaseRepairUI::ProgressDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK CDatabaseRepairUI::ProgressDlgProc(HWND hwnd, UINT uMsg, 
    WPARAM wParam, LPARAM lParam)
{
    // Locals
    CHAR                szRes[255];
    CHAR                szMsg[255 + MAX_PATH];
    CDatabaseRepairUI  *pThis = (CDatabaseRepairUI *)GetWndThisPtr(hwnd);
    static HWND         s_hwndProgress=NULL;

    // Trace
    TraceCall("CDatabaseRepairUI::ProgressDlgProc");

    // Handle Window Message
    switch(uMsg)
    {
    // Initialize
    case WM_INITDIALOG:

        // Get pThis
        pThis = (CDatabaseRepairUI *)lParam;

        // Save pThis
        SetWndThisPtr(hwnd, pThis);

        // Get Progress
        s_hwndProgress = GetDlgItem(hwnd, IDC_REPAIR_PROGRESS);

        // Set the Message...
        SendMessage(hwnd, WM_UPDATESTATUS, 0, 0);

        // Show the Window
        ShowWindow(hwnd, SW_SHOWNORMAL);

        // Set to foreground
        SetForegroundWindow(hwnd);

        // Done
        return(1);

    case WM_UPDATESTATUS:

        // Verifying '%s' - 95% Complete
        LoadString(g_hInst, (REPAIR_VERIFYING == pThis->m_tyState) ? IDS_VERIFYING_FILE : IDS_REPAIRING_FILE, szRes, ARRAYSIZE(szRes));

        // Format the string
        wsprintf(szMsg, szRes, pThis->m_cPercent, pThis->m_pszFile ? pThis->m_pszFile : c_szEmpty);

        // Set the Status
        SetDlgItemText(hwnd, IDC_REPAIR_STATUS, szMsg);

        // Update the Progress
        SendMessage(s_hwndProgress, PBM_SETPOS, pThis->m_cPercent, 0);

        // Done
        return(1);
    }

    // Not Handled
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\stream.h ===
//--------------------------------------------------------------------------
// Stream.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
#include "database.h"

//--------------------------------------------------------------------------
// CDatabaseStream
//--------------------------------------------------------------------------
class CDatabaseStream : public IDatabaseStream
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CDatabaseStream(CDatabase *pDB, STREAMINDEX iStream, ACCESSTYPE tyAccess, FILEADDRESS faStart) 
        : m_iStream(iStream), 
          m_faStart(faStart), 
          m_tyAccess(tyAccess) 
    {
        TraceCall("CDatabaseStream::CDatabaseStream");
        m_cRef = 1; 
        m_cbOffset = 0; 
        m_iCurrent = 0; 
        m_cbCurrent = 0;
        m_faCurrent = m_faStart; 
        m_pDB = pDB; 
        m_pDB->AddRef();
    }
        
    //----------------------------------------------------------------------
    // De-construction
    //----------------------------------------------------------------------
    ~CDatabaseStream(void) { 
        TraceCall("CDatabaseStream::~CDatabaseStream");
        m_pDB->StreamRelease(this); m_pDB->Release(); 
    }

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) {
        TraceCall("CDatabaseStream::QueryInterface");
        *ppv = NULL;
        if (IID_IUnknown == riid)
            *ppv = (IUnknown *)(IDatabaseStream *)this;
        else if (IID_IStream == riid)
            *ppv  = (IStream *)this;
        else if (IID_IDatabaseStream == riid)
            *ppv = (IDatabaseStream *)this;
        else if (IID_CDatabaseStream == riid)
            *ppv = (CDatabaseStream *)this;
        else
            return TraceResult(E_NOINTERFACE);
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    //----------------------------------------------------------------------
    // IStream::AddRef
    //----------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(void) {
        TraceCall("CDatabaseStream::AddRef");
        return InterlockedIncrement(&m_cRef);
    }

    //----------------------------------------------------------------------
    // IStream::Release
    //----------------------------------------------------------------------
    STDMETHODIMP_(ULONG) Release(void) {
        TraceCall("CDatabaseStream::Release");
        LONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
            delete this;
        return (ULONG)cRef;
    }

    //----------------------------------------------------------------------
    // IStream::Read
    //----------------------------------------------------------------------
    STDMETHODIMP Read(LPVOID pvData, ULONG cbWanted, ULONG *pcbRead) { 
        TraceCall("CDatabaseStream::Read");
        return m_pDB->StreamRead(this, pvData, cbWanted, pcbRead);
    }

    //----------------------------------------------------------------------
    // IStream::Write
    //----------------------------------------------------------------------
    STDMETHODIMP Write(const void *pvData, ULONG cb, ULONG *pcbWritten) {
        TraceCall("CDatabaseStream::Write");
        return m_pDB->StreamWrite(this, pvData, cb, pcbWritten);
    }

    //----------------------------------------------------------------------
    // IStream::Seek
    //----------------------------------------------------------------------
    STDMETHODIMP Seek(LARGE_INTEGER liMove, DWORD dwOrigin, ULARGE_INTEGER *pulNew) {
        TraceCall("CDatabaseStream::Seek");
        return m_pDB->StreamSeek(this, liMove, dwOrigin, pulNew);
    }

    //----------------------------------------------------------------------
    // CDatabaseStream::GetFileAddress
    //----------------------------------------------------------------------
    STDMETHODIMP GetFileAddress(LPFILEADDRESS pfaStream) { 
        TraceCall("CDatabaseStream::GetFileAddress");
        return m_pDB->GetStreamAddress(this, pfaStream);
    }

    //----------------------------------------------------------------------
    // CDatabaseStream::CompareDatabase
    //----------------------------------------------------------------------
    STDMETHODIMP CompareDatabase(IDatabase *pDatabase) {
        TraceCall("CDatabaseStream::CompareDatabase");
        return m_pDB->StreamCompareDatabase(this, pDatabase);
    }

    //----------------------------------------------------------------------
    // Not Implemented IStream Methods
    //----------------------------------------------------------------------
    STDMETHODIMP SetSize(ULARGE_INTEGER uliSize) { return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD) { return S_OK; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER*, ULARGE_INTEGER*) { return E_NOTIMPL; }
    STDMETHODIMP Revert(void) { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER,DWORD) { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG *, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM*) { return E_NOTIMPL; }

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                    m_cRef;
    STREAMINDEX             m_iStream;
    FILEADDRESS             m_faStart;
    ACCESSTYPE              m_tyAccess;
    DWORD                   m_iCurrent;
    DWORD                   m_faCurrent;
    DWORD                   m_cbCurrent;
    DWORD                   m_cbOffset;
    CDatabase              *m_pDB;

    //----------------------------------------------------------------------
    // Private Friend
    //----------------------------------------------------------------------
    friend CDatabase;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\session.cpp ===
//--------------------------------------------------------------------------
// Session.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "session.h"
#include "listen.h"
#include "database.h"
#include "wrapwide.h"

//--------------------------------------------------------------------------
// CreateDatabaseSession
//--------------------------------------------------------------------------
HRESULT CreateDatabaseSession(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("CreateDatabaseSession");

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CDatabaseSession *pNew = new CDatabaseSession();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IDatabaseSession *);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CDatabaseSession::CDatabaseSession
//--------------------------------------------------------------------------
CDatabaseSession::CDatabaseSession(void)
{
    TraceCall("CDatabaseSession::CDatabaseSession");
    m_cRef = 1;
    ListenThreadAddRef();
}

//--------------------------------------------------------------------------
// CDatabaseSession::~CDatabaseSession
//--------------------------------------------------------------------------
CDatabaseSession::~CDatabaseSession(void)
{
    TraceCall("CDatabaseSession::~CDatabaseSession");
    ListenThreadRelease();
}

//--------------------------------------------------------------------------
// CDatabaseSession::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabaseSession::AddRef(void)
{
    TraceCall("CDatabaseSession::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CDatabaseSession::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDatabaseSession::Release(void)
{
    TraceCall("CDatabaseSession::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CDatabaseSession::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CDatabaseSession::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CDatabaseSession::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IDatabaseSession == riid)
        *ppv = (IDatabaseSession *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabaseSession::OpenDatabase
//--------------------------------------------------------------------------
STDMETHODIMP CDatabaseSession::OpenDatabase(LPCSTR pszFile, OPENDATABASEFLAGS dwFlags,
    LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension, IDatabase **ppDB)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszFile=NULL;

    // Trace
    TraceCall("CDatabaseSession::OpenDatabase");

    // Convert to Unicode
    IF_NULLEXIT(pwszFile = ConvertToUnicode(CP_ACP, pszFile));

    // Open It
    IF_FAILEXIT(hr = OpenDatabaseW(pwszFile, dwFlags, pSchema, pExtension, ppDB));

exit:
    // Cleanup
    g_pMalloc->Free(pwszFile);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabaseSession::OpenDatabaseW
//--------------------------------------------------------------------------
STDMETHODIMP CDatabaseSession::OpenDatabaseW(LPCWSTR pszFile, OPENDATABASEFLAGS dwFlags,
    LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension, IDatabase **ppDB)
{
    // Locals
    HRESULT         hr=S_OK;
    CDatabase      *pDatabase=NULL;

    // Trace
    TraceCall("CDatabaseSession::OpenDatabaseW");

    // Create a pDatabase
    IF_NULLEXIT(pDatabase = new CDatabase);

    // Open It
    IF_FAILEXIT(hr = pDatabase->Open(pszFile, dwFlags, pSchema, pExtension));

    // Cast It
    (*ppDB) = (IDatabase *)pDatabase;

    // Don't Free It
    pDatabase = NULL;

exit:
    // Cleanup
    SafeRelease(pDatabase);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CDatabaseSession::OpenQuery
//--------------------------------------------------------------------------
STDMETHODIMP CDatabaseSession::OpenQuery(IDatabase *pDatabase, LPCSTR pszQuery,
    IDatabaseQuery **ppQuery)
{
    // Locals
    HRESULT         hr=S_OK;
    CDatabaseQuery *pQuery=NULL;

    // Trace
    TraceCall("CDatabaseSession::OpenQuery");

    // Create a pDatabase
    IF_NULLEXIT(pQuery = new CDatabaseQuery);

    // Open It
    IF_FAILEXIT(hr = pQuery->Initialize(pDatabase, pszQuery));

    // Cast It
    (*ppQuery) = (IDatabaseQuery *)pQuery;

    // Don't Free It
    pQuery = NULL;

exit:
    // Cleanup
    SafeRelease(pQuery);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\session.h ===
//--------------------------------------------------------------------------
// Session.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// CDatabaseSession
//--------------------------------------------------------------------------
class CDatabaseSession : public IDatabaseSession
{
public:
    //----------------------------------------------------------------------
    // Construction / Deconstruction
    //----------------------------------------------------------------------
    CDatabaseSession(void);
    ~CDatabaseSession(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IDatabaseSession Members
    //----------------------------------------------------------------------
    STDMETHODIMP OpenDatabase(LPCSTR pszFile, OPENDATABASEFLAGS dwFlags, LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension, IDatabase **ppDB);
    STDMETHODIMP OpenDatabaseW(LPCWSTR pszFile, OPENDATABASEFLAGS dwFlags, LPCTABLESCHEMA pSchema, IDatabaseExtension *pExtension, IDatabase **ppDB);
    STDMETHODIMP OpenQuery(IDatabase *pDatabase, LPCSTR pszQuery, IDatabaseQuery **ppQuery);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                    m_cRef;
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT CreateDatabaseSession(IUnknown *pUnkOuter, IUnknown **ppUnknown);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\threads.cpp ===
//--------------------------------------------------------------------------
// Threads.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "database.h"
#include "types.h"

//--------------------------------------------------------------------------
// THREADIDHEADER
//--------------------------------------------------------------------------
typedef struct tagTHREADIDHEADER {
    WORD            cDepth;
} THREADIDHEADER, *LPTHREADIDHEADER;

//--------------------------------------------------------------------------
// THREADIDBLOCK
//--------------------------------------------------------------------------
typedef struct tagTHREADIDBLOCK {
    DWORD           cbSize;
} THREADIDBLOCK, *LPTHREADIDBLOCK;

//--------------------------------------------------------------------------
// GetThreadIdBlockSize
//--------------------------------------------------------------------------
DWORD GetThreadIdBlockSize(LPCTABLESCHEMA pSchema, LPTABLEINDEX pIndex,
    LPVOID pBinding)
{
    // Locals
    DWORD           i;
    DWORD           cbSize;
    LPCTABLECOLUMN  pColumn;

    // Include space for column tags
    cbSize = sizeof(THREADIDBLOCK) + (pIndex->cKeys * sizeof(COLUMNTAG));

    // Walk through Index1 and get size of items from pParent
    for (i=0; i<pIndex->cKeys; i++)
    {
        // Readability
        pColumn = &pSchema->prgColumn[pIndex->rgKey[i].iColumn];

        // Compute Amount of Data to Store
        cbSize += DBTypeGetSize(pColumn, pBinding);
    }

    // Done
    return(cbSize);
}

//--------------------------------------------------------------------------
// WriteThreadIdBlock
//--------------------------------------------------------------------------
HRESULT WriteThreadIdBlock(LPCTABLESCHEMA pSchema, LPTABLEINDEX pIndex, 
    LPVOID pBinding, DWORD cbBlock, LPBYTE pbBlock)
{
    // Locals
    DWORD           i;
    THREADIDBLOCK   Block={0};
    DWORD           cbOffset=0;
    DWORD           cbTags;
    LPBYTE          pbData;
    LPCOLUMNTAG     prgTag;
    LPCOLUMNTAG     pTag;
    LPCTABLECOLUMN  pColumn;

    // Trace
    TraceCall("WriteThreadIdBlock");

    // Invalid Args
    Assert(pSchema && pIndex && pBinding && cbBlock && pbBlock);

    // Write the Block Header
    Block.cbSize = cbBlock;

    // Write the Header
    CopyMemory(pbBlock, &Block, sizeof(THREADIDBLOCK));

    // Set prgTag
    prgTag = (LPCOLUMNTAG)(pbBlock + sizeof(THREADIDBLOCK));

    // Set cbTags
    cbTags = (sizeof(COLUMNTAG) * pIndex->cKeys);

    // Set pbData
    pbData = (pbBlock + sizeof(THREADIDBLOCK) + cbTags);

    // Walk through Index1 and get size of items from pParent
    for (i=0; i<pIndex->cKeys; i++)
    {
        // Readability
        pColumn = &pSchema->prgColumn[pIndex->rgKey[i].iColumn];

        // Compute Hash
        pTag = &prgTag[i];

        // Set Tag Id
        pTag->iColumn = pColumn->iOrdinal;
    
        // Assume pTag Doesn't Contain Data
        pTag->fData = 0;

        // Store the Offset
        pTag->Offset = cbOffset;
    
        // WriteBindTypeData
        cbOffset += DBTypeWriteValue(pColumn, pBinding, pTag, pbData + cbOffset);
    }

    // Validate
    Assert(cbOffset == cbBlock - cbTags - sizeof(THREADIDBLOCK));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// WriteThreadIdHeader
//--------------------------------------------------------------------------
HRESULT WriteThreadIdHeader(LPBYTE pbThreadId, LPTHREADINGINFO pThreading, 
    LPBYTE *ppbNext)
{
    // Locals
    DWORD           i;
    THREADIDHEADER  Header={0};
    LPBYTE          pbWrite=pbThreadId;

    // Trace
    TraceCall("WriteThreadIdHeader");

    // Invalid Arg
    Assert(pbThreadId && pThreading && ppbNext);

    // Write the Header
    CopyMemory(pbWrite, &Header, sizeof(THREADIDHEADER));

    // Increment pbWrite
    pbWrite += sizeof(THREADIDHEADER);

    // Set Return
    *ppbNext = pbWrite;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// CreateThreadId
//--------------------------------------------------------------------------
HRESULT CreateThreadId(CDatabase *pDB, LPCTABLESCHEMA pSchema, 
    LPTHREADINGINFO pThreading, LPVOID pParent, LPVOID pChild, 
    LPBLOB pThreadId)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cbBlock;
    LPBYTE              pbBlock;
    DWORD               cbHeader;
    LPBLOB              pParentId;
    DWORD               cbThreadId;
    LPBYTE              pbThreadId=NULL;
    LPTHREADIDHEADER    pHeader;

    // Trace
    TraceCall("CreateThreadId");

    // Invalid Args
    Assert(pThreading && pSchema && pChild && pThreadId);
    Assert(pSchema->prgColumn[pThreading->iThreadId].type == CDT_THREADID);

    // Initialize
    pThreadId->cbSize = 0;
    pThreadId->pBlobData = NULL;

    // If no parent, build thread id from pChild
    if (NULL == pParent)
    {
        // Get size of thread Id
        cbBlock = GetThreadIdBlockSize(pSchema, &pThreading->RootIndex, pChild);

        // Compute cbThreadId
        cbThreadId = sizeof(THREADIDHEADER) + cbBlock;

        // Allocate the ThreadId
        IF_NULLEXIT(pbThreadId = (LPBYTE)pDB->PHeapAllocate(0, cbThreadId));

        // Write ThreadIdHeader
        IF_FAILEXIT(hr = WriteThreadIdHeader(pbThreadId, pThreading, &pbBlock));

        // Write the ThreadIdBlock
        IF_FAILEXIT(hr = WriteThreadIdBlock(pSchema, &pThreading->RootIndex, pChild, cbBlock, pbBlock));
    }

    // Otherwise
    else
    {
        // Get Parent ThreadId
        pParentId = (LPBLOB)((LPBYTE)pParent + pSchema->prgColumn[pThreading->iThreadId].ofBinding);

        // Parent Must have an ID
        Assert(pParentId && pParentId->cbSize && pParentId->pBlobData);

        // Get size of thread Id
        cbBlock = GetThreadIdBlockSize(pSchema, &pThreading->ChildIndex, pChild);

        // Compute cbThreadId
        cbThreadId = pParentId->cbSize + cbBlock;

        // Allocate the ThreadId
        IF_NULLEXIT(pbThreadId = (LPBYTE)pDB->PHeapAllocate(0, cbThreadId));

        // Fill the Block Header
        CopyMemory(pbThreadId, pParentId->pBlobData, pParentId->cbSize);

        // Set pHeader
        pHeader = (LPTHREADIDHEADER)pbThreadId;

        // Adjust the Depth
        pHeader->cDepth++;

        // Write the ThreadIdBlock
        IF_FAILEXIT(hr = WriteThreadIdBlock(pSchema, &pThreading->ChildIndex, pChild, cbBlock, pbThreadId + pParentId->cbSize));
    }

    // Return that ThreadId
    pThreadId->cbSize = cbThreadId;
    pThreadId->pBlobData = pbThreadId;
    pbThreadId = NULL;

exit:
    // Cleanup
    pDB->HeapFree(pbThreadId);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CompareBindingThreadId
//--------------------------------------------------------------------------
INT CompareBindingThreadId(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPRECORDMAP pMap)
{   
    // Locals
    LPBLOB  pThreadId1=NULL;
    LPBLOB  pThreadId2=NULL;
    BLOB    ThreadId2;

    // Validate
    Assert(pMap && pMap->pThreading);

    // Get Left ThreadId
    pThreadId1 = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);

    // No Tag
    if (pTag)
    {
        // Get the Right ThreadId
        ThreadId2.cbSize = *((DWORD *)(pMap->pbData + pTag->Offset));
        ThreadId2.pBlobData = (ThreadId2.cbSize > 0) ? ((pMap->pbData + pTag->Offset) + sizeof(DWORD)) : NULL;
        pThreadId2 = &ThreadId2;
    }

    // Compare
    return(CompareThreadIds(pMap->pSchema, pMap->pThreading, pThreadId1, pThreadId2));
}

//--------------------------------------------------------------------------
// CompareRecordThreadId
//--------------------------------------------------------------------------
INT CompareRecordThreadId(LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, 
    LPRECORDMAP pMap1, LPRECORDMAP pMap2)
{
    // Locals
    LPBLOB  pThreadId1=NULL;
    LPBLOB  pThreadId2=NULL;
    BLOB    ThreadId1;
    BLOB    ThreadId2;

    // Validate
    Assert(pMap1 && pMap2 && pMap2->pThreading);

    // Get Left ThreadId
    if (pTag1)
    {
        ThreadId1.cbSize = *((DWORD *)(pMap1->pbData + pTag1->Offset));
        ThreadId1.pBlobData = (ThreadId1.cbSize > 0) ? ((pMap1->pbData + pTag1->Offset) + sizeof(DWORD)) : NULL;
        pThreadId1 = &ThreadId1;
    }

    // Get the Right ThreadId
    if (pTag2)
    {
        ThreadId2.cbSize = *((DWORD *)(pMap2->pbData + pTag2->Offset));
        ThreadId2.pBlobData = (ThreadId2.cbSize > 0) ? ((pMap2->pbData + pTag2->Offset) + sizeof(DWORD)) : NULL;
        pThreadId2 = &ThreadId2;
    }

    // Compare
    return(CompareThreadIds(pMap2->pSchema, pMap2->pThreading, pThreadId1, pThreadId2));
}

//--------------------------------------------------------------------------
// SetRecordMap
//--------------------------------------------------------------------------
void SetRecordMap(BYTE cKeys, LPBYTE pbRead, LPRECORDMAP pMap, LPBYTE *ppbRead)
{
    // Locals
    LPTHREADIDBLOCK pBlock;

    // Trace
    TraceCall("SetRecordMap");

    // Set Block
    pBlock = (LPTHREADIDBLOCK)pbRead;

    // Increment pbRead
    pbRead += sizeof(THREADIDBLOCK);

    // Set Number of Tags
    pMap->cTags = cKeys;

    // Set cbTags
    pMap->cbTags = (sizeof(COLUMNTAG) * pMap->cTags);

    // Set prgTag
    pMap->prgTag = (LPCOLUMNTAG)pbRead;

    // Increment pbRead
    pbRead += (pMap->cbTags);

    // Set pbData
    pMap->pbData = pbRead;

    // Set cbData
    pMap->cbData = (pBlock->cbSize - sizeof(THREADIDBLOCK) - pMap->cbTags);

    // Increment pbRead
    pbRead += (pMap->cbData);

    // Set ppbRead
    *ppbRead = pbRead;

    // Done
    return;
}

//--------------------------------------------------------------------------
// CompareThreadIdBlocks
//--------------------------------------------------------------------------
INT CompareThreadIdBlocks(LPCTABLESCHEMA pSchema, LPTABLEINDEX pIndex,
    LPRECORDMAP pMap1, LPRECORDMAP pMap2)
{
    // Locals
    DWORD           iKey;
    LPCOLUMNTAG     pTag1;
    LPCOLUMNTAG     pTag2;
    LPCTABLECOLUMN  pColumn;
    INT             nCompare;

    // Trace
    TraceCall("CompareThreadIdBlocks");

    // Compare Root Keys
    for (iKey=0; iKey<pIndex->cKeys; iKey++)
    {
        // Get Tags
        pTag1 = &pMap1->prgTag[iKey];
        pTag2 = &pMap2->prgTag[iKey];

        // Validate the Tags
        Assert(pTag1->iColumn == pTag2->iColumn && pTag1->iColumn == pIndex->rgKey[iKey].iColumn);

        // Get the Column
        pColumn = &pSchema->prgColumn[pTag1->iColumn];

        // Validate Column
        Assert(CDT_THREADID != pColumn->type);

        // Compare the Values
        nCompare = DBTypeCompareRecords(pColumn, &pIndex->rgKey[iKey], pTag1, pTag2, pMap1, pMap2);

        // Reverse nCompare
        if (0 != nCompare)
            break;
    }

    // Done
    return(nCompare);
}

//--------------------------------------------------------------------------
// CompareThreadIds
//--------------------------------------------------------------------------
INT CompareThreadIds(LPCTABLESCHEMA pSchema, LPTHREADINGINFO pThreading,
    LPBLOB pThreadId1, LPBLOB pThreadId2)
{
    // Locals
    INT                 nCompare=0;
    DWORD               iDepth;
    DWORD               cDepth;
    LPBYTE              pbRead1;
    LPBYTE              pbRead2;
    LPTHREADIDHEADER    pHeader1;
    LPTHREADIDHEADER    pHeader2;
    RECORDMAP           Map1;
    RECORDMAP           Map2;

    // Trace
    TraceCall("CompareThreadIds");

    // Invalid Args
    Assert(pSchema);

    // Invalid or no ThreadId1
    if (NULL == pThreadId1 || 0 == pThreadId1->cbSize || NULL == pThreadId2 || 0 == pThreadId2->cbSize)
    {
        IxpAssert(FALSE);
        return(-1);
    }

    // Set pbRead
    pbRead1 = pThreadId1->pBlobData;
    pbRead2 = pThreadId2->pBlobData;

    // Set Headers
    pHeader1 = (LPTHREADIDHEADER)(pbRead1);
    pHeader2 = (LPTHREADIDHEADER)(pbRead2);

    // Increment
    pbRead1 += sizeof(THREADIDHEADER);
    pbRead2 += sizeof(THREADIDHEADER);

    // Fill Record Maps
    SetRecordMap(pThreading->RootIndex.cKeys, pbRead1, &Map1, &pbRead1);
    SetRecordMap(pThreading->RootIndex.cKeys, pbRead2, &Map2, &pbRead2);

    // CompareThreadIdBlocks
    nCompare = CompareThreadIdBlocks(pSchema, &pThreading->RootIndex, &Map1, &Map2);

    // If Equal
    if (0 == nCompare)
    {
        // Compute cDepth to compare to...
        cDepth = min(pHeader1->cDepth, pHeader2->cDepth);

        // Compare to least depth
        for (iDepth=0; iDepth<cDepth; iDepth++)
        {
            // Fill Record Maps
            SetRecordMap(pThreading->ChildIndex.cKeys, pbRead1, &Map1, &pbRead1);
            SetRecordMap(pThreading->ChildIndex.cKeys, pbRead2, &Map2, &pbRead2);
        
            // CompareThreadIdBlocks
            nCompare = CompareThreadIdBlocks(pSchema, &pThreading->ChildIndex, &Map1, &Map2);

            // Reverse nCompare
            if (0 != nCompare)
                break;
        }
    }

    // Otherwise, if descending, swap
    else if (ISFLAGSET(pThreading->RootIndex.bFlags, INDEX_DESCENDING))
    {
        // Reverse
        nCompare = DESCENDING(nCompare);
    }

    // If nCompare is zero and Left Depth is less than right depth
    if (0 == nCompare && pHeader1->cDepth != pHeader2->cDepth)
    {
        // Less Than
        nCompare = (pHeader1->cDepth < pHeader2->cDepth) ? -1 : 1;
    }

    // Done
    return(nCompare);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\types.cpp ===
//--------------------------------------------------------------------------
// Types.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "database.h"
#include "types.h"
#include "qstrcmpi.h"
#include "strconst.h"

//--------------------------------------------------------------------------
// Defaults
//--------------------------------------------------------------------------
static const FILETIME g_ftDefault = {0};

//--------------------------------------------------------------------------
// DBCompareStringA
//--------------------------------------------------------------------------
inline INT DBCompareStringA(LPCINDEXKEY pKey, LPSTR pszValue1, LPSTR pszValue2)
{
    // Case Senstive Ansi Compare
    if (ISFLAGSET(pKey->bCompare, COMPARE_ASANSI) && !ISFLAGSET(pKey->bCompare, COMPARE_IGNORECASE))
    {
        // Loop through both strings
        while (*pszValue1 || *pszValue2)
        {
            // pszValue1 < pszValue2
            if (*pszValue1 < *pszValue2)
                return(-1);

            // pszValue1 > pszValue2
            if (*pszValue1 > *pszValue2)
                return(1);

            // Increment Pointers
            pszValue1++;
            pszValue2++;
        }

        // pszValue1 = psValue2
        return(0);
    }

    // Case In-Senstive Ansi Compare
    if (ISFLAGSET(pKey->bCompare, COMPARE_ASANSI) && ISFLAGSET(pKey->bCompare, COMPARE_IGNORECASE))
    {
        return(OEMstrcmpi(pszValue1, pszValue2));
    }

    // Case Sensitive International Compare
    if (!ISFLAGSET(pKey->bCompare, COMPARE_IGNORECASE)) 
    {
        // Strcmp
        return(lstrcmp(pszValue1, pszValue2));
    }

    // Finally, Case In-Sensitive International Compare
    return(lstrcmpi(pszValue1, pszValue2));
}

//--------------------------------------------------------------------------
// DBCompareStringW
//--------------------------------------------------------------------------
inline INT DBCompareStringW(LPCINDEXKEY pKey, LPWSTR pwszValue1, LPWSTR pwszValue2)
{
    // Case In-Senstive Ansi Compare
    if (ISFLAGSET(pKey->bCompare, COMPARE_IGNORECASE))
    {
        return(StrCmpIW(pwszValue1, pwszValue2));
    }

    // Strcmp
    return(StrCmpW(pwszValue1, pwszValue2));
}

//--------------------------------------------------------------------------
// DBTypeIsDefault Implementation
//--------------------------------------------------------------------------

// CDT_FILETIME
BOOL DBTypeIsDefault_FILETIME(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPFILETIME pftValue = (LPFILETIME)((LPBYTE)pBinding + pColumn->ofBinding);
    return (0 == pftValue->dwLowDateTime && 0 == pftValue->dwHighDateTime); 
}

// CDT_FIXSTRA
BOOL DBTypeIsDefault_FIXSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPSTR pszValue = (LPSTR)((LPBYTE)pBinding + pColumn->ofBinding);
    return(NULL == pszValue);
}

// CDT_VARSTRA
BOOL DBTypeIsDefault_VARSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPSTR pszValue = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(NULL == pszValue);
}

// CDT_BYTE
BOOL DBTypeIsDefault_BYTE(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    BYTE bValue = *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == bValue);
}

// CDT_DWORD
BOOL DBTypeIsDefault_DWORD(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == dwValue);
}

// CDT_WORD
BOOL DBTypeIsDefault_WORD(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    WORD wValue = *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == wValue);
}

// CDT_STREAM
BOOL DBTypeIsDefault_STREAM(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    FILEADDRESS faValue = *((FILEADDRESS *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == faValue);
}

// CDT_VARBLOB
BOOL DBTypeIsDefault_VARBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    return(0 == pBlob->cbSize);
}

// CDT_FIXBLOB
BOOL DBTypeIsDefault_FIXBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(FALSE); // We always store fixed length blobs
}

// CDT_FLAGS
BOOL DBTypeIsDefault_FLAGS(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == dwValue);
}

// CDT_UNIQUE
BOOL DBTypeIsDefault_UNIQUE(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(0 == dwValue);
}

// CDT_FIXSTRW
BOOL DBTypeIsDefault_FIXSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPWSTR pwszValue = (LPWSTR)((LPBYTE)pBinding + pColumn->ofBinding);
    return(NULL == pwszValue);
}

// CDT_VARSTRW
BOOL DBTypeIsDefault_VARSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPWSTR pwszValue = *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    return(NULL == pwszValue);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeIsDefault, PFNDBTYPEISDEFAULT);

//--------------------------------------------------------------------------
// DBTypeGetSize Methods
//--------------------------------------------------------------------------

// CDT_FILETIME
DWORD DBTypeGetSize_FILETIME(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(sizeof(FILETIME));
}

// CDT_FIXSTRA
DWORD DBTypeGetSize_FIXSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(pColumn->cbSize);
}

// CDT_VARSTRA
DWORD DBTypeGetSize_VARSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD cb=0; LPSTR pszValue;
    pszValue = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (pszValue) { while(*pszValue) { cb++; pszValue++; } }
    cb++;
    return(cb);
}

// CDT_BYTE
DWORD DBTypeGetSize_BYTE(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(0); // Stored in Column Tag
}

// CDT_DWORD
DWORD DBTypeGetSize_DWORD(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) return(0);
    else return(sizeof(DWORD));
}

// CDT_WORD
DWORD DBTypeGetSize_WORD(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(0); // Stored in Column Tag
}

// CDT_STREAM
DWORD DBTypeGetSize_STREAM(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) return(0);
    else return(sizeof(DWORD));
}

// CDT_VARBLOB
DWORD DBTypeGetSize_VARBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    return(pBlob->cbSize + sizeof(DWORD));
}

// CDT_FIXBLOB
DWORD DBTypeGetSize_FIXBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(pColumn->cbSize);
}

// CDT_FLAGS
DWORD DBTypeGetSize_FLAGS(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) return(0);
    else return(sizeof(DWORD));
}

// CDT_UNIQUE
DWORD DBTypeGetSize_UNIQUE(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) return(0);
    else return(sizeof(DWORD));
}

// CDT_FIXSTRW
DWORD DBTypeGetSize_FIXSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    return(pColumn->cbSize);
}

// CDT_VARSTRW
DWORD DBTypeGetSize_VARSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding) {
    DWORD cb=0; LPWSTR pwszValue;
    pwszValue = *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (pwszValue) { while(*pwszValue) { cb += 2; pwszValue++; } }
    cb += 2;
    return(cb);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeGetSize, PFNDBTYPEGETSIZE);

//--------------------------------------------------------------------------
// DBTypeCompareRecords Implementation
//--------------------------------------------------------------------------

// 0  means pValue1 is equal to pValue2
// -1 means pValue1 is less than pValue2
// +1 means pValue1 is greater than pValue2

// CDT_FILETIME
INT DBTypeCompareRecords_FILETIME(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPFILETIME pftValue1; LPFILETIME pftValue2;
    if (NULL == pTag1) pftValue1 = (LPFILETIME)&g_ftDefault;
    else pftValue1 = (LPFILETIME)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pftValue2 = (LPFILETIME)&g_ftDefault;
    else pftValue2 = (LPFILETIME)(pMap2->pbData + pTag2->Offset);
    return(CompareFileTime(pftValue1, pftValue2));
}

// CDT_FIXSTRA
INT DBTypeCompareRecords_FIXSTRA(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPSTR pszValue1; LPSTR pszValue2;
    if (NULL == pTag1) pszValue1 = (LPSTR)c_szEmpty;
    else pszValue1 = (LPSTR)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pszValue2 = (LPSTR)c_szEmpty;
    else pszValue2 = (LPSTR)(pMap2->pbData + pTag2->Offset);
    return(DBCompareStringA(pKey, pszValue1, pszValue2));
}

// CDT_VARSTRA
INT DBTypeCompareRecords_VARSTRA(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPSTR pszValue1; LPSTR pszValue2;
    if (NULL == pTag1) pszValue1 = (LPSTR)c_szEmpty;
    else pszValue1 = (LPSTR)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pszValue2 = (LPSTR)c_szEmpty;
    else pszValue2 = (LPSTR)(pMap2->pbData + pTag2->Offset);
    return(DBCompareStringA(pKey, pszValue1, pszValue2));
}

// CDT_BYTE
INT DBTypeCompareRecords_BYTE(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    BYTE bValue1; BYTE bValue2;
    if (NULL == pTag1) bValue1 = 0;
    else bValue1 = (BYTE)pTag1->Offset;
    if (NULL == pTag2) bValue2 = 0;
    else bValue2 = (BYTE)pTag2->Offset;
    return((INT)(bValue1 - bValue2));
}

// CDT_DWORD
INT DBTypeCompareRecords_DWORD(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD dwValue1; DWORD dwValue2;
    if (NULL == pTag1) dwValue1 = 0;
    else if (1 == pTag1->fData) dwValue1 = pTag1->Offset;
    else dwValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) dwValue2 = 0;
    else if (1 == pTag2->fData) dwValue2 = pTag2->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_WORD
INT DBTypeCompareRecords_WORD(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    WORD wValue1; WORD wValue2;
    if (NULL == pTag1) wValue1 = 0;
    else wValue1 = (WORD)pTag1->Offset;
    if (NULL == pTag2) wValue2 = 0;
    else wValue2 = (WORD)pTag2->Offset;
    return((INT)(wValue1 - wValue2));
}

// CDT_STREAM
INT DBTypeCompareRecords_STREAM(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD dwValue1; DWORD dwValue2;
    if (NULL == pTag1) dwValue1 = 0;
    else if (1 == pTag1->fData) dwValue1 = pTag1->Offset;
    else dwValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) dwValue2 = 0;
    else if (1 == pTag2->fData) dwValue2 = pTag2->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_VARBLOB
INT DBTypeCompareRecords_VARBLOB(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD cbValue1; DWORD cbValue2; LPBYTE pbValue1; LPBYTE pbValue2;
    if (NULL == pTag1) cbValue1 = 0;
    else cbValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) cbValue2 = 0;
    else cbValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    if (cbValue1 < cbValue2) return(-1);
    if (cbValue2 > cbValue1) return(1);
    if (0 == cbValue1 && 0 == cbValue2) return(1);
    pbValue1 = (LPBYTE)(pMap1->pbData + pTag1->Offset + sizeof(DWORD));
    pbValue2 = (LPBYTE)(pMap2->pbData + pTag2->Offset + sizeof(DWORD));
    return(memcmp(pbValue1, pbValue2, cbValue1));
}

// CDT_FIXBLOB
INT DBTypeCompareRecords_FIXBLOB(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    Assert(pTag1 && pTag2);
    LPBYTE pbValue1 = (LPBYTE)(pMap1->pbData + pTag1->Offset);
    LPBYTE pbValue2 = (LPBYTE)(pMap2->pbData + pTag2->Offset);
    return(memcmp(pbValue1, pbValue2, pColumn->cbSize));
}

// CDT_FLAGS
INT DBTypeCompareRecords_FLAGS(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD dwValue1; DWORD dwValue2;
    if (NULL == pTag1) dwValue1 = 0;
    else if (1 == pTag1->fData) dwValue1 = pTag1->Offset;
    else dwValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) dwValue2 = 0;
    else if (1 == pTag2->fData) dwValue2 = pTag2->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    return (INT)((dwValue1 & pKey->dwBits) - (dwValue2 & pKey->dwBits));
}

// CDT_UNIQUE
INT DBTypeCompareRecords_UNIQUE(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    DWORD dwValue1; DWORD dwValue2;
    if (NULL == pTag1) dwValue1 = 0;
    else if (1 == pTag1->fData) dwValue1 = pTag1->Offset;
    else dwValue1 = *((UNALIGNED DWORD *)(pMap1->pbData + pTag1->Offset));
    if (NULL == pTag2) dwValue2 = 0;
    else if (1 == pTag2->fData) dwValue2 = pTag2->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap2->pbData + pTag2->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_FIXSTRW
INT DBTypeCompareRecords_FIXSTRW(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPWSTR pwszValue1; LPWSTR pwszValue2;
    if (NULL == pTag1) pwszValue1 = (LPWSTR)c_wszEmpty;
    else pwszValue1 = (LPWSTR)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pwszValue2 = (LPWSTR)c_wszEmpty;
    else pwszValue2 = (LPWSTR)(pMap2->pbData + pTag2->Offset);
    return(DBCompareStringW(pKey, pwszValue1, pwszValue2));
}

// CDT_VARSTRW
INT DBTypeCompareRecords_VARSTRW(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPCOLUMNTAG pTag1, LPCOLUMNTAG pTag2, LPRECORDMAP pMap1, 
    LPRECORDMAP pMap2) {
    LPWSTR pwszValue1; LPWSTR pwszValue2;
    if (NULL == pTag1) pwszValue1 = (LPWSTR)c_wszEmpty;
    else pwszValue1 = (LPWSTR)(pMap1->pbData + pTag1->Offset);
    if (NULL == pTag2) pwszValue2 = (LPWSTR)c_wszEmpty;
    else pwszValue2 = (LPWSTR)(pMap2->pbData + pTag2->Offset);
    return(DBCompareStringW(pKey, pwszValue1, pwszValue2));
}

// The Function Map
DEFINE_FUNCTION_MAP(DBTypeCompareRecords, PFNDBTYPECOMPARERECORDS);

//--------------------------------------------------------------------------
// DBTypeCompareBinding Implementation
//--------------------------------------------------------------------------

// 0  means pBinding is equal to pValue
// -1 means pBinding is less than pValue
// +1 means pBinding is greater than pValue

// CDT_FILETIME
INT DBTypeCompareBinding_FILETIME(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPFILETIME pftValue1; LPFILETIME pftValue2;
    pftValue1 = (LPFILETIME)((LPBYTE)pBinding + pColumn->ofBinding);
    if (NULL == pTag) pftValue2 = (LPFILETIME)&g_ftDefault;
    else pftValue2 = (LPFILETIME)(pMap->pbData + pTag->Offset);
    return(CompareFileTime(pftValue1, pftValue2));
}

// CDT_FIXSTRA
INT DBTypeCompareBinding_FIXSTRA(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPSTR pszValue1; LPSTR pszValue2;
    pszValue1 = (LPSTR)((LPBYTE)pBinding + pColumn->ofBinding);
    if (NULL == pTag) pszValue2 = (LPSTR)c_szEmpty;
    else pszValue2 = (LPSTR)(pMap->pbData + pTag->Offset);
    return(DBCompareStringA(pKey, pszValue1, pszValue2));
}

// CDT_VARSTRA
INT DBTypeCompareBinding_VARSTRA(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPSTR pszValue1; LPSTR pszValue2;
    pszValue1 = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pszValue1) pszValue1 = (LPSTR)c_szEmpty;
    if (NULL == pTag) pszValue2 = (LPSTR)c_szEmpty;
    else pszValue2 = (LPSTR)(pMap->pbData + pTag->Offset);
    return(DBCompareStringA(pKey, pszValue1, pszValue2));
}

// CDT_BYTE
INT DBTypeCompareBinding_BYTE(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    BYTE bValue1; BYTE bValue2;
    bValue1 = *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) bValue2 = 0;
    else bValue2 = (BYTE)(pTag->Offset);
    return((INT)(bValue1 - bValue2));
}

// CDT_DWORD
INT DBTypeCompareBinding_DWORD(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    DWORD dwValue1; DWORD dwValue2;
    dwValue1 = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) dwValue2 = 0;
    else if (1 == pTag->fData) dwValue2 = pTag->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_WORD
INT DBTypeCompareBinding_WORD(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    WORD wValue1; WORD wValue2;
    wValue1 = *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) wValue2 = 0;
    else wValue2 = (WORD)(pTag->Offset);
    return((INT)(wValue1 - wValue2));
}

// CDT_STREAM
INT DBTypeCompareBinding_STREAM(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    DWORD dwValue1; DWORD dwValue2;
    dwValue1 = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) dwValue2 = 0;
    else if (1 == pTag->fData) dwValue2 = pTag->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_VARBLOB
INT DBTypeCompareBinding_VARBLOB(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPBLOB pBlob; DWORD cbValue1; DWORD cbValue2; LPBYTE pbValue1; LPBYTE pbValue2;
    pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    cbValue1 = pBlob->cbSize;
    if (NULL == pTag) cbValue2 = 0;
    else cbValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    if (cbValue1 < cbValue2) return(-1);
    if (cbValue2 > cbValue1) return(1);
    if (0 == cbValue1 && 0 == cbValue2) return(1);
    pbValue1 = pBlob->pBlobData;
    pbValue2 = (LPBYTE)(pMap->pbData + pTag->Offset + sizeof(DWORD));
    return(memcmp(pbValue1, pbValue2, cbValue1));
}

// CDT_FIXBLOB
INT DBTypeCompareBinding_FIXBLOB(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    Assert(pTag);
    LPBYTE pbValue1; LPBYTE pbValue2;
    pbValue1 = (LPBYTE)((LPBYTE)pBinding + pColumn->ofBinding);
    pbValue2 = (LPBYTE)(pMap->pbData + pTag->Offset);
    return(memcmp(pbValue1, pbValue2, pColumn->cbSize));
}

// CDT_FLAGS
INT DBTypeCompareBinding_FLAGS(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    DWORD dwValue1; DWORD dwValue2;
    dwValue1 = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) dwValue2 = 0;
    else if (1 == pTag->fData) dwValue2 = pTag->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    return((INT)((dwValue1 & pKey->dwBits) - (dwValue2 & pKey->dwBits)));
}

// CDT_UNIQUE
INT DBTypeCompareBinding_UNIQUE(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    DWORD dwValue1; DWORD dwValue2;
    dwValue1 = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pTag) dwValue2 = 0;
    else if (1 == pTag->fData) dwValue2 = pTag->Offset;
    else dwValue2 = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    return((INT)(dwValue1 - dwValue2));
}

// CDT_FIXSTRW
INT DBTypeCompareBinding_FIXSTRW(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPWSTR pwszValue1; LPWSTR pwszValue2;
    pwszValue1 = (LPWSTR)((LPBYTE)pBinding + pColumn->ofBinding);
    if (NULL == pTag) pwszValue2 = (LPWSTR)c_wszEmpty;
    else pwszValue2 = (LPWSTR)(pMap->pbData + pTag->Offset);
    return(DBCompareStringW(pKey, pwszValue1, pwszValue2));
}

// CDT_VARSTRW
INT DBTypeCompareBinding_VARSTRW(LPCTABLECOLUMN pColumn, LPCINDEXKEY pKey, 
    LPVOID pBinding, LPCOLUMNTAG pTag, LPRECORDMAP pMap) {
    LPWSTR pwszValue1; LPWSTR pwszValue2;
    pwszValue1 = *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (NULL == pwszValue1) pwszValue1 = (LPWSTR)c_wszEmpty;
    if (NULL == pTag) pwszValue2 = (LPWSTR)c_wszEmpty;
    else pwszValue2 = (LPWSTR)(pMap->pbData + pTag->Offset);
    return(DBCompareStringW(pKey, pwszValue1, pwszValue2));
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeCompareBinding, PFNDBTYPECOMPAREBINDING);

//--------------------------------------------------------------------------
// DBTypeWriteValue Implementation
//--------------------------------------------------------------------------

// CDT_FILETIME
DWORD DBTypeWriteValue_FILETIME(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    CopyMemory(pbDest, (LPBYTE)pBinding + pColumn->ofBinding, sizeof(FILETIME));
    return(sizeof(FILETIME));
}

// CDT_FIXSTRA
DWORD DBTypeWriteValue_FIXSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    CopyMemory(pbDest, (LPBYTE)pBinding + pColumn->ofBinding, pColumn->cbSize);
    return(pColumn->cbSize);
}

// CDT_VARSTRA
DWORD DBTypeWriteValue_VARSTRA(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    LPSTR pszT; DWORD cb=0;
    pszT = *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (pszT) { while(*pszT) { *(pbDest + cb) = *pszT; cb++; pszT++; } }
    *(pbDest + cb) = '\0';
    cb++;
    return(cb);
}

// CDT_BYTE
DWORD DBTypeWriteValue_BYTE(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    pTag->Offset = *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding));
    pTag->fData = 1;
    return(0);
}

// CDT_DWORD
DWORD DBTypeWriteValue_DWORD(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) { pTag->fData = 1; pTag->Offset = dwValue; return(0); }
    else { *((UNALIGNED DWORD *)pbDest) = dwValue; return(sizeof(DWORD)); }
}

// CDT_WORD
DWORD DBTypeWriteValue_WORD(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    pTag->Offset = *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    pTag->fData = 1;
    return(0);
}

// CDT_STREAM
DWORD DBTypeWriteValue_STREAM(LPCTABLECOLUMN pColumn, LPVOID pBinding,
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) { pTag->fData = 1; pTag->Offset = dwValue; return(0); }
    else { *((UNALIGNED DWORD *)pbDest) = dwValue; return(sizeof(DWORD)); }
}

// CDT_VARBLOB
DWORD DBTypeWriteValue_VARBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    CopyMemory(pbDest, &pBlob->cbSize, sizeof(DWORD));
    if (pBlob->cbSize > 0) CopyMemory(pbDest + sizeof(DWORD), pBlob->pBlobData, pBlob->cbSize);
    return(pBlob->cbSize + sizeof(DWORD));
}

// CDT_FIXBLOB
DWORD DBTypeWriteValue_FIXBLOB(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    CopyMemory(pbDest, (LPBYTE)pBinding + pColumn->ofBinding, pColumn->cbSize);
    return(pColumn->cbSize);
}

// CDT_FLAGS
DWORD DBTypeWriteValue_FLAGS(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) { pTag->fData = 1; pTag->Offset = dwValue; return(0); }
    else { *((UNALIGNED DWORD *)pbDest) = dwValue; return(sizeof(DWORD)); }
}

// CDT_UNIQUE
DWORD DBTypeWriteValue_UNIQUE(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    DWORD dwValue = *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding));
    if (0 == (TAG_DATA_MASK & dwValue)) { pTag->fData = 1; pTag->Offset = dwValue; return(0); }
    else { *((UNALIGNED DWORD *)pbDest) = dwValue; return(sizeof(DWORD)); }
}

// CDT_FIXSTRW
DWORD DBTypeWriteValue_FIXSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    CopyMemory(pbDest, (LPBYTE)pBinding + pColumn->ofBinding, pColumn->cbSize);
    return(pColumn->cbSize);
}

// CDT_VARSTRW
DWORD DBTypeWriteValue_VARSTRW(LPCTABLECOLUMN pColumn, LPVOID pBinding, 
    LPCOLUMNTAG pTag, LPBYTE pbDest) {
    LPWSTR pwszT1; LPWSTR pwszT2; DWORD cb=0;
    pwszT1 = *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding));
    pwszT2 = (LPWSTR)pbDest;
    if (pwszT1) { while(*pwszT1) { *pwszT2 = *pwszT1; pwszT1++; pwszT2++; cb += 2; } }
    *pwszT2 = L'\0';
    cb += 2;
    return(cb);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeWriteValue, PFNDBTYPEWRITEVALUE);

//--------------------------------------------------------------------------
// DBTypeReadValue Implementation
//--------------------------------------------------------------------------

// CDT_FILETIME
void DBTypeReadValue_FILETIME(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + sizeof(FILETIME) > pMap->cbData) return;
    CopyMemory((LPBYTE)pBinding + pColumn->ofBinding, (LPBYTE)(pMap->pbData + pTag->Offset), sizeof(FILETIME));
}

// CDT_FIXSTRA
void DBTypeReadValue_FIXSTRA(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + pColumn->cbSize > pMap->cbData) return;
    CopyMemory((LPBYTE)pBinding + pColumn->ofBinding, (LPBYTE)(pMap->pbData + pTag->Offset), pColumn->cbSize);
}

// CDT_VARSTRA
void DBTypeReadValue_VARSTRA(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset > pMap->cbData) return;
    *((LPSTR *)((LPBYTE)pBinding + pColumn->ofBinding)) = (LPSTR)(pMap->pbData + pTag->Offset);
}

// CDT_BYTE
void DBTypeReadValue_BYTE(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (0 == pTag->fData) return;
    *((BYTE *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset;
}

// CDT_DWORD
void DBTypeReadValue_DWORD(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (0 == pTag->fData && pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    if (1 == pTag->fData) *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset;
    else *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
}

// CDT_WORD
void DBTypeReadValue_WORD(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (0 == pTag->fData) return;
    *((WORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset;
}

// CDT_STREAM
void DBTypeReadValue_STREAM(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (1 == pTag->fData) { *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset; return; }
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
}

// CDT_VARBLOB
void DBTypeReadValue_VARBLOB(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pBinding + pColumn->ofBinding);
    DWORD cbSize = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    if (pTag->Offset + sizeof(DWORD) + cbSize > pMap->cbData) return;
    pBlob->cbSize = cbSize;
    pBlob->pBlobData = (pBlob->cbSize > 0) ? ((pMap->pbData + pTag->Offset) + sizeof(DWORD)) : NULL;
}

// CDT_FIXBLOB
void DBTypeReadValue_FIXBLOB(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + pColumn->cbSize > pMap->cbData) return;
    CopyMemory((LPBYTE)pBinding + pColumn->ofBinding, (pMap->pbData + pTag->Offset), pColumn->cbSize);
}

// CDT_FLAGS
void DBTypeReadValue_FLAGS(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (1 == pTag->fData) { *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset; return; }
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
}

// CDT_UNIQUE
void DBTypeReadValue_UNIQUE(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (1 == pTag->fData) { *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = pTag->Offset; return; }
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return;
    *((UNALIGNED DWORD *)((LPBYTE)pBinding + pColumn->ofBinding)) = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
}

// CDT_FIXSTRW
void DBTypeReadValue_FIXSTRW(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset + pColumn->cbSize > pMap->cbData) return;
    CopyMemory((LPBYTE)pBinding + pColumn->ofBinding, (LPBYTE)(pMap->pbData + pTag->Offset), pColumn->cbSize);
}

// CDT_VARSTRW
void DBTypeReadValue_VARSTRW(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap, LPVOID pBinding) {
    if (pTag->fData || pTag->Offset > pMap->cbData) return;
    *((LPWSTR *)((LPBYTE)pBinding + pColumn->ofBinding)) = (LPWSTR)(pMap->pbData + pTag->Offset);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeReadValue, PFNDBTYPEREADVALUE);

//--------------------------------------------------------------------------
// DBTypeValidate Implementation
//--------------------------------------------------------------------------

HRESULT DBValidateStringA(LPCOLUMNTAG pTag, LPRECORDMAP pMap, DWORD cbMax)
{
    LPSTR pszT = (LPSTR)(pMap->pbData + pTag->Offset);
    DWORD cbT=0;
    while (*pszT && cbT < cbMax) { pszT++; cbT++; }
    return('\0' == *pszT ? S_OK : S_FALSE);
}

HRESULT DBValidateStringW(LPCOLUMNTAG pTag, LPRECORDMAP pMap, DWORD cbMax)
{
    LPWSTR pwszT = (LPWSTR)(pMap->pbData + pTag->Offset);
    DWORD cbT=0;
    while (*pwszT && cbT < cbMax) { pwszT++; cbT += 2; }
    return(L'\0' == *pwszT ? S_OK : S_FALSE);
}

// CDT_FILETIME
HRESULT DBTypeValidate_FILETIME(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + sizeof(FILETIME) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_FIXSTRA
HRESULT DBTypeValidate_FIXSTRA(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + pColumn->cbSize > pMap->cbData) return(S_FALSE);
    if (S_FALSE == DBValidateStringA(pTag, pMap, pColumn->cbSize)) return(S_FALSE);
    return(S_OK);
}

// CDT_VARSTRA
HRESULT DBTypeValidate_VARSTRA(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset > pMap->cbData) return(S_FALSE);
    if (S_FALSE == DBValidateStringA(pTag, pMap, pMap->cbData)) return(S_FALSE);
    return(S_OK);
}

// CDT_BYTE
HRESULT DBTypeValidate_BYTE(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (0 == pTag->fData) return(S_FALSE);
    return(S_OK);
}

// CDT_DWORD
HRESULT DBTypeValidate_DWORD(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (1 == pTag->fData) return(S_OK);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_WORD
HRESULT DBTypeValidate_WORD(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (0 == pTag->fData) return(S_FALSE);
    return(S_OK);
}

// CDT_STREAM
HRESULT DBTypeValidate_STREAM(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (1 == pTag->fData) return(S_OK);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_VARBLOB
HRESULT DBTypeValidate_VARBLOB(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    BLOB Blob;
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    Blob.cbSize = *((UNALIGNED DWORD *)(pMap->pbData + pTag->Offset));
    if (pTag->Offset + sizeof(DWORD) + Blob.cbSize > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_FIXBLOB
HRESULT DBTypeValidate_FIXBLOB(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + pColumn->cbSize > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_FLAGS
HRESULT DBTypeValidate_FLAGS(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (1 == pTag->fData) return(S_OK);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_UNIQUE
HRESULT DBTypeValidate_UNIQUE(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (1 == pTag->fData) return(S_OK);
    if (pTag->Offset + sizeof(DWORD) > pMap->cbData) return(S_FALSE);
    return(S_OK);
}

// CDT_FIXSTRW
HRESULT DBTypeValidate_FIXSTRW(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset + pColumn->cbSize > pMap->cbData) return(S_FALSE);
    if (S_FALSE == DBValidateStringW(pTag, pMap, pColumn->cbSize)) return(S_FALSE);
    return(S_OK);
}

// CDT_VARSTRW
HRESULT DBTypeValidate_VARSTRW(LPCTABLECOLUMN pColumn, LPCOLUMNTAG pTag, 
    LPRECORDMAP pMap) {
    if (pTag->fData) return(S_FALSE);
    if (pTag->Offset > pMap->cbData) return(S_FALSE);
    if (S_FALSE == DBValidateStringW(pTag, pMap, pMap->cbData)) return(S_FALSE);
    return(S_OK);
}

// The function map
DEFINE_FUNCTION_MAP(DBTypeValidate, PFNDBTYPEVALIDATE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\inc\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\utility.h ===
//--------------------------------------------------------------------------
// Utility.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT CreateSystemHandleName(
        /* in */        LPCWSTR                     pszBase, 
        /* in */        LPCWSTR                     pszSpecific, 
        /* out */       LPWSTR                     *ppszName);

HRESULT DBGetFullPath(
        /* in */        LPCWSTR                     pszFilePath,
        /* out */       LPWSTR                     *ppszFullPath,
        /* out */       LPDWORD                     pcchFilePath);

HRESULT DBGetFileSize(
        /* in */        HANDLE                      hFile,
        /* out */       LPDWORD                     pcbSize);

HRESULT RegisterWindowClass(
        /* in */        LPCSTR                      pszClass,
        /* in */        WNDPROC                     pfnWndProc);

HRESULT CreateNotifyWindow(
        /* in */        LPCSTR                      pszClass,
        /* in */        LPVOID                      pvParam,
        /* in */        HWND                       *phwndNotify);

HRESULT DBOpenFileMapping(
        /* in */        HANDLE                      hFile,
        /* in */        LPCWSTR                     pszName,
        /* in */        DWORD                       cbSize,
        /* out */       BOOL                       *pfNew,
        /* out */       HANDLE                     *phMemoryMap,
        /* out */       LPVOID                     *ppvView);

HRESULT DBMapViewOfFile(
        /* in */        HANDLE                      hMapping, 
        /* in */        DWORD                       cbFile,
        /* in,out */    LPFILEADDRESS               pfaView, 
        /* in,out */    LPDWORD                     pcbView,
        /* out */       LPVOID                     *ppvView);

HRESULT DBOpenFile(
        /* in */        LPCWSTR                     pszFile,
        /* in */        BOOL                        fNoCreate,
        /* in */        BOOL                        fExclusive,
        /* out */       BOOL                       *pfNew,
        /* ou */        HANDLE                     *phFile);

HRESULT GetAvailableDiskSpace(
        /* in */        LPCWSTR                     pszFilePath,
        /* out */       DWORDLONG                   *pdwlFree);

HRESULT CompareTableIndexes(
        /* in */        LPCTABLEINDEX               pIndex1,
        /* in */        LPCTABLEINDEX               pIndex2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\utility.cpp ===
//--------------------------------------------------------------------------
// Utility.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "utility.h"
#include "database.h"
#include "wrapwide.h"

//--------------------------------------------------------------------------
// CreateSystemHandleName
//--------------------------------------------------------------------------
HRESULT CreateSystemHandleName(LPCWSTR pwszBase, LPCWSTR pwszSpecific, 
    LPWSTR *ppwszName)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cchName;
    LPWSTR      pszT;

    // Trace
    TraceCall("CreateSystemHandleName");

    // Invalid Args
    Assert(pwszBase && pwszSpecific && ppwszName);

    // Init
    *ppwszName = NULL;

    // Compute Length
    cchName = lstrlenW(pwszBase) + lstrlenW(pwszSpecific) + 15;

    // Allocate
    IF_NULLEXIT(*ppwszName = AllocateStringW(cchName));

    // Setup Arguments
    wsprintfWrapW(*ppwszName, cchName, L"%s%s", pwszBase, pwszSpecific);

    // Remove backslashes from this string
    for (pszT = (*ppwszName); *pszT != L'\0'; pszT++)
    {
        // Replace Back Slashes
        if (*pszT == L'\\')
        {
            // With _
            *pszT = L'_';
        }
    }

    // Lower Case
    CharLowerBuffWrapW(*ppwszName, lstrlenW(*ppwszName));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DBGetFullPath
// --------------------------------------------------------------------------------
HRESULT DBGetFullPath(LPCWSTR pszFilePath, LPWSTR *ppszFullPath, LPDWORD pcchFilePath)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cchAllocate;
    LPWSTR          pszFilePart;

    // Trace
    TraceCall("DBGetFullPath");

    // Set cchFullPath
    cchAllocate = max(lstrlenW(pszFilePath), MAX_PATH + MAX_PATH);

    // Allocate ppszFullPath
    IF_NULLEXIT(*ppszFullPath = AllocateStringW(cchAllocate));

    // GetFullPathName
    *pcchFilePath = GetFullPathNameWrapW(pszFilePath, cchAllocate, (*ppszFullPath), &pszFilePart);

    // Failure
    if (*pcchFilePath && *pcchFilePath >= cchAllocate)
    {
        // Re-allocate
        IF_NULLEXIT(*ppszFullPath = AllocateStringW(*pcchFilePath));

        // Expand the Path
        *pcchFilePath = GetFullPathNameWrapW(pszFilePath, *pcchFilePath, (*ppszFullPath), &pszFilePart);
    }

    // cch is 0
    if (0 == *pcchFilePath)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Validate
    Assert((*ppszFullPath)[(*pcchFilePath)] == L'\0');

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CompareTableIndexes
// --------------------------------------------------------------------------------
HRESULT CompareTableIndexes(LPCTABLEINDEX pIndex1, LPCTABLEINDEX pIndex2)
{
    // Locals
    DWORD i;

    // Trace
    TraceCall("CompareTableIndexes");

    // Different Number of Keys
    if (pIndex1->cKeys != pIndex2->cKeys)
        return(S_FALSE);

    // Loop through the keys
    for (i=0; i<pIndex1->cKeys; i++)
    {
        // Different Column
        if (pIndex1->rgKey[i].iColumn != pIndex2->rgKey[i].iColumn)
            return(S_FALSE);

        // Different Compare Flags
        if (pIndex1->rgKey[i].bCompare != pIndex2->rgKey[i].bCompare)
            return(S_FALSE);

        // Different Compare Bits
        if (pIndex1->rgKey[i].dwBits != pIndex2->rgKey[i].dwBits)
            return(S_FALSE);
    }

    // Equal
    return(S_OK);
}

//--------------------------------------------------------------------------
// DBOpenFile
//--------------------------------------------------------------------------
HRESULT DBOpenFile(LPCWSTR pszFile, BOOL fNoCreate, BOOL fExclusive, 
    BOOL *pfNew, HANDLE *phFile)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hFile;
    DWORD       dwShare;
    DWORD       dwCreate;

    // Trace
    TraceCall("DBOpenFile");

    // Invalid Args
    Assert(pszFile && phFile);
    
    // Initialize
    *phFile = NULL;
    *pfNew = FALSE;

    // Set Share Falgs
    dwShare = fExclusive ? 0 : FILE_SHARE_READ | FILE_SHARE_WRITE;

    // If not fNoCreate, then OPEN_ALWAYS
    dwCreate = fNoCreate ? OPEN_EXISTING : OPEN_ALWAYS;

    // Do the CreateFile
    hFile = CreateFileWrapW(pszFile, GENERIC_READ | GENERIC_WRITE, dwShare, NULL, dwCreate, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);

    // Failure
    if (INVALID_HANDLE_VALUE == hFile)
    {
        // Return a Good Error
        if (ERROR_SHARING_VIOLATION == GetLastError())
        {
            // Set hr
            hr = TraceResult(DB_E_ACCESSDENIED);
        }

        // Otherwise, generic Error
        else
        {
            // Create File
            hr = TraceResult(DB_E_CREATEFILE);
        }

        // Done
        goto exit;
    }

    // If Not no create
    if (FALSE == fNoCreate)
    {
        // Return pfNew ?
        *pfNew = (ERROR_ALREADY_EXISTS == GetLastError()) ? FALSE : TRUE;
    }

    // Return the hFile
    *phFile = hFile;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// DBMapViewOfFile
//--------------------------------------------------------------------------
HRESULT DBMapViewOfFile(HANDLE hMapping, DWORD cbFile, LPFILEADDRESS pfaView, 
    LPDWORD pcbView, LPVOID *ppvView)
{
    // Locals
    FILEADDRESS     faBase = (*pfaView);
    DWORD           cbSize = (*pcbView);

    // cbBoundary
    DWORD cbBoundary = (faBase % g_SystemInfo.dwAllocationGranularity);

    // Decrement faBase
    faBase -= cbBoundary;

    // Increment cbSize
    cbSize += cbBoundary;

    // Fixup cbSize
    if (faBase + cbSize > cbFile)
    {
        // Map to the end of the file
        cbSize = (cbFile - faBase);
    }

    // Map a view of the entire file
    *ppvView = MapViewOfFile(hMapping, FILE_MAP_ALL_ACCESS, 0, faBase, cbSize);

    // Failure
    if (NULL == *ppvView)
        return(TraceResult(DB_E_MAPVIEWOFFILE));

    // Return Actual Sizes
    *pfaView = faBase;
    *pcbView = cbSize;

    // Success
    return(S_OK);
}

//--------------------------------------------------------------------------
// DBOpenFileMapping
//--------------------------------------------------------------------------
HRESULT DBOpenFileMapping(HANDLE hFile, LPCWSTR pwszName, DWORD cbSize, BOOL *pfNew, 
    HANDLE *phMemoryMap, LPVOID *ppvView)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hMemoryMap=NULL;
    LPVOID      pvView=NULL;

    // Tracing
    TraceCall("OpenFileMapping");

    // Invalid Arg
    Assert(hFile != NULL && phMemoryMap && pfNew);

    // Initialize
    *phMemoryMap = NULL;
    *pfNew = FALSE;
    if (ppvView)
        *ppvView = NULL;

    // Open or create the file mapping
    hMemoryMap = OpenFileMappingWrapW(FILE_MAP_ALL_ACCESS, FALSE, pwszName);

    // If that failed, then lets create the file mapping
    if (NULL == hMemoryMap)
    {
        // Create the file mapping
        hMemoryMap = CreateFileMappingWrapW(hFile, NULL, PAGE_READWRITE, 0, cbSize, pwszName);

        // Failure
        if (NULL == hMemoryMap)
        {
            hr = TraceResult(DB_E_CREATEFILEMAPPING);
            goto exit;
        }

        // Set a State
        *pfNew = TRUE;
    }

    // Map the View
    if (ppvView)
    {
        // Map a view of the entire file
        pvView = MapViewOfFile(hMemoryMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);

        // Failure
        if (NULL == pvView)
        {
            hr = TraceResult(DB_E_MAPVIEWOFFILE);
            goto exit;
        }

        // Return It
        *ppvView = pvView;

        // Don't Free It
        pvView = NULL;
    }

    // Set Return Values
    *phMemoryMap = hMemoryMap;

    // Don't Free
    hMemoryMap = NULL;

exit:
    // Cleanup
    if (pvView)
        UnmapViewOfFile(pvView);
    if (hMemoryMap)
        CloseHandle(hMemoryMap);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// RegisterWindowClass
//--------------------------------------------------------------------------
HRESULT RegisterWindowClass(LPCSTR pszClass, WNDPROC pfnWndProc)
{
    // Locals
    HRESULT         hr=S_OK;
    WNDCLASS        WindowClass;

    // Tracing
    TraceCall("RegisterWindowClass");

    // Register the Window Class
    if (0 != GetClassInfo(g_hInst, pszClass, &WindowClass))
        goto exit;

    // Zero the object
    ZeroMemory(&WindowClass, sizeof(WNDCLASS));

    // Initialize the Window Class
    WindowClass.lpfnWndProc = pfnWndProc;
    WindowClass.hInstance = g_hInst;
    WindowClass.lpszClassName = pszClass;

    // Register the Class
    if (0 == RegisterClass(&WindowClass))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CreateNotifyWindow
//--------------------------------------------------------------------------
HRESULT CreateNotifyWindow(LPCSTR pszClass, LPVOID pvParam, HWND *phwndNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    HWND            hwnd;

    // Tracing
    TraceCall("CreateNotifyWindow");

    // Invalid ARg
    Assert(pszClass && phwndNotify);

    // Initialize
    *phwndNotify = NULL;

    // Create the Window
    hwnd = CreateWindowEx(WS_EX_TOPMOST, pszClass, pszClass, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInst, (LPVOID)pvParam);

    // Failure
    if (NULL == hwnd)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Set Return
    *phwndNotify = hwnd;

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// DBGetFileSize
//--------------------------------------------------------------------------
HRESULT DBGetFileSize(HANDLE hFile, LPDWORD pcbSize)
{
    // Trace
    TraceCall("GetFileSize");

    // Invalid Arg
    Assert(pcbSize);

    // Get the Size
    *pcbSize = ::GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == *pcbSize)
        return TraceResult(DB_E_GETFILESIZE);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// GetAvailableDiskSpace
// --------------------------------------------------------------------------------
HRESULT GetAvailableDiskSpace(LPCWSTR pszFilePath, DWORDLONG *pdwlFree)
{
    // Locals
    HRESULT     hr=S_OK;
    WCHAR       wszDrive[5];
    DWORD       dwSectorsPerCluster;
    DWORD       dwBytesPerSector;
    DWORD       dwNumberOfFreeClusters;
    DWORD       dwTotalNumberOfClusters;

    // Trace
    TraceCall("GetAvailableDiskSpace");

    // Invalid Args
    Assert(pszFilePath && pszFilePath[1] == L':' && pdwlFree);

    // Split the path
    wszDrive[0] = *pszFilePath;
    wszDrive[1] = L':';
    wszDrive[2] = L'\\';
    wszDrive[3] = L'\0';
    
    // Get free disk space - if it fails, lets pray we have enought disk space
    if (!GetDiskFreeSpaceWrapW(wszDrive, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
	    hr = TraceResult(E_FAIL);
	    goto exit;
    }

    // Return Amount of Free Disk Space
    *pdwlFree = (dwNumberOfFreeClusters * (dwSectorsPerCluster * dwBytesPerSector));

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\types.h ===
//--------------------------------------------------------------------------
// Types.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// DEFINE_FUNCTION_MAP
//--------------------------------------------------------------------------
#define DEFINE_FUNCTION_MAP(_name, _pfnType) \
    const _pfnType g_rgpfn##_name[CDT_LASTTYPE] = { \
        (_pfnType)_name##_FILETIME,     \
        (_pfnType)_name##_FIXSTRA,      \
        (_pfnType)_name##_VARSTRA,      \
        (_pfnType)_name##_BYTE,         \
        (_pfnType)_name##_DWORD,        \
        (_pfnType)_name##_WORD,         \
        (_pfnType)_name##_STREAM,       \
        (_pfnType)_name##_VARBLOB,      \
        (_pfnType)_name##_FIXBLOB,      \
        (_pfnType)_name##_FLAGS,        \
        (_pfnType)_name##_UNIQUE,       \
        (_pfnType)_name##_FIXSTRW,      \
        (_pfnType)_name##_VARSTRW       \
    };

//--------------------------------------------------------------------------
// Function Types
//--------------------------------------------------------------------------
typedef BOOL (APIENTRY *PFNDBTYPEISDEFAULT)(
    LPCTABLECOLUMN      pColumn, 
    LPVOID              pBinding);

typedef INT (APIENTRY *PFNDBTYPECOMPARERECORDS)(
    LPCTABLECOLUMN      pColumn, 
    LPCINDEXKEY         pKey, 
    LPCOLUMNTAG         pTag1, 
    LPCOLUMNTAG         pTag2, 
    LPRECORDMAP         pMap1, 
    LPRECORDMAP         pMap2);

typedef INT (APIENTRY *PFNDBTYPECOMPAREBINDING)(
    LPCTABLECOLUMN      pColumn, 
    LPCINDEXKEY         pKey, 
    LPVOID              pBinding, 
    LPCOLUMNTAG         pTag, 
    LPRECORDMAP         pMap);

typedef DWORD (APIENTRY *PFNDBTYPEGETSIZE)(
    LPCTABLECOLUMN      pColumn, 
    LPVOID              pBinding);

typedef DWORD (APIENTRY *PFNDBTYPEWRITEVALUE)(
    LPCTABLECOLUMN      pColumn, 
    LPVOID              pBinding, 
    LPCOLUMNTAG         pTag, 
    LPBYTE              pbDest);

typedef void (APIENTRY *PFNDBTYPEREADVALUE)(
    LPCTABLECOLUMN      pColumn, 
    LPCOLUMNTAG         pTag, 
    LPRECORDMAP         pMap, 
    LPVOID              pBinding);

typedef HRESULT (APIENTRY *PFNDBTYPEVALIDATE)(
    LPCTABLECOLUMN      pColumn, 
    LPCOLUMNTAG         pTag, 
    LPRECORDMAP         pMap);

//--------------------------------------------------------------------------
// Global Function Pointer Tables
//--------------------------------------------------------------------------
extern const PFNDBTYPEISDEFAULT         g_rgpfnDBTypeIsDefault[CDT_LASTTYPE];
extern const PFNDBTYPEGETSIZE           g_rgpfnDBTypeGetSize[CDT_LASTTYPE];
extern const PFNDBTYPECOMPARERECORDS    g_rgpfnDBTypeCompareRecords[CDT_LASTTYPE];
extern const PFNDBTYPECOMPAREBINDING    g_rgpfnDBTypeCompareBinding[CDT_LASTTYPE];
extern const PFNDBTYPEWRITEVALUE        g_rgpfnDBTypeWriteValue[CDT_LASTTYPE];
extern const PFNDBTYPEREADVALUE         g_rgpfnDBTypeReadValue[CDT_LASTTYPE];
extern const PFNDBTYPEVALIDATE          g_rgpfnDBTypeValidate[CDT_LASTTYPE];

//--------------------------------------------------------------------------
// Macros
//--------------------------------------------------------------------------
#define DBTypeIsDefault(_pColumn, _pBinding) \
    (*(g_rgpfnDBTypeIsDefault[(_pColumn)->type])) \
    ((_pColumn), _pBinding)

#define DBTypeGetSize(_pColumn, _pBinding) \
    (*(g_rgpfnDBTypeGetSize[(_pColumn)->type])) \
    ((_pColumn), _pBinding)

#define DBTypeCompareRecords(_pColumn, _pKey, _pTag1, _pTag2, _pMap1, _pMap2) \
    (*(g_rgpfnDBTypeCompareRecords[(_pColumn)->type])) \
    ((_pColumn), _pKey, _pTag1, _pTag2, _pMap1, _pMap2)

#define DBTypeCompareBinding(_pColumn, _pKey, _pBinding, _pTag, _pMap) \
    (*(g_rgpfnDBTypeCompareBinding[(_pColumn)->type])) \
    ((_pColumn), _pKey, _pBinding, _pTag, _pMap)

#define DBTypeWriteValue(_pColumn, _pBinding, _pTag, _pbDest) \
    (*(g_rgpfnDBTypeWriteValue[(_pColumn)->type])) \
    ((_pColumn), _pBinding, _pTag, _pbDest)

#define DBTypeReadValue(_pColumn, _pTag, _pMap, _pBinding) \
    (*(g_rgpfnDBTypeReadValue[(_pColumn)->type])) \
    ((_pColumn), _pTag, _pMap, _pBinding)

#define DBTypeValidate(_pColumn, _pTag, _pMap) \
    (*(g_rgpfnDBTypeValidate[(_pColumn)->type])) \
    ((_pColumn), _pTag, _pMap)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\guids\defguid.cpp ===
//--------------------------------------------------------------------------
// Defguid.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#define INITGUID
#include <initguid.h>
#include <directdb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\inc\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// --------------------------------------------------------------------------------
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\wrapwide.h ===
//--------------------------------------------------------------------------
// WrapWide.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
LPSTR   AllocateStringA(DWORD cch);
LPWSTR  AllocateStringW(DWORD cch);
LPSTR   DuplicateStringA(LPCSTR psz);
LPWSTR  DuplicateStringW(LPCWSTR psz);
LPWSTR  ConvertToUnicode(UINT cp, LPCSTR pcszSource);
LPSTR   ConvertToANSI(UINT cp, LPCWSTR pcwszSource);
DWORD   GetFullPathNameWrapW(LPCWSTR pwszFileName, DWORD nBufferLength, LPWSTR pwszBuffer, LPWSTR *ppwszFilePart);
HANDLE  CreateMutexWrapW(LPSECURITY_ATTRIBUTES pMutexAttributes, BOOL bInitialOwner, LPCWSTR pwszName);
int     wsprintfWrapW( LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ... );
DWORD   CharLowerBuffWrapW(LPWSTR pwsz, DWORD cch);
HANDLE  CreateFileWrapW(LPCWSTR pwszFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES pSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
BOOL    GetDiskFreeSpaceWrapW(LPCWSTR pwszRootPathName, LPDWORD pdwSectorsPerCluster, LPDWORD pdwBytesPerSector, LPDWORD pdwNumberOfFreeClusters, LPDWORD pdwTotalNumberOfClusters);
HANDLE  OpenFileMappingWrapW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR pwszName);
HANDLE  CreateFileMappingWrapW(HANDLE hFile, LPSECURITY_ATTRIBUTES pFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR pwszName);
BOOL    MoveFileWrapW(LPCWSTR pwszExistingFileName, LPCWSTR pwszNewFileName);
BOOL    DeleteFileWrapW(LPCWSTR pwszFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\engine\wrapwide.cpp ===
//--------------------------------------------------------------------------
// WrapWide.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"

// --------------------------------------------------------------------------
// AllocateStringA
// --------------------------------------------------------------------------
LPSTR AllocateStringA(DWORD cch)
{
    // Allocate It
    return((LPSTR)g_pMalloc->Alloc((cch + 1) * sizeof(CHAR)));
}

// --------------------------------------------------------------------------
// AllocateStringW
// --------------------------------------------------------------------------
LPWSTR AllocateStringW(DWORD cch)
{
    // Allocate It
    return((LPWSTR)g_pMalloc->Alloc((cch + 1) * sizeof(WCHAR)));
}

// --------------------------------------------------------------------------
// DuplicateStringA
// --------------------------------------------------------------------------
LPSTR DuplicateStringA(LPCSTR psz)
{
    // Locals
    HRESULT hr=S_OK;
    DWORD   cch;
    LPSTR   pszT;

    // Trace
    TraceCall("DuplicateStringA");

    // Invalid Arg
    if (NULL == psz)
        return(NULL);

    // Length
    cch = lstrlenA(psz);

    // Allocate
    IF_NULLEXIT(pszT = AllocateStringA(cch));

    // Copy (including NULL)
    CopyMemory(pszT, psz, (cch + 1) * sizeof(CHAR));

exit:
    // Done
    return(pszT);
}

// --------------------------------------------------------------------------
// DuplicateStringW
// --------------------------------------------------------------------------
LPWSTR DuplicateStringW(LPCWSTR psz)
{
    // Locals
    HRESULT hr=S_OK;
    DWORD   cch;
    LPWSTR  pszT;

    // Trace
    TraceCall("DuplicateStringW");

    // Invalid Arg
    if (NULL == psz)
        return(NULL);

    // Length
    cch = lstrlenW(psz);

    // Allocate
    IF_NULLEXIT(pszT = AllocateStringW(cch));

    // Copy (including NULL) 
    CopyMemory(pszT, psz, (cch + 1) * sizeof(WCHAR));

exit:
    // Done
    return(pszT);
}

// --------------------------------------------------------------------------
// ConvertToUnicode
// --------------------------------------------------------------------------
LPWSTR ConvertToUnicode(UINT cp, LPCSTR pcszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPWSTR      pwszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Length
    cchNarrow = lstrlenA(pcszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, NULL, 0);

    // Error
    if (cchWide == 0)
        goto exit;

    // Alloc temp buffer
    IF_NULLEXIT(pwszDup = AllocateStringW(cchWide));

    // Do the actual translation
	cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, pwszDup, cchWide+1);

    // Error
    if (cchWide == 0)
    {
        SafeMemFree(pwszDup);
        goto exit;
    }

exit:
    // Done
    return(pwszDup);
}

// --------------------------------------------------------------------------
// ConvertToANSI
// --------------------------------------------------------------------------
LPSTR ConvertToANSI(UINT cp, LPCWSTR pcwszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPSTR       pszDup=NULL;

    // No Source
    if (pcwszSource == NULL)
        goto exit;

    // Length
    cchWide = lstrlenW(pcwszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, NULL, 0, NULL, NULL);

    // Error
    if (cchNarrow == 0)
        goto exit;

    // Alloc temp buffer
    IF_NULLEXIT(pszDup = AllocateStringA(cchNarrow + 1));

    // Do the actual translation
	cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, pszDup, cchNarrow + 1, NULL, NULL);

    // Error
    if (cchNarrow == 0)
    {
        SafeMemFree(pszDup);
        goto exit;
    }

exit:
    // Done
    return(pszDup);
}

//--------------------------------------------------------------------------
// GetFullPathNameWrapW
//--------------------------------------------------------------------------
DWORD GetFullPathNameWrapW(LPCWSTR pwszFileName, DWORD nBufferLength, 
    LPWSTR pwszBuffer, LPWSTR *ppwszFilePart)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwReturn;
    LPSTR       pszFileName=NULL;
    LPSTR       pszFilePart=NULL;
    LPSTR       pszBuffer=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("GetFullPathNameWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(GetFullPathNameW(pwszFileName, nBufferLength, pwszBuffer, ppwszFilePart));

    // Convert
    if (pwszFileName)
    {
        // To ANSI
        IF_NULLEXIT(pszFileName = ConvertToANSI(CP_ACP, pwszFileName));
    }

    // Allocate
    if (pwszBuffer && nBufferLength)
    {
        // Allocate a Buffer
        IF_NULLEXIT(pszBuffer = AllocateStringA(nBufferLength));
    }

    // Call
    dwReturn = GetFullPathNameA(pszFileName, nBufferLength, pszBuffer, &pszFilePart);

    // Save Last Error
    dwError = GetLastError();

    // If we have a buffer
    if (pwszBuffer && nBufferLength)
    {
        // Convert to Unicode
        if (0 == (dwReturn = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszBuffer, -1, pwszBuffer, nBufferLength)))
        {
            TraceResult(E_FAIL);
            goto exit;
        }
		if(dwReturn < nBufferLength)
			pwszBuffer[dwReturn] = L'\0';
		else
			Assert(FALSE);
    }

    // Set ppwszFilePath
    if (ppwszFilePart)
    {
        // Do we have a file part
        if (pszFilePart && pszBuffer && pwszBuffer && nBufferLength)
        {
            // Set Length
            DWORD cch = (DWORD)(pszFilePart - pszBuffer);

            // Set
            *ppwszFilePart = (LPWSTR)((LPBYTE)pwszBuffer + (cch * sizeof(WCHAR)));
        }

        // Otherwise
        else
            *ppwszFilePart = NULL;
    }


exit:
    // Cleanup
    g_pMalloc->Free(pszFileName);
    g_pMalloc->Free(pszBuffer);

    // Save Last Error
    SetLastError(dwError);

    // Done
    return(SUCCEEDED(hr) ? dwReturn : 0);
}

//--------------------------------------------------------------------------
// CreateMutexWrapW
//--------------------------------------------------------------------------
HANDLE CreateMutexWrapW(LPSECURITY_ATTRIBUTES pMutexAttributes, 
    BOOL bInitialOwner, LPCWSTR pwszName)
{
    // Locals
    HRESULT         hr=S_OK;
    HANDLE          hMutex=NULL;
    LPSTR           pszName=NULL;
    DWORD           dwError=0;

    // Trace
    TraceCall("CreateMutexWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(CreateMutexW(pMutexAttributes, bInitialOwner, pwszName));

    // Convert to Ansi
    if (pwszName)
    {
        // To ANSI
        IF_NULLEXIT(pszName = ConvertToANSI(CP_ACP, pwszName));
    }

    // Call ANSI
    hMutex = CreateMutexA(pMutexAttributes, bInitialOwner, pszName);

    // Save Last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszName);

    // Save Last Error
    SetLastError(dwError);

    // Done
    return(hMutex);
}


//--------------------------------------------------------------------------
// CharLowerBuffWrapW
//--------------------------------------------------------------------------
DWORD CharLowerBuffWrapW(LPWSTR pwsz, DWORD cch)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       psz=NULL;
    DWORD       dwReturn=0;
    DWORD       dwError=0;
    DWORD       cchMax;

    // Trace
    TraceCall("CharLowerBuffWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(CharLowerBuffW(pwsz, cch));

    // Convert
    if (pwsz)
    {
        // Convert to ANSI
        IF_NULLEXIT(psz = ConvertToANSI(CP_ACP, pwsz));
    }

    // Call ANSI
    dwReturn = CharLowerBuffA(psz, cch);

    // Get the last error
    dwError = GetLastError();

    // If psz
    if (psz)
    {
        // Convert back to unicode
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, psz, -1, pwsz, cch);
    }

exit:
    // Cleanup
    g_pMalloc->Free(psz);

    // Save the last error
    SetLastError(dwError);

    // Done
    return(dwReturn);
}

//--------------------------------------------------------------------------
// CreateFileWrapW
//--------------------------------------------------------------------------
HANDLE CreateFileWrapW(LPCWSTR pwszFileName, DWORD dwDesiredAccess,
    DWORD dwShareMode, LPSECURITY_ATTRIBUTES pSecurityAttributes,
    DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hFile=INVALID_HANDLE_VALUE;
    LPSTR       pszFileName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("CreateFileWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(CreateFileW(pwszFileName, dwDesiredAccess, dwShareMode, pSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile));

    // To ANSI
    if (pwszFileName)
    {
        // Convert to ANSI
        IF_NULLEXIT(pszFileName = ConvertToANSI(CP_ACP, pwszFileName));
    }

    // Call ANSI
    hFile = CreateFileA(pszFileName, dwDesiredAccess, dwShareMode, pSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

    // Save the last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszFileName);

    // Set Last Error
    SetLastError(dwError);

    // Done
    return(hFile);
}

//--------------------------------------------------------------------------
// GetDiskFreeSpaceWrapW
//--------------------------------------------------------------------------
BOOL GetDiskFreeSpaceWrapW(LPCWSTR pwszRootPathName, LPDWORD pdwSectorsPerCluster,
    LPDWORD pdwBytesPerSector, LPDWORD pdwNumberOfFreeClusters,
    LPDWORD pdwTotalNumberOfClusters)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fReturn=FALSE;
    LPSTR       pszRootPathName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("GetClassInfoWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(GetDiskFreeSpaceW(pwszRootPathName, pdwSectorsPerCluster, pdwBytesPerSector, pdwNumberOfFreeClusters, pdwTotalNumberOfClusters));

    // To ANSI
    if (pwszRootPathName)
    {
        // to ANSI
        IF_NULLEXIT(pszRootPathName = ConvertToANSI(CP_ACP, pwszRootPathName));
    }

    // Call ANSI
    fReturn = GetDiskFreeSpaceA(pszRootPathName, pdwSectorsPerCluster, pdwBytesPerSector, pdwNumberOfFreeClusters, pdwTotalNumberOfClusters);

    // Save Last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszRootPathName);

    // Save Last Error
    SetLastError(dwError);

    // Done
    return(fReturn);
}
 
//--------------------------------------------------------------------------
// OpenFileMappingWrapW
//--------------------------------------------------------------------------
HANDLE OpenFileMappingWrapW(DWORD dwDesiredAccess, BOOL bInheritHandle,
    LPCWSTR pwszName)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hMapping=NULL;
    LPSTR       pszName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("OpenFileMappingWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(OpenFileMappingW(dwDesiredAccess, bInheritHandle, pwszName));

    // To ANSI
    if (pwszName)
    {
        // to ANSI
        IF_NULLEXIT(pszName = ConvertToANSI(CP_ACP, pwszName));
    }

    // Call ANSI
    hMapping = OpenFileMappingA(dwDesiredAccess, bInheritHandle, pszName);

    // Save the last error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszName);

    // Set the last error
    SetLastError(dwError);

    // Done
    return(hMapping);
}

//--------------------------------------------------------------------------
// CreateFileMappingWrapW
//--------------------------------------------------------------------------
HANDLE CreateFileMappingWrapW(HANDLE hFile, LPSECURITY_ATTRIBUTES pFileMappingAttributes,
    DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow,
    LPCWSTR pwszName)
{
    // Locals
    HRESULT     hr=S_OK;
    HANDLE      hMapping=NULL;
    LPSTR       pszName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("OpenFileMappingWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(CreateFileMappingW(hFile, pFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pwszName));

    // To ANSI
    if (pwszName)
    {
        // to ANSI
        IF_NULLEXIT(pszName = ConvertToANSI(CP_ACP, pwszName));
    }

    // Call ANSI
    hMapping = CreateFileMappingA(hFile, pFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pszName);

    // Save last error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszName);

    // Save last error
    SetLastError(dwError);

    // Done
    return(hMapping);
}
 
//--------------------------------------------------------------------------
// MoveFileWrapW
//--------------------------------------------------------------------------
BOOL MoveFileWrapW(LPCWSTR pwszExistingFileName, LPCWSTR pwszNewFileName)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fReturn=FALSE;
    LPSTR       pszExistingFileName=NULL;
    LPSTR       pszNewFileName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("MoveFileWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(MoveFileW(pwszExistingFileName, pwszNewFileName));

    // To ANSI
    if (pwszExistingFileName)
    {
        // to ANSI
        IF_NULLEXIT(pszExistingFileName = ConvertToANSI(CP_ACP, pwszExistingFileName));
    }

    // To ANSI
    if (pwszNewFileName)
    {
        // to ANSI
        IF_NULLEXIT(pszNewFileName = ConvertToANSI(CP_ACP, pwszNewFileName));
    }

    // Call ANSI
    fReturn = MoveFileA(pszExistingFileName, pszNewFileName);

    // Save the last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszExistingFileName);
    g_pMalloc->Free(pszNewFileName);

    // Save the last Error
    SetLastError(dwError);

    // Done
    return(fReturn);
}

//--------------------------------------------------------------------------
// DeleteFileWrapW
//--------------------------------------------------------------------------
BOOL DeleteFileWrapW(LPCWSTR pwszFileName)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fReturn=FALSE;
    LPSTR       pszFileName=NULL;
    DWORD       dwError=0;

    // Trace
    TraceCall("DeleteFileWrapW");

    // If WinNT, call Unicode Version
    if (g_fIsWinNT)
        return(DeleteFileW(pwszFileName));

    // To ANSI
    if (pwszFileName)
    {
        // to ANSI
        IF_NULLEXIT(pszFileName = ConvertToANSI(CP_ACP, pwszFileName));
    }

    // Call ANSI
    fReturn = DeleteFileA(pszFileName);

    // Save the last Error
    dwError = GetLastError();

exit:
    // Cleanup
    g_pMalloc->Free(pszFileName);

    // Save the last Error
    SetLastError(dwError);

    // Done
    return(fReturn);
}

/**********************************************************************************\
* from msoert ported by YSt 6/25/99
*
* bobn 6/23/99
*
* The following code was ported from ShlWapi.  There were problems with
* our implementation on Win95 and it seemed prudent to have a solution
* without a bunch of special cases.
*
*
\**********************************************************************************/

#define DBCS_CHARSIZE   (2)

int DDB_MBToWCS(LPSTR pszIn, int cchIn, LPWSTR *ppwszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppwszOut))
    {
        cchIn++;
        cbAlloc = cchIn * sizeof(WCHAR);

        *ppwszOut = (LPWSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppwszOut)
        {
            cch = MultiByteToWideChar(CP_ACP, 0, pszIn, cchIn, *ppwszOut, cchIn);

            if (!cch)
            {
                LocalFree(*ppwszOut);
                *ppwszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

int DDB_WCSToMB(LPCWSTR pwszIn, int cchIn, LPSTR *ppszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppszOut))
    {
        cchIn++;
        cbAlloc = cchIn * DBCS_CHARSIZE;

        *ppszOut = (LPSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppszOut)
        {
            cch = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchIn, 
                                      *ppszOut, cbAlloc, NULL, NULL);

            if (!cch)
            {
                LocalFree(*ppszOut);
                *ppszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

/* Max number of characters. Doesn't include termination character */
#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout

/***************************************************************************\
* DDB_SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from DDB_SP_GetFmtValue)
\***************************************************************************/

LPCWSTR DDB_SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* DDB_SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int DDB_SP_PutNumberW(
    LPWSTR lpstr,
    DWORD n,
    int   limit,
    DWORD radix,
    int   uppercase,
    int   *pcch)
{
    DWORD mod;
    *pcch = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (limit) {
        do  {
            mod =  n % radix;
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            (*pcch)++;
        } while((*pcch < limit) && n);
    }

    return (n == 0) && (*pcch > 0);
}

/***************************************************************************\
* DDB_SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void DDB_SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
* 1-22-97 tnoonan       Converted to wvnsprintfW
\***************************************************************************/

int DDB_wvnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem = FALSE;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = --cchLimitIn, cch, cchAvailable;
    LPWSTR lpT, lpTWC;
    LPSTR psz;
    va_list varglist = arglist;
    union {
        long l;
        unsigned long ul;
        CHAR sz[2];
        WCHAR wsz[2];
    } val;

    if (cchLimit < 0)
        return 0;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = DDB_SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = DDB_SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                size=1;
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 */
                if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 * DDB_SP_PutNumberW returns FALSE if it runs out of space
                 */
                if (!DDB_SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper, &cch))
                {
                    break;
                }

                //  Now we have the number backwards, calculate how much
                //  more buffer space we'll need for this number to
                //  format correctly.
                cchAvailable = cchLimit - cch;

                width -= cch;
                prec -= cch;
                if (prec > 0)
                {
                    width -= prec;
                    cchAvailable -= prec;
                }

                if (width > 0)
                {
                    cchAvailable -= width - (sign ? 1 : 0);
                }

                if (sign)
                {
                    cchAvailable--;
                }

                if (cchAvailable < 0)
                {
                    break;
                }

                //  We have enough space to format the buffer as requested
                //  without overflowing.

                lpOut += cch;
                cchLimit -= cch;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    DDB_SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    DDB_SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = (LPSTR)(val.sz);
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    cch = lstrlenW(lpT);
                } else {
                    psz = va_arg(varglist, LPSTR);
                    cch = lstrlen((LPCSTR)psz);
putstring:
                    cch = DDB_MBToWCS(psz, cch, &lpTWC);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }
putwstring:
                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     LocalFree(lpTWC);
                     fAllocateMem = FALSE;
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    if (fAllocateMem)
    {
        LocalFree(lpTWC);
    }

    return cchLimitIn - cchLimit;
}

int wsprintfWrapW( LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ... )
{
    va_list arglist;
    int ret;

    Assert(lpOut);
    Assert(lpFmt);

    lpOut[0] = 0;
    va_start(arglist, lpFmt);
    
    ret = DDB_wvnsprintfW(lpOut, cchLimitIn, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\res\makefile.inc ===
$(O)\directdb.res : $(O)\selfreg.inf

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\sample\dbsample.h ===
#ifndef __MAIN_H
#define __MAIN_H

extern UINT g_msgSMTP;

#endif __MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\inc\strconst.h ===
//--------------------------------------------------------------------------
// strconst.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Constant String Definition Macros
//--------------------------------------------------------------------------
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C extern
#endif

#ifndef STRCONSTA
#ifdef DEFINE_STRCONST
#define STRCONSTA(x,y)    EXTERN_C const char x[] = y
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[] = L##y
#else
#define STRCONSTA(x,y)    EXTERN_C const char x[]
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[]
#endif
#endif

//--------------------------------------------------------------------------
// Constant String
//--------------------------------------------------------------------------
STRCONSTA(c_szEmpty,                            "");
STRCONSTW(c_wszEmpty,                           "");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\sample\dbsample.cpp ===
// --------------------------------------------------------------------------------
// dbsample.cpp
// --------------------------------------------------------------------------------
#define INITGUID
#include "pch.h"
#include <initguid.h>
#define DEFINE_DIRECTDB
#include "..\\inc\\directdb.h"

// --------------------------------------------------------------------------------
// Employee Database guid {411AA011-700F-11d2-9957-00C04FA309D4}
// --------------------------------------------------------------------------------
DEFINE_GUID(CLSID_EmployeeDatabase, 0x411aa011, 0x700f, 0x11d2, 0x99, 0x57, 0x0, 0xc0, 0x4f, 0xa3, 0x9, 0xd4);

// --------------------------------------------------------------------------------
// Version
// --------------------------------------------------------------------------------
#define EMPLOYEE_DATABASE_VERSION 1

// --------------------------------------------------------------------------------
// EMPUSERDATA - Fixed length blob that I can store in a DirectDB file
// --------------------------------------------------------------------------------
typedef struct tagEMPUSERDATA {
    BYTE            rgbReserved[256];
} EMPUSERDATA, *LPEMPUSERDATA;

// --------------------------------------------------------------------------------
// EMPCOLID
// --------------------------------------------------------------------------------
typedef enum tagEMPCOLID {
    EMPCOL_ID,
    EMPCOL_NAME,
    EMPCOL_SALARY,
    EMPCOL_LAST
} EMPCOLID;

// --------------------------------------------------------------------------------
// EMPINFO - The structure that represents a record
// --------------------------------------------------------------------------------
typedef struct tagEMPINFO {
    BYTE           *pAllocated;     // Required by DirectDB
    BYTE            bVersion;       // Required by DirectDB
    DWORD           dwId;
    LPWSTR          pwszName;
    DWORD           dwSalary;
} EMPINFO, *LPEMPINFO;

// --------------------------------------------------------------------------------
// Employee Column Definition Array
// --------------------------------------------------------------------------------
BEGIN_COLUMN_ARRAY(g_rgEmpTblColumns, EMPCOL_LAST)
    DEFINE_COLUMN(EMPCOL_ID,     CDT_UNIQUE,  EMPINFO, dwId)
    DEFINE_COLUMN(EMPCOL_NAME,   CDT_VARSTRW, EMPINFO, pwszName)
    DEFINE_COLUMN(EMPCOL_SALARY, CDT_DWORD,   EMPINFO, dwSalary)
END_COLUMN_ARRAY

// --------------------------------------------------------------------------------
// Employee Database Primary Index
// --------------------------------------------------------------------------------
BEGIN_TABLE_INDEX(g_EmpTblPrimaryIndex, 1)
    DEFINE_KEY(EMPCOL_ID, 0, 0,)
END_TABLE_INDEX

// --------------------------------------------------------------------------------
// Employee Database Schema Definition
// --------------------------------------------------------------------------------
BEGIN_TABLE_SCHEMA(g_EmpTableSchema, CLSID_EmployeeDatabase, EMPINFO)
    SCHEMA_PROPERTY(EMPLOYEE_DATABASE_VERSION)          // Version
    SCHEMA_PROPERTY(TSF_RESETIFBADVERSION)              // Table Schema Flags
    SCHEMA_PROPERTY(sizeof(EMPUSERDATA))                // Size of user data
    SCHEMA_PROPERTY(offsetof(EMPINFO, dwId))            // Optional: Offset of a unique field
    SCHEMA_PROPERTY(EMPCOL_LAST)                        // Number of columns (can grow)
    SCHEMA_PROPERTY(g_rgEmpTblColumns)                  // The column array
    SCHEMA_PROPERTY(&g_EmpTblPrimaryIndex)              // The primary index
    SCHEMA_PROPERTY(NULL)                               // Optional: Symbol table for expression handling
END_TABLE_SCHEMA

// --------------------------------------------------------------------------------
// main
// --------------------------------------------------------------------------------
void __cdecl main(int argc, char *argv[])
{
    // Locals
    HRESULT             hr;
    EMPINFO             Employee;
    HROWSET             hRowset=NULL;
    IDatabaseSession   *pSession=NULL;
    IDatabase          *pDatabase=NULL;

    // You must always call this if you are going to use COM
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        printf("Error - CoInitialize failed: %08X\n", hr);
        exit(1);
    }

    // Create a Database Session
    hr = CoCreateInstance(CLSID_DatabaseSession, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseSession, (LPVOID *)&pSession);
    if (FAILED(hr))
    {
        printf("Error - CoCreateInstance(CLSID_DatabaseSession...) failed: %08X\n", hr);
        goto exit;
    }

    // Open a database
    hr = pSession->OpenDatabase("c:\\emp.dbx", OPEN_DATABASE_NOEXTENSION, &g_EmpTableSchema, NULL, &pDatabase);
    if (FAILED(hr))
    {
        printf("Error - pSession->OpenDatabase failed: %08X\n", hr);
        goto exit;
    }

    // Delete employee 568 or InsertRecord may return DB_E_DUPLICATE
    Employee.dwId = 568;

    // Delete It
    hr = pDatabase->DeleteRecord(&Employee);
    if (FAILED(hr) && DB_E_NOTFOUND != hr)
    {
        printf("Error - pDatabase->DeleteRecord failed: %08X\n", hr);
        goto exit;
    }

    // Fill an Employee Structure
    Employee.dwId = 568;
    Employee.pwszName = L"Don Johnson";
    Employee.dwSalary = 56000;

    // Insert the Record
    hr = pDatabase->InsertRecord(&Employee);
    if (FAILED(hr))
    {
        printf("Error - pDatabase->InsertRecord failed: %08X\n", hr);
        goto exit;
    }

    // Zero out Employee
    ZeroMemory(&Employee, sizeof(EMPINFO));

    // Set the id of the record I want to find
    Employee.dwId = 568;

    // Find the Record
    hr = pDatabase->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Employee, NULL);
    if (FAILED(hr))
    {
        printf("Error - pDatabase->FindRecord failed: %08X\n", hr);
        goto exit;
    }

    // Was the Record Found
    if (DB_S_FOUND == hr)
        printf("FindRecord Result: Id: %d, Name: %ls, Salaray: %d\n", Employee.dwId, Employee.pwszName, Employee.dwSalary);
    else if (DB_S_NOTFOUND == hr)
        printf("The Record Was NOT Found.\n");

    // Free the Employee Memory
    pDatabase->FreeRecord(&Employee);

    // Lets create a rowset to walk through the records in the same order that the index is in...
    hr = pDatabase->CreateRowset(IINDEX_PRIMARY, 0, &hRowset);
    if (FAILED(hr))
    {
        printf("Error - pDatabase->CreateRowset failed: %08X\n", hr);
        goto exit;
    }

    // Zero out Employee
    ZeroMemory(&Employee, sizeof(EMPINFO));

    // Query the Rowset...
    while (S_OK == pDatabase->QueryRowset(hRowset, 1, (LPVOID *)&Employee, NULL))
    {
        // Print
        printf("QueryRowset Result: Id: %d, Name: %ls, Salaray: %d\n", Employee.dwId, Employee.pwszName, Employee.dwSalary);

        // Free the REcord
        pDatabase->FreeRecord(&Employee);
    }

    // Close the Rowset
    pDatabase->CloseRowset(&hRowset);

exit:
    // Cleanup
    if (pDatabase)
        pDatabase->Release();
    if (pSession)
        pSession->Release();

    // I called CoInitialize, so lets call this...
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\envhost\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\envhost\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDBCS_DIVIDE -D_WIN32_OE=0x0500

WIN32_IE_VERSION=0x0300

INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(BASEDIR)\public\sdk\inc; \
    $(ATHROOT)\inc; \
    $(ATHROOT)\mailnews\extinc; \
    $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1
#ifndef WIN16
PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch
#else
PRECOMPILED_OPTION=/fh=$R\inc\$(_OBJ_DIR)\*\pch.pch
#endif
PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\envhost\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#include <initguid.h>
#include <ole2.h>
#define INITGUID
#include "mimeole.h"
#include <msoert.h>
#include "envguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\directdb\sample\pch.h ===
#include <windows.h>
#include <stdio.h>
#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\envhost\envhost.h ===
/*
 *    e n v h o s t . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _ENVHOST_H
#define _ENVHOST_H

#include "privunk.h"
#include <envelope.h>
#include <mso.h>
#include <envguid.h>




class CNoteWnd:
    public IPersistMime,
    public IServiceProvider,
    public IMsoEnvelopeSite,
    public IMsoComponentManager
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IServiceProvider ***
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    // *** IPersist ***
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);

    // *** IPersistMime ***
	virtual HRESULT STDMETHODCALLTYPE Load(IMimeMessage *pMsg);
	virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwFlags);

    // *** IEnvelopeSite ***
    virtual HRESULT STDMETHODCALLTYPE RequestResize(int *pcHeight);
    virtual HRESULT STDMETHODCALLTYPE CloseNote(DWORD grfClose);
    virtual HRESULT STDMETHODCALLTYPE GetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody);
    virtual HRESULT STDMETHODCALLTYPE SetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody);
    virtual HRESULT STDMETHODCALLTYPE SetFocus(BOOL fTab);
    virtual HRESULT STDMETHODCALLTYPE OnEnvSetFocus();
    virtual HRESULT STDMETHODCALLTYPE DirtyToolbars(void);

    virtual HRESULT STDMETHODCALLTYPE OnPropChange(ULONG dispid);
    virtual HRESULT STDMETHODCALLTYPE IsBodyDirty();
    virtual HRESULT STDMETHODCALLTYPE HandsOff();
    virtual HRESULT STDMETHODCALLTYPE GetMsoInst(HMSOINST *phinst);
    virtual HRESULT STDMETHODCALLTYPE GetFrameWnd(HWND *phwndFrame);
    virtual HRESULT STDMETHODCALLTYPE DisplayMessage(HRESULT hr, LPCWSTR wszError, DWORD grfMsg);

    virtual HRESULT STDMETHODCALLTYPE SetHelpMode(BOOL fEnter);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerators(MSG *pMsg);
    
    // *** IMsoComponentManager ***       
	//HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID iid, void **ppvObj);
    BOOL STDMETHODCALLTYPE FDebugMessage(HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam);
	BOOL STDMETHODCALLTYPE FRegisterComponent(IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, DWORD *pdwComponentID);
	BOOL STDMETHODCALLTYPE FRevokeComponent(DWORD dwComponentID);
	BOOL STDMETHODCALLTYPE FUpdateComponentRegistration(DWORD dwComponentID, const MSOCRINFO *pcrinfo);
	BOOL STDMETHODCALLTYPE FOnComponentActivate(DWORD dwComponentID);
	BOOL STDMETHODCALLTYPE FSetTrackingComponent(DWORD dwComponentID, BOOL fTrack);
	void STDMETHODCALLTYPE OnComponentEnterState(DWORD dwComponentID, ULONG uStateID, ULONG uContext, ULONG cpicmExclude, IMsoComponentManager **rgpicmExclude, DWORD dwReserved);
	BOOL STDMETHODCALLTYPE FOnComponentExitState(DWORD dwComponentID, ULONG uStateID, ULONG uContext, ULONG cpicmExclude, IMsoComponentManager **rgpicmExclude);
	BOOL STDMETHODCALLTYPE FInState(ULONG uStateID, void *pvoid);
	BOOL STDMETHODCALLTYPE FContinueIdle ();
	BOOL STDMETHODCALLTYPE FPushMessageLoop(DWORD dwComponentID, ULONG uReason, void *pvLoopData);
	BOOL STDMETHODCALLTYPE FCreateSubComponentManager(IUnknown *piunkOuter, IUnknown *piunkServProv,REFIID riid, void **ppvObj);
	BOOL STDMETHODCALLTYPE FGetParentComponentManager(IMsoComponentManager **ppicm);
    BOOL STDMETHODCALLTYPE FGetActiveComponent(DWORD dwgac, IMsoComponent **ppic, MSOCRINFO *pcrinfo, DWORD dwReserved);

    CNoteWnd(IUnknown *pUnkOuter=NULL);
    virtual ~CNoteWnd();

    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT Init(REFCLSID clsidEnvelope, DWORD dwFlags);
    HRESULT Show();
    
    HRESULT TranslateAcclerator(MSG *lpmsg);

private:
    IMsoEnvelope    *m_pEnv;
    IMsoComponent   *m_pComponent;
    ULONG           m_cRef;
    HWND            m_hwnd,
                    m_hwndRE,
                    m_hwndFocus;
    ULONG           m_cyEnv;

    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT OnNCDestroy();
    HRESULT OnCreate(HWND hwnd);
    HRESULT InitEnvelope(REFCLSID clsidEnvelope, DWORD dwFlags);
    HRESULT WMCommand(HWND hwndCmd, int id, WORD wCmd);
    HRESULT WMNotify(int idFrom, NMHDR *pnmh);

    HRESULT HrHeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn);

    //saveas helpers
    HRESULT SaveToFile(LPWSTR pszW);
    HRESULT SaveAs();

    HRESULT OnInitMenuPopup(HMENU hMenuPopup, ULONG uPos);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\envhost\main.h ===
#ifndef _MAIN_H
#define _MAIN_H

class CNoteWnd;

HRESULT HrCreateNote(REFCLSID clsidEnvelope, DWORD dwFlags);

extern CNoteWnd     *g_pActiveNote;
extern HWND         g_hwndInit;
extern HEVENT       g_hEventSpoolerInit;
extern DWORD        g_dwNoteThreadID;
extern BOOL         g_fInitialized;
extern HINSTANCE    g_hInst;

#endif //_MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\envhost\main.cpp ===
/*
 *    m a i n . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "msoert.h"
#include "mimeole.h"
#include "envhost.h"
#include "main.h"

LRESULT CALLBACK InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
HRESULT CreateNoteWindow();
DWORD MainThreadProc(LPVOID lpvUnused);
void NoteMsgPump();

CNoteWnd             *g_pActiveNote=0;
HINSTANCE           g_hInst;

int CALLBACK WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow)
{
    if (hInstPrev)
        return 0;

    if (OleInitialize(0)==S_OK)
    {
        g_hInst = hInst;

        // create a note and pump messages
        if (CreateNoteWindow()==S_OK)
            NoteMsgPump();

        OleUninitialize();
    }
    return 0;
}


void NoteMsgPump()
{
    MSG     msg;

    while (GetMessage(&msg, NULL, 0, 0))
        {
        if(g_pActiveNote &&                     // if a note has focus, call it's XLateAccelerator...
            g_pActiveNote->TranslateAcclerator(&msg)==S_OK)
            continue;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
}

HRESULT CreateNoteWindow()
{
    static HINSTANCE s_hRichEdit=0;
    HRESULT hr;
    CNoteWnd *pNote=0;
    CLSID   clsid;

    // LAMEHACK: we loadlibrary richedit but never free it
    if (!s_hRichEdit)
        s_hRichEdit = LoadLibrary("RICHED32.DLL");
 
    // need to create this puppy on new thread 
    pNote = new CNoteWnd(NULL);
    if (!pNote)
        return E_OUTOFMEMORY;

    hr = pNote->Init(CLSID_OEEnvelope, 0);
    if (FAILED(hr))
        goto error;

    hr = pNote->Show();

error:
    ReleaseObj(pNote);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\envhost\envhost.cpp ===
/*
 *    e n v h o s t . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <docobj.h>
#include <commdlg.h>
#include <richedit.h>

#include "resource.h"
#include "envcid.h"
#include "envguid.h"
#include "msoert.h"
#include "mimeole.h"
#include "envhost.h"
#include "main.h"

HINSTANCE   s_hRichEdit;
HINSTANCE   g_hLocRes ;
HACCEL      g_hAccelMailSend;

HRESULT HrRicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags);
void SaveFocus(BOOL fActive, HWND *phwnd);
        

static const TCHAR  c_szGWNoteWndClass[] = "ENV_Note";



//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CNoteWnd::CNoteWnd(IUnknown *pUnkOuter)
{
    m_pEnv=NULL;
    m_hwnd=NULL;
    m_hwndRE=NULL;
    m_pComponent=NULL;
    m_hwndFocus=NULL;
    m_cRef=1;
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CNoteWnd::~CNoteWnd()
{
}

ULONG CNoteWnd::AddRef()
{
    return ++m_cRef;
}

ULONG CNoteWnd::Release()
{
    m_cRef--;
    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CNoteWnd::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IPersistMime *)this;
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(IPersistMime *)this;
    else if (IsEqualIID(riid, IID_IMsoEnvelopeSite))
        *lplpObj = (LPVOID)(IMsoEnvelopeSite *)this;
    else if (IsEqualIID(riid, IID_IMsoComponentManager))
        *lplpObj = (LPVOID)(IMsoComponentManager *)this;
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CNoteWnd::GetClassID(CLSID *pClassID)
{
	*pClassID = CLSID_GWEnvelopeHost;
    return NOERROR;
}

// *** IServiceProvider ***
//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CNoteWnd::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (IsEqualGUID(guidService, IID_IMsoComponentManager))
        return QueryInterface(riid, ppvObject);

    return E_NOINTERFACE;
}

// *** IPersistMime ***
//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CNoteWnd::Load(IMimeMessage *pMsg)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CNoteWnd::Save(IMimeMessage *pMsg, DWORD dwFlags)
{
    IPersistMime    *pPM;
    IStream         *pstm;
    HRESULT         hr;

    // save envelope props
    if (m_pEnv &&
        m_pEnv->QueryInterface(IID_IPersistMime, (LPVOID *)&pPM)==S_OK)
        {
        hr = pPM->Save(pMsg, dwFlags);
        pPM->Release();
        }

    // save body props
    if (CreateStreamOnHGlobal(NULL, TRUE, &pstm)==S_OK)
        {
        if (HrRicheditStreamOut(m_hwndRE, pstm, SF_TEXT)==S_OK)
            pMsg->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pstm, NULL);
        
        pstm->Release();
        }
    return hr;
}

HRESULT CNoteWnd::RequestResize(int *pcHeight)
{
    RECT rc;

    m_cyEnv = *pcHeight;

    GetClientRect(m_hwnd, &rc);
    rc.top +=2;
    rc.bottom = m_cyEnv+2;
    if (m_pEnv)
        m_pEnv->Resize(&rc);

    GetClientRect(m_hwnd, &rc);
    rc.top += m_cyEnv + 4;
    rc.bottom -=2;
    SetWindowPos(m_hwndRE, NULL, 0, rc.top, rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER);
    return S_OK;
}

HRESULT CNoteWnd::CloseNote(DWORD grfClose)
{
    SendMessage(m_hwnd, WM_CLOSE, 0, 0);
    return S_OK;
}

HRESULT CNoteWnd::GetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody)
{
    return E_NOTIMPL;
}

HRESULT CNoteWnd::SetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody)
{
    return S_OK;
}

HRESULT CNoteWnd::SetFocus(BOOL fTab)
{
    if (fTab)
        ::SetFocus(m_hwndRE);
    return S_OK;
}

HRESULT CNoteWnd::OnEnvSetFocus()
{
    return S_OK;
}

HRESULT CNoteWnd::OnPropChange(ULONG dispid)
{
    return S_OK;
}

HRESULT CNoteWnd::IsBodyDirty()
{
    return S_OK;
}

HRESULT CNoteWnd::HandsOff()
{
    return S_OK;
}

HRESULT CNoteWnd::GetMsoInst(HMSOINST *phinst)
{
    return E_NOTIMPL;
}

HRESULT CNoteWnd::GetFrameWnd(HWND *phwndFrame)
{
    return E_NOTIMPL;
}

HRESULT CNoteWnd::DisplayMessage(HRESULT hr, LPCWSTR wszError, DWORD grfMsg)
{
    return S_OK;
}

LRESULT CNoteWnd::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CNoteWnd *pNote;

    if(msg==WM_CREATE)
        {
        pNote=(CNoteWnd *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pNote)
            return -1;

        if(FAILED(pNote->OnCreate(hwnd)))
            return -1;
        }
    
    pNote = (CNoteWnd *)GetWndThisPtr(hwnd);
    if(pNote)
        return pNote->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);

}

LRESULT CNoteWnd::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LONG    lret;
    HWND    hwndT;

    switch (msg)
        {
        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            hwndT = m_pComponent->HwndGetWindow(msocWindowComponent, 0);
            if (hwndT)
                SendMessage(hwndT, msg, wParam, lParam);
            break;
        
        case WM_INITMENUPOPUP:
            OnInitMenuPopup((HMENU)wParam, lParam);
            break;

        case WM_NOTIFY:
            return (WMNotify(wParam, (NMHDR *)lParam)==S_OK);
                

        case WM_COMMAND:
            if (WMCommand(  GET_WM_COMMAND_HWND(wParam, lParam),
                            GET_WM_COMMAND_ID(wParam, lParam),
                            GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;

            break;

        case WM_SIZE:
            RequestResize((int *)&m_cyEnv);
            break;

        case WM_NCDESTROY:
            PostQuitMessage(0);
            OnNCDestroy();
            break;
        }

    lret = DefWindowProc(hwnd, msg, wParam, lParam);

    if(msg==WM_ACTIVATE)
        {
        // post-process wm_activates to set focus back to
        // control
        SaveFocus((BOOL)(LOWORD(wParam)), &m_hwndFocus);
        g_pActiveNote = (LOWORD(wParam)==WA_INACTIVE)?NULL:this;
        }

    return lret;

}





HRESULT CNoteWnd::Init(REFCLSID clsidEnvelope, DWORD dwFlags)
{

    HRESULT     hr=S_OK;
    HWND        hwnd;
    WNDCLASS    wc;

	TraceCall("CDocHost::Init");

    if (!GetClassInfo(g_hInst, c_szGWNoteWndClass, &wc))
        {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        wc.lpfnWndProc   = (WNDPROC)CNoteWnd::ExtWndProc;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_szGWNoteWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.style = CS_DBLCLKS;

        if(!RegisterClass(&wc))
            return E_OUTOFMEMORY;
        }

    hwnd=CreateWindowEx(WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT,
                        c_szGWNoteWndClass, 
						"Envelope Test Container",
                        WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN,
                        0, 
						0,
						400, 
						400, 
						NULL, 
                        LoadMenu(g_hInst, MAKEINTRESOURCE(ENV_HOST_MENU)), 
						g_hInst, 
						(LPVOID)this);
    if(!hwnd)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

    
    hr = InitEnvelope(clsidEnvelope, dwFlags);

error:
    return hr;
}

HRESULT CNoteWnd::OnCreate(HWND hwnd)
{
    CHARFORMAT  cf={0};

    m_hwnd = hwnd;
    SetWindowLong(hwnd, GWL_USERDATA, (LPARAM)this);

    m_hwndRE  = CreateWindowEx(WS_EX_CLIENTEDGE, 
                                "RichEdit",
                                "",
                                ES_SAVESEL|ES_WANTRETURN|ES_MULTILINE|WS_CHILD|WS_TABSTOP|WS_VISIBLE|ES_AUTOVSCROLL|WS_VSCROLL,
                                0, 0, 0, 0,
                                hwnd, 
                                (HMENU)99,
                                g_hInst,
                                NULL);
    
    if (!m_hwndRE)
        return E_FAIL;

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR|CFM_FACE|CFM_BOLD;
    cf.crTextColor = RGB(0,0,0);
    lstrcpy(cf.szFaceName, "Courier New");

    SendMessage(m_hwndRE, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
    SendMessage(m_hwndRE, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    SendMessage(m_hwndRE, EM_SETEVENTMASK, 0, ENM_KEYEVENTS);
    AddRef();
    return S_OK;
}


HRESULT CNoteWnd::OnNCDestroy()
{
    SafeRelease(m_pEnv);
    if (m_pComponent)
        {
        m_pComponent->Terminate();
        SafeRelease(m_pComponent);
        }

    SetWindowLong(m_hwnd, GWL_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
    return S_OK;
}

HRESULT CNoteWnd::Show()
{
    ShowWindow(m_hwnd, SW_SHOW);
    return S_OK;
}

HRESULT CNoteWnd::InitEnvelope(REFCLSID clsidEnvelope, DWORD dwFlags)
{
    HRESULT hr;
    RECT    rc;

    hr = CoCreateInstance(clsidEnvelope, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER, IID_IMsoEnvelope, (LPVOID *)&m_pEnv);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->Init(NULL, (IMsoEnvelopeSite *)this, dwFlags);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->SetParent(m_hwnd);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->Show(TRUE);
    if (FAILED(hr))
        goto error;

    m_pEnv->SetFocus(ENV_FOCUS_INITIAL);

error:
    return hr;        
}


HRESULT CNoteWnd::TranslateAcclerator(MSG *lpmsg)
{
    if (!g_hAccelMailSend)
        g_hAccelMailSend= LoadAccelerators(g_hInst, MAKEINTRESOURCE(ENV_HOST_ACCEL));

    if (g_hAccelMailSend &&
        ::TranslateAccelerator(m_hwnd, g_hAccelMailSend, lpmsg))
        return S_OK;

    if (m_pComponent &&
        m_pComponent->FPreTranslateMessage(lpmsg))
        return S_OK;

    return S_FALSE;
}



DWORD CALLBACK EditStreamOutCallback(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb)
{
    return ((LPSTREAM)dwCookie)->Write(pbBuff, cb, (ULONG *)pcb);
}



HRESULT HrRicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags)
{
    EDITSTREAM  es;

    if(!pstm)
        return E_INVALIDARG;

    if(!IsWindow(hwndRE))
        return E_INVALIDARG;

    es.dwCookie = (DWORD)pstm;
    es.pfnCallback=(EDITSTREAMCALLBACK)EditStreamOutCallback;
    SendMessage(hwndRE, EM_STREAMOUT, uSelFlags, (LONG)&es);
    return S_OK;
}




BOOL CNoteWnd::FRegisterComponent(IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, DWORD *pdwComponentID)
{
    if (m_pComponent)   // only one register allowed
        return E_FAIL;

    ReplaceInterface(m_pComponent, piComponent);
    *pdwComponentID=666;
    return TRUE;
}

BOOL CNoteWnd::FRevokeComponent(DWORD dwComponentID)
{
    return TRUE;
}

BOOL CNoteWnd::FUpdateComponentRegistration(DWORD dwComponentID, const MSOCRINFO *pcrinfo)
{
    return FALSE;
}

BOOL CNoteWnd::FOnComponentActivate(DWORD dwComponentID)
{
    return FALSE;
}

BOOL CNoteWnd::FSetTrackingComponent(DWORD dwComponentID, BOOL fTrack)
{
    return FALSE;
}

void CNoteWnd::OnComponentEnterState(DWORD dwComponentID, ULONG uStateID, ULONG uContext,ULONG cpicmExclude,IMsoComponentManager **rgpicmExclude, DWORD dwReserved)
{
}

BOOL CNoteWnd::FOnComponentExitState(DWORD dwComponentID, ULONG uStateID, ULONG uContext,ULONG cpicmExclude,IMsoComponentManager **rgpicmExclude)
{
    return FALSE;
}

BOOL CNoteWnd::FInState(ULONG uStateID, void *pvoid)
{
    return FALSE;
}

BOOL CNoteWnd::FContinueIdle ()
{
    return FALSE;
}

BOOL CNoteWnd::FPushMessageLoop(DWORD dwComponentID, ULONG uReason, void *pvLoopData)
{
    return FALSE;
}

BOOL CNoteWnd::FCreateSubComponentManager(IUnknown *piunkOuter, IUnknown *piunkServProv,REFIID riid, void **ppvObj)
{
    return FALSE;
}

BOOL CNoteWnd::FGetParentComponentManager(IMsoComponentManager **ppicm)
{
    return FALSE;
}

BOOL CNoteWnd::FGetActiveComponent(DWORD dwgac, IMsoComponent **ppic, MSOCRINFO *pcrinfo, DWORD dwReserved)
{
    return FALSE;
}


BOOL CNoteWnd::FDebugMessage(HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}




HRESULT CNoteWnd::WMCommand(HWND hwndCmd, int id, WORD wCmd)
{
    ULONG               nCmdID=0;
    IOleCommandTarget   *pCmdTarget;

    if (wCmd > 1)
        return S_FALSE;

    switch(id)
    {
        case IDM_UNDO:
            nCmdID = OLECMDID_UNDO;
            break;

        case IDM_CUT:
            nCmdID = OLECMDID_CUT;
            break;

        case IDM_COPY:
            nCmdID = OLECMDID_COPY;
            break;

        case IDM_PASTE:
            nCmdID = OLECMDID_PASTE;
            break;

        case IDM_SELECT_ALL:
            nCmdID = OLECMDID_SELECTALL;
            break;

        case IDM_POPUP_HELP:
            MessageBox(m_hwnd, "Envelope Test Container\nby brettm", "About", MB_OK);
            break;

        case IDM_CLOSE:
            PostMessage(m_hwnd, WM_CLOSE, 0, 0);
            return S_OK;
        
        case IDM_SEND:
            HrHeaderExecCommand(MSOEENVCMDID_SEND, 0, NULL);
            break;
    }
            
    if (nCmdID && 
        m_pEnv &&
        m_pEnv->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
    {
        pCmdTarget->Exec(NULL, nCmdID, 0, NULL, NULL);
        pCmdTarget->Release();
        return S_OK;
    }
    return S_FALSE;
}



HRESULT CNoteWnd::HrHeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn)
{
    HRESULT             hr = S_FALSE;
    IOleCommandTarget   *pCmdTarget;

    if(m_pEnv &&
        m_pEnv->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
        hr = pCmdTarget->Exec(&CGID_Envelope, uCmdID, nCmdExecOpt, pvaIn, NULL);
        pCmdTarget->Release();
        }
    return hr;

}

HRESULT CNoteWnd::WMNotify(int idFrom, NMHDR *pnmh)
{
    MSGFILTER   *pmf=(MSGFILTER *)pnmh;
    BOOL        fShift;

    switch (pnmh->code)
        {
        case EN_MSGFILTER:
            if (pmf->msg == WM_KEYDOWN && pmf->wParam == VK_TAB && !(GetKeyState(VK_CONTROL) & 0x8000))
                {
                // shift tab puts focus in the envelope
                if (GetKeyState(VK_SHIFT)&0x8000 && m_pEnv)
                    {
                    m_pEnv->SetFocus(ENV_FOCUS_TAB);
                    return S_OK;
                    }
                }
            break;
        }
    return S_FALSE;
}



void SaveFocus(BOOL fActive, HWND *phwnd)
{
    if(fActive&&IsWindow(*phwnd))
        SetFocus(*phwnd);
    else
        *phwnd=GetFocus();
}



static char c_szFilter[] = "Rfc 822 Messages (*.eml)\0*.eml\0\0";

HRESULT CNoteWnd::SaveAs()
{
    OPENFILENAME    ofn;
    TCHAR           szFile[MAX_PATH];
    TCHAR           szTitle[MAX_PATH];
    TCHAR           szDefExt[30];
    WCHAR           szFileW[MAX_PATH];

    lstrcpy(szFile, "c:\\*.eml");
    lstrcpy(szDefExt, ".eml");
    lstrcpy(szTitle, "Save Message As...");
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = c_szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;

    if (*szFile==NULL)
        return E_FAIL;
    

    // Show OpenFile Dialog
    if (!GetSaveFileName(&ofn))
        return MIMEEDIT_E_USERCANCEL;
 
    MultiByteToWideChar(CP_ACP, 0, szFile, -1, szFileW, MAX_PATH);

    return SaveToFile(szFileW);
}


HRESULT CNoteWnd::SaveToFile(LPWSTR pszW)
{
    IPersistMime        *ppm;
    IPersistFile        *pPF;
    IMimeMessage        *pMsg;
    HRESULT             hr;

    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (!FAILED(hr))
        {
        pMsg->InitNew();
        
        hr = pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF);
        if (!FAILED(hr))
            {
            hr = Save(pMsg, 0);
            if (!FAILED(hr))
                {
                hr = pPF->Save(pszW, FALSE);
                }
            pPF->Release();
            }
        pMsg->Release();
        }
    return hr; 
}


HRESULT CNoteWnd::DirtyToolbars(void)
{
    return S_OK;
}


HRESULT CNoteWnd::SetHelpMode(BOOL fEnter)
{
    return S_OK;
}

HRESULT CNoteWnd::TranslateAccelerators(MSG *pMsg)
{
    return S_FALSE;
}



HRESULT CNoteWnd::OnInitMenuPopup(HMENU hMenuPopup, ULONG uPos)
{
    OLECMD  rgCmds[]    ={  {OLECMDID_CUT,      0},
                            {OLECMDID_COPY,     0},
                            {OLECMDID_PASTE,    0},
                            {OLECMDID_UNDO,     0},
                            {OLECMDID_SELECTALL,0}};

    int     rgidm[]     = { IDM_CUT,
                            IDM_COPY,
                            IDM_PASTE,
                            IDM_UNDO,
                            IDM_SELECT_ALL};
    MENUITEMINFO    mii;
    IOleCommandTarget   *pCmdTarget;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;

    // find the sub-menu
    if (GetMenuItemInfo(GetMenu(m_hwnd), uPos, TRUE, &mii) && 
        mii.hSubMenu == hMenuPopup)
    {
        switch (mii.wID)
        {
        case IDM_POPUP_EDIT:
            if (m_pEnv &&
                m_pEnv->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
            {
                pCmdTarget->QueryStatus(NULL, sizeof(rgCmds)/sizeof(OLECMD), rgCmds, NULL);
                pCmdTarget->Release();
            }
            for (int i=0; i<ARRAYSIZE(rgCmds); i++)
                EnableMenuItem(hMenuPopup, rgidm[i], (rgCmds[i].cmdf&OLECMDF_ENABLED ? MF_ENABLED: MF_GRAYED)|MF_BYCOMMAND);

            break;
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\envhost\resource.h ===
//
// resource.h
//
// contains global resource identifiers
//

#ifndef __RESOURCE_H_
#define __RESOURCE_H_

#define IDM_FIRST 10000

// commands
#define IDM_POPUP_FILE                  (IDM_FIRST + 1)
#define IDM_SEND                        (IDM_FIRST + 2)
#define IDM_CLOSE                       (IDM_FIRST + 3)
#define IDM_POPUP_EDIT                  (IDM_FIRST + 4)
#define IDM_UNDO                        (IDM_FIRST + 5)
#define IDM_REDO                        (IDM_FIRST + 6)
#define IDM_CUT                         (IDM_FIRST + 7)
#define IDM_COPY                        (IDM_FIRST + 8)
#define IDM_PASTE                       (IDM_FIRST + 9)
#define IDM_SELECT_ALL                  (IDM_FIRST + 10)
#define IDM_POPUP_HELP                  (IDM_FIRST + 11)
#define IDM_ABOUT                       (IDM_FIRST + 12)


// menus
#define ENV_HOST_MENU                   2000

// accel
#define ENV_HOST_ACCEL                  5000

#endif // __RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\exploder\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// --------------------------------------------------------------------------------
#ifndef __RESOURCE_H
#define __RESOURCE_H

// --------------------------------------------------------------------------------
// String Resource Ids
// --------------------------------------------------------------------------------
#define IDS_CMDLINE_FORMAT          100
#define IDS_HELP                    101
#define IDS_TITLE                   102
#define IDS_FILE_NOEXIST            103
#define IDS_MHTML_FILTER            104
#define IDS_DIRECTORY_NOEXIST       105
#define IDS_NOCREATE_DIRECTORY      106
#define IDS_BROWSE_DEST             107
#define IDS_MEMORY                  108
#define IDS_GENERAL_ERROR           109
#define IDS_OPEN_FILE               110
#define IDS_LOAD_FAILURE            111
#define IDS_NO_HTML                 112

#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\external\inc\cryptdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptdlg.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTDLG_H__
#define __CRYPTDLG_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef _CRYPTDLG_
#define CRYPTDLGAPI
#else
#define CRYPTDLGAPI DECLSPEC_IMPORT
#endif

#if (_WIN32_WINNT >= 0x0400) || defined(_MAC) || defined(WIN16)

#include <prsht.h>

#ifdef __cplusplus
extern "C" {
#endif

// Master flags to control how revocation is managed

#define CRYTPDLG_FLAGS_MASK                 0xff000000
#define CRYPTDLG_REVOCATION_DEFAULT         0x00000000
#define CRYPTDLG_REVOCATION_ONLINE          0x80000000
#define CRYPTDLG_REVOCATION_CACHE           0x40000000
#define CRYPTDLG_REVOCATION_NONE            0x20000000


// Policy flags which control how we deal with user's certificates

#define CRYPTDLG_POLICY_MASK                0x0000FFFF
#define POLICY_IGNORE_NON_CRITICAL_BC       0x00000001

#define CRYPTDLG_ACTION_MASK                0xFFFF0000
#define ACTION_REVOCATION_DEFAULT_ONLINE    0x00010000
#define ACTION_REVOCATION_DEFAULT_CACHE     0x00020000

//
//  Many of the common dialogs can be passed a filter proc to reduce
//      the set of certificates displayed.  A generic filter proc has been
//      provided to cover many of the generic cases.
//  Return TRUE to display and FALSE to hide

typedef BOOL (WINAPI * PFNCMFILTERPROC)(
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD,   // lCustData, a cookie
        IN DWORD,   // dwFlags
        IN DWORD);  // dwDisplayWell

//  Display Well Values
#define CERT_DISPWELL_SELECT                    1
#define CERT_DISPWELL_TRUST_CA_CERT             2
#define CERT_DISPWELL_TRUST_LEAF_CERT           3
#define CERT_DISPWELL_TRUST_ADD_CA_CERT         4
#define CERT_DISPWELL_TRUST_ADD_LEAF_CERT       5
#define CERT_DISPWELL_DISTRUST_CA_CERT          6
#define CERT_DISPWELL_DISTRUST_LEAF_CERT        7
#define CERT_DISPWELL_DISTRUST_ADD_CA_CERT      8
#define CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT    9

//
typedef UINT (WINAPI * PFNCMHOOKPROC)(
        IN HWND hwndDialog,
        IN UINT message,
        IN WPARAM wParam,
        IN LPARAM lParam);

//
#define CSS_HIDE_PROPERTIES             0x00000001
#define CSS_ENABLEHOOK                  0x00000002
#define CSS_ALLOWMULTISELECT            0x00000004
#define CSS_SHOW_HELP                   0x00000010
#define CSS_ENABLETEMPLATE              0x00000020
#define CSS_ENABLETEMPLATEHANDLE        0x00000040

#define SELCERT_OK                      IDOK
#define SELCERT_CANCEL                  IDCANCEL
#define SELCERT_PROPERTIES              100
#define SELCERT_FINEPRINT               101
#define SELCERT_CERTLIST                102
#define SELCERT_HELP                    IDHELP
#define SELCERT_ISSUED_TO               103
#define SELCERT_VALIDITY                104
#define SELCERT_ALGORITHM               105
#define SELCERT_SERIAL_NUM              106
#define SELCERT_THUMBPRINT              107

typedef struct tagCSSA {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_A, *PCERT_SELECT_STRUCT_A;

typedef struct tagCSSW {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_W, *PCERT_SELECT_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_STRUCT_W CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_W PCERT_SELECT_STRUCT;
#else
typedef CERT_SELECT_STRUCT_A CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_A PCERT_SELECT_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateA(
        IN OUT PCERT_SELECT_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificate CertSelectCertificateA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateW(
        IN OUT PCERT_SELECT_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificate CertSelectCertificateW
#else
#define CertSelectCertificate CertSelectCertificateA
#endif
#endif  // MAC


typedef struct tagCSSA_CUI {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_CRYPTUI_STRUCT_A, *PCERT_SELECT_CRYPTUI_STRUCT_A;

typedef struct tagCSSW_CUI {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_CRYPTUI_STRUCT_W, *PCERT_SELECT_CRYPTUI_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_CRYPTUI_STRUCT_W CERT_SELECT_CRYPTUI_STRUCT;
typedef PCERT_SELECT_CRYPTUI_STRUCT_W PCERT_SELECT_CRYPTUI_STRUCT;
#else
typedef CERT_SELECT_CRYPTUI_STRUCT_A CERT_SELECT_CRYPTUI_STRUCT;
typedef PCERT_SELECT_CRYPTUI_STRUCT_A PCERT_SELECT_CRYPTUI_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateCryptUIA(
        IN OUT PCERT_SELECT_CRYPTUI_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificateCryptUI CertSelectCertificateCryptUIA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateCryptUIW(
        IN OUT PCERT_SELECT_CRYPTUI_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificateCryptUI CertSelectCertificateCryptUIW
#else
#define CertSelectCertificateCryptUI CertSelectCertificateCryptUIA
#endif
#endif  // MAC


/////////////////////////////////////////////////////////////

#define CM_VIEWFLAGS_MASK       0x00ffffff
#define CM_ENABLEHOOK           0x00000001
#define CM_SHOW_HELP            0x00000002
#define CM_SHOW_HELPICON        0x00000004
#define CM_ENABLETEMPLATE       0x00000008
#define CM_HIDE_ADVANCEPAGE     0x00000010
#define CM_HIDE_TRUSTPAGE       0x00000020
#define CM_NO_NAMECHANGE        0x00000040
#define CM_NO_EDITTRUST         0x00000080
#define CM_HIDE_DETAILPAGE      0x00000100
#define CM_ADD_CERT_STORES      0x00000200
#define CERTVIEW_CRYPTUI_LPARAM 0x00800000

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_A, *PCERT_VIEWPROPERTIES_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_W, *PCERT_VIEWPROPERTIES_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIES_STRUCT_W CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_W PCERT_VIEWPROPERTIES_STRUCT;
#else
typedef CERT_VIEWPROPERTIES_STRUCT_A CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_A PCERT_VIEWPROPERTIES_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesA(
        PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewProperties CertViewPropertiesA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesW(
        PCERT_VIEWPROPERTIES_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewProperties CertViewPropertiesW
#else
#define CertViewProperties CertViewPropertiesA
#endif
#endif  // MAC


typedef struct tagCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIESCRYPTUI_STRUCT_A, *PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIESCRYPTUI_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIESCRYPTUI_STRUCT_W, *PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIESCRYPTUI_STRUCT_W CERT_VIEWPROPERTIESCRYPTUI_STRUCT;
typedef PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_W PCERT_VIEWPROPERTIESCRYPTUI_STRUCT;
#else
typedef CERT_VIEWPROPERTIESCRYPTUI_STRUCT_A CERT_VIEWPROPERTIESCRYPTUI_STRUCT;
typedef PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A PCERT_VIEWPROPERTIESCRYPTUI_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesCryptUIA(
        PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewPropertiesCryptUI CertViewPropertiesCryptUIA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesCryptUIW(
        PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewPropertiesCryptUI CertViewPropertiesCryptUIW
#else
#define CertViewPropertiesCryptUI CertViewPropertiesCryptUIA
#endif
#endif  // MAC



//
//  We provide a default filter function that people can use to do some
//      of the most simple things.
//

#define CERT_FILTER_OP_EXISTS           1
#define CERT_FILTER_OP_NOT_EXISTS       2
#define CERT_FILTER_OP_EQUALITY         3

typedef struct tagCMOID {
    LPCSTR              szExtensionOID;         // Extension to filter on
    DWORD               dwTestOperation;
    LPBYTE              pbTestData;
    DWORD               cbTestData;
} CERT_FILTER_EXTENSION_MATCH;

#define CERT_FILTER_INCLUDE_V1_CERTS    0x0001
#define CERT_FILTER_VALID_TIME_RANGE    0x0002
#define CERT_FILTER_VALID_SIGNATURE     0x0004
#define CERT_FILTER_LEAF_CERTS_ONLY     0x0008
#define CERT_FILTER_ISSUER_CERTS_ONLY   0x0010
#define CERT_FILTER_KEY_EXISTS          0x0020

typedef struct tagCMFLTR {
    DWORD               dwSize;
    DWORD               cExtensionChecks;
    CERT_FILTER_EXTENSION_MATCH * arrayExtensionChecks;
    DWORD               dwCheckingFlags;
} CERT_FILTER_DATA;

//
//  Maybe this should not be here -- but until it goes into wincrypt.h
//

//
//   Get a formatted friendly name for a certificate

CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pchBuffer,
                             DWORD cchBuffer);
CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pchBuffer,
                              DWORD cchBuffer);
#ifdef UNICODE
#define GetFriendlyNameOfCert GetFriendlyNameOfCertW
#else
#define GetFriendlyNameOfCert GetFriendlyNameOfCertA
#endif


//
//  We also provide a WinTrust provider which performs the same set of
//      parameter checking that we do in order to validate certificates.
//

#define CERT_CERTIFICATE_ACTION_VERIFY  \
  { /* 7801ebd0-cf4b-11d0-851f-0060979387ea */  \
    0x7801ebd0, \
    0xcf4b,     \
    0x11d0,     \
    {0x85, 0x1f, 0x00, 0x60, 0x97, 0x93, 0x87, 0xea} \
  }

#define szCERT_CERTIFICATE_ACTION_VERIFY    \
    "{7801ebd0-cf4b-11d0-851f-0060979387ea}"  
    
typedef HRESULT (WINAPI * PFNTRUSTHELPER)(
        IN PCCERT_CONTEXT       pCertContext,
        IN DWORD                lCustData,
        IN BOOL                 fLeafCertificate,
        IN LPBYTE               pbTrustBlob);
//
//  Failure Reasons:
//

#define CERT_VALIDITY_BEFORE_START              0x00000001
#define CERT_VALIDITY_AFTER_END                 0x00000002
#define CERT_VALIDITY_SIGNATURE_FAILS           0x00000004
#define CERT_VALIDITY_CERTIFICATE_REVOKED       0x00000008
#define CERT_VALIDITY_KEY_USAGE_EXT_FAILURE     0x00000010
#define CERT_VALIDITY_EXTENDED_USAGE_FAILURE    0x00000020
#define CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE  0x00000040
#define CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION 0x00000080
#define CERT_VALIDITY_ISSUER_INVALID            0x00000100
#define CERT_VALIDITY_OTHER_EXTENSION_FAILURE   0x00000200
#define CERT_VALIDITY_PERIOD_NESTING_FAILURE    0x00000400
#define CERT_VALIDITY_OTHER_ERROR               0x00000800
#define CERT_VALIDITY_ISSUER_DISTRUST           0x02000000
#define CERT_VALIDITY_EXPLICITLY_DISTRUSTED     0x01000000
#define CERT_VALIDITY_NO_ISSUER_CERT_FOUND      0x10000000
#define CERT_VALIDITY_NO_CRL_FOUND              0x20000000
#define CERT_VALIDITY_CRL_OUT_OF_DATE           0x40000000
#define CERT_VALIDITY_NO_TRUST_DATA             0x80000000
#define CERT_VALIDITY_MASK_TRUST                0xffff0000
#define CERT_VALIDITY_MASK_VALIDITY             0x0000ffff

#define CERT_TRUST_DO_FULL_SEARCH               0x00000001
#define CERT_TRUST_PERMIT_MISSING_CRLS          0x00000002
#define CERT_TRUST_DO_FULL_TRUST                0x00000005
#define CERT_TRUST_ADD_CERT_STORES              CM_ADD_CERT_STORES

//
//  Trust data structure
//
//      Returned data arrays will be allocated using LocalAlloc and must
//      be freed by the caller.  The data in the TrustInfo array are individually
//      allocated and must be freed.  The data in rgChain must be freed by
//      calling CertFreeCertificateContext.
//
//  Defaults:
//      pszUsageOid == NULL     indicates that no trust validation should be done
//      cRootStores == 0        Will default to User's Root store
//      cStores == 0            Will default to User's CA and system's SPC stores
//      cTrustStores == 0       Will default to User's TRUST store
//      hprov == NULL           Will default to RSABase
//      any returned item which has a null pointer will not return that item.
//  Notes:
//      pfnTrustHelper is nyi

typedef struct _CERT_VERIFY_CERTIFICATE_TRUST {
    DWORD               cbSize;         // Size of this structure
    PCCERT_CONTEXT      pccert;         // Certificate to be verified
    DWORD               dwFlags;        // CERT_TRUST_*
    DWORD               dwIgnoreErr;    // Errors to ignore (CERT_VALIDITY_*)
    DWORD *             pdwErrors;      // Location to return error flags
    LPSTR               pszUsageOid;    // Extended Usage OID for Certificate
    HCRYPTPROV          hprov;          // Crypt Provider to use for validation
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    DWORD               lCustData;      //
    PFNTRUSTHELPER      pfnTrustHelper; // Callback function for cert validation
    DWORD *             pcChain;        // Count of items in the chain array
    PCCERT_CONTEXT **   prgChain;       // Chain of certificates used
    DWORD **            prgdwErrors;    // Errors on a per certificate basis
    DATA_BLOB **        prgpbTrustInfo; // Array of trust information used
} CERT_VERIFY_CERTIFICATE_TRUST, * PCERT_VERIFY_CERTIFICATE_TRUST;

//
//  Trust list manipulation routine
//
//  CertModifyCertificatesToTrust can be used to do modifications to the set of certificates
//      on trust lists for a given purpose.
//      if hcertstoreTrust is NULL, the System Store TRUST in Current User will be used
//      if pccertSigner is specified, it will be used to sign the resulting trust lists,
//              it also restricts the set of trust lists that may be modified.
//

#define CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED      1
#define CTL_MODIFY_REQUEST_REMOVE               2
#define CTL_MODIFY_REQUEST_ADD_TRUSTED          3

typedef struct _CTL_MODIFY_REQUEST {
    PCCERT_CONTEXT      pccert;         // Certificate to change trust on
    DWORD               dwOperation;    // Operation to be performed
    DWORD               dwError;        // Operation error code
} CTL_MODIFY_REQUEST, * PCTL_MODIFY_REQUEST;

CRYPTDLGAPI
HRESULT
WINAPI
CertModifyCertificatesToTrust(
        int cCerts,                     // Count of modifications to be done
        PCTL_MODIFY_REQUEST rgCerts,    // Array of modification requests
        LPCSTR szPurpose,               // Purpose OID to for modifications
        HWND hwnd,                      // HWND for any dialogs
        HCERTSTORE hcertstoreTrust,     // Cert Store to store trust information in
        PCCERT_CONTEXT pccertSigner);   // Certificate to be used in signing trust list

#ifdef WIN16
// Need to define export functions in WATCOM.
BOOL
WINAPI CertConfigureTrustA(void);

BOOL
WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/,
    DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/,
    const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/,
    void * pbFormat,
    DWORD * pcbFormat);
#endif // !WIN16

#define malloc(_cb)         GlobalAlloc(GMEM_FIXED, _cb)
#define realloc(_pb, _cb)   GlobalReAlloc(_pb, _cb, 0)
#define free(_pb)           GlobalFree(_pb)

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // (_WIN32_WINNT >= 0x0400)

#endif // _CRYPTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\exploder\exploder.cpp ===
// --------------------------------------------------------------------------------
// Exploder.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "resource.h"

// --------------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------------
#define CCHMAX_RES              1024
#define CCHMAX_PATH_EXPLODER    1024

// --------------------------------------------------------------------------------
// String Consts
// --------------------------------------------------------------------------------
static const char c_szRegCmd[]      = "/reg";
static const char c_szUnRegCmd[]    = "/unreg";
static const char c_szReg[]         = "Reg";
static const char c_szUnReg[]       = "UnReg";
static const char c_szAdvPackDll[]  = "ADVPACK.DLL";
static const char c_szSource[]      = "/SOURCE:";
static const char c_szDest[]        = "/DEST:";

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
HINSTANCE       g_hInst=NULL;
CHAR            g_szTitle[CCHMAX_RES];
IMalloc        *g_pMalloc=NULL;

// --------------------------------------------------------------------------------
// BODYFILEINFO
// --------------------------------------------------------------------------------
typedef struct tagBODYFILEINFO {
    HBODY           hBody;
    LPSTR           pszCntId;
    LPSTR           pszCntLoc;
    LPSTR           pszFileName;
    LPSTR           pszFilePath;
    BYTE            fIsHtml;
    IStream        *pStmFile;
} BODYFILEINFO, *LPBODYFILEINFO;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT CallRegInstall(LPCSTR szSection);
HRESULT ReplaceContentIds(LPSTREAM pStmHtml, LPBODYFILEINFO prgBody, DWORD cBodies);
int     WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow);
HRESULT MimeOleExplodeMhtmlFile(LPCSTR pszSrcFile, LPSTR pszDstDir, INT *pnError);

// --------------------------------------------------------------------------------
// IF_FAILEXIT_ERROR
// --------------------------------------------------------------------------------
#define IF_FAILEXIT_ERROR(_nError, hrExp) \
    if (FAILED(hrExp)) { \
        TraceResult(hr); \
        *pnError = _nError; \
        goto exit; \
    } else

// --------------------------------------------------------------------------------
// ModuleEntry - Stolen from the CRT, used to shirink our code
// --------------------------------------------------------------------------------
int _stdcall ModuleEntry(void)
{
    // Locals
    int             i;
    STARTUPINFOA    si;
    LPTSTR          pszCmdLine;

    // Get Malloc
    CoGetMalloc(1, &g_pMalloc);

    // Get the command line
    pszCmdLine = GetCommandLine();

    // We don't want the "No disk in drive X:" requesters, so we set the critical error mask such that calls will just silently fail
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Parse the command line
    if (*pszCmdLine == TEXT('\"')) 
    {
        // Scan, and skip over, subsequent characters until another double-quote or a null is encountered.
        while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')))
            {};

        // If we stopped on a double-quote (usual case), skip over it.
        if (*pszCmdLine == TEXT('\"'))
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    // Skip past any white space preceeding the second token.
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) 
        pszCmdLine++;

    // Register
    if (0 == lstrcmpi(c_szRegCmd, pszCmdLine))
    {
        CallRegInstall(c_szReg);
        goto exit;
    }

    // Unregister
    else if (0 == lstrcmpi(c_szUnRegCmd, pszCmdLine))
    {
        CallRegInstall(c_szUnReg);
        goto exit;
    }

    // Get startup information...
    si.dwFlags = 0;
    GetStartupInfoA(&si);

    // Call the real winmain
    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine, si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

exit:
    // Cleanup
    SafeRelease(g_pMalloc);

    // Since we now have a way for an extension to tell us when it is finished, we will terminate all processes when the main thread goes away.
    ExitProcess(i);

    // Done
    return i;
}

// --------------------------------------------------------------------------------
// WinMainT
// --------------------------------------------------------------------------------
int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow)
{
    // Locals
    HRESULT         hr;
    CHAR            szRes[CCHMAX_RES];
    CHAR            szSource[CCHMAX_PATH_EXPLODER];
    CHAR            szDest[CCHMAX_PATH_EXPLODER];
    LPSTR           pszT;
    DWORD           i;
    INT             nError;

    // Message
    LoadString(hInst, IDS_TITLE, g_szTitle, ARRAYSIZE(g_szTitle));

    // Message
    LoadString(hInst, IDS_HELP, szRes, ARRAYSIZE(szRes));

    // If Command Line is Empty...
    if (NULL == pszCmdLine || StrStrA(pszCmdLine, szRes) || *pszCmdLine == '?' || lstrcmpi("\\?", pszCmdLine) == 0)
    {
        // Message
        LoadString(hInst, IDS_CMDLINE_FORMAT, szRes, ARRAYSIZE(szRes));

        // Message
        MessageBox(NULL, szRes, g_szTitle, MB_OK | MB_ICONINFORMATION);

        // Done
        goto exit;
    }

    // Null Out Source and Dest
    *szSource = '\0';
    *szDest = '\0';

    // If pszCmdLine specifies a specific, existing file...
    if (PathFileExists(pszCmdLine))
    {
        // Copy To source
        lstrcpyn(szSource, pszCmdLine, ARRAYSIZE(szSource));

        // Pick a Temporary Location to store the thicket
        GetTempPath(ARRAYSIZE(szDest), szDest);
    }

    // Otherwise, try to get a source
    else
    {
        // Lets Upper Case the Command Line
        CharUpper(pszCmdLine);

        // Try to locate /SOURCE:
        pszT = StrStrA(pszCmdLine, c_szSource);

        // If we found /SOURCE, then read the contents...
        if (pszT)
        {
            // Step over /SOURCE:
            pszT += lstrlen(c_szSource);

            // Initialize
            i = 0;

            // Read into szSource, until I hit a / or end of string...
            while ('\0' != *pszT && '/' != *pszT && i < CCHMAX_PATH_EXPLODER)
                szSource[i++] = *pszT++;

            // Pound in a Null
            szSource[i] = '\0';

            // Strip Leading and Trailing Whitespace
            UlStripWhitespace(szSource, TRUE, TRUE, NULL);

            // See if file exists
            if (FALSE == PathFileExists(szSource))
            {
                // Locals
                CHAR szError[CCHMAX_RES + CCHMAX_PATH_EXPLODER];

                // Message
                LoadString(hInst, IDS_FILE_NOEXIST, szRes, ARRAYSIZE(szRes));

                // Format the error message
                wsprintf(szError, szRes, szSource);

                // Message
                INT nAnswer = MessageBox(NULL, szError, g_szTitle, MB_YESNO | MB_ICONEXCLAMATION );

                // Done
                if (IDNO == nAnswer)
                    goto exit;

                // Otherwise, clear szSource
                *szSource = '\0';
            }
        }

        // No Source File, lets browser for one
        if (FIsEmptyA(szSource))
        {
            // Locals
            OPENFILENAME    ofn;            
            CHAR            rgszFilter[CCHMAX_PATH_EXPLODER];
            CHAR            szDir[MAX_PATH];

            // Copy in the source of exploder.exe
            GetModuleFileName(hInst, szDir, ARRAYSIZE(szDir));

            // Initialize szDest
            PathRemoveFileSpecA(szDir);

            // Initialize ofn
            ZeroMemory(&ofn, sizeof(OPENFILENAME));

            // Initialize the STring
            *szSource ='\0';

            // Load the MHTML File Filter
            LoadString(hInst, IDS_MHTML_FILTER, rgszFilter, ARRAYSIZE(rgszFilter));

            // Fixup the String
            ReplaceChars(rgszFilter, '|', '\0');

            // Initialize the Open File Structure
            ofn.lStructSize     = sizeof(OPENFILENAME);
            ofn.hwndOwner       = NULL;
            ofn.hInstance       = hInst;
            ofn.lpstrFilter     = rgszFilter;
            ofn.nFilterIndex    = 1;
            ofn.lpstrFile       = szSource;
            ofn.nMaxFile        = CCHMAX_PATH_EXPLODER;
            ofn.lpstrInitialDir = szDir;
            ofn.Flags           = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

            // Get Open File Name
            if (FALSE == GetOpenFileName(&ofn))
                goto exit;
        }
    }

    // Do we have a valid destination...
    if (FALSE == PathIsDirectoryA(szDest))
    {
        // Try to locate /DEST:
        pszT = StrStrA(pszCmdLine, c_szDest);

        // If we found /DEST, then read the contents...
        if (pszT)
        {
            // Step over /DEST:
            pszT += lstrlen(c_szDest);

            // Initialize
            i = 0;

            // Read into szSource, until I hit a / or end of string...
            while ('\0' != *pszT && '/' != *pszT && i < CCHMAX_PATH_EXPLODER)
                szDest[i++] = *pszT++;

            // Pound in a Null
            szDest[i] = '\0';

            // Strip Leading and Trailing Whitespace
            UlStripWhitespace(szDest, TRUE, TRUE, NULL);

            // See if file exists
            if (FALSE == PathIsDirectoryA(szDest))
            {
                // Locals
                CHAR szError[CCHMAX_RES + CCHMAX_PATH_EXPLODER];

                // Message
                LoadString(hInst, IDS_DIRECTORY_NOEXIST, szRes, ARRAYSIZE(szRes));

                // Format the error message
                wsprintf(szError, szRes, szDest);

                // Message
                INT nAnswer = MessageBox(NULL, szError, g_szTitle, MB_YESNO | MB_ICONEXCLAMATION );

                // Done
                if (IDNO == nAnswer)
                    goto exit;

                // Try to create the directory
                if (FALSE == CreateDirectory(szDest, NULL))
                {
                    // Message
                    LoadString(hInst, IDS_NOCREATE_DIRECTORY, szRes, ARRAYSIZE(szRes));

                    // Format the error message
                    wsprintf(szError, szRes, szDest);

                    // Message
                    INT nAnswer = MessageBox(NULL, szError, g_szTitle, MB_YESNO | MB_ICONEXCLAMATION );

                    // Done
                    if (IDNO == nAnswer)
                        goto exit;

                    // Clear *szDest
                    *szDest = '\0';
                }
            }
        }

        // No Source File, lets browser for one
        if (FIsEmptyA(szDest))
        {
            // Copy in the source of exploder.exe
            GetModuleFileName(hInst, szDest, ARRAYSIZE(szDest));

            // Initialize szDest
            PathRemoveFileSpecA(szDest);

            // Failure
            if (FALSE == BrowseForFolder(hInst, NULL, szDest, ARRAYSIZE(szDest), IDS_BROWSE_DEST, TRUE))
                goto exit;

            // Better be a directory
            Assert(PathIsDirectoryA(szDest));
        }
    }

    // Validate the dest and source
    Assert(PathIsDirectoryA(szDest) && PathFileExists(szSource));

    // Explode the file
    nError = 0;
    hr = MimeOleExplodeMhtmlFile(szSource, szDest, &nError);

    // Failure ?
    if (FAILED(hr) || 0 != nError)
    {
        // Locals
        CHAR szError[CCHMAX_RES + CCHMAX_PATH_EXPLODER];

        // Message
        LoadString(hInst, nError, szRes, ARRAYSIZE(szRes));

        // Need to format with file name ?
        if (IDS_OPEN_FILE == nError || IDS_LOAD_FAILURE == nError || IDS_NO_HTML == nError)
        {
            // Format the error message
            wsprintf(szError, szRes, szSource, hr);
        }

        // Otherwise,
        else
        {
            // Format the error message
            wsprintf(szError, szRes, hr);
        }

        // Message
        MessageBox(NULL, szError, g_szTitle, MB_OK | MB_ICONEXCLAMATION);
    }

exit:
    // Done
    return(1);
}

// --------------------------------------------------------------------------------
// MimeOleExplodeMhtmlFile
// --------------------------------------------------------------------------------
HRESULT MimeOleExplodeMhtmlFile(LPCSTR pszSrcFile, LPSTR pszDstDir, INT *pnError)
{
    // Locals
    HRESULT             hr=S_OK;
    IStream            *pStmFile=NULL;
    IMimeMessage       *pMessage=NULL;
    HBODY               hRootHtml=NULL;
    DWORD               cMaxBodies;
    DWORD               cBodies=0;
    FINDBODY            FindBody={0};
    DWORD               cchDstDir;
    DWORD               iRootBody=0xffffffff;
    HBODY               hBody;
    PROPVARIANT         Variant;
    SHELLEXECUTEINFO    ExecuteInfo;
    LPBODYFILEINFO      prgBody=NULL;
    LPBODYFILEINFO      pInfo;
    DWORD               i;
    IMimeBody          *pBody=NULL;

    // Trace
    TraceCall("MimeOleExplodeMhtmlFile");

    // Invalid Args
    if (FALSE == PathIsDirectoryA(pszDstDir) || FALSE == PathFileExists(pszSrcFile) || NULL == pnError)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *pnError = 0;

    // Get DstDir Length
    cchDstDir = lstrlen(pszDstDir);

    // Remove last \\ from pszDstDir
    if (cchDstDir && pszDstDir[cchDstDir - 1] == '\\')
    {
        pszDstDir[cchDstDir - 1] = '\0';
        cchDstDir--;
    }

    // Create a Mime Message
    IF_FAILEXIT_ERROR(IDS_MEMORY, hr = MimeOleCreateMessage(NULL, &pMessage));

    // Initialize the message
    IF_FAILEXIT_ERROR(IDS_GENERAL_ERROR, hr = pMessage->InitNew());

    // Create a stream on the file
    IF_FAILEXIT_ERROR(IDS_OPEN_FILE, hr = OpenFileStream((LPSTR)pszSrcFile, OPEN_EXISTING, GENERIC_READ, &pStmFile));

    // Load the Message
    IF_FAILEXIT_ERROR(IDS_LOAD_FAILURE, hr = pMessage->Load(pStmFile));

    // Invalid Message
    if (MIME_S_INVALID_MESSAGE == hr)
    {
        *pnError = IDS_LOAD_FAILURE;
        goto exit;
    }

    // Count the Bodies
    IF_FAILEXIT(hr = pMessage->CountBodies(NULL, TRUE, &cMaxBodies));

    // Allocate
    IF_FAILEXIT_ERROR(IDS_MEMORY, hr = HrAlloc((LPVOID *)&prgBody, sizeof(BODYFILEINFO) * cMaxBodies));

    // Zero
    ZeroMemory(prgBody, sizeof(BODYFILEINFO) * cMaxBodies);

    // Get the root body...
    IF_FAILEXIT_ERROR(IDS_NO_HTML, hr = pMessage->GetTextBody(TXT_HTML, IET_DECODED, NULL, &hRootHtml));

    // Loop through all the bodies
    hr = pMessage->FindFirst(&FindBody, &hBody);

    // Loop
    while(SUCCEEDED(hr))
    {
        // Must have an hBody
        Assert(hBody);

        // Skip Multipart Bodies
        if (S_FALSE == pMessage->IsContentType(hBody, STR_CNT_MULTIPART, NULL))
        {
            // Is this the root ?
            if (hBody == hRootHtml)
                iRootBody = cBodies;

            // Readability
            pInfo = &prgBody[cBodies];

            // Better not over run prgBody
            pInfo->hBody = hBody;

            // Init the Variant
            Variant.vt = VT_LPSTR;

            // Get the Content Id
            if (SUCCEEDED(pMessage->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTID), 0, &Variant)))
                pInfo->pszCntId = Variant.pszVal;

            // Get the Content Location
            if (SUCCEEDED(pMessage->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTLOC), 0, &Variant)))
                pInfo->pszCntLoc = Variant.pszVal;

            // Generate a filename
            if (SUCCEEDED(pMessage->GetBodyProp(hBody, PIDTOSTR(PID_ATT_GENFNAME), 0, &Variant)))
                pInfo->pszFileName = Variant.pszVal;

            // If its html, lets make sure that the filename has a .html file extension
            pInfo->fIsHtml = (S_OK == pMessage->IsContentType(hBody, STR_CNT_TEXT, STR_SUB_HTML)) ? TRUE : FALSE;

            // Take the filename and build the file path
            Assert(pInfo->pszFileName);

            // Don't Crash
            if (NULL == pInfo->pszFileName)
            {
                hr = TraceResult(E_UNEXPECTED);
                goto exit;
            }

            // Validate Extension
            if (pInfo->fIsHtml)
            {
                // Get Extension
                LPSTR pszExt = PathFindExtensionA(pInfo->pszFileName);

                // If Null or not .html..
                if (NULL == pszExt || lstrcmpi(pszExt, ".html") != 0)
                {
                    // Re-allocate pInfo->pszFileName...
                    IF_FAILEXIT_ERROR(IDS_MEMORY, hr = HrRealloc((LPVOID *)&pInfo->pszFileName, lstrlen(pInfo->pszFileName) + 10));

                    // Rename the Extension
                    PathRenameExtensionA(pInfo->pszFileName, ".html");
                }
            }

            // Build that full file path
            IF_FAILEXIT_ERROR(IDS_MEMORY, hr = HrAlloc((LPVOID *)&pInfo->pszFilePath, lstrlen(pszDstDir) + lstrlen(pInfo->pszFileName) + 10));

            // Formath the filepath
            wsprintf(pInfo->pszFilePath, "%s\\%s", pszDstDir, pInfo->pszFileName);

            // Save the body to the file
            IF_FAILEXIT(hr = pMessage->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

            // Save to the file
            IF_FAILEXIT(hr = pBody->SaveToFile(IET_DECODED, pInfo->pszFilePath));

            // Open a file stream
            if (pInfo->fIsHtml)
            {
                // Open it if its html
                IF_FAILEXIT(hr = OpenFileStream(pInfo->pszFilePath, OPEN_ALWAYS, GENERIC_READ | GENERIC_WRITE, &pInfo->pStmFile));
            }

            // Increment cBodies
            cBodies++;
        }

        // Loop through all the bodies
        hr = pMessage->FindNext(&FindBody, &hBody);
    }

    // Reset hr
    hr = S_OK;

    // Root Body was not found
    Assert(iRootBody != 0xffffffff);

    // Bad News
    if (0xffffffff == iRootBody)
    {
        hr = TraceResult(E_UNEXPECTED);
        goto exit;
    }

    // Walk through and fixup all HTML files and close all streams
    for (i=0; i<cBodies; i++)
    {
        // Readability
        pInfo = &prgBody[i];

        // If HTML...
        if (pInfo->fIsHtml)
        {
            // Better have an open stream
            Assert(pInfo->pStmFile);

            // Failure
            if (NULL == pInfo->pStmFile)
            {
                hr = TraceResult(E_UNEXPECTED);
                goto exit;
            }

            // Replace all the CID references with file references...
            ReplaceContentIds(pInfo->pStmFile, prgBody, cBodies);
        }

        // Release this stream
        SafeRelease(pInfo->pStmFile);
    }

    // Launch the Currently Registered HTML Editor ontop of iRootBody pszFilePath
    ZeroMemory(&ExecuteInfo, sizeof(SHELLEXECUTEINFO));
    ExecuteInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    ExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFO);
    ExecuteInfo.lpVerb = "Edit";
    ExecuteInfo.lpFile = prgBody[iRootBody].pszFilePath;
    ExecuteInfo.lpParameters = NULL;
    ExecuteInfo.lpDirectory = pszDstDir;
    ExecuteInfo.nShow = SW_SHOWNORMAL;

    // Compress szBlobFile
    ShellExecuteEx(&ExecuteInfo);

exit:
    // General Error
    if (FAILED(hr) && 0 == *pnError)
        *pnError = IDS_GENERAL_ERROR;

    // Free prgBody
    if (prgBody)
    {
        // Loop
        for (i=0; i<cBodies; i++)
        {
            SafeMemFree(prgBody[i].pszCntId);
            SafeMemFree(prgBody[i].pszCntLoc);
            SafeMemFree(prgBody[i].pszFileName);
            SafeMemFree(prgBody[i].pszFilePath);
            SafeRelease(prgBody[i].pStmFile);
        }

        // Free the Array
        CoTaskMemFree(prgBody);
    }

    // Cleanup
    SafeRelease(pStmFile);
    SafeRelease(pBody);
    SafeRelease(pMessage);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// ReplaceContentIds
// --------------------------------------------------------------------------------
HRESULT ReplaceContentIds(LPSTREAM pStmHtml, LPBODYFILEINFO prgBody, DWORD cBodies)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cb;
    LPSTR           pszFound;
    LPSTR           pszT;
    LPSTR           pszHtml=NULL;
    LPSTR           pszCntId=NULL;
    DWORD           i;
    DWORD           cchCntId;
    ULARGE_INTEGER  uliSize;

    // Trac
    TraceCall("ReplaceContentIds");

    // Invalid Args
    Assert(pStmHtml && prgBody && cBodies);

    // Loop through the bodies
    for (i=0; i<cBodies; i++)
    {
        // No Content-ID here...
        if (NULL == prgBody[i].pszCntId)
            continue;

        // Better have a filename
        Assert(prgBody[i].pszFileName);

        // Load the stream into memory...
        IF_FAILEXIT(hr = HrGetStreamSize(pStmHtml, &cb));

        // Allocate Memory
        IF_FAILEXIT(hr = HrAlloc((LPVOID *)&pszHtml, cb + 1));

        // Rewind
        IF_FAILEXIT(hr = HrRewindStream(pStmHtml));

        // Read the Stream
        IF_FAILEXIT(hr = pStmHtml->Read(pszHtml, cb, NULL));

        // Stuff Null terminator
        pszHtml[cb] = '\0';

        // Kill pStmHtml
        uliSize.QuadPart = 0;
        IF_FAILEXIT(hr = pStmHtml->SetSize(uliSize));

        // Allocate Memory
        IF_FAILEXIT(hr = HrAlloc((LPVOID *)&pszCntId, lstrlen(prgBody[i].pszCntId) + lstrlen("cid:") + 5));

        // Format
        pszT = prgBody[i].pszCntId;
        if (*pszT == '<')
            pszT++;
        wsprintf(pszCntId, "cid:%s", pszT);

        // Remove trailing >
        cchCntId = lstrlen(pszCntId);
        if (pszCntId[cchCntId - 1] == '>')
            pszCntId[cchCntId - 1] = '\0';

        // Set pszT
        pszT = pszHtml;

        // Begin replace loop
        while(1)
        {
            // Find pszCntId
            pszFound = StrStrA(pszT, pszCntId);

            // Done
            if (NULL == pszFound)
            {
                // Write from pszT to pszFound
                IF_FAILEXIT(hr = pStmHtml->Write(pszT, (pszHtml + cb) - pszT, NULL));

                // Done
                break;
            }

            // Write from pszT to pszFound
            IF_FAILEXIT(hr = pStmHtml->Write(pszT, pszFound - pszT, NULL));

            // Write 
            IF_FAILEXIT(hr = pStmHtml->Write(prgBody[i].pszFileName, lstrlen(prgBody[i].pszFileName), NULL));

            // Set pszT
            pszT = pszFound + lstrlen(pszCntId);
        }

        // Commit
        IF_FAILEXIT(hr = pStmHtml->Commit(STGC_DEFAULT));

        // Cleanup
        SafeMemFree(pszHtml);
        SafeMemFree(pszCntId);
    }

exit:
    // Cleanup
    SafeMemFree(pszHtml);
    SafeMemFree(pszCntId);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CallRegInstall
// --------------------------------------------------------------------------------
HRESULT CallRegInstall(LPCSTR szSection)
{
    int         cch;
    HRESULT     hr;
    HINSTANCE   hAdvPack, hinst;
    REGINSTALL  pfnri;
    char        szExploderDll[CCHMAX_PATH_EXPLODER], szDir[CCHMAX_PATH_EXPLODER];
    STRENTRY    seReg[2];
    STRTABLE    stReg;
    char        c_szExploder[] = "EXPLODER";
    char        c_szExploderDir[] = "EXPLODER_DIR";


    hr = E_FAIL;

    hinst = GetModuleHandle(NULL);

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (hAdvPack != NULL)
        {
        // Get Proc Address for registration util
        pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnri != NULL)
            {
            stReg.cEntries = 0;
            stReg.pse = seReg;

            GetModuleFileName(hinst, szExploderDll, ARRAYSIZE(szExploderDll));
            seReg[stReg.cEntries].pszName = c_szExploder;
            seReg[stReg.cEntries].pszValue = szExploderDll;
            stReg.cEntries++;

            lstrcpy(szDir, szExploderDll);
            cch = lstrlen(szDir);
            for ( ; cch > 0; cch--)
                {
                if (szDir[cch] == '\\')
                    {
                    szDir[cch] = 0;
                    break;
                    }
                }
            seReg[stReg.cEntries].pszName = c_szExploderDir;
            seReg[stReg.cEntries].pszValue = szDir;
            stReg.cEntries++;

            // Call the self-reg routine
            hr = pfnri(hinst, szSection, &stReg);
            }

        FreeLibrary(hAdvPack);
        }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDBCS_DIVIDE -D_WIN32_OE=0x0500

WIN32_IE_VERSION=0x0300

INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(BASEDIR)\public\sdk\inc; \
    $(ATHROOT)\inc; \
    $(ATHROOT)\mailnews\extinc; \
    $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1
#ifndef WIN16
PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch
#else
PRECOMPILED_OPTION=/fh=$R\inc\$(_OBJ_DIR)\*\pch.pch
#endif
PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\external\inc\lid.h ===
/*------------------------------------------------------------
    lid.h - Unified language id file

	1/10/97	dougp	created
	1/30/97	dougp	added Farsi
        4/15/97 dougp	add Basque, SLovenian, Latvian, Lithuanian, Romainian, Bulgarian
	9/ 2/97 DougP	add Ukranian, Greek, Estonian
	9/12/97 DougP	add Gallego	

    Note:  The Natural Language Group maintains this file.
	Please contact us with change requests.
------------------------------------------------------------*/

#if !defined(LID_H)
#define LID_H

#ifndef LID
typedef unsigned short    LID;      /* two byte language identifier code */
#endif

/* IPG two byte language id's.  Returned in LID field. */
#define lidAmerican         0x0409  /* "AM" American English   */
#define lidAustralian       0x0c09  /* "EA" English Australian */
#define lidBritish          0x0809  /* "BR" English            */
#define lidEnglishCanadian  0x1009  /* "EC" English Canadian   */
#define lidCatalan          0x0403  /* "CT" Catalan            */
#define lidDanish           0x0406  /* "DA" Danish             */
#define lidDutch            0x0413  /* "NL" Dutch              */
#define lidDutchPreferred   0x0013  /* "NL" Dutch Preferred    */
#define lidFinnish          0x040b  /* "FI" Finish             */
#define lidFrench           0x040c  /* "FR" French             */
#define lidFrenchCanadian   0x0c0c  /* "FC" French Canadian    */
#define lidGerman           0x0407  /* "GE" German             */
#define lidSwissGerman      0x0807  /* "GS" German Swiss       */
#define lidItalian          0x0410  /* "IT" Italian            */
#define lidNorskBokmal      0x0414  /* "NO" Norwegian Bokmal   */
#define lidNorskNynorsk     0x0814  /* "NN" Norwegian Nynorsk  */
#define lidPortBrazil       0x0416  /* "PB" Portuguese Brazil  */
#define lidPortIberian      0x0816  /* "PT" Portuguese Iberian */
#define lidSpanish          0x040a  /* "SP" Spanish            */
#define lidSwedish          0x041d  /* "SW" Swedish            */
#define lidRussian          0x0419  /* "RU" Russian            */
#define lidCzech            0x0405  /* "CZ" Czech              */
#define lidHungarian        0x040e  /* "HU" Hungarian          */
#define lidPolish           0x0415  /* "PL" Polish             */
#define lidTurkish          0x041f  /* "TR" Turkish            */
#define	lidFarsi	    0x0429

#define lidBasque	    0x042d  /* "EU" Basque/Euskara     */ 
#define lidSlovenian	    0x0424  /*	Slovene - Slovenia	*/
#define lidLatvian	    0x0426  /*	Latvian - Latvia - Latvia */
#define lidLithuanian	    0x0427  /*	Lithuanian - Lithuania */
#define lidRomanian 	    0x0418  /*	Romanian - Romania */
#define lidRomanianMoldavia 0x0818  /*	Romanian - Moldavia */
#define lidBulgarian 	    0x0402  /*	Bulgarian - Bulgaria */


/* African languages */
#define lidSutu             0x0430  /* "ST" Sutu               */
#define lidTsonga           0x0431  /* "TS" Tsonga             */
#define lidTswana           0x0432  /* "TN" Tswana             */
#define lidVenda            0x0433  /* "VE" Venda			   */
#define lidXhosa            0x0434  /* "XH" Xhosa              */
#define lidZulu             0x0435  /* "ZU" Zulu               */

#define lidAfrikaans        0x0436  /* "AF" Afrikaans          */

#define lidKoreanExtWansung	0x0412	/* Korean(Extended Wansung) - Korea */
#define lidKoreanJohab		0x0812	/* Korean(Johab) - Korea */

#define	lidUkranian	0x0422	/* Ukrainian - Ukraine */
#define	lidGreek	0x0408	/* Greek */
#define	lidEstonian	0x0425	/* Estonian */
#define	lidGalician	0x0456	/* Gallego */

/* These are currently not used, but added for future support. */
#define lidArabic           0x0401
#define lidHebrew           0x040d
#define lidJapanese         0x0411
#define lidLatin            0x041a /* Croato-Serbian (Latin)   */
#define lidCyrillic         0x081a /* Serbo-Croatian (Cyrillic) */
#define lidSlovak           0x041b

#define LID_UNKNOWN         0xffff
#if !defined(lidUnknown)
#	define lidUnknown		0xffff
#endif

#endif /* LID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\external\inc\cryptui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptui.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTUI_H__
#define __CRYPTUI_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <prsht.h>
#include <wintrust.h>

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(8)


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the functions which return property sheet pages take this callback as one of the parameters in
//  the input structure.  it is then called when each page is about to be created and when each page
//  is about to be destroyed.  the messages are PSPCB_CREATE when a page is about to be created and
//  PSPCB_RELEASE when a page is about to be destroyed.  the pvCallbackData parameter in the callback
//  is the pvoid that was passed in with the callback in the input structure.
typedef BOOL (WINAPI * PFNCPROPPAGECALLBACK)(
        HWND        hWndPropPage,
        UINT        uMsg,
        void        *pvCallbackData);


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below       (OPTIONAL)
// szTitle                         title for the window                                     (OPTIONAL)
// pCertContext                    the cert context that is to be displayed
// rgszPurposes                    array of purposes that this cert is to be validated for  (OPTIONAL)
// cPurposes                       number of purposes                                       (OPTIONAL)
// pCryptProviderData/hWVTStateData if WinVerifyTrust has already been called for the cert  (OPTIONAL)
//                                 then pass in a pointer to the state struct that was
//                                 acquired through a call to WTHelperProvDataFromStateData(),
//                                 or pass in the hWVTStateData of the WINTRUST_DATA struct
//                                 if WTHelperProvDataFromStateData() was not called.
//                                 if pCryptProviderData/hWVTStateData is used then
//                                 fpCryptProviderDataTrustedUsage, idxSigner, idxCert, and
//                                 fCounterSignature must be set
// fpCryptProviderDataTrustedUsage if WinVerifyTrust was called this is the result of whether (OPTIONAL)
//                                 the cert was trusted
// idxSigner                       the index of the signer to view                          (OPTIONAL)
// idxCert                         the index of the cert that is being viewed within the    (OPTIONAL)
//                                 signer chain.  the cert context of this cert MUST match
//                                 pCertContext
// fCounterSigner                  set to TRUE if a counter signature is being viewed.  if  (OPTIONAL)
//                                 this is TRUE then idxCounterSigner must be valid
// idxCounterSigner                the index of the counter signer to view                  (OPTIONAL)
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain
// cPropSheetPages                 number of extra pages to add to the dialog.              (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog.                        (OPTIONAL)
//                                 each page in this array will NOT recieve the lParam in
//                                 the PROPSHEET structure as the lParam in the
//                                 WM_INITDIALOG, instead it will receive a pointer to a
//                                 CRYPTUI_INITDIALOG_STRUCT (defined below) which contains
//                                 the lParam in the PROPSSHEET structure AND the
//                                 PCCERT_CONTEXT for which the page is being displayed.
// nStartPage                      this is the index of the initial page that will be
//                                 displayed.  if the upper most bit (0x8000) is set then
//                                 the index is assumed to index rgPropSheetPages
//                                 (after the upper most bit has been stripped off.  eg.
//                                 0x8000 will indicate the first page in rgPropSheetPages),
//                                 if the upper most bit is 0 then nStartPage will be the
//                                 starting index of the default certificate dialog pages.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_HIERARCHYPAGE       0x00000001
#define CRYPTUI_HIDE_DETAILPAGE          0x00000002
#define CRYPTUI_DISABLE_EDITPROPERTIES   0x00000004
#define CRYPTUI_ENABLE_EDITPROPERTIES    0x00000008
#define CRYPTUI_DISABLE_ADDTOSTORE       0x00000010
#define CRYPTUI_ENABLE_ADDTOSTORE        0x00000020
#define CRYPTUI_ACCEPT_DECLINE_STYLE     0x00000040
#define CRYPTUI_IGNORE_UNTRUSTED_ROOT    0x00000080  
#define CRYPTUI_DONT_OPEN_STORES         0x00000100
#define CRYPTUI_ONLY_OPEN_ROOT_STORE     0x00000200
#define CRYPTUI_WARN_UNTRUSTED_ROOT      0x00000400  // For use with viewing of certificates on remote 
                                                     // machines only.  If this flag is used rghStores[0] 
                                                     // must be the handle of the root store on the remote machine.

typedef struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTW {
    DWORD                       dwSize;
    HWND                        hwndParent;                     // OPTIONAL
    DWORD                       dwFlags;                        // OPTIONAL
    LPCWSTR                     szTitle;                        // OPTIONAL
    PCCERT_CONTEXT              pCertContext;
    LPCSTR *                    rgszPurposes;                   // OPTIONAL
    DWORD                       cPurposes;                      // OPTIONAL
    union
    {
        CRYPT_PROVIDER_DATA const * pCryptProviderData;         // OPTIONAL
        HANDLE                      hWVTStateData;              // OPTIONAL
    };
    BOOL                        fpCryptProviderDataTrustedUsage;// OPTIONAL
    DWORD                       idxSigner;                      // OPTIONAL
    DWORD                       idxCert;                        // OPTIONAL
    BOOL                        fCounterSigner;                 // OPTIONAL
    DWORD                       idxCounterSigner;               // OPTIONAL
    DWORD                       cStores;                        // OPTIONAL
    HCERTSTORE *                rghStores;                      // OPTIONAL
    DWORD                       cPropSheetPages;                // OPTIONAL
    LPCPROPSHEETPAGEW           rgPropSheetPages;               // OPTIONAL
    DWORD                       nStartPage;
} CRYPTUI_VIEWCERTIFICATE_STRUCTW, *PCRYPTUI_VIEWCERTIFICATE_STRUCTW;
typedef const CRYPTUI_VIEWCERTIFICATE_STRUCTW *PCCRYPTUI_VIEWCERTIFICATE_STRUCTW;


typedef struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTA {
    DWORD                       dwSize;
    HWND                        hwndParent;                     // OPTIONAL
    DWORD                       dwFlags;                        // OPTIONAL
    LPCSTR                      szTitle;                        // OPTIONAL
    PCCERT_CONTEXT              pCertContext;
    LPCSTR *                    rgszPurposes;                   // OPTIONAL
    DWORD                       cPurposes;                      // OPTIONAL
    union
    {
        CRYPT_PROVIDER_DATA const * pCryptProviderData;         // OPTIONAL
        HANDLE                      hWVTStateData;              // OPTIONAL
    };
    BOOL                        fpCryptProviderDataTrustedUsage;// OPTIONAL
    DWORD                       idxSigner;                      // OPTIONAL
    DWORD                       idxCert;                        // OPTIONAL
    BOOL                        fCounterSigner;                 // OPTIONAL
    DWORD                       idxCounterSigner;               // OPTIONAL
    DWORD                       cStores;                        // OPTIONAL
    HCERTSTORE *                rghStores;                      // OPTIONAL
    DWORD                       cPropSheetPages;                // OPTIONAL
    LPCPROPSHEETPAGEA           rgPropSheetPages;               // OPTIONAL
    DWORD                       nStartPage;
} CRYPTUI_VIEWCERTIFICATE_STRUCTA, *PCRYPTUI_VIEWCERTIFICATE_STRUCTA;
typedef const CRYPTUI_VIEWCERTIFICATE_STRUCTA *PCCRYPTUI_VIEWCERTIFICATE_STRUCTA;

//
// pfPropertiesChanged             this will be set by the dialog proc to inform the caller
//                                 if any properties have been changed on certs in the chain
//                                 while the dialog was open
//
BOOL
WINAPI
CryptUIDlgViewCertificateW(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        );

BOOL
WINAPI
CryptUIDlgViewCertificateA(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTA   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        );

#ifdef UNICODE
#define CryptUIDlgViewCertificate           CryptUIDlgViewCertificateW
#define PCRYPTUI_VIEWCERTIFICATE_STRUCT     PCRYPTUI_VIEWCERTIFICATE_STRUCTW
#define CRYPTUI_VIEWCERTIFICATE_STRUCT      CRYPTUI_VIEWCERTIFICATE_STRUCTW
#define PCCRYPTUI_VIEWCERTIFICATE_STRUCT    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW
#else
#define CryptUIDlgViewCertificate           CryptUIDlgViewCertificateA
#define PCRYPTUI_VIEWCERTIFICATE_STRUCT     PCRYPTUI_VIEWCERTIFICATE_STRUCTA
#define CRYPTUI_VIEWCERTIFICATE_STRUCT      CRYPTUI_VIEWCERTIFICATE_STRUCTA
#define PCCRYPTUI_VIEWCERTIFICATE_STRUCT    PCCRYPTUI_VIEWCERTIFICATE_STRUCTA
#endif

//
// this struct is passed as the lParam in the WM_INITDIALOG call to each
// property sheet that is in the rgPropSheetPages array of the
// CRYPTUI_VIEWCERTIFICATE_STRUCT structure
//
typedef struct tagCRYPTUI_INITDIALOG_STRUCT {
    LPARAM          lParam;
    PCCERT_CONTEXT  pCertContext;
} CRYPTUI_INITDIALOG_STRUCT, *PCRYPTUI_INITDIALOG_STRUCT;


//
// this structure is used in CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT,
// and allows users of MMC to recieve notifications that properties
// on certificates have changed
//
typedef HRESULT (__stdcall * PFNCMMCCALLBACK)(LONG_PTR lNotifyHandle, LPARAM param);

typedef struct tagCRYPTUI_MMCCALLBACK_STRUCT {
    PFNCMMCCALLBACK pfnCallback;    // the address of MMCPropertyChangeNotify()
    LONG_PTR         lNotifyHandle;  // the lNotifyHandle passed to MMCPropertyChangeNotify()
    LPARAM          param;          // the param passed to MMCPropertyChangeNotify()
} CRYPTUI_MMCCALLBACK_STRUCT, *PCRYPTUI_MMCCALLBACK_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// union                           the szTitle field of the union is only valid if
//                                 CryptUIDlgViewCertificateProperties is being called.
//                                 the pMMCCallback field of the union is only valid if
//                                 CryptUIGetCertificatePropertiesPages is being called.
//                                 Note that if pMMCCallback is non-NULL and
//                                 CryptUIGetCertificatePropertiesPages was called, the
//                                 struct pointed to by pMMCCallback will not be referenced
//                                 by cryptui.dll after the callback has been made to MMC.
//                                 this will allow the original caller of
//                                 CryptUIGetCertificatePropertiesPages to free the struct
//                                 pointed to by pMMCCallback in the actual callback.
//      szTitle                    title for the window                                     (OPTIONAL)
//      pMMCCallback               this structure is used to callback MMC if properties     (OPTIONAL)
//                                 have changed
// pCertContext                    the cert context that is to be displayed
// pPropPageCallback               this callback will be called when each page that is      (OPTIONAL)
//                                 returned in the CryptUIGetCertificatePropertiesPages call
//                                 is about to be created or destroyed.  if this is NULL no
//                                 callback is made.  Note that this is not used if
//                                 CryptUIDlgViewCertificateProperties is called
// pvCallbackData                  this is uniterpreted data that is passed back when the   (OPTIONAL)
//                                 when pPropPageCallback is made
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    union
    {
        LPCWSTR                     szTitle;    // OPTIONAL
        PCRYPTUI_MMCCALLBACK_STRUCT pMMCCallback;// OPTIONAL
    };
    PCCERT_CONTEXT          pCertContext;
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW, *PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;
typedef const CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;

typedef struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    union
    {
        LPCSTR                      szTitle;    // OPTIONAL
        PCRYPTUI_MMCCALLBACK_STRUCT pMMCCallback;// OPTIONAL
    };
    PCCERT_CONTEXT          pCertContext;
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA, *PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;
typedef const CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;

// pfPropertiesChanged             this will be set by the dialog proc to inform the caller
//                                 if any properties have been changed on certs in the chain
//                                 while the dialog was open
BOOL
WINAPI
CryptUIDlgViewCertificatePropertiesW(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
            OUT BOOL                                        *pfPropertiesChanged  // OPTIONAL
            );

BOOL
WINAPI
CryptUIDlgViewCertificatePropertiesA(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp,
            OUT BOOL                                        *pfPropertiesChanged  // OPTIONAL
            );


// NOTE!!   when calling this function, the following parameters of the
//          CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT struct are unused
//              cPropSheetPages
//              rgPropSheetPages
BOOL
WINAPI
CryptUIGetCertificatePropertiesPagesW(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
            OUT BOOL                                        *pfPropertiesChanged,  // OPTIONAL
            OUT PROPSHEETPAGEW                              **prghPropPages,
            OUT DWORD                                       *pcPropPages
            );

BOOL
WINAPI
CryptUIGetCertificatePropertiesPagesA(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp,
            OUT BOOL                                         *pfPropertiesChanged,  // OPTIONAL
            OUT PROPSHEETPAGEA                               **prghPropPages,
            OUT DWORD                                        *pcPropPages
            );

BOOL
WINAPI
CryptUIFreeCertificatePropertiesPagesW(
            IN PROPSHEETPAGEW   *rghPropPages,
            IN DWORD            cPropPages
            );

BOOL
WINAPI
CryptUIFreeCertificatePropertiesPagesA(
            IN PROPSHEETPAGEA   *rghPropPages,
            IN DWORD            cPropPages
            );

#ifdef UNICODE
#define CryptUIDlgViewCertificateProperties         CryptUIDlgViewCertificatePropertiesW
#define PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT   PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define CryptUIGetCertificatePropertiesPages        CryptUIGetCertificatePropertiesPagesW
#define CryptUIFreeCertificatePropertiesPages       CryptUIFreeCertificatePropertiesPagesW
#else
#define CryptUIDlgViewCertificateProperties         CryptUIDlgViewCertificatePropertiesA
#define PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT   PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define CryptUIGetCertificatePropertiesPages        CryptUIGetCertificatePropertiesPagesA
#define CryptUIFreeCertificatePropertiesPages       CryptUIFreeCertificatePropertiesPagesA
#endif

//
// The certificate properties property sheet dialog is extensible via a callback mechanism.
// A client needs to register their callback using CryptRegisterDefaultOIDFunction, and,
// if they need to unregister it they should use CryptUnregisterDefaultOIDFunction.
// The form for calling these functions is given below
//
// CryptRegisterDefaultOIDFunction(
//            0,
//            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK,
//            CRYPT_REGISTER_FIRST_INDEX,
//            L"c:\\fully qualified path\\dll_being_registered.dll");  <<----- your dll name
//
// CryptUnregisterDefaultOIDFunction(
//            0,
//            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK,
//            L"c:\\fully qualified path\\dll_being_registered.dll");  <<----- your dll name
//
// NOTE: Per the documentation on CryptRegisterDefaultOIDFunction in wincrypt.h,
//       the dll name may contain environment-variable strings
//       which are ExpandEnvironmentStrings()'ed before loading the Dll.
//
#define MAX_CLIENT_PAGES 20
#define CRYPTUILDLG_CERTPROP_PAGES_CALLBACK "CryptUIDlgClientCertPropPagesCallback"

//
//
// The typedef for the callback function which resides in the registered dll is given
// below.  Note that the callback must have the name #defined by
// CRYPTUILDLG_CERTPROP_PAGES_CALLBACK
//
// pCertContext - The certificate for which the properties are being displayed.
// rgPropPages  - An array of PropSheetPageW structures that are to be filled in by
//                the client with the property pages to be shown.
// pcPropPages  - A pointer to a DWORD that on input contains the maximum number of
//                PropSheetPages the client may supply, and on output must have been
//                filled in by the client with the number of pages they supplied in
//                rgPropPages.
//
// Return Value:  The client should return TRUE if they wish to show extra property pages,
//                in this case pcPropPages must >= 1 and rgPropPages must have the
//                corresponding number of pages.  or, return FALSE if no pages are suplied.
typedef BOOL (WINAPI *PFN_CRYPTUIDLG_CERTPROP_PAGES_CALLBACK)
        (IN     PCCERT_CONTEXT pCertContext,
         OUT    PROPSHEETPAGEW *rgPropPages,
         IN OUT DWORD *pcPropPages);


/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pCTLContext                     the ctl context that is to be displayed
// cCertSearchStores;              count of other stores to search for the certs contained  (OPTIONAL)
//                                 in the ctl
// rghCertSearchStores;            array of other stores to search for the certs contained  (OPTIONAL)
//                                 in the ctl
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain of the cert which signed the ctl
//                                 and the certs contained in the ctl
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain of the cert which signed the ctl
//                                 and the certs contained in the ctl
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_TRUSTLIST_PAGE        0x00000001

typedef struct tagCRYPTUI_VIEWCTL_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    PCCTL_CONTEXT       pCTLContext;
    DWORD               cCertSearchStores;  // OPTIONAL
    HCERTSTORE *        rghCertSearchStores;// OPTIONAL
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCTL_STRUCTW, *PCRYPTUI_VIEWCTL_STRUCTW;
typedef const CRYPTUI_VIEWCTL_STRUCTW *PCCRYPTUI_VIEWCTL_STRUCTW;

typedef struct tagCRYPTUI_VIEWCTL_STRUCTA {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    PCCTL_CONTEXT       pCTLContext;
    DWORD               cCertSearchStores;  // OPTIONAL
    HCERTSTORE *        rghCertSearchStores;// OPTIONAL
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCTL_STRUCTA, *PCRYPTUI_VIEWCTL_STRUCTA;
typedef const CRYPTUI_VIEWCTL_STRUCTA *PCCRYPTUI_VIEWCTL_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewCTLW(
            IN PCCRYPTUI_VIEWCTL_STRUCTW pcvctl
            );

BOOL
WINAPI
CryptUIDlgViewCTLA(
            IN PCCRYPTUI_VIEWCTL_STRUCTA pcvctl
            );

#ifdef UNICODE
#define CryptUIDlgViewCTL           CryptUIDlgViewCTLW
#define PCRYPTUI_VIEWCTL_STRUCT     PCRYPTUI_VIEWCTL_STRUCTW
#define CRYPTUI_VIEWCTL_STRUCT      CRYPTUI_VIEWCTL_STRUCTW
#define PCCRYPTUI_VIEWCTL_STRUCT    PCCRYPTUI_VIEWCTL_STRUCTW
#else
#define CryptUIDlgViewCTL           CryptUIDlgViewCTLA
#define PCRYPTUI_VIEWCTL_STRUCT     PCRYPTUI_VIEWCTL_STRUCTA
#define CRYPTUI_VIEWCTL_STRUCT      CRYPTUI_VIEWCTL_STRUCTA
#define PCCRYPTUI_VIEWCTL_STRUCT    PCCRYPTUI_VIEWCTL_STRUCTA
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pCTLContext                     the ctl context that is to be displayed
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 signed the crl and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 signed the crl and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_REVOCATIONLIST_PAGE   0x00000001

typedef struct tagCRYPTUI_VIEWCRL_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    PCCRL_CONTEXT       pCRLContext;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCRL_STRUCTW, *PCRYPTUI_VIEWCRL_STRUCTW;
typedef const CRYPTUI_VIEWCRL_STRUCTW *PCCRYPTUI_VIEWCRL_STRUCTW;

typedef struct tagCRYPTUI_VIEWCRL_STRUCTA {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    PCCRL_CONTEXT       pCRLContext;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCRL_STRUCTA, *PCRYPTUI_VIEWCRL_STRUCTA;
typedef const CRYPTUI_VIEWCRL_STRUCTA *PCCRYPTUI_VIEWCRL_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewCRLW(
            IN PCCRYPTUI_VIEWCRL_STRUCTW pcvcrl
            );

BOOL
WINAPI
CryptUIDlgViewCRLA(
            IN PCCRYPTUI_VIEWCRL_STRUCTA pcvcrl
            );

#ifdef UNICODE
#define CryptUIDlgViewCRL           CryptUIDlgViewCRLW
#define PCRYPTUI_VIEWCRL_STRUCT     PCRYPTUI_VIEWCRL_STRUCTW
#define CRYPTUI_VIEWCRL_STRUCT      CRYPTUI_VIEWCRL_STRUCTW
#define PCCRYPTUI_VIEWCRL_STRUCT    PCCRYPTUI_VIEWCRL_STRUCTW
#else
#define CryptUIDlgViewCRL           CryptUIDlgViewCRLA
#define PCRYPTUI_VIEWCRL_STRUCT     PCRYPTUI_VIEWCRL_STRUCTA
#define CRYPTUI_VIEWCRL_STRUCT      CRYPTUI_VIEWCRL_STRUCTA
#define PCCRYPTUI_VIEWCRL_STRUCT    PCCRYPTUI_VIEWCRL_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pSignerInfo                     the signer info struct that is to be displayed
// hMsg                            the HCRYPTMSG that the signer info was extracted from
// pszOID                          an OID that signifies what the certificate that did the  (OPTIONAL)
//                                 signing whould be validated for.  for instance if this is
//                                 being called to view the signature of a CTL the
//                                 szOID_KP_CTL_USAGE_SIGNING OID should be passed in.
//                                 if this is NULL then the certificate is only validated
//                                 cryptographicaly and not for usages.
// dwReserved                      reserved for future use and must be set to NULL
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_TRUSTLIST_PAGE        0x00000001

typedef struct tagCRYPTUI_VIEWSIGNERINFO_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCWSTR                 szTitle;            // OPTIONAL
    CMSG_SIGNER_INFO const *pSignerInfo;
    HCRYPTMSG               hMsg;
    LPCSTR                  pszOID;             // OPTIONAL
    DWORD_PTR               dwReserved;
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE             *rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNERINFO_STRUCTW, *PCRYPTUI_VIEWSIGNERINFO_STRUCTW;
typedef const CRYPTUI_VIEWSIGNERINFO_STRUCTW *PCCRYPTUI_VIEWSIGNERINFO_STRUCTW;

typedef struct tagCRYPTUI_VIEWSIGNERINFO_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCSTR                  szTitle;            // OPTIONAL
    CMSG_SIGNER_INFO const *pSignerInfo;
    HCRYPTMSG               hMsg;
    LPCSTR                  pszOID;             // OPTIONAL
    DWORD_PTR               dwReserved;
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE             *rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNERINFO_STRUCTA, *PCRYPTUI_VIEWSIGNERINFO_STRUCTA;
typedef const CRYPTUI_VIEWSIGNERINFO_STRUCTA *PCCRYPTUI_VIEWSIGNERINFO_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewSignerInfoW(
            IN PCCRYPTUI_VIEWSIGNERINFO_STRUCTW pcvsi
            );

BOOL
WINAPI
CryptUIDlgViewSignerInfoA(
            IN PCCRYPTUI_VIEWSIGNERINFO_STRUCTA pcvsi
            );

#ifdef UNICODE
#define CryptUIDlgViewSignerInfo        CryptUIDlgViewSignerInfoW
#define PCRYPTUI_VIEWSIGNERINFO_STRUCT  PCRYPTUI_VIEWSIGNERINFO_STRUCTW
#define CRYPTUI_VIEWSIGNERINFO_STRUCT   CRYPTUI_VIEWSIGNERINFO_STRUCTW
#define PCCRYPTUI_VIEWSIGNERINFO_STRUCT PCCRYPTUI_VIEWSIGNERINFO_STRUCTW
#else
#define CryptUIDlgViewSignerInfo        CryptUIDlgViewSignerInfoA
#define PCRYPTUI_VIEWSIGNERINFO_STRUCT  PCRYPTUI_VIEWSIGNERINFO_STRUCTA
#define CRYPTUI_VIEWSIGNERINFO_STRUCT   CRYPTUI_VIEWSIGNERINFO_STRUCTA
#define PCCRYPTUI_VIEWSIGNERINFO_STRUCT PCCRYPTUI_VIEWSIGNERINFO_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// szTitle                         title for the window                                     (OPTIONAL)
// choice                          the form of the message that is to have its signers displayed
// u                               either an encoded message or a message handle
//          EncodedMessage         a data blob which contains a pointer to the encoded data
//                                 and the count of encoded bytes
//          hMsg                   a message handle
// szFileName                      the fully qualified file name, should be passed in if    (OPTIONAL)
//                                 signatures on a file are being viewed
// pPropPageCallback               this callback will be called when each page that is      (OPTIONAL)
//                                 returned in the CryptUIGetViewSignaturesPages call
//                                 is about to be created or destroyed.  if this is NULL no
//                                 callback is made.
// pvCallbackData                  this is uniterpreted data that is passed back when the   (OPTIONAL)
//                                 when pPropPageCallback is made
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// for the coice field of the CRYPTUI_VIEWSIGNATURES_STRUCT structure
#define EncodedMessage_Chosen   1
#define hMsg_Chosen             2

typedef struct tagCRYPTUI_VIEWSIGNATURES_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCWSTR                 szTitle;            // OPTIONAL
    unsigned short          choice;
    union {
        CRYPT_DATA_BLOB     EncodedMessage;
        HCRYPTMSG           hMsg;
    } u;
    LPCWSTR                 szFileName;         // OPTIONAL
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNATURES_STRUCTW, *PCRYPTUI_VIEWSIGNATURES_STRUCTW;
typedef const CRYPTUI_VIEWSIGNATURES_STRUCTW *PCCRYPTUI_VIEWSIGNATURES_STRUCTW;

typedef struct tagCRYPTUI_VIEWSIGNATURES_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCSTR                  szTitle;            // OPTIONAL
    unsigned short          choice;
    union {
        CRYPT_DATA_BLOB     EncodedMessage;
        HCRYPTMSG           hMsg;
    } u;
    LPCSTR                  szFileName;         // OPTIONAL
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNATURES_STRUCTA, *PCRYPTUI_VIEWSIGNATURES_STRUCTA;
typedef const CRYPTUI_VIEWSIGNATURES_STRUCTA *PCCRYPTUI_VIEWSIGNATURES_STRUCTA;


// NOTE!!   when calling this function, the following parameters of the
//          CRYPTUI_VIEWSIGNATURES_STRUCT struct are unused
//              cPropSheetPages
//              rgPropSheetPages
//              szTitle
BOOL
WINAPI
CryptUIGetViewSignaturesPagesW(
            IN  PCCRYPTUI_VIEWSIGNATURES_STRUCTW    pcvs,
            OUT PROPSHEETPAGEW                      **prghPropPages,
            OUT DWORD                               *pcPropPages
            );

BOOL
WINAPI
CryptUIGetViewSignaturesPagesA(
            IN  PCCRYPTUI_VIEWSIGNATURES_STRUCTA    pcvs,
            OUT PROPSHEETPAGEA                      **prghPropPages,
            OUT DWORD                               *pcPropPages
            );

BOOL
WINAPI
CryptUIFreeViewSignaturesPagesW(
            IN PROPSHEETPAGEW  *rghPropPages,
            IN DWORD           cPropPages
            );

BOOL
WINAPI
CryptUIFreeViewSignaturesPagesA(
            IN PROPSHEETPAGEA  *rghPropPages,
            IN DWORD           cPropPages
            );

#ifdef UNICODE
#define CryptUIGetViewSignaturesPages   CryptUIGetViewSignaturesPagesW
#define CryptUIFreeViewSignaturesPages  CryptUIFreeViewSignaturesPagesW
#define PCRYPTUI_VIEWSIGNATURES_STRUCT  PCRYPTUI_VIEWSIGNATURES_STRUCTW
#define CRYPTUI_VIEWSIGNATURES_STRUCT   CRYPTUI_VIEWSIGNATURES_STRUCTW
#define PCCRYPTUI_VIEWSIGNATURES_STRUCT PCCRYPTUI_VIEWSIGNATURES_STRUCTW
#else
#define CryptUIGetViewSignaturesPages   CryptUIGetViewSignaturesPagesA
#define CryptUIFreeViewSignaturesPages  CryptUIFreeViewSignaturesPagesA
#define PCRYPTUI_VIEWSIGNATURES_STRUCT  PCRYPTUI_VIEWSIGNATURES_STRUCTA
#define CRYPTUI_VIEWSIGNATURES_STRUCT   CRYPTUI_VIEWSIGNATURES_STRUCTA
#define PCCRYPTUI_VIEWSIGNATURES_STRUCT PCCRYPTUI_VIEWSIGNATURES_STRUCTA
#endif


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the select store dialog can be passed a callback which is called to validate the store that the
//  user selected.  Return TRUE to accept the store, or FALSE to reject the store.  It TRUE is
//  returned then the store will be returned to the caller of CryptUIDlg\, if FALSE is returned
//  then the select store dialog will remain displayed so the user may make another selection

typedef BOOL (WINAPI * PFNCVALIDATESTOREPROC)(
        HCERTSTORE  hStore,
        HWND        hWndSelectStoreDialog,
        void        *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//      these two parameters are passed to the CertEnumSystemStore call and the stores that are
//      enumerated via that call are added to the store selection list.
//
//      dwFlags                    CertEnumSystemStore
//      pvSystemStoreLocationPara  CertEnumSystemStore
typedef struct _STORENUMERATION_STRUCT {
    DWORD               dwFlags;
    void *              pvSystemStoreLocationPara;
} STORENUMERATION_STRUCT, *PSTORENUMERATION_STRUCT;
typedef const STORENUMERATION_STRUCT *PCSTORENUMERATION_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//      both the array of store handles and the array of enumeration strucs may be used to
//      populate the store selection list.  if either is not used the count must be set to 0.
//      if the array of store handles is used the cert stores must have either been opened
//      with the CERT_STORE_SET_LOCALIZED_NAME_FLAG flag, or the CertSetStoreProperty function
//      must have been called with the CERT_STORE_LOCALIZED_NAME_PROP_ID flag.  if the
//      CryptUIDlgSelectStore function is unable to obtain a name for a store that store will not
//      be displayed.
//
//      cStores                    count of stores to select from
//      rghStores                  array of stores to select from
//      cEnumerationStructs        count of enumeration structs
//      rgEnumerationStructs       array of enumeration structs
typedef struct _STORESFORSELCTION_STRUCT {
    DWORD                       cStores;
    HCERTSTORE *                rghStores;
    DWORD                       cEnumerationStructs;
    PCSTORENUMERATION_STRUCT    rgEnumerationStructs;
} STORESFORSELCTION_STRUCT, *PSTORESFORSELCTION_STRUCT;
typedef const STORESFORSELCTION_STRUCT *PCSTORESFORSELCTION_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title of the dialog                                      (OPTIONAL)
// szDisplayString                 a string that will be displayed in the dialog that may   (OPTIONAL)
//                                 be used to infor the user what they are selecting a store
//                                 for.  if it is not set a default string will be displayed,
//                                 the default resource is IDS_SELECT_STORE_DEFAULT
// pStoresForSelection             a struct that contains the stores that are to be selected
//                                 from.  the stores can be in two different formats, an array
//                                 of store handles and/or an array of enumeration structs
//                                 which will be used to call CertEnumSystemStore
// pValidateStoreCallback          a pointer to a PFNCVALIDATESTOREPROC which is used to    (OPTIONAL)
//                                 callback the caller of CryptUIDlgSelectStore when the
//                                 user hasselected a store and pressed OK
// pvCallbackData                  if pValidateStoreCallback is being used this value is    (OPTIONAL)
//                                 passed back to the caller when the pValidateStoreCallback
//                                 is made
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW       0x00000001
#define CRYPTUI_RETURN_READ_ONLY_STORE          0x00000002
#define CRYPTUI_DISPLAY_WRITE_ONLY_STORES       0x00000004
#define CRYPTUI_VALIDATE_STORES_AS_WRITABLE     0x00000008

typedef struct tagCRYPTUI_SELECTSTORE_STRUCTW {
    DWORD                       dwSize;
    HWND                        hwndParent;             // OPTIONAL
    DWORD                       dwFlags;                // OPTIONAL
    LPCWSTR                     szTitle;                // OPTIONAL
    LPCWSTR                     szDisplayString;        // OPTIONAL
    PCSTORESFORSELCTION_STRUCT  pStoresForSelection;
    PFNCVALIDATESTOREPROC       pValidateStoreCallback; // OPTIONAL
    void *                      pvCallbackData;         // OPTIONAL
} CRYPTUI_SELECTSTORE_STRUCTW, *PCRYPTUI_SELECTSTORE_STRUCTW;
typedef const CRYPTUI_SELECTSTORE_STRUCTW *PCCRYPTUI_SELECTSTORE_STRUCTW;

typedef struct tagCRYPTUI_SELECTSTORE_STRUCTA {
    DWORD                       dwSize;
    HWND                        hwndParent;             // OPTIONAL
    DWORD                       dwFlags;                // OPTIONAL
    LPCSTR                      szTitle;                // OPTIONAL
    LPCSTR                      szDisplayString;        // OPTIONAL
    PCSTORESFORSELCTION_STRUCT  pStoresForSelection;
    PFNCVALIDATESTOREPROC       pValidateStoreCallback; // OPTIONAL
    void *                      pvCallbackData;         // OPTIONAL
} CRYPTUI_SELECTSTORE_STRUCTA, *PCRYPTUI_SELECTSTORE_STRUCTA;
typedef const CRYPTUI_SELECTSTORE_STRUCTA *PCCRYPTUI_SELECTSTORE_STRUCTA;

//
// the HCERTSTORE that is returned must be closed by calling CertCloseStore
//
HCERTSTORE
WINAPI
CryptUIDlgSelectStoreW(
            IN PCCRYPTUI_SELECTSTORE_STRUCTW pcss
            );

HCERTSTORE
WINAPI
CryptUIDlgSelectStoreA(
            IN PCCRYPTUI_SELECTSTORE_STRUCTA pcss
            );

#ifdef UNICODE
#define CryptUIDlgSelectStore           CryptUIDlgSelectStoreW
#define PCRYPTUI_SELECTSTORE_STRUCT     PCRYPTUI_SELECTSTORE_STRUCTW
#define CRYPTUI_SELECTSTORE_STRUCT      CRYPTUI_SELECTSTORE_STRUCTW
#define PCCRYPTUI_SELECTSTORE_STRUCT    PCCRYPTUI_SELECTSTORE_STRUCTW
#else
#define CryptUIDlgSelectStore           CryptUIDlgSelectStoreA
#define PCRYPTUI_SELECTSTORE_STRUCT     PCRYPTUI_SELECTSTORE_STRUCTA
#define CRYPTUI_SELECTSTORE_STRUCT      CRYPTUI_SELECTSTORE_STRUCTA
#define PCCRYPTUI_SELECTSTORE_STRUCT    PCCRYPTUI_SELECTSTORE_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  The select cert dialog can be passed a filter proc to reduce the set of certificates
//  displayed.  Return TRUE to display the certificate and FALSE to hide it.  If TRUE is
//  returned then optionally the pfInitialSelectedCert boolean may be set to TRUE to indicate
//  to the dialog that this cert should be the initially selected cert.  Note that the
//  most recent cert that had the pfInitialSelectedCert boolean set during the callback will
//  be the initially selected cert.

typedef BOOL (WINAPI * PFNCFILTERPROC)(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Certificates may be viewed by the user when selecting certificates from the select certificate
//  dialog.  This callback will allow the caller of the select certificate dialog to handle the
//  displaying of those certificates.  This may be useful if the caller wishes to call WinVerifyTrust
//  with their own policy module and display the certificate with that WinVerifyTrust state.  If
//  FALSE is returned from this callback it is assumed that the select certificate dialog will be
//  responsible for dislaying the certificate in question.  If TRUE is returned it is assumed that the
//  display of the certificate was already handled.

typedef BOOL (WINAPI * PFNCCERTDISPLAYPROC)(
        PCCERT_CONTEXT  pCertContext,
        HWND            hWndSelCertDlg,
        void            *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// dwDontUseColumn                 This can be used to disable the display of certain       (OPTIONAL)
//                                 columns.  It can be set with any comibnation of the
//                                 column flags below
// szTitle                         title of the dialog                                      (OPTIONAL)
// szDisplayString                 a string that will be displayed in the dialog that may   (OPTIONAL)
//                                 be used to inform the user what they are selecting a
//                                 a certificate for.  if it is not set a default string
//                                 will be displayed.  the defualt strings resourece is
//                                 IDS_SELECT_CERT_DEFAULT
// pFilterCallback                 a pointer to a PFNCMFILTERPROC which is used to filter   (OPTIONAL)
//                                 the certificates which are displayed for selection
// pDisplayCallback                a pointer to a PFNCCERTDISPLAYPROC which is used to
//                                 handle displaying certificates
// pvCallbackData                  if either or both pFilterCallback or pDisplayCallback    (OPTIONAL)
//                                 are being used this value is passed back to the caller
//                                 when the callbacks are made
// cDisplayStores                  count of stores that contain the certs to display
//                                 for selection
// rghDisplayStores                array of stores that contain the certs to display
//                                 for selection
// cStores                         count of other stores to search when building chain and  (OPTIONAL)
//                                 validating trust of the certs which are displayed, if
//                                 the user choosing a cert would like to view a particular
//                                 cert which is displayed for selection, these stores
//                                 are passed to the CertViewCert dialog
// rghStores                       array of other stores to search when building chain and  (OPTIONAL)
//                                 validating trust of the certs which are displayed, if
//                                 the user choosing a cert would like to view a particular
//                                 cert which is displayed for selection, these stores
//                                 are passed to the CertViewCert dialog
// cPropSheetPages                 PASS THROUGH - number of pages in rgPropSheetPages array (OPTIONAL)
// rgPropSheetPages                PASS THROUGH - extra pages that are passed through       (OPTIONAL)
//                                 to the certificate viewing dialog when it is invoked from
//                                 the selection dialog
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// flags for dwDontUseColumn
#define CRYPTUI_SELECT_ISSUEDTO_COLUMN        0x000000001
#define CRYPTUI_SELECT_ISSUEDBY_COLUMN        0x000000002
#define CRYPTUI_SELECT_INTENDEDUSE_COLUMN     0x000000004
#define CRYPTUI_SELECT_FRIENDLYNAME_COLUMN    0x000000008
#define CRYPTUI_SELECT_LOCATION_COLUMN        0x000000010
#define CRYPTUI_SELECT_EXPIRATION_COLUMN      0x000000020

typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    DWORD               dwDontUseColumn;    // OPTIONAL
    LPCWSTR             szDisplayString;    // OPTIONAL
    PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
    PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
    void *              pvCallbackData;     // OPTIONAL
    DWORD               cDisplayStores;
    HCERTSTORE *        rghDisplayStores;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_SELECTCERTIFICATE_STRUCTW, *PCRYPTUI_SELECTCERTIFICATE_STRUCTW;
typedef const CRYPTUI_SELECTCERTIFICATE_STRUCTW *PCCRYPTUI_SELECTCERTIFICATE_STRUCTW;

typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    DWORD               dwDontUseColumn;    // OPTIONAL
    LPCSTR              szDisplayString;    // OPTIONAL
    PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
    PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
    void *              pvCallbackData;     // OPTIONAL
    DWORD               cDisplayStores;
    HCERTSTORE *        rghDisplayStores;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_SELECTCERTIFICATE_STRUCTA, *PCRYPTUI_SELECTCERTIFICATE_STRUCTA;
typedef const CRYPTUI_SELECTCERTIFICATE_STRUCTA *PCCRYPTUI_SELECTCERTIFICATE_STRUCTA;

//
// the PCCERT_CONTEXT that is returned must be released by calling CertFreeCertificateContext().
// if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
// "cancel" button, otherwise GetLastError() will contain the last error.
//
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateW(
            IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc
            );

PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateA(
            IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTA pcsc
            );

#ifdef UNICODE
#define CryptUIDlgSelectCertificate         CryptUIDlgSelectCertificateW
#define PCRYPTUI_SELECTCERTIFICATE_STRUCT   PCRYPTUI_SELECTCERTIFICATE_STRUCTW
#define CRYPTUI_SELECTCERTIFICATE_STRUCT    CRYPTUI_SELECTCERTIFICATE_STRUCTW
#define PCCRYPTUI_SELECTCERTIFICATE_STRUCT  PCCRYPTUI_SELECTCERTIFICATE_STRUCTW
#else
#define CryptUIDlgSelectCertificate         CryptUIDlgSelectCertificateA
#define PCRYPTUI_SELECTCERTIFICATE_STRUCT   PCRYPTUI_SELECTCERTIFICATE_STRUCTA
#define CRYPTUI_SELECTCERTIFICATE_STRUCT    CRYPTUI_SELECTCERTIFICATE_STRUCTA
#define PCCRYPTUI_SELECTCERTIFICATE_STRUCT  PCCRYPTUI_SELECTCERTIFICATE_STRUCTA
#endif


//flags for dwFlags in CRYPTUI_SELECT_CA_STRUCT struct
#define     CRYPTUI_DLG_SELECT_CA_FROM_NETWORK                  0x0001
#define     CRYPTUI_DLG_SELECT_CA_USE_DN                        0x0002
#define     CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION     0x0004
//-------------------------------------------------------------------------
//
//	CRYPTUI_CA_CONTEXT
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_CA_CONTEXT
{
    DWORD                   dwSize;	
    LPCWSTR                 pwszCAName;
    LPCWSTR                 pwszCAMachineName;
}CRYPTUI_CA_CONTEXT, *PCRYPTUI_CA_CONTEXT;

typedef const CRYPTUI_CA_CONTEXT *PCCRYPTUI_CA_CONTEXT;


//-------------------------------------------------------------------------
//
//	
//
//  The select certificate authoritiy (CA) dialog can be passed a filter proc to reduce the set of CAs
//  displayed.  Return TRUE to display the CA and FALSE to hide it.  If TRUE is
//  returned then optionally the pfInitialSelectedCert boolean may be set to TRUE to indicate
//  to the dialog that this CA should be the initially selected CA.  Note that the
//  most recent cert that had the pfInitialSelectedCert boolean set during the callback will
//  be the initially selected CA.
//
//-------------------------------------------------------------------------

typedef BOOL (WINAPI * PFN_CRYPTUI_SELECT_CA_FUNC)(
        PCCRYPTUI_CA_CONTEXT        pCAContext,
        BOOL                        *pfInitialSelected,
        void                        *pvCallbackData);


//-------------------------------------------------------------------------
//
//	CRYPTUI_SELECT_CA_STRUCT
//
//  dwSize	           Required:    Must be set to sizeof(CRYPTUI_SELECT_CA_STRUCT)
//  hwndParent         Optional:    Parent of this dialog
//  dwFlags            Optional:    Flags, Can be set to any combination of the following:
//                                  CRYPTUI_DLG_SELECT_CA_FROM_NETWORK:
//                                     All the available CAs from the network will be displayed
//                                  CRYPTUI_DLG_SELECT_CA_USE_DN:
//                                     Use the full DN (Distinguished Name) as the CA name.
//                                      By default, CN (common name) is used.
//                                  CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION:
//                                      Display the CAs available to the local machine only.
//                                      By Default, CAs available to the current user will be displayed
//  wszTitle           Optional:    Title of the dialog
//  wszDisplayString   Optional:    A string that will be displayed in the dialog that may   (OPTIONAL)
//                                  be used to inform the user what they are selecting a
//                                  a certificate for.  if it is not set a default string
//                                  will be displayed.  the defualt strings resourece is
//                                  IDS_SELECT_CA_DISPLAY_DEFAULT
//  cCAContext         Optional:    The count of additional CA contexts that will be displayed
//                                  in the dialogs
//  *rgCAContext       Optioanl:    The array of additional CA contexts that will be displayed
//                                  in the dialogs
//  pSelectCACallback  Optional:    a pointer to a PCCRYPTUI_CA_CONTEXT which is used to filter
//                                  the certificate autorities which are displayed for selection
//  pvCallbackData     Optional:    if pSelectCACallback is being used this value is passed
//                                  back to the caller when the pSelectCACallback is made
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_SELECT_CA_STRUCT
{
    DWORD                       dwSize;	                    // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     wszTitle;                   // OPTIONAL
    LPCWSTR                     wszDisplayString;           // OPTIONAL
    DWORD                       cCAContext;                 // OPTIONAL
    PCCRYPTUI_CA_CONTEXT        *rgCAContext;               // OPTIONAL
    PFN_CRYPTUI_SELECT_CA_FUNC  pSelectCACallback;          // OPTIONAL
    void                        *pvCallbackData;            // OPTIONAL
}CRYPTUI_SELECT_CA_STRUCT, *PCRYPTUI_SELECT_CA_STRUCT;

typedef const CRYPTUI_SELECT_CA_STRUCT *PCCRYPTUI_SELECT_CA_STRUCT;

//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUISelectCA       IN  Required
//
//  the PCCRYPTUI_CA_CONTEXT that is returned must be released by calling
//  CryptUIDlgFreeCAContext
//  if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
//  "cancel" button, otherwise GetLastError() will contain the last error.
//
//
//--------------------------------------------------------------
PCCRYPTUI_CA_CONTEXT
WINAPI
CryptUIDlgSelectCA(
        IN PCCRYPTUI_SELECT_CA_STRUCT pCryptUISelectCA
             );

BOOL
WINAPI
CryptUIDlgFreeCAContext(
        IN PCCRYPTUI_CA_CONTEXT       pCAContext
            );




//-------------------------------------------------------------------------
//
//	CRYPTUI_CERT_MGR_STRUCT
//
//  dwSize	           Required:    Must be set to sizeof(CRYPTUI_CERT_MGR_STRUCT)
//  hwndParent         Optional:    Parent of this dialog
//  dwFlags            Reserved:    Must be set to 0
//  wszTitle           Optional:    Title of the dialog
//  pszInitUsageOID    Optional:    The enhanced key usage object identifier (OID).
//                                  Certificates with this OID will initially
//                                  be shown as a default. User
//                                  can then choose different OIDs.
//                                  NULL means all certificates will be shown initially.
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_CERT_MGR_STRUCT
{
    DWORD                       dwSize;	                    // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     pwszTitle;                   // OPTIONAL
    LPCSTR                      pszInitUsageOID;            // OPTIONAL
}CRYPTUI_CERT_MGR_STRUCT, *PCRYPTUI_CERT_MGR_STRUCT;

typedef const CRYPTUI_CERT_MGR_STRUCT *PCCRYPTUI_CERT_MGR_STRUCT;

//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUICertMgr       IN  Required
//
//
//--------------------------------------------------------------
BOOL
WINAPI
CryptUIDlgCertMgr(
        IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr);



/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------
//  The valid values for dwFlags for the CryptUIWiz APIs
//
//------------------------------------------------------------------------

#define     CRYPTUI_WIZ_NO_UI                           0x0001


//CRYPTUI_WIZ_NO_INSTALL_ROOT is only valid for CryptUIWizCertRequest API
//the wizard will not install the issued certificate chain into the root store,
//instead, it will put the certificate chain into the CA store.
#define     CRYPTUI_WIZ_NO_INSTALL_ROOT                 0x0010


//CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user to enter destination where the CTL will
//be stored.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION       0x0004


//CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user to sign the CTL.
//the CTLContext returned by CryptUIWizBuildCTL will not be signed.
//Caller can then use CryptUIWizDigitalSign to sign the CTL.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING           0x0008

//CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user for the purpose, validity,
//and list ID of the CTL.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE           0x0010


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT
{
    DWORD           dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT)
    PCCERT_CONTEXT  pCertContext;       //Required: Use the private key of the certificate context
                                        //          The certificate context
                                        //          has to have CERT_KEY_PROV_INFO_PROP_ID property
                                        //          and the private key has to exist
}CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT;

typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING)
    PCRYPT_KEY_PROV_INFO    pKeyProvInfo;       //Required: The information about the provider and the private key
                                                //          The optional CRYPT_KEY_PROV_PARAM fields in PCRYPT_KEY_PROV_INFO
                                                //          are ignored.
}CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING;

typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING;

///-----------------------------------------------------------------------
//  CERT_REQUEST_PVK_NEW
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW)
    PCRYPT_KEY_PROV_INFO    pKeyProvInfo;       //Optional: The information about the provider and the private key
                                                //          NULL means use the default
                                                //          The optional CRYPT_KEY_PROV_PARAM fields in PCRYPT_KEY_PROV_INFO
                                                //          are ignored.
    DWORD                   dwGenKeyFlags;      //Optional: The flags for CryptGenKey
}CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW;


typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_TYPE
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_TYPE
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_TYPE)
    DWORD                   cCertType;          //the count of rgwszCertType.  cCertType should be 1.
    LPWSTR                  *rgwszCertType;     //the array of certificate type name
}CRYPTUI_WIZ_CERT_TYPE, *PCRYPTUI_WIZ_CERT_TYPE;

typedef const CRYPTUI_WIZ_CERT_TYPE *PCCRYPTUI_WIZ_CERT_TYPE;


//-----------------------------------------------------------------------
// dwPvkChoice
//-----------------------------------------------------------------------
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT        1
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING    2
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW         3

//-----------------------------------------------------------------------
// dwPurpose
//-----------------------------------------------------------------------

#define     CRYPTUI_WIZ_CERT_ENROLL     0x00010000
#define     CRYPTUI_WIZ_CERT_RENEW      0x00020000

//-----------------------------------------------------------------------
//
// valid flags for dwPostOption
//-----------------------------------------------------------------------
//post the requested certificate on the directory serivce
#define     CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS                     0x01

//post the requested certificate with the private key container.
#define     CRYPTUI_WIZ_CERT_REQUEST_POST_ON_CSP                    0x02

//-----------------------------------------------------------------------
//
// valid flags for dwCertChoice
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                      0x01

#define     CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE                      0x02
//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_CERT_REQUEST_INFO
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_INFO
{
	DWORD			    dwSize;				    //Required: Has to be set to sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO)
    DWORD               dwPurpose;              //Required: If CRYPTUI_WIZ_CERT_ENROLL is set, a certificate will be enrolled,
                                                //          If CRYPTUI_WIZ_CERT_RENEW  is set, a certificate will be renewed.
                                                //          CRYPTUI_WIZ_CERT_ENROLL and CRYPTUI_WIZ_CERT_RENEW can not be set
                                                //          at the same time
    LPCWSTR             pwszMachineName;        //Optional: The machine name for which to enroll.
    LPCWSTR             pwszAccountName;        //Optional: The account name(user or service) for which to enroll
                                                //
                                                //  pwszMachineName     pwszAccountName    Meaning
                                                //---------------------------------------------------
                                                //  NULL                NULL               Request for current account on the current machine
                                                //  "fooMachine"        NULL               Request for the machine named "fooMachine"
                                                //  NULL                "fooUser"          Request for the "fooUser" account on the current machine
                                                //  "fooMachine"        "fooUser"          Request for the "fooUser" accunt on the "fooMachine" machine
                                                //
    void                *pAuthentication;       //Reserved: authenticate info.  Must be set to NULL.
    LPCWSTR             pCertRequestString;     //Reserved: The additional request string.  Must be set to NULL.
    LPCWSTR             pwszDesStore;           //Optional: The desination store where to put
                                                //              the enrolled certificate.  Default to "My" if the value is NULL
    DWORD               dwCertOpenStoreFlag;    //Optional: The value passed to dwFlags of CertOpenStore for the
                                                //          destination store
                                                //          If this value is 0, we use CERT_SYSTEM_STORE_CURRENT_USER for
                                                //          an accout and CERT_SYSTEM_STORE_LOCAL_MACHINE for a machine
    LPCSTR              pszHashAlg;             //Optional: The oid string of the hash algorithm of the certificate.
	PCCERT_CONTEXT      pRenewCertContext;      //Required  if CRYPTUI_WIZ_CERT_RENEW  is set in dwPurpose
                                                //Ignored   otherwise and shoule be set to NULL.
    DWORD               dwPvkChoice;            //Required: Specify the private key information
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW
    union                                       //Required.
    {
		PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT      pPvkCert;	
        PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING  pPvkExisting;
        PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW       pPvkNew;
    };

    LPCWSTR             pwszCALocation;         //Required  if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                                                //Optional  Otherwise
                                                //Optional  Otherwise
                                                //          The machine name of the Certiviate Authority (CA)
    LPCWSTR             pwszCAName;             //Required   if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //Optional  Otherwise
                                                //          The name of the Certificate Authority (CA)
    DWORD               dwPostOption;           //Optional  Can set to any combination of the following flag:
                                                //              CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS
                                                //
    DWORD               dwCertChoice;           //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //          and CRYPTUI_WIZ_NO_UI is not set
                                                //Required  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //          and CRYPTUI_WIZ_NO_UI is set
                                                //ignored   otherwise and should be set to 0.
                                                //          Specify the type of the requested certificate
                                                //          it can be one of the following flag:
                                                //              CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //              CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE
    union
    {
        PCERT_ENHKEY_USAGE      pKeyUsage;      //          Indicate the enhanced key usage OIDs for the requested certificate.
        PCCRYPTUI_WIZ_CERT_TYPE pCertType;      //          Indicate the certificate type of the requested certificate
    };

    LPCWSTR             pwszFriendlyName;       //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //Ignored   otherwise and should be set to NULL.
                                                //          The friendly name of the certificate
    LPCWSTR             pwszDescription;        //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //Ignored   otherwise and should be set to NULL.
                                                //          The description of the certificate
    PCERT_EXTENSIONS    pCertRequestExtensions; //Optional  The extensions to add to the certificate request
    LPWSTR              pwszCertDNName;         //Optional  The certificate DN string
}CRYPTUI_WIZ_CERT_REQUEST_INFO, *PCRYPTUI_WIZ_CERT_REQUEST_INFO;

typedef const CRYPTUI_WIZ_CERT_REQUEST_INFO *PCCRYPTUI_WIZ_CERT_REQUEST_INFO;


//-----------------------------------------------------------------------
//
// possible status for pdwStatus
//  Those status indicate the status value returned
//  from the certificate authority (certificate server).
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED           0
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR       1
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED      2
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY   3
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION    4
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN             5
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_CERT_ISSUED         6
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED   7


//-----------------------------------------------------------------------
//
//  CryptUIWizCertRequest
//
//      Request a certificate via a wizard.
//
//  dwFlags:  IN Optional
//      If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.
//      If CRYPTUI_WIZ_NO_INSTALL_ROOT is set in dwFlags, the wizard will not
//      install the issued certificate chain into the root store,
//      instead, it will put the certificate chain into the CA store.

//
//  hwndParent:  IN Optional
//      The parent window for the UI.  Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pwszWizardTitle: IN Optional
//      The title of the wizard.   Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pCertRequestInfo: IN Required
//      A pointer to CRYPTUI_WIZ_CERT_REQUEST_INFO struct
//
//  ppCertContext: Out Optional
//      The issued certificate.  The certificate is in a memory store for remote enrollment.
//      The certificate is in a system cert store for local enrollment.
//
//      Even the function return TRUE, it does not mean the certificate is issued.  Use should
//      check for the *pdwCAStatus.  If the status is CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//      of   CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION, *ppCertContext will be NULL.
//      It is valid only if *pdwCAStatus==CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//
//  pdwCAStatus: Out Optional.
//      The return status of the certificate authority cerver.  The dwStatus can be one of
///     the following:
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizCertRequest(
 IN             DWORD                           dwFlags,
 IN OPTIONAL    HWND                            hwndParent,
 IN OPTIONAL    LPCWSTR                         pwszWizardTitle,
 IN             PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
 OUT OPTIONAL   PCCERT_CONTEXT                  *ppCertContext,
 OUT OPTIONAL   DWORD                           *pCAdwStatus
);

//-------------------------------------------------------------------------
//
//	Valid values for dwSubjectChoice in IMPORT_SUBJECT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_FILE                 1
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT         2
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT          3
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT          4
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE           5

//-------------------------------------------------------------------------
//
//	Struct to define the subject CertImportWizard
//
//  CRYPTUI_WIZ_IMPORT_SUBJECT_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_IMPORT_SUBJECT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(IMPORT_SUBJECT_INFO)
	DWORD					dwSubjectChoice;	//Required:	indicate the type of the subject:
                                                //          If can one of the following:
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_FILE
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE
    union
	{
		LPCWSTR          	pwszFileName;	
        PCCERT_CONTEXT      pCertContext;
        PCCTL_CONTEXT       pCTLContext;
        PCCRL_CONTEXT       pCRLContext;
        HCERTSTORE          hCertStore;
    };

    DWORD                   dwFlags;            //Required if pwszFileName contains a PFX BLOB.
                                                //Ignored otherwise
                                                //This is the same flag for PFXImportCertStore
    LPCWSTR                 pwszPassword;       //Required if pwszFileName contains a PFX BLOB.
                                                //ignored otherwise
}CRYPTUI_WIZ_IMPORT_SRC_INFO, *PCRYPTUI_WIZ_IMPORT_SRC_INFO;

typedef const CRYPTUI_WIZ_IMPORT_SRC_INFO *PCCRYPTUI_WIZ_IMPORT_SRC_INFO;

//-----------------------------------------------------------------------
//
// Valid flags for dwFlags in CryptUIWizImport
//
//-----------------------------------------------------------------------
//if this flag is set in dwFlags, user will not be allowed to change
//the hDesCertStore in the wizard page
#define   CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE           0x00010000

//Allow importing certificate
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CERT                     0x00020000

//Allow importing certificate revocation list
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CRL                      0x00040000

//Allow importing certificate trust list
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CTL                      0x00080000

//-----------------------------------------------------------------------
//
// CryptUIWizImport
//
//  The import wizard to import public key related files to a certificate
//  store
//
//  dwFlags can be set to any combination of the following flags:
//  CRYPTUI_WIZ_NO_UI                           No UI will be shown.  Otherwise, User will be
//                                              prompted by a wizard.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT               Allow importing certificate
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL                Allow importing CRL(certificate revocation list)
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL                Allow importing CTL(certificate trust list)
//  CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE     user will not be allowed to change
//                                              the hDesCertStore in the wizard page
//  Please notice that if neither of following three flags is in dwFlags, default to is
//  allow everything.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL
//
//
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pImportSubject:     IN Required:    The subject to import.
//      hDesCertStore:      IN Optional:    The destination certficate store
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_IMPORT_WIZARD_TITLE
//      pImportSubject:     IN Optional:    The file name to import.
//                                          If NULL, the wizard will prompt user to enter the file name
//      hDesCertStore:      IN Optional:    The destination certificate store where the file wil be
//                                          imported to.  The store should be opened with
//                                          flag CERT_STORE_SET_LOCALIZED_NAME_FLAG.  If NULL, the wizard will prompt user to select
//                                          a certificate store.
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizImport(
     DWORD                               dwFlags,
     HWND                                hwndParent,
     LPCWSTR                             pwszWizardTitle,
     PCCRYPTUI_WIZ_IMPORT_SRC_INFO       pImportSrc,
     HCERTSTORE                          hDestCertStore
);


//-------------------------------------------------------------------------
//
//	Struct to define the information needed to build a new CTL
//
//  CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO
{
	DWORD			    dwSize;				    //Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_NEW_CTL)
    PCERT_ENHKEY_USAGE  pSubjectUsage;          //Optioanl: The purpose of the CTL
    LPWSTR              pwszListIdentifier;     //Optional: The string to identify the CTL
    LPCSTR              pszSubjectAlgorithm;    //Optional: The hashing algorithm.
                                                //          Currently, only SHA1 or MD5 hashing is supported
    HCERTSTORE          hCertStore;             //Optional: The certificate in the CTL.  Only the certificates
                                                //          with the enhanced key usage specified by pSubjectUsage
                                                //          will be included in the CTL
    FILETIME            NextUpdate;             //Optional: The next update time of the CTL.  If the value
                                                //          is more than 99 month from the current system time,
                                                //          the value will be ignored.
    LPWSTR              pwszFriendlyName;       //Optional: The friendly name of the CTL
    LPWSTR              pwszDescription;        //Optional: The description of the CTL
}CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO, *PCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO *PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO;

//-------------------------------------------------------------------------
//
//	Valid values for dwSourceChoice for CRYPTUI_WIZ_BUILDCTL_SRC_INFO
//-------------------------------------------------------------------------
#define         CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL       1
#define         CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL            2

//-------------------------------------------------------------------------
//
//	Struct to define the source of certBuildCTL wizard
//
//  CRYPTUI_WIZ_BUILDCTL_SRC_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_SRC_INFO
{
	DWORD			dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_SRC_INFO)
    DWORD           dwSourceChoice;     //Required: indicate the source from which to build the CTL
                                        //          if can be one of the following:
                                        //          CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL
                                        //          CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL
    union
    {
        PCCTL_CONTEXT                       pCTLContext;    //Required if dwSourceChoice == CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL
                                                            //          An existing CTL based on which a new CTL is to be built
        PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO pNewCTLInfo;        //Required if dwSourceChoise == CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL
    };
}CRYPTUI_WIZ_BUILDCTL_SRC_INFO, *PCRYPTUI_WIZ_BUILDCTL_SRC_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_SRC_INFO *PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO;

//-------------------------------------------------------------------------
//
//	Valid values for dwDestinationChoice for CRYPTUI_WIZ_BUILDCTL_DEST_INFO
//-------------------------------------------------------------------------
#define         CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE     1
#define         CRYPTUI_WIZ_BUILDCTL_DEST_FILE           2
//-------------------------------------------------------------------------
//
//	Struct to define the desination of certBuildCTL wizard
//
//  CRYPTUI_WIZ_BUILDCTL_DEST_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_DEST_INFO
{
	DWORD					dwSize;				 //Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_DEST_INFO)
	DWORD					dwDestinationChoice; //Required:	indicate the type of the desination:
                                                 //          If can one of the following:
                                                 //          CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE
                                                 //          CRYPTUI_WIZ_BUILDCTL_DEST_FILE
    union
	{
		LPCWSTR          	pwszFileName;	
        HCERTSTORE          hCertStore;
    };

}CRYPTUI_WIZ_BUILDCTL_DEST_INFO, *PCRYPTUI_WIZ_BUILDCTL_DEST_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_DEST_INFO *PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizBuildCTL
//
//  Build a new CTL or modify an existing CTL.   The UI for wizard will
//  always show in this case
//
//
//  dwFlags:            IN  Optional:   Can be set to the any combination of the following:
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION.
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_BUILDCTL_WIZARD_TITLE
//  pBuildCTLSrc:       IN  Optional:   The source from which the CTL will be built
//  pBuildCTLDest:      IN  Optional:   The desination where the newly
//                                      built CTL will be stored
//  ppCTLContext:       OUT Optaionl:   The newly build CTL
//
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizBuildCTL(
    IN              DWORD                                   dwFlags,
    IN  OPTIONAL    HWND                                    hwndParent,
    IN  OPTIONAL    LPCWSTR                                 pwszWizardTitle,
    IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO         pBuildCTLSrc,
    IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO        pBuildCTLDest,
    OUT OPTIONAL    PCCTL_CONTEXT                           *ppCTLContext
);


//-------------------------------------------------------------------------
//
//	Valid values for dwSubjectChoice in CRYPTUI_WIZ_EXPORT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_EXPORT_CERT_CONTEXT 			        1
#define     CRYPTUI_WIZ_EXPORT_CTL_CONTEXT  			        2
#define     CRYPTUI_WIZ_EXPORT_CRL_CONTEXT  			        3
#define     CRYPTUI_WIZ_EXPORT_CERT_STORE   			        4
#define     CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY   	5

//-------------------------------------------------------------------------
//
//	Struct to define the object to be exported and where to export it to
//
//  CRYPTUI_WIZ_EXPORT_SUBJECT_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_EXPORT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_EXPORT_INFO)
    LPCWSTR                 pwszExportFileName; //Required if the CRYPTUI_WIZ_NO_UI flag is set, Optional otherwise.
                                                //The fully qualified file name to export to, if this is
                                                //non-NULL and the CRYPTUI_WIZ_NO_UI flag is NOT set, then it is
                                                //displayed to the user as the default file name
	DWORD					dwSubjectChoice;	//Required:	indicate the type of the subject:
                                                //          If can one of the following:
                                                //          CRYPTUI_WIZ_EXPORT_CERT_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CTL_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CRL_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CERT_STORE
						                        //	        CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY
    union
	{
	PCCERT_CONTEXT      pCertContext;
        PCCTL_CONTEXT       pCTLContext;
        PCCRL_CONTEXT       pCRLContext;
        HCERTSTORE          hCertStore;
    };

    DWORD                   cStores;            // Optional: count of extra stores to search for the certs in the
                                                //           trust chain if the chain is being exported with a cert.
                                                //           this is ignored if dwSubjectChoice is anything other
                                                //           than CRYPTUI_WIZ_EXPORT_CERT_CONTEXT
    HCERTSTORE *            rghStores;          // Optional: array of extra stores to search for the certs in the
                                                //           trust chain if the chain is being exported with a cert.
                                                //           this is ignored if dwSubjectChoice is anything other
                                                //           than CRYPTUI_WIZ_EXPORT_CERT_CONTEXT

}CRYPTUI_WIZ_EXPORT_INFO, *PCRYPTUI_WIZ_EXPORT_INFO;

typedef const CRYPTUI_WIZ_EXPORT_INFO *PCCRYPTUI_WIZ_EXPORT_INFO;


//-------------------------------------------------------------------------
//
//	Valid values for dwExportFormat in CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_EXPORT_FORMAT_DER                   1
#define     CRYPTUI_WIZ_EXPORT_FORMAT_PFX                   2
#define     CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7                 3
#define     CRYPTUI_WIZ_EXPORT_FORMAT_BASE64                4
#define     CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE 5   // NOTE: not currently supported!!

//-------------------------------------------------------------------------
//
//	Struct to define the information needed to export a CERT_CONTEXT
//
//  CRYPTUI_WIZ_EXPORT_NOUI_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_EXPORT_NOUI_INFO)
	DWORD					dwExportFormat;	    //Required:
                                                //          It can be one of the following:
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_DER
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_PFX
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE

    BOOL                    fExportChain;       //Required
    BOOL                    fExportPrivateKeys; //Required 
    LPCWSTR                 pwszPassword;       //Required if the fExportPrivateKeys boolean is TRUE, otherwise,
                                                //it is ignored
    BOOL                    fStrongEncryption;  //Required if dwExportFormat is CRYPTUI_WIZ_EXPORT_FORMAT_PFX
                                                //Note that if this flag is TRUE then the PFX blob produced is
                                                //NOT compatible with IE4.

}CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO, *PCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO;

typedef const CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO *PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizExport
//
//  The export wizard to export public key related objects to a file
//
//  If dwFlags is set to CRYPTUI_WIZ_NO_UI, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pExportInfo:        IN Required:    The subject to export.
//      pvoid:              IN Required:    Contains information about how to do the export based on what
//                                          is being exported
//
//                                          dwSubjectChoice                     INPUT TYPE
//                                          -------------------------------------------------------------------------
//                                          CRYPTUI_WIZ_EXPORT_CERT_CONTEXT     PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
//                                          CRYPTUI_WIZ_EXPORT_CTL_CONTEXT      NULL
//                                          CRYPTUI_WIZ_EXPORT_CRL_CONTEXT      NULL
//                                          CRYPTUI_WIZ_EXPORT_CERT_STORE       NULL
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_EXPORT_WIZARD_TITLE
//      pExportInfo:        IN Required:    The subject to export.
//      pvoid:              IN Optional:    Contains information about how to do the export based on what
//                                          is being exported.  See above table for values, if this is non-NULL
//                                          the values are displayed to the user as the default choices.
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizExport(
     DWORD                                  dwFlags,
     HWND                                   hwndParent,
     LPCWSTR                                pwszWizardTitle,
     PCCRYPTUI_WIZ_EXPORT_INFO              pExportInfo,
     void                                   *pvoid
);



//-------------------------------------------------------------------------
//valid values for dwSubjectChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE           0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB           0x02


//-------------------------------------------------------------------------
//valid values for dwSigningCertChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_CERT                   0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_STORE                  0x02
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK                    0x03

//-------------------------------------------------------------------------
//valid values for dwAddtionalCertChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
//include the entire certificate trust chain in the signature
#define CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN               0x00000001

//include the entilre certificate trust chain, with the exception of the root
//certificate, in the signature
#define CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT       0x00000002

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
//
//  dwSize			IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO)
//  pGuidSubject    IN Required: Idenfity the sip functions to load
//  cbBlob			IN Required: the size of BLOB, in bytes
//  pbBlob		    IN Required: the pointer to the BLOB
//  pwszDispalyName IN Optional: the display name of the BLOB to sign.
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
{
    DWORD               dwSize;			
    GUID                *pGuidSubject;
    DWORD               cbBlob;				
    BYTE                *pbBlob;			
    LPCWSTR             pwszDisplayName;
}CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO
//
//	dwSize				IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO)
//  cCertStore          IN Required: The acount of certificate store array that includes potentical sining certs
//  rghCertStore        IN Required: The certificate store array that includes potential signing certs
//  pFilterCallback     IN Optional: The filter call back function for display the certificate
//  pvCallbackData      IN Optional: The call back data
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO
{
	DWORD               dwSize;	
	DWORD               cCertStore;			
    HCERTSTORE          *rghCertStore;
    PFNCFILTERPROC      pFilterCallback;
    void *              pvCallbackData;
}CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO
//
//	dwSize				        IN Required: should be set to sizeof(CRYPT_WIZ_DIGITAL_SIGN_PVK_FILE_INFO)
//  pwszPvkFileName             IN Required: the PVK file name
//  pwszProvName                IN Required: the provider name
//  dwProvType                  IN Required: the provider type
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO
{
	DWORD                   dwSize;
    LPWSTR                  pwszPvkFileName;
    LPWSTR                  pwszProvName;
    DWORD                   dwProvType;
}CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO;

//-------------------------------------------------------------------------
//
// valid values for dwPvkChoice in CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE        0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV        0x02


//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO
//
//	dwSize				        IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO)
//  pwszSigningCertFileName     IN Required: the file name that contains the signing cert(s)
//  dwPvkChoice                 IN Required: Indicate the private key type:
//                                           It can be one of the following:
//                                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE
//                                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV
//  pPvkFileInfo                IN Required if dwPvkChoice == CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE
//  pPvkProvInfo                IN Required if dwPvkContainer== CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO
{
	DWORD                   dwSize;
    LPWSTR                  pwszSigningCertFileName;
    DWORD					dwPvkChoice;		
    union
	{
        PCCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO      pPvkFileInfo;
        PCRYPT_KEY_PROV_INFO                        pPvkProvInfo;
    };

}CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO;

//-------------------------------------------------------------------------
//
// valid values for dwAttrFlags in CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO struct
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL         0x0001
#define     CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL         0x0002

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
//
//   dwSize			        IN Required:  should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO)
//   dwAttrFlags            IN Required:  Flag to indicate signing options.
//                                        It can be one of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL
//   pwszDescription        IN Optional:  The description of the signing subject
//   pwszMoreInfoLocation   IN Optional:  the localtion to get more information about file
//                                        this information will be shown upon download time
//   pszHashAlg             IN Optional:  the hashing algorithm for the signature
//                                        NULL means using SHA1 hashing algorithm
//   pwszSigningCertDisplayString  IN Optional: The display string to be displayed on the
//                                        signing certificate wizard page.  The string should
//                                        prompt user to select a certificate for a particular purpose
//   hAddtionalCertStores  IN Optional:   the addtional cert store to add to the signature
//   psAuthenticated	    IN Optional:  user supplied authenticated attributes added to the signature
//   psUnauthenticated	    IN Optional:  user supplied unauthenticated attributes added to the signature
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
{
	DWORD		            dwSize;			
    DWORD                   dwAttrFlags;
    LPCWSTR                 pwszDescription;
	LPCWSTR				    pwszMoreInfoLocation;		
    LPCSTR                  pszHashAlg;
    LPCWSTR                 pwszSigningCertDisplayString;
    HCERTSTORE              hAdditionalCertStore;
	PCRYPT_ATTRIBUTES		psAuthenticated;	
	PCRYPT_ATTRIBUTES		psUnauthenticated;	
}CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO;
//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_DIGITAL_SIGN_INFO
//
// dwSize			    IN Required: Has to be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO)
// dwSubjectChoice	    IN Required if CRYPTUI_WIZ_NO_UI is set in dwFlags of the CryptUIWizDigitalSigning,         :
//                         Optional if CRYPTUI_WIZ_NO_UI is not set in dwFlags of the CryptUIWizDigitalSigning
//                                  Indicate whether to sign a file or to sign a memory BLOB.
//                                  0 means promting user for the file to sign
//                                  It can be one of the following:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE
//			                        CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB
//
//
//pwszFileName	        IN Required if dwSubjectChoice==CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE
//pSignBlobInfo	        IN Required if dwSubhectChoice==CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB
//
//dwSigningCertChoice   IN Optional: Indicate the signing certificate.
//                                  0 means using the certificates in "My" store"
//                                  It can be one of the following choices:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_CERT
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_STORE
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//                                  If CRYPTUI_WIZ_NO_UI is set in dwFlags of the CryptUIWizDigitalSigning,
//                                  dwSigningCertChoice has to be CRYPTUI_WIZ_DIGITAL_SIGN_CERT or
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//
//pSigningCertContext       IN Required if dwSigningCertChoice==CRYPTUI_WIZ_DIGITAL_SIGN_CERT
//pSigningCertStore         IN Required if dwSigningCertChoice==CRYPTUI_WIZ_DIGITAL_SIGN_STORE
//pSigningCertPvkInfo       IN Required if dwSigningCertChoise==CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//
//pwszTimestampURL      IN Optional: The timestamp URL address
//
//dwAdditionalCertChoice IN Optional: Indicate additional certificates to be included in the signature.                                                       //
//                                  0 means no addtional certificates will be added
//                                  The following flags are mutually exclusive.
//                                  Only one of them can be set:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT
//
//
//pSignExtInfo         IN Optional: The extended information for signing
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_INFO
{
	DWORD			                            dwSize;			
	DWORD					                    dwSubjectChoice;	
	union
	{
		LPCWSTR                                 pwszFileName;	
		PCCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO    pSignBlobInfo;	
	};

    DWORD                                       dwSigningCertChoice;
    union
    {
        PCCERT_CONTEXT                              pSigningCertContext;
        PCCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO       pSigningCertStore;
        PCCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO    pSigningCertPvkInfo;
    };

    LPCWSTR                                     pwszTimestampURL;
    DWORD                                       dwAdditionalCertChoice;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO    pSignExtInfo;

}CRYPTUI_WIZ_DIGITAL_SIGN_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
//
//  dwSize			 set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT)
//  cbBlob			 the size of pbBlob.  In bytes
//  pbBlob		     the signed BLOB
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
{
    DWORD               dwSize;			
    DWORD               cbBlob;				
    BYTE                *pbBlob;			
}CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT, *PCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT *PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT;

//-----------------------------------------------------------------------
//
// CryptUIWizDigitalSign
//
//  The wizard to digitally sign a document or a BLOB.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  dwFlags:            IN  Required:
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_DIGITAL_SIGN_WIZARD_TITLE
//  pDigitalSignInfo:   IN  Required:   The information about the signing process
//  ppSignContext       OUT Optional:   The context pointer points to the signed BLOB
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizDigitalSign(
     IN                 DWORD                               dwFlags,
     IN     OPTIONAL    HWND                                hwndParent,
     IN     OPTIONAL    LPCWSTR                             pwszWizardTitle,
     IN                 PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo,
     OUT    OPTIONAL    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  *ppSignContext);


BOOL
WINAPI
CryptUIWizFreeDigitalSignContext(
     IN  PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT   pSignContext);


//-------------------------------------------------------------------------
//valid values for dwPageChoice in CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//-------------------------------------------------------------------------

#define     CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES       0x0001
#define     CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES       0x0002
#define     CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES        0x0004
#define     CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES           0x0008

#define     CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE                       0x0100
#define     CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE                     0x0200
#define     CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE                  0x0400


//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//
//	dwSize				IN Required:    should be set to sizeof(CRYPTUI_WIZ_SIGN_GET_PAGE_INFO)
//  dwPageChoice:       IN Required:    It should one of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES
//                                      It can also be ORed with any of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE
//                                      If user tries to sign a BLOB, CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE
//                                      should not be set
//  dwFlags;            IN Optional:    Flags and has to be set to 0
//  hwndParent          IN Optional:    The parent window of the dialogue
//  pwszPageTitle       IN Optional:    The title for the pages and the message boxes.
//  pDigitalSignInfo    IN Optional:    the addtional information for signing
//  pPropPageCallback   IN Optional:    this callback will be called when each page that is
//                                      returned in the CryptUIGetViewSignaturesPages call
//                                      is about to be created or destroyed.  if this is NULL no
//                                      callback is made.
//  pvCallbackData      IN Optional:    this is uniterpreted data that is passed back when the
//                                      when pPropPageCallback is made
//  fResult             OUT:            The result of signing
//  dwError             OUT:            The value of GetLastError() if fResult is FALSE
//  pSignContext        OUT:            The context pointer to the signed BLOB.  User needs to free
//                                      the blob by CryptUIWizDigitalSignFreeContext
//  dwReserved          Reserved:       The private data used by the signing process.
//                                      must be set to NULL
//  pvSignReserved      Reserved:       The private data used by the signing process
//                                      must be set to NULL
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_GET_SIGN_PAGE_INFO
{
	DWORD				                dwSize;	
    DWORD                               dwPageChoice;
    DWORD                               dwFlags;
    HWND                                hwndParent;
    LPWSTR                              pwszPageTitle;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo;
    PFNCPROPPAGECALLBACK                pPropPageCallback;
    void *                              pvCallbackData;
    BOOL                                fResult;
    DWORD                               dwError;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  pSignContext;
    DWORD                               dwReserved;
    void                                *pvSignReserved;
}CRYPTUI_WIZ_GET_SIGN_PAGE_INFO, *PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO;

typedef const CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *PCCRYPTUI_WIZ_GET_SIGN_PAGE_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizGetDigitalSignPages
//
//  Get specific wizard pages from the CryptUIWizDigitalSign wizard.
//  Application can include the pages to other wizards.  The pages will
//  gather user inputs throught the new "Parent" wizard.
//  After user clicks the finish buttion, signing process will start the signing
//  and return the result in fResult and dwError field of CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//  struct.  If not enough information can be gathered through the wizard pages,
//  user should supply addtional information in pSignGetPageInfo.
//
//
// pSignGetPageInfo    IN   Required:   The struct that user allocate.   It can be used
//                                      to supply additinal information which is not gathered
//                                      from the selected wizard pages
// prghPropPages,      OUT  Required:   The wizard pages returned.  Please
//                                      notice the pszTitle of the struct is set to NULL
// pcPropPages         OUT  Required:   The number of wizard pages returned
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizGetDigitalSignPages(
     IN     PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO     pSignGetPageInfo,
     OUT    PROPSHEETPAGEW                      **prghPropPages,
     OUT    DWORD                               *pcPropPages);

BOOL
WINAPI
CryptUIWizFreeDigitalSignPages(
            IN PROPSHEETPAGEW    *rghPropPages,
            IN DWORD             cPropPages
            );








#pragma pack()

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // _CRYPTUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#include <initguid.h>
#include <ole2.h>
#define INITGUID
#include "mimeole.h"
#include <msoert.h>
#include "envguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\external\inc\proofbse.h ===
/********************************************************************
  ProofBase.h - Base API definitions for CSAPI, CTAPI, & CHAPI
	Speller, Thesaurus, and Hyphenator

  Version 3.0 - all api's

    History:
	5/97	DougP	Created
	12/97	DougP	Copied from ProofAPI.h and Separated into tool section files

    The Natural Language Group maintains this file.

  1997 Microsoft Corporation
********************************************************************/

#if !defined(PROOFBASE_H)
#define PROOFBASE_H

#pragma pack(push, proofapi_h, 8)	// default alignment

#include "vendor.h"

  // you may wish to include lid.h for some convenient langid defs
#if !defined(lidUnknown)
#	define lidUnknown	0xffff
#endif

/*************************************************************
     PART 1 - Structure Defs
**************************************************************/
/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) --------- */

/* hardcoded ordinals are the exported dll entry points */
// individual def files have these as well so be sure to change them
// if you change these
#define idllProofVersion		20
#define idllProofInit			21
#define idllProofTerminate		22
#define idllProofOpenLex		23
#define idllProofCloseLex		24
#define idllProofSetOptions		25
#define idllProofGetOptions		26

typedef unsigned long PTEC;		// ptec

/******************* Proofing Tool Error Codes ************************/
	/* Major Error Codes in low two bytes (WORD) of PTEC */
enum {
	ptecNoErrors,
	ptecOOM,			/* memory error */
	ptecModuleError,	/* Something wrong with parameters, or state of spell module. */
	ptecIOErrorMainLex,	 /* Read,write,or share error with Main Dictionary. */
	ptecIOErrorUserLex,	 /* Read,write,or share error with User Dictionary. */
	ptecNotSupported,	/* No support for requested operation */
	ptecBufferTooSmall,	/* Insufficient room for return info */
	ptecNotFound,		/* Hyphenator and Thesaurus only */
	ptecModuleNotLoaded,	/* underlying module not loaded (Glue Dll's) */
};

/* Minor Error Codes in high two bytes of PTEC */
/* (Not set unless major code also set) */
enum {
	ptecModuleAlreadyBusy=128,	/* For non-reentrant code */
	ptecInvalidID,				/* Not yet inited or already terminated.*/
	ptecInvalidWsc,				/* Illegal values in WSC struct (speller only) */
	ptecInvalidMainLex,		/* Mdr not registered with session */
	ptecInvalidUserLex,		/* Udr not registered with session */
	ptecInvalidCmd,				/* Command unknown */
	ptecInvalidFormat,			/* Specified dictionary not correct format */
	ptecOperNotMatchedUserLex,	/* Illegal operation for user dictionary type. */
	ptecFileRead,				/* Generic read error */
	ptecFileWrite,				/* Generic write error */
	ptecFileCreate,				/* Generic create error */
	ptecFileShare,				/* Generic share error */
	ptecModuleNotTerminated,	/* Module not able to be terminated completely.*/
	ptecUserLexFull,			/* Could not update Udr without exceeding limit.*/
	ptecInvalidEntry,			/* invalid chars in string(s) */
	ptecEntryTooLong,			/* Entry too long, or invalid chars in string(s) */
	ptecMainLexCountExceeded,	/* Too many Mdr references */
	ptecUserLexCountExceeded,	/* Too many udr references */
	ptecFileOpenError,			/* Generic Open error */
	ptecFileTooLargeError,		/* Generic file too large error */
	ptecUserLexReadOnly,		/* Attempt to add to or write RO udr */
	ptecProtectModeOnly,		/* (obsolete) */
	ptecInvalidLanguage,		/* requested language not available */
};


#define ProofMajorErr(x) LOWORD(x)
#define ProofMinorErr(x) HIWORD(x)

/************* Structure def macros *************
Smoke and mirrors to allow initialization of some members when
using C++
***********************************/
#if !defined(__cplusplus)
#	define STRUCTUREBEGIN(x) typedef struct {
#	define STRUCTUREEND0(x) } x;
#	define STRUCTUREEND1(x, y) } x;
#	define STRUCTUREEND2(x, y, z) } x;
#	define STRUCTUREEND3(x, y, z, w) } x;
#else
#	define STRUCTUREBEGIN(x) struct x {
#	define STRUCTUREEND0(x) };
#	define STRUCTUREEND1(x, y) public: x() : y {} };
#	define STRUCTUREEND2(x, y, z) public: x() : y, z {} };
#	define STRUCTUREEND3(x, y, z, w) public: x() : y, z, w {} };
#endif

typedef DWORD PROOFVERNO;	// version

  /* Proof Information Structure - return info from ToolVersion */
STRUCTUREBEGIN(PROOFINFO)	// info
	WCHAR			*pwszCopyright;	/* pointer to copyright buffer -
											can be NULL if size is zero */
	PROOFVERNO	versionAPI;	  /* API */
	PROOFVERNO	versionVendor;	/* includes buildnumber */
	VENDORID		vendorid; 	/* from vendor.h */
	  /* size of copyright buffer in chars - client sets */
	DWORD			cchCopyright;	/* no error if too small or zero */
	DWORD			xcap;	/* tool dependent */
STRUCTUREEND2(PROOFINFO, pwszCopyright(0), cchCopyright(0))

/* xcap is the bitwise-or of */
enum {
	xcapNULL					=	0x00000000,
	xcapWildCardSupport			=	0x00000001,	// Speller only
	xcapMultiLexSupport			=	0x00000002,
	xcapUserLexSupport			=	0x00000008,	// a must for spellers
	xcapLongDefSupport			=	0x00000010,	// Thesaurus only
	xcapExampleSentenceSupport	=	0x00000020,	// Thesaurus only
	xcapLemmaSupport			=	0x00000040,	// Thesaurus only
	xcapAnagramSupport			=	0x00000100,	// Speller only
};	// xcap

typedef void * PROOFLEX;	// lex

typedef enum {
	lxtChangeOnce=0,
	lxtChangeAlways,
	lxtUser,
	lxtExclude,
	lxtMain,
	lxtMax,
	lxtIgnoreAlways=lxtUser,
} PROOFLEXTYPE;	// lxt


  // note this API does not support external user dictionaries with
  // Change (lxtChangeAlways or lxtChangeOnce) properties
  // It does support either UserLex (the norm) or Exclude types
  // Opening a udr with type Exclude automatically makes it apply to
  // the entire session
STRUCTUREBEGIN(PROOFLEXIN)	/* Dictionary Input Info - lxin */
	const WCHAR		*pwszLex;	// full path of dictionary to open
	BOOL			fCreate;	/* create if not already exist? (UDR's only) */
	PROOFLEXTYPE	lxt;	/* lxtMain, lxtUser, or lxtExclude (Speller UDR's only) */
	LANGID			lidExpected;	// expected LANGID of dictionary
STRUCTUREEND3(PROOFLEXIN, lidExpected(lidUnknown), fCreate(TRUE), lxt(lxtMain))


STRUCTUREBEGIN(PROOFLEXOUT)    /* Dictionary Output Info - lxout */
	WCHAR		*pwszCopyright;	/* pointer to copyright buffer (MDR only)
										-- can be NULL if size (below) is zero*/
	PROOFLEX	lex;			/* id for use in subsequent calls */
	DWORD		cchCopyright;	/* client sets - no error if too small or zero */
	PROOFVERNO	version;		/* version of lexfile - includes buildnumber */
	BOOL		fReadonly;		/* set if can't be written on */
	LANGID		lid;			/* LANGID actually used */
STRUCTUREEND2(PROOFLEXOUT, pwszCopyright(0), cchCopyright(0))

typedef void *PROOFID;	// id (or sid, hid, or tid)

#define PROOFMAJORVERSION(x)			(HIBYTE(HIWORD(x)))
#define PROOFMINORVERSION(x)			(LOBYTE(HIWORD(x)))
#define PROOFMAJORMINORVERSION(x)		(HIWORD(x))
#define PROOFBUILDNO(x)					(LOWORD(x))
#define PROOFMAKEVERSION1(major, minor, buildno)	(MAKELONG(buildno, MAKEWORD(minor, major)))
#define PROOFMAKEVERSION(major, minor)	PROOFMAKEVERSION1(major, minor, 0)

#define PROOFTHISAPIVERSION				PROOFMAKEVERSION(3, 0)

STRUCTUREBEGIN(PROOFPARAMS)	// xpar
	DWORD	versionAPI;	// API version requested
STRUCTUREEND1(PROOFPARAMS, versionAPI(PROOFTHISAPIVERSION))



/*************************************************************
     PART 2 - Function Defs
**************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif

/* -------------- Common Section (Speller, Hyphenator, and Thesaurus) -------------- 

the functions in this section are for documentation only -
separate versions exist for each tool.

  ---------------------------------------------- */
// ****************************************************************
//  ******** PROOFVERSION ****************
//  This is the only routine that can be called outside of a session.
//	ToolInit begins a session.

//	The version numbers are in hex format with  
//	the high byte representing the major version number,
//	the next byte the minor revision number, and the
//	low order bytes represent an optional build number. 
//	For example, version 1.00 is 0x01000000.  Version 2.13
//	is 0x020d0000.  Engines that support
//	this API should return 0x03000000 for iAPIVersion.

//	The engine ID identifies the core engine creator.  The list
//	in vendor.h identifies the possible values.  For example,
//	the Inso derived speller returns VendorIdInso.   iVendorVersion
//	is up to the vendor to manage and determine.

//	This routine may return in xcap the functionality
//	supported by the module.  Since modules are usually
//	dynamically linked, the application should read the
//	information and verify that required functionality is
//	present.
// PTEC WINAPI ToolVersion(ToolInfo *pInfo);
typedef PTEC (WINAPI *PROOFVERSION) (PROOFINFO *pinfo);

// ***********************************************************
// *** ToolInit
// This is the entry point for a session.  With the exception
// of ToolVersion, this routine must return successfully before
// use of any other routines.  ToolInit initializes internal
// structures and resources needed for subsequent calls into the
// module.  For example, SpellerInit initializes the UserLex,
// ChangeOnce, and ChangeAlways built-in UDR's.  In general,
// modules allocate and free resources as needed, transparent to
// the application.  pToolId is the handle to those variables.
// Modules store any data from the PROOFPARAMS structure internally
// and do not rely on the data in the structure remaining intact.

// PTEC WINAPI ToolInit(PROOFID *pToolid, const PROOFPARAMS *pxpar);
typedef PTEC (WINAPI *PROOFINIT) (PROOFID *pid, const PROOFPARAMS *pxpar);


// ************************************************************
// *** ToolTerminate 
// This function marks the end of the session.  It attempts to
// close all dictionaries and free up any and all other resources
// allocated by the module since ToolInit.

// Do not call ToolTerminate if  ToolInit was not successful.

// If fForce is TRUE, ToolTerminate is guaranteed to succeed.  If
// fForce is false, it may fail.  For example, there may be errors
// writing the user dictionaries out to disk.  After ToolTerminate
// (whether it succeeds or fails), all other module routines with
// the exception of ToolTerminate and ToolVersion are unusable
// until the module is successfully reinitialized using ToolInit.  

// If this call fails, successful re-initialization of the module
// is not guaranteed on all platforms.  In addition, failure to
// successfully terminate each session may lock memory and file
// resources in an unrecoverable way until terminate is successful.
// If the terminate call fails, the main application should either
// fix the problem (e.g., insert floppy in drive) and try to
// terminate again, or should terminate using the fForce flag
// switch.

// PTEC WINAPI ToolTerminate(PROOFID id, BOOL fForce);
typedef PTEC (WINAPI *PROOFTERMINATE) (PROOFID id, BOOL fForce);


// *****************************************************************
// *** ToolSetOptions
// Set the value of an option for a tool.  The value to set is in iOptVal.

// PTEC WINAPI ToolSetOptions(PROOFID id, int iOptionSelect, int iOptVal);
typedef PTEC (WINAPI *PROOFSETOPTIONS) (PROOFID id, DWORD iOptionSelect, const DWORD iOptVal);


// *****************************************************************
// *** ToolGetOptions
// Get the current value of an option from a tool.  Returns in *piOptVal;
// PTEC WINAPI ToolGetOptions(PROOFID id, int iOptionSelect, int *piOptVal);
typedef PTEC (WINAPI *PROOFGETOPTIONS) (PROOFID id, DWORD iOptionSelect, DWORD *piOptVal);


// *****************************************************************
// *** ToolOpenLex 
// The dictionary file (main or user) is opened and verified, but not
// necessarily loaded.
// PTEC WINAPI ToolOpenLex(PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);
typedef PTEC (WINAPI *PROOFOPENLEX) (PROOFID id, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);


// *****************************************************************
// *** ToolCloseLex
// Closes the specified dictionary and disassociates that dictionary
// from any subsequent checks.  In the case of user dictionaries,
// updates the disk file (if any).  If the dictionary file cannot
// be updated, the call fails unless the fForce parameter is also set.

// If fForce is true, ToolCloseLex is guaranteed to successfully
// remove the dictionary from the dictionary list and effectively
// close the file.  In this case, it the file could not be updated,
// the changes are lost, but the function is considered successful,
// and therefore returns ptecNOERRORS.

// PTEC WINAPI ToolCloseLex(PROOFID id, PROOFLEX dict, BOOL fforce);
typedef PTEC (WINAPI *PROOFCLOSELEX) (PROOFID id, PROOFLEX lex, BOOL fforce);
// fForce forces closing the specified user dictionary, even if the
// dictionary cannot be updated.  Has no meaning for main
// dictionaries.


/******************************** Special Glue DLL API ******************
For the glue dll's (converts the API for clients to tools that use API v1 for
speller, hyphenator, v2 for thesaurus), we need to set the name of the previous version
DLL to use - and the code page (that it can't figure out from the LANGID)
to use for any data conversion.
The glue dll's use the lid to set the code page for data conversion.

BOOL WINAPI ToolSetDllName(const WCHAR *pwszDllName, const UINT uCodePage);
*************************************************************************/
#define idllProofSetDllName		19
typedef BOOL (WINAPI *PROOFSETDLLNAME)(const WCHAR *pwszDllName, const UINT uCodePage);


#if defined(__cplusplus)
}
#endif
#pragma pack(pop, proofapi_h)	// restore to whatever was before

#endif // PROOFBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\external\inc\softpub.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       softpub.h
//
//  Contents:   Microsoft Internet Security Authenticode Policy Provider
//
//  History:    05-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef SOFTPUB_H
#define SOFTPUB_H

#include "wintrust.h"

#ifdef __cplusplus
extern "C" 
{
#endif

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// Softpub Policy Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Authenticode Policy Provider
//  (SOFTPUB.DLL's Policy Provider)
//  

#define SP_POLICY_PROVIDER_DLL_NAME         L"SOFTPUB.DLL"

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_VERIFY_V2 Guid  (Authenticode)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a file/object using the Microsoft Authenticode
//  Policy Provider,
//  
//          {00AAC56B-CD44-11d0-8CC2-00C04FC295EE}
//
#define WINTRUST_ACTION_GENERIC_VERIFY_V2                       \
            { 0xaac56b,                                         \
              0xcd44,                                           \
              0x11d0,                                           \
              { 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_INIT_FUNCTION                    L"SoftpubInitialize"
#define SP_OBJTRUST_FUNCTION                L"SoftpubLoadMessage"
#define SP_SIGTRUST_FUNCTION                L"SoftpubLoadSignature"
#define SP_CHKCERT_FUNCTION                 L"SoftpubCheckCert"
#define SP_FINALPOLICY_FUNCTION             L"SoftpubAuthenticode"
#define SP_CLEANUPPOLICY_FUNCTION           L"SoftpubCleanup"

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_TRUSTPROVIDER_TEST (Authenticode TEST)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to dump
//  the CRYPT_PROVIDER_DATA structure to a file after calling the 
//  Authenticode Policy Provider.
//  
//          {573E31F8-DDBA-11d0-8CCB-00C04FC295EE}
//
#define WINTRUST_ACTION_TRUSTPROVIDER_TEST                      \
            { 0x573e31f8,                                       \
              0xddba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_TESTDUMPPOLICY_FUNCTION_TEST     L"SoftpubDumpStructure"


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_CERT_VERIFY
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify
//  a certificate chain only.  This is only valid when passing in a
//  certificate context in the WinVerifyTrust input structures.
//  
//          {189A3842-3041-11d1-85E1-00C04FC295EE}
//
#define WINTRUST_ACTION_GENERIC_CERT_VERIFY                     \
            { 0x189a3842,                                       \
              0x3041,                                           \
              0x11d1,                                           \
              { 0x85, 0xe1, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define SP_GENERIC_CERT_INIT_FUNCTION       L"SoftpubDefCertInit"


//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_ACTION_GENERIC_CHAIN_VERIFY
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify
//  certificate chains created from any object type: file, cert, signer, ...
//  A callback is provided to implement the final chain policy using
//  the chain context for each signer and counter signer.
//  
//          {fc451c16-ac75-11d1-b4b8-00c04fb66ea0}
//
#define WINTRUST_ACTION_GENERIC_CHAIN_VERIFY                    \
            { 0xfc451c16,                                       \
              0xac75,                                           \
              0x11d1,                                           \
              { 0xb4, 0xb8, 0x00, 0xc0, 0x4f, 0xb6, 0x6e, 0xa0 }\
            }
#define GENERIC_CHAIN_FINALPOLICY_FUNCTION      L"GenericChainFinalProv"
#define GENERIC_CHAIN_CERTTRUST_FUNCTION        L"GenericChainCertificateTrust"


typedef struct _WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO
    WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO,
        *PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO;

struct _WTD_GENERIC_CHAIN_POLICY_SIGNER_INFO {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };
    PCCERT_CHAIN_CONTEXT                    pChainContext;

    // SGNR_TYPE_TIMESTAMP defined in wintrust.h
    DWORD                                   dwSignerType;
    PCMSG_SIGNER_INFO                       pMsgSignerInfo;
    DWORD                                   dwError;

    DWORD                                   cCounterSigner;
    PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO   *rgpCounterSigner;
};

typedef HRESULT (WINAPI *PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK)(
    IN PCRYPT_PROVIDER_DATA pProvData,
    IN DWORD dwStepError,
    IN DWORD dwRegPolicySettings,
    IN DWORD cSigner,
    IN PWTD_GENERIC_CHAIN_POLICY_SIGNER_INFO *rgpSigner,
    IN void *pvPolicyArg
    );

// The fields in the following data structure are passed to
// CertGetCertificateChain().
typedef struct _WTD_GENERIC_CHAIN_POLICY_CREATE_INFO {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };

    HCERTCHAINENGINE                        hChainEngine;
    PCERT_CHAIN_PARA                        pChainPara;
    DWORD                                   dwFlags;
    void                                    *pvReserved;
} WTD_GENERIC_CHAIN_POLICY_CREATE_INFO, *PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO;

typedef struct _WTD_GENERIC_CHAIN_POLICY_DATA {
    union {
        DWORD                                   cbStruct;
        DWORD                                   cbSize;
    };

    PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO   pSignerChainInfo;
    PWTD_GENERIC_CHAIN_POLICY_CREATE_INFO   pCounterSignerChainInfo;
    PFN_WTD_GENERIC_CHAIN_POLICY_CALLBACK   pfnPolicyCallback;
    void                                    *pvPolicyArg;
} WTD_GENERIC_CHAIN_POLICY_DATA, *PWTD_GENERIC_CHAIN_POLICY_DATA;


//////////////////////////////////////////////////////////////////////////////
//
// HTTPSPROV_ACTION Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  SSL/PCT connections through IE.
//  
//          {573E31F8-AABA-11d0-8CCB-00C04FC295EE}
//
#define HTTPSPROV_ACTION                                        \
            { 0x573e31f8,                                       \
              0xaaba,                                           \
              0x11d0,                                           \
              { 0x8c, 0xcb, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } \
            }

#define HTTPS_FINALPOLICY_FUNCTION          L"HTTPSFinalProv"
#define HTTPS_CHKCERT_FUNCTION              L"HTTPSCheckCertProv"
#define HTTPS_CERTTRUST_FUNCTION            L"HTTPSCertificateTrust"

// fdwChecks flags are defined in wininet.h
typedef struct _HTTPSPolicyCallbackData
{
    union {
        DWORD           cbStruct;       // sizeof(HTTPSClientData);
        DWORD           cbSize;         // sizeof(HTTPSClientData);
    };

    DWORD           dwAuthType;
#                       define      AUTHTYPE_CLIENT         1
#                       define      AUTHTYPE_SERVER         2

    DWORD           fdwChecks;

    WCHAR           *pwszServerName; // used to check against CN=xxxx

} HTTPSPolicyCallbackData, *PHTTPSPolicyCallbackData,
    SSL_EXTRA_CERT_CHAIN_POLICY_PARA, *PSSL_EXTRA_CERT_CHAIN_POLICY_PARA;




//////////////////////////////////////////////////////////////////////////////
//
// OFFICESIGN_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a Structured Storage file using the Microsoft Office
//  Authenticode add-on Policy Provider,
//  
//          {5555C2CD-17FB-11d1-85C4-00C04FC295EE}
//
#define     OFFICESIGN_ACTION_VERIFY                                    \
                { 0x5555c2cd,                                           \
                  0x17fb,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xc4, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     OFFICE_POLICY_PROVIDER_DLL_NAME             SP_POLICY_PROVIDER_DLL_NAME
#define     OFFICE_INITPROV_FUNCTION                    L"OfficeInitializePolicy"
#define     OFFICE_CLEANUPPOLICY_FUNCTION               L"OfficeCleanupPolicy"


//////////////////////////////////////////////////////////////////////////////
//
// DRIVER_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a WHQL signed driver.  This is an Authenticode add-on
//  Policy Provider,
//  
//          {F750E6C3-38EE-11d1-85E5-00C04FC295EE}
//
#define     DRIVER_ACTION_VERIFY                                        \
                { 0xf750e6c3,                                           \
                  0x38ee,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xe5, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     DRIVER_INITPROV_FUNCTION                    L"DriverInitializePolicy"
#define     DRIVER_FINALPOLPROV_FUNCTION                L"DriverFinalPolicy"
#define     DRIVER_CLEANUPPOLICY_FUNCTION               L"DriverCleanupPolicy"

typedef struct DRIVER_VER_MAJORMINOR_
{
    DWORD           dwMajor;
    DWORD           dwMinor;

} DRIVER_VER_MAJORMINOR;

typedef struct DRIVER_VER_INFO_
{
    DWORD                               cbStruct;               // IN - set to sizeof(DRIVER_VER_INFO)

    DWORD                               dwReserved1;            // IN - set to NULL
    DWORD                               dwReserved2;            // IN - set to NULL

    DWORD                               dwPlatform;             // IN - OPTIONAL: platform to use
    DWORD				dwVersion;		// IN - OPTIONAL: major version to use, same as sOSVersionLow

    WCHAR                               wszVersion[MAX_PATH];   // OUT: version string from catalog file
    WCHAR                               wszSignedBy[MAX_PATH];  // OUT: signer display name from certificate
    PCCERT_CONTEXT                      pcSignerCertContext;    // OUT: client MUST free this!!!

    // 08-Dec-1997 pberkman: added
    DRIVER_VER_MAJORMINOR               sOSVersionLow;          // IN - OPTIONAL: lowest compatible version
    DRIVER_VER_MAJORMINOR		sOSVersionHigh; 	// IN - OPTIONAL: for now must be the same as sOSVersionLow

} DRIVER_VER_INFO, *PDRIVER_VER_INFO;

#include <poppack.h>


#ifdef __cplusplus
}
#endif

#endif // SOFTPUB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\external\inc\spellapi.h ===
/********************************************************************
  spellAPI.h - API definitions for CSAPI, the Speller

You are not entitled to any support or assistance from Microsoft Corporation
regarding your use of the documentation, this C-header file, or any sample source
code associated with the Common Speller Application Programming Interface (CSAPI).
We regret that Microsoft is unable to support or
assist you should you have problems using these files.

To use the CSAPI (including without limitation, the documentation,
C-header file, and any sample source code), you must have executed the
CSAPI end user license agreement (EULA),
available through Microsoft.

IF YOU HAVE NOT SIGNED THE CSAPI EULA,
YOU ARE NOT AUTHORIZED TO USE THE CSAPI.

  Version 3.0 - all api's

    History:
    5/97    DougP   Created
    11/97   DougP   This separate speller part

    The Natural Language Group maintains this file.

  1997 Microsoft Corporation
********************************************************************/

#if !defined(SPELLAPI_H)
#define SPELLAPI_H

/**********************************************************
The Speller, Hyphenator, and Thesaurus share 7 functions.
The prototypes, etc. for these functions are in ProofBase.h
**********************************************************/
#if !defined(PROOFBASE_H)
#include "ProofBse.h"
#endif

/*************************************************************
     PART 1 - Structure Defs
**************************************************************/
#pragma pack(push, proofapi_h, 8)   // default alignment

// eliminate Wizard Special Characters */
    /* all this array are well defined Unicode (and Latin-1) characters. */

typedef PROOFPARAMS SpellerParams;  // spm
typedef DWORD   SpellerState;   // sstate

STRUCTUREBEGIN(WSIB)            /* Spell Input Buffer - sib */
    const WCHAR *pwsz;      /* Ptr to buffer of text to be processed */
    PROOFLEX    *prglex;    /* List of dicts to use */
    size_t      cch;        /* Count of characters in pwsz */
    size_t      clex;       /* Count of dicts specified in prglex */
                                /* State relative to prev. SpellerCheck call */
    SpellerState    sstate;     // sstate
    DWORD       ichStart;   /* position in pwsz to start (New) */
    size_t      cchUse;     /* count of characters in pwsz to consider (New) */
STRUCTUREEND2(WSIB, ichStart(0), sstate(0))

typedef enum {  /* Spell Check Return Status */
    sstatNoErrors,          /* All buffer processed. */
    sstatUnknownInputWord,  /* Unknown word. */
    sstatReturningChangeAlways, /* Returning a Change Always word in SRB. */
    sstatReturningChangeOnce,  /* Returning a Change Once word in SRB. */
    sstatInvalidHyphenation,   /* obsolete - Error in hyphenation point.*/
    sstatErrorCapitalization,   /* Cap pattern not valid. */
    sstatWordConsideredAbbreviation, /* Word is considered an abbreviation. */
    sstatHyphChangesSpelling, /* obsolete - Word changes spelling when not hyphenated. */
    sstatNoMoreSuggestions,  /* All methods used. */
    sstatMoreInfoThanBufferCouldHold,  /* More suggestions than could fit in SRB. */
    sstatNoSentenceStartCap,  /* obsolete - Start of sentence was not capitalized. */
    sstatRepeatWord,    /* Repeat word found. */
    sstatExtraSpaces,   /* obsolete - Too many spaces for context.*/
    sstatMissingSpace, /* obsolete - Too few space(s) between words or sentences. */
    sstatInitialNumeral,  /* Word starts with numeral & sobitFlagInitialNumeral set */
    sstatNoErrorsUDHit, /* obsolete - No errors, but at least 1 word found in user dicts */
    sstatReturningAutoReplace,  /* Returning an AutoReplace suggestion in WSRB */
    sstatErrorAccent,   /* accents not valid - returns correctly accented word */
} SPELLERSTATUS;    // sstat


typedef struct {
    WCHAR   *pwsz;  // pointer to the suggestion (in pwsz)
    DWORD   ichSugg;    // position in input buffer corresponding to suggestion
    DWORD   cchSugg;    // length in input buffer corresponding to suggestion
    DWORD   iRating;    // rating value of this suggestion (0 - 255)
} SPELLERSUGGESTION;    // sugg

STRUCTUREBEGIN(WSRB)                 /* Spell Return Buffer - srb */
    WCHAR       *pwsz;      /* Ptr to suggestion buffer.
                         Format: word\0word\0...word\0\0 */
    SPELLERSUGGESTION   *prgsugg;   // ptr to array of suggestions (see above)
    DWORD       ichError;   /* Position of verif. error in SIB */
    DWORD       cchError;     /* Length of verif. error in SIB.*/
    DWORD       ichProcess;     /* position where processing began */
    DWORD       cchProcess;     /* length of processed region */
    SPELLERSTATUS    sstat;       /* Spell check return status */
    DWORD       csz;           /* Count of wsz's in pwsz
                                can be greater than cszAlloc,
                                in which case you got sstatMoreInfoThanBufferCouldHold */
    DWORD       cszAlloc;       /* number of entries allocated in pSuggestion
                                    (set by App) */
    DWORD       cchMac; /* Current chars used in pwsz (incl all trailing nulls) */
    DWORD       cchAlloc;          /* Size in chars of pwsz (Set by App) */
STRUCTUREEND2(WSRB, pwsz(0), prgsugg(0))

// for a null response (no returns), csz=0, cchMac=1 (for the trailing null)
// and *pwsz = L'\0'.  To be really safe, pwsz[1] = L'\0' as well

/*
    Client typically allocates arrays for pwsz and rgSuggestion:
    #define MAXSUGGBUFF 512
    #define MAXSUGG 20
    SPELLERSUGGESTION   rgsugg[MAXSUGG];
    WCHAR   SuggestionBuffer[MAXSUGGBUF];
    WSRB    srb;
    srb.pwsz = SuggestionBuffer;
    srb.prgsugg = rgsugg;
    srb.cszAlloc = MAXSUGG;
    srb.cchAlloc = MAXSUGGBUFF;

  Now the return buffer is ready to receive suggestions lists.  The list
  comes back as a list of null terminated strings in pwsz.  It also comes
  back in the array that rgSugg points to.  rgSugg also contains information
  for each suggestion as to the area of the input buffer that the suggestion
  applies to.
*/

// rating guidelines - these guidelines apply to both the AutoReplaceThreshold
// and the ratings optionally returned in the WSRB
// These give clients guidelines for setting the AutoReplace Threshold
// Spellers can deviate from these guidelines as appropriate for a language.
enum
{
    SpellerRatingNone                   =256,   // this rating is so high it turns off all AutoReplace
    SpellerRatingCapit                  =255,   // capitalization and accent errors
    SpellerRatingDropDoubleConsonant    =255-13,    // dropped one of a doubled consonant
    SpellerRatingDropDoubleVowel        =255-15,    // dropped one of a doubled vowel
    SpellerRatingAddDoubleConsonant     =255-13,    // doubled a consonant
    SpellerRatingAddDoubleVowel         =255-15,    // doubled a vowel
    SpellerRatingTransposeVowel         =255-14,    // transposed vowels
    SpellerRatingTransposeConsonant     =255-17,    // transposed consonants
    SpellerRatingTranspose              =255-18,    // other transpositions
    SpellerRatingSubstituteVowel        =255-20,    // substitute vowels
    SpellerRatingDrop                   =255-30,    // drop a letter
    SpellerRatingSubstituteConsonant    =255-40,    // substitute Consonants
    SpellerRatingAdd                    =255-34,    // add a letter
    SpellerRatingSubstitute             =255-42,    // other substitutions
};

/*************************************************************
     PART 2 - Function Defs
**************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif

/* -------------- Speller Section --------------
--------------------------------------------- */

//PTEC WINAPI SpellerVersion(PROOFINFO *pinfo);

//PTEC WINAPI SpellerInit(PROOFID *psid, const SpellerParams *pspm);

//PTEC WINAPI SpellerTerminate(PROOFID sid, BOOL fForce);

enum {
    sobitSuggestFromUserLex     = 0x00000001L,  /* Suggest from user dictionaries. */
    sobitIgnoreAllCaps          = 0x00000002L,  /* Ignore words in all UPPERCASE. */
    sobitIgnoreMixedDigits      = 0x00000004L, /* Ignore words with any numbers in it. */
    sobitIgnoreRomanNumerals    = 0x00000008L, /* Ignore words composed of all roman numerals. */

    sobitFindRepeatWord         = 0x00000040L, /* Flag repeated words. */

    sobitRateSuggestions        = 0x00000400L, /* Rate the suggestions on scale
                                                *  of 1-255, 255 being most likely
                                                */

    sobitFindInitialNumerals    = 0x00000800L, /* Flag words starting with number(s) */

    sobitSglStepSugg            = 0x00010000L, /* Break after each suggestion task for faster
                                                * return of control to the application.
                                                */

    sobitIgnoreSingleLetter     = 0x00020000L, /* Do not check single letters: e.g., "a)".
                                                */
    sobitIgnoreInitialCap       = 0x00040000L, /* ignore words with initial letter capped */

    sobitLangMode               = 0xF0000000L, /* Language Mode mask */
      /* Hebrew Language Modes -- (CT only) */
    sobitHebrewFullScript       = 0x00000000L,
    sobitHebrewPartialScript    = 0x10000000L,
    sobitHebrewMixedScript      = 0x20000000L,
    sobitHebrewMixedAuthorizedScript    = 0x30000000L,
      /* French Language Modes -- (HM only) */
    sobitFrenchDialectDefault       = 0x00000000L,
    sobitFrenchUnaccentedUppercase  = 0x10000000L,
    sobitFrenchAccentedUppercase    = 0x20000000L,
      /* Russian Language Modes -- (HM only) */
    sobitRussianDialectDefault      = 0x00000000L,
    sobitRussianIE                  = 0x10000000L,
    sobitRussianIO                  = 0x20000000L,
      /* Korean Language Modes */
    sobitKoreanNoAuxCombine         = 0x10000000L,  /* Auxiliary verb and Auxiliary adjective can combine together. */
    sobitKoreanNoMissSpellDictSearch    = 0x20000000L,  /* Search frequently-misspelled-word dictionary. */
    sobitKoreanNoCompoundNounProc  = 0x40000000L,  /* Do not search frequently-misspelled word dictionary */
    sobitKoreanDefault              = 0,    /* Korean default */
      /* German Language Modes */
    sobitGermanUsePrereform         = 0x10000000L,  /* use prereform spelling */
};

  /* Option Set and Get Codes */
enum {
    soselBits,  /*  Set bit-oriented options (as before). */
    soselPossibleBits,  /*  GetOptions only.  The returned value in *piOptRet shows which options can be turned on. */
    soselAutoReplace,   /* AutoReplaceThreshold (0-255) */
};
typedef DWORD SPELLEROPTIONSELECT;  // sosel

//PTEC WINAPI SpellerSetOptions(PROOFID sid, SPELLEROPTIONSELECT sosel, const DWORD iOptVal);

//PTEC WINAPI SpellerGetOptions(PROOFID sid, SPELLEROPTIONSELECT sosel, DWORD *piOptVal);

//PTEC WINAPI SpellerOpenLex(PROOFID sid, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);

//PTEC WINAPI SpellerCloseLex(PROOFID sid, PROOFLEX lex, BOOL fforce);

/* Flag values for dwSpellState field in Sib. */
enum {
    sstateIsContinued       = 0x0001,
    /* Call is continuing from where last call returned.  Must be cleared
    *  for first call into SpellCheck().
    */

    sstateStartsSentence    = 0x0002,
   /* First word in buffer is known to be start of
   *  sentence/paragraph/document.  This is only used if the
   *  fSibIsContinued bit is not set.  It should not be needed if the
   *  fSibIsContinued bit is being used.  If this bit is set during a
   *  suggestion request, suggestions will be capitalized.
   */

    sstateIsEditedChange    = 0x0004,
   /* The run of text represented in the SIB is a change from either
   *  a change pair (change always or change once) edit, or from a
   *  user specified change, possibly from a suggestion list presented
   *  to the user.  This text should be checked for repeat word
   *  problems, and possibly sentence status, but should not be subject
   *  to subsequent spell verification or change pair substitutions.
   *  Note that if an app is not using the fSibIsContinued support,
   *  they do not need to pass in these edited changes, thus bypassing
   *  the potential problem, and working faster.
   */

    sstateNoStateInfo       = 0x0000,
   /* App is responsible for checking for all repeat word and sentence
   *  punctuation, and avoiding processing loops such as change always
   *  can=can can.
   */
};  /* End of Sib Spell State flag definitions. */

typedef enum {
    scmdVerifyBuffer=2,
    scmdSuggest,
    scmdSuggestMore,

    scmdWildcard=6, // no reason to support this
    scmdAnagram,    // or this

    scmdVerifyBufferAutoReplace=10, // Same as VerifyBuffer - but offer AutoReplacements
} SPELLERCOMMAND;   // scmd 

//PTEC WINAPI SpellerCheck(PROOFID sid, SPELLERCOMMAND scmd, const WSIB *psib, WSRB *psrb);
typedef PTEC (WINAPI *SPELLERCHECK)(PROOFID sid, SPELLERCOMMAND scmd, const WSIB *psib, WSRB *psrb);

/* Add the string referenced in pwszAdd to the specified UDR.
The UDR must be either the built-in UserLex UDR or a
UDR opened with UserLex. */
//PTEC WINAPI SpellerAddUdr(PROOFID sid, PROOFLEX lex, const WCHAR *pwszAdd);
typedef PTEC (WINAPI *SPELLERADDUDR) (PROOFID sid, PROOFLEX lex, const WCHAR *pwszAdd);

/* Add the pair of strings referenced in pwszAdd and pwszChange to the specified UDR.
Since this call can only refer to the built-in ChangeOnce or ChangeAlways UDRs, we need
only specify the type. */
//PTEC WINAPI SpellerAddChangeUdr(PROOFID sid, PROOFLEXTYPE lxt, const WCHAR *pwszAdd, const WCHAR *pwszChange);
typedef PTEC (WINAPI *SPELLERADDCHANGEUDR)(PROOFID sid, PROOFLEXTYPE lxt, const WCHAR *pwszAdd, const WCHAR *pwszChange);

/* Delete the specified word referenced in pwszDel from the
specified user dictionary.  If the string is not in dictionary,
the routine still returns success.
If the string found in the specified UDR is the first part
of a change pair entry, then both strings of the change pair
is removed from the word list, i.e., the entire entry is deleted.
The UDR can reference any of the built-in UDR's or a legally
open user dictionary. */
//PTEC WINAPI SpellerDelUdr(PROOFID sid, PROOFLEX lex, const WCHAR *pwszDel);
typedef PTEC (WINAPI *SPELLERDELUDR)(PROOFID sid, PROOFLEX lex, const WCHAR *pwszDel);

/* Completely clears the specified built-in UDR of all entries.
Note that in order to completely purge the built-in UDR's, this
call would have to be made once for each of UserLex,
lxtChangeOnce, and lxtChangeAlways.
Note:
v1 API spellers may not support
SpellerClearUdr for non-built-in dictionary files.  This function
allows multiple document spell checks to clear out the built-in
UDR's between documents, without stopping and restarting a spell
session between every document.
*/
//PTEC WINAPI SpellerClearUdr(PROOFID sid, PROOFLEX lex);
typedef PTEC (WINAPI *SPELLERCLEARUDR)(PROOFID sid, PROOFLEX lex);

/* Determines the number of entries in any of the opened
user dictionaries, including the built-in dictionaries.
Note that spell pair entries are considered a single entry.
*/
//PTEC WINAPI SpellerGetSizeUdr(PROOFID sid, PROOFLEX lex, DWORD *pcWords);
typedef PTEC (WINAPI *SPELLERGETSIZEUDR)(PROOFID sid, PROOFLEX lex, DWORD *pcWords);

/* This function lists the contents of any of the open user
dictionaries, which includes the exclusion or built-in
dictionaries.
The WSRB is filled with null terminated strings (Sz's) from the
specified UDR starting at the entry indexed by the iszStart
parameter until the buffer is full, or until the end of the file
is reached.  Note that the buffer in the WSRB is overwritten
from the beginning on each call.
For dictionaries with the ChangeAlways or ChangeOnce property,
the entries are returned in a slightly modified way.  Each word
pair entry is stripped of any embedded formatting and divided
into its two parts, and each part is added as a separate Sz
into the WSRB buffer.  Therefore, these types of dictionaries
or word lists always yield an even number of Sz strings in the
WSRB buffer, and represents two Sz's strings for every entry
in the list.
When getting all the words from a dictionary, it is important
to remember that SpellerGetSizeUdr finds the number of entries,
while SpellerGetListUdr gives back a count of strings (WSRB.csz)
in the buffer.  The only way to know when all the words have been
retrieved is by checking WSRB.sstat.  It should contain
SpellRetNoErrors when all words have been returned and
SpellRetMoreInfoThanBufferCouldHold when more words remain.
Although user dictionary entries have embedded formatting to
distinguish their property type, the strings returned in the
WSRB buffer are completely stripped of any formatting or padding,
and are simply terminated as an Sz string.
This routine does not use or reference the ichError or cchError
fields of WSRB, which are used in the SpellerCheck function.
*/
//PTEC WINAPI SpellerGetListUdr(PROOFID sid, PROOFLEX lex, DWORD iszStart, WSRB *psrb);
typedef PTEC (WINAPI *SPELLERGETLISTUDR)(PROOFID sid, PROOFLEX lex, DWORD iszStart, WSRB *psrb);

/* Return the UDR id of one of the built-in user dictionarys. */
//PROOFLEX WINAPI SpellerBuiltinUdr(PROOFID sid, PROOFLEXTYPE lxt);
typedef PROOFLEX (WINAPI *SPELLERBUILTINUDR)(PROOFID sid, PROOFLEXTYPE lxt);

  // Optional Prototypes for possible static linking (not recommended)
#if defined(WINCE) || defined(PROTOTYPES)
PTEC WINAPI SpellerVersion(PROOFINFO *pInfo);
PTEC WINAPI SpellerInit(PROOFID *pSpellerid, const SpellerParams *pParams);
PTEC WINAPI SpellerTerminate(PROOFID splid, BOOL fForce);
PTEC WINAPI SpellerSetOptions(PROOFID splid, DWORD iOptionSelect, const DWORD iOptVal);
PTEC WINAPI SpellerGetOptions(PROOFID splid, DWORD iOptionSelect, DWORD *piOptVal);
PTEC WINAPI SpellerOpenLex(PROOFID splid, const PROOFLEXIN *plxin, PROOFLEXOUT *plxout);
PTEC WINAPI SpellerCloseLex(PROOFID splid, PROOFLEX lex, BOOL fforce);
PTEC WINAPI SpellerCheck(PROOFID splid, SPELLERCOMMAND iScc, const WSIB *pSib, WSRB *pSrb);
PTEC WINAPI SpellerAddUdr(PROOFID splid, PROOFLEX udr, const WCHAR *pwszAdd);
PTEC WINAPI SpellerAddChangeUdr(PROOFID splid, PROOFLEXTYPE utype, const WCHAR *pwszAdd, const WCHAR *pwszChange);
PTEC WINAPI SpellerDelUdr(PROOFID splid, PROOFLEX udr, const WCHAR *pwszDel);
PTEC WINAPI SpellerClearUdr(PROOFID splid, PROOFLEX udr);
PTEC WINAPI SpellerGetSizeUdr(PROOFID splid, PROOFLEX udr, DWORD *pcWords);
PTEC WINAPI SpellerGetListUdr(PROOFID splid, PROOFLEX udr, DWORD iszStart, WSRB *pSrb);
PROOFLEX WINAPI SpellerBuiltinUdr(PROOFID splid, PROOFLEXTYPE udrtype);
BOOL WINAPI SpellerSetDllName(const WCHAR *pwszDllName, const UINT uCodePage);
#endif

#if defined(__cplusplus)
}
#endif

#pragma pack(pop, proofapi_h)   // restore to whatever was before

#endif  // SPELLAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\external\inc\vendor.h ===
/*------------------------------------------------------------
    vendor.h - Unified vendor include file

        2/5/97  dougp   created

    Note:  The Natural Language Group maintains this file.
        Please contact us with change requests.
------------------------------------------------------------*/

#if !defined(VENDOR_H)
#define VENDOR_H

/* unified codes */
// I originally used an enum here - but RC doesn't like it

typedef int VENDORID;   // vendorid

#define  vendoridSoftArt            1
#define  vendoridInso               2

  // these came from the original list from the speller
  // but don't conflict with any others - so they are safe for all tools
#define vendoridInformatic         17     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define vendoridAmebis             18     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define vendoridLogos              19     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define vendoridDatecs             20     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define vendoridFilosoft           21     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define vendoridLingsoft           22     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define vendoridPolderland         23     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */


#define  vendoridMicrosoft          64
#define  vendoridSynapse            65              /* Synapse - French(Spelling:Mssp3fr.lex, Mssp3fr.dll) */
#define  vendoridFotonija           66              /* Fotonija - Lithuanian(Spelling:Mssp_lt.lex, Msplt32.dll) - added 3/25/97 */
#define  vendoridFotonja        vendoridFotonija                /* To make up for earlier misspelling */
#define  vendoridHizkia             67              /* Hizkia -Basque (Spelling:Mssp_eu.lex, Mspeu32.dll) - added 5/21/97 */
#define  vendoridExpertSystem       68              /* ExpertSystem - Italian(Spelling:Mssp3lt.lex, Mssp3lt.dll) - added 7/17/97 */
#define  vendoridWYSIWYG            69      /* Various languages as an addon - 2/2/98 */

  // next five added at Ireland's request 3/27/98
#define  vendoridSYS                70  // Croatian - Spelling:Mssp_cr.lex, Mspcr32.dll
#define  vendoridTilde              71  // Latvian - Spelling:Mssp_lv.lex, Msplv32.dll
#define  vendoridSignum             72  // Spanish - Spelling:Mssp3es.lex, Mssp3es.dll
#define  vendoridProLing            73  // Ukrainian - Spelling:Mssp3ua.lex, Mssp3ua.dll
#define  vendoridItautecPhilcoSA    74  // Brazilian - Spelling:mssp3PB.lex, Mssp3PB.dll


/*************** legacy codes ******************/

/* Spell Engine Id's */
#define sidSA    vendoridSoftArt      /* Reserved */
#define sidInso  vendoridInso      /* Inso */
#define sidHM    sidInso      /* Inso was Houghton Mifflin */
#define sidML    3      /* MicroLytics */
#define sidLS    4      /* LanSer Data */
#define sidCT    5      /* Center of Educational Technology */
#define sidHS    6      /* HSoft - Turkish(mssp_tr.lex, Msptr32.dll)*/
#define sidMO    7      /* Morphologic - Romanian(Mssp_ro.lex, Msthro32.dll) and Hungarian(Mssp_hu.lex, Msphu32.dll) */
#define sidTI    8      /* TIP - Polish(Mssp_pl.lex, Mspl32.dll) */
#define sidTIP sidTI
#define sidKF    9      /* Korean Foreign Language University */
#define sidKFL sidKF
#define sidPI    10     /* Priberam Informatica Lince - Portuguese(Mssp3PT.lex, Mssp3PT.dll) */
#define sidPIL sidPI
#define sidColtec   11  /* Coltec (Arabic) */
#define sidGS    sidColtec     /* Glyph Systems - this was an error */
#define sidRA    12     /* Radiar (Romansch) */
#define sidIN    13     /* Intracom - Greek(Mssp_el.lex, Mspel32.dll) */
#define sidSY    14     /* Sylvan */
#define sidHI    15     /* Hizkia (obsolete - use vendoridHizkia) */
#define sidFO    16     /* Forma - Slovak(Mssp_sk.lex, Mspsk32.dll) */
#define sidIF    vendoridInformatic     /* Informatic - Russian (Mssp_ru.lex, Mspru32.dll) */
#define sidAM    vendoridAmebis     /* Amebis - Slovenian(Mssp_sl.lex, Mspsl32.dll) and Serbian(Mssp_sr.lex, Mspsr32.dll) */
#define sidLO    vendoridLogos     /* Logos - Czech(Mssp_cz.lex, Mspcz32.dll) */
#define sidDT    vendoridDatecs     /* Datecs - Bulgarian(Mssp_bg.lex, Mspbg32.dll) */
#define sidFS    vendoridFilosoft     /* Filosoft - Estonian(Mssp_et.lex, Mspet32.dll) */
#define sidLI    vendoridLingsoft     /* Lingsoft - German(Mssp3ge.lex,Mssp3ge.dll), Danish(Mssp_da.lex,Mspda32.dll), Norwegian(Mssp_no.lex, Mspno32.dll), Finnish(Mssp_fi.lex, Mspfi32.dll) and Swedish(Mssp_sw.lex, Mspsw32.dll) */
#define sidPL    vendoridPolderland     /* Polderland - Dutch(Mssp_nl.lex, Mspnl32.dll) */

  /* Thesaurus Engine Id's */
#define teidSA    vendoridSoftArt
#define teidInso  vendoridInso    /* Inso */
#define teidHM    teidInso    /* Inso was Houghton-Mifflin */
#define teidIF    3    /* Informatic */
#define teidIN    4    /* Intracom */
#define teidMO    5    /* MorphoLogic */
#define teidTI    6    /* TiP */
#define teidPI    7    /* Priberam Informatica Lince */
#define teidAM    8    /* Amebis */
#define teidDT    9    /* Datecs */
#define teidES   10    /* Expert System */
#define teidFS   11    /* Filosoft */
#define teidFO   12    /* Forma */
#define teidHS   13    /* HSoft */
#define teidLI   14    /* Lingsoft */
#define teidLO   15    /* Logos */
#define teidPL   16    /* Polderland */

/* HYphenation Engine ID's */
#define hidSA    vendoridSoftArt
#define hidHM    vendoridInso      /* Houghton Mifflin */
#define hidML    3      /* MicroLytics */
#define hidLS    4      /* LanSer Data */
#define hidFO    5      /* Forma */
#define hidIF    6      /* Informatic */
#define hidAM    7      /* Amebis */
#define hidDT    8      /* Datecs */
#define hidFS    9      /* Filosoft */
#define hidHS   10      /* HSoft */
#define hidLI   11      /* Lingsoft */
#define hidLO   12      /* Logos */
#define hidMO   13      /* MorphoLogic */
#define hidPL   14      /* Polderland */
#define hidTI   15      /* TiP */

/* Grammar Id Engine Defines */
#define geidHM    1    /* Houghton-Mifflin */
#define geidRF    2    /* Reference */
#define geidES    3    /* Expert System */
#define geidLD    4    /* Logidisque */
#define geidSMK   5    /* Sumitomo Kinzoku (Japanese) */
#define geidIF    6    /* Informatic */
#define geidMO    7    /* MorphoLogic */
#define geidMS    8    /* Microsoft Reserved */
#define geidNO    9    /* Novell */
#define geidCTI  10    /* CTI (Greek) */
#define geidAME  11    /* Amebis (Solvenian) */
#define geidTIP  12    /* TIP (Polish) */

#endif  /* VENDOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\external\inc\wintrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       wintrust.h
//
//  Contents:   Microsoft Internet Security Trust Provider Model
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WINTRUST_H
#define WINTRUST_H

#include    <wincrypt.h>

#ifdef __cplusplus
extern "C"
{
#endif


#ifndef WIN_CERT_REVISION_1_0   // there were duplicate definitions in winbase.h
#   define  WT_DEFINE_ALL_APIS
#else
#   undef   WT_DEFINE_ALL_APIS
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//      Client definitions, typedefs, and prototypes
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_DATA Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust to pass necessary information into
//  the Providers.
//
typedef struct _WINTRUST_DATA
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)

    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.

    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
#                       define      WTD_UI_ALL              1
#                       define      WTD_UI_NONE             2
#                       define      WTD_UI_NOBAD            3
#                       define      WTD_UI_NOGOOD           4

    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
#                       define      WTD_REVOKE_NONE         0x00000000
#                       define      WTD_REVOKE_WHOLECHAIN   0x00000001

    DWORD           dwUnionChoice;              // required: which structure is being passed in?
#                       define      WTD_CHOICE_FILE         1
#                       define      WTD_CHOICE_CATALOG      2
#                       define      WTD_CHOICE_BLOB         3
#                       define      WTD_CHOICE_SIGNER       4
#                       define      WTD_CHOICE_CERT         5
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };

    DWORD           dwStateAction;                      // optional (Catalog File Processing)
#                       define      WTD_STATEACTION_IGNORE           0x00000000
#                       define      WTD_STATEACTION_VERIFY           0x00000001
#                       define      WTD_STATEACTION_CLOSE            0x00000002
#                       define      WTD_STATEACTION_AUTO_CACHE       0x00000003
#                       define      WTD_STATEACTION_AUTO_CACHE_FLUSH 0x00000004

    HANDLE          hWVTStateData;                      // optional (Catalog File Processing)

    WCHAR           *pwszURLReference;          // optional: (future) used to determine zone.

    // 17-Feb-1998 philh: added
    DWORD           dwProvFlags;
#       define WTD_PROV_FLAGS_MASK          0x0000FFFF
#       define WTD_USE_IE4_TRUST_FLAG       0x00000001
#       define WTD_NO_IE4_CHAIN_FLAG        0x00000002
#       define WTD_NO_POLICY_USAGE_FLAG     0x00000004
} WINTRUST_DATA, *PWINTRUST_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_FILE_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against an individual file.
//
typedef struct WINTRUST_FILE_INFO_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)

    LPCWSTR         pcwszFilePath;              // required, file name to be verified
    HANDLE          hFile;                      // optional, open handle to pcwszFilePath

    // 09-Dec-1997 pberkman: added
    GUID            *pgKnownSubject;            // optional: fill if the subject type is known.

} WINTRUST_FILE_INFO, *PWINTRUST_FILE_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CATALOG_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a member of a Microsoft Catalog
//  file.
//
typedef struct WINTRUST_CATALOG_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_CATALOG_INFO)

    DWORD           dwCatalogVersion;       // optional: Catalog version number
    LPCWSTR         pcwszCatalogFilePath;   // required: path/name to Catalog file

    LPCWSTR         pcwszMemberTag;         // required: tag to member in Catalog
    LPCWSTR         pcwszMemberFilePath;    // required: path/name to member file
    HANDLE          hMemberFile;            // optional: open handle to pcwszMemberFilePath

    // 30-Oct-1997 pberkman: added
    BYTE            *pbCalculatedFileHash;  // optional: pass in the calculated hash
    DWORD           cbCalculatedFileHash;   // optional: pass in the count bytes of the calc hash

    // 15-Jan-1998 pberkman: added
    PCCTL_CONTEXT   pcCatalogContext;       // optional: pass in to use instead of CatalogFilePath.

} WINTRUST_CATALOG_INFO, *PWINTRUST_CATALOG_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_BLOB_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a memory blob.
//
typedef struct WINTRUST_BLOB_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_BLOB_INFO)

    GUID            gSubject;               // SIP to load

    LPCWSTR         pcwszDisplayName;       // display name of object

    DWORD           cbMemObject;
    BYTE            *pbMemObject;

    DWORD           cbMemSignedMsg;
    BYTE            *pbMemSignedMsg;

} WINTRUST_BLOB_INFO, *PWINTRUST_BLOB_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_SGNR_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CMSG_SIGNER_INFO Structure
//
typedef struct WINTRUST_SGNR_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_SGNR_INFO)

    LPCWSTR         pcwszDisplayName;       // name of the "thing" the pbMem is pointing to.

    CMSG_SIGNER_INFO *psSignerInfo;

    DWORD           chStores;               // number of stores in pahStores
    HCERTSTORE      *pahStores;             // array of stores to add to internal list

} WINTRUST_SGNR_INFO, *PWINTRUST_SGNR_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CERT_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CERT_CONTEXT Structure
//
typedef struct WINTRUST_CERT_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_CERT_INFO)

    LPCWSTR         pcwszDisplayName;       // display name

    CERT_CONTEXT    *psCertContext;

    DWORD           chStores;               // number of stores in pahStores
    HCERTSTORE      *pahStores;             // array of stores to add to internal list

    // 17-Nov-1997 pberkman: added
    DWORD           dwFlags;
#                       define      WTCI_DONT_OPEN_STORES   0x00000001  // only open dummy "root" all other are in pahStores.
#                       define      WTCI_OPEN_ONLY_ROOT     0x00000002

    // 26-Nov-1997 pberkman: added
    FILETIME        *psftVerifyAsOf;        // if not null, each cert will be validated as of this time.

} WINTRUST_CERT_INFO, *PWINTRUST_CERT_INFO;

#include <poppack.h>


//////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrust
//----------------------------------------------------------------------------
//  Exported from WINTRUST.DLL.
//  Call this function to verify the trust based on a digital signer.
//
//  Returns:
//          ERROR_SUCCESS               If the trust is authenticated or
//                                      if the user accepted the risk.
//
//          TRUST_E_PROVIDER_UNKNOWN    there was an error loading one of the
//                                      required Providers.
//
//          all error codes passed back are based on the Policy Provider used.
//
extern LONG WINAPI WinVerifyTrust(HWND hwnd, GUID *pgActionID,
                                  LPVOID pWVTData);


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//      Trust, Policy, and UI Provider definitions, typedefs, and prototypes
//
//  Model:
//      A client wishing to validate trust through WinVerifyTrust will
//      select an appropriate Action ID guid for the call.
//      This guid is defined by each Policy Provider and represents the
//      functions called based on the policy for the given object.
//
//      In this model, the Policy Provider determines which style of UI
//      will be shown to the user (this only applies to style, the
//      determination of whether UI is displayed is set by the calling client
//      in the UI flags member of WINTRUST_DATA).
//
//      Since the function entry points are common (same return value and
//      parameters), it allows Policy Provider developers to take advantage
//      of existing, generic, code to fill the CRYPT_PROVIDER_DATA structure.
//
//      This also allows the developer to simply add the specific policy they
//      need, then, call the generic Policy Provider - if appropriate.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Wintrust Policy Flags
//----------------------------------------------------------------------------
//  These are set during install and can be modified by the user
//  through various means.  The SETREG.EXE utility (found in the Authenticode
//  Tools Pack) will select/deselect each of them.
//
#define WTPF_TRUSTTEST              0x00000020  // trust any "TEST" certificate
#define WTPF_TESTCANBEVALID         0x00000080
#define WTPF_IGNOREEXPIRATION       0x00000100  // Use expiration date
#define WTPF_IGNOREREVOKATION       0x00000200  // Do revocation check
#define WTPF_OFFLINEOK_IND          0x00000400  // off-line is ok individual certs
#define WTPF_OFFLINEOK_COM          0x00000800  // off-line is ok commercial certs
#define WTPF_OFFLINEOKNBU_IND       0x00001000  // off-line is ok individual certs, no bad ui
#define WTPF_OFFLINEOKNBU_COM       0x00002000  // off-line is ok commercial certs, no bad ui
#define WTPF_VERIFY_V1_OFF          0x00010000  // turn verify of v1 certs off
#define WTPF_IGNOREREVOCATIONONTS   0x00020000  // ignore TimeStamp revocation checks
#define WTPF_ALLOWONLYPERTRUST      0x00040000  // allow only items in personal trust db.

//////////////////////////////////////////////////////////////////////////////
//
// WintrustGetRegPolicyFlags
//----------------------------------------------------------------------------
//  This API call is exported from WINTRUST.DLL and is the recommended method
//  of retrieving the DWORD representing the Policy Flags.
//
extern void WINAPI      WintrustGetRegPolicyFlags(DWORD *pdwPolicyFlags);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustSetRegPolicyFlags
//----------------------------------------------------------------------------
//  This API call is exported from WINTRUST.DLL and is the recommended method
//  of setting the DWORD representing the Policy Flags.  MAKE SURE to call
//  WintrustGetRegPolicyFlags to get the current value and or/and the value
//  you need then call the set the flags.
//
extern BOOL WINAPI      WintrustSetRegPolicyFlags(DWORD dwPolicyFlags);



//////////////////////////////////////////////////////////////////////////////
//
// Trust Provider "Step" Error defines
//----------------------------------------------------------------------------
//  Each "step" of the Trust process has an error "slot" associated with it.
//  If an error occurs, the "step" will assign its result to this "slot".  These
//  errors can be any valid WINERROR.H HRESULT code.
//

    //
    //  step errors 0 through 20 are reserved for Authenticode specific.  If
    //  you are not calling any of the SOFTPUB.DLL (Authenticode) providers, you
    //  may use these as needed.
    //
#define TRUSTERROR_STEP_WVTPARAMS                   0
#define TRUSTERROR_STEP_FILEIO                      2
#define TRUSTERROR_STEP_SIP                         3
#define TRUSTERROR_STEP_SIPSUBJINFO                 5
#define TRUSTERROR_STEP_CATALOGFILE                 6
#define TRUSTERROR_STEP_CERTSTORE                   7
#define TRUSTERROR_STEP_MESSAGE                     8
#define TRUSTERROR_STEP_MSG_SIGNERCOUNT             9
#define TRUSTERROR_STEP_MSG_INNERCNTTYPE            10
#define TRUSTERROR_STEP_MSG_INNERCNT                11
#define TRUSTERROR_STEP_MSG_STORE                   12
#define TRUSTERROR_STEP_MSG_SIGNERINFO              13
#define TRUSTERROR_STEP_MSG_SIGNERCERT              14
#define TRUSTERROR_STEP_MSG_CERTCHAIN               15
#define TRUSTERROR_STEP_MSG_COUNTERSIGINFO          16
#define TRUSTERROR_STEP_MSG_COUNTERSIGCERT          17
#define TRUSTERROR_STEP_VERIFY_MSGHASH              18
#define TRUSTERROR_STEP_VERIFY_MSGINDIRECTDATA      19

    //
    //  step errors 30 through 37 are reserved for the ending error code for each
    //  entry point in the Trust Model.
    //
#define TRUSTERROR_STEP_FINAL_WVTINIT               30
#define TRUSTERROR_STEP_FINAL_INITPROV              31
#define TRUSTERROR_STEP_FINAL_OBJPROV               32
#define TRUSTERROR_STEP_FINAL_SIGPROV               33
#define TRUSTERROR_STEP_FINAL_CERTPROV              34
#define TRUSTERROR_STEP_FINAL_CERTCHKPROV           35
#define TRUSTERROR_STEP_FINAL_POLICYPROV            36
#define TRUSTERROR_STEP_FINAL_UIPROV                37

#define TRUSTERROR_MAX_STEPS                        38

//////////////////////////////////////////////////////////////////////////////
//
//  allocation and free function prototypes
//----------------------------------------------------------------------------
//
typedef void        *(*PFN_CPD_MEM_ALLOC)(IN DWORD cbSize);
typedef void        (*PFN_CPD_MEM_FREE)(IN void *pvMem2Free);

typedef BOOL        (*PFN_CPD_ADD_STORE)(IN struct _CRYPT_PROVIDER_DATA *pProvData,
                                         IN HCERTSTORE hStore2Add);

typedef BOOL        (*PFN_CPD_ADD_SGNR)(IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                        IN          BOOL fCounterSigner,
                                        IN OPTIONAL DWORD idxSigner,
                                        IN          struct _CRYPT_PROVIDER_SGNR *pSgnr2Add);

typedef BOOL        (*PFN_CPD_ADD_CERT)(IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                        IN          DWORD idxSigner,
                                        IN          BOOL fCounterSigner,
                                        IN OPTIONAL DWORD idxCounterSigner,
                                        IN          PCCERT_CONTEXT pCert2Add);

typedef BOOL        (*PFN_CPD_ADD_PRIVDATA)(IN struct _CRYPT_PROVIDER_DATA *pProvData,
                                            IN struct _CRYPT_PROVIDER_PRIVDATA *pPrivData2Add);

//////////////////////////////////////////////////////////////////////////////
//
//  Provider function prototypes
//----------------------------------------------------------------------------
//

//
//  entry point for the object provider
//
typedef HRESULT     (*PFN_PROVIDER_INIT_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the object provider
//
typedef HRESULT     (*PFN_PROVIDER_OBJTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Signature Provider
//
typedef HRESULT     (*PFN_PROVIDER_SIGTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Certificate Provider
//
typedef HRESULT     (*PFN_PROVIDER_CERTTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's final call (from the trust provider)
//
typedef HRESULT     (*PFN_PROVIDER_FINALPOLICY_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's "dump structure" call
//
typedef HRESULT     (*PFN_PROVIDER_TESTFINALPOLICY_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's clean up routine for any PRIVDATA allocated
//
typedef HRESULT     (*PFN_PROVIDER_CLEANUP_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's Cert Check call.  This will return
//  true if the Trust Provider is to continue building the certificate chain.
//  If the PP returns FALSE, it is assumed that we have reached a "TRUSTED",
//  self-signed, root.  it is also the CertCheck's responsibility to set the
//  fTrustedRoot flag in the certificate structure.
//
typedef BOOL        (*PFN_PROVIDER_CERTCHKPOLICY_CALL)( IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                                        IN          DWORD idxSigner,
                                                        IN          BOOL fCounterSignerChain,
                                                        IN OPTIONAL DWORD idxCounterSigner);


#define WVT_OFFSETOF(t,f)   ((ULONG_PTR)(&((t*)0)->f))

#define WVT_ISINSTRUCT(structtypedef, structpassedsize, member) \
                    ((WVT_OFFSETOF(structtypedef, member) < structpassedsize) ? TRUE : FALSE)


#define WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(structtypedef, structpassedsize, member) \
                    WVT_ISINSTRUCT(structtypedef, structpassedsize, member)

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_DATA Structure
//----------------------------------------------------------------------------
//  Used to pass information between WinVerifyTrust and all of the Provider
//  calls.
//
//  IMPORTANT:  1.  All dynamically allocated members MUST use the allocation
//                  and Add2 functions provided.
//
typedef struct _CRYPT_PROVIDER_DATA
{
    DWORD                               cbStruct;               // = sizeof(TRUST_PROVIDER_DATA) (set in WVT)

    WINTRUST_DATA                       *pWintrustData;         // NOT verified (set in WVT)
    BOOL                                fOpenedFile;            // the provider opened the file handle (if applicable)
    HWND                                hWndParent;             // if passed in, else, Desktop hWnd (set in WVT).
    GUID                                *pgActionID;            // represents the Provider combination (set in WVT).

    HCRYPTPROV                          hProv;                  // set to NULL to let CryptoAPI to assign.

    DWORD                               dwError;                // error if a low-level, system error was encountered

    DWORD                               dwRegSecuritySettings;  // ie security settings (set in WVT)
    DWORD                               dwRegPolicySettings;    // setreg settings (set in WVT)

    struct _CRYPT_PROVIDER_FUNCTIONS    *psPfns;                // set in WVT.

    DWORD                               cdwTrustStepErrors;     // set in WVT.
    DWORD                               *padwTrustStepErrors;   // allocated in WVT.  filled in WVT & Trust Provider

    DWORD                               chStores;               // number of stores in pahStores (root set in WVT)
    HCERTSTORE                          *pahStores;             // array of known stores (root set in WVT) root is ALWAYS #0!!!

    DWORD                               dwEncoding;             // message encoding type (set in WVT and Signature Prov)
    HCRYPTMSG                           hMsg;                   // set in Signature Prov.

    DWORD                               csSigners;              // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_SGNR         *pasSigners;            // use Add2 and Get functions!

    DWORD                               csProvPrivData;         // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_PRIVDATA     *pasProvPrivData;       // use Add2 and Get functions!

    DWORD                               dwSubjectChoice;
#                       define              CPD_CHOICE_SIP          1

    union
    {
        struct _PROVDATA_SIP            *pPDSip;
    };

    char                                *pszUsageOID;           // set in Init Provider

    // 03-Oct-1997 pberkman: added
    BOOL                                fRecallWithState;       // state was maintained for Catalog Files.

    // 10-Nov-1997 pberkman: added
    FILETIME                            sftSystemTime;

    // 16-Jan-1998 pberkman: added
    char                                *pszCTLSignerUsageOID;

    // 17-Feb-1998 philh: added
    // LOWORD intialized from WINTRUST_DATA's dwProvFlags.
    //
    // Debug version reads "DEBUG_TRUST_PROV_FLAGS" environment variable
    // and OR's with WINTRUST_DATA's dwProvFlags to initialize the LOWORD.
    DWORD                               dwProvFlags;
#       define CPD_USE_NT5_CHAIN_FLAG       0x80000000

    // 24-Feb-1998 philh: added
    DWORD                               dwFinalError;

    // 20-May-1998 KeithV: added
    PCERT_USAGE_MATCH					pRequestUsage;

} CRYPT_PROVIDER_DATA, *PCRYPT_PROVIDER_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_FUNCTIONS structure
//----------------------------------------------------------------------------
//
typedef struct _CRYPT_PROVIDER_FUNCTIONS
{
    DWORD                               cbStruct;

    PFN_CPD_MEM_ALLOC                   pfnAlloc;               // set in WVT
    PFN_CPD_MEM_FREE                    pfnFree;                // set in WVT

    PFN_CPD_ADD_STORE                   pfnAddStore2Chain;      // call to add a store to the chain.
    PFN_CPD_ADD_SGNR                    pfnAddSgnr2Chain;       // call to add a sgnr struct to a msg struct sgnr chain
    PFN_CPD_ADD_CERT                    pfnAddCert2Chain;       // call to add a cert struct to a sgnr struct cert chain
    PFN_CPD_ADD_PRIVDATA                pfnAddPrivData2Chain;   // call to add provider private data to struct.

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy data.
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info up to the signer info(s).
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;     // dump structures to a file (or whatever the policy chooses)

    struct _CRYPT_PROVUI_FUNCS          *psUIpfns;

                    // 23-Jul-1997 pberkman: added
    PFN_PROVIDER_CLEANUP_CALL           pfnCleanupPolicy;       // PRIVDATA cleanup routine.

} CRYPT_PROVIDER_FUNCTIONS, *PCRYPT_PROVIDER_FUNCTIONS;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVUI_FUNCS structure
//----------------------------------------------------------------------------
//

typedef BOOL        (*PFN_PROVUI_CALL)(IN HWND hWndSecurityDialog, IN struct _CRYPT_PROVIDER_DATA *pProvData);

typedef struct _CRYPT_PROVUI_FUNCS
{
    DWORD                               cbStruct;

    struct _CRYPT_PROVUI_DATA           *psUIData;

    PFN_PROVUI_CALL                     pfnOnMoreInfoClick;
    PFN_PROVUI_CALL                     pfnOnMoreInfoClickDefault;

    PFN_PROVUI_CALL                     pfnOnAdvancedClick;
    PFN_PROVUI_CALL                     pfnOnAdvancedClickDefault;

} CRYPT_PROVUI_FUNCS, *PCRYPT_PROVUI_FUNCS;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVUI_DATA
//----------------------------------------------------------------------------
//
typedef struct _CRYPT_PROVUI_DATA
{
    DWORD                               cbStruct;

    DWORD                               dwFinalError;

    WCHAR                               *pYesButtonText;        // default: "&Yes"
    WCHAR                               *pNoButtonText;         // default: "&No"
    WCHAR                               *pMoreInfoButtonText;   // default: "&More Info"
    WCHAR                               *pAdvancedLinkText;     // default: <none>

    // 15-Sep-1997 pberkman: added
        // good: default:
                // "Do you want to install and run ""%1"" signed on %2 and distributed by:"
    WCHAR                               *pCopyActionText;
        // good no time stamp: default:
                // "Do you want to install and run ""%1"" signed on an unknown date/time and distributed by:"
    WCHAR                               *pCopyActionTextNoTS;
        // bad: default:
                // "Do you want to install and run ""%1""?"
    WCHAR                               *pCopyActionTextNotSigned;


} CRYPT_PROVUI_DATA, *PCRYPT_PROVUI_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_SGNR structure
//----------------------------------------------------------------------------
//  After the Signature Provider is finished there will be zero to many of these
//  filled out.  One for each signer of the message.  Also, there will be zero
//  to many of these filled out inside this structure.  One for each counter
//  signer of the signer.
//
//  IMPORTANT:  1.  All dynamically allocated members MUST use allocation
//                  and Add2 functions provided.
//
typedef struct _CRYPT_PROVIDER_SGNR
{
    DWORD                               cbStruct;

    FILETIME                            sftVerifyAsOf;      // either today's filetime or the timestamps

    DWORD                               csCertChain;        // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_CERT         *pasCertChain;      // use Add2 and Get functions!

    DWORD                               dwSignerType;       // set if known by policy
#                                           define  SGNR_TYPE_TIMESTAMP     0x00000010

    CMSG_SIGNER_INFO                    *psSigner;          // must use the pfnAlloc allocator!

    DWORD                               dwError;            // error encounted while building/verifying the signer.

    DWORD                               csCounterSigners;   // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_SGNR         *pasCounterSigners; // use Add2 and Get functions!

    // 11-Feb-1998 philh: added
    PCCERT_CHAIN_CONTEXT                pChainContext;

} CRYPT_PROVIDER_SGNR, *PCRYPT_PROVIDER_SGNR;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_CERT structure
//----------------------------------------------------------------------------
//  After the Signature and Certificate Providers are finished there will
//  be zero to many of these filled out in the CRYPT_PROVIDER_SGNR
//  structure.  One for each certificate in the chain.
//
//
typedef struct _CRYPT_PROVIDER_CERT
{
    DWORD                               cbStruct;

    PCCERT_CONTEXT                      pCert;              // must have its own ref-count!

    BOOL                                fCommercial;
    BOOL                                fTrustedRoot;       // certchk policy should set this.
    BOOL                                fSelfSigned;        // set in cert provider

    BOOL                                fTestCert;          // certchk policy will set

    DWORD                               dwRevokedReason;

    DWORD                               dwConfidence;       // set in the Certificate Provider
#                                           define  CERT_CONFIDENCE_SIG             0x10000000  // this cert
#                                           define  CERT_CONFIDENCE_TIME            0x01000000  // issuer cert
#                                           define  CERT_CONFIDENCE_TIMENEST        0x00100000  // this cert
#                                           define  CERT_CONFIDENCE_AUTHIDEXT       0x00010000  // this cert
#                                           define  CERT_CONFIDENCE_HYGIENE         0x00001000  // this cert
#                                           define  CERT_CONFIDENCE_HIGHEST         0x11111000

    DWORD                               dwError;

    CTL_CONTEXT                         *pTrustListContext;

    // 16-Jan-1998 pberkman: added
    BOOL                                fTrustListSignerCert;

    // 25-Feb-1998 philh: added
    //
    // The following two are only applicable to Self Signed certificates
    // residing in a CTL.
    PCCTL_CONTEXT                       pCtlContext;
    DWORD                               dwCtlError;

    // 12-Mar-1998 philh: added
    BOOL                                fIsCyclic;

    // 12-Oct-2000 DSIE: added
    PCERT_CHAIN_ELEMENT                 pChainElement;

} CRYPT_PROVIDER_CERT, *PCRYPT_PROVIDER_CERT;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_PRIVDATA structure
//----------------------------------------------------------------------------
//  This structure is to allow Policy Provider functions to share
//  POLICY SPECIFIC data between Policy Functions.
//  The Policy must use the pfnAddPrivateData2Chain function and
//  must free any data within the member before the Final Policy returns
//  to WVT.
//  To allow multiple providers to use this feature, each provider that
//  uses this member must set the provider ID to it's Action ID so that
//  the provider can find its data and ignore any other.
//
typedef struct _CRYPT_PROVIDER_PRIVDATA
{
    DWORD                               cbStruct;

    GUID                                gProviderID;

    DWORD                               cbProvData;
    void                                *pvProvData;

} CRYPT_PROVIDER_PRIVDATA, *PCRYPT_PROVIDER_PRIVDATA;

//////////////////////////////////////////////////////////////////////////////
//
// PROVDATA_SIP
//----------------------------------------------------------------------------
//
typedef struct _PROVDATA_SIP
{
    DWORD                               cbStruct;               // = sizeof(PROVDATA_SIP)

    GUID                                gSubject;               // subject guid of file/member file. (set in Sig Prov)

    struct SIP_DISPATCH_INFO_           *pSip;                  // set in Sig Prov - defined in sipbase.h
    struct SIP_DISPATCH_INFO_           *pCATSip;               // set in Sig Prov - defined in sipbase.h
    struct SIP_SUBJECTINFO_             *psSipSubjectInfo;      // set in Sig Prov - defined in sipbase.h
    struct SIP_SUBJECTINFO_             *psSipCATSubjectInfo;   // set in Sig Prov - defined in sipbase.h
    struct SIP_INDIRECT_DATA_           *psIndirectData;        // set in Sig Prov - defined in sipbase.h

} PROVDATA_SIP, *PPROVDATA_SIP;

//////////////////////////////////////////////////////////////////////////////
//
// structures used to register action IDs
//----------------------------------------------------------------------------
//
#define WT_CURRENT_VERSION                  0x00000200

typedef struct _CRYPT_TRUST_REG_ENTRY
{
    DWORD                               cbStruct;

    WCHAR                               *pwszDLLName;
    WCHAR                               *pwszFunctionName;  // no more than WT_MAX_FUNC_NAME!

} CRYPT_TRUST_REG_ENTRY, *PCRYPT_TRUST_REG_ENTRY;

typedef struct _CRYPT_REGISTER_ACTIONID
{
    DWORD                               cbStruct;

    CRYPT_TRUST_REG_ENTRY               sInitProvider;
    CRYPT_TRUST_REG_ENTRY               sObjectProvider;
    CRYPT_TRUST_REG_ENTRY               sSignatureProvider;
    CRYPT_TRUST_REG_ENTRY               sCertificateProvider;
    CRYPT_TRUST_REG_ENTRY               sCertificatePolicyProvider;
    CRYPT_TRUST_REG_ENTRY               sFinalPolicyProvider;
    CRYPT_TRUST_REG_ENTRY               sTestPolicyProvider;

                    // 23-Jul-1997 pberkman: added
    CRYPT_TRUST_REG_ENTRY               sCleanupProvider;

} CRYPT_REGISTER_ACTIONID, *PCRYPT_REGISTER_ACTIONID;

typedef BOOL (*PFN_ALLOCANDFILLDEFUSAGE)(IN const char *pszUsageOID,
                                         IN struct _CRYPT_PROVIDER_DEFUSAGE *psDefUsage);
typedef BOOL (*PFN_FREEDEFUSAGE)(IN const char *pszUsageOID,
                                 IN struct _CRYPT_PROVIDER_DEFUSAGE *psDefUsage);

typedef struct _CRYPT_PROVIDER_REGDEFUSAGE
{
    DWORD                   cbStruct;   // = sizeof CRYPT_PROVIDER_REGDEFUSAGE

    GUID                    *pgActionID;

    WCHAR                   *pwszDllName;
    char                    *pwszLoadCallbackDataFunctionName;
    char                    *pwszFreeCallbackDataFunctionName;

} CRYPT_PROVIDER_REGDEFUSAGE, *PCRYPT_PROVIDER_REGDEFUSAGE;

typedef struct _CRYPT_PROVIDER_DEFUSAGE
{
    DWORD                   cbStruct;               // = sizeof CRYPT_PROVIDER_DEFUSAGE

    GUID                    gActionID;            // ActionID of provider

    LPVOID                  pDefPolicyCallbackData; // normally filled in WINTRUST_DATA
    LPVOID                  pDefSIPClientData;      // normally filled in WINTRUST_DATA

} CRYPT_PROVIDER_DEFUSAGE, *PCRYPT_PROVIDER_DEFUSAGE;

#include <poppack.h>

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST.DLL Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Generic Cert Provider
//
#define WT_PROVIDER_DLL_NAME                L"WINTRUST.DLL"
#define WT_PROVIDER_CERTTRUST_FUNCTION      L"WintrustCertificateTrust"

//////////////////////////////////////////////////////////////////////////////
//
// WintrustAddActionID
//----------------------------------------------------------------------------
//  Adds a new Provider combination to the users'
//  system.  Creates all necessary registry entries, etc.  This should be done
//  during the Policy Provider's DllRegisterServer.
//
//  *** THE ONLY ONE WHO SHOULD CALL THIS IS THE POLICY PROVIDER ***
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
extern BOOL WINAPI  WintrustAddActionID(IN GUID *pgActionID,
                                        IN DWORD fdwReserved,    // future use.
                                        IN CRYPT_REGISTER_ACTIONID *psProvInfo);


//////////////////////////////////////////////////////////////////////////////
//
// WintrustRemoveActionID
//----------------------------------------------------------------------------
//  Removes the Provider action combination from the users'
//  system.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
extern BOOL WINAPI  WintrustRemoveActionID(IN GUID *pgActionID);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustLoadFunctionPointers
//----------------------------------------------------------------------------
//  Retrieves the function entry points based on the Action ID given.
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
extern BOOL WINAPI WintrustLoadFunctionPointers(GUID *pgActionID, CRYPT_PROVIDER_FUNCTIONS *pPfns);


//////////////////////////////////////////////////////////////////////////////
//
// WintrustAddDefaultForUsage
//----------------------------------------------------------------------------
//  Sets the default Action ID for the usage.  If the provider uses this
//  function, and the provider requires any of the "callback" data in
//  WINTRUST_DATA to be filled out, it MUST completely fill out the
//  CRYPT_PROVIDER_REGDEFUSAGE structure.
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
extern BOOL WINAPI              WintrustAddDefaultForUsage(IN const char *pszUsageOID,
                                                           IN CRYPT_PROVIDER_REGDEFUSAGE *psDefUsage);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustGetDefaultForUsage
//----------------------------------------------------------------------------
//  Retrieves the Action ID and default callback data for the specified usage
//
//  this function must be called again with dwAction set to FREE to deallocate
//
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
#define                             DWACTION_ALLOCANDFILL           1
#define                             DWACTION_FREE                   2
extern BOOL WINAPI              WintrustGetDefaultForUsage(IN DWORD dwAction,
                                                           IN const char *pszUsageOID,
                                                           IN OUT CRYPT_PROVIDER_DEFUSAGE *psUsage);

extern CRYPT_PROVIDER_SGNR * WINAPI     WTHelperGetProvSignerFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                       DWORD idxSigner,
                                                                       BOOL fCounterSigner,
                                                                       DWORD idxCounterSigner);
extern CRYPT_PROVIDER_CERT * WINAPI     WTHelperGetProvCertFromChain(CRYPT_PROVIDER_SGNR *pSgnr,
                                                                     DWORD idxCert);

extern CRYPT_PROVIDER_DATA * WINAPI     WTHelperProvDataFromStateData(HANDLE hStateData);

extern CRYPT_PROVIDER_PRIVDATA * WINAPI WTHelperGetProvPrivateDataFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                            GUID *pgProviderID);
extern BOOL WINAPI                      WTHelperCertIsSelfSigned(DWORD dwEncoding, CERT_INFO *pCert);

//////////////////////////////////////////////////////////////////////////////
//
// Supported ASN structures contained in WINTRUST.DLL
//----------------------------------------------------------------------------
//
#include <pshpack8.h>

//
//  CTL Trusted CA Lists
//
#define szOID_TRUSTED_CODESIGNING_CA_LIST   "1.3.6.1.4.1.311.2.2.1"
#define szOID_TRUSTED_CLIENT_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.2"
#define szOID_TRUSTED_SERVER_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.3"

//
//  encode/decode OID defines
//
#define SPC_COMMON_NAME_OBJID               szOID_COMMON_NAME
#define SPC_TIME_STAMP_REQUEST_OBJID        "1.3.6.1.4.1.311.3.2.1"
#define SPC_INDIRECT_DATA_OBJID             "1.3.6.1.4.1.311.2.1.4"
#define SPC_SP_AGENCY_INFO_OBJID            "1.3.6.1.4.1.311.2.1.10"
#define SPC_STATEMENT_TYPE_OBJID            "1.3.6.1.4.1.311.2.1.11"
#define SPC_SP_OPUS_INFO_OBJID              "1.3.6.1.4.1.311.2.1.12"
#define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#define SPC_PE_IMAGE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.15"
#define SPC_RAW_FILE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.18"
#define SPC_STRUCTURED_STORAGE_DATA_OBJID   "1.3.6.1.4.1.311.2.1.19"
#define SPC_JAVA_CLASS_DATA_OBJID           "1.3.6.1.4.1.311.2.1.20"
#define SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.21"
#define SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.22"
#define SPC_CAB_DATA_OBJID                  "1.3.6.1.4.1.311.2.1.25"
#define SPC_GLUE_RDN_OBJID                  "1.3.6.1.4.1.311.2.1.25"    // obsolete!
#define SPC_MINIMAL_CRITERIA_OBJID          "1.3.6.1.4.1.311.2.1.26"
#define SPC_FINANCIAL_CRITERIA_OBJID        "1.3.6.1.4.1.311.2.1.27"
#define SPC_LINK_OBJID                      "1.3.6.1.4.1.311.2.1.28"
#define SPC_SIGINFO_OBJID                   "1.3.6.1.4.1.311.2.1.30"

#define CAT_NAMEVALUE_OBJID                 "1.3.6.1.4.1.311.12.2.1"
#define CAT_MEMBERINFO_OBJID                "1.3.6.1.4.1.311.12.2.2"


//
//  encode/decode internal defines
//
#define SPC_SP_AGENCY_INFO_STRUCT           ((LPCSTR) 2000)
#define SPC_MINIMAL_CRITERIA_STRUCT         ((LPCSTR) 2001)
#define SPC_FINANCIAL_CRITERIA_STRUCT       ((LPCSTR) 2002)
#define SPC_INDIRECT_DATA_CONTENT_STRUCT    ((LPCSTR) 2003)
#define SPC_PE_IMAGE_DATA_STRUCT            ((LPCSTR) 2004)
#define SPC_LINK_STRUCT                     ((LPCSTR) 2005)
#define SPC_STATEMENT_TYPE_STRUCT           ((LPCSTR) 2006)
#define SPC_SP_OPUS_INFO_STRUCT             ((LPCSTR) 2007)
#define SPC_CAB_DATA_STRUCT                 ((LPCSTR) 2008)
#define SPC_JAVA_CLASS_DATA_STRUCT          ((LPCSTR) 2009)

#define SPC_SIGINFO_STRUCT                  ((LPCSTR) 2130)

#define CAT_NAMEVALUE_STRUCT                ((LPCSTR) 2221)
#define CAT_MEMBERINFO_STRUCT               ((LPCSTR) 2222)


#define SPC_UUID_LENGTH     16
typedef BYTE SPC_UUID[SPC_UUID_LENGTH];

typedef struct _SPC_SERIALIZED_OBJECT
{
    SPC_UUID            ClassId;
    CRYPT_DATA_BLOB     SerializedData;

} SPC_SERIALIZED_OBJECT, *PSPC_SERIALIZED_OBJECT;

typedef struct SPC_SIGINFO_
{
    DWORD       dwSipVersion;
    GUID        gSIPGuid;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
    DWORD       dwReserved5;

} SPC_SIGINFO, *PSPC_SIGINFO;

typedef struct SPC_LINK_
{
    DWORD dwLinkChoice;
#               define          SPC_URL_LINK_CHOICE         1
#               define          SPC_MONIKER_LINK_CHOICE     2
#               define          SPC_FILE_LINK_CHOICE        3

    union
    {
        LPWSTR                  pwszUrl;
        SPC_SERIALIZED_OBJECT   Moniker;
        LPWSTR                  pwszFile;
    };

} SPC_LINK, *PSPC_LINK;

typedef struct _SPC_PE_IMAGE_DATA
{
    CRYPT_BIT_BLOB            Flags;
    PSPC_LINK                 pFile;

} SPC_PE_IMAGE_DATA, *PSPC_PE_IMAGE_DATA;

typedef struct _SPC_INDIRECT_DATA_CONTENT
{
    CRYPT_ATTRIBUTE_TYPE_VALUE  Data;
    CRYPT_ALGORITHM_IDENTIFIER  DigestAlgorithm;
    CRYPT_HASH_BLOB             Digest;

} SPC_INDIRECT_DATA_CONTENT, *PSPC_INDIRECT_DATA_CONTENT;

typedef struct _SPC_FINANCIAL_CRITERIA
{
    BOOL                        fFinancialInfoAvailable;
    BOOL                        fMeetsCriteria;

} SPC_FINANCIAL_CRITERIA, *PSPC_FINANCIAL_CRITERIA;

typedef struct _SPC_IMAGE
{
    struct SPC_LINK_            *pImageLink;
    CRYPT_DATA_BLOB             Bitmap;
    CRYPT_DATA_BLOB             Metafile;
    CRYPT_DATA_BLOB             EnhancedMetafile;
    CRYPT_DATA_BLOB             GifFile;

} SPC_IMAGE, *PSPC_IMAGE;

typedef struct _SPC_SP_AGENCY_INFO
{
    struct SPC_LINK_            *pPolicyInformation;
    LPWSTR                      pwszPolicyDisplayText;
    PSPC_IMAGE                  pLogoImage;
    struct SPC_LINK_            *pLogoLink;

} SPC_SP_AGENCY_INFO, *PSPC_SP_AGENCY_INFO;

typedef struct _SPC_STATEMENT_TYPE
{
    DWORD                       cKeyPurposeId;
    LPSTR                       *rgpszKeyPurposeId;     // pszObjId

} SPC_STATEMENT_TYPE, *PSPC_STATEMENT_TYPE;

typedef struct _SPC_SP_OPUS_INFO
{
    LPCWSTR                     pwszProgramName;
    struct SPC_LINK_            *pMoreInfo;
    struct SPC_LINK_            *pPublisherInfo;

} SPC_SP_OPUS_INFO, *PSPC_SP_OPUS_INFO;

typedef struct _CAT_NAMEVALUE
{
    LPWSTR          pwszTag;
    DWORD           fdwFlags;
    CRYPT_DATA_BLOB Value;

} CAT_NAMEVALUE, *PCAT_NAMEVALUE;

typedef struct _CAT_MEMBERINFO
{
    LPWSTR          pwszSubjGuid;
    DWORD           dwCertVersion;

} CAT_MEMBERINFO, *PCAT_MEMBERINFO;

#include <poppack.h>



//////////////////////////////////////////////////////////////////////////////////
//
//  support for old calling convention: *** DO NOT USE ***
//
#ifdef WT_DEFINE_ALL_APIS

typedef struct _WIN_CERTIFICATE
{
    DWORD       dwLength;
    WORD        wRevision;
    WORD        wCertificateType;   // WIN_CERT_TYPE_xxx
    BYTE        bCertificate[ANYSIZE_ARRAY];

} WIN_CERTIFICATE, *LPWIN_CERTIFICATE;

#define WIN_CERT_REVISION_1_0               (0x0100)
#define WIN_CERT_REVISION_2_0               (0x0200)

#define WIN_CERT_TYPE_X509                  (0x0001)   // bCertificate contains an X.509 Certificate
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA      (0x0002)   // bCertificate contains a PKCS SignedData structure
#define WIN_CERT_TYPE_RESERVED_1            (0x0003)   // Reserved


typedef LPVOID WIN_TRUST_SUBJECT;

typedef struct _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
{
    HANDLE            hClientToken;
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT, *LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ;


typedef struct _WIN_TRUST_ACTDATA_SUBJECT_ONLY
{
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} WIN_TRUST_ACTDATA_SUBJECT_ONLY, *LPWIN_TRUST_ACTDATA_SUBJECT_ONLY;

/* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_RAW_FILE                              \
            { 0x959dc450,                                        \
              0x8d9e,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_PE_IMAGE                              \
            { 0x43c9a1e0,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }


/* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_JAVA_CLASS                            \
            { 0x08ad3990,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
/* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 */
#define WIN_TRUST_SUBJTYPE_CABINET                               \
            { 0xd17c5374,                                        \
              0xa392,                                            \
              0x11cf,                                            \
              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
            }

typedef struct _WIN_TRUST_SUBJECT_FILE
{
    HANDLE  hFile;
    LPCWSTR lpPath;

} WIN_TRUST_SUBJECT_FILE, *LPWIN_TRUST_SUBJECT_FILE;

#define WIN_TRUST_SUBJTYPE_RAW_FILEEX                            \
            { 0x6f458110,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_PE_IMAGEEX                            \
            { 0x6f458111,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_JAVA_CLASSEX                          \
            { 0x6f458113,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_CABINETEX                             \
            { 0x6f458114,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

typedef struct _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY
{
    HANDLE  hFile;              // handle to the open file if you got it
    LPCWSTR lpPath;             // the path to open if you don't
    LPCWSTR lpDisplayName;      // (optional) display name to show to user

} WIN_TRUST_SUBJECT_FILE_AND_DISPLAY, *LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY;

/* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_OLE_STORAGE                           \
            { 0xc257e740,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }


/* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_TRUSTED_PUBLISHER                        \
            { 0x66426730,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb */
#define     WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE                    \
            { 0x8bc96b00,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE                       \
            { 0x64b9d180,                                        \
              0x8da2,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

typedef struct _WIN_SPUB_TRUSTED_PUBLISHER_DATA
{
    HANDLE            hClientToken;
    LPWIN_CERTIFICATE lpCertificate;

} WIN_SPUB_TRUSTED_PUBLISHER_DATA, *LPWIN_SPUB_TRUSTED_PUBLISHER_DATA;

#endif



#ifdef __cplusplus
}
#endif

#endif // WINTRUST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\dllmain.h ===
// --------------------------------------------------------------------------------
// Dllmain.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Defined later

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern CRITICAL_SECTION     g_csDllMain;
extern CRITICAL_SECTION     g_csCounter;
extern DWORD                g_dwCounter;     // boundary/cid/mid ratchet
extern LONG                 g_cRef;
extern LONG                 g_cLock;
extern HINSTANCE            g_hInst;
extern HINSTANCE            g_hLocRes;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);
DWORD DwCounterNext(void);
HRESULT GetTypeLibrary(ITypeLib **ppTypeLib);

#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\dllmain.cpp ===
// --------------------------------------------------------------------------------
// Dllmain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#define DEFINE_STRING_CONSTANTS
#define DEFINE_STRCONST
#define DEFINE_PROPSYMBOLS
#define DEFINE_TRIGGERS
#include "msoert.h"
#include "Mimeole.h"
#include <advpub.h>
#include "dllmain.h"
#include "init.h"

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
CRITICAL_SECTION    g_csDllMain={0};
LONG                g_cRef=0;
LONG                g_cLock=0;
HINSTANCE           g_hInst=NULL;
IMalloc            *g_pMalloc=NULL;

// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// InitGlobalVars
// --------------------------------------------------------------------------------
void InitGlobalVars(void)
{
    // Locals
    SYSTEM_INFO rSystemInfo;

	// Initialize Global Critical Sections
    InitializeCriticalSection(&g_csDllMain);

	// Create OLE Task Memory Allocator
	CoGetMalloc(1, &g_pMalloc);
	Assert(g_pMalloc);
}

// --------------------------------------------------------------------------------
// FreeGlobalVars
// --------------------------------------------------------------------------------
void FreeGlobalVars(void)
{
    DeleteCriticalSection(&g_csDllMain);
	SafeRelease(g_pMalloc);
}

// --------------------------------------------------------------------------------
// Win32 Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
	    g_hInst = hInst;
		InitGlobalVars();
        SideAssert(DisableThreadLibraryCalls(hInst));
        break;

    case DLL_PROCESS_DETACH:
		FreeGlobalVars();
	    break;
    }

    // Done
    return TRUE;
}


// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    TraceCall("DllAddRef");
    if (g_cRef == 0 && !g_fInitialized)
        InitGWNoteThread(TRUE);

    return (ULONG)InterlockedIncrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    TraceCall("DllRelease");
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    EnterCriticalSection(&g_csDllMain);

    HRESULT hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;

    if (hr==S_OK && g_fInitialized)
        InitGWNoteThread(FALSE);

    LeaveCriticalSection(&g_csDllMain);
    return hr;
}

// --------------------------------------------------------------------------------
// CallRegInstall - Self-Registration Helper
// --------------------------------------------------------------------------------
HRESULT CallRegInstall(LPCSTR szSection)
{
    // Locals
    HRESULT     hr=S_OK;
    HINSTANCE   hAdvPack=NULL;
    REGINSTALL  pfnri;

    // TraceCAll
    TraceCall("CallRegInstall");

    // Load ADVPACK.DLL
    hAdvPack = LoadLibraryA("ADVPACK.DLL");
    if (NULL == hAdvPack)
    {
        hr = TraceResult(TYPE_E_CANTLOADLIBRARY);
        goto exit;
    }

    // Get Proc Address for registration util
    pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
    if (NULL == pfnri)
    {
        hr = TraceResult(TYPE_E_CANTLOADLIBRARY);
        goto exit;
    }

    // Call the self-reg routine

    IF_FAILEXIT(hr = pfnri(g_hInst, szSection, NULL));

exit:
    // Cleanup
    SafeFreeLibrary(hAdvPack);
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("DllRegisterServer");

    // Register my self
    IF_FAILEXIT(hr = CallRegInstall("Reg"));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("DllUnregisterServer");

    // UnRegister
    IF_FAILEXIT(hr = CallRegInstall("UnReg"));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Override new operator
// --------------------------------------------------------------------------------
void * __cdecl operator new(UINT cb)
{
    LPVOID  lpv = 0;

    lpv = CoTaskMemAlloc(cb);
    if (lpv)
    {
#ifdef DEBUG
        memset(lpv, 0xFF, cb);
#endif 
    }
    return lpv;
}

// --------------------------------------------------------------------------------
// Override delete operator
// --------------------------------------------------------------------------------
#ifndef WIN16
void __cdecl operator delete(LPVOID pv)
#else
void __cdecl operator delete(PVOID pv)
#endif
{
    CoTaskMemFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\envhost.cpp ===
/*
 *    e n v h o s t . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "resource.h"
#include "envcid.h"
#include "commdlg.h"
#include "docobj.h"
#include "dllmain.h"
#include "msoert.h"
#include "mimeole.h"
#include "envhost.h"
#include "richedit.h"
#include "init.h"
#include "shellapi.h"

HINSTANCE   s_hRichEdit;
HINSTANCE   g_hLocRes ;
HACCEL      g_hAccelMailSend;

HRESULT HrRicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags);
void SaveFocus(BOOL fActive, HWND *phwnd);
        

static const TCHAR  c_szGWNoteWndClass[] = "GW_Note";

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CEnvHost::CEnvHost(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    DllAddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CEnvHost::~CEnvHost()
{
    DllRelease();
}

//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CEnvHost::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IMsoEnvelopeHost *)this;
    else if (IsEqualIID(riid, IID_IMsoEnvelopeHost))
        *lplpObj = (LPVOID)(IMsoEnvelopeHost *)this;
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}



HRESULT CEnvHost::CreateNote(IUnknown *punk, REFCLSID clsidCreate, LPCWSTR wszTheme, LPCWSTR wszAuthor, LPCWSTR wszPrefix, DWORD grfCreate)
{
    return HrCreateNote(clsidCreate, grfCreate);
}

HRESULT CEnvHost::LockServer(BOOL fLock)
{
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CGWNote::CGWNote(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    m_pEnv=NULL;
    m_hwnd=NULL;
    m_hwndRE=NULL;
    m_pComponent=NULL;
    m_hwndFocus=NULL;

    DllAddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CGWNote::~CGWNote()
{
    DllRelease();
}

//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IPersistMime *)this;
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(IPersistMime *)this;
    else if (IsEqualIID(riid, IID_IMsoEnvelopeSite))
        *lplpObj = (LPVOID)(IMsoEnvelopeSite *)this;
    else if (IsEqualIID(riid, IID_IMsoComponentManager))
        *lplpObj = (LPVOID)(IMsoComponentManager *)this;
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::GetClassID(CLSID *pClassID)
{
	*pClassID = CLSID_GWEnvelopeHost;
    return NOERROR;
}

// *** IServiceProvider ***
//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (IsEqualGUID(guidService, IID_IMsoComponentManager))
        return PrivateQueryInterface(riid, ppvObject);

    return E_NOINTERFACE;
}

// *** IPersistMime ***
//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::Load(IMimeMessage *pMsg)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CGWNote::Save(IMimeMessage *pMsg, DWORD dwFlags)
{
    IPersistMime    *pPM;
    IStream         *pstm;
    HRESULT         hr;

    // save envelope props
    if (m_pEnv &&
        m_pEnv->QueryInterface(IID_IPersistMime, (LPVOID *)&pPM)==S_OK)
        {
        hr = pPM->Save(pMsg, dwFlags);
        pPM->Release();
        }

    // save body props
    if (MimeOleCreateVirtualStream(&pstm)==S_OK)
        {
        if (HrRicheditStreamOut(m_hwndRE, pstm, SF_TEXT)==S_OK)
            pMsg->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pstm, NULL);
        
        pstm->Release();
        }
    return hr;
}

HRESULT CGWNote::RequestResize(int *pcHeight)
{
    RECT rc;

    m_cyEnv = *pcHeight;

    GetClientRect(m_hwnd, &rc);
    rc.top +=2;
    rc.bottom = m_cyEnv+2;
    m_pEnv->Resize(&rc);

    GetClientRect(m_hwnd, &rc);
    rc.top += m_cyEnv + 4;
    rc.bottom -=2;
    SetWindowPos(m_hwndRE, NULL, 0, rc.top, rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER);
    return S_OK;
}

HRESULT CGWNote::CloseNote(DWORD grfClose)
{
    SendMessage(m_hwnd, WM_CLOSE, 0, 0);
    return S_OK;
}

HRESULT CGWNote::GetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody)
{
    return E_NOTIMPL;
}

HRESULT CGWNote::SetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody)
{
    return S_OK;
}

HRESULT CGWNote::SetFocus(BOOL fTab)
{
    if (fTab)
        ::SetFocus(m_hwndRE);
    return S_OK;
}

HRESULT CGWNote::OnEnvSetFocus()
{
    return S_OK;
}

HRESULT CGWNote::OnPropChange(ULONG dispid)
{
    return S_OK;
}

HRESULT CGWNote::IsBodyDirty()
{
    return S_OK;
}

HRESULT CGWNote::HandsOff()
{
    return S_OK;
}

HRESULT CGWNote::GetMsoInst(HMSOINST *phinst)
{
    return E_NOTIMPL;
}

HRESULT CGWNote::GetFrameWnd(HWND *phwndFrame)
{
    return E_NOTIMPL;
}

HRESULT CGWNote::DisplayMessage(HRESULT hr, LPCWSTR wszError, DWORD grfMsg)
{
    return S_OK;
}

LRESULT CGWNote::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CGWNote *pNote;

    if(msg==WM_CREATE)
        {
        pNote=(CGWNote *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pNote)
            return -1;

        if(FAILED(pNote->OnCreate(hwnd)))
            return -1;
        }
    
    pNote = (CGWNote *)GetWndThisPtr(hwnd);
    if(pNote)
        return pNote->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);

}

LRESULT CGWNote::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LONG    lret;

    switch (msg)
        {
        case WM_NOTIFY:
            return (WMNotify(wParam, (NMHDR *)lParam)==S_OK);
                

        case WM_COMMAND:
            if (WMCommand(  GET_WM_COMMAND_HWND(wParam, lParam),
                            GET_WM_COMMAND_ID(wParam, lParam),
                            GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;

            break;

        case WM_SIZE:
            RequestResize((int *)&m_cyEnv);
            break;

        case WM_NCDESTROY:
            OnNCDestroy();
            break;
        }

    lret = DefWindowProc(hwnd, msg, wParam, lParam);

    if(msg==WM_ACTIVATE)
        {
        // post-process wm_activates to set focus back to
        // control
        SaveFocus((BOOL)(LOWORD(wParam)), &m_hwndFocus);
        g_pActiveNote = (LOWORD(wParam)==WA_INACTIVE)?NULL:this;
        }

    return lret;

}





HRESULT CGWNote::Init(REFCLSID clsidEnvelope, DWORD dwFlags)
{

    HRESULT     hr=S_OK;
    HWND        hwnd;
    WNDCLASS    wc;
    HMENU       hMenu;

	TraceCall("CDocHost::Init");

    if (!GetClassInfo(g_hInst, c_szGWNoteWndClass, &wc))
        {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        wc.lpfnWndProc   = (WNDPROC)CGWNote::ExtWndProc;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_szGWNoteWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.style = CS_DBLCLKS;

        if(!RegisterClass(&wc))
            return E_OUTOFMEMORY;
        }

    hMenu = LoadMenu(g_hInst, "GWNOTEMENU");
    if (!hMenu)
        return E_OUTOFMEMORY;

    hwnd=CreateWindowEx(WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT,
                        c_szGWNoteWndClass, 
						"GW Note Control",
                        WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN,
                        0, 
						0,
						400, 
						400, 
						NULL, 
                        hMenu, 
						g_hInst, 
						(LPVOID)this);
    if(!hwnd)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

    
    hr = InitEnvelope(clsidEnvelope, dwFlags);

error:
    return hr;
}

HRESULT CGWNote::OnCreate(HWND hwnd)
{
    CHARFORMAT  cf={0};

    m_hwnd = hwnd;
    SetWindowLong(hwnd, GWL_USERDATA, (LPARAM)this);

    m_hwndRE  = CreateWindowEx(WS_EX_CLIENTEDGE, 
                                "RichEdit",
                                "",
                                //ES_MULTILINE|ES_SAVESEL|ES_AUTOVSCROLL|ES_SELECTIONBAR|ES_WANTRETURN|WS_VSCROLL|WS_CHILD|WS_TABSTOP|WS_VISIBLE,
                                ES_SAVESEL|ES_WANTRETURN|ES_MULTILINE|WS_CHILD|WS_TABSTOP|WS_VISIBLE|ES_AUTOVSCROLL|WS_VSCROLL,
                                0, 0, 0, 0,
                                hwnd, 
                                (HMENU)99,
                                g_hInst,
                                NULL);
    
    if (!m_hwndRE)
        return E_FAIL;

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR|CFM_FACE;
    cf.crTextColor = RGB(0,0,255);
    lstrcpy(cf.szFaceName, "Verdana");

    SendMessage(m_hwndRE, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
    SendMessage(m_hwndRE, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    SendMessage(m_hwndRE, EM_SETEVENTMASK, 0, ENM_KEYEVENTS);
    AddRef();
    return S_OK;
}


HRESULT CGWNote::OnNCDestroy()
{
    SafeRelease(m_pEnv);
    if (m_pComponent)
        {
        m_pComponent->Terminate();
        SafeRelease(m_pComponent);
        }

    SetWindowLong(m_hwnd, GWL_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
    return S_OK;
}

HRESULT CGWNote::Show()
{
    ShowWindow(m_hwnd, SW_SHOW);
    return S_OK;
}

HRESULT CGWNote::InitEnvelope(REFCLSID clsidEnvelope, DWORD dwFlags)
{
    HRESULT hr;
    RECT    rc;

    hr = CoCreateInstance(clsidEnvelope, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER, IID_IMsoEnvelope, (LPVOID *)&m_pEnv);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->Init(NULL, (IMsoEnvelopeSite *)this, dwFlags);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->SetParent(m_hwnd);
    if (FAILED(hr))
        goto error;

    hr = m_pEnv->Show(TRUE);
    if (FAILED(hr))
        goto error;

    m_pEnv->SetFocus(ENV_FOCUS_INITIAL);

error:
    return hr;        
}


HRESULT CGWNote::TranslateAcclerator(MSG *lpmsg)
{
    if (!g_hAccelMailSend)
        g_hAccelMailSend= LoadAccelerators(g_hInst, MAKEINTRESOURCE(idacMail_SendNote));

    if (::TranslateAccelerator(m_hwnd, g_hAccelMailSend, lpmsg))
        return S_OK;


    if (m_pComponent &&
        m_pComponent->FPreTranslateMessage(lpmsg))
        return S_OK;

    return S_FALSE;
}



DWORD CALLBACK EditStreamOutCallback(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb)
{
    return ((LPSTREAM)dwCookie)->Write(pbBuff, cb, (ULONG *)pcb);
}



HRESULT HrRicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags)
{
    EDITSTREAM  es;

    if(!pstm)
        return E_INVALIDARG;

    if(!IsWindow(hwndRE))
        return E_INVALIDARG;

    HrRewindStream(pstm);

    es.dwCookie = (DWORD)pstm;
    es.pfnCallback=(EDITSTREAMCALLBACK)EditStreamOutCallback;
    SendMessage(hwndRE, EM_STREAMOUT, uSelFlags, (LONG)&es);
    return S_OK;
}




BOOL CGWNote::FRegisterComponent(IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, DWORD *pdwComponentID)
{
    if (m_pComponent)   // only one register allowed
        return E_FAIL;

    ReplaceInterface(m_pComponent, piComponent);
    *pdwComponentID=666;
    return TRUE;
}

BOOL CGWNote::FRevokeComponent(DWORD dwComponentID)
{
    return TRUE;
}

BOOL CGWNote::FUpdateComponentRegistration(DWORD dwComponentID, const MSOCRINFO *pcrinfo)
{
    return FALSE;
}

BOOL CGWNote::FOnComponentActivate(DWORD dwComponentID)
{
    return FALSE;
}

BOOL CGWNote::FSetTrackingComponent(DWORD dwComponentID, BOOL fTrack)
{
    return FALSE;
}

void CGWNote::OnComponentEnterState(DWORD dwComponentID, ULONG uStateID, ULONG uContext,ULONG cpicmExclude,IMsoComponentManager **rgpicmExclude, DWORD dwReserved)
{
}

BOOL CGWNote::FOnComponentExitState(DWORD dwComponentID, ULONG uStateID, ULONG uContext,ULONG cpicmExclude,IMsoComponentManager **rgpicmExclude)
{
    return FALSE;
}

BOOL CGWNote::FInState(ULONG uStateID, void *pvoid)
{
    return FALSE;
}

BOOL CGWNote::FContinueIdle ()
{
    return FALSE;
}

BOOL CGWNote::FPushMessageLoop(DWORD dwComponentID, ULONG uReason, void *pvLoopData)
{
    return FALSE;
}

BOOL CGWNote::FCreateSubComponentManager(IUnknown *piunkOuter, IUnknown *piunkServProv,REFIID riid, void **ppvObj)
{
    return FALSE;
}

BOOL CGWNote::FGetParentComponentManager(IMsoComponentManager **ppicm)
{
    return FALSE;
}

BOOL CGWNote::FGetActiveComponent(DWORD dwgac, IMsoComponent **ppic, MSOCRINFO *pcrinfo, DWORD dwReserved)
{
    return FALSE;
}


BOOL CGWNote::FDebugMessage(HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}




HRESULT CGWNote::WMCommand(HWND hwndCmd, int id, WORD wCmd)
{
    if (wCmd > 1)
        return S_FALSE;

    switch(id)
        {
        case idmNewMsg:
            ShellExecute(m_hwnd, NULL, "mailto:", 0, 0, SW_SHOW);
            return S_OK;

        case idmProperties:
            MessageBox(m_hwnd, "PlaceHolder", "Properties", MB_OK);
            return S_OK;

        case idmSaveAs:
            return SaveAs();

        case idmClose:
            PostMessage(m_hwnd, WM_CLOSE, 0, 0);
            return S_OK;

        case idmCheckNames:
            return HrHeaderExecCommand(MSOEENVCMDID_CHECKNAMES, MSOCMDEXECOPT_PROMPTUSER, NULL);

        case idmPickRecipients:
            return HrHeaderExecCommand(MSOEENVCMDID_SELECTRECIPIENTS, MSOCMDEXECOPT_DODEFAULT, NULL);

        case idmViewContacts:
            return HrHeaderExecCommand(MSOEENVCMDID_VIEWCONTACTS, MSOCMDEXECOPT_DODEFAULT, NULL);
        
        default:
            MessageBox(m_hwnd, "Not Yet Implemented", "Menu Command", MB_OK);
            return S_OK;
        }
            
    return S_FALSE;
}



HRESULT CGWNote::HrHeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn)
{
    HRESULT             hr = S_FALSE;
    IOleCommandTarget   *pCmdTarget;

    if(m_pEnv &&
        m_pEnv->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
        hr = pCmdTarget->Exec(&CGID_Envelope, uCmdID, nCmdExecOpt, pvaIn, NULL);
        pCmdTarget->Release();
        }
    return hr;

}

HRESULT CGWNote::WMNotify(int idFrom, NMHDR *pnmh)
{
    MSGFILTER   *pmf=(MSGFILTER *)pnmh;
    BOOL        fShift;

    switch (pnmh->code)
        {
        case EN_MSGFILTER:
            if (pmf->msg == WM_KEYDOWN && pmf->wParam == VK_TAB && !(GetKeyState(VK_CONTROL) & 0x8000))
                {
                // shift tab puts focus in the envelope
                if (GetKeyState(VK_SHIFT)&0x8000 && m_pEnv)
                    {
                    m_pEnv->SetFocus(ENV_FOCUS_TAB);
                    return S_OK;
                    }
                }
            break;
        }
    return S_FALSE;
}



void SaveFocus(BOOL fActive, HWND *phwnd)
{
    if(fActive&&IsWindow(*phwnd))
        SetFocus(*phwnd);
    else
        *phwnd=GetFocus();
}



static char c_szFilter[] = "Rfc 822 Messages (*.eml)\0*.eml\0\0";

HRESULT CGWNote::SaveAs()
{
    OPENFILENAME    ofn;
    TCHAR           szFile[MAX_PATH];
    TCHAR           szTitle[MAX_PATH];
    TCHAR           szDefExt[30];
    WCHAR           szFileW[MAX_PATH];

    lstrcpy(szFile, "c:\\*.eml");
    lstrcpy(szDefExt, ".eml");
    lstrcpy(szTitle, "Save Message As...");
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = c_szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;

    if (*szFile==NULL)
        return E_FAIL;
    

    // Show OpenFile Dialog
    if (!GetSaveFileName(&ofn))
        return MIMEEDIT_E_USERCANCEL;
 
    MultiByteToWideChar(CP_ACP, 0, szFile, -1, szFileW, MAX_PATH);

    return SaveToFile(szFileW);
}


HRESULT CGWNote::SaveToFile(LPWSTR pszW)
{
    IPersistMime        *ppm;
    IPersistFile        *pPF;
    IMimeMessage        *pMsg;
    HRESULT             hr;

    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (!FAILED(hr))
        {
        pMsg->InitNew();
        
        hr = pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF);
        if (!FAILED(hr))
            {
            hr = Save(pMsg, 0);
            if (!FAILED(hr))
                {
                hr = pPF->Save(pszW, FALSE);
                }
            pPF->Release();
            }
        pMsg->Release();
        }
    return hr;
}


HRESULT CGWNote::DirtyToolbars(void)
{
    return S_OK;
}


HRESULT CGWNote::SetHelpMode(BOOL fEnter)
{
    return S_OK;
}

HRESULT CGWNote::TranslateAccelerators(MSG *pMsg)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include "msoert.h"
#include "mimeole.h"
#include "envhost.h"

// --------------------------------------------------------------------------------
// Pretty
// --------------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_GWEnvelopeHost,          OBJTYPE0, (PFCREATEINSTANCE)GWNote_CreateInstance)
};
                 
// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK; 
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TrapError(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else       InterlockedDecrement(&g_cLock);
    return NOERROR;
}

// --------------------------------------------------------------------------------
// GWNote_CreateInstance
// --------------------------------------------------------------------------------
HRESULT GWNote_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CEnvHost *pNew= new CEnvHost(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMsoEnvelopeHost *);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\envhost.h ===
/*
 *    e n v h o s t . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _ENVHOST_H
#define _ENVHOST_H

#include "privunk.h"
#include <envelope.h>
#include <mso.h>
#include <envguid.h>


class CEnvHost:
    public IMsoEnvelopeHost,
    public CPrivateUnknown
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // *** IMsoEnvelopeHost ***
    virtual HRESULT STDMETHODCALLTYPE CreateNote(IUnknown *punk,REFCLSID clsidCreate, LPCWSTR wszTheme, LPCWSTR wszAuthor, LPCWSTR wszPrefix, DWORD grfCreate);
    virtual HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);

    CEnvHost(IUnknown *pUnkOuter=NULL);
    virtual ~CEnvHost();

private:

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

};


class CGWNote:
    public IPersistMime,
    public IServiceProvider,
    public IMsoEnvelopeSite,
    public IMsoComponentManager,
    public CPrivateUnknown
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // *** IServiceProvider ***
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    // *** IPersist ***
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);

    // *** IPersistMime ***
	virtual HRESULT STDMETHODCALLTYPE Load(IMimeMessage *pMsg);
	virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwFlags);

    // *** IEnvelopeSite ***
    virtual HRESULT STDMETHODCALLTYPE RequestResize(int *pcHeight);
    virtual HRESULT STDMETHODCALLTYPE CloseNote(DWORD grfClose);
    virtual HRESULT STDMETHODCALLTYPE GetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody);
    virtual HRESULT STDMETHODCALLTYPE SetBody(IStream *pstm, DWORD dwCodePage, DWORD grfBody);
    virtual HRESULT STDMETHODCALLTYPE SetFocus(BOOL fTab);
    virtual HRESULT STDMETHODCALLTYPE OnEnvSetFocus();
    virtual HRESULT STDMETHODCALLTYPE DirtyToolbars(void);

    virtual HRESULT STDMETHODCALLTYPE OnPropChange(ULONG dispid);
    virtual HRESULT STDMETHODCALLTYPE IsBodyDirty();
    virtual HRESULT STDMETHODCALLTYPE HandsOff();
    virtual HRESULT STDMETHODCALLTYPE GetMsoInst(HMSOINST *phinst);
    virtual HRESULT STDMETHODCALLTYPE GetFrameWnd(HWND *phwndFrame);
    virtual HRESULT STDMETHODCALLTYPE DisplayMessage(HRESULT hr, LPCWSTR wszError, DWORD grfMsg);

    virtual HRESULT STDMETHODCALLTYPE SetHelpMode(BOOL fEnter);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerators(MSG *pMsg);
    
    // *** IMsoComponentManager ***       
	//HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID iid, void **ppvObj);
    BOOL STDMETHODCALLTYPE FDebugMessage(HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam);
	BOOL STDMETHODCALLTYPE FRegisterComponent(IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, DWORD *pdwComponentID);
	BOOL STDMETHODCALLTYPE FRevokeComponent(DWORD dwComponentID);
	BOOL STDMETHODCALLTYPE FUpdateComponentRegistration(DWORD dwComponentID, const MSOCRINFO *pcrinfo);
	BOOL STDMETHODCALLTYPE FOnComponentActivate(DWORD dwComponentID);
	BOOL STDMETHODCALLTYPE FSetTrackingComponent(DWORD dwComponentID, BOOL fTrack);
	void STDMETHODCALLTYPE OnComponentEnterState(DWORD dwComponentID, ULONG uStateID, ULONG uContext, ULONG cpicmExclude, IMsoComponentManager **rgpicmExclude, DWORD dwReserved);
	BOOL STDMETHODCALLTYPE FOnComponentExitState(DWORD dwComponentID, ULONG uStateID, ULONG uContext, ULONG cpicmExclude, IMsoComponentManager **rgpicmExclude);
	BOOL STDMETHODCALLTYPE FInState(ULONG uStateID, void *pvoid);
	BOOL STDMETHODCALLTYPE FContinueIdle ();
	BOOL STDMETHODCALLTYPE FPushMessageLoop(DWORD dwComponentID, ULONG uReason, void *pvLoopData);
	BOOL STDMETHODCALLTYPE FCreateSubComponentManager(IUnknown *piunkOuter, IUnknown *piunkServProv,REFIID riid, void **ppvObj);
	BOOL STDMETHODCALLTYPE FGetParentComponentManager(IMsoComponentManager **ppicm);
    BOOL STDMETHODCALLTYPE FGetActiveComponent(DWORD dwgac, IMsoComponent **ppic, MSOCRINFO *pcrinfo, DWORD dwReserved);

    CGWNote(IUnknown *pUnkOuter=NULL);
    virtual ~CGWNote();

    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT Init(REFCLSID clsidEnvelope, DWORD dwFlags);
    HRESULT Show();
    
    HRESULT TranslateAcclerator(MSG *lpmsg);

private:
    IMsoEnvelope    *m_pEnv;
    IMsoComponent   *m_pComponent;

    HWND            m_hwnd,
                    m_hwndRE,
                    m_hwndFocus;
    ULONG           m_cyEnv;

    HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT OnNCDestroy();
    HRESULT OnCreate(HWND hwnd);
    HRESULT InitEnvelope(REFCLSID clsidEnvelope, DWORD dwFlags);
    HRESULT WMCommand(HWND hwndCmd, int id, WORD wCmd);
    HRESULT WMNotify(int idFrom, NMHDR *pnmh);

    HRESULT HrHeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn);

    //saveas helpers
    HRESULT SaveToFile(LPWSTR pszW);
    HRESULT SaveAs();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CClassFactory;

// --------------------------------------------------------------------------------
// Object Flags
// --------------------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    // ----------------------------------------------------------------------------
    // Public Data
    // ----------------------------------------------------------------------------
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    // ----------------------------------------------------------------------------
    // IUnknown members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IClassFactory members
    // ----------------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

// --------------------------------------------------------------------------------
// Object Creators
// --------------------------------------------------------------------------------
HRESULT GWNote_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\init.cpp ===
/*
 *    i n i t . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include "msoert.h"
#include "mimeole.h"
#include "envhost.h"
#include "init.h"

LRESULT CALLBACK InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
HRESULT HrCreateNoteThisThread(WPARAM wp, LPARAM lp);
DWORD MainThreadProc(LPVOID lpvUnused);
void NoteMsgPump();


CGWNote             *g_pActiveNote=0;
HWND                g_hwndInit = NULL;
HEVENT              g_hEventSpoolerInit =NULL;
DWORD               g_dwNoteThreadID=0;
BOOL                g_fInitialized=FALSE;

static HTHREAD      s_hMainThread = NULL;
static HEVENT       s_hInitEvent = NULL;
static DWORD        s_dwMainThreadId = 0;
static TCHAR        s_szInitWndClass[] = "GWInitWindow";

void InitGWNoteThread(BOOL fInit)
{
    if (fInit)
        {
        // create an event for the main thread to signal
        if (s_hInitEvent = CreateEvent(NULL, FALSE, FALSE, NULL))
            {
            if (s_hMainThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MainThreadProc, NULL, 0, &s_dwMainThreadId))
                {
                HANDLE  rghWait[]={s_hMainThread, s_hInitEvent};

                // wait for the main thread to signal that initialization is complete
                WaitForMultipleObjects(sizeof(rghWait)/sizeof(HANDLE), rghWait, FALSE, INFINITE);
                }
            
            CloseHandle(s_hInitEvent);
            s_hInitEvent = NULL;
            }
        }
    else
        {
        // tell the main thread to deinitialize everything
        // the SendMessage() will block the calling thread until deinit is complete,
        if (g_hwndInit)
            SendMessage(g_hwndInit, ITM_SHUTDOWNTHREAD, 0, 0);

        // wait for main thread to terminate (when it exits its message loop)
        // this isn't strictly necessary, but it helps to ensure proper cleanup.
        WaitForSingleObject(s_hMainThread, INFINITE);

        CloseHandle(s_hMainThread);
        s_hMainThread = NULL;
        }
}

DWORD MainThreadProc(LPVOID lpvUnused)
{
    DWORD   dw;
    HRESULT hr;
    RECT    rc={0};
 
    WNDCLASS wc = { 0,                  // style
                    InitWndProc,        // lpfnWndProc
                    0,                  // cbClsExtra
                    0,                  // cbWndExtra
                    g_hInst,            // hInstance
                    NULL,               // hIcon
                    NULL,               // hCursor
                    NULL,               // hbrBackground
                    NULL,               // lpszMenuName
                    s_szInitWndClass }; // lpszClassName

    g_dwNoteThreadID = GetCurrentThreadId();

    if (!RegisterClass(&wc))
        return 0;

    g_hwndInit = CreateWindowEx(NULL,
                                s_szInitWndClass,
                                s_szInitWndClass,
                                WS_POPUP,
                                0,0,0,0,
                                NULL,
                                NULL,
                                g_hInst,
                                NULL);
    if (!g_hwndInit)
        return 0;

    OleInitialize(0);

    g_fInitialized=TRUE;
    SetEvent(s_hInitEvent);

    NoteMsgPump();
    return 0;
}

LRESULT CALLBACK InitWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    BOOL fRet;
    HRESULT hr;

    switch(msg)
        {
        case ITM_SHUTDOWNTHREAD:
            Assert(GetCurrentThreadId()==s_dwMainThreadId);
            OleUninitialize();
            DestroyWindow(hwnd);
            PostThreadMessage(s_dwMainThreadId, WM_QUIT, 0, 0);
            g_fInitialized=FALSE;
            return 0;

        case ITM_CREATENOTEONTHREAD:
            return (LONG)HrCreateNoteThisThread(wp, lp);

        }
    return DefWindowProc(hwnd, msg, wp, lp);
}



void NoteMsgPump()
{
    MSG     msg;

    while (GetMessage(&msg, NULL, 0, 0))
        {
        if (msg.hwnd != g_hwndInit &&               // ignore init window msgs
            IsWindow(msg.hwnd))                     // ignore per-task msgs where hwnd=0
            {
            if(g_pActiveNote &&                     // if a note has focus, call it's XLateAccelerator...
                g_pActiveNote->TranslateAcclerator(&msg)==S_OK)
                continue;
            }
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
}

HRESULT HrCreateNote(REFCLSID clsidEnvelope, DWORD dwFlags)
{
    LPOLESTR    pstr;
    HRESULT     hr;

    if (FAILED(StringFromCLSID(clsidEnvelope, &pstr)))
        return E_FAIL;

    // switch thread
    hr = SendMessage (g_hwndInit, ITM_CREATENOTEONTHREAD, (WPARAM)pstr, (LPARAM)dwFlags);
    CoTaskMemFree(pstr);
    return hr;

}


HRESULT HrCreateNoteThisThread(WPARAM wp, LPARAM lp)
{
    static HINSTANCE s_hRichEdit=0;
    HRESULT hr;
    CGWNote *pNote=0;
    CLSID   clsid;

    // hack, need to free lib this
    if (!s_hRichEdit)
        s_hRichEdit = LoadLibrary("RICHED32.DLL");
 
    // need to create this puppy on new thread 
    pNote = new CGWNote(NULL);
    if (!pNote)
        return E_OUTOFMEMORY;

    CLSIDFromString((LPOLESTR)wp, &clsid);

    hr = pNote->Init(clsid, (DWORD)lp);
    if (FAILED(hr))
        goto error;

    hr = pNote->Show();

error:
    ReleaseObj(pNote);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\privunk.cpp ===
// --------------------------------------------------------------------------------
// Privunk.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "msoert.h"
#include "privunk.h"

// --------------------------------------------------------------------------------
// CPrivateUnknown::CPrivateUnknown
// --------------------------------------------------------------------------------
CPrivateUnknown::CPrivateUnknown(IUnknown *pUnkOuter) 
{
    m_pUnkOuter = pUnkOuter ? pUnkOuter : &m_cUnkInner;
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::SetOuter
// --------------------------------------------------------------------------------
void CPrivateUnknown::SetOuter(IUnknown *pUnkOuter)
{
    // Must have an outer, and should not have been aggregated yet...
    Assert(pUnkOuter && m_pUnkOuter == &m_cUnkInner);

    // Save pUnkOuter
    m_pUnkOuter = pUnkOuter;
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::QueryInterface
// --------------------------------------------------------------------------------
HRESULT CPrivateUnknown::CUnkInner::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    // I can handle the unknown
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // Return IUnknown
        *ppvObj = SAFECAST(this, IUnknown *);

        // Increment Ref Count
        InterlockedIncrement(&m_cRef);

        // Done
        return S_OK;
    }

    // Get my parent (computes the offset of the parent's base address)
    CPrivateUnknown *pParent = IToClass(CPrivateUnknown, m_cUnkInner, this);

    // Dispatch to PrivateQueryInterface
    return pParent->PrivateQueryInterface(riid, ppvObj);
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::AddRef
// --------------------------------------------------------------------------------
ULONG CPrivateUnknown::CUnkInner::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::Release
// --------------------------------------------------------------------------------
ULONG CPrivateUnknown::CUnkInner::Release(void)
{
    // Decrement Internal Reference Count
    LONG cRef = InterlockedDecrement(&m_cRef);

    // No dead yet...
    if (cRef > 0)
        return (ULONG)cRef;

    // Some groovy, mystical, disco stuff
    // protect against cached pointers bumping us up then down
    m_cRef = 1000; 

    // Get the parent
    CPrivateUnknown* pParent = IToClass(CPrivateUnknown, m_cUnkInner, this);

    // Kill the parent
    delete pParent;

    // Done
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\init.h ===
#ifndef _INIT_H
#define _INIT_H

class CGWNote;

#define ITM_SHUTDOWNTHREAD		(WM_USER + 1)
#define ITM_CREATENOTEONTHREAD	(WM_USER + 2)

void InitGWNoteThread(BOOL fInit);
HRESULT HrCreateNote(REFCLSID clsidEnvelope, DWORD dwFlags);

extern CGWNote  *g_pActiveNote;
extern HWND     g_hwndInit;
extern HEVENT   g_hEventSpoolerInit;
extern DWORD    g_dwNoteThreadID;
extern BOOL     g_fInitialized;

#endif //_INIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\privunk.h ===
// --------------------------------------------------------------------------------
// Privunk.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __PRIVUNK_H
#define __PRIVUNK_H

// --------------------------------------------------------------------------------
// CPrivateUnknown
// --------------------------------------------------------------------------------
class CPrivateUnknown : public IUnknown
{
private:
    // ----------------------------------------------------------------------------
    // Embed default IUnknown handler
    // ----------------------------------------------------------------------------
    class CUnkInner : public IUnknown
    {
    private:
        LONG m_cRef;     // Private Ref Count

    public:
        // Construction
        CUnkInner(void) { m_cRef = 1; }

        // IUnknown Members
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);
    };

    friend class CUnkInner;

    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    CUnkInner           m_cUnkInner;      // Private Inner
    IUnknown           *m_pUnkOuter;      // points to _cUnkInner or aggregating IUnknown

protected:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPrivateUnknown(IUnknown *pUnkOuter);
    virtual ~CPrivateUnknown(void) {};

    // ----------------------------------------------------------------------------
    // This is the QueryInterface the aggregator implements
    // ----------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj) = 0;

public:
    // ----------------------------------------------------------------------------
    // This is the IUnknown that subclasses returns from their CreateInstance func
    // ----------------------------------------------------------------------------
    IUnknown* GetInner() { return &m_cUnkInner; }

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    inline virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) {
        return m_pUnkOuter->QueryInterface(riid, ppvObj); }
    inline virtual STDMETHODIMP_(ULONG) AddRef(void) {
        return m_pUnkOuter->AddRef(); }
    inline virtual STDMETHODIMP_(ULONG) Release(void) {
        return m_pUnkOuter->Release(); }

    // ----------------------------------------------------------------------------
    // Public Utilities
    // ----------------------------------------------------------------------------
    void SetOuter(IUnknown *pUnkOuter);
};

#endif // __PRIVUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\badata.h ===
// badata.h: interface for the CAddressBookData class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __BADATA_H_
#define __BADATA_H_

// Pull in the WAB header files
#include <wab.h>
#include <mimeole.h>

class CIEMsgAb;

typedef struct tagITEMINFO {
    LONG        lObjectType;
    LPENTRYID   pEntryID;
    ULONG       cbEntryID;
} ITEMINFO, *PITEMINFO;

typedef enum
{
    LPARAM_MENTRY = 1,
    LPARAM_ABENTRY,
    LPARAM_MABENTRY,
    LPARAM_ABGRPENTRY,
    MAX_LPARAM
} MABENUM;

// MAB types masks

#define  MAB_CONTACT    0x001
#define  MAB_GROUP      0x002
#define  MAB_BUDDY      0x004     
#define  MAB_CERT       0x008


class ATL_NO_VTABLE CAddressBookData
{
public:
	/////////////////////////////////////////////////////////////////////////
	// Constructor & Destructor
	//
	CAddressBookData();
	virtual ~CAddressBookData();

	/////////////////////////////////////////////////////////////////////////
	// WAB Functions
	//
	BOOL	fIsWabLoaded(void) {return(m_pAdrBook ? TRUE : FALSE);};
	HRESULT OpenWabFile(BOOL fWAB);
	HRESULT LoadWabContents(CContainedWindow& ctlList, CIEMsgAb *pSink);
    HRESULT DoLDAPSearch(LPTSTR pszText, CContainedWindow& ctlList);
    HRESULT NewContact(HWND hwndParent);
    HRESULT AddRecipient(LPMIMEADDRESSTABLEW pAddrTable, LPSBinary pInfo, BOOL fGroup);
    HRESULT FreeListViewItem(LPSBinary pSB);
    HRESULT ShowDetails(HWND hwndParent, LPSBinary pSB);
    HRESULT AddAddress(LPWSTR pwszDisplay, LPWSTR pwszAddress);
    HRESULT GetDisplayName(LPSBinary pSB, LPWSTR pwszDisplayName, int nMax);
    HRESULT DeleteItems(ENTRYLIST *pList);
    HRESULT Unadvise(void)
    {
        if (m_ulConnection)
           m_pAdrBook->Unadvise(m_ulConnection);
        return (S_OK);
    }
    HRESULT Find(HWND hwndParent);
    HRESULT AddressBook(HWND hwndParent);
    HRESULT NewGroup(HWND hwndParent);
    HRESULT AutoAddContact(TCHAR * pchName, TCHAR * pchID);
    HRESULT InitNamedProps(void);
    HRESULT SetDefaultMsgrID(LPSBinary pSB, LPWSTR pchID);
    BOOL CheckEmailAddr(LPSBinary pSB, LPWSTR wszEmail);

    /////////////////////////////////////////////////////////////////////////
    // MAPI Utility Functions
    //
protected:
    void    _FreeProws(LPSRowSet prows);
    HRESULT	_MergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst);
    HRESULT _QueryAllRows(LPMAPITABLE ptable, LPSPropTagArray ptaga, 
                          LPSRestriction pres, LPSSortOrderSet psos,
	                      LONG crowsMax, LPSRowSet FAR *pprows);
    HRESULT _FillListFromTable(CContainedWindow& ctlList, LPSRowSet pSRowSet,
                               BOOL bLDAP = FALSE);
    HRESULT _GetWABTemplateID(ULONG ulObjectType, ULONG *lpcbEID, LPENTRYID *lppEID);
    HRESULT _AllocateBuffer(ULONG   cbSize, LPVOID FAR *lppBuffer);
    HRESULT _FreeBuffer(LPVOID lppBuffer);
    HRESULT _AllocateMore(ULONG   cbSize, LPVOID lpObject, LPVOID FAR *lppBuffer);

    /////////////////////////////////////////////////////////////////////////
    // LDAP Routines
    //

    typedef struct _SortInfo
    {
        BOOL bSortAscending;
        BOOL bSortByLastName;
    } SORT_INFO, *LPSORT_INFO;

    HRESULT _GetLDAPContainer(ULONG *pcbEntryID, LPENTRYID *ppEntryID);
    HRESULT _GetLDAPSearchRestriction(LPTSTR pszText, LPSRestriction lpSRes);
    HRESULT _GetLDAPContentsList(ULONG cbContainerEID, LPENTRYID pContainerEID, 
                                 SORT_INFO rSortInfo, LPSRestriction pPropRes, 
                                 CContainedWindow& ctlList);

// Private member data
private:

	// WAB Stuff
	LPWABOBJECT m_pWABObject;
    HINSTANCE	m_hInstWAB;
    LPADRBOOK	m_pAdrBook; 
    ULONG       m_ulConnection;
    // LPMAPISESSION m_pSession;

    CIEMsgAb * m_pAB;
};

void AddAccountsToList(HWND hDlg, int id, LPARAM lParam);

#endif  // __BADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\baprop.cpp ===
// baprop.cpp
// WAB & Messenger integration to OE
// Created 06/23/98 by YST
//
//////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include "msoert.h"
#include "hotlinks.h"
#include "shlwapi.h"
#include "badata.h"
#include "baprop.h"
#include "bllist.h"
#include "baui.h"
#include "shlwapip.h"
// #include "demand.h"
// #include "mailnews.h"
// #include "menuutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MAX_SUMMARY_ID  13
#define Msgr_Index      0

extern ULONG MsgrPropTags[];
extern ULONG PR_MSGR_DEF_ID;

// static WCHAR szDefault[CCHMAX_STRINGRES];  // TEXT(" (default)");
// static WCHAR szPending[CCHMAX_STRINGRES];  // TEXT(" (Pending...)");

const LPWSTR szDomainSeparator = L"@";
const LPWSTR szSMTP = L"SMTP";

#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)
static int nDefault = -1;
static HFONT hBold = NULL;
static HFONT hNormal = NULL;
static CMsgrList *s_pMsgrList = NULL;

static SizedSPropTagArray(1, pTagProp)=
{
    1,
    {
        PR_EMAIL_ADDRESS,
    }
};

///$$/////////////////////////////////////////////////////////////////////////
//
// AddCBEmailItem - Adds an email address to the personal tab list view
//
// lpszAddrType can be NULL in which case a default one of type SMTP will be used
//
//////////////////////////////////////////////////////////////////////////////
void AddCBEmailItem(HWND    hWndCB,
                    LPWSTR  lpwszEmailAddress,
                    BOOL    fDefault,
                    LPWSTR lpwszPendName)
{
    WCHAR szBuf[CCHMAX_STRINGRES];
    WCHAR szTmp[CCHMAX_STRINGRES];
    LV_ITEMW lvi = {0};
    UINT nSim = 0;
    int index = -1;

    if(lstrlenW(lpwszEmailAddress) < CCHMAX_STRINGRES)
        lstrcpyW(szTmp, lpwszEmailAddress);
    else
    {
        lstrcpynW(szTmp, lpwszEmailAddress, CCHMAX_STRINGRES - 2);
        szTmp[CCHMAX_STRINGRES - 1] = '\0';
    }

    // TCHAR *pch = StrStr(CharUpper(szTmp), szHotMail);
    // if(pch != NULL)
    nSim = lstrlenW(szTmp); //(UINT) (pch - szTmp + 1);

    Assert(nSim < CCHMAX_STRINGRES);

    if(nSim > 0)
    {
        if(nSim > ((UINT) (CCHMAX_STRINGRES /*- lstrlenW(szDefault)*/ - 2)))
        {
            nSim = CCHMAX_STRINGRES /*- lstrlenW(szDefault)*/ - 2;
            lstrcpynW(szBuf, lpwszEmailAddress, nSim);
            szBuf[nSim] = '\0';
        }
        else
            lstrcpyW(szBuf, szTmp);

        if(fDefault)
        {

            if(s_pMsgrList)
            {
#ifdef LATER
                if(s_pMsgrList->FindAndDeleteUser(lpwszEmailAddress, FALSE /*fDelete*/) == S_OK)
                    lstrcatW(szBuf, szDefault);
                else if(!lstrcmpiW(lpwszPendName, lpwszEmailAddress))
                    lstrcatW(szBuf, szPending);
#endif //LATER
            }

        }

        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvi.iImage = IMAGE_EMPTY;
        lvi.pszText = szBuf;
        lvi.cchTextMax = 256; //nSim;
        lvi.iItem = ListView_GetItemCount(hWndCB);
        lvi.iSubItem = 0;
        lvi.lParam = fDefault;

        index = ListView_InsertItem(hWndCB, &lvi);
        if(fDefault)
            nDefault = index;
    }
    return;
}

#ifdef LATER
const static HELPMAP g_rgCtxWabExt[] =
{
    {IDC_MSGR_ID_EDIT,              IDH_WAB_ONLINE_ADDNEW},
    {IDC_MSGR_ADD,                  IDH_WAB_ONLINE_ADD},
    {IDC_MSGR_BUTTON_SETDEFAULT,    IDH_WAB_ONLINE_SETAS},
    {IDC_SEND_INSTANT_MESSAGE,      IDH_WAB_ONLINE_SENDIM},
    {IDC_USER_NAME,                 IDH_WAB_ONLINE_LIST},
    {idcStatic1,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                    IDH_NEWS_COMM_GROUPBOX},
    {0,                             0}
};
#endif

INT_PTR CALLBACK WabExtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef LATER
    LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD dwError = 0;
    HIMAGELIST himl = NULL;

    switch (msg)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE * pps = (PROPSHEETPAGE *) lParam;
            LPWABEXTDISPLAY * lppWED = (LPWABEXTDISPLAY *) pps->lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
                // Add two columns to the listview
            LVCOLUMN lvc;
            RECT rc;
            HWND ctlList = GetDlgItem(hDlg, IDC_USER_NAME);

            s_pMsgrList = OE_OpenMsgrList();

            // one column
            lvc.mask = LVCF_FMT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.iSubItem = 0;

            GetWindowRect(ctlList,&rc);
            lvc.cx = rc.right - rc.left - 20; //TBD

            ListView_InsertColumn(ctlList, 0, &lvc);

            if(lppWED)
            {
                SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM)*lppWED);
                lpWED = *lppWED;
            }
            InitFonts();
            AthLoadString(idsBADefault, szDefault, ARRAYSIZE(szDefault));
            AthLoadString(idsBADispStatus, szPending, ARRAYSIZE(szPending));
            // ListView_SetExtendedListViewStyle(ctlList, LVS_EX_FULLROWSELECT);

            himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbAddrBookHot), 18, 0,
                               RGB(255, 0, 255), IMAGE_BITMAP,
                               LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);

            ListView_SetImageList(ctlList, himl, LVSIL_SMALL);

            AddAccountsToList(hDlg, lpWED);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),FALSE);
        }
        break;

    case WM_CONTEXTMENU:
    case WM_HELP:
        return OnContextHelp(hDlg, msg, wParam, lParam, g_rgCtxWabExt);
        break;

    case WM_COMMAND:
        {
            switch(HIWORD(wParam))		// Notification code
            {
            case EN_CHANGE:
                {
                    if(LOWORD(wParam) == IDC_MSGR_ID_EDIT)
                    {
                        if(GetWindowTextLength(GetDlgItem(hDlg, IDC_MSGR_ID_EDIT)) > 0)
                        {
                            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),TRUE);
                            SendMessage(GetParent(hDlg), DM_SETDEFID, IDC_MSGR_ADD, 0);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),FALSE);
                            SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
                        }
                    }
                    break;
                }
            }

            switch(LOWORD(wParam))		// commands
            {
            case IDC_MSGR_BUTTON_SETDEFAULT:
                SetAsDefault(hDlg, lpWED);
                break;

            case IDC_MSGR_ADD:
                AddMsgrId(hDlg, lpWED);
                break;

            case IDC_SEND_INSTANT_MESSAGE:
                WabSendIMsg(hDlg, lpWED);
                break;
            default:
                break;
            }
        }
        break;

    case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {

            case PSN_APPLY:
                ::SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, TRUE);
                DeleteFonts();
                if(s_pMsgrList)
                    OE_CloseMsgrList(s_pMsgrList);

                break;

            case PSN_SETACTIVE:
                ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_USER_NAME));
                AddAccountsToList(hDlg, lpWED);
                break;

            case PSN_KILLACTIVE:
                AddMsgrId(hDlg, lpWED);
                SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
                return 1;
                break;

            case PSN_RESET:
                SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
                DeleteFonts();
                if(s_pMsgrList)
                    OE_CloseMsgrList(s_pMsgrList);
                break;

            case LVN_ITEMCHANGED:
                {
                int nItem = ListView_GetNextItem(::GetDlgItem(hDlg, IDC_USER_NAME), -1, LVIS_SELECTED);
                if((nItem != nDefault) && (nItem > -1))
                    EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),TRUE);
                else
                    EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);

                if(WabIsItemOnline(hDlg, nItem))
                    EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
                else
                    EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
                }
                break;


            case NM_CUSTOMDRAW:
                switch(wParam)
                {
                case IDC_USER_NAME:
                    {
                        NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                        NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                        if(pnmcd->dwDrawStage==CDDS_PREPAINT)
                        {
                            SetLastError(0);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
                            dwError = GetLastError();
                            return TRUE;
                        }
                        else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
                        {
                            if(pnmcd->lItemlParam)
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, hBold);
                                SetLastError(0);
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                dwError = GetLastError();
                                return TRUE;
                            }
                            else
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, hNormal);
                                SetLastError(0);
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                dwError = GetLastError();
                                return TRUE;
                            }
                        }
                        SetLastError(0);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                        dwError = GetLastError();
                        return TRUE;
                    }
                    break;
                default:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                    break;
                }
                break;
            }
        }
        break;
    }
#endif
    return FALSE;	
}

void AddAccountsToList(HWND hDlg, LPWABEXTDISPLAY lpWED, LPWSTR lpwszPendName)
{
#ifdef LATER
    // LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLongPtr(hDlg, DWLP_USER);
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG i = 0;
    LPSPropValue lpPropEmail = NULL;
    LPSPropValue lpPropAddrType = NULL;
    LPSPropValue lpPropMVEmail = NULL;
    LPSPropValue lpPropMVAddrType = NULL;
    LPSPropValue lpPropDefaultIndex = NULL;
    LPSPropValue lpMsgrDevId = NULL;
    HWND ctlList = GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    Assert(PR_MSGR_DEF_ID);
    nDefault = -1;

    if(!lpWED)
    {
        Assert(FALSE);
        return;
    }

    if(!HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0,
        &ulcPropCount,
        &lpPropArray)))
    {
        if(ulcPropCount && lpPropArray)
        {
            for(i = 0; i < ulcPropCount; i++)
            {
                switch(lpPropArray[i].ulPropTag)
                {
                case PR_EMAIL_ADDRESS:
                    lpPropEmail = &(lpPropArray[i]);
                    break;
                case PR_ADDRTYPE:
                    lpPropAddrType = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_EMAIL_ADDRESSES:
                    lpPropMVEmail = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_ADDRTYPES:
                    lpPropMVAddrType = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                    lpPropDefaultIndex = &(lpPropArray[i]);
                    break;
                default:
                    if(lpPropArray[i].ulPropTag == PR_MSGR_DEF_ID)
                        lpMsgrDevId = &(lpPropArray[i]);
                    break;
                }
            }
            if(!lpPropEmail && !lpPropMVEmail)
                goto Error;

            if(lpPropMVEmail)
            {
                // we have a multiple emails
                //Assume, if this is present, so is MVAddrType, and defaultindex
                for(i = 0; i < lpPropMVEmail->Value.MVszW.cValues; i++)
                {
                    AddCBEmailItem(ctlList,
                                    lpPropMVEmail->Value.MVszW.lppszW[i],
                                    (lpMsgrDevId ?
                                    ((!lstrcmpiW(lpPropMVEmail->Value.MVszW.lppszW[i], lpMsgrDevId->Value.lpszW)) ? TRUE : FALSE) : FALSE), lpwszPendName);
                }
            }
            else
            {
                // we dont have multi-valued props yet - lets use the
                // single valued ones and tag a change so that the record is
                // updated ...
                AddCBEmailItem(ctlList,
                                    lpPropEmail->Value.lpszW,
                                    (lpMsgrDevId ?
                                    ((!lstrcmpiW(lpPropEmail->Value.lpszW, lpMsgrDevId->Value.lpszW)) ? TRUE : FALSE) : FALSE), lwpszPendName);
            }
        }
    }

Error:
    if(nDefault == -1)
    {
        if(ListView_GetItemCount(ctlList) > 0)            // We have as min 1 item
        {
            // Select default item
            ListView_SetItemState(ctlList, 0,
                        LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),TRUE);
            // Enable "SendInstant Message only when contact is Online
            if(WabIsItemOnline(hDlg, 0))
                EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
            else
                EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);
        }
    }
    else
    {
        // Select default item
        ListView_SetItemState(ctlList, nDefault,
                        LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);
            // Enable "SendInstant Message only when contact is Online
        if(WabIsItemOnline(hDlg, nDefault))
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
        else
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
    }

    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
#endif
    return;

}

// Set selected email address as default for Messenger
void SetAsDefault(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
#ifdef LATER
    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    TCHAR szName[CCHMAX_STRINGRES];
    Assert(ctlList);

    int iItem = ListView_GetNextItem(ctlList, -1, LVIS_SELECTED);
    if(iItem == -1)
        return;

    ListView_GetItemText(ctlList, iItem, 0,szName, CCHMAX_STRINGRES - 1);

    if(StrStr(CharUpper(szName), CharUpper(szDefault))) // already default
        return;

    SetDefaultID(szName, hDlg, lpWED);
#endif
}

// Add Messanger ID  to list
#define NOT_FOUND ((ULONG) -1)

void AddMsgrId(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
#ifdef LATER
    HWND hwndEdit = ::GetDlgItem(hDlg, IDC_MSGR_ID_EDIT);
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0;
    ULONG i = 0;

    ULONG nMVEmailAddress = NOT_FOUND, nMVAddrTypes = NOT_FOUND, nEmailAddress = NOT_FOUND;
    ULONG nAddrType = NOT_FOUND, nDefaultIndex = NOT_FOUND;
    TCHAR szName[CCHMAX_STRINGRES];
    HRESULT hr = S_OK;

    if(!::GetWindowText(hwndEdit, szName, CCHMAX_STRINGRES - 1))
        return;

    TCHAR *pch = NULL;
    if(!AsciiTrimSpaces(szName))
    {
        AthMessageBoxW(hDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsBAErrExtChars),
               NULL, MB_OK | MB_ICONSTOP);
        ::SetWindowText(hwndEdit, "");
        ::SetFocus(hwndEdit);
        return;
    }

    int nLen = lstrlen(szName);
    if(nLen <= 0)
        goto exi;

    nLen = lstrlen(szSMTP);
    if(nLen <= 0)
        goto exi;

    // Create a return prop array to pass back to the WAB
    if(HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0,
        &ulcPropCount,
        &lpPropArray)))
        return;

    if(ulcPropCount && lpPropArray)
    {
        for(i = 0; i < ulcPropCount; i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_EMAIL_ADDRESS:
                nEmailAddress = i;
                break;
            case PR_ADDRTYPE:
                nAddrType = i;
                break;
            case PR_CONTACT_EMAIL_ADDRESSES:
                nMVEmailAddress = i;
                break;
            case PR_CONTACT_ADDRTYPES:
                nMVAddrTypes = i;
                break;
            case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                nDefaultIndex = i;
                break;
            }
        }

        // if no e-mail address, just add the given prop as e-mail address and in mv e-mail addresses
        if(nEmailAddress == NOT_FOUND)
        {
            SPropValue spv[5];

            spv[0].ulPropTag = PR_EMAIL_ADDRESS;
            spv[0].Value.lpszW = szName;

            spv[1].ulPropTag = PR_ADDRTYPE;
            spv[1].Value.lpszW = szSMTP;

            spv[2].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
            spv[2].Value.MVszW.cValues = 1;
            spv[2].Value.MVszW.lppszW = (WCHAR **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));

            if(spv[2].Value.MVszW.lppszW)
                spv[2].Value.MVszW.lppszW[0] = szName;

            spv[3].ulPropTag = PR_CONTACT_ADDRTYPES;
            spv[3].Value.MVszW.cValues = 1;
            spv[3].Value.MVszW.lppszW = (WCHAR **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));

            if(spv[3].Value.MVszW.lppszW)
                spv[3].Value.MVszW.lppszW[0] = szSMTP;

            spv[4].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            spv[4].Value.l = 0;

            hr = lpWED->lpPropObj->SetProps(5, (LPSPropValue)&spv, NULL);

            if(spv[2].Value.MVszW.lppszW)
                LocalFree(spv[2].Value.MVszW.lppszW);
            if(spv[3].Value.MVszW.lppszW)
                LocalFree(spv[3].Value.MVszW.lppszW);

        }
        else if(nMVEmailAddress == NOT_FOUND)
        {
            // we have an e-mail address but no contact-email-addresses
            // so we will need to create the contact e-mail addresses
            SPropValue spv[3];

            spv[0].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
            spv[0].Value.MVszW.cValues = 2;
            spv[0].Value.MVszW.lppszW = (WCHAR **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);

            if(spv[0].Value.MVszW.lppszW)
            {
                spv[0].Value.MVszW.lppszW[0] = lpPropArray[nEmailAddress].Value.lpszW;
                spv[0].Value.MVszW.lppszW[1] = szName;
            }

            spv[1].ulPropTag = PR_CONTACT_ADDRTYPES;
            spv[1].Value.MVszW.cValues = 2;
            spv[1].Value.MVszW.lppszW = (WCHAR **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);

            if(spv[1].Value.MVszW.lppszW)
            {
                spv[1].Value.MVszW.lppszW[0] = (nAddrType == NOT_FOUND) ? (LPTSTR)szSMTP : lpPropArray[nAddrType].Value.lpszW;
                spv[1].Value.MVszW.lppszW[1] = szSMTP;
            }

            spv[2].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            spv[2].Value.l = 0;

            hr = lpWED->lpPropObj->SetProps(3, (LPSPropValue)&spv, NULL);

            if(spv[0].Value.MVszW.lppszW)
                LocalFree(spv[0].Value.MVszW.lppszW);

            if(spv[1].Value.MVszW.lppszW)
                LocalFree(spv[1].Value.MVszW.lppszW);
        }
        else
        {
            // tag on the new props to the end of the existing contact_address_types
            if(HR_FAILED(hr = AddPropToMVPString(lpWED, lpPropArray,ulcPropCount, nMVEmailAddress, szName)))
                goto exi;

            if(HR_FAILED(hr = AddPropToMVPString(lpWED, lpPropArray, ulcPropCount, nMVAddrTypes, szSMTP)))
                goto exi;

            hr = lpWED->lpPropObj->SetProps(ulcPropCount, lpPropArray, NULL);
        }

        // Set this new data on the object
        //
        if(SUCCEEDED(hr))
        {
            lpWED->fDataChanged = TRUE;
            if(nDefault == -1)
                SetDefaultID(szName, hDlg, lpWED);
            else
            {
                // just refresh list, which will add buddy.6
                ListView_DeleteAllItems(::GetDlgItem(hDlg, IDC_USER_NAME));
                AddAccountsToList(hDlg, lpWED);
            }
            ::SetWindowText(hwndEdit, "");
        }
    }
exi:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
#endif
}

    //Set default ID in WAB
void SetDefaultID(TCHAR *szName, HWND hDlg, LPWABEXTDISPLAY lpWED)
{
#ifdef LATER
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc = 0;

    if(s_pMsgrList)
    {
        s_pMsgrList->AddUser(szName); // Always ignore result
    }
    else
        return;

    // Create a return prop array to pass back to the WAB
    int nLen = lstrlen(szName);

    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(SPropValue),
        (LPVOID *)&lpPropArray);
    if (sc!=S_OK)
        goto out;

    if(nLen)
    {
        lpPropArray[Msgr_Index].ulPropTag = MsgrPropTags[Msgr_Index];
        sc = lpWED->lpWABObject->AllocateMore(nLen+1, lpPropArray,
            (LPVOID *)&(lpPropArray[Msgr_Index].Value.lpszW));

        if (sc!=S_OK)
            goto out;

        lstrcpy(lpPropArray[Msgr_Index].Value.lpszW, szName);
    }
    // Set this new data on the object
    //
    if(HR_FAILED(lpWED->lpPropObj->SetProps( 1, lpPropArray, NULL)))
        goto out;

    lpWED->fDataChanged = TRUE;
    ListView_DeleteAllItems(::GetDlgItem(hDlg, IDC_USER_NAME));
    AddAccountsToList(hDlg, lpWED, szName);

out:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
#endif
}


//$$//////////////////////////////////////////////////////////////////////////////
//
//  TrimSpaces - strips a string of leading and trailing blanks
//
//  szBuf - pointer to buffer containing the string we want to strip spaces off.
//  Also, check that characters are ASCII
//
////////////////////////////////////////////////////////////////////////////////
BOOL AsciiTrimSpaces(TCHAR * szBuf)
{
    register LPTSTR lpTemp = szBuf;

    if(!szBuf || !lstrlen(szBuf))
        return FALSE;

    // Trim leading spaces
    while (IEIsSpace(lpTemp)) {
        lpTemp = CharNext(lpTemp);
    }

    if (lpTemp != szBuf) {
        // Leading spaces to trim
        lstrcpy(szBuf, lpTemp);
        lpTemp = szBuf;
    }

    if (*lpTemp == '\0') {
        // empty string
        return(TRUE);
    }

    // Move to the end
    lpTemp += lstrlen(lpTemp);
    lpTemp--;

    // Walk backwards, triming spaces
    while (IEIsSpace(lpTemp) && lpTemp > szBuf) {
        *lpTemp = '\0';
        lpTemp = CharPrev(szBuf, lpTemp);
    }

   lpTemp = szBuf;

    while (*lpTemp)
    {
        // Internet addresses only allow pure ASCII.  No high bits!
        if (*lpTemp & 0x80)
           return(FALSE);
        lpTemp++;
    }

    return(TRUE);
}

/***************************************************************************

    Name      : AddPropToMVPString

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpszNew -> new data string

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array lpszW to the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPString(
  LPWABEXTDISPLAY lpWED,
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPWSTR lpszNew) {

#ifdef UNICODE
    SWStringArray UNALIGNED * lprgszOld = NULL; // old SString array
#else
    SWStringArray UNALIGNED * lprgszOld = NULL; // old SString array
#endif
    LPWSTR  *lppszNew = NULL;           // new prop array
    LPWSTR  *lppszOld = NULL;           // old prop array
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;
    ULONG cbNew;

    if (lpszNew) {
        cbNew = lstrlenW(lpszNew) + 1;
    } else {
        cbNew = 0;
    }

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_TSTRING, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgszOld = &(lpaProps[index].Value.MVszW);
        lppszOld = lprgszOld->lppszW;

        cExisting = lprgszOld->cValues;
        cbMVP = cExisting * sizeof(LPTSTR);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(LPWSTR);    // room in the MVP for another string pointer


    // Allocate room for new MVP array
    if (sc = lpWED->lpWABObject->AllocateMore(cbMVP, lpaProps, (LPVOID *)&lppszNew)) {
        DebugTrace("AddPropToMVPString allocation (%u) failed %x\n", cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lppszNew[i] = lppszOld[i];
    }

    // Add the new property value
    // Allocate room for it
    if (cbNew) {
        if (sc = lpWED->lpWABObject->AllocateMore(cbNew, lpaProps, (LPVOID *)&(lppszNew[i]))) {
            DebugTrace("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc);
            hResult = ResultFromScode(sc);
            return(hResult);
        }
        lstrcpyW(lppszNew[i], lpszNew);

        lpaProps[index].Value.MVszW.lppszW= lppszNew;
        lpaProps[index].Value.MVszW.cValues = cExisting + 1;

    } else {
        lppszNew[i] = NULL;
    }

    return(hResult);
}

// this function check if selected item is online
BOOL WabIsItemOnline(HWND hDlg, int nItem)
{
#ifdef LATER
    TCHAR szName[CCHMAX_STRINGRES];
    TCHAR *pch = NULL;

    if(nItem < 0)
        return(FALSE);

    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    ListView_GetItemText(ctlList, nItem, 0,szName, CCHMAX_STRINGRES - 1);

    // Remove "(default)"
    pch = StrStr(szName, szDefault);
    if(pch != NULL)
        szName[pch - szName] = '\0';

    if(s_pMsgrList)
    {
        return(s_pMsgrList->IsContactOnline(szName, s_pMsgrList->GetFirstMsgrItem()));
    }
#endif
    return(FALSE);
}

// Send instant message to selected item
void WabSendIMsg(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
#ifdef LATER
    TCHAR szName[CCHMAX_STRINGRES];
    TCHAR *pch = NULL;

    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    int iItem = ListView_GetNextItem(ctlList, -1, LVIS_SELECTED);
    if(iItem == -1)
        return;

    ListView_GetItemText(ctlList, iItem, 0,szName, CCHMAX_STRINGRES - 1);

    // Remove "(default)"

    pch = StrStr(szName, szDefault);
    if(pch != NULL)
        szName[pch - szName] = '\0';

    if(s_pMsgrList)
    {
        s_pMsgrList->SendInstMessage(szName);
    }
#endif
}

BOOL InitFonts(void)
{
    LOGFONT lf;

    // Create the font
    if(SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
    {
        if(!hNormal)
            hNormal = CreateFontIndirect(&lf);
        lf.lfWeight = (lf.lfWeight < 700) ? 700 : 1000;
        if(!hBold)
            hBold = CreateFontIndirect(&lf);

    }
    return(TRUE);
}

void DeleteFonts(void)
{
    if(hNormal)
    {
        DeleteObject(hNormal);
        hNormal = NULL;
    }
    if(hBold)
    {
        DeleteObject(hBold);
        hBold = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\gwnote\resource.h ===
//
// resource.h
//
// contains global resource identifiers
//

#ifndef __RESOURCE_H_
#define __RESOURCE_H_

#define RT_FILE                         2110

/////////////////////////////////////////////////////////////////////////////
//
//  * * * RESOURCE NAMING CONVENTIONS * * *
//
/////////////////////////////////////////////////////////////////////////////
//
//  Resource Type       Prefix      Comments
//  -------------       ------      --------
//
//  String              ids         menu help strings should end in MH
//  Menu command        idm
//  Menu resource       idmr
//  Bitmap              idb
//  Icon                idi
//  Animation           idan
//  Dialog              idd
//  Dialog control      idc
//  Cursor              idcur
//  Raw RCDATA          idr
//  Accelerator         idac
//  Window              idw
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN String Resource IDs
//
// MENU HELP strings
#define MH_BASE                         1
#define idsNewMsgMH                     (idmNewMsg + MH_BASE)
#define idsNewMsg2MH                    (idmNewMsg2 + MH_BASE)
#define idsNewContactMH                 (idmNewContact + MH_BASE)
#define idsHelpAboutMH                  (idmHelpAbout + MH_BASE)
#define idsPrintMH                      (idmPrint + MH_BASE)
#define idsCompactAllMH                 (idmCompactAll + MH_BASE)
#define idsSpellingMH                   (idmSpelling + MH_BASE)
#define idsOpenMH                       (idmOpen + MH_BASE)
#define idsSaveAsMH                     (idmSaveAs + MH_BASE)
#define idsSaveAttachMH                 (idmSaveAttach + MH_BASE)
#define idsSubscribeNewsMH              (idmSubscribeNews + MH_BASE)
#define idsSubscribeGroupMH             (idmSubscribeGroup + MH_BASE)
#define idsConnectMH                    (idmConnect + MH_BASE)
#define idsPropertiesMH                 (idmProperties + MH_BASE)
#define idsUndoMH                       (idmUndo + MH_BASE)
#define idsCutMH                        (idmCut + MH_BASE)
#define idsCopyMH                       (idmCopy + MH_BASE)
#define idsPasteMH                      (idmPaste + MH_BASE)
#define idsSelectAllMH                  (idmSelectAll + MH_BASE)
#define idsMarkReadMH                   (idmMarkRead + MH_BASE)
#define idsMarkTopicReadMH              (idmMarkTopicRead + MH_BASE)
#define idsMarkAllReadMH                (idmMarkAllRead + MH_BASE)
#define idsMarkDownloadMH               (idmMarkDownload + MH_BASE)
#define idsMarkTopicDownloadMH          (idmMarkTopicDownload + MH_BASE)
#define idsFindMH                       (idmFind + MH_BASE)
#define idsFindNextMH                   (idmFindNext + MH_BASE)
#define idsViewDecryptMH                (idmViewDecrypt + MH_BASE)
#define idsColumnsMH                    (idmColumns + MH_BASE)
#define idsNextMH                       (idmNext + MH_BASE)
#define idsPreviousMH                   (idmPrevious + MH_BASE)
#define idsNewArticleMH                 (idmNewArticle + MH_BASE)
#define idsNewArticle2MH                (idmNewArticle2 + MH_BASE)
#define idsReplyPostMH                  (idmReplyPost + MH_BASE)
#define idsReplyMailMH                  (idmReplyMail + MH_BASE)
#define idsForwardMH                    (idmForward + MH_BASE)
#define idsGetNextHeadersMH             (idmGetNextHeaders + MH_BASE)
#define idsHelpTopicsMH                 (idmHelpTopics + MH_BASE)
#define idsGotoNewsgroupMH              (idmGotoNewsgroup + MH_BASE)
#define idsViewContactsMH               (idmViewContacts + MH_BASE)
#define idsPopupOfflineMH               (idmPopupOffline + MH_BASE)
#define idsPopupArrangeMH               (idmPopupArrange + MH_BASE)
#define idsFindTextMH                   (idmFindText + MH_BASE)
#define idsReplyMH                      (idmReply + MH_BASE)
#define idsReplyAllMH                   (idmReplyAll + MH_BASE)
#define idsGotoInboxMH                  (idmGotoInbox + MH_BASE)
#define idsDeliverMailMH                (idmDeliverMail + MH_BASE)
#define idsMoveToMH                     (idmMoveTo + MH_BASE)
#define idsCopyToMH                     (idmCopyTo + MH_BASE)
#define idsFldrCreateMH                 (idmFldrCreate + MH_BASE)
#define idsFldrCreate2MH                (idmFldrCreate2 + MH_BASE)
#define idsFldrRenameMH                 (idmFldrRename + MH_BASE)
#define idsFldrEmptyMH                  (idmFldrEmpty + MH_BASE)
#define idsDeleteMH                     (idmDelete + MH_BASE)
#define idsPopupImportMH                (idmPopupImport + MH_BASE)
#define idsPopupExportMH                (idmPopupExport + MH_BASE)
#define idsImportAddressBookMH          (idmImportAddressBook + MH_BASE)
#define idsImportMessagesMH             (idmImportMessages + MH_BASE)
#define idsImportAcctsMH                (idmImportAccts + MH_BASE)
#define idsExportAddressBookMH          (idmExportAddressBook + MH_BASE)
#define idsExportMessagesMH             (idmExportMessages + MH_BASE)
#define idsMarkUnreadMH                 (idmMarkUnread + MH_BASE)
#define idsPopupPreviewMH               (idmPopupPreview + MH_BASE)
#define idsThreadArticlesMH             (idmThreadArticles + MH_BASE)
#define idsViewAllArticlesMH            (idmViewAllArticles + MH_BASE)
#define idsViewUnreadArticlesMH         (idmViewUnreadArticles + MH_BASE)
#define idsCombineAndDecodeMH           (idmCombineAndDecode + MH_BASE)
#define idsViewNewGroupsMH              (idmViewNewGroups + MH_BASE)
#define idsPrintNowMH                   (idmPrintNow + MH_BASE)
#define idsForwardMsgAttachMH           (idmForwardMsgAttach + MH_BASE)
#define idsSortToggleMH                 (idmSortToggle + MH_BASE)
#define idsFldrCompactMH                (idmFldrCompact + MH_BASE)
#define idsExpandThreadMH               (idmExpandThread + MH_BASE)
#define idsCollapseThreadMH             (idmCollapseThread + MH_BASE)
#define idsCancelArticleMH              (idmCancelArticle + MH_BASE)
#define idsAddToWABMH                   (idmAddrObj_AddToWAB + MH_BASE)
#define idsReadmeMH                     (idmReadme + MH_BASE)
#define idsLanguagePopupMH              (idmLanguagePopup + MH_BASE)
#define idsCleanUpFilesMH               (idmCleanUpFiles + MH_BASE)
#define idsCustomizeToolbarMH           (idmCustomizeToolbar + MH_BASE)
#define idsInboxRulesMH                 (idmInboxRules + MH_BASE)
#define idsPostAndDownloadMH            (idmPostAndDownload + MH_BASE)
#define idsSaveMessageMH                (idmSaveMessage + MH_BASE)     
#define idsMarkNewsgroupsMH             (idmMarkNewsgroups + MH_BASE)
#define idsMarkAllDownloadMH            (idmMarkAllDownload + MH_BASE)
#define idsUnmarkMH                     (idmUnmark + MH_BASE)
#define idsReplyPostAndMailMH           (idmReplyPostAndMail + MH_BASE)
#define idsDisconnectMH                 (idmDisconnect + MH_BASE)
#define idsHelpMSWebMH                  (idmHelpMSWeb + MH_BASE)
#define idsViewNewsMH                   (idmViewNews + MH_BASE)
#define idsViewMailMH                   (idmViewMail + MH_BASE)
#define idsBrowseWebMH                  (idmBrowseWeb + MH_BASE)
#define idsStopMH                       (idmStop + MH_BASE)
#define idsViewTipOfTheDayMH            (idmViewTipOfTheDay + MH_BASE)
#define idsViewRefreshMH                (idmViewRefresh + MH_BASE)
#define idsUnDeleteMH                   (idmUnDelete + MH_BASE)
#define idsExpungeMH                    (idmExpunge + MH_BASE)
#define idsViewDeletedArticlesMH        (idmViewDeletedArticles + MH_BASE)
#define idsFoldersMH                    (idmFolders + MH_BASE)
#define idsSubscribeFolderMH            (idmSubscribeFolder + MH_BASE)
#define idsDownloadAttachMH             (idmDownloadAttach + MH_BASE)
#define idsViewFilteredArticlesMH       (idmViewFilteredArticles + MH_BASE)
//#define idsDigSignMH                    (idmDigSign + MH_BASE)
//#define idsEncryptMH                    (idmEncrypt + MH_BASE)
#define idsSaveAttachAllMH              (idmSaveAttachAll + MH_BASE)
#define idsRefreshFoldersMH             (idmRefreshFolders + MH_BASE)
#define idsSpoolerWarningsMH            (idmSpoolerWarnings + MH_BASE)
#define idsSpoolerShowMH                (idmSpoolerShow + MH_BASE)

// TOOLTIP strings
#define TT_BASE                         (IDM_LAST + MH_BASE + 1)
#define idsNewMsg                       (idmNewMsg + TT_BASE)
#define idsNewContactTT                 (idmNewContact + TT_BASE)
#define idsPrint                        (idmPrint + TT_BASE)
#define idsNextUnreadNewsgroup          (idmNextUnreadNewsgroup + TT_BASE)
#define idsNextUnreadArticle            (idmNextUnreadArticle + TT_BASE)
#define idsNextUnreadTopic              (idmNextUnreadThread + TT_BASE)
#define idsMarkRead                     (idmMarkRead + TT_BASE)
#define idsConnect                      (idmConnect + TT_BASE)
#define idsMarkDownload                 (idmMarkDownload + TT_BASE)
#define idsFind                         (idmFind + TT_BASE)
#define idsSpellingTT                   (idmSpelling + TT_BASE)
#define idsNewArticleTT                 (idmNewArticle + TT_BASE)
#define idsReplyPostTT                  (idmReplyPost + TT_BASE)
#define idsReplyMailTT                  (idmReplyMail + TT_BASE)
#define idsForwardTT                    (idmForward + TT_BASE)
#define idsPrintNowTT                   (idmPrintNow + TT_BASE)
#define idsReplyTT                      (idmReply + TT_BASE)
#define idsReplyAllTT                   (idmReplyAll + TT_BASE)
#define idsGotoInboxTT                  (idmGotoInbox + TT_BASE)
#define idsDeliverMailTT                (idmDeliverMail + TT_BASE)
#define idsUndoTT                       (idmUndo + TT_BASE)
#define idsDeleteTT                     (idmDelete + TT_BASE)
#define idsSendMsgTT                    (idmSendMsg + TT_BASE)
#define idsSaveTT                       (idmSave + TT_BASE)
#define idsCutTT                        (idmCut + TT_BASE)
#define idsCopyTT                       (idmCopy + TT_BASE)
#define idsPasteTT                      (idmPaste + TT_BASE)
#define idsCheckNamesTT                 (idmCheckNames + TT_BASE)
#define idsPickRecipientsTT             (idmPickRecipients + TT_BASE)
#define idsInsertFileTT                 (idmInsertFile + TT_BASE)
#define idsPreviousTT                   (idmPrevious + TT_BASE)
#define idsNextTT                       (idmNext + TT_BASE)
#define idsFindTextTT                   (idmFindText + TT_BASE)
#define idsFmtSizeTT                    (idmFmtSize + TT_BASE)
#define idsFmtColorTT                   (idmFmtColor + TT_BASE)
#define idsFmtBoldTT                    (idmFmtBold + TT_BASE)
#define idsFmtItalicTT                  (idmFmtItalic + TT_BASE)
#define idsFmtUnderlineTT               (idmFmtUnderline + TT_BASE)
#define idsFmtBulletsTT                 (idmFmtBullets + TT_BASE)
#define idsFmtDecreaseIndentTT          (idmFmtDecreaseIndent + TT_BASE)
#define idsFmtIncreaseIndentTT          (idmFmtIncreaseIndent + TT_BASE)
#define idsFmtLeftTT                    (idmFmtLeft + TT_BASE)
#define idsFmtCenterTT                  (idmFmtCenter + TT_BASE)
#define idsFmtRightTT                   (idmFmtRight + TT_BASE)
#define idsPostMsgTT                    (idmPostMsg + TT_BASE)
#define idsMarkAllReadTT                (idmMarkAllRead + TT_BASE)
#define idsMarkTopicReadTT              (idmMarkTopicRead + TT_BASE)
#define idsMarkTopicDownloadTT          (idmMarkTopicDownload + TT_BASE)
#define idsInsertSigTT                  (idmInsertSig + TT_BASE)
#define idsViewContactsTT               (idmViewContacts + TT_BASE)
#define idsSaveAsTT                     (idmSaveAs + TT_BASE)
#define idsUnDeleteTT                   (idmUnDelete + TT_BASE)
#define idsExpungeTT                    (idmExpunge + TT_BASE)
#define idsViewDeletedArticlesTT        (idmViewDeletedArticles + TT_BASE)
#define idsFoldersTT                    (idmFolders + TT_BASE)
#define idsSubscribeFolderTT            (idmSubscribeFolder + TT_BASE)
#define idsDownloadAttachTT             (idmDownloadAttach + TT_BASE)
#define idsDigSignTT                    (idmDigSign + TT_BASE)
#define idsEncryptTT                    (idmEncrypt + TT_BASE)
#define idsLanguage                     (idmLangFirst + TT_BASE)
#define idsFolderListTT                 (idmViewFolders + TT_BASE)
#define idsSpoolerWarningsTT            (idmSpoolerWarnings + TT_BASE)
#define idsSpoolerShowTT                (idmSpoolerShow + TT_BASE)
#define idsDownloadAccountTT            (idmSyncAccount + TT_BASE)
#define idsDownloadNewsgroupTT          (idmSyncSelected + TT_BASE)
#define idsPostDefaultTT                (idmPostDefault + TT_BASE)
#define idsSendDefaultTT                (idmSendDefault + TT_BASE)
#define idsViewRefreshTT                (idmViewRefresh + TT_BASE)
#define idsPurgeTT                      (idmExpunge + TT_BASE)

// regular strings (not tooltips and not menu help strings)
#define STR_FIRST                       (IDM_LAST + TT_BASE + 1)
#define idsAthena                       (STR_FIRST + 8)
#define idsAthenaMail                   idsAthena
#define idsAthenaNews                   idsAthena
#define idsNlogErrConnClosed            (STR_FIRST + 10)
#define idsNlogIConnect                 (STR_FIRST + 11)
#define idsNlogErrConnError             (STR_FIRST + 12)
#define idsTo                           (STR_FIRST + 13)
#define idsFrom                         (STR_FIRST + 14)
#define idsSubject                      (STR_FIRST + 15)
#define idsReceived                     (STR_FIRST + 16)
#define idsSent                         (STR_FIRST + 17)
#define idsSize                         (STR_FIRST + 18)

// keep the mailview column description string ids in sequence
#define idsFromField                    (STR_FIRST + 21)
#define idsToField                      (STR_FIRST + 22)
#define idsCcField                      (STR_FIRST + 23)
#define idsSubjectField                 (STR_FIRST + 24)
#define idsTTFormattingFont             (STR_FIRST + 25)
#define idsTTFormattingSize             (STR_FIRST + 27)
#define idsAutoColor                    (STR_FIRST + 31)
#define idsColor1                       (STR_FIRST + 32)
#define idsColor2                       (STR_FIRST + 33)
#define idsColor3                       (STR_FIRST + 34)
#define idsColor4                       (STR_FIRST + 35)
#define idsColor5                       (STR_FIRST + 36)
#define idsColor6                       (STR_FIRST + 37)
#define idsColor7                       (STR_FIRST + 38)
#define idsColor8                       (STR_FIRST + 39)
#define idsColor9                       (STR_FIRST + 40)
#define idsColor10                      (STR_FIRST + 41)
#define idsColor11                      (STR_FIRST + 42)
#define idsColor12                      (STR_FIRST + 43)
#define idsColor13                      (STR_FIRST + 44)
#define idsColor14                      (STR_FIRST + 45)
#define idsColor15                      (STR_FIRST + 46)
#define idsColor16                      (STR_FIRST + 47)
#define idsSmapiClose                   (STR_FIRST + 48)
#define idsHideHotmailMenu              (STR_FIRST + 49)
#define idsNewsgroups                   (STR_FIRST + 52)
#define idsDescription                  (STR_FIRST + 53)
#define idsEmptyTo                      (STR_FIRST + 60)
#define idsEmptyCc                      (STR_FIRST + 61)
#define idsEmptySubject                 (STR_FIRST + 62)
#define idsNoCcOrTo                     (STR_FIRST + 63)
#define idsNoSubject                    (STR_FIRST + 64)
#define idsTTTo                         (STR_FIRST + 65)
#define idsTTCc                         (STR_FIRST + 66)
#define idsTTSubject                    (STR_FIRST + 67)
#define idsTTRecipients                 (STR_FIRST + 68)
#define idsTTStampForSendnote           (STR_FIRST + 69)
#define idsSaveChangesMsg               (STR_FIRST + 71)
#define idsCantSaveMsg                  (STR_FIRST + 72)
#define idsCantDeleteMsg                (STR_FIRST + 73)
#define idsNewsgroupsField              (STR_FIRST + 81)
#define idsEmptyNewsgroups              (STR_FIRST + 82)
#define idsDateField                    (STR_FIRST + 83)
#define idsErrInvalidGroup              (STR_FIRST + 84)
#define idsWantToSubscribe              (STR_FIRST + 85)
#define idsWantToUnSubscribe            (STR_FIRST + 89)
#define idsUnsubscribeMenu              (STR_FIRST + 90)
#define idsSubscribeMenu                (STR_FIRST + 91)
#define idsErrNewsCantReply             (STR_FIRST + 92)
#define idsHTMLErrNewsCantOpen          (STR_FIRST + 93)
#define idsErrAttmanLoadFail            (STR_FIRST + 94)

#define idsSaveAttachmentAs             (STR_FIRST + 97)
#define idsNoFromField                  (STR_FIRST + 102)
#define idsTTNewsgroups                 (STR_FIRST + 103)
#define idsDownloadArtTitle             (STR_FIRST + 104)
#define idsDownloadArtMsg               (STR_FIRST + 105)
#define idsErrNoPoster                  (STR_FIRST + 106)
#define idsDownloadingGroups            (STR_FIRST + 110)
#define idsSortingGroups                (STR_FIRST + 111)
#define idsDownloadingDesc              (STR_FIRST + 112)
#define idsWritingFile                  (STR_FIRST + 113)
#define idsUnknown                      (STR_FIRST + 114)
#define idsNewsLogon                    (STR_FIRST + 116)
#define idsShowDetails                  (STR_FIRST + 117)
#define idsHideDetails                  (STR_FIRST + 118)
#define idsFilterAttSave                (STR_FIRST + 129)
#define idsCompose                      (STR_FIRST + 139)
#define idsPostReply                    (STR_FIRST + 140)
#define idsMailReply                    (STR_FIRST + 141)
#define idsForward                      (STR_FIRST + 142)
#define idsReply                        (STR_FIRST + 144)
#define idsReplyAll                     (STR_FIRST + 145)
#define idsDefMailExt                   (STR_FIRST + 148)
#define idsDefNewsExt                   (STR_FIRST + 149)
#define idsNewsSaveAsTitle              (STR_FIRST + 150)
#define idsMailSaveAsTitle              (STR_FIRST + 151)
#define idsUnableToSaveMessage          (STR_FIRST + 152)

#define idsDownloadingHeaders           (STR_FIRST + 172)
#define idsDownloadingArticle           (STR_FIRST + 173)
#define idsNewsStatus                   (STR_FIRST + 174)
#define idsErrPeerClosed                (STR_FIRST + 179)
#define idsErrAuthenticate              (STR_FIRST + 193)

// Options Spelling dialog strings
#define idsSpellClose                   (STR_FIRST + 201)
#define idsSpellCaption                 (STR_FIRST + 202)
#define idsSpellRepeatWord              (STR_FIRST + 203)
#define idsSpellWordNeedsCap            (STR_FIRST + 204)
#define idsSpellWordNotFound            (STR_FIRST + 205)
#define idsSpellNoSuggestions           (STR_FIRST + 206)
#define idsSpellDelete                  (STR_FIRST + 207)
#define idsSpellDeleteAll               (STR_FIRST + 208)
#define idsSpellChange                  (STR_FIRST + 209)
#define idsSpellChangeAll               (STR_FIRST + 210)
#define idsSpellMsgDone                 (STR_FIRST + 212)
#define idsSpellMsgContinue             (STR_FIRST + 213)
#define idsSpellMsgConfirm              (STR_FIRST + 214)
#define idsSpellMsgSendOK               (STR_FIRST + 215)

#define idsErrSpellGenericSpell         (STR_FIRST + 221)
#define idsErrSpellGenericLoad          (STR_FIRST + 222)
#define idsErrSpellMainDictLoad         (STR_FIRST + 223)
#define idsErrSpellVersion              (STR_FIRST + 224)
#define idsErrSpellUserDictLoad         (STR_FIRST + 226)
#define idsErrSpellUserDictOpenRO       (STR_FIRST + 227)
#define idsErrSpellCacheWordLen         (STR_FIRST + 230)
#define idsPrefixReply                  (STR_FIRST + 231)
#define idsPrefixForward                (STR_FIRST + 232)
#define idsErrCannotOpenMailMsg         (STR_FIRST + 233)
#define idsErrSpellLangChanged          (STR_FIRST + 234)
#define idsErrSpellWarnDictionary       (STR_FIRST + 235)

#ifdef  WIN16   // Because Win16 don't have long file name support!!!
#define idsInboxFile                    (STR_FIRST + 236)
#define idsOutboxFile                   (STR_FIRST + 237)
#define idsSentItemsFile                (STR_FIRST + 238)
#define idsDeletedItemsFile             (STR_FIRST + 239)
#define idsDraftFile                    (STR_FIRST + 240)
#define idsNewsOutboxFile               (STR_FIRST + 241)
#endif

// keep this contiguous please, or i'll kill you
#define idsInbox                        (STR_FIRST + 242)
#define idsOutbox                       (STR_FIRST + 243)
#define idsSentItems                    (STR_FIRST + 244)
#define idsDeletedItems                 (STR_FIRST + 245)
#define idsDraft                        (STR_FIRST + 246)
#define idsSharedInbox                  (STR_FIRST + 247)
// keep this contiguous please, or i'll kill you

#define idsAllFilesFilter               (STR_FIRST + 248)
#define idsTextFileFilter               (STR_FIRST + 249)
#define idsLinkExtension                (STR_FIRST + 251)
#define idsAttach                       (STR_FIRST + 252)
#define idsInsertAttachment             (STR_FIRST + 253)
#define idsOverwriteFile                (STR_FIRST + 254)
#define idsDropLinkDirs                 (STR_FIRST + 255)
#define idsAttConfirmDeletion           (STR_FIRST + 256)
#define idsTextOrHtmlFileFilter         (STR_FIRST + 257)

// leave a little space for addrview stuff...
// end addrview strings

#define idsErrCreateNewFld              (STR_FIRST + 259)
#define idsErrRenameFld                 (STR_FIRST + 260)
#define idsErrDeleteFld                 (STR_FIRST + 261)
#define idsWarnDeleteFolder             (STR_FIRST + 262)
#define idsErrRenameSpecialFld          (STR_FIRST + 263)
#define idsErrFolderNameConflict        (STR_FIRST + 264)
#define idsErrBadFolderName             (STR_FIRST + 265)
#define idsErrDeleteSpecialFolder       (STR_FIRST + 266)
#define idsWarnEmptyDeletedItems        (STR_FIRST + 267)
#define idsWarnPermDelete               (STR_FIRST + 268)
#define idsWarnPermDeleteSome           (STR_FIRST + 269)
#define idsErrStartupFailed             (STR_FIRST + 270)
#define idsDoYouWantToSave              (STR_FIRST + 274)
#define idsXMsgsYUnread                 (STR_FIRST + 277)
#define idsXMsgs                        (STR_FIRST + 278)
#define idsErrNoRecipients              (STR_FIRST + 299)

#define idsPropPageSecurity             (STR_FIRST + 301)
#define idsPropPageGeneral              (STR_FIRST + 302)
#define idsPropPageDetails              (STR_FIRST + 303)
#define idsErrReplyForward              (STR_FIRST + 304)
#define idsShowFavorites                (STR_FIRST + 310)
#define idsNewArticleTitle              (STR_FIRST + 311)
#define idsAttDefaultName               (STR_FIRST + 313)
#define idsErrNoGroupsFound             (STR_FIRST + 314)
#define idsErrCantResolveGroup          (STR_FIRST + 315)
#define idsEmptySubjectRO               (STR_FIRST + 316)
#define idsReplyTextPrefix              (STR_FIRST + 318)
#define idsMailRundllFailed             (STR_FIRST + 319)
#define idsNewsRundllFailed             (STR_FIRST + 320)
#define idsRecipient                    (STR_FIRST + 322)
#define idsWarnMultipleOpens            (STR_FIRST + 323)
#define idsNoNewGroupsAvail             (STR_FIRST + 328)
#define idsNewGroups                    (STR_FIRST + 329)
#define idsDllExpired                   (STR_FIRST + 332)
#define idsErrNoSubject                 (STR_FIRST + 333)
#define idsEmlFileFilter                (STR_FIRST + 334)
#define idsNwsFileFilter                (STR_FIRST + 335)
#define idsBase64                       (STR_FIRST + 338)
#define idsQuotedPrintable              (STR_FIRST + 339)
#define idsEnterPollTime                (STR_FIRST + 342)
#define idsEnterSigText                 (STR_FIRST + 345)
#define idsEnterSigFile                 (STR_FIRST + 346)
#define idsOptions                      (STR_FIRST + 347)
#define idsWarnSigTruncated             (STR_FIRST + 348)
#define idsWarnSigNotFound              (STR_FIRST + 350)
#define idsWarnSigBinary                (STR_FIRST + 351)
#define idsDLChecking                   (STR_FIRST + 352)
#define idsWarnUnsentMail               (STR_FIRST + 355)
#define idsErrRemoveServer              (STR_FIRST + 358)
#define idsEnterPreviewTime             (STR_FIRST + 361)
#define idsEnterDownloadChunks          (STR_FIRST + 362)
#define idsSBSending                    (STR_FIRST + 367)
#define idsSBReceiving                  (STR_FIRST + 368)
#define idsSBConnecting                 (STR_FIRST + 369)
#define idsSBNoNewMsgs                  (STR_FIRST + 370)
#define idsSBNewMsgsControl             (STR_FIRST + 371)
#define idsSBChecking                   (STR_FIRST + 372)
#define idsPropAttachNone               (STR_FIRST + 373)
#define idsUnderComp                    (STR_FIRST + 375)
#define idsSortAsc                      (STR_FIRST + 376)
#define idsSortMenuHelpControl          (STR_FIRST + 377)
#define idsReplyTextAppend              (STR_FIRST + 378)
#define idsErrPreviewLoadFail           (STR_FIRST + 379)
#define idsCharsetMapChange             (STR_FIRST + 380)

#define idsDisplayFavoritesDlg          (STR_FIRST + 383)
#define idsNoNewsgroupParen             (STR_FIRST + 384)
#define idsNewsStatusNoServer           (STR_FIRST + 385)
#define idsNone                         (STR_FIRST + 387)
#define idsAuthorizing                  (STR_FIRST + 389)
#define idsPropNoSubject                (STR_FIRST + 390)
#define idsErrNoMailInstalled           (STR_FIRST + 394)
#define idsErrCantCompactFolder         (STR_FIRST + 395)
#define idsErrCantCompactInUse          (STR_FIRST + 396)
#define idsCompactStore                 (STR_FIRST + 397)
#define idsRenameFolderTitle            (STR_FIRST + 398)
#define idsTabSubscribed                (STR_FIRST + 399)
#define idsTabAll                       (STR_FIRST + 400)
#define idsTabNew                       (STR_FIRST + 401)
#define idsFile                         (STR_FIRST + 402)
#define idsVersion                      (STR_FIRST + 403)
#define idsFollowupToField              (STR_FIRST + 404)
#define idsReplyToField                 (STR_FIRST + 405)
#define idsOrgField                     (STR_FIRST + 406)
#define idsDistributionField            (STR_FIRST + 407)
#define idsKeywordsField                (STR_FIRST + 408) 
#define idsApprovedField                (STR_FIRST + 409)

// Address Book Strings
#define idsPickNamesTitle               (STR_FIRST + 410)
#define idsGeneralWabError              (STR_FIRST + 412)

#define idsStartupError                 (STR_FIRST + 413)
#define idsEmptyFollowupTo              (STR_FIRST + 415)
#define idsEmptyDistribution            (STR_FIRST + 416)
#define idsEmptyKeywords                (STR_FIRST + 417)
#define idsEmptyReplyTo                 (STR_FIRST + 418)
#define idsNotSpecified                 (STR_FIRST + 419)                                   
#define idsVerifyCancel                 (STR_FIRST + 420)
#define idsCantCancel                   (STR_FIRST + 421)
#define idsCancelFailed                 (STR_FIRST + 422)
#define idsErrRemoveServerInUse         (STR_FIRST + 423)
#define idsHTMLPressSpaceToDownload     (STR_FIRST + 425)
#define idsEnterAutoWrap                (STR_FIRST + 427)
#define idsLines                        (STR_FIRST + 428)
#define idsReadingCachedHeaders         (STR_FIRST + 436)
#define idsErrEmptyMessage              (STR_FIRST + 437)
#define idsErrOnlyQuotedText            (STR_FIRST + 438)
#define idsErrLinesLongerThan80         (STR_FIRST + 439)
#define idsErrTooMuchQuoted             (STR_FIRST + 440)

#define idsMsgRecipients                (STR_FIRST + 441)
#define idsErrAddToWAB                  (STR_FIRST + 442)
#define idsErrAddrProps                 (STR_FIRST + 443)
#define idsErrBadRecipients             (STR_FIRST + 444)
#define idsErrDeleteMsg                 (STR_FIRST + 445)
#define idsErrPickNames                 (STR_FIRST + 446)
#define idsErrAddrDupe                  (STR_FIRST + 447)

#define idsControlField                 (STR_FIRST + 448)
#define idsTTControl                    (STR_FIRST + 449)

#define idsErrConfigureServer           (STR_FIRST + 450)
#define idsErrCantForward               (STR_FIRST + 451)
#define idsErrAddCertToWAB              (STR_FIRST + 452)
#define idsErrOpenManyMessages          (STR_FIRST + 453)
#define idsIgnoreResolveError           (STR_FIRST + 458)

#define idsErrSendMail                  (STR_FIRST + 473)
#define idsErrStoreInit                 (STR_FIRST + 475)
#define idsErrMailInit                  (STR_FIRST + 476)
#define idsErrDelete                    (STR_FIRST + 478)
#define idsErrImport                    (STR_FIRST + 480)
#define idsErrImportLoad                (STR_FIRST + 481)
#define idsHTMLErrNewsExpired           (STR_FIRST + 483)
#define idsBack                         (STR_FIRST + 484)
#define idsNext                         (STR_FIRST + 485)

#define idsTTFollowup                   (STR_FIRST + 510)
#define idsTTDistribution               (STR_FIRST + 511)
#define idsTTKeywords                   (STR_FIRST + 512)
#define idsTTReplyTo                    (STR_FIRST + 513)
#define idsTTApproved                   (STR_FIRST + 514)
#define idsTTPickNewsgroups             (STR_FIRST + 515)
#define idsErrDeleteOnExit              (STR_FIRST + 518)
#define idsFolderLocked                 (STR_FIRST + 519)
#define idsGenericError                 (STR_FIRST + 520)
#define idsCcWell                       (STR_FIRST + 521)
#define idsErrOnlyOneReplyTo            (STR_FIRST + 522)
#define idsReplyToWell                  (STR_FIRST + 523)
#define idsErrMove                      (STR_FIRST + 525)
#define idsErrCopy                      (STR_FIRST + 528)
#define idsWarnMailEmptySubj            (STR_FIRST + 531)
#define idsEnterDays                    (STR_FIRST + 532)
#define idsAllServers                   (STR_FIRST + 533)
#define idsWastedKB                     (STR_FIRST + 536)

#define idsEnterCompactPer              (STR_FIRST + 538)
#define idsDelete                       (STR_FIRST + 542)
#define idsCantLoadMapi32Dll            (STR_FIRST + 544)
#define idsErrBadFindParams             (STR_FIRST + 545)
#define idsNoMoreMsgFound               (STR_FIRST + 546)
#define idsErrNewsgroupLineTooLong      (STR_FIRST + 549)
#define idsNoteLangTitle                (STR_FIRST + 550)
#define idsCompacting                   (STR_FIRST + 551)
#define idsConfirmDelAll                (STR_FIRST + 552)
#define idsConfirmDelGroup              (STR_FIRST + 553)
#define idsConfirmDelServer             (STR_FIRST + 554)

// don't make me kill you for reordering the following ids...
#define idsNotConnected                 (STR_FIRST + 556)
#define idsReconnecting                 (STR_FIRST + 557)
#define idsFindingHost                  (STR_FIRST + 558)
#define idsFoundHost                    (STR_FIRST + 559)
#define idsConnecting                   (STR_FIRST + 560)
#define idsConnected                    (STR_FIRST + 561)
#define idsSecuring                     (STR_FIRST + 562)
// don't make me kill you for reordering the preceding ids...

#define idsBCcField                     (STR_FIRST + 563)
#define idsEmptyBCc                     (STR_FIRST + 564)
#define idsTTBCc                        (STR_FIRST + 565)
#define idsErrCompactAll                (STR_FIRST + 566)
#define idsMemory                       (STR_FIRST + 567)
#define idsDiskFull                     (STR_FIRST + 568)
#define idsErrExport                    (STR_FIRST + 574)
#define idsCleaningUp                   (STR_FIRST + 575)
#define idsErrBadRecips                 (STR_FIRST + 576)
#define idsSaveAs                       (STR_FIRST + 577)
#define idsCancelArticle                (STR_FIRST + 578)
#define idsMarkAllRead                  (STR_FIRST + 579)
#define idsMarkUnread                   (STR_FIRST + 580)
#define idsGotoOutbox                   (STR_FIRST + 581)
#define idsGotoPosted                   (STR_FIRST + 582)
#define idsMarkNewsgroups               (STR_FIRST + 583)
#define idsMarkThreadDownload           (STR_FIRST + 584)
#define idsMarkAllDownload              (STR_FIRST + 585)
#define idsMarkThreadRead               (STR_FIRST + 586)
#define idsHelp                         (STR_FIRST + 587)
#define idsProgDLPost                   (STR_FIRST + 588)
#define idsProgDLMessage                (STR_FIRST + 589)
#define idsProgDLGetLines               (STR_FIRST + 593)
#define idsPostedItems                  (STR_FIRST + 596)
#define idsGoToSentItems                (STR_FIRST + 598)
#define idsMarkReadTT                   (STR_FIRST + 599)
#define idsErrSelectGroup               (STR_FIRST + 602)
#define idsSavedItems                   (STR_FIRST + 605)
#define idsActionMoveTo                 (STR_FIRST + 606)
#define idsActionCopyTo                 (STR_FIRST + 607)
#define idsActionDontDownload           (STR_FIRST + 608)
#define idsIf                           (STR_FIRST + 609)
#define idsSubjectContains              (STR_FIRST + 610)
#define idsFromContains                 (STR_FIRST + 611)
#define idsToContains                   (STR_FIRST + 612)
#define idsCCContains                   (STR_FIRST + 613)
#define idsAnd                          (STR_FIRST + 614)
#define idsMaxCoolbarBtnWidth           (STR_FIRST + 619)
#define idsProgCombiningMsgs            (STR_FIRST + 620)
#define idsProgCopyMessages             (STR_FIRST + 621)
#define idsProgMoveMessages             (STR_FIRST + 622)
#define idsProgDeleteMessages           (STR_FIRST + 623)
#define idsMaxOutbarBtnWidth            (STR_FIRST + 624)
#define idshrRasInitFailure             (STR_FIRST + 625)
#define idshrRasDialFailure             (STR_FIRST + 626)
#define idshrRasServerNotFound          (STR_FIRST + 627)
#define idsRasError                     (STR_FIRST + 628)

#define idshrGetDialParamsFailed        (STR_FIRST + 630)
#define idsEndOfListReached             (STR_FIRST + 631)
#define idsMime                         (STR_FIRST + 632)
#define idsUUEncode                     (STR_FIRST + 633)
#define idsPriLow                       (STR_FIRST + 634)
#define idsPriHigh                      (STR_FIRST + 635)
#define idsPriNormal                    (STR_FIRST + 636)
#define idsWarnHTMLToPlain              (STR_FIRST + 638)
#define idsMoveTo                       (STR_FIRST + 647)
#define idsCopyTo                       (STR_FIRST + 648)
#define idsDisconnect                   (STR_FIRST + 649)
#define IDS_BROWSE_FOLDER               (STR_FIRST + 650)
#define idsRasErrorGeneral              (STR_FIRST + 651)
#define idsRas_Dialing                  (STR_FIRST + 652)
#define idsRas_Authentication           (STR_FIRST + 653)
#define idsErrorText                    (STR_FIRST + 654)
#define idsRas_Authenticated            (STR_FIRST + 655)
#define idsRASCS_OpenPort               (STR_FIRST + 657)
#define idsRASCS_PortOpened             (STR_FIRST + 658)
#define idsRASCS_ConnectDevice          (STR_FIRST + 659)
#define idsRASCS_DeviceConnected        (STR_FIRST + 660)
#define idsRASCS_AuthNotify             (STR_FIRST + 661)
#define idsRASCS_AuthRetry              (STR_FIRST + 662)
#define idsRASCS_AuthCallback           (STR_FIRST + 663)
#define idsRASCS_AuthChangePassword     (STR_FIRST + 664)
#define idsRASCS_AuthProject            (STR_FIRST + 665)
#define idsRASCS_AuthLinkSpeed          (STR_FIRST + 666)
#define idsRASCS_AuthAck                (STR_FIRST + 667)
#define idsRASCS_Authenticated          (STR_FIRST + 669)
#define idsRASCS_PrepareForCallback     (STR_FIRST + 670)
#define idsRASCS_WaitForModemReset      (STR_FIRST + 671)
#define idsRASCS_WaitForCallback        (STR_FIRST + 672)
#define idsRASCS_Projected              (STR_FIRST + 673)
#define idsRASCS_Connected              (STR_FIRST + 674)
#define idsRASCS_Disconnected           (STR_FIRST + 675)
#define idshrSetDialParamsFailed        (STR_FIRST + 676)
#define idsOK                           (STR_FIRST + 677)
#define idsRASCS_AllDevicesConnected    (STR_FIRST + 678)
#define idsErrCouldntCopyMessage        (STR_FIRST + 679)
#define idsErrMailBombHtml              (STR_FIRST + 680)
#define idsDefault                      (STR_FIRST + 681)
#define idsFailACacheCompact            (STR_FIRST + 682)
#define idsFailACacheCompactReason      (STR_FIRST + 683)

// For the HTML Welcome message
#define idsWelcomeMessageSubj           (STR_FIRST + 686)
#define idsSecWelcomeMessageSubj        (STR_FIRST + 687)
#define idsSpoolerDisconnect            (STR_FIRST + 696)
#define idsHTMLErrArticleNotCached      (STR_FIRST + 699)

#define idsStopTT                       (STR_FIRST + 701)

#define idsSecurityWarning              (STR_FIRST + 702)
#define idsErrServerNotConnected        (STR_FIRST + 703)
#define idsCacheRemovingReadArts        (STR_FIRST + 704)
#define idsCacheRemovingExpired         (STR_FIRST + 705)
#define idsProgDLPostTo                 (STR_FIRST + 707)
#define idsCacheRemovingBody            (STR_FIRST + 708)        // Bug# 51180 (v-snatar)

#define idsHelpMSWebFirst               (STR_FIRST + 710)
#define idsHelpMSWebFree                (STR_FIRST + 711)
#define idsHelpMSWebProductNews         (STR_FIRST + 712)
#define idsHelpMSWebFaq                 (STR_FIRST + 713)
#define idsHelpMSWebSupport             (STR_FIRST + 714)
#define idsHelpMSWebFeedback            (STR_FIRST + 715)
#define idsHelpMSWebBest                (STR_FIRST + 716)
#define idsHelpMSWebSearch              (STR_FIRST + 717)
#define idsHelpMSWebHome                (STR_FIRST + 718)
#define idsHelpMSWebOutlook             (STR_FIRST + 719)
#define idsHelpMSWebIE                  (STR_FIRST + 720)
#define idsHelpMSWebCert                (STR_FIRST + 721)
#define idsHelpMSWebCertSubName         (STR_FIRST + 722)
#define idsHelpMSWebHotmail             (STR_FIRST + 723)
#define idsHelpMSWebLast                (STR_FIRST + 730)

#define idsCombineAndDecodeTT           (STR_FIRST + 732)
#define idsPostAndDownloadTT            (STR_FIRST + 733)
#define idsGetNextTT                    (STR_FIRST + 734)
#define idsUnscrambleTT                 (STR_FIRST + 735)
#define idsUnmarkTT                     (STR_FIRST + 736)
#define idsErrCantCombineNotConnected   (STR_FIRST + 737)
#define idsDefTextExt                   (STR_FIRST + 738)
#define idsInsertTextTitle              (STR_FIRST + 739)
#define idsErrHTMLInNewsIsBad           (STR_FIRST + 740)
#define idsRasPromptDisconnect          (STR_FIRST + 741)
#define idsProgReceivedLines            (STR_FIRST + 743)
#define idsErrServerNotCongured         (STR_FIRST + 744)
#define idsErrSendDownloadFail          (STR_FIRST + 745)
#define idsErrSaveDownloadFail          (STR_FIRST + 746)

#define idsHTMLErrNewsDLCancelled       (STR_FIRST + 781)
#define idsErrGrpListDL                 (STR_FIRST + 782)
#define idsNewMailNotify                (STR_FIRST + 794)
#define idsXMsgsYUnreadZonServ          (STR_FIRST + 795)
#define idsGetHeaderFmt                 (STR_FIRST + 796)
#define idsPassReqd                     (STR_FIRST + 798)
#define idsHTMLDiskOutOfSpace           (STR_FIRST + 799)   // Bug# 50704 (v-snatar)

#define idsToWell                       (STR_FIRST + 822)
#define idsFromWell                     (STR_FIRST + 823)
#define idsFolder                       (STR_FIRST + 829)
#define idsErrCantRepairInUse           (STR_FIRST + 832)
#define idsRulesNoActions               (STR_FIRST + 833)
#define idsRulesNoCriteria              (STR_FIRST + 834)
#define idsRuleNoForwardTo              (STR_FIRST + 835)
#define idsActionForwardTo              (STR_FIRST + 836)
#define idsIn                           (STR_FIRST + 838)
#define idsOn                           (STR_FIRST + 839)
#define idsForAllMessages               (STR_FIRST + 840)
#define idsMessagePostedMoreThan        (STR_FIRST + 841)
#define idsDaysAgo                      (STR_FIRST + 842)
#define idsMessageSizeGreaterThan       (STR_FIRST + 843)
#define idsKB                           (STR_FIRST + 844)
#define idsActionReplyWith              (STR_FIRST + 845)
#define idsActionDeleteOffServer        (STR_FIRST + 846)
#define idsDontShowMessages             (STR_FIRST + 847)
#define idsInAnyGroup                   (STR_FIRST + 848)
#define idsRulesPickGroup               (STR_FIRST + 850)
#define idsRuleNoReplyWithFile          (STR_FIRST + 851)
#define idsRulePickFrom                 (STR_FIRST + 852)
#define idsRulePickTo                   (STR_FIRST + 853)
#define idsRulePickForwardTo            (STR_FIRST + 854)
#define idsRulePickCC                   (STR_FIRST + 855)
#define idsReasonMoveTo                 (STR_FIRST + 856)
#define idsReasonCopyTo                 (STR_FIRST + 857)
#define idsReasonForwardTo              (STR_FIRST + 858)
#define idsReasonReplyWith              (STR_FIRST + 859)
#define idsReasonActions                (STR_FIRST + 860)
#define idsNameCol                      (STR_FIRST + 861)
#define idsUnread                       (STR_FIRST + 862)
#define idsNew                          (STR_FIRST + 863)
#define idsLastUpdated                  (STR_FIRST + 864)
#define idsWastedSpace                  (STR_FIRST + 865)
#define idsTotal                        (STR_FIRST + 866)
#define idsErrDDFileNotFound            (STR_FIRST + 867)
#define idsGroupPropStatusDef           (STR_FIRST + 871) 
#define idsFolderPropStatusDef          (STR_FIRST + 872) 
#define idsGroupPropStatus              (STR_FIRST + 873) 
#define idsFolderPropStatus             (STR_FIRST + 874) 
#define idsTipOfTheDay                  (STR_FIRST + 875)
#define idsNextTip                      (STR_FIRST + 876)

#define idsEmptyControl                 (STR_FIRST + 878)
#define idsEmptyApproved                (STR_FIRST + 879)

#define idshrCantOpenOutbox             (STR_FIRST + 908)
#define idsUrlDetecting                 (STR_FIRST + 909)
#define idshrAuthFailed                 (STR_FIRST + 912)
#define idsInetMailConnectingHost       (STR_FIRST + 923)
#define idsInetMailRecvStatus           (STR_FIRST + 932)
#define idsReplySep                     (STR_FIRST + 933)
#define idsReplyFont                    (STR_FIRST + 934)
#define idsDetail_Account               (STR_FIRST + 941)
#define idsDetail_Server                (STR_FIRST + 942)
#define idsDetail_UserName              (STR_FIRST + 943)
#define idsDetail_Protocol              (STR_FIRST + 944)
#define idsDetail_Port                  (STR_FIRST + 945)
#define idsDetail_Secure                (STR_FIRST + 946)
#define idsDetail_ErrorNumber           (STR_FIRST + 947)
#define idsDetail_HRESULT               (STR_FIRST + 948)
#define idsDetails_Config               (STR_FIRST + 949)

#define idshrLockUidCacheFailed         (STR_FIRST + 986)
#define idshrCantLeaveOnServer          (STR_FIRST + 988)
#define idsNewsRulesTitle               (STR_FIRST + 989)
#define idsUpOneLevel                   (STR_FIRST + 990)
#define idsAccount                      (STR_FIRST + 997)
#define idsSendMsgUsing                 (STR_FIRST + 999)
#define idsSendMsgAccelTip              (STR_FIRST + 1000)
#define idsDefaultAccount               (STR_FIRST + 1001)
#define idsConnection                   (STR_FIRST + 1002)
#define idsConnectionLAN                (STR_FIRST + 1003)
#define idsConnectionManual             (STR_FIRST + 1004)
#define idsGroupFilters                 (STR_FIRST + 1007)
#define idsSendMsgOneAccount            (STR_FIRST + 1008)
#define idsErrNoSendAccounts            (STR_FIRST + 1009)
#define idshrErrNoSmtpResponse          (STR_FIRST + 1011)
#define idshrErrNoPop3Response          (STR_FIRST + 1012)
#define idsWarnDeleteAccount            (STR_FIRST + 1014)
#define idsPollAllAccounts              (STR_FIRST + 1015)
#define idsSecurityField                (STR_FIRST + 1017)
#define idsStitchingMessages            (STR_FIRST + 1018)
#define idsRuleReplyWithFilter          (STR_FIRST + 1019)
#define idsCopy                         (STR_FIRST + 1020)
#define idsCopyCaption                  (STR_FIRST + 1021)
#define idsMove                         (STR_FIRST + 1022)
#define idsMoveCaption                  (STR_FIRST + 1023)
#define idsNoMoveDestinationFolder      (STR_FIRST + 1024)
#define idsNoCopyDestinationFolder      (STR_FIRST + 1025)
#define idsErrFolderMove                (STR_FIRST + 1026)
#define idsErrCantMoveIntoSubfolder     (STR_FIRST + 1027)
#define idsErrURLExec                   (STR_FIRST + 1028)
#define idsErrNoteDeferedInit           (STR_FIRST + 1029)
#define idsErrCannotMoveSpecial         (STR_FIRST + 1030)
#define idsErrLoadingHtmlEdit           (STR_FIRST + 1031)
#define idsErrLoadingWAB                (STR_FIRST + 1032)
#define idsErrWAB                       (STR_FIRST + 1033)
#define idsErrWABNotFound               (STR_FIRST + 1034)

// Languages for purposes of spelling
#define idsSpellLangAmerican            (STR_FIRST + 1035)
#define idsSpellLangAustralian          (STR_FIRST + 1036)
#define idsSpellLangBritish             (STR_FIRST + 1037)
#define idsSpellLangCatalan             (STR_FIRST + 1038)
#define idsSpellLangCzecheslovakian     (STR_FIRST + 1039)
#define idsSpellLangDanish              (STR_FIRST + 1040)
#define idsSpellLangDutch               (STR_FIRST + 1041)
#define idsSpellLangFinnish             (STR_FIRST + 1042)
#define idsSpellLangFrench              (STR_FIRST + 1043)
#define idsSpellLangFrenchCanadian      (STR_FIRST + 1044)
#define idsSpellLangGerman              (STR_FIRST + 1045)
#define idsSpellLangGreek               (STR_FIRST + 1046)
#define idsSpellLangHungarian           (STR_FIRST + 1047)
#define idsSpellLangItalian             (STR_FIRST + 1048)
#define idsSpellLangNorskBokmal         (STR_FIRST + 1049)
#define idsSpellLangNorskNynorsk        (STR_FIRST + 1050)
#define idsSpellLangPolish              (STR_FIRST + 1051)
#define idsSpellLangPortBrazil          (STR_FIRST + 1052)
#define idsSpellLangPortIberian         (STR_FIRST + 1053)
#define idsSpellLangRussian             (STR_FIRST + 1054)
#define idsSpellLangSpanish             (STR_FIRST + 1055)
#define idsSpellLangSwedish             (STR_FIRST + 1056)
#define idsSpellLangTurkish             (STR_FIRST + 1057)
#define idsSpellLangDefault             (STR_FIRST + 1058)

#define idsErrCantDeleteFolderWithSub   (STR_FIRST + 1060)
#define idsIMAP                         (STR_FIRST + 1064)
#define idsErrResetSubList              (STR_FIRST + 1065)
#define idsMessagesOn                   (STR_FIRST + 1069)
#define idsWarnDeleteManyFolders        (STR_FIRST + 1070)
#define idsErrMsgURLNotFound            (STR_FIRST + 1071)
#define idsDownloadingImapFldrs         (STR_FIRST + 1072)
#define idsColLines                     (STR_FIRST + 1073)
#define idsNewFolder                    (STR_FIRST + 1074)
#define idsNewFolderNumber              (STR_FIRST + 1075)
#define idsImapLogon                    (STR_FIRST + 1076)
#define idsFontSize0                    (STR_FIRST + 1079)
#define idsFontSize1                    (STR_FIRST + 1080)
#define idsFontSize2                    (STR_FIRST + 1081)
#define idsFontSize3                    (STR_FIRST + 1082)
#define idsFontSize4                    (STR_FIRST + 1083)
#define idsFontSize5                    (STR_FIRST + 1084)
#define idsFontSize6                    (STR_FIRST + 1085)
#define idsErrLoadWinMM                 (STR_FIRST + 1086)
#define idsErrInetcplLoad               (STR_FIRST + 1087)
#define idsErrSicilyFailedToLoad        (STR_FIRST + 1089)
#define idsErrSicilyLogonFailed         (STR_FIRST + 1090)
#define idsOui                          (STR_FIRST + 1101)
#define idsNon                          (STR_FIRST + 1102)
#define idsBit                          (STR_FIRST + 1103)
#define idsMaybe                        (STR_FIRST + 1104)
#define idsMessageSizeLessThan          (STR_FIRST + 1106)
#define idsLogCouldNotConnect           (STR_FIRST + 1110)
#define idsErrCoCreateTrident           (STR_FIRST + 1122)
#define idsLogErrorGroup                (STR_FIRST + 1123)
#define idsLogErrorConnection           (STR_FIRST + 1124)
#define idsLogCheckingNewMessages       (STR_FIRST + 1125)
#define idsErrNotSaveUntilDownloadDone  (STR_FIRST + 1126)
#define idsLogErrorSwitchGroup          (STR_FIRST + 1127)
#define idsSendBeforeFullyDisplayed     (STR_FIRST + 1128)
#define idsLogStartDownloadAll          (STR_FIRST + 1132)
#define idsDetails                      (STR_FIRST + 1145)
#define idsIMAPCmdCompletionError       (STR_FIRST + 1149)
#define idsIMAPFolderListFailed         (STR_FIRST + 1150)
#define idsIMAPCreateFailed             (STR_FIRST + 1151)
#define idsIMAPCreateListFailed         (STR_FIRST + 1152)
#define idsIMAPCreateSubscribeFailed    (STR_FIRST + 1153)
#define idsIMAPFolderCacheTitle         (STR_FIRST + 1154)
#define idsIMAPFolderCacheError         (STR_FIRST + 1155)

#define idsIMAPSendNextOpErrTitle       (STR_FIRST + 1157)
#define idsIMAPSendNextOpErrText        (STR_FIRST + 1158)
#define idsIMAPFmgrInitErrTitle         (STR_FIRST + 1159)
#define idsIMAPFmgrInitErrText          (STR_FIRST + 1160)
#define idsIMAPCreateFldrErrorTitle     (STR_FIRST + 1161)
#define idsIMAPCreateFldrErrorText      (STR_FIRST + 1162)
#define idsIMAPFldrInitHdrsErrTitle     (STR_FIRST + 1163)
#define idsIMAPFldrInitHdrsErrText      (STR_FIRST + 1164)
#define idsIMAPServerAlertTitle         (STR_FIRST + 1165)
#define idsIMAPServerAlertIntro         (STR_FIRST + 1166)
#define idsIMAPServerParseErrTitle      (STR_FIRST + 1167)
#define idsIMAPServerParseErrIntro      (STR_FIRST + 1168)
#define idsIMAPOutOfSyncTitle           (STR_FIRST + 1169)
#define idsWarnChangeSecurity           (STR_FIRST + 1170)

#define idsIMAPNewHdrErrTitle           (STR_FIRST + 1171)
#define idsIMAPNewHdrErrText            (STR_FIRST + 1172)
#define idsIMAPNewBodyErrTitle          (STR_FIRST + 1173)
#define idsIMAPNewBodyErrText           (STR_FIRST + 1174)
#define idsIMAPNewFlagsErrTitle         (STR_FIRST + 1175)
#define idsIMAPNewFlagsErrText          (STR_FIRST + 1176)
#define idsIMAPErrorNotificationText    (STR_FIRST + 1177)
#define idsIMAPAuthFailureText          (STR_FIRST + 1178)
#define idsIMAPMsgDeleteSyncErrTitle    (STR_FIRST + 1179)
#define idsIMAPMsgDeleteSyncErrText     (STR_FIRST + 1180)
#define idsIMAPSelectFailureTitle       (STR_FIRST + 1181)
#define idsIMAPSelectFailureTextFmt     (STR_FIRST + 1182)
#define idsIMAPNewMsgDLErrTitle         (STR_FIRST + 1183)
#define idsIMAPNewMsgDLErrText          (STR_FIRST + 1184)
#define idsIMAPOldMsgUpdateFailure      (STR_FIRST + 1185)
#define idsIMAPFldrDeleteSyncErrTitle   (STR_FIRST + 1186)
#define idsIMAPFldrDeleteSyncErrText    (STR_FIRST + 1187)
#define idsErrNewsgroupBlocked          (STR_FIRST + 1188)
#define idsErrNewsgroupNoPosting        (STR_FIRST + 1189)
#define idsNewsOutbox                   (STR_FIRST + 1190)
#define idsIMAP_HCFCouldNotDelete       (STR_FIRST + 1191)
#define idsIMAPNoHierarchy              (STR_FIRST + 1192)
#define idsIMAPNoHierarchyLosePrefix    (STR_FIRST + 1193)
#define idsIMAPPrefixCreateFailedFmt    (STR_FIRST + 1194)

#define idsSaveAttachControl            (STR_FIRST + 1196)
#define idsOpenAttachControl            (STR_FIRST + 1197)
#define idsAll                          (STR_FIRST + 1198)
#define idsSaveAllBrowse                (STR_FIRST + 1199)
#define idsErrCmdFailed                 (STR_FIRST + 1200)
#define idsEmptyFolderMenuCommand       (STR_FIRST + 1201)

#define idsIMAPDeleteFldrFailed         (STR_FIRST + 1203)
#define idsIMAPDeleteFldrUnsubFailed    (STR_FIRST + 1204)
#define idsIMAPUnselectFailed           (STR_FIRST + 1205)
#define idsIMAPDeleteFldrErrorTitle     (STR_FIRST + 1206)
#define idsIMAPDeleteFldrErrorText      (STR_FIRST + 1207)
#define idsIMAPUpldProgressFmt          (STR_FIRST + 1208)
#define idsIMAPAppendFailed             (STR_FIRST + 1209)
#define idsIMAPUploadMsgFailedTitle     (STR_FIRST + 1211)
#define idsIMAPUploadMsgStoreFail       (STR_FIRST + 1212)
#define idsIMAPUploadMsgMoveDelFail     (STR_FIRST + 1213)
#define idsIMAPUploadMsgNoRootLvl       (STR_FIRST + 1214)
#define idsIMAPUploadMsgErrorText       (STR_FIRST + 1215)
#define idsInlineImageHeader            (STR_FIRST + 1216)
#define idsInlineImagePlaceHolder       (STR_FIRST + 1217)
#define idsBccWell                      (STR_FIRST + 1218)
#define idsErrNewsCantOpen              (STR_FIRST + 1219)
#define idsErrNewsExpired               (STR_FIRST + 1220)
#define idsPrintHeader                  (STR_FIRST + 1221)
#define idsIMAPImapCopyMoveNYI          (STR_FIRST + 1223)
#define idsIMAPCopyMsgsFailed           (STR_FIRST + 1224)
#define idsIMAPMoveMsgsFailed           (STR_FIRST + 1225)
#define idsIMAPCopyMsgProgressFmt       (STR_FIRST + 1226)
#define idsIMAPMoveMsgProgressFmt       (STR_FIRST + 1227)
#define idsIMAPCopyDlgTitleFmt          (STR_FIRST + 1228)
#define idsIMAPMoveDlgTitleFmt          (STR_FIRST + 1229)
#define idsButtonReadNews               (STR_FIRST + 1231)
#define idsButtonReadMail               (STR_FIRST + 1232)
#define idsButtonCompose                (STR_FIRST + 1233)
#define idsButtonUpdate                 (STR_FIRST + 1234)
#define idsButtonFind                   (STR_FIRST + 1235)
#define idsAthenaTitle                  (STR_FIRST + 1236)
#define idsIMAPDnldDlgErrorTitle        (STR_FIRST + 1238)
#define idsIMAPDnldProgressFmt          (STR_FIRST + 1239)
#define idsIMAPDnldDlgDLFailed          (STR_FIRST + 1240)
#define idsIMAPDnldDlgAbort             (STR_FIRST + 1241)
#define idsIMAPDnldDlgHeaderFailure     (STR_FIRST + 1242)
#define idsIMAPDnldDlgGetMsgFailure     (STR_FIRST + 1243)
#define idsIMAPDnldDlgSaveFailure       (STR_FIRST + 1244)
#define idsIMAPBodyFetchFailed          (STR_FIRST + 1245)
#define idsIMAPDeleteFailed             (STR_FIRST + 1246)
#define idsIMAPDnldDlgInitFailure       (STR_FIRST + 1247)
#define idsSecurityLineDigSign          (STR_FIRST + 1249)
#define idsSecurityLineSignGood         (STR_FIRST + 1250)
#define idsSecurityLineSignBad          (STR_FIRST + 1251)
#define idsSecurityLineSignUnsure       (STR_FIRST + 1252)
#define idsSecurityLineBreakStr         (STR_FIRST + 1253)
#define idsSecurityLineEncryption       (STR_FIRST + 1254)
#define idsSecurityLineEncGood          (STR_FIRST + 1255)
#define idsSecurityLineEncBad           (STR_FIRST + 1256)
#define idsPerformingRepair             (STR_FIRST + 1257)
#define idsErrViewLanguage              (STR_FIRST + 1258)
#define idsReplaceContents              (STR_FIRST + 1259)
#define idsFromAccount                  (STR_FIRST + 1260)
#define idsErrorPickAccount             (STR_FIRST + 1261)
#define idsSpellingOptions              (STR_FIRST + 1264)
#define idsErrSecurityNoSigningCert     (STR_FIRST + 1265)
#define idsIMAPNoHierarchyCharsFmt      (STR_FIRST + 1266)
#define idsIMAPRenameFldrErrorTitle     (STR_FIRST + 1267)
#define idsIMAPRenameFldrErrorText      (STR_FIRST + 1268)
#define idsIMAPRenameFailed             (STR_FIRST + 1269)
#define idsIMAPRenameFCUpdateFailure    (STR_FIRST + 1270)
#define idsIMAPReconnectFailed          (STR_FIRST + 1271)
#define idsIMAPRenameSubscribeFailed    (STR_FIRST + 1272)
#define idsIMAPRenameUnsubscribeFailed  (STR_FIRST + 1273)
#define idsIMAPRenameINBOX              (STR_FIRST + 1274)
#define idsIMAPAtomicRenameFailed       (STR_FIRST + 1275)
#define idsIMAPFldrInitError            (STR_FIRST + 1276)
#define idsEmptyStr                     (STR_FIRST + 1277)
#define idsIMAPTurnOnPolling            (STR_FIRST + 1278)
#define idsIMAPUIDValidityError         (STR_FIRST + 1279)
#define idsErrSecurityBadSigningPrint   (STR_FIRST + 1280)
#define idsSecurityLineSignPreProblem   (STR_FIRST + 1281)
#define idsSecurityLineEncExpired       (STR_FIRST + 1282)
#define idsSecurityLineSignDistrusted   (STR_FIRST + 1283)
#define idsSecurityLineSignExpired      (STR_FIRST + 1284)
#define idsSecurityLineListStr          (STR_FIRST + 1285)

#ifdef ATHENA_RTM_RELEASE
#error Need to remove beta1 strings
#else
// NYI strings for beta1 - pull these out before RTM!!
#define idsNYIGeneral                   (STR_FIRST + 1289)
#define idsNYITitle                     (STR_FIRST + 1290)
// NYI strings for beta1 - pull these out before RTM!!
#endif

#define idsViewLangMimeDBBad            (STR_FIRST + 1301)
#define idsIMAPViewInitFldrErr          (STR_FIRST + 1302)
#define idsIMAPViewInitFldrMgrErr       (STR_FIRST + 1303)
// standard warning -- reorder and die vvv
#define idsSecurityCertMissing          (STR_FIRST + 1305)
#define idsSecurityCertExpired          (STR_FIRST + 1306)
#define idsSecurityCertChainTooLong     (STR_FIRST + 1307)
#define idsSecurityCertNoIssuer         (STR_FIRST + 1308)
#define idsSecurityCertRevoked          (STR_FIRST + 1309)
#define idsSecurityCertNotTrusted       (STR_FIRST + 1310)
#define idsSecurityCertInvalid          (STR_FIRST + 1311)
#define idsSecurityCertError            (STR_FIRST + 1312)
#define idsSecurityCertNoPrint          (STR_FIRST + 1313)
#define idsSecurityCertUnknown          (STR_FIRST + 1314)
// standard warning -- reorder and die ^^^
#define idsErrFailedNavigate            (STR_FIRST + 1330)
#define idsAthenaStoreDir               (STR_FIRST + 1331)
#define idsIMAPMustBeConnectedFmt       (STR_FIRST + 1332)
#define idsDisconnecting                (STR_FIRST + 1333)
#define idsWrnSecurityNoCertForEnc      (STR_FIRST + 1334)
#define idsErrSecurityNoPrivateKey      (STR_FIRST + 1335)
#define idsErrSecurityNoChosenCert      (STR_FIRST + 1336)
#define idsErrSecurityNoCertForDecrypt  (STR_FIRST + 1338)
#define idsNYIMail                      (STR_FIRST + 1339)
#define idsIMAPNoInferiorsFmt           (STR_FIRST + 1343)
#define idsViewLanguageGeneralHelp      (STR_FIRST + 1344)
#define idsErrDuplicateAccount          (STR_FIRST + 1345)
#define idsErrRenameAccountFailed       (STR_FIRST + 1346)
#define idsSecurityLineSignUntrusted    (STR_FIRST + 1350)
#define idsCtxtAddToWab                 (STR_FIRST + 1351)
#define idsCtxtAddToFavorites           (STR_FIRST + 1352)
#define idsErrNewsServerTimeout         (STR_FIRST + 1353)
#define idsNNTPErrUnknownResponse       (STR_FIRST + 1354)
#define idsNNTPErrNewgroupsFailed       (STR_FIRST + 1355)
#define idsNNTPErrListFailed            (STR_FIRST + 1356)
#define idsNNTPErrListGroupFailed       (STR_FIRST + 1357)
#define idsNNTPErrGroupFailed           (STR_FIRST + 1358)
#define idsNNTPErrGroupNotFound         (STR_FIRST + 1359)
#define idsNNTPErrArticleFailed         (STR_FIRST + 1360)
#define idsNNTPErrHeadFailed            (STR_FIRST + 1361)
#define idsNNTPErrBodyFailed            (STR_FIRST + 1362)
#define idsNNTPErrPostFailed            (STR_FIRST + 1363)
#define idsNNTPErrNextFailed            (STR_FIRST + 1364)
#define idsNNTPErrDateFailed            (STR_FIRST + 1365)
#define idsNNTPErrHeadersFailed         (STR_FIRST + 1366)
#define idsNNTPErrXhdrFailed            (STR_FIRST + 1367)
#define idsDetail_ServerResponse        (STR_FIRST + 1368)
#define idsFavoritesFromOutlook         (STR_FIRST + 1369)
#define idsErrFavorites                 (STR_FIRST + 1370)
#define idsErrSendWebPageUrl            (STR_FIRST + 1371)
#define idsTasks                        (STR_FIRST + 1374)
#define idsErrors                       (STR_FIRST + 1375)
#define idsStatusCol                    (STR_FIRST + 1377)
#define idsErrCantFindHost              (STR_FIRST + 1378)
#define idsFmtTagGeneralHelp            (STR_FIRST + 1379)
#define idsHtmlNoFrames                 (STR_FIRST + 1380)
#define idsErrPostWithoutNewsgroup      (STR_FIRST + 1381)
#define idsNewsTaskPost                 (STR_FIRST + 1382)
#define idsStateExecuting               (STR_FIRST + 1384)
#define idsStateCompleted               (STR_FIRST + 1385)
#define idsStateFailed                  (STR_FIRST + 1386)
#define idsErrNewMsgsFailed             (STR_FIRST + 1387)
#define idsCheckingNewMsgsServer        (STR_FIRST + 1388)
#define idsCheckNewMsgsServer           (STR_FIRST + 1389)
#define idsChooseName                   (STR_FIRST + 1390)
#define idsVCFName                      (STR_FIRST + 1391)
#define idsRasErrorGeneralWithName      (STR_FIRST + 1392)
#define idsErrFindWAB                   (STR_FIRST + 1393)
#define idsErrAttachVCard               (STR_FIRST + 1394)
#define idsErrInsertVCard               (STR_FIRST + 1395)
#define idsNewsTaskPostError            (STR_FIRST + 1396)
#define idsSyncAccountFmt               (STR_FIRST + 1397)
#define idsDLHeaders                    (STR_FIRST + 1398)
#define idsDLHeadersAndMarked           (STR_FIRST + 1399)
#define idsDLNewMsgs                    (STR_FIRST + 1400)
#define idsDLNewMsgsAndMarked           (STR_FIRST + 1401)
#define idsDLAllMsgs                    (STR_FIRST + 1402)
#define idsDLMarkedMsgs                 (STR_FIRST + 1403)
#define idsSpoolerIdleErrors            (STR_FIRST + 1404)
#define idsSpoolerIdle                  (STR_FIRST + 1405)
#define idsStateWarnings                (STR_FIRST + 1406)
#define idsNewsTaskArticleError         (STR_FIRST + 1407)
#define idsForwardMessage               (STR_FIRST + 1408)
#define idsColPriority                  (STR_FIRST + 1409)
#define idsColAttach                    (STR_FIRST + 1410)
#define idsServerErrorNumber                        (STR_FIRST + 1411)
#define idsSocketErrorNumber                        (STR_FIRST + 1412)
#define idsOtherInformation                         (STR_FIRST + 1413)
#define IDS_IXP_E_TIMEOUT                           (STR_FIRST + 1414)
#define IDS_IXP_E_USER_CANCEL                       (STR_FIRST + 1415)
#define IDS_IXP_E_INVALID_ACCOUNT                   (STR_FIRST + 1416)    
#define IDS_IXP_E_WINSOCK_WSAVERNOTSUPPORTED        (STR_FIRST + 1417)
#define IDS_IXP_E_SOCKET_CONNECT_ERROR              (STR_FIRST + 1418)
#define IDS_IXP_E_SOCKET_INIT_ERROR                 (STR_FIRST + 1419)
#define IDS_IXP_E_SOCKET_WRITE_ERROR                (STR_FIRST + 1420)
#define IDS_IXP_E_SOCKET_READ_ERROR                 (STR_FIRST + 1421)
#define IDS_IXP_E_CONNECTION_DROPPED                (STR_FIRST + 1422)    
#define IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP         (STR_FIRST + 1423)
#define IDS_IXP_E_LOAD_SICILY_FAILED                (STR_FIRST + 1424)
#define IDS_IXP_E_INVALID_CERT_CN                   (STR_FIRST + 1425)
#define IDS_IXP_E_INVALID_CERT_DATE                 (STR_FIRST + 1426)
#define IDS_IXP_E_CONN                              (STR_FIRST + 1427)
#define IDS_IXP_E_CANT_FIND_HOST                    (STR_FIRST + 1428)
#define IDS_IXP_E_SICILY_LOGON_FAILED               (STR_FIRST + 1429)
#define IDS_IXP_E_FAILED_TO_CONNECT                 (STR_FIRST + 1430)
#define IDS_IXP_E_SMTP_RESPONSE_ERROR               (STR_FIRST + 1431)
#define IDS_IXP_E_SMTP_UNKNOWN_RESPONSE_CODE        (STR_FIRST + 1432)
#define IDS_E_OUTOFMEMORY                           (STR_FIRST + 1433)
#define IDS_IXP_E_UNKNOWN                           (STR_FIRST + 1434)
#define IDS_IXP_E_SMTP_REJECTED_SENDER              (STR_FIRST + 1435)
#define IDS_SP_E_SENDINGSPLITGROUP                  (STR_FIRST + 1436)
#define IDS_SP_E_SMTP_CANTOPENMESSAGE               (STR_FIRST + 1437)
#define IDS_SP_E_SMTP_CANTAUTOFORWARD               (STR_FIRST + 1438)
#define IDS_IXP_E_SMTP_NO_RECIPIENTS                (STR_FIRST + 1439)
#define IDS_IXP_E_SMTP_NO_SENDER                    (STR_FIRST + 1440)
#define IDS_IXP_E_SMTP_REJECTED_RECIPIENTS          (STR_FIRST + 1441)
#define IDS_SPS_SMTPEVENT                           (STR_FIRST + 1442)
#define IDS_SPS_POP3EVENT                           (STR_FIRST + 1443)
#define IDS_SPS_SMTPPROGRESS                        (STR_FIRST + 1444)
#define IDS_SPS_SMTPPROGRESS_SPLIT                  (STR_FIRST + 1445)
#define IDS_SPS_SMTPPROGGEN                         (STR_FIRST + 1446)
#define IDS_SPS_POP3CHECKING                        (STR_FIRST + 1447)
#define IDS_SPS_POP3STAT                            (STR_FIRST + 1448)
#define IDS_SPS_POP3DELE                            (STR_FIRST + 1449)
#define IDS_SPS_POP3UIDL_TOP                        (STR_FIRST + 1450)
#define IDS_SPS_POP3UIDL_UIDL                       (STR_FIRST + 1451)
#define IDS_SPS_PREDOWNRULES                        (STR_FIRST + 1452)
#define IDS_IXP_E_POP3_RESPONSE_ERROR               (STR_FIRST + 1453)
#define IDS_IXP_E_POP3_INVALID_USER_NAME            (STR_FIRST + 1454)
#define IDS_IXP_E_POP3_INVALID_PASSWORD             (STR_FIRST + 1455)
#define idsNNTPErrPasswordFailed                    (STR_FIRST + 1456)
#define idsStateCanceled                            (STR_FIRST + 1457)
#define idsSBCheckingNews                           (STR_FIRST + 1458)
#define idsSBSendingNews                            (STR_FIRST + 1459)
#define idsSBReceivingNews                          (STR_FIRST + 1460)
#define idsLogStartDownloadMarked                   (STR_FIRST + 1461)
#define idsTTSecurityCircSign           (STR_FIRST + 1462)
#define idsTTSecurityCircEnc            (STR_FIRST + 1463)
#define idsTTStampForReadnote           (STR_FIRST + 1464)
// standard warning -- reorder and die vvv
//NOTE: some of the Ok ids are referenced by offset only
#define OFFSET_SMIMEOK                  20
#define idsWrnSecurityMsgTamper         (STR_FIRST + 1465)
#define idsOkSecurityMsgTamper          (idsWrnSecurityMsgTamper + OFFSET_SMIMEOK)
#define idsUnkSecurityMsgTamper         (STR_FIRST + 1466)
#define idsWrnSecurityTrustNotTrusted   (STR_FIRST + 1467)
#define idsOkSecurityTrustNotTrusted    (idsWrnSecurityTrustNotTrusted + OFFSET_SMIMEOK)
#define idsUnkSecurityTrust             (STR_FIRST + 1468)
#ifdef N_NEST
#define idsWrnSigningValidity           (STR_FIRST + 1469)
#define idsOkSigningValidity            (idsWrnSigningValidity + OFFSET_SMIMEOK)
#endif
#define idsWrnSecurityTrustAddress      (STR_FIRST + 1470)
#define idsOkSecurityTrustAddress       (idsWrnSecurityTrustAddress + OFFSET_SMIMEOK)
#define idsWrnSecurityCertRevoked       (STR_FIRST + 1471)
#define idsOkSecurityCertRevoked        (idsWrnSecurityCertRevoked + OFFSET_SMIMEOK)
#define idsWrnSecurityOtherValidity     (STR_FIRST + 1472)
#define idsOkSecurityOtherValidity      (idsWrnSecurityOtherValidity + OFFSET_SMIMEOK)
#define idsWrnSecurityTrustExpired      (STR_FIRST + 1480)
#define idsOkSecurityTrustExpired       (idsWrnSecurityTrustExpired + OFFSET_SMIMEOK)
// standard warning -- reorder and die ^^^
#define idsAbortMessageLoad             (STR_FIRST + 1505)
#define idsConnNoDial                   (STR_FIRST + 1506)
#define idsRASWarnDidntDialConn         (STR_FIRST + 1507)

#define idsNonePicture                  (STR_FIRST + 1508)
#define idsStationery                   (STR_FIRST + 1509)
#define idsCaptionMail                  (STR_FIRST + 1510)
#define idsCaptionNews                  (STR_FIRST + 1511)
#define idsImageFileFilter              (STR_FIRST + 1512)
#define idsMoreStationery               (STR_FIRST + 1513)
#define idsErrNewStationery             (STR_FIRST + 1514)
#define idsHtmlFileFilter               (STR_FIRST + 1515)
#define idsErrVCardProperties           (STR_FIRST + 1516)
#define idsRSListGeneralHelp            (STR_FIRST + 1517)
#define idsTTVCardStamp                 (STR_FIRST + 1518)
#define idsChoosePicture                (STR_FIRST + 1519)
#define idsInvalidPicture               (STR_FIRST + 1520)
// begin tip of the day strings
#define IDS_TIP_FIRST_GENERAL           (STR_FIRST + 1521)
#define idsTipGen01                     (STR_FIRST + 1521)
#define idsTipGen02                     (STR_FIRST + 1522)
#define idsTipGen03                     (STR_FIRST + 1523)
#define idsTipGen04                     (STR_FIRST + 1524)
#define idsTipGen05                     (STR_FIRST + 1525)
#define idsTipGen06                     (STR_FIRST + 1526)
#define idsTipGen07                     (STR_FIRST + 1527)
#define idsTipGen08                     (STR_FIRST + 1528)
#define idsTipGen09                     (STR_FIRST + 1529)
#define idsTipGen10                     (STR_FIRST + 1530)
#define idsTipGen11                     (STR_FIRST + 1531)
#define idsTipGen12                     (STR_FIRST + 1532)
#define idsTipGen13                     (STR_FIRST + 1533)
#define idsTipGen14                     (STR_FIRST + 1534)
#define IDS_TIP_LAST_GENERAL            (STR_FIRST + 1534)
//
#define IDS_TIP_FIRST_POP               (STR_FIRST + 1535)
#define idsTipPop01                     (STR_FIRST + 1535)
#define idsTipPop02                     (STR_FIRST + 1536)
#define idsTipPop03                     (STR_FIRST + 1537)
#define idsTipPop04                     (STR_FIRST + 1538)
#define idsTipPop05                     (STR_FIRST + 1539)
#define idsTipPop06                     (STR_FIRST + 1540)
#define idsTipPop07                     (STR_FIRST + 1541)
#define idsTipPop08                     (STR_FIRST + 1542)
#define idsTipPop09                     (STR_FIRST + 1543)
#define idsTipPop10                     (STR_FIRST + 1544)
#define idsTipPop11                     (STR_FIRST + 1545)
#define IDS_TIP_LAST_POP                (STR_FIRST + 1545)
//
#define IDS_TIP_FIRST_NEWS              (STR_FIRST + 1546)
#define idsTipNews01                    (STR_FIRST + 1546)
#define idsTipNews02                    (STR_FIRST + 1547)
#define idsTipNews03                    (STR_FIRST + 1548)
#define idsTipNews04                    (STR_FIRST + 1549)
#define idsTipNews05                    (STR_FIRST + 1550)
#define idsTipNews06                    (STR_FIRST + 1551)
#define idsTipNews07                    (STR_FIRST + 1552)
#define idsTipNews08                    (STR_FIRST + 1553)
#define idsTipNews09                    (STR_FIRST + 1554)
#define idsTipNews10                    (STR_FIRST + 1555)
#define idsTipNews11                    (STR_FIRST + 1556)
#define IDS_TIP_LAST_NEWS               (STR_FIRST + 1556)
//
#define IDS_TIP_FIRST_IMAP              (STR_FIRST + 1557)
#define idsTipIMAP01                    (STR_FIRST + 1557)
#define idsTipIMAP02                    (STR_FIRST + 1558)
#define idsTipIMAP03                    (STR_FIRST + 1559)
#define idsTipIMAP04                    (STR_FIRST + 1560)
#define idsTipIMAP05                    (STR_FIRST + 1561)
#define idsTipIMAP06                    (STR_FIRST + 1562)
#define idsTipIMAP07                    (STR_FIRST + 1563)
#define IDS_TIP_LAST_IMAP               (STR_FIRST + 1563)
// end tip of the day strings

#define idsSendRecvOneAccount           (STR_FIRST + 1600)
#define idsSendRecvUsing                (STR_FIRST + 1601)
#define idsFPStatInbox                  (STR_FIRST + 1602)
#define idsFPStatDraft                  (STR_FIRST + 1603)
#define idsFPStatOutbox                 (STR_FIRST + 1604)
#define idsFPStatNews                   (STR_FIRST + 1605)
#define idsBold                         (STR_FIRST + 1606)
#define idsItalic                       (STR_FIRST + 1607)
#define idsComposeFontFace              (STR_FIRST + 1608)
#define IDS_SP_E_RETRFAILED             (STR_FIRST + 1609)
#define IDS_SPS_POP3TOTAL               (STR_FIRST + 1610)
#define IDS_SPS_POP3NEW                 (STR_FIRST + 1611)
#define IDS_IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX (STR_FIRST + 1612) 
#define IDS_SPS_SMTPUSEDEFAULT          (STR_FIRST + 1613)
#define idsNNTPErrServerTimeout         (STR_FIRST + 1614)
#define idsPictureTitle                 (STR_FIRST + 1615)
#define idsErrNoSubscribedGroups        (STR_FIRST + 1616)
#define idsWarnErrorUnsentMail          (STR_FIRST + 1617)
#define idsClose                        (STR_FIRST + 1618)
#define idsSelectFolder                 (STR_FIRST + 1619)
#define idsApplyRulesCaption            (STR_FIRST + 1620)
#define idsLeftOnServerWarning          (STR_FIRST + 1621)
#define idsReplyForwardLoop             (STR_FIRST + 1622)
#define idsDeleteOnServerWarning        (STR_FIRST + 1623)
#define idsNotDefNewsClient             (STR_FIRST + 1624)
#define idsFontSample                   (STR_FIRST + 1625)
#define idsSelectStationery             (STR_FIRST + 1626)
#define idsShopMoreStationery           (STR_FIRST + 1627)
#define idsFontFolderLarge              (STR_FIRST + 1628)
#define idsFontFolderSmall              (STR_FIRST + 1629)
#define idsFontViewTextLarge            (STR_FIRST + 1630)
#define idsFontViewTextSmall            (STR_FIRST + 1631)
#define idsEmptyEmailWarning            (STR_FIRST + 1632)
#define idsIMAPUnsubSubscribeErrTitle   (STR_FIRST + 1633)
#define idsIMAPUnsubSubscribeErrText    (STR_FIRST + 1634)
#define idsIMAPSubscribeFailedFmt       (STR_FIRST + 1635)
#define idsIMAPUnsubscribeFailedFmt     (STR_FIRST + 1636)
#define idsIMAPSubscribeAllFailed       (STR_FIRST + 1637)
#define idsSubscribingIMAPFldrs         (STR_FIRST + 1638)
#define idsUnsubscribingIMAPFldrs       (STR_FIRST + 1639)
#define idsSubscribingAllIMAPFldrs      (STR_FIRST + 1640)
#define idsUnsubscribingAllIMAPFldrs    (STR_FIRST + 1641)
#define idsIMAPSubscribeCountFmt        (STR_FIRST + 1642)
#define idsIMAPUnsubscribeCountFmt      (STR_FIRST + 1643)
#define idsIMAPSubscribeErrors          (STR_FIRST + 1644)
#define idsIMAPUnsubscrRemovalErrorFmt  (STR_FIRST + 1645)
#define idsIMAPSubscrAddErrorFmt        (STR_FIRST + 1646)
#define idsIMAPSubscribeAllSureFmt      (STR_FIRST + 1647)
#define idsIMAPUnsubscribeAllSureFmt    (STR_FIRST + 1648)
#define idsAreYouSureContinue           (STR_FIRST + 1649)
#define idsSyncThisAccount              (STR_FIRST + 1650)
#define idsModerated                    (STR_FIRST + 1651)
#define idsBlocked                      (STR_FIRST + 1652)
#define idsNoPosting                    (STR_FIRST + 1653)
#define idsWindowLayout                 (STR_FIRST + 1654)
#define IDS_IXP_E_SMTP_552_STORAGE_OVERFLOW (STR_FIRST + 1655)
#define idsSigningCertProperties        (STR_FIRST + 1656)
#define idsRas_Dialing_Param            (STR_FIRST + 1657)
#define idsFormatK                      (STR_FIRST + 1658)
#define idsIMAPRules                    (STR_FIRST + 1659)
#define idsGoToFolderTitle              (STR_FIRST + 1660)
#define idsGoToFolderText               (STR_FIRST + 1661)
#define idsMicrosoft                    (STR_FIRST + 1662)
#define idsComposeFontStyle             (STR_FIRST + 1663)
#define idsSendLaterUsing               (STR_FIRST + 1664)
#define idsSendLaterOneAccount          (STR_FIRST + 1665)
#define idsConfirmResetServer           (STR_FIRST + 1666)
#define idsConfirmResetGroup            (STR_FIRST + 1667)
#define idsNotApplicable                (STR_FIRST + 1668)
#define idsIMAPPollUnreadFailuresFmt    (STR_FIRST + 1670)
#define idsIMAPPollUnreadIMAP4Fmt       (STR_FIRST + 1671)
#define idsLameStatus                   (STR_FIRST + 1672)
#define idsNoAccountsFound              (STR_FIRST + 1673)
#define idsErrSecurityCertDisappeared   (STR_FIRST + 1674)
#define idsErrSecuritySendExpiredSign   (STR_FIRST + 1675)
#define idsErrSecuritySendTrust         (STR_FIRST + 1676)
#define idsErrSecuritySendExpiredEnc    (STR_FIRST + 1677)
#define idsNoNewsAccountsFound          (STR_FIRST + 1679)

#define idsSpoolerTackTT                (STR_FIRST + 1678)
// Strings used in Simple MAPI - vsnatar
#define idsAttachedFiles                (STR_FIRST + 1700)
#define idsBlank                        (STR_FIRST + 1701)

#define idsIMAPFolderReadOnly           (STR_FIRST + 1702)
#define idsFolderPropStatusIMAP         (STR_FIRST + 1703)
#define idsFileExistWarning             (STR_FIRST + 1704)
#define idsIMAPDeleteFldrTitleFmt       (STR_FIRST + 1705)

#define idsThen                         (STR_FIRST + 1710)
#define idsRulesLocal1                  (STR_FIRST + 1711)
#define idsRulesLocal2                  (STR_FIRST + 1712)
#define idsRulesLocal3                  (STR_FIRST + 1713)

#define idsIMAPNoFldrsRefreshPrompt     (STR_FIRST + 1714)
#define idsIMAPDirtyFldrsRefreshPrompt  (STR_FIRST + 1715)
#define idsIMAPNewAcctRefreshPrompt     (STR_FIRST + 1716)
#define idsLogOffUser                   (STR_FIRST + 1717)
#define idsErrBadMHTMLLinks             (STR_FIRST + 1718)
#define idsAbortDownload                (STR_FIRST + 1719)
#define idsErrWorkingOffline            (STR_FIRST + 1720)
#define idsSyncCacheWithSvr             (STR_FIRST + 1721)
#define idsLogOffTitle                  (STR_FIRST + 1722)
#define idsLogOffPrompt                 (STR_FIRST + 1723)
#define idsIMAPSubscrAllMemory          (STR_FIRST + 1724)

#ifdef WIN16
#define idsOE16NotSupportNews           (STR_FIRST + 1725)
#define idsFileTooBig                   (STR_FIRST + 1726)
#endif

#define idsNewAthenaUser                (STR_FIRST + 1727)
#define idsStatusTipConnectedDUN        (STR_FIRST + 1728)
#define idsStatusTipWorkOffline         (STR_FIRST + 1729)
#define idsPickStationery               (STR_FIRST + 1730)
#define idsSearching                    (STR_FIRST + 1731)
#define idsWarnBoringStationery         (STR_FIRST + 1732)
#define idsWarnSMapi                    (STR_FIRST + 1733)
#define idsWelcomeFromDisplay           (STR_FIRST + 1734)
#define idsWelcomeFromEmail             (STR_FIRST + 1735)
#define idsOutlookNews                  (STR_FIRST + 1736)
#define idsNewsgroupsMenu               (STR_FIRST + 1737)
#define idsNewsgroupFiltersMenu         (STR_FIRST + 1738)
#define idsNotDefOutNewsClient          (STR_FIRST + 1739)
#define idsAlwaysCheckOutNews           (STR_FIRST + 1740)
#define idsApplyStationeryGeneralHelp   (STR_FIRST + 1741)
#define idsCantSaveIMAPMsgFmt           (STR_FIRST + 1742)
#define idsUploadingIMAPDraftFmt        (STR_FIRST + 1743)
#define idsIMAPNoDraftsFolder           (STR_FIRST + 1744)
#define idsIMAPNoSentItemsFolder        (STR_FIRST + 1745)
#define idsIMAPCreatingSpecialFldrFmt   (STR_FIRST + 1746)
#define idsAboutOutlookNewsTitle        (STR_FIRST + 1747)
#define idsIMAPUpldSentItemsEventFmt    (STR_FIRST + 1748)
#define idsIMAPUpldSentItemsFailureFmt  (STR_FIRST + 1749)
#define IDS_ERROR_PREFIX1               (STR_FIRST + 1750)
#define IDS_ERROR_CREATE_INSTMUTEX      (STR_FIRST + 1751)
#define IDS_ERROR_MIMEOLE_ALLOCATOR     (STR_FIRST + 1752)
#define IDS_ERROR_FIRST_TIME_ICW        (STR_FIRST + 1753)
#define IDS_ERROR_INITSTORE_DIRECTORY   (STR_FIRST + 1754)
#define IDS_ERROR_REGCREATE_ROOT        (STR_FIRST + 1755)
#define IDS_ERROR_CREATE_HDRHEAP        (STR_FIRST + 1756)
#define IDS_ERROR_REG_WNDCLASS          (STR_FIRST + 1757)
#define IDS_ERROR_CREATEWINDOW          (STR_FIRST + 1758)
#define IDS_ERROR_INIT_GOPTIONS         (STR_FIRST + 1759)
#define IDS_ERROR_OPTNOTIFY_REG         (STR_FIRST + 1760)
#define IDS_ERROR_INITSTORE             (STR_FIRST + 1761)
#define IDS_ERROR_ALLOC_SUBMAN          (STR_FIRST + 1762)
#define IDS_ERROR_CREATE_ACCTMAN        (STR_FIRST + 1763)
#define IDS_ERROR_ALLOC_MIGRATESRV      (STR_FIRST + 1764)
#define IDS_ERROR_INIT_MIGRATESRV       (STR_FIRST + 1765)
#define IDS_ERROR_ALLOC_ACCTADVISE      (STR_FIRST + 1766)
#define IDS_ERROR_INIT_ACCTADVISE       (STR_FIRST + 1767)
#define IDS_ERROR_INIT_ACCTMAN          (STR_FIRST + 1768)
#define IDS_ERROR_ADVISE_ACCTMAN        (STR_FIRST + 1769)
#define IDS_ERROR_ALLOC_CONMAN          (STR_FIRST + 1770)
#define IDS_ERROR_INIT_CONMAN           (STR_FIRST + 1771)
#define IDS_ERROR_CREATE_SPOOLER        (STR_FIRST + 1772)
#define IDS_ERROR_CREATE_FONTCACHE      (STR_FIRST + 1773)
#define IDS_ERROR_REASON1               (STR_FIRST + 1774)
#define IDS_ERROR_REASON2               (STR_FIRST + 1775)
#define IDS_ERROR_START_HELP            (STR_FIRST + 1776)
#define IDS_ERROR_UNKNOWN               (STR_FIRST + 1777)
#define IDS_ERROR_FILE_NOEXIST          (STR_FIRST + 1778)
#define idsOperationAborted             (STR_FIRST + 1779)
#define idsIMAPUpldSentItemsDeleteFail  (STR_FIRST + 1780)
#define idsIMAPUpldSentItemsMoveFail    (STR_FIRST + 1781)
#define idsConfirmChangeStoreLocation   (STR_FIRST + 1782)
#define idsCantMoveStoreToSubfolder     (STR_FIRST + 1783)
#define idsMoveStoreProgress            (STR_FIRST + 1784)
#define idsResNameEmailAddress          (STR_FIRST + 1786)
#define idsResNamePerInfo               (STR_FIRST + 1787)
#define idsResNameAddress               (STR_FIRST + 1788)
#define idsResNameBusInfo               (STR_FIRST + 1789)
#define idsResNameTitle                 (STR_FIRST + 1790)
#define idsResNameDept                  (STR_FIRST + 1791)
#define idsResNameOff                   (STR_FIRST + 1792)
#define idsResNameComp                  (STR_FIRST + 1793)
#define idsResNameNotes                 (STR_FIRST + 1794)
#define idsResNamePhone                 (STR_FIRST + 1795)
#define idsResNameFax                   (STR_FIRST + 1796)
#define idsResNameCellular              (STR_FIRST + 1797)
#define idsResNameWeb                   (STR_FIRST + 1798)
#define idsResNamePager                 (STR_FIRST + 1799)
#define idsSavedToLocalDraftsInstead    (STR_FIRST + 1800)
#define idsSaveNowUploadLater           (STR_FIRST + 1801)
#define idsSavedToIMAPDraftFmt          (STR_FIRST + 1802)
#define idsSpoolerUserCancel            (STR_FIRST + 1803)
#define idsGrpDlgEmtpyList              (STR_FIRST + 1804)
#define idsEmptyFolder                  (STR_FIRST + 1805)
#define idsEmptyFolderFilter            (STR_FIRST + 1806)
#define idsEmptyNewsgroup               (STR_FIRST + 1807)
#define idsEmptyNewsgroupFilter         (STR_FIRST + 1808)
#define idsNoFindResults                (STR_FIRST + 1809)
#define IDS_ERROR_PREFIX2               (STR_FIRST + 1810)
#define IDS_ERROR_GETPROCSTART          (STR_FIRST + 1811)
#define IDS_ERROR_MISSING_DLL           (STR_FIRST + 1812)
#define idsDefaultSignature             (STR_FIRST + 1813)
#define idsSigNameFmt                   (STR_FIRST + 1814)
#define IDS_SP_E_CANT_MOVETO_SENTITEMS  (STR_FIRST + 1815)
#define idsType                         (STR_FIRST + 1816)
#define idsMail                         (STR_FIRST + 1817)
#define idsNews                         (STR_FIRST + 1818)
#define idsSearchingNews                (STR_FIRST + 1819)
#define idsSearchingIMAP                (STR_FIRST + 1820)
#define idsUnreadText                   (STR_FIRST + 1821)
#define idsIMAPCloseFailed              (STR_FIRST + 1822)
#define idsPapFBarFont                  (STR_FIRST + 1823)
#define idsPapFBarText                  (STR_FIRST + 1824)
#define idsErrSelectOneColumn           (STR_FIRST + 1825)
#define idsWorkOffline                  (STR_FIRST + 1826)
#define idsConfigServer                 (STR_FIRST + 1827)
#define idsIMAPSearchSettingsFail       (STR_FIRST + 1828)
#define idsIMAPCouldNotConnectFmt       (STR_FIRST + 1829)
#define idsIMAPUploadSettingsFailFmt    (STR_FIRST + 1830)
#define idsIMAPDownloadSettingsFailFmt  (STR_FIRST + 1831)
#define idsIMAPDLSettingsTitle          (STR_FIRST + 1832)
#define idsIMAPULSettingsTitle          (STR_FIRST + 1833)
#define idsCouldNotSelectFldr           (STR_FIRST + 1834)
#define idsIMAPUploadingSettings        (STR_FIRST + 1835)
#define idsIMAPDownloadingSettings      (STR_FIRST + 1836)
#define idsIMAPSelectingSettingsFldr    (STR_FIRST + 1837)
#define idsIMAPSearchingForSettings     (STR_FIRST + 1838)
#define idsIMAPCreatingSettingsFldr     (STR_FIRST + 1839)
#define idsIMAPDeletingOldSettings      (STR_FIRST + 1840)
#define idsConfigSvrLogin               (STR_FIRST + 1841)
#define idsConfigServerAcct             (STR_FIRST + 1842)
#define idsConfigDataMsgText            (STR_FIRST + 1843)
#define idsColumnDlgTitle               (STR_FIRST + 1844)
#define idsMailSig                      (STR_FIRST + 1845)
#define idsNewsSig                      (STR_FIRST + 1846)
#define idsMigrateFolder                (STR_FIRST + 1847)
#define idsLocalStore                   (STR_FIRST + 1848)
//
// end string Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Menu Command IDs (commands, not MENU resources!)
//
//  NOTE: toolbar cmd ids for DefView must be between
//          0 and (SFVIDM_CLIENT_LAST-SFVIDM_CLIENT_LAST)!!!
// all the commands between IDM_FIRST and IDM_LAST have
// a tooltip string and/or a status bar string associated with them
#define IDM_FIRST                       100
#define idmNewMsg                       (IDM_FIRST + 0)  
#define idmNewContact                   (IDM_FIRST + 1)  
#define idmHelpAbout                    (IDM_FIRST + 2)  
#define idmPrint                        (IDM_FIRST + 3)  
#define idmCompactAll                   (IDM_FIRST + 4)
#define idmCloseFind                    (IDM_FIRST + 5)
#define idmOpenContainer                (IDM_FIRST + 6)
#define idmOpen                         (IDM_FIRST + 9)  
#define idmSaveAs                       (IDM_FIRST + 10) 
#define idmFind                         (IDM_FIRST + 11) 
#define idmRedo                         (IDM_FIRST + 12) 
#define idmHelpTopics                   (IDM_FIRST + 13) 
#define idmSaveAttach                   (IDM_FIRST + 15) 
#define idmProperties                   (IDM_FIRST + 16) 
#define idmUndo                         (IDM_FIRST + 17) 
#define idmCut                          (IDM_FIRST + 18) 
#define idmCopy                         (IDM_FIRST + 19) 
#define idmPaste                        (IDM_FIRST + 20) 
#define idmDelete                       (IDM_FIRST + 21) 
#define idmSelectAll                    (IDM_FIRST + 22) 
#define idmMarkRead                     (IDM_FIRST + 23) 
#define idmMarkUnread                   (IDM_FIRST + 24) 
#define idmMarkTopicRead                (IDM_FIRST + 25) 
#define idmMarkAllRead                  (IDM_FIRST + 26) 
#define idmMarkDownload                 (IDM_FIRST + 27) 
#define idmMarkTopicDownload            (IDM_FIRST + 28) 
#define idmViewDecrypt                  (IDM_FIRST + 35)
#define idmColumns                      (IDM_FIRST + 37)
#define idmPopupArrange                 (IDM_FIRST + 38)
#define idmNext                         (IDM_FIRST + 39)
#define idmPrevious                     (IDM_FIRST + 40)
#define idmNewArticle                   (IDM_FIRST + 41)
#define idmReply                        (IDM_FIRST + 42)
#define idmReplyAll                     (IDM_FIRST + 43)
#define idmReplyPost                    (IDM_FIRST + 44)
#define idmReplyMail                    (IDM_FIRST + 45)
#define idmForward                      (IDM_FIRST + 46)
#define idmGetNextHeaders               (IDM_FIRST + 47)
#define idmNextUnreadNewsgroup          (IDM_FIRST + 50)
#define idmNextUnreadArticle            (IDM_FIRST + 51)
#define idmSubscribeNews                (IDM_FIRST + 52)
#define idmDeliverMail                  (IDM_FIRST + 54)
#define idmGotoInbox                    (IDM_FIRST + 55)
#define idmMoveTo                       (IDM_FIRST + 57)
#define idmCopyTo                       (IDM_FIRST + 58)
#define idmSortAsc                      (IDM_FIRST + 60)
#define idmSortDesc                     (IDM_FIRST + 61)

#define idmFldrCreate                   (IDM_FIRST + 63)
#define idmFldrRename                   (IDM_FIRST + 64)
#define idmFldrEmpty                    (IDM_FIRST + 65)
#define idmFldrCreate2                  (IDM_FIRST + 66)
#define idmPrintNow                     (IDM_FIRST + 68)
                               
#define idmFmtFont                      (IDM_FIRST + 70)
#define idmFmtSize                      (IDM_FIRST + 71)
#define idmFmtColor                     (IDM_FIRST + 72)
#define idmFmtColorAuto                 (IDM_FIRST + 73)
#define idmFmtColor1                    (IDM_FIRST + 74)
#define idmFmtColor2                    (IDM_FIRST + 75)
#define idmFmtColor3                    (IDM_FIRST + 76)
#define idmFmtColor4                    (IDM_FIRST + 77)
#define idmFmtColor5                    (IDM_FIRST + 78)
#define idmFmtColor6                    (IDM_FIRST + 79)
#define idmFmtColor7                    (IDM_FIRST + 80)
#define idmFmtColor8                    (IDM_FIRST + 81)
#define idmFmtColor9                    (IDM_FIRST + 82)
#define idmFmtColor10                   (IDM_FIRST + 83)
#define idmFmtColor11                   (IDM_FIRST + 84)
#define idmFmtColor12                   (IDM_FIRST + 85)
#define idmFmtColor13                   (IDM_FIRST + 86)
#define idmFmtColor14                   (IDM_FIRST + 87)
#define idmFmtColor15                   (IDM_FIRST + 88)
#define idmFmtColor16                   (IDM_FIRST + 89)
#define idmFmtBold                      (IDM_FIRST + 90)
#define idmFmtItalic                    (IDM_FIRST + 91)
#define idmFmtUnderline                 (IDM_FIRST + 92)
#define idmFmtBullets                   (IDM_FIRST + 93)
#define idmFmtDecreaseIndent            (IDM_FIRST + 94)
#define idmFmtIncreaseIndent            (IDM_FIRST + 95)
#define idmFmtLeft                      (IDM_FIRST + 96)
#define idmFmtCenter                    (IDM_FIRST + 97)
#define idmFmtRight                     (IDM_FIRST + 98)
#define idmFmtFontDlg                   (IDM_FIRST + 101)
#define idmPriLow                       (IDM_FIRST + 102)
#define idmPriNormal                    (IDM_FIRST + 103)
#define idmPriHigh                      (IDM_FIRST + 104)
#define idmFmtParagraph                 (IDM_FIRST + 105)
#define idmSave                         (IDM_FIRST + 106)
#define idmSendMsg                      (IDM_FIRST + 107)
#define idmCheckNames                   (IDM_FIRST + 108)
#define idmPickRecipients               (IDM_FIRST + 109)
#define idmInsertFile                   (IDM_FIRST + 110)
#define idmToolbar                      (IDM_FIRST + 111)
#define idmFormatBar                    (IDM_FIRST + 112)
#define idmClose                        (IDM_FIRST + 113)
#define idmPopupPri                     (IDM_FIRST + 114)
#define idmPopupFormat                  (IDM_FIRST + 115)
#define idmAccelCycleBkColor            (IDM_FIRST + 117)
#define idmSubscribeGroup               (IDM_FIRST + 119)
#define idmConnect                      (IDM_FIRST + 120)
#define idmPopupPreview                 (IDM_FIRST + 126)
#define idmNextUnreadThread             (IDM_FIRST + 127)
#define idmSpelling                     (IDM_FIRST + 128)
#define idmGotoNewsgroup                (IDM_FIRST + 129)
#define idmCancelArticle                (IDM_FIRST + 130)
#define idmViewContacts                 (IDM_FIRST + 131)
#define idmPopupOffline                 (IDM_FIRST + 132)
#define idmFindText                     (IDM_FIRST + 133)
#define idmPostMsg                      (IDM_FIRST + 134)
#define idmPickGroups                   (IDM_FIRST + 135)
#define idmPopupImport                  (IDM_FIRST + 136)
#define idmPopupExport                  (IDM_FIRST + 137)
#define idmImportAddressBook            (IDM_FIRST + 138)
#define idmImportMessages               (IDM_FIRST + 139)
#define idmExportAddressBook            (IDM_FIRST + 140)
#define idmExportMessages               (IDM_FIRST + 141)
#define idmImportAccts                  (IDM_FIRST + 142)
#define idmThreadArticles               (IDM_FIRST + 149)
#define idmViewNewGroups                (IDM_FIRST + 152)
#define idmCombineAndDecode             (IDM_FIRST + 153)
#define idmInsertSig                    (IDM_FIRST + 154)
#define idmNotePopupInsert              (IDM_FIRST + 158)
#define idmForwardMsgAttach             (IDM_FIRST + 161)
#define idmExpandThread                 (IDM_FIRST + 162)
#define idmCollapseThread               (IDM_FIRST + 163)
#define idmSortToggle                   (IDM_FIRST + 164)
#define idmFldrCompact                  (IDM_FIRST + 165)
#define idmSaveAttachAll                (IDM_FIRST + 167)

// Ole Object Verbs
//
#define idmNoteOle_First                (IDM_FIRST + 168)
#define idmNoteOle_Last                 (IDM_FIRST + 200)
// brettm: reserved a block of extra verbs for ole objects
// please don't reassign these, without talking to me.

// AddrObject:
#define idmAddrObj_Props                (idmNoteOle_First)
#define idmAddrObj_AddToWAB             (idmNoteOle_First+1)
#define idmAddrObj_Find                 (idmNoteOle_First+2)
// End: Ole Object Verbs
//

#define idmFillPreview                  (IDM_FIRST + 201)
#define idmViewFullHeaders              (IDM_FIRST + 202)
#define idmSep1                         (IDM_FIRST + 203)
#define idmSep2                         (IDM_FIRST + 204)

// reserved block of cmds for add to WAB dynamic menu
#define idmAddRecipToWAB_First          (IDM_FIRST + 207)
#define idmAddRecipToWAB_Last           (IDM_FIRST + 230) 
// reserved block of cmds for add to WAB dynamic menu

#define idmPopupAddToWAB                (IDM_FIRST + 231)
#define idmAddSenderToWAB               (IDM_FIRST + 232)
#define idmReadme                       (IDM_FIRST + 233)
#define idmFindNext                     (IDM_FIRST + 234)


//-------------------------------------------------------
// Language Command Ids
#define idmLanguagePopup                (IDM_FIRST + 237)
#define idmUSASCII                      (IDM_FIRST + 238)
#define idmLangFirst                    idmUSASCII
#define idmWesternEuropean              (IDM_FIRST + 239)
#define idmCentralEuropeanISO           (IDM_FIRST + 240)
#define idmCentralEuropeanWindows       (IDM_FIRST + 241)
#define idmRussianKOI8R                 (IDM_FIRST + 242)
#define idmRussianWindows               (IDM_FIRST + 243)
#define idmBalticISO                    (IDM_FIRST + 244)
#define idmBalticWindows                (IDM_FIRST + 245)
#define idmGreekISO                     (IDM_FIRST + 246)
#define idmGreekWindows                 (IDM_FIRST + 247)
#define idmTurkishISO                   (IDM_FIRST + 248)
#define idmTurkishWindows               (IDM_FIRST + 249)
#define idmJapaneseJisAuto              (IDM_FIRST + 250)
#define idmJapaneseJis                  (IDM_FIRST + 251)
#define idmJapaneseSJisAuto             (IDM_FIRST + 252)
#define idmJapaneseSJis                 (IDM_FIRST + 253)
#define idmJapaneseEucAuto              (IDM_FIRST + 254)
#define idmJapaneseEuc                  (IDM_FIRST + 255)
#define idmSimpChineseCnGb              (IDM_FIRST + 256)
#define idmSimpChineseHzGb              (IDM_FIRST + 257)
#define idmSimpChineseGbk               (IDM_FIRST + 258)
#define idmTradChineseCnBig5            (IDM_FIRST + 259)
#define idmTradChineseBig5              (IDM_FIRST + 260)
#define idmKoreanKsc                    (IDM_FIRST + 261)
#define idmLangLast                     (IDM_FIRST + 280)
#define idmLanguage                     (IDM_FIRST + 281)
//-------------------------------------------------------

#define idmCleanUpFiles                 (IDM_FIRST + 282)
#define idmCustomizeToolbar             (IDM_FIRST + 283)
#define idmCoolbarTop                   (IDM_FIRST + 284)
#define idmCoolbarLeft                  (IDM_FIRST + 285)
#define idmCoolbarBottom                (IDM_FIRST + 286)
#define idmCoolbarRight                 (IDM_FIRST + 287)
#define idmPostAndDownload              (IDM_FIRST + 288)
#define idmMarkNewsgroups               (IDM_FIRST + 289)
#define idmMarkAllDownload              (IDM_FIRST + 290)
#define idmUnmark                       (IDM_FIRST + 291)
#define idmDisconnect                   (IDM_FIRST + 292)
#define idmGotoOutbox                   (IDM_FIRST + 293)
#define idmInboxRules                   (IDM_FIRST + 295)
#define idmReplyPostAndMail             (IDM_FIRST + 296)
#define idmPopupFmtAlign                (IDM_FIRST + 297)
#define idmFmtSettings                  (IDM_FIRST + 298)
#define idmFmtHTML                      (IDM_FIRST + 299)
#define idmFmtPlain                     (IDM_FIRST + 300)
#define idmIconsWithText                (IDM_FIRST + 301)
#define idmSaveMessage                  (IDM_FIRST + 303)
#define idmDebugCoolbar                 (IDM_FIRST + 304)
#define idmWebNewsFind                  (IDM_FIRST + 305)
#define idmStop                         (IDM_FIRST + 307)
#define idmHelpMSWeb                    (IDM_FIRST + 308)
#define idmHelpMSWebFree                (IDM_FIRST + 309)
#define idmHelpMSWebProductNews         (IDM_FIRST + 310)
#define idmHelpMSWebFaq                 (IDM_FIRST + 311)
#define idmHelpMSWebSupport             (IDM_FIRST + 312)
#define idmHelpMSWebFeedback            (IDM_FIRST + 313)
#define idmHelpMSWebBest                (IDM_FIRST + 314)
#define idmHelpMSWebSearch              (IDM_FIRST + 315)
#define idmHelpMSWebHome                (IDM_FIRST + 316)
#define idmHelpMSWebOutlook             (IDM_FIRST + 317)
#define idmHelpMSWebHotmail             (IDM_FIRST + 321)
#define idmHelpMSWebLast                (IDM_FIRST + 328)
#define idmViewNews                     (IDM_FIRST + 329)
#define idmViewMail                     (IDM_FIRST + 330)
#define idmBrowseWeb                    (IDM_FIRST + 331)
#define idmInsertText                   (IDM_FIRST + 332)
#define idmPopupFilter                  (IDM_FIRST + 338)
#define idmViewAllArticles              (IDM_FIRST + 339)
#define idmViewUnreadArticles           (IDM_FIRST + 340)
#define idmViewBodiedArticles           (IDM_FIRST + 341)
#define idmGroupFilters                 (IDM_FIRST + 342)
#define idmViewTipOfTheDay              (IDM_FIRST + 343)
#define idmNewsNewServer                (IDM_FIRST + 344)
#define idmNewsRemoveServer             (IDM_FIRST + 345)
#define idmNewsSetDefaultServer         (IDM_FIRST + 346)
#define idmAccounts                     (IDM_FIRST + 348)
#define idmGetNewHeaders                (IDM_FIRST + 349)
#define idmGetNewMsgs                   (IDM_FIRST + 350)
#define idmGetAllMsgs                   (IDM_FIRST + 351)
#define idmCatchUp                      (IDM_FIRST + 352)
#define idmGetMarkedMsgs                (IDM_FIRST + 353)
#define idmDigSign                      (IDM_FIRST + 360)
#define idmEncrypt                      (IDM_FIRST + 361)
#define idmViewFolders                  (IDM_FIRST + 362)
#define idmViewRefresh                  (IDM_FIRST + 365)
#define idmViewOptions                  (IDM_FIRST + 366)
#define idmGoBack                       (IDM_FIRST + 368)
#define idmGoForward                    (IDM_FIRST + 369)
#define idmGoUpOneLevel                 (IDM_FIRST + 370)
#define idmGoNextUnreadMsg              (IDM_FIRST + 371)
#define idmGoNextUnreadFolder           (IDM_FIRST + 372)
#define idmFavoritesAddToFavorites      (IDM_FIRST + 373)
#define idmFavoritesOrganizeFavorites   (IDM_FIRST + 374)
#define idmPopupGo                      (IDM_FIRST + 375)
#define idmPopupFavorites               (IDM_FIRST + 376)
#define idmLanguageDelay                (IDM_FIRST + 377)
#define idmSendImages                   (IDM_FIRST + 379)

// why are these in the 400s?
#define idmReceiveFrom                  (IDM_FIRST + 450)
#define idmSendOutbox                   (IDM_FIRST + 451)
#define idmMarkNewHeaderDownload        (IDM_FIRST + 452)
#define idmMarkAllMsgDownload           (IDM_FIRST + 453)
#define idmMarkNewMsgDownload           (IDM_FIRST + 454)
#define idmInsertImage                  (IDM_FIRST + 458)
#ifdef BETA2_MENU
#define idmInsertLink                   (IDM_FIRST + 459)
#endif
#define idmUnDelete                     (IDM_FIRST + 460)
#define idmExpunge                      (IDM_FIRST + 461)
#define idmViewDeletedArticles          (IDM_FIRST + 462)
#define idmFolders                      (IDM_FIRST + 463)
#define idmSubscribeFolder              (IDM_FIRST + 464)
#define idmDownloadAttach               (IDM_FIRST + 465)
#define idmStatusbar                    (IDM_FIRST + 466)
#define idmUnInsertLink                 (IDM_FIRST + 467)
#define idmRefreshFolders               (IDM_FIRST + 469)
#define idmViewFilteredArticles         (IDM_FIRST + 471)
#define idmSyncAll                      (IDM_FIRST + 472)
#define idmSyncSelected                 (IDM_FIRST + 473)
#define idmMarkDownloadMenu             (IDM_FIRST + 474)
#define idmFmtNumbers                   (IDM_FIRST + 475)
#define idmFmtInsertHLine               (IDM_FIRST + 476)
#define idmPopupFmtBkground             (IDM_FIRST + 480)
#define idmFmtBkgroundImage             (IDM_FIRST + 481)
#define idmPopupFmtBkgroundColor        (IDM_FIRST + 482)

#define idmBkColorAuto                  (IDM_FIRST + 490)
#define idmBkColor1                     (IDM_FIRST + 491)
#define idmBkColor2                     (IDM_FIRST + 492)
#define idmBkColor3                     (IDM_FIRST + 493)
#define idmBkColor4                     (IDM_FIRST + 494)
#define idmBkColor5                     (IDM_FIRST + 495)
#define idmBkColor6                     (IDM_FIRST + 496)
#define idmBkColor7                     (IDM_FIRST + 497)
#define idmBkColor8                     (IDM_FIRST + 498)
#define idmBkColor9                     (IDM_FIRST + 499)
#define idmBkColor10                    (IDM_FIRST + 500)
#define idmBkColor11                    (IDM_FIRST + 501)
#define idmBkColor12                    (IDM_FIRST + 502)
#define idmBkColor13                    (IDM_FIRST + 503)
#define idmBkColor14                    (IDM_FIRST + 504)
#define idmBkColor15                    (IDM_FIRST + 505)
#define idmBkColor16                    (IDM_FIRST + 506)
#define idmBodyViewSource               (IDM_FIRST + 507)
#define idmMarkAllHeaderDownload        (IDM_FIRST + 508)
#define idmPopupCompose                 (IDM_FIRST + 509)
#define idmPopupFolder                  (IDM_FIRST + 510)
#define idmPopupFonts                   (IDM_FIRST + 511)
#define idmPopupNew                     (IDM_FIRST + 512)
#define idmPopupNext                    (IDM_FIRST + 513)
#define idmPopupSynchronize             (IDM_FIRST + 514)
#define idmPopupToolbar                 (IDM_FIRST + 515)
#define idmPopupTools                   (IDM_FIRST + 516)
#define idmGotoMeeting                  (IDM_FIRST + 517)
#define idmViewNewWindow                (IDM_FIRST + 518)
#define idmFldrMove                     (IDM_FIRST + 519)
#define idmFldrCopy                     (IDM_FIRST + 520)
#define idmFldrDelete                   (IDM_FIRST + 521)
#define idmGotoChat                     (IDM_FIRST + 522)
#define idmFontSmallest                 (IDM_FIRST + 523)
#define idmFontSmaller                  (IDM_FIRST + 524)
#define idmFontMedium                   (IDM_FIRST + 525)    
#define idmFontLarger                   (IDM_FIRST + 526)
#define idmFontLargest                  (IDM_FIRST + 527)
#define idmGotoFolder                   (IDM_FIRST + 528)
#define idmGotoNews                     (IDM_FIRST + 529)
#ifdef BETA2_MENU
#define idmEditPicture                  (IDM_FIRST + 530)
#endif
#define idmEditLink                     (IDM_FIRST + 531)
#define idmTridentProps                 (IDM_FIRST + 532)
#define idmNewMsg2                      (IDM_FIRST + 533)  
#define idmNewArticle2                  (IDM_FIRST + 534)
#define idmPopupFile                    (IDM_FIRST + 535)
#define idmPopupEdit                    (IDM_FIRST + 536)
#define idmPopupView                    (IDM_FIRST + 537)
#define idmPopupHelp                    (IDM_FIRST + 538)
#define idmBodyViewMsgSource            (IDM_FIRST + 539)
#define idmCtxtAddToWab                 (IDM_FIRST + 541)
#define idmCtxtAddToFavorites           (IDM_FIRST + 542)
#define idmSendWebPage                  (IDM_FIRST + 543)
#define idmPopupFmtTag                  (IDM_FIRST + 544)
#define idmFmtTag                       (IDM_FIRST + 545)
#define idmViewReplyArticles            (IDM_FIRST + 546)
#define idmInsertVCard                  (IDM_FIRST + 547)
#define idmSyncAccount                  (IDM_FIRST + 548)
#define idmMarkThisNewsgroup            (IDM_FIRST + 549)
#define idmStationery                   (IDM_FIRST + 550)
#define idmFindPeople                   (IDM_FIRST + 551)
#define idmRSList0                      (IDM_FIRST + 552)
#define idmRSList1                      (IDM_FIRST + 553)
#define idmRSList2                      (IDM_FIRST + 554)
#define idmRSList3                      (IDM_FIRST + 555)
#define idmRSList4                      (IDM_FIRST + 556)
#define idmRSList5                      (IDM_FIRST + 557)
#define idmRSList6                      (IDM_FIRST + 558)
#define idmRSList7                      (IDM_FIRST + 559)
#define idmRSList8                      (IDM_FIRST + 560)
#define idmRSList9                      (IDM_FIRST + 561)
#define idmMoreStationery               (IDM_FIRST + 562)
#define idmNewPopup                     (IDM_FIRST + 563)
#define idmVCardDelete                  (IDM_FIRST + 564)
#define idmVCardProperties              (IDM_FIRST + 565)
#define idmGotoDraft                    (IDM_FIRST + 566)
#define idmSpoolerWarnings              (IDM_FIRST + 567)
#define idmSpoolerShow                  (IDM_FIRST + 568)
#define idmCloseBrowser                 (IDM_FIRST + 569)
#define idmSubscribeAllFldrs            (IDM_FIRST + 570)
#define idmUnsubscribeAllFldrs          (IDM_FIRST + 571)
#define idmUnsubscribeFolder            (IDM_FIRST + 572)
#define idmSendLater                    (IDM_FIRST + 574)
#define idmPostLater                    (IDM_FIRST + 575)
#define idmNoStationery                 (IDM_FIRST + 576)
#define idmSavePicture                  (IDM_FIRST + 577)
#define idmSendDefault                  (IDM_FIRST + 578)
#define idmPostDefault                  (IDM_FIRST + 579)
#define idmPaneSigning                  (IDM_FIRST + 580)
#define idmPaneEncryption               (IDM_FIRST + 581)
#define idmPanePaperclip                (IDM_FIRST + 582)
#define idmPaneVCard                    (IDM_FIRST + 583)
#define idmDSPViewProp                  (IDM_FIRST + 584)
#define idmDSPViewCert                  (IDM_FIRST + 585)
#define idmDSPTrust                     (IDM_FIRST + 586)
#define idmDSPHelp                      (IDM_FIRST + 587)
#define idmEPViewProp                   (IDM_FIRST + 588)
#define idmEPViewCert                   (IDM_FIRST + 589)
#define idmEPHelp                       (IDM_FIRST + 590)
#define idmLogOffUser                   (IDM_FIRST + 591)
#define idmWorkOffline                  (IDM_FIRST + 592)
#define idmIMAPDeliverMail              (IDM_FIRST + 593)
#define idmSaveBackground               (IDM_FIRST + 594)
#define idmSaveAsStationery             (IDM_FIRST + 595)
#define idmFmtApplyStationeryPopup      (IDM_FIRST + 596)
#define idmApplyMoreStationery          (IDM_FIRST + 597)
#define idmApplyNoStationery            (IDM_FIRST + 598)
#define idmApplyStationery0             (IDM_FIRST + 599)
#define idmApplyStationery1             (IDM_FIRST + 600)
#define idmApplyStationery2             (IDM_FIRST + 601)
#define idmApplyStationery3             (IDM_FIRST + 602)
#define idmApplyStationery4             (IDM_FIRST + 603)
#define idmApplyStationery5             (IDM_FIRST + 604)
#define idmApplyStationery6             (IDM_FIRST + 605)
#define idmApplyStationery7             (IDM_FIRST + 606)
#define idmApplyStationery8             (IDM_FIRST + 607)
#define idmApplyStationery9             (IDM_FIRST + 608)
#define idmImportNewsAcct               (IDM_FIRST + 609)
#define idmSetPriority                  (IDM_FIRST + 610)
#define idmClearSelection               (IDM_FIRST + 611)

// DO NOT CHANGE IDM_LAST unless you have a really
// good reason. when IDM_LAST changes, all the string ids
// change and the localizers get really upset because they
// have to re-localize everything.
#define IDM_LAST                       (IDM_FIRST + 2000)

// command ID's after IDM_LAST have no tooltip assoc.
#define idmAccelBold                   (IDM_LAST + 5)
#define idmAccelItalic                 (IDM_LAST + 6)
#define idmAccelUnderline              (IDM_LAST + 7)
#define idmAccelIncreaseIndent         (IDM_LAST + 8)
#define idmAccelDecreaseIndent         (IDM_LAST + 9)
#define idmAccelBullets                (IDM_LAST + 10)
#define idmAccelLeft                   (IDM_LAST + 11)
#define idmAccelCenter                 (IDM_LAST + 12)
#define idmAccelRight                  (IDM_LAST + 13)
#define idmAccelColor                  (IDM_LAST + 14)
#define idmAccelFont                   (IDM_LAST + 15)
#define idmAccelSize                   (IDM_LAST + 16)
#define idmAccelNextCtl                (IDM_LAST + 17)
#define idmAccelPrevCtl                (IDM_LAST + 18)

//AttachWell context menu's
#define idmAttCtxLI                    (IDM_LAST + 19)
#define idmAttCtxSI                    (IDM_LAST + 21)
#define idmAttCtxRemove                (IDM_LAST + 23)
#define idmAttCtxOpen                  (IDM_LAST + 24)
#define idmAttCtxQuickView             (IDM_LAST + 25)
#define idmAttCtxSave                  (IDM_LAST + 26)
#define idmAttCtxRename                (IDM_LAST + 27)
#define idmAttCtxPrint                 (IDM_LAST + 28)
#define idmAttCtxInsertFile            (IDM_LAST + 29)
#define idmAttCtxProps                 (IDM_LAST + 30)
#define idmAttCtxPopupView             (IDM_LAST + 31)
#define idmAttDragMove                 (IDM_LAST + 32)
#define idmAttDragCopy                 (IDM_LAST + 33)
#define idmAttDragLink                 (IDM_LAST + 34)

// reserve 50 id's for sort menus
#define idmSortMenuBase                 (IDM_LAST + 36)
#define idmSortMenuLast                 (idmSortMenuBase + 50)
#define idmSentItems                    (idmSortMenuLast +1)  // Justin told me to put this id here. So don't blame me!  Ann

// Send Using Account Ranges.... (Allowing up to 100 Send Accounts)
#define idmAccountMenuFirst            (idmSentItems + 1)
#define idmAccountMenuLast             (idmAccountMenuFirst + 100)

#define idmDebugMenuFirst               (idmAccountMenuLast + 1)
#define idmTridentTest1                 (idmDebugMenuFirst)
#define idmTridentTest2                 (idmDebugMenuFirst + 1)
#define idmTridentTest3                 (idmDebugMenuFirst + 2)
#define idmTridentTest4                 (idmDebugMenuFirst + 3)
#define idmTridentTest5                 (idmDebugMenuFirst + 4)
#define idmMessageSource                (idmDebugMenuFirst + 5)
#define idmAsyncTest                    (idmDebugMenuFirst + 6)
#define idmRangeTest                    (idmDebugMenuFirst + 7)
#define idmURLTest                      (idmDebugMenuFirst + 8)
#define idmUUENCODETest                 (idmDebugMenuFirst + 9)
#define idmIMAPTest                     (idmDebugMenuFirst + 10)
#define idmPropTreeTest                 (idmDebugMenuFirst + 11)
#define idmNewsNNTXTest                 (idmDebugMenuFirst + 12)
#define idmStoreTest                    (idmDebugMenuFirst + 13)
#define idmOfflineTest                  (idmDebugMenuFirst + 14)
#define idmSpoolerStart                 (idmDebugMenuFirst + 15)
#define idmUploadConfig                 (idmDebugMenuFirst + 16)
#define idmDebugMenuLast                (idmDebugMenuFirst + 16)

// reserve 50 id's for SaveAttachments menu
#define idmSaveAttachFirst              (idmTridentTest5 + 35)
#define idmSaveAttachLast               (idmSaveAttachFirst + 50)

#define CONNECT_MENU_BASE               (idmSaveAttachLast + 1)
#define CONNECT_MENU_LAST               (CONNECT_MENU_BASE + 100)

// reserve 50 id's for format bar style menu
#define idmFmtTagFirst                  (CONNECT_MENU_LAST + 1)
#define idmFmtTagLast                   (idmFmtTagFirst + 50)

// Reserve 100 for send later accounts
#define idmAccountLaterFirst            (idmFmtTagLast + 1)
#define idmAccountLaterLast             (idmAccountLaterFirst + 100)

// Reserve 100 for OE Extension
#define idmExtensionFirst               (idmAccountLaterLast + 1)
#define idmExtensionLast                (idmExtensionFirst + 100)

#define idmSignatureFirst               (idmExtensionLast + 1)
#define idmSignatureLast                (idmSignatureFirst + 100)

// ------------------------------------------------------

//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap Resource IDs
//
#define idbToolbarBtns                  1
#define idb16x16                        2
#define idb16x16st                      4
#define idbSplash                       5
#define idbFormatBar                    8
#define idbFormatBarFont                9
#define idbStamps                      11
#define idbBtns                        12
#define idbFolders                     16
#define idbHorzStrip                   17
#define idbSecurity                    19
#define idbFoldersLarge                20

// Don't change the order of these - SteveSer
#define idbCoolbar                     27
#define idbCoolbarHot                  28
#define idbOfflineHot                  30
// Don't change the order of these - SteveSer
 
#define idbBrand                       31
#define idbSBrand                      32
#define idbSpooler                     36
#define idbStatusBar                   37

// Don't change the order of these - SteveSer
#define idb256Coolbar                  38
#define idb256CoolbarHot               39
#define idbSmCoolbar                   40
#define idbSmCoolbarHot                41
// Don't change the order of these - SteveSer

// Don't change the order of these vvv (t-erikne)
#define idbPaneBar32                   42
#define idbPaneBar32Hot                43
#define idbPaneBar16                   44
#define idbPaneBar16Hot                45
// Don't change the order of these ^^^ (t-erikne)

#define idbPapLeft                     46
#define idbPapRight                    47

//
// END Bitmap Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Icon Resource IDs
//
#define idiMail                         2
#define idiMailNews                     idiMail
#define idiNews                         3
#define idiOEDocument                   5
#define idiPasswordKeys                 6
#define idiNewsServer                   7
#define idiNewsGroup                    8
#define idiFileAtt                      9
#define idiMessageAtt                  12
#define idiDefaultAtt                  13
#define idiMsgPropSent                 14
#define idiMsgPropUnSent               15
#define idiError                       16
#define idiUpArrow                     17
#define idiDownArrow                   18
#define idiArtPropPost                 19
#define idiArtPropUnpost               20
#define idiPhone                       21
#define idiNewMailNotify               23
#define idiPickRecip                   24
#define idiFolder                      25
#define idiNewsFolder                  27
#define idiDLNews                      42
#define idiSecure                      43
#define idiNoSecure                    44
#define idiSendReceive                 45
#define idiWindowLayout                46
#define idiToolbarLayout               47
#define idiPrePaneLayout               48
#define idiOfflineIcon                 49
#define idiPapLargeIcon                50
#define idiPapSmallIcon                51

//
// END Icon Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Animation Resource IDs
//
#define idanInbox                     1
#define idanOutbox                    2
#define idanMiniOut                   4
#define idanMiniIn                    5
#define idanDecode                    6
#define idanCompact                   7
#define idanDownloadNews              8
#define idanCopyMsgs                  9


//
// END Animation Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Dialog Resource IDs (DIALOG resource ids, not control ids!)
//
#define iddVersion                      1
#define iddSubscribe                    2
#define iddSubscribeOneServer           3
#define iddAdvSecurity                  4
#define iddPerformingRepair             5
#define iddAthenaDefault                6
#define iddStoreLocation                7
#define iddAdvSig                       8
#define iddAthPropSheet                 9
#define iddSortBy                      11
#define iddPassword                    16
#define iddInsertFile                  21 
#define iddFileExists                  24
#define iddFileExistsMult              25
#define iddSafeOpen                    26
#define iddRasLogon                    27
#define iddWebPage                     28
#define iddBkImage                     29

#define iddSpelling                    30
#define iddRangeTest                   39
#define iddPickGroup                   40
#define iddDownloadGroups              41
#define iddURLTest                     42
#define iddInboxRulesManager           43
#define iddInboxRulesEdit              44
#define iddNewFolder                   45
#define iddRasCloseConn                46

#define iddOpt_Security                47
#define iddOpt_Spelling                48
#define iddOpt_DialUp                  49
#define iddOpt_Read                    50
#define iddOpt_General                 51
#define iddOpt_Send                    52
#define iddOpt_Advanced                53
#define iddOpt_Signature               54

#define iddMsgProp_General             58
#define iddMsgProp_Details             60
#define iddMsgSource                   61
#define iddRasProgress                 62
#define iddDetailedError               63
#define iddOrderMessages               69
#define iddArtProp_General             74
#define iddStoreTest                   78
#define iddPlainRecipWarning           79

#define iddIMAPTest                    80

#define iddArticleCacheTest            81
#define iddAsyncTest                   83
#define iddCacheMan                    85
#define iddProgress                    87
#define iddFindMsg                     88
#define iddFindNNTPMsg                 89
#define iddNNTXTest                    90
#define iddCombineAndDecode            92
#define iddDownloadImapFldrs           94

#define iddMsgProp_Security_Msg        95
#define iddMsgProp_Security_WIP        96
#define iddMsgProp_Security_Sent       97
#define iddSecCerificateErr            98

#define iddIMAPSubscribe               99


// "don't show me again" dialogs
// kept in (dontshow.dlg)
// these dialogs are message-box style with a checkbox
// of id==idchkDontShowMeAgain
#define iddDSSendMail                 100
#define iddDSSendNews                 101
#define iddDSWarnDeleteThread         102
#define iddDSCancelNews               103
#define iddDSAskSubscribe             104
#define iddHTMLSettings               105
#define iddPlainSettings              106
#define iddDSPostInOutbox             107
#define iddDSSavedInSavedItems        108
#define iddDSErrHTMLInNewsIsBad       109
#define iddDSNoteLost                 110
#define iddFolderProp_General         115
#define iddGroupProp_General          116
#define iddDSDefSubList               117   //Bug# 6473 (v-snatar)

#define iddNewsProp_Cache             121
#define iddGroupFilterEdit            125
#define iddInetMailError              126
#define iddFindNewsMsg                128
#define iddFindIMAPMsg                129
#define iddInsertLink                 130
#define iddDSGroupFilters             131
#define iddDSTooMuchQuoted            132
#define iddCreateFolder               133
#define iddSelectFolder               134
#define iddImapUploadProgress         135
#define iddImapCopyProgress           136
#define iddImapDownloadProgress       137
#define iddTransportErrorDlg          138
#define iddSpoolerDlg                 140
#define iddFrameWarning               141
#define iddUpdateNewsgroup            142
#define iddGroupProp_Update           143
#define iddRasStartup                 144
#define iddStationery                 145
#define iddIntlSetting                146
#define iddCharsetConflict            147
#define iddCharsetChange              148
#define iddTimeout                    149
#define iddSelectStationery           150
#define iddViewLayout                 152
#define iddImapDeleteFldr             153

#ifdef WIN16
#define iddFontSettings               154
#endif
#define iddErrSecurityNoSigningCert   155
#define iddImapUploadDraft            156
#define iddDSIMAPDeletedMessagesWarning 158
#define iddColumns                    160

//
// END Dialog Resource IDs (DIALOG resource ids, not control ids!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Dialog Control IDs (control ids, not DIALOG resource ids!)
//
// These only need to be unique within a single dialog.
//

// universal dialog stuff
#define IDC_STATIC                      -1
#define idcStatic1                      3500
#define idcStatic2                      3501
#define idcStatic3                      3502
#define idcStatic4                      3503
#define idcStatic5                      3504
#define idchkDontShowMeAgain            3505

// charset conflict dialog
#define idcSendAsUnicode                100

// version dialog
#define idcVerFirst                     101
#define idcVerLast                      103
#define idcVerList                      104

// WebPage dialog
#define idTxtWebPage                    1000

// header and note controls
#define NOTE_FIRST                      1000
#define idREBody                        (NOTE_FIRST + 0)
#define idADTo                          (NOTE_FIRST + 1)
#define idADNewsgroups                  (NOTE_FIRST + 2)
#define idADCc                          (NOTE_FIRST + 3)
#define idTXTSubject                    (NOTE_FIRST + 4)
#define idADFrom                        (NOTE_FIRST + 5)
#define idbtnTo                         (NOTE_FIRST + 7)
#define idbtnCc                         (NOTE_FIRST + 8)
#define idtbNoteWnd                     (NOTE_FIRST + 9)
#define idTTWnd                         (NOTE_FIRST + 10)
#define idStamp                         (NOTE_FIRST + 11)
#define idAttach                        (NOTE_FIRST + 12)
#define idREFmtbar                      (NOTE_FIRST + 13)
#define idNoteToolbar                   (NOTE_FIRST + 14)
#define idcNoteHdr                      (NOTE_FIRST + 15)
#define idTXTDate                       (NOTE_FIRST + 16)
#define idAttNoteBody                   (NOTE_FIRST + 17)
#define idTXTFollowupTo                 (NOTE_FIRST + 18)
#define idADReplyTo                     (NOTE_FIRST + 19)
#define idTXTOrg                        (NOTE_FIRST + 20)
#define idTXTDistribution               (NOTE_FIRST + 21)
#define idTXTKeywords                   (NOTE_FIRST + 22)
#define idADApproved                    (NOTE_FIRST + 23)
#define idbtnFollowup                   (NOTE_FIRST + 24)
#define idbtnReplyTo                    (NOTE_FIRST + 25)
#define idADBCc                         (NOTE_FIRST + 26)
#define idbtnBCc                        (NOTE_FIRST + 27)
#define idSecurity                      (NOTE_FIRST + 28)
#define idStatusbar                     (NOTE_FIRST + 29)
#define idTxtBkImage                    (NOTE_FIRST + 30)
#define idTxtControl                    (NOTE_FIRST + 31)
#define idCheckSendPicture              (NOTE_FIRST + 32)
#define idBrowsePicture                 (NOTE_FIRST + 33)
#define idVCardStamp                    (NOTE_FIRST + 34)
#define idNoteRebar                     (NOTE_FIRST + 35)

// dialog
#define idbtnSendPlain              101
#define idbtnSendHTML               102

// Tools.Spelling dialog
#define PSB_Spell_Ignore            101
#define PSB_Spell_IgnoreAll         102
#define PSB_Spell_Change            103
#define PSB_Spell_ChangeAll         104
#define PSB_Spell_Add               105
#define PSB_Spell_Suggest           106
#define PSB_Spell_UndoLast          107
#define EDT_Spell_WrongWord         108
#define TXT_Spell_Error             109
#define PSB_Spell_Options           110
#define TXT_Spell_Suggest           111
#define LBX_Spell_Suggest           112
#define EDT_Spell_ChangeTo          113
#define TXT_Spell_ChangeTo          114

#define CHK_AlwaysSuggest           202
#define CHK_CheckSpellingOnSend     203
#define CHK_IgnoreUppercase         204
#define CHK_IgnoreNumbers           205
#define CHK_IgnoreDBCS              206
#define CHK_IgnoreOriginalMessage   207
#define CHK_IgnoreURL               208

#define idcSpellLanguages           209
#define idcViewDictionary           210

#define GRP_SpellOptions            511
#define GRP_SpellIgnore             512

#define idtxtFolderName             101

#define IDC_CAPTION                 1049
#define IDC_TREEVIEW                1050
#define IDC_NEWFOLDER_BTN           1051

#define IDE_URL                     1052

//Mail Options
// now stored in mail/mailopt.h

// Folder dialogs

// message property sheets:
// now stored in inc/mpropdlg.h

#define idcTxtSubject                   125
#define idcTxtBody                      126
#define idcAttachCheck                  127
#define idcTxtFrom                      132
#define idcTxtRecip                     151
#define idcDateFrom                     153
#define idcDateTo                       154
#define idcFindNow                      155
#define idcStop                         156    
#define idcReset                        157
#define idcFindCombo                    158
#define idcSubFolders                   159


// Certificate error dlg
#define idcCertList 1234
#define idGetDigitalIDs 1235

#ifdef WIN16

#define IDC_UNUSED                              1300
#define IDC_FONTS_SCRIPTS_GROUPBOX              1301
#define IDC_FONTS_CODE_PAGES_LIST               1302
#define IDC_FONTS_PROP_FONT_COMBO               1303
#define IDC_FONTS_FIXED_FONT_COMBO              1304
#define IDC_FONTS_MIME_FONT_COMBO               1305
#define IDC_FONTS_SIZE_FONT_COMBO               1306
#define IDC_FONTS_SETDEFAULT_BUTTON             1307
#define IDC_FONTS_DEFAULT_LANG_TEXT             1308

#endif

//
// END Dialog Control IDs (control ids, not DIALOG resource ids!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Menu Resource IDs (MENU resources, not commands!)
//
#define idmrMailContext                 4
#define idmrColumnSort                  5
#define idmrFindPopContext              6
#define idmrStampPriority               7
#define idmrCtxtEdit                    8
#define idmrCtxtReadonly                9
#define idmrMailReadNote                10
#define idmrMailSendNote                11
#define idmrCtxtWell                    12
#define idmrNewsContext                 13
#define idmrFind                        14
#define idmrAttCtxSend                  16 
#define idmrAttCtxRead                  17 
#define idmrAttCtxNoSel                 18 
#define idmrAttPopupDrapDrop            19 
#define idmrNewsReadNote                20
#define idmrNewsSendNote                21
#define idmrAddrObjCtx                  23
#define idmrCoolbarContext              24        
#define idmrNewsServerContext           29 
#define idmrNewsGroupContext            30
#define idmrIMAPSpecialContext          31 
#define idmrLocalFolderContext          32 
#define idmrIMAPContext                 34
#define idmrLocalFolder                 38
#define idmrNewsFolder                  39
#define idmrIMAPFolder                  40
#define idmrCommonFolder                41
#define idmrMailSpecialContext          42
#define idmrIMAPServerContext           43
#define idmrIMAPFolderContext           44
#define idmrRootContext                 45
#define idmrIMAPOfflineFolder           46
#define idmrIMAPOfflineServer           47
#define idmrIMAPSyncFolder              48
#define idmrIMAPSyncServer              49
#define idmrNewsOfflineFolder           50
#define idmrNewsOfflineServer           51
#define idmrNewsSyncFolder              52
#define idmrNewsSyncServer              53
#define idmrStampVCard                  54
#define idmrDigSigPopup                 55
#define idmrEncryptionPopup             56
#define idmrStationeryPopup             57
#define idmrFindNewsContext             58

//
// END Menu Resource IDs (MENU resources, not commands!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Cursor Resource IDs
//
#define idcurSplitHoriz                 2
#define idcurSplitVert                  3
#define idcurHand                       4
//
// END Cursor Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN RCDATA Resource IDs
//
#define IDR_FIRST                       1

//
// END RCDATA Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Accelerator Resource IDs
//
#define idacBrowser                     1
#define idacNewsView                    2
#define idacMailView                    3
#define idacMail_ReadNote               4
#define idacNews_ReadNote               5
#define idacMail_SendNote               6
#define idacNews_SendNote               7
#define idacFolderNews                  8
#define idacFolderMail                  9
#define idacIMAPView                    10
#define idacFind                        11


//
// END Accelerator Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN import/export ids.
//
#define STR_IMP_FIRST                   23000

#define iddExport                       23602
#define iddImpProgress                  23603
#define iddMigrate                      23605
#define iddSelectClient                 23606
#define iddLocation                     23607
#define iddSelectFolders                23608
#define iddAddressComplete              23609
#define iddSelectCommUser               23610
#define iddSelectAth16User              23611
#define iddProvideMailPath              23612

#define IDC_IMPORTALL_RADIO             (STR_IMP_FIRST + 1000)
#define IDC_SELECT_RADIO                (STR_IMP_FIRST + 1001)
#define IDC_IMPFOLDER_LISTVIEW          (STR_IMP_FIRST + 1002)
#define IDC_IMPFOLDER_EDIT              (STR_IMP_FIRST + 1003)
#define IDC_SELECTFOLDER_BUTTON         (STR_IMP_FIRST + 1004)
#define IDC_NEWIMPFOLDER_EDIT           (STR_IMP_FIRST + 1005)
#define IDC_SKIPFOLDER_BUTTON           (STR_IMP_FIRST + 1008)
#define IDC_ERROR_STATIC                (STR_IMP_FIRST + 1009)
#define IDC_IMPORT_COMBO                (STR_IMP_FIRST + 1010)
#define IDC_CMD_STATIC                  (STR_IMP_FIRST + 1011)
#define IDC_IMPORT_PROGRESS             (STR_IMP_FIRST + 1012)
#define IDC_FOLDER_STATIC               (STR_IMP_FIRST + 1013)
#define IDC_MESSAGE_STATIC              (STR_IMP_FIRST + 1014)
#define idcClientsListbox               (STR_IMP_FIRST + 1015)
#define idcMessagesCheck                (STR_IMP_FIRST + 1016)
#define idcAddrBookCheck                (STR_IMP_FIRST + 1017)
#define IDC_LOCATION_STATIC             (STR_IMP_FIRST + 1018)
#define IDC_LABEL                       (STR_IMP_FIRST + 1019)
#define IDC_USERLIST                    (STR_IMP_FIRST + 1020)
#define IDC_BUTT1                       (STR_IMP_FIRST + 1021)
#define IDC_EDT1                        (STR_IMP_FIRST + 1022)

#define IDB_IMPORT                      24023

#define idsOutOfMemory                  (STR_IMP_FIRST + 1)
#define idsNotEnoughDiskSpace           (STR_IMP_FIRST + 2)
#define idsImport                       (STR_IMP_FIRST + 3)
#define idsPerformExport                (STR_IMP_FIRST + 4)
#define idsExport                       (STR_IMP_FIRST + 5)
#define idsExportTitle                  (STR_IMP_FIRST + 6)
#define idsImportTitle                  (STR_IMP_FIRST + 7)
#define idsImportingFolderFmt           (STR_IMP_FIRST + 11)
#define idsExportingFolderFmt           (STR_IMP_FIRST + 12)
#define idsImportingMessageFmt          (STR_IMP_FIRST + 13)
#define idsExportError                  (STR_IMP_FIRST + 14)
#define idsMAPIStoreOpenError           (STR_IMP_FIRST + 15)
#define idsMAPIInitError                (STR_IMP_FIRST + 16)
#define idsAddressUnknownFmt            (STR_IMP_FIRST + 17)
#define idsFolderOpenFail               (STR_IMP_FIRST + 18)
#define idsFolderReadFail               (STR_IMP_FIRST + 19)
#define idsFolderImportErrorFmt         (STR_IMP_FIRST + 20)
#define idsOut                          (STR_IMP_FIRST + 22)
#define idsTrash                        (STR_IMP_FIRST + 23)
#define idsEudora                       (STR_IMP_FIRST + 25)
#define idsNetscape                     (STR_IMP_FIRST + 26)
#define idsImportABTitle                (STR_IMP_FIRST + 27)
#define idsImportAB                     (STR_IMP_FIRST + 28)
#define idsImportingABFmt               (STR_IMP_FIRST + 29)
#define idsBrowseFolderText             (STR_IMP_FIRST + 30)
#define idsLocationUnknown              (STR_IMP_FIRST + 31)
#define idsLocationInvalid              (STR_IMP_FIRST + 32)
#define idsCancelWizard                 (STR_IMP_FIRST + 33)
#define idsMsgsOrAddrs                  (STR_IMP_FIRST + 34)
#define idsABImportError                (STR_IMP_FIRST + 35)
#define idsExchange                     (STR_IMP_FIRST + 36)
#define idsCommunicator                 (STR_IMP_FIRST + 37)
#define idsMapiInitError                (STR_IMP_FIRST + 38)
#define idsNoMapiProfiles               (STR_IMP_FIRST + 39)
#define idsMapiImportFailed             (STR_IMP_FIRST + 40)
#define idsSelectFolders                (STR_IMP_FIRST + 41)


// END import/export ids.
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN window ids.
//

#define idwAttachWell   1000

// END window ids
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN indices into the toolbar button bitmap
//
enum {
    itbNewMsg = 0,
    itbPrint,
    itbCut,
    itbCopy,
    itbPaste,
    itbUndo,
    itbDelete,
    itbFind,
    itbGotoInbox,
    itbDeliverNowUsingAll,
    itbReply,
    itbReplyAll,
    itbForward,
    itbSend,
    itbSaveAs,
    itbPickRecipients,
    itbCheckNames,
    itbAttach,
    itbNext,
    itbPrevious,
    itbNextUnreadArticle,
    itbNextUnreadThread,
    itbNextUnreadSubscr,
    itbMarkAsRead,
    itbDisconnect,
    itbNewPost,
    itbMarkDownload,
    itbReplyByPost,
    itbConnect,
    itbMarkTopicRead,
    itbMarkAllRead,
    itbMarkTopicDownload,
    itbNextTopic,
    itbInsertSig,
    itbPostNow,
    itbViewContacts,
    itbEncrypted,
    itbSigned,
    itbSetPriority,
    ctbBtns
    };


// FormatBar stuff
enum 
    {
    itbFormattingTag,
    itbFormattingBold,
    itbFormattingItalic,
    itbFormattingUnderline,
    itbFormattingColor,
    itbFormattingNumbers,
    itbFormattingBullets,
    itbFormattingDecreaseIndent,
    itbFormattingIncreaseIndent,
    itbFormattingLeft,
    itbFormattingCenter,
    itbFormattingRight,
    itbFormattingInsertHLine,
    itbFormattingInsertLink,
    itbFormattingInsertImage,
    ctbFormatting
    };

// Folder bitmap stuff
// Do NOT move the first two entries beyond 14.
enum 
    {
    iNullBitmap = 0,
    iDisconnected,
    iFolderClosed,
    iInbox,
    iOutbox,
    iSendMail,
    iWastebasket,
    iFolderDraft,
    iNewsGroup,
    iNewsServer,
    iPostFolder,
    iUnsubGroup,
    iUnsubServer,
    iSortAsc,
    iSortDesc,
    iMailServer,
    iMailServerGrayed,
    iMailRoot,
    iInboxFull,
    iOutboxFull,
    iWastebasketFull,
    iFolderFull,
    iMailTrust,
    iFolderOpen,
    iFolderUnsub,
    iNewsSavedItems,
    iMailNews,
    iLDAPServer,
    iNewsGroupSync
    };
    
// Coolbar bitmaps
enum
    {    
    iCBBack = 0,
    iCBNext,
    iCBNewArticle,
    iCBReplyPost,
    iCBReplyAll,
    iCBForward,
    iCBPrint,
    iCBNewsgroup,
    iCBNewMessage,
    iCBReplyMail,
    iCBDeliverNow,
    iCBNextUnreadArt,
    iCBNextUnreadThread,
    iCBNextUnreadGroup,
    iCBDelete,
    iCBGotoInbox,
    iCBGotoOutbox,
    iCBGotoPosted,
    iCBGotoSentItems,
    iCBAddressBook,
    iCBSaveAs,
    iCBFind,
    iCBNextMsg,
    iCBPrevMsg,
    iCBMarkRead,
    iCBMarkThreadRead,
    iCBMarkAllRead,
    iCBMarkAsUnread,
    iCBStop,
    iCBRefresh,
    iCBHelp,
    iCBMarkDownload,
    iCBMarkThreadDownload,
    iCBMarkAllDownload,
    iCBCancelPost,
    iCBMailMarkUnRead,
    iCBMailMarkRead,
    iCBMarkNewsgroups,
    iCBCombineAndDecode,
    iCBPostAndDownload,
    iCBGetNext300Headers,
    iCBUnscramble,
    iCBUnmarkDownload,
    iCBReplyPostAndMail,
    iCBMoveTo,
    iCBCopyTo,
    iCBConnect,
    iCBDisconnect,
    iCBUpOneLevel,
    iCBShowHideTree,
    iCBLanguage,
    iCBDownloadAccount,
    iCBDownloadNewsgroup,
    iCBPurgeDeletedMessages,
    iCBWorkOffline,
    iCBCoolbarMax,
    };

enum {    
    iCBEncryption,
    iCBSigning,
    iCBBadEnc,
    iCBBadSign,
    iCBPaperclip,
    iCBVCard,
    };

// Folder State bitmap stuff
enum 
    {
    iDownloadHeaders = 0,
    iDownloadNew,
    iDownloadAll,
    iStateMax
    };

enum 
    {
    iColorMenu = 0,
    iColorCombo,
    iColorMax
    };
    
//
// END indices into the toolbar button bitmap
//
/////////////////////////////////////////////////////////////////////////////


#endif // __RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\badata.cpp ===
// badata.cpp: implementation of the CAddressBook class.
// WAB & Messenger integration to OE
// Created 04/20/98 by YST
//
//////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include <commctrl.h>
#include "msoert.h"
#include "bactrl.h"
#include "badata.h"
#include "baui.h"
#include "baprop.h"
#include "shlwapi.h" 
#include "ourguid.h"
#include "mapiguid.h"
#include "shlwapip.h" 

// #include "ipab.h"
// #include "multiusr.h"
// #include "demand.h"
// #include "secutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define WAB_USE_OUTLOOK_CONTACT_STORE 0x10000000// Note: This internal flag needs to be
                                                // harmonious with external flags defined 
                                                // in wabapi.h for WAB_PARAM structs


//////////////////////////////////////////////////////////////////////
// Defines for the various MAPI Tables we request from the WAB
//////////////////////////////////////////////////////////////////////

#define MAX_QUERY_SIZE 1000

// Here are some private properties that the WAB stores
#define WAB_INTERNAL_BASE       0x6600
#define PR_WAB_LDAP_SERVER      PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 1)
#define PR_WAB_RESOLVE_FLAG     PROP_TAG(PT_BOOLEAN,    WAB_INTERNAL_BASE + 2)


// This BA's private GUID:
// {2BAD7EE0-36AB-11d1-9BAC-00A0C91F9C8B}
static const GUID WAB_ExtBAGuid = 
{ 0x2bad7ee0, 0x36ab, 0x11d1, { 0x9b, 0xac, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b } };

static const LPTSTR lpMsgrPropNames[] = 
{   
    "MsgrID"
};

enum _MsgrTags
{
    MsgrID = 0,
    msgrMax
};

ULONG MsgrPropTags[msgrMax];
ULONG PR_MSGR_DEF_ID = 0;


// These two define the table we request from the WAB when showing the
// contents of the local address book.

enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidPR_OBJECT_TYPE,
    ieidPR_MSGR_DEF_ID,
    ieidPR_HOME_TELEPHONE_NUMBER,
    ieidPR_BUSINESS_TELEPHONE_NUMBER,
    ieidPR_MOBILE_TELEPHONE_NUMBER,
//    ieidPR_WAB_IPPHONE,
    ieidPR_EMAIL_ADDRESS, 
    ieidPR_USER_X509_CERTIFICATE,
    ieidPR_RECORD_KEY,
    ieidMax
};

static SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME_W,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        0,
        PR_HOME_TELEPHONE_NUMBER_W,
        PR_BUSINESS_TELEPHONE_NUMBER_W,
        PR_MOBILE_TELEPHONE_NUMBER_W,
//        PR_WAB_IPPHONE,
        PR_EMAIL_ADDRESS_W, 
        PR_USER_X509_CERTIFICATE,
        PR_RECORD_KEY
    }
};


// These two define the table we request to see which LDAP servers should
// be resolved against.
enum {
    irnPR_OBJECT_TYPE = 0,
    irnPR_WAB_RESOLVE_FLAG,
    irnPR_ENTRYID,
    irnPR_DISPLAY_NAME,
    irnMax
};

static const SizedSPropTagArray(irnMax, irnColumns) =
{
    irnMax,
    {
        PR_OBJECT_TYPE,
        PR_WAB_RESOLVE_FLAG,
        PR_ENTRYID,
        PR_DISPLAY_NAME_W,
    }
};


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};

const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};


// --------------------------------------------------------------------------
// PszAllocW
// --------------------------------------------------------------------------
LPWSTR IEPszAllocW(INT nLen)
{
    // Locals
    LPWSTR  pwsz=NULL;

    // Empty ?
    if (nLen == 0)
        goto exit;

    // Allocate
    if (FAILED(HrAlloc((LPVOID *)&pwsz, (nLen + 1) * sizeof (WCHAR))))
        goto exit;
    
exit:
    // Done
    return pwsz;
}

// --------------------------------------------------------------------------
// IEPszToUnicode
// --------------------------------------------------------------------------
LPWSTR IEPszToUnicode(UINT cp, LPCSTR pcszSource)
{
    // Locals
    INT         cchNarrow,
                cchWide;
    LPWSTR      pwszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Length
    cchNarrow = lstrlenA(pcszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, NULL, 0);

    // Error
    if (cchWide == 0)
        goto exit;

    // Alloc temp buffer
    pwszDup = IEPszAllocW(cchWide + 1);
    if (!pwszDup)
        goto exit;

    // Do the actual translation
	cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, pwszDup, cchWide+1);

    // Error
    if (cchWide == 0)
    {
        SafeMemFree(pwszDup);
        goto exit;
    }

exit:
    // Done
    return pwszDup;
}



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAddressBookData::CAddressBookData()
{
    m_pWABObject = NULL;
    m_hInstWAB = NULL;
    m_pAdrBook = NULL;
    m_ulConnection = 0;
}


CAddressBookData::~CAddressBookData()
{
    // Release the Address Book pointer
    SafeRelease(m_pAdrBook);

    // Release the WAB object
    SafeRelease(m_pWABObject);

    if (m_hInstWAB)
    {
        FreeLibrary(m_hInstWAB);
        m_hInstWAB = NULL;
    }
}

//
//  FUNCTION:   CAddressBookData::OpenWabFile()
//
//  PURPOSE:    Finds the WAB DLL, loads the DLL, and opens the WAB.
//
HRESULT CAddressBookData::OpenWabFile(BOOL fWAB)
{
    TCHAR       szDll[MAX_PATH];
    TCHAR       szExpanded[MAX_PATH];
    DWORD       dwType = 0;
    LPTSTR      psz = szDll;
    ULONG       cbData = sizeof(szDll);
    HKEY        hKey = NULL;
    HRESULT     hr = E_FAIL;
    LPWABOPEN   lpfnWABOpen;

    // Initialize the path string
    *szDll = '\0';

    // First look under the default WAB DLL path location in the Registry.
    // WAB_DLL_PATH_KEY is defined in wabapi.h
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, _T(""), NULL, &dwType, (LPBYTE) szDll, &cbData))
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szDll, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }

        RegCloseKey(hKey);
    }

    // If the registry thing came up blank, then do a LoadLibrary on wab32.dll
    m_hInstWAB = LoadLibrary((lstrlen(psz)) ? (LPCTSTR) psz : (LPCTSTR) WAB_DLL_NAME);

    if (m_hInstWAB)
    {
        // If we've got the DLL, then get the entry point
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hInstWAB, "WABOpen");

        if (lpfnWABOpen)
        {
            WAB_PARAM       wp = {0};
            wp.cbSize = sizeof(WAB_PARAM);
            wp.guidPSExt = CLSID_IEMsgAb;
            wp.ulFlags = WAB_ENABLE_PROFILES | WAB_USE_OE_SENDMAIL;
            if(!fWAB)
            {
                wp.ulFlags = wp.ulFlags | WAB_USE_OUTLOOK_CONTACT_STORE;
                hr = lpfnWABOpen(&m_pAdrBook, &m_pWABObject, &wp, 0);
                if(hr == S_OK)
                    return (hr);  // in error case, try to open WAB
                else
                    wp.ulFlags = WAB_ENABLE_PROFILES | WAB_USE_OE_SENDMAIL;
            }
            hr = lpfnWABOpen(&m_pAdrBook, &m_pWABObject, &wp, 0);

        }
    }
    if(!m_pAdrBook || !m_pWABObject || FAILED(hr))
    {
        WCHAR wszTitle[CCHMAX_STRINGRES];
        WCHAR wszMsg[CCHMAX_STRINGRES];

        if(!AthLoadString(idsAthena, wszTitle, ARRAYSIZE(wszTitle)))
            wszTitle[0] = L'\0';

        if(!AthLoadString(idsWabNotFound, wszMsg, ARRAYSIZE(wszMsg)))
            wszMsg[0] = L'\0';

        MessageBoxW(NULL, wszMsg, wszTitle, MB_OK | MB_ICONSTOP);
    }
    return (hr);
}



//
//  FUNCTION:   CAddressBookData::LoadWabContents()
//
//  PURPOSE:    Loads the contents of the WAB into the provided ListView control.
//
//  PARAMETERS: 
//      [in] ctlList - Pointer to the ListView control to load the WAB into.
//
HRESULT CAddressBookData::LoadWabContents(CContainedWindow& ctlList, CIEMsgAb *pSink)
{
    ULONG       ulObjType = 0;
    LPMAPITABLE lpAB =  NULL;
    LPTSTR     *lppszArray = NULL;
    ULONG       cRows = 0;
    LPSRowSet   lpRow = NULL;
    LPSRowSet   lpRowAB = NULL;
    LPABCONT    lpContainer = NULL;
    int         cNumRows = 0;
    int         nRows = 0;
    HRESULT     hr = E_FAIL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;
    LPSRowSet   pSRowSet = NULL;

    Assert(m_pAdrBook);
    if (!m_pAdrBook)
        return E_UNEXPECTED;

    // Get the entryid of the root PAB container
    hr = m_pAdrBook->GetPAB(&lpcbEID, &lpEID);

    if(!PR_MSGR_DEF_ID)
        InitNamedProps();

    // Open the root PAB container.  This is where all the WAB contents reside.
    ulObjType = 0;
    hr = m_pAdrBook->OpenEntry(lpcbEID,
                               (LPENTRYID)lpEID,
                               NULL,
                               0,
                               &ulObjType,
                               (LPUNKNOWN *) &lpContainer);

    if(HR_FAILED(hr))
        goto exit;

    if(pSink)
        m_pAB = pSink;

#ifdef LATER
    if (pSink && !m_ulConnection)
        m_pAdrBook->Advise(lpcbEID, lpEID, fnevObjectModified, (IMAPIAdviseSink *) pSink, &m_ulConnection);
#endif

    // Get a contents table of all the contents in the WABs root container.
    hr = lpContainer->GetContentsTable(WAB_PROFILE_CONTENTS  | MAPI_UNICODE, &lpAB);
    if(HR_FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the ones we want
    // - which are mainly DisplayName, EntryID and ObjectType.  The table is 
    // guaranteed to set the columns in the order requested.
    Assert(PR_MSGR_DEF_ID);
    ptaEid.aulPropTag[ieidPR_MSGR_DEF_ID] = PR_MSGR_DEF_ID;
    hr = lpAB->SetColumns((LPSPropTagArray) &ptaEid, 0);
    if(HR_FAILED(hr))
        goto exit;

    // Reset to the beginning of the table
    hr = lpAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
    if(HR_FAILED(hr))
        goto exit;

    // If we got this far, we have a populated table.  We can query the rows
    // now.
    hr = _QueryAllRows(lpAB, NULL, NULL, NULL, MAX_QUERY_SIZE, &pSRowSet);
    if (FAILED(hr) || !pSRowSet)
        goto exit;
    
    // Fill the provided ListView with this table
    _FillListFromTable(ctlList, pSRowSet);

exit:
    if (lpEID)
        m_pWABObject->FreeBuffer(lpEID);

    if (pSRowSet)
        _FreeProws(pSRowSet);

    if (lpContainer)
        lpContainer->Release();

    if (lpAB)
        lpAB->Release();

    return hr;
}


HRESULT CAddressBookData::DoLDAPSearch(LPTSTR pszText, CContainedWindow& ctlList)
{
    // Build a restriction based on the given text
    SRestriction SRes;
    if (SUCCEEDED(_GetLDAPSearchRestriction(pszText, &SRes)))
    {
        // Figure out what the entry ID is for the LDAP container
        ULONG     cbEntryID = 0;
        LPENTRYID pEntryID = 0;

        if (SUCCEEDED(_GetLDAPContainer(&cbEntryID, &pEntryID)))
        {
            // Perform the search
            SORT_INFO si = {0, 0};
            _GetLDAPContentsList(cbEntryID, pEntryID, si, &SRes, ctlList);

            if (pEntryID)
                m_pWABObject->FreeBuffer(pEntryID);

        }

        if (SRes.res.resAnd.lpRes)
            m_pWABObject->FreeBuffer(SRes.res.resAnd.lpRes);
    }

    return (S_OK);
}
    
    
void CAddressBookData::_FreeProws(LPSRowSet prows)
{
    if (prows)
    {
        for (ULONG irow = 0; irow < prows->cRows; ++irow)
            m_pWABObject->FreeBuffer(prows->aRow[irow].lpProps);

        m_pWABObject->FreeBuffer(prows);
    }
}


//
//  FUNCTION:   CAddressBookData::_MergeRowSets()
//
//  PURPOSE:    Merges prows with *pprowsDst, reallocating *pprowsDst if 
//              necessary.  Destroys the container portion of prows (but not 
//              the individual rows it contains).
//
//  PARAMETERS: 
//      [in]       prows     - source set of rows
//      [in, out] *pprowsDst - set of rows to merge the prows into 
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CAddressBookData::_MergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst)
{
    SCODE       sc = S_OK;
    LPSRowSet   prowsT;
    UINT        crowsSrc;
    UINT        crowsDst;

    _ASSERTE(!IsBadWritePtr(pprowsDst, sizeof(LPSRowSet)));
    _ASSERTE(prows);

    // If the table is completely empty we want to return this.
    if (!*pprowsDst || (*pprowsDst)->cRows == 0)
    {
        m_pWABObject->FreeBuffer(*pprowsDst);
        *pprowsDst = prows;
        prows = NULL;                           // Don't free it!
        goto exit;
    }

    if (prows->cRows == 0)
    {
        goto exit;
    }

    // OK, now we know there are rows in both rowsets, we have to do a real 
    // merge.
    crowsSrc = (UINT) prows->cRows;
    crowsDst = (UINT) (*pprowsDst)->cRows;      //  handle 0

    if (FAILED(sc = m_pWABObject->AllocateBuffer(CbNewSRowSet(crowsSrc + crowsDst), (LPVOID*) &prowsT)))
        goto exit;
    if (crowsDst)
        CopyMemory(prowsT->aRow, (*pprowsDst)->aRow, crowsDst * sizeof(SRow));
    CopyMemory(&prowsT->aRow[crowsDst], prows->aRow, crowsSrc * sizeof(SRow));
    prowsT->cRows = crowsSrc + crowsDst;

    m_pWABObject->FreeBuffer(*pprowsDst);
    *pprowsDst = prowsT;

exit:
    // if (prows)
    //     m_pWABObject->FreeBuffer(&prows);

    return ResultFromScode(sc);
}


/*
 -	HrQueryAllRows
 -	
 *	Purpose:
 *		Retrieves all rows from an IMAPITable interface up to a set
 *		maximum. It will optionally set the column set, sort order,
 *		and restriction on the table before querying.
 *	
 *		If the table is empty, an SRowSet with zero rows is
 *		returned (just like QueryRows).
 *	
 *		The seek position of the table is undefined both before and
 *		after this call.
 *	
 *		If the function fails with an error other than
 *		MAPI_E_NOT_ENOUGH_MEMORY, extended error information is
 *		available through the table interface.
 *	
 *	Arguments:
 *		ptable		in		the table interface to query
 *		ptaga		in		if not NULL, column set for the table
 *		pres		in		if not NULL, restriction to be applied
 *		psos		in		if not NULL, sort order to be applied
 *		crowsMax	in		if nonzero, limits the number of rows
 *							to be returned.
 *		pprows		out		all rows of the table
 *	
 *	Returns:
 *		HRESULT. Extended error information normally is in the
 *		table.
 *	
 *	Side effects:
 *		Seek position of table is undefined.
 *	
 *	Errors:
 *		MAPI_E_TABLE_TOO_BIG if the table contains more than
 *		cRowsMax rows.
 */
HRESULT CAddressBookData::_QueryAllRows(LPMAPITABLE ptable,
	                                LPSPropTagArray ptaga, 
                                    LPSRestriction pres, 
                                    LPSSortOrderSet psos,
	                                LONG crowsMax, 
                                    LPSRowSet FAR *pprows)
{
	HRESULT		hr;
	LPSRowSet	prows = NULL;
	UINT		crows = 0;
	LPSRowSet	prowsT=NULL;
	UINT		crowsT;

	*pprows = NULL;

	// Set up the table, if the corresponding setup parameter is present.
	if (ptaga && FAILED(hr = ptable->SetColumns(ptaga, TBL_BATCH)))
		goto exit;
	if (pres && FAILED(hr = ptable->Restrict(pres, TBL_BATCH)))
		goto exit;
	if (psos && FAILED(hr = ptable->SortTable(psos, TBL_BATCH)))
		goto exit;

	// Set position to beginning of the table.
	if (FAILED(hr = ptable->SeekRow(BOOKMARK_BEGINNING, 0, NULL)))
		goto exit;

	if (crowsMax == 0)
		crowsMax = 0xffffffff;

	for (;;)
	{
		prowsT = NULL;

		// Retrieve some rows. Ask for the limit.
		hr = ptable->QueryRows(crowsMax, 0, &prowsT);
		if (FAILED(hr))
		{
			// Note: the failure may actually have happened during one of the 
            // setup calls, since we set TBL_BATCH.
			goto exit;
		}
		_ASSERTE(prowsT->cRows <= 0xFFFFFFFF);
		crowsT = (UINT) prowsT->cRows;

		// Did we get more rows than caller can handle?
		if ((LONG) (crowsT + (prows ? prows->cRows : 0)) > crowsMax)
		{
			hr = ResultFromScode(MAPI_E_TABLE_TOO_BIG);
			//_FreeProws(prowsT);
			goto exit;
		}

		// Add the rows just retrieved into the set we're building.		
        //
        // NOTE: this handles boundary conditions including either row set is 
        // empty.
        // 
		// NOTE: the merge destroys prowsT.
		if (FAILED(hr = _MergeRowSets(prowsT, &prows)))
			goto exit;

		// Did we hit the end of the table? Unfortunately, we have to ask twice 
        // before we know.
		if (crowsT == 0)
			break;
	}

    if(prows->cRows != 0)
	    *pprows = prows;

exit:
    if (prowsT)
        _FreeProws(prowsT);

	if (FAILED(hr))
		_FreeProws(prows);

	return hr;
}


HRESULT CAddressBookData::_GetLDAPContainer(ULONG *pcbEntryID, LPENTRYID *ppEntryID)
{
    ULONG           ulObjectType = 0;
    IABContainer   *pRoot = 0;
    LPMAPITABLE     pRootTable = 0;
    HRESULT         hr = S_OK;

    // Get the root Address Book container
    hr = m_pAdrBook->OpenEntry(0, NULL, NULL, 0, &ulObjectType, (LPUNKNOWN *) &pRoot);
    if (FAILED(hr))
        goto exit;

    // From the address book container, get a table of it's contents
    hr = pRoot->GetContentsTable(0, &pRootTable);
    if (FAILED(hr))
        goto exit;

    // Set the columns
    pRootTable->SetColumns((LPSPropTagArray) &irnColumns, 0);

    // Build a restriction to only display LDAP servers that we're supposed
    // to resolve against.
    SRestriction resAnd[2];         // 0 = LDAP, 1 = ResolveFlag
    SRestriction resLDAPResolve;
    SPropValue   ResolveFlag;

    // Restrict: Only show LDAP containers with Resolve TRUE
    resAnd[0].rt = RES_EXIST;
    resAnd[0].res.resExist.ulReserved1 = 0;
    resAnd[0].res.resExist.ulReserved2 = 0;
    resAnd[0].res.resExist.ulPropTag = PR_WAB_LDAP_SERVER;

    ResolveFlag.ulPropTag = PR_WAB_RESOLVE_FLAG;
    ResolveFlag.Value.b = TRUE;

    resAnd[1].rt = RES_PROPERTY;
    resAnd[1].res.resProperty.relop = RELOP_EQ;
    resAnd[1].res.resProperty.ulPropTag = PR_WAB_RESOLVE_FLAG;
    resAnd[1].res.resProperty.lpProp = &ResolveFlag;

    resLDAPResolve.rt = RES_AND;
    resLDAPResolve.res.resAnd.cRes = 2;
    resLDAPResolve.res.resAnd.lpRes = resAnd;

    // Apply the restruction
    hr = pRootTable->Restrict(&resLDAPResolve, 0);
    if (HR_FAILED(hr))
        goto exit;

    // We're going to just blindly grab the first item in this table as the
    // LDAP container we're going to use.
    LPSRowSet pRowSet;
    hr = pRootTable->QueryRows(1, 0, &pRowSet);
    if (FAILED(hr))
        goto exit;

    // Grab the size of the entry id
    *pcbEntryID = pRowSet->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.cb;

    // Make a copy of the entry id
    hr = m_pWABObject->AllocateBuffer(*pcbEntryID, (LPVOID *) ppEntryID);
    if (FAILED(hr))
        goto exit;

    CopyMemory(*ppEntryID, pRowSet->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.lpb, 
               *pcbEntryID);

exit:
    if (pRootTable)
        pRootTable->Release();

    if (pRoot)
        pRoot->Release();

    if (pRowSet)
        _FreeProws(pRowSet);

    return (hr);
}


HRESULT CAddressBookData::_GetLDAPSearchRestriction(LPTSTR pszText, LPSRestriction lpSRes)
{
    SRestriction    SRes = { 0 };
    LPSRestriction  lpPropRes = NULL;
    ULONG           ulcPropCount = 0;
    HRESULT         hr = E_FAIL;
    ULONG           i = 0;
    SCODE           sc = ERROR_SUCCESS;
    LPSPropValue    lpPropArray = NULL;


    if (!lstrlen(pszText))
    {
        ATLTRACE(_T("No Search Props"));
        goto exit;
    }

    lpSRes->rt = RES_AND;
    lpSRes->res.resAnd.cRes = 1;

    // Allocate a buffer for the restriction
    lpSRes->res.resAnd.lpRes = NULL;
    sc = m_pWABObject->AllocateBuffer(1 * sizeof(SRestriction), 
                                      (LPVOID *) &(lpSRes->res.resAnd.lpRes));
    if (S_OK != sc || !(lpSRes->res.resAnd.lpRes))
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropRes = lpSRes->res.resAnd.lpRes;

    // Create the first part of the OR clause
    lpPropRes[0].rt = RES_PROPERTY;
    lpPropRes[0].res.resProperty.relop = RELOP_EQ;
    lpPropRes[0].res.resProperty.ulPropTag = PR_EMAIL_ADDRESS;

    lpPropRes[0].res.resProperty.lpProp = NULL;
    m_pWABObject->AllocateMore(sizeof(SPropValue), lpPropRes, (LPVOID*) &(lpPropRes[0].res.resProperty.lpProp));
    lpPropArray = lpPropRes[0].res.resProperty.lpProp;
    if (!lpPropArray)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropArray->ulPropTag = PR_EMAIL_ADDRESS;
    lpPropArray->Value.LPSZ = NULL;

    m_pWABObject->AllocateMore(lstrlen(pszText) + 1, lpPropRes, (LPVOID *) &(lpPropArray->Value.LPSZ));
    if (!lpPropArray->Value.LPSZ)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lstrcpy(lpPropArray->Value.LPSZ, pszText);

#if 0
    // Add the second OR clause
    lpPropRes[1].rt = RES_PROPERTY;
    lpPropRes[1].res.resProperty.relop = RELOP_EQ;
    lpPropRes[1].res.resProperty.ulPropTag = PR_DISPLAY_NAME;

    lpPropRes[1].res.resProperty.lpProp = NULL;
    m_pWABObject->AllocateMore(sizeof(SPropValue), lpPropRes, (LPVOID*) &(lpPropRes[1].res.resProperty.lpProp));
    lpPropArray = lpPropRes[1].res.resProperty.lpProp;
    if (!lpPropArray)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropArray->ulPropTag = PR_DISPLAY_NAME;
    lpPropArray->Value.LPSZ = NULL;

    m_pWABObject->AllocateMore(lstrlen(pszText) + 1, lpPropRes, (LPVOID *) &(lpPropArray->Value.LPSZ));
    if (!lpPropArray->Value.LPSZ)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lstrcpy(lpPropArray->Value.LPSZ, pszText);
#endif

    hr = S_OK;

exit:
    return hr;
}


HRESULT CAddressBookData::_GetLDAPContentsList(ULONG cbContainerEID,
                                           LPENTRYID pContainerEID,
                                           SORT_INFO rSortInfo,
                                           LPSRestriction pPropRes,
                                           CContainedWindow& ctlList)
{
    HRESULT          hr = S_OK;
    HRESULT          hrTemp;
    ULONG            ulObjectType = 0;
    LPMAPICONTAINER  pContainer = NULL;
    LPMAPITABLE      pContentsTable = NULL;
    LPSRowSet        pSRowSet = NULL;

    // Open the container object corresponding to pContainerEID
    hr = m_pAdrBook->OpenEntry(cbContainerEID, pContainerEID, NULL, 0, 
                               &ulObjectType, (LPUNKNOWN *) &pContainer);
    if (FAILED(hr))
        goto exit;

    // Get the contents table from this container
    hr = pContainer->GetContentsTable(0, &pContentsTable);
    if (FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the ones we want
    // - which are mainly DisplayName, EntryID and ObjectType.  The table is 
    // guaranteed to set the columns in the order requested.
    Assert(PR_MSGR_DEF_ID);
    ptaEid.aulPropTag[ieidPR_MSGR_DEF_ID] = PR_MSGR_DEF_ID;
    hr = pContentsTable->SetColumns((LPSPropTagArray) &ptaEid, 0);
    if(HR_FAILED(hr))
        goto exit;

    // Do the find
    hr = pContentsTable->FindRow(pPropRes, BOOKMARK_BEGINNING, 0);
    if (FAILED(hr))
        goto exit;

    // If this was a partial completion error, we want to continue but also
    // return this information to the caller
    if (MAPI_W_PARTIAL_COMPLETION == hr)
        hrTemp = hr;

    // If we got this far, we have a populated table.  We can query the rows
    // now.
    hr = _QueryAllRows(pContentsTable, NULL, NULL, NULL, MAX_QUERY_SIZE, &pSRowSet);
    if (FAILED(hr) || !pSRowSet)
        goto exit;

    // Fill in the ListView from the table
    _FillListFromTable(ctlList, pSRowSet, TRUE);

exit:
    if (pSRowSet)
        _FreeProws(pSRowSet);

    if (pContentsTable)
        pContentsTable->Release();

    if (pContainer)
        pContainer->Release();

    return (hr);
}


HRESULT CAddressBookData::_FillListFromTable(CContainedWindow& ctlList, LPSRowSet pSRowSet, BOOL bLDAP)
{
    LPSBinary lpSB;
    PNONEENTRIES Phones;

    // Make sure the caller passed us a rowset
    Assert(pSRowSet);
    Assert(PR_MSGR_DEF_ID);

    // Loop through the rows in the rowset
    for (ULONG i = 0; i < pSRowSet->cRows; i++)
    {
        // Get the information out of the table that we need.  Right now we're 
        // grabbing the entry ID, the display name, and the business phone number.
        LPENTRYID lpEID = (LPENTRYID) pSRowSet->aRow[i].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
        ULONG     cbEID = pSRowSet->aRow[i].lpProps[ieidPR_ENTRYID].Value.bin.cb;
        DWORD     nFlag = (pSRowSet->aRow[i].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_DISTLIST) ? MAB_GROUP : MAB_CONTACT;
        LPWSTR    lpwszID = NULL;
        LPWSTR    lpwszName = NULL;
        
        if(nFlag == MAB_CONTACT)
        {
            if(pSRowSet->aRow[i].lpProps[ieidPR_USER_X509_CERTIFICATE].ulPropTag == PR_USER_X509_CERTIFICATE)
                nFlag |= MAB_CERT;
        }

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_MSGR_DEF_ID/*ieidPR_EMAIL_ADDRESS*/].ulPropTag) == PT_UNICODE )
        {
            nFlag = nFlag | MAB_BUDDY;
            lpwszID = pSRowSet->aRow[i].lpProps[ieidPR_MSGR_DEF_ID/*ieidPR_EMAIL_ADDRESS*/].Value.lpszW;
        }
        else if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_EMAIL_ADDRESS].ulPropTag) == PT_UNICODE )
            lpwszID = pSRowSet->aRow[i].lpProps[ieidPR_EMAIL_ADDRESS].Value.lpszW;
        else
            lpwszID = NULL;

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_DISPLAY_NAME].ulPropTag) == PT_UNICODE )
            lpwszName = pSRowSet->aRow[i].lpProps[ieidPR_DISPLAY_NAME].Value.lpszW;
        else
            lpwszName = lpwszID;
        
        // LPTSTR    lpszPhone = pSRowSet->aRow[i].lpProps[ieidPR_BUSINESS_TELEPHONE_NUMBER].Value.lpszW;
        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_HOME_TELEPHONE_NUMBER].ulPropTag) == PT_UNICODE )
            Phones.pchHomePhone = pSRowSet->aRow[i].lpProps[ieidPR_HOME_TELEPHONE_NUMBER].Value.lpszW;
        else
            Phones.pchHomePhone = NULL;

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_BUSINESS_TELEPHONE_NUMBER].ulPropTag) == PT_UNICODE )
            Phones.pchWorkPhone = pSRowSet->aRow[i].lpProps[ieidPR_BUSINESS_TELEPHONE_NUMBER].Value.lpszW;
        else
            Phones.pchWorkPhone = NULL;

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_MOBILE_TELEPHONE_NUMBER].ulPropTag) == PT_UNICODE )
            Phones.pchMobilePhone = pSRowSet->aRow[i].lpProps[ieidPR_MOBILE_TELEPHONE_NUMBER].Value.lpszW;
        else
            Phones.pchMobilePhone = NULL;

         Phones.pchIPPhone = NULL; // temporary disabled pSRowSet->aRow[i].lpProps[ieidPR_HOME_TELEPHONE_NUMBER].Value.lpszW;

        // Allocate an ITEMINFO struct to store this information
        lpSB = NULL;
        m_pWABObject->AllocateBuffer(sizeof(SBinary), (LPVOID *) &lpSB);
        if (lpSB)
        {
            // Save the information we'll need later
            m_pWABObject->AllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb));
            if (!lpSB->lpb)
            {
                m_pWABObject->FreeBuffer(lpSB);
                continue;
            }

            CopyMemory(lpSB->lpb, lpEID, cbEID);
            lpSB->cb = cbEID;

            // Create an item to add to the list
            m_pAB->CheckAndAddAbEntry(lpSB, lpwszID, lpwszName, nFlag, &Phones);
        }
    }

    // Let's make sure the first item is selected
//    ListView_SetItemState(ctlList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
   
    return (S_OK);
}

HRESULT CAddressBookData::NewContact(HWND hwndParent)
{    
    HRESULT     hr;
    ULONG       cbNewEntry;
    LPENTRYID   pNewEntry;
    ULONG           cbContainerID;
    LPENTRYID       pContainerID = 0;

    if(!m_pAdrBook)
        return E_FAIL;

    hr = m_pAdrBook->GetPAB(&cbContainerID, &pContainerID);
    if (FAILED(hr))
        return(hr);

    hr = m_pAdrBook->NewEntry((ULONG_PTR) hwndParent, /*CREATE_CHECK_DUP_STRICT*/ 0, cbContainerID, pContainerID, 0, NULL,
                              &cbNewEntry, &pNewEntry);

    return (hr);
}

// Add new (Msgr) contact to address book
HRESULT CAddressBookData::AutoAddContact(TCHAR * pchName, TCHAR * pchID)
{
    LPMAILUSER      lpMailUser = NULL;
    ULONG           ulcPropCount = 1;
    ULONG           ulIndex = 0;
    LPSPropValue    lpPropArray = NULL;
    SCODE           sc;
    LPWSTR          pwszName = NULL,
                    pwszID = NULL;
    HRESULT         hr = S_OK;

    if(!m_pAdrBook || !m_pWABObject)
        return(S_FALSE);

    // 1. Add entry to Address book
    pwszName = IEPszToUnicode(CP_ACP, pchName);
    if (!pwszName && (pchName && *pchName))
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

    pwszID = IEPszToUnicode(CP_ACP, pchID);
    if (!pwszID && (pchID && *pchID))
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

#ifdef LATER
    hr = HrWABCreateEntry(m_pAdrBook,
                            m_pWABObject,
                            pwszName,
                            pwszID,
                            CREATE_CHECK_DUP_STRICT,
                            &lpMailUser, KEEP_OPEN_READWRITE);
#endif
    if(SUCCEEDED(hr))
    {
        // 2. Set custom property: default address for buddy
        
        // Create a return prop array to pass back to the WAB
        sc = m_pWABObject->AllocateBuffer(sizeof(SPropValue), 
                                            (LPVOID *)&lpPropArray);
        if (sc!=S_OK)
            goto out;

        int nLen = lstrlen(pchID);
        if(nLen)
        {
            lpPropArray[0].ulPropTag = MsgrPropTags[0];
            sc = m_pWABObject->AllocateMore(nLen+1, lpPropArray, 
                                    (LPVOID *)&(lpPropArray[0].Value.LPSZ));

            if (sc!=S_OK)
                goto out;
            lstrcpy(lpPropArray[0].Value.LPSZ, pchID);
        }
        // Set this new data on the object
        //
        if(lpMailUser)
        {
            hr = lpMailUser->SetProps(1, lpPropArray, NULL);
            if(SUCCEEDED(hr))
                hr = lpMailUser->SaveChanges(FORCE_SAVE);
        }
    }

out:
    MemFree(pwszName);
    MemFree(pwszID);
    if(lpPropArray)
        m_pWABObject->FreeBuffer(lpPropArray);

    if(lpMailUser)
        ReleaseObj(lpMailUser);

    return(hr);
}

// Unicode string property version of template array
SizedSPropTagArray(6, ptaAddr_W) =
{
    6,
    {
        PR_ADDRTYPE_W,
        PR_DISPLAY_NAME_W,
        PR_EMAIL_ADDRESS_W,
        PR_ENTRYID,
        PR_CONTACT_EMAIL_ADDRESSES_W,  //4
        PR_SEARCH_KEY
    }
};

// ANSI string property version of template array
SizedSPropTagArray(6, ptaAddr_A) =
{
    6,
    {
        PR_ADDRTYPE_A,
        PR_DISPLAY_NAME_A,
        PR_EMAIL_ADDRESS_A,
        PR_ENTRYID,
        PR_CONTACT_EMAIL_ADDRESSES_A,
        PR_SEARCH_KEY
    }
};

HRESULT CAddressBookData::AddRecipient(LPMIMEADDRESSTABLEW pAddrTable, LPSBinary pSB, BOOL fGroup)
{
    HRESULT     hr;
    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;
    ULONG       ulObjType = 0;
    LPMAPITABLE lpAB =  NULL;
    LPABCONT    lpContainer = NULL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;

    // Retrieve the item from the wab
    hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

    // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_W, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    // Set those badboys on the address table
    if(pPropArray[2].ulPropTag == PR_EMAIL_ADDRESS_W)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[2].Value.lpszW, NULL , NULL);
    else if(pPropArray[4].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES_W)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[4].Value.MVszW.lppszW[0], NULL , NULL);
    else if((pPropArray[1].ulPropTag == PR_DISPLAY_NAME_W) && fGroup)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[1].Value.lpszW, NULL , NULL);

    // Bug 34077 - they don't want to have a display name...
    /* else if(pPropArray[1].ulPropTag == PR_DISPLAY_NAME)
        pAddrTable->Append(IAT_TO, IET_DECODED, pPropArray[1].Value.lpszW, NULL , NULL);
    else
        Assert(FALSE); */
exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (hr);
}

HRESULT CAddressBookData::SetDefaultMsgrID(LPSBinary pSB, LPWSTR pchID)
{
    ULONG       ulType = 0;
    IMailUser  *lpMailUser = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &lpMailUser);
    if (FAILED(hr))
        goto exit;

    if(SUCCEEDED(hr))
    {
        // 2. Set custom property: default address for buddy
        
        // Create a return prop array to pass back to the WAB
        sc = m_pWABObject->AllocateBuffer(sizeof(SPropValue), 
                                            (LPVOID *)&lpPropArray);
        if (sc!=S_OK)
            goto exit;

        int nLen = lstrlenW(pchID)*sizeof(WCHAR);
        if(nLen)
        {
            lpPropArray[0].ulPropTag = MsgrPropTags[0];
            sc = m_pWABObject->AllocateMore(nLen+1, lpPropArray, 
                                    (LPVOID *)&(lpPropArray[0].Value.lpszW));

            if (sc!=S_OK)
                goto exit;

            lstrcpyW(lpPropArray[0].Value.lpszW, pchID);
        }
        // Set this new data on the object
        //
        if(lpMailUser)
        {
            hr = lpMailUser->SetProps(1, lpPropArray, NULL);
            if(SUCCEEDED(hr))
                hr = lpMailUser->SaveChanges(FORCE_SAVE);
        }
    }

exit:
//    if(lpPropArray)
//        m_pWABObject->FreeBuffer(lpPropArray);

    SafeRelease(lpMailUser);
    return (hr);
}

HRESULT CAddressBookData::GetDisplayName(LPSBinary pSB, LPWSTR wszDisplayName, int nMax)
{

    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

        // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_W, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    lstrcpynW(wszDisplayName, pPropArray[1].Value.lpszW, nMax);
    wszDisplayName[nMax - 1] = L'\0';

exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (hr);

}

BOOL CAddressBookData::CheckEmailAddr(LPSBinary pSB, LPWSTR wszEmail)
{
    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;
    LPSPropValue lpPropMVEmail = NULL;
    UINT i = 0;
    BOOL fRet = FALSE;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

        // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_W, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    // 4 element is PR_CONTACT_EMAIL_ADDRESSES in ptaAddr
    lpPropMVEmail = &(pPropArray[4]);
    if(lpPropMVEmail && (lpPropMVEmail->ulPropTag == PR_CONTACT_EMAIL_ADDRESSES))
    {
        // we have a multiple emails
        //Assume, if this is present, so is MVAddrType, and defaultindex
        for(i = 0; i < lpPropMVEmail->Value.MVszW.cValues; i++)
        {

            if(!lstrcmpiW(lpPropMVEmail->Value.MVszW.lppszW[i], wszEmail))
                fRet = TRUE;
        }
    }
exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (fRet);
}



HRESULT CAddressBookData::FreeListViewItem(LPSBinary pSB)
{
    if (pSB)
        m_pWABObject->FreeBuffer(pSB);
    return (S_OK);
}

HRESULT CAddressBookData::ShowDetails(HWND hwndParent, LPSBinary pSB)
{
    HRESULT hr;
    ULONG_PTR   ulUIParam = (ULONG_PTR) hwndParent;

    hr = m_pAdrBook->Details(&ulUIParam, NULL, NULL, pSB->cb, (LPENTRYID) pSB->lpb, 
                             NULL, NULL, NULL, 0);

    return (hr);
}

HRESULT CAddressBookData::AddAddress(LPWSTR pwszDisplay, LPWSTR pwszAddress)
{
    HRESULT         hr;
    LPABCONT        pABContainer = NULL;
    ULONG           cbContainerID,
        ul;
    LPENTRYID       pContainerID = 0;
    LPMAPIPROP      lpProps = 0;
    SPropValue      rgpv[3];
    SPropTagArray   ptaEID = { 1, { PR_ENTRYID } };
    LPSPropValue    ppvDefMailUser=0;
    SizedSPropTagArray(1, ptaDefMailUser) =
    { 1, { PR_DEF_CREATE_MAILUSER } };
    
    DWORD           cUsedValues;
    
    // Get the entry ID for the PAB
    hr = m_pAdrBook->GetPAB(&cbContainerID, &pContainerID);
    if (FAILED(hr))
        goto error;
    
    // Request the container
    hr = m_pAdrBook->OpenEntry(cbContainerID, pContainerID, NULL,
        0, &ul, (LPUNKNOWN *) &pABContainer);
    Assert(ul == MAPI_ABCONT);
    if (FAILED(hr))
        goto error;
    
    // Free the entry ID
    m_pWABObject->FreeBuffer(pContainerID);
    
    // Get the properties for the default mail template
    hr = pABContainer->GetProps((LPSPropTagArray) &ptaDefMailUser, 0, &ul, &ppvDefMailUser);
    if (FAILED(hr) || !ppvDefMailUser || ppvDefMailUser->ulPropTag != PR_DEF_CREATE_MAILUSER)
        goto error;
    
    // Create a new entry
    hr=pABContainer->CreateEntry(ppvDefMailUser->Value.bin.cb, 
        (LPENTRYID) ppvDefMailUser->Value.bin.lpb,
        CREATE_CHECK_DUP_STRICT, &lpProps);
    if (FAILED(hr))
        goto error;
    
    // Fill in the properties for the display name and address
    rgpv[0].ulPropTag   = PR_DISPLAY_NAME_W;
    rgpv[0].Value.lpszW = pwszDisplay;
    rgpv[1].ulPropTag   = PR_EMAIL_ADDRESS_W;
    rgpv[1].Value.lpszW = pwszAddress;
    
    cUsedValues = 2;
    // Set those props on the entry
    hr = lpProps->SetProps(cUsedValues, rgpv, NULL);
    if (FAILED(hr))
        goto error;
    
    // Save 'em
    hr = lpProps->SaveChanges(KEEP_OPEN_READONLY);
    if (FAILED(hr))
        goto error;
    
error:
    ReleaseObj(lpProps);
    ReleaseObj(pABContainer);
    
    if (ppvDefMailUser)
        m_pWABObject->FreeBuffer(ppvDefMailUser);
    
    return hr;
}


HRESULT CAddressBookData::DeleteItems(ENTRYLIST *pList)
{
    ULONG       ulObjType = 0;
    LPABCONT    lpContainer = NULL;
    HRESULT     hr = E_FAIL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;

    // Get the entryid of the root PAB container
    hr = m_pAdrBook->GetPAB(&lpcbEID, &lpEID);

    // Open the root PAB container.  This is where all the WAB contents reside.
    ulObjType = 0;
    hr = m_pAdrBook->OpenEntry(lpcbEID,
                               (LPENTRYID)lpEID,
                               NULL,
                               0,
                               &ulObjType,
                               (LPUNKNOWN *) &lpContainer);

    m_pWABObject->FreeBuffer(lpEID);
    lpEID = NULL;

    // Delete those items
    lpContainer->DeleteEntries(pList, 0);

    lpContainer->Release();
    return (S_OK);
}

HRESULT CAddressBookData::Find(HWND hwndParent)
{
    m_pWABObject->Find(m_pAdrBook, hwndParent);
    return (S_OK);
}


HRESULT CAddressBookData::NewGroup(HWND hwndParent)
{
    HRESULT     hr;
    ULONG       cbNewEntry = 0;
    LPENTRYID   pNewEntry = 0;
    LPENTRYID   pTplEid;
    ULONG       cbTplEid;

    hr = _GetWABTemplateID(MAPI_DISTLIST, &cbTplEid, &pTplEid);
    if (SUCCEEDED(hr))
    {
        hr = m_pAdrBook->NewEntry((ULONG_PTR) hwndParent, 0, 0, NULL, cbTplEid, pTplEid, &cbNewEntry, &pNewEntry);
        Assert(pTplEid);
        m_pWABObject->FreeBuffer(pTplEid);
    }

    return (hr);
}

HRESULT CAddressBookData::AddressBook(HWND hwndParent)
{
#ifdef LATER
    CWab *pWab = NULL;
    
    if (SUCCEEDED(HrCreateWabObject(&pWab)))
    {
        pWab->HrBrowse(hwndParent);
        pWab->Release();
    }
    else
    {
        AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsGeneralWabError), 
                      NULL, MB_OK | MB_ICONEXCLAMATION);
    }
#endif
    return (S_OK);
}


HRESULT CAddressBookData::_GetWABTemplateID(ULONG ulObjectType, ULONG *lpcbEID, LPENTRYID *lppEID)
{
    LPABCONT lpContainer = NULL;
    HRESULT  hr  = S_OK;
    SCODE    sc = ERROR_SUCCESS;
    ULONG    ulObjType = 0;
    ULONG    cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG    cNewProps;
    ULONG    nIndex;

    if ((!m_pAdrBook) || ((ulObjectType != MAPI_MAILUSER) && (ulObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpcbEID = 0;
    *lppEID  = NULL;

    if (FAILED(hr = m_pAdrBook->GetPAB(&cbWABEID, &lpWABEID)))
    {
        goto out;
    }

    if (HR_FAILED(hr = m_pAdrBook->OpenEntry(cbWABEID,     // size of EntryID to open
                                              lpWABEID,     // EntryID to open
                                              NULL,         // interface
                                              0,            // flags
                                              &ulObjType,
                                              (LPUNKNOWN *) &lpContainer)))
    {
        goto out;
    }

    // Get us the default creation entryids
    if (FAILED(hr = lpContainer->GetProps((LPSPropTagArray) &ptaCreate,
                                          0, &cNewProps, &lpCreateEIDs)))
    {
        goto out;
    }

    // Validate the properites
    if (lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
        lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        goto out;
    }

    if (ulObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;

    m_pWABObject->AllocateBuffer(*lpcbEID, (LPVOID *) lppEID);
    
    if (sc != S_OK)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);

out:
    if (lpCreateEIDs)
        m_pWABObject->FreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->Release();

    if (lpWABEID)
        m_pWABObject->FreeBuffer(lpWABEID);

    return hr;
}

/*//$$****************************************************************
//
// InitNamedProps
//
// Gets the PropTags for the Named Props this app is interested in
//
//********************************************************************/
HRESULT CAddressBookData::InitNamedProps(/*LPWABEXTDISPLAY lpWED*/)
{
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lptaMsgrProps = NULL;
    LPMAPINAMEID * lppMsgrPropNames;
    SCODE sc;
    // LPMAILUSER lpMailUser = NULL;
    WCHAR szBuf[msgrMax][MAX_PATH];

/*    if(!lpWED)
        goto err;

    lpMailUser = (LPMAILUSER) lpWED->lpPropObj;

    if(!lpMailUser)
        goto err; */

    sc = m_pWABObject->AllocateBuffer(sizeof(LPMAPINAMEID) * msgrMax, 
                                            (LPVOID *) &lppMsgrPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<msgrMax;i++)
    {
        sc = m_pWABObject->AllocateMore(sizeof(MAPINAMEID), 
                                                lppMsgrPropNames, 
                                                (LPVOID *)&(lppMsgrPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppMsgrPropNames[i]->lpguid = (LPGUID) &WAB_ExtBAGuid;
        lppMsgrPropNames[i]->ulKind = MNID_STRING;

        *(szBuf[i]) = '\0';

        // Convert prop name to wide-char
        if ( !MultiByteToWideChar( GetACP(), 0, lpMsgrPropNames[i], -1, szBuf[i], ARRAYSIZE(szBuf[i]) ))
        {
            continue;
        }

        lppMsgrPropNames[i]->Kind.lpwstrName = (LPWSTR) szBuf[i];
    }

    hr = m_pAdrBook->GetIDsFromNames(   msgrMax, 
                                        lppMsgrPropNames,
                                        MAPI_CREATE, 
                                        &lptaMsgrProps);
    if(HR_FAILED(hr))
        goto err;

    if(lptaMsgrProps)
    {
        // Set the property types on the returned props
        MsgrPropTags[MsgrID] = PR_MSGR_DEF_ID = CHANGE_PROP_TYPE(lptaMsgrProps->aulPropTag[MsgrID], PT_TSTRING);
    }

err:
    if(lptaMsgrProps)
        m_pWABObject->FreeBuffer( lptaMsgrProps);

    if(lppMsgrPropNames)
        m_pWABObject->FreeBuffer( lppMsgrPropNames);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\baprop.h ===
// baprop.h
// WAB & Messenger integration to OE
// Created 06/23/98 by YST
//
//////////////////////////////////////////////////////////////////////

#ifndef __BAPROP_H_
#define __BAPROP_H_

#include "pch.hxx"
#include "badata.h"
// #include "demand.h"

// Definitions
void AddCBEmailItem(HWND hWndCB, LPTSTR  lpszEmailAddress, BOOL fDefault, LPTSTR lpszPendName);
INT_PTR CALLBACK WabExtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
void AddAccountsToList(HWND hDlg, LPWABEXTDISPLAY lpWED, LPTSTR lpszPendName = NULL);
void SetAsDefault(HWND hDlg, LPWABEXTDISPLAY lpWED);
void AddMsgrId(HWND hDlg, LPWABEXTDISPLAY lpWED);
void SetDefaultID(TCHAR *szName, HWND hdlg, LPWABEXTDISPLAY lpWED);
BOOL AsciiTrimSpaces(TCHAR * szBuf);
HRESULT AddPropToMVPString(LPWABEXTDISPLAY lpWED, LPSPropValue lpaProps, DWORD cProps, DWORD index, LPTSTR lpszNew);
void WabSendIMsg(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL InitFonts(void);
void DeleteFonts(void);
BOOL WabIsItemOnline(HWND hDlg, int iItem);

#endif // __BAPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\baui.h ===
// abui.h : Declaration of the CIEMsgAb
// Messanger integration to OE
// Created 04/20/98 by YST

#ifndef __BAUI_H_
#define __BAUI_H_

class CFolderBar;
class CPaneFrame;

#include "resource.h"       // main symbols
//#include "blobevnt.h"
#include "bactrl.h"
#include "commctrl.h"
#include "badata.h"
#include <docobj.h>
#include <shlobj.h>
#include <shlguid.h>
#include <wab.h>
#include <mapiguid.h>
#include "bllist.h"
// #include "menures.h"
#include <wabapi.h>
// #include "util.h"
// {32bb8320-b41b-11cf-a6bb-0080c7b2d682}
DEFINE_GUID(IID_IBrowserExtension, 0x32bb8320, 0xb41b, 0x11cf, 0xa6, 0xbb, 0x0, 0x80, 0xc7, 0xb2, 0xd6, 0x82);
#define IDT_PANETIMER           100
#define ELAPSE_MOUSEOVERCHECK   60000

// Load resource string once
#define RESSTRMAX   64

extern HINSTANCE  g_hLocRes;

interface IBrowserExtension : IUnknown
{
    virtual STDMETHODIMP Init(REFGUID refguid) = 0;
    virtual STDMETHODIMP GetProperty(SHORT iPropID, VARIANTARG * varProperty) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Bitmap Indices
//

enum {
    IMAGE_NEW_MESSAGE = 0,
    IMAGE_DISTRIBUTION_LIST,
    IMAGE_ONLINE,
    IMAGE_OFFLINE,
    IMAGE_STOPSIGN,
    IMAGE_CLOCKSIGN,
    IMAGE_CERT,
    IMAGE_EMPTY,
    ABIMAGE_MAX
};

enum {
    BASORT_STATUS_ACSEND = 0,
    BASORT_STATUS_DESCEND,
    BASORT_NAME_ACSEND,
    BASORT_NAME_DESCEND
};

HRESULT CreateIEMsgAbCtrl(IIEMsgAb **pIEMsgAb);

typedef struct _tag_Phones
{
    WCHAR   *   pchHomePhone;
    WCHAR   *   pchWorkPhone;
    WCHAR   *   pchMobilePhone;
    WCHAR   *   pchIPPhone;
} PNONEENTRIES;

typedef PNONEENTRIES * LPPNONEENTRIES;

typedef struct _tag_MABEntry
{
    MABENUM         tag;
    WCHAR   *       pchWABName;
    WCHAR   *       pchWABID;
    LPSBinary       lpSB;
    LPMINFO         lpMsgrInfo;
    BOOL            fCertificate;
    LPPNONEENTRIES  lpPhones;
} mabEntry;

typedef mabEntry * LPMABENTRY;

class CEmptyList
{
public:
    CEmptyList()
    {
        m_hwndList = NULL;
        m_hwndBlocker = NULL;
        m_hwndHeader = NULL;
        m_pwszString = NULL;
        m_pfnWndProc = NULL;
        m_hbrBack = NULL;
        m_hFont = NULL;
    }

    ~CEmptyList();
    HRESULT Show(HWND hwndList, LPWSTR pwszString);
    HRESULT Hide(void);
    static LRESULT SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
private:
    HWND    m_hwndList;
    HWND    m_hwndBlocker;
    HWND    m_hwndHeader;
    WCHAR  *m_pwszString;
    WNDPROC m_pfnWndProc;
    HBRUSH  m_hbrBack;
    HFONT   m_hFont;
};


/////////////////////////////////////////////////////////////////////////////
// CIEMsgAb
class ATL_NO_VTABLE CIEMsgAb : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CIEMsgAb, &CLSID_IEMsgAb>,
    public CComControl<CIEMsgAb>,
    public IDispatchImpl<IIEMsgAb, &IID_IIEMsgAb, &LIBID_IEMsgAbLib>,
    public IProvideClassInfo2Impl<&CLSID_IEMsgAb, NULL, &LIBID_IEMsgAbLib>,
    public IPersistStreamInitImpl<CIEMsgAb>,
    public IPersistStorageImpl<CIEMsgAb>,
    public IQuickActivateImpl<CIEMsgAb>,
    public IOleControlImpl<CIEMsgAb>,
    public IOleObjectImpl<CIEMsgAb>,
    public IOleInPlaceActiveObjectImpl<CIEMsgAb>,
    public IViewObjectExImpl<CIEMsgAb>,
    public IOleInPlaceObjectWindowlessImpl<CIEMsgAb>,
    public IDataObjectImpl<CIEMsgAb>,
    public IConnectionPointContainerImpl<CIEMsgAb>,
	public IPropertyNotifySinkCP<CIEMsgAb>,
    public ISpecifyPropertyPagesImpl<CIEMsgAb>,
    public IInputObject,
    public IObjectWithSite,
//    public IBrowserExtension,
    public IDeskBand,
//    public IPersistStream,
    public IDropTarget,
    public IOleCommandTarget,
    // public IWABExtInit,
    public IShellPropSheetExt
{
public:
    // Declare our own window class that doesn't have the CS_HREDRAW etc set
    static CWndClassInfo& GetWndClassInfo() 
    { 
        static CWndClassInfo wc = 
        { 
            { sizeof(WNDCLASSEX), 0, StartWindowProc, 
              0, 0, 0, 0, 0, 0 /*(HBRUSH) (COLOR_DESKTOP + 1) */, 0, TEXT("Outlook Express Address Book Control"), 0 }, 
              NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
        }; 
        return wc; 
    }
    CIEMsgAb();
    ~CIEMsgAb();

DECLARE_REGISTRY_RESOURCEID(IDR_BLVIEW)
    
BEGIN_COM_MAP(CIEMsgAb)
    COM_INTERFACE_ENTRY(IIEMsgAb)
    // COM_INTERFACE_ENTRY(IBrowserExtension)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IDeskBand)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IDropTarget)
    COM_INTERFACE_ENTRY(IInputObject)
    COM_INTERFACE_ENTRY(IOleCommandTarget)
//    COM_INTERFACE_ENTRY(IFontCacheNotify)
    COM_INTERFACE_ENTRY(IObjectWithSite)
//    COM_INTERFACE_ENTRY_IID(IID_IDropDownFldrBar, IDropDownFldrBar)
//    COM_INTERFACE_ENTRY(IMAPIAdviseSink)
//    COM_INTERFACE_ENTRY(IPersistStream)
    // COM_INTERFACE_ENTRY(IWABExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CIEMsgAb)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_CONNECTION_POINT_MAP(CIEMsgAb)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(CIEMsgAb)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_WININICHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_MSGR_SHUTDOWN, OnMsgrShutDown)
    MESSAGE_HANDLER(WM_USER_STATUS_CHANGED, OnUserStateChanged)
    MESSAGE_HANDLER(WM_USER_MUSER_REMOVED, OnUserRemoved)
    MESSAGE_HANDLER(WM_MSGR_LOGOFF, OnUserLogoffEvent)
    MESSAGE_HANDLER(WM_MSGR_LOGRESULT, OnUserLogResultEvent)
    MESSAGE_HANDLER(WM_USER_MUSER_ADDED, OnUserAdded)
    MESSAGE_HANDLER(WM_USER_NAME_CHANGED, OnUserNameChanged)
    MESSAGE_HANDLER(WM_LOCAL_STATUS_CHANGED, OnLocalStateChanged)

    COMMAND_ID_HANDLER(ID_FIND_PEOPLE, CmdFind)
    COMMAND_ID_HANDLER(ID_ADDRESS_BOOK, CmdIEMsgAb)
    COMMAND_ID_HANDLER(ID_DELETE_CONTACT, CmdDelete)

//    COMMAND_ID_HANDLER(ID_NEW_MSG_DEFAULT, CmdNewMessage)
    COMMAND_ID_HANDLER(ID_PROPERTIES, CmdProperties)
    COMMAND_ID_HANDLER(ID_NEW_CONTACT, CmdNewContact)
    COMMAND_ID_HANDLER(ID_NEW_ONLINE_CONTACT, CmdNewOnlineContact)
    COMMAND_ID_HANDLER(ID_SET_ONLINE_CONTACT, CmdSetOnline)
    COMMAND_ID_HANDLER(ID_NEW_GROUP, CmdNewGroup)
    COMMAND_ID_HANDLER(ID_SEND_INSTANT_MESSAGE, CmdNewIMsg)
    COMMAND_ID_HANDLER(ID_SEND_INSTANT_MESSAGE2, CmdNewMessage)
    COMMAND_ID_HANDLER(ID_SEND_MESSAGE, CmdNewEmaile)
    COMMAND_ID_HANDLER(ID_NEW_MSG_DEFAULT, CmdNewEmaile)
    COMMAND_ID_HANDLER(ID_HOME_PHONE, CmdHomePhone)
    COMMAND_ID_HANDLER(ID_WORK_PHONE, CmdWorkPhone)
    COMMAND_ID_HANDLER(ID_MOBILE_PHONE, CmdMobilePhone)
    COMMAND_ID_HANDLER(ID_IP_PHONE, CmdIPPhone)
    COMMAND_ID_HANDLER(ID_DIAL_PHONE_NUMBER, CmdDialPhone)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_FONTCHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_PALETTECHANGED, OnSysParamsChange)

    NOTIFY_CODE_HANDLER(LVN_GETDISPINFOW, NotifyGetDisplayInfo)
    NOTIFY_CODE_HANDLER(LVN_GETINFOTIPW, NotifyGetInfoTip)
    NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, NotifyItemChanged)
    NOTIFY_CODE_HANDLER(LVN_DELETEITEM, NotifyDeleteItem)
    NOTIFY_CODE_HANDLER(LVN_ITEMACTIVATE, NotifyItemActivate)
    NOTIFY_CODE_HANDLER(NM_SETFOCUS, NotifySetFocus)
    NOTIFY_CODE_HANDLER(NM_KILLFOCUS, NotifyKillFocus)
END_MSG_MAP()

// CComControlBase

    HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
    {
        m_hwndParent = hWndParent; 
		return Create(hWndParent, rcPos, NULL, WS_CHILD | WS_TABSTOP | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 
                      WS_EX_CONTROLPARENT);
    } 
// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

// IQuickActivate
    STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
    {
        // $REVIEW - Someone updated the size of QACONTAINER to add two
        //           new members, pOleControlSite and pServiceProvider.
        //           This causes ATL to assert in a big way, but to 
        //           avoid the assert we tweek the structure size.  This
        //           is a bad thing. -- steveser
        pQACont->cbSize = sizeof(QACONTAINER);
        return (IQuickActivateImpl<CIEMsgAb>::QuickActivate(pQACont, pQACtrl));
    }

// IOleInPlaceActiveObjectImpl
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg)
    {
        if (lpmsg->message == WM_CHAR && lpmsg->wParam == VK_DELETE)
        {
            PostMessage(WM_COMMAND, ID_DELETE, 0);
            return (S_OK);
        }
        return (S_FALSE);
    }

// IIEMsgAb

public:
    STDMETHOD(get_InstMsg)(BOOL *pVal);
    HRESULT OnDraw(ATL_DRAWINFO& di);
	HRESULT ResizeChildWindows(LPCRECT prcPos = NULL);

   // IOleWindow methods
   STDMETHOD(GetWindow)(HWND* phwnd);
   STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

   STDMETHOD(Init) (REFGUID refguid);
   STDMETHOD(GetProperty)(SHORT iPropID, VARIANTARG * varProperty);

    // IDockingWindow methods
   STDMETHOD(ShowDW)(BOOL fShow);
   STDMETHOD(CloseDW)(DWORD dwReserved);
   STDMETHOD(ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

   // IDeskBand methods
   STDMETHOD(GetBandInfo)(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi);

   // IDropTarget
    STDMETHOD(DragEnter)(THIS_ IDataObject *pDataObject, DWORD grfKeyState,
                         POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(THIS_ DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(THIS);
    STDMETHOD(Drop)(THIS_ IDataObject *pDataObject, DWORD grfKeyState,
                    POINTL pt, DWORD *pdwEffect);

//IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        rgCmds[], 
                                          OLECMDTEXT    *pCmdText);
    HRESULT STDMETHODCALLTYPE Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut);


// IInputObject
    STDMETHOD(HasFocusIO)(THIS);
    STDMETHOD(TranslateAcceleratorIO)(THIS_ LPMSG lpMsg);
    STDMETHOD(UIActivateIO)(THIS_ BOOL fActivate, LPMSG lpMsg);

#ifdef LATER
/////////////////////////////////////////////////////////////////////////
// IFontCacheNotify
//
	STDMETHOD(OnPreFontChange)(void);
	STDMETHOD(OnPostFontChange)(void);
#endif
//     STDMETHOD(IOleObject_SetClientSite) (IOleClientSite *pClientSite) { return S_OK;}
//     STDMETHOD(IOleObject_GetClientSite) (IOleClientSite **ppClientSite){ return S_OK;}
//IObjectWithSite
    STDMETHOD(SetSite)(IUnknown  *punksite);
    STDMETHOD(GetSite)(REFIID  riid, LPVOID *ppvSite);

//IDropDownFolderBar
    HRESULT RegisterFlyOut(CFolderBar *pFolderBar);
    HRESULT RevokeFlyOut();

// IMAPIAdviseSink
    STDMETHOD_(ULONG, OnNotify)(ULONG cNotif, LPNOTIFICATION pNotifications);

// IShellPropSheetExt interface
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IWABExtInit interface
    STDMETHOD(Initialize)(LPWABEXTDISPLAY lpWED);

    // STDMETHOD (EventUserStateChanged)(THIS_ IBasicIMUser * pUser);

    LPMABENTRY AddBlabEntry(MABENUM tag, LPSBinary lpSB, LPMINFO lpMsgrInfo = NULL, WCHAR *pchMail = NULL, 
                                    WCHAR *pchDisplayName = NULL, BOOL fCert = FALSE, LPPNONEENTRIES  lpPhs = NULL);
    void CheckAndAddAbEntry(LPSBinary lpSB, WCHAR *pchEmail, WCHAR *pchDisplayName, DWORD nFlag, LPPNONEENTRIES pPhEnries);
    BOOL DontShowMessenger(void) { return (m_pCMsgrList ? m_pCMsgrList->IsLocalOnline() :(m_dwHideMessenger ? TRUE : (m_dwDisableMessenger ? TRUE : FALSE))); }
    BOOL HideViewMenu(void) { return(m_dwHideMessenger); }
    BOOL IsMessengerInstalled(void) { return (m_pCMsgrList ? TRUE : FALSE); }

// Message Handlers
private:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT  nMsg , WPARAM  wParam , LPARAM  lParam , BOOL&  bHandled );

    LRESULT OnTimer(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
    {
        if(wParam == IDT_PANETIMER)
            _ReloadListview();
        return 0;
    }

    LRESULT OnSysParamsChange(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
    {
        m_ctlList.SendMessage(nMsg, wParam, lParam);

        return 0;
    }
    HRESULT OnMsgrShutDown(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserRemoved(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserLogoffEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserLogResultEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserAdded(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserNameChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnLocalStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);

    LRESULT CmdDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdIEMsgAb(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewOnlineContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewGroup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewEmaile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewIMsg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdSetOnline(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//    LRESULT CmdMsgrOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT NewInstantMessage(LPMABENTRY pEntry);

    LRESULT CmdHomePhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdWorkPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdMobilePhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdIPPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdDialPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT NotifyDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyItemActivate(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyGetDisplayInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
//     LRESULT NotifyColumnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT CmdProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT NotifySetFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyKillFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // Utility Functions
    HRESULT _ResizeElements(LPCRECT prcPos = NULL, LPCRECT prcClip = NULL);
    void    _AutosizeColumns(void);
    void    _EnableCommands(void);
    HRESULT _DoDropMessage(LPMIMEMESSAGE pMessage);
    HRESULT _DoDropMenu(POINTL pt, LPMIMEMESSAGE pMessage);
    void    _ReloadListview(void);
    LRESULT SetUserIcon(LPMABENTRY pEntry, int nStatus, int * pImage);
    void AddMsgrListItem(LPMINFO lpMsgrInfo);
    HRESULT FillMsgrList();
    void RemoveBlabEntry(LPMABENTRY lpEntry);
    LPMABENTRY FindUserEmail(WCHAR *pchEmail, int *pIndex = NULL, BOOL fMsgrOnly = TRUE);
    LPMABENTRY GetSelectedEntry(void);
    LPMABENTRY GetEntryForSendInstMsg(LPMABENTRY pEntry = NULL);
    HRESULT PromptToGoOnline(void);
    void RemoveMsgrInfo(LPMINFO lpMsgrInfo);
    BOOL _FillPhoneNumber(UINT Id, OLECMDTEXT *cmdText);
    LRESULT CallPhone(WCHAR *szPhone, BOOL fMessengerContact);

    // Member Data
private:
    // Address Book Object
    CAddressBookData  m_cAddrBook;

    // Child windows
    CContainedWindow m_ctlList;         // Displays the list of people

    HIMAGELIST              m_himl;
    DWORD                   m_dwFontCacheCookie;        // For the Advise on the font cache
    CEmptyList              m_cEmptyList;
    WCHAR *                 m_szOnline;
    // TCHAR *                 m_szInvisible;
    WCHAR *                 m_szBusy;
    WCHAR *                 m_szBack;
    WCHAR *                 m_szAway;
    WCHAR *                 m_szOnPhone;
    WCHAR *                 m_szLunch;
    WCHAR *                 m_szOffline;
    WCHAR *                 m_szIdle;
    WCHAR *                 m_szEmptyList;
    WCHAR *                 m_szMsgrEmptyList;
    WCHAR *                 m_szLeftBr;
    WCHAR *                 m_szRightBr;
    BOOL                    m_fNoRemove:1;
    BOOL                    m_fShowAllContacts:1;
    BOOL                    m_fShowOnlineContacts:1;
    BOOL                    m_fShowOfflineContacts:1;
    BOOL                    m_fShowEmailContacts:1;
    BOOL                    m_fShowOthersContacts:1;
    BOOL                    m_fWAB:1;
    BOOL                    m_fRight:1;
    BOOL                    m_fLogged:1;
    int                     m_delItem;
    DWORD                   m_dwHideMessenger;
    DWORD                   m_dwDisableMessenger;

    // Drag & Drop stuff
    IDataObject     *m_pDataObject;
    CLIPFORMAT       m_cf;

    // Properties
    //Site ptr
    IInputObjectSite *m_pObjSite;

    HWND             m_hwndParent;
    CFolderBar       *m_pFolderBar;

    int m_nSortType;
    CMsgrList *m_pCMsgrList;        // pointer to OE Msgr

    int             m_nChCount;

    // WAB extension
    UINT            m_cRefThisDll;     // Reference count for this DLL
    HPROPSHEETPAGE  m_hPage1; // Handle to the property sheet page

    LPWABEXTDISPLAY m_lpWED;

    LPWABEXTDISPLAY m_lpWEDContext;
    LPMAPIPROP      m_lpPropObj; // For context menu extensions, hang onto the prop obj

};

int CALLBACK BA_Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
INT_PTR CALLBACK WabExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#define AthMessageBox(hwnd, pszT, psz1, psz2, fu) MessageBoxInst(g_hLocRes, hwnd, pszT, psz1, psz2, fu)
#define AthMessageBoxW(hwnd, pwszT, pwsz1, pwsz2, fu) MessageBoxInstW(g_hLocRes, hwnd, pwszT, pwsz1, pwsz2, fu, LoadStringWrapW, MessageBoxWrapW)

LPWSTR AthLoadString(UINT id, LPWSTR sz, int cch);
LPSTR ANSI_AthLoadString(UINT id, TCHAR* sz, int cch);
HMENU LoadPopupMenu(UINT id);
void MenuUtil_BuildMenuIDList(HMENU hMenu, OLECMD **prgCmds, ULONG *pcStart, ULONG *pcCmds);
HRESULT MenuUtil_EnablePopupMenu(HMENU hPopup, CIEMsgAb *pTarget);



#endif //__BAUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\baui.cpp ===
// baui.cpp : Implementation of CIEMsgAb
// Messenger integration to OE
// Created 04/20/98 by YST
// #define YST 1


#include "pch.hxx"
#include <windowsx.h>
#include "msoert.h"
#include "basicim2.h"
#include "shlwapi.h"
#include "bactrl.h"
#include "baprop.h"
#include "baui.h"
#include "bllist.h"
#include <wabapi.h>
#include "shlwapip.h"
#include "clutil.h"
#include <mapi.h>
#include "hotlinks.h"
#include <w95wraps.h>

static CAddressBookData  * st_pAddrBook = NULL;

#define MAX_MENUSTR             256
//
//  Pseudoclass for the variable-sized OLECMDTEXT structure.
//  You need to declare it as a class (and not a BYTE buffer that is
//  suitable cast) because BYTE buffers are not guaranteed to be aligned.
//
template <int n>
class OLECMDTEXTV : public OLECMDTEXT {
    WCHAR wszBuf[n-1];          // "-1" because OLECMDTEXT includes 1 wchar
};



#ifdef DEBUG
DWORD dwDOUTLevel = 0;
#endif
HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState);
STDAPI OESimulateDrop(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                      const POINTL *ppt, DWORD *pdwEffect);

typedef enum _tagGetPropertyIDs
{
    TBEX_BUTTONTEXT     = 100,     // VT_BSTR
    TBEX_TOOLTIPTEXT    = 101,     // VT_BSTR
    TBEX_GRAYICON       = 102,     // HICON as a VT_BYREF
    TBEX_HOTICON        = 103,     // HICON as a VT_BYREF
    TBEX_GRAYICONSM     = 104,     // HICON as a VT_BYREF
    TBEX_HOTICONSM      = 105,     // HICON as a VT_BYREF
    TBEX_DEFAULTVISIBLE = 106,     // VT_BOOL
    TMEX_MENUTEXT       = 200,     // VT_BSTR
    TMEX_STATUSBARTEXT  = 201,     // VT_BSTR
    TMEX_CUSTOM_MENU    = 202,     // VT_BSTR
} GETPROPERTYIDS;

static const int BA_SortOrder[] =
{
    BIMSTATE_ONLINE,
    BIMSTATE_BE_RIGHT_BACK,
    BIMSTATE_OUT_TO_LUNCH,
    BIMSTATE_IDLE,
    BIMSTATE_AWAY,
    BIMSTATE_ON_THE_PHONE,
    BIMSTATE_BUSY,
    BIMSTATE_INVISIBLE,
    BIMSTATE_OFFLINE,
    BIMSTATE_UNKNOWN
};


// Create control
HRESULT CreateIEMsgAbCtrl(IIEMsgAb **ppIEMsgAb)
{
    HRESULT         hr;
    IUnknown         *pUnknown;

    TraceCall("CreateMessageList");

    // Get the class factory for the MessageList object
    IClassFactory *pFactory = NULL;
    hr = _Module.GetClassObject(CLSID_IEMsgAb, IID_IClassFactory,
                                (LPVOID *) &pFactory);

    // If we got the factory, then get an object pointer from it
    if (SUCCEEDED(hr))
    {
        hr = pFactory->CreateInstance(NULL, IID_IUnknown,
                                      (LPVOID *) &pUnknown);
        if (SUCCEEDED(hr))
        {
            hr = pUnknown->QueryInterface(IID_IIEMsgAb, (LPVOID *) ppIEMsgAb);
            pUnknown->Release();
        }
        pFactory->Release();
    }

    return (hr);
}

/////////////////////////////////////////////////////////////////////////////
// CIEMsgAb
CIEMsgAb::CIEMsgAb():m_ctlList(_T("SysListView32"), this, 1)
{
    m_bWindowOnly = TRUE;

    m_pDataObject = 0;
    m_cf = 0;

    m_hwndParent    = NULL;
    m_pFolderBar    = NULL;
    m_pObjSite      = NULL;
    m_nSortType =  HIWORD(DwGetOptions());
    m_pCMsgrList = NULL;

    m_himl = NULL;

    m_fLogged = FALSE;
    m_dwFontCacheCookie = 0;
    m_nChCount = 0;

    m_lpWED = NULL;
    m_lpWEDContext = NULL;
    m_lpPropObj = NULL;

    m_szOnline = NULL;
    // m_szInvisible = NULL;
    m_szBusy = NULL;
    m_szBack = NULL;
    m_szAway = NULL;
    m_szOnPhone = NULL;
    m_szLunch = NULL;
    m_szOffline = NULL;
    m_szIdle = NULL;
    m_szEmptyList = NULL;
    m_szMsgrEmptyList = NULL;
    m_szLeftBr = NULL;
    m_szRightBr = NULL;

    m_fNoRemove = FALSE;
    m_delItem = 0;

    m_dwHideMessenger = DwGetMessStatus();
    m_dwDisableMessenger = DwGetDisableMessenger();

    WORD wShow =  LOWORD(DwGetOptions());

    m_fShowAllContacts = FALSE;
    m_fShowOnlineContacts = FALSE;
    m_fShowOfflineContacts = FALSE;
    m_fShowEmailContacts  = FALSE;
    m_fShowOthersContacts  = FALSE;

    if(wShow == 0)
        m_fShowAllContacts = TRUE;
    else if (wShow == 1)
        m_fShowOfflineContacts = TRUE;
    else
        m_fShowOnlineContacts = TRUE;

    m_fWAB = TRUE;

    // Initialize the applicaiton
#ifdef LATER
    g_pInstance->DllAddRef();
#endif

    // Raid-32933: OE: MSIMN.EXE doesn't always exit
    // g_pInstance->CoIncrementInit();

    // LATER this is temporary hack for resources!!!
    _ASSERT(g_hLocRes);
//    g_hLocRes = g_hInst; //_Module.GetResourceInstance();
}

CIEMsgAb::~CIEMsgAb()
{
// #ifdef  TEST
    SafeRelease(m_pObjSite);
// #endif

    // unregister from Msgr list
    if(m_pCMsgrList)
    {
        m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
        OE_CloseMsgrList(m_pCMsgrList);
        m_pCMsgrList = NULL;
    }  
    
    SafeMemFree(m_szOnline);
    // SafeMemFree(m_szInvisible);
    SafeMemFree(m_szBusy);
    SafeMemFree(m_szBack);
    SafeMemFree(m_szAway);
    SafeMemFree(m_szOnPhone);
    SafeMemFree(m_szLunch);
    SafeMemFree(m_szOffline);
    SafeMemFree(m_szIdle);
    SafeMemFree(m_szMsgrEmptyList);
    SafeMemFree(m_szEmptyList);
    SafeMemFree(m_szLeftBr);
    SafeMemFree(m_szRightBr);

    // Raid-32933: OE: MSIMN.EXE doesn't always exit
    // g_pInstance->CoDecrementInit();
#ifdef LATER
    g_pInstance->DllRelease();
#endif
}

LRESULT CIEMsgAb::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    WORD wShow;
    if(m_fShowOnlineContacts)
        wShow = 2;
    else if(m_fShowOfflineContacts)
        wShow = 1;
    else
        wShow = 0;

    DwSetOptions((DWORD) MAKELONG(wShow, m_nSortType));

//    KillTimer(IDT_PANETIMER);
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);

#ifdef LATER
    if (m_dwFontCacheCookie && g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Unadvise(m_dwFontCacheCookie);
            pConnection->Release();
        }
    }
    m_cAddrBook.Unadvise();
#endif
    // RevokeDragDrop(m_hWnd); 

    if (m_himl != NULL)
        ImageList_Destroy(m_himl);
    return 0;
}

HRESULT CIEMsgAb::OnDraw(ATL_DRAWINFO& di)
{
    RECT&   rc = *(RECT*)di.prcBounds;

#if 0
    int     patGray[4];
    HBITMAP hbm;
    HBRUSH  hbr;
    COLORREF cFg;
    COLORREF cBkg;

    // Initialize the pattern
    patGray[0] = 0x005500AA;
    patGray[1] = 0x005500AA;
    patGray[2] = 0x005500AA;
    patGray[3] = 0x005500AA;

    // Create a bitmap from the pattern
    hbm = CreateBitmap(8, 8, 1, 1, (LPSTR)patGray);

    if ((HBITMAP) NULL != hbm)
    {
        hbr = CreatePatternBrush(hbm);
        if (hbr)
        {
            // Select the right colors into the DC
            cFg = SetTextColor(di.hdcDraw, GetSysColor(COLOR_3DFACE));
            cBkg = SetBkColor(di.hdcDraw, RGB(255, 255, 255));

            // Fill the rectangle
            FillRect(di.hdcDraw, &rc, hbr);

            SetTextColor(di.hdcDraw, cFg);
            SetBkColor(di.hdcDraw, cBkg);

            DeleteObject(hbr);
        }

        DeleteObject(hbm);
    }
#endif

    // Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    return S_OK;
}

LRESULT CIEMsgAb::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Define a bogus rectangle for the controls.  They will get resized in
    // our size handler.
    RECT rcPos = {0, 0, 100, 100};
    WCHAR       sz[CCHMAX_STRINGRES];

    // Create the various controls
    m_ctlList.Create(m_hWnd, rcPos, _T("Outlook Express Address Book ListView"),
                     WS_TABSTOP | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN |
                     LVS_REPORT | LVS_NOCOLUMNHEADER | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS /* | LVS_SORTASCENDING*/);

    if(m_ctlList.m_hWnd == NULL)
    {
        DWORD dwErr = GetLastError();
        Assert(FALSE);
    }

    ListView_SetUnicodeFormat(m_ctlList, TRUE);
    ListView_SetExtendedListViewStyleEx(m_ctlList, LVS_EX_INFOTIP | LVS_EX_LABELTIP, LVS_EX_INFOTIP | LVS_EX_LABELTIP);

    // Image List
    Assert(m_himl == NULL);
    m_himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbAddrBookHot), 16, 0,
                               RGB(255, 0, 255), IMAGE_BITMAP,
                               LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);

    ListView_SetImageList(m_ctlList, m_himl, LVSIL_SMALL);

    LVCOLUMN lvc;

    lvc.mask = LVCF_SUBITEM;
    lvc.iSubItem = 0;

    ListView_InsertColumn(m_ctlList, 0, &lvc);

#ifdef LATER
    m_ctlList.SendMessage(WM_SETFONT, NULL, 0);
    SetListViewFont(m_ctlList, GetListViewCharset(), TRUE);

    if (g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Advise((IUnknown *)(IFontCacheNotify *) this, &m_dwFontCacheCookie);
            pConnection->Release();
        }
    }
#endif

    if(!m_dwHideMessenger && !m_dwDisableMessenger)
    {
        // Msgr Initialization
        m_pCMsgrList = OE_OpenMsgrList();
        // Register our control for Msgr list
        if(m_pCMsgrList)
        {
            m_pCMsgrList->RegisterUIWnd(m_hWnd);
            if(m_pCMsgrList->IsLocalOnline())
            {
                m_fLogged = TRUE;
                FillMsgrList();
            }
        }
    }

    // Initialize the address book object too
    m_fWAB = CheckForWAB();
	if(m_fWAB)
	{
		HRESULT hr = m_cAddrBook.OpenWabFile(m_fWAB);
		if(hr == S_OK) // && m_fShowAllContacts)
			m_cAddrBook.LoadWabContents(m_ctlList, this);
	}
    else
    {   if(m_fShowAllContacts)
        {
            // Bug 23934. We show only online/offline contacts if we use Outlook
            m_fShowAllContacts = FALSE;
            m_fShowOnlineContacts = FALSE;
            m_fShowOfflineContacts = TRUE;
        }
    }

    st_pAddrBook = &m_cAddrBook;

    // Sort and Select the first item
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    ListView_SetItemState(m_ctlList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

    // Add the tooltip
    // Load Tooltip strings

    if(AthLoadString(idsBAOnline, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOnline, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szOnline, sz);
    }

    /* if(AthLoadString(idsBAInvisible, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szInvisible, lstrlen(sz) + 1))
            lstrcpy(m_szInvisible, sz);
    }*/

    if(AthLoadString(idsBABusy, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szBusy, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szBusy, sz);
    }

    if(AthLoadString(idsBABack, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szBack, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szBack, sz);
    }

    if(AthLoadString(idsBAAway, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szAway, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szAway, sz);
    }

    if(AthLoadString(idsBAOnPhone, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOnPhone, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szOnPhone, sz);
    }

    if(AthLoadString(idsBALunch, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szLunch, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szLunch, sz);
    }

    if(AthLoadString(idsBAOffline, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOffline, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szOffline, sz);
    }

    if(AthLoadString(idsBAIdle, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szIdle, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szIdle, sz);
    }

    if(AthLoadString(idsMsgrEmptyList, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szEmptyList, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szEmptyList, sz);
    }

    if(AthLoadString(idsMSNEmptyList, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szMsgrEmptyList, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szMsgrEmptyList, sz);
    }

    if(AthLoadString(idsLeftBr, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szLeftBr, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szLeftBr, sz);
    }
    if(AthLoadString(idsRightBr, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szRightBr, (lstrlenW(sz) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_szRightBr, sz);
    }

    m_ctlList.SetFocus();

    // Register ourselves as a drop target
    // RegisterDragDrop(m_hWnd, (IDropTarget *) this);

    // Update the size of the listview columns
    _AutosizeColumns();

    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));

//    SetTimer(IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
    // Finished
    return (0);
}

LRESULT CIEMsgAb::OnSetFocus(UINT  nMsg , WPARAM  wParam , LPARAM  lParam , BOOL&  bHandled )
{
    CComControlBase::OnSetFocus(nMsg, wParam, lParam, bHandled);
    m_ctlList.SetFocus();
#ifdef TEST
    if (m_pObjSite)
    {
        m_pObjSite->OnFocusChangeIS((IInputObject*) this, TRUE);
    }
#endif //TEST
    return 0;
}

LRESULT CIEMsgAb::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RECT rc;
    DWORD width = LOWORD(lParam);
    DWORD height = HIWORD(lParam);

    // Position the listview to fill the entire area
    RECT rcList;
    rcList.left   = 0;
    rcList.top    = 0;
    rcList.right  = width;
    rcList.bottom = height;

    m_ctlList.SetWindowPos(NULL, &rcList, SWP_NOACTIVATE | SWP_NOZORDER);

    // Update the size of the listview columns
    _AutosizeColumns();
    // bHandled = FALSE;
    return (0);
}

void CIEMsgAb::_AutosizeColumns(void)
{
    RECT rcList;
    m_ctlList.GetClientRect(&rcList);
    ListView_SetColumnWidth(m_ctlList, 0, rcList.right - 5);
}


#ifdef LATER
//
//  FUNCTION:   CMessageList::OnPreFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache before it changes the fonts we're
//              using.  In response we tell the ListView to dump any custom
//              font's it's using.
//
STDMETHODIMP CIEMsgAb::OnPreFontChange(void)
{
    m_ctlList.SendMessage(WM_SETFONT, 0, 0);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::OnPostFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache after it updates the font's we're
//              using.  In response, we set the new font for the current charset.
//
STDMETHODIMP CIEMsgAb::OnPostFontChange(void)
{
    SetListViewFont(m_ctlList, GetListViewCharset(), TRUE);
    return (S_OK);
}
#endif

LRESULT CIEMsgAb::CmdSetOnline(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();

    if(!pEntry || (pEntry->tag == LPARAM_MENTRY) || !m_pCMsgrList)
        return S_FALSE;

    // m_cAddrBook.SetDefaultMsgrID(pEntry->lpSB, pEntry->pchWABID);
    if(m_pCMsgrList && (PromptToGoOnline() == S_OK) )
        m_pCMsgrList->AddUser(pEntry->pchWABID);

    return S_OK;
}

LRESULT CIEMsgAb::CmdNewOnlineContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(m_pCMsgrList)
    {
        if(PromptToGoOnline() == S_OK)
            m_pCMsgrList->NewOnlineContact();
    }

    return S_OK;
}

LRESULT CIEMsgAb::CmdNewContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Tell the WAB to bring up it's new contact UI
	HRESULT hr = S_OK;

	if(!m_cAddrBook.fIsWabLoaded())
	{
		if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
			goto exit;
	}
    if(FAILED(hr = m_cAddrBook.NewContact(m_hWnd)))
		goto exit;

    _ReloadListview();
exit:
    return (hr);
}

LRESULT CIEMsgAb::NewInstantMessage(LPMABENTRY pEntry)
{
    if(((INT_PTR)  pEntry) == -1)
        return(m_pCMsgrList->SendInstMessage(NULL));
    else if(m_pCMsgrList)
    {
        if(PromptToGoOnline() == S_OK)
            return(m_pCMsgrList->SendInstMessage(pEntry->lpMsgrInfo->pchID));
    }

    return(S_OK);
}

LRESULT CIEMsgAb::CmdDialPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(CallPhone(NULL, FALSE));
}

LRESULT CIEMsgAb::CmdHomePhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    if(!pEntry || !(pEntry->lpPhones))
    {
        Assert(FALSE);
        return(E_FAIL);
    }
    return(CallPhone(pEntry->lpPhones->pchHomePhone, (pEntry->tag == LPARAM_MENTRY)));
}

LRESULT CIEMsgAb::CmdWorkPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    if(!pEntry || !(pEntry->lpPhones))
    {
        Assert(FALSE);
        return(E_FAIL);
    }
    return(CallPhone(pEntry->lpPhones->pchWorkPhone, (pEntry->tag == LPARAM_MENTRY)));
}

LRESULT CIEMsgAb::CmdMobilePhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    if(!pEntry || !(pEntry->lpPhones))
    {
        Assert(FALSE);
        return(E_FAIL);
    }
    return(CallPhone(pEntry->lpPhones->pchMobilePhone, (pEntry->tag == LPARAM_MENTRY)));
}

LRESULT CIEMsgAb::CmdIPPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    if(!pEntry || !(pEntry->lpPhones))
    {
        Assert(FALSE);
        return(E_FAIL);
    }
    return(CallPhone(pEntry->lpPhones->pchIPPhone, (pEntry->tag == LPARAM_MENTRY)));
}

LRESULT CIEMsgAb::CallPhone(WCHAR *wszPhone, BOOL fMessengerContact)
{
    WCHAR wszTmp[MAX_PATH] ={0};
    
    if((lstrlenW(wszPhone) + 5) >= MAX_PATH)
        return(E_FAIL);
    
    if(!(!m_pCMsgrList || !m_pCMsgrList->IsLocalOnline()))
    {
        // Use Messenger API
        if(fMessengerContact)
        {
            lstrcpyW(wszTmp, L"+");
            lstrcatW(wszTmp, wszPhone);
        }
        else
            lstrcpyW(wszTmp, wszPhone);
        
        if(SUCCEEDED(m_pCMsgrList->LaunchPhoneUI(wszTmp)))
            return(S_OK);
    }
    
    Assert(IsTelInstalled());
    
    lstrcpyW(wszTmp, L"Tel:");
    if(wszPhone)
    {
        lstrcatW(wszTmp, wszPhone);
    }
    
    SHELLEXECUTEINFOW ExecInfo;
    ExecInfo.cbSize = sizeof(SHELLEXECUTEINFOW);
    ExecInfo.nShow = SW_SHOWNORMAL;
    ExecInfo.fMask = 0;
    ExecInfo.hwnd = m_hWnd;
    ExecInfo.lpDirectory = NULL;
    ExecInfo.lpParameters = NULL;
    ExecInfo.lpVerb = L"open";
    ExecInfo.lpFile = wszTmp;
    
    if(!ShellExecuteExW(&ExecInfo))
    {
        WCHAR wszMsg[CCHMAX_STRINGRES];
        WCHAR wszTitle[CCHMAX_STRINGRES];

        if(!AthLoadString(idsAthena, wszTitle, ARRAYSIZE(wszTitle)))
            wszTitle[0] = L'\0';

        if(!AthLoadString(idsTelFail, wszMsg, ARRAYSIZE(wszMsg)))
            wszMsg[0] = L'\0';

        MessageBoxW(NULL, wszMsg, wszTitle, MB_OK | MB_ICONSTOP);

    }
    return(S_OK);
}

LRESULT CIEMsgAb::CmdNewEmaile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LVITEM                  lvi;
    LPMABENTRY              pEntry;
    LPRECIPLIST             lpList = NULL;
    LPRECIPLIST             lpListNext = lpList;
    ULONG                   nRecipCount = 0;
    TCHAR                   szBuf[MAX_PATH];
    HRESULT hr = S_OK;

    // Loop through the selected items
    lvi.mask = LVIF_PARAM;
    lvi.iItem = -1;
    lvi.iSubItem = 0;

    while (-1 != (lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVIS_SELECTED)))
    {
        // We need to get the entry ID from the item
        ListView_GetItem(m_ctlList, &lvi);

        // Tell the data source to add this person to the message
        pEntry = (LPMABENTRY) lvi.lParam;
        Assert(pEntry);

        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY)
        {
         //   m_cAddrBook.AddRecipient(pAddrTableW, pEntry->lpSB, FALSE);

            lpListNext = AddTeimToRecipList(lpListNext, pEntry->pchWABID, pEntry->pchWABName, pEntry->lpSB);
            if(!lpList)
                lpList = lpListNext;
            nRecipCount++;
        }
/*        else if(pEntry->tag == LPARAM_ABGRPENTRY)
            m_cAddrBook.AddRecipient(pAddrTableW, pEntry->lpSB, TRUE);*/
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            Assert(pEntry->lpMsgrInfo);
            lpListNext = AddTeimToRecipList(lpListNext, pEntry->lpMsgrInfo->pchID, pEntry->lpMsgrInfo->pchMsgrName, NULL);
            if(!lpList)
                lpList = lpListNext;
            nRecipCount++;
        }
        else
            Assert(FALSE);
    }


    if(nRecipCount)
        hr = HrStartMailThread( m_hWnd, nRecipCount,
                            lpList,                     // HrSendMail frees lpList so dont reuse
                            CheckForOutlookExpress(szBuf));

    return (hr);
}

LRESULT CIEMsgAb::CmdNewIMsg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(CmdNewMessage(wNotifyCode, ID_SEND_INSTANT_MESSAGE, hWndCtl, bHandled));
}

LRESULT CIEMsgAb::CmdNewMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LVITEM                  lvi;
    LPMABENTRY             pEntry;

    pEntry = GetEntryForSendInstMsg();

    if(wID == ID_SEND_INSTANT_MESSAGE)
    {
        if(pEntry)
            return(NewInstantMessage(pEntry));
        else
        {
            Assert(FALSE);
            return(-1);
        }
    }
    else if((((INT_PTR) pEntry) != -1) && pEntry)
        return(NewInstantMessage(pEntry));
    else
        return(CmdNewEmaile(wNotifyCode, wID, hWndCtl, bHandled));
}
// Exec for Properties command
LRESULT CIEMsgAb::CmdProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    LPMABENTRY pEntry = GetSelectedEntry();

    if(pEntry)
    {
        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
		{
			if(!m_cAddrBook.fIsWabLoaded())
			{
				if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
					return(hr);
			}

            m_cAddrBook.ShowDetails(m_hWnd, pEntry->lpSB);
		}
    }

    _ReloadListview();
    return (0);
}

LRESULT CIEMsgAb::NotifyDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLISTVIEW *pnmlv = (NMLISTVIEW *) pnmh;
    LVITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = pnmlv->iItem;
    lvi.iSubItem = 0;

    ListView_GetItem(m_ctlList, &lvi);
    LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

    if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
	{
		Assert(m_cAddrBook.fIsWabLoaded());
        m_cAddrBook.FreeListViewItem(pEntry->lpSB);
	}
    RemoveBlabEntry(pEntry);
    if(m_delItem > 0)
        m_delItem--;
    else
        Assert(FALSE);
    return (0);
}


LRESULT CIEMsgAb::NotifyItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    ULONG       uChanged;
    NMLISTVIEW *pnmlv = (NMLISTVIEW *) pnmh;

    if (pnmlv->uChanged & LVIF_STATE)
    {
        uChanged = pnmlv->uNewState ^ pnmlv->uOldState;
        if (uChanged & LVIS_SELECTED)
            _EnableCommands();
    }

    return (0);
}

// Sort compare
int CALLBACK BA_Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LPMABENTRY pEntry1 = (LPMABENTRY) lParam1;
    LPMABENTRY pEntry2 = (LPMABENTRY) lParam2;

    WCHAR pchName1[MAXNAME];
    WCHAR pchName2[MAXNAME];

    int nIndex1 = 0;
    int nIndex2 = 0 ;

    if(!(pEntry1->lpMsgrInfo))
    {
        nIndex1 = sizeof(BA_SortOrder)/sizeof(int);
        if(pEntry1->tag == LPARAM_ABGRPENTRY)
            nIndex1++;
    }
    else
    {
        while((pEntry1->lpMsgrInfo) && (BA_SortOrder[nIndex1] != pEntry1->lpMsgrInfo->nStatus) && (BA_SortOrder[nIndex1] != BIMSTATE_UNKNOWN))
            nIndex1++;
    }

    if(!(pEntry2->lpMsgrInfo))
    {
        nIndex2 = sizeof(BA_SortOrder)/sizeof(int);
        if(pEntry2->tag == LPARAM_ABGRPENTRY)
            nIndex2++;
    }
    else
    {
        while((BA_SortOrder[nIndex2] != pEntry2->lpMsgrInfo->nStatus) && (BA_SortOrder[nIndex2] != BIMSTATE_UNKNOWN))
            nIndex2++;
    }

    if(pEntry1->tag == LPARAM_MENTRY)              // if no AB entry
        lstrcpynW(pchName1, pEntry1->lpMsgrInfo->pchMsgrName, MAXNAME);
    else
        lstrcpynW(pchName1, pEntry1->pchWABName, MAXNAME);
        // st_pAddrBook->GetDisplayName(pEntry1->lpSB, pchName1);
    pchName1[MAXNAME - 1] = L'\0';

    if(pEntry2->tag == LPARAM_MENTRY)              // if no AB entry
        lstrcpynW(pchName2, pEntry2->lpMsgrInfo->pchMsgrName, MAXNAME);
    else
        lstrcpynW(pchName2, pEntry2->pchWABName, MAXNAME);
        // st_pAddrBook->GetDisplayName(pEntry2->lpSB, pchName2);
    pchName2[MAXNAME - 1] = L'\0';

    switch(lParamSort)
    {
        case BASORT_NAME_ACSEND:
            return(lstrcmpiW(pchName1, pchName2));

        case BASORT_NAME_DESCEND:
            return(lstrcmpiW(pchName2, pchName1));

        default:
            if((pEntry1->lpMsgrInfo) && (pEntry2->lpMsgrInfo) && (pEntry1->lpMsgrInfo->nStatus == pEntry2->lpMsgrInfo->nStatus))
            {
                if(lParamSort == BASORT_STATUS_ACSEND)
                    return(lstrcmpiW(pchName1, pchName2));
                else
                    return(lstrcmpiW(pchName2, pchName1));
            }
            else
            {
                if(lParamSort == BASORT_STATUS_ACSEND)
                    return(nIndex1 - nIndex2);
                else
                    return(nIndex2 - nIndex1);
            }
    }

    Assert(FALSE);
    return(0);
}

void CIEMsgAb::_EnableCommands(void)
{
#ifdef LATER
    if(g_pBrowser)
        g_pBrowser->UpdateToolbar();
#endif
}

LRESULT CIEMsgAb::NotifyItemActivate(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return (SendMessage(WM_COMMAND, ID_SEND_INSTANT_MESSAGE2, 0));
}


// GETDISPLAYINFO notification message
LRESULT CIEMsgAb::NotifyGetDisplayInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LV_DISPINFOW * plvdi = (LV_DISPINFOW *)pnmh;
    LRESULT hr;

    if(plvdi->item.lParam)
    {
        LPMABENTRY pEntry = (LPMABENTRY) plvdi->item.lParam;
        LPMABENTRY pFindEntry = NULL;

        if (plvdi->item.mask &  LVIF_IMAGE)
        {
            if((hr = SetUserIcon(pEntry, (pEntry->lpMsgrInfo ? pEntry->lpMsgrInfo->nStatus : BIMSTATE_OFFLINE), &(plvdi->item.iImage) ) ) != S_OK)
                return(hr);
        }

        if (plvdi->item.mask &  LVIF_TEXT)
        {

            if(pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
            {
                // if((hr = m_cAddrBook.GetDisplayName(pEntry->lpSB, plvdi->item.pszText)) != S_OK)
                //    return(hr);
                Assert(pEntry->pchWABName);
                lstrcpynW(plvdi->item.pszText, pEntry->pchWABName, plvdi->item.cchTextMax - 1);
                plvdi->item.pszText[plvdi->item.cchTextMax - 1] = L'\0';
            }
            else if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_MENTRY)
            {
#ifdef LATER
                if(pEntry->tag == LPARAM_MENTRY && (pEntry->lpMsgrInfo->nStatus == BIMSTATE_ONLINE) &&
                        lstrcmpiW(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID) && m_fWAB)
                {
                    lstrcpynW(plvdi->item.pszText, pEntry->lpMsgrInfo->pchMsgrName, plvdi->item.cchTextMax - 1);
                    plvdi->item.pszText[plvdi->item.cchTextMax - 1] = L'\0';

                    // Don't need redraw now, do it later
                    hr = MAPI_E_COLLISION; // m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID);
                    if(hr == MAPI_E_COLLISION)      // already have a contact in AB
                    {
                        int Index = -1;
                        WCHAR *pchID = NULL;

                        if(MemAlloc((LPVOID *) &pchID, (lstrlenW(pEntry->lpMsgrInfo->pchID) + 1)*sizeof(WCHAR)))
                        {
                            lstrcpyW(pchID, pEntry->lpMsgrInfo->pchID);
                            do
                            {
                                pFindEntry = FindUserEmail(pchID, &Index, FALSE);
                            }while((pFindEntry != NULL) && (pFindEntry->tag == LPARAM_MENTRY));

                            if(pFindEntry != NULL)
                            {
                                hr = m_cAddrBook.SetDefaultMsgrID(pFindEntry->lpSB, pchID);
                                if(hr == S_OK)
                                    _ReloadListview();
                            }
                            MemFree(pchID);
                        }
                    }
                    //if we not found...
                    if(hr != S_OK)
                    {
                        hr = m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID);
                        if(hr == S_OK)
                            _ReloadListview();
                    }

                }
                else
                {
#endif //LATER
                    lstrcpynW(plvdi->item.pszText, pEntry->lpMsgrInfo->pchMsgrName, plvdi->item.cchTextMax - 1);
                    plvdi->item.pszText[plvdi->item.cchTextMax - 1] = L'\0';
                    // plvdi->item.pszText = pEntry->lpMsgrInfo->pchMsgrName;
//                }
            }
            else    // Unknown tag
                Assert(FALSE);
        }
    }
    return S_OK;
}


LRESULT CIEMsgAb::NotifyGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLVGETINFOTIPW *plvgit = (NMLVGETINFOTIPW *) pnmh;

    LVITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = plvgit->iItem;
    lvi.iSubItem = plvgit->iSubItem;

    ListView_GetItem(m_ctlList, &lvi);

    LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

    if (pEntry->lpMsgrInfo != NULL)
    {
        StrCpyNW(plvgit->pszText, pEntry->lpMsgrInfo->pchMsgrName, plvgit->cchTextMax);
        StrCatBuffW(plvgit->pszText, m_szLeftBr, plvgit->cchTextMax);
        StrCatBuffW(plvgit->pszText, pEntry->lpMsgrInfo->pchID, plvgit->cchTextMax);
        StrCatBuffW(plvgit->pszText, m_szRightBr, plvgit->cchTextMax);

        LPCWSTR szStatus;

        switch(pEntry->lpMsgrInfo->nStatus)
        {
        case BIMSTATE_ONLINE:
            szStatus = m_szOnline;
            break;
        case BIMSTATE_BUSY:
            szStatus = m_szBusy;
            break;
        case BIMSTATE_BE_RIGHT_BACK:
            szStatus = m_szBack;
            break;
        case BIMSTATE_IDLE:
            szStatus = m_szIdle;
            break;
        case BIMSTATE_AWAY:
            szStatus = m_szAway;
            break;
        case BIMSTATE_ON_THE_PHONE:
            szStatus = m_szOnPhone;
            break;
        case BIMSTATE_OUT_TO_LUNCH:
            szStatus = m_szLunch;
            break;

        default:
            szStatus = m_szOffline;
            break;
        }

        StrCatBuffW(plvgit->pszText, szStatus, plvgit->cchTextMax);
    }

    else if (plvgit->dwFlags & LVGIT_UNFOLDED)
    {
        // If this is not a messenger item and the text
        // isn't truncated do not display a tooltip.

        plvgit->pszText[0] = L'\0';
    }

    return 0;
}


LRESULT CIEMsgAb::SetUserIcon(LPMABENTRY pEntry, int nStatus, int * pImage)
{
    switch(pEntry->tag)
    {
    case LPARAM_MENTRY:
    case LPARAM_MABENTRY:
        {
            switch(nStatus)
            {
            case BIMSTATE_ONLINE:
                *pImage = IMAGE_ONLINE;
                break;

            case BIMSTATE_INVISIBLE:
                *pImage = IMAGE_STOPSIGN;
                break;

            case BIMSTATE_BUSY:
                *pImage = IMAGE_STOPSIGN;
                break;

            case BIMSTATE_BE_RIGHT_BACK:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_BE_RIGHT_BACK;
                break;

            case BIMSTATE_IDLE:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_IDLE;
                break;

            case BIMSTATE_AWAY:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_AWAY;
                break;

            case BIMSTATE_ON_THE_PHONE:
                *pImage = IMAGE_STOPSIGN; // IMAGE_ON_THE_PHONE;
                break;

            case BIMSTATE_OUT_TO_LUNCH:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_OUT_TO_LUNCH;
                break;

            default:
                *pImage = IMAGE_OFFLINE;
                break;

            }
        }
        break;

    case LPARAM_ABGRPENTRY:
        // WAB group
        *pImage = IMAGE_DISTRIBUTION_LIST;
        break;

    default:
        // Not a buddy...
        if(pEntry->fCertificate)
            *pImage = IMAGE_CERT;
        else
            *pImage = IMAGE_NEW_MESSAGE;
        break;
    }
    return(S_OK);

}

// Return MAB entry for first selected item
LPMABENTRY CIEMsgAb::GetSelectedEntry()
{
    LVITEM lvi;

    // Get the focused item
    lvi.iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_SELECTED | LVNI_FOCUSED);

    // Get the lParam for that item
    if (lvi.iItem != -1)
    {
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;

        if(ListView_GetItem(m_ctlList, &lvi))
            return((LPMABENTRY) lvi.lParam);
    }
    return(NULL);   // unscucces
}


/*
LRESULT CIEMsgAb::CmdMsgrOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(m_pCMsgrList->LaunchOptionsUI()); // (MOPTDLG_GENERAL_PAGE);

}
*/

// Check entry for possibility to send Instant message
LPMABENTRY CIEMsgAb::GetEntryForSendInstMsg(LPMABENTRY pEntry)
{
    if(!IsMessengerInstalled())
        return(NULL);

    if(ListView_GetSelectedCount(m_ctlList) == 1)
    {
        if(!pEntry)     // if we don'y have pEntry yet then get it
            pEntry = GetSelectedEntry();

        if(pEntry && (pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_MENTRY) &&
                    (pEntry->lpMsgrInfo->nStatus != BIMSTATE_OFFLINE) && (pEntry->lpMsgrInfo->nStatus != BIMSTATE_INVISIBLE) &&
                    !(m_pCMsgrList->IsLocalName(pEntry->lpMsgrInfo->pchID)))
            return(pEntry);
    }

#ifdef NEED
    if(m_pCMsgrList)
    {
        if(m_pCMsgrList->IsLocalOnline() && (m_pCMsgrList->GetCount() > 0))
            return(NULL);   // should be /*return((LPMABENTRY) -1);*/ - temporary disabled (YST)
    }
#endif

    return(NULL);
}

// Display right-mouse click (context) menu
LRESULT CIEMsgAb::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPMABENTRY pEntry;
    HMENU       hPopup = 0;
    HWND        hwndHeader;
    int         id = 0;
    POINT       pt = { (int)(short) LOWORD(lParam), (int)(short) HIWORD(lParam) };
    int n = -1;
    // Figure out if this came from the keyboard or not
    if (lParam == -1)
    {
        Assert((HWND) wParam == m_ctlList);
        int i = ListView_GetFirstSel(m_ctlList);
        if (i == -1)
            return (0);

        ListView_GetItemPosition(m_ctlList, i, &pt);
        m_ctlList.ClientToScreen(&pt);
    }

    LVHITTESTINFO lvhti;
    lvhti.pt = pt;
    m_ctlList.ScreenToClient(&lvhti.pt);
    ListView_HitTest(m_ctlList, &lvhti);

    if (lvhti.iItem == -1)
        return (0);

    // Load the context menu
    hPopup = LoadPopupMenu(IDR_BA_POPUP);
    if (!hPopup)
        goto exit;

    pEntry = GetSelectedEntry();
    pEntry = GetEntryForSendInstMsg(pEntry);

    if(pEntry)
        SetMenuDefaultItem(hPopup, ID_SEND_INSTANT_MESSAGE, FALSE);
    else
        SetMenuDefaultItem(hPopup, ID_SEND_MESSAGE, FALSE);

    if (!m_pCMsgrList)
    {
        DeleteMenu(hPopup, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND);
        DeleteMenu(hPopup, ID_SET_ONLINE_CONTACT, MF_BYCOMMAND);
        DeleteMenu(hPopup, ID_NEW_ONLINE_CONTACT, MF_BYCOMMAND);
    }

    MenuUtil_EnablePopupMenu(hPopup, this);

    TrackPopupMenuEx(hPopup, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                     pt.x, pt.y, m_hWnd, NULL);

exit:
    if (hPopup)
        DestroyMenu(hPopup);

    return (0);
}

//
//  FUNCTION:   CIEMsgAb::DragEnter()
//
//  PURPOSE:    This get's called when the user starts dragging an object
//              over our target area.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
STDMETHODIMP CIEMsgAb::DragEnter(IDataObject* pDataObject, DWORD grfKeyState,
                                     POINTL pt, DWORD* pdwEffect)
{
    IEnumFORMATETC *pEnum;
    FORMATETC       fe;
    ULONG           celtFetched;

    // Verify we got this
    if (!pDataObject)
        return (S_OK);

    // Init
    ZeroMemory(&fe, sizeof(FORMATETC));

    // Set the default return value to be failure
    *pdwEffect = DROPEFFECT_NONE;

    // Get the FORMATETC enumerator for this data object
    if (SUCCEEDED(pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
    {
        // Walk through the data types to see if we can find the ones we're
        // interested in.
        pEnum->Reset();

        while (S_OK == pEnum->Next(1, &fe, &celtFetched))
        {
            Assert(celtFetched == 1);

#ifdef LATER
            // The only format we care about is CF_INETMSG
            if ((fe.cfFormat == CF_INETMSG) /*|| (fe.cfFormat == CF_OEMESSAGES)*/)
            {
                *pdwEffect = DROPEFFECT_COPY;
                break;
            }
#endif
        }

        pEnum->Release();
    }

    // We we're going to allow the drop, then keep a copy of the data object
    if (*pdwEffect != DROPEFFECT_NONE)
    {
        m_pDataObject = pDataObject;
        m_pDataObject->AddRef();
        m_cf = fe.cfFormat;
        m_fRight = (grfKeyState & MK_RBUTTON);
    }

    return (S_OK);
}


//
//  FUNCTION:   CIEMsgAb::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
STDMETHODIMP CIEMsgAb::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    // If we didn't cache a data object in IDropTarget::DragEnter(), we
    // blow this off.
    if (NULL == m_pDataObject)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return (S_OK);
    }

    // We always do a copy
    *pdwEffect = DROPEFFECT_COPY;
    return (S_OK);
}

//
//  FUNCTION:   CIEMsgAb::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
STDMETHODIMP CIEMsgAb::DragLeave(void)
{
    // Free everything up at this point.
    if (NULL != m_pDataObject)
    {
        m_pDataObject->Release();
        m_pDataObject = 0;
        m_cf = 0;
    }

    return (S_OK);
}


//
//  FUNCTION:   CIEMsgAb::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
STDMETHODIMP CIEMsgAb::Drop(IDataObject* pDataObject, DWORD grfKeyState,
                                POINTL pt, DWORD* pdwEffect)
{
    HRESULT             hr = S_OK;
#ifdef LATER
    FORMATETC           fe;
    STGMEDIUM           stm;
    IMimeMessage        *pMessage = 0;

    // Get the stream from the DataObject
    ZeroMemory(&stm, sizeof(STGMEDIUM));
    SETDefFormatEtc(fe, CF_INETMSG, TYMED_ISTREAM);

    if (FAILED(hr = pDataObject->GetData(&fe, &stm)))
        goto exit;

    // Create a new message object
    if (FAILED(hr = HrCreateMessage(&pMessage)))
        goto exit;

    // Load the message from the stream
    if (FAILED(hr = pMessage->Load(stm.pstm)))
        goto exit;

    // If this was a right-drag, then we bring up a context menu etc.
    if (m_fRight)
        _DoDropMenu(pt, pMessage);
    else
        _DoDropMessage(pMessage);

exit:
    ReleaseStgMedium(&stm);
    SafeRelease(pMessage);

    m_pDataObject->Release();
    m_pDataObject = 0;
    m_cf = 0;
#endif
    return (hr);
}

HRESULT CIEMsgAb::_DoDropMessage(LPMIMEMESSAGE pMessage)
{
    HRESULT     hr;
#ifdef LATER
    ADDRESSLIST addrList = { 0 };
    ULONG       i;
    SECSTATE    secState = {0};
    BOOL        fSignTrusted = FALSE;

    if(FAILED(hr = HandleSecurity(m_hWnd, pMessage)))
        return hr;

    if (IsSecure(pMessage) && SUCCEEDED(HrGetSecurityState(pMessage, &secState, NULL)))
    {
        fSignTrusted = !!IsSignTrusted(&secState);
        CleanupSECSTATE(&secState);
    }

    // Get the address list from the message
    hr = pMessage->GetAddressTypes(IAT_FROM | IAT_SENDER, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList);
    if (FAILED(hr))
        goto exit;

    // Loop through the addresses
    for (i = 0; i < addrList.cAdrs; i++)
    {
		if(!m_cAddrBook.fIsWabLoaded())
		{
			if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
				return(hr);
		}
        m_cAddrBook.AddAddress(addrList.prgAdr[i].pszFriendlyW, addrList.prgAdr[i].pszEmail);
#ifdef DEAD
        TCHAR *pch = StrStr(CharUpper(addrList.prgAdr[i].pszEmail), szHotMail);
        if((pch != NULL) && m_pCMsgrList)
            m_pCMsgrList->AddUser(addrList.prgAdr[i].pszEmail);
#endif // DEAD
    }

    if(fSignTrusted)
    {
        FILETIME ftNull = {0};
        HrAddSenderCertToWab(NULL, pMessage, NULL, NULL, NULL, ftNull, WFF_CREATE);
    }

#ifdef NEEDED
    // Reload the table
    _ReloadListview();
#endif

exit:
#endif
    return (S_OK);

}

HRESULT CIEMsgAb::_DoDropMenu(POINTL pt, LPMIMEMESSAGE pMessage)
{
    HRESULT     hr = S_OK;
#ifdef LATER
    ADDRESSLIST addrList = { 0 };
    ULONG       i;
    HMENU       hPopup = 0, hSubMenu = 0;
    UINT        id = 0;
    BOOL        fReload = FALSE;
    SECSTATE    secState = {0};
    BOOL        fSignTrusted = FALSE;

    // Get the address list from the message
    if(FAILED(hr = HandleSecurity(m_hWnd, pMessage)))
        return hr;

    if (IsSecure(pMessage) && SUCCEEDED(HrGetSecurityState(pMessage, &secState, NULL)))
    {
        fSignTrusted = !!IsSignTrusted(&secState);
        CleanupSECSTATE(&secState);
    }

    hr = pMessage->GetAddressTypes(IAT_KNOWN, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList);
    if (FAILED(hr))
        goto exit;

    // Load the context menu
    hPopup = LoadPopupMenu(IDR_BA_DRAGDROP_POPUP);
    if (!hPopup)
        goto exit;

    // Bold the "Save All" item
    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE;
    if (GetMenuItemInfo(hPopup, ID_SAVE_ALL, FALSE, &mii))
    {
        mii.fState |= MFS_DEFAULT;
        SetMenuItemInfo(hPopup, ID_SAVE_ALL, FALSE, &mii);
    }

    // Create the "Save >" item
    hSubMenu = CreatePopupMenu();

    // Loop through the addresses
    for (i = 0; i < addrList.cAdrs; i++)
    {
        AppendMenuWrapW(hSubMenu, MF_STRING | MF_ENABLED, ID_SAVE_ADDRESS_FIRST + i, addrList.prgAdr[i].pszFriendlyW);
    }

    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = hSubMenu;
    SetMenuItemInfo(hPopup, ID_SAVE, FALSE, &mii);

    id = TrackPopupMenuEx(hPopup, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                          pt.x, pt.y, m_hWnd, NULL);

    if (id == ID_SAVE_ALL_ADDRESSES)
    {
        for (i = 0; i < addrList.cAdrs; i++)
        {
            m_cAddrBook.AddAddress(addrList.prgAdr[i].pszFriendlyW, addrList.prgAdr[i].pszEmail);
        }
        fReload = TRUE;
    }
    else if (id >= ID_SAVE_ADDRESS_FIRST && id < ID_SAVE_ADDRESS_LAST)
    {
        m_cAddrBook.AddAddress(addrList.prgAdr[id - ID_SAVE_ADDRESS_FIRST].pszFriendlyW,
                               addrList.prgAdr[id - ID_SAVE_ADDRESS_FIRST].pszEmail);
        fReload = TRUE;
    }

    if(fSignTrusted)
    {
        FILETIME ftNull = {0};
        HrAddSenderCertToWab(NULL, pMessage, NULL, NULL, NULL, ftNull, WFF_CREATE);
    }


    if (fReload)
    {
        // Reload the table
        _ReloadListview();
    }

exit:
    if (hSubMenu)
        DestroyMenu(hSubMenu);

    if (hPopup)
        DestroyMenu(hPopup);
#endif
    return (S_OK);
}

LRESULT CIEMsgAb::CmdDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    LVITEM lvi;
    ENTRYLIST rList;
    ULONG cValues;
    SBinary UNALIGNED *pEntryId;
    BOOL fConfirm = TRUE;
    TCHAR szText[CCHMAX_STRINGRES + MAXNAME];
    WCHAR wszBuff[CCHMAX_STRINGRES];

    if(m_delItem > 0)
    {
        MessageBeep(MB_OK);
        return(S_OK);
    }

    if(m_fNoRemove)
        m_fNoRemove = FALSE;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = -1;

    // Figure out how many items are selected
    cValues = ListView_GetSelectedCount(m_ctlList);
    m_delItem = cValues;
    if (cValues != 1)
    {
        // Remove only Msgr entry
#ifdef LATER
        AthLoadString(idsBADelMultiple, wszBuff, ARRAYSIZE(szBuff));
        wsprintf(szText, szBuff, cValues);

        if(IDNO == AthMessageBoxW(NULL, MAKEINTRESOURCE(idsAthena), MAKEINTRESOURCE(idsAthena),
                NULL, MB_YESNO | MB_ICONEXCLAMATION))
        {
            return (0);
        }
        else
#endif // LATER
            if(m_fNoRemove)
        {
            MessageBeep(MB_OK);
            return(S_OK);
        }
        else
            fConfirm = FALSE;

        //        Assert(FALSE);
        //        return (0);
    }
    while(cValues > 0)
    {
        lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVNI_SELECTED);

        if(lvi.iItem < 0)
        {
ErrBeep:
            MessageBeep(MB_OK);
            return(S_OK);
        }
        // Get the item from the ListView
        if(ListView_GetItem(m_ctlList, &lvi) == FALSE)
            goto ErrBeep;

        // Check buddy state
        LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;
        if(pEntry->tag == LPARAM_MENTRY)
        {
            if(m_pCMsgrList && m_pCMsgrList->IsLocalOnline())
            {
                // Remove only Msgr entry
                if(fConfirm)
                {
#ifdef LATER
                    AthLoadString(idsBADelBLEntry, szBuff, ARRAYSIZE(szBuff));
                    wsprintf(szText, szBuff,  pEntry->lpMsgrInfo->pchMsgrName);


                    if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                        NULL, MB_YESNO | MB_ICONEXCLAMATION))
                    {
                        m_delItem = 0;
                        return (0);
                    }
                    else if(m_fNoRemove)
                        goto ErrBeep;
#endif // LATER

                }
                if(pEntry->lpMsgrInfo)
                {
                    m_delItem--;
                    hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
                }
                else
                {
                    m_delItem = 0;
                    return(S_OK);
                }
            }
            else
                goto ErrBeep;
        }
        else if(pEntry->tag == LPARAM_MABENTRY)
        {
            int nID = IDNO;
            if(fConfirm)
            {

#ifdef LATER
                AthLoadString(idsBADelBLABEntry, szBuff, ARRAYSIZE(szBuff));
                wsprintf(szText, szBuff, pEntry->pchWABName);

                nID = AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                    NULL, MB_YESNOCANCEL | MB_ICONEXCLAMATION);
#endif // LATER
            }
            if(((nID == IDYES) || !fConfirm) && !m_fNoRemove)
            {
                if(m_pCMsgrList && m_pCMsgrList->IsLocalOnline())
                {
                    // Remove only Msgr & AB entry
                    if(pEntry->lpMsgrInfo)
                        hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
                    else
                    {
                        m_delItem = 0;
                        return(S_OK);
                    }

                    // Allocate a structure big enough for all of 'em
                    if (MemAlloc((LPVOID *) &(rList.lpbin), sizeof(SBinary)))
                    {
                        rList.cValues = 0;
                        pEntryId = rList.lpbin;

                        *pEntryId = *(pEntry->lpSB);
                        pEntryId++;
                        rList.cValues = 1;
                        // Tell the WAB to delete 'em
                        m_nChCount++;    // increase count of our notification messages from WAB

						if(!m_cAddrBook.fIsWabLoaded())
						{
							if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
								return(hr);
						}

                        m_cAddrBook.DeleteItems(&rList);

                        // Free our array
                        MemFree(rList.lpbin);

                    }
                    // m_delItem++;
                    ListView_DeleteItem(m_ctlList, lvi.iItem);
                    lvi.iItem--;
                    ListView_SetItemState(m_ctlList, ((lvi.iItem >= 0) ? lvi.iItem : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                }
                else
                    MessageBeep(MB_OK);
            }
            else if((nID == IDNO) && !m_fNoRemove)
            {
                // Remove only Msgr entry
                m_delItem--;
                hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
            }
            else
            {
                // Remove nothing
                m_delItem--;
                hr = S_OK;
            }

        }
        else
        {
            // remove AN entry (group or contact)
            if(fConfirm)
            {
#ifdef LATER
                AthLoadString(idsBADelABEntry, szBuff, ARRAYSIZE(szBuff));
                wsprintf(szText, szBuff, pEntry->pchWABName);

                if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                    NULL, MB_YESNO | MB_ICONEXCLAMATION))
                {
                    m_delItem = 0;
                    return(0);
                }
                else if(m_fNoRemove)
                    goto ErrBeep;
#endif // LATER

            }
            // Allocate a structure big enough for all of 'em
            if(pEntry->lpSB)
            {
                if (MemAlloc((LPVOID *) &(rList.lpbin), sizeof(SBinary)))
                {
                    rList.cValues = 0;
                    pEntryId = rList.lpbin;

                    *pEntryId = *(pEntry->lpSB);
                    pEntryId++;
                    rList.cValues = 1;
                    // Tell the WAB to delete 'em
                    m_nChCount++;    // increase count of our notification messages from WAB

					if(!m_cAddrBook.fIsWabLoaded())
					{
						if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
							return(hr);
					}

                    m_cAddrBook.DeleteItems(&rList);

                    // Free our array
                    MemFree(rList.lpbin);
                }
            }
            // m_delItem++;
            ListView_DeleteItem(m_ctlList, lvi.iItem);
            lvi.iItem--;
        }
        cValues--;
    }

    if(ListView_GetItemCount(m_ctlList) > 0)
    {
        m_cEmptyList.Hide();
        ListView_SetItemState(m_ctlList, ((lvi.iItem >= 0) ? lvi.iItem : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    }
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));

    _ReloadListview();
    return (hr);
}

STDMETHODIMP CIEMsgAb::get_InstMsg(BOOL * pVal)
{
    *pVal = (GetEntryForSendInstMsg() != NULL);
    return S_OK;
}

/* STDMETHODIMP CIEMsgAb::put_InstMsg(BOOL newVal)
{
    return S_OK;
}  */

STDMETHODIMP CIEMsgAb::HasFocusIO()
{
    if (GetFocus() == m_ctlList)
        return S_OK;
    else
        return S_FALSE;
}

STDMETHODIMP CIEMsgAb::TranslateAcceleratorIO(LPMSG pMsg)
{
    if(!pMsg)
        goto SNDMsg;

#ifdef NEED
    if ((pMsg->message == WM_SYSKEYDOWN) && (pMsg->wParam == ((int) 'D')))
        return(S_FALSE);
#endif

    if (pMsg->message != WM_KEYDOWN)
        goto SNDMsg;

    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        goto SNDMsg;

    m_ctlList.SendMessage(WM_KILLFOCUS, (WPARAM) NULL, (LPARAM) 0);
    return S_OK;

SNDMsg:
    ::TranslateMessage(pMsg);
    ::DispatchMessage(pMsg);

    // m_ctlList.SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);

    return (S_OK);
}

STDMETHODIMP CIEMsgAb::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    if (!m_pObjSite)
        return E_FAIL;
    if (!IsWindow(m_hWnd))
    {
        IOleWindow  *pOleWnd;

        if (SUCCEEDED(m_pObjSite->QueryInterface(IID_IOleWindow, (LPVOID*)&pOleWnd)))
        {
            if(SUCCEEDED(pOleWnd->GetWindow(&m_hwndParent)))
            {
            //Will be resized by parent
            RECT    rect = {0};

            m_hWnd = CreateControlWindow(m_hwndParent, rect);
            if (!m_hWnd)
                return E_FAIL;
            }
        }
        pOleWnd->Release();
    }

    if (fActivate)
    {
        m_ctlList.SetFocus();
    }

    m_pObjSite->OnFocusChangeIS((IInputObject*) this, fActivate);
    return (S_OK);
}

STDMETHODIMP CIEMsgAb::SetSite(IUnknown  *punksite)
{
    //If we already have a site, we release it
    SafeRelease(m_pObjSite);

    IInputObjectSite    *pObjSite;
    if ((punksite) && (SUCCEEDED(punksite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pObjSite))))
    {
        m_pObjSite = pObjSite;

//         IOleWindow* pOleWindow;
//        if(SUCCEEDED(punksite->QueryInterface(IID_IOleWindowe, (LPVOID*)&pOleWindow))))
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CIEMsgAb::GetSite(REFIID  riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

HRESULT CIEMsgAb::RegisterFlyOut(CFolderBar *pFolderBar)
{
#ifdef LATER
    Assert(m_pFolderBar == NULL);
    m_pFolderBar = pFolderBar;
    m_pFolderBar->AddRef();
#endif
    return S_OK;
}

HRESULT CIEMsgAb::RevokeFlyOut(void)
{
#ifdef LATER
    if (m_pFolderBar)
    {
        m_pFolderBar->Release();
        m_pFolderBar = NULL;
    }
#endif
    return S_OK;
}

void CIEMsgAb::_ReloadListview(void)
{
    // Kill timer first
//    KillTimer(IDT_PANETIMER);

    // Turn off redrawing
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);
    SetWindowRedraw(m_ctlList, FALSE);
    int index = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);
    if(index == -1)
        index = 0;

    // Delete everything and reload
    SideAssert(ListView_DeleteAllItems(m_ctlList));
    if(m_pCMsgrList && m_pCMsgrList->IsLocalOnline())
    {
        m_fLogged = TRUE;
        FillMsgrList(); // User list reload
    }

    if(m_fShowAllContacts)
    {
		if(!m_cAddrBook.fIsWabLoaded())
		{
            if(FAILED(m_cAddrBook.OpenWabFile(m_fWAB)))
				return;
		}
        m_cAddrBook.LoadWabContents(m_ctlList, this);
    }

    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    ListView_SetItemState(m_ctlList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    ListView_EnsureVisible(m_ctlList, index, FALSE);
    SetWindowRedraw(m_ctlList, TRUE);
//    Invalidate(TRUE); //

   if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));

    UpdateWindow(/*m_ctlList*/);

//    SetTimer(IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
    return;
}

ULONG STDMETHODCALLTYPE CIEMsgAb::OnNotify(ULONG cNotif, LPNOTIFICATION pNotifications)
{
    // Well something changed in WAB, but we don't know what.  We should reload.
    // Sometimes these changes from us and we should ignore it.
    if(m_nChCount > 0)
        m_nChCount--;
    else
        _ReloadListview();
    return (0);
}

LRESULT CIEMsgAb::CmdFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    if(!m_cAddrBook.fIsWabLoaded())
	{
	    if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
		    return(hr);
    }

    m_cAddrBook.Find(m_hWnd);
    return (0);
}

LRESULT CIEMsgAb::CmdNewGroup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    if(!m_cAddrBook.fIsWabLoaded())
	{
	    if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
		    return(hr);
    }
    m_cAddrBook.NewGroup(m_hWnd);
    _ReloadListview();
    return (0);
}

LRESULT CIEMsgAb::CmdIEMsgAb(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    if(!m_cAddrBook.fIsWabLoaded())
	{
	    if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
		    return(hr);
    }
    m_cAddrBook.AddressBook(m_hWnd);
    return (0);
}

void CIEMsgAb::AddMsgrListItem(LPMINFO lpMsgrInfo)
{
    LV_ITEMW lvItem;
    m_cEmptyList.Hide(); // m,ust be sure that empty mesage is hide
    lvItem.iItem = ListView_GetItemCount(m_ctlList);
    lvItem.mask = LVIF_PARAM  | LVIF_IMAGE | LVIF_TEXT;
    lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_MENTRY, NULL, lpMsgrInfo, NULL, NULL, FALSE);
    lvItem.iSubItem = 0;
    lvItem.pszText = LPSTR_TEXTCALLBACKW;
    lvItem.iImage = I_IMAGECALLBACK;
    // SetUserIcon(LPARAM_MENTRY, lpMsgrInfo->nStatus, &(lvItem.iImage));
    ::SendMessage(m_ctlList, LVM_INSERTITEMW, 0, ((LPARAM) &lvItem));

    return;
}

HRESULT CIEMsgAb::FillMsgrList()
{
    LPMINFO pEntry = NULL;

    if(!m_pCMsgrList)
    {
        // Assert(FALSE); // Possible situation. See Bug 31262
        return(S_OK);
    }

    pEntry = m_pCMsgrList->GetFirstMsgrItem();

    while(pEntry)
    {
        // if(m_fShowAllContacts || ((pEntry->nStatus != BIMSTATE_OFFLINE) && (pEntry->nStatus != BIMSTATE_INVISIBLE) &&
        //             !(m_pCMsgrList->IsLocalName(pEntry->pchID) )))
        if(m_fShowAllContacts)
            AddMsgrListItem(pEntry);
        else if((m_fShowOnlineContacts || m_fShowOfflineContacts) && ((pEntry->nStatus != BIMSTATE_OFFLINE) && (pEntry->nStatus != BIMSTATE_INVISIBLE) &&
                     !(m_pCMsgrList->IsLocalName(pEntry->pchID))))
            AddMsgrListItem(pEntry);
        else if(m_fShowOfflineContacts && (((pEntry->nStatus == BIMSTATE_OFFLINE) || (pEntry->nStatus == BIMSTATE_INVISIBLE)) &&
                     !(m_pCMsgrList->IsLocalName(pEntry->pchID))))
            AddMsgrListItem(pEntry);

        pEntry = m_pCMsgrList->GetNextMsgrItem(pEntry);
    }
    return S_OK;
}

// Add BLAB table entry
LPMABENTRY CIEMsgAb::AddBlabEntry(MABENUM tag, LPSBinary lpSB, LPMINFO lpMsgrInfo, WCHAR *pchMail, WCHAR *pchDisplayName, BOOL fCert, LPPNONEENTRIES  lpPhs)
{
    WCHAR szName[MAXNAME];
    LPMABENTRY pEntry = NULL;
    WCHAR *pchName = NULL;
    int nLen = 0;

    if (!MemAlloc((LPVOID *) &pEntry, sizeof(mabEntry)))
        return(NULL);

    pEntry->tag = tag;
    pEntry->lpSB = lpSB;
    pEntry->pchWABName = NULL;
    pEntry->pchWABID = NULL;
    pEntry->fCertificate = fCert;
    pEntry->lpPhones = NULL;

    if(lpSB != NULL)
    {
        if(!pchDisplayName)
        {
            if(!m_cAddrBook.fIsWabLoaded())
	        {
	            if(FAILED(m_cAddrBook.OpenWabFile(m_fWAB)))
		            return(NULL);
            }
            m_cAddrBook.GetDisplayName(pEntry->lpSB, szName, MAXNAME);
            pchName = szName;
        }
        else
            pchName = pchDisplayName;

        if(pchName)
        {
            if (!MemAlloc((LPVOID *) &(pEntry->pchWABName), (lstrlenW(pchName) + 1)*sizeof(WCHAR) ))
            {
                MemFree(pEntry);
                return(NULL);
            }
            lstrcpyW(pEntry->pchWABName, pchName);
        }

        if(pchMail != NULL)
        {
            if (MemAlloc((LPVOID *) &(pEntry->pchWABID), (lstrlenW(pchMail) + 1)*sizeof(WCHAR) ))
                lstrcpyW(pEntry->pchWABID, pchMail);
        }
    }

    if(lpMsgrInfo && MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo), sizeof(struct _tag_OEMsgrInfo)))
    {

        pEntry->lpMsgrInfo->nStatus = lpMsgrInfo->nStatus;
        pEntry->lpMsgrInfo->pPrev = NULL;
        pEntry->lpMsgrInfo->pNext = NULL;

        if(lpMsgrInfo->pchMsgrName && MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo->pchMsgrName), (lstrlenW(lpMsgrInfo->pchMsgrName) + 1)*sizeof(WCHAR)))
            lstrcpyW(pEntry->lpMsgrInfo->pchMsgrName, lpMsgrInfo->pchMsgrName);
        else
            pEntry->lpMsgrInfo->pchMsgrName = NULL;

        if(lpMsgrInfo->pchID && MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo->pchID), (lstrlenW(lpMsgrInfo->pchID) + 1)*sizeof(WCHAR)))
            lstrcpyW(pEntry->lpMsgrInfo->pchID, lpMsgrInfo->pchID);
        else
            pEntry->lpMsgrInfo->pchID = NULL;

        if((lpMsgrInfo->pchWorkPhone || lpMsgrInfo->pchHomePhone || lpMsgrInfo->pchMobilePhone) && MemAlloc((LPVOID *) &(pEntry->lpPhones), sizeof(PNONEENTRIES)))
        {

            if(lpMsgrInfo->pchHomePhone && MemAlloc((LPVOID *) &(pEntry->lpPhones->pchHomePhone), (lstrlenW(lpMsgrInfo->pchHomePhone) + 1)*sizeof(WCHAR)))
                lstrcpyW(pEntry->lpPhones->pchHomePhone, lpMsgrInfo->pchHomePhone);
            else
                pEntry->lpPhones->pchHomePhone = NULL;

            if(lpMsgrInfo->pchWorkPhone && MemAlloc((LPVOID *) &(pEntry->lpPhones->pchWorkPhone), (lstrlenW(lpMsgrInfo->pchWorkPhone) + 1)*sizeof(WCHAR)))
                lstrcpyW(pEntry->lpPhones->pchWorkPhone, lpMsgrInfo->pchWorkPhone);
            else
                pEntry->lpPhones->pchWorkPhone = NULL;

            if(lpMsgrInfo->pchMobilePhone && MemAlloc((LPVOID *) &(pEntry->lpPhones->pchMobilePhone), (lstrlenW(lpMsgrInfo->pchMobilePhone) + 1)*sizeof(WCHAR)))
                lstrcpyW(pEntry->lpPhones->pchMobilePhone, lpMsgrInfo->pchMobilePhone);
            else
                pEntry->lpPhones->pchMobilePhone = NULL;

            pEntry->lpPhones->pchIPPhone = NULL;

            return(pEntry);
        }

    }
    else
        pEntry->lpMsgrInfo = NULL;

    // Add information about pfones
    if(lpPhs && MemAlloc((LPVOID *) &(pEntry->lpPhones), sizeof(PNONEENTRIES)))
    {
        if(lpPhs->pchHomePhone && (nLen = lstrlenW(lpPhs->pchHomePhone)))
        {
            if(MemAlloc((LPVOID *) &(pEntry->lpPhones->pchHomePhone), (nLen + 1)*sizeof(WCHAR)))
                lstrcpyW(pEntry->lpPhones->pchHomePhone, lpPhs->pchHomePhone);
            else
                pEntry->lpPhones->pchHomePhone = NULL;
        }
        else
            pEntry->lpPhones->pchHomePhone = NULL;

        if(lpPhs->pchWorkPhone && (nLen = lstrlenW(lpPhs->pchWorkPhone)))
        {
            if(MemAlloc((LPVOID *) &(pEntry->lpPhones->pchWorkPhone), (nLen + 1)*sizeof(WCHAR)))
                lstrcpyW(pEntry->lpPhones->pchWorkPhone, lpPhs->pchWorkPhone);
            else
                pEntry->lpPhones->pchWorkPhone = NULL;
        }
        else
            pEntry->lpPhones->pchWorkPhone = NULL;

        if(lpPhs->pchMobilePhone && (nLen = lstrlenW(lpPhs->pchMobilePhone)))
        {
            if(MemAlloc((LPVOID *) &(pEntry->lpPhones->pchMobilePhone), (nLen + 1)*sizeof(WCHAR)))
                lstrcpyW(pEntry->lpPhones->pchMobilePhone, lpPhs->pchMobilePhone);
            else
                pEntry->lpPhones->pchMobilePhone = NULL;
        }
        else
            pEntry->lpPhones->pchMobilePhone = NULL;

        if(lpPhs->pchIPPhone && (nLen = lstrlenW(lpPhs->pchIPPhone)))
        {
            if(MemAlloc((LPVOID *) &(pEntry->lpPhones->pchIPPhone), (nLen + 1)*sizeof(WCHAR)))
                lstrcpyW(pEntry->lpPhones->pchIPPhone, lpPhs->pchIPPhone);
            else
                pEntry->lpPhones->pchIPPhone = NULL;
        }
        else
            pEntry->lpPhones->pchIPPhone = NULL;
    }

    return(pEntry);
}

void CIEMsgAb::RemoveMsgrInfo(LPMINFO lpMsgrInfo)
{
    SafeMemFree(lpMsgrInfo->pchMsgrName);
    SafeMemFree(lpMsgrInfo->pchID);
    SafeMemFree(lpMsgrInfo);
}

// Remove BLAB table entry
void CIEMsgAb::RemoveBlabEntry(LPMABENTRY lpEntry)
{
    if(lpEntry == NULL)
        return;

    if(lpEntry->pchWABName)
        MemFree(lpEntry->pchWABName);

    if(lpEntry->pchWABID)
        MemFree(lpEntry->pchWABID);

    if(lpEntry->lpPhones)
    {
        if(lpEntry->lpPhones->pchHomePhone)
            MemFree(lpEntry->lpPhones->pchHomePhone);

        if(lpEntry->lpPhones->pchWorkPhone)
            MemFree(lpEntry->lpPhones->pchWorkPhone);

        if(lpEntry->lpPhones->pchMobilePhone)
            MemFree(lpEntry->lpPhones->pchMobilePhone);

        if(lpEntry->lpPhones->pchIPPhone)
            MemFree(lpEntry->lpPhones->pchIPPhone);
        MemFree(lpEntry->lpPhones);
    }

    if(lpEntry->lpMsgrInfo)
    {
        RemoveMsgrInfo(lpEntry->lpMsgrInfo);
        lpEntry->lpMsgrInfo = NULL;
    }

    MemFree(lpEntry);
    lpEntry = NULL;

    return;
}

// This function check buddy and if we have AB entry then set LPARAM_MABENTRY tag
void CIEMsgAb::CheckAndAddAbEntry(LPSBinary lpSB, WCHAR *pchEmail, WCHAR *pchDisplayName, DWORD nFlag, LPPNONEENTRIES pPhEnries)
{
    WCHAR szName[MAXNAME];
    LPMABENTRY pEntry = NULL;

    LV_ITEMW lvItem;

    lvItem.iItem = ListView_GetItemCount(m_ctlList);
    lvItem.mask = LVIF_PARAM  | LVIF_IMAGE | LVIF_TEXT;
    lvItem.iSubItem = 0;
    lvItem.pszText = LPSTR_TEXTCALLBACKW;
    lvItem.iImage = I_IMAGECALLBACK;

    m_cEmptyList.Hide(); // must be sure that empty mesage is hide
    if(!(nFlag & MAB_BUDDY))
    {
        if(m_fShowAllContacts || (m_fShowEmailContacts && pchEmail) || (m_fShowOthersContacts && (pchEmail == NULL)))
        {
            lvItem.lParam = (LPARAM) AddBlabEntry((nFlag & MAB_GROUP) ? LPARAM_ABGRPENTRY : LPARAM_ABENTRY, lpSB, NULL, pchEmail,
                                    pchDisplayName, (nFlag & MAB_CERT), pPhEnries);
        // SetUserIcon(LPARAM_ABGRPENTRY, 0, &(lvItem.iImage));

            ::SendMessage(m_ctlList, LVM_INSERTITEMW, 0, ((LPARAM) &lvItem));
            // ListView_InsertItem(m_ctlList, &lvItem);
        }
        return;
    }

    if(pchEmail)
        pEntry = FindUserEmail(pchEmail, NULL, TRUE);

    if(pEntry)      // buddy found
    {
        // if we already linked this budyy to AN entry, add new list item)
        if(pEntry->tag == LPARAM_MABENTRY)
        {
            lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_MABENTRY, lpSB, pEntry->lpMsgrInfo, pchEmail, pchDisplayName, (nFlag & MAB_CERT), pPhEnries);
            // SetUserIcon(LPARAM_MABENTRY, pEntry->lpMsgrInfo->nStatus, &(lvItem.iImage));
            ListView_InsertItem(m_ctlList, &lvItem);
        }
        else if(pEntry->tag == LPARAM_MENTRY)      // buddy was not linked to AB entry
        {
            pEntry->tag = LPARAM_MABENTRY;
            pEntry->lpSB = lpSB;
            Assert(lpSB);

            if(!m_cAddrBook.fIsWabLoaded())
	        {
	            if(FAILED(m_cAddrBook.OpenWabFile(m_fWAB)))
		            return;
            }

            m_cAddrBook.GetDisplayName(pEntry->lpSB, szName, MAXNAME);
            pEntry->pchWABName = NULL;
            pEntry->pchWABID = NULL;

            if (MemAlloc((LPVOID *) &(pEntry->pchWABName), (lstrlenW(szName) + 1)*sizeof(WCHAR) ))
                lstrcpyW(pEntry->pchWABName, szName);

            if(MemAlloc((LPVOID *) &(pEntry->pchWABID), (lstrlenW(pchEmail) + 1)*sizeof(WCHAR) ))
                lstrcpyW(pEntry->pchWABID, pchEmail);
        }
        else
            Assert(FALSE);      // something strange
    }
    else        // buddy not found, simple AB entry
    {
        if(m_fShowAllContacts || (m_fShowEmailContacts && pchEmail) || (m_fShowOthersContacts && (pchEmail == NULL)))
        {
            lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_ABENTRY, lpSB, NULL, pchEmail, pchDisplayName, (nFlag & MAB_CERT), pPhEnries);
            // SetUserIcon(LPARAM_ABENTRY, 0, &(lvItem.iImage));
            ListView_InsertItem(m_ctlList, &lvItem);
        }
    }
}

LPMABENTRY CIEMsgAb::FindUserEmail(WCHAR *pchEmail, int *pIndex, BOOL fMsgrOnly)
{
    LPMABENTRY pEntry = NULL;
    LVITEMW             lvi;

    lvi.mask = LVIF_PARAM;
    if(pIndex != NULL)
        lvi.iItem = *pIndex;
    else
        lvi.iItem = -1;
    lvi.iSubItem = 0;

    while((lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVNI_ALL)) != -1)
    {
        ListView_GetItem(m_ctlList, &lvi);
        pEntry = (LPMABENTRY) lvi.lParam;
        if(pEntry)
        {
            if(fMsgrOnly)
            {
                if(pEntry->lpMsgrInfo)
                {
                    if((pEntry->lpMsgrInfo)->pchID)
                    {
                        // lstrcat(szEmailName, szHotMailSuffix);
                        if(!lstrcmpiW((pEntry->lpMsgrInfo)->pchID, pchEmail))
                        {
                            if(pIndex != NULL)
                                *pIndex = lvi.iItem;
                            return(pEntry);
                        }
                    }
                }
            }
            else
            {
                if(pEntry->pchWABID)
                {
                    if(!lstrcmpiW(pEntry->pchWABID, pchEmail))
                    {
                        if(pIndex != NULL)
                            *pIndex = lvi.iItem;
                        return(pEntry);
                    }
                }
                if(pEntry->lpSB)
                {
                    Assert(m_cAddrBook.fIsWabLoaded());
                    if(m_cAddrBook.CheckEmailAddr(pEntry->lpSB, pchEmail))
                    {
                        if(pIndex != NULL)
                            *pIndex = lvi.iItem;
                        return(pEntry);
                    }
                }

            }
        }
    }

    return(NULL);
}

// messenger want shutown. release messenger object
HRESULT CIEMsgAb::OnMsgrShutDown(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    if(m_pCMsgrList)
    {
        m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
        OE_CloseMsgrList(m_pCMsgrList);
        m_pCMsgrList = NULL;
    }  
    m_dwHideMessenger = 1;
    m_dwDisableMessenger = 1;
    _ReloadListview();
    ::SendMessage(m_hwndParent, WM_MSGR_LOGRESULT, 0, 0);
    return(S_OK);
    
}

// Set new buddy status (online/ofline/etc. and redraw list view entry)
HRESULT CIEMsgAb::OnUserStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    LPMABENTRY  pEntry = NULL;
    int index = -1;
    BOOL fNeedRefresh = m_fShowOnlineContacts ;

    if(fNeedRefresh)
    {
        m_fShowOfflineContacts = TRUE;
        m_fShowOnlineContacts = FALSE;
        _ReloadListview();
    }

    while((pEntry = FindUserEmail((LPWSTR) lParam, &index, TRUE)) != NULL)
    {
        pEntry->lpMsgrInfo->nStatus = (int) wParam;
        ListView_RedrawItems(m_ctlList, index, index+1);
    }

    if(fNeedRefresh)
    {
        m_fShowOfflineContacts = FALSE;
        m_fShowOnlineContacts = TRUE;
        _ReloadListview();
    }

    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    return(hr);
}

// Message: buddy was removed
HRESULT CIEMsgAb::OnUserRemoved(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    int index = -1;
    LPMABENTRY  pEntry = NULL;

    while((pEntry = FindUserEmail((LPWSTR) lParam, &index, TRUE)) != NULL)
    {
        // Not removed yet
        if(pEntry->tag == LPARAM_MABENTRY)
        {
            Assert(pEntry->lpMsgrInfo);
            if(pEntry->lpMsgrInfo)
            {
                RemoveMsgrInfo(pEntry->lpMsgrInfo);

                pEntry->lpMsgrInfo = NULL;
            }

            pEntry->tag = LPARAM_ABENTRY;
            ListView_RedrawItems(m_ctlList, index, index+1);
        }
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            int index1 = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);
            m_delItem++;
            ListView_DeleteItem(m_ctlList, index);
            if(index == index1)
            {
                index1--;
                ListView_SetItemState(m_ctlList, ((index1 >= 0) ? index1 : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            }
        }
        else
            index++;
    }

    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));
    return(hr);
}

// Event User was added => add buddy to our list.
HRESULT CIEMsgAb::OnUserAdded(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    LPMINFO  pEntry =  (LPMINFO) lParam;
    
    if(m_fShowAllContacts)
        AddMsgrListItem(pEntry);
    else if((m_fShowOnlineContacts || m_fShowOfflineContacts) && ((pEntry->nStatus != BIMSTATE_OFFLINE) && (pEntry->nStatus != BIMSTATE_INVISIBLE) &&
        !(m_pCMsgrList->IsLocalName(pEntry->pchID))))
        AddMsgrListItem(pEntry);
    else if(m_fShowOfflineContacts && (((pEntry->nStatus == BIMSTATE_OFFLINE) || (pEntry->nStatus == BIMSTATE_INVISIBLE)) &&
        !(m_pCMsgrList->IsLocalName(pEntry->pchID))))
        AddMsgrListItem(pEntry);
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    
    return(S_OK);
}

HRESULT CIEMsgAb::OnUserNameChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
#ifdef NEEDED
    LPMINFO  pItem =  (LPMINFO) lParam;
    LPMABENTRY  pEntry = NULL;
    int index = -1;

    while((pEntry = FindUserEmail(pItem->pchID, &index, TRUE)) != NULL)
    {
        if((pEntry->tag == LPARAM_MENTRY) && lstrcmpi(pItem->pchID, pItem->pchMsgrName))
        {
            hr = m_cAddrBook.AutoAddContact(pItem->pchMsgrName, pItem->pchID);
            // _ReloadListview();
        }
        ListView_RedrawItems(m_ctlList, index, index+1);
    }
#endif
    _ReloadListview();
    return(hr);
}

HRESULT CIEMsgAb::OnUserLogoffEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    ::SendMessage(m_hwndParent, nMsg, wParam, lParam);

    if(!m_fLogged)
        return S_OK;
    else
        m_fLogged = FALSE;

    SetWindowRedraw(m_ctlList, FALSE);
    int index = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);

    // Delete everything and reload
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);
    ListView_DeleteAllItems(m_ctlList);
//     FillMsgrList();                         // User list reload
    if(m_fShowAllContacts)
    {
        if(!m_cAddrBook.fIsWabLoaded())
	    {
	        if(FAILED(hr = m_cAddrBook.OpenWabFile(m_fWAB)))
		        return(hr);
        }

        m_cAddrBook.LoadWabContents(m_ctlList, this);
    }

    ListView_SetItemState(m_ctlList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    SetWindowRedraw(m_ctlList, TRUE);

    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPWSTR) (m_fShowAllContacts ? m_szEmptyList : m_szMsgrEmptyList));
    UpdateWindow(/*m_ctlList*/);

    return S_OK;

}

HRESULT CIEMsgAb::OnLocalStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    ::SendMessage(m_hwndParent, nMsg, wParam, lParam);

    return S_OK;
}

HRESULT CIEMsgAb::OnUserLogResultEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    ::SendMessage(m_hwndParent, nMsg, wParam, lParam);

    _ReloadListview();

    if(SUCCEEDED(lParam))
    {
        m_fLogged = TRUE;
    }
    return S_OK;
}

LRESULT CIEMsgAb::NotifyKillFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT hres = E_FAIL;

    if (m_pObjSite != NULL)
        {
        IInputObjectSite *pis;

        hres = m_pObjSite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pis);
        if (SUCCEEDED(hres))
            {
            hres = pis->OnFocusChangeIS((IInputObject*) this, FALSE);
            pis->Release();
            }
        }
    return (hres);
}

LRESULT CIEMsgAb::NotifySetFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
// #ifdef LATER
//    UnkOnFocusChangeIS(m_pObjSite, (IInputObject*) this, TRUE);
// #endif
    HRESULT hres = S_OK;

/*    if (m_pObjSite != NULL)
        {
        IInputObjectSite *pis;

        hres = m_pObjSite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pis);
        if (SUCCEEDED(hres))
            {
            hres = pis->OnFocusChangeIS((IInputObject*) this, TRUE);
            pis->Release();
            }
        }*/
    return (hres);
}

HRESULT  STDMETHODCALLTYPE CIEMsgAb::QueryStatus(const GUID *pguidCmdGroup,
                                                ULONG cCmds, OLECMD *prgCmds,
                                                OLECMDTEXT *pCmdText)
{
    int     nEnable;
    HRESULT hr;
    DWORD   cSelected = ListView_GetSelectedCount(m_ctlList);
    UINT    id;
    BIMSTATE  State;

    // Loop through all the commands in the array
    for ( ; cCmds > 0; cCmds--, prgCmds++)
    {
        // Only look at commands that don't have OLECMDF_SUPPORTED;
        if (prgCmds->cmdf == 0)
        {
            switch (prgCmds->cmdID)
            {
                case ID_HIDE_IM:
                    if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else if(!m_dwDisableMessenger)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_INVISIBLE;

                    break;

                case ID_SHOW_IM:
                    if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else if(!m_dwDisableMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                // These commands are enabled if and only if one item is selected
                case ID_DELETE_CONTACT:
                    if (cSelected > 0)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_FIND_PEOPLE:
                case ID_ADDRESS_BOOK:
                    if(m_fWAB)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    break;

                case ID_SEND_MESSAGE:
                    if((HasFocusIO() == S_OK) && cSelected >= 1)
                       prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SEND_INSTANT_MESSAGE2:
                {
                    if (cSelected == 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_SORT_BY_STATUS:
                    if(!IsMessengerInstalled())
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }
                    else
                        if(ListView_GetItemCount(m_ctlList) > 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    if((m_nSortType == BASORT_STATUS_ACSEND) || (m_nSortType == BASORT_STATUS_DESCEND))
                        prgCmds->cmdf |= OLECMDF_NINCHED;
                    break;

                case ID_SORT_BY_NAME:
                    if(!IsMessengerInstalled())
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }
                    else if(ListView_GetItemCount(m_ctlList) > 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    if((m_nSortType == BASORT_NAME_ACSEND) || (m_nSortType == BASORT_NAME_DESCEND))
                        prgCmds->cmdf |= OLECMDF_NINCHED;


                    break;

                // These commands are always enabled
                case ID_POPUP_NEW_ACCOUNT:
                case ID_NEW_HOTMAIL_ACCOUNT:
                case ID_NEW_ATT_ACCOUNT:
                case ID_NEW_CONTACT:
                case ID_POPUP_MESSENGER:
                    prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SET_ONLINE_CONTACT:
                    {
                        if(m_dwHideMessenger)
                        {
                            prgCmds->cmdf = OLECMDF_INVISIBLE;
                            break;
                        }
                        else if(cSelected != 1)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                        LPMABENTRY pEntry = GetSelectedEntry();
                        if(!pEntry && m_pCMsgrList)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                        else if(pEntry && pEntry->tag != LPARAM_ABENTRY)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                    }
                case ID_NEW_ONLINE_CONTACT:
                    if(m_pCMsgrList)
                    {
                        if(m_pCMsgrList->IsLocalOnline())
                            prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                    }
                    else if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    break;

                // Properties is only enabled if the input focus is in the
                // list view.  Otherwise, we don't mark it as supported at all.
                case ID_PROPERTIES:
                {
                    LPMABENTRY pEntry = GetSelectedEntry();
                    if(pEntry && pEntry->tag != LPARAM_MENTRY)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_VIEW_ONLINE:
                    if(m_fShowOnlineContacts)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED ;
                    break;

                case ID_VIEW_ONANDOFFLINE:
                    if(m_fShowOfflineContacts)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED ;
                    break;

                case ID_VIEW_ALL:
                    if(m_fShowAllContacts)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED ;
                    break;

                case ID_MESSENGER_OPTIONS:

                    if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else if (!m_pCMsgrList)
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                    break;

                case ID_CALL:
                case ID_DIAL_PHONE_NUMBER:
                    if((ListView_GetItemCount(m_ctlList) < 1) || (!IsTelInstalled())) // && (!m_pCMsgrList || !m_pCMsgrList->IsLocalOnline())))
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_HOME_PHONE:
                case ID_WORK_PHONE:
                case ID_MOBILE_PHONE:
                case ID_IP_PHONE:
                    if(_FillPhoneNumber(prgCmds->cmdID, pCmdText))
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    break;

                case SEP_PHONE:
                    {
                    LPMABENTRY pEntry = GetSelectedEntry();
                    if(pEntry  && pEntry->lpPhones && (pEntry->lpPhones->pchIPPhone || pEntry->lpPhones->pchMobilePhone || pEntry->lpPhones->pchWorkPhone || pEntry->lpPhones->pchHomePhone))
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    }
                    break;

                // These depend on whether
                case ID_LOGIN_MESSENGER:
                case ID_LOGOFF_MESSENGER:
                case ID_MESSENGER_ONLINE:
                case ID_MESSENGER_INVISIBLE:
                case ID_MESSENGER_BUSY:
                case ID_MESSENGER_BACK:
                case ID_MESSENGER_AWAY:
                case ID_MESSENGER_ON_PHONE:
                case ID_MESSENGER_LUNCH:
                case ID_POPUP_MESSENGER_STATUS:
                {
                    // If messenger isn't installed, then none of these commands will
                    // be enabled.
                    if(m_dwHideMessenger)
                    {
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                        break;
                    }
                    else if (!m_pCMsgrList)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }

                    if (FAILED(m_pCMsgrList->GetLocalState(&State)))
                        State = BIMSTATE_UNKNOWN;

                    // Convert the online state to a command ID
                    switch (State)
                    {
                        case BIMSTATE_ONLINE:
                        case BIMSTATE_IDLE:
                            id = ID_MESSENGER_ONLINE;
                            break;
                        case BIMSTATE_INVISIBLE:
                            id = ID_MESSENGER_INVISIBLE;
                            break;
                        case BIMSTATE_BUSY:
                            id = ID_MESSENGER_BUSY;
                            break;
                        case BIMSTATE_BE_RIGHT_BACK:
                            id = ID_MESSENGER_BACK;
                            break;
                        case BIMSTATE_AWAY:
                            id = ID_MESSENGER_AWAY;
                            break;
                        case BIMSTATE_ON_THE_PHONE:
                            id = ID_MESSENGER_ON_PHONE;
                            break;
                        case BIMSTATE_OUT_TO_LUNCH:
                            id = ID_MESSENGER_LUNCH;
                            break;
                        default:
                            id = 0xffff;
                    }

                    // Logon is handled a bit seperatly
                    if (prgCmds->cmdID == ID_LOGIN_MESSENGER)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id == 0xffff)
                            prgCmds->cmdf |= OLECMDF_ENABLED;
                    }
                    else if (prgCmds->cmdID == ID_LOGOFF_MESSENGER)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id != 0xffff)
                            prgCmds->cmdf |= OLECMDF_ENABLED;
                    }
                    else
                    {
                        // For all other commands, if we in a known state
                        // then the command is enabled.
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id != 0xffff)
                            prgCmds->cmdf = OLECMDF_ENABLED;

                        // If the command is the same as our state, it should be checked
                        if (id == prgCmds->cmdID)
                            prgCmds->cmdf |= OLECMDF_NINCHED;
                    }
                }
                break;

                case ID_SEND_INSTANT_MESSAGE:
                {
                    if(m_dwHideMessenger)
                        prgCmds->cmdf = OLECMDF_INVISIBLE;
                    else if (GetEntryForSendInstMsg())
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }
            }
        }
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CIEMsgAb::Exec(const GUID  *pguidCmdGroup,
                                                    DWORD        nCmdID,
                                                    DWORD        nCmdExecOpt,
                                                    VARIANTARG   *pvaIn,
                                                    VARIANTARG   *pvaOut)
{
    HRESULT     hr = OLECMDERR_E_NOTSUPPORTED;
    BOOL        bHandled = 0;
    BIMSTATE      State = BIMSTATE_UNKNOWN;

    switch (nCmdID)
    {

    case ID_HIDE_IM:
        Assert(!m_dwHideMessenger && !m_dwDisableMessenger)

        m_dwDisableMessenger = 1;
        DwSetDisableMessenger(m_dwDisableMessenger);
        if(m_pCMsgrList)
        {
            m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
            OE_CloseMsgrList(m_pCMsgrList);
            m_pCMsgrList = NULL;
            _ReloadListview();
        }
        ::SendMessage(m_hwndParent, WM_MSGR_LOGRESULT, 0, 0);
        break;

    case ID_SHOW_IM:
        Assert(!m_dwHideMessenger && m_dwDisableMessenger)

        m_dwDisableMessenger = 0;
        DwSetDisableMessenger(m_dwDisableMessenger);
        if(!m_pCMsgrList)
        {
            m_pCMsgrList = OE_OpenMsgrList();
            // Register our control for Msgr list
            if(m_pCMsgrList)
            {
                m_pCMsgrList->RegisterUIWnd(m_hWnd);
                if(m_pCMsgrList->IsLocalOnline())
                {
                    m_fLogged = TRUE;
                    FillMsgrList();
                    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
                }
            }
        }
        ::SendMessage(m_hwndParent, WM_MSGR_LOGRESULT, 0, 0);

        break;

    case ID_SHOWALLCONTACT:
        if(m_fShowAllContacts)
        {
            m_fShowAllContacts = FALSE;
            m_fShowOnlineContacts = TRUE;
            m_fShowOfflineContacts = FALSE;
        }
        else if(m_fShowOnlineContacts)
        {
            m_fShowAllContacts = FALSE;
            m_fShowOnlineContacts = FALSE;
            m_fShowOfflineContacts = TRUE;
        }
        else if(m_fShowOfflineContacts)
        {
            m_fShowAllContacts = TRUE;
            m_fShowOnlineContacts = FALSE;
            m_fShowOfflineContacts = FALSE;
        }
        _ReloadListview();
        break;

    case ID_VIEW_ONLINE:
        m_fShowAllContacts = FALSE;
        m_fShowOfflineContacts = FALSE;
        m_fShowOnlineContacts = TRUE;
        _ReloadListview();
        break;

    case ID_VIEW_ONANDOFFLINE:
        m_fShowAllContacts = FALSE;
        m_fShowOnlineContacts = FALSE;
        m_fShowOfflineContacts = TRUE;
        _ReloadListview();
        break;

    case ID_VIEW_ALL:
        m_fShowAllContacts = TRUE;
        m_fShowOnlineContacts = FALSE;
        m_fShowOfflineContacts = FALSE;
        _ReloadListview();
        break;

    case ID_DIAL_PHONE_NUMBER:
        CallPhone(NULL, FALSE);
        break;

    case ID_HOME_PHONE:
    case ID_WORK_PHONE:
    case ID_MOBILE_PHONE:
    case ID_IP_PHONE:
        {
        LPMABENTRY pEntry = GetSelectedEntry();
        if(!pEntry || !(pEntry->lpPhones))
        {
            Assert(FALSE);
            break;
        }
        switch(nCmdID)
        {
        case ID_HOME_PHONE:
            CallPhone(pEntry->lpPhones->pchHomePhone, (pEntry->tag == LPARAM_MENTRY));
            break;

        case ID_WORK_PHONE:
            CallPhone(pEntry->lpPhones->pchWorkPhone, (pEntry->tag == LPARAM_MENTRY));
            break;

        case ID_MOBILE_PHONE:
            CallPhone(pEntry->lpPhones->pchMobilePhone, (pEntry->tag == LPARAM_MENTRY));
            break;

        case ID_IP_PHONE:
            CallPhone(pEntry->lpPhones->pchIPPhone, (pEntry->tag == LPARAM_MENTRY));
            break;
        }
        }
        break;

    case ID_SEND_INSTANT_MESSAGE2:
        CmdNewMessage(HIWORD(nCmdID), ID_SEND_INSTANT_MESSAGE2, m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_DELETE_CONTACT:
        hr = (HRESULT) CmdDelete(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;

    case ID_NEW_CONTACT:
//        if(HasFocusIO() == S_OK)
        CmdNewContact(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_SET_ONLINE_CONTACT:
        CmdSetOnline(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_NEW_ONLINE_CONTACT:
        CmdNewOnlineContact(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_PROPERTIES:
        CmdProperties(0, 0, m_ctlList, bHandled);
        hr = S_OK;
        break;

#ifdef GEORGEH
    case ID_NEW_MSG_DEFAULT:
        if(HasFocusIO() == S_OK)
            hr = CmdNewMessage(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;
#endif // GEORGEH

    case ID_FIND_PEOPLE:
    case ID_ADDRESS_BOOK:
        {
            WCHAR wszWABExePath[MAX_PATH];
            if(S_OK == HrLoadPathWABEXE(wszWABExePath, sizeof(wszWABExePath)/sizeof(wszWABExePath[0])))
            {
                SHELLEXECUTEINFOW ExecInfo;
                ExecInfo.cbSize = sizeof(SHELLEXECUTEINFOW);
                ExecInfo.nShow = SW_SHOWNORMAL;
                ExecInfo.fMask = 0;
                ExecInfo.hwnd = NULL;
                ExecInfo.lpDirectory = NULL;
                ExecInfo.lpParameters = ((nCmdID == ID_FIND_PEOPLE) ? L"/find" : L"");
                ExecInfo.lpVerb = L"open";
                ExecInfo.lpFile = wszWABExePath;

                ShellExecuteExW(&ExecInfo);

                // ShellExecuteW(NULL, L"open", wszWABExePath,
                //            ((nCmdID == ID_FIND_PEOPLE) ? L"/find" : L""),
                //            "", SW_SHOWNORMAL);

            }
            break;
        }

    case ID_SEND_MESSAGE:
        if(HasFocusIO() == S_OK)
            hr = (HRESULT) CmdNewEmaile(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;

    case ID_SEND_INSTANT_MESSAGE:
        // Assert(m_pCMsgrList);
        CmdNewIMsg(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_MESSENGER_OPTIONS:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->LaunchOptionsUI(); //CmdMsgrOptions();
        break;

    case ID_MESSENGER_ONLINE:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_ONLINE);
        break;

    case ID_MESSENGER_INVISIBLE:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_INVISIBLE);
        break;

    case ID_MESSENGER_BUSY:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_BUSY);
        break;

    case ID_MESSENGER_BACK:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_BE_RIGHT_BACK);
        break;

    case ID_MESSENGER_AWAY:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_AWAY);
        break;

    case ID_MESSENGER_ON_PHONE:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_ON_THE_PHONE);
        break;

    case ID_MESSENGER_LUNCH:
        if(m_pCMsgrList)
            hr = m_pCMsgrList->SetLocalState(BIMSTATE_OUT_TO_LUNCH);
        break;

    case ID_LOGIN_MESSENGER:
        if(m_pCMsgrList)
        {
            if(!m_pCMsgrList->IsLocalOnline())
            {
                if(PromptToGoOnline() == S_OK)
                    m_pCMsgrList->UserLogon();
            }
            hr = S_OK;
        }
        break;

    case ID_LOGOFF_MESSENGER:
        Assert(m_pCMsgrList);
        if(m_pCMsgrList)
                m_pCMsgrList->UserLogoff();
        hr = S_OK;
        break;

    case ID_SORT_BY_NAME:
        m_nSortType = BASORT_NAME_ACSEND;
        ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
        break;

    case ID_SORT_BY_STATUS:
        m_nSortType = BASORT_STATUS_ACSEND;
        ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
        break;

    default:
        break;
    }
    return hr;
}


// fill a phone number for menu
BOOL CIEMsgAb::_FillPhoneNumber(UINT Id, OLECMDTEXT *pcmdText)
{
    LPMABENTRY pEntry = GetSelectedEntry();
    WCHAR   szTmp[CCHMAX_STRINGRES];
    WCHAR * pch = NULL;
    TCHAR * pchStr = NULL;

    if(!pEntry || !(pEntry->lpPhones))
    {
err:
        pcmdText->cwBuf = 0;
        return(FALSE);
    }

    szTmp[0] = L'\0';
    switch(Id)
    {
    case ID_HOME_PHONE:
        pch = pEntry->lpPhones->pchHomePhone;
        AthLoadString(idsHome, szTmp, ARRAYSIZE(szTmp));
        break;

    case ID_WORK_PHONE:
        pch = pEntry->lpPhones->pchWorkPhone;
        AthLoadString(idsWork, szTmp, ARRAYSIZE(szTmp));
        break;

    case ID_MOBILE_PHONE:
        pch = pEntry->lpPhones->pchMobilePhone;
        AthLoadString(idsMobile, szTmp, ARRAYSIZE(szTmp));
        break;

    case ID_IP_PHONE:
        pch = pEntry->lpPhones->pchIPPhone;
        AthLoadString(idsIPPhone, szTmp, ARRAYSIZE(szTmp));
        break;

    default:
        pch = NULL;
        Assert(FALSE);
        break;
    }

    if(!pch)
        goto err;

    if(pcmdText->cmdtextf == OLECMDTEXTF_NONE)
        return(TRUE);

    pcmdText->cwBuf = (lstrlenW(pch) + 2 + lstrlenW(szTmp));
    if(pcmdText->cwBuf > MAX_MENUSTR)
        Assert(FALSE);

    else
    {
#ifdef NEW
        if(!MultiByteToWideChar(GetACP(), 0, pch, -1, pcmdText->rgwz, pcmdText->cwBuf))
        {
            Assert(FALSE);
            pcmdText->cwBuf = 0;
        }
#else
        pchStr = ((TCHAR *)(pcmdText->rgwz));

        LPTSTR pchTmpA = LPTSTRfromBstr(pch);
        lstrcpy(pchStr, pchTmpA);
        MemFree(pchTmpA);

        LPTSTR pchA = LPTSTRfromBstr(szTmp);
        lstrcat(pchStr, pchA);
        MemFree(pchA);

        pcmdText->cwActual = lstrlen(pchStr) + 1;
        // pcmdText->rgwz = ((WCHAR *) pchStr);

#endif

    }
/*    else
        goto err; */

    return(TRUE);
}

STDMETHODIMP CIEMsgAb::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
#ifdef LATER
    TCHAR sz[CCHMAX_STRINGRES];
    if(m_lpWED->fReadOnly)
        return NOERROR;

    PROPSHEETPAGE psp;

    // hinstApp        = g_hInst;
    psp.dwSize      = sizeof(psp);   // no extra data
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USETITLE ;
    psp.hInstance   = g_hLocRes;
    psp.lParam      = (LPARAM) &(m_lpWED);
    psp.pcRefParent = (UINT *)&(m_cRefThisDll);

    psp.pszTemplate = MAKEINTRESOURCE(iddWabExt);

    psp.pfnDlgProc  = (DLGPROC) WabExtDlgProc;
    psp.pszTitle    = AthLoadString(idsWABExtTitle, sz, ARRAYSIZE(sz)); // Title for your tab AthLoadString(idsWABExtTitle, sz, ARRAYSIZE(sz))

    m_hPage1 = ::CreatePropertySheetPage(&psp);
    if (m_hPage1)
    {
        if (!lpfnAddPage(m_hPage1, lParam))
            ::DestroyPropertySheetPage(m_hPage1);
    }

    return NOERROR;
#else
    return E_NOTIMPL;
#endif
}

STDMETHODIMP CIEMsgAb::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    Assert(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CIEMsgAb::Initialize(LPWABEXTDISPLAY lpWABExtDisplay)
{

    if (lpWABExtDisplay == NULL)
    {
	    TRACE("CIEMsgAb::Initialize() no data object");
	    return E_FAIL;
    }

    if(st_pAddrBook == NULL)
    {
	    TRACE("CIEMsgAb::Initialize() - run from not OE - no st_pAddrbook");
	    return E_FAIL;
    }

    if (!m_dwHideMessenger && !m_dwDisableMessenger)
    {
        if(!m_pCMsgrList)
        {
            m_pCMsgrList = OE_OpenMsgrList();
            if(!m_pCMsgrList)
            {
    	        TRACE("CIEMsgAb::Initialize() - Messeneger not installed");
	            return E_FAIL;
            }
        }
    }

    // However if this is a context menu extension, we need to hang
    // onto the propobj till such time as InvokeCommand is called ..
    // At this point just AddRef the propobj - this will ensure that the
    // data in the lpAdrList remains valid till we release the propobj..
    // When we get another ContextMenu initiation, we can release the
    // older cached propobj - if we dont get another initiation, we
    // release the cached object at shutdown time
    if(lpWABExtDisplay->ulFlags & WAB_CONTEXT_ADRLIST) // this means a IContextMenu operation is occuring
    {
        if(m_lpPropObj)
        {
            m_lpPropObj->Release();
            m_lpPropObj = NULL;
        }

        m_lpPropObj = lpWABExtDisplay->lpPropObj;
        m_lpPropObj->AddRef();

        m_lpWEDContext = lpWABExtDisplay;
    }
    else
    {
        // For property sheet extensions, the lpWABExtDisplay will
        // exist for the life of the property sheets ..
        m_lpWED = lpWABExtDisplay;
    }

    return S_OK;
}

HRESULT CIEMsgAb::PromptToGoOnline()
{
    HRESULT     hr = S_OK;

#ifdef LATER
    if (g_pConMan->IsGlobalOffline())
    {
        if (IDYES == AthMessageBoxW(m_hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                  0, MB_YESNO | MB_ICONEXCLAMATION ))
        {
            g_pConMan->SetGlobalOffline(FALSE);
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
        hr = S_OK;
#endif
    return hr;
}

HRESULT CIEMsgAb::ResizeChildWindows(LPCRECT prcPos)
{
    RECT rc;

    // Get the size of the outer window
    if (!prcPos)
    {
        GetClientRect(&rc);
	    rc.right = rc.right - rc.left;
	    rc.bottom = rc.bottom - rc.top;
    }
    else
    {
        rc.top = 0;
        rc.left = 0;
		rc.right = prcPos->right - prcPos->left;
		rc.bottom = prcPos->bottom - prcPos->top;
    }

#if 0
    // If we have to reserve room for the status bar and menu bar, do it
    if (m_fStatusBar)
        rc.bottom -= m_cyStatusBar;

    if (m_fMenuBar)
        rc.top += m_cyMenuBar;
#endif

    // Move the ListView into the right place
/*	::SetWindowPos(m_ctlList.m_hWnd, NULL, rc.top, rc.left,
                   rc.right, rc.bottom, SWP_NOZORDER | SWP_NOACTIVATE); */

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// IDeskBand implementation
//

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::GetBandInfo()
//
///////////////////////////////////////////////////////////////////////////
#define MIN_SIZE_X 50
#define MIN_SIZE_Y 50

STDMETHODIMP CIEMsgAb::GetBandInfo(DWORD dwBandID,
								   DWORD dwViewMode,
								   DESKBANDINFO* pdbi)
{
   if (pdbi)
   {
//      _dwBandID = dwBandID;
//      _dwViewMode = dwViewMode;

      if (pdbi->dwMask & DBIM_MINSIZE)
      {
         pdbi->ptMinSize.x = MIN_SIZE_X;
         pdbi->ptMinSize.y = MIN_SIZE_Y;
      }

      if (pdbi->dwMask & DBIM_MAXSIZE)
      {
         pdbi->ptMaxSize.x = -1;
         pdbi->ptMaxSize.y = -1;
      }

      if (pdbi->dwMask & DBIM_INTEGRAL)
      {
         pdbi->ptIntegral.x = 1;
         pdbi->ptIntegral.y = 1;
      }

      if (pdbi->dwMask & DBIM_ACTUAL)
      {
         pdbi->ptActual.x = 0;
         pdbi->ptActual.y = 0;
      }

      if (pdbi->dwMask & DBIM_TITLE)
      {
         lstrcpyW(pdbi->wszTitle, L"WebBand Search");
      }

      if (pdbi->dwMask & DBIM_MODEFLAGS)
         pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT;

      if (pdbi->dwMask & DBIM_BKCOLOR)
      {
         // Use the default background color by removing this flag.
         pdbi->dwMask &= ~DBIM_BKCOLOR;
      }

      return S_OK;
   }

   return E_INVALIDARG;
}

///////////////////////////////////////////////////////////////////////////
//
// IDockingWindow Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::ShowDW()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::ShowDW(BOOL fShow)
{
   if (m_hWnd)
   {
      //
      // Hide or show the window depending on
      // the value of the fShow parameter.
      //
      if (fShow)
          ::ShowWindow(m_hWnd, SW_SHOW);
      else
          ::ShowWindow(m_hWnd, SW_HIDE);
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::CloseDW()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::CloseDW(DWORD dwReserved)
{
   ShowDW(FALSE);

   // Assert(FALSE);
   if (IsWindow(m_hWnd))
       ::DestroyWindow(m_hWnd);

   m_hWnd = NULL;

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::ResizeBorderDW()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite,
                                            BOOL fReserved)
{
   // This method is never called for Band Objects.
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleWindow Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::GetWindow()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::GetWindow(HWND *phwnd)
{
   *phwnd = m_hWnd;
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CIEMsgAb::ContextSensitiveHelp()
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIEMsgAb::ContextSensitiveHelp(BOOL fEnterMode)
{
   return E_NOTIMPL;
}

STDMETHODIMP CIEMsgAb::Init (REFGUID refguid)
{
    return S_OK;
}

STDMETHODIMP CIEMsgAb::GetProperty(SHORT iPropID, VARIANTARG * pvarProperty)
{
    HRESULT hr = S_OK;

    switch (iPropID)
    {
    case TBEX_BUTTONTEXT:
        if (pvarProperty)
        {
            pvarProperty->vt = VT_BSTR;
            pvarProperty->bstrVal = SysAllocString(L"YST Button");
            if (NULL == pvarProperty->bstrVal)
                hr = E_OUTOFMEMORY;
        }
        break;

    case TBEX_GRAYICON:
        hr = E_NOTIMPL; // hr = _GetIcon(TEXT("Icon"), 20, 20, _hIcon, pvarProperty);
        break;

    case TBEX_GRAYICONSM:
        hr = E_NOTIMPL; // hr = _GetIcon(TEXT("Icon"), 16, 16, _hIconSm, pvarProperty);
        break;

    case TBEX_HOTICON:
        hr = E_NOTIMPL; // hr = _GetIcon(TEXT("HotIcon"), 20, 20, _hHotIcon, pvarProperty);
        break;

    case TBEX_HOTICONSM:
        hr = E_NOTIMPL; //hr = _GetIcon(TEXT("HotIcon"), 16, 16, _hHotIcon, pvarProperty);
        break;

    case TBEX_DEFAULTVISIBLE:
        if (pvarProperty)
        {
            // BOOL fVisible = _RegGetBoolValue(L"Default Visible", FALSE);
            pvarProperty->vt = VT_BOOL;
            pvarProperty->boolVal = VARIANT_TRUE;
        }
        break;

    case TMEX_CUSTOM_MENU:
        {
            if (pvarProperty != NULL)
            {
                pvarProperty->vt = VT_BSTR;
                pvarProperty->bstrVal = SysAllocString(L"YST test");
                if (pvarProperty->bstrVal == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        break;

    case TMEX_MENUTEXT:
        if (pvarProperty)
        {
            pvarProperty->vt = VT_BSTR;
            pvarProperty->bstrVal = SysAllocString(L"YST test 1");
            if (NULL == pvarProperty->bstrVal)
                hr = E_OUTOFMEMORY;
        }
        break;

    case TMEX_STATUSBARTEXT:
        if (pvarProperty)
        {
            pvarProperty->vt = VT_BSTR;
            pvarProperty->bstrVal = SysAllocString(L"YST test 2");
            if (NULL == pvarProperty->bstrVal)
                hr = E_OUTOFMEMORY;
        }
        break;
    default:
        hr = E_NOTIMPL;
    }
    return hr;
}

// --------------------------------------------------------------------------------
// AthLoadString
// --------------------------------------------------------------------------------
LPSTR ANSI_AthLoadString(UINT id, TCHAR* sz, int cch)
{
    LPSTR szT;

    if (sz == NULL)
    {
        if (!MemAlloc((LPVOID*)&szT, CCHMAX_STRINGRES))
            return(NULL);
        cch = CCHMAX_STRINGRES;
    }
    else
        szT = sz;

    if(g_hLocRes)
    {
        cch = LoadString(g_hLocRes, id, szT, cch);
        Assert(cch > 0);

        if (cch == 0)
        {
            if (sz == NULL)
                MemFree(szT);
            szT = NULL;
        }
    }
    else
    {
        if (sz == NULL)
            MemFree(szT);
        szT = NULL;

    }
    return(szT);
}

// --------------------------------------------------------------------------------
// AthLoadString
// --------------------------------------------------------------------------------
LPWSTR AthLoadString(UINT id, LPWSTR sz, int cch)
{
    LPWSTR szT;

    if (sz == NULL)
    {
        if (!MemAlloc((LPVOID*)&szT, CCHMAX_STRINGRES*sizeof(WCHAR)))
            return(NULL);
        cch = CCHMAX_STRINGRES;
    }
    else
        szT = sz;

    if(g_hLocRes)
    {
        cch = LoadStringW(g_hLocRes, id, szT, cch);
        Assert(cch > 0);

        if (cch == 0)
        {
            if (sz == NULL)
                MemFree(szT);
            szT = NULL;
        }
    }
    else
    {
        if (sz == NULL)
            MemFree(szT);
        szT = NULL;

    }
    return(szT);
}

//
// REVIEW: We need this function because current version of USER.EXE does
//  not support pop-up only menu.
//
HMENU LoadPopupMenu(UINT id)
{
    HMENU hmenuParent = LoadMenuW(g_hLocRes, MAKEINTRESOURCEW(id));

    if (hmenuParent) {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }

    return NULL;
}

void MenuUtil_BuildMenuIDList(HMENU hMenu, OLECMD **prgCmds, ULONG *pcStart, ULONG *pcCmds)
{
    ULONG        cItems = 0;
    MENUITEMINFO mii;

    if(!IsMenu(hMenu))
    return;
    // Start by getting the count of items on this menu
    cItems = GetMenuItemCount(hMenu);
    if (!cItems)
        return;

    // Realloc the array to be cItems elements bigger
    if (!MemRealloc((LPVOID *) prgCmds, sizeof(OLECMD) * (cItems + (*pcCmds))))
        return;

    *pcCmds += cItems;

    // Walk this menu and add our items to it
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    for (ULONG i = 0; i < cItems; i++)
    {
        if (GetMenuItemInfo(hMenu, i, TRUE, &mii))
        {
            // Make sure this isn't a separator
            if (mii.wID != -1 && mii.wID != 0)
            {
                // Add the ID to our array
                (*prgCmds)[*pcStart].cmdID = mii.wID;
                (*prgCmds)[*pcStart].cmdf = 0;
                (*pcStart)++;

                // See if we need to recurse
                if (mii.hSubMenu)
                {
                    MenuUtil_BuildMenuIDList(mii.hSubMenu, prgCmds, pcStart, pcCmds);
                }
            }
        }
    }

    return;
}

//
//  FUNCTION:   MenuUtil_EnablePopupMenu()
//
//  PURPOSE:    Walks the given menu and takes care of enabling and
//              disabling each item via the provided commnand target.
//
//  PARAMETERS:
//      [in] hPopup
//      [in] *pTarget
//
HRESULT MenuUtil_EnablePopupMenu(HMENU hPopup, CIEMsgAb *pTarget)
{
    HRESULT             hr = S_OK;
    int                 i;
    int                 cItems;
    OLECMD             *rgCmds = NULL;
    ULONG               cStart = 0;
    ULONG               cCmds = 0;
    MENUITEMINFO        mii = {0};
    OLECMDTEXT          CmdText;
    OLECMDTEXTV<MAX_MENUSTR> CmdNewText;

    Assert(hPopup && pTarget);

    // Build the array of menu ids
    MenuUtil_BuildMenuIDList(hPopup, &rgCmds, &cCmds, &cStart);

    // Ask our parent for the state of the commands
    CmdText.cmdtextf = OLECMDTEXTF_NONE;

    if (SUCCEEDED(hr = pTarget->QueryStatus(NULL, cCmds, rgCmds, &CmdText)))
    {
        mii.cbSize = sizeof(MENUITEMINFO);

        // Now loop through the menu and apply the state
        for (i = 0; i < (int) cCmds; i++)
        {
            BOOL f;
            CmdNewText.cwBuf = 0;

            if(rgCmds[i].cmdf & OLECMDF_INVISIBLE)
                RemoveMenu(hPopup, rgCmds[i].cmdID, MF_BYCOMMAND);
            else
            {
               // The default thing we're going to update is the state
                mii.fMask = MIIM_STATE;

                // Enabled or Disabled
                if (rgCmds[i].cmdf & OLECMDF_ENABLED)
                {
                    mii.fState = MFS_ENABLED;
                }
                else
                    mii.fState = MFS_GRAYED;

                // Checked?
                if (rgCmds[i].cmdf & OLECMDF_LATCHED)
                    mii.fState |= MFS_CHECKED;

                if(mii.fState == MFS_ENABLED)
                {
                    // special for phones
                    if((rgCmds[i].cmdID > ID_DIAL_PHONE_NUMBER) && (rgCmds[i].cmdID < ID_DIAL_PHONE_LAST))
                    {
                        OLECMD Cmd[1];
                        Cmd[0].cmdf = 0;
                        Cmd[0].cmdID = rgCmds[i].cmdID;
                        CmdNewText.cmdtextf = OLECMDTEXTF_NAME;

                        if (SUCCEEDED(hr = pTarget->QueryStatus(NULL, 1, Cmd, &CmdNewText)))
                        {
                            if(CmdNewText.cwBuf)
                            {
                                mii.fType = MFT_STRING;
                                mii.fMask |= MIIM_TYPE;
                                mii.dwTypeData = ((LPSTR) CmdNewText.rgwz);
                                mii.cch = CmdNewText.cwBuf;
                            }
                            else
                            {
                                mii.dwTypeData = NULL;
                                mii.cch = 0;
                            }
                        }
                    }
                }
                // Set the item state
                f = SetMenuItemInfo(hPopup, rgCmds[i].cmdID, FALSE, &mii);

                // if(CmdNewText.cwBuf)
                //    MemFree(&(CmdNewText.rgwz[0]));

                // Radio Check?
                if ((rgCmds[i].cmdf & OLECMDF_NINCHED) && rgCmds[i].cmdID != (-1))
                {
                    CheckMenuRadioItem(hPopup, rgCmds[i].cmdID, rgCmds[i].cmdID, rgCmds[i].cmdID, MF_BYCOMMAND);
                    // mii.fMask |= MIIM_TYPE;
                    // mii.fType = MFT_RADIOCHECK;
                    // mii.fState |= MFS_CHECKED;
                }
                // Assert(f);
            }
        }
    }

    SafeMemFree(rgCmds);
    return (hr);
}

HRESULT CEmptyList::Show(HWND hwndList, LPWSTR pszString)
{
    // We're already doing a window
    if (m_hwndList)
    {
        Hide();
    }

    // Keep a copy of the listview window handle
    m_hwndList = hwndList;

    if(MemAlloc((LPVOID *) &m_pwszString, (lstrlenW(pszString) + 1)*sizeof(WCHAR)))
            lstrcpyW(m_pwszString, pszString);

    // Get the header window handle from the listview
    m_hwndHeader = ListView_GetHeader(m_hwndList);

    // Save our this pointer on the listview window
    SetProp(m_hwndList, _T("EmptyListClass"), (HANDLE) this);
    // Subclass the listview so we can steal sizing messages
    if (!m_pfnWndProc)
        m_pfnWndProc = SubclassWindow(m_hwndList, SubclassWndProc);

    // Create our window on top
    if (!m_hwndBlocker)
    {
        m_hwndBlocker = CreateWindow(_T("Button"), _T("Blocker"), 
                                     WS_CHILD | WS_TABSTOP | WS_CLIPSIBLINGS |  BS_OWNERDRAW /*| ES_MULTILINE | ES_READONLY*/,
                                     0, 0, 0, 0, m_hwndList, (HMENU) NULL, g_hLocRes, NULL);
        Assert(m_hwndBlocker);
    }


    // Set the font for the blocker
    if(!m_hFont)
    {
        LOGFONT     lf;
        // Figure out which font to use
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, FALSE);

        // Create the fonts
        m_hFont = CreateFontIndirect(&lf);
    }

    // Show the silly thing
    if(m_hFont)
    {
        SendMessageW(m_hwndBlocker, WM_SETFONT, (WPARAM) m_hFont, MAKELPARAM(TRUE, 0));
    } 

    // SetWindowTextW(m_hwndBlocker, m_pwszString);

    // Position the blocker
    RECT rcList = {0};
    RECT rcHead = {0};

    GetClientRect(m_hwndList, &rcList);
    if(m_hwndHeader)
        GetClientRect(m_hwndHeader, &rcHead);

    SetWindowPos(m_hwndBlocker, 0, 0, rcHead.bottom, rcList.right,
                 rcList.bottom - rcHead.bottom, SWP_NOACTIVATE | SWP_NOZORDER);

    ShowWindow(m_hwndBlocker, SW_SHOW);
    return (S_OK);
}

HRESULT CEmptyList::Hide(void)
{
    // Verify we have the blocker up first
    if (m_pfnWndProc)
    {
        // Hide the window
        ShowWindow(m_hwndBlocker, SW_HIDE);

        // Unsubclass the window
        SubclassWindow(m_hwndList, m_pfnWndProc);

        // Delete the property
        RemoveProp(m_hwndList, _T("EmptyListClass"));

        // Free the string
        SafeMemFree(m_pwszString);

        // NULL everything out
        m_pfnWndProc = 0;
        m_hwndList = 0;
    }

    return (S_OK);

}

CEmptyList::~CEmptyList()
{
    if(m_hFont)
        DeleteObject(m_hFont);

    if (IsWindow(m_hwndBlocker))
        DestroyWindow(m_hwndBlocker);
    SafeMemFree(m_pwszString);
    if (NULL != m_hbrBack)
        DeleteObject(m_hbrBack);
}

LRESULT CEmptyList::SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CEmptyList* pThis = (CEmptyList *) GetProp(hwnd, _T("EmptyListClass"));
    Assert(pThis);

    switch (uMsg)
    {
        case WM_DRAWITEM:
            if (pThis && IsWindow(pThis->m_hwndBlocker))
            {
                LPDRAWITEMSTRUCT pdis = (LPDRAWITEMSTRUCT) lParam;
                RECT rc = pdis->rcItem;
                WCHAR  wszStr[RESSTRMAX];
                HBRUSH hbr3DFace = NULL;
                hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                FillRect(pdis->hDC, &(pdis->rcItem), hbr3DFace);
                SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
                DeleteObject(hbr3DFace);

                // Position the blocker
                RECT rcList = {0};
                RECT rcHead = {0};

                GetClientRect(pThis->m_hwndList, &rcList);
                if(pThis->m_hwndHeader)
                    GetClientRect(pThis->m_hwndHeader, &rcHead);

                SetWindowPos(pThis->m_hwndBlocker, 0, 0, rcHead.bottom, rcList.right,
                             rcList.bottom - rcHead.bottom, SWP_NOACTIVATE | SWP_NOZORDER);

                SelectFont(pdis->hDC, pThis->m_hFont);
                rc.left = 0;
                rc.top = rcHead.bottom;
                rc.right = rcList.right;
                rc.bottom = rcList.bottom - rcHead.bottom;

                hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                FillRect(pdis->hDC, &(pdis->rcItem), hbr3DFace);
                SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
                DeleteObject(hbr3DFace);

                DrawTextW(pdis->hDC, pThis->m_pwszString, -1, &rc, DT_WORDBREAK | DT_VCENTER | DT_CENTER );
                return(0);
            } 
            break;

        case WM_SIZE:
            if (pThis && IsWindow(pThis->m_hwndBlocker))
            {
                RECT rcHeader = {0};

                GetClientRect(pThis->m_hwndHeader, &rcHeader);
                SetWindowPos(pThis->m_hwndBlocker, 0, 0, 0, LOWORD(lParam),
                             HIWORD(lParam) - rcHeader.bottom,
                             SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
                InvalidateRect(pThis->m_hwndBlocker, NULL, FALSE);
            }
            break;

        case WM_CTLCOLORSTATIC:
            if ((HWND) lParam == pThis->m_hwndBlocker)
            {
                if (!pThis->m_hbrBack)
                {
                    pThis->m_hbrBack = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                }
                SetBkColor((HDC) wParam, GetSysColor(COLOR_WINDOW));
                return (LRESULT) pThis->m_hbrBack;
            }
            break;

        case WM_SYSCOLORCHANGE:
            if (pThis)
            {
                DeleteObject(pThis->m_hbrBack);
                pThis->m_hbrBack = 0;

                SendMessage(pThis->m_hwndBlocker, uMsg, wParam, lParam);
            }
            break;

        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            if (pThis)
            {
                LRESULT lResult = CallWindowProc(pThis->m_pfnWndProc, hwnd, uMsg, wParam, lParam);

                SendMessage(pThis->m_hwndBlocker, uMsg, wParam, lParam);
                // HFONT hf = (HFONT) SendMessage(pThis->m_hwndList, WM_GETFONT, 0, 0);
                // SendMessage(pThis->m_hwndBlocker, WM_SETFONT, (WPARAM) hf, MAKELPARAM(TRUE, 0));

                return (lResult);
            }

        case WM_DESTROY:
            {
                if (pThis)
                {
                    WNDPROC pfn = pThis->m_pfnWndProc;
                    pThis->Hide();
                    return (CallWindowProc(pfn, hwnd, uMsg, wParam, lParam));
                }
            }
            break;
    }

    return (CallWindowProc(pThis->m_pfnWndProc, hwnd, uMsg, wParam, lParam));
}


extern "C" const GUID CLSID_MailRecipient;

HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState)
{
    IDropTarget *pdrop;
    HRESULT hres = CoCreateInstance(CLSID_MailRecipient,
        NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_IDropTarget, (void **) &pdrop);

    if (SUCCEEDED(hres))
    {
        hres = OESimulateDrop(pdrop, pdtobj, grfKeyState, NULL, NULL);
        pdrop->Release();
    }
    return hres;
}
STDAPI OESimulateDrop(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                      const POINTL *ppt, DWORD *pdwEffect)
{
    POINTL pt;
    DWORD dwEffect;

    if (!ppt)
    {
        ppt = &pt;
        pt.x = 0;
        pt.y = 0;
    }

    if (!pdwEffect)
    {
        pdwEffect = &dwEffect;
        dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY;
    }

    DWORD dwEffectSave = *pdwEffect;    // drag enter returns the default effect

    HRESULT hr = pdrop->DragEnter(pdtobj, grfKeyState, *ppt, pdwEffect);
    if (*pdwEffect)
    {
        *pdwEffect = dwEffectSave;      // do Drop with the full set of bits
        hr = pdrop->Drop(pdtobj, grfKeyState, *ppt, pdwEffect);
    }
    else
    {
        pdrop->DragLeave();
        hr = S_FALSE;     // HACK? S_FALSE DragEnter said no
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\blframe.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
// BLFrame.cpp : Contains DLLMain and standard COM object functions.
/////////////////////////////////////////////////////////////////////////////
#include "pch.hxx"

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#include <ole2.h>
#include <comcat.h>
#include <olectl.h>
#include "ClsFact.h"
#include "resource.h"
#include "msoert.h"
#include "shared.h"
#include <shlwapi.h>
#include <shlwapip.h>
// #include "demand.h"

static const char c_szShlwapiDll[] = "shlwapi.dll";
static const char c_szDllGetVersion[] = "DllGetVersion";

// This part is only done once
// If you need to use the GUID in another file, just include Guid.h
//#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "Guid.h"
//#pragma data_seg()

// HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT);
const TCHAR c_szBlCtlResDll[] =           "iecontlc.dll";

extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);
BOOL RegisterServer(CLSID, LPTSTR);
BOOL RegisterComCat(CLSID, CATID);
BOOL UnRegisterServer(CLSID);
BOOL UnRegisterComCat(CLSID, CATID);

HINSTANCE  g_hLocRes;
HINSTANCE  g_OrgInst = NULL;
LONG       g_cDllRefCount;
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IEMsgAb, CIEMsgAb)
END_OBJECT_MAP()

typedef struct
{
    HKEY   hRootKey;
    LPTSTR szSubKey;  // TCHAR szSubKey[MAX_PATH];
    LPTSTR lpszValueName;
    LPTSTR szData;    // TCHAR szData[MAX_PATH];
    
} DOREGSTRUCT, *LPDOREGSTRUCT;

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

HINSTANCE IELoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT)
{
    char szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(377));
                    if (pfn != NULL)
                        hInst = pfn(szDllName, hInstCaller, (ML_CROSSCODEPAGE));
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if ((NULL == hInst) && (GetModuleFileName(hInstCaller, szPath, ARRAYSIZE(szPath))))
    {
        PathRemoveFileSpec(szPath);
        iEnd = lstrlen(szPath);
        szPath[iEnd++] = '\\';
        lstrcpyn(&szPath[iEnd], szDllName, ARRAYSIZE(szPath)-iEnd);
        hInst = LoadLibrary(szPath);
    }

    AssertSz(hInst, "Failed to LoadLibrary Lang Dll");

    return(hInst);
}
// CComModule _Module;

IMalloc                *g_pMalloc=NULL;

extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        CoGetMalloc(1, &g_pMalloc);
        // Get Resources from Lang DLL
        g_OrgInst = hInstance;
        g_hLocRes = IELoadLangDll(hInstance, c_szBlCtlResDll, TRUE);
        if(g_hLocRes == NULL)
        {
            _ASSERT(FALSE);
            return FALSE;
        }
        _Module.Init(ObjectMap, hInstance);
        // InitDemandLoadedLibs();
        DisableThreadLibraryCalls(hInstance);
        break;
        
    case DLL_PROCESS_DETACH:
        // FreeDemandLoadedLibs();
        _Module.Term();
        SafeRelease(g_pMalloc);
        break;
    }
    
    return TRUE;
}                                 

STDAPI DllCanUnloadNow(void)
{
    return (g_cDllRefCount ? S_FALSE : S_OK);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;
    
    // If we don't support this classid, return the proper error code
    if (!IsEqualCLSID(rclsid, CLSID_BLHost) && !IsEqualCLSID(rclsid, CLSID_IEMsgAb) )
        return CLASS_E_CLASSNOTAVAILABLE;
    
    if(IsEqualCLSID(rclsid, CLSID_BLHost))
    {
        // Create a CClassFactory object and check it for validity
        CClassFactory* pClassFactory = new CClassFactory(rclsid);
        if (NULL == pClassFactory)
            return E_OUTOFMEMORY;
    
        // QI for the requested interface
        hr = pClassFactory->QueryInterface(riid, ppv);
    
        // Call Release to decement the ref count - creating the object set it to one 
        // and QueryInterface incremented it - since its being used externally (not by 
        // us), we only want the ref count to be 1
        pClassFactory->Release();
    }
    else if(IsEqualCLSID(rclsid, CLSID_IEMsgAb))
        return _Module.GetClassObject(rclsid, riid, ppv);

    return hr;
}

STDAPI DllRegisterServer(void)
{
    TCHAR szTitle[256];
    // Register the explorer bar object.
    if(!ANSI_AthLoadString(idsTitle, szTitle, ARRAYSIZE(szTitle)))
    {
        _ASSERT(FALSE);
        szTitle[0] = '\0';
    }

    if (!RegisterServer(CLSID_BLHost, szTitle))
        return SELFREG_E_CLASS;
    
    // Register the Component Categories for the explorer bar object.
    RegisterComCat(CLSID_BLHost, CATID_InfoBand); // ignore error in this case
    
    // registers IEMsgAb object, typelib and all interfaces in typelib
    _Module.RegisterServer(TRUE);
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    // Register the Component Categories for the explorer bar object.
    UnRegisterComCat(CLSID_BLHost, CATID_InfoBand); // ignore error in this case
    
    // Register the explorer bar object.
    if (!UnRegisterServer(CLSID_BLHost))
        return SELFREG_E_CLASS;
    
    _Module.UnregisterServer();
    return S_OK;
}

BOOL RegisterServer(CLSID clsid, LPTSTR lpszTitle)
{
    int     i;
    HKEY    hKey;
    LRESULT lResult;
    DWORD   dwDisp;
    TCHAR   szSubKey[MAX_PATH];
    TCHAR   szCLSID[MAX_PATH];
    TCHAR   szBlFrameCLSID[MAX_PATH];
    TCHAR   szModule[MAX_PATH];
    LPWSTR  pwsz;
    
    // Get the CLSID in string form
    StringFromIID(clsid, &pwsz);
    
    if (pwsz)
    {
#ifdef UNICODE
        lstrcpy(szBlFrameCLSID, pwsz);
#else
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szBlFrameCLSID,
            ARRAYSIZE(szBlFrameCLSID), NULL, NULL);
#endif
        
        // Free the string
        LPMALLOC pMalloc;
        
        CoGetMalloc(1, &pMalloc);
        pMalloc->Free(pwsz);
        
        pMalloc->Release();
    }
    
    // Get this app's path and file name
    GetModuleFileName(g_OrgInst, szModule, ARRAYSIZE(szModule));
    
    DOREGSTRUCT ClsidEntries[] =
    {
        HKEY_CLASSES_ROOT, TEXT("CLSID\\%s"),                 
            NULL, lpszTitle,
            HKEY_CLASSES_ROOT, TEXT("CLSID\\%s\\InprocServer32"), 
            NULL, szModule,
            HKEY_CLASSES_ROOT, TEXT("CLSID\\%s\\InprocServer32"),
            TEXT("ThreadingModel"), TEXT("Apartment"),
            NULL, NULL, NULL, NULL
    };
    
    // Register the CLSID entries
    for (i = 0; ClsidEntries[i].hRootKey; i++)
    {
        // Create the sub key string - for this case, insert
        // the file extension
        //
        wsprintf(szSubKey, ClsidEntries[i].szSubKey, szBlFrameCLSID);
        
        lResult = RegCreateKeyEx(ClsidEntries[i].hRootKey, szSubKey, 
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_WRITE, NULL, &hKey, &dwDisp);
        
        if (ERROR_SUCCESS == lResult)
        {
            TCHAR szData[MAX_PATH];
            
            // If necessary, create the value string
            wsprintf(szData, ClsidEntries[i].szData, szModule);
            
            lResult = RegSetValueEx(hKey, ClsidEntries[i].lpszValueName, 
                0, REG_SZ, (LPBYTE)szData,
                lstrlen(szData) + 1);
            RegCloseKey(hKey);
            
            if (ERROR_SUCCESS != lResult)
                return FALSE;
        }
        else
        {
            return FALSE;
        }
    }
    
    // Create the Registry key entry and values for the
    // toolbar button.
    //
    StringFromIID(CLSID_BlFrameButton, &pwsz);
    
    if (!pwsz)
        return TRUE;
    
#ifdef UNICODE
    lstrcpy(szCLSID, pwsz);
#else
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szCLSID,
        ARRAYSIZE(szCLSID), NULL, NULL);
#endif
    
    // Free the string
    LPMALLOC pMalloc;
    
    CoGetMalloc(1, &pMalloc);
    pMalloc->Free(pwsz);
    pMalloc->Release();
    
    wsprintf(szSubKey, "Software\\Microsoft\\Internet Explorer\\Extensions\\%s",
        szCLSID);
    
    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hKey, &dwDisp);
    
    if (ERROR_SUCCESS == lResult)
    {
        TCHAR szData[MAX_PATH];
        
        // Create the value strings
        //
        // Register the explorer bar object.


        OSVERSIONINFO OSInfo;
        BOOL fWhistler = FALSE;
        OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        GetVersionEx(&OSInfo);
        if((OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (OSInfo.dwMajorVersion >= 5) && 
                    (OSInfo.dwMinorVersion >= 1))
            fWhistler = TRUE;

#ifdef NEED // Bug 28254
        lstrcpy(szData, "Yes");
        RegSetValueEx(hKey, TEXT("Default Visible"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
#endif         
        TCHAR szPath[MAX_PATH];
        HMODULE hModule;
        
        hModule = GetModuleHandle(TEXT("iecont.dll"));
        GetModuleFileName(hModule, szPath, MAX_PATH);
        
        wsprintf(szData, "%s,%d", szPath, fWhistler ? IDI_WHISTICON : IDI_HOTICON);
        RegSetValueEx(hKey, TEXT("HotIcon"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        wsprintf(szData, "%s,%d", szPath, fWhistler ? IDI_WHISTICON : IDI_ICON);
        RegSetValueEx(hKey, TEXT("Icon"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        lstrcpy(szData, "{E0DD6CAB-2D10-11D2-8F1A-0000F87ABD16}");
        RegSetValueEx(hKey, TEXT("CLSID"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        wsprintf(szData, "%s", szBlFrameCLSID);
        RegSetValueEx(hKey, TEXT("BandCLSID"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
//        SHGetWebFolderFilePath(TEXT("iecontlc.dll"), szPath, ARRAYSIZE(szPath));
        wsprintf(szData, "@iecontlc.dll,-%d",idsButtontext);
        RegSetValueEx(hKey, TEXT("ButtonText"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        wsprintf(szData, "@iecontlc.dll,-%d",idsTitle);
        RegSetValueEx(hKey, TEXT("MenuText"), 
            0, REG_SZ, (LPBYTE)szData,
            lstrlen(szData) + 1);
        
        RegCloseKey(hKey);
    }
    
    return TRUE;
}

BOOL RegisterComCat(CLSID clsid, CATID CatID)
{
    ICatRegister* pcr;
    HRESULT hr = S_OK ;
    
    CoInitialize(NULL);
    
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
        NULL,
        CLSCTX_INPROC_SERVER, 
        IID_ICatRegister,
        (LPVOID*)&pcr);
    
    if (SUCCEEDED(hr))
    {
        hr = pcr->RegisterClassImplCategories(clsid, 1, &CatID);
        pcr->Release();
    }
    
    CoUninitialize();
    
    return SUCCEEDED(hr);
}

BOOL UnRegisterServer(CLSID clsid)
{
    TCHAR   szSubKey[MAX_PATH];
    TCHAR   szCLSID[MAX_PATH];
    LPWSTR  pwsz;
    
    // Get the CLSID in string form
    StringFromIID(clsid, &pwsz);
    
    if (pwsz)
    {
#ifdef UNICODE
        lstrcpy(szCLSID, pwsz);
#else
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szCLSID,
            ARRAYSIZE(szCLSID), NULL, NULL);
#endif
        
        // Free the string
        LPMALLOC pMalloc;
        
        CoGetMalloc(1, &pMalloc);
        
        pMalloc->Free(pwsz);
        pMalloc->Release();
    }
    
    DOREGSTRUCT ClsidEntries[] =
    {
        HKEY_CLASSES_ROOT, TEXT("CLSID\\%s\\InprocServer32"),
            NULL, NULL,
            //
            // Remove the "Implemented Categories" key, just in case 
            // UnRegisterClassImplCategories does not remove it
            // 
            HKEY_CLASSES_ROOT, TEXT("CLSID\\%s\\Implemented Categories"),
            NULL, NULL,
            HKEY_CLASSES_ROOT, TEXT("CLSID\\%s"), NULL, NULL,
            NULL, NULL, NULL, NULL
    };
    
    // Delete the CLSID entries
    for (int i = 0; ClsidEntries[i].hRootKey; i++)
    {
        wsprintf(szSubKey, ClsidEntries[i].szSubKey, szCLSID);
        RegDeleteKey(ClsidEntries[i].hRootKey, szSubKey);
    }
    
    // Delete the button information
    //
    StringFromIID(CLSID_BlFrameButton, &pwsz);
    
    if (!pwsz)
        return TRUE;
    
#ifdef UNICODE
    lstrcpy(szCLSID, pwsz);
#else
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szCLSID,
        ARRAYSIZE(szCLSID), NULL, NULL);
#endif
    
    // Free the string
    LPMALLOC pMalloc;
    
    CoGetMalloc(1, &pMalloc);
    pMalloc->Free(pwsz);
    pMalloc->Release();
    
    wsprintf(szSubKey, "Software\\Microsoft\\Internet Explorer\\Extensions\\%s", szCLSID);
    RegDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);
    
    return TRUE;
}

BOOL UnRegisterComCat(CLSID clsid, CATID CatID)
{
    ICatRegister* pcr;
    HRESULT hr = S_OK ;
    
    CoInitialize(NULL);
    
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
        NULL,
        CLSCTX_INPROC_SERVER, 
        IID_ICatRegister,
        (LPVOID*)&pcr);
    
    if (SUCCEEDED(hr))
    {
        hr = pcr->UnRegisterClassImplCategories(clsid, 1, &CatID);
        pcr->Release();
    }
    
    CoUninitialize();
    
    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\blframe.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the BlFrame_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// BlFrame_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef BlFrame_EXPORTS
#define BlFrame_API __declspec(dllexport)
#else
#define BlFrame_API __declspec(dllimport)
#endif

// This class is exported from the BlFrame.dll
class CBlFrame
{
public:
	CBlFrame();
	// TODO: add your methods here.
};

BlFrame_API int fnBlFrame(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\blhost.h ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
//
// BLHost.h - CBLHost declaration
/////////////////////////////////////////////////////////////////////////////

#ifndef __BLHost_h__
#define __BLHost_h__

#include <windows.h>
#include <shlobj.h>

// #include <stack>
// #include <string>
#include "baui.h"
// using namespace std;

#include "Globals.h"

#define EB_CLASS_NAME (TEXT("BLHostClass"))

#define MIN_SIZE_X   10
#define MIN_SIZE_Y   10

#define IDM_REFRESH       0
#define IDM_OPENINWINDOW  1
#define IDM_SEARCHMENU    WM_USER + 200
#define IDM_ONTHEINTERNET WM_USER + 202
#define IDM_FIRSTURL      WM_USER + 250
#define IDM_LASTURL       WM_USER + 260  // We allow 10 Urls in the menu.
// In Internet Explorer 5.0, there
// are only 5 stored in the registry.

class CBLHost : public IDeskBand, 
public IInputObject, 
public IObjectWithSite,
public IPersistStream,
public IContextMenu,
public IOleClientSite,
public IOleInPlaceSite,
public IOleControlSite,
public IOleCommandTarget,
public IDispatch
{
public:
    CBLHost();
    ~CBLHost();
    
protected:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID iid, void** ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(DWORD, Release)();
    
    // IOleWindow methods
    STDMETHOD(GetWindow)(HWND* phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);
    
    // IDockingWindow methods
    STDMETHOD(ShowDW)(BOOL fShow);
    STDMETHOD(CloseDW)(DWORD dwReserved);
    STDMETHOD(ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);
    
    // IDeskBand methods
    STDMETHOD(GetBandInfo)(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi);
    
    // IInputObject methods
    STDMETHOD(UIActivateIO)(BOOL fActivate, LPMSG lpMsg);
    STDMETHOD(HasFocusIO)(void);
    STDMETHOD(TranslateAcceleratorIO)(LPMSG lpMsg);
    
    // IObjectWithSite methods
    STDMETHOD(SetSite)(IUnknown* pUnkSite);
    STDMETHOD(GetSite)(REFIID riid, void** ppvSite);
    
    // IPersistStream methods
    STDMETHOD(GetClassID)(CLSID* pClassID);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize);
    
    // IContextMenu methods
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax);
    
    // IOleClientSite methods 
    STDMETHOD(SaveObject)();
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppmk);
    STDMETHOD(GetContainer)(LPOLECONTAINER* ppContainer);
    STDMETHOD(ShowObject)();
    STDMETHOD(OnShowWindow)(BOOL fShow);
    STDMETHOD(RequestNewObjectLayout)();
    
    // IOleInPlaceSite Methods
    STDMETHOD(CanInPlaceActivate)();
    STDMETHOD(OnInPlaceActivate)();
    STDMETHOD(OnUIActivate)();
    STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc,
        LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD(Scroll)(SIZE scrollExtent);
    STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
    STDMETHOD(OnInPlaceDeactivate)();
    STDMETHOD(DiscardUndoState)();
    STDMETHOD(DeactivateAndUndo)();
    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect); 
    
    // IOleControlSite Methods
    STDMETHOD(OnControlInfoChanged)(void);
    STDMETHOD(LockInPlaceActive)(BOOL fLock);
    STDMETHOD(GetExtendedControl)(LPDISPATCH* ppDisp);
    STDMETHOD(TransformCoords)(POINTL* pPtlHimetric, POINTF* pPtfContainer, DWORD dwFlags);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, DWORD grfModifiers);
    STDMETHOD(OnFocus)(BOOL fGotFocus);
    STDMETHOD(ShowPropertyFrame)(void);

//IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        *prgCmds, 
                                          OLECMDTEXT    *pCmdText);

    HRESULT STDMETHODCALLTYPE Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut);
    // IDispatch Methods
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo);
    STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid,DISPID* rgDispId);
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pDispParams,
        VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr);
    
protected:
    LONG _cRef;
    
private:
    HWND                _hwndParent;     // HWND of the Parent
    HWND                m_hWnd;          // My HWND
    HWND                m_hwndContact;
    DWORD               _dwViewMode;
    DWORD               _dwBandID;
    DWORD               _dwWBCookie;
    HBRUSH              m_hbr3DFace;
    HBRUSH              m_hbrStaticText;
    HBRUSH              m_hbr3DHighFace;
    HFONT               m_hFont;
    HFONT               m_hBoldFont;
    HFONT               m_hUnderlineFont;
    UINT                m_cyTitleBar;
    UINT                m_TextHeight;
    BOOL                m_fHighlightIndicator;
    BOOL                m_fHighlightPressed;
    BOOL                m_fButtonPressed;
    BOOL                m_fButtonHighLight;
    BOOL                m_fViewMenuPressed;
    BOOL                m_fShowLoginPart;
    BOOL                m_fStateChange;
    RECT                m_rcTitleButton;
    RECT                m_rcTextButton;
    TCHAR               m_szTitleMenu[RESSTRMAX];
    TCHAR               m_szButtonText[RESSTRMAX];
    WCHAR               m_wszClickText[RESSTRMAX];
    WCHAR               m_wszAttemptText[RESSTRMAX];
    WCHAR               m_wszWaitText[RESSTRMAX];
    HWND                m_hWndLogin;
    HWND                m_hWndClick;
    COLORREF            m_clrLink;
    COLORREF            m_clrBack;
    BOOL                m_fStrsAdded;
    LONG_PTR            m_lStrOffset;
   
    // Interface pointers
    IUnknown*           m_pUnkSite; 
    IInputObjectSite*   _pSite;
    IIEMsgAb*           m_pIMsgrAB;
 
private:
    // Message Handlers
    LRESULT OnKillFocus(void);
    LRESULT OnSetFocus(void);
    LRESULT OnPaint(void);
    LRESULT OnSize(void);
    LRESULT OnDrawItem(WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnMouseMove(int x, int y, UINT keyFlags);
    void OnTimer(UINT wParam);
    void OnLButtonDown(int x, int y, UINT keyFlags);
    void OnLButtonUp(int x, int y, UINT keyFlags);
    void AddButtons(BOOL fAdd);
    void UpdateButtonArray(TBBUTTON *ptbDst, const TBBUTTON *ptbSrc, int ctb, LONG_PTR lStrOffset);

    // Helper Methods
    void FocusChange(BOOL);
    BOOL RegisterAndCreateWindow(void);
    void Cleanup(void);
    
    HRESULT GetConnectionPoint(LPUNKNOWN pUnk, REFIID riid, LPCONNECTIONPOINT* pCP);
    
public:
    LRESULT WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
};


#endif   // __BLHost_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\blhost.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//
// BLHost.cpp - CBLHost implementation
/////////////////////////////////////////////////////////////////////////////
#include "pch.hxx"
#include <shlobj.h>
#include <shlobjp.h>
#include <windowsx.h>
#include <comdef.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <ieguidp.h> 
#include <w95wraps.h>
#include <mshtml.h>
#include <mshtmdid.h>
#include <ExDispID.h>

#include "bactrl.h"
#include "baprop.h"
#include "baui.h"
#include "msoert.h"

#include "BLHost.h"
#include "hotlinks.h"
#include "Guid.h"
#include "resource.h"

// Insert your server name 
#define STARTUP_URL "http://localhost/BlFrame.htm"
#define SEARCH_PANE_INDICATOR "#_mysearch"

const int c_cxBorder     = 0;
const int c_cyBorder     = 0;
const int c_cxTextBorder = 4;
const int c_cyTextBorder = 2;
const int c_cyClose      = 3;
const int c_cySplit      = 4;
const int c_cxSplit      = 3;
const int c_cxTextSpace  = 1;
const int c_cxTriangle   = 14;
const int c_cyIEDelta    = 5;

// --------------------------------------------------------------------------------
// SAFECAST - Insures that a cast is valid, otherwise it won't compile
// --------------------------------------------------------------------------------
#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

HMENU LoadPopupMenu(UINT id);
HRESULT MenuUtil_EnablePopupMenu(HMENU hPopup, CIEMsgAb* pTarget);

static const TBBUTTON c_tbIECont[] =
{
    {  I_IMAGENONE, ID_CONT_FILE,       TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_WHOLEDROPDOWN | BTNS_SHOWTEXT, {0,0}, 0, 0 },
    {  I_IMAGENONE, ID_SHOWALLCONTACT, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_DROPDOWN | BTNS_SHOWTEXT, {0, 0}, 0, 1}
};



CBLHost::CBLHost()
   : _cRef(1),
     _hwndParent(NULL),
     m_hWnd(NULL),
     m_hwndContact(NULL),
     _dwViewMode(0),
     _dwBandID(0),
     _dwWBCookie(0), 
     _pSite(NULL), 
     m_pUnkSite(NULL)
{
    HDC         hdc;

    InterlockedIncrement(&g_cDllRefCount);
    m_pIMsgrAB = NULL;
    m_hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
    m_hbrStaticText = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    m_hbr3DHighFace = CreateSolidBrush(GetSysColor(COLOR_3DLIGHT));
    LOGFONT     lf;
    // Figure out which font to use
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, FALSE);

    // Create the fonts
    m_hFont = CreateFontIndirect(&lf);
    lf.lfWeight = FW_BOLD;
    m_hBoldFont = CreateFontIndirect(&lf);
    lf.lfUnderline = (BYTE) TRUE;
    m_hUnderlineFont = CreateFontIndirect(&lf);

    m_cyTitleBar = 32;
    m_fHighlightIndicator = FALSE;
    m_fHighlightPressed = FALSE;
    m_fButtonPressed = FALSE;
    m_fViewMenuPressed = FALSE;
    m_fButtonHighLight = FALSE;
    m_fShowLoginPart = FALSE;
    m_fStateChange = FALSE;
    m_TextHeight = 0;
    ZeroMemory(&m_rcTitleButton, sizeof(RECT));
    ZeroMemory(&m_rcTextButton, sizeof(RECT));
    m_hWndLogin = NULL;
    // m_hWndClick = NULL;
    m_fStrsAdded = FALSE;
    m_lStrOffset = 0;

    // Link colors
    if(!LookupLinkColors(&m_clrLink, NULL))
        m_clrLink = 0;
    if(!LookupLinkColors(NULL, &m_clrBack))
        m_clrBack = RGB(255, 255, 255);
}

CBLHost::~CBLHost()
{
   Cleanup();
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::QueryInterface()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
   *ppvObject= NULL;

   if (IsEqualIID(riid, IID_IUnknown))
   {
      *ppvObject = this;
   }
   else if (IsEqualIID(riid, IID_IOleWindow) || IsEqualIID(riid, IID_IDockingWindow))
   {
      *ppvObject = static_cast<IDockingWindow*>(this);
   }
   else if (IsEqualIID(riid, IID_IInputObject))
   {
      *ppvObject = static_cast<IInputObject*>(this);
   }   
   else if (IsEqualIID(riid, IID_IObjectWithSite))
   {
      *ppvObject = static_cast<IObjectWithSite*>(this);
   }   
   else if (IsEqualIID(riid, IID_IDeskBand))
   {
      *ppvObject = static_cast<IDeskBand*>(this);
   }   
   else if (IsEqualIID(riid, IID_IPersist))
   {
      *ppvObject = static_cast<IPersist*>(this);
   }   
   else if (IsEqualIID(riid, IID_IPersistStream))
   {
      *ppvObject = static_cast<IPersistStream*>(this);  
   }   
   else if (IsEqualIID(riid, IID_IContextMenu))
   {
      *ppvObject = static_cast<IContextMenu*>(this);
   }   
   else if (IsEqualIID(riid, IID_IOleClientSite))
   {
      *ppvObject = static_cast<IOleClientSite*>(this);
   }   
   else if (IsEqualIID(riid, IID_IOleInPlaceSite))
   {
      *ppvObject = static_cast<IOleInPlaceSite*>(this);
   }   
   else if (IsEqualIID(riid, IID_IOleControlSite))
   {
      *ppvObject = static_cast<IOleControlSite*>(this);
   }   
   else if (IsEqualIID(riid, IID_IOleCommandTarget))
   {
      *ppvObject = static_cast<IOleCommandTarget*>(this);
   }   
   else if (IsEqualIID(riid, IID_IDispatch) || IsEqualIID(riid, DIID_DWebBrowserEvents2))
   {
      *ppvObject = static_cast<IDispatch*>(this);
   }   

   if (*ppvObject)
   {
      static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
      return S_OK;
   }

   return E_NOINTERFACE;
}                                             

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::AddRef()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CBLHost::AddRef()
{
   return (ULONG)InterlockedIncrement(&_cRef);
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Release()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CBLHost::Release()
{
   if (0 == InterlockedDecrement(&_cRef))
   {
      delete this;
      return 0;
   }
   
   return (ULONG)_cRef;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleWindow Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetWindow()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetWindow(HWND *phwnd)
{
   *phwnd = m_hWnd;
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ContextSensitiveHelp()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ContextSensitiveHelp(BOOL fEnterMode)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IDockingWindow Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ShowDW()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ShowDW(BOOL fShow)
{
   if (m_hWnd)
   {
      //
      // Hide or show the window depending on
      // the value of the fShow parameter.
      //
      if (fShow)
         ShowWindow(m_hWnd, SW_SHOW);
      else
         ShowWindow(m_hWnd, SW_HIDE);
   }

   AddButtons(fShow);
   return S_OK;
}


void CBLHost::UpdateButtonArray(TBBUTTON *ptbDst, const TBBUTTON *ptbSrc, int ctb, LONG_PTR lStrOffset)
{
    memcpy(ptbDst, ptbSrc, ctb*sizeof(TBBUTTON));
    if (lStrOffset == -1)
    {
        // handle failure case
        for (int i = 0; i < ctb; i++)
            ptbDst[i].iString = 0;
    }
    else
    {
        for (int i = 0; i < ctb; i++)
            ptbDst[i].iString += lStrOffset;
    }
}

void CBLHost::AddButtons(BOOL fAdd)
{
    IExplorerToolbar* piet;

    _ASSERT(m_pUnkSite);

    if (SUCCEEDED(m_pUnkSite->QueryInterface(IID_IExplorerToolbar, (void**)&piet)))
    {
        if (fAdd)
        {
            piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CLSID_BLHost, 0);
            if (!m_fStrsAdded)
            {
                LONG_PTR   cbOffset;
                piet->AddString(&CLSID_BLHost, g_hLocRes, idsToolBar, &cbOffset);
                m_lStrOffset = cbOffset;
                m_fStrsAdded = TRUE;
            }
            // piet->SetImageList(&CGID_SearchBand, _himlNormal, _himlHot, NULL); // set image list
            TBBUTTON tbCont[ARRAYSIZE(c_tbIECont)];
            UpdateButtonArray(tbCont, c_tbIECont, ARRAYSIZE(c_tbIECont), m_lStrOffset);

            CIEMsgAb        *pMsgrAb = (CIEMsgAb *) m_pIMsgrAB;
            if(pMsgrAb && pMsgrAb->HideViewMenu())
                tbCont[1].fsState = TBSTATE_HIDDEN;

            piet->AddButtons(&CLSID_BLHost, ARRAYSIZE(tbCont), tbCont);
        }     
        else
            piet->SetCommandTarget(NULL, NULL, 0);

        piet->Release();
    }

}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::CloseDW()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::CloseDW(DWORD dwReserved)
{
   ShowDW(FALSE);

   if (IsWindow(m_hWnd))
      DestroyWindow(m_hWnd);

   m_hWnd = NULL;
   
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ResizeBorderDW()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite,
                                            BOOL fReserved)
{
   // This method is never called for Band Objects.
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IInputObject Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::UIActivateIO()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
   _ASSERT(m_pIMsgrAB);

   HRESULT hr = E_FAIL;

   if (m_pIMsgrAB)
        hr = ((CIEMsgAb*) m_pIMsgrAB)->UIActivateIO(fActivate, lpMsg);

   return hr;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::HasFocusIO()
//   
//   If this window or one of its decendants has the focus, return S_OK. Return 
//   S_FALSE if we don't have the focus.
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::HasFocusIO(void)
{
   HWND hwnd = GetFocus();
   HWND hwndTmp;
   ((CIEMsgAb *) m_pIMsgrAB)->GetWindow(&hwndTmp);

   // See if the focus has been set to any of the children
   //
   while (hwnd && hwndTmp)
   {
      if (hwnd == hwndTmp)
         return S_OK;

      hwndTmp = ::GetWindow(hwndTmp, GW_CHILD);
   }

   return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::TranslateAcceleratorIO()
//   
//   If the accelerator is translated, return S_OK or S_FALSE otherwise.
//
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::TranslateAcceleratorIO(LPMSG pMsg)
{
   _RPT0(_CRT_WARN, "TranslateAcceleratorIO\n");

   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IObjectWithSite Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::SetSite()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::SetSite(IUnknown* pUnkSite)
{
    TEXTMETRIC  tm;
    HRESULT hr  = S_OK;
    CIEMsgAb        *pMsgrAb = NULL;

    // Assert(FALSE);
   // If punkSite is not NULL, a new site is being set.
   if (pUnkSite)
   {
      //
      // If a IInputObjectSite pointer is being held, release it.
      //
      if (_pSite)
      {
         _pSite->Release();
         _pSite = NULL;
      }

      if(m_pUnkSite)
         m_pUnkSite->Release();

      m_pUnkSite = pUnkSite;

      // Get the parent window.
      IOleWindow* pOleWindow;
   
      if (SUCCEEDED(pUnkSite->QueryInterface(IID_IOleWindow,
											            (LPVOID*)&pOleWindow)))
      {
         pOleWindow->GetWindow(&_hwndParent);
         pOleWindow->Release();
      }

      _ASSERT(_hwndParent);
      if (!_hwndParent)
         return E_FAIL;

      if (!RegisterAndCreateWindow())
         return E_FAIL;

      // Get and keep the IInputObjectSite pointer.

       hr = pUnkSite->QueryInterface(IID_IInputObjectSite,
											           (LPVOID*)&_pSite);
      _ASSERT(SUCCEEDED(hr));
      
      hr = CreateIEMsgAbCtrl(&m_pIMsgrAB);

/*            // Create and initialize the WebBrowser control that we are hosting.
      hr = CoCreateInstance(CLSID_MsgrAb, NULL, CLSCTX_INPROC,
                            IID_IMsgrAb, (LPVOID*)&m_pMsgrAB);

      // Get the rectangle of the client area*/

      _ASSERT(m_hWnd);

    // Get the metrics of this font
    HDC hdc = GetDC(m_hWnd);
    SelectFont(hdc, m_hFont);
    GetTextMetrics(hdc, &tm);

    if(!ANSI_AthLoadString(idsTitleMenu, m_szTitleMenu, ARRAYSIZE(m_szTitleMenu)))
        m_szTitleMenu[0] = '\0';

    if(!ANSI_AthLoadString(idsButtonText, m_szButtonText, ARRAYSIZE(m_szButtonText)))
        m_szButtonText[0] = '\0';

//    if(!AthLoadString(idsLoginText, m_szInstallText, ARRAYSIZE(m_szInstallText)))
//        m_szInstallText[0] = '\0';
    if(!AthLoadString(idsClickText, m_wszClickText, ARRAYSIZE(m_wszClickText)))
        m_wszClickText[0] = L'\0';
    if(!AthLoadString(idsAttemptText, m_wszAttemptText, ARRAYSIZE(m_wszAttemptText)))
        m_wszAttemptText[0] = L'\0';
    if(!AthLoadString(idsWaitText, m_wszWaitText, ARRAYSIZE(m_wszWaitText)))
        m_wszWaitText[0] = L'\0';

    // Calculate the height
    m_cyTitleBar = 0; //tm.tmHeight + (2 * c_cyBorder) + (2 * c_cyTextBorder) + c_cyIEDelta;
    m_TextHeight = tm.tmHeight;

    pMsgrAb = (CIEMsgAb *) m_pIMsgrAB;

// Calculate the height
    RECT rc = {2 * c_cxBorder, 2 * c_cyBorder, 0, m_cyTitleBar - c_cyBorder};
    SIZE s;
    GetTextExtentPoint32(hdc, m_szTitleMenu, lstrlen(m_szTitleMenu), &s);
    m_rcTitleButton = rc;
    m_rcTitleButton.right = c_cxTriangle  + (2 * c_cxTextBorder) + s.cx + (2 * c_cxBorder);

    RECT rcClient = { 0, 0, 0/*100*/, 0/*500*/ };

    GetClientRect(m_hWnd, &rcClient);
    m_hwndContact = pMsgrAb->CreateControlWindow(m_hWnd, rcClient);
    // m_pIMsgrAB->Release(); // CreateControl.. add reference

    // Calculate "Show All" button rect
    m_rcTextButton.left = m_rcTitleButton.right + c_cxTextSpace;
    m_rcTextButton.top = m_rcTitleButton.top; 
    m_rcTextButton.bottom = m_rcTitleButton.bottom; 
    GetTextExtentPoint32(hdc, m_szButtonText, lstrlen(m_szButtonText), &s);
    m_rcTextButton.right = c_cxTriangle + m_rcTextButton.left + (2 * c_cxTextBorder) + s.cx + (2 * c_cxBorder);


    m_hWndLogin = CreateWindow(_T("Button"), _T("_Login"), 
                                     WS_CHILD | WS_TABSTOP | WS_CLIPSIBLINGS |  BS_OWNERDRAW /*| ES_MULTILINE | ES_READONLY*/,
                                     0, 0, 0, 0, m_hWnd, (HMENU) ID_LOGIN_MESSENGER, g_hLocRes, NULL);
    SendMessage(m_hWndLogin, WM_SETFONT, (WPARAM) m_hUnderlineFont, MAKELPARAM(TRUE, 0));
/*     SendMessage(m_hWndLogin, WM_SETFONT, (WPARAM) m_hFont, MAKELPARAM(TRUE, 0));

    m_hWndClick = CreateWindow(_T("Button"), _T("_Click"), 
                                     WS_CHILD | WS_TABSTOP | WS_CLIPSIBLINGS | BS_OWNERDRAW,
                                     0, 0, 0, 0, m_hWnd, (HMENU) ID_LOGIN_MESSENGER, g_hLocRes, NULL);
    SendMessage(m_hWndClick, WM_SETFONT, (WPARAM) m_hUnderlineFont, MAKELPARAM(TRUE, 0)); */
    }
    if(pMsgrAb)
        hr = pMsgrAb->SetSite(pUnkSite);

   return hr;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetSite()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetSite(REFIID riid, void** ppvSite)
{
   *ppvSite = NULL;

   if (_pSite)
      return _pSite->QueryInterface(riid, ppvSite);
   return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////
//
// IDeskBand implementation
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetBandInfo()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetBandInfo(DWORD dwBandID,
										 DWORD dwViewMode,
										 DESKBANDINFO* pdbi)
{
   if (pdbi)
   {
      _dwBandID = dwBandID;
      _dwViewMode = dwViewMode;

      if (pdbi->dwMask & DBIM_MINSIZE)
      {
         pdbi->ptMinSize.x = MIN_SIZE_X;
         pdbi->ptMinSize.y = MIN_SIZE_Y;
      }

      if (pdbi->dwMask & DBIM_MAXSIZE)
      {
         pdbi->ptMaxSize.x = -1;
         pdbi->ptMaxSize.y = -1;
      }

      if (pdbi->dwMask & DBIM_INTEGRAL)
      {
         pdbi->ptIntegral.x = 1;
         pdbi->ptIntegral.y = 1;
      }

      if (pdbi->dwMask & DBIM_ACTUAL)
      {
         pdbi->ptActual.x = 0;
         pdbi->ptActual.y = 0;
      }

      if (pdbi->dwMask & DBIM_TITLE)
      { 
        if(!AthLoadString(idsButtontext, pdbi->wszTitle, 256))
            pdbi->wszTitle[0] = L'\0';
      }

      if (pdbi->dwMask & DBIM_MODEFLAGS)
         pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT;
   
      if (pdbi->dwMask & DBIM_BKCOLOR)
      {
         // Use the default background color by removing this flag.
         pdbi->dwMask &= ~DBIM_BKCOLOR;
      }

      return S_OK;
   }

   return E_INVALIDARG;
}

///////////////////////////////////////////////////////////////////////////
//
// IPersistStream Methods
// 
// This is only supported to allow the desk band to be dropped on the 
// desktop and to prevent multiple instances of the desk band from showing 
// up in the context menu. This desk band doesn't actually persist any data.
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetClassID()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetClassID(LPCLSID pClassID)
{
   *pClassID = CLSID_BLHost;
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::IsDirty()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::IsDirty(void)
{
   return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Load()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::Load(LPSTREAM pStream)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Save()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::Save(LPSTREAM pStream, BOOL fClearDirty)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetSizeMax()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetSizeMax(ULARGE_INTEGER *pul)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IContextMenu Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::QueryContextMenu()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::QueryContextMenu(HMENU hmenu,
                                              UINT indexMenu, 
                                              UINT idCmdFirst,
                                              UINT idCmdLast, 
                                              UINT uFlags)
{
   if (!(CMF_DEFAULTONLY & uFlags))
   {
      InsertMenu(hmenu, indexMenu, MF_STRING | MF_BYPOSITION,
                 idCmdFirst + IDM_REFRESH, TEXT("&Refresh"));

      InsertMenu(hmenu, indexMenu + 1, MF_STRING | MF_BYPOSITION,
                 idCmdFirst + IDM_OPENINWINDOW, TEXT("&Open in Window"));

      return MAKE_HRESULT(SEVERITY_SUCCESS, 0,
                          USHORT(IDM_OPENINWINDOW + 1));
   }

   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::InvokeCommand()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetCommandString()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetCommandString(UINT_PTR idCmd, UINT uType, UINT* pwReserved,
                                              LPSTR pszName, UINT cchMax)
{
   HRESULT hr = E_INVALIDARG;

   switch(uType)
   {
      case GCS_HELPTEXT:
         switch(idCmd)
         {
            case IDM_REFRESH:
               lstrcpy(pszName, TEXT("Refreshes the search window"));
               hr = NOERROR;
               break;

            case IDM_OPENINWINDOW:
               lstrcpy(pszName, TEXT("Open a new instance of the Internet Explorer window"));
               hr = NOERROR;
               break;
         }

         break;
   
      case GCS_VERB:
         switch(idCmd)
         {
            case IDM_REFRESH:
               lstrcpy(pszName, TEXT("Refresh"));
               hr = NOERROR;
               break;

            case IDM_OPENINWINDOW:
               lstrcpy(pszName, TEXT("Open in Window"));
               hr = NOERROR;
               break;
         }

         break;
   
      case GCS_VALIDATE:
         hr = NOERROR;
         break;
   }

   return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleClientSite Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::SaveObject()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::SaveObject()
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetMoniker()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppmk)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetContainer()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetContainer(LPOLECONTAINER* ppContainer)
{
    *ppContainer = NULL;       
    return E_NOINTERFACE;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ShowObject()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ShowObject()
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnShowWindow()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnShowWindow(BOOL fShow)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::RequestNewObjectLayout()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::RequestNewObjectLayout()
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleInPlaceSite Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::CanInPlaceActivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::CanInPlaceActivate(void)
{
    return S_OK;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnInPlaceActivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnInPlaceActivate(void)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnUIActivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnUIActivate(void)
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetWindowContext()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetWindowContext(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppIIPUIWin, 
                                              LPRECT lprcPosRect, LPRECT lprcClipRect,
                                              LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
   *ppFrame = NULL;
   *ppIIPUIWin = NULL;

   GetClientRect(m_hWnd, lprcPosRect);
   GetClientRect(m_hWnd, lprcClipRect);

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Scroll()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::Scroll(SIZE scrollExtent)
{
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnUIDeactivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnUIDeactivate(BOOL fUndoable)
{
    
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnInPlaceDeactivate()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnInPlaceDeactivate(void)
{
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::DiscardUndoState()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::DiscardUndoState(void)
{
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::DeactivateAndUndo()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::DeactivateAndUndo(void)
{
    return E_NOTIMPL;   
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnPosRectChange()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnPosRectChange(LPCRECT lprcPosRect) 
{
   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleControlSite Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnControlInfoChanged()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnControlInfoChanged(void)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::LockInPlaceActive()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::LockInPlaceActive(BOOL fLock)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetExtendedControl()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetExtendedControl(LPDISPATCH* ppDisp)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::TransformCoords()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::TransformCoords(POINTL* pPtlHimetric, POINTF* pPtfContainer, DWORD dwFlags)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::TranslateAccelerator()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
   return E_NOTIMPL;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnFocus()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::OnFocus(BOOL fGotFocus)
{
   _RPT1(_CRT_WARN, "OnFocus: %s\n", fGotFocus ? "True" : "False");

   if (_pSite)
      _pSite->OnFocusChangeIS(static_cast<IInputObject*>(this), fGotFocus);

   return S_OK;
}
     
///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::ShowPropertyFrame()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::ShowPropertyFrame(void)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// Private Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetTypeInfoCount()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetTypeInfoCount(UINT* pctinfo)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetTypeInfo()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::GetIDsOfNames()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                                           LCID lcid,DISPID* rgDispId)
{
   return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::Invoke()
//   
///////////////////////////////////////////////////////////////////////////

STDMETHODIMP CBLHost::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
                                    DISPPARAMS* pDispParams, VARIANT* pVarResult,
                                    EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
   if (IID_NULL != riid)
      return DISP_E_UNKNOWNINTERFACE;

   if (!pDispParams)
      return DISP_E_PARAMNOTOPTIONAL;

   static bool sbIsAnchor = false;

   switch (dispIdMember)
   {
      //
      // The parameters for this DISPID:
      // [0]: New status bar text - VT_BSTR
      //
      case DISPID_STATUSTEXTCHANGE:
         if (pDispParams->cArgs && pDispParams->rgvarg[0].vt != VT_BSTR)
         {
            *puArgErr = 0;
            return DISP_E_TYPEMISMATCH;
         }

         break;

      default:
         return DISP_E_MEMBERNOTFOUND;
   }

   return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// Private Methods
//

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::WndProc()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT uMessage, 
                             WPARAM wParam, LPARAM lParam)
{
	if (uMessage == WM_NCCREATE)
	{
		LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
		SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)lpcs->lpCreateParams);
	}

	CBLHost* pThis = reinterpret_cast<CBLHost*>(
                                  GetWindowLongPtr(hWnd, GWLP_USERDATA));
	if (pThis)
		return pThis->WndProc(hWnd, uMessage, wParam, lParam);
	else
		return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

LRESULT CBLHost::WndProc(HWND hWnd, UINT uMessage, 
                         WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_NCCREATE:
        {
            // Set the window handle
            m_hWnd = hWnd;
        }
        break;
        
    case WM_PAINT:
        return OnPaint();
        
    case WM_MOUSEMOVE:
        return OnMouseMove(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        
    case WM_TIMER:
        OnTimer((UINT) wParam);
        return(0);
        
    case WM_LBUTTONDOWN:
        OnLButtonDown(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        return(0);

    case WM_LBUTTONUP:
        OnLButtonUp(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        return(0);

    case WM_COMMAND:
        return OnCommand(wParam, lParam);
        
    case WM_SETFOCUS:
        return OnSetFocus();
        
    case WM_KILLFOCUS:
        return OnKillFocus();
        
    case WM_DRAWITEM:
        return OnDrawItem(wParam, lParam);

    case WM_SIZE:
        return OnSize();
        
//    case WM_DESTROY:
        //
        // If you decided to implement the Open in Window context
        // menu item and you are using Internet Explorer 5,
        // be careful.  WM_DESTROY will get sent to the band for
        // each window.  You'll want to keep a count of the number
        // of windows open and only call Cleanup() if WM_DESTROY
        // is meant for the first window.
        //
        // Cleanup();
        
//        break;
    case WM_LOCAL_STATUS_CHANGED:
        m_fStateChange = TRUE;
        return OnSize();
    case WM_MSGR_LOGRESULT:
    case WM_MSGR_LOGOFF:
    case WM_MSGR_SHUTDOWN:
        m_fStateChange = FALSE;
        return OnSize();

        return 0;
    }
    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

LRESULT CBLHost::OnDrawItem(WPARAM wParam, LPARAM lParam)
{
    LPDRAWITEMSTRUCT pdis = (LPDRAWITEMSTRUCT) lParam;
    RECT rc = pdis->rcItem;
    WCHAR  wszStr[RESSTRMAX];
    HBRUSH hbr3DFace = NULL;
    
    lstrcpyW(wszStr, m_fStateChange ? m_wszWaitText : m_wszClickText);

    hbr3DFace = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    FillRect(pdis->hDC, &(pdis->rcItem), hbr3DFace);
    SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    DeleteObject(hbr3DFace);

    if(!m_fStateChange)
    {
        SetTextColor(pdis->hDC, m_clrLink);
        SelectFont(pdis->hDC, m_hUnderlineFont);
    }
    else
        SelectFont(pdis->hDC, m_hBoldFont);

    DrawTextW(pdis->hDC, wszStr, -1, &rc, DT_WORDBREAK | DT_VCENTER | DT_CENTER );
    return 0;
}


void CBLHost::OnLButtonUp(int x, int y, UINT keyFlags)
{
#if 0
    POINT pt = {x, y};

    if(PtInRect(&m_rcTextButton, pt))
    {
        ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, ID_SHOWALLCONTACT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        m_fButtonPressed = FALSE;
        InvalidateRect(m_hWnd, &m_rcTextButton, TRUE);
    }
#endif
}

void CBLHost::OnLButtonDown(int x, int y, UINT keyFlags)
{
}
void CBLHost::OnTimer(UINT id)
{
#if 0
    // RECT rcClient;
    POINT pt;
    DWORD dw;

    dw = GetMessagePos();
    pt.x = LOWORD(dw);
    pt.y = HIWORD(dw);
    ScreenToClient(m_hWnd, &pt);

    if (id == IDT_PANETIMER)
    {
       // GetClientRect(m_hWnd, &rcClient);

        // No need to handle mouse in client area, OnMouseMove will catch this. We
		// only need to catch the mouse moving out of the client area.
		if (!(PtInRect(&m_rcTitleButton, pt) || PtInRect(&m_rcTextButton, pt)) && !m_fHighlightPressed)
		{
			KillTimer(m_hWnd, IDT_PANETIMER);
			m_fHighlightIndicator = FALSE;
            m_fButtonHighLight = FALSE;
            m_fButtonPressed = FALSE;
            InvalidateRect(m_hWnd, &m_rcTitleButton, TRUE);
            InvalidateRect(m_hWnd, &m_rcTextButton, TRUE);
		}
	}
#endif
}


LRESULT CBLHost::OnMouseMove(int x, int y, UINT keyFlags)
{
#if 0
    POINT pt = {x, y};

    if (m_fHighlightIndicator != PtInRect(&m_rcTitleButton, pt))
    {
        m_fHighlightIndicator = !m_fHighlightIndicator;
        if(m_fHighlightIndicator)
            m_fButtonHighLight = FALSE;

        InvalidateRect(m_hWnd, &m_rcTitleButton, TRUE);
        InvalidateRect(m_hWnd, &m_rcTextButton, TRUE);

        if (m_fHighlightIndicator)       
            SetTimer(m_hWnd, IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
        else
            KillTimer(m_hWnd, IDT_PANETIMER);
    }
    else if (m_fButtonHighLight != PtInRect(&m_rcTextButton, pt))
    {
        m_fButtonHighLight = !m_fButtonHighLight;
        if(m_fButtonHighLight)
            m_fHighlightIndicator = FALSE;

        InvalidateRect(m_hWnd, &m_rcTextButton, TRUE);
        InvalidateRect(m_hWnd, &m_rcTitleButton, TRUE);

        if (m_fButtonHighLight)
            SetTimer(m_hWnd, IDT_PANETIMER, ELAPSE_MOUSEOVERCHECK, NULL);
        else
            KillTimer(m_hWnd, IDT_PANETIMER);
    }
#endif 
    return(S_OK);
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnPaint()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnPaint(void)
{
    PAINTSTRUCT ps;
    
    // Start painting
    HDC hdc = BeginPaint(m_hWnd, &ps);
    SelectFont(hdc, m_hFont);   
    EndPaint(m_hWnd, &ps);  

    return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnCommand()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnCommand(WPARAM wParam, LPARAM lParam)
{
    _RPT0(_CRT_WARN, "CBLHost::OnCommand\n");
    UINT id = LOWORD(wParam); 

    if(id == ID_LOGIN_MESSENGER && !((CIEMsgAb*)m_pIMsgrAB)->IsMessengerInstalled())
    {
        // redirect browser pane
        IServiceProvider* psp;

        // if invoked from within a browser reuse it, else open a new browser
        HRESULT hres = IUnknown_QueryService(m_pUnkSite, SID_STopLevelBrowser, IID_IServiceProvider, (LPVOID*)&psp);
        if (SUCCEEDED(hres))
        {
            IWebBrowser2*     pwb2 = NULL;

            hres = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID*)&pwb2);
            psp->Release();
    
            if (SUCCEEDED(hres))
            {
                // we don't care about the error here
                VARIANT varEmpty = {0};

                pwb2->Navigate(L"http://www.microsoft.com/isapi/redir.dll?prd=ie&Plcid=0x0409&Pver=6.0&Clcid=0x0409&Ar=getmms", &varEmpty, &varEmpty, &varEmpty, &varEmpty);
                pwb2->Release();
            }
        }
        return(hres);
    }
    if((id == ID_LOGIN_MESSENGER) && m_fStateChange)
        return 0; // id = ID_LOGOFF_MESSENGER;

    if(m_pIMsgrAB)
        ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::FocusChange()
//   
///////////////////////////////////////////////////////////////////////////

void CBLHost::FocusChange(BOOL fFocus)
{
   _RPT1(_CRT_WARN, "FocusChange: %s\n", fFocus ? "True" : "False");

   // Inform the input object site that the focus has changed
   //
   if (_pSite)
      _pSite->OnFocusChangeIS(static_cast<IDockingWindow*>(this), fFocus);
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::SetFocus()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnSetFocus(void)
{
   _RPT0(_CRT_WARN, "OnSetFocus\n");

   FocusChange(TRUE);
   return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnKillFocus()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnKillFocus(void)
{
   _RPT0(_CRT_WARN, "OnKillFocus\n");

   FocusChange(FALSE);
   return 0;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::OnSize()
//   
///////////////////////////////////////////////////////////////////////////

LRESULT CBLHost::OnSize(void)
{
    HRESULT hr = E_FAIL;
    
    if (m_pIMsgrAB)
    {
        RECT rcClient;
        HWND hWndTmp = NULL;
        GetClientRect(m_hWnd, &rcClient);
        
        CIEMsgAb        *pMsgrAb = (CIEMsgAb *) m_pIMsgrAB;
        if(pMsgrAb)
        {
            pMsgrAb->GetWindow(&hWndTmp);
            m_fShowLoginPart = !pMsgrAb->DontShowMessenger();
            
            if(m_fShowLoginPart && m_hWndLogin /* && m_hWndClick*/)
            {
                SetWindowPos(m_hWndLogin, NULL, rcClient.left, m_cyTitleBar, rcClient.right, 
                    m_TextHeight*2,
                    SWP_NOACTIVATE | SWP_NOZORDER);
                
                SendMessage(m_hWndLogin, WM_SETFONT, (WPARAM) m_hUnderlineFont, MAKELPARAM(TRUE, 0));
                SetWindowTextW(m_hWndLogin, m_fStateChange ? m_wszAttemptText : m_wszClickText);
                
                SetWindowPos(hWndTmp, NULL, 0, m_cyTitleBar + m_TextHeight*2, rcClient.right - rcClient.left, 
                    rcClient.bottom - rcClient.top - m_cyTitleBar - m_TextHeight*2, 
                    SWP_NOACTIVATE | SWP_NOZORDER);
                ShowWindow(m_hWndLogin, SW_SHOW);
                ShowWindow(hWndTmp, SW_SHOW);

            }
            else
            {
               
                if(m_hWndLogin)
                    ShowWindow(m_hWndLogin, SW_HIDE);
                
                
                SetWindowPos(hWndTmp, NULL, 0, m_cyTitleBar, rcClient.right - rcClient.left, 
                    rcClient.bottom - rcClient.top - m_cyTitleBar, 
                    SWP_NOACTIVATE | SWP_NOZORDER);
                ShowWindow(hWndTmp, SW_SHOW);
            }
        }
    }
    
    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
//   CBLHost::RegisterAndCreateWindow()
//   
///////////////////////////////////////////////////////////////////////////

BOOL CBLHost::RegisterAndCreateWindow(void)
{
    // If the window doesn't exist yet, create it now.
    if (!m_hWnd)
    {
        // Can't create a child window without a parent.
        if (!_hwndParent)
            return FALSE;
        
        // If the window class has not been registered, then do so.
        WNDCLASS wc;
        if (!GetClassInfo(g_hLocRes, EB_CLASS_NAME, &wc))
        {
            ZeroMemory(&wc, sizeof(wc));
            wc.style          = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS;
            wc.lpfnWndProc    = (WNDPROC)MainWndProc;
            wc.cbClsExtra     = 0;
            wc.cbWndExtra     = 0;
            wc.hInstance      = g_hLocRes;
            wc.hIcon          = NULL;
            wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
            wc.hbrBackground  = NULL;
            wc.lpszMenuName   = NULL;
            wc.lpszClassName  = EB_CLASS_NAME;
            
            if (!RegisterClass(&wc))
            {
                // If RegisterClass fails, CreateWindow below will fail.
            }
        }
        
        // RECT rc;
        // GetClientRect(m_hWnd, &rc);
        
        // Create the window. The WndProc will set m_hWnd.
        CreateWindowEx(0,
            EB_CLASS_NAME,
            NULL,
            WS_CHILD | WS_CLIPSIBLINGS, // No border
            0, // rc.left,
            0, // rc.top,
            0, // rc.right - rc.left,
            0, // rc.bottom - rc.top,
            _hwndParent,
            NULL,
            g_hLocRes,
            (LPVOID)this);
    }
    
    return (NULL != m_hWnd);
}

///////////////////////////////////////////////////////////////////////////
//
// CBLHost::GetConnectionPoint()
//
///////////////////////////////////////////////////////////////////////////

HRESULT CBLHost::GetConnectionPoint(LPUNKNOWN pUnk, REFIID riid, LPCONNECTIONPOINT* ppCP)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// CBLHost::Cleanup()
//
// Description: This method releases all interfaces we are holding onto.
//              This has to be done here because Internet Explorer is not
//              releasing all of our interfaces.  Therefore, our ref count
//              never reaches 0 and we never delete ourself.
//
///////////////////////////////////////////////////////////////////////////

void CBLHost::Cleanup(void)
{
    UnregisterClass(EB_CLASS_NAME, g_hLocRes);
    if (m_pIMsgrAB)
    {
        while(m_pIMsgrAB->Release() != 0)
            ;
//        m_pIMsgrAB->Release();
        //      m_pIMsgrAB = NULL;
    }

    if (m_hFont != 0)
        DeleteObject(m_hFont);

    if (m_hUnderlineFont != 0)
        DeleteObject(m_hUnderlineFont);

    if (m_hBoldFont != 0)
        DeleteObject(m_hBoldFont);

    if (m_hbr3DFace)
        DeleteObject(m_hbr3DFace);

    if (m_hbrStaticText)
        DeleteObject(m_hbrStaticText);

    if (m_hbr3DHighFace)
        DeleteObject(m_hbr3DHighFace);

/*    if (_pSite)
    {
        _pSite->Release();
        _pSite = NULL;
    }

    if(m_pUnkSite)
    {
        m_pUnkSite->Release();
        m_pUnkSite = NULL;
    } */

    InterlockedDecrement(&g_cDllRefCount);
}

HRESULT STDMETHODCALLTYPE CBLHost::QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        *prgCmds, 
                                          OLECMDTEXT    *pCmdText)
{

    prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBLHost::Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut)
{
    UINT  id;
    HMENU hMenu = NULL; 
    POINT pt = {0, 0};

    if(pvaIn)
    {
        pt.x = GET_X_LPARAM(pvaIn->lVal);
        pt.y = GET_Y_LPARAM(pvaIn->lVal) - 2;
    }
    else
        return (S_OK);

    switch (nCmdID)
    {
    case ID_CONT_FILE:
        hMenu = LoadPopupMenu(IDR_BA_TITLE_POPUP);
        MenuUtil_EnablePopupMenu(hMenu, (CIEMsgAb*) m_pIMsgrAB);

        id = TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                              pt.x, pt.y, 0, m_hWnd, NULL);
        if (id)
        {
            ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        }

        UpdateWindow(m_hWnd);
        break;

    case ID_SHOWALLCONTACT:
        if(nCmdExecOpt != OLECMDEXECOPT_PROMPTUSER)
            ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, ID_SHOWALLCONTACT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        else
        {

            hMenu = LoadPopupMenu(IDR_POPUP_VIEW);
            MenuUtil_EnablePopupMenu(hMenu, (CIEMsgAb*) m_pIMsgrAB);

            id = TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                              pt.x, pt.y, 0, m_hWnd, NULL);
            if (id)
            {
                ((CIEMsgAb*)m_pIMsgrAB)->Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
            }
            UpdateWindow(m_hWnd);
        }
        break;

    default:
        break;

    }

    if(hMenu)
    {
        BOOL bMenuDestroyed = DestroyMenu(hMenu);
        _ASSERT(bMenuDestroyed);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\bllist.h ===
// bllist.h : Declaration of the CMsgrList
// Messenger integration to OE
// Created 05/07/98 by YST
// 
#ifndef __BLLIST_H_
#define __BLLIST_H_

#include "basicim2.h"
#include "blobevnt.h"

#define MAXNAME 256

// message for all Msgr client windows
#define WM_USER_STATUS_CHANGED      (WM_USER + 1)
#define WM_MSGR_LOGOFF              (WM_USER + 2)
#define WM_MSGR_LOGRESULT           (WM_USER + 3)
#define WM_USER_MUSER_REMOVED       (WM_USER + 4)
#define WM_USER_MUSER_ADDED         (WM_USER + 5)
#define WM_USER_NAME_CHANGED        (WM_USER + 6)
#define WM_LOCAL_STATUS_CHANGED     (WM_USER + 7)
#define WM_MSGR_SHUTDOWN            (WM_USER + 8)


typedef struct _tag_OEMsgrInfo
{
    WCHAR   * pchMsgrName;
    WCHAR   * pchID;
    WCHAR   * pchHomePhone;
    WCHAR   * pchWorkPhone;
    WCHAR   * pchMobilePhone;
    int     nStatus;
    struct _tag_OEMsgrInfo * pPrev;
    struct _tag_OEMsgrInfo * pNext;
} oeMsgrInfo;

typedef oeMsgrInfo * LPMINFO;

typedef struct _tag_MsgrWndList
{
    HWND hWndUI;
    struct _tag_MsgrWndList * pPrev;
    struct _tag_MsgrWndList * pNext;
} MsgrWndList;

typedef MsgrWndList * LPMWNDLIST;

class CMsgrList
{
public:

    CMsgrList();
    ~CMsgrList();

    void        AddWndEntry(HWND hWnd);
    void        FindAndDelEntry(HWND hWnd, LPMWNDLIST pWndEntry=NULL);
    LPMINFO     GetRootMsgrItem(void)    { return(m_pblInfRoot); }
    void        RegisterUIWnd(HWND hWndUI);
    void        UnRegisterUIWnd(HWND hWndUI);
    LPMINFO     GetFirstMsgrItem(void)                { CheckAndInitMsgr(); return (m_pblInfRoot); };
    LPMINFO     GetNextMsgrItem(LPMINFO pEntry)      { return(pEntry ? pEntry->pNext : NULL); }
    int         AddRef(void)                        { return(++m_nRef); }
    void        Release(void);                      /* { return(--m_nRef); } */
    HRESULT     CheckAndInitMsgr(void);
    HRESULT     SendInstMessage(WCHAR *pchID);
    HRESULT     EventUserStateChanged(IBasicIMUser * pUser);
    HRESULT     EventUserRemoved(IBasicIMUser * pUser);
    HRESULT     EventUserAdded(IBasicIMUser * pUser);
    HRESULT     EventUserNameChanged(IBasicIMUser * pUser);
    HRESULT     EventLocalStateChanged(BIMSTATE State);

    HRESULT     UserLogon(void);
    HRESULT     AutoLogon(void);
    HRESULT     GetLocalState(BIMSTATE *pState);
    HRESULT     SetLocalState(BIMSTATE State);
    HRESULT     EventLogoff(void);
    HRESULT     EventAppShutdown(void);
    HRESULT     EventLogonResult(long lResult);
    HRESULT     HrInitMsgr(void);
    HRESULT     FillList(void);
    HRESULT     UserLogoff(void);
    HRESULT     FindAndDeleteUser(WCHAR * pchID, BOOL fDelete);
    HRESULT     NewOnlineContact(void);
    HRESULT     LaunchOptionsUI(void);
    HRESULT     LaunchPhoneUI(WCHAR *Phone);
    HRESULT     AddUser(WCHAR * pchID);
    void        DelAllEntries(LPMWNDLIST pWndEntry);
    long        GetCount(void);
    BOOL        IsLocalOnline(void);
    BOOL        IsLocalName(WCHAR *pchName);
    BOOL        IsContactOnline(WCHAR *pchID, LPMINFO pEntry);

private:
    void        FreeWndList(LPMWNDLIST pWndEntry);
    void        FreeMsgrInfoList(LPMINFO pEntry);
    void        RemoveMsgrInfoEntry(LPMINFO pEntry);
    void        RemoveWndEntry(LPMWNDLIST pWndEntry);
    void        SendMsgToAllUIWnd(UINT msg, WPARAM wParam, LPARAM lParam, LPMWNDLIST pWndEntry=NULL);
    void        AddMsgrListEntry(WCHAR *szName, WCHAR *szID, int nState, WCHAR *wszHomePhone = NULL, WCHAR *wszWorkPhone = NULL, WCHAR *wszMobilePhone = NULL);
    void        FindAndRemoveBlEntry(WCHAR *szID, LPMINFO pEntry=NULL);

private:
    LPMINFO         m_pblInfRoot;
    LPMINFO         m_pblInfLast;
    LPMWNDLIST      m_pWndLRoot;
    LPMWNDLIST      m_pWndLLast;
    int             m_nRef;

    // Smart pointer
    CComPtr<IBasicIM>           m_spMsgrObject;
    CMsgrObjectEvents*          m_pMsgrObjectEvents;

    long            m_MsgrCookie;
};


// Global functions available for everybody
CMsgrList *   OE_OpenMsgrList(void);
void        OE_CloseMsgrList(CMsgrList *pCMsgrList);
HRESULT     OE_Msgr_Logoff(void);
HRESULT     InstallMessenger(HWND hWnd);

#ifdef NEEDED
HRESULT     OE_Msgr_Logon(void);
#endif // NEEDED

#endif // __BLLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\bllist.cpp ===
// bllist.cpp : Implementation of the CMsgrList
// Messenger integration to OE
// Created 05/07/98 by YST
// 

#include "pch.hxx"
#include "bllist.h"
#include "basicim2.h"
#include "msoert.h"
#include "blobevnt.h"
#include <string.h>
#include "shlwapi.h" 
#include "shlwapip.h" 
#include <w95wraps.h>

static CMsgrList * sg_pMsgrList = NULL;     // global for buddy list

int const CCHMAX = 512;

CMsgrList::CMsgrList()
{
    m_pblInfRoot = NULL;
    m_pblInfLast = NULL;
    m_pWndLRoot = NULL;
    m_pWndLLast = NULL;
    m_nRef = 1;
    m_spMsgrObject = NULL;
    m_pMsgrObjectEvents = NULL;
    m_MsgrCookie = 0xffffffff;
}


CMsgrList::~CMsgrList()
{
    Assert(m_nRef == 0);

    if(m_pblInfRoot)
    {
        FreeMsgrInfoList(m_pblInfRoot);
        m_pblInfRoot = NULL;
        m_pblInfLast = NULL;
    }

    if(m_pWndLRoot)
        FreeWndList(m_pWndLRoot);

    if(m_pMsgrObjectEvents)
    {
        m_pMsgrObjectEvents->DelListOfBuddies();
        if (m_MsgrCookie != 0xffffffff && m_spMsgrObject != NULL)
            m_spMsgrObject->UnadviseOE(m_MsgrCookie);
        m_pMsgrObjectEvents->Release();
        m_pMsgrObjectEvents = NULL;
    }
}

void CMsgrList::Release()
{
    Assert(m_nRef > 0);

    m_nRef--;
    if(m_nRef == 0)
    {
        DelAllEntries(NULL);
        delete this;
        sg_pMsgrList = NULL;
    }
}

// Check and Init Msgr
HRESULT CMsgrList::CheckAndInitMsgr()
{
    if(m_pblInfRoot)
        return(S_OK);
    else
    {
        // Do Initialization again
        if(!m_pMsgrObjectEvents)
        {
            if(HrInitMsgr() == S_OK)
                return(FillList());
            else
                return S_FALSE;
        }
        else
            return(FillList());
    }
    return S_FALSE;         //???
}

// Free list of client UI window
void CMsgrList::FreeWndList(LPMWNDLIST pWndEntry)
{
    if(pWndEntry->pNext)
        FreeWndList(pWndEntry->pNext);
    
    MemFree(pWndEntry);
    pWndEntry = NULL;
}

// Free list buddies
void CMsgrList::FreeMsgrInfoList(LPMINFO pEntry)
{
    if(pEntry == NULL)
        return;
    if(pEntry->pNext)
        FreeMsgrInfoList(pEntry->pNext);

    MemFree(pEntry->pchMsgrName);
    MemFree(pEntry->pchID);
    MemFree(pEntry->pchHomePhone);
    MemFree(pEntry->pchWorkPhone);
    MemFree(pEntry->pchMobilePhone);
    MemFree(pEntry);
    pEntry = NULL;
}

// Remove buddy from list
void CMsgrList::RemoveMsgrInfoEntry(LPMINFO pEntry)
{
    if(m_pblInfLast == pEntry)
        m_pblInfLast = pEntry->pPrev;

    if(m_pblInfRoot == pEntry)
        m_pblInfRoot = pEntry->pNext;

    MemFree(pEntry->pchMsgrName);
    MemFree(pEntry->pchID);
    MemFree(pEntry->pchHomePhone);
    MemFree(pEntry->pchWorkPhone);
    MemFree(pEntry->pchMobilePhone);

    if(pEntry->pPrev)
        (pEntry->pPrev)->pNext = pEntry->pNext;

    if(pEntry->pNext)
        (pEntry->pNext)->pPrev = pEntry->pPrev;

    MemFree(pEntry);
    pEntry = NULL;
}

// Check that item is Online starting point for search is pEntry
BOOL CMsgrList::IsContactOnline(WCHAR *pchID, LPMINFO pEntry)
{
    if(!pEntry)
        return(FALSE);

    if(!lstrcmpiW(pEntry->pchID, pchID))
    {
        if((pEntry->nStatus != BIMSTATE_OFFLINE)  && (pEntry->nStatus != BIMSTATE_INVISIBLE))
            return(TRUE);
        else
            return(FALSE);
    }
    else if(pEntry->pNext)
        return(IsContactOnline(pchID, pEntry->pNext));
    else
        return(FALSE);
}

// Find entry with ID == szID and remove this from list
void CMsgrList::FindAndRemoveBlEntry(WCHAR *szID, LPMINFO pEntry)
{
    if(!pEntry)
        pEntry = m_pblInfRoot;

    if(!pEntry)
        return;

    if(!lstrcmpiW(pEntry->pchID, szID))
    {
        RemoveMsgrInfoEntry(pEntry);
    }
    else if(pEntry->pNext)
        FindAndRemoveBlEntry(szID, pEntry->pNext);
}

// Send message to all registred client UI windows
void CMsgrList::SendMsgToAllUIWnd(UINT msg, WPARAM wParam, LPARAM lParam, LPMWNDLIST pWndEntry)
{
    if(!pWndEntry)
        pWndEntry = m_pWndLRoot;

    if(!pWndEntry)
        return;

    if(pWndEntry->pNext)
        SendMsgToAllUIWnd(msg, wParam, lParam, pWndEntry->pNext);

    ::SendMessage(pWndEntry->hWndUI, msg, wParam, lParam);
}

// Add client Window to list
void CMsgrList::AddWndEntry(HWND hWnd)
{
    if(m_pWndLLast == NULL)
    {
        // Really first entry
        Assert(!m_pWndLRoot);
        if (!MemAlloc((LPVOID *) &m_pWndLLast, sizeof(MsgrWndList)))
            return;
        m_pWndLRoot = m_pWndLLast;
        m_pWndLLast->pPrev = NULL;
    }
    else 
    {
        if (!MemAlloc((LPVOID *) &(m_pWndLLast->pNext), sizeof(MsgrWndList)))
            return;
        (m_pWndLLast->pNext)->pPrev = m_pWndLLast;
        m_pWndLLast = m_pWndLLast->pNext;

    }
    
    m_pWndLLast->pNext = NULL;
    m_pWndLLast->hWndUI = hWnd;

}

// remove entry from WND list
void CMsgrList::RemoveWndEntry(LPMWNDLIST pWndEntry)
{
    if(m_pWndLLast == pWndEntry)
        m_pWndLLast = pWndEntry->pPrev;

    if(m_pWndLRoot == pWndEntry)
        m_pWndLRoot = pWndEntry->pNext;

    if(pWndEntry->pPrev)
        (pWndEntry->pPrev)->pNext = pWndEntry->pNext;

    if(pWndEntry->pNext)
        (pWndEntry->pNext)->pPrev = pWndEntry->pPrev;

    MemFree(pWndEntry);
    pWndEntry = NULL;

}

// Find entry and remove it from list
void CMsgrList::FindAndDelEntry(HWND hWnd, LPMWNDLIST pWndEntry)
{
    if(!pWndEntry)
        pWndEntry = m_pWndLRoot;

    if(!pWndEntry)
        return;

    if(pWndEntry->hWndUI == hWnd)
    {
        RemoveWndEntry(pWndEntry);
    }
    else if(pWndEntry->pNext)
        FindAndDelEntry(hWnd, pWndEntry->pNext);
}

void  CMsgrList::DelAllEntries(LPMWNDLIST pWndEntry)
{
    if(pWndEntry == NULL)
        pWndEntry = m_pWndLRoot;                

    if(pWndEntry == NULL)
        return;

    if(pWndEntry->pNext)
        DelAllEntries(pWndEntry->pNext);

    RemoveWndEntry(pWndEntry);
}

HRESULT CMsgrList::HrInitMsgr(void)
{
	//create the COM server and connect to it
	HRESULT hr = S_OK;
    
    Assert(m_pMsgrObjectEvents == NULL);

    m_spMsgrObject = NULL;
	hr = CoCreateInstance(CLSID_BasicIMObject, NULL,CLSCTX_LOCAL_SERVER, 
		                IID_IBasicIM, (LPVOID *)&m_spMsgrObject);
    if(FAILED(hr))
    {
        return(hr);
    }

    m_pMsgrObjectEvents = new CMsgrObjectEvents();
    if (m_pMsgrObjectEvents == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
	    hr = m_spMsgrObject->AdviseOE(m_pMsgrObjectEvents, &m_MsgrCookie);
        //We, of course, have to release m_pMsgrObjectEvents when we are finished with it
        if(FAILED(hr))
        {
            m_pMsgrObjectEvents->Release();
            m_pMsgrObjectEvents = NULL;
        }
        else 
            m_pMsgrObjectEvents->SetListOfBuddies(this);
    }

    return(hr);
}

// Set new buddy status (online/ofline/etc. and redraw list view entry)
HRESULT CMsgrList::EventUserStateChanged(IBasicIMUser * pUser)
{
    BSTR bstrID;
    HRESULT hr = pUser->get_LogonName(&bstrID);
    BOOL fFinded = FALSE;
    
    if (SUCCEEDED(hr))
    {
        BIMSTATE nState = BIMSTATE_UNKNOWN;
        if(SUCCEEDED(pUser->get_State(&nState)))
        {
            LPMINFO pInf = m_pblInfRoot;
            if(!pInf)
            {
                //                    MemFree(pszID);    
                SysFreeString(bstrID);
                return(hr);
            }
            
            // Find buddy in our list
            do
            {
                if(!lstrcmpiW(pInf->pchID, bstrID))
                {
                    fFinded = TRUE;
                    break;
                }
            } while ((pInf = pInf->pNext) != NULL);
            
            if(fFinded)
            {
                pInf->nStatus = nState;
                SendMsgToAllUIWnd(WM_USER_STATUS_CHANGED, (WPARAM) nState, (LPARAM) bstrID);
            }
        }
        
    }
    
    SysFreeString(bstrID);
    return(hr);
}

// Baddy was removed
HRESULT CMsgrList::EventUserRemoved(IBasicIMUser * pUser)
{
    BSTR bstrID;
    HRESULT hr = pUser->get_LogonName(&bstrID);
    
    if (SUCCEEDED(hr))
    {
        Assert(m_nRef > 0);  
        SendMsgToAllUIWnd(WM_USER_MUSER_REMOVED, (WPARAM) 0, (LPARAM) bstrID);
        FindAndRemoveBlEntry(bstrID);
    }
    
    SysFreeString(bstrID);
    return(hr);
}

// Event: buddy name was changed
// Add buddy to our list and send message to UI windows about this.
HRESULT CMsgrList::EventUserNameChanged(IBasicIMUser * pUser)
{
    BSTR bstrName;
    BSTR bstrID;
    BOOL fFinded = FALSE;
    
    HRESULT hr = pUser->get_LogonName(&bstrID);
    hr = pUser->get_FriendlyName(&bstrName);
    if (SUCCEEDED(hr))
    {
        LPMINFO pInf = m_pblInfRoot;
        
        // Find buddy in our list
        do
        {
            if(!lstrcmpiW(pInf->pchID, bstrID))
            {
                fFinded = TRUE;
                break;
            }
        } while ((pInf = pInf->pNext) != NULL);
        
        if(fFinded)
        {
            if(pInf->pchMsgrName)
                MemFree(pInf->pchMsgrName);       // Free prev name
            pInf->pchMsgrName = bstrName;
            SendMsgToAllUIWnd(WM_USER_NAME_CHANGED, (WPARAM) 0, (LPARAM) pInf);
        }
    }        

    SysFreeString(bstrName);
    SysFreeString(bstrID);
    return(hr);   
}

// Event: local state changed
HRESULT CMsgrList::EventLocalStateChanged(BIMSTATE State)
{
    SendMsgToAllUIWnd(WM_LOCAL_STATUS_CHANGED, (WPARAM) 0, (LPARAM) State);
    return(S_OK);
}

// Event: buddy was added
// Add buddy to our list and send message to UI windows about this.

HRESULT CMsgrList::EventUserAdded(IBasicIMUser * pUser)
{
    BSTR bstrName;
    BSTR bstrID;
    WCHAR wszHome[CCHMAX] = {0};
    WCHAR wszWork[CCHMAX] = {0};
    WCHAR wszMobile[CCHMAX] = {0};
    WCHAR *pH, *pW, *pM;
    
    HRESULT hr = pUser->get_LogonName(&bstrID);
    hr = pUser->get_FriendlyName(&bstrName);
    if (SUCCEEDED(hr))
    {
        BIMSTATE nState = BIMSTATE_UNKNOWN;
        if(SUCCEEDED(pUser->get_State(&nState)))
        {
            CComPtr<IBasicIMUser2> spUser2;

            if(SUCCEEDED(pUser->QueryInterface(IID_IBasicIMUser2, (void **) &spUser2)))
            {
                VARIANT var;
                var.vt = VT_BSTR;

                if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_HOME_PHONE_NUMBER, &var)))
                {
                    lstrcpynW(wszHome, var.bstrVal, CCHMAX - 1);
                    wszHome[CCHMAX - 1] = L'\0';
                    pH = wszHome;
                }
                else
                    pH = NULL;

                if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_WORK_PHONE_NUMBER, &var)))
                {
                    lstrcpynW(wszWork, var.bstrVal, CCHMAX - 1);
                    wszWork[CCHMAX - 1] = L'\0';
                    pW = wszWork;
                }
                else
                    pW = NULL;

                if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_MOBILE_PHONE_NUMBER, &var)))
                {
                    lstrcpynW(wszMobile, var.bstrVal, CCHMAX - 1);
                    wszMobile[CCHMAX - 1] = L'\0';
                    pM = wszMobile;
                }
                else
                    pM = NULL;
            }
            AddMsgrListEntry(bstrName, bstrID, nState,pH, pW, pM);
            SendMsgToAllUIWnd(WM_USER_MUSER_ADDED, (WPARAM) 0, (LPARAM) m_pblInfLast);
            
        }
    }
    SysFreeString(bstrName);
    SysFreeString(bstrID);
    return(hr);
}

HRESULT CMsgrList::EventLogoff()
{
    SendMsgToAllUIWnd(WM_MSGR_LOGOFF, (WPARAM) 0, (LPARAM) 0);
    FreeMsgrInfoList(m_pblInfRoot);
    m_pblInfRoot = NULL;
    m_pblInfLast = NULL;
    return(S_OK);
    
}

HRESULT CMsgrList::EventAppShutdown()
{
    SendMsgToAllUIWnd(WM_MSGR_SHUTDOWN, (WPARAM) 0, (LPARAM) 0);
    return(S_OK);   
}

HRESULT CMsgrList::EventLogonResult(long lResult)
{
    if(!m_pblInfRoot && SUCCEEDED(lResult))
        FillList();
    else if(SUCCEEDED(lResult))
    {
//        EnterCriticalSection(&g_csMsgrList);
        FreeMsgrInfoList(m_pblInfRoot);
        m_pblInfRoot = NULL;
        m_pblInfLast = NULL;
        FillList();
        // LeaveCriticalSection(&g_csMsgrList);
    }
    SendMsgToAllUIWnd(WM_MSGR_LOGRESULT, (WPARAM) 0, (LPARAM) lResult);
    return(S_OK);
}

// return number of buddies
long CMsgrList::GetCount()
{
    HRESULT hr = E_FAIL;
    long lCount = 0;
    CComPtr<IBasicIMUsers> spBuddies;

    if (!m_spMsgrObject)
        goto Exit;

    hr = m_spMsgrObject->get_ContactList(&spBuddies);
    if( FAILED(hr) )
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Buddies() failed, hr = %s"), g_GetErrorString(hr));
        Assert(FALSE);
        goto Exit;
    }

    //Iterate through the MsgrList make sure that the buddy we wish to remove is effectively in the list
    hr = spBuddies->get_Count(&lCount);
    Assert(SUCCEEDED(hr));
Exit:
    return(lCount);
}

HRESULT CMsgrList::FillList()
{
    long lCount = 0;
    IBasicIMUser* pUser = NULL;
    WCHAR wszHome[CCHMAX] = {0};
    WCHAR wszWork[CCHMAX] = {0};
    WCHAR wszMobile[CCHMAX] = {0};
    
    //process the Buddies list
    IBasicIMUsers *pBuddies = NULL;
    
    if(!m_spMsgrObject)
        return S_FALSE;
    
    HRESULT hr = m_spMsgrObject->get_ContactList(&pBuddies);
    if(FAILED(hr))
    {
FilErr:
    if(m_pMsgrObjectEvents)
    {
        m_pMsgrObjectEvents->DelListOfBuddies();
        if (m_MsgrCookie != 0xffffffff)
        {
            if (m_spMsgrObject)
                m_spMsgrObject->UnadviseOE(m_MsgrCookie);
            m_MsgrCookie = 0xffffffff;
        }
        m_pMsgrObjectEvents->Release();
        m_pMsgrObjectEvents = NULL;
    }
    return(hr);
    }
    
    //Check the current state (in case the client was already running and was 
    //not in the logoff state
    BIMSTATE lState = BIMSTATE_OFFLINE;
    if (m_spMsgrObject)
        hr = m_spMsgrObject->get_LocalState(&lState);
    
    if(FAILED(hr) /*|| lState == BIMSTATE_OFFLINE  !(lState == BIMSTATE_ONLINE || lState == BIMSTATE_BUSY || lState == BIMSTATE_INVISIBLE)*/)
    {
Err2:
    pBuddies->Release();
    pBuddies = NULL;
    goto FilErr;
    }
    else if(lState == BIMSTATE_OFFLINE)
    {
        if(FAILED(AutoLogon()))
            goto Err2;
    }
    
    if(!SUCCEEDED(pBuddies->get_Count(&lCount)))
        goto Err2;
    
    for (int i = 0; i < lCount; i++)
    {
        hr = pBuddies->Item(i, &pUser);
        if(SUCCEEDED(hr))
        {
            // EventUserAdded(pUser);
            BSTR bstrName;
            BSTR bstrID;
            
            hr = pUser->get_LogonName(&bstrID);
            hr = pUser->get_FriendlyName(&bstrName);
            if (SUCCEEDED(hr))
            {
                BIMSTATE nState = BIMSTATE_UNKNOWN;
                if(SUCCEEDED(pUser->get_State(&nState)))
                {
                    CComPtr<IBasicIMUser2> spUser2;
                    WCHAR *pH, *pW, *pM;
                    
                    if(SUCCEEDED(pUser->QueryInterface(IID_IBasicIMUser2, (void **) &spUser2)))
                    {
                        VARIANT var;
                        var.vt = VT_BSTR;
                        
                        if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_HOME_PHONE_NUMBER, &var)))
                        {
                            lstrcpynW(wszHome, var.bstrVal, CCHMAX - 1);
                            wszHome[CCHMAX - 1] = L'\0';
                            pH = wszHome;
                        }
                        else
                            pH = NULL;
                        
                        if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_WORK_PHONE_NUMBER, &var)))
                        {
                            lstrcpynW(wszWork, var.bstrVal, CCHMAX - 1);
                            wszWork[CCHMAX - 1] = L'\0';
                            pW = wszWork;
                        }
                        else
                            pW = NULL;
                        
                        if(SUCCEEDED(spUser2->get_Property(BIMUSERPROP_MOBILE_PHONE_NUMBER, &var)))
                        {
                            lstrcpynW(wszMobile, var.bstrVal, CCHMAX - 1);
                            wszMobile[CCHMAX - 1] = L'\0';
                            pM = wszMobile;
                        }
                        else
                            pM = NULL;
                    }
                    AddMsgrListEntry(bstrName, bstrID, nState,pH, pW, pM);
                }
            }
            SysFreeString(bstrName);
            SysFreeString(bstrID);
            pUser->Release();
        }
    }
    pBuddies->Release();
    return(S_OK);
}

// Add entry to list of buddies
void CMsgrList::AddMsgrListEntry(WCHAR *szName, WCHAR *szID, int nState, WCHAR *wszHomePhone, WCHAR *wszWorkPhone, WCHAR *wszMobilePhone)
{
    if(m_pblInfLast == NULL)
    {
        // Really first entry
        Assert(!m_pblInfRoot);
        if (!MemAlloc((LPVOID *) &m_pblInfLast, sizeof(oeMsgrInfo)))
            return;
        m_pblInfRoot = m_pblInfLast;
        m_pblInfLast->pPrev = NULL;
    }
    else 
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pNext), sizeof(oeMsgrInfo)))
            return;
        (m_pblInfLast->pNext)->pPrev = m_pblInfLast;
        m_pblInfLast = m_pblInfLast->pNext;
        
    }
    
    m_pblInfLast->pNext = NULL;
    
    if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchMsgrName), (lstrlenW(szName) + 1)*sizeof(WCHAR)))
        return;
    lstrcpyW(m_pblInfLast->pchMsgrName, szName);
    
    if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchID), (lstrlenW(szID) + 1)*sizeof(WCHAR)))
        return;
    lstrcpyW(m_pblInfLast->pchID, szID);
    m_pblInfLast->nStatus = nState;
    
    if(wszHomePhone)
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchHomePhone), (lstrlenW(wszHomePhone) + 1)*sizeof(WCHAR)))
            return;
        lstrcpyW(m_pblInfLast->pchHomePhone, wszHomePhone);
    }
    else 
        m_pblInfLast->pchHomePhone = NULL;
    
    if(wszWorkPhone)
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchWorkPhone), (lstrlenW(wszWorkPhone) + 1)*sizeof(WCHAR)))
            return;
        lstrcpyW(m_pblInfLast->pchWorkPhone, wszWorkPhone);
    }
    else 
        m_pblInfLast->pchWorkPhone = NULL;
    
    if(wszMobilePhone)
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchMobilePhone), (lstrlenW(wszMobilePhone) + 1)*sizeof(WCHAR)))
            return;
        lstrcpyW(m_pblInfLast->pchMobilePhone, wszMobilePhone);
    }
    else 
        m_pblInfLast->pchMobilePhone = NULL;
    
}

// register ui window in list
void CMsgrList::RegisterUIWnd(HWND hWndUI)
{
    CheckAndInitMsgr();
    AddWndEntry(hWndUI);
}

// remove UI window from list
void CMsgrList::UnRegisterUIWnd(HWND hWndUI)
{
    if(hWndUI)
        FindAndDelEntry(hWndUI);
}

// This call Messenger UI for instant message.
HRESULT CMsgrList::SendInstMessage(WCHAR *pchID)
{
    Assert(m_spMsgrObject);
    BSTRING bstrName(pchID);
    VARIANT var;
    var.bstrVal = bstrName;
    var.vt = VT_BSTR;

    HRESULT hr = S_OK;
    if(m_spMsgrObject)
        hr = m_spMsgrObject->LaunchIMUI(var);

    return(hr);
}

HRESULT CMsgrList::AutoLogon()
{
    if(m_spMsgrObject)
    {
        // if(DwGetOption(OPT_BUDDYLIST_CHECK))
            m_spMsgrObject->AutoLogon();
    }
    else
        return(E_FAIL);

    return S_OK;

}

HRESULT CMsgrList::UserLogon()
{
    if(m_spMsgrObject)
        return(m_spMsgrObject->LaunchLogonUI());
    else
        return(S_FALSE);
}

// Logoff call
HRESULT CMsgrList::UserLogoff()
{
    if(!m_spMsgrObject)
        return E_UNEXPECTED;

    return(m_spMsgrObject->Logoff());
}

// Get/Set local states.
HRESULT CMsgrList::GetLocalState(BIMSTATE *pState)
{
    if(m_spMsgrObject && SUCCEEDED(m_spMsgrObject->get_LocalState(pState)))
        return(S_OK);
    else
        return(S_FALSE);
}

// Check name: this is local name?
BOOL CMsgrList::IsLocalName(WCHAR *pchName)
{
    CComBSTR cbstrID;
    HRESULT hr;
    BOOL fRes = FALSE;

    if(m_spMsgrObject)
    {
        hr = m_spMsgrObject->get_LocalLogonName(&cbstrID);
        if(FAILED(hr))
            return FALSE;
        if(!lstrcmpiW(pchName, (LPWSTR)cbstrID))
            fRes = TRUE;
    }

    return(fRes);    
}

// Check current state
BOOL CMsgrList::IsLocalOnline(void)
{
    BIMSTATE State;
    if(m_spMsgrObject && SUCCEEDED(m_spMsgrObject->get_LocalState(&State)))
    {
        switch(State)
        {
            case BIMSTATE_ONLINE:
            case BIMSTATE_INVISIBLE:
            case BIMSTATE_BUSY:
            case BIMSTATE_BE_RIGHT_BACK:
            case BIMSTATE_IDLE:
            case BIMSTATE_AWAY:
            case BIMSTATE_ON_THE_PHONE:
            case BIMSTATE_OUT_TO_LUNCH:
                return(TRUE);

            default:
                return(FALSE);
        }
    }
    return(FALSE);
}

HRESULT CMsgrList::SetLocalState(BIMSTATE State)
{
    if(m_spMsgrObject && State != BIMSTATE_UNKNOWN)
    {
        m_spMsgrObject->put_LocalState(State);
        return S_OK;                        
    }
    else
        return S_FALSE;
}

HRESULT CMsgrList::NewOnlineContact()
{
    if(m_spMsgrObject)
        return(m_spMsgrObject-> LaunchAddContactUI(NULL));
    else
        return(S_FALSE); 

}

HRESULT CMsgrList::LaunchOptionsUI(void)
{
    if(m_spMsgrObject)
        return(m_spMsgrObject-> LaunchOptionsUI());
    else
        return(S_FALSE); 
}


HRESULT CMsgrList::LaunchPhoneUI(WCHAR *Phone)
{
    BSTRING             bstrPhone(Phone);
    HRESULT hr = S_FALSE;
    if(m_spMsgrObject)
         hr = m_spMsgrObject->LaunchPhoneUI(bstrPhone);

    return(hr); 
}

//****************************************************************************
//
// void CMsgrList::DeleteUser
//
// This function finds
// the buddy to be removed in the MsgrList and then calls the Remove method.
//
//****************************************************************************

HRESULT CMsgrList::FindAndDeleteUser(WCHAR * pchID, BOOL fDelete) 
{
    USES_CONVERSION;

    HRESULT             hr = E_FAIL;
    INT                 i;
    LONG                lCount = 0;
    BOOL                bFound = FALSE;
    CComPtr<IBasicIMUser>  spUser;
    CComPtr<IBasicIMUsers> spBuddies;
    // BSTRING             bstrName(pchID);
    // get an interface pointer to the MsgrList, so we can call the method Remove after
    if (!m_spMsgrObject)
    {
        hr = E_FAIL;
        goto Exit;
    }
    hr = m_spMsgrObject->get_ContactList(&spBuddies);
    if( FAILED(hr) )
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Buddies() failed, hr = %s"), g_GetErrorString(hr));
        Assert(FALSE);
        goto Exit;
    }

    //Iterate through the MsgrList make sure that the buddy we wish to remove is effectively in the list
    hr = spBuddies->get_Count(&lCount);
    Assert(SUCCEEDED(hr));
    
    for(i = 0; ((i<lCount) && (!bFound)); i++)
    {
        CComBSTR    cbstrID;

        spUser.Release();
        hr = spBuddies->Item(i, &spUser);
        
        if (SUCCEEDED(hr))
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("Item : %i succeeded"), i);
            
            hr = spUser->get_LogonName(&cbstrID);
            Assert(SUCCEEDED(hr));
            if (lstrcmpiW((LPCWSTR) cbstrID, pchID) == 0)
                bFound = TRUE;

            if (bFound)
                break;
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("Item : %i failed, hr = %s"), i, g_GetErrorString(hr));
            Assert(FALSE);
        }
    }
    
    // if we found the buddy in the list
    if( bFound )
    {
        if(fDelete)
            //finally, make the request to remove the buddy to the MsgrList
            hr = spBuddies->Remove(spUser);
        else
            // just search
            hr = S_OK;
    }
    else // Not found
    
        hr = DISP_E_MEMBERNOTFOUND;
Exit:
//    SysFreeString(bstrName);
    return(hr);
}

HRESULT CMsgrList::AddUser(WCHAR * pchID) 
{
    CComPtr<IBasicIMUser>  spUser;
    CComPtr<IBasicIMUsers> spUsers;
    BSTRING             bstrName(pchID);

    HRESULT hr = FindAndDeleteUser(pchID, FALSE /*fDelete*/);
    if(hr != DISP_E_MEMBERNOTFOUND)
        return(hr);

    // if not found, add buddy

    // get an interface pointer to the MsgrList, so we can call the method Remove after
    if (!m_spMsgrObject)
        return E_FAIL;
    hr = m_spMsgrObject->LaunchAddContactUI(bstrName);

    return(hr);

}


// Global functions available for everybody

// Entrance to MsgrList
CMsgrList *OE_OpenMsgrList(void)
{
    // if(!sg_pMsgrList)     
//    {
        // this first call, create class
        CMsgrList *pMsgrList = new(CMsgrList);

        if(pMsgrList)
        {
            // Init of User List
            if(pMsgrList->HrInitMsgr() == S_OK)
            {
                if(pMsgrList->FillList() != S_OK)
                    goto ErrEx;
            }
            else
            {
ErrEx:
                pMsgrList->Release();
                return(NULL);
            }
        }

//    }
//    else
//        sg_pMsgrList->AddRef();

    // LeaveCriticalSection(&g_csMsgrList);

    return(pMsgrList);
}

// Close entrance to MsgrList
void    OE_CloseMsgrList(CMsgrList *pCMsgrList)
{
    // Assert(pCMsgrList == sg_pMsgrList);

    // EnterCriticalSection(&g_csMsgrList);
    pCMsgrList->EventLocalStateChanged(BIMSTATE_OFFLINE);
    pCMsgrList->Release();
    // LeaveCriticalSection(&g_csMsgrList);
}

HRESULT OE_Msgr_Logoff(void)
{
    BIMSTATE State;
    HRESULT hr = S_OK;
#ifdef LATER    
    if(!sg_pMsgrList)
    {
        // EnterCriticalSection(&g_csMsgrList);
        sg_pMsgrList = new(CMsgrList);
        // LeaveCriticalSection(&g_csMsgrList);

        if(!sg_pMsgrList)
            return(E_UNEXPECTED);

        // Init of User List
        if(FAILED(hr = sg_pMsgrList->HrInitMsgr()))
            goto logoff_end;

        else if(FAILED(hr = sg_pMsgrList->GetLocalState(&State)) || State == BIMSTATE_OFFLINE)
            goto logoff_end;
        else
            hr = sg_pMsgrList->UserLogoff();

    }
    else
    {
        return(sg_pMsgrList->UserLogoff());  // we cannot delete sg_pMsgrList in this case!
    }

logoff_end:
    if(sg_pMsgrList)
    {
        OE_CloseMsgrList(sg_pMsgrList);
    }
#endif
    return(hr);
}

HRESULT InstallMessenger(HWND hWnd)
{
    HRESULT         hr  = REGDB_E_CLASSNOTREG;
#ifdef LATER
	uCLSSPEC classpec;
    TCHAR szBuff[CCHMAX];
		
   	classpec.tyspec=TYSPEC_CLSID;
	classpec.tagged_union.clsid = CLSID_MessengerApp;
	
  	// See below for parameter definitions and return values
	hr = FaultInIEFeature(hWnd, &classpec, NULL, FIEF_FLAG_FORCE_JITUI);

	if (hr != S_OK) {
        if(hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            AthLoadString(idsJITErrDenied, szBuff, ARRAYSIZE(szBuff));
            AthMessageBox(hWnd, MAKEINTRESOURCE(idsAthena), szBuff,
                    NULL, MB_OK | MB_ICONSTOP);
        }
        else
        {
            AthLoadString(idsBAErrJITFail, szBuff, ARRAYSIZE(szBuff));
            MenuUtil_BuildMessengerString(szBuff);
            AthMessageBox(hWnd, MAKEINTRESOURCE(idsAthena), szBuff,
                    NULL, MB_OK | MB_ICONSTOP);
        }
		hr = REGDB_E_CLASSNOTREG;
	}
#else
    hr= S_OK;
#endif // LATER
        return hr;
}

#ifdef NEEDED
HRESULT OE_Msgr_Logon(void)
{
    if(!sg_pMsgrList)
        return S_FALSE;
    else
        return(sg_pMsgrList->UserLogon());

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\blobevnt.cpp ===
//****************************************************************************
//
// BLObEvnt.cpp
// Messenger integration to OE
// Created 04/20/98 by YST
//
//  Copyright (c) Microsoft Corporation 1997-1998
//


#include "pch.hxx"
#include "MDispid.h"
#include "BLObEvnt.h"
// #include "demand.h"
#include "bllist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define ASSERT _ASSERTE

#define STR_MAX     256

//****************************************************************************
//
// CLASS CMsgrObjectEvents
//
//****************************************************************************

//****************************************************************************
//
// Construction/Destruction
//
//****************************************************************************

CMsgrObjectEvents::CMsgrObjectEvents() 
{
    // m_pBlAbCtrl = NULL;
    // lLocalState = BIMSTATE_OFFLINE;
}

CMsgrObjectEvents::~CMsgrObjectEvents()
{

}


//****************************************************************************
//
// Methods from IUnknown
//
//****************************************************************************

//****************************************************************************
//
// STDMETHODIMP_(ULONG) CMsgrObjectEvents::AddRef()
//
// Purpose : increment the object's reference count,
// Entry   : None
// Exit    : current count
//
//****************************************************************************

STDMETHODIMP_ (ULONG) CMsgrObjectEvents::AddRef()
{
	return RefCount::AddRef();
}


//****************************************************************************
//
// STDMETHODIMP_(ULONG) CMsgrObjectEvents::Release()
//
// Purpose : decrement the object's reference count
// Entry   : None
// Exit    : returns new count
//
//****************************************************************************

STDMETHODIMP_ (ULONG) CMsgrObjectEvents::Release()
{
	return RefCount::Release();
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::QueryInterface(REFIID iid, LPVOID *ppv)
//
// returns a pointer to the requested interface on the same object
// Purpose: To retrieve a pointer to requested interface
// Entry  : iid -- GUID of requested interface
// Exit   : ppv -- pointer to requested interface (if one exists)
//          return value : HRESULT
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::QueryInterface (REFIID riid, LPVOID *ppv)
{
	*ppv = NULL;
	HRESULT hr = E_NOINTERFACE;

	if (riid == IID_IUnknown)
	 	*ppv = (LPVOID) this;
    else if (riid == DIID_DBasicIMEvents) 
    	*ppv = (LPVOID) this;
	else if (riid == IID_IDispatch) 
    	*ppv = (LPVOID) this;
              
    if (*ppv) 
    {
	 	((LPUNKNOWN)*ppv)->AddRef();
		hr = S_OK;
	}
	return hr;
}

//****************************************************************************
//
// IDispatch implementation
//
//****************************************************************************


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetTypeInfoCount(UINT* pcTypeInfo)
//
// Set pcTypeInfo to 0 because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetTypeInfoCount(UINT* pcTypeInfo)
{
//	g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfoCount call succeeded"));

	*pcTypeInfo = 0 ;
	return NOERROR ;
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetTypeInfo(
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetTypeInfo(
	UINT iTypeInfo,
	LCID,          // This object does not support localization.
	ITypeInfo** ppITypeInfo)
{    
	*ppITypeInfo = NULL ;

	if(iTypeInfo != 0)
	{
		// g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfo call failed -- bad iTypeInfo index"));

		return DISP_E_BADINDEX ; 
	}
	else
	{
		 //g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfo call succeeded"));

		return E_NOTIMPL;
	}
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetIDsOfNames(  
//												const IID& iid,
//												OLECHAR** arrayNames,
//												UINT countNames,
//												LCID,          // Localization is not supported.
//												DISPID* arrayDispIDs)
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetIDsOfNames(  
	const IID& iid,
	OLECHAR** arrayNames,
	UINT countNames,
	LCID,          // Localization is not supported.
	DISPID* arrayDispIDs)
{
	HRESULT hr;
	if (iid != IID_NULL)
	{
		// g_AddToLog(LOG_LEVEL_COM, _T("GetIDsOfNames call failed -- bad IID"));

		return DISP_E_UNKNOWNINTERFACE ;
	}

	// g_AddToLog(LOG_LEVEL_COM, _T("GetIDsOfNames call succeeded"));

	hr = E_NOTIMPL;

	return hr ;
}

// Set BLAB control for CMsgrObjectEvents
STDMETHODIMP CMsgrObjectEvents::SetListOfBuddies(CMsgrList *pList)
{
    m_pMsgrList = pList;
    return S_OK;

}

// Set BLAB control for CMsgrObjectEvents
STDMETHODIMP CMsgrObjectEvents::DelListOfBuddies()
{
    m_pMsgrList = NULL;
    return S_OK;

}

//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::Invoke(   
//										  DISPID dispidMember,
//										  const IID& iid,
//										  LCID,          // Localization is not supported.
//										  WORD wFlags,
//										  DISPPARAMS* pDispParams,
//										  VARIANT* pvarResult,
//										  EXCEPINFO* pExcepInfo,
//										  UINT* pArgErr)
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::Invoke(   
      DISPID dispidMember,
      const IID& iid,
      LCID,          // Localization is not supported.
      WORD wFlags,
      DISPPARAMS* pDispParams,
      VARIANT* pvarResult,
      EXCEPINFO* pExcepInfo,
      UINT* pArgErr)
{   
	// g_AddToLog(LOG_LEVEL_FUNCTIONS, _T("CMsgrObjectEvents::Invoke entered"));
	// g_AddToLog(LOG_LEVEL_NOTIFICATIONS, _T("Dispid passed : %s"), g_GetStringFromDISPID(dispidMember));
	
	HRESULT hr;

    HRESULT     hrRet;

    if (iid != IID_NULL)
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Invoke call failed -- bad IID"));
        return DISP_E_UNKNOWNINTERFACE ;
    }

    ::SetErrorInfo(0, NULL) ;


    BOOL                bRet = TRUE; //this variable is there for future use
    CComPtr<IBasicIMUser>   spUser;
    CComPtr<IBasicIMUsers> spBuddies;
        
    switch (dispidMember) 
    {
    case DISPID_ONLOGONRESULT:
        //we should only have one parameter, the result, and that it is a long
        ASSERT(pDispParams->cArgs == 1);
        ASSERT(pDispParams->rgvarg->vt == VT_I4);
        // g_AddToLog(LOG_LEVEL_NOTIFICATIONS, _T("Result passed : %s"), g_GetStringFromLogonResult(pDispParams->rgvarg->lVal));

        if(m_pMsgrList)
            bRet = m_pMsgrList->EventLogonResult(pDispParams->rgvarg->lVal);
        break;

    case DISPID_ONUSERFRIENDLYNAMECHANGERESULT :
        _ASSERTE(pDispParams->cArgs == 3);
        _ASSERTE(pDispParams->rgvarg[2].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_DISPATCH);

        //if(lLocalState >= BIMSTATE_LOCAL_FINDING_SERVER)
        //    break;

        hr = pDispParams->rgvarg[1].pdispVal->QueryInterface(IID_IBasicIMUser, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if(m_pMsgrList)
                bRet = m_pMsgrList->EventUserNameChanged(spUser);
        }

        break;

    case DISPID_ONLOGOFF:
        if(m_pMsgrList)
            bRet = m_pMsgrList->EventLogoff();
        break;
        
    case DISPID_ONAPPSHUTDOWN:
        if(m_pMsgrList)
            bRet = m_pMsgrList->EventAppShutdown();
        break;

    case DISPID_ONLISTADDRESULT:
        // we should have two parameter, HRESULT, and the pMsgrUser
        //

        // WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
        // The parameters are inversed. This means that the las parameter in the
        // prototype of the function is the first one in the array received, and so on

        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_DISPATCH);

        hrRet = V_I4(&pDispParams->rgvarg[1]);
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IBasicIMUser, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if( SUCCEEDED(hrRet) )
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was added sucessfully."));

                if(m_pMsgrList)
                    bRet = m_pMsgrList->EventUserAdded(spUser);
            }
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("QueryInterface for IID_IBasicIMUser failed"));
        }

        break;

    case DISPID_ONLISTREMOVERESULT:
        // we should have two parameter, HRESULT, and the pMsgrUser
        //
        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_DISPATCH);

        hrRet = V_I4(&pDispParams->rgvarg[1]);
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IBasicIMUser, (LPVOID *)&spUser);

        if (SUCCEEDED(hr))
        {
            if( SUCCEEDED(hrRet) )
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was removed sucessfully."));
                if(m_pMsgrList)
                    bRet = m_pMsgrList->EventUserRemoved(spUser);
            }
            else
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was not removed due to error %s."), g_GetErrorString(hrRet));
            }
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("QueryInterface for IID_IBasicIMUser failed"));
        }

        break;

    case DISPID_ONUSERSTATECHANGED:
        //we should only have two parameters, the previousState and the pMsgrUser 
        ASSERT(pDispParams->cArgs == 2);
        ASSERT(pDispParams->rgvarg[1].vt == VT_DISPATCH);
        ASSERT(pDispParams->rgvarg[0].vt == VT_I4);

        // if(lLocalState >= BIMSTATE_LOCAL_FINDING_SERVER)
        //    break;

        hr = pDispParams->rgvarg[1].pdispVal->QueryInterface(IID_IBasicIMUser, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if(m_pMsgrList)
                bRet = m_pMsgrList->EventUserStateChanged(spUser);
        }

        break;

    case DISPID_ONLOCALSTATECHANGERESULT:
        //we should only have two parameters, hr and the LocalState
#if 0
        _ASSERTE(pDispParams->cArgs >== 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_I4);
#endif // 0
        // lLocalState = pDispParams->rgvarg[0].lVal;
        if(m_pMsgrList)
            bRet = m_pMsgrList->EventLocalStateChanged(((BIMSTATE) pDispParams->rgvarg[0].lVal));
        break;
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\clsfact.h ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
//
// ClsFact.h - CClassFactory declaration
/////////////////////////////////////////////////////////////////////////////

#ifndef __ClsFact_h__
#define __ClsFact_h__

#include <windows.h>
#include "Globals.h"
#include "blhost.h"

class CClassFactory : public IClassFactory
{
public:
   CClassFactory(CLSID);
   ~CClassFactory();

   //IUnknown methods
   STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObject);
   STDMETHOD_(ULONG, AddRef)();
   STDMETHOD_(ULONG, Release)();

   //IClassFactory methods
   STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID* ppvObject);
   STDMETHOD(LockServer)(BOOL fLock);

protected:
   LONG m_cRef;

private:
   CLSID m_clsidObject;
};

#endif   // __ClsFact_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\blobevnt.h ===
// File:       BLObEvn.h
// Messenger integration to OE
// Created 04/20/98 by YST
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//

#ifndef BLOBEVNT_H
#define BLOBEVNT_H

//****************************************************************************
//
// INCLUDES
//
//****************************************************************************

#include "clUtil.h"
#include "basicim2.h"

class CMsgrList;

//****************************************************************************
//
// DEFINES
//
//****************************************************************************


//****************************************************************************
//
// CLASS CMsgrObjectEvents
//
//****************************************************************************

class CMsgrObjectEvents :	public DBasicIMEvents, 
						public RefCount
{

//****************************************************************************
//
// METHODS
//
//****************************************************************************

public:

	// Constructor/Destructor

	CMsgrObjectEvents(); 
	virtual ~CMsgrObjectEvents();


	//****************************************************************************
	//
	// IUnknown methods declaration
	//
	//****************************************************************************

	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObject);


	//****************************************************************************
	//
	// IDispatch methods declaration
	//
	//****************************************************************************

	STDMETHOD (GetTypeInfoCount) (UINT* pCountTypeInfo);
	STDMETHOD (GetTypeInfo) ( UINT iTypeInfo,
							  LCID,          // This object does not support localization.
							  ITypeInfo** ppITypeInfo);
	STDMETHOD (GetIDsOfNames) (  const IID& iid,
								 OLECHAR** arrayNames,
								 UINT countNames,
								 LCID,          // Localization is not supported.
								 DISPID* arrayDispIDs);
	STDMETHOD (Invoke) ( DISPID dispidMember,
    									 const IID& iid,
	    								 LCID,          // Localization is not supported.
		    							 WORD wFlags,
										 DISPPARAMS* pDispParams,
										 VARIANT* pvarResult,
										 EXCEPINFO* pExcepInfo,
										 UINT* pArgErr);

    STDMETHOD (SetListOfBuddies) (CMsgrList *pList);
    STDMETHOD (DelListOfBuddies) (void);

private:
    CMsgrList * m_pMsgrList;
    IBasicIM  * m_pMsgr;
};


#endif //BLOBEVNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\clsfact.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
//
// ClsFact.cpp - CClassFactory Implementation
/////////////////////////////////////////////////////////////////////////////
#include "pch.hxx"
#include "ClsFact.h"
#include "Guid.h"

///////////////////////////////////////////////////////////////////////////
//
// IClassFactory Methods
//

CClassFactory::CClassFactory(CLSID clsid)
   : m_cRef(1),
     m_clsidObject(clsid)
     
{
   InterlockedIncrement(&g_cDllRefCount);
}

CClassFactory::~CClassFactory()
{
   InterlockedDecrement(&g_cDllRefCount);
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
   *ppvObject = NULL;

   if (IsEqualIID(riid, IID_IUnknown))
      *ppvObject = this;
   else if(IsEqualIID(riid, IID_IClassFactory))
      *ppvObject = static_cast<IClassFactory*>(this);

   if (*ppvObject)
   {
      static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
      return S_OK;
   }

   return E_NOINTERFACE;
}                                             

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
   return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
   if (0 == InterlockedDecrement(&m_cRef))
   {
      delete this;
      return 0;
   }
   
   return m_cRef;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID* ppvObject)
{
   HRESULT hr = E_FAIL;
   LPVOID  pTemp = NULL;

   *ppvObject = NULL;

   if (pUnkOuter != NULL)
      return CLASS_E_NOAGGREGATION;

   // Create the proper object
   if (IsEqualCLSID(m_clsidObject, CLSID_BLHost))
   {
      CBLHost* pBLHost = new CBLHost();

      if (NULL == pBLHost)
         return E_OUTOFMEMORY;
   
      pTemp = pBLHost;
   }
  
   if (pTemp)
   {
      // QI for the requested interface
      hr = (static_cast<LPUNKNOWN>(pTemp))->QueryInterface(riid, ppvObject);

      // Call Release to decement the ref count
      (static_cast<LPUNKNOWN>(pTemp))->Release();
   }

   return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL)
{
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\dispid.h ===
// Dispatch Ids

#ifndef __DISPID_H_
#define __DISPID_H_


#define DISPID_BLVIEW_BASE            1000

#define DISPID_BLVIEW_SERVER          (DISPID_BLVIEW_BASE + 1)
#define DISPID_BLVIEW_FOLDER          (DISPID_BLVIEW_BASE + 2)
#define DISPID_BLVIEW_CONNECT         (DISPID_BLVIEW_BASE + 3)
#define DISPID_BLVIEW_DISCONNECT      (DISPID_BLVIEW_BASE + 4)

#endif // __DISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\clutil.h ===
//****************************************************************************
//
//  BLClient sample for Microsoft Messenger SDK
//
//  Module:     BLClient.exe
//  File:       clUtil.h
//  Content:    Usefull clases for COM and Connection points
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_

class CIEMsgAb;
#include <docobj.h>

//****************************************************************************
//
// CLASS RefCount
//
//****************************************************************************

class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers destruction to destructor of derived class.
   virtual ~RefCount();

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//****************************************************************************
//
// CLASS CNotify
//
// Notification sink
//
//****************************************************************************

class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};



//****************************************************************************
//
// CLASS BSTRING
//
//****************************************************************************

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#ifndef UNICODE
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // #ifndef UNICODE

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};

BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		// ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	// This function is intended to be used to set the BSTR value for
	// objects that are initialized to NULL.  It should not be called
	// on objects which already have a non-NULL BSTR.
	// ASSERT(NULL == m_bstr);

	return &m_bstr;
}



//****************************************************************************
//
// CLASS BTSTR
//
//****************************************************************************

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR LPTSTRfromBstr(BSTR bstr);


#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\clutil.cpp ===
//****************************************************************************
//
//  BLClient sample for Microsoft Messenger SDK
//
//  Module:     BLClient.exe
//  File:       clUtil.cpp
//  Content:    Usefull clases for COM and Connection points
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************


#include "pch.hxx"
#include "clUtil.h"
#include "msoert.h"
// #include <instance.h>
// #include "demand.h"


#define ASSERT _ASSERTE

//****************************************************************************
//
// CLASS RefCount
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

RefCount::RefCount(void)
{
    m_cRef = 1;
    
//    Assert(NULL != g_pInstance);
//    CoIncrementInit("RefCount::RefCount", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

//****************************************************************************
//
// Destructor
//
//****************************************************************************

RefCount::~RefCount(void)
{
//    CoDecrementInit("RefCount::RefCount", NULL);    
}


//****************************************************************************
//
// ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
//
//****************************************************************************

ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


//****************************************************************************
//
// ULONG STDMETHODCALLTYPE RefCount::Release(void)
//
//****************************************************************************

ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    ASSERT(m_cRef > 0);
    return (ULONG) m_cRef;
}


//****************************************************************************
//
// CLASS CNotify
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

CNotify::CNotify() :
    m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}


//****************************************************************************
//
// destructor
//
//****************************************************************************

CNotify::~CNotify()
{
    Disconnect(); // Make sure we're disconnected
}


//****************************************************************************
//
// HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
//
// Connects the sink to the container
//
//****************************************************************************

HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
    HRESULT hr;

    ASSERT(0 == m_dwCookie);

    // Get the connection container
    hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
    if (SUCCEEDED(hr))
    {
        // Find an appropriate connection point
        hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != m_pcnp);
            // Connect the sink object
            hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
        }
    }

    if (FAILED(hr))
    {
        m_dwCookie = 0;
    }
    else
    {
        m_pUnk = pUnk; // keep around for caller
    }

    return hr;
}


//****************************************************************************
//
// HRESULT CNotify::Disconnect (void)
//
// Disconnects the sink from the container
//
//****************************************************************************

HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {

        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}


//****************************************************************************
//
// CLASS BSTRING
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

// We don't support construction from an ANSI string in the Unicode build.
#ifndef UNICODE

BSTRING::BSTRING(LPCSTR lpcString)
{
    m_bstr = NULL;

    // Compute the length of the required BSTR, including the null
    int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
    if (cWC <= 0)
        return;

    // Allocate the BSTR, including the null
    m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

    ASSERT(NULL != m_bstr);
    if (NULL == m_bstr)
    {
        return;
    }

    // Copy the string
    MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

    // Verify that the string is null terminated
    ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // #ifndef UNICODE


//****************************************************************************
//
// CLASS BTSTR
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

BTSTR::BTSTR(BSTR bstr)
{
    m_psz = LPTSTRfromBstr(bstr);
}


//****************************************************************************
//
// Destructor
//
//****************************************************************************

BTSTR::~BTSTR()
{
    if (NULL != m_psz)
        MemFree(m_psz);
}


//****************************************************************************
//
// LPTSTR LPTSTRfromBstr(BSTR bstr)
//
// Converts a BSTR to a LPTSTR
//
//****************************************************************************

LPTSTR LPTSTRfromBstr(BSTR bstr)
{
    if (NULL == bstr)
        return NULL;

    int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
    if (cch <= 0)
        return NULL;

    LPTSTR psz;

    if (!MemAlloc((void **)&psz, sizeof(TCHAR) * (cch+1)))
        return NULL;

#ifndef UNICODE
    WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
#else
    wcscpy(psz, bstr);
#endif

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\globals.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     globals.h
//
//  PURPOSE:    Defines any global constants that are interesting to the 
//              entire project.
//

#pragma once 

/////////////////////////////////////////////////////////////////////////////
// 
// Window Messages
//
extern HINSTANCE  g_hLocRes;
extern LONG       g_cDllRefCount;

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


#define WM_CREATEOBJECTS                (WM_USER + 1000)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\guid.h ===
/////////////////////////////////////////////////////////////////////////////
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Author: Scott Roberts, Microsoft Developer Support - Internet Client SDK  
//
// Portions of this code were taken from the bandobj sample that comes
// with the Internet Client SDK for Internet Explorer 4.0x
//
//
// Guid.h - Private GUID definition.
/////////////////////////////////////////////////////////////////////////////

#ifndef __Guid_h__
#define __Guid_h__

// {864B4D50-3B9A-11d2-B8DB-00C04FA3471C}
DEFINE_GUID(CLSID_BLHost, 
0x864b4d50, 0x3b9a, 0x11d2, 0xb8, 0xdb, 0x0, 0xc0, 0x4f, 0xa3, 0x47, 0x1c);

DEFINE_GUID(CLSID_BlFrameButton, 
0x9239E4EC, 0xC9A6, 0x11d2, 0xA8, 0x44, 0x00, 0xC0, 0x4F, 0x68, 0xD5, 0x38);


DEFINE_GUID(CLSID_MsgrAb,
0x233A9694,0x667E,0x11d1,0x9D,0xFB,0x00,0x60,0x97,0xD5,0x04,0x08);

DEFINE_GUID(IID_IMsgrAb,
0x233A9696,0x667E,0x11d1,0x9D,0xFB,0x00,0x60,0x97,0xD5,0x04,0x08);

#endif // __Guid_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\ourguid.h ===
/************
**  ATHGUID.H
**      Holds the GUIDs for Athena, including
**  those copied from Ren.
**
**  Author:  t-ErikN  (8/22/95)
*/

#ifndef __ATHGUID_H
#define __ATHGUID_H

#include "imnact.h"
#include <shlguidp.h>

////////////////////////////////////////////////////////////////////////
//
//  Athena CLSID
//
//  every OLE2 object class must have a unique CLSID (class id)
//  ours are: 
//  
//      Athena  {89292101-4755-11cf-9DC2-00AA006C2B84}
//      Mail    {89292102-4755-11cf-9DC2-00AA006C2B84}    
//      News    {89292103-4755-11cf-9DC2-00AA006C2B84}
//
//  you get a CLSID by running the guidgen application in the Win96 PDK
//
////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------------
// BA control 
// --------------------------------------------------------------------------------
// {233A9694-667E-11d1-9DFB-006097D50408}
DEFINE_GUID(CLSID_OEBAControl, 0x233a9694, 0x667e, 0x11d1, 0x9d, 0xfb, 0x00, 0x60, 0x97, 0xd5, 0x04, 0x08);

#endif // include //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WebBand.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "pch.hxx"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\mdispid.h ===
#ifndef _MDISPID_H_
#define _MDISPID_H_

//
// Dispatch IDs for DMsgrObjectEvents Dispatch Events.
//
#define DISPID_ONLOGONRESULT                  100
#define DISPID_ONLOGOFF                       101
#define DISPID_ONLISTADDRESULT                102
#define DISPID_ONLISTREMOVERESULT             103
#define DISPID_ONMESSAGEPRIVACYCHANGERESULT   104
#define DISPID_ONPROMPTCHANGERESULT           105
#define DISPID_ONUSERFRIENDLYNAMECHANGERESULT 106
#define DISPID_ONUSERSTATECHANGED             107
#define DISPID_ONTEXTRECEIVED                 108
#define DISPID_ONLOCALFRIENDLYNAMECHANGERESULT 109
#define DISPID_ONLOCALSTATECHANGERESULT       110
#define DISPID_ONAPPINVITERECEIVED            111
#define DISPID_ONAPPINVITEACCEPTED            112
#define DISPID_ONAPPINVITECANCELLED           113
#define DISPID_ONSENDRESULT                   114
#define DISPID_ONNEWERCLIENTAVAILABLE         115
#define DISPID_ONFINDRESULT                   116
#define DISPID_ONINVITEMAILRESULT             117
#define DISPID_ONREQUESTURLRESULT             118
#define DISPID_ONSESSIONSTATECHANGE           119
#define DISPID_ONUSERJOIN                     120
#define DISPID_ONUSERLEAVE                    121
#define DISPID_ONNEWSESSIONREQUEST            122
#define DISPID_ONINVITEUSER                   123
#define DISPID_ONSERVICELOGOFF                124
#define DISPID_ONPRIMARYSERVICECHANGED        125
#define DISPID_ONAPPSHUTDOWN                  126
#define DISPID_ONUNREADEMAILCHANGED           127
#define DISPID_ONUSERDROPPED                  128
#define DISPID_ONREQUESTURLPOSTRESULT         129
#define DISPID_ONNEWERSITESAVAILABLE          130
#define DISPID_ONTRUSTCHANGED                 131
#define DISPID_ONFILETRANSFERINVITERECEIVED   132
#define DISPID_ONFILETRANSFERINVITEACCEPTED   133
#define DISPID_ONFILETRANSFERINVITECANCELLED  134
#define DISPID_ONFILETRANSFERCANCELLED        135
#define DISPID_ONFILETRANSFERSTATUSCHANGE     136
#define DISPID_ONSPMESSAGERECEIVED            137
#define DISPID_ONLOCALPROPERTYCHANGERESULT    141
#define DISPID_ONBUDDYPROPERTYCHANGERESULT    142
#define DISPID_ONNOTIFICATIONRECEIVED         143
	
//
// Dispatch IDs for DMessengerAppEvents Dispatch Events.
// (don't overlap DMsgrObjectEvents ids)
//
#define DISPID_ONBEFORELAUNCHIMUI           20000
#define DISPID_ONSHOWIMUI		            20001
#define DISPID_ONDESTROYIMUI                20002
#define DISPID_ONINDICATEMESSAGERECEIVED	20003
#define DISPID_ONSTATUSTEXT					20004
#define DISPID_ONTITLEBARTEXT				20005
#define DISPID_ONINFOBARTEXT				20006
#define DISPID_ONSENDENABLED				20007
#define DISPID_ONTRANSLATEACCELERATOR		20008
#define DISPID_ONFILETRANSFER				20009
#define DISPID_ONVOICESESSIONSTATE			20010
#define DISPID_ONVOICEVOLUMECHANGED		    20011
#define DISPID_ONMICROPHONEMUTE			    20012

//
// Dispatch IDs for IMsgrObject.
//
#define DISPID_CREATEUSER                     100
#define DISPID_LOGON                          104
#define DISPID_LOGOFF                         105
#define DISPID_GETLIST                        0x60020003
#define DISPID_LOCALLOGONNAME                 0x60020004
#define DISPID_LOCALFRIENDLYNAME              0x60020005
#define DISPID_LOCALSTATE                     0x60020006
#define DISPID_MESSAGEPRIVACY                 0x60020008
#define DISPID_PROMPT                         0x6002000a
#define DISPID_SENDAPPINVITE                  108
#define DISPID_SENDAPPINVITEACCEPT            109
#define DISPID_SENDAPPINVITECANCEL            110
#define DISPID_LOCALOPTION                    0x6002000f
#define DISPID_FINDUSER                       111
#define DISPID_SENDINVITEMAIL                 112
#define DISPID_REQUESTURL                     113
#define DISPID_IMSESSIONS                     0x60020014
#define DISPID_CREATEIMSESSIONS               114
#define DISPID_SESSIONREQUESTACCEPT           115
#define DISPID_SESSIONREQUESTCANCEL           116
#define DISPID_SERVICES                       0x60020018
#define DISPID_UNREADEMAIL                    0x60020019
#define DISPID_SENDFILETRANSFERINVITE         117
#define DISPID_SENDFILETRANSFERINVITEACCEPT   118
#define DISPID_SENDFILETRANSFERINVITECANCEL   119
#define DISPID_CANCELFILETRANSFER             120
#define DISPID_FILETRANSFERSTATUS             121


//
// Dispatch IDs for IMessengerApp.
//
#define DISPID_APPLICATION                    0x60020000
#define DISPID_PARENT                         0x60020001
#define DISPID_QUIT                           100
#define DISPID_NAME                           0x60020003
#define DISPID_FULLNAME                       0x60020004
#define DISPID_PATH                           0x60020005
#define DISPID_LAUNCHLOGONUI                  200
#define DISPID_LAUNCHOPTIONSUI                201
#define DISPID_LAUNCHADDCONTACTUI             202
#define DISPID_LAUNCHFINDCONTACTUI            203
#define DISPID_LAUNCHIMUI                     210
#define DISPID_IMWINDOWS                      0x6002000b
#define DISPID_TOOLBAR                        0x6002000c
#define DISPID_STATUSBAR                      0x6002000e
#define DISPID_STATUSTEXT                     0x60020010
#define DISPID_GETHWND                        0x60020012
#define DISPID_LEFT                           0x60020013
#define DISPID_TOP                            0x60020015
#define DISPID_WIDTH                          0x60020017
#define DISPID_HEIGHT                         0x60020019
#define DISPID_MSGS_VISIBLE                   0x6002001b
#define DISPID_AUTOLOGON                      222
#define DISPID_FIRSTTIMECREDENTIONS           0x6002001e
#define DISPID_CACHEDPASSWORD                 0x6002001f
#define DISPID_REQUESTURLPOST                 223
#define DISPID_MSGS_TASKBARICON               224

//
// Dispatch IDs for IMsgrUser.
//
#define DISPID_USERFRIENDLYNAME               0x60020000
#define DISPID_USEREMAILADDRESS               0x60020002
#define DISPID_USERSTATE                      0x60020003
#define DISPID_USERLOGONNAME                  0x60020004
#define DISPID_USERSENDTEXT                   101
#define DISPID_USERSERVICE                    0x60020006

//
// Dispatch IDs for IMsgrUsers.
//
#define DISPID_USERSCOUNT                     0x60020000
#define DISPID_USERSADD                       100
#define DISPID_USERSREMOVE                    101

//
// Dispatch IDs for IMsgrService.
//
#define DISPID_SERVICESERVICENAME             0x60020000
#define DISPID_SERVICELOGONNAME               0x60020001
#define DISPID_SERVICEFRIENDLYNAME            0x60020002
#define DISPID_SERVICECAPABILITIES            0x60020004
#define DISPID_SERVICESTATUS                  0x60020005
#define DISPID_SERVICELOGOFF                  0x60020006
#define DISPID_SERVICEFINDUSER                0x60020007
#define DISPID_SERVICESENDINVITEMAIL          0x60020008
#define DISPID_SERVICEREQUESTURL              0x60020009
#define DISPID_SERVICEPROFILEFIELD            0x6002000a

//
// Dispatch IDs for IMsgrServices.
//
#define DISPID_SERVICESPRIMARYSERVICE         0x60020000
#define DISPID_SERVICESCOUNT                  0x60020002

#endif // ! _MDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\hotlinks.h ===
// =================================================================================
// H O T L I N K S . H
// =================================================================================
#ifndef __HOTLINKS_H
#define __HOTLINKS_H
#include <wab.h>
#include <wabapi.h>

// We will create a linked list of all selected entries that have an
// email address and then use that to create the recip list for sendmail
typedef struct _RecipList
{
    LPTSTR lpszName;
    LPTSTR lpszEmail;
    LPSBinary lpSB;
    struct _RecipList * lpNext;
} RECIPLIST, * LPRECIPLIST;


BOOL LookupLinkColors(LPCOLORREF pclrLink, LPCOLORREF pclrViewed);
BOOL CheckForOutlookExpress(LPTSTR szDllPath);
LPRECIPLIST AddTeimToRecipList(LPRECIPLIST lpList, WCHAR *pszEmail, WCHAR *pszName, LPSBinary lpSB);
void FreeLPRecipList(LPRECIPLIST lpList);
HRESULT HrStartMailThread(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, BOOL bUseOEForSendMail);
BOOL CheckForWAB(void);
HRESULT HrLoadPathWABEXE(LPWSTR szPath, ULONG cbPath);
DWORD DwGetOptions(void);
DWORD DwSetOptions(DWORD dwVal);
BOOL IEIsSpace(LPSTR psz);
BOOL IsTelInstalled(void);
DWORD DwGetMessStatus(void);
DWORD DwGetDisableMessenger(void);
DWORD DwSetDisableMessenger(DWORD dwVal);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msoectrl.rc
//
#define IDI_ICON                        104
#define IDI_HOTICON                     105
#define IDI_WHISTICON                   106
//
#define IDR_BLVIEW                      101
#define IDR_MAINMENU                    202
#define IDI_MAINICON                    203
#define ID_HELP_ABOUT                   204

// Bitmaps 
#define IDB_FACE                        240

// Command IDs for buttons
#define IDM_SEND                        225
#define IDM_ADD                         226

#define IDR_BA_DRAGDROP_POPUP               109
#define IDR_BA_POPUP                        108
#define IDR_BA_TITLE_POPUP                  110
#define IDR_POPUP_VIEW                      111

/////////////////////////////////////////////////////////////////////////////
// BEGIN SEPARATOR IDs
//

#define SEP_FIRST                           30000
#define SEP_MESSENGER                       (SEP_FIRST + 4)
#define SEP_PHONE                           (SEP_FIRST + 5)

/////////////////////////////////////////////////////////////////////////////
// BEGIN COMMAND IDs
//
#define ID_FIRST                            40000
#define ID_POPUP_NEW_ACCOUNT                (ID_FIRST + 31)
#define ID_PROPERTIES                       (ID_FIRST + 122)
#define ID_DELETE                           (ID_FIRST + 128)
#define ID_FIND_PEOPLE                      (ID_FIRST + 134)
#define ID_NEW_MSG_DEFAULT                  (ID_FIRST + 170)
#define ID_SEND_MESSAGE                     (ID_FIRST + 171)
#define ID_ADDRESS_BOOK                     (ID_FIRST + 199)
#define ID_SAVE                             (ID_FIRST + 227)
#define ID_SAVE_ALL_ADDRESSES               (ID_FIRST + 266)
#define ID_CANCEL                           (ID_FIRST + 267)
#define ID_SEND_INSTANT_MESSAGE             (ID_FIRST + 268)
#define ID_NEW_CONTACT                      (ID_FIRST + 270)
#define ID_ADD_ADDRESS_BOOK                 (ID_FIRST + 271)
#define ID_NEW_HOTMAIL_ACCOUNT              (ID_FIRST + 327)
#define ID_NEW_ATT_ACCOUNT                  (ID_FIRST + 328)
#define ID_NEW_GROUP                        (ID_FIRST + 330)
#define ID_SEND_INSTANT_MESSAGE2            (ID_FIRST + 331)
#define ID_DELETE_CONTACT                   (ID_FIRST + 435)
#define ID_NEW_ONLINE_CONTACT               (ID_FIRST + 456)
#define ID_SORT_BY_NAME                     (ID_FIRST + 457)
#define ID_SORT_BY_STATUS                   (ID_FIRST + 458)
#define ID_SET_ONLINE_CONTACT               (ID_FIRST + 476)
#define ID_LOGIN                            (ID_FIRST + 477)
#define ID_SEND                             (ID_FIRST + 478)
#define ID_CALL                             (ID_FIRST + 479)
#define ID_STATUS                           (ID_FIRST + 480)
#define ID_SHOWALLCONTACT                   (ID_FIRST + 481)
#define ID_SHOW_IM                          (ID_FIRST + 482)
#define ID_HIDE_IM                          (ID_FIRST + 483)

#define ID_DIAL_PHONE_NUMBER                (ID_FIRST + 600)
#define ID_HOME_PHONE                       (ID_FIRST + 601)
#define ID_WORK_PHONE                       (ID_FIRST + 602)
#define ID_MOBILE_PHONE                     (ID_FIRST + 603)
#define ID_IP_PHONE                         (ID_FIRST + 604)

#define ID_DIAL_PHONE_LAST                  (ID_FIRST + 699)

#define ID_VIEW_FILTER_LAST                 (ID_FIRST + 5000)

#define ID_NEW_ACCT_FIRST                   (ID_VIEW_FILTER_LAST + 1)
#define ID_NEW_ACCT_LAST                    (ID_NEW_ACCT_FIRST + 20)

#define ID_MESSENGER_FIRST                  (ID_NEW_ACCT_LAST + 1)
#define ID_POPUP_MESSENGER                  ID_MESSENGER_FIRST
#define ID_POPUP_MESSENGER_STATUS           (ID_MESSENGER_FIRST + 1)
#define ID_LOGIN_MESSENGER                  (ID_MESSENGER_FIRST + 2)
#define ID_MESSENGER_ONLINE                 (ID_MESSENGER_FIRST + 3)
#define ID_MESSENGER_INVISIBLE              (ID_MESSENGER_FIRST + 4)
#define ID_MESSENGER_BUSY                   (ID_MESSENGER_FIRST + 5)
#define ID_MESSENGER_BACK                   (ID_MESSENGER_FIRST + 6)
#define ID_MESSENGER_AWAY                   (ID_MESSENGER_FIRST + 7)
#define ID_MESSENGER_ON_PHONE               (ID_MESSENGER_FIRST + 8)
#define ID_MESSENGER_LUNCH                  (ID_MESSENGER_FIRST + 9)
#define ID_MESSENGER_OPTIONS                (ID_MESSENGER_FIRST + 10)
#define ID_LOGOFF_MESSENGER                 (ID_MESSENGER_FIRST + 11)
#define ID_MESSENGER_LAST                   (ID_MESSENGER_FIRST + 20)
#define ID_VIEW_ONLINE                      (ID_MESSENGER_FIRST + 22)
#define ID_VIEW_ONANDOFFLINE                (ID_MESSENGER_FIRST + 23)
#define ID_VIEW_ALL                         (ID_MESSENGER_FIRST + 24)
#define ID_CONT_FILE                        (ID_MESSENGER_FIRST + 25)
 
//
// END COMMAND IDs
/////////////////////////////////////////////////////////////////////////////

// BL control strings
#define STR_FIRST                       4203
#define idsAthena                       (STR_FIRST + 8)
#define idsAthenaMail                   idsAthena
#define idsChooseName                   (STR_FIRST + 1390)

#define idsBADelBLEntry                 (STR_FIRST + 1924)
#define idsBADelBLABEntry               (STR_FIRST + 1925)
#define idsBADelABEntry                 (STR_FIRST + 1926)
#define idsBADelMultiple                (STR_FIRST + 1927)
#define idsBAErrExtChars                (STR_FIRST + 1928)
// #define idsBAErrNotHotmail              (STR_FIRST + 1929) // Not used anymore
#define idsWABExtTitle                  (STR_FIRST + 1930)
#define idsBAErrJITFail                 (STR_FIRST + 1931)

#define idsBADefault                    (STR_FIRST + 1940)

#define idsServiceName                  (STR_FIRST + 1979)

#define idsBADispStatus                 (STR_FIRST + 2006)
#define idsBAEmail                      (STR_FIRST + 2007)
#define idsBAIMsg                       (STR_FIRST + 2008)
#define idsBAOnline                     (STR_FIRST + 2009)
#define idsBAInvisible                  (STR_FIRST + 2010)
#define idsBABusy                       (STR_FIRST + 2011)
#define idsBABack                       (STR_FIRST + 2012)
#define idsBAAway                       (STR_FIRST + 2013)
#define idsBAOnPhone                    (STR_FIRST + 2014)
#define idsBALunch                      (STR_FIRST + 2015)
#define idsBAOffline                    (STR_FIRST + 2016)
#define idsBAIdle                       (STR_FIRST + 2017)
#define idsTitleMenu                    (STR_FIRST + 2018)
#define idsButtonText                   (STR_FIRST + 2019)
#define idsWabNotFound                  (STR_FIRST + 2020)
#define idsTelFail                      (STR_FIRST + 2021)

// Strings PArt II 
#define idsMsgrEmptyList                (STR_FIRST + 2477)
#define idsInstallText                  (STR_FIRST + 2478)
#define idsClickText                    (STR_FIRST + 2479)
#define idsAttemptText                  (STR_FIRST + 2480)
#define idsWaitText                     (STR_FIRST + 2481)
#define idsHome                         (STR_FIRST + 2482)
#define idsWork                         (STR_FIRST + 2483)
#define idsMobile                       (STR_FIRST + 2484)
#define idsIPPhone                      (STR_FIRST + 2485)
#define idsLeftBr                       (STR_FIRST + 2486)
#define idsRightBr                      (STR_FIRST + 2487)
#define idsTitle                        (STR_FIRST + 2488)
#define idsButtontext                   (STR_FIRST + 2489)
#define idsMSNEmptyList                 (STR_FIRST + 2490)
#define idsToolBar                      (STR_FIRST + 2491)


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap Resource IDs
//
#define idbAddrBookHot                 47

// BL Dialogs
#define iddWabExt                     182

// Strings
#define IDS_PROJNAME                    300
#define IDS_ADDBUDDY                    301
#define IDS_SENDMSG                     302

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        500
#define _APS_NEXT_COMMAND_VALUE         32783
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\resdll\makefile.inc ===
BLCTL_RC_DEPENDS = ..\blctl.rc \
		   ..\blctl.ico \
		   ..\blframe.ico \
		   ..\blframehot.ico \
		   ..\abhot.bmp \
		   ..\face.bmp

..\blctl.rc : $(O)\bactrl.tlb 

$O\blctl.res : $(BLCTL_RC_DEPENDS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\iecont\hotlinks.cpp ===
// =================================================================================
// L I N K S . C P P
// =================================================================================
#include "pch.hxx"
#include "resource.h"
#include "hotlinks.h"
#include <shlwapi.h>
#include <string.h>
#include "baui.h"
#include "clutil.h"
#include <mapi.h>
#include "msoert.h"
#include <w95wraps.h>

#ifndef CharSizeOf
#define CharSizeOf(x)	(sizeof(x) / sizeof(TCHAR))
#endif

// explicit implementation of CharSizeOf
#define CharSizeOf_A(x)	(sizeof(x) / sizeof(CHAR))
#define CharSizeOf_W(x)	(sizeof(x) / sizeof(WCHAR))

const LPTSTR szDefMailKey =  TEXT("Software\\Clients\\Mail");
const LPTSTR szDefContactsKey =  TEXT("Software\\Clients\\Contacts");
const LPTSTR szIEContactsArea =  TEXT("Software\\Microsoft\\Internet Explorer\\Bar\\Contacts");
const LPTSTR szDisableMessnegerArea =  TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Contacts");
const LPTSTR szPhoenixArea =  TEXT("tel\\shell\\open\\command");
const LPTSTR szOEDllPathKey =   TEXT("DllPath");
const LPTSTR szOEName =  TEXT("Outlook Express");
const LPTSTR szEmpty = TEXT("");
const LPTSTR szOutlookName = TEXT("Microsoft Outlook");
const LPTSTR szContactOptions = TEXT("Options");
const LPTSTR szContactDisabled = TEXT("Disabled");
const LPTSTR szUseIM = TEXT("Use_IM");
const LPTSTR szDisableIM = TEXT("Disable_IM");

// =================================================================================
// Globals
// =================================================================================
static COLORREF g_crLink = RGB(0,0,128);
static COLORREF g_crLinkVisited = RGB(128,0,0);

const TCHAR c_szIESettingsPath[] =        "Software\\Microsoft\\Internet Explorer\\Settings";
const TCHAR c_szLinkVisitedColorIE[] =    "Anchor Color Visited";
const TCHAR c_szLinkColorIE[] =           "Anchor Color";
const TCHAR c_szNSSettingsPath[] =        "Software\\Netscape\\Netscape Navigator\\Settings";
const TCHAR c_szLinkColorNS[] =           "Link Color";
const TCHAR c_szLinkVisitedColorNS[] =    "Followed Link Color";


typedef struct _MailParams
{
    HWND hWnd;
    ULONG nRecipCount;
    LPRECIPLIST lpList;
    BOOL bUseOEForSendMail;   // True means check and use OE before checking for Simple MAPI client
} MAIL_PARAMS, * LPMAIL_PARAMS;

/***************************************************************************

    Name      : LocalFreeAndNull

    Purpose   : Frees a local allocation and null's the pointer

    Parameters: lppv = pointer to LocalAlloc pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

***************************************************************************/
// void __fastcall LocalFreeAndNull(LPVOID * lppv) {
void __fastcall LocalFreeAndNull(LPVOID * lppv) {
    if (lppv && *lppv) {
        LocalFree(*lppv);
        *lppv = NULL;
    }
}

/*
-
-   LPCSTR ConvertWtoA(LPWSTR lpszW);
*
*   LocalAllocs a ANSI version of an LPWSTR
*
*   Caller is responsible for freeing
*/
LPSTR ConvertWtoA(LPCWSTR lpszW)
{
    int cch;
    LPSTR lpC = NULL;

    if ( !lpszW)
        goto ret;

//    cch = lstrlenW( lpszW ) + 1;

    cch = WideCharToMultiByte( CP_ACP, 0, lpszW, -1, NULL, 0, NULL, NULL );
    cch = cch + 1;

    if(lpC = (LPSTR) LocalAlloc(LMEM_ZEROINIT, cch))
    {
        WideCharToMultiByte( CP_ACP, 0, lpszW, -1, lpC, cch, NULL, NULL );
    }
ret:
    return lpC;
}

// --------------------------------------------------------------------------
// IEIsSpace
// --------------------------------------------------------------------------
BOOL IEIsSpace(LPSTR psz)
{
    WORD wType = 0;

    if (IsDBCSLeadByte(*psz))
        GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType);
    else
        GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType);
    return (wType & C1_SPACE);
}


// =============================================================================================
// StringTok - similiar to strtok
// =============================================================================================
BOOL FStringTok (LPCTSTR        lpcszString, 
                 ULONG          *piString, 
                 LPTSTR         lpcszTokens, 
                 TCHAR          *chToken, 
                 LPTSTR         lpszValue, 
                 ULONG          cbValueMax,
                 BOOL           fStripTrailingWhitespace)
{
    // Locals
    LPTSTR      lpszStringLoop, 
                lpszTokenLoop;
    ULONG       cbValue=0, 
                nLen=0,
                cCharsSinceSpace=0,
                iLastSpace=0;
    BOOL        fTokenFound = FALSE;

    // Check Params
    _ASSERT (lpcszString && piString && lpcszTokens/*, "These should have been checked."*/);

    // INit = better be on a dbcs boundary
    lpszStringLoop = (LPTSTR)(lpcszString + (*piString));

    // Loop current
    while (*lpszStringLoop)
    {
        // If DBCS Lead Byte, skip it, it will never match the type of tokens I'm looking for
        // Or, If an escape character, don't check delimiters
        if (IsDBCSLeadByte(*lpszStringLoop) || *lpszStringLoop == _T('\\'))
        {
            cCharsSinceSpace+=2;
            lpszStringLoop+=2;
            cbValue+=2;
            continue;
        }
        // Mark and remember last space
        if (cCharsSinceSpace && IEIsSpace(lpszStringLoop))
        {
            cCharsSinceSpace=0;
            iLastSpace=cbValue;
        }
        // Count number of characters since last space
        else
            cCharsSinceSpace++;

        // Look for a tokens
        lpszTokenLoop=lpcszTokens;
        while(*lpszTokenLoop)
        {
            // Token Match ?
            if (*lpszStringLoop == *lpszTokenLoop)
            {
                // Save the found token
                if (chToken)
                    *chToken = *lpszStringLoop;

                // Don't count this character as a charcter seen since last space
                cCharsSinceSpace--;

                // Were done
                fTokenFound = TRUE;
                goto done;
            }

            // Next Token
            lpszTokenLoop++;
        }

        // Next Char
        lpszStringLoop++;
        cbValue++;
    }

done:
    // If reached end of string, this is a default token
    if (*lpszStringLoop == _T('\0'))
    {
        if (chToken)
            *chToken = *lpszStringLoop;
        fTokenFound = TRUE;
    }

    // Copy value if token found
    if (fTokenFound)
    {
        if (lpszValue && cbValueMax > 0 && cbValue)
        {
            if (cbValue+1 <= cbValueMax)
            {
                lstrcpyn (lpszValue, lpcszString + (*piString), cbValue+1);
                nLen = cbValue-1;
            }
            else
            {
                _ASSERT  (FALSE/*, "Buffer is too small."*/);
                lstrcpyn (lpszValue, lpcszString + (*piString), cbValueMax);
                nLen = cbValueMax-1;
            }

            // Strip Trailing Whitespace ?
            if (fStripTrailingWhitespace && cCharsSinceSpace == 0)
            {
                *(lpszValue + iLastSpace) = _T('\0');
                nLen = iLastSpace - 1;
            }
        }

        // No Text
        else
        {
            if (lpszValue)
                *lpszValue = _T('\0');
            nLen = 0;
            cbValue = 0;
        }

        // Set new string index
        *piString += cbValue + 1;
    }
    // Return whether we found a token

    return fTokenFound;
}


// =================================================================================
// ParseLinkColorFromSz
// =================================================================================
VOID ParseLinkColorFromSz(LPTSTR lpszLinkColor, LPCOLORREF pcr)
{
    // Locals
    ULONG           iString = 0;
    TCHAR           chToken,
                    szColor[5];
    DWORD           dwR,
                    dwG,
                    dwB;

    // Red
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T(','))
        goto exit;
    dwR = StrToInt(szColor);

    // Green
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T(','))
        goto exit;
    dwG = StrToInt(szColor);

    // Blue
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T('\0'))
        goto exit;
    dwB = StrToInt(szColor);

    // Create color
    *pcr = RGB(dwR, dwG, dwB);

exit:
    // Done
    return;
}

// =================================================================================
// LookupLinkColors
// =================================================================================
BOOL LookupLinkColors(LPCOLORREF pclrLink, LPCOLORREF pclrViewed)
{
    // Locals
    HKEY        hReg=NULL;
    TCHAR       szLinkColor[255],
                szLinkVisitedColor[255];
    LONG        lResult;
    DWORD       cb;

    // Init
    *szLinkColor = _T('\0');
    *szLinkVisitedColor = _T('\0');

    // Look for IE's link color
    if (RegOpenKeyEx (HKEY_CURRENT_USER, (LPTSTR)c_szIESettingsPath, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
        goto tryns;

    // Query for value
    cb = sizeof (szLinkVisitedColor);
    RegQueryValueEx(hReg, (LPTSTR)c_szLinkVisitedColorIE, 0, NULL, (LPBYTE)szLinkVisitedColor, &cb);
    cb = sizeof (szLinkColor);
    lResult = RegQueryValueEx(hReg, (LPTSTR)c_szLinkColorIE, 0, NULL, (LPBYTE)szLinkColor, &cb);

    // Close Reg
    RegCloseKey(hReg);

    // Did we find it
    if (lResult == ERROR_SUCCESS)
        goto found;

tryns:
    // Try Netscape
    if (RegOpenKeyEx (HKEY_CURRENT_USER, (LPTSTR)c_szNSSettingsPath, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
        goto exit;

    // Query for value
    cb = sizeof (szLinkVisitedColor);
    RegQueryValueEx(hReg, (LPTSTR)c_szLinkVisitedColorNS, 0, NULL, (LPBYTE)szLinkVisitedColor, &cb);
    cb = sizeof (szLinkColor);
    lResult = RegQueryValueEx(hReg, (LPTSTR)c_szLinkColorNS, 0, NULL, (LPBYTE)szLinkColor, &cb);

    // Close Reg
    RegCloseKey(hReg);

    // Did we find it
    if (lResult == ERROR_SUCCESS)
        goto found;

    // Not Found
    goto exit;

found:

    // Parse Link
    ParseLinkColorFromSz(szLinkColor, &g_crLink);
    ParseLinkColorFromSz(szLinkVisitedColor, &g_crLinkVisited);
    
    if (pclrLink)
        *pclrLink = g_crLink;
    if (pclrViewed)    
        *pclrViewed = g_crLinkVisited;
    return (TRUE);

exit:
    // Done
    return (FALSE);
}

//$$///////////////////////////////////////////////////////////////////////
//
// CheckForWAB(void)
//
// return TRUE if default Contacts sectionselected as "Address Book" means WAB
// also We need to be sure that Microsoft Outlook is default email client, 
// if Microsoft Outlook selected as default Contacts
//////////////////////////////////////////////////////////////////////////

BOOL CheckForWAB(void)
{
    BOOL bRet = TRUE;
    HKEY hKeyContacts = NULL;
    DWORD dwErr     = 0;
    DWORD dwSize    = 0;
    DWORD dwType    = 0;
    TCHAR szBuf[MAX_PATH];

    // Open the key for default Contacts client
    // HKLM\Software\Clients\Contacts

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDefContactsKey, 0, KEY_READ, &hKeyContacts);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefContactsKey, dwErr);
        goto out;
    }

    dwSize = CharSizeOf(szBuf);         // Expect ERROR_MORE_DATA

    dwErr = RegQueryValueEx(hKeyContacts, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
        goto out;

    if(!lstrcmpi(szBuf, szOutlookName))
    {
        // Yes its Microsoft Outlook
        bRet = FALSE;
    }
    else
        goto out;
#ifdef NEED
    RegCloseKey(hKeyContacts);
    
    // Check that default email is Microsoft Outlook too.

    // Open the key for default internet mail client
    // HKLM\Software\Clients\Mail

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDefMailKey, 0, KEY_READ, &hKeyContacts);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        bRet = TRUE;
        goto out;
    }

    dwSize = CharSizeOf(szBuf);         // Expect ERROR_MORE_DATA

    dwErr = RegQueryValueEx(    hKeyContacts, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
    {
        bRet = TRUE;
        goto out;
    }

    if(lstrcmpi(szBuf, szOutlookName))
    {
        // Yes its not Microsoft Outlook
        bRet = TRUE;
    }
    
#endif // NEED
out:
    if(hKeyContacts)
        RegCloseKey(hKeyContacts);
    return(bRet);
}

//$$///////////////////////////////////////////////////////////////////////
//
// CheckForOutlookExpress
//
//  szDllPath - is a big enough buffer that will contain the path for
//      the OE dll ..
//
//////////////////////////////////////////////////////////////////////////
BOOL CheckForOutlookExpress(LPTSTR szDllPath)
{
    HKEY hKeyMail   = NULL;
    HKEY hKeyOE     = NULL;
    DWORD dwErr     = 0;
    DWORD dwSize    = 0;
    TCHAR szBuf[MAX_PATH];
    TCHAR szPathExpand[MAX_PATH];
    DWORD dwType    = 0;
    BOOL bRet = FALSE;


    lstrcpy(szDllPath, szEmpty);
    lstrcpy(szPathExpand, szEmpty);

    // Open the key for default internet mail client
    // HKLM\Software\Clients\Mail

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDefMailKey, 0, KEY_READ, &hKeyMail);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = CharSizeOf(szBuf);         // Expect ERROR_MORE_DATA

    dwErr = RegQueryValueEx(    hKeyMail, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(!lstrcmpi(szBuf, szOEName))
    {
        // Yes its outlook express ..
        bRet = TRUE;
    }

    //Get the DLL Path anyway whether this is the default key or not

    // Get the DLL Path
    dwErr = RegOpenKeyEx(hKeyMail, szOEName, 0, KEY_READ, &hKeyOE);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = CharSizeOf(szBuf);
    lstrcpy(szBuf, s