 PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;

    Status = PrepareForSeparation();
    if (Status != S_OK)
    {
        ErrOut("Unable to prepare process for termination, %s\n",
               FormatStatusCode(Status));
        return Status;
    }

    PPROCESS_INFO Process;

    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        if ((Status = TerminateProcess(Process)) != S_OK)
        {
            goto Exit;
        }
    }

    if (g_EngDefer & ENG_DEFER_CONTINUE_EVENT)
    {
        // The event's process may just been terminated so don't
        // check for failures.
        Services->ContinueEvent(DBG_CONTINUE);
    }
    DiscardLastEvent();

    DEBUG_EVENT64 Event;
    ULONG EventUsed;
    BOOL AnyLeft;
    BOOL AnyExited;

    for (;;)
    {
        while (Services->WaitForEvent(0, &Event, sizeof(Event),
                                      &EventUsed) == S_OK)
        {
            // Check for process exit events so we can
            // mark the process infos as exited.
            if (EventUsed == sizeof(DEBUG_EVENT32))
            {
                DEBUG_EVENT32 Event32 = *(DEBUG_EVENT32*)&Event;
                DebugEvent32To64(&Event32, &Event);
            }
            else if (EventUsed != sizeof(DEBUG_EVENT64))
            {
                ErrOut("Event data corrupt\n");
                Status = E_FAIL;
                goto Exit;
            }

            if (Event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
            {
                Process = FindProcessBySystemId(Event.dwProcessId);
                if (Process != NULL)
                {
                    MarkProcessExited(Process);
                }
            }

            Services->ContinueEvent(DBG_CONTINUE);
        }

        AnyLeft = FALSE;
        AnyExited = FALSE;

        for (Process = g_ProcessHead;
             Process != NULL;
             Process = Process->Next)
        {
            if (!Process->Exited)
            {
                ULONG Code;

                if ((Status = Services->
                     GetProcessExitCode(Process->FullHandle, &Code)) == S_OK)
                {
                    MarkProcessExited(Process);
                    AnyExited = TRUE;
                }
                else if (FAILED(Status))
                {
                    ErrOut("Unable to wait for process to terminate, %s\n",
                           FormatStatusCode(Status));
                    goto Exit;
                }
                else
                {
                    AnyLeft = TRUE;
                }
            }
        }

        if (!AnyLeft)
        {
            break;
        }

        if (!AnyExited)
        {
            // Give things time to run and exit.
            Sleep(50);
        }
    }

    // We've terminated everything so it's safe to assume
    // we're no longer debugging any system processes.
    // We do this now rather than wait for DeleteProcess
    // so that shutdown can query the value immediately.
    g_AllProcessFlags &= ~ENG_PROC_SYSTEM;

    //
    // Drain off any remaining events.
    //

    while (Services->WaitForEvent(10, &Event, sizeof(Event), NULL) == S_OK)
    {
        Services->ContinueEvent(DBG_CONTINUE);
    }

    Status = S_OK;

 Exit:
    return Status;
}

HRESULT
DetachProcess(PPROCESS_INFO Process)
{
    DBG_ASSERT(IS_LIVE_USER_TARGET());
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;
    HRESULT Status = S_OK;
    
    if (!Process->Exited)
    {
        if ((Process->Flags & ENG_PROC_EXAMINED) == 0 &&
            (Status = Services->DetachProcess(Process->SystemId)) != S_OK)
        {
            // Older systems don't support detach so
            // don't show an error message in that case.
            if (Status != E_NOTIMPL)
            {
                ErrOut("DebugActiveProcessStop(%d) failed, %s\n",
                       Process->SystemId, FormatStatusCode(Status));
            }
        }
        else
        {
            MarkProcessExited(Process);
        }
    }

    return Status;
}

HRESULT
DetachProcesses(void)
{
    DBG_ASSERT(IS_LIVE_USER_TARGET());
    
    HRESULT Status;
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;

    Status = PrepareForSeparation();
    if (Status != S_OK)
    {
        ErrOut("Unable to prepare process for detach, %s\n",
               FormatStatusCode(Status));
        return Status;
    }

    if (g_EngDefer & ENG_DEFER_CONTINUE_EVENT)
    {
        if ((Status = Services->ContinueEvent(DBG_CONTINUE)) != S_OK)
        {
            ErrOut("Unable to continue terminated process, %s\n",
                   FormatStatusCode(Status));
            return Status;
        }
    }
    DiscardLastEvent();

    PPROCESS_INFO Process;

    for (Process = g_ProcessHead;
         Process != NULL;
         Process = Process->Next)
    {
        DetachProcess(Process);
    }

    // We've terminated everything so it's safe to assume
    // we're no longer debugging any system processes.
    // We do this now rather than wait for DeleteProcess
    // so that shutdown can query the value immediately.
    g_AllProcessFlags &= ~ENG_PROC_SYSTEM;

    //
    // Drain off any remaining events.
    //

    DEBUG_EVENT64 Event;

    while (Services->WaitForEvent(10, &Event, sizeof(Event), NULL) == S_OK)
    {
        Services->ContinueEvent(DBG_CONTINUE);
    }

    return S_OK;
}

HRESULT
AbandonProcess(PPROCESS_INFO Process)
{
    DBG_ASSERT(IS_LIVE_USER_TARGET());
    
    HRESULT Status;
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;

    if ((Status = Services->AbandonProcess(Process->FullHandle)) != S_OK)
    {
        // Older systems don't support abandon so
        // don't show an error message in that case.
        if (Status != E_NOTIMPL)
        {
            ErrOut("Unable to abandon process\n");
        }
        return Status;
    }

    // We need to continue any existing event as it won't
    // be returned from WaitForDebugEvent again.  We
    // do not want to resume execution, though.
    if (g_EngDefer & ENG_DEFER_CONTINUE_EVENT)
    {
        if ((Status = Services->ContinueEvent(DBG_CONTINUE)) != S_OK)
        {
            ErrOut("Unable to continue abandoned event, %s\n",
                   FormatStatusCode(Status));
            return Status;
        }
    }
    DiscardLastEvent();

    return Status;
}

HRESULT
SeparateCurrentProcess(ULONG Mode, PSTR Description)
{
    if (!IS_LIVE_USER_TARGET() ||
        g_CurrentProcess == NULL)
    {
        return E_UNEXPECTED;
    }
    
    PUSER_DEBUG_SERVICES Services = ((UserTargetInfo*)g_Target)->m_Services;

    if (Mode == SEP_DETACH && IS_CONTEXT_ACCESSIBLE())
    {
        ADDR Pc;

        // Move the PC past any current breakpoint instruction so that
        // the process has a chance of running.
        g_Machine->GetPC(&Pc);
        if (g_Machine->IsBreakpointInstruction(&Pc))
        {
            g_Machine->AdjustPCPastBreakpointInstruction
                (&Pc, DEBUG_BREAKPOINT_CODE);
        }
    }
        
    // Flush any buffered changes.
    if (IS_CONTEXT_ACCESSIBLE())
    {
        FlushRegContext();
    }
    
    if (g_EventProcess == g_CurrentProcess)
    {
        if (g_EngDefer & ENG_DEFER_CONTINUE_EVENT)
        {
            Services->ContinueEvent(DBG_CONTINUE);
        }
        DiscardLastEvent();
        g_EventProcess = NULL;
        g_EventThread = NULL;
    }
    
    SuspendResumeThreads(g_CurrentProcess, FALSE, NULL);

    HRESULT Status;
    PSTR Operation;

    switch(Mode)
    {
    case SEP_DETACH:
        Status = DetachProcess(g_CurrentProcess);
        Operation = "Detached";
        break;
    case SEP_TERMINATE:
        Status = TerminateProcess(g_CurrentProcess);
        if ((g_CurrentProcess->Flags & ENG_PROC_EXAMINED) == 0)
        {
            Operation = "Terminated.  "
                "Exit thread and process events will occur.";
        }
        else
        {
            Operation = "Terminated";
        }
        break;
    case SEP_ABANDON:
        Status = AbandonProcess(g_CurrentProcess);
        Operation = "Abandoned";
        break;
    }
    
    if (Status == S_OK)
    {
        if (Description != NULL)
        {
            strcpy(Description, Operation);
        }

        // If we're detaching or abandoning it's safe to go
        // ahead and remove the process now so that it
        // can't be access further.
        // If we're terminating we have to wait for
        // the exit events to come through so
        // keep the process until that happens.
        if (Mode != SEP_TERMINATE)
        {
            PPROCESS_INFO Prev, Cur;

            Prev = NULL;
            for (Cur = g_ProcessHead;
                 Cur != g_CurrentProcess;
                 Cur = Cur->Next)
            {
                Prev = Cur;
            }
            RemoveAndDeleteProcess(Cur, Prev);
        
            g_CurrentProcess = g_ProcessHead;
            if (g_CurrentProcess != NULL)
            {
                if (g_CurrentProcess->CurrentThread == NULL)
                {
                    g_CurrentProcess->CurrentThread =
                        g_CurrentProcess->ThreadHead;
                }
                if (g_CurrentProcess->CurrentThread != NULL)
                {
                    SetPromptThread(g_CurrentProcess->CurrentThread,
                                    SPT_DEFAULT_OCI_FLAGS);
                }
            }
        }
        else
        {
            g_CurrentProcess->Exited = FALSE;
        }
    }
    else
    {
        SuspendResumeThreads(g_CurrentProcess, TRUE, NULL);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\stepgo.cpp ===
//----------------------------------------------------------------------------
//
// Handles stepping, tracing and go.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define DBG_KWT 0
#define DBG_UWT 0

Breakpoint* g_GoBreakpoints[MAX_GO_BPS];
ULONG g_NumGoBreakpoints;

// Pass count of trace breakpoint.
ULONG   g_StepTracePassCount;
ULONG64 g_StepTraceInRangeStart = (ULONG64)-1;
ULONG64 g_StepTraceInRangeEnd;

IMAGEHLP_LINE64 g_SrcLine;      //  Current source line for step/trace
BOOL g_SrcLineValid;            //  Validity of SrcLine information

BOOL    g_WatchTrace;
BOOL    g_WatchWhole;
ADDR    g_WatchTarget;
ULONG64 g_WatchInitialSP;
ULONG64 g_WatchBeginCurFunc = 1;
ULONG64 g_WatchEndCurFunc;

WatchFunctions g_WatchFunctions;

//----------------------------------------------------------------------------
//
// WatchFunctions.
//
//----------------------------------------------------------------------------

WatchFunctions::WatchFunctions(void)
{
    m_Started = FALSE;
}

void
WatchFunctions::Start(void)
{
    ULONG i;

    m_TotalInstr = 0;
    m_TotalWatchTraceEvents = 0;
    m_TotalWatchThreadMismatches = 0;

    for (i = 0; i < WF_BUCKETS; i++)
    {
        m_Funcs[i] = NULL;
    }
    
    m_Sorted = NULL;
    m_CallTop = NULL;
    m_CallBot = NULL;
    m_CallLevel = 0;
    m_Started = TRUE;
}

void
WatchFunctions::End(PADDR PcAddr)
{
    g_StepTracePassCount = 0;
    g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
    if (IS_CONN_KERNEL_TARGET())
    {
        g_DbgKdTransport->m_BreakIn = FALSE;
    }

    if (!m_Started)
    {
        return;
    }
        
    ULONG TotalInstr;
    
    if (IS_KERNEL_TARGET())
    {
        PDBGKD_TRACE_DATA td = (PDBGKD_TRACE_DATA)g_StateChangeData;
        if (g_WatchWhole)
        {
            if (td[1].s.Instructions == TRACE_DATA_INSTRUCTIONS_BIG)
            {
                TotalInstr = td[2].LongNumber;
            }
            else
            {
                TotalInstr = td[1].s.Instructions;
            }
        }
        else
        {
            if (PcAddr != NULL)
            {
                g_Target->ProcessWatchTraceEvent(td, *PcAddr);
            }
        
            while (m_CallTop != NULL)
            {
                PopCall();
            }

            TotalInstr = m_TotalInstr;
        }
        
        g_BreakpointsSuspended = FALSE;
        g_WatchInitialSP = 0;
    }
    else
    {
        if (m_CallTop != NULL)
        {
            OutputCall(m_CallTop);
        }

        while (m_CallTop != NULL)
        {
            PopCall();
        }

        TotalInstr = m_TotalInstr;
        dprintf("\n");
    }

    m_Started = FALSE;

    dprintf("%d instructions were executed in %d events "
            "(%d from other threads)\n",
            TotalInstr,
            m_TotalWatchTraceEvents,
            m_TotalWatchThreadMismatches);

    if (!g_WatchWhole)
    {
        OutputFunctions();
    }
    
    if (!IS_KERNEL_TARGET())
    {
        OutputSysCallFunctions();
    }

    dprintf("\n");
    
    Clear();
}

void
WatchFunctions::OutputFunctions(void)
{
    WatchFunction* Func;
    
    dprintf("\n%-43.43s Invocations MinInst MaxInst AvgInst\n",
            "Function Name");

    for (Func = m_Sorted; Func != NULL; Func = Func->Sort)
    {
        dprintf("%-47.47s%8d%8d%8d%8d\n",
                Func->Symbol, Func->Calls,
                Func->MinInstr, Func->MaxInstr,
                Func->Calls ? Func->TotalInstr / Func->Calls : 0);
    }
}

void
WatchFunctions::OutputSysCallFunctions(void)
{
    WatchFunction* Func;
    ULONG TotalSysCalls = 0;
    
    for (Func = m_Sorted; Func != NULL; Func = Func->Sort)
    {
        TotalSysCalls += Func->SystemCalls;
    }

    if (TotalSysCalls == 1)
    {
        dprintf("\n%d system call was executed\n", TotalSysCalls);
    }
    else
    {
        dprintf("\n%d system calls were executed\n", TotalSysCalls);
    }

    if (TotalSysCalls == 0)
    {
        return;
    }
    
    dprintf("\nCalls  System Call\n");

    for (Func = m_Sorted; Func != NULL; Func = Func->Sort)
    {
        if (Func->SystemCalls > 0)
        {
            dprintf("%5d  %s\n", Func->SystemCalls, Func->Symbol);
        }
    }
}

WatchFunction*
WatchFunctions::FindAlways(PSTR Sym, ULONG64 Start)
{
    WatchFunction* Func = Find(Sym);
    if (Func == NULL)
    {
        Func = Add(Sym, Start);
    }
    return Func;
}

WatchCallStack*
WatchFunctions::PushCall(WatchFunction* Func)
{
    WatchCallStack* Call = new WatchCallStack;
    if (Call != NULL)
    {
        ZeroMemory(Call, sizeof(*Call));
        
        Call->Prev = m_CallTop;
        Call->Next = NULL;
        if (m_CallTop == NULL)
        {
            m_CallBot = Call;
        }
        else
        {
            m_CallTop->Next = Call;
            m_CallLevel++;
        }
        m_CallTop = Call;

        Call->Func = Func;
        Call->Level = m_CallLevel;
    }
    return Call;
}

void
WatchFunctions::PopCall(void)
{
    if (m_CallTop == NULL)
    {
        return;
    }

    WatchCallStack* Call = m_CallTop;
    
    if (Call->Prev != NULL)
    {
        Call->Prev->Next = Call->Next;
    }
    else
    {
        m_CallBot = Call->Next;
    }
    if (Call->Next != NULL)
    {
        Call->Next->Prev = Call->Prev;
    }
    else
    {
        m_CallTop = Call->Prev;
    }

    m_CallLevel = m_CallTop != NULL ? m_CallTop->Level : 0;
    
    ReuseCall(Call, NULL);
    delete Call;
}

#define MAXPCOFFSET 10

WatchCallStack*
WatchFunctions::PopCallsToCallSite(PADDR Pc)
{
    WatchCallStack* Call = m_CallTop;
    while (Call != NULL)
    {
        if ((Flat(*Pc) - Flat(Call->CallSite)) < MAXPCOFFSET)
        {
            break;
        }

        Call = Call->Prev;
    }

    if (Call == NULL)
    {
        // No matching call site found.
        return NULL;
    }

    // Pop off calls above the call site.
    while (m_CallTop != Call)
    {
        PopCall();
    }

    return m_CallTop;
}

WatchCallStack*
WatchFunctions::PopCallsToFunctionStart(ULONG64 Start)
{
    WatchCallStack* Call = m_CallTop;
    while (Call != NULL)
    {
        if (Start == Call->Func->StartOffset)
        {
            break;
        }

        Call = Call->Prev;
    }

    if (Call == NULL)
    {
        // No matching calling function found.
        return NULL;
    }

    // Pop off calls above the calling function.
    while (m_CallTop != Call)
    {
        PopCall();
    }

    return m_CallTop;
}

void
WatchFunctions::ReuseCall(WatchCallStack* Call,
                          WatchFunction* ReinitFunc)
{
    if (Call->Prev != NULL)
    {
        Call->Prev->ChildInstrCount +=
            Call->InstrCount + Call->ChildInstrCount;
    }

    WatchFunction* Func = Call->Func;
    if (Func != NULL)
    {
        Func->Calls++;
        Func->TotalInstr += Call->InstrCount;
        m_TotalInstr += Call->InstrCount;
        if (Func->MinInstr > Call->InstrCount)
        {
            Func->MinInstr = Call->InstrCount;
        }
        if (Func->MaxInstr < Call->InstrCount)
        {
            Func->MaxInstr = Call->InstrCount;
        }
    }

    ZeroMemory(&Call->CallSite, sizeof(Call->CallSite));
    Call->Func = ReinitFunc;
    Call->Level = m_CallLevel;
    Call->InstrCount = 0;
    Call->ChildInstrCount = 0;
}

#define MAX_INDENT_LEVEL 50

void
WatchFunctions::OutputCall(WatchCallStack* Call)
{
    LONG i;

    dprintf("%5ld %5ld [%3ld]", Call->InstrCount, Call->ChildInstrCount,
            Call->Level);

    if (Call->Level < MAX_INDENT_LEVEL)
    {
        for (i = 0; i < Call->Level; i++)
        {
            dprintf("  ");
        }
    }
    else
    {
        for (i = 0; i < MAX_INDENT_LEVEL + 1; i++)
        {
            dprintf("  ");
        }
    }
    dprintf(" %s\n", Call->Func->Symbol);
}

WatchFunction*
WatchFunctions::Add(PSTR Sym, ULONG64 Start)
{
    WatchFunction* Func = new WatchFunction;
    if (Func == NULL)
    {
        return NULL;
    }

    ZeroMemory(Func, sizeof(*Func));

    Func->StartOffset = Start;
    Func->MinInstr = -1;
    Func->SymbolLength = strlen(Sym);
    strncat(Func->Symbol, Sym, sizeof(Func->Symbol) - 1);

    //
    // Add into appropriate hash bucket.
    //

    // Hash under full name as that's what searches will
    // hash with.
    int Bucket = Hash(Sym, Func->SymbolLength);
    Func->Next = m_Funcs[Bucket];
    m_Funcs[Bucket] = Func;
    
    //
    // Add into sorted list.
    //
    
    WatchFunction* Cur, *Prev;

    Prev = NULL;
    for (Cur = m_Sorted; Cur != NULL; Cur = Cur->Sort)
    {
        if (strcmp(Func->Symbol, Cur->Symbol) <= 0)
        {
            break;
        }
        
        Prev = Cur;
    }

    Func->Sort = Cur;
    if (Prev == NULL)
    {
        m_Sorted = Func;
    }
    else
    {
        Prev->Sort = Func;
    }
    
    return Func;
}

WatchFunction*
WatchFunctions::Find(PSTR Sym)
{
    int SymLen = strlen(Sym);
    int Bucket = Hash(Sym, SymLen);
    WatchFunction* Func = m_Funcs[Bucket];

    while (Func != NULL)
    {
        if (SymLen == Func->SymbolLength &&
            !strncmp(Sym, Func->Symbol, sizeof(Func->Symbol) - 1))
        {
            break;
        }

        Func = Func->Next;
    }

    return Func;
}

void
WatchFunctions::Clear(void)
{
    ULONG i;

    for (i = 0; i < WF_BUCKETS; i++)
    {
        WatchFunction* Func;

        while (m_Funcs[i] != NULL)
        {
            Func = m_Funcs[i]->Next;
            delete m_Funcs[i];
            m_Funcs[i] = Func;
        }
    }

    m_Sorted = NULL;
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo watch trace methods.
//
//----------------------------------------------------------------------------

typedef struct _TRACE_DATA_SYM
{
    ULONG64 SymMin;
    ULONG64 SymMax;
} TRACE_DATA_SYM, *PTRACE_DATA_SYM;

TRACE_DATA_SYM TraceDataSyms[256];
UCHAR NextTraceDataSym = 0;   // what's the next one to be replaced
UCHAR NumTraceDataSyms = 0;   // how many are valid?

void
ConnLiveKernelTargetInfo::InitializeWatchTrace(void)
{
    ADDR SpAddr;
            
    g_Machine->GetSP(&SpAddr);
    g_WatchInitialSP = Flat(SpAddr);
    g_BreakpointsSuspended = TRUE;

    NextTraceDataSym = 0;
    NumTraceDataSyms = 0;
}

LONG
SymNumFor (
    ULONG64 Pc
    )
{
    long index;

    for ( index = 0; index < NumTraceDataSyms; index++ )
    {
        if ( (TraceDataSyms[index].SymMin <= Pc) &&
             (TraceDataSyms[index].SymMax > Pc) )
        {
            return index;
        }
    }
    return -1;
}

VOID
PotentialNewSymbol (
    ULONG64 Pc
    )
{
    if ( -1 != SymNumFor(Pc) )
    {
        return;  // we've already seen this one
    }

    TraceDataSyms[NextTraceDataSym].SymMin = g_WatchBeginCurFunc;
    TraceDataSyms[NextTraceDataSym].SymMax = g_WatchEndCurFunc;

    //
    // Bump the "next" pointer, wrapping if necessary.  Also bump the
    // "valid" pointer if we need to.
    //

    NextTraceDataSym = (NextTraceDataSym + 1) %
        (sizeof(TraceDataSyms) / sizeof(TraceDataSyms[0]));;
    if ( NumTraceDataSyms < NextTraceDataSym )
    {
        NumTraceDataSyms = NextTraceDataSym;
    }
}

void
ConnLiveKernelTargetInfo::ProcessWatchTraceEvent(
    PDBGKD_TRACE_DATA TraceData,
    ADDR PcAddr
    )
{
    //
    // All of the real information is captured in the TraceData unions
    // sent to us by the kernel.  Here we have two main jobs:
    //
    // 1) Print out the data in the TraceData record.
    // 2) See if we need up update the SymNum table before
    //    returning to the kernel.
    //

    char SymName[MAX_SYMBOL_LEN];
    ULONG index;
    ULONG64 qw;
    ADDR CurSP;

    g_WatchFunctions.RecordEvent();
    
    g_Machine->GetSP(&CurSP);
    if ( AddrEqu(g_WatchTarget, PcAddr) && (Flat(CurSP) >= g_WatchInitialSP) )
    {
        //
        // HACK HACK HACK
        //
        // fix up the last trace entry.
        //

        ULONG lastEntry = TraceData[0].LongNumber;
        if (lastEntry != 0)
        {
            TraceData[lastEntry].s.LevelChange = -1;
            // this is wrong if we
            // filled the symbol table!
            TraceData[lastEntry].s.SymbolNumber = 0;
        }
    }

    for ( index = 1; index < TraceData[0].LongNumber; index++ )
    {
        WatchFunction* Func;
        WatchCallStack* Call;
        ULONG64 SymOff = TraceDataSyms[TraceData[index].s.SymbolNumber].SymMin;

        GetSymbolStdCall(SymOff, SymName, sizeof(SymName), &qw, NULL);
        if (!SymName[0])
        {
            SymName[0] = '0';
            SymName[1] = 'x';
            strcpy(SymName + 2, FormatAddr64(SymOff));
            qw = 0;
        }

#if DBG_KWT
        dprintf("!%2d: lev %2d instr %4u %s %s\n",
                index,
                TraceData[index].s.LevelChange,
                TraceData[index].s.Instructions ==
                TRACE_DATA_INSTRUCTIONS_BIG ?
                TraceData[index + 1].LongNumber :
                TraceData[index].s.Instructions,
                FormatAddr64(SymOff), SymName);
#endif
        
        Func = g_WatchFunctions.FindAlways(SymName, SymOff - qw);
        if (Func == NULL)
        {
            ErrOut("Unable to allocate watch function\n");
            goto Flush;
        }

        Call = g_WatchFunctions.GetTopCall();
        if (Call == NULL || TraceData[index].s.LevelChange > 0)
        {
            if (Call == NULL)
            {
                // Treat the initial entry as a pseudo-call to
                // get it pushed.
                TraceData[index].s.LevelChange = 1;
            }
            
            while (TraceData[index].s.LevelChange != 0)
            {
                Call = g_WatchFunctions.PushCall(Func);
                if (Call == NULL)
                {
                    ErrOut("Unable to allocate watch call level\n");
                    goto Flush;
                }

                TraceData[index].s.LevelChange--;
            }
        }
        else if (TraceData[index].s.LevelChange < 0)
        {
            while (TraceData[index].s.LevelChange != 0)
            {
                g_WatchFunctions.PopCall();
                TraceData[index].s.LevelChange++;
            }

            // The level change may not actually be accurate, so
            // attempt to match up the current symbol offset with
            // some level of the call stack.
            Call = g_WatchFunctions.PopCallsToFunctionStart(SymOff);
            if (Call == NULL)
            {
                WarnOut(">> Unable to match return to %s\n", SymName);
                Call = g_WatchFunctions.GetTopCall();
            }
        }
        else
        {
            // We just made a horizontal call.
            g_WatchFunctions.ReuseCall(Call, Func);
        }

        ULONG InstrCount;
        
        if (TraceData[index].s.Instructions == TRACE_DATA_INSTRUCTIONS_BIG)
        {
            InstrCount = TraceData[++index].LongNumber;
        }
        else
        {
            InstrCount = TraceData[index].s.Instructions;
        }

        if (Call != NULL)
        {
            Call->InstrCount += InstrCount;
            g_WatchFunctions.OutputCall(Call);
        }
    }

    //
    // now see if we need to add a new symbol
    //

    index = SymNumFor(Flat(PcAddr));
    if (-1 == index)
    {
        /* yup, add the symbol */

        GetAdjacentSymOffsets(Flat(PcAddr),
                              &g_WatchBeginCurFunc, &g_WatchEndCurFunc);
        if ((g_WatchBeginCurFunc == 0) ||
            (g_WatchEndCurFunc == (ULONG64)-1))
        {
            // Couldn't determine function, fake up
            // a single-byte function.
            g_WatchBeginCurFunc = g_WatchEndCurFunc = Flat(PcAddr);
        }

        PotentialNewSymbol(Flat(PcAddr));
    }
    else
    {
        g_WatchBeginCurFunc = TraceDataSyms[index].SymMin;
        g_WatchEndCurFunc = TraceDataSyms[index].SymMax;
    }

    if ((g_WatchBeginCurFunc <= Flat(g_WatchTarget)) &&
        (Flat(g_WatchTarget) < g_WatchEndCurFunc))
    {
        // The "exit" address is in the symbol range;
        // fix it so this isn't the case.
        if (Flat(PcAddr) < Flat(g_WatchTarget))
        {
            g_WatchEndCurFunc = Flat(g_WatchTarget);
        }
        else
        {
            g_WatchBeginCurFunc = Flat(g_WatchTarget) + 1;
        }
    }

 Flush:
    FlushCallbacks();
}

//----------------------------------------------------------------------------
//
// UserTargetInfo watch trace methods.
//
//----------------------------------------------------------------------------

LONG g_DeferredLevelChange;

void
UserTargetInfo::InitializeWatchTrace(void)
{
    g_DeferredLevelChange = 0;
}

void
UserTargetInfo::ProcessWatchTraceEvent(
    PDBGKD_TRACE_DATA TraceData,
    ADDR PcAddr
    )
{
    WatchFunction* Func;
    WatchCallStack* Call;
    ULONG64 Disp64;
    CHAR Disasm[MAX_DISASM_LEN];

    g_WatchFunctions.RecordEvent();
    
    //
    // Get current function and see if it matches current.  If so, bump
    // count in current, otherwise, update to new level
    //

    GetSymbolStdCall(Flat(PcAddr), Disasm, sizeof(Disasm),
                     &Disp64, NULL);

    // If there's no symbol for the current address create a
    // fake symbol for the instruction address.
    if (!Disasm[0])
    {
        Disasm[0] = '0';
        Disasm[1] = 'x';
        strcpy(Disasm + 2, FormatAddr64(Flat(PcAddr)));
        Disp64 = 0;
    }
    
    Func = g_WatchFunctions.FindAlways(Disasm, Flat(PcAddr) - Disp64);
    if (Func == NULL)
    {
        ErrOut("Unable to allocate watch symbol\n");
        goto Flush;
    }
    
    g_Machine->Disassemble(&PcAddr, Disasm, FALSE);

    Call = g_WatchFunctions.GetTopCall();
    if (Call == NULL)
    {
        //
        // First symbol in the list
        //

        Call = g_WatchFunctions.PushCall(Func);
        if (Call == NULL)
        {
            ErrOut("Unable to allocate watch symbol\n");
            goto Flush;
        }

        // At least one instruction must have executed
        // in this call to register it so initialize to one.
        // Also, one instruction was executed to get to the
        // first trace point so count it here.
        Call->InstrCount += 2;
    }
    else
    {
        if (g_DeferredLevelChange < 0)
        {
            g_DeferredLevelChange = 0;

            g_WatchFunctions.OutputCall(Call);
            
            // We have to see if this is really returning to a call site.
            // We do this because of try-finally funnies
            LONG OldLevel = g_WatchFunctions.GetCallLevel();
            WatchCallStack* CallSite =
                g_WatchFunctions.PopCallsToCallSite(&PcAddr);
            if (CallSite == NULL)
            {
                WarnOut(">> No match on ret %s\n", Disasm);
            }
            else
            {
                if (OldLevel - 1 != CallSite->Level)
                {
                    WarnOut(">> More than one level popped %d -> %d\n",
                            OldLevel, CallSite->Level);
                }
                
                ZeroMemory(&CallSite->CallSite, sizeof(CallSite->CallSite));
                Call = CallSite;
            }
        }

        if (Call->Func == Func && g_DeferredLevelChange == 0)
        {
            Call->InstrCount++;
        }
        else
        {
            g_WatchFunctions.OutputCall(Call);

            if (g_DeferredLevelChange > 0)
            {
                g_DeferredLevelChange = 0;

                Call = g_WatchFunctions.PushCall(Func);
                if (Call == NULL)
                {
                    ErrOut("Unable to allocate watch symbol\n");
                    goto Flush;
                }
            }
            else
            {
                g_WatchFunctions.ReuseCall(Call, Func);
            }

            // At least one instruction must have executed
            // in this call to register it so initialize to one.
            Call->InstrCount++;
        }
    }

#if DBG_UWT
    dprintf("! %3d %s", Call != NULL ? Call->InstrCount : -1, Disasm);
#endif
    
    //
    // Adjust watch level to compensate for kernel-mode callbacks
    //
    if (Call->InstrCount == 1)
    {
        if (!_stricmp(Call->Func->Symbol,
                      "ntdll!_KiUserCallBackDispatcher"))
        {
            g_WatchFunctions.ChangeCallLevel(1);
            Call->Level = g_WatchFunctions.GetCallLevel();
        }
        else if (!_stricmp(Call->Func->Symbol, "ntdll!_ZwCallbackReturn"))
        {
            g_WatchFunctions.ChangeCallLevel(-2);
            Call->Level = g_WatchFunctions.GetCallLevel();
        }
    }

    if (g_Machine->IsCallDisasm(Disasm))
    {
        Call->CallSite = PcAddr;
        g_DeferredLevelChange = 1;
    }
    else if (g_Machine->IsReturnDisasm(Disasm))
    {
        g_DeferredLevelChange = -1;
    }
    else if (g_Machine->IsSystemCallDisasm(Disasm))
    {
        PSTR CallName;
        ULONG i;
        WatchCallStack* SysCall = Call;

        CallName = strchr(Call->Func->Symbol, '!');
        if (!CallName)
        {
            CallName = Call->Func->Symbol;
        }
        else
        {
            CallName++;
        }
        if (!strcmp(CallName, "*SharedUserSystemCall"))
        {
            // We're in a Whistler system call thunk
            // and the interesting system call symbol
            // is the previous level.
            SysCall = Call->Prev;
        }

        if (SysCall != NULL)
        {
            SysCall->Func->SystemCalls++;

            // ZwRaiseException returns out two levels after the call.
            if (!_stricmp(SysCall->Func->Symbol, "ntdll!ZwRaiseException") ||
                !_stricmp(SysCall->Func->Symbol, "ntdll!_ZwRaiseException"))
            {
                g_WatchFunctions.ChangeCallLevel(-1);
            }
        }

        g_WatchFunctions.ChangeCallLevel(-1);
    }

 Flush:
    FlushCallbacks();
}

//----------------------------------------------------------------------------
//
// Support functions.
//
//----------------------------------------------------------------------------

/*** parseStepTrace - parse step or trace
*
*   Purpose:
*       Parse the step ("p") or trace ("t") command.  Command
*       syntax is "[~<thread>]p|t[b] [=<addr>][count].  Once parsed,
*       call fnStepTrace to step or trace the program.
*
*   Input:
*       pThread - nonNULL for breakpoint on specific thread
*       fThreadFreeze - TRUE if all threads except pThread are frozen
*       *g_CurCmd - pointer to operands in command string
*       chcmd - 'p' for step, 't' for trace, 'w' for watch
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit:
*               SYNTAX - indirectly through GetExpression
*
*************************************************************************/

VOID
parseStepTrace (
    PTHREAD_INFO pThread,
    BOOL fThreadFreeze,
    UCHAR chcmd
    )
{
    ADDR    addr1;
    ULONG64 value2;
    UCHAR   ch;
    CHAR    chAddrBuffer[MAX_SYMBOL_LEN];
    ULONG64 displacement;

    if (!IS_EXECUTION_POSSIBLE())
    {
        error(SESSIONNOTSUP);
    }

    if (!IS_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }
    
    if (IS_LIVE_USER_TARGET())
    {
        if (g_AllProcessFlags & ENG_PROC_EXAMINED)
        {
            ErrOut("The debugger is not attached so "
                   "process execution cannot be monitored\n");
            return;
        }
        else if ((g_EngDefer & ENG_DEFER_CONTINUE_EVENT) == 0)
        {
            ErrOut("Due to the break-in timeout the debugger "
                   "cannot step or trace\n");
            return;
        }
    }
    
    if (chcmd == 'w')
    {
        if (IS_KERNEL_TARGET() &&
            g_TargetMachineType != IMAGE_FILE_MACHINE_I386)
        {
            error(UNIMPLEMENT);
        }
        
        if ((PeekChar() == 't') ||
            (IS_KERNEL_TARGET() && PeekChar() == 'w'))
        {
            g_WatchTrace = TRUE;
            g_WatchWhole = *g_CurCmd == 'w';
            g_WatchBeginCurFunc = g_WatchEndCurFunc = 0;
            g_CurCmd++;
        }
        else
        {
            error(SYNTAX);
        }
    }
    else
    {
        g_WatchTrace = FALSE;

        //
        // if next character is 'b' and command is 't' perform branch trace
        //

        ch = PeekChar();
        if ((chcmd == 't') && (tolower(ch) == 'b'))
        {
            if (!g_Machine->IsStepStatusSupported(DEBUG_STATUS_STEP_BRANCH))
            {
                error(SESSIONNOTSUP);                
            }

            chcmd = 'b';
            g_CurCmd++;
        }

        //
        //  if next character is 'r', toggle flag to output registers
        //  on display on breakpoint.
        //

        ch = PeekChar();
        if (tolower(ch) == 'r')
        {
            g_CurCmd++;
            g_OciOutputRegs = !g_OciOutputRegs;
        }
    }

    g_Machine->GetPC(&addr1);         // default to current PC
    if (PeekChar() == '=')
    {
        g_CurCmd++;
        GetAddrExpression(SEGREG_CODE, &addr1);
    }

    value2 = 1;
    if ((ch = PeekChar()) != '\0' && ch != ';')
    {
        value2 = GetExpression();
    }
    else if (chcmd == 'w')
    {
        GetSymbolStdCall(Flat(addr1),
                         chAddrBuffer,
                         sizeof(chAddrBuffer),
                         &displacement,
                         NULL);

        if (displacement == 0 && chAddrBuffer[ 0 ] != '\0')
        {
            ADDR Addr2;
            g_Machine->GetRetAddr(&Addr2);
            value2 = Flat(Addr2);
            dprintf("Tracing %s to return address %s\n",
                    chAddrBuffer,
                    FormatAddr64(value2));
            if (g_WatchWhole)
            {
                g_WatchBeginCurFunc = value2;
                g_WatchEndCurFunc = 0;
            }
        }
    }

    if (((LONG)value2 <= 0) && (!g_WatchTrace))
    {
        error(SYNTAX);
    }
    
    fnStepTrace(&addr1,
                value2,  // count or watch end address
                pThread,
                fThreadFreeze,
                chcmd);
}

//
// Returns TRUE if the current step/trace should be passed over.
//
BOOL
StepTracePass(
    PADDR pcaddr
    )
{
    // If we have valid source line information and we're stepping
    // by source line, check and see if we moved from one line to another.
    if ((g_SrcOptions & SRCOPT_STEP_SOURCE) && g_SrcLineValid)
    {
        IMAGEHLP_LINE64 Line;
        DWORD Disp;

        Line.SizeOfStruct = sizeof(Line);
        if (SymGetLineFromAddr64(g_CurrentProcess->Handle,
                                 Flat(*pcaddr),
                                 &Disp,
                                 &Line))
        {
            if (Line.LineNumber == g_SrcLine.LineNumber)
            {
                // The common case is that we're still in the same line,
                // so check for a name match by pointer as a very quick
                // trivial accept.  If there's a mismatch we need to
                // do the hard comparison.

                if (Line.FileName == g_SrcLine.FileName ||
                    _strcmpi(Line.FileName, g_SrcLine.FileName) == 0)
                {
                    // We're still on the same line so don't treat
                    // this as motion.
                    return TRUE;
                }
            }

            // We've changed lines so we drop one from the pass count.
            // SrcLine also needs to be updated.
            g_SrcLine = Line;
        }
        else
        {
            // If we can't get line number information for the current
            // address we treat it as a transition on the theory that
            // it's better to stop than to skip interesting code.
            g_SrcLineValid = FALSE;
        }
    }

    if (--g_StepTracePassCount > 0)
    {
        if (!g_WatchFunctions.IsStarted())
        {
            // If the engine doesn't break for some other reason
            // on this intermediate step it should output the
            // step information to show the user the stepping
            // path.
            g_EngDefer |= ENG_DEFER_OUTPUT_CURRENT_INFO;
        }
        
        return TRUE;
    }

    return FALSE;
}

/*** fnStepTrace - step or trace the program
*
*   Purpose:
*       To continue execution of the program with a temporary
*       breakpoint set to stop after the next instruction
*       executed (trace - 't') or the instruction in the next
*       memory location (step - 'p').  The PC is also set
*       as well as a pass count variable.
*
*   Input:
*       addr - new value of PC
*       count - passcount for step or trace
*       pThread - thread pointer to qualify step/trace, NULL for all
*       chStepType - 't' for trace; 'p' for step
*
*   Output:
*       cmdState - set to 't' for trace; 'p' for step
*       g_StepTracePassCount - pass count for step/trace
*
*************************************************************************/

void
fnStepTrace (
    PADDR Addr,
    ULONG64 Count,
    PTHREAD_INFO Thread,
    BOOL ThreadFreeze,
    UCHAR StepType
    )
{
    // If we're stepping a particular thread it better
    // be the current context thread so that the machine
    // activity occurs on the appropriate thread.
    DBG_ASSERT(Thread == NULL || Thread == g_RegContextThread);

    if ((g_SrcOptions & SRCOPT_STEP_SOURCE) && fFlat(*Addr))
    {
        ULONG Disp;

        // Get the current line information so it's possible to
        // tell when the line changes.
        g_SrcLine.SizeOfStruct = sizeof(g_SrcLine);
        g_SrcLineValid = SymGetLineFromAddr64(g_CurrentProcess->Handle,
                                              Flat(*Addr),
                                              &Disp,
                                              &g_SrcLine);
    }

    g_Machine->SetPC(Addr);
    g_StepTracePassCount = (ULONG)Count;

    g_SelectedThread = Thread;
    g_SelectExecutionThread = ThreadFreeze ? SELTHREAD_THREAD : SELTHREAD_ANY;

    if (StepType == 'w')
    {
        ULONG NextMachine;
        
        g_Target->InitializeWatchTrace();
        g_WatchFunctions.Start();
        
        g_WatchTarget = *Addr;
        g_Machine->GetNextOffset(TRUE, &g_WatchTarget, &NextMachine);
        if ( Flat(g_WatchTarget) != OFFSET_TRACE || Count != 1)
        {
            if (IS_KERNEL_TARGET())
            {
                SetupSpecialCalls();
            }

            g_StepTracePassCount = 0xfffffff;
            if ( Count != 1 )
            {
                Flat(g_WatchTarget) = Count;
            }
        }
        
        StepType = 't';
    }

    g_CmdState = StepType;
    switch(StepType)
    {
    case 'b':
        g_ExecutionStatusRequest = DEBUG_STATUS_STEP_BRANCH;
        break;
    case 't':
        g_ExecutionStatusRequest = DEBUG_STATUS_STEP_INTO;
        break;
    case 'p':
    default:
        g_ExecutionStatusRequest = DEBUG_STATUS_STEP_OVER;
        break;
    }

    if (Thread)
    {
        g_StepTraceBp->m_Process = Thread->Process;
        g_StepTraceBp->m_MatchThread = Thread;
    }
    else
    {
        g_StepTraceBp->m_Process = g_CurrentProcess;
        g_StepTraceBp->m_MatchThread = g_CurrentProcess->CurrentThread;
    }
    if (StepType == 'b')
    {
        // Assume that taken branch trace is always performed by
        // hardware so set the g_StepTraceBp address to OFFSET_TRACE
        // (the value returned by GetNextOffset to signal the
        // hardware stepping mode).
        DBG_ASSERT(g_Machine->
                   IsStepStatusSupported(DEBUG_STATUS_STEP_BRANCH));
        ADDRFLAT(g_StepTraceBp->GetAddr(), OFFSET_TRACE);
    }
    else
    {
        ULONG NextMachine;
                
        g_Machine->GetNextOffset(g_CmdState == 'p',
                                 g_StepTraceBp->GetAddr(),
                                 &NextMachine);
        g_StepTraceBp->SetProcType(NextMachine);
    }
    GetCurrentMemoryOffsets(&g_StepTraceInRangeStart,
                            &g_StepTraceInRangeEnd);
    g_StepTraceBp->m_Flags |= DEBUG_BREAKPOINT_ENABLED;
    g_StepTraceCmdState = g_CmdState;
    
    g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
    NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                            g_ExecutionStatusRequest, TRUE);
}

/*** fnGoExecution - continue execution with temporary breakpoints
*
*   Purpose:
*       Function of the "[~[<thrd>]g[=<startaddr>][<bpaddr>]*" command.
*
*       Set the PC to startaddr.  Set the temporary breakpoints in
*       golist with the addresses pointed by *bparray and the count
*       in gocnt to bpcount.  Set cmdState to exit the command processor
*       and continue program execution.
*
*   Input:
*       startaddr - new starting address
*       bpcount - number of temporary breakpoints
*       pThread - thread pointer to qualify <bpaddr>, NULL for all
*       fThreadFreeze - TRUE if freezing all but pThread thread
*       bpaddr - pointer to array of temporary breakpoints
*
*   Output:
*       cmdState - set to continue execution
*
*************************************************************************/

void
fnGoExecution (
    ULONG ExecStatus,
    PADDR StartAddr,
    ULONG BpCount,
    PTHREAD_INFO Thread,
    BOOL ThreadFreeze,
    PADDR BpArray
    )
{
    ULONG Count;

    // If we're resuming a particular thread it better
    // be the current context thread so that the machine
    // activity occurs on the appropriate thread.
    DBG_ASSERT(Thread == NULL || Thread == g_RegContextThread);

    if (IS_CONTEXT_ACCESSIBLE())
    {
        g_Machine->SetPC(StartAddr);
    }

    // Remove old go breakpoints.
    for (Count = 0; Count < g_NumGoBreakpoints; Count++)
    {
        if (g_GoBreakpoints[Count] != NULL)
        {
            RemoveBreakpoint(g_GoBreakpoints[Count]);
            g_GoBreakpoints[Count] = NULL;
        }
    }
        
    DBG_ASSERT(BpCount <= MAX_GO_BPS);
    g_NumGoBreakpoints = BpCount;
        
    // Add new go breakpoints.
    for (Count = 0; Count < g_NumGoBreakpoints; Count++)
    {
        HRESULT Status;
            
        // First try to put the breakpoint at an ID up
        // and out of the way of user breakpoints.
        Status = AddBreakpoint(NULL, DEBUG_BREAKPOINT_CODE |
                               BREAKPOINT_HIDDEN, 10000 + Count,
                               &g_GoBreakpoints[Count]);
        if (Status != S_OK)
        {
            // That didn't work so try letting the engine
            // pick an ID.
            Status =
                AddBreakpoint(NULL, DEBUG_BREAKPOINT_CODE |
                              BREAKPOINT_HIDDEN, DEBUG_ANY_ID,
                              &g_GoBreakpoints[Count]);
        }
        if (Status != S_OK)
        {
            WarnOut("Temp bp at ");
            MaskOutAddr(DEBUG_OUTPUT_WARNING, BpArray);
            WarnOut("failed.\n");
        }
        else
        {
            // Matches must be allowed so that temporary breakpoints
            // don't interfere with permanent breakpoints.
            g_GoBreakpoints[Count]->SetAddr(BpArray,
                                            BREAKPOINT_ALLOW_MATCH);
            g_GoBreakpoints[Count]->m_Flags |=
                (DEBUG_BREAKPOINT_GO_ONLY |
                 DEBUG_BREAKPOINT_ENABLED);
        }

        BpArray++;
    }

    g_CmdState = 'g';
    if (Thread == NULL || Thread == g_StepTraceBp->m_MatchThread)
    {
        g_StepTraceBp->m_Flags &= ~DEBUG_BREAKPOINT_ENABLED;
    }
    g_ExecutionStatusRequest = ExecStatus;
    g_SelectExecutionThread = ThreadFreeze ? SELTHREAD_THREAD : SELTHREAD_ANY;
    g_SelectedThread = Thread;
    NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS, ExecStatus, TRUE);
}

/*** parseGoCmd - parse go command
*
*   Purpose:
*       Parse the go ("g") command.  Once parsed, call fnGoExecution
*       restart program execution.
*
*   Input:
*       pThread - nonNULL for breakpoint on specific thread
*       fThreadFreeze - TRUE if all threads except pThread are frozen
*       *g_CurCmd - pointer to operands in command string
*
*   Output:
*       None.
*
*   Exceptions:
*       error exit:
*               LISTSIZE - breakpoint address list too large
*
*************************************************************************/

void
parseGoCmd (
     PTHREAD_INFO pThread,
     BOOL fThreadFreeze
    )
{
    ULONG   count;
    ADDR    addr[MAX_GO_BPS];
    CHAR    ch;
    ADDR    pcaddr;
    CHAR    ch2;
    ULONG   ExecStatus;

    if (!IS_EXECUTION_POSSIBLE())
    {
        error(SESSIONNOTSUP);
    }

    if (IS_LIVE_USER_TARGET() &&
        (g_AllProcessFlags & ENG_PROC_EXAMINED))
    {
        ErrOut("The debugger is not attached so "
               "process execution cannot be monitored\n");
        return;
    }

    if (!IS_MACHINE_SET() || IS_RUNNING(g_CmdState))
    {
        ErrOut("Debuggee is busy, cannot go\n");
        return;
    }

    ExecStatus = DEBUG_STATUS_GO;
    ch = (CHAR)tolower(*g_CurCmd);
    if (ch == 'h' || ch == 'n')
    {
        ch2 = *(g_CurCmd + 1);
        if (ch2 == ' ' || ch2 == '\t' || ch2 == '\0')
        {
            g_CurCmd++;
            ExecStatus = ch == 'h' ? DEBUG_STATUS_GO_HANDLED :
                DEBUG_STATUS_GO_NOT_HANDLED;
        }
    }

    g_PrefixSymbols = TRUE;

    if (IS_CONTEXT_ACCESSIBLE())
    {
        g_Machine->GetPC(&pcaddr);       //  default to current PC
    }
    else
    {
        ZeroMemory(&pcaddr, sizeof(pcaddr));
    }
    
    if (PeekChar() == '=')
    {
        g_CurCmd++;
        GetAddrExpression(SEGREG_CODE, &pcaddr);
    }
    
    count = 0;
    while ((ch = PeekChar()) != '\0' && ch != ';')
    {
        ULONG AddrSpace, AddrFlags;

        if (count == DIMA(addr))
        {
            error(LISTSIZE);
        }
        
        GetAddrExpression(SEGREG_CODE, addr + (count++));
        
        if (g_Target->
            QueryAddressInformation(Flat(addr[count - 1]),
                                    DBGKD_QUERY_MEMORY_VIRTUAL,
                                    &AddrSpace, &AddrFlags) != S_OK)
        {
            ErrOut("Invalid breakpoint address\n");
            error(MEMORY);
        }

        if (AddrSpace == DBGKD_QUERY_MEMORY_SESSION ||
            !(AddrFlags & DBGKD_QUERY_MEMORY_WRITE) ||
            (AddrFlags & DBGKD_QUERY_MEMORY_FIXED))
        {
            ErrOut("Software breakpoints cannot be used on session code, "
                   "ROM code or other\nread-only memory. "
                   "Use hardware execution breakpoints (ba e) instead.\n");
            error(MEMORY);
        }            
    }

    g_PrefixSymbols = FALSE;
    
    if (IS_USER_TARGET())
    {
        g_LastCommand[0] = '\0';    //  null out g command
    }
    
    fnGoExecution(ExecStatus, &pcaddr, count, pThread, fThreadFreeze, addr);
}



VOID
SetupSpecialCalls(
    VOID
    )
{
    ULONG64 SpecialCalls[10];
    PULONG64 Call = SpecialCalls;

    g_SrcLineValid = FALSE;
    g_StepTracePassCount = 0xfffffffe;

    // Set the special calls (overkill, once per boot
    // would be enough, but this is easier).

    if (!GetOffsetFromSym("hal!KfLowerIrql", Call, NULL) &&
        !GetOffsetFromSym("hal!KeLowerIrql", Call, NULL))
    {
        dprintf( "Cannot find hal!KfLowerIrql/KeLowerIrql\n" );
    }
    else
    {
        Call++;
    }

    if (!GetOffsetFromSym("hal!KfReleaseSpinLock", Call, NULL) &&
        !GetOffsetFromSym("hal!KeReleaseSpinLock", Call, NULL))
    {
        dprintf( "Cannot find hal!KfReleaseSpinLock/KeReleaseSpinLock\n" );
    }
    else
    {
        Call++;
    }

#define GetSymWithErr(s)                      \
    if (!GetOffsetFromSym(s, Call, NULL))     \
    {                                         \
        dprintf("Cannot find " s "\n");       \
    }                                         \
    else                                      \
    {                                         \
        Call++;                               \
    }

    GetSymWithErr("hal!HalRequestSoftwareInterrupt");
    if (g_SystemVersion >= NT_SVER_W2K)
    {
        GetSymWithErr("hal!ExReleaseFastMutex");
        GetSymWithErr("hal!KeReleaseQueuedSpinLock");
        if (g_SystemVersion >= NT_SVER_W2K_WHISTLER)
        {
            GetSymWithErr("hal!KeReleaseInStackQueuedSpinLock");
        }
    }

    GetSymWithErr("nt!SwapContext");
    GetSymWithErr("nt!KiUnlockDispatcherDatabase");
    GetSymWithErr("nt!KiCallUserMode");

    DBG_ASSERT((ULONG)(Call - SpecialCalls) <=
               sizeof(SpecialCalls) / sizeof(SpecialCalls[0]));
    DbgKdSetSpecialCalls((ULONG)(Call - SpecialCalls), SpecialCalls);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\stepgo.hpp ===
//----------------------------------------------------------------------------
//
// Handles stepping, tracing, watching and go.
//
// Copyright (C) Microsoft Corporation, 1997-2000.
//
//----------------------------------------------------------------------------

#ifndef _STEPGO_HPP_
#define _STEPGO_HPP_

struct WatchFunction
{
    ULONG64 StartOffset;
    
    // Hash bucket list.
    WatchFunction* Next;
    // Sorted list.
    WatchFunction* Sort;
    
    ULONG Calls;
    ULONG MinInstr, MaxInstr, TotalInstr;
    // This counter is incremented every time a system call
    // instruction is hit inside the function.
    ULONG SystemCalls;
    // There's no strong need to make this symbol buffer
    // MAX_SYMBOL_LEN as the output only displays half a
    // line's worth of the name.  The only real reason to
    // keep more is to reduce false sharing due to prefix
    // matches.  The buffer is large enough that this should
    // be extremely rare, plus we keep the true length
    // as a further check.
    ULONG SymbolLength;
    CHAR Symbol[256];
};

struct WatchCallStack
{
    ADDR CallSite;
    WatchFunction* Func;
    WatchCallStack* Prev, *Next;
    LONG Level;
    ULONG InstrCount, ChildInstrCount;
};

//----------------------------------------------------------------------------
//
// WatchFunctions.
//
// Collects function information encountered during watch tracing.
//
//----------------------------------------------------------------------------

#define WF_BUCKETS 71

class WatchFunctions
{
public:
    WatchFunctions(void);
    
    void Start(void);
    void End(PADDR PcAddr);
    
    BOOL IsStarted(void)
    {
        return m_Started;
    }

    void OutputFunctions(void);
    void OutputSysCallFunctions(void);

    WatchFunction* FindAlways(PSTR Sym, ULONG64 Start);

    WatchCallStack* GetTopCall(void)
    {
        return m_CallTop;
    }
    WatchCallStack* PushCall(WatchFunction* Func);
    void            PopCall(void);
    WatchCallStack* PopCallsToCallSite(PADDR Pc);
    WatchCallStack* PopCallsToFunctionStart(ULONG64 Start);
    void            ReuseCall(WatchCallStack* Call,
                              WatchFunction* ReinitFunc);

    void OutputCall(WatchCallStack* Call);
    
    LONG GetCallLevel(void)
    {
        return m_CallLevel;
    }
    LONG ChangeCallLevel(LONG Delta)
    {
        m_CallLevel += Delta;
        if (m_CallLevel < 0)
        {
            m_CallLevel = 0;
        }
        return m_CallLevel;
    }

    ULONG RecordEvent(void)
    {
        return ++m_TotalWatchTraceEvents;
    }
    ULONG RecordThreadMismatch(void)
    {
        return ++m_TotalWatchThreadMismatches;
    }
    
protected:
    ULONG Hash(PSTR Sym, ULONG SymLen)
    {
        // Hash on the first and last letters of the symbol.
        return ((ULONG)(UCHAR)Sym[0] +
                (ULONG)(UCHAR)Sym[SymLen - 1]) % WF_BUCKETS;
    }

    WatchFunction* Add(PSTR Sym, ULONG64 Start);
    WatchFunction* Find(PSTR Sym);
    void           Clear(void);

    BOOL m_Started;

    ULONG m_TotalInstr;
    ULONG m_TotalWatchTraceEvents;
    ULONG m_TotalWatchThreadMismatches;

    WatchFunction* m_Funcs[WF_BUCKETS];
    WatchFunction* m_Sorted;

    WatchCallStack* m_CallTop, *m_CallBot;
    LONG m_CallLevel;
};

extern WatchFunctions g_WatchFunctions;

extern ULONG      g_StepTracePassCount;
extern ULONG64    g_StepTraceInRangeStart;
extern ULONG64    g_StepTraceInRangeEnd;

extern BOOL       g_SrcLineValid;

extern BOOL       g_WatchTrace;
extern BOOL       g_WatchWhole;
extern ADDR       g_WatchTarget;
extern ULONG64    g_WatchInitialSP;
extern ULONG64    g_WatchBeginCurFunc;
extern ULONG64    g_WatchEndCurFunc;

#define MAX_GO_BPS 16

extern Breakpoint* g_GoBreakpoints[MAX_GO_BPS];
extern ULONG g_NumGoBreakpoints;

BOOL StepTracePass(PADDR);

void
fnGoExecution (
    ULONG ExecStatus,
    PADDR startaddr,
    ULONG bpcount,
    PTHREAD_INFO pThread,
    BOOL fThreadFreeze,
    PADDR bparray
    );

void
fnStepTrace (
    PADDR addr,
    ULONG64 count,
    PTHREAD_INFO pThread,
    BOOL fThreadFreeze,
    UCHAR chStepType
    );

void
parseGoCmd (
    PTHREAD_INFO pThread,
    BOOL fThreadFreeze
    );

VOID
parseStepTrace (
    PTHREAD_INFO pThread,
    BOOL fThreadFreeze,
    UCHAR chcmd
    );

VOID SetupSpecialCalls(VOID);

#endif // #ifndef _STEPGO_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\stkwalk.cpp ===
//----------------------------------------------------------------------------
//
// Stack walking support.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

IMAGE_IA64_RUNTIME_FUNCTION_ENTRY g_EpcRfeBuffer;
PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY g_EpcRfe;

PFPO_DATA
SynthesizeKnownFpo(PSTR Symbol, ULONG64 OffStart, ULONG64 Disp)
{
    static ULONG64 s_Nr2, s_Lu2, s_Eh3, s_Kuit;

    if (!s_Nr2 || !s_Lu2 || !s_Eh3 || !s_Kuit)
    {
        GetOffsetFromSym("nt!_NLG_Return2", &s_Nr2, NULL);
        GetOffsetFromSym("nt!_local_unwind2", &s_Lu2, NULL);
        GetOffsetFromSym("nt!_except_handler3", &s_Eh3, NULL);
        GetOffsetFromSym("nt!KiUnexpectedInterruptTail", &s_Kuit, NULL);
    }
        
    if (OffStart == s_Nr2 || OffStart == s_Lu2)
    {
        static FPO_DATA s_Lu2Fpo;

        s_Lu2Fpo.ulOffStart = (ULONG)OffStart;
        s_Lu2Fpo.cbProcSize = 0x68;
        s_Lu2Fpo.cdwLocals  = 4;
        s_Lu2Fpo.cdwParams  = 0;
        s_Lu2Fpo.cbProlog   = 0;
        s_Lu2Fpo.cbRegs     = 3;
        s_Lu2Fpo.fHasSEH    = 0;
        s_Lu2Fpo.fUseBP     = 0;
        s_Lu2Fpo.reserved   = 0;
        s_Lu2Fpo.cbFrame    = FRAME_FPO;
        return &s_Lu2Fpo;
    }
    else if (OffStart == s_Eh3)
    {
        static FPO_DATA s_Eh3Fpo;

        s_Eh3Fpo.ulOffStart = (ULONG)OffStart;
        s_Eh3Fpo.cbProcSize = 0xbd;
        s_Eh3Fpo.cdwLocals  = 2;
        s_Eh3Fpo.cdwParams  = 4;
        s_Eh3Fpo.cbProlog   = 3;
        s_Eh3Fpo.cbRegs     = 4;
        s_Eh3Fpo.fHasSEH    = 0;
        s_Eh3Fpo.fUseBP     = 0;
        s_Eh3Fpo.reserved   = 0;
        s_Eh3Fpo.cbFrame    = FRAME_NONFPO;
        return &s_Eh3Fpo;
    }
    else if (OffStart == s_Kuit)
    {
        //
        // KiUnexpectedInterruptTail has three special stubs
        // following it for CommonDispatchException[0-2]Args.
        // These stubs set up for the appropriate number of
        // arguments and then call CommonDispatchException.
        // They do not have symbols or FPO data so fake some
        // up if we're in the region immediately after KUIT.
        //
        
        PFPO_DATA KuitData = (PFPO_DATA)
            SymFunctionTableAccess(g_CurrentProcess->Handle, OffStart);
        if (KuitData != NULL &&
            Disp >= (ULONG64)KuitData->cbProcSize &&
            Disp < (ULONG64)KuitData->cbProcSize + 0x20)
        {
            static FPO_DATA s_CdeStubFpo;
            
            s_CdeStubFpo.ulOffStart = (ULONG)OffStart;
            s_CdeStubFpo.cbProcSize = 0x10;
            s_CdeStubFpo.cdwLocals  = 0;
            s_CdeStubFpo.cdwParams  = 0;
            s_CdeStubFpo.cbProlog   = 0;
            s_CdeStubFpo.cbRegs     = 0;
            s_CdeStubFpo.fHasSEH    = 0;
            s_CdeStubFpo.fUseBP     = 0;
            s_CdeStubFpo.reserved   = 0;
            s_CdeStubFpo.cbFrame    = FRAME_TRAP;
            return &s_CdeStubFpo;
        }
    }

    return NULL;
}
    
PFPO_DATA
SynthesizeFpoDataForModule(DWORD64 PCAddr)
{
    DWORD64     Offset;
    USHORT      StdCallArgs;
    CHAR        symbuf[MAX_SYMBOL_LEN];

    GetSymbolStdCall( PCAddr,
                      symbuf,
                      sizeof(symbuf),
                      &Offset,
                      &StdCallArgs);

    if (Offset == PCAddr)
    {
        // No symbol.
        return NULL;
    }

    PFPO_DATA KnownFpo =
        SynthesizeKnownFpo(symbuf, PCAddr - Offset, Offset);
    if (KnownFpo != NULL)
    {
        return KnownFpo;
    }
    
    if (StdCallArgs == 0xffff)
    {
        return NULL;
    }

    static FPO_DATA s_SynthFpo;
    
    s_SynthFpo.ulOffStart = (ULONG)(PCAddr - Offset);
    s_SynthFpo.cbProcSize = (ULONG)(Offset + 10);
    s_SynthFpo.cdwLocals  = 0;
    s_SynthFpo.cdwParams  = StdCallArgs;
    s_SynthFpo.cbProlog   = 0;
    s_SynthFpo.cbRegs     = 0;
    s_SynthFpo.fHasSEH    = 0;
    s_SynthFpo.fUseBP     = 0;
    s_SynthFpo.reserved   = 0;
    s_SynthFpo.cbFrame    = FRAME_NONFPO;
    return &s_SynthFpo;
}

PFPO_DATA
SynthesizeFpoDataForFastSyscall(ULONG64 Offset)
{
    static FPO_DATA s_FastFpo;
    
    // XXX drewb - Temporary until the fake user-shared
    // module is worked out.
    
    s_FastFpo.ulOffStart = (ULONG)Offset;
    s_FastFpo.cbProcSize = X86_SHARED_SYSCALL_SIZE;
    s_FastFpo.cdwLocals  = 0;
    s_FastFpo.cdwParams  = 0;
    s_FastFpo.cbProlog   = 0;
    s_FastFpo.cbRegs     = 0;
    s_FastFpo.fHasSEH    = 0;
    s_FastFpo.fUseBP     = 0;
    s_FastFpo.reserved   = 0;
    s_FastFpo.cbFrame    = FRAME_FPO;
    return &s_FastFpo;
}    

PFPO_DATA
ModifyFpoRecord(PDEBUG_IMAGE_INFO Image, PFPO_DATA FpoData)
{
    if (FpoData->cdwLocals == 80)
    {
        static ULONG64 s_CommonDispatchException;

        // Some versions of CommonDispatchException have
        // the wrong locals size, which screws up stack
        // traces.  Detect and fix up these problems.
        if (s_CommonDispatchException == 0)
        {
            GetOffsetFromSym("nt!CommonDispatchException",
                             &s_CommonDispatchException,
                             NULL);
        }
                
        if (Image->BaseOfImage + FpoData->ulOffStart ==
            s_CommonDispatchException)
        {
            static FPO_DATA s_CdeFpo;
                    
            s_CdeFpo = *FpoData;
            s_CdeFpo.cdwLocals = 20;
            FpoData = &s_CdeFpo;
        }
    }
    else if (FpoData->cdwLocals == 0 && FpoData->cdwParams == 0 &&
             FpoData->cbRegs == 3)
    {
        static ULONG64 s_KiSwapThread;

        // KiSwapThread has shrink-wrapping so that three registers
        // are pushed in only a portion of the code.  Unfortunately,
        // the most important place in the code -- the call to
        // KiSwapContext -- is outside of this region and therefore
        // the register count is wrong much more often than it's
        // correct.  Switch the register count to two to make it
        // correct more often than wrong.
        if (s_KiSwapThread == 0)
        {
            GetOffsetFromSym("nt!KiSwapThread", &s_KiSwapThread, NULL);
        }

        if (Image->BaseOfImage + FpoData->ulOffStart ==
            s_KiSwapThread)
        {
            static FPO_DATA s_KstFpo;

            s_KstFpo = *FpoData;
            s_KstFpo.cbRegs = 2;
            FpoData = &s_KstFpo;
        }
    }
    else if (FpoData->fHasSEH)
    {
        static FPO_DATA s_SehFpo;

        s_SehFpo = *FpoData;
        s_SehFpo.cbFrame = FRAME_NONFPO;
        FpoData = &s_SehFpo;
    }

    return FpoData;
}

PFPO_DATA
FindFpoDataForModule(DWORD64 PCAddr)
/*++

Routine Description:

    Locates the fpo data structure in the process's linked list for the
    requested module.

Arguments:

    PCAddr        - address contained in the program counter

Return Value:

    null            - could not locate the entry
    valid address   - found the entry at the adress retured

--*/
{
    PPROCESS_INFO Process;
    PDEBUG_IMAGE_INFO Image;
    PFPO_DATA FpoData;

    Process = g_CurrentProcess;
    Image = Process->ImageHead;
    FpoData = 0;
    while (Image)
    {
        if ((PCAddr >= Image->BaseOfImage) &&
            (PCAddr < Image->BaseOfImage + Image->SizeOfImage))
        {
            FpoData = (PFPO_DATA)
                SymFunctionTableAccess(g_CurrentProcess->Handle, PCAddr);
            if (!FpoData)
            {
                FpoData = SynthesizeFpoDataForModule(PCAddr);
            }
            else
            {
                FpoData = ModifyFpoRecord(Image, FpoData);
            }
            
            return FpoData;
        }
        
        Image = Image->Next;
    }

    ULONG64 FscBase;
    
    switch(IsInFastSyscall(PCAddr, &FscBase))
    {
    case FSC_FOUND:
        return SynthesizeFpoDataForFastSyscall(FscBase);
    }
    
    // the function is not part of any known loaded image
    return NULL;
}

LPVOID
SwFunctionTableAccess(
    HANDLE  hProcess,
    ULONG64 AddrBase
    )
{
    static IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY s_Axp32;
    static IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY s_Axp64;
    static IMAGE_IA64_RUNTIME_FUNCTION_ENTRY s_Ia64;
    static _IMAGE_RUNTIME_FUNCTION_ENTRY s_Amd64;

    PVOID pife;

    if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
    {
        return (LPVOID)FindFpoDataForModule( AddrBase );
    }

    pife = SymFunctionTableAccess64(hProcess, AddrBase);

    switch (g_EffMachine)
    {
    case IMAGE_FILE_MACHINE_AXP64:
        if (!pife)
        {
            return NULL;
        }

        s_Axp64.BeginAddress =
            ((PIMAGE_FUNCTION_ENTRY64)pife)->StartingAddress;
        s_Axp64.EndAddress =
            ((PIMAGE_FUNCTION_ENTRY64)pife)->EndingAddress;
        s_Axp64.ExceptionHandler = 0;
        s_Axp64.HandlerData = 0;
        s_Axp64.PrologEndAddress =
            ((PIMAGE_FUNCTION_ENTRY64)pife)->EndOfPrologue;
        return &s_Axp64;

    case IMAGE_FILE_MACHINE_ALPHA:
        if (!pife)
        {
            return NULL;
        }

        s_Axp32.BeginAddress =
            ((PIMAGE_FUNCTION_ENTRY)pife)->StartingAddress;
        s_Axp32.EndAddress =
            ((PIMAGE_FUNCTION_ENTRY)pife)->EndingAddress;
        s_Axp32.ExceptionHandler = 0;
        s_Axp32.HandlerData = 0;
        s_Axp32.PrologEndAddress =
            ((PIMAGE_FUNCTION_ENTRY)pife)->EndOfPrologue;
        return &s_Axp32;

    case IMAGE_FILE_MACHINE_IA64:
        if (pife)
        {
            s_Ia64 = *(PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)pife;
            return &s_Ia64;
        }
        else
        {
            if (IS_KERNEL_TARGET() &&
                (AddrBase >= IA64_MM_EPC_VA) &&
                (AddrBase < (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
            {
                return g_EpcRfe;
            }
            else
            {
                return NULL;
            }
        }
        break;

    case IMAGE_FILE_MACHINE_AMD64:
        if (pife)
        {
            s_Amd64 = *(_PIMAGE_RUNTIME_FUNCTION_ENTRY)pife;
            return &s_Amd64;
        }
        break;
    }

    return NULL;
}

DWORD64
SwTranslateAddress(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddress
    )
{
    //
    // don't support 16bit stacks
    //
    return 0;
}


BOOL
SwReadMemory32(
    HANDLE hProcess,
    ULONG dwBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    return SwReadMemory(hProcess,
                        EXTEND64(dwBaseAddress),
                        lpBuffer,
                        nSize,
                        lpNumberOfBytesRead);
}

BOOL
SwReadMemory(
    HANDLE  hProcess,
    ULONG64 BaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    DBG_ASSERT(hProcess == g_CurrentProcess->Handle);

    if (IS_KERNEL_TARGET())
    {
        DWORD   BytesRead;
        HRESULT Status;

        if ((LONG_PTR)lpNumberOfBytesRead == -1)
        {
            if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386)
            {
                BaseAddress += g_TargetMachine->m_SizeTargetContext;
            }
    
            Status = g_Target->ReadControl(CURRENT_PROC,
                                           (ULONG)BaseAddress,
                                           lpBuffer,
                                           nSize,
                                           &BytesRead);
            return Status == S_OK;
        }
    }

    if (g_Target->ReadVirtual(BaseAddress, lpBuffer, nSize,
                              lpNumberOfBytesRead) != S_OK)
    {
        // Make sure bytes read is zero.
        if (lpNumberOfBytesRead != NULL)
        {
            *lpNumberOfBytesRead = 0;
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

DWORD64
SwGetModuleBase(
    HANDLE  hProcess,
    ULONG64 Address
    )
{
    PDEBUG_IMAGE_INFO Image = g_CurrentProcess->ImageHead;

    if (g_EffMachine == IMAGE_FILE_MACHINE_IA64 &&
        IS_KERNEL_TARGET() &&
        (Address >= IA64_MM_EPC_VA) &&
        (Address < (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
    {
        Address -= (IA64_MM_EPC_VA - g_SystemCallVirtualAddress);
    }

    while (Image)
    {
        if ((Address >= Image->BaseOfImage) &&
            (Address < (Image->BaseOfImage + Image->SizeOfImage)))
        {
            return Image->BaseOfImage;
        }
        Image = Image->Next;
    }

    // If no regular module was found we need to look in
    // the dynamic function tables to see if an entry
    // there matches.
    ULONG64 DynBase = g_Target->
        GetDynamicFunctionTableBase(g_Machine, Address);
    if (DynBase)
    {
        return DynBase;
    }
    
    if (IS_KERNEL_TARGET())
    {
        // If no modules have been loaded there's still a possibility
        // of getting a kernel stack trace (without symbols) by going
        // after the module base directly. This also makes it possible
        // to get a stack trace when there are no symbols available.

        if (g_CurrentProcess->ImageHead == NULL)
        {
            return GetKernelModuleBase( Address );
        }
    }

    return 0;
}

DWORD
SwGetModuleBase32(
    HANDLE hProcess,
    DWORD Address
    )
{
    return (DWORD)SwGetModuleBase(hProcess, Address);
}


void
PrintStackTraceHeaderLine(
   ULONG Flags
   )
{
    if ( (Flags & DEBUG_STACK_COLUMN_NAMES) == 0 )
    {
        return;
    }

    StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP);

    if (Flags & DEBUG_STACK_FRAME_NUMBERS)
    {
        dprintf(" # ");
    }
    
    if (Flags & DEBUG_STACK_FRAME_ADDRESSES)
    {
        g_Machine->PrintStackFrameAddressesTitle(Flags);
    }

    if (Flags & DEBUG_STACK_ARGUMENTS)
    {
        g_Machine->PrintStackArgumentsTitle(Flags);
    }

    g_Machine->PrintStackCallSiteTitle(Flags);

    dprintf("\n");
}

VOID
PrintStackFrame(
    PDEBUG_STACK_FRAME StackFrame,
    ULONG              Flags
    )
{
    DWORD64       displacement;
    CHAR          symbuf[MAX_SYMBOL_LEN];
    USHORT        StdCallArgs;
    ULONG64       InstructionOffset = StackFrame->InstructionOffset;

    if (g_EffMachine == IMAGE_FILE_MACHINE_IA64 &&
        IS_KERNEL_TARGET() &&
        (InstructionOffset >= IA64_MM_EPC_VA) &&
        (InstructionOffset < (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
    {
        InstructionOffset = InstructionOffset -
                            (IA64_MM_EPC_VA - g_SystemCallVirtualAddress);
    }

    GetSymbolStdCall(InstructionOffset,
                     symbuf,
                     sizeof(symbuf),
                     &displacement,
                     &StdCallArgs);

    
    StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP);

    if (Flags & DEBUG_STACK_FRAME_NUMBERS)
    {
        dprintf("%02lx ", StackFrame->FrameNumber);
    }

    if (Flags & DEBUG_STACK_FRAME_ADDRESSES)
    {
        g_Machine->PrintStackFrameAddresses(Flags, StackFrame);
    }
    
    if (Flags & DEBUG_STACK_ARGUMENTS)
    {
        g_Machine->PrintStackArguments(Flags, StackFrame);
    }

    g_Machine->PrintStackCallSite(Flags, StackFrame, 
                                  symbuf, displacement, 
                                  StdCallArgs);

    if (Flags & DEBUG_STACK_SOURCE_LINE)
    {
        OutputLineAddr(InstructionOffset, " [%s @ %d]");
    }

    dprintf( "\n" );
}

VOID
PrintStackTrace(
    ULONG              NumFrames,
    PDEBUG_STACK_FRAME StackFrames,
    ULONG              Flags
    )
{
    ULONG i;

    PrintStackTraceHeaderLine(Flags);

    for (i = 0; i < NumFrames; i++)
    {
        PrintStackFrame(StackFrames + i, Flags);
    }
}

void
GetStkTraceArgsForCurrentScope(
    PULONG64 FramePointer,
    PULONG64 StackPointer,
    PULONG64 InstructionPointer,
    PCROSS_PLATFORM_CONTEXT ContextCopyPointer
    )
{
    PCROSS_PLATFORM_CONTEXT ScopeContext = GetCurrentScopeContext();
    if (ScopeContext != NULL)
    {
        g_Machine->PushContext(ScopeContext);

        switch (g_EffMachine)
        { 
        case IMAGE_FILE_MACHINE_I386:
            if (*InstructionPointer == 0) 
            {
                *InstructionPointer = g_Machine->GetReg64(X86_EIP);
            }
            if (*StackPointer == 0) 
            {
                *StackPointer = g_Machine->GetReg64(X86_ESP);
            }
            if (*FramePointer == 0) 
            {
                *FramePointer = g_Machine->GetReg64(X86_EBP);
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:
            *InstructionPointer = g_Machine->GetReg64(STIIP);
            *StackPointer = g_Machine->GetReg64(INTSP);
            *FramePointer = g_Machine->GetReg64(RSBSP);
            break;

        case IMAGE_FILE_MACHINE_AXP64:
        case IMAGE_FILE_MACHINE_ALPHA:
            *InstructionPointer = g_Machine->GetReg64(ALPHA_FIR);
            *StackPointer = g_Machine->GetReg64(SP_REG);
            *FramePointer = g_Machine->GetReg64(FP_REG);
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            *InstructionPointer = g_Machine->GetReg64(AMD64_RIP);
            *StackPointer = g_Machine->GetReg64(AMD64_RSP);
            *FramePointer = g_Machine->GetReg64(AMD64_RBP);
            break;
            
        default:
            break;
        } 

        if (ContextCopyPointer) 
        {
            *ContextCopyPointer = g_Machine->m_Context;
        }
        g_Machine->PopContext();
    }
    else 
    {
        if (ContextCopyPointer) 
        {
            *ContextCopyPointer = g_Machine->m_Context;
        }
    }
}

DWORD
StackTrace(
    ULONG64            FramePointer,
    ULONG64            StackPointer,
    ULONG64            InstructionPointer,
    PDEBUG_STACK_FRAME StackFrames,
    ULONG              NumFrames,
    ULONG64            ExtThread,
    ULONG              Flags,
    BOOL               EstablishingScope
    )
{
    STACKFRAME64  VirtualFrame;
    DWORD         i;
    CROSS_PLATFORM_CONTEXT Context;
    PVOID FunctionEntry;
    ULONG64 Value;
    ULONG result;
    BOOL SymWarning = FALSE;
    ULONG X86Ebp;

    if (!EstablishingScope)
    {
        RequireCurrentScope();
    }
    
    //
    // let's start clean
    //
    ZeroMemory( StackFrames, sizeof(StackFrames[0]) * NumFrames );
    ZeroMemory( &VirtualFrame, sizeof(VirtualFrame) );

    if (g_Machine->GetContextState(MCTX_FULL) != S_OK)
    {
        return 0;
    }

    ULONG Seg;

    if ((!FramePointer && !InstructionPointer && !StackPointer) ||
        (g_EffMachine == IMAGE_FILE_MACHINE_I386))
    {
        // Do the default stack trace for current debug context
        // For x86, set these if any of them is 0
        GetStkTraceArgsForCurrentScope(&FramePointer, &StackPointer, 
                                       &InstructionPointer, &Context);
    }

    if (IS_KERNEL_TARGET())
    {
        //
        // if debugger was initialized at boot, usermode addresses needed for
        // stack traces on IA64 were not available.  Try it now:
        //

        if (g_EffMachine == IMAGE_FILE_MACHINE_IA64 &&
            !KdDebuggerData.KeUserCallbackDispatcher)
        {
            VerifyKernelBase (FALSE);
        }

        ULONG64 ThreadData;

        // If no explicit thread is given then we use the
        // current thread.  However, the current thread is only
        // valid if the current thread is the event thread since
        // tracing back into user mode requires that the appropriate
        // user-mode memory state be active.
        if (ExtThread != 0)
        {
            ThreadData = ExtThread;
        }
        else if (g_CurrentProcess->CurrentThread != g_EventThread ||
                 g_CurrentProcess != g_EventProcess ||
                 GetImplicitThreadData(&ThreadData) != S_OK)
        {
            ThreadData = 0;
        }

        VirtualFrame.KdHelp.Thread = ThreadData;
        VirtualFrame.KdHelp.ThCallbackStack = ThreadData ?
            KdDebuggerData.ThCallbackStack : 0;
        VirtualFrame.KdHelp.KiCallUserMode = KdDebuggerData.KiCallUserMode;
        VirtualFrame.KdHelp.NextCallback = KdDebuggerData.NextCallback;
        VirtualFrame.KdHelp.KeUserCallbackDispatcher =
            KdDebuggerData.KeUserCallbackDispatcher;
        VirtualFrame.KdHelp.FramePointer = KdDebuggerData.FramePointer;
        VirtualFrame.KdHelp.SystemRangeStart = g_SystemRangeStart;
    }
    
    //
    // setup the program counter
    //
    if (!InstructionPointer)
    {
        if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
        {
            ADDR Addr;

            VirtualFrame.AddrPC.Mode = AddrModeFlat;
            g_Machine->GetPC(&Addr);
            VirtualFrame.AddrPC.Segment = Addr.seg;
            VirtualFrame.AddrPC.Offset = Flat(Addr);
        }
    }
    else
    {
        VirtualFrame.AddrPC.Mode = AddrModeFlat;
        Seg = g_Machine->GetSegRegNum(SEGREG_CODE);
        VirtualFrame.AddrPC.Segment =
            Seg ? (WORD)GetRegVal32(Seg) : 0;
        VirtualFrame.AddrPC.Offset = InstructionPointer;
    }

    //
    // setup the frame pointer
    //
    if (!FramePointer)
    {
        if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
        {
            ADDR Addr;

            VirtualFrame.AddrFrame.Mode = AddrModeFlat;
            g_Machine->GetFP(&Addr);
            VirtualFrame.AddrFrame.Segment = Addr.seg;
            VirtualFrame.AddrFrame.Offset = Flat(Addr);
        }
    }
    else
    {
        VirtualFrame.AddrFrame.Mode = AddrModeFlat;
        Seg = g_Machine->GetSegRegNum(SEGREG_STACK);
        VirtualFrame.AddrFrame.Segment =
            Seg ? (WORD)GetRegVal32(Seg) : 0;
        VirtualFrame.AddrFrame.Offset = FramePointer;
    }
    VirtualFrame.AddrBStore = VirtualFrame.AddrFrame;
    if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
    {
        X86Ebp =  (ULONG) VirtualFrame.AddrFrame.Offset;
    }

    //
    // setup the stack pointer
    //
    if (!StackPointer)
    {
        if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
        {
            ADDR Addr;

            VirtualFrame.AddrStack.Mode = AddrModeFlat;
            g_Machine->GetSP(&Addr);
            VirtualFrame.AddrStack.Segment = Addr.seg;
            VirtualFrame.AddrStack.Offset = Flat(Addr);
        }
    }
    else
    {
        VirtualFrame.AddrStack.Mode = AddrModeFlat;
        Seg = g_Machine->GetSegRegNum(SEGREG_STACK);
        VirtualFrame.AddrStack.Segment =
            Seg ? (WORD)GetRegVal32(Seg) : 0;
        VirtualFrame.AddrStack.Offset = StackPointer;
    }

    if (g_EffMachine == IMAGE_FILE_MACHINE_IA64 &&
        IS_KERNEL_TARGET() &&
        g_SystemCallVirtualAddress)
    {
        PVOID functionEntry;
        ULONG numberOfBytesRead;

        functionEntry = SwFunctionTableAccess (g_CurrentProcess->Handle,
                                               g_SystemCallVirtualAddress);
        if (functionEntry != NULL)
        {
            RtlCopyMemory(&g_EpcRfeBuffer, functionEntry,
                          sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY));
            g_EpcRfe = &g_EpcRfeBuffer;
        }
        else
        {
            g_EpcRfe = NULL;
        }
    }

    for (i = 0; i < NumFrames; i++)
    {
        // SwReadMemory doesn't currently use the thread handle
        // but send in something reasonable in case of future changes.
        if (!StackWalk64(g_EffMachine,
                         g_CurrentProcess->Handle,
                         OS_HANDLE(g_CurrentProcess->CurrentThread->Handle),
                         &VirtualFrame,
                         &Context,
                         SwReadMemory,
                         SwFunctionTableAccess,
                         SwGetModuleBase,
                         SwTranslateAddress))
        {
            break;
        }

        StackFrames[i].InstructionOffset  = VirtualFrame.AddrPC.Offset;
        StackFrames[i].ReturnOffset       = VirtualFrame.AddrReturn.Offset;
        StackFrames[i].FrameOffset        = VirtualFrame.AddrFrame.Offset;
        StackFrames[i].StackOffset        = VirtualFrame.AddrStack.Offset;
        StackFrames[i].FuncTableEntry     = (ULONG64)VirtualFrame.FuncTableEntry;
        StackFrames[i].Virtual            = VirtualFrame.Virtual;
        StackFrames[i].FrameNumber        = i;

        // NOTE - we have more reserved space in the DEBUG_STACK_FRAME
        memcpy(StackFrames[i].Reserved, VirtualFrame.Reserved,
               sizeof(VirtualFrame.Reserved));
        memcpy(StackFrames[i].Params, VirtualFrame.Params,
               sizeof(VirtualFrame.Params));

        if (g_EffMachine == IMAGE_FILE_MACHINE_IA64 &&
            IS_KERNEL_TARGET())
        {
            if ((VirtualFrame.AddrPC.Offset >= IA64_MM_EPC_VA) &&
                (VirtualFrame.AddrPC.Offset <
                 (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
            {
                VirtualFrame.AddrPC.Offset -=
                    (IA64_MM_EPC_VA - g_SystemCallVirtualAddress);
            }

            if ((i != 0) &&
                (StackFrames[i - 1].InstructionOffset >= IA64_MM_EPC_VA) &&
                (VirtualFrame.AddrPC.Offset <
                 (IA64_MM_EPC_VA + IA64_PAGE_SIZE)))
            {
                StackFrames[i - 1].ReturnOffset =
                    VirtualFrame.AddrPC.Offset;
            }
        } else if (g_EffMachine == IMAGE_FILE_MACHINE_I386)
        {
            if (StackFrames[i].FuncTableEntry) 
            {
                PFPO_DATA FpoData = (PFPO_DATA)StackFrames[i].FuncTableEntry;
                if (FpoData->cbFrame == FRAME_FPO &&
                    !FpoData->fUseBP)
                {
                    SAVE_EBP(&StackFrames[i]) = (ULONG64) (LONG64) (LONG) X86Ebp;
                }

            }
            X86Ebp = Context.X86Context.Ebp;
        }


        if (Flags && i == 0)
        {
            PrintStackTraceHeaderLine(Flags);
        }

        IMAGEHLP_MODULE64 Mod;
        
        // If the current frame's PC is in a loaded module and
        // that module does not have symbols it's very possible
        // that the stack trace will be incorrect since the
        // debugger has to guess about how to unwind the stack.
        // Non-x86 architectures have unwind info in the images
        // themselves so restrict this check to x86.
        Mod.SizeOfStruct = sizeof(Mod);
        if (!SymWarning &&
            NumFrames > 1 &&
            g_EffMachine == IMAGE_FILE_MACHINE_I386 &&
            StackFrames[i].InstructionOffset != -1 &&
            SymGetModuleInfo64(g_CurrentProcess->Handle,
                               StackFrames[i].InstructionOffset, &Mod) &&
            (Mod.SymType == SymNone || Mod.SymType == SymExport ||
             Mod.SymType == SymDeferred))
        {
            WarnOut("WARNING: Stack unwind information not available. "
                    "Following frames may be wrong.\n");
            // Only show one warning per trace.
            SymWarning = TRUE;
        }
        
        if (Flags)
        {
            PrintStackFrame(StackFrames + i, Flags);
        
            if (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS)
            {
                g_Machine->PrintStackNonvolatileRegisters(Flags, 
                                                          StackFrames + i, 
                                                          &Context, i);
            }
        }
    }

    return i;

}

#define BASIC_STACK \
    (DEBUG_STACK_COLUMN_NAMES | DEBUG_STACK_FRAME_ADDRESSES | \
     DEBUG_STACK_SOURCE_LINE)

ULONG g_StackTraceTypeFlags[STACK_TRACE_TYPE_MAX] =
{
    BASIC_STACK,                                                      // Default
    BASIC_STACK | DEBUG_STACK_ARGUMENTS,                              // kb
    BASIC_STACK | DEBUG_STACK_ARGUMENTS | DEBUG_STACK_FUNCTION_INFO |
        DEBUG_STACK_NONVOLATILE_REGISTERS,                            // kv
    0,                                                                // kd
    BASIC_STACK | DEBUG_STACK_PARAMETERS,                             // kp
    BASIC_STACK | DEBUG_STACK_FRAME_NUMBERS,                          // kn
    BASIC_STACK | DEBUG_STACK_ARGUMENTS | DEBUG_STACK_FRAME_NUMBERS,  // kbn
    BASIC_STACK | DEBUG_STACK_ARGUMENTS | DEBUG_STACK_FUNCTION_INFO | 
        DEBUG_STACK_NONVOLATILE_REGISTERS | DEBUG_STACK_FRAME_NUMBERS,// kvn
    DEBUG_STACK_FRAME_NUMBERS,                                        // kdn
    BASIC_STACK | DEBUG_STACK_PARAMETERS | DEBUG_STACK_FRAME_NUMBERS  // kpn
};

VOID
DoStackTrace(
    ULONG64           FramePointer,
    ULONG64           StackPointer,
    ULONG64           InstructionPointer,
    ULONG             NumFrames,
    STACK_TRACE_TYPE  TraceType
    )
{
    PDEBUG_STACK_FRAME StackFrames;
    ULONG         NumFramesToRead;
    DWORD         FrameCount;

    if (NumFrames == 0)
    {
        NumFrames = g_DefaultStackTraceDepth;
    }

    if (TraceType == STACK_TRACE_TYPE_KD)
    {
        NumFramesToRead = 1;
    }
    else
    {
        NumFramesToRead = NumFrames;
    }

    StackFrames = (PDEBUG_STACK_FRAME)
        malloc( sizeof(StackFrames[0]) * NumFramesToRead );
    if (!StackFrames)
    {
        ErrOut( "could not allocate memory for stack trace\n" );
        return;
    }

    ULONG Flags = g_StackTraceTypeFlags[TraceType];

    if ((TraceType == STACK_TRACE_TYPE_KB) && g_Machine->m_Ptr64)
    {
        Flags |= DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY;
    }

    FrameCount = StackTrace( FramePointer,
                             StackPointer,
                             InstructionPointer,
                             StackFrames,
                             NumFramesToRead,
                             0,
                             Flags,
                             FALSE
                             );

    if (FrameCount == 0)
    {
        ErrOut( "could not fetch any stack frames\n" );
        free(StackFrames);
        return;
    }

    if (TraceType == STACK_TRACE_TYPE_KD)
    {
        // Starting with the stack pointer, dump NumFrames DWORD's
        // and the symbol if possible.

        ADDR startAddr;
        ADDRFLAT(&startAddr, StackFrames[0].FrameOffset);

        fnDumpDwordMemory(&startAddr, NumFrames, TRUE);
    }

    free( StackFrames );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\stkwalk.h ===
//----------------------------------------------------------------------------
//
// Stack walking support.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _STKWALK_H_
#define _STKWALK_H_

#define SAVE_EBP(f)        (f)->Reserved[0]
#define TRAP_TSS(f)        (f)->Reserved[1]
#define TRAP_EDITED(f)     (f)->Reserved[1]
#define SAVE_TRAP(f)       (f)->Reserved[2]


LPVOID
SwFunctionTableAccess(
    HANDLE  hProcess,
    ULONG64 AddrBase
    );

BOOL
SwReadMemory(
    HANDLE  hProcess,
    ULONG64 lpBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    );

BOOL
SwReadMemory32(
    HANDLE hProcess,
    ULONG dwBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead
    );

DWORD64
SwGetModuleBase(
    HANDLE  hProcess,
    ULONG64 Address
    );

DWORD
SwGetModuleBase32(
    HANDLE hProcess,
    DWORD Address
    );

VOID
DoStackTrace(
    ULONG64            FramePointer,
    ULONG64            StackPointer,
    ULONG64            InstructionPointer,
    ULONG              NumFrames,
    STACK_TRACE_TYPE   TraceType
    );

VOID
PrintStackFrame(
    PDEBUG_STACK_FRAME StackFrame,
    ULONG              Flags
    );

VOID
PrintStackTrace(
    ULONG              NumFrames,
    PDEBUG_STACK_FRAME StackFrames,
    ULONG              Flags
    );

DWORD
StackTrace(
    ULONG64            FramePointer,
    ULONG64            StackPointer,
    ULONG64            InstructionPointer,
    PDEBUG_STACK_FRAME StackFrames,
    ULONG              NumFrames,
    ULONG64            ExtThread,
    ULONG              Flags,
    BOOL               EstablishingScope
    );

#endif // #ifndef _STKWALK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\symtype.h ===
#ifndef SYMTYPE_H
#define SYMTYPE_H

#define NONE                     0x000000

#define NO_INDENT                DBG_DUMP_NO_INDENT
#define NO_OFFSET                DBG_DUMP_NO_OFFSET
#define VERBOSE                  DBG_DUMP_VERBOSE
#define CALL_FOR_EACH            DBG_DUMP_CALL_FOR_EACH
#define ARRAY_DUMP               DBG_DUMP_ARRAY
#define LIST_DUMP                DBG_DUMP_LIST
#define NO_PRINT                 DBG_DUMP_NO_PRINT
#define GET_SIZE_ONLY            DBG_DUMP_GET_SIZE_ONLY
#define RECURSIVE1               0x000100
#define RECURSIVE2               0x000200
#define RECURSIVE3               0x000400
#define RECURS_DEF               0x000800
#define RECURSIVE        (RECURSIVE3 | RECURSIVE2 | RECURSIVE1 | RECURS_DEF)


// Dump and callback optons for fields
#define CALL_BEFORE_PRINT        DBG_DUMP_FIELD_CALL_BEFORE_PRINT
#define NO_CALLBACK_REQ          DBG_DUMP_FIELD_NO_CALLBACK_REQ
#define RECUR_ON_THIS            DBG_DUMP_FIELD_RECUR_ON_THIS
#define COPY_FIELD_DATA          DBG_DUMP_FIELD_COPY_FIELD_DATA
#define FIELD_ARRAY_DUMP         DBG_DUMP_FIELD_ARRAY
#define DBG_DUMP_FIELD_STRING    (DBG_DUMP_FIELD_DEFAULT_STRING | DBG_DUMP_FIELD_WCHAR_STRING | DBG_DUMP_FIELD_MULTI_STRING | DBG_DUMP_FIELD_GUID_STRING)

#ifdef DBG_RETURN_TYPE
#undef DBG_RETURN_TYPE
#undef DBG_RETURN_SUBTYPES
#undef DBG_RETURN_TYPE_VALUES
#endif

//
// Return the name and type data for this symbol
//
#define DBG_RETURN_TYPE                   0x00000010
//
// Return the sub-type list for the type data
//
#define DBG_RETURN_SUBTYPES               0x00001000
//
// Get the Values for this type data
//
#define DBG_RETURN_TYPE_VALUES            0x00004000


#define MAX_NAME                 2048
#define MAX_STRUCT_DUMP_SIZE     256

#define SYM_IS_VARIABLE          0x1000

//
// Structure to store the information about most recently referred types.
//   Going through module list for type search takes time, so maintain a "cache"
//   of types.
//
typedef struct _TYPES_INFO {
    ANSI_STRING Name;          // Name of struct stored
    CHAR    ModName[30];       // Name of module (optional)
    ULONG   TypeIndex;         // Type index in module's pdb file
    HANDLE  hProcess;          // Handle of process to access the module
    ULONG64 ModBaseAddress;    // Base address of te module
    ULONG64 SymAddress;        // Address in case of a gvar / local
    ULONG   Referenced;        // Time since previous reference
    ULONG64 Value;             // Value of symbol, if its a constant
    ULONG   Flag;              // IMAGEHLP_SYMBOL_INFO* flags
} TYPES_INFO, *PTYPES_INFO;

typedef struct _TYPES_INFO_ALL {
    ANSI_STRING Name;
    ULONG   TypeIndex;
    HANDLE  hProcess;
    ULONG64 Module;
    ULONG   Size;
    ULONG64 Offset;
    ULONG64 Address;
    ULONG   Register;
    ULONG64 Value;
    ULONG   Flags;
    ULONG   SubElements;
    ULONG64 SubAddr;
} TYPES_INFO_ALL, *PTYPES_INFO_ALL;

typedef struct _FIND_TYPE_INFO {
    ULONG Flags;
    ULONG nParams;
    CHAR  SymPrefix[8]; // may contain &,* for pointers
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL InternalParams;
    TYPES_INFO_ALL FullInfo;
    ULONG64 ParentExpandAddress; // Valid if DBG_RETURN_SUBTYPES flag is used
} FIND_TYPE_INFO, *PFIND_TYPE_INFO;

#define MAX_TYPES_STORED       20
#define MINIMUM_BUFFER_LENGTH  40
#define DEBUG_LOCALS_MASK      (SYMF_REGISTER | SYMF_FRAMEREL | SYMF_REGREL)

typedef struct _ALT_FIELD_INFO {
    struct {
        ULONG       ReferAltInfo:1;
        ULONG       Matched:1;
        ULONG       InPtrReference:1;
        ULONG       ArrayElement:1;
        ULONG       Reserved:26;
    } FieldType;
    ULONG           ArrayElements;
} ALT_FIELD_INFO, *PALT_FIELD_INFO;

//
// Struct to keep list of parents as we go inside a structure/union during dump
//
typedef struct _TYPE_NAME_LIST {
   ULONG Type;
   LPSTR Name;
   struct _TYPE_NAME_LIST *Next;
} TYPE_NAME_LIST, *PTYPE_NAME_LIST;


typedef struct _TYPE_DUMP_INTERNAL {
   HANDLE     hProcess;         // Handle to get module information
   ULONG64    modBaseAddr;      // Module which contains symbol info


   USHORT     nElements;        // Maximum nubler of elements to dump in list
   ULONG64    NextListElement;  // This is used to store the next list elements address
   ULONG64    LastListElement;  // When we are dumping _LIST_ENTRY type, this specifies the end

   USHORT     arrElements;       // Maximum elements to dump With Array

   //
   // Stores index+1 of array element to dump.
   //
   ULONG      ArrayElementToDump;

   USHORT     StringSize;        // To get the size of string to dump

   // If we are in field1.field2, this is Offset of field1 + Offset of field2
   ULONG64    totalOffset;
   ULONG      BaseClassOffsets;

   //
   // If we are reading in data, copy it into buffer if following are set.
   // TypeDataPointer is updated to point to next location to be copied
   //
   BOOL       CopyDataInBuffer;
   PUCHAR     TypeDataPointer;

   // Tells whether to write from 0th bit or the bit's actual position, when copying bit-fields
   ULONG      BitIndex;

   ULONG      TypeOptions;
   USHORT     level;
   ULONG      FieldOptions;

   PTYPE_NAME_LIST ParentTypes;  // Stores list of all parent type names
   PTYPE_NAME_LIST ParentFields; // Stores list of all parent field names

   ULONG      rootTypeIndex;
   ULONG      typeSize;

   //
   // PtrRead becomes true just after reading the pointer
   //
   BOOL       PtrRead;

   //
   // A field may be processessed if it can be parent of some field specified
   // in Fields array. In that case InUnlistedField becomes true.
   //
   BOOL       InUnlistedField;

   //
   // Error values are set here if the Type dump call fails
   //
   ULONG      ErrorStatus;

   //
   // Memory read error at this
   //
   ULONG64    InvalidAddress;

   //
   // Tells we are in field Sym->Fields[FieldIndex]
   //
   ULONG      FieldIndex;

   ULONG      fieldNameLen;
   //
   // An array to keep track of fields internally
   //
   PALT_FIELD_INFO AltFields;

   ULONG      newLinePrinted;

   //
   // For type information of symbols
   //
   PDEBUG_SYMBOL_PARAMETERS_INTERNAL pSymParams;
   PFIND_TYPE_INFO pInfoFound;

   ULONG      FillTypeInfo:1;
   ULONG      CopyName:1;
   ULONG      RefFromPtr:1;
   ULONG      CopyDataForParent:1;
   ULONG      InBaseClass:1;
   ULONG      BitFieldRead:1;
   ULONG      DeReferencePtr:1;
   ULONG      IsAVar:1;             // Symbol is a variable (as opposed to type)
   ULONG      ValuePresent:1;       // True for constants or when value is read from registers
   ULONG      IsEnumVal:1;
   ULONG      Reserved:23;

   ULONG      NumSymParams;
   ULONG      CurrentSymParam;


   ULONG      BitFieldSize;
   ULONG      BitFieldOffset;

   ULONG64    Value;
   TYPES_INFO  LastType;
   PCHAR      Prefix;
} TYPE_DUMP_INTERNAL, *PTYPE_DUMP_INTERNAL;


typedef enum _DBG_TYPES {
    DBG_TYP_UNKNOWN = 0,
    DBG_TYP_POINTER,
    DBG_TYP_NUMBER,      // for int, char, short, int64
    DBG_TYP_BIT,
    DBG_TYP_STRUCT,      // for structs, class, union
    DBG_TYP_ARRAY,
} DBG_TYPES;

typedef
ULONG
(WDBGAPI*PSYM_DUMP_FIELD_CALLBACK_EX)(
    struct _FIELD_INFO_EX *pField,
    PVOID UserContext
    );

typedef struct _FIELD_INFO_EX {
   PUCHAR       fName;          // Name of the field
   PUCHAR       printName;      // Name to be printed at dump
   ULONG        size;           // Size of the field
   ULONG        fOptions;       // Dump Options for the field
   ULONG64      address;        // address of the field
   union {
       PVOID    fieldCallBack;  // Return info or callBack routine for the field
       PVOID    pBuffer;        // the type data is copied into this
   };
   DBG_TYPES    fType;
   ULONG        fOffset;
   ULONG        BufferSize;    
   struct _BitField {
       USHORT Position;
       USHORT Size;
   } BitField;
} FIELD_INFO_EX, *PFIELD_INFO_EX;

typedef struct _SYM_DUMP_PARAM_EX {
   ULONG               size;          // size of this struct
   PUCHAR              sName;         // type name
   ULONG               Options;       // Dump options
   ULONG64             addr;          // Address to take data for type
   PFIELD_INFO_EX      listLink;      // fName here would be used to do list dump
   union {
       PVOID           Context;       // Usercontext passed to CallbackRoutine
       PVOID           pBuffer;       // the type data is copied into this
   };
   PSYM_DUMP_FIELD_CALLBACK_EX CallbackRoutine;
                                      // Routine called back
   ULONG               nFields;       // # elements in Fields
   PFIELD_INFO_EX      Fields;        // Used to return information about field
   DBG_TYPES           Type;
   ULONG               TypeSize;
   ULONG               BufferSize;    
} SYM_DUMP_PARAM_EX, *PSYM_DUMP_PARAM_EX;

typedef SYM_DUMP_PARAM_EX FAST_DUMP_INFO, *PFAST_DUMP_INFO;

class ReferencedSymbolList {
public:
    ReferencedSymbolList() {
        ZeroMemory(&m_ReferencedTypes, sizeof(m_ReferencedTypes));
    };
    ULONG StoreTypeInfo(PTYPES_INFO pInfo);
    ULONG LookupType(PCHAR Name, PCHAR Module, BOOL CompleteName);
    VOID  ClearStoredSymbols (ULONG64 ModBase);
    VOID  EnsureValidLocals (void);
    PTYPES_INFO GetStoredIndex(ULONG Index) {
        if (Index < MAX_TYPES_STORED)
        return &m_ReferencedTypes[Index];
        else return NULL;
        };

private:

    // FP & IP for scope of locals list
    ULONG64 m_FP;
    ULONG64 m_RO;
    ULONG64 m_IP;
    ULONG   m_ListSize;
    TYPES_INFO m_ReferencedTypes[MAX_TYPES_STORED];
};


//------------------------------------------------------------------------------

//
// This has any specail/native type which debugger wants to dump in specific way
//
typedef struct _DBG_NATIVE_TYPE {
    PCHAR TypeName;
    ULONG TypeId;
    ULONG Size;
} DBG_NATIVE_TYPE, *PDBG_NATIVE_TYPE;


//
// Tyopes defined in debugger (not in pdb) to allow typecasts like
//     CHAR **, ULONG[2],
//
#define DBG_DE_POINTER_ID             0x80000001
#define DBG_DE_ARRAY_ID               0x80000002
#define DBG_DE_ADDROF_ID              0x80000003

// Generic type
typedef struct DBG_DE_TYPE {
    ULONG TypeId;
    ULONG ChildId;
    ULONG NumChilds;
    ULONG StartIndex;   // Index of start char for this derived type in the main type name
    ULONG Namelength;   // Length of this derived type name
    PVOID pNext;        // Easy reference to next special type if ChildId is a special type
} DBG_DE_TYPE, *PDBG_DE_TYPE;


class DbgTypes {
public:
    DbgTypes(PTYPE_DUMP_INTERNAL pInternalDumpInfo,
             PTYPES_INFO         pTypeInfo,
             PSYM_DUMP_PARAM_EX  pExternalDumpInfo);
    ~DbgTypes() {};

    ULONG64 GetAddress(void) {
        return m_pDumpInfo->addr ? 
            (m_pDumpInfo->addr + m_pInternalInfo->totalOffset +
              m_pInternalInfo->BaseClassOffsets)  : 0;
    };

    ULONG ProcessType(ULONG TypeIndex);

    ULONG ProcessVariant(
        IN VARIANT var,
        IN LPSTR   name
    );

    BOOL CheckAndPrintStringType(
        IN ULONG TI,
        IN ULONG Size
    );

    ULONG ProcessBaseType(
        IN ULONG TypeIndex,
        IN ULONG TI,
        IN ULONG Size
        );

    ULONG ProcessPointerType(
        IN ULONG TI,
        IN ULONG ChildTI,
        IN ULONG Size
        );

    ULONG ProcessBitFieldType(
        IN ULONG               TI,
        IN ULONG               ParentTI,
        IN ULONG               length,
        IN ULONG               position
        );

    ULONG ProcessDataMemberType(
        IN ULONG               TI,
        IN ULONG               ChildTI,
        IN LPSTR               name,
        IN BOOL                bStatic
        );

    ULONG ProcessUDType(
        IN ULONG               TI,
        IN LPSTR               name
        );

    ULONG ProcessEnumerate(
        IN VARIANT             var,
        IN LPSTR               name
        );

    ULONG ProcessEnumType(
        IN ULONG               TI,
        IN LPSTR               name
        );

    ULONG ProcessArrayType(
        IN ULONG               TI,
        IN ULONG               eltTI,
        IN ULONG               count,
        IN ULONGLONG           size,
        IN LPSTR               name
        );

    ULONG ProcessVTShapeType(
        IN ULONG               TI,
        IN ULONG               count
        );

    ULONG ProcessVTableType(
        IN ULONG               TI,
        IN ULONG               ChildTI
          );

    ULONG ProcessBaseClassType(
        IN ULONG               TI,
        IN ULONG               ChildTI
        );

    ULONG ProcessFunction(
        IN ULONG               TI,
        IN ULONG               ChildTI,
        IN LPSTR               name
        );

    ULONG ProcessFunctionType(
        IN ULONG               TI,
        IN ULONG               ChildTI
        );

    ULONG ProcessFunctionArgType(
        IN ULONG               TI,
        IN ULONG               ChildTI
    );

    ULONG MatchField(
        LPSTR               fName,
        PTYPE_DUMP_INTERNAL m_pInternalInfo,
        PFIELD_INFO_EX      fields,
        ULONG               nFields,
        PULONG              ParentOfField
        );
    void CopyDumpInfo(
        ULONG Size
        );
    BOOL DumpKnownStructFormat(
        PCHAR Name
        );

    ULONG64 GetDumpAddress() {
        return m_AddrPresent ? (m_pInternalInfo->totalOffset +
                                m_pDumpInfo->addr) :
            0;
    }
    /*
    ULONG ReadTypeData (
        PUCHAR   des,
        ULONG64  src,
        ULONG    count,
        ULONG    Option
        );
    ULONG ReadInAdvance(
        ULONG64 addr,
        ULONG size,
        ULONG Options);
*/
    ULONG               m_typeIndex;
    ULONG               m_Options;
    PTYPE_DUMP_INTERNAL m_pInternalInfo;
    PSYM_DUMP_PARAM_EX  m_pDumpInfo;
    ULONG               m_ParentTag;
    ULONG               m_SymTag;
    PCHAR               m_pNextSym;
    PCHAR               m_pSymPrefix;

private:
    BOOL                m_AddrPresent;
    BOOL                m_thisPointerDump; // TRUE if DumpType is called on local var 'this'
    TYPES_INFO          m_TypeInfo;
    TYPE_DUMP_INTERNAL  m_InternalInfo;
    SYM_DUMP_PARAM_EX      m_ExtDumpInfo;
};

class DbgDerivedType : public DbgTypes {
public:
    DbgDerivedType(
        PTYPE_DUMP_INTERNAL pInternalDumpInfo,
        PTYPES_INFO         pTypeInfo,
        PSYM_DUMP_PARAM_EX     pExternalDumpInfo);
    ~DbgDerivedType() { 
        if (m_SpTypes) { 
            while (m_SpTypes->pNext) m_SpTypes = (DBG_DE_TYPE *) m_SpTypes->pNext; 
            free (m_SpTypes);
        }
        }

    ULONG DumpType();

    HRESULT GetSpecialTypes(
        IN PCHAR TypeName,
        IN ULONG TypeIndex,
        OUT DBG_DE_TYPE **pSpTypeOut
        );

    ULONG DumpSilgleDimArray(
        IN ULONG               NumElts,
        IN ULONG               ElementType
    );

    ULONG DumpPointer(
        IN ULONG               ptrSize,
        IN ULONG               ChildIndex,
        IN DBG_DE_TYPE        *pPtrType
        );

    ULONG DumpAddressOf(
        ULONG               ptrSize,
        ULONG               ChildIndex
        );

    ULONG GetTypeSize();

private:
    DBG_DE_TYPE        *m_SpTypes;
};


//------------------------------------------------------------------------------

BOOL
ParseArgumentString (
   IN LPSTR lpArgumentString,
   OUT PSYM_DUMP_PARAM_EX dp);

VOID
ClearStoredTypes (
    ULONG64 ModBase
    );

ULONG
DumpType(
    PTYPES_INFO     pTypeInfo,
    PSYM_DUMP_PARAM_EX pSym,
    PULONG          pStatus
    );

ULONG
TypeInfoFound(
    IN HANDLE hProcess,
    IN PDEBUG_IMAGE_INFO pImage,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO pTypeInfo
    );

ULONG
SymbolTypeDump(
   IN HANDLE hProcess,
   IN PDEBUG_IMAGE_INFO pImage,
   IN OUT PSYM_DUMP_PARAM pSym,
   OUT PULONG pStatus
   );

ULONG
SymbolTypeDumpNew(
    IN OUT PSYM_DUMP_PARAM_EX pSym,
    OUT PULONG pStatus
    );

ULONG
SymbolTypeDumpEx(
   IN HANDLE hProcess,
   IN PDEBUG_IMAGE_INFO pImage,
   IN LPSTR lpArgString);

ULONG
DumpSingleValue (
    PSYMBOL_INFO pSymInfo
    );

HRESULT
GetTypeName(
    IN OPTIONAL PCHAR       pSymName,
    IN OPTIONAL PTYPES_INFO pTypeInfo,
    OUT PANSI_STRING        TypeName
    );

ULONG
fnFieldOffset(
    PCHAR Type,
    PCHAR Field,
    OUT PULONG Offset
    );

HRESULT
GetNameFromIndex(
    PTYPES_INFO pTypeInfo,
    PCHAR       Name,
    PUSHORT     NameLen
    );

ULONG
DumpTypeAndReturnInfo(
    PTYPES_INFO     pTypeInfo,
    PSYM_DUMP_PARAM_EX pSym,
    PULONG          pStatus,
    PFIND_TYPE_INFO pReturnTypeInfo
    );


BOOL
GetExpressionTypeInfo(
    IN PCHAR TypeExpr,
    OUT PTYPES_INFO_ALL pTypeInfo
    );

void 
PrintParamValue(ULONG Param);

BOOL
ShowSymbolInfo(
    PSYMBOL_INFO   pSymInfo
    );

BOOL 
IsFunctionSymbol(
    PSYMBOL_INFO pSymInfo
    );

extern BOOL    g_EnableUnicode;
extern ULONG   g_TypeOptions;

#endif // SYMTYPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\target.hpp ===
//----------------------------------------------------------------------------
//
// Abstraction of target-specific information.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __TARGET_HPP__
#define __TARGET_HPP__

extern DBGKD_GET_VERSION64 g_KdVersion;

HRESULT EmulateNtSelDescriptor(class MachineInfo* Machine,
                               ULONG Selector, PDESCRIPTOR64 Desc);
    
ULONG NtBuildToSystemVersion(ULONG Build);
ULONG Win9xBuildToSystemVersion(ULONG Build);
void SetTargetSystemVersionAndBuild(ULONG Build, ULONG PlatformId);
PCSTR SystemVersionName(ULONG Sver);

BOOL
GetUserModuleListAddress(
    MachineInfo* Machine,
    ULONG64 Peb,
    BOOL Quiet,
    PULONG64 OrderModuleListStart,
    PULONG64 FirstEntry
    );

BOOL
GetModNameFromLoaderList(
    MachineInfo* Machine,
    ULONG64 Peb,
    ULONG64 ModuleBase,
    PSTR NameBuffer,
    ULONG BufferSize,
    BOOL FullPath
    );

void InitSelCache(void);

void
ConvertLoaderEntry32To64(
    PKLDR_DATA_TABLE_ENTRY32 b32,
    PKLDR_DATA_TABLE_ENTRY64 b64
    );

void SetTargetNtCsdVersion(ULONG CsdVersion);

//----------------------------------------------------------------------------
//
// Module list abstraction.
//
//----------------------------------------------------------------------------

// If the image header is paged out the true values for
// certain fields cannot be retrieved.  These placeholders
// are used instead.
#define UNKNOWN_CHECKSUM 0xffffffff
#define UNKNOWN_TIMESTAMP 0xfffffffe

typedef struct _MODULE_INFO_ENTRY
{
    // NamePtr should include a path if one is available.
    // It is the responsibility of callers to find the
    // file tail if that's all they care about.
    // If UnicodeNamePtr is false NameLength is ignored.
    PSTR NamePtr;
    ULONG UnicodeNamePtr:1;
    ULONG ImageInfoValid:1;
    ULONG ImageInfoPartial:1;
    ULONG ImageDebugHeader:1;
    ULONG Unused:28;
    // Length in bytes not including the terminator.
    ULONG NameLength;
    PSTR ModuleName;
    HANDLE File;
    ULONG64 Base;
    ULONG Size;
    ULONG SizeOfCode;
    ULONG SizeOfData;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    PVOID DebugHeader;
    ULONG SizeOfDebugHeader;
    CHAR Buffer[MAX_IMAGE_PATH * sizeof(WCHAR)];
} MODULE_INFO_ENTRY, *PMODULE_INFO_ENTRY;

class ModuleInfo
{
public:
    virtual HRESULT Initialize(void) = 0;
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry) = 0;
    // Base implementation does nothing.

    // Updates the entry image info by reading the
    // image header.
    void ReadImageHeaderInfo(PMODULE_INFO_ENTRY Entry);
};

class NtModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

protected:
    MachineInfo* m_Machine;
    ULONG64 m_Head;
    ULONG64 m_Cur;
};

class NtKernelModuleInfo : public NtModuleInfo
{
public:
    virtual HRESULT Initialize(void);
};

extern NtKernelModuleInfo g_NtKernelModuleIterator;

class NtUserModuleInfo : public NtModuleInfo
{
public:
    virtual HRESULT Initialize(void);

protected:
    ULONG64 m_Peb;
};

class NtTargetUserModuleInfo : public NtUserModuleInfo
{
public:
    virtual HRESULT Initialize(void);
};

extern NtTargetUserModuleInfo g_NtTargetUserModuleIterator;

class NtWow64UserModuleInfo : public NtUserModuleInfo
{
public:
    virtual HRESULT Initialize(void);

private:
    HRESULT GetPeb32(PULONG64 Peb32);
};

extern NtWow64UserModuleInfo g_NtWow64UserModuleIterator;

class DebuggerModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(void);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    PDEBUG_IMAGE_INFO m_Image;
};

extern DebuggerModuleInfo g_DebuggerModuleIterator;

class UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(void) = 0;
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params) = 0;
};

class NtKernelUnloadedModuleInfo : public UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(void);
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params);

protected:
    ULONG64 m_Base;
    ULONG m_Index;
    ULONG m_Count;
};

extern NtKernelUnloadedModuleInfo g_NtKernelUnloadedModuleIterator;

class W9xModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(void);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

protected:
    HANDLE m_Snap;
    BOOL m_First;
    ULONG m_LastId;
};

extern W9xModuleInfo g_W9xModuleIterator;

//----------------------------------------------------------------------------
//
// Target configuration information.
//
//----------------------------------------------------------------------------

#define IS_TARGET_SET() (g_TargetClass != DEBUG_CLASS_UNINITIALIZED)

#define IS_KERNEL_TARGET() (g_TargetClass == DEBUG_CLASS_KERNEL)
#define IS_USER_TARGET() (g_TargetClass == DEBUG_CLASS_USER_WINDOWS)

#define IS_CONN_KERNEL_TARGET() \
    (IS_KERNEL_TARGET() && g_TargetClassQualifier == DEBUG_KERNEL_CONNECTION)

#define IS_LOCAL_KERNEL_TARGET() \
    (IS_KERNEL_TARGET() && g_TargetClassQualifier == DEBUG_KERNEL_LOCAL)

#define IS_EXDI_KERNEL_TARGET() \
    (IS_KERNEL_TARGET() && g_TargetClassQualifier == DEBUG_KERNEL_EXDI_DRIVER)

#define IS_LIVE_USER_TARGET() \
    (IS_USER_TARGET() && !IS_DUMP_TARGET())

#define IS_LIVE_KERNEL_TARGET() \
    (IS_KERNEL_TARGET() && !IS_DUMP_TARGET())

#define IS_REMOTE_USER_TARGET() \
    (IS_USER_TARGET() && \
     g_TargetClassQualifier == DEBUG_USER_WINDOWS_PROCESS_SERVER)

#define IS_LOCAL_USER_TARGET() \
    (IS_USER_TARGET() && \
     g_TargetClassQualifier != DEBUG_USER_WINDOWS_PROCESS_SERVER)

// Local kernels do not need caching.  Anything else does.
#define IS_REMOTE_KERNEL_TARGET() \
    (IS_LIVE_KERNEL_TARGET() && g_TargetClassQualifier != DEBUG_KERNEL_LOCAL)


// g_TargetMachineType is sometimes set before InitializeMachine
// is called so it can't be used as a direct check for
// initialization.  Instead a separate, clean initialization
// variable is used.
// IS_MACHINE_SET == TRUE implies a target is set
// since it isn't possible to determine the machine type
// without knowing the target.
#define IS_MACHINE_SET() g_MachineInitialized

// Checks whether the debuggee is in a state where it
// can be examined.  This requires that the debuggee is known
// and paused so that its state is available.
#define IS_MACHINE_ACCESSIBLE() \
    (IS_MACHINE_SET() && !IS_RUNNING(g_CmdState) && \
     g_CurrentProcess != NULL && g_CurrentProcess->CurrentThread != NULL)

// Further restricts the check to just context state as a
// local kernel session can examine memory and therefore is
// accessible but it does not have a context.
#define IS_CONTEXT_ACCESSIBLE() \
    (IS_MACHINE_ACCESSIBLE() && !IS_LOCAL_KERNEL_TARGET())

// Simpler context check for code which may be on the suspend/
// resume path and therefore may be in the middle of initializing
// the variables that IS_CONTEXT_ACCESSIBLE checks.  This
// macro just checks whether it's possible to get any
// context information.
#define IS_CONTEXT_POSSIBLE() \
    (g_RegContextThread != NULL && !IS_LOCAL_KERNEL_TARGET())

// Dumps and local kernel sessions cannot ever support
// execution so disallow execution commands for them.
#define IS_EXECUTION_POSSIBLE() \
    (!(IS_DUMP_TARGET() || IS_LOCAL_KERNEL_TARGET()))

//
// System version is an internal abstraction of build numbers
// and product types.  The only requirement is that within
// a specific system family the numbers increase for newer
// systems.
//
// Most of the debugger code is built around NT system versions
// so there's a SystemVersion variable which is always an
// NT system version.  The ActualSystemVersion contains the
// true system version which gets mapped into a compatible NT
// system version for SystemVersion.
//

enum
{
    SVER_INVALID = 0,
    
    NT_SVER_START = 4 * 1024,
    NT_SVER_NT4,
    NT_SVER_W2K_RC3,
    NT_SVER_W2K,
    NT_SVER_W2K_WHISTLER,
    NT_SVER_END,

    W9X_SVER_START = 8 * 1024,
    W9X_SVER_W95,
    W9X_SVER_W98,
    W9X_SVER_W98SE,
    W9X_SVER_WME,
    W9X_SVER_END,
    
    XBOX_SVER_START = 12 * 1024,
    XBOX_SVER_1,
    XBOX_SVER_END,

    BIG_SVER_START = 16 * 1024,
    BIG_SVER_1,
    BIG_SVER_END,

    EXDI_SVER_START = 20 * 1024,
    EXDI_SVER_1,
    EXDI_SVER_END,

    NTBD_SVER_START = 24 * 1024,
    NTBD_SVER_W2K_WHISTLER,
    NTBD_SVER_END,
    
    EFI_SVER_START = 28 * 1024,
    EFI_SVER_1,
    EFI_SVER_END,
};

// KD version MajorVersion high-byte identifiers.
enum
{
    KD_MAJOR_NT,
    KD_MAJOR_XBOX,
    KD_MAJOR_BIG,
    KD_MAJOR_EXDI,
    KD_MAJOR_NTBD,
    KD_MAJOR_EFI,
    KD_MAJOR_COUNT
};

extern ULONG g_SystemVersion;
extern ULONG g_ActualSystemVersion;

extern ULONG g_TargetCheckedBuild;
extern ULONG g_TargetBuildNumber;
extern BOOL  g_MachineInitialized;
extern ULONG g_TargetMachineType;
extern ULONG g_TargetExecMachine;
extern ULONG g_TargetPlatformId;
extern char  g_TargetServicePackString[MAX_PATH];
extern ULONG g_TargetServicePackNumber;
extern char  g_TargetBuildLabName[272];
extern ULONG g_TargetNumberProcessors;
extern ULONG g_TargetClass;
extern ULONG g_TargetClassQualifier;

//----------------------------------------------------------------------------
//
// Convenience routines.
//
//----------------------------------------------------------------------------

extern ULONG g_TmpCount;

#define ReadVirt(Offset, Var) \
    (g_Target->ReadVirtual(Offset, &(Var), sizeof(Var), \
                           &g_TmpCount) == S_OK && g_TmpCount == sizeof(Var))
#define WriteVirt(Offset, Var) \
    (g_Target->WriteVirtual(Offset, &(Var), sizeof(Var), \
                            &g_TmpCount) == S_OK && g_TmpCount == sizeof(Var))

//----------------------------------------------------------------------------
//
// This class abstracts processing of target-class-dependent
// information.  g_Target is set to the appropriate implementation
// once the class of target is known.
//
//----------------------------------------------------------------------------

class TargetInfo
{
public:
    //
    // Pure abstraction methods.
    // Unless otherwise indicated, base implementations give
    // an error message and return E_UNEXPECTED.
    //
    
    virtual HRESULT Initialize(void);
    // Base implementation does nothing.
    virtual void Uninitialize(void);

    // Some targets, such as eXDI, require initialization
    // per thread.  In eXDI's case, it's calling CoInitialize.
    // Base implementations do nothing.
    virtual HRESULT ThreadInitialize(void);
    virtual void ThreadUninitialize(void);

    // Determines the next byte offset and next page offset
    // that might have different validity than the given offset.
    virtual void NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                PULONG64 NextOffset,
                                                PULONG64 NextPage);
    
    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    // Base implementation layers on ReadVirtual.
    virtual HRESULT SearchVirtual(
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        );
    // Base implementations just call Read/WriteVirtual.
    virtual HRESULT ReadVirtualUncached(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtualUncached(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    // Base implementations just call Read/WritePhysical.
    virtual HRESULT ReadPhysicalUncached(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysicalUncached(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadMsr(
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    virtual HRESULT WriteMsr(
        IN ULONG Msr,
        IN ULONG64 Value
        );
    virtual HRESULT ReadBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT GetProcessorSystemDataOffset(
        IN ULONG Processor,
        IN ULONG Index,
        OUT PULONG64 Offset
        );
    virtual HRESULT CheckLowMemory(
        );
    virtual HRESULT ReadHandleData(
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    // Base implementations layer on WriteVirtual/Physical.
    virtual HRESULT FillVirtual(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT PULONG Filled
        );
    virtual HRESULT FillPhysical(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT PULONG Filled
        );
    virtual HRESULT GetProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);
    // Base implementation silently fails as many targets do
    // not support this.
    virtual HRESULT ReadPageFile(ULONG PfIndex, ULONG64 PfOffset,
                                 PVOID Buffer, ULONG Size);

    virtual HRESULT GetFunctionTableListHead(void);
    virtual PVOID FindDynamicFunctionEntry(MachineInfo* Machine,
                                           ULONG64 Address);
    virtual ULONG64 GetDynamicFunctionTableBase(MachineInfo* Machine,
                                                ULONG64 Address);
    virtual HRESULT ReadOutOfProcessDynamicFunctionTable(PWSTR Dll,
                                                         ULONG64 Table,
                                                         PULONG TableSize,
                                                         PVOID* TableData);
    static PVOID CALLBACK DynamicFunctionTableCallback(HANDLE Process,
                                                       ULONG64 Address,
                                                       ULONG64 Context);

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    // Retrieves segment register descriptors if they are available
    // directly.  Invalid descriptors may be returned, indicating
    // either segment registers aren't supported or that the
    // descriptors must be looked up in descriptor tables.
    // Base implementation returns invalid descriptors.
    virtual HRESULT GetTargetSegRegDescriptors(ULONG64 Thread,
                                               ULONG Start, ULONG Count,
                                               PDESCRIPTOR64 Descs);
    // Base implementations call Read/WriteSpecialRegisters.
    virtual HRESULT GetTargetSpecialRegisters
        (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    virtual HRESULT SetTargetSpecialRegisters
        (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    // Called when the current context state is being
    // discarded so that caches can be flushed.
    // Base implementation does nothing.
    virtual void InvalidateTargetContext(void);

    virtual HRESULT GetThreadIdByProcessor(
        IN ULONG Processor,
        OUT PULONG Id
        );
    
    // This method takes both a PTHREAD_INFO and a "handle"
    // to make things simpler for the kernel thread-to-processor
    // mapping.  If Thread is NULL processor must be a processor
    // index in kernel mode or a thread handle in user mode.
    virtual HRESULT GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    // In theory this method should take a PPROCESS_INFO.
    // Due to the current kernel process and thread structure
    // where there's only a kernel process and threads per
    // processor such a call would be useless in kernel mode.
    // Instead it allows you to either get the process data
    // for a thread of that process or get the process data
    // from a thread data.
    virtual HRESULT GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(PTHREAD_INFO Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(PTHREAD_INFO Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    // This is on target rather than machine since it has
    // both user and kernel variations and the implementations
    // don't have much processor-specific code in them.
    virtual HRESULT GetSelDescriptor(class MachineInfo* Machine,
                                     ULONG64 Thread, ULONG Selector,
                                     PDESCRIPTOR64 Desc);

    virtual HRESULT GetTargetKdVersion(PDBGKD_GET_VERSION64 Version);
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    virtual HRESULT OutputVersion(void);
    virtual HRESULT OutputTime(void);
    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);
    virtual UnloadedModuleInfo* GetUnloadedModuleInfo(void);
    // Image can be identified either by its path or base address.
    virtual HRESULT GetImageVersionInformation(PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer, ULONG BufferSize,
                                               PULONG VerInfoSize);
    virtual HRESULT Reload(PCSTR Args);

    virtual HRESULT GetExceptionContext(PCROSS_PLATFORM_CONTEXT Context);
    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetCurrentSystemUpTimeN(void);
    virtual ULONG64 GetProcessUpTimeN(ULONG64 Process);
    
    virtual void InitializeWatchTrace(void);
    virtual void ProcessWatchTraceEvent(PDBGKD_TRACE_DATA TraceData,
                                        ADDR PcAddr);

    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout);
    
    virtual HRESULT RequestBreakIn(void);
    virtual HRESULT Reboot(void);

    virtual HRESULT InsertCodeBreakpoint(PPROCESS_INFO Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveCodeBreakpoint(PPROCESS_INFO Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         PUCHAR StorageSpace);

    // Returns information similar to VirtualQueryEx for
    // user-mode targets.  Used when writing dump files.
    virtual HRESULT QueryMemoryRegion(PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);
    // Returns information about the kind of memory the
    // given address refers to.
    // Base implementation returns rwx with process for
    // user-mode and kernel for kernel mode.  In other words,
    // the least restrictive settings.
    virtual HRESULT QueryAddressInformation(ULONG64 Address, ULONG InSpace,
                                            PULONG OutSpace, PULONG OutFlags);
    
    //
    // Layered methods.  These are usually common code that
    // use pure methods to do their work.
    //

    HRESULT ReadAllVirtual(ULONG64 Address, PVOID Buffer, ULONG BufferSize)
    {
        HRESULT Status;
        ULONG Done;

        if ((Status = ReadVirtual(Address, Buffer, BufferSize, &Done)) == S_OK
            && Done != BufferSize)
        {
            Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }
        return Status;
    }
    HRESULT WriteAllVirtual(ULONG64 Address, PVOID Buffer, ULONG BufferSize)
    {
        HRESULT Status;
        ULONG Done;

        if ((Status = WriteVirtual(Address, Buffer, BufferSize, &Done)) == S_OK
            && Done != BufferSize)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
        }
        return Status;
    }

    HRESULT ReadAllPhysical(ULONG64 Address, PVOID Buffer, ULONG BufferSize)
    {
        HRESULT Status;
        ULONG Done;

        if ((Status = ReadPhysical(Address, Buffer, BufferSize, &Done)) == S_OK
            && Done != BufferSize)
        {
            Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }
        return Status;
    }
    HRESULT WriteAllPhysical(ULONG64 Address, PVOID Buffer, ULONG BufferSize)
    {
        HRESULT Status;
        ULONG Done;

        if ((Status = WritePhysical(Address, Buffer, BufferSize,
                                    &Done)) == S_OK
            && Done != BufferSize)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
        }
        return Status;
    }

    HRESULT ReadPointer(MachineInfo* Machine,
                        ULONG64 Address, PULONG64 PointerValue);
    HRESULT WritePointer(MachineInfo* Machine,
                         ULONG64 Address, ULONG64 PointerValue);
    HRESULT ReadListEntry(MachineInfo* Machine,
                          ULONG64 Address, PLIST_ENTRY64 List);
    HRESULT ReadLoaderEntry(MachineInfo* Machine,
                            ULONG64 Address, PKLDR_DATA_TABLE_ENTRY64 Entry);
    HRESULT ReadUnicodeString(MachineInfo* Machine,
                              ULONG64 Address, PUNICODE_STRING64 String);
    HRESULT ReadDirectoryTableBase(PULONG64 DirBase);
    HRESULT ReadSharedUserTimeDateN(PULONG64 TimeDate);
    HRESULT ReadSharedUserUpTimeN(PULONG64 UpTime);
    HRESULT ReadImageVersionInfo(ULONG64 ImageBase,
                                 PCSTR Item,
                                 PVOID Buffer,
                                 ULONG BufferSize,
                                 PULONG VerInfoSize,
                                 PIMAGE_DATA_DIRECTORY ResDataDir);

    HRESULT ReadImplicitThreadInfoPointer(ULONG Offset, PULONG64 Ptr);
    HRESULT ReadImplicitProcessInfoPointer(ULONG Offset, PULONG64 Ptr);
    
    // Internal routines which provide canonical context input
    // and output, applying any necessary conversions before
    // or after calling Get/SetTargetContext.
    HRESULT GetContext(
        ULONG64 Thread,
        PCROSS_PLATFORM_CONTEXT Context
        );
    HRESULT SetContext(
        ULONG64 Thread,
        PCROSS_PLATFORM_CONTEXT Context
        );

    // Calls GetTargetKdVersion on g_KdVersion and outputs the content.
    void GetKdVersion(void);
    
    // Internal implementations based on user or kernel
    // registers and data.  Placed here for sharing between
    // live and dump sessions rather than using multiple
    // inheritance.
    
    HRESULT KdGetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                      ULONG64 ThreadHandle,
                                      PULONG64 Offset);
    HRESULT KdGetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                       ULONG Processor,
                                       ULONG64 ThreadData,
                                       PULONG64 Offset);
    HRESULT KdGetThreadInfoTeb(PTHREAD_INFO Thread,
                               ULONG Processor,
                               ULONG64 ThreadData,
                               PULONG64 Offset);
    HRESULT KdGetProcessInfoPeb(PTHREAD_INFO Thread,
                                ULONG Processor,
                                ULONG64 ThreadData,
                                PULONG64 Offset);
    HRESULT KdGetSelDescriptor(class MachineInfo* Machine,
                               ULONG64 Thread, ULONG Selector,
                               PDESCRIPTOR64 Desc);
};

// Base failure behaviors for when a specific target isn't selected.
extern TargetInfo g_UnexpectedTarget;

extern TargetInfo* g_Target;

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

class LiveKernelTargetInfo : public TargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    
    virtual HRESULT GetProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);
    
    virtual HRESULT GetThreadIdByProcessor(
        IN ULONG Processor,
        OUT PULONG Id
        );
    virtual HRESULT GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    virtual HRESULT GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(PTHREAD_INFO Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(PTHREAD_INFO Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    virtual HRESULT GetSelDescriptor(class MachineInfo* Machine,
                                     ULONG64 Thread, ULONG Selector,
                                     PDESCRIPTOR64 Desc);
    
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);

    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetCurrentSystemUpTimeN(void);
    
    // LiveKernelTargetInfo.

    // Options are only valid in Initialize.
    PCSTR m_ConnectOptions;
};

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

class ConnLiveKernelTargetInfo : public LiveKernelTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void    Uninitialize(void);
    
    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT SearchVirtual(
        IN ULONG64 Offset,
        IN ULONG64 Length,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        IN ULONG PatternGranularity,
        OUT PULONG64 MatchOffset
        );
    virtual HRESULT ReadVirtualUncached(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtualUncached(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysicalUncached(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysicalUncached(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadMsr(
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    virtual HRESULT WriteMsr(
        IN ULONG Msr,
        IN ULONG64 Value
        );
    virtual HRESULT ReadBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT CheckLowMemory(
        );
    virtual HRESULT FillVirtual(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT PULONG Filled
        );
    virtual HRESULT FillPhysical(
        THIS_
        IN ULONG64 Start,
        IN ULONG Size,
        IN PVOID Pattern,
        IN ULONG PatternSize,
        OUT PULONG Filled
        );

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetTargetKdVersion(PDBGKD_GET_VERSION64 Version);

    virtual void InitializeWatchTrace(void);
    virtual void ProcessWatchTraceEvent(PDBGKD_TRACE_DATA TraceData,
                                        ADDR PcAddr);
    
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout);

    virtual HRESULT RequestBreakIn(void);
    virtual HRESULT Reboot(void);

    virtual HRESULT InsertCodeBreakpoint(PPROCESS_INFO Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveCodeBreakpoint(PPROCESS_INFO Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         PUCHAR StorageSpace);

    virtual HRESULT QueryAddressInformation(ULONG64 Address, ULONG InSpace,
                                            PULONG OutSpace, PULONG OutFlags);
};

extern ConnLiveKernelTargetInfo g_ConnLiveKernelTarget;

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

class LocalLiveKernelTargetInfo : public LiveKernelTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    
    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadMsr(
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    virtual HRESULT WriteMsr(
        IN ULONG Msr,
        IN ULONG64 Value
        );
    virtual HRESULT ReadBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT CheckLowMemory(
        );

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetTargetKdVersion(PDBGKD_GET_VERSION64 Version);

    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout);
};

extern LocalLiveKernelTargetInfo g_LocalLiveKernelTarget;

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo.
//
//----------------------------------------------------------------------------

class ExdiNotifyRunChange : public IeXdiClientNotifyRunChg
{
public:
    HRESULT Initialize(void);
    void Uninitialize(void);
    
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IeXdiClientNotifyRunChg.
    STDMETHOD(NotifyRunStateChange)(RUN_STATUS_TYPE ersCurrent, 
                                    HALT_REASON_TYPE ehrCurrent,
                                    ADDRESS_TYPE CurrentExecAddress,
                                    DWORD dwExceptionCode);

    // ExdiNotifyRunChange.
    HANDLE m_Event;
    HALT_REASON_TYPE m_HaltReason;
    ADDRESS_TYPE m_ExecAddress;
    ULONG m_ExceptionCode;
};

typedef union _EXDI_CONTEXT
{
    CONTEXT_X86 X86Context;
    CONTEXT_X86_64 Amd64Context;
} EXDI_CONTEXT, *PEXDI_CONTEXT;

enum EXDI_KD_SUPPORT
{
    EXDI_KD_NONE,
    EXDI_KD_IOCTL,
    EXDI_KD_GS_PCR
};

class ExdiLiveKernelTargetInfo : public LiveKernelTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);
    
    virtual HRESULT ThreadInitialize(void);
    virtual void ThreadUninitialize(void);
    
    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteIo(
        IN ULONG InterfaceType,
        IN ULONG BusNumber,
        IN ULONG AddressSpace,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadMsr(
        IN ULONG Msr,
        OUT PULONG64 Value
        );
    virtual HRESULT WriteMsr(
        IN ULONG Msr,
        IN ULONG64 Value
        );
    virtual HRESULT ReadBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteBusData(
        IN ULONG BusDataType,
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT GetProcessorSystemDataOffset(
        IN ULONG Processor,
        IN ULONG Index,
        OUT PULONG64 Offset
        );
    virtual HRESULT CheckLowMemory(
        );

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT GetTargetSegRegDescriptors(ULONG64 Thread,
                                               ULONG Start, ULONG Count,
                                               PDESCRIPTOR64 Descs);
    virtual HRESULT GetTargetSpecialRegisters
        (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    virtual HRESULT SetTargetSpecialRegisters
        (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special);
    virtual void InvalidateTargetContext(void);

    virtual HRESULT GetTargetKdVersion(PDBGKD_GET_VERSION64 Version);

    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout);

    virtual HRESULT RequestBreakIn(void);
    virtual HRESULT Reboot(void);

    virtual HRESULT InsertCodeBreakpoint(PPROCESS_INFO Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveCodeBreakpoint(PPROCESS_INFO Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         PUCHAR StorageSpace);

    // ExdiLiveKernelTargetInfo.
    IeXdiServer* m_Server;
    IUnknown* m_Context;
    ULONG m_ContextValid;
    EXDI_CONTEXT m_ContextData;
    GLOBAL_TARGET_INFO_STRUCT m_GlobalInfo;
    EXDI_KD_SUPPORT m_KdSupport;
    BOOL m_ForceX86;
    ULONG m_ExpectedMachine;
    CBP_KIND m_CodeBpType;
    ExdiNotifyRunChange m_RunChange;
};

extern ExdiLiveKernelTargetInfo g_ExdiLiveKernelTarget;

//----------------------------------------------------------------------------
//
// UserTargetInfo.
//
//----------------------------------------------------------------------------

class UserTargetInfo : public TargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);
    virtual void Uninitialize(void);
    
    virtual HRESULT ReadVirtualUncached(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtualUncached(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    virtual HRESULT ReadHandleData(
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    virtual HRESULT GetProcessorId
        (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id);

    virtual HRESULT GetFunctionTableListHead(void);
    virtual HRESULT ReadOutOfProcessDynamicFunctionTable(PWSTR Dll,
                                                         ULONG64 Table,
                                                         PULONG TableSize,
                                                         PVOID* TableData);

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    virtual HRESULT SetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetThreadInfoDataOffset(PTHREAD_INFO Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    virtual HRESULT GetProcessInfoDataOffset(PTHREAD_INFO Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(PTHREAD_INFO Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(PTHREAD_INFO Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    virtual HRESULT GetSelDescriptor(class MachineInfo* Machine,
                                     ULONG64 Thread, ULONG Selector,
                                     PDESCRIPTOR64 Desc);

    virtual HRESULT GetImageVersionInformation(PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer, ULONG BufferSize,
                                               PULONG VerInfoSize);
    
    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetCurrentSystemUpTimeN(void);
    virtual ULONG64 GetProcessUpTimeN(ULONG64 Process);

    virtual void InitializeWatchTrace(void);
    virtual void ProcessWatchTraceEvent(PDBGKD_TRACE_DATA TraceData,
                                        ADDR PcAddr);
    
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout);

    virtual HRESULT RequestBreakIn(void);

    virtual HRESULT InsertCodeBreakpoint(PPROCESS_INFO Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         PUCHAR StorageSpace);
    virtual HRESULT RemoveCodeBreakpoint(PPROCESS_INFO Process,
                                         class MachineInfo* Machine,
                                         PADDR Addr,
                                         PUCHAR StorageSpace);

    virtual HRESULT QueryMemoryRegion(PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    IUserDebugServices* m_Services;
    ULONG m_ServiceFlags;
};

class LocalUserTargetInfo : public UserTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
};

extern LocalUserTargetInfo g_LocalUserTarget;

class RemoteUserTargetInfo : public UserTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT ReadVirtual(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
};

extern RemoteUserTargetInfo g_RemoteUserTarget;

//----------------------------------------------------------------------------
//
// DumpTargetInfo hierarchy is in dump.hpp.
//
//----------------------------------------------------------------------------

#endif // #ifndef __TARGET_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\target.cpp ===
//----------------------------------------------------------------------------
//
// Abstraction of target-specific information.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

//
// Note by olegk
// We using KLDR_DATA_TABLE_ENTRY64 in some places like 
// GetModNameFromLoaderList) instead of LDR_DATA_TABLE_ENTRY assuming that 
// most important fields are the same in  these structures. 
// So I add some asserts for quick notification if  anything will change 
// (these are not fullproof checks just a basics)
//
C_ASSERT(&(((PLDR_DATA_TABLE_ENTRY64)0)->InLoadOrderLinks) ==
         &(((PKLDR_DATA_TABLE_ENTRY64)0)->InLoadOrderLinks));

C_ASSERT(&(((PLDR_DATA_TABLE_ENTRY64)0)->DllBase) ==
         &(((PKLDR_DATA_TABLE_ENTRY64)0)->DllBase));

C_ASSERT(&(((PLDR_DATA_TABLE_ENTRY64)0)->FullDllName) ==
         &(((PKLDR_DATA_TABLE_ENTRY64)0)->FullDllName));

DBGKD_GET_VERSION64 g_KdVersion;

PCSTR g_NtSverNames[] =
{
    "Windows NT 4", "Windows 2000 RC3", "Windows 2000", "Windows XP",
};
PCSTR g_W9xSverNames[] =
{
    "Windows 95", "Windows 98", "Windows 98 SE", "Windows ME",
};
PCSTR g_XBoxSverNames[] =
{
    "XBox",
};
PCSTR g_BigSverNames[] =
{
    "BIG KD Emulation",
};
PCSTR g_ExdiSverNames[] =
{
    "eXDI Device",
};
PCSTR g_NtBdSverNames[] =
{
    "Windows Boot Debugger",
};
PCSTR g_EfiSverNames[] =
{
    "EFI KD Emulation",
};

//----------------------------------------------------------------------------
//
// Support functions.
//
//----------------------------------------------------------------------------

ULONG
NtBuildToSystemVersion(ULONG Build)
{
    if (Build > 2195)
    {
        return NT_SVER_W2K_WHISTLER;
    }
    else if (Build > 2183)
    {
        return NT_SVER_W2K;
    }
    else if (Build > 1381)
    {
        return NT_SVER_W2K_RC3;
    }
    else
    {
        return NT_SVER_NT4;
    }
}

// Taken from http://kbinternal/kb/articles/q158/2/38.htm
//
// Release                   Version                    File dates
//    ---------------------------------------------------------------------
//    Windows 95 retail, OEM    4.00.950                      7/11/95
//    Windows 95 retail SP1     4.00.950A                     7/11/95
//    OEM Service Release 1     4.00.950A                     7/11/95
//    OEM Service Release 2     4.00.1111* (4.00.950B)        8/24/96
//    OEM Service Release 2.1   4.03.1212-1214* (4.00.950B)   8/24/96-8/27/97
//    OEM Service Release 2.5   4.03.1214* (4.00.950C)        8/24/96-11/18/97
//    Windows 98 retail, OEM    4.10.1998                     5/11/98
//    Windows 98 Second Edition 4.10.2222A                    4/23/99

ULONG
Win9xBuildToSystemVersion(ULONG Build)
{
    if (Build > 2222)
    {
        return W9X_SVER_WME;
    }
    else if (Build > 1998)
    {
        return W9X_SVER_W98SE;
    }
    else if (Build > 950)
    {
        return W9X_SVER_W98;
    }
    else
    {
        return W9X_SVER_W95;
    }
}

void
SetTargetSystemVersionAndBuild(ULONG Build, ULONG PlatformId)
{
    if (PlatformId == VER_PLATFORM_WIN32_NT)
    {
        g_ActualSystemVersion = NtBuildToSystemVersion(Build);
        g_SystemVersion = g_ActualSystemVersion;
    }
    else
    {
        // Win9x puts the major and minor versions in the high word
        // of the build number so mask them off.
        Build &= 0xffff;
        g_ActualSystemVersion = Win9xBuildToSystemVersion(Build);
        // Win98SE was the first Win9x version to support
        // the extended registers thread context flag.
        if (g_ActualSystemVersion >= W9X_SVER_W98SE)
        {
            g_SystemVersion = NT_SVER_W2K;
        }
        else
        {
            g_SystemVersion = NT_SVER_NT4;
        }
    }

    g_TargetBuildNumber = Build;
}

PCSTR
SystemVersionName(ULONG Sver)
{
    if (Sver > NT_SVER_START && Sver < NT_SVER_END)
    {
        return g_NtSverNames[Sver - NT_SVER_START - 1];
    }
    else if (Sver > W9X_SVER_START && Sver < W9X_SVER_END)
    {
        return g_W9xSverNames[Sver - W9X_SVER_START - 1];
    }
    else if (Sver > XBOX_SVER_START && Sver < XBOX_SVER_END)
    {
        return g_XBoxSverNames[Sver - XBOX_SVER_START - 1];
    }
    else if (Sver > BIG_SVER_START && Sver < BIG_SVER_END)
    {
        return g_BigSverNames[Sver - BIG_SVER_START - 1];
    }
    else if (Sver > EXDI_SVER_START && Sver < EXDI_SVER_END)
    {
        return g_ExdiSverNames[Sver - EXDI_SVER_START - 1];
    }
    else if (Sver > NTBD_SVER_START && Sver < NTBD_SVER_END)
    {
        return g_NtBdSverNames[Sver - NTBD_SVER_START - 1];
    }
    else if (Sver > EFI_SVER_START && Sver < EFI_SVER_END)
    {
        return g_EfiSverNames[Sver - EFI_SVER_START - 1];
    }

    return "Unknown System";
}

BOOL
GetUserModuleListAddress(
    MachineInfo* Machine,
    ULONG64 Peb,
    BOOL Quiet,
    PULONG64 OrderModuleListStart,
    PULONG64 FirstEntry
    )
{
    ULONG64 PebLdrOffset;
    ULONG64 ModuleListOffset;
    ULONG64 PebAddr;
    ULONG64 PebLdr = 0;

    *OrderModuleListStart = 0;
    *FirstEntry = 0;

    //
    // Triage dumps have no user mode information.
    // User-mode minidumps don't have a loader list.
    //

    if (IS_KERNEL_TRIAGE_DUMP() || IS_USER_MINI_DUMP())
    {
        return FALSE;
    }

    if (Machine->m_Ptr64)
    {
        PebLdrOffset     = PEBLDR_FROM_PEB64;
        ModuleListOffset = MODULE_LIST_FROM_PEBLDR64;
    }
    else
    {
        PebLdrOffset     = PEBLDR_FROM_PEB32;
        ModuleListOffset = MODULE_LIST_FROM_PEBLDR32;
    }

    if (!Peb)
    {
        if (GetImplicitProcessDataPeb(&Peb) != S_OK)
        {
            if (!Quiet)
            {
                ErrOut("Unable to read KPROCESS\n");
            }
            return FALSE;
        }
        
        if ( (Peb == 0) )
        {
            // This is a common error as the system process has no
            // user address space.
            if (!Quiet)
            {
                ErrOut("Unable to retrieve the PEB address.  "
                       "This is usually caused\n");
                ErrOut("by being in the wrong process context or by paging\n");
            }
            return FALSE;
        }
    }

    //
    // Read address the PEB Ldr data from the PEB structure
    //

    Peb += PebLdrOffset;

    if ( (g_Target->ReadPointer(Machine, Peb, &PebLdr) != S_OK) ||
         (PebLdr == 0) )
    {
        if (!Quiet)
        {
            ErrOut("PPEB_LDR_DATA is NULL (Peb = %s)\n",
                   FormatMachineAddr64(Machine, Peb));
            ErrOut("This is usually caused by being in the wrong process\n");
            ErrOut("context or by paging\n");
        }
        return FALSE;
    }

    //
    // Read address of the user mode module list from the PEB Ldr Data.
    //

    PebLdr += ModuleListOffset;
    *OrderModuleListStart = PebLdr;

    if ( (g_Target->ReadPointer(Machine, PebLdr, FirstEntry) != S_OK) ||
         (*FirstEntry == 0) )
    {
        if (!Quiet)
        {
            ErrOut("UserMode Module List Address is NULL (Addr= %s)\n",
                   FormatMachineAddr64(Machine, PebLdr));
            ErrOut("This is usually caused by being in the wrong process\n");
            ErrOut("context or by paging\n");
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
GetModNameFromLoaderList(
    MachineInfo* Machine,
    ULONG64 Peb,
    ULONG64 ModuleBase,
    PSTR NameBuffer,
    ULONG BufferSize,
    BOOL FullPath
    )
{
    ULONG64 ModList;
    ULONG64 List;
    HRESULT Status;
    KLDR_DATA_TABLE_ENTRY64 Entry;
    WCHAR UnicodeBuffer[MAX_IMAGE_PATH];
    ULONG Read;

    if (!GetUserModuleListAddress(Machine, Peb, TRUE, &ModList, &List))
    {
        return FALSE;
    }

    while (List != ModList)
    {
        Status = g_Target->ReadLoaderEntry(Machine, List, &Entry);
        if (Status != S_OK)
        {
            ErrOut("Unable to read LDR_DATA_TABLE_ENTRY at %s - %s\n",
                   FormatMachineAddr64(Machine, List),
                   FormatStatusCode(Status));
            return FALSE;
        }

        List = Entry.InLoadOrderLinks.Flink;

        if (Entry.DllBase == ModuleBase)
        {
            UNICODE_STRING64 Name;
            
            //
            // We found a matching entry.  Try to get the name.
            //
            if (FullPath)
            {
                Name = Entry.FullDllName;
            }
            else
            {
                Name = Entry.BaseDllName;
            }
            if (Name.Length == 0 ||
                Name.Buffer == 0 ||
                Name.Length >= sizeof(UnicodeBuffer) - sizeof(WCHAR))
            {
                return FALSE;
            }
            
            Status = g_Target->ReadVirtual(Name.Buffer, UnicodeBuffer,
                                           Name.Length, &Read);
            if (Status != S_OK || Read < Name.Length)
            {
                ErrOut("Unable to read name string at %s - %s\n",
                       FormatMachineAddr64(Machine, Name.Buffer),
                       FormatStatusCode(Status));
                return FALSE;
            }

            UnicodeBuffer[Name.Length / sizeof(WCHAR)] = UNICODE_NULL;

            if (!WideCharToMultiByte(CP_ACP, 0, UnicodeBuffer,
                                     Name.Length / sizeof(WCHAR) + 1,
                                     NameBuffer, BufferSize,
                                     NULL, NULL))
            {
                ErrOut("Unable to convert Unicode string %ls to ANSI\n",
                       UnicodeBuffer);
                return FALSE;
            }

            return TRUE;
        }
    }

    return FALSE;
}

void
SetTargetNtCsdVersion(ULONG CsdVersion)
{
    g_TargetServicePackNumber = CsdVersion;

    if (CsdVersion == 0)
    {
        g_TargetServicePackString[0] = 0;
        return;
    }

    PSTR Str = g_TargetServicePackString;
    *Str = 0;

    if (CsdVersion & 0xFFFF)
    {
        sprintf(Str, "Service Pack %u", (CsdVersion & 0xFF00) >> 8);
        Str += strlen(Str);
        if (CsdVersion & 0xFF)
        {
            *Str++ = 'A' + (char)(CsdVersion & 0xFF) - 1;
            *Str = 0;
        }
    }

    if (CsdVersion & 0xFFFF0000)
    {
        if (CsdVersion & 0xFFFF)
        {
            strcpy(Str, ", ");
            Str += strlen(Str);
        }
        sprintf(Str, "RC %u", (CsdVersion >> 24) & 0xFF);
        Str += strlen(Str);
        if (CsdVersion & 0x00FF0000)
        {
            sprintf(Str, ".%u", (CsdVersion >> 16) & 0xFF);
            Str += strlen(Str);
        }
    }
}

//----------------------------------------------------------------------------
//
// Module list abstraction.
//
//----------------------------------------------------------------------------

void
ModuleInfo::ReadImageHeaderInfo(PMODULE_INFO_ENTRY Entry)
{
    HRESULT Status;
    UCHAR SectorBuffer[ 512 ];
    PIMAGE_NT_HEADERS64 NtHeaders;
    ULONG Result;

    if (Entry->ImageInfoValid)
    {
        return;
    }

    //
    // For live debugging of both user mode and kernel mode, we have
    // to go load the checksum timestamp directly out of the image header
    // because someone decided to overwrite these fields in the OS
    // module list  - Argh !
    //

    Entry->CheckSum = UNKNOWN_CHECKSUM;
    Entry->TimeDateStamp = UNKNOWN_TIMESTAMP;

    Status = g_Target->ReadVirtual(Entry->Base, SectorBuffer,
                                   sizeof(SectorBuffer), &Result);
    if (Status == S_OK && Result >= sizeof(SectorBuffer))
    {
        NtHeaders = (PIMAGE_NT_HEADERS64)ImageNtHeader(SectorBuffer);
        if (NtHeaders != NULL)
        {
            switch (NtHeaders->OptionalHeader.Magic)
            {
            case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
                Entry->CheckSum = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.CheckSum;
                Entry->Size = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.SizeOfImage;
                Entry->SizeOfCode = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.SizeOfCode;
                Entry->SizeOfData = ((PIMAGE_NT_HEADERS32)NtHeaders)->
                    OptionalHeader.SizeOfInitializedData;
                break;
            case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
                Entry->CheckSum = NtHeaders->OptionalHeader.CheckSum;
                Entry->Size = NtHeaders->OptionalHeader.SizeOfImage;
                Entry->SizeOfCode = NtHeaders->OptionalHeader.SizeOfCode;
                Entry->SizeOfData =
                    NtHeaders->OptionalHeader.SizeOfInitializedData;
                break;
            }
            Entry->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;

            Entry->ImageInfoValid = 1;
        }
    }
}

HRESULT
NtModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    HRESULT Status;
    ULONG   Result = 0;
    ULONG   Length;
    ULONG64 Buffer;

    if (m_Cur == m_Head)
    {
        return S_FALSE;
    }

    KLDR_DATA_TABLE_ENTRY64 LdrEntry;

    Status = g_Target->ReadLoaderEntry(m_Machine, m_Cur, &LdrEntry);
    if (Status != S_OK)
    {
        ErrOut("Unable to read KLDR_DATA_TABLE_ENTRY at %s - %s\n",
               FormatAddr64(m_Cur), FormatStatusCode(Status));
        return Status;
    }

    m_Cur = LdrEntry.InLoadOrderLinks.Flink;

    //
    // Get the image path if possible, otherwise
    // just use the image base name.
    //

    Entry->NamePtr = NULL;
    Entry->NameLength = 0;

    Length = (ULONG)(ULONG_PTR) LdrEntry.FullDllName.Length;
    Buffer = LdrEntry.FullDllName.Buffer;

    // In the NT4 dumps that we have the long name may
    // point to valid memory but the memory content is
    // rarely the correct name, so just don't bother
    // trying to read the long name on NT4.
    if (g_SystemVersion >= NT_SVER_W2K &&
        Length != 0 && Buffer != 0 &&
        Length < (MAX_IMAGE_PATH * sizeof(WCHAR)))
    {
        Status = g_Target->ReadVirtual(Buffer,
                                       Entry->Buffer,
                                       Length,
                                       &Result);

        if (Status != S_OK || (Result < Length))
        {
            // Make this a verbose message since it's possible the
            // name is simply paged out.
            VerbOut("Unable to read NT module Full Name string at %s - %s\n",
                    FormatAddr64(Buffer), FormatStatusCode(Status));
            Result = 0;
        }
    }

    if (!Result)
    {
        Length = (ULONG)(ULONG_PTR) LdrEntry.BaseDllName.Length;
        Buffer = LdrEntry.BaseDllName.Buffer;

        if (Length != 0 && Buffer != 0 &&
            Length < (MAX_IMAGE_PATH * sizeof(WCHAR)))
        {
            Status = g_Target->ReadVirtual(Buffer,
                                           Entry->Buffer,
                                           Length,
                                           &Result);

            if (Status != S_OK || (Result < Length))
            {
                WarnOut("Unable to read NT module Base Name "
                        "string at %s - %s\n",
                        FormatAddr64(Buffer), FormatStatusCode(Status));
                Result = 0;
            }
        }
    }

    if (!Result)
    {
        // We did not get any name - just return.
        return S_OK;
    }

    *(PWCHAR)(Entry->Buffer + Length) = UNICODE_NULL;
    
    Entry->NamePtr = &(Entry->Buffer[0]);
    Entry->NameLength = Length;
    Entry->UnicodeNamePtr = 1;
    Entry->Base = LdrEntry.DllBase;
    Entry->Size = LdrEntry.SizeOfImage;
    Entry->CheckSum = LdrEntry.CheckSum;
    Entry->TimeDateStamp = LdrEntry.TimeDateStamp;

    //
    // Update the image informaion, such as timestamp and real image size,
    // Directly from the image header
    //

    ReadImageHeaderInfo(Entry);

    //
    // For newer NT builds, we also have an alternate entry in the
    // LdrDataTable to store image information in case the actual header
    // is paged out.  We do this for session space images only right now.
    //

    if (LdrEntry.Flags & LDRP_NON_PAGED_DEBUG_INFO)
    {
        NON_PAGED_DEBUG_INFO di;

        Status = g_Target->ReadVirtual(LdrEntry.NonPagedDebugInfo,
                                       &di,
                                       sizeof(di), // Only read the base struct
                                       &Result);

        if (Status != S_OK || (Result < sizeof(di)))
        {
            WarnOut("Unable to read NonPagedDebugInfo at %s - %s\n",
                    FormatAddr64(LdrEntry.NonPagedDebugInfo),
                    FormatStatusCode(Status));
            return S_OK;
        }

        Entry->TimeDateStamp = di.TimeDateStamp;
        Entry->CheckSum      = di.CheckSum;
        Entry->Size          = di.SizeOfImage;

        Entry->ImageInfoPartial = 1;
        Entry->ImageInfoValid = 1;

        if (di.Flags == 1)
        {
            Entry->DebugHeader = malloc(di.Size - sizeof(di));

            if (Entry->DebugHeader)
            {
                Status = g_Target->ReadVirtual(LdrEntry.NonPagedDebugInfo +
                                                   sizeof(di),
                                               Entry->DebugHeader,
                                               di.Size - sizeof(di),
                                               &Result);

                if (Status != S_OK || (Result < di.Size - sizeof(di)))
                {
                    WarnOut("Unable to read NonPagedDebugInfo data at %s - %s\n",
                            FormatAddr64(LdrEntry.NonPagedDebugInfo + sizeof(di)),
                            FormatStatusCode(Status));
                    return S_OK;
                }

                Entry->ImageDebugHeader = 1;
                Entry->SizeOfDebugHeader = di.Size - sizeof(di);
            }
        }
    }

    return S_OK;
}

HRESULT
NtKernelModuleInfo::Initialize(void)
{
    HRESULT Status;
    LIST_ENTRY64 List64;

    m_Machine = g_TargetMachine;
    
    if ((m_Head = KdDebuggerData.PsLoadedModuleList) == 0)
    {
        //
        // This field is ALWAYS set in NT 5 targets.
        //
        // We will only fail here if someone changed the debugger code
        // and did not "make up" this structure properly for NT 4 or
        // dump targets..
        //

        ErrOut("Module List address is NULL - "
               "debugger not initialized properly.\n");
        return E_FAIL;
    }

    Status = g_Target->ReadListEntry(m_Machine, m_Head, &List64);

    //
    // In live debug sessions, the debugger connects before Mm creates
    // the actual module list.
    // If we are this early on, try to load symbols from the loader
    // block module list (NT 6).  Otherwise, just fail and we will
    // get called back later by the ntoskrnl.exe module load call.
    //
    // For dumps, (not user mode or triage) the data should always
    // be initialized.
    //

    if ( (Status == S_OK) && (List64.Flink) )
    {
        m_Cur = List64.Flink;
    }
    else
    {
        dprintf("PsLoadedModuleList not initialized yet.  "
                "Delay kernel load.\n");
        return S_FALSE;
    }

    return S_OK;
}

NtKernelModuleInfo g_NtKernelModuleIterator;

HRESULT
NtUserModuleInfo::Initialize(void)
{
    return GetUserModuleListAddress(m_Machine, m_Peb, FALSE, &m_Head, &m_Cur) ?
        S_OK : S_FALSE;
}

HRESULT
NtTargetUserModuleInfo::Initialize(void)
{
    m_Machine = g_TargetMachine;
    m_Peb = 0;
    return NtUserModuleInfo::Initialize();
}

NtTargetUserModuleInfo g_NtTargetUserModuleIterator;

HRESULT
NtWow64UserModuleInfo::Initialize(void)
{
    HRESULT Status;
    
    if (g_TargetMachine->m_NumExecTypes < 2)
    {
        return E_UNEXPECTED;
    }

    m_Machine = MachineTypeInfo(g_TargetMachine->m_ExecTypes[1]);
    
    if ((Status = GetPeb32(&m_Peb)) != S_OK)
    {
        return Status;
    }
    
    return NtUserModuleInfo::Initialize();
}

HRESULT 
NtWow64UserModuleInfo::GetPeb32(PULONG64 Peb32)
{
    ULONG64 Teb;
    ULONG64 Teb32;
    ULONG Result;
    HRESULT Status;

    if ((Status = GetImplicitThreadDataTeb(&Teb)) == S_OK)
    {
        if ((Status = g_Target->ReadPointer(g_TargetMachine,
                                            Teb, &Teb32)) == S_OK)
        {
            if (!Teb32) 
            {
                return E_UNEXPECTED;
            }

            ULONG RawPeb32;
            
            Status = g_Target->
                ReadAllVirtual(Teb32 + PEB_FROM_TEB32, &RawPeb32,
                               sizeof(RawPeb32));
            if (Status != S_OK)
            {
                ErrOut("Cannot read PEB32 from WOW64 TEB32 %s - %s\n",
                       FormatAddr64(Teb32), FormatStatusCode(Status));
                return Status;
            }

            *Peb32 = EXTEND64(RawPeb32);
        }
    }

    return Status;
}

NtWow64UserModuleInfo g_NtWow64UserModuleIterator;

HRESULT
DebuggerModuleInfo::Initialize(void)
{
    m_Image = g_CurrentProcess->ImageHead;
    return S_OK;
}

HRESULT
DebuggerModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Image == NULL)
    {
        return S_FALSE;
    }

    Entry->NamePtr = m_Image->ImagePath;
    Entry->UnicodeNamePtr = 0;
    Entry->ModuleName = m_Image->ModuleName;
    Entry->File = m_Image->File;
    Entry->Base = m_Image->BaseOfImage;
    Entry->Size = m_Image->SizeOfImage;
    Entry->CheckSum = m_Image->CheckSum;
    Entry->TimeDateStamp = m_Image->TimeDateStamp;

    Entry->ImageInfoValid = 1;

    m_Image = m_Image->Next;

    return S_OK;
}

DebuggerModuleInfo g_DebuggerModuleIterator;

HRESULT
NtKernelUnloadedModuleInfo::Initialize(void)
{
    if (KdDebuggerData.MmUnloadedDrivers == 0 ||
        KdDebuggerData.MmLastUnloadedDriver == 0)
    {
        return E_FAIL;
    }

    // If this is the initial module load we need to be
    // careful because much of the system isn't initialized
    // yet.  Some versions of the OS can crash when scanning
    // the unloaded module list, plus at this point we can
    // safely assume there are no unloaded modules, so just
    // don't enumerate anything.
    if (g_EngStatus & ENG_STATUS_AT_INITIAL_MODULE_LOAD)
    {
        return E_FAIL;
    }
    
    HRESULT Status;
    ULONG Read;

    if ((Status = g_Target->ReadPointer(g_TargetMachine,
                                        KdDebuggerData.MmUnloadedDrivers,
                                        &m_Base)) != S_OK ||
        (Status = g_Target->ReadVirtual(KdDebuggerData.MmLastUnloadedDriver,
                                        &m_Index, sizeof(m_Index),
                                        &Read)) != S_OK)
    {
        return Status;
    }
    if (Read != sizeof(m_Index))
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    m_Count = 0;
    return S_OK;
}

HRESULT
NtKernelUnloadedModuleInfo::GetEntry(PSTR Name,
                                     PDEBUG_MODULE_PARAMETERS Params)
{
    if (m_Count == MI_UNLOADED_DRIVERS)
    {
        return S_FALSE;
    }

    if (m_Index == 0)
    {
        m_Index = MI_UNLOADED_DRIVERS - 1;
    }
    else
    {
        m_Index--;
    }

    ULONG64 Offset;
    ULONG Read;
    HRESULT Status;
    ULONG64 WideName;
    ULONG NameLen;

    ZeroMemory(Params, sizeof(*Params));
    Params->Flags |= DEBUG_MODULE_UNLOADED;

    if (g_TargetMachine->m_Ptr64)
    {
        UNLOADED_DRIVERS64 Entry;

        Offset = m_Base + m_Index * sizeof(Entry);
        if ((Status = g_Target->ReadVirtual(Offset, &Entry, sizeof(Entry),
                                            &Read)) != S_OK)
        {
            return Status;
        }
        if (Read != sizeof(Entry))
        {
            return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }

        if (Entry.Name.Buffer == 0)
        {
            m_Count = MI_UNLOADED_DRIVERS;
            return S_FALSE;
        }

        Params->Base = Entry.StartAddress;
        Params->Size = (ULONG)(Entry.EndAddress - Entry.StartAddress);
        Params->TimeDateStamp =
            FileTimeToTimeDateStamp(Entry.CurrentTime.QuadPart);
        WideName = Entry.Name.Buffer;
        NameLen = Entry.Name.Length;
    }
    else
    {
        UNLOADED_DRIVERS32 Entry;

        Offset = m_Base + m_Index * sizeof(Entry);
        if ((Status = g_Target->ReadVirtual(Offset, &Entry, sizeof(Entry),
                                            &Read)) != S_OK)
        {
            return Status;
        }
        if (Read != sizeof(Entry))
        {
            return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }

        if (Entry.Name.Buffer == 0)
        {
            m_Count = MI_UNLOADED_DRIVERS;
            return S_FALSE;
        }

        Params->Base = EXTEND64(Entry.StartAddress);
        Params->Size = Entry.EndAddress - Entry.StartAddress;
        Params->TimeDateStamp =
            FileTimeToTimeDateStamp(Entry.CurrentTime.QuadPart);
        WideName = EXTEND64(Entry.Name.Buffer);
        NameLen = Entry.Name.Length;
    }

    if (Name != NULL)
    {
        //
        // This size restriction is in force for minidumps only.
        // For kernel dumps, just truncate the name for now ...
        //

        if (NameLen > MAX_UNLOADED_NAME_LENGTH)
        {
            NameLen = MAX_UNLOADED_NAME_LENGTH;
        }

        WCHAR WideBuf[MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1];

        if ((Status = g_Target->ReadVirtual(WideName, WideBuf, NameLen,
                                            &Read)) != S_OK)
        {
            return Status;
        }

        WideBuf[NameLen / sizeof(WCHAR)] = 0;
        if (WideCharToMultiByte(CP_ACP, 0,
                                WideBuf, NameLen / sizeof(WCHAR) + 1,
                                Name,
                                MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR) + 1,
                                NULL, NULL) == 0)
        {
            return WIN32_LAST_STATUS();
        }

        Name[MAX_UNLOADED_NAME_LENGTH / sizeof(WCHAR)] = 0;
    }

    m_Count++;
    return S_OK;
}

NtKernelUnloadedModuleInfo g_NtKernelUnloadedModuleIterator;

HRESULT
W9xModuleInfo::Initialize(void)
{
    m_Snap = g_Kernel32Calls.
        CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,
                                 g_CurrentProcess->SystemId);
    if (m_Snap == INVALID_HANDLE_VALUE)
    {
        m_Snap = NULL;
        ErrOut("Can't create snapshot\n");
        return WIN32_LAST_STATUS();
    }

    m_First = TRUE;
    m_LastId = 0;
    return S_OK;
}

HRESULT
W9xModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Snap == NULL)
    {
        return S_FALSE;
    }
    
    BOOL Succ;
    MODULEENTRY32 Mod;

    Mod.dwSize = sizeof(Mod);
    if (m_First)
    {
        Succ = g_Kernel32Calls.Module32First(m_Snap, &Mod);
        m_First = FALSE;
    }
    else
    {
        // Win9x seems to require that this module ID be saved
        // between calls so stick it back in to keep Win9x happy.
        Mod.th32ModuleID = m_LastId;
        Succ = g_Kernel32Calls.Module32Next(m_Snap, &Mod);
    }
    if (!Succ)
    {
        CloseHandle(m_Snap);
        m_Snap = NULL;
        return S_FALSE;
    }

    m_LastId = Mod.th32ModuleID;
    strncat(Entry->Buffer, Mod.szModule, sizeof(Entry->Buffer) - 1);
    Entry->NamePtr = Entry->Buffer;
    Entry->UnicodeNamePtr = 0;
    Entry->Base = EXTEND64((ULONG_PTR)Mod.modBaseAddr);
    Entry->Size = Mod.modBaseSize;

    //
    // Update the image informaion, such as timestamp and real image size,
    // Directly from the image header
    //

    ReadImageHeaderInfo(Entry);

    return S_OK;
}

W9xModuleInfo g_W9xModuleIterator;

//----------------------------------------------------------------------------
//
// Target configuration information.
//
//----------------------------------------------------------------------------

ULONG g_SystemVersion;
ULONG g_ActualSystemVersion;

ULONG g_TargetCheckedBuild;
ULONG g_TargetBuildNumber;
BOOL  g_MachineInitialized;
ULONG g_TargetMachineType = IMAGE_FILE_MACHINE_UNKNOWN;
ULONG g_TargetExecMachine = IMAGE_FILE_MACHINE_UNKNOWN;
ULONG g_TargetPlatformId;
char  g_TargetServicePackString[_MAX_PATH];
ULONG g_TargetServicePackNumber;
char  g_TargetBuildLabName[272];

ULONG g_TargetNumberProcessors;
ULONG g_TargetClass = DEBUG_CLASS_UNINITIALIZED;
ULONG g_TargetClassQualifier;

ConnLiveKernelTargetInfo g_ConnLiveKernelTarget;
LocalLiveKernelTargetInfo g_LocalLiveKernelTarget;
ExdiLiveKernelTargetInfo g_ExdiLiveKernelTarget;
LocalUserTargetInfo g_LocalUserTarget;
RemoteUserTargetInfo g_RemoteUserTarget;

//----------------------------------------------------------------------------
//
// TargetInfo.
//
//----------------------------------------------------------------------------

// Used in convenience macros.
ULONG g_TmpCount;

TargetInfo* g_Target = &g_UnexpectedTarget;

void
TargetInfo::Uninitialize(void)
{
    // Placeholder.
}

HRESULT
TargetInfo::ThreadInitialize(void)
{
    // Placeholder.
    return S_OK;
}

void
TargetInfo::ThreadUninitialize(void)
{
    // Placeholder.
}

HRESULT
TargetInfo::OutputTime(void)
{
    ULONG64 TimeDateN = GetCurrentTimeDateN();
    if (TimeDateN)
    {
        dprintf("Debug session time: %s\n",
                 TimeToStr(FileTimeToTimeDateStamp(TimeDateN)));
    }

    ULONG64 UpTimeN = GetCurrentSystemUpTimeN();
    if (UpTimeN)
    {
        ULONG seconds = FileTimeToTime(UpTimeN);
        ULONG minutes = seconds / 60;
        ULONG hours = minutes / 60;
        ULONG days = hours / 24;

        dprintf("System Uptime: %d days %d:%02d:%02d \n",
                 days, hours%24, minutes%60, seconds%60);
    }
    else
    {
        dprintf("System Uptime: not available\n");
    }

    if (IS_LIVE_USER_TARGET())
    {
        ULONG64 UpTimeProcessN = GetProcessUpTimeN(g_CurrentProcess->FullHandle);
        if (UpTimeN)
        {
            ULONG seconds = FileTimeToTime(UpTimeProcessN);
            ULONG minutes = seconds / 60;
            ULONG hours = minutes / 60;
            ULONG days = hours / 24;

            dprintf("Process Uptime: %d days %d:%02d:%02d \n",
                     days, hours%24, minutes%60, seconds%60);
        }
        else
        {
            dprintf("Process Uptime: not available\n");
        }
    }

    return (TimeDateN && UpTimeN) ? S_OK : E_FAIL;
}

HRESULT
TargetInfo::OutputVersion(void)
{
    BOOL MpMachine;

    if (!IS_TARGET_SET())
    {
        return E_UNEXPECTED;
    }
    else if (IS_USER_TARGET())
    {
        dprintf("%s ", SystemVersionName(g_ActualSystemVersion));
    }
    else
    {
        dprintf("%s Kernel ", SystemVersionName(g_ActualSystemVersion));
    }

    dprintf("Version %u", g_TargetBuildNumber);

    // Win9x seems to set the CSD string to a space which isn't
    // very interesting so ignore it.
    if (g_TargetServicePackString[0] &&
        strcmp(g_TargetServicePackString, " ") != 0)
    {
        dprintf(" (%s)", g_TargetServicePackString);
    }

    MpMachine = IS_LIVE_KERNEL_TARGET() ?
                    ((g_KdVersion.Flags & DBGKD_VERS_FLAG_MP) ? 1 : 0) :
                    (g_TargetNumberProcessors > 1);

    dprintf(" %s ", MpMachine ? "MP" : "UP");

    if (MpMachine)
    {
        dprintf("(%d procs) ", g_TargetNumberProcessors);
    }

    dprintf("%s %s\n",
            g_TargetCheckedBuild == 0xC ? "Checked" : "Free",
            g_TargetMachine != NULL ? g_TargetMachine->m_FullName : "");

    if (g_Wow64exts != NULL)
    {
        dprintf("WOW64 extensions loaded\n");
    }
    
    if (g_TargetBuildLabName[0])
    {
        dprintf("%s\n", g_TargetBuildLabName);
    }

    if (IS_KERNEL_TARGET())
    {
        dprintf("Kernel base = 0x%s PsLoadedModuleList = 0x%s\n",
                FormatAddr64(KdDebuggerData.KernBase),
                FormatAddr64(KdDebuggerData.PsLoadedModuleList));
    }

    OutputTime();

    return S_OK;
}

ModuleInfo*
TargetInfo::GetModuleInfo(BOOL UserMode)
{
    if (UserMode)
    {
        switch(g_TargetPlatformId)
        {
        case VER_PLATFORM_WIN32_NT:
            return &g_NtTargetUserModuleIterator;
        case VER_PLATFORM_WIN32_WINDOWS:
            return &g_W9xModuleIterator;
        default:
            ErrOut("System module info not available\n");
            return NULL;
        }
    }
    else
    {
        if (g_TargetPlatformId != VER_PLATFORM_WIN32_NT)
        {
            ErrOut("System module info only available on Windows NT/2000\n");
            return NULL;
        }

        DBG_ASSERT(IS_KERNEL_TARGET());
        return &g_NtKernelModuleIterator;
    }
}

UnloadedModuleInfo*
TargetInfo::GetUnloadedModuleInfo(void)
{
    if (g_TargetPlatformId != VER_PLATFORM_WIN32_NT)
    {
        ErrOut("System unloaded module info only available on "
               "Windows NT/2000\n");
        return NULL;
    }

    if (IS_KERNEL_TARGET())
    {
        return &g_NtKernelUnloadedModuleIterator;
    }
    else
    {
        return NULL;
    }
}

HRESULT
TargetInfo::GetImageVersionInformation(PCSTR ImagePath,
                                       ULONG64 ImageBase,
                                       PCSTR Item,
                                       PVOID Buffer, ULONG BufferSize,
                                       PULONG VerInfoSize)
{
    return E_NOINTERFACE;
}

HRESULT
TargetInfo::Reload(
    IN PCSTR args
    )
{
    HRESULT      Status;
    CHAR         AnsiString[MAX_IMAGE_PATH];
    LPSTR        SpecificModule = NULL;
    ULONG64      Address = 0;
    ULONG        ImageSize = 0;
    PCHAR        p;
    ULONG        ModCount;
    BOOL         IgnoreSignature = FALSE;
    ULONG        ReloadSymOptions;
    BOOL         UnloadOnly = FALSE;
    BOOL         ReallyVerbose = FALSE;
    BOOL         LoadUserSymbols = TRUE;
    BOOL         UserModeList = IS_USER_TARGET();
    BOOL         ForceSymbolLoad = FALSE;
    BOOL         PrintImageListOnly = FALSE;
    BOOL         rc;
    BOOL         AddrLoad = FALSE;
    BOOL         UseDebuggerModuleList;
    BOOL         SkipPathChecks = FALSE;
    ModuleInfo*  ModIter;
    BOOL         Wow64ModLoaded = FALSE;
    HRESULT      RetStatus = S_OK;
    MODULE_INFO_ENTRY ModEntry = {0};


    if (!IS_TARGET_SET() ||
        g_CurrentProcess == NULL)
    {
        return E_UNEXPECTED;
    }

    // Historically, live user-mode reload has always
    // just used the internal module list so preserve that.
    UseDebuggerModuleList = IS_USER_TARGET() && !IS_DUMP_TARGET();

    while (*args)
    {
        while (*args && *args <= ' ')
        {
            args++;
        }

        if (*args == '/' || *args == '-')
        {
            args++;
            while (*args > ' ')
            {
                switch (*args++)
                {
                case 'a':
                    // for internal use only: loads whatever is found at the
                    // passed address
                    AddrLoad = TRUE;
                    break;

                case 'd':
                    UseDebuggerModuleList = TRUE;
                    break;

                case 'f':
                    ForceSymbolLoad = TRUE;
                    break;

                case 'i':
                    IgnoreSignature = TRUE;
                    break;

                case 'l':
                    PrintImageListOnly = TRUE;
                    break;

                case 'n':
                    LoadUserSymbols = FALSE;
                    break;

                case 'P':
                    // Internal-only switch.
                    SkipPathChecks = TRUE;
                    break;
                    
                case 's':
                    UseDebuggerModuleList = FALSE;
                    break;

                case 'u':
                    if (!_strcmpi(args, "ser"))
                    {
                        UserModeList = TRUE;
                        args += 3;
                    }
                    else
                    {
                        UnloadOnly = TRUE;
                    }
                    break;

                case 'v':
                    ReallyVerbose = TRUE;
                    break;

                default:
                    dprintf("Reload: Unknown option '%c'\n", args[-1]);
                    dprintf("Usage: .reload [flags] [module] ...\n");
                    dprintf("  Flags:   /d  Use the debugger's module list\n");
                    dprintf("               Default for live user-mode "
                            "sessions\n");
                    dprintf("           /f  Force immediate symbol load "
                            "instead of deferred\n");
                    dprintf("           /i  Force symbol load by ignoring "
                            "mismatches in the pdb signature (requires /f as well)\n");
                    dprintf("           /l  Just list the modules.  "
                            "Kernel output same as !drivers\n");
                    dprintf("           /n  Do not load from user-mode list "
                            "in kernel sessions\n");
                    dprintf("           /s  Use the system's module list\n");
                    dprintf("               Default for dump and kernel sessions\n");
                    dprintf("           /u  Unload symbols, no reload\n");
                    dprintf("        /user  Load only user-mode symbols "
                            "in kernel sessions\n");
                    dprintf("           /v  Verbose\n");
                    return E_INVALIDARG;
                }
            }
        }

        while (*args && *args <= ' ')
        {
            args++;
        }

        if (!(*args == '/' || *args == '-') || AddrLoad)
        {
            AnsiString[ 0 ] = '\0';
            Address = 0;

            if (!sscanf(args, "%s", AnsiString) ||
                !strlen(AnsiString))
            {
                AddrLoad = FALSE;
                break;
            }
            else
            {
                p = 0;
                args += strlen( AnsiString );

                //
                // Support !reload pri_kern.exe=0x80400000,size
                //

                if (p = strchr(AnsiString, '='))
                {
                    *p++ = 0;

                    if (sscanf(p, "%I64x", &Address) != 1)
                    {
                        ErrOut("Invalid address %s\n", p);
                        return E_INVALIDARG;
                    }
                    if (!g_TargetMachine->m_Ptr64)
                    {
                        Address = EXTEND64(Address);
                    }

                    if (p = strchr(p, ','))
                    {
                        p++;
                        if (sscanf(p, "%x", &ImageSize) != 1)
                        {
                            ErrOut("Invalid ImageSize %s\n", p);
                            return E_INVALIDARG;
                        }
                    }
                }

                if (UnloadOnly)
                {
                    BOOL Deleted;

                    Deleted = DelImageByName(g_CurrentProcess, AnsiString,
                                             INAME_MODULE);
                    if (!Deleted)
                    {
                        // The user might have given an image name
                        // instead of a module name so try that.
                        Deleted = DelImageByName(g_CurrentProcess,
                                                 PathTail(AnsiString),
                                                 INAME_IMAGE_PATH_TAIL);
                    }
                    if (Deleted)
                    {
                        dprintf("Unloaded %s\n", AnsiString);
                        return S_OK;
                    }
                    else
                    {
                        dprintf("Unable to find module '%s'\n", AnsiString);
                        return E_NOINTERFACE;
                    }
                }

                //
                // NOTE: This seems unnecessary as AddImage is going to
                // check for the renamed image anyway.
                //

                SpecificModule = _strdup( AnsiString );
                if (!SpecificModule)
                {
                    return S_OK;
                }
                if (IS_KERNEL_TARGET() &&
                    _stricmp( AnsiString, KERNEL_MODULE_NAME ) == 0)
                {
                    ForceSymbolLoad = TRUE;
                }
                else
                {
                    if (AddrLoad)
                    {
                        free(SpecificModule);
                        SpecificModule = NULL;
                    }
                }
            }
        }
    }

    // Ignore signature will only work if we load the symbols imediately.
    if (ForceSymbolLoad == FALSE)
    {
        IgnoreSignature = FALSE;
    }

    if (!PrintImageListOnly && !SkipPathChecks)
    {
        if (g_SymbolSearchPath == NULL ||
            *g_SymbolSearchPath == NULL)
        {
            dprintf("*********************************************************************\n");
            dprintf("* Symbols can not be loaded because symbol path is not initialized. *\n");
            dprintf("*                                                                   *\n");
            dprintf("* The Symbol Path can be set by:                                    *\n");
            dprintf("*   using the _NT_SYMBOL_PATH environment variable.                 *\n");
            dprintf("*   using the -y <symbol_path> argument when starting the debugger. *\n");
            dprintf("*   using .sympath and .sympath+                                    *\n");
            dprintf("*********************************************************************\n");
            RetStatus = E_INVALIDARG;
            goto FreeSpecMod;
        }

        if (IS_DUMP_WITH_MAPPED_IMAGES() &&
            (g_ExecutableImageSearchPath == NULL ||
             *g_ExecutableImageSearchPath == NULL))
        {
            dprintf("*********************************************************************\n");
            dprintf("* Analyzing Minidumps requires access to the actual executable      *\n");
            dprintf("* images for the crashed system                                     *\n");
            dprintf("*                                                                   *\n");
            dprintf("* The Executable Image Path can be set by:                          *\n");
            dprintf("*   using the _NT_EXECUTABLE_IMAGE_PATH environment variable.       *\n");
            dprintf("*   using the -i <image_path> argument when starting the debugger.  *\n");
            dprintf("*   using .exepath and .exepath+                                    *\n");
            dprintf("*********************************************************************\n");
            RetStatus = E_INVALIDARG;
            goto FreeSpecMod;
        }
    }

    //
    // If both the module name and the address are specified, then just load
    // the module right now, as this is only used when normal symbol loading
    // would have failed in the first place.
    //

    if (SpecificModule && Address)
    {
        if (IgnoreSignature)
        {
            ReloadSymOptions = SymGetOptions();
            SymSetOptions(ReloadSymOptions | SYMOPT_LOAD_ANYTHING);
        }

        ModEntry.NamePtr       = SpecificModule,
        ModEntry.Base          = Address;
        ModEntry.Size          = ImageSize;
        ModEntry.CheckSum      = -1;

        if (AddImage(&ModEntry, TRUE) == NULL)
        {
            ErrOut("Unable to add module at %s\n", FormatAddr64(Address));
            RetStatus = E_FAIL;
        }

        if (IgnoreSignature)
        {
            SymSetOptions(ReloadSymOptions);
        }

        goto FreeSpecMod;
    }

    //
    // Don't unload and reset things if we are looking for a specific module
    // or if we're going to use the existing module list.
    //

    if (SpecificModule == NULL)
    {
        if (!PrintImageListOnly &&
            (!UseDebuggerModuleList || UnloadOnly))
        {
            DelImages(g_CurrentProcess);
        }

        if (UnloadOnly)
        {
            dprintf("Unloaded all modules\n");
            return S_OK;
        }

        if (!IS_USER_TARGET() && !UseDebuggerModuleList)
        {
            if (!IS_DUMP_TARGET())
            {
                GetKdVersion();
            }

            VerifyKernelBase(TRUE);
        }

        //
        // Print out the correct statement based on the type of output we
        // want to provide
        //

        if (PrintImageListOnly)
        {
            if (UseDebuggerModuleList)
            {
                dprintf("Debugger Module List Summary\n");
            }
            else
            {
                dprintf("System %s Summary\n",
                        IS_USER_TARGET() ? "Image" : "Driver and Image");
            }

            dprintf("Base       ");
            if (g_TargetMachine->m_Ptr64)
            {
                dprintf("         ");
            }
#if 0
            if (Flags & 1)
            {
                dprintf("Code Size       Data Size       Resident  "
                        "Standby   Driver Name\n");
            }
            else if (Flags & 2)
            {
                dprintf("Code  Data  Locked  Resident  Standby  "
                        "Loader Entry  Driver Name\n");
            }
            else
            {
#endif

            if (UseDebuggerModuleList)
            {
                dprintf("Image Size      "
                        "Image Name        Creation Time\n");
            }
            else
            {
                dprintf("Code Size      Data Size      "
                        "Image Name        Creation Time\n");
            }
        }
        else if (UseDebuggerModuleList)
        {
            dprintf("Reloading current modules\n");
        }
        else if (!IS_USER_TARGET())
        {
            dprintf("Loading %s Symbols\n",
                    UserModeList ? "User" : "Kernel");
        }
    }

    //
    // Get the beginning of the module list.
    //

    if (UseDebuggerModuleList)
    {
        ModIter = &g_DebuggerModuleIterator;
    }
    else
    {
        ModIter = GetModuleInfo(UserModeList);
    }

    if (ModIter == NULL)
    {
        // Error messages already printed.
        RetStatus = E_UNEXPECTED;
        goto FreeSpecMod;
    }
    if ((Status = ModIter->Initialize()) != S_OK)
    {
        // Error messages already printed.
        // Fold unprepared-to-reload S_FALSE into S_OK.
        RetStatus = SUCCEEDED(Status) ? S_OK : Status;
        goto FreeSpecMod;
    }

    if (IgnoreSignature)
    {
        ReloadSymOptions = SymGetOptions();
        SymSetOptions(ReloadSymOptions | SYMOPT_LOAD_ANYTHING);
    }

    // Suppress notifications until everything is done.
    g_EngNotify++;

LoadLoop:
    for (ModCount=0; ; ModCount++)
    {
        // Flush regularly so the user knows something is
        // happening during the reload.
        FlushCallbacks();

        if (CheckUserInterrupt())
        {
            break;
        }

        if (ModCount > 1000)
        {
            ErrOut("ModuleList is corrupt - walked over 1000 module entries\n");
            break;
        }

        if (ModEntry.DebugHeader)
        {
            free(ModEntry.DebugHeader);
        }

        ZeroMemory(&ModEntry, sizeof(ModEntry));
        if ((Status = ModIter->GetEntry(&ModEntry)) != S_OK)
        {
            // Error message already printed in error case.
            // Works for end-of-list case also.
            break;
        }

        //
        // Warn if not all the information was gathered
        //

        if (!ModEntry.ImageInfoValid)
        {
            VerbOut("Unable to read image header for");

            if (ModEntry.UnicodeNamePtr)
            {
                VerbOut(" %ls", ModEntry.NamePtr);
            }
            else
            {
                VerbOut(" %s", ModEntry.NamePtr);
            }

            VerbOut(" at %s\n",
                   FormatAddr64(ModEntry.Base));
        }


        if (ModEntry.NameLength > (MAX_IMAGE_PATH - 1) *
            (ModEntry.UnicodeNamePtr ? sizeof(WCHAR) : sizeof(CHAR)))
        {
            ErrOut("Module list is corrupt.");
            if (IS_KERNEL_TARGET())
            {
                ErrOut("  Check your kernel symbols.\n");
            }
            else
            {
                ErrOut("  Loader list may be invalid\n");
            }
            break;
        }


        // If this entry has no name just skip it.
        if ((ModEntry.NamePtr == NULL) ||
            (ModEntry.UnicodeNamePtr && ModEntry.NameLength == 0))
        {
            ErrOut("  Module List has empty entry in it - skipping\n");
            continue;
        }

        //
        // Are we looking for a module at a specific address ?
        //

        if (AddrLoad)
        {
            if (Address < ModEntry.Base ||
                Address >= ModEntry.Base + ModEntry.Size)
            {
                continue;
            }
        }

        if (ModEntry.UnicodeNamePtr)
        {
            if (!WideCharToMultiByte(CP_ACP,
                                     0,
                                     (PWSTR)ModEntry.NamePtr,
                                     ModEntry.NameLength / sizeof(WCHAR),
                                     AnsiString,
                                     sizeof(AnsiString),
                                     NULL,
                                     NULL))
            {
                WarnOut("Unable to convert Unicode string %ls to Ansi\n",
                        ModEntry.NamePtr);
                continue;
            }

            ModEntry.NamePtr = AnsiString;
            ModEntry.UnicodeNamePtr = 0;
            AnsiString[ModEntry.NameLength / sizeof(WCHAR)] = 0;
        }

        //
        // If we are loading a specific module:
        //
        // If the Module is NT, we take the first module in the list as it is
        // guaranteed to be the kernel.  Reset the Base address if it was
        // not set.
        //
        // Otherwise, actually compare the strings and continue if they don't
        // match
        //

        if (SpecificModule)
        {
            if (!UserModeList && _stricmp( SpecificModule, KERNEL_MODULE_NAME ) == 0)
            {
                if (!KdDebuggerData.KernBase)
                {
                    KdDebuggerData.KernBase = ModEntry.Base;
                }
            }
            else
            {
                if (!MatchPathTails(SpecificModule, ModEntry.NamePtr))
                {
                    continue;
                }
            }
        }

        PCSTR NamePtrTail = PathTail(ModEntry.NamePtr);
        
        if (PrintImageListOnly)
        {
            PCHAR Time;

            //
            // The timestamp in minidumps was corrupt until NT5 RC3
            // The timestamp could also be invalid because it was paged out
            //    in which case it's value is UNKNOWN_TIMESTAMP.

            if (IS_KERNEL_TRIAGE_DUMP() &&
                (g_ActualSystemVersion > NT_SVER_START &&
                 g_ActualSystemVersion <= NT_SVER_W2K_RC3))
            {
                Time = "";
            }

            Time = TimeToStr(ModEntry.TimeDateStamp);

            if (UseDebuggerModuleList)
            {
                dprintf("%s %6lx (%4ld k) %12s  %s\n",
                        FormatAddr64(ModEntry.Base), ModEntry.Size,
                        KBYTES(ModEntry.Size), NamePtrTail,
                        Time);
            }
            else
            {
                dprintf("%s %6lx (%4ld k) %5lx (%3ld k) %12s  %s\n",
                        FormatAddr64(ModEntry.Base),
                        ModEntry.SizeOfCode, KBYTES(ModEntry.SizeOfCode),
                        ModEntry.SizeOfData, KBYTES(ModEntry.SizeOfData),
                        NamePtrTail, Time);
            }
        }
        else
        {
            //
            // Don't bother reloading the kernel if we are not specifically
            // asked since we know those symbols we reloaded by the
            // VerifyKernel call.
            //

            if (!SpecificModule && !UserModeList &&
                KdDebuggerData.KernBase == ModEntry.Base)
            {
                continue;
            }

            if (ReallyVerbose)
            {
                dprintf("AddImage: %s\n DllBase  = %s\n Size     = %08x\n "
                        "Checksum = %08x\n TimeDateStamp = %08x\n",
                        ModEntry.NamePtr, FormatAddr64(ModEntry.Base),
                        ModEntry.Size, ModEntry.CheckSum,
                        ModEntry.TimeDateStamp);
            }
            else
            {
                if (!SpecificModule)
                {
                    dprintf(".");
                }
            }

            if (Address)
            {
                ModEntry.Base = Address;
            }

            if (AddImage(&ModEntry, ForceSymbolLoad) == NULL)
            {
                RetStatus = E_FAIL;
            }
        }

        if (SpecificModule)
        {
            free( SpecificModule );
            goto Notify;
        }

        if (AddrLoad)
        {
            goto Notify;
        }
    }

    if (UseDebuggerModuleList || IS_KERNEL_TARGET() || UserModeList)
    {
        // print newline after all the '.'
        dprintf("\n");
    }

    if (!UseDebuggerModuleList && !UserModeList && SpecificModule == NULL)
    {
        // If we just reloaded the kernel modules
        // go through the unloaded module list.
        if (!PrintImageListOnly)
        {
            dprintf("Loading unloaded module list\n");
        }
        ListUnloadedModules(PrintImageListOnly ?
                            LUM_OUTPUT : LUM_OUTPUT_TERSE, NULL);
    }

    //
    // If we got to the end of the kernel symbols, try to load the
    // user mode symbols for the current process.
    //

    if (!UseDebuggerModuleList    &&
        (UserModeList == FALSE)   &&
        (LoadUserSymbols == TRUE) &&
        SUCCEEDED(Status))
    {
        if (!AddrLoad && !SpecificModule)
        {
            dprintf("Loading User Symbols\n");
        }

        UserModeList = TRUE;
        ModIter = GetModuleInfo(UserModeList);
        if (ModIter != NULL && ModIter->Initialize() == S_OK)
        {
            goto LoadLoop;
        }
    }

    if (!SpecificModule && !Wow64ModLoaded) 
    {
        ModIter = &g_NtWow64UserModuleIterator;
        
        Wow64ModLoaded = TRUE;
        if (ModIter->Initialize() == S_OK)
        {
            dprintf("Loading Wow64 Symbols\n");
            goto LoadLoop;
        }
    }

    // In the multiple load situation we always return OK
    // since an error wouldn't tell you much about what
    // actually occurred.
    // Specific loads that haven't already been handled are checked
    // right after this.
    RetStatus = S_OK;
    
    //
    // If we still have not managed to load a named file, just pass the name
    // and the address and hope for the best.
    //

    if (SpecificModule)
    {
        WarnOut("\nModule \"%s\" was not found in the module list.\n",
                SpecificModule);
        WarnOut("Debugger will attempt to load module \"%s\" "
                "by guessing the base address.\n\n", SpecificModule);
        WarnOut("Please provide the full image name, including the "
                "extension (i.e. kernel32.dll) for more reliable results.\n");

        ZeroMemory(&ModEntry, sizeof(ModEntry));

        ModEntry.NamePtr       = SpecificModule,
        ModEntry.Base          = Address;
        ModEntry.Size          = ImageSize;

        if (AddImage(&ModEntry, TRUE) == NULL)
        {
            ErrOut("Unable to load module at %s\n", FormatAddr64(Address));
            RetStatus = E_FAIL;
        }

        free(SpecificModule);
    }

 Notify:
    // If we've gotten this far we've done one or more reloads
    // and postponed notifications.  Do them now that all the work
    // has been done.
    g_EngNotify--;
    if (SUCCEEDED(RetStatus))
    {
        NotifyChangeSymbolState(DEBUG_CSS_LOADS | DEBUG_CSS_UNLOADS, 0,
                                g_CurrentProcess);
    }

    if (IgnoreSignature)
    {
        SymSetOptions(ReloadSymOptions);
    }

    if (ModEntry.DebugHeader)
    {
        free(ModEntry.DebugHeader);
    }

    return RetStatus;

 FreeSpecMod:
    free(SpecificModule);
    return RetStatus;
}

ULONG64
TargetInfo::GetCurrentTimeDateN(void)
{
    // No information.
    return 0;
}
 
ULONG64
TargetInfo::GetCurrentSystemUpTimeN(void)
{
    // No information.
    return 0;
}
 
ULONG64
TargetInfo::GetProcessUpTimeN(ULONG64 Process)
{
    // No information.
    return 0;
}
 
void
TargetInfo::GetKdVersion(void)
{
    BOOL Ptr64;
    
    if (GetTargetKdVersion(&g_KdVersion) != S_OK)
    {
        ErrOut("Debugger can't get KD version information\n");
        memset(&g_KdVersion, 0, sizeof(g_KdVersion));
        return;
    }

    if ((g_KdVersion.MajorVersion >> 8) >= KD_MAJOR_COUNT)
    {
        ErrOut("KD version has unknown kernel type\n");
        memset(&g_KdVersion, 0, sizeof(g_KdVersion));
        return;
    }

    if (MachineTypeIndex(g_KdVersion.MachineType) == MACHIDX_COUNT)
    {
        ErrOut("KD version has unknown processor architecture\n");
        memset(&g_KdVersion, 0, sizeof(g_KdVersion));
        return;
    }

    Ptr64 =
        ((g_KdVersion.Flags & DBGKD_VERS_FLAG_PTR64) == DBGKD_VERS_FLAG_PTR64);
    if (g_KdVersion.Flags & DBGKD_VERS_FLAG_NOMM)
    {
        g_VirtualCache.m_DecodePTEs = FALSE;
    }

    // Reloads cause the version to be retrieved but
    // we don't want to completely reinitialize machines
    // in that case as some settings can be lost.  Only
    // reinitialize if there's a need to do so.
    BOOL MustInitializeMachines =
        g_TargetMachineType != g_KdVersion.MachineType ||
        g_TargetMachine == NULL;
    
    g_TargetMachineType = g_KdVersion.MachineType;
    g_TargetBuildNumber = g_KdVersion.MinorVersion;
    g_TargetCheckedBuild = g_KdVersion.MajorVersion & 0xFF;

    if ((g_TargetMachineType == IMAGE_FILE_MACHINE_ALPHA) && Ptr64)
    {
        g_TargetMachineType = IMAGE_FILE_MACHINE_AXP64;
        g_KdVersion.MachineType = IMAGE_FILE_MACHINE_AXP64;
    }

    //
    // Determine the OS running.
    //
    
    switch(g_KdVersion.MajorVersion >> 8)
    {
    case KD_MAJOR_NT:
        g_TargetPlatformId = VER_PLATFORM_WIN32_NT;
        g_ActualSystemVersion = NtBuildToSystemVersion(g_TargetBuildNumber);
        g_SystemVersion = g_ActualSystemVersion;
        break;

    case KD_MAJOR_XBOX:
        g_TargetPlatformId = VER_PLATFORM_WIN32_NT;
        g_ActualSystemVersion = XBOX_SVER_1;
        g_SystemVersion = NT_SVER_W2K;
        break;

    case KD_MAJOR_BIG:
        g_TargetPlatformId = VER_PLATFORM_WIN32_NT;
        g_ActualSystemVersion = BIG_SVER_1;
        g_SystemVersion = NT_SVER_W2K;
        break;

    case KD_MAJOR_EXDI:
        g_TargetPlatformId = VER_PLATFORM_WIN32_NT;
        g_ActualSystemVersion = EXDI_SVER_1;
        g_SystemVersion = NT_SVER_W2K;
        break;

    case KD_MAJOR_NTBD:
        // Special mode for the NT boot debugger where
        // the full system hasn't started yet.
        g_TargetPlatformId = VER_PLATFORM_WIN32_NT;
        g_ActualSystemVersion = NTBD_SVER_W2K_WHISTLER;
        g_SystemVersion = NtBuildToSystemVersion(g_TargetBuildNumber);
        break;
        
    case KD_MAJOR_EFI:
        g_TargetPlatformId = VER_PLATFORM_WIN32_NT;
        g_ActualSystemVersion = EFI_SVER_1;
        g_SystemVersion = NT_SVER_W2K_WHISTLER;
        break;
    }

    //
    // Pre-Whistler kernels didn't set these values so
    // default them appropriately.
    //
    
    g_KdMaxPacketType = g_KdVersion.MaxPacketType;
    if (g_SystemVersion < NT_SVER_W2K_WHISTLER ||
        g_KdMaxPacketType == 0 ||
        g_KdMaxPacketType > PACKET_TYPE_MAX)
    {
        g_KdMaxPacketType = PACKET_TYPE_KD_CONTROL_REQUEST + 1;
    }
    
    g_KdMaxStateChange = g_KdVersion.MaxStateChange +
        DbgKdMinimumStateChange;
    if (g_SystemVersion < NT_SVER_W2K_WHISTLER ||
        g_KdMaxStateChange == DbgKdMinimumStateChange ||
        g_KdMaxStateChange > DbgKdMaximumStateChange)
    {
        g_KdMaxStateChange = DbgKdLoadSymbolsStateChange + 1;
    }

    g_KdMaxManipulate = g_KdVersion.MaxManipulate +
        DbgKdMinimumManipulate;
    if (g_SystemVersion < NT_SVER_W2K_WHISTLER ||
        g_KdMaxManipulate == DbgKdMinimumManipulate ||
        g_KdMaxManipulate > DbgKdMaximumManipulate)
    {
        g_KdMaxManipulate = DbgKdCheckLowMemoryApi + 1;
    }

    if (MustInitializeMachines)
    {
        InitializeMachines(g_TargetMachineType);
    }

    KdOut("Target MajorVersion       %08lx\n", g_KdVersion.MajorVersion);
    KdOut("Target MinorVersion       %08lx\n", g_KdVersion.MinorVersion);
    KdOut("Target ProtocolVersion    %08lx\n", g_KdVersion.ProtocolVersion);
    KdOut("Target Flags              %08lx\n", g_KdVersion.Flags);
    KdOut("Target MachineType        %08lx\n", g_KdVersion.MachineType);
    KdOut("Target MaxPacketType      %x\n", g_KdVersion.MaxPacketType);
    KdOut("Target MaxStateChange     %x\n", g_KdVersion.MaxStateChange);
    KdOut("Target MaxManipulate      %x\n", g_KdVersion.MaxManipulate);
    KdOut("Target KernBase           %s\n",
          FormatAddr64(g_KdVersion.KernBase));
    KdOut("Target PsLoadedModuleList %s\n",
          FormatAddr64(g_KdVersion.PsLoadedModuleList));
    KdOut("Target DebuggerDataList   %s\n",
          FormatAddr64(g_KdVersion.DebuggerDataList));

    dprintf("Connected to %s %d %s target, ptr64 %s\n",
            SystemVersionName(g_ActualSystemVersion), g_TargetBuildNumber,
            g_TargetMachine->m_FullName,
            g_TargetMachine->m_Ptr64 ? "TRUE" : "FALSE");
}

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

HRESULT
LiveKernelTargetInfo::Initialize(void)
{
    InitSelCache();
    return S_OK;
}

HRESULT
LiveKernelTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    ULONG64 BugCheckData;
    ULONG64 Data[5];
    HRESULT Status;
    ULONG Read;

    if (!(BugCheckData = KdDebuggerData.KiBugcheckData))
    {
        if (!GetOffsetFromSym("nt!KiBugCheckData", &BugCheckData, NULL) ||
            !BugCheckData)
        {
            ErrOut("Unable to resolve nt!KiBugCheckData\n");
            return E_NOINTERFACE;
        }
    }

    if (g_TargetMachine->m_Ptr64)
    {
        Status = ReadVirtual(BugCheckData, Data, sizeof(Data), &Read);
    }
    else
    {
        ULONG i;
        ULONG Data32[5];

        Status = ReadVirtual(BugCheckData, Data32, sizeof(Data32), &Read);
        Read *= 2;
        for (i = 0; i < DIMA(Data); i++)
        {
            Data[i] = EXTEND64(Data32[i]);
        }
    }

    if (Status != S_OK || Read != sizeof(Data))
    {
        ErrOut("Unable to read KiBugCheckData\n");
        return Status == S_OK ? E_FAIL : Status;
    }

    *Code = (ULONG)Data[0];
    memcpy(Args, Data + 1, sizeof(Data) - sizeof(ULONG64));
    return S_OK;
}

ULONG64
LiveKernelTargetInfo::GetCurrentTimeDateN(void)
{
    ULONG64 TimeDate;
    
    if (ReadSharedUserTimeDateN(&TimeDate) == S_OK)
    {
        return TimeDate;
    }
    else
    {
        return 0;
    }
}

ULONG64
LiveKernelTargetInfo::GetCurrentSystemUpTimeN(void)
{
    ULONG64 UpTime;
    
    if (ReadSharedUserUpTimeN(&UpTime) == S_OK)
    {
        return UpTime;
    }
    else
    {
        return 0;
    }
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

HRESULT
ConnLiveKernelTargetInfo::Initialize(void)
{
    HRESULT Status = DbgKdConnectAndInitialize(m_ConnectOptions);

    if (Status == S_OK)
    {
        Status = LiveKernelTargetInfo::Initialize();
    }

    return Status;
}

void
ConnLiveKernelTargetInfo::Uninitialize(void)
{
    if (g_DbgKdTransport != NULL)
    {
        g_DbgKdTransport->Uninitialize();
        g_DbgKdTransport = NULL;
    }
    
    LiveKernelTargetInfo::Uninitialize();
}

HRESULT
ConnLiveKernelTargetInfo::GetTargetKdVersion(PDBGKD_GET_VERSION64 Version)
{
    NTSTATUS Status = DbgKdGetVersion(Version);
    return CONV_NT_STATUS(Status);
}

HRESULT
ConnLiveKernelTargetInfo::RequestBreakIn(void)
{
    // Tell the waiting thread to break in.
    g_DbgKdTransport->m_BreakIn = TRUE;
    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::Reboot(void)
{
    DbgKdReboot();
    ResetConnection(DEBUG_SESSION_REBOOT);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

HRESULT
LocalLiveKernelTargetInfo::Initialize(void)
{
    DBGKD_GET_VERSION64 Version;

    // Do a quick check to see if this kernel even
    // supports the necessary debug services.
    if (!NT_SUCCESS(g_NtDllCalls.
                    NtSystemDebugControl(SysDbgQueryVersion, NULL, 0,
                                         &Version, sizeof(Version), NULL)))
    {
        ErrOut("The system does not support local kernel debugging.\n");
        ErrOut("Local kernel debugging requires Windows XP, Administrative\n"
               "privileges, and is not supported by WOW64.\n");
        return E_NOTIMPL;
    }

    //
    // Set this right here since we know kernel debugging only works on
    // recent systems using the 64 bit protocol.
    //

    DbgKdApi64 = TRUE;

    return LiveKernelTargetInfo::Initialize();
}

HRESULT
LocalLiveKernelTargetInfo::GetTargetKdVersion(PDBGKD_GET_VERSION64 Version)
{
    NTSTATUS Status = g_NtDllCalls.
        NtSystemDebugControl(SysDbgQueryVersion, NULL, 0,
                             Version, sizeof(*Version), NULL);
    return CONV_NT_STATUS(Status);
}

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

HRESULT
ExdiNotifyRunChange::Initialize(void)
{
    m_Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_Event == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

void
ExdiNotifyRunChange::Uninitialize(void)
{
    if (m_Event != NULL)
    {
        CloseHandle(m_Event);
        m_Event = NULL;
    }
}

STDMETHODIMP
ExdiNotifyRunChange::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    if (DbgIsEqualIID(IID_IUnknown, InterfaceId) ||
        DbgIsEqualIID(__uuidof(IeXdiClientNotifyRunChg), InterfaceId))
    {
        *Interface = this;
        return S_OK;
    }

    *Interface = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
ExdiNotifyRunChange::AddRef(
    THIS
    )
{
    return 1;
}

STDMETHODIMP_(ULONG)
ExdiNotifyRunChange::Release(
    THIS
    )
{
    return 0;
}

STDMETHODIMP
ExdiNotifyRunChange::NotifyRunStateChange(RUN_STATUS_TYPE ersCurrent,
                                          HALT_REASON_TYPE ehrCurrent,
                                          ADDRESS_TYPE CurrentExecAddress,
                                          DWORD dwExceptionCode)
{
    if (ersCurrent == rsRunning)
    {
        // We're waiting for things to stop so ignore this.
        return S_OK;
    }

    m_HaltReason = ehrCurrent;
    m_ExecAddress = CurrentExecAddress;
    m_ExceptionCode = dwExceptionCode;
    SetEvent(m_Event);

    return S_OK;
}

class ExdiParams : public ParameterStringParser
{
public:
    virtual ULONG GetNumberParameters(void)
    {
        // No need to get.
        return 0;
    }
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value)
    {
    }

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    CLSID m_Clsid;
    EXDI_KD_SUPPORT m_KdSupport;
    BOOL m_ForceX86;
};

void
ExdiParams::ResetParameters(void)
{
    ZeroMemory(&m_Clsid, sizeof(m_Clsid));
    m_KdSupport = EXDI_KD_NONE;
    m_ForceX86 = FALSE;
}

BOOL
ScanExdiDriverList(PCSTR Name, LPCLSID Clsid)
{
    char Pattern[MAX_PARAM_VALUE];

    strncpy(Pattern, Name, sizeof(Pattern));
    Pattern[MAX_PARAM_VALUE-1] = 0;

    _strupr(Pattern);

    HKEY ListKey;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\eXdi\\DriverList", 0,
                     KEY_ALL_ACCESS, &ListKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    ULONG Index = 0;
    BOOL Status = FALSE;
    char ValName[MAX_PARAM_VALUE];
    WCHAR WideValName[MAX_PARAM_VALUE];
    ULONG NameLen, ValLen;
    ULONG Type;
    char Value[MAX_PARAM_VALUE];

    for (;;)
    {
        NameLen = sizeof(ValName);
        ValLen = sizeof(Value);
        if (RegEnumValue(ListKey, Index, ValName, &NameLen, NULL,
                         &Type, (PBYTE)Value, &ValLen) != ERROR_SUCCESS)
        {
            break;
        }

        if (Type == REG_SZ &&
            MatchPattern(Value, Pattern) &&
            MultiByteToWideChar(CP_ACP, 0, ValName, -1, WideValName,
                                sizeof(WideValName) / sizeof(WCHAR)) > 0 &&
            g_Ole32Calls.CLSIDFromString(WideValName, Clsid) == S_OK)
        {
            Status = TRUE;
            break;
        }

        Index++;
    }

    RegCloseKey(ListKey);
    return Status;
}

BOOL
ExdiParams::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_strcmpi(Name, "CLSID"))
    {
        WCHAR WideValue[MAX_PARAM_VALUE];

        if (MultiByteToWideChar(CP_ACP, 0, Value, -1, WideValue,
                                sizeof(WideValue) / sizeof(WCHAR)) == 0)
        {
            return FALSE;
        }
        return g_Ole32Calls.CLSIDFromString(WideValue, &m_Clsid) == S_OK;
    }
    else if (!_strcmpi(Name, "Desc"))
    {
        return ScanExdiDriverList(Value, &m_Clsid);
    }
    else if (!_strcmpi(Name, "ForceX86"))
    {
        m_ForceX86 = TRUE;
    }
    else if (!_strcmpi(Name, "Kd"))
    {
        if (!Value)
        {
            return FALSE;
        }
        
        if (!_strcmpi(Value, "Ioctl"))
        {
            m_KdSupport = EXDI_KD_IOCTL;
        }
        else if (!_strcmpi(Value, "GsPcr"))
        {
            m_KdSupport = EXDI_KD_GS_PCR;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

PCSTR g_ExdiGroupNames[] =
{
    "exdi",
};

HRESULT
ExdiLiveKernelTargetInfo::Initialize(void)
{
    HRESULT Status;

    // Load ole32.dll so we can call CoCreateInstance.
    if ((Status = InitDynamicCalls(&g_Ole32CallsDesc)) != S_OK)
    {
        return Status;
    }

    ULONG Group;

    Group = ParameterStringParser::
        GetParser(m_ConnectOptions, DIMA(g_ExdiGroupNames), g_ExdiGroupNames);
    if (Group == PARSER_INVALID)
    {
        return E_INVALIDARG;
    }

    ExdiParams Params;

    Params.ResetParameters();
    if (!Params.ParseParameters(m_ConnectOptions))
    {
        return E_INVALIDARG;
    }

    m_KdSupport = Params.m_KdSupport;

    if ((Status = g_Ole32Calls.
         CoInitializeEx(NULL, COINIT_MULTITHREADED)) != S_OK)
    {
        return Status;
    }
    if ((Status = g_Ole32Calls.CoCreateInstance(Params.m_Clsid, NULL,
                                                CLSCTX_LOCAL_SERVER,
                                                __uuidof(IeXdiServer),
                                                (PVOID*)&m_Server)) != S_OK)
    {
        goto EH_CoInit;
    }

    if ((Status = m_Server->GetTargetInfo(&m_GlobalInfo)) != S_OK)
    {
        goto EH_Server;
    }

    if (Params.m_ForceX86 ||
        m_GlobalInfo.TargetProcessorFamily == PROCESSOR_FAMILY_X86)
    {
        if (!Params.m_ForceX86 &&
            (Status = m_Server->
             QueryInterface(__uuidof(IeXdiX86_64Context),
                            (PVOID*)&m_Context)) == S_OK)
        {
            m_ExpectedMachine = IMAGE_FILE_MACHINE_AMD64;
        }
        else if ((Status = m_Server->
                  QueryInterface(__uuidof(IeXdiX86Context),
                                 (PVOID*)&m_Context)) == S_OK)
        {
            m_ExpectedMachine = IMAGE_FILE_MACHINE_I386;
        }
        else
        {
            goto EH_Server;
        }
    }
    else
    {
        Status = E_NOINTERFACE;
        goto EH_Server;
    }

    DWORD HwCode, SwCode;
    
    if ((Status = m_Server->GetNbCodeBpAvail(&HwCode, &SwCode)) != S_OK)
    {
        goto EH_Context;
    }

    // We'd prefer to use software code breakpoints for our
    // software code breakpoints so that hardware resources
    // aren't consumed for a breakpoint we don't need to
    // use hardware for.  However, some servers, such as
    // the x86-64 SimNow implementation, do not support
    // software breakpoints.
    // Also, if the number of hardware breakpoints is
    // unbounded, go ahead and let the server choose.
    // SimNow advertises -1 -1 for some reason and
    // this is necessary to get things to work.

    if (SwCode > 0 && HwCode != (DWORD)-1)
    {
        m_CodeBpType = cbptSW;
    }
    else
    {
        m_CodeBpType = cbptAlgo;
    }
    
    if ((Status = m_RunChange.Initialize()) != S_OK)
    {
        goto EH_Context;
    }

    if ((Status = LiveKernelTargetInfo::Initialize()) != S_OK)
    {
        goto EH_RunChange;
    }

    m_ContextValid = 0;
    return S_OK;

 EH_RunChange:
    m_RunChange.Uninitialize();
 EH_Context:
    RELEASE(m_Context);
 EH_Server:
    RELEASE(m_Server);
 EH_CoInit:
    g_Ole32Calls.CoUninitialize();
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ThreadInitialize(void)
{
    return g_Ole32Calls.CoInitializeEx(NULL, COINIT_MULTITHREADED);
}

void
ExdiLiveKernelTargetInfo::ThreadUninitialize(void)
{
    g_Ole32Calls.CoUninitialize();
}

void
ExdiLiveKernelTargetInfo::Uninitialize(void)
{
    m_RunChange.Uninitialize();
    RELEASE(m_Context);
    RELEASE(m_Server);
    g_Ole32Calls.CoUninitialize();
}

#define EXDI_IOCTL_GET_KD_VERSION ((ULONG)'VDKG')

HRESULT
ExdiLiveKernelTargetInfo::GetTargetKdVersion(PDBGKD_GET_VERSION64 Version)
{
    switch(m_KdSupport)
    {
    case EXDI_KD_IOCTL:
        //
        // User has indicated the target supports the
        // KD version ioctl.
        //

        ULONG Command;
        ULONG Retrieved;
        HRESULT Status;

        Command = EXDI_IOCTL_GET_KD_VERSION;
        if ((Status = m_Server->Ioctl(sizeof(Command), (PBYTE)&Command,
                                      sizeof(*Version), &Retrieved,
                                      (PBYTE)Version)) != S_OK)
        {
            return Status;
        }
        if (Retrieved != sizeof(*Version))
        {
            return E_FAIL;
        }

        // This mode implies a recent kernel so we can
        // assume 64-bit kd.
        DbgKdApi64 = TRUE;
        break;

    case EXDI_KD_GS_PCR:
        //
        // User has indicated that a version of NT
        // is running and that the PCR can be accessed
        // through GS.  Look up the version block from
        // the PCR.
        //

        if (m_ExpectedMachine == IMAGE_FILE_MACHINE_AMD64)
        {
            ULONG64 KdVer;
            ULONG Done;
            
            if ((Status = g_Amd64Machine.
                 GetExdiContext(m_Context, &m_ContextData)) != S_OK)
            {
                return Status;
            }
            if ((Status = m_Server->
                 ReadVirtualMemory(m_ContextData.Amd64Context.
                                   DescriptorGs.SegBase +
                                   FIELD_OFFSET(AMD64_KPCR, KdVersionBlock),
                                   sizeof(KdVer), 8, (PBYTE)&KdVer,
                                   &Done)) != S_OK)
            {
                return Status;
            }
            if (Done != sizeof(KdVer))
            {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }
            if ((Status = m_Server->
                 ReadVirtualMemory(KdVer, sizeof(*Version), 8, (PBYTE)Version,
                                   &Done)) != S_OK)
            {
                return Status;
            }
            if (Done != sizeof(*Version))
            {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }

            // This mode implies a recent kernel so we can
            // assume 64-bit kd.
            DbgKdApi64 = TRUE;

            // Update the version block's Simulation field to
            // indicate that this is a simulated execution.
            Version->Simulation = DBGKD_SIMULATION_EXDI;
            if ((Status = m_Server->
                 WriteVirtualMemory(KdVer, sizeof(*Version), 8, (PBYTE)Version,
                                    &Done)) != S_OK)
            {
                return Status;
            }
            if (Done != sizeof(*Version))
            {
                return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            }
        }
        else
        {
            return E_INVALIDARG;
        }
        break;

    case EXDI_KD_NONE:
        //
        // Fake up a version structure.
        //

        Version->MajorVersion = KD_MAJOR_EXDI << 8;
        Version->ProtocolVersion = 0;
        Version->Flags = DBGKD_VERS_FLAG_PTR64 | DBGKD_VERS_FLAG_NOMM;
        Version->MachineType = (USHORT)m_ExpectedMachine;
        Version->KernBase = 0;
        Version->PsLoadedModuleList = 0;
        Version->DebuggerDataList = 0;
        break;
    }

    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::RequestBreakIn(void)
{
    return m_Server->Halt();
}

HRESULT
ExdiLiveKernelTargetInfo::Reboot(void)
{
    HRESULT Status = m_Server->Reboot();
    if (Status == S_OK)
    {
        ResetConnection(DEBUG_SESSION_REBOOT);
    }
    return Status;
}

//----------------------------------------------------------------------------
//
// UserTargetInfo miscellaneous methods.
//
// Data space methods and system objects methods are elsewhere.
//
//----------------------------------------------------------------------------

HRESULT
UserTargetInfo::Initialize(void)
{
    // Nothing to do right now.
    return S_OK;
}

void
UserTargetInfo::Uninitialize(void)
{
    RELEASE(m_Services);
}

HRESULT
UserTargetInfo::GetImageVersionInformation(PCSTR ImagePath,
                                           ULONG64 ImageBase,
                                           PCSTR Item,
                                           PVOID Buffer,
                                           ULONG BufferSize,
                                           PULONG VerInfoSize)
{
    return m_Services->
        GetFileVersionInformation(ImagePath, Item,
                                  Buffer, BufferSize, VerInfoSize);
}

ULONG64
UserTargetInfo::GetCurrentTimeDateN(void)
{
    ULONG64 TimeDate;

    if (m_Services->GetCurrentTimeDateN(&TimeDate) == S_OK)
    {
        return TimeDate;
    }
    else
    {
        return 0;
    }
}

ULONG64
UserTargetInfo::GetCurrentSystemUpTimeN(void)
{
    ULONG64 UpTime;

    if (m_Services->GetCurrentSystemUpTimeN(&UpTime) == S_OK)
    {
        return UpTime;
    }
    else
    {
        return 0;
    }
}

ULONG64
UserTargetInfo::GetProcessUpTimeN(ULONG64 Process)
{
    ULONG64 UpTime;

    if (m_Services->GetProcessUpTimeN(Process, &UpTime) == S_OK)
    {
        return UpTime;
    }
    else
    {
        return 0;
    }
}

HRESULT
UserTargetInfo::RequestBreakIn(void)
{
    PPROCESS_INFO Process = g_CurrentProcess;
    if (Process == NULL)
    {
        Process = g_ProcessHead;
        if (Process == NULL)
        {
            return E_UNEXPECTED;
        }
    }

    return m_Services->RequestBreakIn(Process->FullHandle);
}

//----------------------------------------------------------------------------
//
// Base TargetInfo methods that trivially fail.
//
//----------------------------------------------------------------------------

#define UNEXPECTED_VOID(Class, Method, Args)                    \
void                                                            \
Class::Method Args                                              \
{                                                               \
    ErrOut("TargetInfo::" #Method " is not available in the current debug session\n"); \
}

#define UNEXPECTED_HR(Class, Method, Args)                      \
HRESULT                                                         \
Class::Method Args                                              \
{                                                               \
    ErrOut("TargetInfo::" #Method " is not available in the current debug session\n"); \
    return E_UNEXPECTED;                                        \
}

#define UNEXPECTED_ULONG64(Class, Method, Val, Args)            \
ULONG64                                                         \
Class::Method Args                                              \
{                                                               \
    ErrOut("TargetInfo::" #Method " is not available in the current debug session\n"); \
    return Val;                                                 \
}

TargetInfo g_UnexpectedTarget;

UNEXPECTED_HR(TargetInfo, Initialize, (void))
UNEXPECTED_HR(TargetInfo, ReadVirtual, (
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WriteVirtual, (
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, ReadPhysical, (
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WritePhysical, (
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, ReadControl, (
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WriteControl, (
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, ReadIo, (
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WriteIo, (
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, ReadMsr, (
    IN ULONG Msr,
    OUT PULONG64 Value
    ))
UNEXPECTED_HR(TargetInfo, WriteMsr, (
    IN ULONG Msr,
    IN ULONG64 Value
    ))
UNEXPECTED_HR(TargetInfo, ReadBusData, (
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    ))
UNEXPECTED_HR(TargetInfo, WriteBusData, (
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    ))
UNEXPECTED_HR(TargetInfo, CheckLowMemory, (
    ))
UNEXPECTED_HR(TargetInfo, ReadHandleData, (
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    ))
UNEXPECTED_HR(TargetInfo, GetTargetContext, (
    ULONG64 Thread,
    PVOID Context
    ))
UNEXPECTED_HR(TargetInfo, SetTargetContext, (
    ULONG64 Thread,
    PVOID Context
    ))
UNEXPECTED_HR(TargetInfo, GetThreadIdByProcessor, (
    IN ULONG Processor,
    OUT PULONG Id
    ))
UNEXPECTED_HR(TargetInfo, GetThreadInfoDataOffset, (
    PTHREAD_INFO Thread,
    ULONG64 ThreadHandle,
    PULONG64 Offset))
UNEXPECTED_HR(TargetInfo, GetProcessInfoDataOffset, (
    PTHREAD_INFO Thread,
    ULONG Processor,
    ULONG64 ThreadData,
    PULONG64 Offset))
UNEXPECTED_HR(TargetInfo, GetThreadInfoTeb, (
    PTHREAD_INFO Thread,
    ULONG Processor,
    ULONG64 ThreadData,
    PULONG64 Offset))
UNEXPECTED_HR(TargetInfo, GetProcessInfoPeb, (
    PTHREAD_INFO Thread,
    ULONG Processor,
    ULONG64 ThreadData,
    PULONG64 Offset))
UNEXPECTED_HR(TargetInfo, GetSelDescriptor, (
    MachineInfo* Machine,
    ULONG64 Thread,
    ULONG Selector,
    PDESCRIPTOR64 Desc))
UNEXPECTED_HR(TargetInfo, GetTargetKdVersion, (
    PDBGKD_GET_VERSION64 Version))
UNEXPECTED_HR(TargetInfo, ReadBugCheckData, (
    PULONG Code, ULONG64 Args[4]))
UNEXPECTED_HR(TargetInfo, GetExceptionContext, (
    PCROSS_PLATFORM_CONTEXT Context))
UNEXPECTED_VOID(TargetInfo, InitializeWatchTrace, (
    void))
UNEXPECTED_VOID(TargetInfo, ProcessWatchTraceEvent, (
    PDBGKD_TRACE_DATA TraceData,
    ADDR PcAddr))
UNEXPECTED_HR(TargetInfo, WaitForEvent, (
    ULONG Flags,
    ULONG Timeout))
UNEXPECTED_HR(TargetInfo, RequestBreakIn, (void))
UNEXPECTED_HR(TargetInfo, Reboot, (void))
UNEXPECTED_HR(TargetInfo, InsertCodeBreakpoint, (
    PPROCESS_INFO Process,
    MachineInfo* Machine,
    PADDR Addr,
    PUCHAR StorageSpace))
UNEXPECTED_HR(TargetInfo, RemoveCodeBreakpoint, (
    PPROCESS_INFO Process,
    MachineInfo* Machine,
    PADDR Addr,
    PUCHAR StorageSpace))
UNEXPECTED_HR(TargetInfo, QueryMemoryRegion, (
    PULONG64 Handle,
    BOOL HandleIsOffset,
    PMEMORY_BASIC_INFORMATION64 Info))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\util.cpp ===
//----------------------------------------------------------------------------
//
// General utility functions.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include <sys\types.h>
#include <sys\stat.h>

#define DBG_MOD_LIST 0

PCSTR g_DefaultLogFileName = "dbgeng.log";
char  g_OpenLogFileName[MAX_PATH + 1];
BOOL  g_OpenLogFileAppended;
int   g_LogFile = -1;
BOOL  g_DisableErrorPrint;

ULONG
CheckUserInterrupt(void)
{
    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
    {
        g_EngStatus &= ~ENG_STATUS_USER_INTERRUPT;
        return TRUE;
    }
    return FALSE;
}

LONG
MappingExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
    static ULONG s_InPageErrors = 0;
    
    ULONG Code = ExceptionInfo->ExceptionRecord->ExceptionCode;
    if (Code == STATUS_IN_PAGE_ERROR)
    {
        if (++s_InPageErrors < 10)
        {
            if (s_InPageErrors % 2)
            {
                WarnOut("Ignore in-page I/O error\n");
                FlushCallbacks();
            }
            Sleep(500);
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

    s_InPageErrors = 0;
    ErrOut("Exception 0x%08x while accessing mapping\n", Code);
    FlushCallbacks();
    return EXCEPTION_EXECUTE_HANDLER;
}

void
RemoveDelChar(PSTR Buffer)
{
    PSTR BufferOld = Buffer;
    PSTR BufferNew = Buffer;

    while (*BufferOld)
    {
        if (*BufferOld == 0x7f)
        {
            if (BufferNew > Buffer)
            {
                BufferNew--;
            }
        }
        else if (*BufferOld == '\r' || *BufferOld == '\n')
        {
            *BufferNew++ = ' ';
        }
        else
        {
            *BufferNew++ = *BufferOld;
        }

        BufferOld++;
    }

    *BufferNew = '\0';
}

/*** error - error reporting and recovery
*
*   Purpose:
*       To output an error message with a location indicator
*       of the problem.  Once output, the command line is reset
*       and the command processor is restarted.
*
*   Input:
*       errorcode - number of error to output
*
*   Output:
*       None.
*
*   Exceptions:
*       Return is made via exception to start of command processor.
*
*************************************************************************/

static char g_Blanks[] =
                  "                                                  "
                  "                                                  "
                  "                                                  "
                  "                                                ^ ";
void
ReportError(
    ULONG errcode,
    PCSTR* DescPtr
    )
{
    ULONG Count = g_PromptLength + 1;
    PSTR Temp = g_CommandStart;
    PCSTR Desc;

    if (DescPtr != NULL)
    {
        // Clear out description so it doesn't get reused.
        Desc = *DescPtr;
        *DescPtr = NULL;
    }
    else
    {
        Desc = NULL;
    }
    
    if (g_DisableErrorPrint || 
        (g_CommandStart > g_CurCmd) ||
        (g_CommandStart + MAX_COMMAND < g_CurCmd))
    {
        goto SkipErrorPrint;
    }

    while (Temp < g_CurCmd)
    {
        if (*Temp++ == '\t')
        {
            Count = (Count + 7) & ~7;
        }
        else
        {
            Count++;
        }
    }

    ErrOut(&g_Blanks[sizeof(g_Blanks) - (Count + 1)]);

    if (Desc != NULL)
    {
        ErrOut("%s '%s'\n", Desc, g_CommandStart);
        goto SkipErrorPrint;
    }
    
    switch (errcode)
    {
    case OVERFLOW:
        ErrOut("Overflow");
        break;
    case SYNTAX:
        ErrOut("Syntax");
        break;
    case BADRANGE:
        ErrOut("Range");
        break;
    case VARDEF:
        ErrOut("Couldn't resolve");
        break;
    case EXTRACHARS:
        ErrOut("Extra character");
        break;
    case LISTSIZE:
        ErrOut("List size");
        break;
    case STRINGSIZE:
        ErrOut("String size");
        break;
    case MEMORY:
        ErrOut("Memory access");
        break;
    case BADREG:
        ErrOut("Bad register");
        break;
    case BADOPCODE:
        ErrOut("Bad opcode");
        break;
    case SUFFIX:
        ErrOut("Opcode suffix");
        break;
    case OPERAND:
        ErrOut("Operand");
        break;
    case ALIGNMENT:
        ErrOut("Alignment");
        break;
    case PREFIX:
        ErrOut("Opcode prefix");
        break;
    case DISPLACEMENT:
        ErrOut("Displacement");
        break;
    case BPLISTFULL:
        ErrOut("No breakpoint available");
        break;
    case BPDUPLICATE:
        ErrOut("Duplicate breakpoint");
        break;
    case UNIMPLEMENT:
        ErrOut("Unimplemented");
        break;
    case AMBIGUOUS:
        ErrOut("Ambiguous symbol");
        break;
    case BADTHREAD:
        ErrOut("Illegal thread");
        break;
    case BADPROCESS:
        ErrOut("Illegal process");
        break;
    case FILEREAD:
        ErrOut("File read");
        break;
    case LINENUMBER:
        ErrOut("Line number");
        break;
    case BADSEL:
        ErrOut("Bad selector");
        break;
    case BADSEG:
        ErrOut("Bad segment");
        break;
    case SYMTOOSMALL:
        ErrOut("Symbol only 1 character");
        break;
    case BPIONOTSUP:
        ErrOut("I/O breakpoints not supported");
        break;
    case NOTFOUND:
        ErrOut("No information found");
        break;
    case SESSIONNOTSUP:
        ErrOut("Operation not supported in current debug session");
        break;

    default:
        ErrOut("Unknown");
        break;
    }
    if (errcode != VARDEF && errcode != SESSIONNOTSUP)
    {
        ErrOut(" error in '%s'\n", g_CommandStart);
    }
    else
    {
        ErrOut(" '%s'\n", g_CommandStart);
    }

SkipErrorPrint:
    RaiseException(COMMAND_EXCEPTION_BASE + errcode, 0, 0, NULL);
}

/*** HexList - parse list of hex values
*
*   Purpose:
*       With the current location of the command string in
*       g_CurCmd, attempt to parse hex number of byte size
*       bytesize as bytes into the character array pointed by
*       parray.  The value pointed by *pcount contains the bytes
*       of the array filled.
*
*   Input:
*       g_CurCmd - start of command string
*       bytesize - size of items in bytes
*
*   Output:
*       parray - pointer to byte array to fill
*       pcount - pointer to value of bytes filled
*
*   Exceptions:
*       error exit:
*               LISTSIZE: too many items in list
*               SYNTAX: illegal separator of list items
*               OVERFLOW: item value too large
*
*************************************************************************/

void
HexList (PUCHAR parray, ULONG *pcount, ULONG bytesize)
{
    UCHAR    ch;
    ULONG64  value;
    ULONG    count = 0;
    ULONG    i;

    while ((ch = PeekChar()) != '\0' && ch != ';')
    {
        if (count == STRLISTSIZE)
        {
            error(LISTSIZE);
        }
        
        value = HexValue(bytesize);
        for (i = 0; i < bytesize; i++)
        {
            *parray++ = (char) value;
            value >>= 8;
        }
        count += bytesize;
    }
    *pcount = count;
}

ULONGLONG
HexValue (
    ULONG ByteSize
    )
{
    ULONGLONG Value;

    Value = GetExpression();

    // Reverse sign extension done by expression evaluator.
    if (ByteSize == 4 && !NeedUpper(Value))
    {
        Value = (ULONG)Value;
    }

    if (Value > (0xffffffffffffffffUI64 >> (8 * (8 - ByteSize))))
    {
        error(OVERFLOW);
    }

    return Value;
}

/*** AsciiList - process string for ascii list
*
*   Purpose:
*       With the current location of the command string in
*       g_CurCmd, attempt to parse ascii characters into the
*       character array pointed by parray.  The value pointed
*       by pcount contains the bytes of the array filled.  The
*       string must start with a double quote.  The string must
*       end with a quote or be at the end of the input line.
*
*   Input:
*       g_CurCmd - start of command string
*
*   Output:
*       parray - pointer to byte array to fill
*       pcount - pointer to value of bytes filled
*
*   Exceptions:
*       error exit:
*               STRINGSIZE: string length too long
*               SYNTAX: no leading double quote
*
*************************************************************************/

void
AsciiList(PSTR parray, ULONG *pcount)
{
    UCHAR    ch;
    ULONG    count = 0;

    if (PeekChar() != '"')
    {
        error(SYNTAX);
    }
    
    g_CurCmd++;

    do
    {
        ch = *g_CurCmd++;

        if (ch == '"')
        {
            count++;
            *parray++ = 0;
            break;
        }

        if (ch == '\0' || ch == ';')
        {
            g_CurCmd--;
            break;
        }

        if (count == STRLISTSIZE)
        {
            error(STRINGSIZE);
        }

        count++;
        *parray++ = ch;

    } while (1);

    *pcount = count;
}

PSTR
GetEscapedChar(PSTR Str, PCHAR Raw)
{
    switch(*Str)
    {
    case 0:
        error(SYNTAX);
    case '0':
        // Octal char value.
        *Raw = (char)strtoul(Str + 1, &Str, 8);
        break;
    case 'b':
        *Raw = '\b';
        Str++;
        break;
    case 'n':
        *Raw = '\n';
        Str++;
        break;
    case 'r':
        *Raw = '\r';
        Str++;
        break;
    case 't':
        *Raw = '\t';
        Str++;
        break;
    case 'x':
        // Hex char value.
        *Raw = (char)strtoul(Str + 1, &Str, 16);
        break;
    default:
        // Verbatim escape.
        *Raw = *Str;
        Str++;
        break;
    }

    return Str;
}

PSTR
BufferStringValue(PSTR* Buf, ULONG Flags, PCHAR Save)
{
    BOOL Quoted;
    PSTR Str;
    BOOL Escapes = FALSE;

    while (isspace(*(*Buf)))
    {
        (*Buf)++;
    }
    if (*(*Buf) == '"')
    {
        Quoted = TRUE;
        Str = ++(*Buf);
        // If the string is quoted it can always contain spaces.
        Flags &= ~STRV_SPACE_IS_SEPARATOR;
    }
    else
    {
        Quoted = FALSE;
        Str = *Buf;
        // Escaped characters can only be present in quoted strings.
        Flags &= ~STRV_ALLOW_ESCAPED_CHARACTERS;
    }
    
    while (*(*Buf) &&
           (!(Flags & STRV_SPACE_IS_SEPARATOR) || !isspace(*(*Buf))) &&
           (Quoted || *(*Buf) != ';') &&
           (!Quoted || *(*Buf) != '"'))
    {
        if (Flags & STRV_ALLOW_ESCAPED_CHARACTERS)
        {
            if (*(*Buf) == '\\')
            {
                char Raw;
                
                *Buf = GetEscapedChar((*Buf) + 1, &Raw);
                Escapes = TRUE;
            }
            else
            {
                (*Buf)++;
            }
        }
        else
        {
            (*Buf)++;
        }
    }

    if (Quoted && *(*Buf) != '"')
    {
        return NULL;
    }

    if (Flags & STRV_TRIM_TRAILING_SPACE)
    {
        PSTR Trim = *Buf;

        while (Trim > Str)
        {
            if (isspace(*--Trim))
            {
                *Trim = 0;
            }
            else
            {
                break;
            }
        }
    }
    
    if (Quoted && *(*Buf) == '"')
    {
        // Null the quote and advance beyond it
        // so that the buffer pointer is always pointing
        // beyond the string on exit.
        *(*Buf)++ = 0;

        // Require some kind of separator after the
        // string to keep things symmetric with the
        // non-quoted case.
        if (!isspace(*(*Buf)) &&
            *(*Buf) != ';' && *(*Buf) != 0)
        {
            *((*Buf) - 1) = '"';
            return NULL;
        }
    }
    
    *Save = *(*Buf);
    *(*Buf) = 0;

    if (Escapes && (Flags & STRV_COMPRESS_ESCAPED_CHARACTERS))
    {
        CompressEscapes(Str);
    }
    
    return Str;
}

PSTR
StringValue(ULONG Flags, PCHAR Save)
{
    PSTR Str = BufferStringValue((PSTR*)&g_CurCmd, Flags, Save);
    if (Str == NULL)
    {
        error(SYNTAX);
    }
    return Str;
}

void
CompressEscapes(PSTR Str)
{
    // Scan through a string for character escapes and
    // convert them to their escape value, packing
    // the rest of the string down.  This allows for
    // in-place conversion of strings with escapes
    // inside the command buffer.

    while (*Str)
    {
        if (*Str == '\\')
        {
            char Raw;
            PSTR Slash = Str;
            Str = GetEscapedChar(Slash + 1, &Raw);

            // Copy raw value over backslash and pack down
            // trailing characters.
            *Slash = Raw;
            ULONG Len = strlen(Str) + 1;
            memmove(Slash + 1, Str, Len);
            Str = Slash + 1;
        }
        else
        {
            Str++;
        }
    }
}

void
OpenLogFile(PCSTR File,
            BOOL Append)
{
    //  close existing opened log file
    fnLogClose();

    if (Append)
    {
        g_LogFile = _open(File, O_APPEND | O_CREAT | O_RDWR,
                          S_IREAD | S_IWRITE);
    }
    else
    {
        g_LogFile = _open(File, O_APPEND | O_CREAT | O_TRUNC | O_RDWR,
                          S_IREAD | S_IWRITE);
    }

    if (g_LogFile != -1)
    {
        dprintf("Opened log file '%s'\n", File);
        strncat(g_OpenLogFileName, File, sizeof(g_OpenLogFileName) - 1);
        g_OpenLogFileAppended = Append;

        NotifyChangeEngineState(DEBUG_CES_LOG_FILE, TRUE, TRUE);
    }
    else
    {
        ErrOut("log file could not be opened\n");
    }
}

void
fnLogOpen(BOOL Append)
{
    PSTR FileName;
    CHAR Save;

    if (PeekChar() && *g_CurCmd != ';')
    {
        FileName = StringValue(STRV_SPACE_IS_SEPARATOR |
                               STRV_TRIM_TRAILING_SPACE, &Save);
    }
    else
    {
        FileName = (PSTR)g_DefaultLogFileName;
    }

    OpenLogFile(FileName, Append);

    *g_CurCmd = Save;
}

/*** fnLogClose - close log file
*
*   Purpose:
*       Closes any open log file.
*
*   Input:
*       g_LogFile - file handle of open log file
*
*   Output:
*       None.
*
*************************************************************************/

void
fnLogClose (void)
{
    if (g_LogFile != -1)
    {
        dprintf("closing open log file\n");
        _close(g_LogFile);
        g_LogFile = -1;
        g_OpenLogFileName[0] = 0;
        g_OpenLogFileAppended = FALSE;

        NotifyChangeEngineState(DEBUG_CES_LOG_FILE, FALSE, TRUE);
    }
}

/*** lprintf - log file print
*
*   Purpose:
*       Print line only to log file.  Used to echo input line that
*       is already printed on standard output by gets() function.
*
*   Input:
*       g_LogFile - file handle variable of log file
*
*   Output:
*       None.
*
*************************************************************************/

void
lprintf (
    PCSTR string
    )
{
    if (g_LogFile != -1)
    {
        _write(g_LogFile, string, strlen(string));
    }
}

void
RestrictModNameChars(PCSTR ModName, PSTR RewriteBuffer)
{
    PCSTR Scan = ModName;
    PSTR Write = RewriteBuffer;

    while (*Scan)
    {
        if ((*Scan < 'a' || *Scan > 'z') &&
            (*Scan < 'A' || *Scan > 'Z') &&
            (*Scan < '0' || *Scan > '9') &&
            *Scan != '_')
        {
            *Write++ = '_';
        }
        else
        {
            *Write++ = *Scan;
        }

        Scan++;
    }
    *Write = 0;
}

PSTR
PrepareImagePath(PSTR ImagePath)
{
    // dbghelp will sometimes scan the path given to
    // SymLoadModule64 for the image itself.  There
    // can be cases where the scan uses fuzzy matching,
    // so we want to be careful to only pass in a path
    // for dbghelp to use when the path can safely be
    // used.
    if ((IS_LIVE_USER_TARGET() && !IS_REMOTE_USER_TARGET()) ||
        IS_LOCAL_KERNEL_TARGET())
    {
        return ImagePath;
    }
    else
    {
        return (PSTR)PathTail(ImagePath);
    }
}

#define CSRSS_IMAGE_NAME        "csrss.exe"
#define LSASS_IMAGE_NAME        "lsass.exe"
#define SERVICES_IMAGE_NAME     "services.exe"

CHAR *
AddImage(
    PMODULE_INFO_ENTRY ModEntry,
    BOOL ForceSymbolLoad
    )
{
    PDEBUG_IMAGE_INFO   ImageNew;
    PDEBUG_IMAGE_INFO   *pp;
    IMAGEHLP_MODULE64   mi;
    ULONG64             LoadAddress;
    BOOL                LoadSymbols = TRUE;
    BOOL                ReusedExisting = FALSE;
    PCSTR               ImagePathTail;
    MODLOAD_DATA        mld;        

#if DBG_MOD_LIST
    dprintf("AddImage:\n"
            " ImagePath       %s\n"
            " File            %I64x\n"
            " BaseOfImage     %I64x\n"
            " SizeOfImage     %x\n"
            " CheckSum        %x\n"
            " ModuleName      %s\n"
            " ForceSymbolLoad %d\n",
            ModEntry->NamePtr,
            (ULONG64)(ULONG_PTR)File,
            ModEntry->Base,
            ModEntry->Size,
            ModEntry->CheckSum,
            ModEntry->ModuleName,
            ForceSymbolLoad);
#endif

    if (ModEntry->NamePtr == NULL)
    {
        WarnOut("AddImage(NULL) fails\n");
        return NULL;
    }

    //
    //  Search for existing image with same checksum at same base address.
    //      If found, remove symbols, but leave image structure intact.
    //

    pp = &g_CurrentProcess->ImageHead;
    while (ImageNew = *pp)
    {
        if (ImageNew->BaseOfImage == ModEntry->Base)
        {
            VerbOut("Force unload of %s\n", ImageNew->ImagePath);
            SymUnloadModule64( g_CurrentProcess->Handle,
                               ImageNew->BaseOfImage );
            ClearStoredTypes(ImageNew->BaseOfImage);
            if (IS_DUMP_WITH_MAPPED_IMAGES())
            {
                // Unmap the memory for this image.
                UnloadExecutableImageMemory(ImageNew);
            }
            ReusedExisting = TRUE;
            break;
        }
        else if (ImageNew->BaseOfImage > ModEntry->Base)
        {
            break;
        }

        pp = &ImageNew->Next;
    }

    //
    // If we didn't reuse an existing image, allocate
    // a new one.
    //

    if (!ReusedExisting)
    {
        ImageNew = (PDEBUG_IMAGE_INFO)calloc(sizeof(*ImageNew), 1);
        if (ImageNew == NULL)
        {
            ErrOut("Unable to allocate memory for %s symbols.\n",
                   ModEntry->NamePtr);
            return NULL;
        }

        strcpy(ImageNew->ImagePath, ModEntry->NamePtr);
        // Module name is set later after possible renaming.
        ImageNew->File          = ModEntry->File;
        ImageNew->BaseOfImage   = ModEntry->Base;
        ImageNew->CheckSum      = ModEntry->CheckSum;
        ImageNew->TimeDateStamp = ModEntry->TimeDateStamp;
        ImageNew->GoodCheckSum = TRUE;
    }

    // Always update the entry size as this allows users
    // to update explicit entries (.reload image.ext=base,size)
    // without having to unload them first.
    ImageNew->SizeOfImage = ModEntry->Size;

    ImagePathTail = PathTail(ImageNew->ImagePath);
    
    //
    // If we are handling a mini dump, we need to try to add the
    // executable's memory as well as the symbol file.  We
    // do this right away so the image is mapped for the
    // below GetModnameFromImage calls.
    //

    if (IS_DUMP_WITH_MAPPED_IMAGES())
    {
        if (!LoadExecutableImageMemory(ImageNew))
        {
            // If the caller has requested that we fail on
            // incomplete information fail the module load.
            // We don't do this if we're reusing an existing
            // module under the assumption that it's better
            // to continue and try to complete the reused
            // image rather than deleting it.
            if ((g_EngOptions & DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION) &&
                !ReusedExisting)
            {
                free(ImageNew);
                return NULL;
            }
        }
    }

    if (IS_KERNEL_TARGET())
    {
        CHAR Buf[MAX_IMAGE_PATH];
        
        //
        // Determine the actual image name for kernel images which
        // are known to have multiple identities.
        //
        if ((ModEntry->ModuleName &&
             _stricmp(ModEntry->ModuleName, KERNEL_MODULE_NAME) == 0) ||
             ModEntry->Base == KdDebuggerData.KernBase)
        {
            if (GetModnameFromImage(ModEntry->Base, NULL, Buf, sizeof(Buf)))
            {
                strcpy(ImageNew->ImagePath, Buf);
            }
            ModEntry->ModuleName = KERNEL_MODULE_NAME;
        }
        else if (_stricmp(ImagePathTail, HAL_IMAGE_FILE_NAME) == 0)
        {
            if (GetModnameFromImage(ModEntry->Base, NULL, Buf, sizeof(Buf)))
            {
                strcpy(ImageNew->ImagePath, Buf);
            }
            ModEntry->ModuleName = HAL_MODULE_NAME;
        }
        else if (_stricmp(ImagePathTail, KDHWEXT_IMAGE_FILE_NAME) == 0)
        {
            if (GetModnameFromImage(ModEntry->Base, NULL, Buf, sizeof(Buf)))
            {
                strcpy(ImageNew->ImagePath, Buf);
            }
            ModEntry->ModuleName = KDHWEXT_MODULE_NAME;
        }
        else if (ImageNew->SizeOfImage == 0 &&
            ((_stricmp(ImagePathTail, NTLDR_IMAGE_NAME) == 0) ||
             (_stricmp(ImagePathTail, NTLDR_IMAGE_NAME ".exe") == 0) ||
             (_stricmp(ImagePathTail, OSLOADER_IMAGE_NAME) == 0) ||
             (_stricmp(ImagePathTail, OSLOADER_IMAGE_NAME ".exe") == 0) ||
             (_stricmp(ImagePathTail, SETUPLDR_IMAGE_NAME) == 0) ||
             (_stricmp(ImagePathTail, SETUPLDR_IMAGE_NAME ".exe") == 0)))
        {
            ImageNew->SizeOfImage = LDR_IMAGE_SIZE;
        }
    }
    else if (!IS_DUMP_TARGET())
    {
        //
        // When debugging CSR, LSA or Services.exe, force the use of local-only
        // symbols. Otherwise we can deadlock the entire machine when trying
        // to load the symbol file from the network.
        //

        if (IS_LOCAL_USER_TARGET() &&
            (_stricmp(ImagePathTail, CSRSS_IMAGE_NAME) == 0 ||
             _stricmp(ImagePathTail, LSASS_IMAGE_NAME) == 0 ||
             _stricmp(ImagePathTail, SERVICES_IMAGE_NAME) == 0))
        {
            if (g_EngOptions & DEBUG_ENGOPT_ALLOW_NETWORK_PATHS)
            {
                //
                // Since the user has chambered a round and pointed the barrel
                // of the gun at his head, we may as well tell him that it's
                // going to hurt if he pulls the trigger.
                //

                WarnOut("WARNING: Using network symbols with %s\n",
                        ImagePathTail);
                WarnOut("WARNING: You may deadlock your machine.\n");
            }
            else
            {
                g_EngOptions |= DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS;
            }
        }

        if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
        {
            DWORD NetPath;

            NetPath = NetworkPathCheck(g_SymbolSearchPath);
            if (NetPath == ERROR_FILE_OFFLINE)
            {
                ErrOut("ERROR: sympath contained network references but "
                       "they were not allowed.\n");
                ErrOut("Symbols not loaded for %s\n",
                       ImagePathTail);
                LoadSymbols = FALSE;
            }
            else if (NetPath == ERROR_BAD_PATHNAME)
            {
                VerbOut("WARNING: sympath contains invalid references.\n");
            }
        }
    }

    if (ModEntry->ModuleName == NULL)
    {
        CreateModuleNameFromPath(ImageNew->ImagePath,
                                 ImageNew->ModuleName);
        RestrictModNameChars(ImageNew->ModuleName, ImageNew->ModuleName);
        strcpy(ImageNew->OriginalModuleName, ImageNew->ModuleName);
    }
    else
    {
        RestrictModNameChars(ModEntry->ModuleName, ImageNew->ModuleName);
        
        //
        // We have an alias, so keep original module name from path
        //
        CreateModuleNameFromPath(ImageNew->ImagePath,
                                 ImageNew->OriginalModuleName);
        RestrictModNameChars(ImageNew->OriginalModuleName,
                             ImageNew->OriginalModuleName);
    }
    
    //
    // Check for duplicate module names.
    //

    PDEBUG_IMAGE_INFO Check;
    for (Check = g_CurrentProcess->ImageHead;
         Check != NULL;
         Check = Check->Next)
    {
        if (Check != ImageNew &&
            !_strcmpi(ImageNew->ModuleName, Check->ModuleName))
        {
            int Len = strlen(ImageNew->ModuleName);
            
            // Module names match, so qualify with the base address.
            // Resulting name must be unique since base addresses are.
            if (g_TargetMachine->m_Ptr64)
            {
                if (Len >= MAX_MODULE - 17)
                {
                    Len = MAX_MODULE - 18;
                }
                sprintf(ImageNew->ModuleName + Len, "_%I64x", ModEntry->Base);
            }
            else
            {
                if (Len >= MAX_MODULE - 9)
                {
                    Len = MAX_MODULE - 10;
                }
                sprintf(ImageNew->ModuleName + Len, "_%x",
                        (ULONG)ModEntry->Base);
            }
            break;
        }
    }

    //
    // If a new image structure was allocated, add it
    // into the image list.
    //

    if (!ReusedExisting)
    {
        ImageNew->Next = *pp;
        *pp = ImageNew;
        g_CurrentProcess->NumberImages++;

        if (g_CurrentProcess->ExecutableImage == NULL)
        {
            // Try and locate the executable image entry for
            // the process to use as the process's name.
            ULONG NameLen = strlen(ImageNew->ImagePath);
            if (NameLen > 4 &&
                !_stricmp(ImageNew->ImagePath + NameLen - 4, ".exe"))
            {
                g_CurrentProcess->ExecutableImage = ImageNew;
            }
        }
    }

    //
    // If we do not want to load symbolic information, just return here.
    //

    if (!LoadSymbols)
    {
        return ImageNew->ImagePath;
    }

    if (ModEntry->DebugHeader)
    {
        mld.ssize      = sizeof(MODLOAD_DATA);
        mld.ssig       = DBHHEADER_DEBUGDIRS;
        mld.data       = ModEntry->DebugHeader;
        mld.size       = ModEntry->SizeOfDebugHeader;
        mld.flags      = 0;;
    }
    
    LoadAddress = SymLoadModuleEx(g_CurrentProcess->Handle,
                                  ImageNew->File,
                                  PrepareImagePath(ImageNew->ImagePath),
                                  ImageNew->ModuleName,
                                  ImageNew->BaseOfImage,
                                  ImageNew->SizeOfImage,
                                  ModEntry->DebugHeader ? &mld : NULL,
                                  0);
    
    if (!LoadAddress)
    {
        VerbOut("SymLoadModule(%N, %N, \"%s\", \"%s\", %s, %x) fails\n",
                g_CurrentProcess->Handle,
                ImageNew->File,
                ImageNew->ImagePath,
                ImageNew->ModuleName,
                FormatAddr64(ImageNew->BaseOfImage),
                ImageNew->SizeOfImage);
        
        // We don't want DelImage to notify of a symbol change
        // if this is a partially newly created image.
        if (!ReusedExisting)
        {
            g_EngNotify++;
        }
        DelImageByBase(g_CurrentProcess, ImageNew->BaseOfImage);
        if (!ReusedExisting)
        {
            g_EngNotify--;
        }
        return NULL;
    }

    if (!ImageNew->BaseOfImage)
    {
        ImageNew->BaseOfImage = LoadAddress;
    }

    if (ForceSymbolLoad)
    {
        SymLoadModule64(g_CurrentProcess->Handle,
                        NULL,
                        NULL,
                        NULL,
                        ImageNew->BaseOfImage,
                        0);
    }

    mi.SizeOfStruct = sizeof(mi);
    if (SymGetModuleInfo64( g_CurrentProcess->Handle,
                            ImageNew->BaseOfImage, &mi ))
    {
        ImageNew->SizeOfImage = mi.ImageSize;
    }
    else
    {
        VerbOut("SymGetModuleInfo(%N, %s) fails\n",
                g_CurrentProcess->Handle,
                FormatAddr64(ImageNew->BaseOfImage));

        // We don't want DelImage to notify of a symbol change
        // if this is a partially newly created image.
        if (!ReusedExisting)
        {
            g_EngNotify++;
        }
        DelImageByBase(g_CurrentProcess, ImageNew->BaseOfImage);
        if (!ReusedExisting)
        {
            g_EngNotify--;
        }
        return NULL;
    }

    StartOutLine(DEBUG_OUTPUT_VERBOSE, OUT_LINE_NO_PREFIX);
    VerbOut( "ModLoad: %s %s   %-8s\n",
             FormatAddr64(ImageNew->BaseOfImage),
             FormatAddr64(ImageNew->BaseOfImage + ImageNew->SizeOfImage),
             ImageNew->ImagePath);

    NotifyChangeSymbolState(DEBUG_CSS_LOADS, ImageNew->BaseOfImage,
                            g_CurrentProcess);

    return ImageNew->ImagePath;
}

void
DelImage(
    PPROCESS_INFO Process,
    PDEBUG_IMAGE_INFO Image
    )
{
    ULONG64 ImageBase = Image->BaseOfImage;

#if DBG_MOD_LIST
    dprintf("DelImage:\n"
            " ImagePath       %s\n"
            " BaseOfImage     %I64x\n"
            " SizeOfImage     %x\n",
            Image->ImagePath,
            Image->BaseOfImage,
            Image->SizeOfImage);
#endif
    
    if (IS_DUMP_WITH_MAPPED_IMAGES())
    {
        // Unmap the memory for this image.
        UnloadExecutableImageMemory(Image);
    }

    SymUnloadModule64( Process->Handle, Image->BaseOfImage );
    ClearStoredTypes(Image->BaseOfImage);
    if (Image->File)
    {
        CloseHandle( Image->File );
    }
    if (Process->ExecutableImage == Image)
    {
        Process->ExecutableImage = NULL;
    }
    free(Image);
    Process->NumberImages--;

    // Notify with this process in order to mark any resulting
    // defered breakpoints due to this mod unload
    NotifyChangeSymbolState(DEBUG_CSS_UNLOADS, ImageBase, Process);
}

BOOL
DelImageByName(PPROCESS_INFO Process, PCSTR Name, INAME Which)
{
    PDEBUG_IMAGE_INFO Image, *pp;

    pp = &Process->ImageHead;
    while (Image = *pp)
    {
        PCSTR WhichStr;

        switch(Which)
        {
        case INAME_IMAGE_PATH:
            WhichStr = Image->ImagePath;
            break;
        case INAME_IMAGE_PATH_TAIL:
            WhichStr = PathTail(Image->ImagePath);
            break;
        case INAME_MODULE:
            WhichStr = Image->ModuleName;
            break;
        }
        
        if (!_stricmp(WhichStr, Name))
        {
            *pp = Image->Next;
            DelImage(Process, Image);
            return TRUE;
        }
        else
        {
            pp = &Image->Next;
        }
    }

    return FALSE;
}

BOOL
DelImageByBase(
    PPROCESS_INFO pProcess,
    ULONG64 BaseOfImage
    )
{
    PDEBUG_IMAGE_INFO     Image, *pp;

    pp = &pProcess->ImageHead;
    while (Image = *pp)
    {
        if (Image->BaseOfImage == BaseOfImage)
        {
            *pp = Image->Next;
            DelImage(pProcess, Image);
            return TRUE;
        }
        else
        {
            pp = &Image->Next;
        }
    }

    return FALSE;
}


void
DelImages(PPROCESS_INFO Process)
{
    PDEBUG_IMAGE_INFO Image, NextImage;

    // Suppress notifications until all images are deleted.
    g_EngNotify++;

    NextImage = Process->ImageHead;
    Process->ImageHead = NULL;
    while (NextImage)
    {
        Image = NextImage;
        NextImage = Image->Next;
        DelImage(Process, Image);
    }

    g_EngNotify--;
    NotifyChangeSymbolState(DEBUG_CSS_UNLOADS, 0, Process);
}

void
OutputSymAddr (
    ULONG64 Offset,
    ULONG Flags
    )
{
    CHAR   AddrBuffer[MAX_SYMBOL_LEN];
    ULONG64 Displacement;

    GetSymbolStdCall(Offset, AddrBuffer, sizeof(AddrBuffer),
                     &Displacement, NULL);
    if ((!Displacement || (Flags & SYMADDR_FORCE)) && AddrBuffer[0])
    {
        dprintf("%s", AddrBuffer);
        if (Displacement)
        {
            dprintf("+%s", FormatDisp64(Displacement));
        }
        if (Flags & SYMADDR_SOURCE)
        {
            OutputLineAddr(Offset, " [%s @ %d]");
        }
        if (Flags & SYMADDR_LABEL)
        {
            dprintf(":\n");
        }
        else
        {
            dprintf(" ");
        }
    }
}

void
OutputLineAddr(
    ULONG64 Offset,
    PCSTR Format
    )
{
    if ((g_SymOptions & SYMOPT_LOAD_LINES) == 0)
    {
        return;
    }
    
    IMAGEHLP_LINE Line;
    DWORD LineDisp;
            
    Line.SizeOfStruct = sizeof(Line);
    if (SymGetLineFromAddr(g_CurrentProcess->Handle, Offset,
                           &LineDisp, &Line))
    {
        dprintf(Format, Line.FileName, Line.LineNumber);
    }
}

/*** OutCurInfo - Display selected information about the current register
*                 state.
*
*   Purpose:
*       Source file lines may be shown.
*       Source line information may be shown.
*       Symbol information may be shown.
*       The current register set may be shown.
*       The instruction at the current program current may be disassembled
*       with any effective address displayed.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*   Notes:
*       If the disassembly is of a delayed control instruction, the
*       delay slot instruction is also output.
*
*************************************************************************/

void OutCurInfo(ULONG Flags, ULONG AllMask, ULONG RegMask)
{
    ADDR    PcValue;
    ADDR    DisasmAddr;
    CHAR    Buffer[MAX_DISASM_LEN];
    BOOL    EA;

    if (g_CurrentProcess == NULL ||
        g_CurrentProcess->CurrentThread == NULL)
    {
        WarnOut("WARNING: The debugger does not have a current "
                "process or thread\n");
        WarnOut("WARNING: Many commands will not work\n");
    }
    
    if (!IS_MACHINE_SET() ||
        g_CurrentProcess == NULL ||
        g_CurrentProcess->CurrentThread == NULL ||
        IS_LOCAL_KERNEL_TARGET() ||
        ((Flags & OCI_IGNORE_STATE) == 0 && IS_RUNNING(g_CmdState)) ||
        ((IS_KERNEL_FULL_DUMP() || IS_KERNEL_SUMMARY_DUMP()) &&
         KdDebuggerData.KiProcessorBlock == 0))
    {
        // State is not available right now.
        return;
    }
    
    g_Machine->GetPC(&PcValue);

    if ((Flags & (OCI_FORCE_ALL | OCI_FORCE_REG)) ||
        ((g_SrcOptions & SRCOPT_LIST_SOURCE_ONLY) == 0 &&
         (Flags & OCI_ALLOW_REG) &&
         g_OciOutputRegs))
    {
        g_Machine->OutputAll(AllMask, RegMask);
    }

    // Output g_PrevRelatedPc address
    if (Flat(g_PrevRelatedPc) && !AddrEqu(g_PrevRelatedPc, PcValue))
    {
        if (Flags & (OCI_FORCE_ALL | OCI_SYMBOL))
        {
            OutputSymAddr(Flat(g_PrevRelatedPc), SYMADDR_FORCE);
            dprintf("(%s)", FormatAddr64(Flat(g_PrevRelatedPc)));
        }
        else
        {
            dprintf("%s", FormatAddr64(Flat(g_PrevRelatedPc)));
        }
        dprintf("\n -> ");
    }
        
    // Deliberately does not force source with force-all so that source line
    // support has no effect on default operation.
    if (Flags & (OCI_FORCE_ALL | OCI_FORCE_SOURCE | OCI_ALLOW_SOURCE))
    {
        if (g_SrcOptions & SRCOPT_LIST_SOURCE)
        {
            if (OutputSrcLinesAroundAddr(Flat(PcValue),
                                         g_OciSrcBefore, g_OciSrcAfter) &&
                (Flags & OCI_FORCE_ALL) == 0 &&
                (g_SrcOptions & SRCOPT_LIST_SOURCE_ONLY))
            {
                return;
            }
        }
        else if ((g_SrcOptions & SRCOPT_LIST_LINE) ||
                 (Flags & OCI_FORCE_SOURCE))
        {
            OutputLineAddr(Flat(PcValue));
        }
    }

    if (Flags & (OCI_FORCE_ALL | OCI_SYMBOL))
    {
        OutputSymAddr(Flat(PcValue), SYMADDR_FORCE | SYMADDR_LABEL);
    }

    if (Flags & (OCI_FORCE_ALL | OCI_DISASM))
    {
        if (Flags & (OCI_FORCE_ALL | OCI_FORCE_EA))
        {
            EA = TRUE;
        }
        else if (Flags & OCI_ALLOW_EA)
        {
            if (IS_DUMP_TARGET() || IS_USER_TARGET())
            {
                // Always show the EA info.
                EA = TRUE;
            }
            else
            {
                // Only show the EA information if registers were shown.
                EA = g_OciOutputRegs;
            }
        }
        else
        {
            EA = FALSE;
        }

        DisasmAddr = PcValue;
        g_Machine->Disassemble(&DisasmAddr, Buffer, EA);
        dprintf("%s", Buffer);
        if (g_Machine->IsDelayInstruction(&PcValue))
        {
            g_Machine->Disassemble(&DisasmAddr, Buffer, EA);
            dprintf("%s", Buffer);
        }
    }
}

#define MAX_FORMAT_STRINGS 8

LPSTR
FormatMachineAddr64(
    MachineInfo* Machine,
    ULONG64 Addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same printf.

Arguments:

    Addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    static CHAR s_Strings[MAX_FORMAT_STRINGS][18];
    static int s_Next = 0;
    LPSTR String;

    String = s_Strings[s_Next];
    ++s_Next;
    if (s_Next >= MAX_FORMAT_STRINGS)
    {
        s_Next = 0;
    }
    if (Machine->m_Ptr64)
    {
        sprintf(String, "%08x`%08x", (ULONG)(Addr >> 32), (ULONG)Addr);
    }
    else
    {
        sprintf(String, "%08x", (ULONG)Addr);
    }
    return String;
}

LPSTR
FormatDisp64(
    ULONG64 addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.  This version does not print
    leading 0's.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same printf.

Arguments:

    addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    static CHAR strings[MAX_FORMAT_STRINGS][18];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS)
    {
        next = 0;
    }
    if ((addr >> 32) != 0)
    {
        sprintf(string, "%x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    }
    else
    {
        sprintf(string, "%x", (ULONG)addr);
    }
    return string;
}

DWORD
NetworkPathCheck(
    LPCSTR PathList
    )

/*++

Routine Description:

    Checks if any members of the PathList are network paths.

Arguments:

    PathList - A list of paths separated by ';' characters.

Return Values:

    ERROR_SUCCESS - The path list contained no network or invalid paths.

    ERROR_BAD_PATHNAME - The path list contained one or more invalid paths,
            but no network paths.

    ERROR_FILE_OFFLINE - The path list contained one or more network paths.


Bugs:

    Any path containing the ';' character will totally confuse this function.

--*/

{
    CHAR EndPath0;
    CHAR EndPath1;
    LPSTR EndPath;
    LPSTR StartPath;
    DWORD DriveType;
    LPSTR Buffer = NULL;
    DWORD ret = ERROR_SUCCESS;
    BOOL AddedTrailingSlash = FALSE;


    if (PathList == NULL ||
        *PathList == '\000') {
        return FALSE;
    }

    Buffer = (LPSTR) malloc ( strlen (PathList) + 3);
    if (!Buffer) {
        return ERROR_BAD_PATHNAME;
    }
    strcpy (Buffer, PathList);
    StartPath = Buffer;

    do {
        if (StartPath [0] == '\\' && StartPath [1] == '\\') {
            ret = ERROR_FILE_OFFLINE;
            break;
        }

        EndPath = strchr (StartPath, ';');

        if (EndPath == NULL) {
            EndPath = StartPath + strlen (StartPath);
            EndPath0 = *EndPath;
        } else {
            EndPath0 = *EndPath;
            *EndPath = '\000';
        }

        if (EndPath [-1] != '\\') {
            EndPath [0] = '\\';
            EndPath1 = EndPath [1];
            EndPath [1] = '\000';
            AddedTrailingSlash = TRUE;

        }

        DriveType = GetDriveType (StartPath);

        if (DriveType == DRIVE_REMOTE) {

            ret = ERROR_FILE_OFFLINE;
            break;

        } else if (DriveType == DRIVE_UNKNOWN ||
                   DriveType == DRIVE_NO_ROOT_DIR) {

            //
            // This is not necessarily an error, but it may merit
            // investigation.
            //

            if (ret == ERROR_SUCCESS) {
                ret = ERROR_BAD_PATHNAME;
            }
        }

        EndPath [0] = EndPath0;
        if (AddedTrailingSlash) {
            EndPath [1] = EndPath1;
        }
        AddedTrailingSlash = FALSE;

        if (EndPath [ 0 ] == '\000') {
            StartPath = NULL;
        } else {
            StartPath = &EndPath [ 1 ];
        }
    } while (StartPath && *StartPath != '\000');


    if (Buffer) {
        free ( Buffer );
        Buffer = NULL;
    }

    return ret;
}

//----------------------------------------------------------------------------
//
// Returns either an ID value or ALL_ID_LIST.  In theory
// this routine could be expanded to pass back true intervals
// so a full list could be specified.
//
// Originally built up a mask for the multi-ID case but that
// was changed to return a real ID when 32 bits became
// constraining.
//
//----------------------------------------------------------------------------

ULONG
GetIdList (void)
{
    ULONG   Value = 0;
    CHAR    ch;
    CHAR    Digits[5];     // allow up to four digits
    int     i;

    //
    // Change to allow more than 32 break points to be set. Use
    // break point numbers instead of masks.
    //

    if ((ch = PeekChar()) == '*')
    {
        Value = ALL_ID_LIST;
        g_CurCmd++;
    }
    else if (ch == '[')
    {
        Value = (ULONG)GetTermExprDesc("Breakpoint ID missing from");
    }
    else
    {
        for (i = 0; i < sizeof(Digits) - 1; i++)
        {
            if (ch >= '0' && ch <= '9')
            {
                Digits[i] = ch;
                ch = *++g_CurCmd;
            }
            else
            {
                break;
            }
        }

        Digits[i] = '\0';

        if (ch == '\0' || ch == ';' || ch == ' ' || ch == '\t')
        {
            Value = strtol(Digits, NULL, 10);
        }
        else
        {
            error (SYNTAX);
        }
    }

    return Value;
}

//
// Sets or appends to a semicolon-delimited path.
//
HRESULT
ChangePath(PSTR* Path, PCSTR New, BOOL Append, ULONG SymNotify)
{
    ULONG NewLen, CurLen, TotLen;
    PSTR NewPath;

    if (New != NULL && *New != 0)
    {
        NewLen = strlen(New) + 1;
    }
    else if (Append)
    {
        // Nothing to append.
        return S_OK;
    }
    else
    {
        NewLen = 0;
    }

    if (*Path == NULL || **Path == 0)
    {
        // Nothing to append to.
        Append = FALSE;
    }

    if (Append)
    {
        CurLen = strlen(*Path) + 1;
    }
    else
    {
        CurLen = 0;
    }

    TotLen = CurLen + NewLen;
    if (TotLen > 0)
    {
        NewPath = (PSTR)malloc(TotLen);
        if (NewPath == NULL)
        {
            ErrOut("Unable to allocate memory for path\n");
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        NewPath = NULL;
    }

    PSTR Cat = NewPath;

    if (CurLen > 0)
    {
        memcpy(Cat, *Path, CurLen);
        Cat[CurLen - 1] = ';';
        Cat += CurLen;
    }

    if (NewLen > 0)
    {
        memcpy(Cat, New, NewLen);
    }

    if (*Path != NULL)
    {
        free(*Path);
    }
    *Path = NewPath;

    if (SymNotify != 0)
    {
        NotifyChangeSymbolState(SymNotify, 0, g_CurrentProcess);
    }

    return S_OK;
}

PSTR
FindPathElement(PSTR Path, ULONG Element, PSTR* EltEnd)
{
    PSTR Elt, Sep;

    if (Path == NULL)
    {
        return NULL;
    }

    Elt = Path;
    for (;;)
    {
        Sep = strchr(Elt, ';');
        if (Sep == NULL)
        {
            Sep = Elt + strlen(Elt);
        }

        if (Element == 0)
        {
            break;
        }

        if (*Sep == 0)
        {
            // No more elements.
            return NULL;
        }

        Elt = Sep + 1;
        Element--;
    }

    *EltEnd = Sep;
    return Elt;
}

void
CheckPath(PCSTR Path)
{
    PCSTR EltStart;
    PCSTR Scan;
    BOOL Space;

    if (Path == NULL)
    {
        return;
    }

    for (;;)
    {
        BOOL Warned = FALSE;
        
        EltStart = Path;

        Scan = EltStart;
        while (isspace(*Scan))
        {
            Scan++;
        }
        if (Scan != EltStart)
        {
            WarnOut("WARNING: Whitespace at start of path element\n");
            Warned = TRUE;
        }

        // Find the end of the element.
        Space = FALSE;
        while (*Scan && *Scan != ';')
        {
            Space = isspace(*Scan);
            Scan++;
        }

        if (Space)
        {
            WarnOut("WARNING: Whitespace at end of path element\n");
            Warned = TRUE;
        }

        if (Scan - EltStart >= MAX_PATH)
        {
            WarnOut("WARNING: Path element is longer than MAX_PATH\n");
            Warned = TRUE;
        }

        if (!Warned)
        {
            char Elt[MAX_PATH];

            memcpy(Elt, EltStart, Scan - EltStart);
            Elt[Scan - EltStart] = 0;
            
            if (!ValidatePathComponent(Elt))
            {
                WarnOut("WARNING: %s is not accessible\n", Elt);
                Warned = TRUE;
            }
        }

        if (!*Scan)
        {
            break;
        }

        Path = Scan + 1;
    }
}

HRESULT
ChangeString(PSTR* Str, PULONG StrLen, PCSTR New)
{
    ULONG Len;
    PSTR Buf;

    if (New != NULL)
    {
        Len = strlen(New) + 1;
        Buf = new char[Len];
        if (Buf == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        Buf = NULL;
        Len = 0;
    }

    delete [] *Str;

    *Str = Buf;
    if (New != NULL)
    {
        memcpy(Buf, New, Len);
    }
    if (StrLen != NULL)
    {
        *StrLen = Len;
    }

    return S_OK;
}

typedef struct _FIND_MODULE_DATA {
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    PVOID FileMapping;
    HANDLE FileHandle;
} FIND_MODULE_DATA, *PFIND_MODULE_DATA;


PCSTR KernelAliasList [] =
{
    "ntoskrnl.exe",
    "ntkrnlpa.exe",
    "ntkrnlmp.exe",
    "ntkrpamp.exe"
};

PCSTR ScsiAlias = "diskdump.sys";

PCSTR HalAliasList [] =
{
    "hal.dll",
    "hal486c.dll",
    "halaacpi.dll",
    "halacpi.dll",
    "halapic.dll",
    "halborg.dll"
    "halmacpi.dll",
    "halmps.dll",
    "halsp.dll"
};

PCSTR KdAliasList [] =
{
    "kdcom.dll",
    "kd1394.dll"
};

#define MAX_ALIAS_COUNT (DIMA(HalAliasList))


PVOID
OpenMapping(
    IN PCSTR FilePath,
    OUT HANDLE* FileHandle
    )
{
    HANDLE File;
    HANDLE Mapping;
    PVOID View;
    ULONG OldMode;

    *FileHandle = NULL;

    if (g_SymOptions & SYMOPT_FAIL_CRITICAL_ERRORS)
    {
        OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    }
    
    File = CreateFile(
                FilePath,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if (g_SymOptions & SYMOPT_FAIL_CRITICAL_ERRORS)
    {
        SetErrorMode(OldMode);
    }
    
    if ( File == INVALID_HANDLE_VALUE )
    {
        return NULL;
    }

    Mapping = CreateFileMapping (
                        File,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );
    if ( !Mapping )
    {
        CloseHandle ( File );
        return FALSE;
    }

    View = MapViewOfFile (
                        Mapping,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    CloseHandle (Mapping);

    *FileHandle = File;
    return View;
}

PVOID
MapImageFile(
    PCSTR FilePath,
    ULONG SizeOfImage,
    ULONG CheckSum,
    ULONG TimeDateStamp,
    HANDLE* FileHandle
    )
{
    PVOID FileMapping;
    PIMAGE_NT_HEADERS NtHeader;

    FileMapping = OpenMapping(FilePath, FileHandle);
    NtHeader = ImageNtHeader(FileMapping);
    if ((NtHeader == NULL) ||
        (CheckSum && NtHeader->OptionalHeader.CheckSum &&
         (NtHeader->OptionalHeader.CheckSum != CheckSum)) ||
        (SizeOfImage != 0 &&
         NtHeader->OptionalHeader.SizeOfImage != SizeOfImage) ||
        (TimeDateStamp != 0 &&
         NtHeader->FileHeader.TimeDateStamp != TimeDateStamp))
    {
        //
        // The image data does not match the request.
        //

        if (g_SymOptions & SYMOPT_DEBUG)
        {
            ErrOut("DBGENG: %s image header does not match memory "
                   "image header\n", FilePath);
        }
                   
        UnmapViewOfFile(FileMapping);
        CloseHandle(*FileHandle);
        *FileHandle = NULL;
        return NULL;
    }

    return FileMapping;
}

BOOL CALLBACK
FindFileInPathCallback(PSTR FileName, PVOID CallerData)
{
    PFIND_MODULE_DATA FindModuleData = (PFIND_MODULE_DATA)CallerData;
    
    FindModuleData->FileMapping =
        MapImageFile(FileName, FindModuleData->SizeOfImage,
                     (g_SymOptions & SYMOPT_EXACT_SYMBOLS) ?
                     FindModuleData->CheckSum : 0,
                     FindModuleData->TimeDateStamp,
                     &FindModuleData->FileHandle);

    // The search stops when FALSE is returned, so
    // return FALSE when we've found a match.
    return FindModuleData->FileMapping == NULL;
}

BOOL
FindExecutableCallback(
    HANDLE File,
    PSTR FileName,
    PVOID CallerData
    )
{
    PFIND_MODULE_DATA FindModuleData;

    DBG_ASSERT ( CallerData );
    FindModuleData = (PFIND_MODULE_DATA) CallerData;

    FindModuleData->FileMapping =
        MapImageFile(FileName, FindModuleData->SizeOfImage,
                     (g_SymOptions & SYMOPT_EXACT_SYMBOLS) ?
                     FindModuleData->CheckSum : 0,
                     FindModuleData->TimeDateStamp,
                     &FindModuleData->FileHandle);

    return FindModuleData->FileMapping != NULL;
}

PVOID
FindImageFile(
    IN PCSTR ImagePath,
    IN ULONG SizeOfImage,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp,
    OUT HANDLE* FileHandle,
    OUT PSTR MappedImagePath
    )

/*++

Routine Description:

    Find the executable image on the SymbolPath that matches ModuleName,
    CheckSum. This function takes care of things like renamed kernels and
    hals, and multiple images with the same name on the path.

Return Values:

    File mapping or NULL.

--*/

{
    ULONG i;
    ULONG j = 0;
    HANDLE File;
    ULONG AliasCount = 0;
    PCSTR AliasList[MAX_ALIAS_COUNT + 3];
    FIND_MODULE_DATA FindModuleData;

    C_ASSERT (MAX_ALIAS_COUNT >= DIMA (KernelAliasList));
    C_ASSERT (MAX_ALIAS_COUNT >= DIMA (HalAliasList));
    C_ASSERT (MAX_ALIAS_COUNT >= DIMA (KdAliasList));

    DBG_ASSERT ( ImagePath != NULL && ImagePath[0] != 0 );

    PCSTR ModuleName = PathTail(ImagePath);

    //
    // Build an alias list. For normal modules, modules that are not the
    // kernel, the hal or a dump driver, this list will contain exactly one
    // entry with the module name. For kernel, hal and dump drivers, the
    // list will contain any number of known aliases for the specific file.
    //

    for (i = 0; i < DIMA(KernelAliasList); i++)
    {
        if (!_strcmpi(ModuleName, KernelAliasList[i]))
        {
            //
            // found a kernel alias.
            //

            AliasList[AliasCount++] = ModuleName;

            while (j < DIMA(KernelAliasList))
            {
                AliasList[AliasCount++] = KernelAliasList[j++];
            }
            break;
        }
    }

    if (!AliasCount)
    {
        for (i = 0; i < DIMA(HalAliasList); i++)
        {
            if (!_strcmpi(ModuleName, HalAliasList[i]))
            {
                //
                // found a HAL alias.
                //

                AliasList[AliasCount++] = ModuleName;

                while (j < DIMA(HalAliasList))
                {
                    AliasList[AliasCount++] = HalAliasList[j++];
                }
                break;
            }
        }
    }

    if (!AliasCount)
    {
        for (i = 0; i < DIMA(KdAliasList); i++)
        {
            if (!_strcmpi(ModuleName, KdAliasList[i]))
            {
                //
                // found a HAL alias.
                //

                AliasList[AliasCount++] = ModuleName;

                while (j < DIMA(KdAliasList))
                {
                    AliasList[AliasCount++] = KdAliasList[j++];
                }
                break;
            }
        }
    }

    if (!AliasCount)
    {
        if ( _strnicmp (ModuleName, "dump_scsiport", 11) == 00 )
        {
            AliasList[0] = ScsiAlias;
            AliasCount = 1;
        }
        else if ( _strnicmp (ModuleName, "dump_", 5) == 00 )
        {
            //
            // Setup dump driver alias list
            //

            AliasList[0] = &ModuleName[5];
            AliasList[1] = ModuleName;
            AliasCount = 2;
        }
        else
        {
            AliasList[0] = ModuleName;
            AliasCount = 1;
        }
    }


    //
    // First try to find it in a symbol server or
    // directly on the image path.
    //

    for (i = 0; i < AliasCount; i++)
    {
        FindModuleData.SizeOfImage = SizeOfImage;
        FindModuleData.CheckSum = CheckSum;
        FindModuleData.TimeDateStamp = TimeDateStamp;
        FindModuleData.FileMapping = NULL;
        FindModuleData.FileHandle = NULL;

        if (SymFindFileInPath(g_CurrentProcess->Handle,
                              g_ExecutableImageSearchPath,
                              (PSTR)AliasList[i], UlongToPtr(TimeDateStamp),
                              SizeOfImage, 0, SSRVOPT_DWORD, MappedImagePath,
                              FindFileInPathCallback, &FindModuleData))
        {
            if (FileHandle) 
            {
                *FileHandle = FindModuleData.FileHandle;
            }
            return FindModuleData.FileMapping;
        }
    }
    
    //
    // Initial search didn't work so do a full tree search.
    //

    for (i = 0; i < AliasCount; i++)
    {
        FindModuleData.SizeOfImage = SizeOfImage;
        FindModuleData.CheckSum = CheckSum;
        FindModuleData.TimeDateStamp = TimeDateStamp;
        FindModuleData.FileMapping = NULL;
        FindModuleData.FileHandle = NULL;

        File = FindExecutableImageEx ((PSTR)AliasList[i],
                                      g_ExecutableImageSearchPath,
                                      MappedImagePath,
                                      FindExecutableCallback,
                                      &FindModuleData);
        if ( File != NULL && File != INVALID_HANDLE_VALUE )
        {
            CloseHandle (File);
        }

        if ( FindModuleData.FileMapping != NULL )
        {
            if (FileHandle) 
            {
                *FileHandle = FindModuleData.FileHandle;
            }
            return FindModuleData.FileMapping;
        }
    }

    //
    // No path searches found the image so just try
    // the given path as a last-ditch check.
    //

    strcpy(MappedImagePath, ImagePath);
    FindModuleData.FileMapping =
        MapImageFile(ImagePath, SizeOfImage, CheckSum, TimeDateStamp,
                     FileHandle);
    if (FindModuleData.FileMapping == NULL)
    {
        MappedImagePath[0] = 0;
    }
    return FindModuleData.FileMapping;
}

// User-mode minidump can be created with data segments
// embedded in the dump.  If that's the case, don't map
// such sections.
#define IS_MINI_DATA_SECTION(SecHeader)                                       \
    (IS_USER_MINI_DUMP() &&                                                   \
     ((SecHeader)->Characteristics & IMAGE_SCN_MEM_WRITE) &&                  \
     ((SecHeader)->Characteristics & IMAGE_SCN_MEM_READ) &&                   \
     (((SecHeader)->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) ||    \
      ((SecHeader)->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA)))

#if 0
#define DBG_IMAGE_MAP
#endif

BOOL
LoadExecutableImageMemory(PDEBUG_IMAGE_INFO Image)
{
    PVOID FileMapping;
    HRESULT Status;

    DBG_ASSERT(Image->File == NULL);
    
    FileMapping = FindImageFile(Image->ImagePath,
                                Image->SizeOfImage,
                                Image->CheckSum,
                                Image->TimeDateStamp,
                                &Image->File,
                                Image->MappedImagePath);
    if (FileMapping == NULL)
    {
        ErrOut("Unable to load image %s\n", Image->ImagePath);
        return FALSE;
    }

    PIMAGE_NT_HEADERS Header = ImageNtHeader(FileMapping);

    // Header was already validated in MapImageFile.
    DBG_ASSERT(Header != NULL);

    // Map the header so we have it later.
    // Mark it with the image structure that this mapping is for.
    if (MemoryMap_AddRegion(Image->BaseOfImage,
                            Header->OptionalHeader.SizeOfHeaders,
                            FileMapping, Image, FALSE) != S_OK)
    {
        UnmapViewOfFile(FileMapping);
        if (Image->File != NULL)
        {
            CloseHandle(Image->File);
            Image->File = NULL;
        }
        Image->MappedImagePath[0] = 0;
        ErrOut("Unable to map image header memory for %s\n",
               Image->ImagePath);
        return FALSE;
    }

    PIMAGE_DATA_DIRECTORY DebugDataDir;
    IMAGE_DEBUG_DIRECTORY UNALIGNED * DebugDir = NULL;
    
    // Due to a linker bug, some images have debug data that is not
    // included as part of a section.  Scan the debug data directory
    // and map anything that isn't already mapped.
    switch(Header->OptionalHeader.Magic)
    {
    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
        DebugDataDir = &((PIMAGE_NT_HEADERS32)Header)->OptionalHeader.
            DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
        break;
    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
        DebugDataDir = &((PIMAGE_NT_HEADERS64)Header)->OptionalHeader.
            DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
        break;
    default:
        DebugDataDir = NULL;
        break;
    }

    //
    // Map all the sections in the image at their
    // appropriate offsets from the base address.
    //

    ULONG i;

#ifdef DBG_IMAGE_MAP
    dprintf("Map %s: base %s, size %x, %d sections, mapping %p\n",
            Image->ImagePath, FormatAddr64(Image->BaseOfImage),
            Image->SizeOfImage, Header->FileHeader.NumberOfSections,
            FileMapping);
#endif

    PIMAGE_SECTION_HEADER SecHeader = IMAGE_FIRST_SECTION(Header);
    for (i = 0; i < Header->FileHeader.NumberOfSections; i++)
    {
        BOOL AllowOverlap;
        
#ifdef DBG_IMAGE_MAP
        dprintf("  %2d: %8.8s v %08x s %08x p %08x char %X\n", i,
                SecHeader->Name, SecHeader->VirtualAddress,
                SecHeader->SizeOfRawData, SecHeader->PointerToRawData,
                SecHeader->Characteristics);
#endif

        if (SecHeader->SizeOfRawData == 0)
        {
            // Probably a BSS section that describes
            // a zero-filled data region and so is not
            // present in the executable.  This should really
            // map to the appropriate page full of zeroes but
            // for now just ignore it.
            SecHeader++;
            continue;
        }

        if (DebugDataDir != NULL &&
            DebugDataDir->VirtualAddress >= SecHeader->VirtualAddress &&
            DebugDataDir->VirtualAddress < SecHeader->VirtualAddress +
            SecHeader->SizeOfRawData)
        {
#ifdef DBG_IMAGE_MAP
            dprintf("    DebugDataDir found in sec %d at %X (%X)\n",
                    i, DebugDataDir->VirtualAddress,
                    DebugDataDir->VirtualAddress - SecHeader->VirtualAddress);
#endif
            
            DebugDir = (PIMAGE_DEBUG_DIRECTORY)
                ((PUCHAR)FileMapping + (DebugDataDir->VirtualAddress -
                                        SecHeader->VirtualAddress +
                                        SecHeader->PointerToRawData));
        }
            
        // As a sanity check make sure that the mapped region will
        // fall within the overall image bounds.
        if (SecHeader->VirtualAddress >= Image->SizeOfImage ||
            SecHeader->VirtualAddress + SecHeader->SizeOfRawData >
            Image->SizeOfImage)
        {
            WarnOut("WARNING: Image %s section %d extends "
                    "outside of image bounds\n",
                    Image->ImagePath, i);
        }

        if (IS_MINI_DATA_SECTION(SecHeader))
        {
            ULONG64 DataBase;
            ULONG DataSize;

            // Dumps can have explicit memory regions for
            // data sections to reflect changes to globals
            // and so on.  If the current data section already
            // is completely mapped just ignore the image data.
            // Otherwise map but allow overlap.
            if (MemoryMap_GetRegionInfo(Image->BaseOfImage +
                                        SecHeader->VirtualAddress,
                                        &DataBase, &DataSize, NULL, NULL) &&
                DataBase + DataSize >= Image->BaseOfImage +
                SecHeader->VirtualAddress + SecHeader->SizeOfRawData)
            {
                SecHeader++;
                continue;
            }
            
            AllowOverlap = TRUE;
        }
        else
        {
            AllowOverlap = FALSE;
        }

        // Mark the region with the image structure to identify the
        // region as an image area.
        if ((Status = MemoryMap_AddRegion(Image->BaseOfImage +
                                          SecHeader->VirtualAddress,
                                          SecHeader->SizeOfRawData,
                                          (PUCHAR)FileMapping +
                                          SecHeader->PointerToRawData,
                                          Image, AllowOverlap)) != S_OK)
        {
            ErrOut("Unable to map %s section %d at %s, %s\n",
                   Image->ImagePath, i,
                   FormatAddr64(Image->BaseOfImage +
                                SecHeader->VirtualAddress),
                   FormatStatusCode(Status));

            // Conflicting region data is not a critical failure
            // unless the incomplete information flag is set.
            if (Status != HR_REGION_CONFLICT ||
                (g_EngOptions & DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION))
            {
                if (!UnloadExecutableImageMemory(Image))
                {
                    UnmapViewOfFile(FileMapping);
                    if (Image->File != NULL)
                    {
                        CloseHandle(Image->File);
                        Image->File = NULL;
                    }
                    Image->MappedImagePath[0] = 0;
                }
                return FALSE;
            }
        }

        SecHeader++;
    }

    if (DebugDir != NULL)
    {
        i = DebugDataDir->Size / sizeof(*DebugDir);
        
#ifdef DBG_IMAGE_MAP
        dprintf("    %d debug dirs\n", i);
#endif
        
        while (i-- > 0)
        {
#ifdef DBG_IMAGE_MAP
            dprintf("    Dir %d at %p\n", i, DebugDir);
#endif
            
            // If this debug directory's data is past the size
            // of the image it's a good indicator of the problem.
            if (DebugDir->AddressOfRawData != 0 &&
                DebugDir->PointerToRawData >= Image->SizeOfImage &&
                !MemoryMap_GetRegionInfo(Image->BaseOfImage +
                                         DebugDir->AddressOfRawData,
                                         NULL, NULL, NULL, NULL))
            {
#ifdef DBG_IMAGE_MAP
                dprintf("    Mapped hidden debug data at RVA %08x, "
                        "size %x, ptr %08x\n",
                        DebugDir->AddressOfRawData, DebugDir->SizeOfData,
                        DebugDir->PointerToRawData);
#endif
                
                if (MemoryMap_AddRegion(Image->BaseOfImage +
                                        DebugDir->AddressOfRawData,
                                        DebugDir->SizeOfData,
                                        (PUCHAR)FileMapping +
                                        DebugDir->PointerToRawData,
                                        Image, FALSE) != S_OK)
                {
                    ErrOut("Unable to map extended debug data at %s\n",
                           FormatAddr64(Image->BaseOfImage +
                                        DebugDir->AddressOfRawData));
                }
            }

            DebugDir++;
        }
    }

    Image->MappedImageBase = FileMapping;
    return TRUE;
}

BOOL
UnloadExecutableImageMemory(PDEBUG_IMAGE_INFO Image)
{
    ULONG64 RegBase;
    ULONG RegSize;
    PVOID RegImage;
    ULONG i;

    // Look up the header region.
    if (!MemoryMap_GetRegionInfo(Image->BaseOfImage, &RegBase, &RegSize,
                                 NULL, &RegImage))
    {
        // This is expected for images which couldn't be located.
        return FALSE;
    }

    if (RegImage != Image)
    {
        ErrOut("UnloadEIM: Header at %s isn't owned by %s\n",
               FormatAddr64(Image->BaseOfImage), Image->ImagePath);
        return FALSE;
    }
    
    PIMAGE_NT_HEADERS Header = ImageNtHeader(Image->MappedImageBase);
    if (Header == NULL ||
        Header->OptionalHeader.SizeOfHeaders != RegSize)
    {
        ErrOut("UnloadEIM %s: Unable to get image header at %s\n",
               Image->ImagePath, FormatAddr64(Image->BaseOfImage));
        return FALSE;
    }

#ifdef DBG_IMAGE_MAP
    dprintf("Unmap %s: base %s, size %x, %d sections\n",
            Image->ImagePath, FormatAddr64(Image->BaseOfImage),
            Image->SizeOfImage, Header->FileHeader.NumberOfSections);
#endif

    PIMAGE_DATA_DIRECTORY DebugDataDir;
    IMAGE_DEBUG_DIRECTORY UNALIGNED * DebugDir = NULL;
    
    // Due to a linker bug, some images have debug data that is not
    // included as part of a section.  Scan the debug data directory
    // and map anything that isn't already mapped.
    switch(Header->OptionalHeader.Magic)
    {
    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
        DebugDataDir = &((PIMAGE_NT_HEADERS32)Header)->OptionalHeader.
            DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
        break;
    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
        DebugDataDir = &((PIMAGE_NT_HEADERS64)Header)->OptionalHeader.
            DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
        break;
    default:
        DebugDataDir = NULL;
        break;
    }

    //
    // Unmap sections.
    //

    PIMAGE_SECTION_HEADER SecHeader = IMAGE_FIRST_SECTION(Header);
    for (i = 0; i < Header->FileHeader.NumberOfSections; i++)
    {
        if (SecHeader->SizeOfRawData == 0)
        {
            SecHeader++;
            continue;
        }

        if (DebugDataDir != NULL &&
            DebugDataDir->VirtualAddress >= SecHeader->VirtualAddress &&
            DebugDataDir->VirtualAddress < SecHeader->VirtualAddress +
            SecHeader->SizeOfRawData)
        {
            ULONG Dir;
            
            DebugDir = (PIMAGE_DEBUG_DIRECTORY)
                ((PUCHAR)Image->MappedImageBase +
                 (DebugDataDir->VirtualAddress -
                  SecHeader->VirtualAddress +
                  SecHeader->PointerToRawData));
            Dir = DebugDataDir->Size / sizeof(*DebugDir);
            while (Dir-- > 0)
            {
                if (!IsBadReadPtr(DebugDir, sizeof(*DebugDir)) &&
                    DebugDir->AddressOfRawData != 0 &&
                    DebugDir->PointerToRawData >= Image->SizeOfImage &&
                    MemoryMap_GetRegionInfo(Image->BaseOfImage +
                                            DebugDir->AddressOfRawData,
                                            &RegBase, &RegSize, NULL,
                                            &RegImage) &&
                    RegImage == Image)
                {
#ifdef DBG_IMAGE_MAP
                    dprintf("    Unmap hidden debug data at RVA %08x, "
                            "size %x\n",
                            DebugDir->AddressOfRawData, DebugDir->SizeOfData);
#endif
                
                    MemoryMap_RemoveRegion(RegBase, RegSize);
                }

                DebugDir++;
            }
        }
            
        // Code segments may be fragmented by the overlap handling
        // splitting them up when they overlap with code memory
        // areas recorded in the dump.  Iterate over the sections
        // and clean up everything that's tagged as coming from this
        // image.
        
        ULONG64 SecBase = Image->BaseOfImage + SecHeader->VirtualAddress;
        ULONG SecSize = SecHeader->SizeOfRawData;

        while (SecSize > 0)
        {
            if (!MemoryMap_GetRegionInfo(SecBase, &RegBase, &RegSize, NULL,
                                         &RegImage))
            {
                ErrOut("UnloadEIM %s: Unable to get section %d "
                       "fragment at %s\n",
                       Image->ImagePath, i, FormatAddr64(SecBase));
                break;
            }

            if (RegImage == Image)
            {
                MemoryMap_RemoveRegion(RegBase, RegSize);
            }

            SecBase += RegSize;
            if (RegSize <= SecSize)
            {
                SecSize -= RegSize;
            }
            else
            {
                break;
            }
        }

        SecHeader++;
    }

    MemoryMap_RemoveRegion(Image->BaseOfImage,
                           Header->OptionalHeader.SizeOfHeaders);
    UnmapViewOfFile(Image->MappedImageBase);
    Image->MappedImageBase = NULL;
    CloseHandle(Image->File);
    Image->File = NULL;
    Image->MappedImagePath[0] = 0;

    return TRUE;
}

#if DBG

void
DbgAssertionFailed(PCSTR File, int Line, PCSTR Str)
{
    char Text[512];

    _snprintf(Text, sizeof(Text),
              "Assertion failed: %s(%d)\n  %s\n",
              File, Line, Str);
    OutputDebugStringA(Text);

    if (getenv("DBGENG_ASSERT_BREAK"))
    {
        DebugBreak();
    }
    else
    {
        ErrOut("%s", Text);
        FlushCallbacks();
    }
}

#endif // #if DBG

void
ExceptionRecordTo64(PEXCEPTION_RECORD Rec,
                    PEXCEPTION_RECORD64 Rec64)
{
    ULONG i;

    Rec64->ExceptionCode    = Rec->ExceptionCode;
    Rec64->ExceptionFlags   = Rec->ExceptionFlags;
    Rec64->ExceptionRecord  = (ULONG64)Rec->ExceptionRecord;
    Rec64->ExceptionAddress = (ULONG64)Rec->ExceptionAddress;
    Rec64->NumberParameters = Rec->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)
    {
        Rec64->ExceptionInformation[i] = Rec->ExceptionInformation[i];
    }
}

void
ExceptionRecord64To(PEXCEPTION_RECORD64 Rec64,
                    PEXCEPTION_RECORD Rec)
{
    ULONG i;

    Rec->ExceptionCode    = Rec64->ExceptionCode;
    Rec->ExceptionFlags   = Rec64->ExceptionFlags;
    Rec->ExceptionRecord  = (PEXCEPTION_RECORD)(ULONG_PTR)
        Rec64->ExceptionRecord;
    Rec->ExceptionAddress = (PVOID)(ULONG_PTR)
        Rec64->ExceptionAddress;
    Rec->NumberParameters = Rec64->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)
    {
        Rec->ExceptionInformation[i] = (ULONG_PTR)
            Rec64->ExceptionInformation[i];
    }
}

void
MemoryBasicInformationTo64(PMEMORY_BASIC_INFORMATION Mbi,
                           PMEMORY_BASIC_INFORMATION64 Mbi64)
{
#ifdef _WIN64
    memcpy(Mbi64, Mbi, sizeof(*Mbi64));
#else
    Mbi64->BaseAddress = (ULONG64) Mbi->BaseAddress;
    Mbi64->AllocationBase = (ULONG64) Mbi->AllocationBase;
    Mbi64->AllocationProtect = Mbi->AllocationProtect;
    Mbi64->__alignment1 = 0;
    Mbi64->RegionSize = Mbi->RegionSize;
    Mbi64->State = Mbi->State;
    Mbi64->Protect = Mbi->Protect;
    Mbi64->Type = Mbi->Type;
    Mbi64->__alignment2 = 0;
#endif
}

void
MemoryBasicInformation32To64(PMEMORY_BASIC_INFORMATION32 Mbi32,
                             PMEMORY_BASIC_INFORMATION64 Mbi64)
{
    Mbi64->BaseAddress = EXTEND64(Mbi32->BaseAddress);
    Mbi64->AllocationBase = EXTEND64(Mbi32->AllocationBase);
    Mbi64->AllocationProtect = Mbi32->AllocationProtect;
    Mbi64->__alignment1 = 0;
    Mbi64->RegionSize = Mbi32->RegionSize;
    Mbi64->State = Mbi32->State;
    Mbi64->Protect = Mbi32->Protect;
    Mbi64->Type = Mbi32->Type;
    Mbi64->__alignment2 = 0;
}

void
DebugEvent32To64(LPDEBUG_EVENT32 Event32,
                 LPDEBUG_EVENT64 Event64)
{
    Event64->dwDebugEventCode = Event32->dwDebugEventCode;
    Event64->dwProcessId = Event32->dwProcessId;
    Event64->dwThreadId = Event32->dwThreadId;
    Event64->__alignment = 0;
    
    switch(Event32->dwDebugEventCode)
    {
    case EXCEPTION_DEBUG_EVENT:
        ExceptionRecord32To64(&Event32->u.Exception.ExceptionRecord,
                              &Event64->u.Exception.ExceptionRecord);
        Event64->u.Exception.dwFirstChance =
            Event32->u.Exception.dwFirstChance;
        break;
        
    case CREATE_THREAD_DEBUG_EVENT:
        Event64->u.CreateThread.hThread =
            EXTEND64(Event32->u.CreateThread.hThread);
        Event64->u.CreateThread.lpThreadLocalBase =
            EXTEND64(Event32->u.CreateThread.lpThreadLocalBase);
        Event64->u.CreateThread.lpStartAddress =
            EXTEND64(Event32->u.CreateThread.lpStartAddress);
        break;
        
    case CREATE_PROCESS_DEBUG_EVENT:
        Event64->u.CreateProcessInfo.hFile =
            EXTEND64(Event32->u.CreateProcessInfo.hFile);
        Event64->u.CreateProcessInfo.hProcess =
            EXTEND64(Event32->u.CreateProcessInfo.hProcess);
        Event64->u.CreateProcessInfo.hThread =
            EXTEND64(Event32->u.CreateProcessInfo.hThread);
        Event64->u.CreateProcessInfo.lpBaseOfImage =
            EXTEND64(Event32->u.CreateProcessInfo.lpBaseOfImage);
        Event64->u.CreateProcessInfo.dwDebugInfoFileOffset =
            Event32->u.CreateProcessInfo.dwDebugInfoFileOffset;
        Event64->u.CreateProcessInfo.nDebugInfoSize =
            Event32->u.CreateProcessInfo.nDebugInfoSize;
        Event64->u.CreateProcessInfo.lpThreadLocalBase =
            EXTEND64(Event32->u.CreateProcessInfo.lpThreadLocalBase);
        Event64->u.CreateProcessInfo.lpStartAddress =
            EXTEND64(Event32->u.CreateProcessInfo.lpStartAddress);
        Event64->u.CreateProcessInfo.lpImageName =
            EXTEND64(Event32->u.CreateProcessInfo.lpImageName);
        Event64->u.CreateProcessInfo.fUnicode =
            Event32->u.CreateProcessInfo.fUnicode;
        break;
        
    case EXIT_THREAD_DEBUG_EVENT:
        Event64->u.ExitThread.dwExitCode =
            Event32->u.ExitThread.dwExitCode;
        break;
        
    case EXIT_PROCESS_DEBUG_EVENT:
        Event64->u.ExitProcess.dwExitCode =
            Event32->u.ExitProcess.dwExitCode;
        break;
        
    case LOAD_DLL_DEBUG_EVENT:
        Event64->u.LoadDll.hFile =
            EXTEND64(Event32->u.LoadDll.hFile);
        Event64->u.LoadDll.lpBaseOfDll =
            EXTEND64(Event32->u.LoadDll.lpBaseOfDll);
        Event64->u.LoadDll.dwDebugInfoFileOffset =
            Event32->u.LoadDll.dwDebugInfoFileOffset;
        Event64->u.LoadDll.nDebugInfoSize =
            Event32->u.LoadDll.nDebugInfoSize;
        Event64->u.LoadDll.lpImageName =
            EXTEND64(Event32->u.LoadDll.lpImageName);
        Event64->u.LoadDll.fUnicode =
            Event32->u.LoadDll.fUnicode;
        break;
        
    case UNLOAD_DLL_DEBUG_EVENT:
        Event64->u.UnloadDll.lpBaseOfDll =
            EXTEND64(Event32->u.UnloadDll.lpBaseOfDll);
        break;
        
    case OUTPUT_DEBUG_STRING_EVENT:
        Event64->u.DebugString.lpDebugStringData =
            EXTEND64(Event32->u.DebugString.lpDebugStringData);
        Event64->u.DebugString.fUnicode =
            Event32->u.DebugString.fUnicode;
        Event64->u.DebugString.nDebugStringLength =
            Event32->u.DebugString.nDebugStringLength;
        break;
        
    case RIP_EVENT:
        Event64->u.RipInfo.dwError =
            Event32->u.RipInfo.dwError;
        Event64->u.RipInfo.dwType =
            Event32->u.RipInfo.dwType;
        break;
    }
}

LPSTR
TimeToStr(
    ULONG TimeDateStamp
    )
{
    LPSTR TimeDateStr;

    // Handle invalid \ page out timestamps, since ctime blows up on
    // this number

    if ((TimeDateStamp == 0) || (TimeDateStamp == UNKNOWN_TIMESTAMP))
    {
        return "unavailable";
    }
    else if (IS_LIVE_KERNEL_TARGET() && TimeDateStamp == 0x49ef6f00)
    {
        // At boot time the shared memory data area is not
        // yet initialized.  The above value seems to be
        // the random garbage that's there so detect it and
        // ignore it.  This is highly fragile but people
        // keep asking about the garbage value.
        return "unavailable until booted";
    }
    else
    {
        // TimeDateStamp is always a 32 bit quantity on the target,
        // and we need to sign extend for 64 bit host since time_t
        // has been extended to 64 bits.


        time_t TDStamp = (time_t) (LONG) TimeDateStamp;
        TimeDateStr = ctime((time_t *)&TDStamp);

        if (TimeDateStr)
        {
            TimeDateStr[strlen(TimeDateStr) - 1] = 0;
        }
        else
        {
            TimeDateStr = "***** Invalid";
        }
    }

    return TimeDateStr;
}

PCSTR
PathTail(PCSTR Path)
{
    PCSTR Tail = Path + strlen(Path);
    while (--Tail >= Path)
    {
        if (*Tail == '\\' || *Tail == '/' || *Tail == ':')
        {
            break;
        }
    }

    return Tail + 1;
}

BOOL
MatchPathTails(PCSTR Path1, PCSTR Path2)
{
    return _stricmp(PathTail(Path1), PathTail(Path2)) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\symtype.cpp ===
/*******************************************************************
*
*    Copyright (c) 1999-2001  Microsoft Corporation
*
*    DESCRIPTIO:
*       Use PDB information to get type info and decode a symbol address
*
*    AUTHOR: Kshitiz K. Sharma
*
*    DATE:4/19/1999
*
*******************************************************************/


#include "ntsdp.hpp"
#include "cvconst.h"
#include <windef.h>
#include <time.h>

//
// Define the print routines - normal and verbose
//
#define typPrint      if (!(Options & NO_PRINT)) dprintf64
#define vprintf       if (Options & VERBOSE) typPrint
#define ExtPrint      if ((Options & DBG_RETURN_TYPE_VALUES) && (Options & DBG_RETURN_TYPE)) dprintf64
#define EXT_PRINT_INT64(v) if (((ULONG64) v) >= 10) { ExtPrint("0x%s", FormatDisp64(v));  } else { ExtPrint("%I64lx", (v));}
#define EXT_PRINT_INT(v) ExtPrint((((ULONG) v) >= 10 ? "%#lx" : "%lx"),  (v) ) 

//
// Store the frequently refeenced types
//
ReferencedSymbolList g_ReferencedSymbols;

ULONG64 LastReadError;
BOOL    g_EnableUnicode = FALSE;
ULONG   g_TypeOptions;

#define IsAPrimType(typeIndex)       (typeIndex < 0x0fff)
#define DBG_DERIVED_TYPE_FLAG        0x80000000
#define IsDbgDerivedType(TI) ((TI) & DBG_DERIVED_TYPE_FLAG)


#define IsIdStart(c) ((c=='_') || (c=='!') || ((c>='A') && (c<='Z')) || ((c>='a') && (c<='z')))
#define IsIdChar(c) (IsIdStart(c) || isdigit(c))

#define TypeVerbose (Options & VERBOSE)
#define SYM_LOCAL (SYMF_REGISTER | SYMF_REGREL | SYMF_FRAMEREL)

#define IsPrintChar(c) (((UCHAR) c >= 0x20) && ((UCHAR) c <= 0x7e))
#define IsPrintWChar(wc) (((WCHAR) wc >= 0x20) && ((WCHAR) wc <= 0x7e))

#define DBG_NATIVE_TYPE_FLAG         0x40000000
#define IsDbgNativeType(TI) ((TI) & DBG_NATIVE_TYPE_FLAG)

// Special pre-defined types
DBG_NATIVE_TYPE g_DbgNativeTypes[] = {
    {"void",   btVoid,      1},
    {"wchar",  btWChar,     2},
    {"float",  btFloat,     4},
    {"double", btFloat,     8},
    {"char",   btChar,      1},
    {"short",  btInt,       2},
    {"int",    btInt,       4},
    {"long",   btInt,       4},
    {"int64",  btInt,       8},
    {"unsigned char",    btUInt,       1},
    {"unsigned short",   btUInt,       2},
    {"unsigned int",     btUInt,       4},
    {"unsigned long",    btUInt,       4},
    {"unsigned int64",   btUInt,       8},
#if 0
    // For use of GetTypeName    
    {"short",  btInt16,       2},
    {"int",    btInt32,       4},
    {"int64",  btInt64,       8},
    {"unsigned short",  btUInt16,       2},
    {"unsigned int",    btUInt32,       4},
    {"unsigned int64",  btUInt64,       8},
#endif // 0
};

#define NUM_DBG_NATIVE_TYPES sizeof(g_DbgNativeTypes)/sizeof(DBG_NATIVE_TYPE)
#define NATIVE_TO_BT(TI) (((TI & ~DBG_NATIVE_TYPE_FLAG) < NUM_DBG_NATIVE_TYPES) ? \
                          (g_DbgNativeTypes[TI & ~DBG_NATIVE_TYPE_FLAG].TypeId) : 0)

//
// Initialise the return type DEBUG_SYMBOL_PARAMETER
//
#define GET_RETTYPE(S)        {S = m_pInternalInfo->pInfoFound->InternalParams;}
// (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) m_pDumpInfo->Context;}
//#define GET_RETSUBTYP(S)      {S = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) &m_pInternalInfo->pSymParams[m_pInternalInfo->CurrentSymParam];}
#define GET_RETSUBTYP(S)      \
{  if (m_pInternalInfo->NumSymParams > m_pInternalInfo->CurrentSymParam)                                   \
     S = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) &m_pInternalInfo->pSymParams[m_pInternalInfo->CurrentSymParam]; \
   else \
     S = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) &m_pInternalInfo->pSymParams[m_pInternalInfo->NumSymParams -1];\
}
#define GET_RETSUBTYP_INCR(S) {GET_RETSUBTYP(S); m_pInternalInfo->CurrentSymParam++;}

#define RET_TYPE(S, Adr, TI)  {S->Address = (Adr); S->TypeIndex = (TI);}
#define RET_SUBTYP(S, sAdr, sTI, n)  \
{S->ExpandTypeIndex = (sTI); S->ExpandTypeAddress = (sAdr); S->External.SubElements = (n);}
#define SUBTYP_COPYNAME(S,name)              \
{ if (m_pInternalInfo->CopyName && (S->Name.Length > strlen(name))) strcpy(S->Name.Buffer, name);}
#define STORE_INFO(ti, addr, sz, sub, saddr) \
    if (m_pInternalInfo->pInfoFound && (!m_pNextSym || !*m_pNextSym) &&       \
       ((m_ParentTag != SymTagPointerType) || (m_pSymPrefix && *m_pSymPrefix == '*')) ) {       \
        PTYPES_INFO_ALL pty = &m_pInternalInfo->pInfoFound->FullInfo;         \
        pty->TypeIndex = ti; pty->Address = addr; pty->SubElements = sub;     \
        pty->Size = sz; pty->SubAddr = saddr;                                 \
    }
#define STORE_PARENT_EXPAND_ADDRINFO(addr)                                                 \
    if (m_pInternalInfo->pInfoFound && (!m_pNextSym || !*m_pNextSym) ) {                    \
       m_pInternalInfo->pInfoFound->ParentExpandAddress = addr;                             \
    }

//
// Copies a length prefix string into name, first byte gives length
//
#define GetLengthPreName(start) {\
    strncpy((char *)(name), (char *)(start)+1, *((UCHAR *)start)); \
    name[*( (UCHAR*) start)]='\0';\
}

#define Indent(nSpaces)                    \
{                                          \
  int i;                                   \
  if (!(Options & (NO_INDENT | DBG_DUMP_COMPACT_OUT))) {           \
     if (!(Options & NO_PRINT)) {                                  \
         StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP); \
     }                                     \
     for (i=0;i<nSpaces;++i) {             \
        typPrint(" ");                     \
     }                                     \
  }                                        \
}                                          \

ULONG
FindTypeInfoInDefaultMod(
    IN HANDLE  hProcess,
    IN PCHAR   SymName,
    IN BOOL    Load,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO    pTypeInfo
    );
void
ClearAllFastDumps();
 
ULONG 
GetNativeTypeSize(
    PCHAR Name,
    ULONG typeIndex
    )
{
    ULONG Size = 0;

    if (NATIVE_TO_BT(typeIndex)) {
        return g_DbgNativeTypes[typeIndex & ~DBG_NATIVE_TYPE_FLAG].Size;
    }
    /*
    for (int i=0; i<NUM_DBG_NATIVE_TYPES; i++) { 
        if (Name) {
            if (!_stricmp(g_DbgNativeTypes[i].TypeName, Name)) {
                return g_DbgNativeTypes[i].Size;
            }
        } 
        if (g_DbgNativeTypes[i].TypeId == typeIndex) {
            Size = g_DbgNativeTypes[i].Size;
        }
    }*/
    return 0;
}

//
// Memory allocation routines for this file
//
PVOID
AllocateMem( ULONG l ) {
    PVOID pBuff = malloc(l);
#if DBG_TYPE
    dprintf ("Alloc'd at %x \n", pBuff);
#endif
    return  pBuff;
}

VOID
FreeMem( PVOID pBuff ) {
#ifdef DBG_TYPE    
    dprintf ("Freed at %x \n", pBuff);
    --nAllocates;
#endif
    free ( pBuff );
}

/*
 * ReadTypeData
 *
 *  Reads data from source src to destination des
 *
 */
__inline ULONG
ReadTypeData (
    PUCHAR   des,
    ULONG64  src,
    ULONG    count,
    ULONG    Option
    )
{
    ULONG readCount=0;
    ADDR ad;                                                    
    if (src != 0) {
        if (!g_Machine->m_Ptr64 && !(Option & DBG_DUMP_READ_PHYSICAL)) {
            if ((ULONG64)(LONG64)(LONG) src != src) {             
                src = (ULONG64) ((LONG64)((LONG) (src)));         
            }                                                     
        }           

        ADDRFLAT(&ad, src);
        if (IS_KERNEL_TARGET() && (Option & DBG_DUMP_READ_PHYSICAL)) {
            if (g_Target->ReadPhysical(src, des, count, &readCount) != S_OK) {
                return readCount;
            }
        } else if (g_Target->ReadVirtual(src, des, count, &readCount) != S_OK) {                
            return readCount;
        }
        return readCount ? readCount : 1;
    }
    return FALSE;
}

//
// Read memory into destination d and store data into m_pInternalInfo->TypeDataPointer
// if Ioctl caller wants some data back
//
#define READ_BYTES(d, s, sz)                                                \
    if (!ReadTypeData((PUCHAR) (d), s, sz, m_pInternalInfo->TypeOptions)) {      \
         m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;                       \
         LastReadError = m_pInternalInfo->InvalidAddress = s; }                  \
    else if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer) { \
        memcpy(m_pInternalInfo->TypeDataPointer, d, sz);                         \
        /*d printf("cp %x at %#x ", sz, m_pInternalInfo->TypeDataPointer);  */   \
        m_pInternalInfo->TypeDataPointer += sz;                                  \
    }


//
// Reads and data is stored in kernel cache - used when we know we'd eventually 
// read all this memory in parts.
//
ULONG 
ReadInAdvance(ULONG64 addr, ULONG size, ULONG Options) {
    UCHAR buff[2048];
    ULONG toRead=size, read;

    while (toRead) {
        read = (toRead > sizeof (buff)) ? sizeof(buff) : toRead;
        // This caches the data if sufficient space available
        if (!ReadTypeData(buff, addr, read, Options))
            return FALSE;
        toRead -= read;
    }
    return TRUE;
}

__inline DBG_TYPES
SymTagToDbgType( ULONG SymTag)
{
    switch (SymTag) { 
    case SymTagPointerType:
        return DBG_TYP_POINTER;
    case SymTagUDT:
        return DBG_TYP_STRUCT;
    case SymTagArrayType:
        return DBG_TYP_ARRAY;
    case SymTagBaseType:
        return DBG_TYP_NUMBER;
    default:
        break;
    }
    return DBG_TYP_UNKNOWN;
}

//
// Insert a child name at the end of parent name list.
//
BOOL
InsertTypeName(
    PTYPE_NAME_LIST *Top,
    PTYPE_NAME_LIST NameToInsert
    ) 
{
    PTYPE_NAME_LIST iterator;
    
    if (!Top) {
        return FALSE;
    }

    NameToInsert->Next = NULL;

    if (*Top == NULL) {
        *Top = NameToInsert;
        return TRUE;
    } else
        for (iterator=*Top; iterator->Next!=NULL; iterator=iterator->Next) ;

    iterator->Next = NameToInsert;

    return TRUE;
}

//
// Remove and return a child name at the end of parent name list.
//
PTYPE_NAME_LIST
RemoveTypeName(
    PTYPE_NAME_LIST *Top
    ) 
{
    PTYPE_NAME_LIST iterator, itrParent;

    if (!Top) {
        return NULL;
    }

    if (*Top == NULL) {
        return NULL;
    }

    itrParent = NULL;
    for (iterator=*Top; iterator->Next!=NULL; iterator=iterator->Next)
        itrParent=iterator;


    if (itrParent) itrParent->Next = NULL;
    else *Top=NULL;
        
    return iterator;
}

PCHAR
GetParentName(
    PTYPE_NAME_LIST Top
    ) 
{
    PTYPE_NAME_LIST iterator, itrParent;

    if (!Top) {
        return NULL;
    }

    itrParent = NULL;
    for (iterator=Top; iterator->Next!=NULL; iterator=iterator->Next)
        itrParent=iterator;


    return iterator->Name;
}

ULONG WStrlen(PWCHAR str)
{
    ULONG result = 0;

    while (*str++ != UNICODE_NULL) {
        result++;
    }

    return result;
}

PCHAR FieldNameEnd(PCHAR Fields)
{
    while (Fields && IsIdChar(*Fields)) { 
        ++Fields;
    }
    if (Fields) {
        return Fields;
    }
    return NULL;
}


PCHAR NextFieldName(PCHAR Fields)
{
    BOOL FieldDeLim = FALSE;
    Fields = FieldNameEnd(Fields);
    while (Fields && *Fields) { 
        if (*Fields=='.') {
            FieldDeLim = TRUE;
            ++Fields;
            break;
        } else if (!strncmp(Fields,"->", 2)) {
            FieldDeLim = TRUE;
            Fields+=2;
            break;
        }
        ++Fields;
    }
    if (FieldDeLim) {
        return Fields;
    }
    return NULL;
}

void FieldChildOptions(PCHAR ChilField, PTYPE_DUMP_INTERNAL internalOpts)
{
    internalOpts->ArrayElementToDump = 0;
    internalOpts->DeReferencePtr     = 0;

    if (ChilField) {
        switch (*ChilField) { 
        case '.':
            // default - do nothing
            break;
        case '[':
            // Array - find which element requested
            ChilField++;
            if (sscanf(ChilField, "%ld", &internalOpts->ArrayElementToDump) == 1) {
                ++internalOpts->ArrayElementToDump;
            }
            break;
        case '-':
            // pointer, check and deref
            if (*(++ChilField) == '>') {
                internalOpts->DeReferencePtr = TRUE;
            }
            break;
        default:
            break;
        }
    }
}
/*
 * MatchField
 *      Routine to check whether a subfield, fName is specified in the fieldlist.
 *      If found, it returns "index of fName in fields"  +  1
 *      
 *      *ParentOfField returns non-zero value is "fName" could be parent of some
 *      field in "fields" list.
 */
ULONG 
DbgTypes::MatchField(
    LPSTR               fName, 
    PTYPE_DUMP_INTERNAL m_pInternalInfo,
    PFIELD_INFO_EX         fields,
    ULONG               nFields,
    PULONG              ParentOfField
    ) 
{
    USHORT i, FieldLevel;
    PTYPE_NAME_LIST ParentType=m_pInternalInfo->ParentTypes, ParentField=m_pInternalInfo->ParentFields; 
    PTYPE_NAME_LIST currParen;
    PCHAR Next=NULL, matchName;
    BOOL fieldMatched, parentFieldMatched, parentTypeMatched;
    ULONG  matchedFieldIndex=0;
    PCHAR  ChildFields=NULL;

    *ParentOfField=0;
    for (i=0; (i<nFields) && fields[i].fName; i++) {
        PCHAR NextParentField, End;

        fieldMatched = FALSE;
        
        NextParentField = (matchName = (PCHAR) &fields[i].fName[0]);
        Next = NextFieldName((char *)matchName);
        FieldLevel = 1;
        parentTypeMatched  = TRUE;
        parentFieldMatched = TRUE;
        ParentField = m_pInternalInfo->ParentFields;
        ParentType  = m_pInternalInfo->ParentTypes;

        while ( Next &&                                
               ((ParentType && parentTypeMatched) || 
                (ParentField && parentFieldMatched))) {
            // 
            // Match the parent field or type names if previous parents have matched
            // and there are more "parents" in matchName
            //

            End = FieldNameEnd(matchName);
            if (ParentField && parentFieldMatched) {

                if (strncmp( (char *)matchName,
                             ParentField->Name, 
                             (End - matchName )) ||
                    ((fields[i].fOptions & DBG_DUMP_FIELD_FULL_NAME) &&
                     (strlen((char *)ParentField->Name) != (ULONG) (End - matchName)) )) {
                    parentFieldMatched = FALSE;
                    break;
                }
                ParentField = ParentField->Next;
                NextParentField = Next;

            } else {
                if (strncmp( (char *)matchName,
                             ParentType->Name, 
                             (End - matchName )) ||
                    ((fields[i].fOptions & DBG_DUMP_FIELD_FULL_NAME) &&
                     (strlen((char *)ParentType->Name) != (ULONG) (End - matchName)) )) {
                    parentTypeMatched = FALSE;
                    break;
                }
                ParentType  = ParentType->Next;
            }

            FieldLevel++;
            matchName = Next;
            Next = NextFieldName(matchName);
        }
        
        if (parentFieldMatched && !ParentField && NextParentField) {
            PCHAR nextDot= NextFieldName( (char *)NextParentField);
            End = FieldNameEnd((PCHAR) NextParentField);
            
            if (nextDot &&
                !strncmp((char *)fName, 
                         (char *)NextParentField, 
                         (End - NextParentField)) &&
                (!(fields[i].fOptions & DBG_DUMP_FIELD_FULL_NAME) ||
                 (strlen((PCHAR) fName) == (ULONG) (End - NextParentField)))) {
                
                //
                // matchName :- A.b.c.d
                // Parentfields :- A.b && fName :- c
                //         then A.b.c "parent-matches" A.b.c.d
                //
                *ParentOfField = i+1;
                ChildFields = End;
#ifdef DBG_TYPE
                dprintf("Field %s parent-matched with %s NP %s Ch %s ND %s\n", 
                        fields[i].fName, fName, NextParentField, ChildFields, nextDot);
#endif
                continue;
            }

        }

        if (!parentFieldMatched && !parentTypeMatched) {
            // 
            // Parent names do not match
            continue;
        }

        //
        // Fields should match till the level we are in
        //
        if (FieldLevel != m_pInternalInfo->level) {
            continue;
        }

        //
        // Compare the field names
        //
        ChildFields = FieldNameEnd((char *) matchName);
        if (fields[i].fOptions & DBG_DUMP_FIELD_FULL_NAME) {
            if (!strncmp((char *)fName, (char *)matchName, (ULONG) (ChildFields - (char *)matchName)) &&
                (strlen(fName) == (ULONG) (ChildFields - (char *)matchName))) {
                fieldMatched = TRUE;
            }
        } else if (!strncmp((char *)fName, (char *)matchName, (ULONG) (ChildFields - (char *) matchName))) {
            fieldMatched = TRUE;
        }

        if (fieldMatched) {
#ifdef DBG_TYPE
            dprintf("Field %s matched with %s\n", fields[i].fName, fName);
#endif
            matchedFieldIndex = i+1;
            m_pInternalInfo->AltFields[i].FieldType.Matched = TRUE;
            m_pInternalInfo->FieldIndex = i;
        }
    }

    if (ChildFields) {

        FieldChildOptions(ChildFields, m_pInternalInfo);
        m_pNextSym = ChildFields;
    }
    return matchedFieldIndex;
}

#define MatchListField(Name, pMatched, pIsParent)                           \
{ PALT_FIELD_INFO OrigAltFields = m_pInternalInfo->AltFields;                    \
                                                                            \
  m_pInternalInfo->AltFields = &m_pInternalInfo->AltFields[m_pDumpInfo->nFields];       \
  *pMatched=MatchField(name, m_pInternalInfo, m_pDumpInfo->listLink, 1, pIsParent);\
  m_pInternalInfo->AltFields = OrigAltFields;                                    \
}\


/*
 *Function Name: printString
 *
 * Parameters: ULONG64 addr, ULONG size, ULONG Options
 *
 * Description: 
 *     Prints out a normal/ wide char / multi / GUID string from addr depending on the options
 *
 * Returns: Size of string printed
 *
 */
ULONG 
printString(ULONG64 addr, ULONG size, ULONG Options) {
    ULONG buffSize=2*MAX_NAME, bytesRead=0, readNow, count;
    CHAR buff[2*MAX_NAME+8];
    BOOL knownSize, done;


    if ((Options & NO_PRINT) || !addr || !(Options & DBG_DUMP_FIELD_STRING)) {
        return size;
    }

    Options &= DBG_DUMP_FIELD_STRING | DBG_DUMP_COMPACT_OUT;

    if (Options & DBG_DUMP_FIELD_GUID_STRING) {
        size=16*(Options & DBG_DUMP_FIELD_WCHAR_STRING ? 2 : 1) ; // Length of a GUID
    }

    knownSize = size;
    while (!knownSize || (bytesRead < size)) {
        USHORT start =0;

        done=FALSE;
        ZeroMemory(&buff[0], sizeof(buff));

        if (knownSize) {
            readNow=min(buffSize, size);
        } else {
            readNow=buffSize;
        }

        if (!(count = ReadTypeData((PUCHAR)&buff[0], addr + bytesRead, readNow, Options & ~DBG_DUMP_FIELD_STRING))) {
            return 0;
        }
        bytesRead+=count;

        // Print the string
        while (!done) { // For MultiStrings
            int i;
            if (Options & DBG_DUMP_FIELD_WCHAR_STRING) {
                PWCHAR wstr = (WCHAR*) &buff[start];

                for (i=0; 
                     wstr[i] && (IsPrintWChar(wstr[i]) || wstr[i] == '\t' || wstr[i] == '\n');
                     ++i);
                // Unprintable strings
                if (!IsPrintWChar(wstr[i]) && wstr[i] && wstr[i] != '\t' && wstr[i] != '\n') {
                    wstr[i++] = '?';
                    wstr[i++] = '?';
                    wstr[i++] = '?';
                }
                wstr[i]=0;
                dprintf("%ws", wstr);
                done=TRUE;
                start += (i+1)*2;
                if ((Options & DBG_DUMP_FIELD_MULTI_STRING) &&
                    (*((WCHAR *) &buff[start]) != (WCHAR) NULL)) {
                    done=FALSE;;
                    dprintf(" ");
                } else {
                    size = i;
                }
            } else if (Options & DBG_DUMP_FIELD_GUID_STRING) { // GUID
                dprintf("{");
                for (i=0;i<16;i++) {
                    if ((i==4) || (i==6) || (i==8) || (i==10)) {
                        dprintf("-");
                    }
                    if (i<4) {
                        dprintf("%02x", (UCHAR) buff[3-i]);
                    } else if (i<6) {
                        dprintf("%02x", (UCHAR) buff[9-i]);
                    } else if (i<8) {
                        dprintf("%02x", (UCHAR) buff[13-i]);
                    } else {
                        dprintf("%02x", (UCHAR) buff[i]);
                    }
                } /* for */
                dprintf("}");
                return 16;
            } else { // DBG_DUMP_DEFAULT_STRING
                for (i=0; 
                     buff[i] && (IsPrintChar(buff[i]) || buff[i] == '\t' || buff[i] == '\n'); 
                     ++i);
                // Unprintable strings
                if (!IsPrintWChar(buff[i]) && buff[i] && buff[i] != '\t' && buff[i] != '\n') {
                    buff[i++] = '?';
                    buff[i++] = '?';
                    buff[i++] = '?';
                }
                buff[i]=0;
                dprintf("%s", (CHAR*) &buff[start]);
                done=TRUE;
                start += (i+1);
                if ((Options & DBG_DUMP_FIELD_MULTI_STRING) &&
                    (*((CHAR *) &buff[start]) != (CHAR) NULL)) {
                    done = FALSE;
                    dprintf(" ");
                } else {
                    size = i;
                }
            }
        } /* while !done */
        if ((start <= readNow) || (bytesRead > MAX_NAME)) {
            knownSize = TRUE;
        }

        if (count<readNow) {
            // we can't read enough memory
            break;
        }

    }
    return bytesRead;
} /* End function printString */

//
// The string at address is :
//   { Length (2 bytes), MaxLen (2 bytes), Str address ( pointer) }
//
void 
printStructString(
    ULONG64 Address,
    ULONG   Option,
    ULONG   StrOpts
    )
{
    USHORT Length;
    ULONG64 StrAddress;

    if ((Option & NO_PRINT) && !(Option & DBG_RETURN_TYPE_VALUES)) {
        return;
    }
    if (ReadTypeData((PUCHAR) &Length, Address, sizeof(Length), Option) &&
        ReadTypeData((PUCHAR) &StrAddress, Address + 4, g_Machine->m_Ptr64 ? 8 : 4, Option)) {
        StrAddress = (g_Machine->m_Ptr64 ? StrAddress : (ULONG64) (LONG64) (LONG) StrAddress);
        dprintf("\"");
        printString(StrAddress, Length, StrOpts);
        dprintf("\"");
    }


}

ULONG
GetSizeOfTypeFromIndex(ULONG64 Mod, ULONG TypIndx)
{
    SYM_DUMP_PARAM_EX Sym = {0};
    Sym.size = sizeof(SYM_DUMP_PARAM_EX); Sym.Options = (GET_SIZE_ONLY | NO_PRINT);

    TYPES_INFO ti = {0};
    ti.hProcess = g_CurrentProcess->Handle;
    ti.ModBaseAddress = Mod;
    ti.TypeIndex = TypIndx;

    return DumpType(&ti, &Sym, &ti.Referenced);
}

DbgDerivedType::DbgDerivedType(
    PTYPE_DUMP_INTERNAL pInternalDumpInfo,
    PTYPES_INFO         pTypeInfo,
    PSYM_DUMP_PARAM_EX     pExternalDumpInfo) 
    : DbgTypes(pInternalDumpInfo, pTypeInfo, pExternalDumpInfo)
{ 
    m_SpTypes=NULL; 

    if (IsDbgDerivedType(pTypeInfo->TypeIndex)) {
        PCHAR TypeName = (PCHAR) pExternalDumpInfo->sName;
        if (GetSpecialTypes(TypeName, pTypeInfo->TypeIndex, &m_SpTypes) != S_OK)
            m_SpTypes=NULL; 
    }

}


//
// Handle &Sym.a expressions
//
ULONG 
DbgDerivedType::DumpAddressOf(
    ULONG               ptrSize,
    ULONG               ChildIndex
    )
{
    ULONG myTI = m_typeIndex;
    ULONG Options = m_pInternalInfo->TypeOptions;
    if (m_pInternalInfo->IsAVar || m_pDumpInfo->addr) {
        // Just IsAVar check should be enough, but OutputSymbol may need the other
        TYPE_DUMP_INTERNAL Save;

        Save = *m_pInternalInfo;
        vprintf("Address of %s ", m_pDumpInfo->sName);
        
        // Get The address of requested type / symbol
        m_pInternalInfo->TypeOptions &= ~(DBG_RETURN_TYPE_VALUES | DBG_RETURN_SUBTYPES | DBG_RETURN_TYPE);
        m_pInternalInfo->TypeOptions |= NO_PRINT;
        FIND_TYPE_INFO FindInfo={0}, *pSave;
        pSave = m_pInternalInfo->pInfoFound;
        m_pInternalInfo->pInfoFound = &FindInfo;
        DumpType();

        typPrint("%s ", FormatAddr64 (FindInfo.FullInfo.Address));
        ExtPrint("%s",  FormatAddr64 (FindInfo.FullInfo.Address));
        *m_pInternalInfo = Save;
        m_ParentTag = m_SymTag;
        m_SymTag = SymTagPointerType;
     //   m_typeIndex = FindInfo.FullInfo.TypeIndex;
        if (!(Options & DBG_RETURN_TYPE_VALUES)) {
            DumpType();
        }
        if (!FindInfo.FullInfo.TypeIndex) {
            FindInfo.FullInfo.TypeIndex = ChildIndex;
        }
        STORE_INFO(DBG_DERIVED_TYPE_FLAG | FindInfo.FullInfo.TypeIndex, 
                   FindInfo.FullInfo.Address,
                   ptrSize,
                   1, 
                   FindInfo.FullInfo.Address);
//        if (pSave) {
//            pSave->FullInfo.Value = FindInfo.FullInfo.Address;
//            pSave->FullInfo.Flags |= IMAGEHLP_SYMBOL_INFO_VALUEPRESENT;
//        }
        return ptrSize;
    }
    return ptrSize;
}


//
// Handle TYP ** expressions
//
ULONG 
DbgDerivedType::DumpPointer(
    ULONG               ptrSize,
    ULONG               ChildIndex,
    DBG_DE_TYPE        *pPtrType
    )
{
    ULONG   Options  = m_pInternalInfo->TypeOptions;
    ULONG64 ReadAddr = 0, saveAddr=0, saveOffset=0; 
    BOOL    DumpChild= TRUE;
    BOOL    CopyData=FALSE;
    PUCHAR  DataBuffer=NULL;

    if (m_pDumpInfo->addr) {
        ULONG64 PtrVal=0;

        m_pInternalInfo->PtrRead = TRUE;
        ReadAddr = m_pDumpInfo->addr + m_pInternalInfo->totalOffset;

        READ_BYTES(&PtrVal, ReadAddr, ptrSize);
        if (ptrSize!=sizeof(ULONG64)) {
            //
            // Signextend the read pointer value
            //
            PtrVal = (ULONG64) (LONG64) (LONG) PtrVal;
        }
        STORE_INFO(m_typeIndex, ReadAddr, ptrSize, 1, PtrVal);

        if (m_pInternalInfo->CopyDataInBuffer && !m_pInternalInfo->CopyDataForParent) {
            *((PULONG64) (m_pInternalInfo->TypeDataPointer - ptrSize)) = PtrVal;
            //
            // We return size as 8 for 32 bit *copied* pointers.
            //
            m_pInternalInfo->TypeDataPointer -= ptrSize;
            ptrSize = 8;
            m_pInternalInfo->TypeDataPointer += ptrSize;

            //
            // Cannot go on copying the pointed value
            //
            CopyData = TRUE;
            DataBuffer = m_pInternalInfo->TypeDataPointer;
            m_pInternalInfo->CopyDataInBuffer = FALSE;
            m_pInternalInfo->TypeDataPointer = NULL;
        }
        ExtPrint("%s", FormatAddr64(PtrVal));

        if (Options & DBG_RETURN_SUBTYPES && m_ParentTag) {
            PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymInternal;

//          SymInternal = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) &m_pInternalInfo->pSymParams[m_pInternalInfo->CurrentSymParam++];
            GET_RETSUBTYP_INCR(SymInternal);

            RET_TYPE(SymInternal, ReadAddr, m_typeIndex); 

            SUBTYP_COPYNAME(SymInternal, "Pointer");

            STORE_PARENT_EXPAND_ADDRINFO(ReadAddr);
            if (ChildIndex) {

                RET_SUBTYP(SymInternal, PtrVal, ChildIndex, 1);
            }

            m_pInternalInfo->RefFromPtr = 1;
            m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
            m_pInternalInfo->TypeOptions |= DBG_RETURN_TYPE;
            m_pInternalInfo->pInfoFound->InternalParams = SymInternal;

            SymInternal->Size    = ptrSize;

            // NOTE :-
            //      Make this part of DumpDbgDerivedType later
            //
            DumpChild            = FALSE;//!IsDbgDerivedType(ChildIndex);
//            if (IsDbgDerivedType(ChildIndex)) {
            strncpy(SymInternal->TypeName, (PCHAR)(m_pDumpInfo->sName+pPtrType->StartIndex),
                    pPtrType->Namelength);
            SymInternal->Flags |= TYPE_NAME_USED;
//            }
        } else if (Options & DBG_RETURN_TYPE) {
            PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymInternal;

            GET_RETTYPE(SymInternal);
//            SymInternal = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) m_pDumpInfo->Context;

            // We found all we needed here itself

            RET_SUBTYP(SymInternal, PtrVal, ChildIndex, 1);
            
            ULONG strOpts = m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING;
            SymInternal->Size    = ptrSize;
            // NOTE :-
            //      Make this part of DumpDbgDerivedType later
            //
            DumpChild            = !IsDbgDerivedType(ChildIndex);

            saveAddr = m_pDumpInfo->addr;
            saveOffset = m_pInternalInfo->totalOffset;

            m_pDumpInfo->addr         = PtrVal;
            m_pInternalInfo->totalOffset = 0;
            
            if (CheckAndPrintStringType(ChildIndex, 0)) {
                DumpChild = FALSE;
            }
            /* if ((Options & DBG_RETURN_TYPE_VALUES) && 
                IsAPrimType(ChildIndex) &&
                ((ChildIndex == T_CHAR) || (ChildIndex == T_RCHAR) || 
                 (ChildIndex == T_WCHAR) || (ChildIndex == T_UCHAR)) ||
                strOpts) {

                if (!strOpts) {
                    strOpts |= (ChildIndex == T_WCHAR) ? 
                        DBG_DUMP_FIELD_WCHAR_STRING : DBG_DUMP_FIELD_DEFAULT_STRING ;
                }
                ExtPrint(" \"");
                printString(PtrVal, 0, strOpts);
                ExtPrint("\"");
            }*/
        } else if (PtrVal) {
            typPrint("0x%s", FormatAddr64(PtrVal));

            saveAddr = m_pDumpInfo->addr;
            saveOffset = m_pInternalInfo->totalOffset;

            m_pDumpInfo->addr         = PtrVal;
            m_pInternalInfo->totalOffset = 0;
            
            if (!(Options & (NO_PRINT | GET_SIZE_ONLY))) {
                ULONG strOpts=m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING;
                if (CheckAndPrintStringType(ChildIndex, 0)) {
                    DumpChild = FALSE;
                }
/*                if ((ChildIndex == T_CHAR)  || (ChildIndex == T_RCHAR) || 
                    (ChildIndex == T_WCHAR) || (ChildIndex == T_UCHAR) ||
                    (m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING)) {  
                    // SPECIAL CASE, treat every pointer as string

                    if (!strOpts) {
                        strOpts |= (ChildIndex == T_WCHAR) ? 
                            DBG_DUMP_FIELD_WCHAR_STRING : DBG_DUMP_FIELD_DEFAULT_STRING ;
                    }
                    typPrint(" \"");
                    printString(PtrVal, m_pInternalInfo->StringSize, strOpts);
                    typPrint("\"");
                    DumpChild            = FALSE;
                }*/
            } 

        } else {
            typPrint("%s",
                     ((m_pInternalInfo->ErrorStatus==MEMORY_READ_ERROR) && (ReadAddr == m_pInternalInfo->InvalidAddress)
                      ? "??" : "(null)"));
            DumpChild            = FALSE;
        }
        
        vprintf(" Ptr%s to ", (g_Machine->m_Ptr64 ? "32" : "64"));
    } else {
        typPrint("Ptr%s to ", (ptrSize==4 ? "32" : "64"));
    }

    
    if (!(m_pInternalInfo->TypeOptions & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    }
    if (DumpChild) {
        m_typeIndex = ChildIndex;
        if (m_pInternalInfo->ArrayElementToDump) {
            // treat pointer as an array
            ULONG64 ChSize = GetTypeSize();
            
            m_pInternalInfo->totalOffset += ChSize * (m_pInternalInfo->ArrayElementToDump -1);
        }
        DumpType();
        if (m_pDumpInfo->addr) {
            m_pDumpInfo->addr = saveAddr;
            m_pInternalInfo->totalOffset = saveOffset;
        }
    }

    if (CopyData) {
        //
        // Restore the copy buffer values
        //  
        m_pInternalInfo->CopyDataInBuffer = TRUE;
        m_pInternalInfo->TypeDataPointer =  DataBuffer;
    }

    m_pInternalInfo->TypeOptions  = Options;

    return ((m_pInternalInfo->ErrorStatus==MEMORY_READ_ERROR) && (ReadAddr == m_pInternalInfo->InvalidAddress)) ?
        0 : ptrSize;
}

//
// Handle TYPE[<array limit>] expressions, process as array element if its a var[<inxed>]
//
ULONG
DbgDerivedType::DumpSilgleDimArray(
    IN ULONG               NumElts,
    IN ULONG               EltType
    )
{
    ULONG  EltSize = GetTypeSize();
    ULONG  ArrSize = EltSize * NumElts;
    PUCHAR savedBuffer=NULL;
    ULONG  Options = m_pInternalInfo->TypeOptions;
    BOOL   CopyData=FALSE;

    if (m_pInternalInfo->IsAVar && !m_SpTypes) {
        // Its a symbol, we need to dump index NumElts
        m_pInternalInfo->ArrayElementToDump = NumElts+1;
        return DumpType();
    } else {
        typPrint("[%d] ", NumElts);
    }
    
    if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer && m_pDumpInfo->addr &&
        (Options & GET_SIZE_ONLY)) {
        //
        // Copy the data
        //
        if (!ReadTypeData(m_pInternalInfo->TypeDataPointer, 
                          m_pDumpInfo->addr + m_pInternalInfo->totalOffset, 
                          ArrSize, 
                          m_pInternalInfo->TypeOptions)) {
            m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
            m_pInternalInfo->InvalidAddress = m_pDumpInfo->addr + m_pInternalInfo->totalOffset;
            return 0;
        }

        m_pInternalInfo->TypeDataPointer += ArrSize;
        savedBuffer = m_pInternalInfo->TypeDataPointer;
        CopyData = TRUE;
        m_pInternalInfo->CopyDataInBuffer = FALSE;
    }
    
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymInternal;
    
    STORE_INFO(m_typeIndex, m_pDumpInfo->addr + m_pInternalInfo->totalOffset, ArrSize, NumElts, 
               m_pDumpInfo->addr + m_pInternalInfo->totalOffset);

    if (Options & (DBG_RETURN_TYPE)) {
        PCHAR ArrayData;

        GET_RETTYPE(SymInternal);
//        SymInternal  = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) m_pDumpInfo->Context;;

        RET_SUBTYP(SymInternal, m_pDumpInfo->addr + m_pInternalInfo->totalOffset,
                   m_typeIndex, NumElts);
    
        if (CheckAndPrintStringType(EltType, ArrSize)) {

        } else {
            ExtPrint("Array [%d]", NumElts);
        }
        return ArrSize;
    }

    if (Options & DBG_RETURN_SUBTYPES) {

        STORE_PARENT_EXPAND_ADDRINFO(m_pDumpInfo->addr + m_pInternalInfo->totalOffset);

        for (m_pInternalInfo->CurrentSymParam=0;
             m_pInternalInfo->CurrentSymParam < NumElts; 
             m_pInternalInfo->CurrentSymParam++) { 

            GET_RETSUBTYP(SymInternal);
//          SymInternal = (PDEBUG_SYMBOL_PARAMETERS_INTERNAL) &m_pInternalInfo->pSymParams[m_pInternalInfo->CurrentSymParam];

            RET_TYPE(SymInternal,
                     m_pDumpInfo->addr + m_pInternalInfo->totalOffset + EltSize*m_pInternalInfo->CurrentSymParam,
                     EltType);

            SymInternal->Size      = EltSize;
            if (m_pInternalInfo->CopyName && (SymInternal->Name.Length > 8)) {
                sprintf(SymInternal->Name.Buffer, "[%d]", m_pInternalInfo->CurrentSymParam);
            }
        } 
        m_pInternalInfo->CopyName = 0;
    }
    if (Options & GET_SIZE_ONLY) {
        return ArrSize;
    }

    if (m_pDumpInfo->addr) {
        // Dump array contents
        ULONG64 tmp = m_pDumpInfo->addr;

        if (CheckAndPrintStringType(EltType, ArrSize)) {
                return ArrSize;
        }
    }

    ULONG szLen=0, index=0;
    ULONG64 saveAddr = m_pDumpInfo->addr;
    do {
        if (Options & DBG_RETURN_SUBTYPES) {
            m_pInternalInfo->pInfoFound->InternalParams = &m_pInternalInfo->pSymParams[index];
//            m_pDumpInfo->Context = (PVOID) &m_pInternalInfo->pSymParams[index];
            m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
            m_pInternalInfo->TypeOptions |=  DBG_RETURN_TYPE;
            ++m_pInternalInfo->level;
        }
        if ((m_pInternalInfo->level && (m_pInternalInfo->FieldOptions & FIELD_ARRAY_DUMP))) {
            Indent(m_pInternalInfo->level*3);
            typPrint(" [%02d] ", index);
        }
        szLen=DumpType();

        if ((Options & DBG_DUMP_COMPACT_OUT ) && (Options & FIELD_ARRAY_DUMP) ) {
            typPrint("%s", ((szLen>8) || (index % 4 == 0)) ? "\n":" ");
        }
        if (!szLen) {
            break;
        }
        if (Options & DBG_RETURN_SUBTYPES) {
            --m_pInternalInfo->level;
        }
        m_pDumpInfo->addr+=szLen;
    } while (saveAddr && (++index < NumElts));

    m_pDumpInfo->addr = saveAddr;
    m_pInternalInfo->TypeOptions = Options;
    if (CopyData) {
        m_pInternalInfo->TypeDataPointer  = savedBuffer;
        m_pInternalInfo->CopyDataInBuffer = TRUE;
    }

    return ArrSize;
}

ULONG
DbgDerivedType::GetTypeSize()
{
    ULONG SavedOptions = m_pInternalInfo->TypeOptions, 
        SaveCopyData =  m_pInternalInfo->CopyDataInBuffer;
    
    m_pInternalInfo->TypeOptions = (GET_SIZE_ONLY | NO_PRINT); 
    m_pInternalInfo->CopyDataInBuffer = FALSE;
    
    ULONG Size = DumpType();
    
    m_pInternalInfo->TypeOptions = SavedOptions; 
    m_pInternalInfo->CopyDataInBuffer = SaveCopyData;

   return Size;
}

/*++
 * GetSpecialTypes
 *      Input: 
 *         TypeName  - String that contains special type chars eg. *, [].
 *         TypeIndex - TypeIndex as found by TypeInfoFound of actual name in TypeName
 *      Output:
 *         TypeOut   - This contains a stream of specail type structs containing 
 *                     Info on how to interpret the TypeName string.
 *                     The Caller is responsible to free this memory
 *      Returns      S_OK if ant specail type is found and TypeOut is allocated 
 --*/
HRESULT
DbgDerivedType::GetSpecialTypes(
    IN PCHAR TypeName,
    IN ULONG TypeIndex,
    OUT DBG_DE_TYPE **pSpTypeOut
    )
{
    DBG_DE_TYPE *SpType=NULL;
    ULONG        CurrIndex=0;

#define MAX_SPTYPES_ALLOWED  5

    if (!IsDbgDerivedType(TypeIndex) || !TypeName) {
        return E_INVALIDARG;
    }

    *pSpTypeOut = NULL;
    // start looking from backwords
    PCHAR Scan = TypeName;

    while (*Scan && *Scan != '*' && *Scan != '[' ) { 
        ++Scan;
    }

    if (!*Scan && *TypeName != '&') {
        return E_INVALIDARG;
    }

    SpType = (DBG_DE_TYPE*) malloc((MAX_SPTYPES_ALLOWED+1)*sizeof(DBG_DE_TYPE));

    if (!SpType) {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(SpType, (MAX_SPTYPES_ALLOWED+1)*sizeof(DBG_DE_TYPE));

    if (*TypeName == '&') {
        // Pointer type
        DBG_DE_TYPE *PtrType = &SpType[CurrIndex];

        PtrType->TypeId  = DBG_DE_ADDROF_ID;
        PtrType->ChildId = TypeIndex;
        PtrType->StartIndex = 0;
        PtrType->Namelength = (ULONG) ((ULONG64) Scan - (ULONG64) TypeName);
        PtrType->pNext   = CurrIndex ? (PVOID) &SpType[CurrIndex-1] : NULL;
        CurrIndex++;
        ++TypeName;
    }

    while (*Scan == '*' || *Scan == '[' || *Scan == ' ') { 
        if (CurrIndex > MAX_SPTYPES_ALLOWED) {
            free ( SpType );
            return E_INVALIDARG;
        }
        
        if (*Scan == '*') {
            // Pointer type
            DBG_DE_TYPE *PtrType = &SpType[CurrIndex];

            PtrType->TypeId  = DBG_DE_POINTER_ID;
            PtrType->ChildId = TypeIndex;
            PtrType->StartIndex = 0;
            PtrType->Namelength = 1 + (ULONG) ((ULONG64) Scan - (ULONG64) TypeName);
            PtrType->pNext   = CurrIndex ? (PVOID) &SpType[CurrIndex-1] : NULL;
            CurrIndex++;
        } else if (*Scan == '[') {
            PCHAR ArrParen = Scan;
            while ((*ArrParen != ']') && *ArrParen) { 
                ++ArrParen;
            }
            if (*ArrParen==']') {
                ULONG ArrIndex;
                
                if (sscanf(Scan+1, "%ld", &ArrIndex) != 1) {
                    ArrIndex=1;
                }

                ArrIndex = (ULONG) EvaluateSourceExpression(1+Scan);
                
                DBG_DE_TYPE* ArrType = &SpType[CurrIndex];

                ArrType->TypeId    = DBG_DE_ARRAY_ID;
                ArrType->ChildId   = TypeIndex;
                ArrType->NumChilds = ArrIndex;
                ArrType->StartIndex = 0;
                ArrType->Namelength = 1 + (ULONG) ((ULONG64) ArrParen - (ULONG64) TypeName);
                ArrType->pNext   = CurrIndex ? (PVOID) &SpType[CurrIndex-1] : NULL;
                CurrIndex++;
            
                Scan=ArrParen;
            } else {
                // syntax error
                free (SpType);
                return E_INVALIDARG;
            }
        }
        ++Scan;
    }

    if (CurrIndex) {
        SpType[0].ChildId &= ~DBG_DERIVED_TYPE_FLAG;
        *pSpTypeOut = &SpType[CurrIndex-1];
    } else {
        *pSpTypeOut = NULL;
        free (SpType);
        return E_FAIL;
    }
    return S_OK;
}

/*++
* Routine to dump special types which are no defined in PDB, but can be derived 
*
* eg. CHAR*, _STRUCT* etc.
*
--*/
ULONG 
DbgDerivedType::DumpType(
    )
{
    ULONG Options  = m_pInternalInfo->TypeOptions;
    ULONG result, Parent = m_ParentTag;
    DBG_DE_TYPE *SaveSpTypes;

    if (!m_SpTypes) {
        return DbgTypes::ProcessType(m_typeIndex & ~DBG_DERIVED_TYPE_FLAG);
    }

    if (!IsDbgDerivedType(m_typeIndex) || !m_pDumpInfo->sName) {
        m_pInternalInfo->ErrorStatus = SYMBOL_TYPE_INFO_NOT_FOUND;
        return 0;
    }


    SaveSpTypes  = m_SpTypes;

    if (m_SpTypes) { 
        switch (m_SpTypes->TypeId) { 
        case DBG_DE_ADDROF_ID: 
            m_SpTypes = (PDBG_DE_TYPE) m_SpTypes->pNext;
            result = DumpAddressOf(g_Machine->m_Ptr64 ? 8 : 4, SaveSpTypes->ChildId);
            break;
        case DBG_DE_POINTER_ID: 
            m_SpTypes = (PDBG_DE_TYPE) m_SpTypes->pNext;
            m_ParentTag = m_SymTag; m_SymTag = SymTagPointerType;
            if (m_pInternalInfo->TypeOptions & DBG_DUMP_GET_SIZE_ONLY) {
                result = g_Machine->m_Ptr64 ? 8 : 4;
            } else {
                result = DumpPointer(g_Machine->m_Ptr64 ? 8 : 4, SaveSpTypes->ChildId, SaveSpTypes);
            }
            break;
        case DBG_DE_ARRAY_ID: 
            m_SpTypes = (PDBG_DE_TYPE) m_SpTypes->pNext;
            m_ParentTag = m_SymTag; m_SymTag = SymTagArrayType;
            result = DumpSilgleDimArray(SaveSpTypes->NumChilds, SaveSpTypes->ChildId);
            break;
        default:
            result = 0;
            m_pInternalInfo->ErrorStatus = SYMBOL_TYPE_INFO_NOT_FOUND;
            break;
        }
    } else {
        return DbgTypes::ProcessType(m_typeIndex & ~DBG_DERIVED_TYPE_FLAG);
    }

    m_SpTypes = SaveSpTypes;
    m_SymTag = m_ParentTag; m_ParentTag = Parent;
    return result;
}

DbgTypes::DbgTypes(
    PTYPE_DUMP_INTERNAL pInternalDumpInfo,
    PTYPES_INFO         pTypeInfo,
    PSYM_DUMP_PARAM_EX     pExternalDumpInfo)
{ 
    m_pInternalInfo = pInternalDumpInfo;
    m_pDumpInfo     = pExternalDumpInfo;
    m_TypeInfo      = *pTypeInfo;
    m_typeIndex     = pTypeInfo->TypeIndex;
    m_ParentTag     = 0;
    m_SymTag        = 0;
    m_AddrPresent   = (pExternalDumpInfo->addr != 0) || pTypeInfo->Flag || pTypeInfo->SymAddress;
    m_pNextSym      = (PCHAR) (pExternalDumpInfo->nFields ? pExternalDumpInfo->Fields[0].fName : NULL);
    m_pSymPrefix    = pInternalDumpInfo->Prefix;
    if (pExternalDumpInfo->sName && 
        !strcmp((char *)pExternalDumpInfo->sName, "this")) {
        m_thisPointerDump = TRUE;
    } else {
        m_thisPointerDump = FALSE;
    }
}

void
DbgTypes::CopyDumpInfo(
    ULONG Size
    )
{
    if (m_pInternalInfo->level) {
//      m_pDumpInfo->Type = SymTagToDbgType(SymTag);
        m_pDumpInfo->TypeSize = Size;
    } else if (m_pDumpInfo->nFields) {
        PFIELD_INFO_EX CurField = &m_pDumpInfo->Fields[m_pInternalInfo->FieldIndex];

//      CurField->fType = SymTagToDbgType(SymTag);
        CurField->size = Size;
        CurField->fOffset = (ULONG) m_pInternalInfo->totalOffset;
    }

}


ULONG
DbgTypes::ProcessVariant(
    IN VARIANT var,
    IN LPSTR   name)
{
    CHAR Buffer[50] = {0};
    ULONG Options = m_pInternalInfo->TypeOptions;
    ULONG len=0;

    if (name) {
        typPrint(name); typPrint(" = ");
    }
    switch (var.vt) { 
    case VT_UI2: 
    case VT_I2:
        sprintf(Buffer, "%lx", var.iVal);
        len = 2;
        break;
    case VT_R4:
        sprintf(Buffer, "%g", var.fltVal);
        len=4;
        break;
        case VT_R8:
        sprintf(Buffer, "%g", var.dblVal);
        len=8;
        break;
    case VT_BOOL:
        sprintf(Buffer, "%lx", var.lVal);
        len=4;
        break;
    case VT_I1:
    case VT_UI1: 
        sprintf(Buffer, "%lx", var.bVal);
        len=1;
        break;
    case VT_I8:
    case VT_UI8:
        if (var.ullVal > 9) {
            sprintf(Buffer, "%I64lx", var.ullVal);
        } else {
            sprintf(Buffer, "0x%s", FormatDisp64(var.ullVal));
        }
        len=8;
        break;
    case VT_UI4:
    case VT_I4:
    case VT_INT:
    case VT_UINT:
    case VT_HRESULT:
        sprintf(Buffer, "%lx", var.lVal);
        len=4;
        break;
    default:
        sprintf(Buffer, "UNIMPLEMENTED %lx %lx", var.vt, var.lVal);
        len=4;
        break;
    }
    typPrint(Buffer);
    ExtPrint(Buffer);
#if 0
    if (Options & (DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES)) {
        PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymInternal;
        GET_RETTYPE(SymInternal);

        if (Options & DBG_RETURN_SUBTYPES) {
            
            GET_RETSUBTYP_INCR(SymInternal);

            RET_TYPE(SymInternal, 0, TypeIndex);
            
        }
        pTypeReturnSize = &SymInternal->Size;

        RET_SUBTYP(SymInternal, 0, 0, 0);
    }
#endif
    if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer) { 
        memcpy(m_pInternalInfo->TypeDataPointer, &var.ullVal, len);
        m_pInternalInfo->TypeDataPointer += len;
    }
    
    if (m_pInternalInfo->pInfoFound && (!m_pNextSym || !*m_pNextSym) && 
        ((m_ParentTag != SymTagPointerType) || (m_pSymPrefix && *m_pSymPrefix == '*')) ) {
        
        if (len <= sizeof(ULONG64)) {
             memcpy(&m_pInternalInfo->pInfoFound->FullInfo.Value, &var.ullVal, len);
             m_pInternalInfo->pInfoFound->FullInfo.Flags |= IMAGEHLP_SYMBOL_INFO_VALUEPRESENT;
        }
    }
    //    STORE_INFO(TypeIndex, , Size, 0,0);

    if (!(m_pInternalInfo->TypeOptions & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    }

    return len;
}

//
// Check if TI is a string type - CHAR, WCHAR
//
BOOL
DbgTypes::CheckAndPrintStringType(
    IN ULONG TI,
    IN ULONG Size
    )
{
    ULONG strOpts = m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING;
    ULONG   Options = m_pInternalInfo->TypeOptions;
    ULONG   Tag;
    ULONG   BaseType;
    ULONG64 Length;

    if ((Options & NO_PRINT) && !(Options & DBG_RETURN_TYPE_VALUES)) {
        return FALSE;
    }
    
    if (IsDbgNativeType(TI)) {
        // Size = GetNativeTypeSize(TI);
        BaseType = NATIVE_TO_BT(TI);
    } else if ((!SymGetTypeInfo(m_pInternalInfo->hProcess,
                        m_pInternalInfo->modBaseAddr,
                        TI,
                        TI_GET_SYMTAG,
                        &Tag)) ||
         (Tag != SymTagBaseType) ||
         (!SymGetTypeInfo(m_pInternalInfo->hProcess,
                          m_pInternalInfo->modBaseAddr,
                          TI,
                          TI_GET_BASETYPE,
                          &BaseType))
         ) {
        return FALSE;
    }

    SymGetTypeInfo(m_pInternalInfo->hProcess,
                   m_pInternalInfo->modBaseAddr,
                   TI,
                   TI_GET_LENGTH,
                   &Length);
    if (!strOpts) {
        if (BaseType == btChar || (BaseType == btUInt && Length == 1)) {
            strOpts = DBG_DUMP_FIELD_DEFAULT_STRING;
        } else if (BaseType == btWChar) {
            strOpts = DBG_DUMP_FIELD_WCHAR_STRING;
        } else if ((BaseType == btUInt && Length == 2)  && 
                   g_EnableUnicode) {
            BaseType = btWChar;
            strOpts = DBG_DUMP_FIELD_WCHAR_STRING;
        } else {
            return FALSE;
        }
    }
    ExtPrint(" \"");
    typPrint(" \"");
    printString(GetDumpAddress(), Size, strOpts);
    ExtPrint("\"");
    typPrint("\"");
    return TRUE;
}

void
StrprintInt(PCHAR str, ULONG64 val, ULONG Size) { 
    switch (Size) { 
    case 1:
        sprintf(str, "%ld", (CHAR) val);
        break;
    case 2:
        sprintf(str, "%ld", (SHORT) val);
        break;
    case 4:
        sprintf(str, "%ld", (LONG) val);
        break;
    case 8:
    default:
        sprintf(str, "%I64ld", val);
        break;
    }
    return;
}

void
StrprintUInt(PCHAR str, ULONG64 val, ULONG Size) { 
    if (val > 9) {
        strcpy(str, "0x");
        str+=2;
    }
    switch (Size) { 
    case 1:
        sprintf(str, "%lx", (CHAR) val);
        break;
    case 2:
        sprintf(str, "%lx", (USHORT) val);
        break;
    case 4:
        sprintf(str, "%lx", (ULONG) val);
        break;
    case 8:
    default:
        sprintf(str, "%s", FormatDisp64(val));
        break;
    }
    return;
}


ULONG
DbgTypes::ProcessBaseType(
    IN ULONG TypeIndex,
    IN ULONG TI,
    IN ULONG Size)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;
    PANSI_STRING NameToCopy=NULL;
    ULONG64 addr;
    PULONG pTypeReturnSize=NULL;

    addr = GetDumpAddress();
    
    //
    // Fill up the SYMBOL_PARAMETERS if required
    //
    if (Options & (DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES)) {
        PDEBUG_SYMBOL_PARAMETERS_INTERNAL SymInternal;
        GET_RETTYPE(SymInternal);

        if ((Options & DBG_RETURN_SUBTYPES) &&
            TI != btVoid) {
            
            GET_RETSUBTYP_INCR(SymInternal);

            RET_TYPE(SymInternal, addr, TypeIndex);
            STORE_PARENT_EXPAND_ADDRINFO(addr);

            if (m_pInternalInfo->CopyName && (SymInternal->Name.Length >20) && SymInternal->Name.Buffer) {
                NameToCopy = &SymInternal->Name;
#define CopySymParamName(name) if ((Options & DBG_RETURN_SUBTYPES) && (strlen(name)<20) && NameToCopy) strcpy(NameToCopy->Buffer, name)
            }
        }

        if ((TI == btFloat)) {
            SymInternal->External.Flags |= DEBUG_SYMBOL_IS_FLOAT;
        }
        // Use this later to copy size when we know it
        pTypeReturnSize = &SymInternal->Size;

        RET_SUBTYP(SymInternal, 0, 0, 0);
    }
    
    STORE_INFO(TypeIndex, addr, Size, 0,0);

    BYTE data[50] = {0};
    ULONGLONG val=0;
    if ((addr || m_pInternalInfo->ValuePresent) && (TI != btVoid)) {
        if (m_pInternalInfo->ValuePresent) {
            memcpy(data, &m_pInternalInfo->Value, Size);
            if (m_pInternalInfo->CopyDataInBuffer) {
                memcpy(m_pInternalInfo->TypeDataPointer, &m_pInternalInfo->Value, Size);
                m_pInternalInfo->TypeDataPointer += Size;
            }
            m_pInternalInfo->ValuePresent = FALSE;
        } else {
            READ_BYTES((PVOID) &data, addr, Size);
        }
        switch (Size) { 
        case 1:
            val = (LONG64) *((PCHAR) &data) ;
            break;
        case 2:
            val = (LONG64) *((PSHORT) &data) ;
            break;
        case 4:
            val = (LONG64) *((PLONG) &data) ;
            break;
        case 8:
            val = *((PULONG64) &data) ;
            break;
        default:
            val = *((PULONG64) &data) ;
            break;
        }
    
        if (m_pInternalInfo->RefFromPtr) typPrint(" -> "); // Its referred from pointer

        if ((m_pInternalInfo->InvalidAddress == addr) && (m_pInternalInfo->ErrorStatus == MEMORY_READ_ERROR)) {
            ExtPrint("Error : Can't read value");
            typPrint("??\n");
            CopySymParamName("??");
            return 0;
        }
    }


    CHAR Buffer1[50] = {0}, Buffer2[50] = {0}, Buffer3[50]={0};
    PSTR PrintOnAddr=&Buffer1[0], PrintOnNoAddr=&Buffer2[0], TypRetPrint;
    TypRetPrint = PrintOnAddr;
    
    switch (TI) { 
    case btNoType:
        vprintf("No type");
        break;
    case btVoid:
        PrintOnNoAddr = "Void";
        break;
    case btWChar: {
        WCHAR w[2], v;
        PrintOnNoAddr = "Wchar";
        v = w[0]=*((WCHAR *) &data[0]); w[1]=0;
        if (v && !IsPrintWChar(w[0])) w[0] = 0;
        sprintf(PrintOnAddr,"%#lx '%ws'", v, w);
        break;
    }
    case btInt:
        if (Size != 1) {
            sprintf(PrintOnNoAddr,"Int%lxB", Size);
            StrprintInt(PrintOnAddr, val, Size);
            TypRetPrint = &Buffer3[0];
            StrprintUInt(TypRetPrint, val, Size);
            break;
        } else {
            // fall through
        }
    case btChar:{
        CHAR c[2], v;
        v = c[0]= *((CHAR *) &data[0]); c[1]=0;
        PrintOnNoAddr = "Char";
        if (v && !IsPrintChar(c[0])) c[0] = '\0';
        sprintf(PrintOnAddr, "%ld '%s'", v, c);
        TypRetPrint = &Buffer3[0];
        sprintf(TypRetPrint, "%#lx '%s'", (ULONG) (UCHAR) v, c);
        break;
    }
    case btUInt:
        if (Size != 1) {
            sprintf(PrintOnNoAddr, "Uint%lxB", Size);
            StrprintUInt(PrintOnAddr, val, Size);
            break;
        } else {
            CHAR c[2], v;
            v = c[0]= *((CHAR *) &data[0]); c[1]=0;
            PrintOnNoAddr = "UChar";
            if (v && !IsPrintChar(c[0])) c[0] = '\0';
            sprintf(PrintOnAddr, "%ld '%s'", v, c);
            TypRetPrint = &Buffer3[0];
            sprintf(TypRetPrint, "%#lx '%s'", (ULONG) (UCHAR) v, c);
            PrintOnAddr = TypRetPrint;
            break;
    }
    case btFloat: {
        PrintOnNoAddr = "Float";
        
        if (Size == 4) {
            float* flt = (float *) &data;
            sprintf(PrintOnAddr, "%1.10g ", *flt);
        } else if (Size == 8) {
            double* flt = (double *) &data;
            sprintf(PrintOnAddr, "%1.20g ", *flt);
        } else {
            for (USHORT j= (USHORT) Size; j>0; ) {
                sprintf(PrintOnAddr, "%02lx", data[j]);
                PrintOnAddr+=2;
                if (!((--j)%4)) {
                    sprintf(PrintOnAddr, " ");
                    PrintOnAddr++;
                }
            }
        }
        break;
    }
    case btBCD:
        break;
    case btBool:
        PrintOnNoAddr = "Bool";
        sprintf(PrintOnAddr,"%I64lx", val);
        break;
#if 0
    case btShort:
        sprintf(PrintOnNoAddr,"Int%lxB", Size);
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, Size);
        break;
    case btUShort:
        sprintf(PrintOnNoAddr, "Uint%lxB", Size);
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btLong:
        sprintf(PrintOnNoAddr, "Int%lxB", Size);
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, Size);
        break;
    case btULong:
        sprintf(PrintOnNoAddr, "Uint%lxB", Size);
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btInt8:
        PrintOnNoAddr = "Int1B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, 1);
        Size=1;
        break;
    case btInt16:
        Size = 2;
        PrintOnNoAddr = "Int2B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, Size);
        break;
    case btInt32:
        Size = 4;
        PrintOnNoAddr = "Int4B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, Size);
        break;
    case btInt64:
        Size = 8;
        PrintOnNoAddr = "Int8B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, 8);
        break;
    case btInt128:
        Size = 16;
        PrintOnNoAddr = "Int16B";
        StrprintInt(PrintOnAddr, val, Size);
        TypRetPrint = &Buffer3[0];
        StrprintUInt(TypRetPrint, val, 8);
        break;
    case btUInt8:
        PrintOnNoAddr = "Uint1B";
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btUInt16:
        PrintOnNoAddr = "Uint2B";
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btUInt32:
        Size = 4;
        PrintOnNoAddr = "Uint4B";
        StrprintUInt(PrintOnAddr, val, Size);
        break;
    case btUInt64:
        Size = 8;
        PrintOnNoAddr = "Uint8B";
        StrprintUInt(TypRetPrint, val, 8);
        break;
    case btUInt128:
        Size = 16;
        PrintOnNoAddr = "Uint16B";
        StrprintUInt(PrintOnAddr, val, Size);
//        sprintf(PrintOnAddr, "%I64lx", val);
//        sprintf(TypRetPrint, "0x%s", FormatDisp64(val));
        break;
#endif // 0
    case btCurrency:
    case btDate:
    case btVariant:
    case btComplex:
    case btBit:
    case btBSTR:
        break;
    case btHresult:
        ULONG hrVal;
        PrintOnNoAddr = "HRESULT";
        Size = 4;
        if (addr) {
            hrVal = *((PULONG) &data);
            sprintf(PrintOnAddr,"%lx", hrVal);
//            EXT_PRINT_INT(hrVal);
        }
        break;
    default:
        vprintf("Error in TI %lx\n", TI);
        break;
    }
    CopySymParamName(PrintOnNoAddr);
    if (!addr) {
        typPrint(PrintOnNoAddr);
    } else {
        typPrint(PrintOnAddr);
        ExtPrint(TypRetPrint);
    }

#undef CopySymParamName
    if (!(m_pInternalInfo->TypeOptions & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    }
    if (pTypeReturnSize) {
        *pTypeReturnSize = (ULONG) Size;
    }

    return Size;
}

ULONG 
DbgTypes::ProcessPointerType(
    IN ULONG TI,
    IN ULONG ChildTI,
    IN ULONG Size)
{
    ULONG64 savedOffset=m_pInternalInfo->totalOffset;
    BOOL   CopyData=FALSE, savedPtrRef=m_pInternalInfo->RefFromPtr;
    ULONG  savedOptions = m_pInternalInfo->TypeOptions;
    PVOID  savedContext = m_pDumpInfo->Context;
    PUCHAR DataBuffer;
    ULONG64 tmp, addr;
    ULONG  Options = m_pInternalInfo->TypeOptions;
    ULONG  retSize = Size;
    BOOL   ProcessSubType;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;

//    if ((Options & DBG_RETURN_TYPE) && m_ParentTag == SymTagPointerType) {
//        return Size;
//    }
    
    addr=0;
    tmp=m_pDumpInfo->addr;
    
    ProcessSubType = !(Options & (GET_SIZE_ONLY | DBG_DUMP_BLOCK_RECURSE)) && 
        (!m_pInternalInfo->InUnlistedField || m_pInternalInfo->DeReferencePtr || m_pInternalInfo->ArrayElementToDump);
    
    if (m_pDumpInfo->addr || m_pInternalInfo->ValuePresent) {
        // Non zero address, dump value
        if (m_pInternalInfo->ValuePresent) {
            memcpy(&addr, &m_pInternalInfo->Value, Size);
            if (m_pInternalInfo->CopyDataInBuffer) {
                memcpy(m_pInternalInfo->TypeDataPointer, &m_pInternalInfo->Value, Size);
                m_pInternalInfo->TypeDataPointer += Size;
            }
            m_pInternalInfo->ValuePresent = FALSE;
            
        } else {
            READ_BYTES(&addr, GetDumpAddress(), Size);
        }
        if (!g_Machine->m_Ptr64) {
            //
            // Signextend the read pointer value
            //
            addr = (ULONG64) (LONG64) (LONG) addr;

        }
        
        STORE_INFO(TI, GetDumpAddress(), Size, 1,addr);

        if ((!m_pNextSym || !*m_pNextSym) &&
            ((m_ParentTag == SymTagPointerType) && (m_pSymPrefix && *m_pSymPrefix == '*'))) {
            ++m_pSymPrefix;
        }

        if (m_pInternalInfo->CopyDataInBuffer && !m_pInternalInfo->CopyDataForParent) {
            if (m_pInternalInfo->ErrorStatus == MEMORY_READ_ERROR &&
                m_pInternalInfo->InvalidAddress == GetDumpAddress()) {
                m_pInternalInfo->TypeDataPointer += Size;
            }
            *((PULONG64) (m_pInternalInfo->TypeDataPointer - Size)) = addr;
            //
            // We return size as 8 for 32 bit *copied* pointers.
            //
            m_pInternalInfo->TypeDataPointer -= Size;
            // advance the pointer
            retSize = 8;
            m_pInternalInfo->TypeDataPointer += retSize;

            CopyData = TRUE;
            DataBuffer = m_pInternalInfo->TypeDataPointer;
            m_pInternalInfo->CopyDataInBuffer = FALSE;
            m_pInternalInfo->TypeDataPointer  = NULL;
        }

    } else {
        if (!m_pInternalInfo->InUnlistedField) {
            typPrint("Ptr%2d ", Size*8);
            vprintf("to ");
        }
    }
    if (m_pDumpInfo->addr && !m_pInternalInfo->ArrayElementToDump) {
        if (savedPtrRef) ExtPrint(" -> "); // Its referred from pointer
        ExtPrint("%s", FormatAddr64(addr));
        m_pInternalInfo->RefFromPtr = 1;
        if (Options & (DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES)) {
            GET_RETTYPE(SymInternal);

            if (Options & DBG_RETURN_SUBTYPES && m_ParentTag) {
                // Parent has been processed, now is time to return its subtype

                GET_RETSUBTYP_INCR(SymInternal);

                m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
                m_pInternalInfo->TypeOptions |= DBG_RETURN_TYPE;
                m_pInternalInfo->pInfoFound->InternalParams = SymInternal;
//                m_pDumpInfo->Context = (PVOID) SymInternal;

                SUBTYP_COPYNAME(SymInternal, ((Size == 8) ? "Ptr64" : "Ptr32"));

                RET_TYPE(SymInternal, GetDumpAddress(), 
                         TI);

                STORE_PARENT_EXPAND_ADDRINFO(GetDumpAddress());

                Options &= ~DBG_RETURN_SUBTYPES;
                Options |= DBG_RETURN_TYPE;
            }

            SymInternal->Size      = Size;

            RET_SUBTYP(SymInternal, addr, TI, (addr ? 1 : 0));
//            RET_SUBTYP(SymInternal, m_pInternalInfo->totalOffset + m_pDumpInfo->addr, TI, (addr ? 1 : 0));
            
            if (Options & DBG_RETURN_TYPE_VALUES) {
                m_pDumpInfo->addr=addr;
                m_pInternalInfo->totalOffset=0;
                if (CheckAndPrintStringType(ChildTI, 0)) {
                    ProcessSubType = FALSE;
                }
            }
            if (Options & DBG_RETURN_TYPE) {
                m_pInternalInfo->TypeOptions &= ~DBG_RETURN_TYPE_VALUES;
                if (!m_pSymPrefix || *m_pSymPrefix != '*') {
                    ProcessSubType = FALSE;
                }
                //ProcessSubType = FALSE;
                //goto ExitPtrType;
            }
        }

        m_pDumpInfo->addr=addr;
        m_pInternalInfo->totalOffset=0;
        if (!m_pInternalInfo->InUnlistedField) {
            if (savedPtrRef) typPrint(" -> "); // Its referred from pointer
            if (addr) {
                typPrint( "0x%s", FormatAddr64(addr));
                if (CheckAndPrintStringType(ChildTI, 0)) {
                    ProcessSubType = FALSE;
                }
                if (m_thisPointerDump) {
                    // Check for thisAdjust of function in scope
                    ULONG thisAdjust;
                    GetThisAdjustForCurrentScope(&thisAdjust);
                    if (thisAdjust) {
                        typPrint(" (-%lx)", thisAdjust);
                    }
                }
                if (!(Options & VERBOSE) && 
                    (m_pInternalInfo->level == 0) &&
                    !(Options & DBG_DUMP_COMPACT_OUT)) 
                    typPrint("\n");
            } else {
                typPrint("(null) ");
            }
        }

        if (ProcessSubType && !addr) ProcessSubType = FALSE;
        m_pInternalInfo->PtrRead = TRUE;
    } else {
        // Just change the atart address, do not print anything
        m_pDumpInfo->addr=addr;
        m_pInternalInfo->totalOffset=0;

    }

    if (ProcessSubType) {
        // get the type pointed by this
        if (m_pInternalInfo->ArrayElementToDump || (m_pNextSym && *m_pNextSym == '[')) {
            // treat pointer as an array
            ULONG64 ChSize;
            
            if (!SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr, 
                                     ChildTI, TI_GET_LENGTH, (PVOID) &ChSize)) {
                return FALSE;
            }
            ULONG sParentTag = m_ParentTag;
            m_ParentTag = m_SymTag; m_SymTag = SymTagArrayType;
            

            ProcessArrayType(0, ChildTI, m_pInternalInfo->ArrayElementToDump, 
                             ChSize* m_pInternalInfo->ArrayElementToDump, NULL); 
            m_SymTag = m_ParentTag; m_ParentTag = sParentTag;
        } else {
            ProcessType(ChildTI);
        }
    } else {
        if (!(Options & DBG_DUMP_COMPACT_OUT)) typPrint("\n");
    }

//ExitPtrType:
    m_pInternalInfo->RefFromPtr = savedPtrRef ? 1 : 0;

    if (((m_pInternalInfo->InvalidAddress == GetDumpAddress()) && 
         (m_pInternalInfo->ErrorStatus == MEMORY_READ_ERROR))) {
        m_pInternalInfo->ErrorStatus = 0;
    } else if (m_pInternalInfo->ErrorStatus) {
        retSize = 0;
    }
    
    if (CopyData) {
        m_pInternalInfo->CopyDataInBuffer = TRUE;
        m_pInternalInfo->TypeDataPointer  = DataBuffer;
    }
    m_pInternalInfo->PtrRead = TRUE;
    m_pInternalInfo->totalOffset = savedOffset;
    m_pInternalInfo->TypeOptions = savedOptions;
    m_pDumpInfo->Context      = savedContext;
    m_pDumpInfo->addr=tmp;

    return retSize;
}

ULONG 
DbgTypes::ProcessBitFieldType(
    IN ULONG               TI,
    IN ULONG               ParentTI,
    IN ULONG               length,
    IN ULONG               position)
{
    ULONG64 mask=0, tmp = 0;
    ULONG  Options = m_pInternalInfo->TypeOptions;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;
    
    vprintf("Bitfield ");

    if (Options & DBG_RETURN_TYPE) {
        // BUGBUG - bitfields not handled in DBG_RETURN*
        GET_RETTYPE(SymInternal);

        RET_TYPE(SymInternal, (GetDumpAddress()),ParentTI);
        RET_SUBTYP(SymInternal, 0, 0, 0);
        SymInternal->Mask = (ULONG64) ~( ((ULONG64)-1) << length);
        SymInternal->Shift = (USHORT) position;
        SymInternal->Size  = (position + length+7) / 8; // Byte align from present offset
    }
    STORE_INFO(ParentTI, GetDumpAddress(), (position + length+7)/8, 0,0);

    if (m_pDumpInfo->addr) {
        USHORT bitVal;
        UCHAR buffer[100];
        ULONG i=(position + length + 7)/8;
        ReadTypeData((PUCHAR)buffer, GetDumpAddress(), i, m_pInternalInfo->TypeOptions);
        tmp=0;
        
        for (i=(position + length - 1); (i!=(position-1));i--) {
            bitVal = (buffer[i/8] & (1 << (i%8))) ? 1 : 0;
            tmp = tmp << 1; tmp |= bitVal;
            mask = mask << 1; mask |=1;
            if (i == (position + length - 1)) {
                typPrint("0y%1d", bitVal);
                ExtPrint("0y%1d", bitVal);
            } else {
                typPrint("%1d", bitVal);
                ExtPrint("%1d", bitVal);
            }
        }

        if (length > 4) {
            typPrint(" (%#I64x)", tmp);
            ExtPrint(" (%#I64x)", tmp);
        }
        // Which place do we start writing the bits..
        if (!m_pInternalInfo->BitIndex) {
            m_pInternalInfo->BitIndex = TRUE;
        } else {
            tmp = tmp << position;
            mask = mask << position;
        }

        if (m_pInternalInfo->CopyDataInBuffer) {
            // Copy the bitfield values
            //    Special case, cannot read whole bytes, so do not 
            //    advance the DataPointer

            // Copys using ULONGS, ULONG64 may cause alignment fault.
            PBYTE pb = (PBYTE) m_pInternalInfo->TypeDataPointer;
            while (mask) {
                *pb &= (BYTE) ~mask;
                *pb |= (BYTE) tmp;
                mask = mask >> 8*sizeof(BYTE); tmp = tmp >> 8*sizeof(BYTE);
                pb++;
            }
        }
    } else
        typPrint("Pos %d, %d Bit%s", position, length, (length==1 ? "":"s"));

    m_pInternalInfo->BitFieldRead = 1;
    m_pInternalInfo->BitFieldSize = length;
    m_pInternalInfo->BitFieldOffset = position;

    if (m_pDumpInfo->Fields &&
        (m_pDumpInfo->Fields[m_pInternalInfo->FieldIndex].fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS)) {
        PFIELD_INFO_EX pField = &m_pDumpInfo->Fields[m_pInternalInfo->FieldIndex];

        pField->size = length;
        pField->address = (GetDumpAddress() << 3) + position;
    }

    if (!(Options & DBG_DUMP_COMPACT_OUT)) {
        typPrint("\n");
    }
    return (length+7)/8;
}

ULONG 
DbgTypes::ProcessDataMemberType(
    IN ULONG               TI,
    IN ULONG               ChildTI,
    IN LPSTR               name,
    IN BOOL                bStatic)
{
    ULONG   off=0, szLen=0, fieldIndex=0, nameLen=0;

    ULONG   callbackResult=STATUS_SUCCESS, IsAParent=0;
    BOOL    called=FALSE, ParentCopyData=FALSE, copiedFieldData=FALSE, CopyName=m_pInternalInfo->CopyName;
    PUCHAR  ParentDataBuffer=NULL;
    TYPE_NAME_LIST fieldName = {0};
    ULONG   savedUnlisteField  = m_pInternalInfo->InUnlistedField;
    ULONG64 savedOffset   = m_pInternalInfo->totalOffset;
    ULONG64 savedAddress  = m_pDumpInfo->addr;
    ULONG   SavedBitIndex = m_pInternalInfo->BitIndex;
    ULONG   savedOptions  = m_pInternalInfo->TypeOptions;
    ULONG   savedfOptions = m_pInternalInfo->FieldOptions;
    ULONG   Options       = m_pInternalInfo->TypeOptions;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;
    HANDLE  hp = m_pInternalInfo->hProcess;
    ULONG64 base = m_pInternalInfo->modBaseAddr;
    BOOL    linkListFound;
    UINT    fieldNameLen=m_pInternalInfo->fieldNameLen;
    ULONG64 tmp, StaticAddr=0;
    HRESULT hr;

    if (bStatic) {
        if (!SymGetTypeInfo(hp, base, TI, TI_GET_ADDRESS, (PVOID) &StaticAddr)) {
            return FALSE;
        } 
        if (m_pDumpInfo->addr) {
            m_pDumpInfo->addr = StaticAddr;
            m_pInternalInfo->totalOffset = 0;
        }
    } else if (!SymGetTypeInfo(hp, base, TI, TI_GET_OFFSET, (PVOID) &off)) {
        return 0;
    }

    if ((m_pDumpInfo->listLink) && (m_pInternalInfo->TypeOptions & LIST_DUMP)) {
        // Check if this is the field we want for list dump
        ULONG listIt;

        MatchListField(Name, &listIt, &IsAParent);

        if (listIt==1) {
            ULONG size;
            //
            // Save the address and type Index for the list
            //
            m_pDumpInfo->listLink->address = off + GetDumpAddress();
            m_pDumpInfo->listLink->size    = ChildTI; 
            linkListFound                = TRUE;
            m_pInternalInfo->NextListElement  = 0;
            m_pInternalInfo->TypeOptions     |= NO_PRINT | GET_SIZE_ONLY;
            ParentCopyData               = m_pInternalInfo->CopyDataInBuffer;
            ParentDataBuffer             = m_pInternalInfo->TypeDataPointer;

            //
            // check if this has same type as root
            //
            if (ChildTI == m_pInternalInfo->rootTypeIndex && 
                m_pDumpInfo->addr) {
                m_pInternalInfo->NextListElement =
                    m_pDumpInfo->listLink->address;
                size = -1; // Fail the default list address finder
            } else {
                //
                // See if it is a pointer and get size
                // 
                m_pDumpInfo->addr = 0;
                size  = ProcessType(ChildTI);

                m_pDumpInfo->addr = savedAddress;
                m_pInternalInfo->CopyDataInBuffer = ParentCopyData;
            }

#ifdef DBG_TYPE
            dprintf("Addr %p, off %p, fOff %d ", m_pDumpInfo->addr, m_pInternalInfo->totalOffset, off);
            dprintf("PtrRead %d, size %d, addr %p\n", m_pInternalInfo->PtrRead, size, saveAddr + m_pInternalInfo->totalOffset + off);
#endif
            m_pInternalInfo->TypeOptions=(Options=savedOptions);
            if (m_pInternalInfo->PtrRead && (size<=8) && m_pDumpInfo->addr) {
                PTYPE_NAME_LIST parTypes = m_pInternalInfo->ParentTypes;
                //
                // This field is a pointer to next elt of list.
                //
                if (!ReadTypeData((PUCHAR) &(m_pInternalInfo->NextListElement),
                                  m_pDumpInfo->listLink->address, 
                                  size, 
                                  m_pInternalInfo->TypeOptions)) {
                    m_pInternalInfo->InvalidAddress = GetDumpAddress();
                    m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
                }

                if (!g_Machine->m_Ptr64) {
                    m_pInternalInfo->NextListElement = (ULONG64) (LONG64) (LONG) m_pInternalInfo->NextListElement;
                }

                while (parTypes && parTypes->Next) parTypes= parTypes->Next;

                if (!strcmp(parTypes->Name, "_LIST_ENTRY")) {
                    //
                    // Parent is _LIST_LINK type
                    //
                    m_pInternalInfo->NextListElement -= (m_pInternalInfo->totalOffset + off);
                    if (!m_pInternalInfo->LastListElement) {
                        //
                        // read the other of Flink or Blink 
                        //
                        if (!ReadTypeData((PUCHAR) &(m_pInternalInfo->LastListElement), 
                                          GetDumpAddress() + (off ? 0 : size), 
                                          size, 
                                          m_pInternalInfo->TypeOptions)) {
                            m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
                            m_pInternalInfo->InvalidAddress = GetDumpAddress();
                        }

                        if (!g_Machine->m_Ptr64) {
                            m_pInternalInfo->LastListElement = 
                                (ULONG64) (LONG64) (LONG) m_pInternalInfo->LastListElement;
                        }
                        m_pInternalInfo->LastListElement -= (m_pInternalInfo->totalOffset );
#ifdef DBG_TYPE
                        dprintf("Last Elt : %p, off:%x\n", m_pInternalInfo->LastListElement, off);
#endif
                    }
                    // dprintf("Next Elt : %p\n", m_pInternalInfo->NextListElement);
                }
            }
        }
    }

    if (m_pDumpInfo->nFields) {
        ULONG ListParent = IsAParent;
        // We can process only on specefied field of given struct

        fieldIndex = MatchField( name, 
                                 m_pInternalInfo, 
                                 m_pDumpInfo->Fields, 
                                 m_pDumpInfo->nFields,
                                 &IsAParent);
        if (!IsAParent) IsAParent = ListParent;
        if (!fieldIndex && !IsAParent) {
            // Not the right field
            m_pDumpInfo->addr = savedAddress;
            return 0;
        }
    }

    fieldName.Name = &name[0];
    fieldName.Type = off;
    InsertTypeName(&m_pInternalInfo->ParentFields, &fieldName);
    m_pInternalInfo->StringSize   = 0;
    if (m_pInternalInfo->ParentTypes) {
        // We add the offsets only when this was accessed and child of some UDT
        m_pInternalInfo->totalOffset += off;
    }

    if (m_pDumpInfo->addr) {

        if (m_pInternalInfo->TypeOptions & DBG_RETURN_SUBTYPES) {

            GET_RETSUBTYP_INCR(SymInternal);

            SUBTYP_COPYNAME(SymInternal, name);

            RET_TYPE(SymInternal, GetDumpAddress(), ChildTI);

            m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
            m_pInternalInfo->TypeOptions |= DBG_RETURN_TYPE;
            m_pInternalInfo->CopyName = 0;
            m_pInternalInfo->pInfoFound->InternalParams = SymInternal;
        }

    }


    if (IsAParent && !fieldIndex) {
        //
        // This field is not listed in Fields array, but one of its subfields is
        //
        m_pInternalInfo->InUnlistedField    = TRUE;
        m_pInternalInfo->TypeOptions       &= ~RECURSIVE;
        m_pInternalInfo->TypeOptions       |= ((ULONG) Options + RECURSIVE1) & RECURSIVE;
        Indent(m_pInternalInfo->level*3);
        if (!(Options & NO_OFFSET)) {
            if (bStatic) {
                typPrint("=%s ", FormatAddr64(StaticAddr));
            } else {
                typPrint("+0x%03lx ",  off + m_pInternalInfo->BaseClassOffsets);
            }
        }
        typPrint("%s", name);
        if (!(Options & (DBG_DUMP_COMPACT_OUT | NO_PRINT))) {
            nameLen = strlen(name);
            while (nameLen++ < fieldNameLen) typPrint(" ");
            typPrint(" : ");
        } else {
            typPrint(" ");
        }
        szLen = ProcessType(ChildTI);
        goto DataMemDone;
    } else {
        if (Options & DBG_DUMP_BLOCK_RECURSE) {
            m_pInternalInfo->TypeOptions       &= ~RECURSIVE;
            m_pInternalInfo->TypeOptions       |= ((ULONG) Options + RECURSIVE1) & RECURSIVE;
        }
        m_pInternalInfo->InUnlistedField = FALSE;
    }

#define ThisField m_pDumpInfo->Fields[fieldIndex-1]
//
// Signextend all copied pointer values
//
#define SignExtendPtrValue(pReadVal, sz)                                        \
{ if ((m_pInternalInfo->PtrRead) && (sz==4))   {sz=8;                                 \
     *((PULONG64) pReadVal) = (ULONG64) (LONG64) (LONG) *((PDWORD) (pReadVal)); }\
}


    if (((Options & CALL_FOR_EACH) && (fieldIndex ? 
                                       !(ThisField.fOptions & NO_CALLBACK_REQ) : 1)) ||
        (m_pDumpInfo->nFields && (ThisField.fOptions & CALL_BEFORE_PRINT))) {
        //
        // We have to do a callback on this field before dumping it.
        //
        // ntsd should dump only if callback routine fails
        FIELD_INFO_EX fld;

        fld.fName = (PUCHAR)name;

        fld.address =  m_pInternalInfo->totalOffset + m_pDumpInfo->addr;
        fld.fOptions = Options;

        if (m_pDumpInfo->nFields) {
            fld.fName = ThisField.fName;
            fld.fOptions = ThisField.fOptions;
            if ( fieldIndex &&
                 (ThisField.fOptions & COPY_FIELD_DATA) &&
                 ThisField.fieldCallBack) {
                //
                // Copy the field data, if required
                // 
                ParentCopyData = m_pInternalInfo->CopyDataInBuffer;
                ParentDataBuffer = m_pInternalInfo->TypeDataPointer;
                SavedBitIndex = m_pInternalInfo->BitIndex;
                m_pInternalInfo->CopyDataInBuffer = TRUE;
                m_pInternalInfo->TypeDataPointer  = (PUCHAR)ThisField.fieldCallBack;
                m_pInternalInfo->BitIndex = 0;
                copiedFieldData = TRUE;
            }
        }


        // Get size of the field
        m_pInternalInfo->TypeOptions = ( Options |= NO_PRINT | GET_SIZE_ONLY);
        SymGetTypeInfo(hp, base, ChildTI, TI_GET_LENGTH, &szLen);
        fld.size = szLen;

        if (m_pDumpInfo->addr) {
            if (!(fld.fOptions & DBG_DUMP_FIELD_RETURN_ADDRESS) && (fld.size<=8)) {
                fld.address=0;
                ReadTypeData((PUCHAR) &(fld.address), 
                             (GetDumpAddress() + (m_pInternalInfo->BitFieldRead ? m_pInternalInfo->BitFieldOffset/8 : 0)), 
                             (m_pInternalInfo->BitFieldRead ? (((m_pInternalInfo->BitFieldOffset % 8) + m_pInternalInfo->BitFieldSize + 7)/8) : fld.size), 
                             m_pInternalInfo->TypeOptions);
                SignExtendPtrValue(&fld.address, fld.size);

                if (m_pInternalInfo->BitFieldRead) {
                    fld.address = fld.address >> (m_pInternalInfo->BitFieldOffset % 8);
                    fld.address &= (0xffffffffffffffff >> (64 - m_pInternalInfo->BitFieldSize));
                }
            }
        }

        //
        // Do Callback
        //
        if (fieldIndex && 
            ThisField.fieldCallBack &&
            !(ThisField.fOptions & COPY_FIELD_DATA)) {
            // Local for field
            callbackResult =
                (*((PSYM_DUMP_FIELD_CALLBACK_EX)
                   ThisField.fieldCallBack))(&(fld),
                                             m_pDumpInfo->Context);
            called=TRUE;
        } else if (m_pDumpInfo->CallbackRoutine != NULL) {
            // Common callback
            callbackResult=
                (*(m_pDumpInfo->CallbackRoutine))(&(fld),
                                                m_pDumpInfo->Context);
            called=TRUE;
        }
        m_pInternalInfo->TypeOptions=(Options=savedOptions);
    }

    if (callbackResult != STATUS_SUCCESS) {
        goto DataMemDone;
    }

    // Print the field name / offset
    Indent(m_pInternalInfo->level*3);
    if (!(Options & NO_OFFSET)) {
        if (bStatic) {
            typPrint("=%s ", FormatAddr64(StaticAddr));
        } else {
            typPrint("+0x%03lx ",  off + m_pInternalInfo->BaseClassOffsets);
        }
    }
    typPrint("%s", ( (fieldIndex && ThisField.printName ) ? 
                     ThisField.printName : (PUCHAR)name ));

    if (fieldIndex && ThisField.printName ) {
        typPrint(" ");
    } else if (!(Options & (DBG_DUMP_COMPACT_OUT | NO_PRINT))) {
        nameLen = strlen(name);
        while (nameLen++ < fieldNameLen) typPrint(" ");
        typPrint(" : ");
    } else {
        typPrint(" ");
    }

    //
    // We need to get type of this field.
    // 
    tmp = m_pDumpInfo->addr;

    if (fieldIndex &&
        (ThisField.fOptions &
         (DBG_DUMP_FIELD_STRING | DBG_DUMP_FIELD_ARRAY))) {
        m_pInternalInfo->FieldOptions =
            (ThisField.fOptions &
             (DBG_DUMP_FIELD_STRING | DBG_DUMP_FIELD_ARRAY));
        if (m_pInternalInfo->AltFields[fieldIndex-1].ArrayElements) {
            if (m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_ARRAY) {
                m_pInternalInfo->arrElements = (USHORT) m_pInternalInfo->AltFields[fieldIndex-1].ArrayElements;
            } else {
                //  m_pInternalInfo->StringSize = (USHORT) ThisField.size;
            }
        }
    }

    //
    // Special cases - handle strings
    //
    if (m_pDumpInfo->addr && !strcmp(name, "Buffer")) {
        PCHAR ParentName = NULL;


        if (!(ParentName = GetParentName(m_pInternalInfo->ParentTypes))) {
            // Must referrred directly thru one DBG_RETURN TYPES

        } else if (!strcmp(ParentName,"_ANSI_STRING") || 
                   !strcmp(ParentName,"_STRING") ||
                   (!strcmp(ParentName, "_UNICODE_STRING"))) {
            m_pInternalInfo->FieldOptions |= (ParentName[1]!='U') ? DBG_DUMP_FIELD_DEFAULT_STRING : DBG_DUMP_FIELD_WCHAR_STRING;

            // Read in the Length Field for string length to be displayed
            ReadTypeData((PBYTE) &m_pInternalInfo->StringSize,
                         (GetDumpAddress() - 2*sizeof(USHORT)),
                         sizeof(m_pInternalInfo->StringSize), 
                         m_pInternalInfo->TypeOptions);
            if (ParentName[1]=='U') m_pInternalInfo->StringSize = m_pInternalInfo->StringSize << 1;
        }
    }


    if (fieldIndex && (ThisField.fOptions & RECUR_ON_THIS)) {
        // Increase the recursive dump level for this field
        m_pInternalInfo->TypeOptions |= ((ULONG) Options + RECURSIVE1) & RECURSIVE;
    } else if (IsAParent) {
        m_pInternalInfo->TypeOptions |= ((ULONG) Options + RECURSIVE1) & RECURSIVE;
    }
    if ( fieldIndex &&
         (ThisField.fOptions & COPY_FIELD_DATA) &&
         ThisField.fieldCallBack) {
        //
        // Copy the field data, if required
        // 
        if (!copiedFieldData) {
            ParentCopyData = m_pInternalInfo->CopyDataInBuffer;
            ParentDataBuffer = m_pInternalInfo->TypeDataPointer;
        }
        m_pInternalInfo->CopyDataInBuffer = TRUE;
        m_pInternalInfo->TypeDataPointer  = (PUCHAR)ThisField.fieldCallBack;
    }
    // Dump the field
    ULONG bitPos;
    if (SymGetTypeInfo(hp, base, TI, TI_GET_BITPOSITION, &bitPos)) {
        ULONG64 len;
        SymGetTypeInfo(hp, base, TI, TI_GET_LENGTH, &len);
        szLen = ProcessBitFieldType(ChildTI, TI, (ULONG) len, bitPos);
    } else {
        szLen = ProcessType(ChildTI);
    }
    m_pInternalInfo->TypeOptions = savedOptions;


    if (fieldIndex && !(ThisField.fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS)) {
        // Address and size are returned through Fields record
        ThisField.address = m_pInternalInfo->totalOffset +
                                m_pDumpInfo->addr;
    }

    if (fieldIndex &&
        (ThisField.fOptions &
         (DBG_DUMP_FIELD_STRING | DBG_DUMP_FIELD_ARRAY))) {
        m_pInternalInfo->TypeOptions = savedOptions;
        Options=savedOptions;
    }

    if (m_pDumpInfo->addr && fieldIndex) {
        //
        // Return data for the field, if it is asked for
        //
        if ( (ThisField.fOptions & COPY_FIELD_DATA) &&
             ThisField.fieldCallBack) {

            if (ParentCopyData && ParentDataBuffer) {
                //
                // Copy the field data, into the parent's buffer too
                // 

                memcpy( ParentDataBuffer, 
                        (PUCHAR) ThisField.fieldCallBack,
                        (m_pInternalInfo->TypeDataPointer - (PUCHAR) ThisField.fieldCallBack));
                ParentDataBuffer += (m_pInternalInfo->TypeDataPointer -  (PUCHAR) ThisField.fieldCallBack);
            }
            m_pInternalInfo->CopyDataInBuffer = ParentCopyData;
            m_pInternalInfo->TypeDataPointer  = ParentDataBuffer;
            m_pInternalInfo->BitIndex         = SavedBitIndex;
        }
        if (!(ThisField.fOptions & DBG_DUMP_FIELD_RETURN_ADDRESS) &&
            (szLen <= 8)) {
            ThisField.address =0;
            ReadTypeData((PBYTE)
                         &ThisField.address,
                         (GetDumpAddress() + (m_pInternalInfo->BitFieldRead ? m_pInternalInfo->BitFieldOffset/8 : 0)), 
                         (m_pInternalInfo->BitFieldRead ? (((m_pInternalInfo->BitFieldOffset % 8) + m_pInternalInfo->BitFieldSize + 7)/8) : szLen),
                         m_pInternalInfo->TypeOptions);
            SignExtendPtrValue(&ThisField.address, szLen);

            if (m_pInternalInfo->BitFieldRead) {
                ThisField.address = ThisField.address >> (m_pInternalInfo->BitFieldOffset % 8);
                ThisField.address &= (0xffffffffffffffff >> (64 - m_pInternalInfo->BitFieldSize));
            }
        }
    }
    CopyDumpInfo(szLen); // - redundant  ??
    
    if (fieldIndex && !(ThisField.fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS)) {
        // Address and size are returned through Fields record
        ThisField.size  = szLen;
    }

    if (fieldIndex) {
        ThisField.fOffset = (ULONG) m_pInternalInfo->totalOffset;
        ThisField.fType   = DBG_TYP_UNKNOWN;
        if (m_pInternalInfo->BitFieldRead) {
            ThisField.fType = DBG_TYP_BIT;
            ThisField.BitField.Size = (USHORT) m_pInternalInfo->BitFieldSize;
            ThisField.BitField.Position = (USHORT) m_pInternalInfo->BitFieldOffset;
        } else if (m_pInternalInfo->PtrRead) {
            ThisField.fType = DBG_TYP_POINTER;
        }

    }
#undef SignExtendPtrValue

    if ((m_pDumpInfo->nFields)
        && fieldIndex && !called
        && !(m_pDumpInfo->Fields[fieldIndex-1].fOptions &
             NO_CALLBACK_REQ)) {
        //
        // Do Callback, if it wasn't done earlier.
        //
        if (ThisField.fieldCallBack &&
            !(ThisField.fOptions & COPY_FIELD_DATA)) {
            callbackResult =
                (*((PSYM_DUMP_FIELD_CALLBACK_EX)
                   ThisField.fieldCallBack))(&(ThisField),
                                             m_pDumpInfo->Context);
        } else if (m_pDumpInfo->CallbackRoutine != NULL) {
            callbackResult=
                (*(m_pDumpInfo->CallbackRoutine)
                 )(&(ThisField),
                   m_pDumpInfo->Context);
        }
    }
    m_pDumpInfo->addr = tmp;

    if ((Options & DBG_DUMP_COMPACT_OUT) && (callbackResult == STATUS_SUCCESS)) {
        typPrint("  ");
    }


DataMemDone:
        RemoveTypeName(&m_pInternalInfo->ParentFields);
        m_pInternalInfo->CopyName           = CopyName ? 1 : 0;
        m_pInternalInfo->TypeOptions        = savedOptions;
        m_pInternalInfo->FieldOptions       = savedfOptions;
        m_pInternalInfo->totalOffset        = savedOffset;
        m_pInternalInfo->InUnlistedField    = savedUnlisteField;
        m_pInternalInfo->PtrRead            = FALSE;
        m_pInternalInfo->BitFieldRead       = FALSE;    
        m_pDumpInfo->addr                   = savedAddress;
#undef ThisField
        return szLen;
}

BOOL
GetThisAdjustForCurrentScope(
    PULONG thisAdjust
    )
{
    ULONG64 disp;
    PDEBUG_SCOPE Scope = GetCurrentScope();
    SYMBOL_INFO SymInfo = {0};
    CHAR Buffer[MAX_PATH];

    SymInfo.SizeOfStruct = sizeof(SYMBOL_INFO);

    if (SymFromAddr(g_CurrentProcess->Handle, Scope->Frame.InstructionOffset, &disp, &SymInfo)) {
        ULONG FunctionType;

        if (SymGetTypeInfo(g_CurrentProcess->Handle, SymInfo.ModBase, 
                           SymInfo.TypeIndex, TI_GET_THISADJUST, thisAdjust)) {
            return TRUE;
        }
    }
    return FALSE;
}

/*
   This sumps structs which are known to debugger in special format
*/
BOOL
DbgTypes::DumpKnownStructFormat(
    PCHAR name
    )
{
    ULONG Options = m_pInternalInfo->TypeOptions;

    if (!strcmp(name,"_ANSI_STRING") || 
        !strcmp(name,"_STRING") ||
        (!strcmp(name, "_UNICODE_STRING"))) {
        m_pInternalInfo->FieldOptions |= (name[1]!='U') ? DBG_DUMP_FIELD_DEFAULT_STRING : DBG_DUMP_FIELD_WCHAR_STRING;

        typPrint(" ");
        ExtPrint(" ");
        printStructString(GetDumpAddress(), Options,
                          m_pInternalInfo->FieldOptions);
        if (!m_pInternalInfo->level && !(Options & DBG_DUMP_COMPACT_OUT)) {
            typPrint("\n");
        }
    } else if ((Options & NO_PRINT) && 
               !((Options & DBG_RETURN_TYPE_VALUES) && (Options & DBG_RETURN_TYPE))) {
        return FALSE;
    }
    if (!strcmp(name,"_GUID")) {
        typPrint(" ");
        ExtPrint(" ");
        printString(GetDumpAddress(), 0, DBG_DUMP_FIELD_GUID_STRING);
        if (!m_pInternalInfo->level && !(Options & DBG_DUMP_COMPACT_OUT)) {
            typPrint("\n");
        }
    } else 
    if ((!strcmp(name,"_LARGE_INTEGER") || !strcmp(name,"_ULARGE_INTEGER"))) {
        if (m_pInternalInfo->level && !(Options & DBG_DUMP_COMPACT_OUT)) {
            ULONG64 li;
            if (ReadTypeData((PUCHAR) &li, 
                             GetDumpAddress(),
                             8, 
                             m_pInternalInfo->TypeOptions)) {
                typPrint(" %s", FormatDisp64(li));
                ExtPrint(" %s", FormatDisp64(li));
            }
        }
    } else 
    if (!strcmp(name,"_LIST_ENTRY")) {
        if (m_pInternalInfo->level && !(Options & DBG_DUMP_COMPACT_OUT)) {
            union {
                LIST_ENTRY32 l32;
                LIST_ENTRY64 l64;
            } u;

            if (ReadTypeData((PUCHAR) &u, 
                             GetDumpAddress(),
                             (g_Machine->m_Ptr64 ? 16 : 8), 
                             m_pInternalInfo->TypeOptions)) {
                if (g_Machine->m_Ptr64) {
                    typPrint(" %s - %s", FormatAddr64(u.l64.Flink), FormatDisp64(u.l64.Blink));
                    ExtPrint(" %s - %s", FormatAddr64(u.l64.Flink), FormatDisp64(u.l64.Blink));
                } else {
                    typPrint(" %lx-%lx", u.l32.Flink, u.l32.Blink);
                    ExtPrint(" %lx-%lx", u.l32.Flink, u.l32.Blink);
                }
            }
        }
    } else if (!strcmp(name,"_FILETIME")) {
        FILETIME ft;
        SYSTEMTIME syst;
        if (ReadTypeData((PUCHAR) &ft, 
                         GetDumpAddress(),
                         sizeof(ft), 
                         m_pInternalInfo->TypeOptions)) {
            if (FileTimeToSystemTime(&ft, &syst)) {
                typPrint(" %02ld:%02ld:%02ld %ld/%ld/%ld",
                         syst.wHour,
                         syst.wMinute,
                         syst.wSecond,
                         syst.wMonth,
                         syst.wDay,
                         syst.wYear);
                ExtPrint(" %02ld:%02ld:%02ld %ld/%ld/%ld",
                         syst.wHour,
                         syst.wMinute,
                         syst.wSecond,
                         syst.wMonth,
                         syst.wDay,
                         syst.wYear);
                if (!m_pInternalInfo->level && !(Options & DBG_DUMP_COMPACT_OUT)) {
                    typPrint("\n");
                }
            }
        }
    }
    return TRUE;
}

#define MAX_RECUR_LEVEL (((Options & RECURSIVE) >> 8) + 1)

ULONG 
DbgTypes::ProcessUDType(
    IN ULONG               TI,
    IN LPSTR               name)
{
    HANDLE  hp   = m_pInternalInfo->hProcess;
    ULONG64 base = m_pInternalInfo->modBaseAddr;
    ULONG64 size=0;
    ULONG   nelements, szLen=0, saveFieldOptions = m_pInternalInfo->FieldOptions;
    ULONG   Options = m_pInternalInfo->TypeOptions;
    BOOL    IsFwdRef, IsNestedType;
    BOOL    IsBaseClass=FALSE;
    HRESULT hr;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;
    ULONG   thisAdjust=0;

    if (!SymGetTypeInfo(hp, base, TI, TI_GET_LENGTH, (PVOID) &size)) {
        return 0;
    }

    hr = !SymGetTypeInfo(hp, base, TI, TI_GET_VIRTUALBASECLASS, &IsBaseClass);
    
    hr = !SymGetTypeInfo(hp, base, TI, TI_GET_NESTED, &IsNestedType);

    if ((hr == S_OK) && IsNestedType && !(Options & VERBOSE) && (m_ParentTag == SymTagUDT)) {
        return 0;
    }

    if (!SymGetTypeInfo(hp, base, TI, TI_GET_CHILDRENCOUNT, (PVOID) &nelements)) {
        return 0;
    }

    TYPE_NAME_LIST structName={0};

    vprintf("UDT ");

    if ((Options & (VERBOSE)) ||
        (!(m_pInternalInfo->PtrRead && m_pDumpInfo->addr) && (m_pInternalInfo->level == MAX_RECUR_LEVEL) && !IsBaseClass)) {
        // Print name if its elements cannot be printed or asked in Options
        typPrint("%s", name);
        if (Options & DBG_DUMP_COMPACT_OUT) {
            typPrint(" ");
        }
    }
    vprintf(", %d elements, 0x%x bytes\n", nelements, size);

    if (( m_pInternalInfo->CopyDataInBuffer ||  // Need to go in struct if it is to be copied
          !(Options & GET_SIZE_ONLY))) {
        //
        // Insert this struct's name in list of parent type names
        //
        structName.Name = &name[0];
        structName.Type = TI;

        InsertTypeName(&m_pInternalInfo->ParentTypes, &structName);
        if (m_AddrPresent) {

            if ((m_pInternalInfo->level < MAX_RECUR_LEVEL)) {
                //
                // We would be eventually reading everything in the struct, so cache it now
                //
                if (!ReadInAdvance(GetDumpAddress(), (ULONG) size, m_pInternalInfo->TypeOptions)) {
                    m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
                    m_pInternalInfo->InvalidAddress = GetDumpAddress();
                }
            } else if (m_pInternalInfo->CopyDataInBuffer) {
                // We won't be going in this, but still need to copy all data
                if (!ReadTypeData(m_pInternalInfo->TypeDataPointer, 
                                  GetDumpAddress(),
                                  (ULONG) size, 
                                  m_pInternalInfo->TypeOptions)) {
                    m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
                    m_pInternalInfo->InvalidAddress = m_pDumpInfo->addr + m_pInternalInfo->totalOffset;
                }

                m_pInternalInfo->TypeDataPointer += size;
            }

            if (Options & DBG_RETURN_TYPE) {
                GET_RETTYPE(SymInternal);

                if (m_ParentTag == SymTagData) {
                    // We can skip the datatag process ing next time
                    SymInternal->TypeIndex = TI;
                }
                SUBTYP_COPYNAME(SymInternal, name);

                RET_SUBTYP(SymInternal, GetDumpAddress(),
                           TI, nelements);

                SymInternal->Flags |= m_pInternalInfo->FieldOptions & DBG_DUMP_FIELD_STRING;
                if (SymInternal->TypeIndex == TI) {
                    ExtPrint(name);
                }
                STORE_INFO(TI, GetDumpAddress(),(ULONG)size, nelements, GetDumpAddress());
            }

            DumpKnownStructFormat(name);
            if (m_thisPointerDump) {
                // Check for thisAdjust of function in scope

                GetThisAdjustForCurrentScope(&thisAdjust);
                if (thisAdjust) {
                    m_pDumpInfo->addr -= (LONG)thisAdjust;
                    vprintf("thisadjust %lx\n", thisAdjust);
                }
                m_thisPointerDump = FALSE;
            }
        }

        if ((m_pInternalInfo->level >= MAX_RECUR_LEVEL) ||
            ((Options & NO_PRINT) && !m_pDumpInfo->nFields && (MAX_RECUR_LEVEL == 1) &&
             !(Options & (DBG_DUMP_BLOCK_RECURSE | DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES | DBG_DUMP_CALL_FOR_EACH | DBG_DUMP_LIST)))) {
            if (!(Options & VERBOSE) && !(Options & DBG_DUMP_COMPACT_OUT)) typPrint("\n");
            RemoveTypeName(&m_pInternalInfo->ParentTypes);
            // Commenting below out for '&' symbols
            // if (m_pDumpInfo->nFields) 
            {
                STORE_INFO(TI, GetDumpAddress(),(ULONG)size, nelements, GetDumpAddress());
            }
            goto ExitUdt;
            return (ULONG) size;
        } else if (m_pInternalInfo->level && !(Options & VERBOSE)) {
            typPrint("\n");
        }
        STORE_INFO(TI, GetDumpAddress(),(ULONG)size, nelements, GetDumpAddress());
        
        ULONG push = m_pInternalInfo->CopyDataForParent ;
        m_pInternalInfo->CopyDataForParent = m_pInternalInfo->CopyDataInBuffer ?  1 : push;
        m_pInternalInfo->PtrRead = FALSE;
        m_pInternalInfo->RefFromPtr = FALSE;
        TI_FINDCHILDREN_PARAMS *pChildren;

        pChildren = (TI_FINDCHILDREN_PARAMS *) AllocateMem(sizeof(TI_FINDCHILDREN_PARAMS) + sizeof(ULONG) * nelements);
        if (!pChildren) {
            m_pInternalInfo->ErrorStatus = CANNOT_ALLOCATE_MEMORY;
            return 0;
        }

        pChildren->Count = nelements;
        pChildren->Start = 0;
        if (!SymGetTypeInfo(hp, base, TI, TI_FINDCHILDREN, (PVOID) pChildren)) {
            return 0;
        }
        ULONG i=m_pDumpInfo->nFields,fieldNameLen=16;
        
        if (i) {
            // Calculate maximum size of fiels to be dumped
            fieldNameLen=0;
            PFIELD_INFO_EX pField = m_pDumpInfo->Fields;
            
            while (i--) {
                PUCHAR dot = (PUCHAR)strchr((char *)pField->fName, '.');
                if (dot && m_pInternalInfo->ParentTypes) {
                    if (!strncmp((char *)pField->fName, 
                                 (char *)m_pInternalInfo->ParentTypes->Name, 
                                 dot - &(pField->fName[0]))) {
                        fieldNameLen = 16; // Back to default, cannnot calculate max size now
                        break;
                    }
                }
                if (pField->printName) {
                    fieldNameLen = (fieldNameLen>=(strlen((char *)pField->printName)-2) ?
                                    fieldNameLen : (strlen((char *)pField->printName)-2)); // -2 for " :"

                } else {
                    fieldNameLen = (fieldNameLen>=strlen((char *)pField->fName) ?
                                    fieldNameLen : strlen((char *)pField->fName));
                }

                pField++;
            }
        }
        m_pInternalInfo->fieldNameLen = fieldNameLen;
        i=0;
        ++m_pInternalInfo->level;


        while (i<nelements) { 
            ULONG Tag;
            BOOL b;
            b = SymGetTypeInfo(hp, base, pChildren->ChildId[i], TI_GET_SYMTAG, &Tag);
//          dprintf("[Child %lx of UDT, tag %lx] ", i, Tag);

            if (b && (Tag == SymTagData || Tag == SymTagFunction || Tag == SymTagBaseClass || Tag == SymTagVTable)) {
                ProcessType(pChildren->ChildId[i]);
            } else if (Options & VERBOSE) {
                ProcessType(pChildren->ChildId[i]);
            }
            ++i;
        }
        
        --m_pInternalInfo->level;
        
        if (thisAdjust) {
            m_pDumpInfo->addr += (LONG)thisAdjust;
            m_thisPointerDump = TRUE;
        }
        
        if (Options & DBG_RETURN_SUBTYPES) {
            STORE_PARENT_EXPAND_ADDRINFO(GetDumpAddress());
        }

        FreeMem(pChildren);
        m_pInternalInfo->CopyDataForParent = push;
        m_pInternalInfo->FieldOptions = saveFieldOptions;
        RemoveTypeName(&m_pInternalInfo->ParentTypes);

    }
ExitUdt:
    return (ULONG) size;
}


ULONG 
DbgTypes::ProcessEnumerate(
    IN VARIANT             var,
    IN LPSTR               name)
{
    ULONG64 val=0, readVal=0;
    ULONG sz=0;
    ULONG Options = m_pInternalInfo->TypeOptions;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;

    if ((m_pDumpInfo->addr)) {
        m_pInternalInfo->TypeOptions |= NO_PRINT;
        m_pInternalInfo->TypeOptions &= ~(DBG_RETURN_TYPE | DBG_RETURN_TYPE_VALUES);

        sz = ProcessVariant(var, NULL);

        m_pInternalInfo->TypeOptions = Options;
        if (sz > sizeof (readVal)) 
            sz = sizeof(readVal);
        //
        // Read the value at address and print name only if it matches
        //
        ReadTypeData((PUCHAR) &readVal, 
                     GetDumpAddress(), 
                     min(m_pInternalInfo->typeSize, sizeof(readVal)), // always read typesize of data
                     m_pInternalInfo->TypeOptions);

        memcpy(&val, &var.lVal, sz);
        if (val == readVal) {
//            typPrint(" ( %s )\n", name);
            typPrint("%I64lx ( %s )\n", val, name);
            ExtPrint("%I64lx ( %s )", val, name);
            m_pInternalInfo->newLinePrinted = TRUE;
            //
            // Found the name we were looking for, get out
            //
            
            // STORE_INFO(0, m_pDumpInfo->addr + m_pInternalInfo->totalOffset,sz, 0,0);

            if (Options & DBG_RETURN_TYPE) {
                GET_RETTYPE(SymInternal);

                RET_SUBTYP(SymInternal, 0, 0, 0);

                SymInternal->Size            = m_pInternalInfo->typeSize;

            }
            if (Options & DBG_RETURN_SUBTYPES) {
                GET_RETSUBTYP_INCR(SymInternal);

                RET_SUBTYP(SymInternal, 0, 0, 0);

                SymInternal->Address = GetDumpAddress();

                SUBTYP_COPYNAME(SymInternal, name);
            }

            return sz;
        }
    } else {

        if (m_pDumpInfo->nFields) {
            ULONG chk, dummy;
            // We can process only on specefied field of given struct

            chk = MatchField( name, m_pInternalInfo, m_pDumpInfo->Fields, m_pDumpInfo->nFields, &dummy);

            if ((!chk) || (chk>m_pDumpInfo->nFields)) {
                // Not the right field
                return sz;
            }
        }
        // No address / too large value, list the enumerate
        Indent(m_pInternalInfo->level*3);
        sz = ProcessVariant(var, name);
//        typPrint("%s = %x\n", name, val);
//        ExtPrint("%s = %I64lx", name, val);
        m_pInternalInfo->newLinePrinted = TRUE;
    }
    
    return sz;
}

ULONG 
DbgTypes::ProcessEnumType(
    IN ULONG               TI,
    IN LPSTR               name)
{
    HANDLE  hp   = m_pInternalInfo->hProcess;
    ULONG64 base = m_pInternalInfo->modBaseAddr;
    ULONG64 size=0;
    DWORD   nelements;
    ULONG   Options = m_pInternalInfo->TypeOptions;
    ULONG   savedOptions;
    ULONG   BaseType;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;

    if (!SymGetTypeInfo(hp, base, TI, TI_GET_CHILDRENCOUNT, (PVOID) &nelements)) {
//        vprintf("num elts not found\n");
    }

    vprintf("Enum ");
    if ((!(m_pDumpInfo->addr) && (m_pInternalInfo->level == MAX_RECUR_LEVEL))
        || (Options &(VERBOSE))) typPrint("%s", name);
    vprintf(",  %d total enums", nelements);

    savedOptions = m_pInternalInfo->TypeOptions;

    if (m_pDumpInfo->addr)
        m_pInternalInfo->TypeOptions |= DBG_DUMP_COMPACT_OUT;

    if (Options & DBG_RETURN_TYPE) {
        GET_RETTYPE(SymInternal);

        m_pInternalInfo->TypeOptions &= ~DBG_RETURN_TYPE;
    }
    assert(!(Options & DBG_RETURN_SUBTYPES));

    m_pInternalInfo->TypeOptions |= NO_PRINT;
    
    if (!SymGetTypeInfo(hp, base, TI, TI_GET_TYPEID, (PVOID) &BaseType)) {
        return 0;
    }
    // This will copy the value if needed
    size = ProcessType(BaseType);
    m_pInternalInfo->typeSize = (ULONG)size;
    m_pInternalInfo->TypeOptions = savedOptions; 
    Options=savedOptions;

    STORE_INFO(TI, GetDumpAddress(), (ULONG) size, 0, 0);
    if ((m_pInternalInfo->typeSize > 8) && m_pDumpInfo->addr) {
        // LF_ENUMERATE won't be able to display correctly
        // ParseTypeRecord(m_pInternalInfo, pEnum->utype, m_pDumpInfo);
    } else {
        ULONG save_rti = m_pInternalInfo->rootTypeIndex;

        if ((m_pInternalInfo->level >= MAX_RECUR_LEVEL) && !m_pDumpInfo->addr) {
            typPrint("\n");
            return  (ULONG) size;
        }
        m_pInternalInfo->rootTypeIndex = BaseType;
        TI_FINDCHILDREN_PARAMS *pChildren;

        pChildren = (TI_FINDCHILDREN_PARAMS *) AllocateMem(sizeof(TI_FINDCHILDREN_PARAMS) + sizeof(ULONG) * nelements);
        if (!pChildren) {
            m_pInternalInfo->ErrorStatus = CANNOT_ALLOCATE_MEMORY;
            return 0;
        }

        pChildren->Count = nelements;
        pChildren->Start = 0;
        if (!SymGetTypeInfo(hp, base, TI, TI_FINDCHILDREN, (PVOID) pChildren)) {
            return 0;
        }
        if (!m_pDumpInfo->addr) {
            m_pInternalInfo->level++;
        }
        ULONG i=0;
        BOOL  Copy;
        
        Copy = m_pInternalInfo->CopyDataInBuffer;
        m_pInternalInfo->CopyDataInBuffer = FALSE;
        m_pInternalInfo->IsEnumVal = TRUE;
        m_pInternalInfo->newLinePrinted = FALSE;
        
        while (i<nelements && (!m_pInternalInfo->newLinePrinted || !m_pDumpInfo->addr)) { 
            ProcessType(pChildren->ChildId[i++]);
        }
        m_pInternalInfo->IsEnumVal = FALSE;
        if (!m_pDumpInfo->addr) {
            m_pInternalInfo->level--;
        }
        m_pInternalInfo->rootTypeIndex = save_rti;
        if (m_pDumpInfo->addr && !m_pInternalInfo->newLinePrinted) {
            m_pInternalInfo->TypeOptions |= DBG_DUMP_COMPACT_OUT;
            ProcessBaseType(TI, btUInt, (ULONG) size);

            typPrint(" (No matching name)\n");
            ExtPrint(" (No matching name)");
            m_pInternalInfo->TypeOptions = savedOptions; 
        }
        m_pInternalInfo->CopyDataInBuffer = Copy;
    }
    
    return (ULONG) size;
}

ULONG 
DbgTypes::ProcessArrayType(
    IN ULONG               TI,
    IN ULONG               eltTI,
    IN ULONG               count,
    IN ULONGLONG           size,
    IN LPSTR               name)
{
    DWORD  arrlen=(ULONG) size, szLen=0, index=0, CopyData=FALSE, SizeToCopy;
    BOOL   OneElement=FALSE;
    PUCHAR savedBuffer=NULL;
    ULONG  savedOptions=m_pInternalInfo->TypeOptions;
    ULONG  ArrayElementsToDump, RefedElement=0;
    PVOID  savedContext = m_pDumpInfo->Context;
    ULONG  Options = m_pInternalInfo->TypeOptions;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;
    ULONG64 tmp;

    szLen = (ULONG) (count ?  (size / count) : size);
    if (m_pNextSym && *m_pNextSym == '[') {
        m_pInternalInfo->ArrayElementToDump = 1 + (ULONG) EvaluateSourceExpression(++m_pNextSym);
        while (*m_pNextSym && *(m_pNextSym++) != ']') { 
        };
    }
    // Get the array element index

    if (m_pInternalInfo->level && (m_pInternalInfo->FieldOptions & FIELD_ARRAY_DUMP)) {
        ArrayElementsToDump = m_pInternalInfo->arrElements ? m_pInternalInfo->arrElements : count;
    } else {
        if (Options & DBG_RETURN_SUBTYPES) {
            ArrayElementsToDump = count;
        } else 
            ArrayElementsToDump = 1;
        if (!m_pInternalInfo->level && (m_pInternalInfo->TypeOptions & DBG_DUMP_ARRAY)) {
            //
            // Let top array/list dump loop take care of this
            //
            m_pInternalInfo->nElements = (USHORT) count;
            m_pInternalInfo->rootTypeIndex = eltTI;
            m_typeIndex = eltTI;
        }
    }

    if (!name) {
        name = "";
    }

    if (//m_pDumpInfo->nFields && 
        m_pInternalInfo->ArrayElementToDump) {
        //
        // Only one particular element has to be precessesed
        // 
        if (m_pInternalInfo->ArrayElementToDump) {
            m_pInternalInfo->totalOffset += szLen * (m_pInternalInfo->ArrayElementToDump -1);
            typPrint("[%d]%s ", m_pInternalInfo->ArrayElementToDump - 1, name);
        }
        RefedElement = m_pInternalInfo->ArrayElementToDump - 1;
        m_pInternalInfo->ArrayElementToDump = 0;
        arrlen = szLen;
        OneElement = TRUE;
    } else if (ArrayElementsToDump > 1 || (m_pInternalInfo->TypeOptions & DBG_DUMP_ARRAY)) {
        vprintf("(%d elements) %s ", count, name);
        if (!m_pInternalInfo->level) arrlen = szLen;
    } else {
        typPrint("[%d]%s ", count, name);
    }

    if (m_pInternalInfo->CopyDataInBuffer && m_pInternalInfo->TypeDataPointer && m_pDumpInfo->addr &&
        (!OneElement || (Options & GET_SIZE_ONLY)) ) {
        //
        // Copy the data
        //
        if (!ReadTypeData(m_pInternalInfo->TypeDataPointer, 
                          GetDumpAddress(), 
                          arrlen, 
                          m_pInternalInfo->TypeOptions)) {
            m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
            m_pInternalInfo->InvalidAddress = GetDumpAddress();
            return FALSE;
        }

        m_pInternalInfo->TypeDataPointer += arrlen;
        savedBuffer = m_pInternalInfo->TypeDataPointer;
        CopyData = TRUE;
        m_pInternalInfo->CopyDataInBuffer = FALSE;
    }
    
    if (OneElement) {
        STORE_INFO(eltTI, GetDumpAddress(),arrlen, count, GetDumpAddress());
    } else {
        STORE_INFO(TI, GetDumpAddress(),arrlen, count, GetDumpAddress());

        if (Options & (DBG_RETURN_TYPE)) {
            PCHAR ArrayData;

            GET_RETTYPE(SymInternal);

            RET_SUBTYP(SymInternal, GetDumpAddress(),
                       TI, count);

            if ((Options & DBG_RETURN_TYPE_VALUES) &&
                !CheckAndPrintStringType(eltTI, 0)) {
                ExtPrint("Array [%d]", count);
            }
            return arrlen;
        }

    }
    if (Options & DBG_RETURN_SUBTYPES) {
        assert (m_pInternalInfo->NumSymParams == count);

        STORE_PARENT_EXPAND_ADDRINFO(GetDumpAddress());

        m_pInternalInfo->CurrentSymParam = count;
        for (m_pInternalInfo->CurrentSymParam=0;
             m_pInternalInfo->CurrentSymParam < count; 
             m_pInternalInfo->CurrentSymParam++) { 

            GET_RETSUBTYP(SymInternal);

            RET_TYPE(SymInternal,GetDumpAddress() + szLen*m_pInternalInfo->CurrentSymParam,
                     eltTI);

            SymInternal->Size      = szLen;
            if (m_pInternalInfo->CopyName && (SymInternal->Name.Length > 8)) {
                sprintf(SymInternal->Name.Buffer, "[%d]", m_pInternalInfo->CurrentSymParam);
            }
        } 
        m_pInternalInfo->CopyName = 0;
    }
    if (Options & GET_SIZE_ONLY) {
        return arrlen;
    }

    if (m_pDumpInfo->addr && !OneElement) {
        // Dump array contents
        tmp = m_pDumpInfo->addr;

        if (!(Options & DBG_RETURN_SUBTYPES)) {
            if (CheckAndPrintStringType(eltTI, (ULONG) size)) {
                typPrint("\n");
                return arrlen;
            }
        }

        if (m_pInternalInfo->FieldOptions & FIELD_ARRAY_DUMP) {
            typPrint("\n");
        }

        do {
            if (Options & DBG_RETURN_SUBTYPES) {
                m_pInternalInfo->pInfoFound->InternalParams = &m_pInternalInfo->pSymParams[index];
//                m_pDumpInfo->Context = (PVOID) &m_pInternalInfo->pSymParams[index];
                m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
                m_pInternalInfo->TypeOptions |=  DBG_RETURN_TYPE;
                ++m_pInternalInfo->level;
            }
            if ((m_pInternalInfo->level && (m_pInternalInfo->FieldOptions & FIELD_ARRAY_DUMP))) {
                // typPrint("\n");
                Indent(m_pInternalInfo->level*3);
                typPrint(" [%02d] ", index);
            }
            szLen=ProcessType(eltTI);

            if ((Options & DBG_DUMP_COMPACT_OUT ) && (Options & FIELD_ARRAY_DUMP) ) {
                typPrint("%s", ((szLen>8) || (index % 4 == 0)) ? "\n":" ");
            }
            if (!szLen) {
                return arrlen;
            }
            if (Options & DBG_RETURN_SUBTYPES) {
                --m_pInternalInfo->level;
            }
            m_pDumpInfo->addr+=szLen;
        } while (++index < ArrayElementsToDump);
        m_pDumpInfo->addr=tmp;
    } else {
        szLen = ProcessType(eltTI);
    }

    if (!size && !m_pInternalInfo->level) {
        size=szLen;  // Return something, for success
    }
    if (CopyData) {
        m_pInternalInfo->TypeDataPointer  = savedBuffer;
        m_pInternalInfo->CopyDataInBuffer = TRUE;
    }
    if (m_pInternalInfo->level == MAX_RECUR_LEVEL &&
        !(OneElement)) {
        STORE_INFO(TI, GetDumpAddress(),arrlen, count, GetDumpAddress());
    }

    return arrlen;
}

ULONG 
DbgTypes::ProcessVTShapeType(
    IN ULONG               TI,
    IN ULONG               count)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;
    ULONG  i;

    vprintf("%d entries", count);
    for (i=0; i<count;i++) { 
        // The pointers
    
    } 
    typPrint("\n");
    return FALSE;
}


ULONG 
DbgTypes::ProcessVTableType(
    IN ULONG               TI,
    IN ULONG               ChildTI)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;
   
    if (Options & DBG_RETURN_SUBTYPES) {
        GET_RETSUBTYP_INCR(SymInternal);

        RET_TYPE(SymInternal,GetDumpAddress(),
                 ChildTI);
        m_pInternalInfo->pInfoFound->InternalParams = SymInternal;
//        m_pDumpInfo->Context = (PVOID) SymInternal;

        SUBTYP_COPYNAME(SymInternal, "__VFN_table");

        m_pInternalInfo->TypeOptions &= ~DBG_RETURN_SUBTYPES;
        m_pInternalInfo->TypeOptions |= DBG_RETURN_TYPE;
    } else {
    }
    if (m_pDumpInfo->nFields) {
        ULONG chk, dummy;
        // We can process only on specefied field of given struct

        chk = MatchField( "__VFN_table", m_pInternalInfo, m_pDumpInfo->Fields, m_pDumpInfo->nFields, &dummy);

        if ((!chk) || (chk>m_pDumpInfo->nFields)) {
            // Not the right field
            return FALSE;
        }
    }
    Indent(m_pInternalInfo->level*3);
    typPrint("+0x000 __VFN_table : ");
    TI=ProcessType(ChildTI);
    if (Options & DBG_RETURN_SUBTYPES) {
        
        m_pInternalInfo->CurrentSymParam--;
        GET_RETSUBTYP(SymInternal);
        m_pInternalInfo->CurrentSymParam++;
//      SymInternal = &m_pInternalInfo->pSymParams[m_pInternalInfo->CurrentSymParam-1];

        // Force not to expand VFN table
        RET_SUBTYP(SymInternal, 0, 0, 0);
        m_pInternalInfo->TypeOptions = Options;
    }
    return TI;
}

ULONG 
DbgTypes::ProcessBaseClassType(
    IN ULONG               TI,
    IN ULONG               ChildTI)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;
    DWORD szLen=0;
    ULONG Baseoffset=0;

    if (!SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr, 
                       TI, TI_GET_OFFSET, (PVOID) &Baseoffset)) {
        return 0;
    }

    if (Options & VERBOSE) {
        Indent(m_pInternalInfo->level * 3);
        if (!(Options & NO_OFFSET)) {
            typPrint("+0x%03x ", Baseoffset);
        }
        typPrint("__BaseClass ");
    }
    m_pInternalInfo->BaseClassOffsets += Baseoffset;
    m_pInternalInfo->totalOffset += Baseoffset;
    
    --m_pInternalInfo->level;
    szLen = ProcessType(ChildTI);

    m_pInternalInfo->BaseClassOffsets -= Baseoffset;
    m_pInternalInfo->totalOffset      -= Baseoffset;
    ++m_pInternalInfo->level;

    return szLen;
}


ULONG 
DbgTypes::ProcessFunction(
    IN ULONG               TI,
    IN ULONG               ChildTI,
    IN LPSTR               name)
{
    ULONG  Options = m_pInternalInfo->TypeOptions;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;

    if ((Options & VERBOSE) || !m_pInternalInfo->level) {
        Indent(m_pInternalInfo->level*3);
        vprintf("Func %s", name);

        return ProcessType(ChildTI);
    }
    return FALSE;
}

ULONG 
DbgTypes::ProcessFunctionType(
    IN ULONG               TI,
    IN ULONG               ChildTI
    )
{
    ULONG   Options = m_pInternalInfo->TypeOptions;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;
    ULONG64 funcAddr, currentfuncAddr;
    USHORT  saveLevel = m_pInternalInfo->level;
    ULONG64 Displacement=0;
    PDEBUG_SCOPE Scope = GetCurrentScope();
    CHAR name[MAX_NAME];
    PIMAGEHLP_SYMBOL64 ImghlpSym = (PIMAGEHLP_SYMBOL64) name;

    if (Options & DBG_RETURN_TYPE)
    {
        GET_RETTYPE(SymInternal);

        RET_SUBTYP(SymInternal, 0, 0, 0);

        ExtPrint(" -function-");
    }
    
    funcAddr=m_pDumpInfo->addr;
    m_pDumpInfo->addr=0;

    m_pInternalInfo->TypeOptions |= DBG_DUMP_COMPACT_OUT;
    Indent(m_pInternalInfo->level* 3);
    m_pInternalInfo->level = (USHORT) MAX_RECUR_LEVEL;
    // Return type 
    if (TypeVerbose)
    {
        ProcessType(ChildTI);
    }
    
    if (funcAddr)
    {

        ImghlpSym->MaxNameLength = sizeof(name) - sizeof(IMAGEHLP_SYMBOL64);
        
        USHORT CallParams; 
        GetSymbolStdCall(funcAddr + m_pInternalInfo->totalOffset,
                         &name[0],
                         sizeof(name),
                         &Displacement,
                         &CallParams);
        funcAddr = funcAddr + m_pInternalInfo->totalOffset - Displacement;

        if (!(Options & DBG_DUMP_FUNCTION_FORMAT))
        {
            
            typPrint(" ");
            ExtPrint(" ");
            
            typPrint("%s+%I64lx", name, Displacement);
            ExtPrint("%s+%I64lx", name, Displacement);
            
        }
    }
    m_pInternalInfo->level = saveLevel;
    if ((Options & DBG_DUMP_FUNCTION_FORMAT) ||
        (!m_pInternalInfo->level))
    {
        CHAR    Buffer[MAX_NAME];
        ANSI_STRING TypeName;
        TYPES_INFO TypeInfo;

        // Arguments
        ULONG nArgs;

        if (!SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr,
                                  TI, TI_GET_CHILDRENCOUNT, (PVOID) &nArgs))
        {
            return FALSE;
        }
        TI_FINDCHILDREN_PARAMS *pChildren;

        TypeName.Buffer = &Buffer[0];
        TypeInfo = m_TypeInfo;

        pChildren = (TI_FINDCHILDREN_PARAMS *) AllocateMem(sizeof(TI_FINDCHILDREN_PARAMS) + sizeof(ULONG) * nArgs);
        typPrint("(");
        if (pChildren)
        {
            ULONG i=0;

            pChildren->Count = nArgs;
            pChildren->Start = 0;
            if (!SymGetTypeInfo(m_pInternalInfo->hProcess, m_pInternalInfo->modBaseAddr,
                                     TI, TI_FINDCHILDREN, (PVOID) pChildren))
            {
                return FALSE;
            }
            m_pInternalInfo->TypeOptions |= DBG_DUMP_COMPACT_OUT;
            
            currentfuncAddr=0;
            if (Scope->Frame.InstructionOffset &&
                SymGetSymFromAddr64(m_pInternalInfo->hProcess, 
                                    Scope->Frame.InstructionOffset,
                                    &Displacement,
                                    ImghlpSym)) {
                currentfuncAddr = ImghlpSym->Address;
            }

            if (funcAddr == currentfuncAddr && funcAddr && !(Options & NO_PRINT)) {
                IMAGEHLP_STACK_FRAME StackFrame;
                
                //    SetCurrentScope to this function address, not the return address
                //    since we only want to enumerate the parameters
                g_EngNotify++;
//                StackFrame = (IMAGEHLP_STACK_FRAME) Scope->Frame;
                StackFrame.InstructionOffset = currentfuncAddr;
                SymSetContext(g_CurrentProcess->Handle,
                              &StackFrame, NULL);
            }

            while (i<nArgs)
            { 
                m_pInternalInfo->level = (USHORT) MAX_RECUR_LEVEL;
                TypeInfo.TypeIndex = pChildren->ChildId[i];
                TypeName.MaximumLength = MAX_NAME;
                if (GetTypeName(NULL, &TypeInfo, &TypeName))
                {
                    ProcessType(pChildren->ChildId[i]);
                }
                else
                {
                    typPrint(Buffer);
                }
                i++;
                //
                // If this is *the* current scoped function, print arg values too
                //
                if (funcAddr == currentfuncAddr && funcAddr && !(Options & NO_PRINT))
                {
                    // print i'th parameter
                    typPrint(" ");
                    PrintParamValue(i-1);
                }
                if (i < nArgs)
                {
                    typPrint(", ");
                }
            }
            if (funcAddr == currentfuncAddr && funcAddr && !(Options & NO_PRINT)) {
                IMAGEHLP_STACK_FRAME StackFrame;
                
                //    SetCurrentScope to this function address, not the return address
                //    since we only want to enumerate the parameters
                g_EngNotify--;
                SymSetContext(g_CurrentProcess->Handle,
                              (PIMAGEHLP_STACK_FRAME) &Scope->Frame , NULL);
            }
            FreeMem(pChildren);
        }
        typPrint(")");
        m_pDumpInfo->addr=funcAddr;

    }
    if (funcAddr && (Options & DBG_DUMP_FUNCTION_FORMAT) && Displacement)
    {
        vprintf("+%s", FormatDisp64(Displacement));
    }
    m_pInternalInfo->TypeOptions = Options;
    m_pInternalInfo->level = saveLevel;
    if (!( Options & DBG_DUMP_COMPACT_OUT) )
    {
        typPrint("\n");
    }
    m_pInternalInfo->level = saveLevel;
    return TRUE;
}

ULONG 
DbgTypes::ProcessFunctionArgType(
    IN ULONG               TI,
    IN ULONG               ChildTI
    )
{
    ULONG   Options = m_pInternalInfo->TypeOptions;
    ULONG  sz;
    PDEBUG_SYMBOL_PARAMETERS_INTERNAL    SymInternal;
    ULONG64 tmp;

    Indent(m_pInternalInfo->level *3);
//    typPrint(" arg = ");
    sz = ProcessType(ChildTI);

    return TRUE;
}

LPSTR
UnicodeToAnsi(BSTR wStr)
{
    ULONG len = WStrlen(wStr);
    LPSTR str = (LPSTR) AllocateMem(len + 1);

    if (str) {
        sprintf(str,"%ws", wStr);
    }
    return str;
}

ULONG 
DbgTypes::ProcessType(
    IN ULONG typeIndex
    )
{
    ULONG64 Size;
    BSTR    wName= NULL;
    LPSTR   Name = "";
    ULONG   Options;
    HANDLE  hp   = m_pInternalInfo->hProcess;
    ULONG64 base = m_pInternalInfo->modBaseAddr;
    ULONG   Parent=m_ParentTag, SymTag=m_SymTag;
    BOOL    NameAllocated = FALSE;

    m_ParentTag = m_SymTag;
    Size = 0;
    
    if (m_pInternalInfo->CopyDataInBuffer && !m_pDumpInfo->addr) {
        m_pInternalInfo->ErrorStatus = MEMORY_READ_ERROR;
        m_pInternalInfo->InvalidAddress = 0;
    }

    Options = m_pInternalInfo->TypeOptions;
    
    if (IsDbgDerivedType(typeIndex)) {
    } else if (IsDbgNativeType(typeIndex)) {
        Size = GetNativeTypeSize((PCHAR) m_pDumpInfo->sName, typeIndex);
        ProcessBaseType(typeIndex, NATIVE_TO_BT(typeIndex), (ULONG) Size);
        m_ParentTag = Parent; m_SymTag=SymTag;
        return (ULONG) Size;
    }

    if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMTAG, (PVOID) &m_SymTag)) {
        return FALSE;
    }
    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT) {
        return FALSE;
    }
    if (0 && (m_SymTag != SymTagBaseType) && (m_pInternalInfo->level > MAX_RECUR_LEVEL)) {
        if (!(Options & DBG_DUMP_COMPACT_OUT)) typPrint("\n");
        m_pInternalInfo->newLinePrinted = TRUE;
        return FALSE;
    }
    ULONG BaseId;

    //vprintf("[TAG %lx, TI %02lx] ", m_SymTag, typeIndex);
    switch (m_SymTag) { 
    case SymTagPointerType: {
        
        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_LENGTH, (PVOID) &Size)) {
            Size = 0;
        }


        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            
            Size = ProcessPointerType(typeIndex, BaseId, (ULONG) Size);
        }
        break;
    }
    case SymTagData: {
        enum DataKind Datakind;

        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_DATAKIND, &Datakind)) {
            BOOL  IsStatic;

            if (m_ParentTag == SymTagUDT && Datakind == DataIsGlobal) {
                // Its atuall is a static member
                Datakind = DataIsStaticMember;
            }
            IsStatic = FALSE;
            switch (Datakind) { 
            case DataIsUnknown: default:
                break;
            case DataIsStaticLocal: 
                IsStatic = TRUE;
            case DataIsLocal: case DataIsParam: 
            case DataIsObjectPtr: case DataIsFileStatic: case DataIsGlobal:
                if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
                    // vprintf("name not found\n");
                } else if (wName) {
                    if (!wcscmp(wName, L"this") && (Datakind == DataIsLocal)) {
                        m_thisPointerDump = TRUE;
                    }
                    LocalFree (wName);
                }
                if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
                    m_pInternalInfo->rootTypeIndex = BaseId;
                    m_pInternalInfo->IsAVar = TRUE;
                    Size = ProcessType(BaseId);
                }
                break;
#define DIA_HAS_CONSTDATA 
#if defined (DIA_HAS_CONSTDATA)
            case DataIsConstant:
            {
                VARIANT var = {0};

                if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
                    // vprintf("name not found\n");
                } else if (wName) {
                    Name = UnicodeToAnsi(wName);
                    if (!Name) {
                        Name = "";
                    } else {
                        NameAllocated = TRUE;
                    }
                    LocalFree (wName);
                }
                if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_VALUE, &var)) {
                    if (m_pInternalInfo->IsEnumVal) {
                        Size = ProcessEnumerate(var, Name);
                    } else {
                        Size = ProcessVariant(var, Name);
                    }
                } else {
                }
                break;
            }
#endif
            case DataIsStaticMember:
                IsStatic = TRUE;
            case DataIsMember: 

                if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
                    // vprintf("name not found\n");
                } else if (wName) {
                    Name = UnicodeToAnsi(wName);
                    if (!Name) {
                        Name = "";
                    } else {
                        NameAllocated = TRUE;
                    }
                    LocalFree (wName);
                }
                if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
                    Size = ProcessDataMemberType(typeIndex, BaseId, (LPSTR) Name, IsStatic);
                }
            } 

        }
        
        break;
    }
#if !defined (DIA_HAS_CONSTDATA)
    case SymTagConstant:
    {
        VARIANT var = {0};

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_VALUE, &var)) {
            if (m_pInternalInfo->IsEnumVal) {
                Size = ProcessEnumerate(var, Name);
            } else {
                Size = ProcessVariant(var, Name);
            }
        } else {
        }
        break;
    }
#endif
    case SymTagUDT: {

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }

        Size = ProcessUDType(typeIndex, (LPSTR) Name);
        break;
    }
    case SymTagEnum: {

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }

        Size = ProcessEnumType(typeIndex, (LPSTR) Name);
        break;
    }
    case SymTagBaseType: {
        ULONG Basetype;
        
        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_LENGTH, (PVOID) &Size)) {
            Size = 0;
        }

        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_BASETYPE, &Basetype)) {
            
            ProcessBaseType(typeIndex, Basetype, (ULONG) Size);
        }

        break;
    }
    case SymTagArrayType: {
        ULONG Count;
        ULONGLONG BaseSz;
        
        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_LENGTH, (PVOID) &Size)) {
            Size = 0;
        }

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }

        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId) &&
            SymGetTypeInfo(hp, base, BaseId, TI_GET_LENGTH, (PVOID) &BaseSz)) {
            Count = (ULONG)(BaseSz ? (Size / (ULONG)(ULONG_PTR)BaseSz) : 1);
            Size = ProcessArrayType(typeIndex, BaseId, Count, Size, Name);
        }
        break;
    }
    case SymTagTypedef: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            m_pInternalInfo->rootTypeIndex = BaseId;
            Size = ProcessType(BaseId);
        } else {
        }
    }
    break;
    case SymTagBaseClass: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessBaseClassType(typeIndex, BaseId);
        } else {
        }
    }
    break;
    case SymTagVTableShape: {
        ULONG Count;
        ULONGLONG BaseSz;
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_COUNT, &Count)) {
            Size = ProcessVTShapeType(typeIndex, Count);
        }
    }
    break;
    case SymTagVTable: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessVTableType(typeIndex, BaseId);
        } 
    }
    break;
    case SymTagFunction: {

        if (!SymGetTypeInfo(hp, base, typeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
            // vprintf("name not found\n");
        } else if (wName) {
            Name = UnicodeToAnsi(wName);
            if (!Name) {
                Name = "";
            } else {
                NameAllocated = TRUE;
            }
            LocalFree (wName);
        }
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessFunction(typeIndex, BaseId, Name);
        } 
    }
    break;
    case SymTagFunctionType: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessFunctionType(typeIndex, BaseId);
        } 
    }
    break;
    case SymTagFunctionArgType: {
        if (SymGetTypeInfo(hp, base, typeIndex, TI_GET_TYPEID, &BaseId)) {
            Size = ProcessFunctionArgType(typeIndex, BaseId);
        } 
    }
    break;
    default:
        typPrint("Unimplemented sym tag %lx\n", m_SymTag);
        break;
    }
    if (Name && NameAllocated) {
        FreeMem(Name);
    }
    m_ParentTag = Parent; m_SymTag=SymTag;
    return (ULONG) Size;
}


//
// Frees up all allocated memory in TypeInfoToFree
//
BOOL 
FreeTypesInfo ( PTYPES_INFO TypeInfoToFree ) {
    
    if (TypeInfoToFree) {

        if (TypeInfoToFree->Name.Buffer) {
            FreeMem (TypeInfoToFree->Name.Buffer);
        }
        return TRUE;
    }
    return FALSE;
}

//
// This routines clears all stored type info. This should be called
// after bangReload
//
VOID
ClearStoredTypes (
    ULONG64 ModBase
    )
{
    g_ReferencedSymbols.ClearStoredSymbols(ModBase);
    
    if (g_CurrentProcess == NULL)
    {
        return;
    }
    FindTypeInfoInDefaultMod(g_CurrentProcess->Handle, (PCHAR) NULL,
                             FALSE, NULL, NULL);

    ClearAllFastDumps();
}

//
// This routines clears all stored type info
//
VOID
ReferencedSymbolList::ClearStoredSymbols (
    ULONG64 ModBase
    )
{
    int i;
    for (i=0;i<MAX_TYPES_STORED;i++) { 
        if ((!ModBase || (m_ReferencedTypes[i].ModBaseAddress == ModBase)) &&
            m_ReferencedTypes[i].Name.Buffer) {
            m_ReferencedTypes[i].Name.Buffer[0] = '\0';
            m_ReferencedTypes[i].Referenced = -1;
        }
    }
}

//
// Lookup a type name in recently referenced types
//       Returns index in RefedTypes, if it is found; -1 otherwise
//
ULONG
ReferencedSymbolList::LookupType (
    LPSTR      Name,
    LPSTR      Module,
    BOOL       CompleteName
    ) 
{
    PTYPES_INFO  RefedTypes = m_ReferencedTypes;
    int i, found=-1;

    if (!Name || !Name[0]) {
        return -1;
    }
    return -1;

    EnsureValidLocals();

    for (i=0; i<MAX_TYPES_STORED; i++) {
        RefedTypes[i].Referenced++;
        if (RefedTypes[i].Name.Buffer && (found == -1)) {
            if ((CompleteName && !strcmp(Name, RefedTypes[i].Name.Buffer)) ||
                (!CompleteName && !strncmp(Name, RefedTypes[i].Name.Buffer, strlen(Name)))) {
                    if (Module) {
                        if (!_stricmp(Module, RefedTypes[i].ModName) || !Module[0] || !RefedTypes[i].ModName[0]) {
                            found = i;
                            RefedTypes[i].Referenced = 0;
                        } else {
          //                  dprintf("Mod %s != %s\n", RefedTypes[i].ModName, Module);
                        }
                    } else {
                        found = i;
                        RefedTypes[i].Referenced = 0;
                    }
                }
            }
    }

    return found;
}

VOID
ReferencedSymbolList::EnsureValidLocals(void)
{
    PDEBUG_SCOPE Scope = GetCurrentScope();
    if ((Scope->Frame.FrameOffset != m_FP) ||
        (Scope->Frame.ReturnOffset != m_RO) ||
        (Scope->Frame.InstructionOffset != m_IP))
    {
        int i;
        
        for (i = 0; i < MAX_TYPES_STORED; i++)
        { 
            if ((m_ReferencedTypes[i].Flag & DEBUG_LOCALS_MASK) &&
                m_ReferencedTypes[i].Name.Buffer)
            {
                m_ReferencedTypes[i].Name.Buffer[0] = '\0';
                m_ReferencedTypes[i].Referenced = -1;
                m_ReferencedTypes[i].Flag = 0;
            }
        }
        m_RO = Scope->Frame.ReturnOffset;
        m_FP = Scope->Frame.FrameOffset;
        m_IP = Scope->Frame.InstructionOffset;
    }
}

//
// Store a referenced Symbol type
//
ULONG
ReferencedSymbolList::StoreTypeInfo (
    PTYPES_INFO pInfo
    ) 
{
    PTYPES_INFO         RefedTypes = m_ReferencedTypes;
    ULONG indexToStore=0, MaxRef=0,i;
    PTYPES_INFO pTypesInfo;
    USHORT ModLen, SymLen;

    EnsureValidLocals();
    for (i=0; i<MAX_TYPES_STORED; i++) {
        if (!RefedTypes[i].Name.Buffer || (RefedTypes[i].Referenced > MaxRef)) {
            MaxRef = (RefedTypes[i].Name.Buffer ? RefedTypes[i].Referenced : -1); 
            indexToStore = i;
        }
    }

    // dprintf("Storing %s at %d\n", pSym->sName, indexToStore);
    pTypesInfo = &RefedTypes[indexToStore];
    ModLen = ( pInfo->ModName ? strlen(pInfo->ModName) : 0);
    SymLen = strlen( (char *)pInfo->Name.Buffer );

    if (pTypesInfo->Name.MaximumLength <= SymLen) {
        if (pTypesInfo->Name.Buffer) FreeMem (pTypesInfo->Name.Buffer);
        pTypesInfo->Name.MaximumLength = (SymLen >= MINIMUM_BUFFER_LENGTH ? SymLen + 1 : MINIMUM_BUFFER_LENGTH);
        pTypesInfo->Name.Buffer = (char *)AllocateMem (pTypesInfo->Name.MaximumLength);
    }

    if (!pTypesInfo->Name.Buffer) {
        return -1;
    }
    strcpy (pTypesInfo->Name.Buffer, (char *)pInfo->Name.Buffer);
    pTypesInfo->Name.Length = SymLen;
    if (ModLen) {
        
        if (sizeof( pTypesInfo->ModName) <= ModLen) {
            // truncate module name
            strncpy(pTypesInfo->ModName, pInfo->ModName, sizeof(pTypesInfo->ModName));
            pTypesInfo->ModName[sizeof(pTypesInfo->ModName) - 1] = '\0';
        } else
            strcpy (pTypesInfo->ModName, pInfo->ModName);
    }

    pTypesInfo->TypeIndex = pInfo->TypeIndex;
    pTypesInfo->Referenced = 0;
    pTypesInfo->hProcess   = pInfo->hProcess;
    pTypesInfo->ModBaseAddress = pInfo->ModBaseAddress;
    pTypesInfo->SymAddress = pInfo->SymAddress;
    pTypesInfo->Value      = pInfo->Value;
    pTypesInfo->Flag       = pInfo->Flag;
    return indexToStore;
}

/*
 * GetTypeAddressFromField 
 *   Calculates the address of the type from address of its field.
 *   If FieldName is NULL, this subtracts the size of type from given address
 *   that is, it calculates the type address from its end address.
 */

ULONG64
GetTypeAddressFromField(
    ULONG64   Address,
    PUCHAR    TypeName,
    PUCHAR    FieldName
    )
{
    FIELD_INFO_EX fld={FieldName, NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM_EX Sym = {
       sizeof (SYM_DUMP_PARAM_EX), TypeName, DBG_DUMP_NO_PRINT, 0,
       NULL, NULL, NULL, 0, &fld
    };
    ULONG sz, status;

    if (!TypeName) {
        return 0;
    }

    if (FieldName) {
        //
        // Get offset and calculate Type address
        // 
        Sym.nFields = 1;
    } else {
        Sym.Options |= DBG_DUMP_GET_SIZE_ONLY;
    }

    if (!(sz = SymbolTypeDumpNew(&Sym, &status))) {
        return 0;
    }

    if (FieldName) {
        return (Address - fld.address);
    } else {
        return (Address - sz);
    }
}

typedef struct NAME_AND_INDEX {
    PUCHAR  Name;
    PULONG  Index;
    ULONG64 Address;
    PSYMBOL_INFO pSymInfo;
} NAME_AND_INDEX;

typedef struct _TYPE_ENUM_CONTEXT {
    PCHAR  ModName;
    PCHAR  SymName;
    SYMBOL_INFO SI;
} TYPE_ENUM_CONTEXT;

//
// Callback routine to list symbols
//
BOOL ListIndexedTypes (LPSTR tyName, ULONG ti, PVOID ctxt)
{
    NAME_AND_INDEX* ListInfo = ((NAME_AND_INDEX *) ctxt);
    LPSTR modName = (char *)ListInfo->Name;
    if (ti || (*ListInfo->Index & VERBOSE))
    {
        dprintf(" %s!%s%s\n", 
                modName, 
                tyName, 
                (ti ? "" : " (no type info)"));
    }
    if (CheckUserInterrupt())
    {
        return FALSE;
    }

    return TRUE;
}


//
// Callback routine to list symbols
//
BOOL ListIndexedVarsWithAddr (LPSTR tyName, ULONG ti, ULONG64 Addr, PVOID ctxt) {
    NAME_AND_INDEX* ListInfo = ((NAME_AND_INDEX *) ctxt);
    LPSTR modName = (char *)ListInfo->Name;
    if (ti || (*ListInfo->Index & VERBOSE)) {
        if (Addr) {
            dprintf64("%p  %s!%s%s\n", 
                      Addr,
                      modName, 
                      tyName, 
                      (ti ? "" : " (no type info)"));
        } else 
            dprintf("          %s!%s%s\n", 
                    modName, 
                    tyName, 
                    (ti ? "" : " (no type info)"));
    }
    
    if (CheckUserInterrupt()) {
        return FALSE;
    }

    return TRUE;
}

//
// Callback routine to list symbols
//
BOOL ListTypeSyms (PSYMBOL_INFO pSym, ULONG Size, PVOID ctxt) {
    TYPE_ENUM_CONTEXT * ListInfo = ((TYPE_ENUM_CONTEXT *) ctxt);
    LPSTR modName = (char *)ListInfo->ModName;
    ULONG ti = pSym->TypeIndex;
    
    if (ti || (ListInfo->SI.Flags & VERBOSE)) {
        if (MatchPattern( pSym->Name, ListInfo->SymName )) {

            if (pSym->Address) {
                dprintf64("%p  %s!%s%s\n", 
                          pSym->Address,
                          modName, 
                          pSym->Name, 
                          (ti ? "" : " (no type info)"));
            } else 
                dprintf("          %s!%s%s\n", 
                        modName, 
                        pSym->Name, 
                        (ti ? "" : " (no type info)"));
        }
    }
    
    if (CheckUserInterrupt()) {
        return FALSE;
    }

    return TRUE;
}

BOOL StoreFirstIndex (LPSTR tyName, ULONG ti, PVOID ctxt) {
    if (ti) {
        PULONG pTI = (PULONG) ctxt;
        *pTI = ti;
        return FALSE;
    }
    return TRUE;
}

BOOL StoreFirstNameIndex (PSYMBOL_INFO pSym, ULONG Sz, PVOID ctxt) {
    NAME_AND_INDEX *pName = (NAME_AND_INDEX *) ctxt;
    
    if (pSym->TypeIndex &&
        !strncmp(pSym->Name, (PCHAR) pName->Name, strlen((PCHAR) pName->Name))) {
        ULONG dw = pName->pSymInfo->MaxNameLen;

        strcpy((char *)pName->Name, pSym->Name);
        
        *pName->Index = pSym->TypeIndex;;
        pName->Address = pSym->Address;

        *pName->pSymInfo  = *pSym;
        pName->pSymInfo->MaxNameLen = dw;
        return FALSE;
    }
    return TRUE;
}

BOOL exactMatch = TRUE;
CHAR g_NextToken[MAX_NAME];

//
// Gets next token from argumentstring
// Returns pointer to next unused char in arg
//
PCHAR
GetNextToken(
    PCHAR arg
    )
{
    PCHAR Token = &g_NextToken[0];
    BOOL ParStart=FALSE;

    *Token=0;
    while (*arg && (*arg == ' ' || *arg =='\t') ) { 
        arg++;
    }

    if (!*arg) {
        return arg;
    }

    ULONG Paren = (*arg=='(' ? (arg++, ParStart=TRUE, 1) : 0);
    ULONG i=0;
    while (*arg && ((*arg != ' ' && *arg != ';') || Paren)) { 
        if (*arg=='(') 
            ++Paren;
        else if (*arg == ')') {
            --Paren;
            if (ParStart && !Paren) {
                // We are done
                *Token=0;
                ++arg;
                break;
            }
        }
        *(Token++) = *(arg++);
    }
    *Token=0;
    return arg;
}

ULONG
IdentifierLen(PSTR Token) {
    ULONG len = 0;

    if (!Token || !IsIdStart(*Token)) {
        return len;
    }
    while (*Token && (IsIdStart(*Token) || isdigit(*Token))) { 
        Token++; len++;
    }
    return len;
}

ULONG
NextToken(
    PLONG64 pvalue
    );

//
// True if word is a symbol / type / typecast
// eg. _name, !ad, mod!x, TYPE *, TYPE*, field.mem.nmem, fld.arr[3] are all symbols 
//
BOOL symNext(LPSTR numStr) {
    USHORT i=0;
    CHAR c=numStr[i];
    BOOL hex=TRUE;
    PSTR save = g_CurCmd;
    LONG64 code;
    ULONG nxt;

    if (!strcmp(numStr, ".")) {
        // Last type
        return TRUE;
    }

    if (c == '&') {
        c = numStr[++i];
    }
    if (IsIdStart(c)) {
        // Can be a symbol
        i=0;
        while ( c && 
               (IsIdChar(c) || (c=='[') || (c=='-') || c==' ' || c=='*' || c=='.' || c==':')) { 
            hex = hex && isxdigit(c);
            if (!IsIdChar(c)) {
                switch (c) { 
                case '[':
                    while (numStr[++i] != ']' && numStr[i]);
                    if (numStr[i] != ']') {
                        return FALSE;
                    }
                    break;
                case '.':
                    while(numStr[i+1]=='.') ++i; // allow field.. for prefix field matches
                    if (numStr[i+1] && !IsIdStart(numStr[i+1])) {
                        return FALSE;
                    }
                case ':':
                case '*':
                    break;
                case '-':
                    if (numStr[++i] != '>') {
                        return FALSE;
                    } else if (!IsIdStart(numStr[i+1])) {
                        return FALSE;
                    }
                    break;
                case ' ':
                    while(numStr[i+1]==' ') ++i;
                    while(numStr[i+1]=='*') ++i;
                    if (numStr[i+1]) {
                        return FALSE;
                    }
                    break;
                }
            }
            if ( c == '!') {
                // must be symbol
                return TRUE;
            }
            c=numStr[++i];
        }
        if (c || hex) {
            return FALSE;
        }
        return TRUE;;

    } else 
        return FALSE;
    
    return FALSE;
}

BOOL 
AddressNext(
    LPSTR numStr
    ) 
{
    int i=0;

    if ((numStr[0]=='0') && (tolower(numStr[1])=='x')) {
        i=2;
    }
    while (numStr[i] && numStr[i]!=' ') { 
        if (!isxdigit(numStr[i]) && (numStr[i] !='\'')) {
            return FALSE;
        }
        ++i;
    }
    return TRUE;
}

/*
 *Function Name: ShowUsage
 *
 *Description: Displays the usage of dt
 *
 */
VOID 
ShowUsage(
    BOOL ShowAll
    ) 
{
    ULONG Options=0;

    typPrint("dt - dump symbolic type information.\n");
    typPrint("dt [[-ny] [<mod-name>!]<name>[*]] [[-ny] <field>]* [<address>] \n"
             "   [-l <list-field>] [-abchioprv]\n");
    if (!ShowAll) {
        return;
    }

    typPrint("  <address>       Memory address containing the type.\n");
    typPrint("  [<module>!]<name>\n");
    typPrint("                  module : name of module, optional\n");
    typPrint("                  name: A type name or a global symbol.\n");
    typPrint("                  Use name* to see all symbols begining with `name'.\n");
    typPrint("  <field>         Dumps only the 'field-name(s)' if 'type-name' is a\n"
             "                  struct or union.                                  \n"
             "                  Format : <[((<type>.)*) | ((<subfield>.)*)]>.field\n"
             "                  Can also refer directly to array elemnt like fld[2].\n");
    typPrint("  dt <mod>!Ty*    Lists all Types, Globals and Statics of prefix Ty in <mod>\n"
             "                  -v with this also lists symbols without type info.\n");
    typPrint("  -a              Shows array elements in new line with its index.\n");
    typPrint("  -b              Dump only the contiguous block of struct.\n");
    typPrint("  -c              Compact output, print fields in same line.\n");
    typPrint("  -h              Show this help.\n");
    typPrint("  -i              Does not indent the subtypes.\n");
    typPrint("  -l <list-field> Field which is pointer to the next element in list.\n");
    typPrint("  -n <name>       Use this if name can be mistaken as an address.\n");
    typPrint("  -o              Omit the offset value of fields of struct.\n");
    typPrint("  -p              Dump from physical address.\n");
    typPrint("  -r[l]           Recursively dump the subtypes (fields) upto l levels.\n");
    typPrint("  -v              Verbose output.\n");
    typPrint("  -y <name>       Does partial match instead of default exact match of the\n"
             "                  name following -y, which can be a type or field's name.\n");
} /* End function ShowUsage */

/*
 * Function Name: ParseArgumentString
 *
 * Parameters: IN LPSTR lpArgumentString, PSYM_DUMP_PARAM_EX dp
 *
 * Description:
 *          Fills up dp by interpreting vcalues in lpArgumentString
 *
 * Returns: TURE on success
 *
 */
BOOL 
ParseArgumentString(
    IN LPSTR lpArgumentString, 
    OUT PSYM_DUMP_PARAM_EX dp
    ) 
{
    DWORD Options=0, maxFields=dp->nFields;
    BOOL symDone=FALSE, addrDone=FALSE, fieldDone=FALSE, listDone=FALSE;
    BOOL flag=FALSE, fullSymMatch;
    LPSTR args;
    BOOL InterpretName = FALSE;
    static CHAR LastType[256]={0};

    if (dp == NULL) {
        return FALSE;
    }

    // Parse the arguments
    dp->nFields=0;
    args = lpArgumentString;
    fullSymMatch = TRUE;
    while ((*args!=(TCHAR)NULL) && (*args!=(TCHAR)';')) {

        if ((*args=='\t') || (*args==' ')) {
            flag=FALSE;
            ++args;
            continue;
        }

        if (*args=='-' || *args=='/') {
            ++args;
            flag=TRUE; 
            continue;
        }

        if (flag) {
            switch (*args) {
            case 'a': {
                ULONG Sz = isdigit(*(args+1)) ? 0 : 5;
                ULONG i  = 0;
                BOOL  SzEntered=FALSE;
                while (isdigit(*(args+1)) && (++i<5)) {
                    Sz= (*((PUCHAR) ++args) - '0') + Sz*10;
                    SzEntered = TRUE;
                }
                
                if (symDone) {
                    dp->Fields[dp->nFields].fOptions |= FIELD_ARRAY_DUMP;
                    dp->Fields[dp->nFields].size = SzEntered ? Sz : 0;
                } else {
                    Options |= DBG_DUMP_ARRAY;
                    dp->listLink->size = Sz;
                }
                break;
            }
            case 'b':
                Options |= DBG_DUMP_BLOCK_RECURSE;
                break;
            case 'c':
                Options |= DBG_DUMP_COMPACT_OUT;
                break;
            case 'h':
            case '?':
                ShowUsage(TRUE);
                g_CurCmd = args + strlen(args);
                return FALSE;
            case 'i':
                Options |= NO_INDENT;
                break;
            case 'l':
                Options |= LIST_DUMP;
                break;
            case 'n':
                InterpretName = TRUE;
                break;
            case 'o':
                Options |= NO_OFFSET;
                break;
            
            case 'p':
                Options |= DBG_DUMP_READ_PHYSICAL;
                break;
            case 'r':
                if (isdigit(*(args+1))) {
                    WORD i = *(++args) -'0';
                    i = i << 8;
                    Options |=i;
                } else {
                    Options |= RECURSIVE2;
                }
                break;
            case 'v':
                Options |= VERBOSE;
                break;
            case 'x': // Obsolete, now default is exact match
                break;
            case 'y':
                if (!symDone) {
                    // partial match for symbol
                    fullSymMatch = FALSE;
                    exactMatch = FALSE;
                } else if (!fieldDone) // exact match for following field
                    fullSymMatch = FALSE;
                break;
            default:
                typPrint("Unknown argument -%c\n", *args);
                ShowUsage(FALSE);
                return FALSE;
            } /* switch */

            ++args;
            continue;
        }

        args = GetNextToken(args);
        // args+= strlen(g_NextToken);
        PCHAR Token = &g_NextToken[0];
        if ((!addrDone) && !InterpretName && !symNext(Token)) {
            LPSTR i = strchr(Token,' '), s;
            ULONG64 addr=0;
            ULONG64 val=0;


            g_CurCmd = Token;
            addr = GetExpression();
            // dprintf("Addr %I64x, Args rem %s\n", addr, g_CurCmd);
            // sscanf(args, "%I64lx", &addr);
            dp->addr=addr;
            addrDone=TRUE;
            continue;
        }
        
        InterpretName = FALSE;

        if (!symDone) {
            strcpy((char *)dp->sName, Token);
            if (!strcmp(Token, ".") && LastType[0]) {
                dprintf("Using sym %s\n", LastType);
                strcpy((char *)dp->sName, LastType);
            } else if (strlen(Token) < sizeof(LastType)) {
                strcpy(LastType, Token);
            }
            symDone=TRUE;
            fullSymMatch = TRUE;
            continue;
        }


        if (!fieldDone) {
            strcpy((char *)dp->Fields[dp->nFields].fName, Token);
            if ((Options & LIST_DUMP) && !(dp->listLink->fName[0]) && !listDone) {
                listDone=TRUE;
                strcpy((char *)dp->listLink->fName,
                       (char *)dp->Fields[dp->nFields].fName);
                dp->listLink->fOptions |= fullSymMatch ? DBG_DUMP_FIELD_FULL_NAME : 0;

            } else {
                PCHAR fName = (PCHAR) dp->Fields[dp->nFields].fName;
                if (fName[strlen(fName)-1] == '.') {
                    fullSymMatch = FALSE;
                }
                dp->Fields[dp->nFields].fOptions |= fullSymMatch ? DBG_DUMP_FIELD_FULL_NAME : 0;
                dp->nFields++;
            }
            fieldDone = (maxFields <= dp->nFields);
            fullSymMatch = TRUE;
            continue;
        } else {
            typPrint("Too many fields in %s\n", args);
            // ShowUsage();
            return FALSE;
        }

    }

    dp->Options = Options;

    g_CurCmd = args;
    return TRUE;

} /* End function ParseArgumentString */


BOOL
CheckFieldsMatched(
    PULONG ReturnVal,
    PTYPE_DUMP_INTERNAL pErrorInfo,
    PSYM_DUMP_PARAM_EX     pSym
    )
{
    ULONG i, OneMatched=FALSE;

    //
    // Return false if we need not continue after this.
    //
    if (*ReturnVal && !pErrorInfo->ErrorStatus) {
        if (!pSym->nFields) 
            return TRUE;
        //
        // Check if any of the fields, if specified in pSym, actually matched
        //
        for (i=0; i<pSym->nFields; i++) { 
            if (pErrorInfo->AltFields[i].FieldType.Matched) {
                return TRUE;
            }
        } 
        pErrorInfo->ErrorStatus = FIELDS_DID_NOT_MATCH;
        return FALSE;
    } 
    return TRUE;
}


//
// Callback routine to find if any symbol has type info
//
BOOL CheckIndexedType (PSYMBOL_INFO pSym, ULONG Sz, PVOID ctxt) {
    PULONG pTypeInfoPresent = (PULONG) ctxt;
    
    if (pSym->TypeIndex) {
        *pTypeInfoPresent = TRUE;
        return FALSE;
    }
    return TRUE;
}


ULONG
CheckForTypeInfo(
    IN HANDLE  hProcess,
    IN ULONG64 ModBaseAddress
    ) 
/*
  This routines checks whether the given module referred by ModBaseAddress has
  any type info or not. This is done by trying to get type info for a basic type 
  like PVOID/ULONG which would always be present in a pdb.
*/
{
    ULONG TypeInfoPresent = FALSE;

    SymEnumTypes(
        hProcess,
        ModBaseAddress,
        &CheckIndexedType,
        &TypeInfoPresent);
    if (TypeInfoPresent) {
        return TRUE;
    }
    
    SymEnumSymbols(
        hProcess,
        ModBaseAddress,
        NULL,
        &CheckIndexedType,
        &TypeInfoPresent);
    if (TypeInfoPresent) {
        return TRUE;
    }
    
    return FALSE;
}

BOOL 
GetModuleBase(
    IN PCHAR  ModName,
    IN PDEBUG_IMAGE_INFO pImage,
    OUT PULONG64 ModBase
    )
{
    if (!ModBase || !ModName || !pImage) {
        return FALSE;
    }
    while (pImage) {
        // Look up the module list
        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT) {
            return FALSE;
        }

        if (ModName[0]) {
            if (!_stricmp(ModName, pImage->ModuleName)) {
                *ModBase = pImage->BaseOfImage;
                return TRUE;
            }
        }
        pImage = pImage->Next;
    }
    return FALSE;
}

ULONG 
EnumerateTypes(
    IN PCHAR TypeName,
    IN ULONG Options
)
{
    PCHAR   bang;
    ULONG   typNamesz, i;
    ULONG64 ModBase=0;
    CHAR    modName[30], SymName[MAX_NAME];

    bang = strchr((char *)TypeName, '!');
    if (bang)
    {
        strncpy(modName, TypeName, (ULONG)( (PCHAR)bang - (PCHAR) TypeName));
        modName[(ULONG)(bang - (char *)TypeName)]='\0';
        strcpy(SymName, bang+1);
    }
    else
    {
        return FALSE;
    }

    if (!GetModuleBase(modName, g_CurrentProcess->ImageHead, &ModBase))
    {
        return FALSE;
    }

    PDEBUG_SCOPE Scope = GetCurrentScope();
    
    IMAGEHLP_MODULE64 mi;
    SymGetModuleInfo64( g_CurrentProcess->Handle, ModBase, &mi );
    
    if (mi.SymType == SymDeferred)
    {
        SymLoadModule64( g_CurrentProcess->Handle, 
                         NULL, 
                         PrepareImagePath(mi.ImageName),
                         mi.ModuleName, 
                         mi.BaseOfImage, 
                         mi.ImageSize);
    }
    
    if (strchr(SymName,'*'))
    {
        TYPE_ENUM_CONTEXT ListTypeSymsCtxt;
        i = -1;
        while (SymName[++i])
        {
            SymName[i] = (CHAR)toupper(SymName[i]);
        }

        ListTypeSymsCtxt.ModName = modName;
        ListTypeSymsCtxt.SymName = SymName;
        ListTypeSymsCtxt.SI.Flags= Options;

        SymEnumTypes(g_CurrentProcess->Handle,
                     ModBase,
                     &ListTypeSyms,
                     &ListTypeSymsCtxt);
        SymEnumSymbols(g_CurrentProcess->Handle,
                   ModBase,
                   NULL,
                   &ListTypeSyms,
                   &ListTypeSymsCtxt);
        return TRUE;
    }
    return FALSE;
}

#define NUM_ALT_NAMES 10


BOOL 
CALLBACK 
FindLocal(
    PSYMBOL_INFO    pSymInfo,
    ULONG           Size,
    PVOID           Context
    )
{
    PSYMBOL_INFO SymTypeInfo = (PSYMBOL_INFO) Context;

    if (!strcmp(pSymInfo->Name, SymTypeInfo->Name)) {
        memcpy(SymTypeInfo, pSymInfo, sizeof(SYMBOL_INFO));
        return FALSE;
    }
    return TRUE;
}


/*
  FindLocalSymbol
         Looks up the type information of a symbol in current Scope.
         
         pTypeInfo is used to store the type info, if found.
         
         Returns TRUE on success
*/
BOOL
FindLocalSymbol(
    IN HANDLE  hProcess,
    IN PCHAR   SymName,
    OUT PTYPES_INFO    pTypeInfo
    )
{
    ULONG sz = sizeof (SYMBOL_INFO);
    CHAR  Buffer[MAX_NAME+sizeof(SYMBOL_INFO)] = {0};
    PSYMBOL_INFO    SymTypeInfo = (PSYMBOL_INFO) &Buffer[0];

    SymTypeInfo->MaxNameLen = MAX_NAME;

    strcpy(SymTypeInfo->Name, SymName);
    
    EnumerateLocals(FindLocal, (PVOID) SymTypeInfo); 
    
    if (!SymTypeInfo->TypeIndex) {

            return FALSE;

    }
    pTypeInfo->hProcess       = hProcess;
    pTypeInfo->ModBaseAddress = SymTypeInfo->ModBase;
    pTypeInfo->TypeIndex      = SymTypeInfo->TypeIndex;
    pTypeInfo->SymAddress     = SymTypeInfo->Address;
    pTypeInfo->Value          = SymTypeInfo->Register;

    if (pTypeInfo->Name.Buffer) {
        if (strlen((char *) SymName) < pTypeInfo->Name.MaximumLength) {
            strcpy(pTypeInfo->Name.Buffer, (char *) SymName);
        } else {
            strncpy(pTypeInfo->Name.Buffer, (char *)SymName, pTypeInfo->Name.MaximumLength - 1);
            pTypeInfo->Name.Buffer[pTypeInfo->Name.MaximumLength - 1]=0;
        }
    }
    if (exactMatch && (SymTypeInfo->Flags & IMAGEHLP_SYMBOL_INFO_VALUEPRESENT)) {
        pTypeInfo->Value = SymTypeInfo->Value;
    }
    pTypeInfo->Flag = SymTypeInfo->Flags | SYM_IS_VARIABLE;
    
    if (pTypeInfo->Name.Buffer) {
        g_ReferencedSymbols.StoreTypeInfo(pTypeInfo);
    }
    return TRUE;
}

/*
  FindTypeInfoFromModName
         Looks up the type information of a symbol in a particular module.
         
         pTypeInfo is used to store the type info, if found.
         
         Returns zero on success error no. on failure
*/
ULONG
FindTypeInfoFromModName(
    IN HANDLE  hProcess,
    IN PCHAR   ModName,
    IN PCHAR   SymName,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO    pTypeInfo
    )
{
    ULONG64 ModBase = 0;
    ULONG res=0;
    ULONG Options = pSym->Options, typNamesz=sizeof(ULONG);    UCHAR i=0;
    ULONG          typeIndex;
    ULONG          TypeStored=-1;
    UCHAR          MatchedName[MAX_NAME+1]={0};
    UCHAR          ModuleName[30];
    BOOL           GotSymAddress=FALSE;
    NAME_AND_INDEX ValuesStored;
    SYMBOL_INFO    SymTypeInfo = {0};

    i=strlen((char *)SymName);
    if (strlen(ModName) < sizeof (ModuleName)) {
        strcpy((char *)ModuleName, ModName);
    }

    if (exactMatch) {
        strcpy((PCHAR) MatchedName, ModName);
        strcat((PCHAR) MatchedName, "!");
        strcat((PCHAR) MatchedName, SymName);
        if (!SymGetTypeFromName(hProcess,ModBase,(LPSTR) &MatchedName[0],&SymTypeInfo)) {
            if (!SymFromName(
                hProcess,
                (LPSTR) &MatchedName[0],
                &SymTypeInfo)) {

                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
        }
    } else {
        // We cannot enumerate without module base
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }
    if (!SymTypeInfo.TypeIndex) {
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }
        
    
    typeIndex = SymTypeInfo.TypeIndex;
    

    // Type index and server info is correctly returned
    if (!MatchedName[0]) {
        strcpy((char *)MatchedName, (char *)SymName);
    }

    if (!typeIndex) {
        vprintf("Cannot get type Index.\n");
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }


    if (!pSym->addr) {
        //
        // See if we can get address in case it is a global symbol
        //
        if (SymTypeInfo.Address && !pSym->addr) {
            GotSymAddress = TRUE;
            SymTypeInfo.Flags |= SYM_IS_VARIABLE;

            vprintf("Got address %p for symbol\n", SymTypeInfo.Address, MatchedName);
        }
    }

    PUCHAR tmp=pSym->sName;
    ULONG64 addr = pSym->addr;

    if (!GotSymAddress) {
        pSym->addr = 0;
    }
    if (!pTypeInfo) {
        typPrint("Null pointer reference : FindTypeInfoInMod-pTypeInfo\n");
        return TRUE;
    }

    pTypeInfo->hProcess       = hProcess;
    pTypeInfo->ModBaseAddress = SymTypeInfo.ModBase;
    pTypeInfo->SymAddress     = SymTypeInfo.Address;
    pTypeInfo->TypeIndex      = SymTypeInfo.TypeIndex;
    strcpy((char *)pTypeInfo->ModName, ModName);
    if (pTypeInfo->Name.Buffer) {
        if (strlen((char *) SymName) < pTypeInfo->Name.MaximumLength) {
            strcpy(pTypeInfo->Name.Buffer, (char *) SymName);
        } else {
            strncpy(pTypeInfo->Name.Buffer, (char *)SymName, pTypeInfo->Name.MaximumLength - 1);
            pTypeInfo->Name.Buffer[pTypeInfo->Name.MaximumLength - 1]=0;
        }
    }
    if (exactMatch && (SymTypeInfo.Flags & IMAGEHLP_SYMBOL_INFO_VALUEPRESENT)) {
        pTypeInfo->Value = SymTypeInfo.Value;
    }
    pTypeInfo->Flag = SymTypeInfo.Flags;

    
    //
    // Store the corresponding module information for fast future reference
    //        
    if (pTypeInfo->Name.Buffer) {
        g_ReferencedSymbols.StoreTypeInfo(pTypeInfo);
    }
    if (addr) {
        // Use original value for this dump
        pTypeInfo->SymAddress = pSym->addr  = addr;
        pTypeInfo->Flag = 0;
    }

    return FALSE;
}

/*
  FindTypeInfoInMod
         Looks up the type information of a symbol in a particular module.
         
         pTypeInfo is used to store the type info, if found.
         
         Returns zero on success error no. on failure
*/
ULONG
FindTypeInfoInMod(
    IN HANDLE  hProcess,
    IN ULONG64 ModBase,
    IN PCHAR   ModName,
    IN PCHAR   SymName,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO    pTypeInfo
    )
{
    ULONG res=0, Options = pSym->Options, typNamesz=sizeof(ULONG);
    UCHAR i=0;
    ULONG          typeIndex;
    ULONG          TypeStored=-1;
    UCHAR          MatchedName[MAX_NAME+1]={0};
    UCHAR          ModuleName[30];
    BOOL           GotSymAddress=FALSE;
    NAME_AND_INDEX ValuesStored;
    SYMBOL_INFO    SymTypeInfo = {0};

    i=strlen((char *)SymName);
    if (strlen(ModName) < sizeof (ModuleName)) {
        strcpy((char *)ModuleName, ModName);
    }

    // Query for the the type / symbol name
    ValuesStored.Index    = &typeIndex;
    ValuesStored.Name     = (PUCHAR) SymName;
    ValuesStored.Address  = 0;
    ValuesStored.pSymInfo = &SymTypeInfo;
    
    if (exactMatch) {
        if (!SymGetTypeFromName(hProcess,ModBase,(LPSTR) SymName,&SymTypeInfo)) {
            strcpy((PCHAR) MatchedName, ModName);
            strcat((PCHAR) MatchedName, "!");
            strcat((PCHAR) MatchedName, SymName);
            if (!SymFromName(
                hProcess,
                (LPSTR) &MatchedName[0],
                &SymTypeInfo)) {

                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
        }
    } else {
        if (!SymEnumTypes(hProcess,ModBase,&StoreFirstNameIndex,&ValuesStored)) {
            if (!SymEnumSymbols(
                hProcess,
                ModBase,
                NULL,
                &StoreFirstNameIndex,
                &ValuesStored)) {
                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
        }
    }
    if (!SymTypeInfo.TypeIndex) {
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }
        
    
    typeIndex = SymTypeInfo.TypeIndex;
    

    // Type index and server info is correctly returned
    if (!exactMatch && strcmp((char *)MatchedName, (char *)SymName) && (Options & VERBOSE) && MatchedName[0]) {
        typPrint("Matched symbol %s\n", MatchedName);
    } else if (!MatchedName[0]) {
        strcpy((char *)MatchedName, (char *)SymName);
    }

    if (!typeIndex) {
        vprintf("Cannot get type Index.\n");
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }


    if (!pSym->addr) {
        //
        // See if we can get address in case it is a global symbol
        //
        if (SymTypeInfo.Address && !pSym->addr) {
//            pSym->addr = SymTypeInfo.Address;
            GotSymAddress = TRUE;
            SymTypeInfo.Flags |= SYM_IS_VARIABLE;

            vprintf("Got address %p for symbol\n", SymTypeInfo.Address, MatchedName);
        }
    }

    PUCHAR tmp=pSym->sName;
    ULONG64 addr = pSym->addr;

    if (!exactMatch && strcmp((char *)MatchedName, (char *)SymName)) {
        strcpy(SymName, (char *) &MatchedName[0]);
    }

    if (!GotSymAddress) {
        pSym->addr = 0;
    }
    if (!pTypeInfo) {
        typPrint("Null pointer reference : FindTypeInfoInMod.pTypeInfo\n");
        return TRUE;
    }

    pTypeInfo->hProcess       = hProcess;
    pTypeInfo->ModBaseAddress = SymTypeInfo.ModBase ? SymTypeInfo.ModBase : ModBase;
    pTypeInfo->SymAddress     = SymTypeInfo.Address;
    pTypeInfo->TypeIndex      = SymTypeInfo.TypeIndex;
    strcpy((char *)pTypeInfo->ModName, ModName);
    if (pTypeInfo->Name.Buffer) {
        if (strlen((char *) SymName) < pTypeInfo->Name.MaximumLength) {
            strcpy(pTypeInfo->Name.Buffer, (char *) SymName);
        } else {
            strncpy(pTypeInfo->Name.Buffer, (char *)SymName, pTypeInfo->Name.MaximumLength - 1);
            pTypeInfo->Name.Buffer[pTypeInfo->Name.MaximumLength - 1]=0;
        }
    }
    if (exactMatch && (SymTypeInfo.Flags & IMAGEHLP_SYMBOL_INFO_VALUEPRESENT)) {
        pTypeInfo->Value = SymTypeInfo.Value;
    }
    pTypeInfo->Flag = SymTypeInfo.Flags;

    
    //
    // Store the corresponding module information for fast future reference
    //        
    if (pTypeInfo->Name.Buffer) {
        g_ReferencedSymbols.StoreTypeInfo(pTypeInfo);
    }
    if (addr) {
        // Use original value for this dump
        pTypeInfo->SymAddress = pSym->addr  = addr;
        pTypeInfo->Flag = 0;
    }

    return FALSE;
}

ULONG
FindTypeInfoInDefaultMod(
    IN HANDLE  hProcess,
    IN PCHAR   SymName,
    IN BOOL    Load,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO    pTypeInfo
    )
{
    ULONG64 mBase;
    static ULONG64 DefaultmBase = 0xfefefefe;
    PTCHAR DefaultModule[4] = {"ntoskrnlsym", "ntkrnlmpsym", "ntkrnlpasym", "ntkrpampsym"};
    static BOOL DefaultModLoaded=FALSE;
    IMAGEHLP_MODULE64 mi;

    //
    // Type information hasn't been found so far, check in the default module
    //
    // If we do not find type information, it's possible the symbol file is 
    // stripped of private information.  This happens when we ship symbols outside 
    // of Microsoft.  So in this case we have a special file, ntsym* which does 
    // have full symbols for the kernel and driver structures.  Let's see if we
    // can find the appropriate type information in that file
    //
    
    // This module is loaded internally and is not
    // part of the real module list so we do not
    // want symbol notifications generated for it.
    g_EngNotify++;
        
    mi.SizeOfStruct = sizeof(mi);
    ULONG j=0;
    if (!DefaultModLoaded && Load) {

        mBase=0;

        if (KdDebuggerData.PaeEnabled) {
            j |= 2;
        }
        if (g_TargetNumberProcessors > 1) {
            j |= 1;
        }

//        dprintf(" %s ...", DefaultModule[j]);            
        if (mBase = SymLoadModule64(hProcess,
                                     NULL,
                                     DefaultModule[j],
                                     DefaultModule[j],
                                     DefaultmBase,
                                     0))
        {
            DefaultmBase = mBase;
            if ( SymGetModuleInfo64( hProcess, DefaultmBase, &mi ) ) {

                if (mi.SymType == SymDeferred) {
                    SymLoadModule64(hProcess,
                                    NULL,
                                    PrepareImagePath(mi.ImageName),
                                    mi.ModuleName,
                                    mi.BaseOfImage,
                                    mi.ImageSize);
                    SymGetModuleInfo64( hProcess, mi.BaseOfImage, &mi );
                }

            } else {
//                dprintf(" failed to load.\n");            
            }
        } else {
//            dprintf(" failed to load 2.\n");            
        }
    } else if (!Load) {
        if (DefaultModLoaded && 
            (mBase = SymUnloadModule64(hProcess, DefaultmBase))) {
        }
        DefaultModLoaded = FALSE;
        g_EngNotify--;
        return SYMBOL_TYPE_INDEX_NOT_FOUND;
    }

    g_EngNotify--;

    if (!SymGetModuleInfo64( hProcess, DefaultmBase, &mi)) {
        DefaultModLoaded = FALSE;
//        DefaultmBase = 0;
    } else  {
        DefaultModLoaded = TRUE;
        return FindTypeInfoInMod(hProcess, DefaultmBase, DefaultModule[j], SymName, pSym, pTypeInfo);
    }

    return SYMBOL_TYPE_INDEX_NOT_FOUND;

}

/*
    TypeInfoFound 
            Looks for the type information of the given symbol (which may either 
            be a variable or a type name.

    Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize

    pImage              - Pointer to list of images (modules) for the process

    pSym                - Parameters for symbol lookup and dump

    pTypeInfo           - Used to return the type information
    
    Return Value:

     0 on success and error val on failure    
    
*/

ULONG
TypeInfoFound(
    IN HANDLE hProcess,
    IN PDEBUG_IMAGE_INFO pImage,
    IN PSYM_DUMP_PARAM_EX pSym,
    OUT PTYPES_INFO pTypeInfo
    )
{
    TCHAR  modName[256], symStored[MAX_NAME]={0}, nTimes=0;
    PTCHAR i, symPassed=(PTCHAR)pSym->sName;
    BOOL   modFound=FALSE, firstPass=TRUE;
    ULONG  TypeStored;
    CHAR   buff[sizeof(SYMBOL_INFO) + MAX_NAME];
    IMAGEHLP_MODULE64     mi;
    PSYMBOL_INFO psymbol;
    USHORT  j;
    ULONG   Options = pSym->Options;
    static BOOL TypeInfoPresent=FALSE, TypeInfoChecked=FALSE;
    ULONG   res=0;
    PDEBUG_IMAGE_INFO pImgStored=pImage;
    BOOL    FoundIt = FALSE, DbgDerivedType=FALSE;

    if (!pSym || !pTypeInfo)
    {
        vprintf("Null input values.\n");
        return NULL_SYM_DUMP_PARAM;
    }

    PDEBUG_SCOPE Scope = GetCurrentScope();

    if (pSym->sName)
    {
        strcpy(symStored, (char *)pSym->sName);
    }
    else
    {
      //       pSym->sName = "";
    }

    // Special pointer/array type
    if (symStored[0] == '&')
    {
        DbgDerivedType = TRUE;
        strcpy(&symStored[0], &symStored[1]);
    }
    modName[0]='\0';
    if (symStored[0] != (TCHAR) NULL)
    {
        i = strchr((char *)symStored, '!');
        if (i)
        {
            strncpy(modName, (char *)symStored, (PCHAR)i - (PCHAR) symStored);
            modName[i - (char *)symStored]='\0';
            strcpy((char *)symStored, i+1);
            //
            // When debugging user mode, NT! should be treated as ntdll!
            //
            if (IS_USER_TARGET())
            {
                if (!_stricmp(modName, "nt"))
                {
                    strcpy(modName, "ntdll");
                }
            }
        }
    }
    else
    {
        if (pSym->addr != 0)
        {
            DWORD64 dw=0;
            psymbol = (PSYMBOL_INFO) &buff[0];
            psymbol->MaxNameLen = MAX_NAME;
            if (SymFromAddr(hProcess, pSym->addr, &dw, psymbol))
            {
                strcpy((char *)symStored, psymbol->Name);
                vprintf("Got symbol %s from address.\n", symStored);
                pTypeInfo->hProcess = hProcess;
                pTypeInfo->Flag = psymbol->Flags;
                pTypeInfo->ModBaseAddress = psymbol->ModBase;
                pTypeInfo->TypeIndex = psymbol->TypeIndex;
                pTypeInfo->Value = psymbol->Register;
                pTypeInfo->SymAddress = psymbol->Address;
                if (pTypeInfo->Name.MaximumLength)
                {
                    pTypeInfo->Name.Length =  min(strlen(psymbol->Name)+1, pTypeInfo->Name.MaximumLength);
                    strncpy(pTypeInfo->Name.Buffer, psymbol->Name, pTypeInfo->Name.Length);
                }
                return S_OK;
            }
            else
            {
                vprintf("No symbol associated with address.\n");
                return SYMBOL_TYPE_INDEX_NOT_FOUND;
            }
        }
    }
    
    //
    // Check if this is a special type
    // 
    
    // Special pointer/array type
    if (symStored[0] == '&')
    {
        DbgDerivedType = TRUE;
        strcpy(&symStored[0], &symStored[1]);
    }
    PCHAR End = &symStored[strlen(symStored) -1];
    while (*End == '*' || *End == ']' || *End == ' ')
    { 
        DbgDerivedType = TRUE;
        if (*End == '*')
        {
            // Pointer type
        }
        else if (*End == ']')
        {
//            --End;
            while (*End && (*End != '['))
            { 
                --End;
            }
            // some way to check if array isdex is valid expr?
            if (*End!='[')
            {
                // syntax error
                typPrint("Syntax error in array type.\n");
                return E_INVALIDARG;
            }
        }
        *End=0;
        --End;
    }
    
    // Special pre-defined type
    if (!modName[0])
    {
        for (j=0; j < NUM_DBG_NATIVE_TYPES; j++)
        { 
            if (!_stricmp(symStored, g_DbgNativeTypes[j].TypeName))
            {
                pTypeInfo->TypeIndex = j | DBG_NATIVE_TYPE_FLAG;//g_DbgNativeTypes[j].TypeId;
                if (DbgDerivedType)
                {
                    pTypeInfo->TypeIndex |= DBG_DERIVED_TYPE_FLAG;
                }
                return S_OK;
            }
        }
    }

    //
    // See if this type was already referenced previously, then we don't need
    // to go through module list.
    //
    TypeStored = g_ReferencedSymbols.LookupType(symStored, modName, exactMatch);
    if (TypeStored != -1)
    {
        // We already have the type index
        ANSI_STRING Name;

        Name = pTypeInfo->Name;
        RtlCopyMemory(pTypeInfo, g_ReferencedSymbols.GetStoredIndex(TypeStored), sizeof(TYPES_INFO));
        if (Name.Buffer)
        {
            strcpy(Name.Buffer, pTypeInfo->Name.Buffer);
        }
        pTypeInfo->Name = Name;

        if (!pSym->addr && pTypeInfo->SymAddress)
        {
            vprintf("Got Address %p from symbol.\n", pTypeInfo->SymAddress);
            pSym->addr = pTypeInfo->SymAddress;
        }
        FoundIt = TRUE;
    }
    
//    if (!modName[0]) 
    {
        if ((FoundIt && !(pTypeInfo->Flag & DEBUG_LOCALS_MASK)) ||
            !FoundIt)
        {
            //
            // Check if this can be found in local scope
            //
            if (FindLocalSymbol(hProcess, symStored, pTypeInfo))
            {
                pSym->addr = pTypeInfo->SymAddress; // Need this for statics
                FoundIt = TRUE;
            } 
        }
    }

    if (FoundIt)
    {
        goto ExitSuccess;
    }

    if (modName[0])
    {
        // We first try to find it directly from dbghelp, without going 
        // through dbgeng module list.
        // This helps resolve ntoskrnl! symbols
        if (!(res = FindTypeInfoFromModName(hProcess, modName, (PCHAR) symStored, pSym, pTypeInfo)))
        {
            goto ExitSuccess;
        }
    }

    while (pImage || firstPass)
    {
        // Look up the module list
        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
        {
            return EXIT_ON_CONTROLC;
        }

        if (!pImage)
        {
            if (!modFound && modName[0])
            {
                //
                // ReLoad the module if caller explicitly asked for it
                //
                vprintf("Loading module %s.\n", modName);
                if (g_Target->Reload(modName) == S_OK)
                {
                    pImage = pImgStored;
                }
            }
            else
            {
                if (!modName[0])
                {
                    // Check in default pdb for type
                    res = FindTypeInfoInDefaultMod(hProcess, (PCHAR) symStored, TRUE, pSym, pTypeInfo);
                    if (!res)
                    {
                        goto ExitSuccess;
                    }
                }
                pImage = pImgStored;
            }
            firstPass = FALSE;
            continue;
        }
        if (modName[0])
        {
            if (_stricmp(modName, pImage->ModuleName))
            {
                pImage = pImage->Next;
                continue;
            }
        }
        modFound = TRUE;

        mi.SizeOfStruct = sizeof(mi);

        if (SymGetModuleInfo64( hProcess, pImage->BaseOfImage, &mi ))
        {
            ULONG ModSymsLoaded=FALSE;
            if (mi.SymType != SymDia)
            {
                if (!firstPass && (mi.SymType == SymDeferred))
                {
                    // Load the deferred symbols on second pass
                    ModSymsLoaded = TRUE;
                    SymLoadModule64(hProcess,
                                    NULL,
                                    PrepareImagePath(mi.ImageName),
                                    mi.ModuleName,
                                    mi.BaseOfImage,
                                    mi.ImageSize);
                    SymGetModuleInfo64( hProcess, pImage->BaseOfImage, &mi );
                }
                else if (!firstPass)
                {
                    // No need to repeat, since no load done
                    pImage = pImage->Next;
                    continue;
                }
                if (mi.SymType != SymDia)
                {
                    pImage = pImage->Next;
                    continue;
                }
                else
                {
                    vprintf(ModSymsLoaded ? " loaded symbols\n" : "\n");
                }
            }
            else
            {
                vprintf("\n");
            }
        }
        else
        {
            vprintf("Cannt get module info.\n");
            pImage = pImage->Next;
            continue;
        }

        if (!TypeInfoPresent || !TypeInfoChecked)
        {
            //
            // Check if we have the type information in pdbs
            //
            TypeInfoPresent = CheckForTypeInfo(hProcess, pImage->BaseOfImage);
        }

        if (TypeInfoPresent)
        {
            // Pdb symbols found, see if we can get type information.
            LPSTR ImageName;

            if (!(res = FindTypeInfoInMod(hProcess, pImage->BaseOfImage, pImage->ModuleName,
                                          (PCHAR) symStored, pSym, pTypeInfo)))
            {
                goto ExitSuccess;
            }
        }
        pImage = pImage->Next;
    }
    
    if (modName[0])
    {
        // We didn't find it yet
        // Check in default pdb
        res = FindTypeInfoInDefaultMod(hProcess, (PCHAR) symStored, TRUE, pSym, pTypeInfo);
        if (!res)
        {
            goto ExitSuccess;
        }
    }

    if (!TypeInfoPresent && !TypeInfoChecked && !(pSym->Options & DBG_RETURN_TYPE))
    {
        ErrOut("*************************************************************************\n"
               "***                                                                   ***\n"
               "***                                                                   ***\n"
               "***    Your debugger is not using the correct symbols                 ***\n"
               "***                                                                   ***\n"
               "***    In order for this command to work properly, your symbol path   ***\n"
               "***    must point to .pdb files that have full type information.      ***\n"
               "***                                                                   ***\n"
               "***    Certain .pdb files (such as the public OS symbols) do not      ***\n"
               "***    contain the required information.  Contact the group that      ***\n"
               "***    provided you with these symbols if you need this command to    ***\n"
               "***    work.                                                          ***\n"
               "***                                                                   ***\n"
               "***                                                                   ***\n"
               "*************************************************************************\n");
         //       TypeInfoChecked = TRUE;
    }
    res=SYMBOL_TYPE_INFO_NOT_FOUND;

    return (res);

ExitSuccess:
    if (DbgDerivedType)
    {
        pTypeInfo->TypeIndex |= DBG_DERIVED_TYPE_FLAG;
    }
    return S_OK;
}

/*
// DumpTypeAndReturnInfo
//      This dumps the type based on given type info and symbol dump info
//
// pTypeInfo  : Has the type information required to process the type
//
// pSym       : Info on how to dump this symbol
//
// pStatus    : Error status returned here
//
// pReturnTypeInfo : Used to return Type info 
//
// Return Val : Size of type dumped on success, 0 otherwise.
//
*/
ULONG
DumpTypeAndReturnInfo(
    PTYPES_INFO     pTypeInfo,
    PSYM_DUMP_PARAM_EX pSym,
    PULONG          pStatus,
    PFIND_TYPE_INFO pReturnTypeInfo
    )
{
    ULONG              Options = pSym->Options, AltNamesUsed=0;
    UCHAR              AltFieldNames[NUM_ALT_NAMES][256]={0};
    TYPE_DUMP_INTERNAL parseVars={0};
    ULONG              res, j,i ;
    UCHAR              LocalName[MAX_NAME], *saveName=pSym->sName;
    ULONG              SymRegisterId;
    DbgDerivedType *pTypeToDump = NULL;
    
    if (!pSym->addr) {
        pSym->addr = pTypeInfo->SymAddress;
    }

    if (pReturnTypeInfo) {
        // Copy the RETURN_TYPE flags
        Options |= pReturnTypeInfo->Flags;
    }
    res = 0;
    SymRegisterId = 0;
    
    //
    // Check if this is something on stack / registers
    //
    if (pTypeInfo->Flag & SYM_LOCAL) {

        pSym->addr = pTypeInfo->SymAddress;
        
        if (pTypeInfo->Flag & SYMF_REGISTER) {
            // Store register ID
            SymRegisterId = (ULONG) pTypeInfo->Value;
        }
        
        typPrint("Local var ");
        
        vprintf("[AddrFlags %lx  AddrOff %p  RegVal %I64lx] ",
                pTypeInfo->Flag, pTypeInfo->SymAddress, pTypeInfo->Value);
        TranslateAddress(pTypeInfo->Flag, (ULONG) pTypeInfo->Value, &pSym->addr, &pTypeInfo->Value);
        typPrint("@ %#p ", pSym->addr);

        if (!(Options & NO_PRINT)) {
            USHORT length = MAX_NAME;
            GetNameFromIndex(pTypeInfo, (PCHAR) &LocalName[0], &length);
            if (LocalName[0] && (LocalName[0]!='<')) {
                typPrint("Type %s", LocalName);
            }
        }
        typPrint("\n");
    }

    //
    // Check if its a constant, then we already have its value
    //
    if (pTypeInfo->Flag & (IMAGEHLP_SYMBOL_INFO_VALUEPRESENT | IMAGEHLP_SYMBOL_INFO_REGISTER)) {
        vprintf("Const ");
        vprintf("%s = %I64lx\n", pSym->sName, pTypeInfo->Value);
        ExtPrint("%I64lx", pTypeInfo->Value);

        if ((Options & DBG_DUMP_COPY_TYPE_DATA) && pSym->Context) {
            *((PULONG64) pSym->Context) = pTypeInfo->Value;
        }
        parseVars.Value = pTypeInfo->Value;
        parseVars.ValuePresent = TRUE;
    }

    if (!(Options & LIST_DUMP)) {
        // Dump only 10 elements as default
        parseVars.nElements = 10; 
        if ((pSym->Options & DBG_DUMP_ARRAY) && (pSym->listLink)) {
            parseVars.nElements = (UCHAR) pSym->listLink->size;
        }
    } else {
        //
        // List dump - make sure we have a list name
        //
        if (!pSym->listLink || !pSym->listLink->fName) {
            vprintf("NULL field name for list dump - Exiting.\n");
            parseVars.ErrorStatus = NULL_FIELD_NAME;
            goto exitDumpType;
        }
    }

    if (pSym->nFields || pSym->listLink) {
        parseVars.AltFields = (PALT_FIELD_INFO) AllocateMem((pSym->nFields + (pSym->listLink ? 1 : 0))
                                                            * sizeof(ALT_FIELD_INFO));

        if (!parseVars.AltFields) {
            parseVars.ErrorStatus = CANNOT_ALLOCATE_MEMORY;
            goto exitDumpType;
        } else {
            ZeroMemory(parseVars.AltFields, (pSym->nFields + (pSym->listLink ? 1 : 0))* sizeof(ALT_FIELD_INFO));
        }
    }

    AltNamesUsed=0;
    //
    // Check if field names are properlyinitialized
    //
    for (j=0;j<pSym->nFields; j++) { 
        PUCHAR ArrIndex;
        ULONG IndexValue=0;

        if (!pSym->Fields[j].fName) {
            vprintf("NULL field name at %d - Exiting.\n", j);
            parseVars.ErrorStatus = NULL_FIELD_NAME;
            goto exitDumpType;
        }
        if (pSym->Fields[j].fOptions & DBG_DUMP_FIELD_ARRAY) {

            parseVars.AltFields[j].ArrayElements = pSym->Fields[j].size;
        }
    }


    //
    //
    // Sign extend the address
    //
    if (!g_Machine->m_Ptr64 && !(Options & DBG_DUMP_READ_PHYSICAL)) {
        pSym->addr = (ULONG64) ((LONG64)((LONG) pSym->addr));
    }

    parseVars.ErrorStatus = 0;
    parseVars.TypeOptions   = pSym->Options;
    parseVars.rootTypeIndex = pTypeInfo->TypeIndex;
    parseVars.hProcess      = pTypeInfo->hProcess;
    parseVars.modBaseAddr   = pTypeInfo->ModBaseAddress;
    if (pTypeInfo->Flag & SYM_IS_VARIABLE) {
        parseVars.IsAVar = TRUE;
    }
    Options = pSym->Options;

    if (pReturnTypeInfo) {
        parseVars.level= (pReturnTypeInfo->Flags & (DBG_RETURN_TYPE ) ) ? 1 : 0; 
        parseVars.pInfoFound = pReturnTypeInfo;
        parseVars.pSymParams = pReturnTypeInfo->InternalParams;
        parseVars.NumSymParams = pReturnTypeInfo->nParams;
        parseVars.TypeOptions |= pReturnTypeInfo->Flags;
        parseVars.CurrentSymParam = 0;
        parseVars.Prefix     = &pReturnTypeInfo->SymPrefix[0];
        if (pReturnTypeInfo->Flags & DBG_RETURN_SUBTYPES) {
            parseVars.CopyName = 1;
        }
    }


    if ((Options & DBG_DUMP_ARRAY) && (!parseVars.nElements)) {
    //
    // Default : array dump only a maximum of 20 elements
    //
        parseVars.nElements=20;
    }
    i=0;

    //  
    // Handle cases when given address is not the addres of begining of type
    //
    if (pSym->addr && (Options & (DBG_DUMP_ADDRESS_OF_FIELD | DBG_DUMP_ADDRESS_AT_END))) {
        ULONG64 addr=0;

        if ((Options & DBG_DUMP_ADDRESS_OF_FIELD) && (pSym->listLink))
            // Get address from address of field
            addr = GetTypeAddressFromField(pSym->addr, pSym->sName, pSym->listLink->fName);
        else if (Options & DBG_DUMP_ADDRESS_AT_END)
            // Get address form end of type record
            addr = GetTypeAddressFromField(pSym->addr, pSym->sName, NULL);            

        if (!addr) {
            goto exitDumpType;
        }
        pSym->addr = addr;
    }

    if (pSym->sName) {
        strcpy((PCHAR)LocalName, (PCHAR)pSym->sName);
        pSym->sName = (PUCHAR) &LocalName[0];
    }

    //
    // Check is caller wants the whole type data and this is a primitive type
    //
    if ((Options & DBG_DUMP_COPY_TYPE_DATA) && //(IsAPrimType( parseVars.rootTypeIndex)) &&
        pSym->Context) {
        parseVars.CopyDataInBuffer = TRUE;
        parseVars.TypeDataPointer  = (PUCHAR)pSym->Context;
    }

    pTypeToDump = new DbgDerivedType(&parseVars, pTypeInfo, pSym);

    if (!pTypeToDump) {
        parseVars.ErrorStatus = CANNOT_ALLOCATE_MEMORY;
        goto exitDumpType;
    }
    do { 
        if ((Options & (DBG_DUMP_ARRAY | DBG_DUMP_LIST)) && 
            (pSym->CallbackRoutine || ( pSym->listLink && pSym->listLink->fieldCallBack)) &&
            !(pSym->listLink->fOptions & NO_CALLBACK_REQ)) {
            //
            // Call the routine before each element dump
            //
            PSYM_DUMP_FIELD_CALLBACK_EX Routine=pSym->CallbackRoutine;

            if ( pSym->listLink && pSym->listLink->fieldCallBack) {
                Routine = (PSYM_DUMP_FIELD_CALLBACK_EX) pSym->listLink->fieldCallBack;
            }
            pSym->listLink->address = pSym->addr;

            if ((*Routine)(pSym->listLink, pSym->Context)) {
                // dprintf("List callback successful, exiting.\n");
                if (!res) res = -1;
                break;
            }
        }

        if ((Options & (DBG_DUMP_LIST | DBG_DUMP_ARRAY)) && (pSym->listLink) && (pSym->addr)) {
            parseVars.NextListElement =0;
            
            // Print heading
            if ( pSym->listLink->printName ) {
                typPrint((char *)pSym->listLink->printName);
            } else {
                if (Options & DBG_DUMP_LIST) {
                    typPrint((g_Machine->m_Ptr64 ? "%s at 0x%I64x" : "%s at 0x%x"), pSym->listLink->fName, pSym->addr);
                } else {
                    typPrint("[%d] ", i++);
                    vprintf((g_Machine->m_Ptr64 ? "at 0x%I64x" : "at 0x%x"), pSym->addr);
                }
                if (!(parseVars.TypeOptions & DBG_DUMP_COMPACT_OUT))
                    typPrint( "\n---------------------------------------------\n" );
            }
        }


//        res=ProcessType(&parseVars, parseVars.rootTypeIndex, pSym);
        res=pTypeToDump->DumpType();

        CheckFieldsMatched(&res, &parseVars, pSym);

        if (parseVars.ErrorStatus) {

            res = 0;
            break;
        }

        if (parseVars.TypeOptions & DBG_DUMP_COMPACT_OUT &&
            !(parseVars.TypeOptions & DBG_DUMP_FUNCTION_FORMAT))  typPrint( "\n" );

        if (pSym->addr) {
            if (Options & DBG_DUMP_LIST) {
                pSym->addr = parseVars.NextListElement;
                if (pSym->addr == parseVars.LastListElement) {
                    break;
                }
                if (!(parseVars.TypeOptions & DBG_DUMP_COMPACT_OUT))  typPrint( "\n" );
                // dprintf("Next :%p, Reamaining elts %d, res %d\n", pSym->addr, pParseVars->nElements, res);
            } else if (Options & DBG_DUMP_ARRAY) {
                ULONG TotalElements;
                pSym->addr +=res;
                if (parseVars.nElements) {
                    // Read a large block into cache
                    parseVars.nElements--;
                    if (!ReadInAdvance(pSym->addr, min (parseVars.nElements * res, 1000), parseVars.TypeOptions)) {
                        parseVars.InvalidAddress = pSym->addr;
                        parseVars.ErrorStatus = MEMORY_READ_ERROR;
                    }

                }
                if (!(parseVars.TypeOptions & DBG_DUMP_COMPACT_OUT))  typPrint( "\n" );
            }

            if ((Options & (DBG_DUMP_ARRAY | DBG_DUMP_LIST)) &&
                (g_EngStatus & ENG_STATUS_USER_INTERRUPT)) {
                res=0;
                break;
            }
            parseVars.totalOffset =0;
        }
        if ((parseVars.PtrRead) && (res==4) && pSym->addr) {
            res=8;
        }


        //
        // Loop for dumping lists / array   
        //
    } while ( res && (Options & (DBG_DUMP_ARRAY | DBG_DUMP_LIST)) &&
              pSym->addr && ((Options & DBG_DUMP_LIST) || (parseVars.nElements)));



exitDumpType:
    *pStatus = parseVars.ErrorStatus;
    pSym->sName = saveName;
    if (parseVars.AltFields) {
        FreeMem((PVOID) parseVars.AltFields);
    }
    if (pTypeToDump) {
        delete pTypeToDump;
    }
    if (pReturnTypeInfo) {
        pReturnTypeInfo->nParams = parseVars.CurrentSymParam;

        if (!pReturnTypeInfo->FullInfo.Address && SymRegisterId) {
            // We do not have address of this expression which was in register initially
            // return the register ID.
            pReturnTypeInfo->FullInfo.Register = SymRegisterId;
            pReturnTypeInfo->FullInfo.Flags |= IMAGEHLP_SYMBOL_INFO_REGISTER;
        }

    }
    LastReadError = (parseVars.ErrorStatus == MEMORY_READ_ERROR ? parseVars.InvalidAddress : 0);
    pSym->TypeSize = res;
    pSym->Type = parseVars.PtrRead ? DBG_TYP_POINTER : DBG_TYP_UNKNOWN;
    return (parseVars.ErrorStatus ? 0 : res);
}

/*
// DumpType
//      This dumps the type based on given type info and symbol dump info
//
// pTypeInfo  : Has the type information required to process the type
//
// pSym       : Info on how to dump this symbol
//
// pStatus    : Error status returned here
//
// Return Val : Size of type dumped on success, 0 otherwise.
//
*/
ULONG
DumpType(
    PTYPES_INFO     pTypeInfo,
    PSYM_DUMP_PARAM_EX pSym,
    PULONG          pStatus
    )
{
    return DumpTypeAndReturnInfo(pTypeInfo, pSym, pStatus, NULL);
}

#define ENABLE_FAST_DUMP 1
#if ENABLE_FAST_DUMP

#define FAST_DUMP_DEBUG 0

// We don't want a lot of syms here, although this should be more than number of types
// an extension references on an average
#define NUM_FASTDUMP 10

FAST_DUMP_INFO g_FastDumps[NUM_FASTDUMP]={0};
UCHAR g_FastDumpNames[NUM_FASTDUMP][MAX_NAME];

void
ReleaseFieldInfo(PFIELD_INFO_EX pFlds, ULONG nFlds)
{
    while (nFlds) { 
        --nFlds;
        if (pFlds[nFlds].fName) 
            FreeMem(pFlds[nFlds].fName);
    }
    FreeMem(pFlds);
}

void
ClearAllFastDumps()
{
    for (int i=0; i<NUM_FASTDUMP;i++) { 
        if (g_FastDumps[i].nFields) {
            ReleaseFieldInfo(g_FastDumps[i].Fields, g_FastDumps[i].nFields);
        }
    }
    ZeroMemory(g_FastDumpNames, sizeof(g_FastDumpNames));
    ZeroMemory(g_FastDumps, sizeof(g_FastDumps));
}

ULONG
FindInFastDumpAndCopy(PSYM_DUMP_PARAM_EX pSym)
{
    FAST_DUMP_INFO *pCheckType = NULL;
    PFIELD_INFO_EX  s, d;
    
    // Search the symbol
    ULONG UseSym=0;
    while (UseSym < NUM_FASTDUMP && pSym->sName) { 
        if (!strcmp((char *) &g_FastDumpNames[UseSym][0], (char *) pSym->sName)) {
            pCheckType = &g_FastDumps[UseSym];
            assert(pCheckType->sName == &g_FastDumpNames[UseSym][0]);
            break;
        }
        ++UseSym;
    }

    if (!pCheckType) {
        return FALSE;
    }
    
    if (!pSym->nFields) {
        pSym->TypeSize = pCheckType->TypeSize;
        pSym->Type     = pCheckType->Type;
        if (pSym->Options & DBG_DUMP_COPY_TYPE_DATA) {
            if (!ReadTypeData((PUCHAR) pSym->Context, pSym->addr, pSym->TypeSize, pSym->Options)) {
                return -1;
            }
            if (pSym->Type == DBG_TYP_POINTER && !g_Machine->m_Ptr64) {
                *((PULONG64) pSym->Context) =
                    (ULONG64) (LONG64) (LONG) *((PULONG64) pSym->Context);
                pSym->TypeSize = sizeof(ULONG64); // We copied ULONG64 for 32 bit pointers so set size to 8
            }
        } else if (pSym->addr) { // check if this adress is readable
            ULONG dummy;
            if (!ReadTypeData((PUCHAR) &dummy, pSym->addr, sizeof(dummy), pSym->Options)) {
                return -1;
            }
        }
        return pSym->TypeSize;
    }

    if (!strcmp((char *)pCheckType->sName, (char *) pSym->sName)) {
        for (ULONG findIt=0; 
             pSym->Fields && findIt < pSym->nFields; 
             findIt++) 
        { 
            BOOL found = FALSE;
            for (ULONG chkFld = 0; 
                 pCheckType->Fields && chkFld < pCheckType->nFields; 
                 chkFld++) 
            { 
                if (!strcmp((char *)pCheckType->Fields[chkFld].fName, 
                            (char *)pSym->Fields[findIt].fName)) {

                    // Force sign extension of symbol address on
                    // 32-bit targets to match the behavior of
                    // ReadTypeData.
                    ULONG64 SymAddr = g_Machine->m_Ptr64 ?
                        pSym->addr : EXTEND64(pSym->addr);
                    
                    s = &pCheckType->Fields[chkFld];
                    d = &pSym->Fields[findIt];

#if FAST_DUMP_DEBUG
                    dprintf("Found +%03lx %s %lx, opts %lx, %lx\n", 
                            s->fOffset, s->fName, s->size, d->fOptions, s->fType);
#endif                    
                    //
                    // Copy the required data
                    //
                    d->BitField = s->BitField;
                    d->size = s->size;
                    d->address = s->fOffset + SymAddr;
                    d->fOffset = s->fOffset;
                    if (SymAddr) {
                        PCHAR buff=NULL;
                        ULONG readSz;
                        ULONG64 readAddr = d->address;
                        
                        if (d->fOptions & DBG_DUMP_FIELD_COPY_FIELD_DATA) {
                            buff = (PCHAR) d->fieldCallBack;
                        } else if (!(d->fOptions & DBG_DUMP_FIELD_RETURN_ADDRESS) &&
                                   (s->size <= sizeof(ULONG64))) {
                            buff = (PCHAR) &d->address;
                            d->address = 0;
                        }
                        if (buff) {
                            
                            if (s->fType == DBG_TYP_POINTER && !g_Machine->m_Ptr64) {
                                readSz = (g_Machine->m_Ptr64 ? 8 : 4);
                            } else {
                                readSz = s->size;
                            }

                            if (s->fType == DBG_TYP_BIT) {
                                ULONG64 readBits;
                                ULONG64 bitCopy;
                                
                                readSz = (s->BitField.Position % 8 + s->BitField.Size + 7) /8 ;
                                readAddr += (s->BitField.Position / 8);
                                
                                if (!ReadTypeData((PUCHAR) &readBits, readAddr, readSz, pSym->Options)) {
                                    return -1;
                                }


                                readBits = readBits >> (s->BitField.Position % 8);
                                bitCopy = ((ULONG64) 1 << s->BitField.Size);
                                bitCopy -= (ULONG64) 1; 
                                readBits &= bitCopy;

                                memcpy(buff, &readBits, (s->BitField.Size + 7) /8);

                            } else {
                                if (!ReadTypeData((PUCHAR) buff, readAddr, readSz, pSym->Options)) {
                                    return -1;
                                }
                            }
                            
                            if (s->fType == DBG_TYP_POINTER && !g_Machine->m_Ptr64) {
                                *((PULONG64) buff) = (ULONG64) (LONG64) *((PLONG) buff); 
                            }
                        }
                        if (d->fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS) {
                            d->address = ((SymAddr + s->fOffset) << 3) + s->BitField.Position;
                            d->size    = s->BitField.Size;
                        }

                    } else if (d->fOptions & DBG_DUMP_FIELD_SIZE_IN_BITS) {
                        d->address = ((s->fOffset) << 3) + s->BitField.Position;
                        d->size    = s->BitField.Size;
                    }
                    if (!SymAddr) {
                        if ((d->fOptions & DBG_DUMP_FIELD_COPY_FIELD_DATA) ||
                            (!(d->fOptions & DBG_DUMP_FIELD_RETURN_ADDRESS) &&
                             (s->size <= sizeof(ULONG64)))) {
                            return -1;
                        }
                    }

                    found = TRUE;
                    break;
                }
            }
            if (!found) {
                return FALSE;
            }
        }
#if FAST_DUMP_DEBUG
        dprintf("fast match found \n");
#endif        
        return pCheckType->TypeSize;
    
    }
    return 0;

}

void
AddSymToFastDump(
    PSYM_DUMP_PARAM_EX pSym
    )
{
    FAST_DUMP_INFO *pCheckType = NULL;
    PFIELD_INFO_EX  pMissingFields;
    ULONG           nMissingFields;
    static ULONG    symindx=0;

    // Search the symbol
    ULONG UseSym=0;
    while (UseSym < NUM_FASTDUMP && pSym->sName) { 
        if (!strcmp((char *) &g_FastDumpNames[UseSym][0], (char *) pSym->sName)) {
            pCheckType = &g_FastDumps[UseSym];
            assert(pCheckType->sName == &g_FastDumpNames[UseSym][0]);
            break;
        }
        ++UseSym;
    }
    if (!pCheckType) {
        // Insert 
        if (pSym->Type == DBG_TYP_POINTER) {
            // Make sure we have right size stored with pointers
            // TypeSize was 8 for 32 bit target if pointer was read
            pSym->TypeSize = g_Machine->m_Ptr64 ? 8 : 4;
        }
        pCheckType = &g_FastDumps[symindx];
        *pCheckType = *pSym;
        pCheckType->sName = &g_FastDumpNames[symindx][0];
        strcpy((char *) &g_FastDumpNames[symindx][0],(char *) pSym->sName);
        pCheckType->Fields = NULL;
        pCheckType->nFields = 0;
        symindx = ++symindx % NUM_FASTDUMP;
    }

    pMissingFields = (PFIELD_INFO_EX) AllocateMem(pSym->nFields * sizeof(FIELD_INFO_EX));

    if (!pMissingFields) {
        return ;
    }
    ZeroMemory(pMissingFields, pSym->nFields * sizeof(FIELD_INFO_EX));

    nMissingFields = 0;
    if (!strcmp((char *)pCheckType->sName, (char *) pSym->sName)) {
        for (ULONG findIt=0; 
             pSym->Fields && findIt < pSym->nFields; 
             findIt++) 
        { 
            BOOL found = FALSE;
            for (ULONG chkFld = 0; 
                 pCheckType->Fields && chkFld < pCheckType->nFields; 
                 chkFld++) 
            { 
                if (!strcmp((char *)pCheckType->Fields[chkFld].fName, 
                            (char *)pSym->Fields[findIt].fName)) {
                    found = TRUE;
                    break;
                }
            }
            if (!found) {
                pMissingFields[nMissingFields].fName    = pSym->Fields[findIt].fName;
                pMissingFields[nMissingFields].size     = pSym->Fields[findIt].size;
                pMissingFields[nMissingFields].fOffset  = pSym->Fields[findIt].fOffset;
                pMissingFields[nMissingFields].fType    = pSym->Fields[findIt].fType;
                pMissingFields[nMissingFields].BitField = pSym->Fields[findIt].BitField;
                nMissingFields++;
            }
        }
        if (nMissingFields) {
            PFIELD_INFO_EX newFlds;

            newFlds = (PFIELD_INFO_EX) AllocateMem((pCheckType->nFields + nMissingFields)* sizeof(FIELD_INFO_EX));
            ZeroMemory(newFlds, (pCheckType->nFields + nMissingFields)* sizeof(FIELD_INFO_EX));

            if (!newFlds) {
                FreeMem(pMissingFields);
                return ;
            }
            
            ULONG field;
            for (field = 0; field <nMissingFields;field++) { 
                newFlds[field] = pMissingFields[field];
                newFlds[field].fName = (PUCHAR) AllocateMem(strlen((PCHAR) pMissingFields[field].fName) + 1);
                if (!newFlds[field].fName) {
                    ReleaseFieldInfo(newFlds, field+1);
                    FreeMem(pMissingFields);
                    return ;
                }
                strcpy((PCHAR) newFlds[field].fName, (PCHAR) pMissingFields[field].fName);
#if FAST_DUMP_DEBUG
                dprintf("Adding +%03lx %s %lx\n", 
                        newFlds[field].fOffset, newFlds[field].fName, newFlds[field].size);
#endif      
            }

            if (pCheckType->nFields) {
                memcpy(&newFlds[field], pCheckType->Fields, pCheckType->nFields * sizeof(FIELD_INFO_EX));

                FreeMem(pCheckType->Fields);
            }
            pCheckType->nFields += nMissingFields;
            pCheckType->Fields = newFlds;
        }

    }
    FreeMem(pMissingFields);
}

/*
  A faster way to dump if same type is dump repeatedly - improves performance
  of extensions.
*/
ULONG 
FastSymbolTypeDump(
    PSYM_DUMP_PARAM_EX pSym,
    PULONG pStatus
    )
{
    if (pSym->nFields > 1) {
        return 0;
    }
    if (!(pSym->Options & NO_PRINT) || 
        pSym->listLink ||
        (pSym->Options & (DBG_DUMP_CALL_FOR_EACH | DBG_DUMP_LIST |
                          DBG_DUMP_ARRAY | DBG_DUMP_ADDRESS_OF_FIELD |
                          DBG_DUMP_ADDRESS_AT_END)) ||
        (pSym->Context && !(pSym->Options & DBG_DUMP_COPY_TYPE_DATA))) {
        return 0;
    }
    ULONG fld;
    for (fld = 0; fld<pSym->nFields; fld++) { 
        if ((pSym->Fields[fld].fOptions & (DBG_DUMP_FIELD_ARRAY | DBG_DUMP_FIELD_CALL_BEFORE_PRINT |
                                          DBG_DUMP_FIELD_STRING)) ||
            (!(pSym->Fields[fld].fOptions & DBG_DUMP_FIELD_COPY_FIELD_DATA) &&
             pSym->Fields[fld].fieldCallBack)) {
            return 0;
        }
    }

    // Make sure we have everything in 
    ULONG retval;
    if (!(retval = FindInFastDumpAndCopy(pSym))) {
        if (retval = SymbolTypeDumpNew(pSym, pStatus)) {
            pSym->TypeSize = retval;
            AddSymToFastDump(pSym);
        }
    } else if (retval == -1) {
        // FindInFastDumpAndCopy returns -1 for memory read error 
        retval = 0;
        *pStatus = MEMORY_READ_ERROR;
    } else {
        *pStatus = 0;
    }

    return retval;
}
#endif // ENABLE_FAST_DUMP

//
// Main routine to dunmp types
//      This looks up if the symtype info in available and then dumps the type
//
//      Returns size of the symbol dumped
ULONG
SymbolTypeDumpNew(
    IN OUT PSYM_DUMP_PARAM_EX pSym,
    OUT PULONG pStatus
    )
{
    TYPES_INFO typeInfo = {0};
    CHAR       MatchedName[MAX_NAME];
    ULONG      err;

    typeInfo.Name.Buffer = &MatchedName[0];
    typeInfo.Name.Length = typeInfo.Name.MaximumLength = MAX_NAME;
    
    if (pSym->size != sizeof(SYM_DUMP_PARAM_EX)) {
        if (pStatus) *pStatus = INCORRECT_VERSION_INFO;
        return FALSE;
    }

    if (pSym->Options & (DBG_RETURN_TYPE | DBG_RETURN_SUBTYPES | DBG_RETURN_TYPE_VALUES)) {
        return FALSE;
    }

    if (!(err = TypeInfoFound(
                      g_CurrentProcess->Handle,
                      g_CurrentProcess->ImageHead,
                      pSym,
                      &typeInfo))) {
        if (typeInfo.TypeIndex) {
            return DumpType(&typeInfo, pSym, pStatus);
        }

        err = SYMBOL_TYPE_INFO_NOT_FOUND;
    }

    if (pStatus) {
        *pStatus = err;
    } 

    return FALSE;
}
    
ULONG
SymbolTypeDump(
    IN HANDLE hProcess,
    IN PDEBUG_IMAGE_INFO pImage,
    IN PSYM_DUMP_PARAM   pSym,
    OUT PULONG pStatus)
/*++

Routine Description:
   This returns the size of the type of symbol if successful. This is called
   upon an IOCTL request IG_DUMP_SYMBOL_INFO or by SymBolTypeDumpEx.
   Thislooks up the module information for symbol, and loads module symbols if 
   possible. If pdb symbols are found, it calls ParseTypeRecordEx for type dump from
   the module found.
   This is internal to ntsd module.

Arguments:

    pSym                - Parameters for PDB symbol dump

    pStatus             - Contains the error value on failure.
    
Return Value:
    
    Size of type is successful. 0 otherwise.
    
--*/    
{
    ULONG ret, i;
    PSYM_DUMP_PARAM pSymSave=NULL; 
    SYM_DUMP_PARAM_EX locSym;
    FIELD_INFO_EX lst;
    if (pSym->size == sizeof(SYM_DUMP_PARAM)) {
        pSymSave = (PSYM_DUMP_PARAM) pSym;
        // convert old to new
        memcpy(&locSym, pSymSave, sizeof(SYM_DUMP_PARAM));
        locSym.size = sizeof(SYM_DUMP_PARAM_EX);
        locSym.Fields = locSym.nFields ? 
            (PFIELD_INFO_EX) AllocateMem(locSym.nFields * sizeof(FIELD_INFO_EX)) : NULL;
        if (pSymSave->listLink) {
            locSym.listLink = &lst;
            memcpy(locSym.listLink, pSymSave->listLink, sizeof(FIELD_INFO));
        }
        if (!locSym.Fields && locSym.nFields) {
            *pStatus = CANNOT_ALLOCATE_MEMORY;
            return 0;
        }
        for (i=0; i<locSym.nFields; i++) { 
            memcpy(&locSym.Fields[i], &pSymSave->Fields[i], sizeof(FIELD_INFO));
        }
    }
    *pStatus = 0;
#if ENABLE_FAST_DUMP
    if (!(ret = FastSymbolTypeDump(&locSym, pStatus)))
    {
        if (!*pStatus) 
        {
            ret = SymbolTypeDumpNew(&locSym, pStatus);
        }
    }
#else 
    ret = SymbolTypeDumpNew(&locSym, pStatus);
#endif        
    
    if (pSymSave) {
        if (pSymSave->listLink) {
            locSym.listLink = &lst;
            memcpy(pSymSave->listLink, locSym.listLink, sizeof(FIELD_INFO));
        }
        for (i=0; i<locSym.nFields; i++) { 
            memcpy(&pSymSave->Fields[i], &locSym.Fields[i], sizeof(FIELD_INFO));
        }
        if (locSym.Fields) {
            FreeMem(locSym.Fields);
        }
    }
    return ret;
}

/*++
  This can be used to dump variables of primitive or pointer types. 
  This only dumps a single line info for Name.
  It'll not dump any sub-fields of the variable
--*/
ULONG
DumpSingleValue (
    PSYMBOL_INFO pSymInfo
    )
{
    TYPES_INFO typeInfo = {0};
    CHAR       MatchedName[MAX_NAME];
    ULONG      err;
    SYM_DUMP_PARAM_EX TypedDump = {0};
    ULONG Status=0, Size, cTotalBytesRead;
    DEBUG_SYMBOL_PARAMETERS_INTERNAL Dummy;
    FIND_TYPE_INFO FindInfo={0};

    FindInfo.Flags = DBG_RETURN_TYPE_VALUES | DBG_RETURN_TYPE;
    FindInfo.InternalParams = &Dummy;
    FindInfo.nParams = 1;

    TypedDump.size  = sizeof(SYM_DUMP_PARAM_EX);
    TypedDump.sName = (PUCHAR) pSymInfo->Name;
    TypedDump.Options = NO_PRINT;
    TypedDump.Context = (PVOID) &Dummy;
    typeInfo.Name.Buffer = &MatchedName[0];
    typeInfo.Name.Length = typeInfo.Name.MaximumLength = MAX_NAME;

    if (pSymInfo->TypeIndex) {
        typeInfo.TypeIndex = pSymInfo->TypeIndex;
        typeInfo.ModBaseAddress = pSymInfo->ModBase;
        typeInfo.Flag      = pSymInfo->Flags;
        typeInfo.SymAddress = pSymInfo->Address;
        typeInfo.hProcess  = g_CurrentProcess->Handle;
        TypedDump.addr     = pSymInfo->Address;
        typeInfo.Value     = pSymInfo->Register;
    }

    if (pSymInfo->TypeIndex ||
        !(err = TypeInfoFound(
                      g_CurrentProcess->Handle,
                      g_CurrentProcess->ImageHead,
                      &TypedDump,
                      &typeInfo))) {
        if (typeInfo.TypeIndex && (typeInfo.SymAddress || typeInfo.Flag)) {
            Dummy.TypeIndex = typeInfo.TypeIndex;
            return DumpTypeAndReturnInfo(&typeInfo, &TypedDump, &err, &FindInfo);
        }
        return TRUE;
    }
    return FALSE;
}

BOOL
GetConstantNameAndVal(
    PTYPES_INFO pTypeInfo,
    PCHAR *pName,
    PULONG64 pValue
    )
{
    PWCHAR pWname;
    VARIANT var;
    ULONG len;

    *pName = NULL;
    if (!SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, pTypeInfo->TypeIndex, TI_GET_SYMNAME, (PVOID) &pWname) ||
        !SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, pTypeInfo->TypeIndex, TI_GET_VALUE, (PVOID) &var)) {
        return FALSE;
    }
    
    if (pWname) {
        *pName = UnicodeToAnsi(pWname);
        LocalFree (pWname);
    } else {
        *pName = NULL;
        return FALSE;
    }

    switch (var.vt) { 
    case VT_UI2: 
    case VT_I2:
        *pValue = var.iVal;
        len = 2;
        break;
    case VT_R4:
        *pValue = (ULONG64) var.fltVal;
        len=4;
        break;
    case VT_R8:
        *pValue = (ULONG64) var.dblVal;
        len=8;
        break;
    case VT_BOOL:
        *pValue = var.lVal;
        len=4;
        break;
    case VT_I1:
    case VT_UI1: 
        *pValue = var.bVal;
        len=1;
        break;
    case VT_I8:
    case VT_UI8:
        *pValue = var.ullVal;
        len=8;
        break;
    case VT_UI4:
    case VT_I4:
    case VT_INT:
    case VT_UINT:
    case VT_HRESULT:
        *pValue = var.lVal;
        len=4;
        break;
    default:
//        sprintf(Buffer, "UNIMPLEMENTED %lx %lx", var.vt, var.lVal);
        len=4;
        break;
    }
    return TRUE;
}


BOOL
GetEnumTypeName(
    PTYPES_INFO pTypeInfo,
    PCHAR Name,
    PUSHORT NameLen
    )
{
    ULONG nelements=0;
    // Get the childrens
    if (!SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, pTypeInfo->TypeIndex, TI_GET_CHILDRENCOUNT, (PVOID) &nelements)) {
        return FALSE;
    }
    if (!(pTypeInfo->Flag & IMAGEHLP_SYMBOL_INFO_VALUEPRESENT)) {
        return FALSE;
    }
    TI_FINDCHILDREN_PARAMS *pChildren;

    pChildren = (TI_FINDCHILDREN_PARAMS *) AllocateMem(sizeof(TI_FINDCHILDREN_PARAMS) + sizeof(ULONG) * nelements);
    if (!pChildren) {
        return 0;
    }

    pChildren->Count = nelements;
    pChildren->Start = 0;
    if (!SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, pTypeInfo->TypeIndex, TI_FINDCHILDREN, (PVOID) pChildren)) {
        FreeMem(pChildren);
        return 0;
    }

    for (ULONG i = 0; i< nelements; i++) { 
        PCHAR pName;
        DWORD64 qwVal;
        
        TYPES_INFO ChildTI = *pTypeInfo;
        ChildTI.TypeIndex = pChildren->ChildId[i];
        // Find name and value for a child TI
        GetConstantNameAndVal(&ChildTI, &pName, &qwVal);

        if (pName) {
            // Fill-in name if value matches
            if ((pTypeInfo->Flag & IMAGEHLP_SYMBOL_INFO_VALUEPRESENT) &&
                (pTypeInfo->Value == qwVal)) {
                if (*NameLen > strlen(pName)) {
                    strcpy(Name, pName);
                    *NameLen = strlen(pName)+1;
                    FreeMem(pName);
                    FreeMem(pChildren);
                    return TRUE;
                }
            }
            FreeMem(pName);
        }
    }

    FreeMem(pChildren);
    return FALSE;
}
HRESULT
GetNameFromIndex(
    PTYPES_INFO pTypeInfo,
    PCHAR       Name,
    PUSHORT     NameLen
    )
{
    BSTR    wName= NULL;
    LPSTR   name = NULL;
    ULONG   SymTag;

#define CopyTypeName(n) if (*NameLen > strlen(n)) {strcpy(Name, n);}; *NameLen = strlen(n)+1;
    
    if (!pTypeInfo->TypeIndex) {
        return E_FAIL;
    }
    if (IsDbgNativeType(pTypeInfo->TypeIndex) &&
        NATIVE_TO_BT(pTypeInfo->TypeIndex)) {
        CopyTypeName(g_DbgNativeTypes[pTypeInfo->TypeIndex & ~DBG_NATIVE_TYPE_FLAG].TypeName);
        return S_OK;
    }

    if (!SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, 
                        pTypeInfo->TypeIndex, TI_GET_SYMTAG, (PVOID) &SymTag)) {
        return E_FAIL;
    }
    
    if (!SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, 
                        pTypeInfo->TypeIndex, TI_GET_SYMNAME, (PVOID) &wName)) {
        // vprintf("name not found\n");
    } else if (wName) {
        name = UnicodeToAnsi(wName);
        LocalFree(wName);
    }
    
    
    switch (SymTag) { 
    case SymTagPointerType: {
        ULONG TI = pTypeInfo->TypeIndex;
        TYPES_INFO ChildTI = *pTypeInfo;

        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, 
                           pTypeInfo->TypeIndex, TI_GET_TYPEID, (PVOID) &ChildTI.TypeIndex)) {
        
            *NameLen=*NameLen-1;
            if (GetNameFromIndex(&ChildTI, Name, NameLen) == S_OK) {
                strcat(Name, "*");
            }
            *NameLen=*NameLen+1;
        }
        pTypeInfo->TypeIndex = TI;
        break;
    }
    case SymTagBaseType: {
        //
        // Its a prim type
        //
        ULONG64 length = 0;
        ULONG   base;
        BOOL    found = FALSE;
        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, 
                           pTypeInfo->TypeIndex, TI_GET_BASETYPE, (PVOID) &base)) {
            SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, 
                           pTypeInfo->TypeIndex, TI_GET_LENGTH, &length);
            for (ULONG i=0; i<NUM_DBG_NATIVE_TYPES; i++) {
                if (base == (g_DbgNativeTypes[i].TypeId) &&
                    g_DbgNativeTypes[i].Size == length) {
                    CopyTypeName(g_DbgNativeTypes[i].TypeName);
                    found = TRUE;
                    break;
                }
            }
        } 
        if (!found) {
            CopyTypeName("<primitive>");
        }
        break;

    }
    case SymTagData: {
        ULONG TI = pTypeInfo->TypeIndex;
        TYPES_INFO ChildTI = *pTypeInfo;
        // A variable, TI_GET_SYMNAME just gives us variable name so get type index and fetch type name
        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, TI, TI_GET_TYPEID, &ChildTI.TypeIndex)) {
            
            GetNameFromIndex(&ChildTI, Name, NameLen);
        }
        break;
    }
    case SymTagEnum: {
        // Enum type
        if (!GetEnumTypeName(pTypeInfo, Name, NameLen) &&
            !(pTypeInfo->Flag & IMAGEHLP_SYMBOL_INFO_VALUEPRESENT)) { 
            if (name) {
                CopyTypeName(name);
            }
        }
        break;
    }
    case SymTagFunctionArgType: {
        ULONG TI = pTypeInfo->TypeIndex;
        TYPES_INFO ChildTI = *pTypeInfo;
        // A variable, TI_GET_SYMNAME just gives us variable name so get type index and fetch type name
        if (SymGetTypeInfo(pTypeInfo->hProcess, pTypeInfo->ModBaseAddress, TI, TI_GET_TYPEID, &ChildTI.TypeIndex)) {
            
            GetNameFromIndex(&ChildTI, Name, NameLen);
        }
        break;
    }
    case SymTagFunctionType: {
        CopyTypeName("<function>");        
        break;
    }
    default:
        if (name) {
            CopyTypeName(name);
        }
        break;
    }
#undef CopyTypeName
    
    if (name) {
        FreeMem(name);
    }
    return S_OK;
}

/******************************************************************************
* This gets the type-name for a TYPES_INFO struct
* 
* This routine only needs one of pSymName or pTypeInfo to get the type name.
*
* If both are present, This will take TypeIndex from pTypeInfo and get its name. 
*
******************************************************************************/
HRESULT
GetTypeName(
    IN OPTIONAL PCHAR       pSymName,
    IN OPTIONAL PTYPES_INFO pTypeInfo,
    OUT PANSI_STRING        TypeName
    )
{

    if ((!pTypeInfo && !pSymName) || !TypeName) {
        return E_INVALIDARG;
    }

    TYPES_INFO lTypeInfo;
    CHAR MatchedName[MAX_NAME];

    if (!pTypeInfo) {
        //
        // Get type info for symbol
        //
        SYM_DUMP_PARAM_EX TypedDump = {0};
        ULONG Status=0, Size, cTotalBytesRead;
        TYPES_INFO_ALL allTypeInfo;

        if (GetExpressionTypeInfo(pSymName, &allTypeInfo)) {
            // Copy what we need
            lTypeInfo.Flag = allTypeInfo.Flags;
            lTypeInfo.hProcess = allTypeInfo.hProcess;
            lTypeInfo.ModBaseAddress = allTypeInfo.Module;
            lTypeInfo.TypeIndex      = allTypeInfo.TypeIndex;
            lTypeInfo.Value          = allTypeInfo.Value;
        }
#if 0
        TypedDump.size  = sizeof(SYM_DUMP_PARAM_EX);
        TypedDump.sName = (PUCHAR) TypeName->Buffer;
        TypedDump.Options = NO_PRINT;
        TypedDump.Context = NULL;
        lTypeInfo.Name.Buffer = &MatchedName[0];
        lTypeInfo.Name.Length = lTypeInfo.Name.MaximumLength = MAX_NAME;

        if (TypeInfoFound(g_CurrentProcess->Handle,
                          g_CurrentProcess->ImageHead,
                          &TypedDump,
                          &lTypeInfo)) {
            // FAIL
            return E_FAIL;
        }
#endif        
        pTypeInfo = &lTypeInfo;

    }
    TypeName->Length = TypeName->MaximumLength;
    ZeroMemory(TypeName->Buffer, TypeName->MaximumLength);
    return GetNameFromIndex(pTypeInfo, TypeName->Buffer, &TypeName->Length);

}


ULONG
SymbolTypeDumpEx(
    IN HANDLE hProcess,
    IN PDEBUG_IMAGE_INFO pImage,
    IN LPSTR lpArgString
    ) 
{
#define MAX_FIELDS                   10
    BYTE buff[sizeof(SYM_DUMP_PARAM_EX) + MAX_FIELDS*sizeof(FIELD_INFO_EX)] = {0};
    PSYM_DUMP_PARAM_EX dp= (PSYM_DUMP_PARAM_EX) &(buff[0]);
    FIELD_INFO_EX listLnk={0};
    UCHAR sName[2000]={0}, fieldNames[MAX_FIELDS * 257]={0}, listName[257]={0};
    clock_t stime, etime;
    int i;
    ULONG Options, ErrorStatus;

    exactMatch = TRUE;
    dp->Fields = (PFIELD_INFO_EX) &(buff[sizeof(SYM_DUMP_PARAM_EX)]);
    for (i=0; i<MAX_FIELDS; i++) { 
        dp->Fields[i].fName = &fieldNames[i*257];
    }
    LastReadError = 0;

    listLnk.fName = &listName[0];
    dp->size = sizeof(buff);
    dp->sName = &sName[0];
    dp->listLink = &listLnk;
    dp->nFields = MAX_FIELDS;

    if (!ParseArgumentString(lpArgString, dp)) {
        exactMatch = TRUE;
        return FALSE;
    }
    if (!dp->sName[0] && !dp->addr) {
        exactMatch = TRUE;
        return FALSE;
    }
    Options = dp->Options;

    dp->size = sizeof(SYM_DUMP_PARAM_EX);

    if (dp->sName[strlen((PCHAR) dp->sName)-1] == '*' &&
        !strchr((PCHAR)dp->sName, ' ')) {
        EnumerateTypes((PCHAR) dp->sName, Options);
        return TRUE;
    }

    if (0 & VERBOSE) {
        ANSI_STRING Name = {MAX_NAME, MAX_NAME, (PCHAR) &fieldNames[0]};
        GetTypeName((PCHAR) &sName[0], NULL, &Name);
        
        dprintf("GetTypeName %s := %s\n",sName, fieldNames);
        return 1;
    }
    if (! (i=SymbolTypeDumpNew(dp, &ErrorStatus))) {
        exactMatch = TRUE;
        switch (ErrorStatus) { 
         
        case MEMORY_READ_ERROR:
            typPrint("Memory read error %p\n", LastReadError ? LastReadError : dp->addr);
            break;

        case SYMBOL_TYPE_INDEX_NOT_FOUND: 
        case SYMBOL_TYPE_INFO_NOT_FOUND: 
            // Look in other modules
            typPrint("Symbol %s not found.\n", dp->sName);
            break;

        case FIELDS_DID_NOT_MATCH: 
            typPrint("Cannot find specified field members.\n");
            return FALSE;
        
        default:
            if (CheckUserInterrupt()) {
                typPrint("Exit on Control-C\n");
            } else 
                typPrint("Error %x in dt\n", ErrorStatus);
        }
        return FALSE;
    }
    exactMatch = TRUE;
    if (CheckUserInterrupt()) {
        return FALSE;
    }
    return TRUE;
}

ULONG
fnFieldOffset(
    PCHAR Type,
    PCHAR Field,
    OUT PULONG Offset
    )
{
    SYM_DUMP_PARAM_EX SymDump = {0};
    FIELD_INFO_EX     fInfo = {0};
    ULONG          Status;

    if (!Type || !Field || !Offset) {
        return E_INVALIDARG;
    }
    SymDump.size    = sizeof (SYM_DUMP_PARAM_EX);
    SymDump.sName   = (PUCHAR) Type;
    SymDump.nFields = 1;
    SymDump.Fields  = &fInfo;
    SymDump.Options = NO_PRINT;

    fInfo.fName     = (PUCHAR) Field;
    fInfo.fOptions  = DBG_DUMP_FIELD_RETURN_ADDRESS;

    SymbolTypeDumpNew(&SymDump, &Status);

    *Offset = (ULONG) fInfo.address;

    return Status;
}

#if 0
ULONG
GetExpressiopnTypeInfo(
    IN PCSTR pTypeExpr,
    OUT PGET_ALL_INFO pTypeInfo
    )
{
    return FALSE;
}

ULONG 
GetChildTypeInfo(
    IN PGET_ALL_INFO pParentInfo,
    IN ULONG Count,
    OUT PGET_ALL_INFO pChildInfo
    )
{
    return 0;
}

ULONG
OutputTypeValue(
    IN PGET_ALL_INFO pTypeInfo
    )
{
    return 0;
}

#endif // 0

/*
  Takes in a complex expression like foo[0]->bar or foo.bar and return foo in Name
  If Expr is just a symbol name eg mod!foo, the routine doesn't change Name, but returns TRUE
  
  Returns TRUE on success.
*/
BOOL
CopySymbolName(
    PCHAR Expr,
    PCHAR *Name)
{
    PCHAR NameEnd = Expr;

    if (*NameEnd == '&') {
       ++NameEnd;
    }
    if (IsIdStart(*NameEnd)) {
        BOOL Bang = TRUE;
        ++NameEnd;

        while (IsIdChar(*NameEnd) || (Bang && *NameEnd == '!')) { 
            if (*NameEnd == '!') {
                Bang = FALSE;
                if (*(NameEnd+1) == '&') {
                   ++NameEnd;
                }
            }
            ++NameEnd;
        }

        if (*NameEnd == '[') {
            while (*NameEnd && *NameEnd != ']') ++NameEnd;
            if (*NameEnd != ']') {
                return FALSE;
            }
            ++NameEnd;
        }
        
        if (!*NameEnd) {
            return TRUE;
        }
        
    } else {
        return FALSE;
    }
    
    // arrays structs and pointers
    BOOL Ptr = FALSE;

    switch (*NameEnd) { 
    case '-':
        if (*(NameEnd+1) != '>') {
            return FALSE;
        }
        Ptr = TRUE;
    case '.': {
        ULONG len;
        PCHAR SymName = (PCHAR) AllocateMem(1 + (len = (ULONG) (NameEnd - Expr)));

        if (!SymName) {
            return FALSE;
        }
        strncpy(SymName, Expr, len );
        SymName[len] = 0;
        *Name = SymName;
        return TRUE;
    }
    default:
        return FALSE;
    } /* switch */

    return FALSE;
}

/*
  Evaluate and return all the useful info about types for a complex expression
  
 eg. foo->bar.field
 
*/
BOOL
GetExpressionTypeInfo(
    IN PCHAR TypeExpr,
    OUT PTYPES_INFO_ALL pTypeInfo
    )
{
    PCHAR PtrRef=0;
    
    switch (*TypeExpr) { 
    case '&':
        break;
    case '*':
        PtrRef = TypeExpr;
        do { 
            ++TypeExpr;
        } while (*TypeExpr == '*');
        break;
    case '(':
    default:
        break;
    }

    PCHAR CopiedName=NULL, SymName, FieldName=NULL;

    if (!CopySymbolName(TypeExpr, &CopiedName)) 
        return FALSE;

    SymName = CopiedName ? CopiedName : TypeExpr;
    
    SYM_DUMP_PARAM_EX SymParam = {sizeof(SYM_DUMP_PARAM_EX),0,0};
    FIELD_INFO_EX     FieldInfo ={0};

    if (CopiedName) {
        FieldName = TypeExpr + strlen(CopiedName) + 1;
        if (*FieldName == '>') {
            // pointer
           ++FieldName;
        }
        
        SymParam.nFields = 1;
        SymParam.Fields  = &FieldInfo;

        FieldInfo.fName = (PUCHAR) FieldName;

        FieldInfo.fOptions = DBG_DUMP_FIELD_RETURN_ADDRESS;
    }
    
    SymParam.sName = (PUCHAR) (SymName ? SymName : TypeExpr);
    ULONG err;
    TYPES_INFO     SymType={0};
    CHAR           Buffer[MAX_NAME];

    SymParam.Options = NO_PRINT;
    SymType.Name.Buffer = &Buffer[0];
    SymType.Name.MaximumLength = MAX_NAME;

    if (!TypeInfoFound(g_CurrentProcess->Handle, g_CurrentProcess->ImageHead,
                      &SymParam, &SymType)) {
        DEBUG_SYMBOL_PARAMETERS_INTERNAL DbgInfo={0};
        FIND_TYPE_INFO FindInfo={0};
        ULONG i=0;

        while (PtrRef && (*PtrRef == '*' || *PtrRef == '&') && (i<sizeof(FindInfo.SymPrefix))) { 
            FindInfo.SymPrefix[i++] = *PtrRef;
            PtrRef++;
        }
        FindInfo.SymPrefix[i] = 0;

        pTypeInfo->hProcess = SymType.hProcess;
        if (!SymParam.nFields) {
            pTypeInfo->Register = (ULONG) SymType.Value;
            pTypeInfo->Flags    = SymType.Flag;
        }

        FindInfo.Flags = SymParam.nFields ? 0 :DBG_RETURN_TYPE;
        FindInfo.nParams = 1;
        FindInfo.InternalParams = &DbgInfo;
        
        DbgInfo.TypeIndex = SymType.TypeIndex;
        DbgInfo.Address   = SymType.SymAddress;
        DbgInfo.Flags     = SymType.Flag;

        DumpTypeAndReturnInfo(&SymType, &SymParam, &err, &FindInfo);
        ZeroMemory(pTypeInfo, sizeof(*pTypeInfo));
        FindInfo.FullInfo.hProcess = SymType.hProcess;
        FindInfo.FullInfo.Module   = SymType.ModBaseAddress;


//        dprintf64("FindInfo\n\tTI %2lx,\tAddr %p, \tSize %2lx\n\tSubs %2lx,\tSubaddr %p\tMod %p\n",
//                  FindInfo.FullInfo.TypeIndex, FindInfo.FullInfo.Address,
//                  FindInfo.FullInfo.Size, FindInfo.FullInfo.SubElements,
//                  FindInfo.FullInfo.SubAddr, FindInfo.FullInfo.Module);
        if (!err) {
            *pTypeInfo = FindInfo.FullInfo;
        }
    } else {
        err = TRUE;
    }
    if (CopiedName) {
        FreeMem(CopiedName);
    }
    return !err;
}

typedef struct _PARAM_TO_SHOW {
    ULONG StartParam;
    ULONG ParamId;
} PARAM_TO_SHOW;

BOOL 
CALLBACK 
ShowParam(
    PSYMBOL_INFO    pSymInfo,
    ULONG           Size,
    PVOID           Context
    )
{
    PARAM_TO_SHOW *ParamTest = (PARAM_TO_SHOW *) Context;

    // Assume parameters are enumerated first
#if _WE_GET_INFO_FROM_DIA_SAYING_WHAT_IS_PARAM_ 
    if (!((g_EffMachine == IMAGE_FILE_MACHINE_I386) && 
          (0 <= (LONG) pSymInfo->Address) && 
          (0x1000 > (LONG) pSymInfo->Address) && 
          (pSymInfo->Flags & SYMF_REGREL)) &&
        (!(pSymInfo->Flags & IMAGEHLP_SYMBOL_INFO_PARAMETER))
        ) {
        return TRUE;
    }
#endif

    if (!strcmp("this", pSymInfo->Name)) {
        // Its implicit parameter, do not display
        return TRUE;
    }
    if (ParamTest->ParamId == ParamTest->StartParam) {
        dprintf("%s = ", pSymInfo->Name);
        DumpSingleValue(pSymInfo);
        return FALSE;
    }
    ParamTest->StartParam++;
    return TRUE;
}

void 
PrintParamValue(ULONG Param)
{
    PARAM_TO_SHOW ParamTest;

    ParamTest.StartParam = 0;
    ParamTest.ParamId = Param;
    EnumerateLocals(ShowParam, &ParamTest);
}


/*
   Check if the symbol is a function or not
 */
BOOL 
IsFunctionSymbol(PSYMBOL_INFO pSymInfo)
{
    ULONG SymTag;
    
    if (!pSymInfo->TypeIndex) {
        return FALSE;
    }

    if (!SymGetTypeInfo(g_CurrentProcess->Handle, pSymInfo->ModBase,
                       pSymInfo->TypeIndex, TI_GET_SYMTAG, &SymTag)) {
        return FALSE;
    }
    switch (SymTag) { 
    case SymTagFunctionType: {
        return TRUE;
        break;
    }
    case SymTagData: {
        SYMBOL_INFO ChildTI = *pSymInfo;
        // A variable, get type index 
        if (SymGetTypeInfo(g_CurrentProcess->Handle, pSymInfo->ModBase, pSymInfo->TypeIndex, TI_GET_TYPEID, &ChildTI.TypeIndex)) {
            return IsFunctionSymbol(&ChildTI);
        }
        break;
    }
    default:
        break;
    }
    
    return FALSE;

}

BOOL
ShowSymbolInfo(
    PSYMBOL_INFO   pSymInfo
    )
{
    ULONG SymTag;
    
    if (!pSymInfo->TypeIndex) {
        return FALSE;
    }

    if (!SymGetTypeInfo(g_CurrentProcess->Handle, pSymInfo->ModBase,
                       pSymInfo->TypeIndex, TI_GET_SYMTAG, &SymTag)) {
        return FALSE;
    }
    switch (SymTag) { 
    case SymTagFunctionType: {
        SYM_DUMP_PARAM_EX SymFunction = {0};
        ULONG Status = 0;
        TYPES_INFO TypeInfo = {0};

        TypeInfo.hProcess = g_CurrentProcess->Handle;
        TypeInfo.ModBaseAddress = pSymInfo->ModBase;
        TypeInfo.TypeIndex = pSymInfo->TypeIndex;
        TypeInfo.SymAddress = pSymInfo->Address;
        SymFunction.size = sizeof(SYM_DUMP_PARAM_EX);
        SymFunction.addr = pSymInfo->Address;
        SymFunction.Options = DBG_DUMP_COMPACT_OUT | DBG_DUMP_FUNCTION_FORMAT;
        if (!DumpType(&TypeInfo, &SymFunction, &Status) &&
            !Status) {
            return FALSE;
        }
#if 0
        ULONG thisAdjust;

        if (SymGetTypeInfo(g_CurrentProcess->Handle, pSymInfo->ModBase, 
                           pSymInfo->TypeIndex, TI_GET_THISADJUST, &thisAdjust)) {
            dprintf("thisadjust = %lx", thisAdjust);
        }
#endif        
        return TRUE;
        break;
    }
    case SymTagData: {
        SYMBOL_INFO ChildTI = *pSymInfo;
        // A variable, TI_GET_SYMNAME just gives us variable name so get type index and fetch type name
        if (SymGetTypeInfo(g_CurrentProcess->Handle, pSymInfo->ModBase, pSymInfo->TypeIndex, TI_GET_TYPEID, &ChildTI.TypeIndex)) {
            return ShowSymbolInfo(&ChildTI);
        }
        break;
    }
    default:
        break;
    }
    
    dprintf(" = ");
    return DumpSingleValue(pSymInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\util.h ===
//----------------------------------------------------------------------------
//
// General utility functions.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

extern PCSTR   g_DefaultLogFileName;
extern char    g_OpenLogFileName[];
extern BOOL    g_OpenLogFileAppended;
extern int     g_LogFile;
extern BOOL    g_DisableErrorPrint;

ULONG CheckUserInterrupt(void);

LONG MappingExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);

void RemoveDelChar(PSTR pBuffer);

ULONGLONG HexValue(ULONG);

void HexList(PUCHAR, ULONG *, ULONG);
void AsciiList(PSTR, ULONG *);

#define STRV_SPACE_IS_SEPARATOR          0x00000001
#define STRV_TRIM_TRAILING_SPACE         0x00000002
#define STRV_ALLOW_ESCAPED_CHARACTERS    0x00000004
#define STRV_COMPRESS_ESCAPED_CHARACTERS 0x00000008

#define STRV_ESCAPED_CHARACTERS \
    (STRV_ALLOW_ESCAPED_CHARACTERS | STRV_COMPRESS_ESCAPED_CHARACTERS)

PSTR BufferStringValue(PSTR* Buf, ULONG Flags, PCHAR Save);
PSTR StringValue(ULONG Flags, PCHAR Save);
void CompressEscapes(PSTR Str);

void DECLSPEC_NORETURN ReportError(ULONG Code, PCSTR* Desc);
#define error(Code) ReportError(Code, NULL)

void OpenLogFile(PCSTR File, BOOL Append);
void fnLogOpen(BOOL Append);
void fnLogClose(void);
void lprintf(PCSTR Str);

PSTR PrepareImagePath(PSTR ImagePath);

CHAR* AddImage(PMODULE_INFO_ENTRY ModEntry, BOOL ForceSymbolLoad);

void
DelImage(
    PPROCESS_INFO pProcess,
    PDEBUG_IMAGE_INFO pImage
    );

BOOL DelImageByName(PPROCESS_INFO Process, PCSTR Name, INAME Which);
BOOL DelImageByBase(PPROCESS_INFO pProcess, ULONG64 Base);
void DelImages(PPROCESS_INFO Process);

#define SYMADDR_FORCE  0x00000001
#define SYMADDR_LABEL  0x00000002
#define SYMADDR_SOURCE 0x00000004

void
OutputSymAddr(
    ULONG64 Offset,
    ULONG Flags
    );

void
OutputLineAddr(
    ULONG64 Offset,
    PCSTR Format
    );

LPSTR
FormatMachineAddr64(
    MachineInfo* Machine,
    ULONG64 Addr
    );
#define FormatAddr64(Addr) FormatMachineAddr64(g_TargetMachine, Addr)

LPSTR
FormatDisp64(
    ULONG64 addr
    );

//
// Output that can be displayed about the current register set.
//

void OutCurInfo(ULONG Flags, ULONG AllMask, ULONG RegMask);

// Items displayed if the flag is given.

// Display symbol nearest PC.
#define OCI_SYMBOL              0x00000001
// Display disassembly at PC.
#define OCI_DISASM              0x00000002

// Items which may be displayed if the flag is given.  Other global
// settings ultimately control whether information is displayed or not;
// these flags indicate whether such output is allowed or not.  Each
// of these flags also has a FORCE bit to force display regardless of
// the global settings.

// Allow registers to be displayed.
#define OCI_ALLOW_REG           0x00000004
// Allow display of source code and/or source line.
#define OCI_ALLOW_SOURCE        0x00000008
// Allow EA memory to be displayed during disasm.
#define OCI_ALLOW_EA            0x00000010

// Force all output to be shown regardless of global settings.
#define OCI_FORCE_ALL           0x80000000
// Force display of registers.
#define OCI_FORCE_REG           0x40000000
// Force source output.
#define OCI_FORCE_SOURCE        0x20000000
// Force display of EA memory during disasm.
#define OCI_FORCE_EA            0x10000000
// Don't check for running state.
#define OCI_IGNORE_STATE        0x08000000


BOOL
__inline
ConvertQwordsToDwords(
    PULONG64 Qwords,
    PULONG Dwords,
    ULONG Count
    )
{
    BOOL rval = TRUE;
    while (Count--) {
        rval = rval && (*Qwords >> 32) == 0;
        *Dwords++ = (ULONG)*Qwords++;
    }
    return rval;
}

DWORD
NetworkPathCheck(
    LPCSTR PathList
    );

#define ALL_ID_LIST 0xffffffff

ULONG GetIdList (void);
HRESULT ChangePath(PSTR* Path, PCSTR New, BOOL Append, ULONG SymNotify);
PSTR FindPathElement(PSTR Path, ULONG Element, PSTR* EltEnd);
void CheckPath(PCSTR Path);
HRESULT ChangeString(PSTR* Str, PULONG StrLen, PCSTR New);

BOOL LoadExecutableImageMemory(PDEBUG_IMAGE_INFO Image);
BOOL UnloadExecutableImageMemory(PDEBUG_IMAGE_INFO Image);

void
ExceptionRecordTo64(PEXCEPTION_RECORD Rec,
                    PEXCEPTION_RECORD64 Rec64);
void
ExceptionRecord64To(PEXCEPTION_RECORD64 Rec64,
                    PEXCEPTION_RECORD Rec);
void
MemoryBasicInformationTo64(PMEMORY_BASIC_INFORMATION Mbi,
                           PMEMORY_BASIC_INFORMATION64 Mbi64);
void
MemoryBasicInformation32To64(PMEMORY_BASIC_INFORMATION32 Mbi32,
                             PMEMORY_BASIC_INFORMATION64 Mbi64);
void
DebugEvent32To64(LPDEBUG_EVENT32 Event32,
                 LPDEBUG_EVENT64 Event64);

LPSTR
TimeToStr(ULONG TimeDateStamp);

PCSTR PathTail(PCSTR Path);
BOOL MatchPathTails(PCSTR Path1, PCSTR Path2);

#endif // #ifndef _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\vdm.h ===
//----------------------------------------------------------------------------
//
// vdm.h
//
// VDM debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _VDM_H_
#define _VDM_H_

#if 0
BOOL fVDMInitDone;
BOOL fVDMActive;
VDMPROCESSEXCEPTIONPROC pfnVDMProcessException;
VDMGETTHREADSELECTORENTRYPROC pfnVDMGetThreadSelectorEntry;
VDMGETPOINTERPROC pfnVDMGetPointer;
VDMGETCONTEXTPROC pfnVDMGetContext;
VDMSETCONTEXTPROC pfnVDMSetContext;
VDMGETSELECTORMODULEPROC pfnVDMGetSelectorModule;
#endif

typedef struct _segentry {
    int     type;
    LPSTR   path_name;
    WORD    selector;
    WORD    segment;
    DWORD   ImgLen;    // MODLOAD only
} SEGENTRY;

extern SEGENTRY segtable[];

ULONG VDMEvent(DEBUG_EVENT64* Event);
#define VDMEVENT_HANDLED STATUS_VDM_EVENT
#define VDMEVENT_NOT_HANDLED 0 

#endif // #ifndef _VDM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ntsd64\vdm.cpp ===
//----------------------------------------------------------------------------
//
// VDM debugging support.
//
// Copyright (C) Microsoft Corporation, 1997-2001.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

BOOL fVDMInitDone;
BOOL fVDMActive;
VDMPROCESSEXCEPTIONPROC pfnVDMProcessException;
VDMGETTHREADSELECTORENTRYPROC pfnVDMGetThreadSelectorEntry;
VDMGETPOINTERPROC pfnVDMGetPointer;
VDMGETCONTEXTPROC pfnVDMGetContext;
VDMSETCONTEXTPROC pfnVDMSetContext;
VDMGETSELECTORMODULEPROC pfnVDMGetSelectorModule;

#define SEGTYPE_AVAILABLE   0
#define SEGTYPE_V86         1
#define SEGTYPE_PROT        2

#define MAXSEGENTRY 1024

SEGENTRY segtable[MAXSEGENTRY];



VOID VDMRegCmd(
    LPSTR achInput,
    X86_NT5_CONTEXT *pvc
    )
{
    DWORD dwVal;

    if ( _stricmp(achInput,"rp") == 0 )
    {
        g_X86Machine.OutputAll(g_X86Machine.m_AllMask,
                               DEBUG_OUTPUT_NORMAL);
        return;
    }

    if (achInput[1] != 'e') {
        dprintf("VDM R: can only operate on 32-bit registers\n");
        return;
    }

    if (strlen(achInput) < 6) {
        dprintf("VDM R: Missing value\n");
        return;
    }

    dwVal = strtoul(&achInput[5], NULL, 16);

    if ( _strnicmp(&achInput[2],"ax", 2) == 0 ) {
        pvc->Eax = dwVal;
    } else if ( _strnicmp(&achInput[2],"bx", 2) == 0 ) {
        pvc->Ebx = dwVal;
    } else if ( _strnicmp(&achInput[2],"cx", 2) == 0 ) {
        pvc->Ecx = dwVal;
    } else if ( _strnicmp(&achInput[2],"dx", 2) == 0 ) {
        pvc->Edx = dwVal;
    } else if ( _strnicmp(&achInput[2],"si", 2) == 0 ) {
        pvc->Esi = dwVal;
    } else if ( _strnicmp(&achInput[2],"di", 2) == 0 ) {
        pvc->Edi = dwVal;
    } else if ( _strnicmp(&achInput[2],"ip", 2) == 0 ) {
        pvc->Eip = dwVal;
    } else if ( _strnicmp(&achInput[2],"sp", 2) == 0 ) {
        pvc->Esp = dwVal;
    } else if ( _strnicmp(&achInput[2],"bp", 2) == 0 ) {
        pvc->Ebp = dwVal;
    } else if ( _strnicmp(&achInput[2],"fl", 2) == 0 ) {
        pvc->EFlags = dwVal;
    } else {
        dprintf("Invalid register\n");
        return;
    }

    dprintf("%.8X will be flushed to '%3.3s'. Use 'rp' to display pending values\n",
            dwVal,
            &achInput[1]);
}

void
DebugEvent64To(LPDEBUG_EVENT64 Event64,
               LPDEBUG_EVENT Event)
{
    Event->dwDebugEventCode = Event64->dwDebugEventCode;
    Event->dwProcessId = Event64->dwProcessId;
    Event->dwThreadId = Event64->dwThreadId;
    
    switch(Event64->dwDebugEventCode)
    {
    case EXCEPTION_DEBUG_EVENT:
        ExceptionRecord64To(&Event64->u.Exception.ExceptionRecord,
                            &Event->u.Exception.ExceptionRecord);
        Event->u.Exception.dwFirstChance =
            Event64->u.Exception.dwFirstChance;
        break;
        
    case CREATE_THREAD_DEBUG_EVENT:
        Event->u.CreateThread.hThread =
            (PVOID)(ULONG_PTR)(Event64->u.CreateThread.hThread);
        Event->u.CreateThread.lpThreadLocalBase =
            (PVOID)(ULONG_PTR)(Event64->u.CreateThread.lpThreadLocalBase);
        Event->u.CreateThread.lpStartAddress =
            (LPTHREAD_START_ROUTINE)(ULONG_PTR)(Event64->u.CreateThread.lpStartAddress);
        break;
        
    case CREATE_PROCESS_DEBUG_EVENT:
        Event->u.CreateProcessInfo.hFile =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.hFile);
        Event->u.CreateProcessInfo.hProcess =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.hProcess);
        Event->u.CreateProcessInfo.hThread =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.hThread);
        Event->u.CreateProcessInfo.lpBaseOfImage =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.lpBaseOfImage);
        Event->u.CreateProcessInfo.dwDebugInfoFileOffset =
            Event64->u.CreateProcessInfo.dwDebugInfoFileOffset;
        Event->u.CreateProcessInfo.nDebugInfoSize =
            Event64->u.CreateProcessInfo.nDebugInfoSize;
        Event->u.CreateProcessInfo.lpThreadLocalBase =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.lpThreadLocalBase);
        Event->u.CreateProcessInfo.lpStartAddress =
            (LPTHREAD_START_ROUTINE)(ULONG_PTR)(Event64->u.CreateProcessInfo.lpStartAddress);
        Event->u.CreateProcessInfo.lpImageName =
            (PVOID)(ULONG_PTR)(Event64->u.CreateProcessInfo.lpImageName);
        Event->u.CreateProcessInfo.fUnicode =
            Event64->u.CreateProcessInfo.fUnicode;
        break;
        
    case EXIT_THREAD_DEBUG_EVENT:
        Event->u.ExitThread.dwExitCode =
            Event64->u.ExitThread.dwExitCode;
        break;
        
    case EXIT_PROCESS_DEBUG_EVENT:
        Event->u.ExitProcess.dwExitCode =
            Event64->u.ExitProcess.dwExitCode;
        break;
        
    case LOAD_DLL_DEBUG_EVENT:
        Event->u.LoadDll.hFile =
            (PVOID)(ULONG_PTR)(Event64->u.LoadDll.hFile);
        Event->u.LoadDll.lpBaseOfDll =
            (PVOID)(ULONG_PTR)(Event64->u.LoadDll.lpBaseOfDll);
        Event->u.LoadDll.dwDebugInfoFileOffset =
            Event64->u.LoadDll.dwDebugInfoFileOffset;
        Event->u.LoadDll.nDebugInfoSize =
            Event64->u.LoadDll.nDebugInfoSize;
        Event->u.LoadDll.lpImageName =
            (PVOID)(ULONG_PTR)(Event64->u.LoadDll.lpImageName);
        Event->u.LoadDll.fUnicode =
            Event64->u.LoadDll.fUnicode;
        break;
        
    case UNLOAD_DLL_DEBUG_EVENT:
        Event->u.UnloadDll.lpBaseOfDll =
            (PVOID)(ULONG_PTR)(Event64->u.UnloadDll.lpBaseOfDll);
        break;
        
    case OUTPUT_DEBUG_STRING_EVENT:
        Event->u.DebugString.lpDebugStringData =
            (LPSTR)(ULONG_PTR)(Event64->u.DebugString.lpDebugStringData);
        Event->u.DebugString.fUnicode =
            Event64->u.DebugString.fUnicode;
        Event->u.DebugString.nDebugStringLength =
            Event64->u.DebugString.nDebugStringLength;
        break;
        
    case RIP_EVENT:
        Event->u.RipInfo.dwError =
            Event64->u.RipInfo.dwError;
        Event->u.RipInfo.dwType =
            Event64->u.RipInfo.dwType;
        break;
    }
}

ULONG
VDMEvent(DEBUG_EVENT64* pDebugEvent)
/*

    returns - 0, if exception not handled
              STATUS_VDM_EVENT, if exception handled
              otherwise, the return value is the translated event status,
              for example STATUS_BREAKPOINT

 */
{
    LPSTR           Str;
    LPSTR           pFileName;
    BOOL            b;
    ULONG           lpNumberOfBytesRead;
    UINT_PTR        address;
    PULONG_PTR      lpdw;
    int             segslot;
    int             mode;
    BOOL            fData;
    WORD            selector;
    WORD            segment;
    WORD            newselect;
    BOOL            fStop;
    DWORD           ImgLen;
    ULONG           ulRet;
    BOOL            fNeedSegTableEdit;
    BOOL            fNeedInteractive;
    BOOL            fVerbose;
    CHAR            achInput[_MAX_PATH];
    PSTR            pTemp;
    BOOL            fProcess;
    SEGMENT_NOTE    se;
    IMAGE_NOTE      im;
    BOOL            bProtectMode;
    WORD            EventFlags;

    ulRet = VDMEVENT_HANDLED;

    if (!fVDMInitDone) {
        fVDMInitDone = TRUE;

        HINSTANCE hmodVDM = NULL;
		const char* c_szVDMFailed = NULL;

        fVDMActive = (
            (hmodVDM = LoadLibrary("VDMDBG.DLL")) &&
            (pfnVDMProcessException = (VDMPROCESSEXCEPTIONPROC)
                GetProcAddress(hmodVDM, c_szVDMFailed = "VDMProcessException")
            ) &&
            (pfnVDMGetPointer = (VDMGETPOINTERPROC)
                GetProcAddress(hmodVDM, c_szVDMFailed = "VDMGetPointer")
            ) &&
            (pfnVDMGetThreadSelectorEntry = (VDMGETTHREADSELECTORENTRYPROC)
                GetProcAddress(hmodVDM, c_szVDMFailed = "VDMGetThreadSelectorEntry")
            ) &&
            (pfnVDMGetContext = (VDMGETCONTEXTPROC)
                GetProcAddress(hmodVDM, c_szVDMFailed = "VDMGetContext")
            ) &&
            (pfnVDMSetContext = (VDMSETCONTEXTPROC)
                GetProcAddress( hmodVDM, c_szVDMFailed = "VDMSetContext")
            ) &&
            (pfnVDMGetSelectorModule = (VDMGETSELECTORMODULEPROC)
                GetProcAddress( hmodVDM, c_szVDMFailed = "VDMGetSelectorModule")
            )
        ); // fVDMActive

		if (!fVDMActive) {  // display error on first time...
			if (!hmodVDM) {
				dprintf("LoadLibrary(VDMDBG.DLL) failed\n");
			}
			else if (c_szVDMFailed && *c_szVDMFailed) { // is valid printable string
				dprintf("%s can not be found in VDMDBG.DLL\n", c_szVDMFailed);
			}
			else {
				dprintf("Unknown failure while initializing VDMDBG.DLL\n");
			} // iff
		} // if
    } // if

    if (!fVDMActive) return VDMEVENT_NOT_HANDLED;

    DEBUG_EVENT Event;
    DebugEvent64To(pDebugEvent, &Event);
    lpdw = &(Event.u.Exception.ExceptionRecord.ExceptionInformation[0]);
    
    fProcess = (*pfnVDMProcessException)(&Event);

    fNeedSegTableEdit = FALSE;
    fNeedInteractive = FALSE;
    fVerbose = FALSE;

    mode = LOWORD(lpdw[0]);
    EventFlags = HIWORD(lpdw[0]);

    bProtectMode = (BOOL) (EventFlags & VDMEVENT_PE);

    // Has the caller explicitly asked for interaction?
    if (EventFlags & VDMEVENT_NEEDS_INTERACTIVE) {
        fNeedInteractive = TRUE;
    }
    if (EventFlags & VDMEVENT_VERBOSE) {
        fVerbose = TRUE;
    }

    switch( mode ) {
        case DBG_SEGLOAD:
        case DBG_SEGMOVE:
        case DBG_SEGFREE:
        case DBG_MODLOAD:
        case DBG_MODFREE:
            address = lpdw[2];

            b = g_Target->ReadVirtual(EXTEND64(address),
                                      &se, sizeof(se),
                                      &lpNumberOfBytesRead ) == S_OK;
            if ( !b || lpNumberOfBytesRead != sizeof(se) ) {
                return( VDMEVENT_NOT_HANDLED );
            }
            break;
        case DBG_DLLSTART:
        case DBG_DLLSTOP:
        case DBG_TASKSTART:
        case DBG_TASKSTOP:
            address = lpdw[2];

            b = g_Target->ReadVirtual(EXTEND64(address),
                                      &im, sizeof(im),
                                      &lpNumberOfBytesRead ) == S_OK;
            if ( !b || lpNumberOfBytesRead != sizeof(im) ) {
                return( VDMEVENT_NOT_HANDLED );
            }
            break;
    }

    switch( mode ) {
        default:
            ulRet = VDMEVENT_NOT_HANDLED;
            break;

        case DBG_SEGLOAD:
            fNeedSegTableEdit = TRUE;

            selector = se.Selector1;
            segment  = se.Segment;
            fData    = (BOOL)se.Type;

            segslot = 0;
            while ( segslot < MAXSEGENTRY ) {
                if ( segtable[segslot].type != SEGTYPE_AVAILABLE ) {
                    if ( _stricmp(segtable[segslot].path_name, se.FileName) == 0 ) {
                        break;
                    }
                }
                segslot++;
            }

            if ( segslot == MAXSEGENTRY ) {
                if ( strlen(se.FileName) != 0 ) {
                    dprintf("Loading [%s]\n", se.FileName );
                }
            }

            if (fVerbose) {
                dprintf("VDM SegLoad: %s(%d) %s => %x\n",
                                        se.FileName,
                                        segment,
                                        fData ? "Data" : "Code",
                                        selector);
            }
            break;

        case DBG_SEGMOVE:
            fNeedSegTableEdit = TRUE;
            segment = se.Segment;
            selector  = se.Selector1;
            newselect = se.Selector2;
            if ( newselect == 0 ) {
                mode = DBG_SEGFREE;
            } else if (segment > 1) {
                //
                // real mode module is getting split up into different
                // segments, so create a new segtable entry
                //
                segslot = 0;
                while ( segslot < MAXSEGENTRY ) {
                    if (( segtable[segslot].type != SEGTYPE_AVAILABLE ) &&
                        ( segtable[segslot].selector == selector )) {
                        mode = DBG_MODLOAD;
                        segment--;          //make it zero-based
                        selector = newselect;
                        pFileName = segtable[segslot].path_name;
                        // Don't have the image length here so
                        // just choose one.
                        ImgLen = segtable[segslot].ImgLen;
                        break;
                    }
                    segslot++;
                }
            }

            if (fVerbose) {
                dprintf("VDM SegMove: (%d) %x => %x\n",
                                        segment, selector, newselect);
            }
            break;

        case DBG_SEGFREE:
            fNeedSegTableEdit = TRUE;
            selector = se.Selector1;
            if (fVerbose) {
                dprintf("VDM SegFree: %x\n",selector);
            }
            break;

        case DBG_MODFREE:
            fNeedSegTableEdit = TRUE;

            if ( strlen(se.FileName) != 0 ) {
                dprintf("Freeing [%s]\n", se.FileName );
            } else if (fVerbose) {
                dprintf("VDM ModFree: unknown module\n");
            }
            break;

        case DBG_MODLOAD:
            fNeedSegTableEdit = TRUE;
            selector = se.Selector1;
            ImgLen   = se.Length;
            segment = 0;
            pFileName = se.FileName;

            segslot = 0;
            while ( segslot < MAXSEGENTRY ) {
                if ( segtable[segslot].type != SEGTYPE_AVAILABLE ) {
                    if ( _stricmp(segtable[segslot].path_name, se.FileName) == 0 ) {
                        break;
                    }
                }
                segslot++;
            }
            if ( segslot == MAXSEGENTRY ) {
                if ( strlen(se.FileName) != 0 ) {
                    dprintf("Loading [%s]\n", se.FileName );
                }
            }
            if (fVerbose) {
                dprintf("VDM ModLoad: %s => %x, len=%x\n",
                                        se.FileName,
                                        selector,
                                        ImgLen);
            }
            break;

        case DBG_SINGLESTEP:
            if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386) {
                fNeedInteractive = FALSE;
                ulRet = STATUS_SINGLE_STEP;
            } else {
                fNeedInteractive = TRUE;
            }
            break;

        case DBG_BREAK:
            if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386) {
                fNeedInteractive = FALSE;
                ulRet = STATUS_BREAKPOINT;
            } else {
                fNeedInteractive = TRUE;
            }
            break;

        case DBG_GPFAULT:
            dprintf(" GP Fault in VDM\n");
            if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386) {
                fNeedInteractive = FALSE;
                ulRet = STATUS_ACCESS_VIOLATION;
            } else {
                fNeedInteractive = TRUE;
            }
            break;
        case DBG_GPFAULT2:
            dprintf("GP Fault in VDM\n");
            dprintf("!!! second chance !!!\n");
            fNeedInteractive = TRUE;
            break;

        case DBG_INSTRFAULT:
            dprintf("invalid opcode fault in VDM\n");
            fNeedInteractive = TRUE;
            break;

        case DBG_DIVOVERFLOW:
            dprintf("divide overflow in VDM\n");
            fNeedInteractive = TRUE;
            break;

        case DBG_STACKFAULT:
            dprintf("stack fault in VDM\n");
            if (g_TargetMachineType == IMAGE_FILE_MACHINE_I386) {
                fNeedInteractive = FALSE;
                ulRet = STATUS_ACCESS_VIOLATION;
            } else {
                fNeedInteractive = TRUE;
            }
            break;
        case DBG_TASKSTART:
            if ( fNeedInteractive || fVerbose ) {
                dprintf("VDM Start Task <%s:%s>\n",
                        im.Module,
                        im.FileName );
            }
            break;
        case DBG_DLLSTART:
            if ( fNeedInteractive || fVerbose ) {
                dprintf("VDM Start Dll <%s:%s>\n", im.Module, im.FileName );
            }
            break;
        case DBG_TASKSTOP:
            fNeedInteractive = FALSE;
            break;
        case DBG_DLLSTOP:
            fNeedInteractive = FALSE;
            break;
    }

    /*
    ** Temporary code to emulate a 16-bit debugger.  Eventually I will make
    ** NTSD understand these events and call ProcessStateChange to allow
    ** real 16-bit debugging and other activities on the other 32-bit threads.
    ** -BobDay
    */
    if ( fNeedInteractive ) {
        char    text[MAX_DISASM_LEN];
        char    path[128];
        UINT    cSeg;
        ADDR    addr;
        X86_NT5_CONTEXT  vc;

        g_X86Machine.m_Context.X86Nt5Context.ContextFlags = VDMCONTEXT_FULL;

        (*pfnVDMGetContext)(g_EventProcess->Handle, OS_HANDLE(g_EventThread->Handle),
                            (LPVDMCONTEXT)&g_X86Machine.m_Context);

        g_X86Machine.m_Context.X86Nt5Context.EFlags &= ~V86FLAGS_TRACE;
        vc = g_X86Machine.m_Context.X86Nt5Context;

        // Dump a simulated context
        g_X86Machine.OutputAll(g_X86Machine.m_AllMask,
                               DEBUG_OUTPUT_PROMPT_REGISTERS);
        b = (*pfnVDMGetSelectorModule)(g_EventProcess->Handle, OS_HANDLE(g_EventThread->Handle),
                (WORD)g_X86Machine.m_Context.X86Nt5Context.SegCs, &cSeg, text, 128, path, 128 );

        if ( b ) {
            dprintf("%s:%d!%04x:\n", text, cSeg, (WORD)g_X86Machine.m_Context.X86Nt5Context.Eip );
        }
        addr.seg = (WORD)g_X86Machine.m_Context.X86Nt5Context.SegCs;
        addr.off = g_X86Machine.m_Context.X86Nt5Context.Eip;
        if ( !bProtectMode ) {
            addr.type = ADDR_V86 | FLAT_COMPUTED;
            addr.flat = (*pfnVDMGetPointer)(
                            g_EventProcess->Handle,
                            OS_HANDLE(g_EventThread->Handle),
                            addr.seg,
                            (ULONG)addr.off,
                            FALSE
                            );
        } else {
            addr.type = ADDR_16 | FLAT_COMPUTED;
            addr.flat = (*pfnVDMGetPointer)(
                            g_EventProcess->Handle,
                            OS_HANDLE(g_EventThread->Handle),
                            addr.seg,
                            (ULONG)addr.off,
                            TRUE
                            );
        }

        if ( Flat(addr) == 0 ) {
            dprintf("Unable to disassemble failing code\n");
        } else {
            g_X86Machine.Disassemble( &addr, text, TRUE );
            dprintf("%s", text );
        }

        AddExtensionDll("vdmexts", TRUE, NULL);

        while ( TRUE ) {
            GetInput("VDM>", achInput, sizeof(achInput));

            if ( _stricmp(achInput,"gh") == 0 || _stricmp(achInput,"g") == 0 ) {
                ulRet = VDMEVENT_HANDLED;
                break;
            }
            if ( _stricmp(achInput,"gn") == 0 ) {
                ulRet = VDMEVENT_NOT_HANDLED;
                break;
            }
            if ( _stricmp(achInput, "t") == 0 ) {
                ulRet = VDMEVENT_HANDLED;
                vc.EFlags |= V86FLAGS_TRACE;
                break;
            }

            if ((achInput[0] == 'r') && (_stricmp(achInput, "r") != 0)) {
                VDMRegCmd(achInput, &vc);
                g_X86Machine.m_Context.X86Nt5Context = vc;
                continue;
            }

            if (achInput[0] == '!') {
                fnBangCmd(NULL, &achInput[1], &pTemp, FALSE);
                continue;
            }

            if (achInput[0] == '.') {
                g_CurCmd = &achInput[1];
                g_CommandStart = g_CurCmd;
                ProcessCommandsAndCatch(NULL);
                continue;
            }

            if ( _stricmp(achInput,"?") == 0 ) {
                dprintf("\n---------- NTVDM Monitor Help ------------\n\n");
                dprintf("g            - Go\n");
                dprintf("gh           - Go : Exception handled\n");
                dprintf("gn           - Go : Exception not handled\n");
                dprintf("help         - Display extension help\n");
                dprintf("r<reg> <val> - reg=[eax|ebx|ecx|edx|eip|esp|ebp|efl]\n");
                dprintf("rp           - display pending register set\n");
                dprintf("t            - Trace 1 instruction\n");
                dprintf("!<cmd>       - Execute extension command\n");
                dprintf(".<cmd>       - Execute native NTSD command\n");
                dprintf("\nAnything else is interpreted as a VDMEXTS extension command\n\n");
                continue;
            }

            fnBangCmd(NULL, achInput, &pTemp, FALSE);

        }
        g_X86Machine.m_Context.X86Nt5Context = vc;
        (*pfnVDMSetContext)(g_EventProcess->Handle, OS_HANDLE(g_EventThread->Handle),
                            (LPVDMCONTEXT)&g_X86Machine.m_Context);
    }
    /*
    ** End of temporary code
    */

    if ( fNeedSegTableEdit ) {
        segslot = 0;
        fStop = FALSE;
        while ( segslot < MAXSEGENTRY ) {
            switch( mode ) {
                case DBG_SEGLOAD:
                    if ( segtable[segslot].type == SEGTYPE_AVAILABLE ) {
                        segtable[segslot].segment = segment;
                        segtable[segslot].selector = selector;
                        // This notification message is used only by wow in prot
                        // It could be determined from the current mode to be
                        // correct
                        segtable[segslot].type = SEGTYPE_PROT;
                        Str = (PSTR)calloc(1,strlen(se.FileName)+1);
                        if ( !Str ) {
                            return( VDMEVENT_NOT_HANDLED );
                        }
                        strcpy( Str, se.FileName );
                        segtable[segslot].path_name = Str;
                        segtable[segslot].ImgLen = 0;
                        fStop = TRUE;
                    }
                    break;
                case DBG_SEGMOVE:
                    if (( segtable[segslot].type != SEGTYPE_AVAILABLE ) &&
                        ( segtable[segslot].selector == selector )) {
                        segtable[segslot].selector = newselect;
                        fStop = TRUE;
                    }
                    break;
                case DBG_SEGFREE:
                    if ( segtable[segslot].selector == selector ) {
                        fStop = TRUE;
                        segtable[segslot].type = SEGTYPE_AVAILABLE;
                        free(segtable[segslot].path_name);
                        segtable[segslot].path_name = NULL;
                    }
                    break;
                case DBG_MODFREE:
                    if ( segtable[segslot].type != SEGTYPE_AVAILABLE ) {
                        if ( _stricmp(segtable[segslot].path_name,se.FileName) == 0 ) {
                            segtable[segslot].type = SEGTYPE_AVAILABLE;
                            free(segtable[segslot].path_name);
                            segtable[segslot].path_name = NULL;
                        }
                    }
                    break;
                case DBG_MODLOAD:
                    if ( segtable[segslot].type == SEGTYPE_AVAILABLE ) {
                        segtable[segslot].segment  = segment;
                        segtable[segslot].selector = selector;
                        // This notification message is used only by v86 dos
                        // It could be determined from the current mode to be
                        // correct
                        segtable[segslot].type = SEGTYPE_V86;
                        Str = (PSTR)calloc(1,strlen(pFileName)+1);
                        if ( !Str ) {
                            return( VDMEVENT_NOT_HANDLED );
                        }
                        strcpy( Str, pFileName );
                        segtable[segslot].path_name = Str;
                        segtable[segslot].ImgLen = ImgLen;
                        fStop = TRUE;
                    }
                    break;

            }
            if ( fStop ) {
                break;
            }
            segslot++;
        }
        if ( segslot == MAXSEGENTRY ) {
            if ( mode == DBG_SEGLOAD ) {
                dprintf("Warning - adding selector %04X for segment %d, segtable full\n",
                         selector, segment );
            }
        }
    }

    pDebugEvent->u.Exception.ExceptionRecord.ExceptionCode = ulRet;

    return( ulRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\published\makefile.inc ===
$O\imagehlp.h: imagehlp.x minidump.x makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    imagehlp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

Revision History:

--*/

#ifndef _IMAGEHLP_
#define _IMAGEHLP_

#if _MSC_VER > 1020
#pragma once
#endif

<<
    hextract -o $@ -xt hide_line -lt show_imagehlp -bt begin_imagehlp end_imagehlp imagehlp.x minidump.x
    type << >> $@

#endif // _IMAGEHLP_
<<

# dbghelp.h

$O\dbghelp.h: imagehlp.x minidump.x makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    dbghelp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#ifndef _DBGHELP_
#define _DBGHELP_

#if _MSC_VER > 1020
#pragma once
#endif

<<
    hextract -o $@ -xt hide_line -lt show_dbghelp -bt begin_dbghelp end_dbghelp imagehlp.x minidump.x
    type << >> $@

#endif // _DBGHELP_
<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\adp_ext\dbgexts.cpp ===
//----------------------------------------------------------------------------
//
// Generic routines and initialization code.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "dbgexts.h"

PDEBUG_CLIENT2         g_ExtClient;
PDEBUG_CONTROL2        g_ExtControl;
PDEBUG_DATA_SPACES2    g_ExtData;
PDEBUG_REGISTERS       g_ExtRegisters;
PDEBUG_SYMBOLS2        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS2 g_ExtSystem;

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugClient2),
                                         (void **)&g_ExtClient)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugControl2),
                                         (void **)&g_ExtControl)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                         (void **)&g_ExtData)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                         (void **)&g_ExtSymbols)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugSystemObjects2),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        ExtRelease();
        return Status;
    }

    return S_OK;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    EXT_RELEASE(g_ExtClient);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

void
ExtExec(PCSTR Command)
{
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, Command,
                          DEBUG_EXECUTE_DEFAULT);
}

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\adp_ext\adp_ext.cpp ===
//----------------------------------------------------------------------------
//
// AutoDump Plus support extension DLL.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "dbgexts.h"

#define STATUS_CPP_EH_EXCEPTION 0xe06d7363

#define MAX_NAME 64
#define MAX_MACHINE 64
#define MAX_COMMENT 256

char g_BaseDir[MAX_PATH];
char g_Machine[MAX_MACHINE];

struct PARAM
{
    ULONG Len;
    PSTR Buf;
};

PARAM g_DirMachParams[2] =
{
    sizeof(g_BaseDir), g_BaseDir,
    sizeof(g_Machine), g_Machine,
};

union LAST_EVENT_INFO_ALL
{
    DEBUG_LAST_EVENT_INFO_BREAKPOINT Breakpoint;
    DEBUG_LAST_EVENT_INFO_EXCEPTION Exception;
    DEBUG_LAST_EVENT_INFO_EXIT_THREAD ExitThread;
    DEBUG_LAST_EVENT_INFO_EXIT_PROCESS ExitProcess;
    DEBUG_LAST_EVENT_INFO_LOAD_MODULE LoadModule;
    DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE UnloadModule;
    DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR SystemError;
};

ULONG g_LastEventType;
LAST_EVENT_INFO_ALL g_LastEventInfo;
PSTR g_LastExName;
char g_UnknownExceptionName[64];
PSTR g_LastExChanceStr;

ULONG g_ProcessId;
char g_ProcessName[MAX_NAME];

struct EXCEPTION_NAME
{
    PSTR Name;
    ULONG Code;
};

EXCEPTION_NAME g_ExceptionNames[] =
{
    "Access Violation", STATUS_ACCESS_VIOLATION,
    "C++ EH Exception", STATUS_CPP_EH_EXCEPTION,
    "Invalid Handle Exception", STATUS_INVALID_HANDLE,
    "Stack Overflow", STATUS_STACK_OVERFLOW,
    NULL, 0,
};

PCSTR
GetParams(PCSTR Args, ULONG Count, PARAM* Params)
{
    PCSTR Start;
    ULONG Len;
    ULONG Index = 0;
    
    while (Count-- > 0)
    {
        while (*Args == ' ' || *Args == '\t')
        {
            Args++;
        }
        Start = Args;
        while (*Args && *Args != ' ' && *Args != '\t')
        {
            Args++;
        }
        Len = (ULONG)(Args - Start);
        if ((Count > 0 && !*Args) || Len >= Params[Index].Len)
        {
            ExtErr("Invalid extension command arguments\n");
            return NULL;
        }
        memcpy(Params[Index].Buf, Start, Len);
        Params[Index].Buf[Len] = 0;

        Index++;
    }

    return Args;
}

HRESULT
GetProcessInfo(void)
{
    HRESULT Status;
    
    if ((Status = g_ExtSystem->
         GetCurrentProcessSystemId(&g_ProcessId)) != S_OK)
    {
        ExtErr("Unable to get current process ID\n");
        return Status;
    }
    
    if (FAILED(g_ExtClient->
               GetRunningProcessDescription(0, g_ProcessId,
                                            DEBUG_PROC_DESC_NO_PATHS,
                                            NULL, 0, NULL,
                                            g_ProcessName, MAX_NAME,
                                            NULL)))
    {
        g_ProcessName[0] = 0;
    }
    else
    {
        PSTR Scan;
        
        // Use the MTS package name as the name if it exists.
        Scan = strstr(g_ProcessName, "MTS Packages: ");
        if (Scan)
        {
            PSTR Start;
            ULONG Len;
            
            Scan += 14;
            Start = Scan;

            Scan = strchr(Start, ',');
            if (!Scan)
            {
                Scan = strchr(Start, ' ');
            }
            if (Scan)
            {
                *Scan = 0;
            }

            Len = strlen(Start) + 1;
            if (Len > 2)
            {
                memmove(g_ProcessName, Start, Len);
            }
            else
            {
                g_ProcessName[0] = 0;
            }
        }
        else
        {
            g_ProcessName[0] = 0;
        }
    }

    if (!g_ProcessName[0])
    {
        if (FAILED(g_ExtSystem->
                   GetCurrentProcessExecutableName(g_ProcessName, MAX_NAME,
                                                   NULL)))
        {
            // This can happen in some situations so handle it
            // rather than exiting.
            ExtErr("Unable to get current process name\n");
            strcpy(g_ProcessName, "UnknownProcess");
        }
    }

    return S_OK;
}

HRESULT
GetEventInfo(void)
{
    HRESULT Status;
    ULONG ProcessId, ThreadId;
    
    if ((Status = g_ExtControl->
         GetLastEventInformation(&g_LastEventType, &ProcessId, &ThreadId,
                                 &g_LastEventInfo, sizeof(g_LastEventInfo),
                                 NULL, NULL, 0, NULL)) != S_OK)
    {
        ExtErr("Unable to get event information\n");
        return Status;
    }
    
    if ((Status = GetProcessInfo()) != S_OK)
    {
        return Status;
    }

    switch(g_LastEventType)
    {
    case DEBUG_EVENT_EXCEPTION:
        {
            EXCEPTION_NAME* ExName = g_ExceptionNames;

            while (ExName->Name != NULL)
            {
                if (ExName->Code == g_LastEventInfo.Exception.
                    ExceptionRecord.ExceptionCode)
                {
                    break;
                }

                ExName++;
            }

            if (ExName->Name != NULL)
            {
                g_LastExName = ExName->Name;
            }
            else
            {
                sprintf(g_UnknownExceptionName, "Unknown Exception (%08X)",
                        g_LastEventInfo.Exception.
                        ExceptionRecord.ExceptionCode);
                g_LastExName = g_UnknownExceptionName;
            }

            if (g_LastEventInfo.Exception.FirstChance)
            {
                g_LastExChanceStr = "First";
            }
            else
            {
                g_LastExChanceStr = "Second";
            }
        }
        break;
    }
    
    return S_OK;
}

void
SanitizeFileName(PSTR FileName)
{
    while (*FileName)
    {
        switch(*FileName)
        {
        case ' ':
        case '\t':
        case '\n':
        case '\r':
            *FileName = '_';
            break;

        case '\\':
        case '/':
        case ':':
            *FileName = '-';
            break;
        }
        
        FileName++;
    }
}

void
GetDumpPath(PSTR NameQual, PSTR TypeStr, PSTR Path)
{
    SYSTEMTIME Time;
    PSTR FilePart;

    GetLocalTime(&Time);

    strcpy(Path, g_BaseDir);
    FilePart = Path + strlen(Path) - 1;
    if (*FilePart != '/' && *FilePart != '\\')
    {
        *++FilePart = '\\';
    }
    FilePart++;
    
    sprintf(FilePart,
            "PID-%d__%s__Date_%02d-%02d-%04d__Time_%02d-%02d-%02d__%s__%s.dmp",
            g_ProcessId,
            g_ProcessName,
            Time.wMonth,
            Time.wDay,
            Time.wYear,
            Time.wHour,
            Time.wMinute,
            Time.wSecond,
            NameQual,
            TypeStr);

    SanitizeFileName(FilePart);
}
            
void
WriteDump(PSTR NameQual, PSTR Comment,
          ULONG DumpQual, ULONG DumpFormat, PSTR TypeStr)
{
    char Path[MAX_PATH];
    
    sprintf(Comment + strlen(Comment),
            " - %s dump from %s",
            TypeStr, g_Machine);
    GetDumpPath(NameQual, TypeStr, Path);

    g_ExtClient->WriteDumpFile2(Path, DumpQual, DumpFormat, Comment);
}

extern "C" HRESULT
AdpEventControlC(PDEBUG_CLIENT Client, PCSTR Args)
{
    char Comment[MAX_COMMENT];
    
    INIT_API();

    //
    // Parameters: directory, machine name.
    //

    Args = GetParams(Args, 2, g_DirMachParams);
    if (Args == NULL)
    {
        goto Exit;
    }

    //
    // Retrieve standard information.
    //

    if ((Status = GetEventInfo()) != S_OK)
    {
        goto Exit;
    }
    
    //
    // Log information.
    //
    
    ExtOut("\n\n----------------------------------------------------------------------\n");
    ExtOut("CTRL-C was pressed to stop debugging this process!\n");
    ExtOut("----------------------------------------------------------------------\n");
    ExtOut("Exiting the debugger at:\n");
    ExtExec(".time");
    ExtOut("\n\n--- Listing all thread stacks: ---\n");
    ExtExec("~*kb250");
    ExtOut("\n--- Listing loaded modules: ---\n");
    ExtExec("lmv");
    ExtOut("\n--- Modules with matching symbols:\n");
    ExtExec("lml");
    ExtOut("\n--- Listing all locks: ---\n");
    ExtExec("!locks");

    //
    // Create a dump file.
    //
    
    strcpy(Comment, "CTRL-C was pressed to stop the debugger while running in crash mode");
    WriteDump("CTRL-C", Comment,
              DEBUG_DUMP_SMALL, DEBUG_FORMAT_DEFAULT, "mini");

 Exit:
    EXIT_API();
    return Status;
}

extern "C" HRESULT
AdpEventException(PDEBUG_CLIENT Client, PCSTR Args)
{
    char Comment[MAX_COMMENT];
    char Qual[MAX_COMMENT];
    ULONG Format;
    PSTR TypeStr;
    
    INIT_API();

    //
    // Parameters: directory, machine name.
    //

    Args = GetParams(Args, 2, g_DirMachParams);
    if (Args == NULL)
    {
        goto Exit;
    }

    //
    // Retrieve standard information.
    //

    if ((Status = GetEventInfo()) != S_OK)
    {
        goto Exit;
    }
    
    if (g_LastEventType != DEBUG_EVENT_EXCEPTION)
    {
        ExtErr("Last event was not an exception\n");
        goto Exit;
    }

    if (g_LastEventInfo.Exception.FirstChance)
    {
        Format = DEBUG_FORMAT_DEFAULT;
        TypeStr = "mini";
    }
    else
    {
        Format = DEBUG_FORMAT_USER_SMALL_FULL_MEMORY |
            DEBUG_FORMAT_USER_SMALL_HANDLE_DATA;
        TypeStr = "mini full handle";
    }
    
    //
    // Log information.
    //
    
    ExtOut("\n---- %s-chance %s - Exception stack below ----\n",
           g_LastExChanceStr, g_LastExName);
    ExtExec(".time");
    ExtOut("\n");
    ExtExec("kvn250");
    ExtOut("-----------------------------------\n");

    //
    // Create a dump file.
    //
    
    sprintf(Comment, "%s-chance %s in %s",
            g_LastExChanceStr, g_LastExName, g_ProcessName);
    sprintf(Qual, "%s-chance %s", g_LastExChanceStr, g_LastExName);

    WriteDump(Qual, Comment, DEBUG_DUMP_SMALL, Format, TypeStr);

    ExtOut("\n\n");
    
 Exit:
    EXIT_API();
    return Status;
}

extern "C" HRESULT
AdpEventExitProcess(PDEBUG_CLIENT Client, PCSTR Args)
{
    INIT_API();

    UNREFERENCED_PARAMETER(Args);
    
    //
    // Log information.
    //
    
    ExtOut("\n\n----------------------------------------------------------------------\n");
    ExtOut("This process is shutting down!\n");
    ExtOut("\nThis can happen for the following reasons:\n");
    ExtOut("1.) Someone killed the process with Task Manager or the kill command.\n");
    ExtOut("\n2.) If this process is an MTS or COM+ server package, it could be\n");
    ExtOut("*   exiting because an MTS/COM+ server package idle limit was reached.\n");
    ExtOut("\n3.) If this process is an MTS or COM+ server package,\n");
    ExtOut("*   someone may have shutdown the package via the MTS Explorer or\n");
    ExtOut("*   Component Services MMC snap-in.\n");
    ExtOut("\n4.) If this process is an MTS or COM+ server package,\n");
    ExtOut("*   MTS or COM+ could be shutting down the process because an internal\n");
    ExtOut("*   error was detected in the process (MTS/COM+ fail fast condition).\n");
    ExtOut("----------------------------------------------------------------------\n");
    ExtOut("\nThe process was shut down at:\n");
    ExtExec(".time");
    ExtOut("\n\n");

    EXIT_API();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\rtlist\rtlist.cpp ===
//----------------------------------------------------------------------------
//
// Simple process list through the debug engine interface
// process enumeration methods.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <dbgeng.h>

PDEBUG_CLIENT g_Client;
PSTR g_ProcName;

void DECLSPEC_NORETURN
Panic(HRESULT Status, char* Format, ...)
{
    va_list Args;

    fprintf(stderr, "Error 0x%08X: ", Status);
    va_start(Args, Format);
    vfprintf(stderr, Format, Args);
    va_end(Args);

    exit(1);
}

void DECLSPEC_NORETURN
UsageExit(void)
{
    printf("Usage: rtlist <Options>\n");
    printf("Options are:\n");
    printf("    -premote <Options> - Connect to process server\n");
    printf("    -pn <Name>         - Look for process name\n");

    exit(2);
}

#define MAX_IDS 16384

void
List(ULONG64 Server)
{
    HRESULT Status;
    ULONG Ids[MAX_IDS];
    ULONG IdCount;
    ULONG i;

    if (g_ProcName != NULL)
    {
        if ((Status = g_Client->
             GetRunningProcessSystemIdByExecutableName
             (Server, g_ProcName, DEBUG_GET_PROC_ONLY_MATCH, &Ids[0])) != S_OK)
        {
            Panic(Status, "GetRunningProcessSystemIdByExecutableName\n");
        }

        IdCount = 1;
    }
    else
    {
        if ((Status = g_Client->
             GetRunningProcessSystemIds(Server, Ids, MAX_IDS,
                                        &IdCount)) != S_OK)
        {
            Panic(Status, "GetRunningProcessSystemIds\n");
        }

        if (IdCount > MAX_IDS)
        {
            fprintf(stderr, "Process list missing %d processes\n",
                    IdCount - MAX_IDS);
            IdCount = MAX_IDS;
        }
    }

    for (i = 0; i < IdCount; i++)
    {
        char ExeName[MAX_PATH];

        if ((Status = g_Client->
             GetRunningProcessDescription(Server, Ids[i],
                                          DEBUG_PROC_DESC_DEFAULT,
                                          ExeName, sizeof(ExeName), NULL,
                                          NULL, 0, NULL)) != S_OK)
        {
            sprintf(ExeName, "Error 0x%08X", Status);
        }

        if (Ids[i] >= 0x80000000)
        {
            printf("0x%x %s\n", Ids[i], ExeName);
        }
        else
        {
            printf("0n%d %s\n", Ids[i], ExeName);
        }
    }
}

void __cdecl
main(int Argc, char** Argv)
{
    HRESULT Status;

    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&g_Client)) != S_OK)
    {
        Panic(Status, "DebugCreate\n");
    }

    BOOL Usage = FALSE;
    ULONG64 Server = 0;
    
    while (--Argc > 0)
    {
        Argv++;

        if (!strcmp(*Argv, "-premote"))
        {
            if (Argc < 2 || Server != 0)
            {
                Usage = TRUE;
            }
            else
            {
                Argc--;
                Argv++;
                
                if ((Status = g_Client->
                     ConnectProcessServer(*Argv, &Server)) != S_OK)
                {
                    Panic(Status, "ConnectProcessServer\n");
                }
            }
        }
        else if (!strcmp(*Argv, "-pn"))
        {
            if (Argc < 2)
            {
                Usage = 2;
            }
            else
            {
                Argc--;
                Argv++;
                g_ProcName = *Argv;
            }
        }
        else
        {
            Usage = TRUE;
            break;
        }
    }

    if (Usage)
    {
        UsageExit();
    }

    List(Server);
    
    if (Server != 0)
    {
        g_Client->DisconnectProcessServer(Server);
    }
    g_Client->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\adp_ext\dbgexts.h ===
//----------------------------------------------------------------------------
//
// Generic routines and initialization code.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __DBGEXTS_H__
#define __DBGEXTS_H__

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define EXIT_API ExtRelease

// Global variables initialized by query.
extern PDEBUG_CLIENT2         g_ExtClient;
extern PDEBUG_CONTROL2        g_ExtControl;
extern PDEBUG_DATA_SPACES2    g_ExtData;
extern PDEBUG_REGISTERS       g_ExtRegisters;
extern PDEBUG_SYMBOLS2        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS2 g_ExtSystem;

HRESULT ExtQuery(PDEBUG_CLIENT Client);
void ExtRelease(void);

void __cdecl ExtOut(PCSTR Format, ...);
void __cdecl ExtErr(PCSTR Format, ...);
void ExtExec(PCSTR Command);
    
#ifdef __cplusplus
}
#endif

#endif // #ifndef __DBGEXTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\dumpstk\dumpstk.cpp ===
//----------------------------------------------------------------------------
//
// Simple example of how to open a dump file and get its stack.
//
// This is not a debugger extension.  It is a tool that can be used to replace
// the debugger.
//
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#include <dbgeng.h>

#include "out.hpp"

PSTR g_DumpFile;
PSTR g_ImagePath;
PSTR g_SymbolPath;

ULONG64 g_TraceFrom[3];

IDebugClient* g_Client;
IDebugControl* g_Control;
IDebugSymbols* g_Symbols;

void
Exit(int Code, PCSTR Format, ...)
{
    // Clean up any resources.
    if (g_Symbols != NULL)
    {
        g_Symbols->Release();
    }
    if (g_Control != NULL)
    {
        g_Control->Release();
    }
    if (g_Client != NULL)
    {
        //
        // Request a simple end to any current session.
        // This may or may not do anything but it isn't
        // harmful to call it.
        //

        // We don't want to see any output from the shutdown.
        g_Client->SetOutputCallbacks(NULL);
        
        g_Client->EndSession(DEBUG_END_PASSIVE);
        
        g_Client->Release();
    }

    // Output an error message if given.
    if (Format != NULL)
    {
        va_list Args;

        va_start(Args, Format);
        vfprintf(stderr, Format, Args);
        va_end(Args);
    }
    
    exit(Code);
}

void
CreateInterfaces(void)
{
    HRESULT Status;

    // Start things off by getting an initial interface from
    // the engine.  This can be any engine interface but is
    // generally IDebugClient as the client interface is
    // where sessions are started.
    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&g_Client)) != S_OK)
    {
        Exit(1, "DebugCreate failed, 0x%X\n", Status);
    }

    // Query for some other interfaces that we'll need.
    if ((Status = g_Client->QueryInterface(__uuidof(IDebugControl),
                                           (void**)&g_Control)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugSymbols),
                                           (void**)&g_Symbols)) != S_OK)
    {
        Exit(1, "QueryInterface failed, 0x%X\n", Status);
    }
}

void
ParseCommandLine(int Argc, char** Argv)
{
    int i;
    
    while (--Argc > 0)
    {
        Argv++;

        if (!strcmp(*Argv, "-a32"))
        {
            if (Argc < 4)
            {
                Exit(1, "-a32 missing arguments\n");
            }

            for (i = 0; i < 3; i++)
            {
                int Addr;
                
                Argv++;
                Argc--;

                sscanf(*Argv, "%i", &Addr);
                g_TraceFrom[i] = (ULONG64)(LONG64)(LONG)Addr;
            }
        }
        else if (!strcmp(*Argv, "-a64"))
        {
            if (Argc < 4)
            {
                Exit(1, "-a64 missing arguments\n");
            }

            for (i = 0; i < 3; i++)
            {
                Argv++;
                Argc--;

                sscanf(*Argv, "%I64i", &g_TraceFrom[i]);
            }
        }
        else if (!strcmp(*Argv, "-i"))
        {
            if (Argc < 2)
            {
                Exit(1, "-i missing argument\n");
            }

            Argv++;
            Argc--;

            g_ImagePath = *Argv;
        }
        else if (!strcmp(*Argv, "-y"))
        {
            if (Argc < 2)
            {
                Exit(1, "-y missing argument\n");
            }

            Argv++;
            Argc--;

            g_SymbolPath = *Argv;
        }
        else if (!strcmp(*Argv, "-z"))
        {
            if (Argc < 2)
            {
                Exit(1, "-z missing argument\n");
            }

            Argv++;
            Argc--;

            g_DumpFile = *Argv;
        }
        else
        {
            Exit(1, "Unknown command line argument '%s'\n", *Argv);
        }
    }

    if (g_DumpFile == NULL)
    {
        Exit(1, "No dump file specified, use -z <file>\n");
    }
}

void
ApplyCommandLineArguments(void)
{
    HRESULT Status;

    // Install output callbacks so we get any output that the
    // later calls produce.
    if ((Status = g_Client->SetOutputCallbacks(&g_OutputCb)) != S_OK)
    {
        Exit(1, "SetOutputCallbacks failed, 0x%X\n", Status);
    }

    if (g_ImagePath != NULL)
    {
        if ((Status = g_Symbols->SetImagePath(g_ImagePath)) != S_OK)
        {
            Exit(1, "SetImagePath failed, 0x%X\n", Status);
        }
    }
    if (g_SymbolPath != NULL)
    {
        if ((Status = g_Symbols->SetSymbolPath(g_SymbolPath)) != S_OK)
        {
            Exit(1, "SetSymbolPath failed, 0x%X\n", Status);
        }
    }

    // Everything's set up so open the dump file.
    if ((Status = g_Client->OpenDumpFile(g_DumpFile)) != S_OK)
    {
        Exit(1, "OpenDumpFile failed, 0x%X\n", Status);
    }

    // Finish initialization by waiting for the event that
    // caused the dump.  This will return immediately as the
    // dump file is considered to be at its event.
    if ((Status = g_Control->WaitForEvent(DEBUG_WAIT_DEFAULT,
                                          INFINITE)) != S_OK)
    {
        Exit(1, "WaitForEvent failed, 0x%X\n", Status);
    }

    // Everything is now initialized and we can make any
    // queries we want.
}

void
DumpStack(void)
{
    HRESULT Status;
    PDEBUG_STACK_FRAME Frames = NULL;
    int Count = 50;

    printf("\nFirst %d frames of the call stack:\n", Count);

    if (g_TraceFrom[0] || g_TraceFrom[1] || g_TraceFrom[2])
    {
        ULONG Filled;
        
        Frames = new DEBUG_STACK_FRAME[Count];
        if (Frames == NULL)
        {
            Exit(1, "Unable to allocate stack frames\n");
        }
        
        if ((Status = g_Control->
             GetStackTrace(g_TraceFrom[0], g_TraceFrom[1], g_TraceFrom[2],
                           Frames, Count, &Filled)) != S_OK)
        {
            Exit(1, "GetStackTrace failed, 0x%X\n", Status);
        }

        Count = Filled;
    }
                           
    // Print the call stack.
    if ((Status = g_Control->
         OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS, Frames,
                          Count, DEBUG_STACK_SOURCE_LINE |
                          DEBUG_STACK_FRAME_ADDRESSES |
                          DEBUG_STACK_COLUMN_NAMES |
                          DEBUG_STACK_FRAME_NUMBERS)) != S_OK)
    {
        Exit(1, "OutputStackTrace failed, 0x%X\n", Status);
    }

    delete Frames;
}

void __cdecl
main(int Argc, char** Argv)
{
    CreateInterfaces();
    
    ParseCommandLine(Argc, Argv);

    ApplyCommandLineArguments();
    
    DumpStack();

    Exit(0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\dumpstk\out.cpp ===
//----------------------------------------------------------------------------
//
// stdio-based output callbacks class.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <dbgeng.h>

#include "out.hpp"

StdioOutputCallbacks g_OutputCb;

STDMETHODIMP
StdioOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
        IsEqualIID(InterfaceId, __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
StdioOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
StdioOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
StdioOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    UNREFERENCED_PARAMETER(Mask);
    fputs(Text, stdout);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\exts\dbgexts.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgexts.cpp

Abstract:

    This file contains the generic routines and initialization code
    for the debugger extensions dll.

--*/

#include "dbgexts.h"


PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYMBOLS2       g_ExtSymbols2;

WINDBG_EXTENSION_APIS   ExtensionApis;

ULONG   TargetMachine;
BOOL    Connected;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                (void **)&g_ExtSymbols)) != S_OK)
    {
	goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                (void **)&g_ExtSymbols2)) != S_OK)
    {
	goto Fail;
    }
    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSymbols2);
}

extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                  (void **)&DebugControl)) == S_OK)
    {

        //
        // Get the windbg-style extension APIS
        //
        ExtensionApis.nSize = sizeof (ExtensionApis);
        if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK)
            return Hr;
        
        DebugControl->Release();

    }
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    UNREFERENCED_PARAMETER(Argument);
    
    //
    // The first time we actually connect to a target
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        HRESULT Hr;
        PDEBUG_CONTROL DebugControl;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                                             &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }

                NotifyOnTargetAccessible(DebugControl);

                DebugControl->Release();
            }
 
            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\dumpstk\out.hpp ===
//----------------------------------------------------------------------------
//
// stdio-based output callbacks class.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __OUT_HPP__
#define __OUT_HPP__

class StdioOutputCallbacks : public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

extern StdioOutputCallbacks g_OutputCb;

#endif // #ifndef __OUT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\exts\exts.cpp ===
/*-----------------------------------------------------------------------------
   Copyright (c) 2000  Microsoft Corporation

Module:
  exts.cpp
  
  Sampe file showing couple of extension examples

-----------------------------------------------------------------------------*/
#include "dbgexts.h"


/*
   Sample extension to demonstrace ececuting debugger command
   
 */
HRESULT CALLBACK 
cmdsample(PDEBUG_CLIENT Client, PCSTR args)
{
    CHAR Input[256];
    INIT_API();

    UNREFERENCED_PARAMETER(args);

    //
    // Output a 10 frame stack
    //
    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS |   // Flags on what to do with output
                                   DEBUG_OUTCTL_OVERRIDE_MASK |
                                   DEBUG_OUTCTL_NOT_LOGGED, 
                                   NULL, 
                                   10,           // number of frames to display
                                   DEBUG_STACK_FUNCTION_INFO | DEBUG_STACK_COLUMN_NAMES |
                                   DEBUG_STACK_ARGUMENTS | DEBUG_STACK_FRAME_ADDRESSES);
    //
    // Engine interface for print 
    //
    g_ExtControl->Output(DEBUG_OUTCTL_ALL_CLIENTS, "\n\nDebugger module list\n");
    
    //
    // list all the modules by executing lm command
    //
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK |
                          DEBUG_OUTCTL_NOT_LOGGED,
                          "lm", // Command to be executed
                          DEBUG_EXECUTE_DEFAULT );
    
    //
    // Ask for user input
    //
    g_ExtControl->Output(DEBUG_OUTCTL_ALL_CLIENTS, "\n\n***User Input sample\n\nEnter Command to run : ");
    GetInputLine(NULL, &Input[0], sizeof(Input));
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK |
                          DEBUG_OUTCTL_NOT_LOGGED,
                          Input, // Command to be executed
                          DEBUG_EXECUTE_DEFAULT );
    
    EXIT_API();
    return S_OK;
}

/*
  Sample extension to read and dump a struct on target
    
  This reads the struct _EXCEPTION_RECORD which is defined as:
  
  typedef struct _EXCEPTION_RECORD {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;
*/
HRESULT CALLBACK 
structsample(PDEBUG_CLIENT Client, PCSTR args)
{
    ULONG64 Address;
    INIT_API();

    Address = GetExpression(args);
    
    DWORD Buffer[4], cb;

    // Read and display first 4 dwords at Address
    if (ReadMemory(Address, &Buffer, sizeof(Buffer), &cb) && cb == sizeof(Buffer)) {
        dprintf("%p: %08lx %08lx %08lx %08lx\n\n", Address,
                Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
    }

    //
    // Method 1 to dump a struct
    //
    dprintf("Method 1:\n");
    // Inititalze type read from the Address
    if (InitTypeRead(Address, _EXCEPTION_RECORD) != 0) {
        dprintf("Error in reading _EXCEPTION_RECORD at %p", // Use %p to print pointer values
                Address);
    } else {
        // read and dump the fields
        dprintf("_EXCEPTION_RECORD @ %p\n", Address);
        dprintf("\tExceptionCode           : %lx\n", (ULONG) ReadField(ExceptionCode));
        dprintf("\tExceptionAddress        : %p\n", ReadField(ExceptionAddress));
        dprintf("\tExceptionInformation[1] : %I64lx\n", ReadField(ExceptionInformation[1]));
        // And so on...
    }

    //
    // Method 2 to read a struct
    //
    ULONG64 ExceptionInformation_1, ExceptionAddress, ExceptionCode;
    dprintf("\n\nMethod 2:\n");
    // Read and dump the fields by specifying type and address individually 
    if (GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionCode", ExceptionCode)) {
        dprintf("Error in reading _EXCEPTION_RECORD at %p\n",
                Address);
    } else {
        // Pointers are read as ULONG64 values
        GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionAddress", ExceptionAddress);
        GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionInformation[1]", ExceptionInformation_1);
        // And so on..
        
        dprintf("_EXCEPTION_RECORD @ %p\n", Address);
        dprintf("\tExceptionCode           : %lx\n", ExceptionCode);
        dprintf("\tExceptionAddress        : %p\n", ExceptionAddress);
        dprintf("\tExceptionInformation[1] : %I64lx\n", ExceptionInformation_1);
    }

    ULONG64 Module;
    ULONG   i, TypeId;
    CHAR Name[MAX_PATH];
    //
    // To get/list field names
    //
    g_ExtSymbols->GetSymbolTypeId("_EXCEPTION_RECORD", &TypeId, &Module);
    dprintf("Fields of _EXCEPTION_RECORD\n");
    for (i=0; ;i++) {
	HRESULT Hr;
	ULONG Offset=0;

	Hr = g_ExtSymbols2->GetFieldName(Module, TypeId, i, Name, MAX_PATH, NULL);
	if (Hr == S_OK) {
	    g_ExtSymbols->GetFieldOffset(Module, TypeId, Name, &Offset);
	    dprintf("%lx (+%03lx) %s\n", i, Offset, Name);
	} else if (Hr == E_INVALIDARG) {
	    // All Fields done
	    break;
	} else {
	    dprintf("GetFieldName Failed %lx\n", Hr);
	    break;
	}
    }

    //
    // Get name for an enumerate
    //
    //     typedef enum {
    //        Enum1,
    //	      Enum2,
    //        Enum3,
    //     } TEST_ENUM;
    //
    ULONG   ValueOfEnum = 0;
    g_ExtSymbols->GetSymbolTypeId("TEST_ENUM", &TypeId, &Module);
    g_ExtSymbols2->GetConstantName(Module, TypeId, ValueOfEnum, Name, MAX_PATH, NULL);
    dprintf("Testenum %I64lx == %s\n", ExceptionCode, Name);
    // This prints out, Testenum 0 == Enum1

    //
    // Read an array
    //
    //    typedef struct FOO_TYPE {
    //      ULONG Bar;
    //      ULONG Bar2;
    //    } FOO_TYPE;
    //
    //    FOO_TYPE sampleArray[20];
    ULONG Bar, Bar2;
    CHAR TypeName[100];
    for (i=0; i<20; i++) {
	sprintf(TypeName, "sampleArray[%lx]", i);
	if (GetFieldValue(0, TypeName, "Bar", Bar)) 
	    break;
	GetFieldValue(0, TypeName, "Bar2", Bar2);
	dprintf("%16s -  Bar %2ld  Bar2 %ld\n", TypeName, Bar, Bar2);
    }

    EXIT_API();
    return S_OK;
}

/*
  This gets called (by DebugExtensionNotify whentarget is halted and is accessible
*/
HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL Control)
{
    dprintf("Extension dll detected a break");
    if (Connected) {
        dprintf(" connected to ");
        switch (TargetMachine) { 
        case IMAGE_FILE_MACHINE_I386:
            dprintf("X86");
            break;
        case IMAGE_FILE_MACHINE_IA64:
            dprintf("IA64");
            break;
        default:
            dprintf("Other");
            break;
        }
    }
    dprintf("\n");
    
    //
    // show the top frame and execute dv to dump the locals here and return
    //
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     ".frame", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     "dv", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    return S_OK;
}

/*
  A built-in help for the extension dll
*/
HRESULT CALLBACK 
help(PDEBUG_CLIENT Client, PCSTR args)
{
    INIT_API();

    UNREFERENCED_PARAMETER(args);

    dprintf("Help for dbgexts.dll\n"
            "  cmdsample           - This does stacktrace and lists\n"
            "  help                = Shows this help\n"
            "  structsample <addr> - This dumps a struct at given address\n"
            );
    EXIT_API();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\exts\dbgexts.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgexts.h

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif


#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define EXIT_API     ExtRelease


// Global variables initialized by query.
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYMBOLS2       g_ExtSymbols2;

extern BOOL  Connected;
extern ULONG TargetMachine;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL Control);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\simplext\exts.c ===
/*-----------------------------------------------------------------------------
   Copyright (c) 2000  Microsoft Corporation

Module:
  exts.c

Sample old windbg style interface using extension 

------------------------------------------------------------------------------*/

#include "simple.h"


//
// Extension to read and dump dwords from target
//
DECLARE_API( read )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Buffer[4];

    Address = GetExpression(args);

    // Read and display first 4 dwords at Address
    if (ReadMemory(Address, &Buffer, sizeof(Buffer), &cb) && cb == sizeof(Buffer)) {
        dprintf("%I64lx: %08lx %08lx %08lx %08lx\n\n", Address,
                Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
    }
}

//
// Extension to edit a dword on target
//  
//    !edit <address> <value>
//
DECLARE_API( edit )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Value;

    if (GetExpressionEx(args, &Address, &args)) {
        Value = (ULONG) GetExpression( args);
    } else {
        dprintf("Usage:   !edit <address> <value>\n");
        return;
    }

    // Read and display first 4 dwords at Address
    if (WriteMemory(Address, &Value, sizeof(Value), &cb) && cb == sizeof(Value)) {
        dprintf("%I64lx: %08lx\n", Address, Value);
    }
}


//
// Extension to dump stacktrace
//
DECLARE_API ( stack )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;


    // Get stacktrace for surrent thread 
    frames = StackTrace( 0, 0, 0, stk, 20 );

    if (!frames) {
        dprintf("Stacktrace failed\n");
    }

    for (i=0; i<frames; i++) {

        if (i==0) {
            dprintf( "ChildEBP RetAddr  Args to Child\n" );
        }

        Buffer[0] = '!';
        GetSymbol(stk[i].ProgramCounter, (PUCHAR)Buffer, &displacement);
        
        dprintf( "%08p %08p %08p %08p %08p %s",
                 stk[i].FramePointer,
                 stk[i].ReturnAddress,
                 stk[i].Args[0],
                 stk[i].Args[1],
                 stk[i].Args[2],
                 Buffer
                 );

        if (displacement) {
            dprintf( "+0x%p", displacement );
        }

        dprintf( "\n" );
    }
}

/*
  A built-in help for the extension dll
*/

DECLARE_API ( help ) 
{
    dprintf("Help for extension dll simple.dll\n"
            "   read  <addr>       - It reads and dumps 4 dwords at <addr>\n"
            "   edit  <addr> <val> - It modifies a dword value to <val> at <addr>\n"
            "   stack              - Printd current stack trace\n"
            "   help               - Shows this help\n"
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\simplext\simple.h ===
/*++
   Copyright (c) 2000  Microsoft Corporation

Module:

    Simple.h
    
    
    Common header file for extensions

--*/

#include <windows.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\healer\test\healtest.cpp ===
//----------------------------------------------------------------------------
//
// Test program for the healer sample.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>

void __cdecl
main(int Argc, char** Argv)
{
    printf("GetVersion returns %08X\n", GetVersion());
    
    OSVERSIONINFO OsVer;

    OsVer.dwOSVersionInfoSize = sizeof(OsVer);
    if (GetVersionEx(&OsVer))
    {
        switch(OsVer.dwPlatformId)
        {
        case VER_PLATFORM_WIN32_NT:
            printf("Windows NT/2000 ");
            break;
        case VER_PLATFORM_WIN32_WINDOWS:
            printf("Windows 9x/ME ");
            break;
        default:
            printf("Platform %d ", OsVer.dwPlatformId);
            break;
        }

        printf("%d.%02d.%04d\n", OsVer.dwMajorVersion, OsVer.dwMinorVersion,
               OsVer.dwBuildNumber);
    }
    else
    {
        printf("GetVersionEx failed, %d\n", GetLastError());
    }
    
    int i;
    
    printf("\nUsing sti/cli\n");
    for (i = 0; i < 10; i++)
    {
        printf(" %d", i);
        __asm sti;
        __asm cli;
    }
    printf("\n");

    printf("\nSuccessful\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\savedump\erdirty.cpp ===
/*++

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    erdirty.cpp

Abstract:

    This module contains the code to report pending dirty shutdown
    events at logon after dirty reboot.

Author:

    Ian Service (ianserv) 29-May-2001

Environment:

    User mode at logon.

Revision History:

--*/

#include "savedump.h"


BOOL
DirtyShutdownEventHandler(
    IN BOOL NotifyPcHealth
    )

/*++

Routine Description:

    This is the boot time routine to handle pending dirty shutdown event.

Arguments:

    NotifyPcHealth - TRUE if we should report event to PC Health, FALSE otherwise.

Return Value:

    TRUE if dirty shutdown event found and reported to PC Health, FALSE otherwise.

--*/

{
    HKEY Key;
    ULONG WinStatus;
    ULONG Length;
    ULONG Type;
    WCHAR DumpName[MAX_PATH];
    BOOLEAN Status;

    Status = FALSE;

    //
    // Open the Reliability key.
    //

    WinStatus = RegOpenKey(HKEY_LOCAL_MACHINE,
                           SUBKEY_RELIABILITY,
                           &Key);

    if (WinStatus != ERROR_SUCCESS)
    {
        return FALSE;
    }

    Length = sizeof (DumpName);
    WinStatus = RegQueryValueEx(Key,
                                L"ShutDownStateSnapShot",
                                NULL,
                                &Type,
                                (LPBYTE)&DumpName,
                                &Length);

    if (ERROR_SUCCESS == WinStatus)
    {
        if (NotifyPcHealth)
        {
            PCHPFNotifyFault(eetShutdown, DumpName, NULL);
            Status = TRUE;
        }

        RegDeleteValue(Key, L"ShutDownStateSnapShot");
        RegCloseKey (Key);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\simplext\simple.c ===
/*++

 Copyright (c) 2000  Microsoft Corporation

Module Name:

    simple.c

--*/

#include "simple.h"

#include <ntverp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG SavedMajorVersion;
ULONG SavedMinorVersion;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Routine called by debugger after load
//
VOID
CheckVersion(
    VOID
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\savedump\erdirty.h ===
/*++

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    erdirty.h

Abstract:

    This module contains the code to report pending dirty shutdown
    events at logon after dirty reboot.

Author:

    Ian Service (ianserv) 29-May-2001

Environment:

    User mode at logon.

Revision History:

--*/

#ifndef _ERDIRTY_H_
#define _ERDIRTY_H_

//
// Prototypes of routines supplied by erwatch.cpp.
//

BOOL
DirtyShutdownEventHandler(
    IN BOOL NotifyPcHealth
    );

#endif  // _ERDIRTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\samples\healer\healer.cpp ===
//----------------------------------------------------------------------------
//
// Sample of monitoring an application for compatibility problems
// and automatically correcting them.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#include <dbgeng.h>

PSTR g_SymbolPath;
char g_CommandLine[8 * MAX_PATH];
BOOL g_Verbose;
BOOL g_NeedVersionBps;

IDebugClient* g_Client;
IDebugControl* g_Control;
IDebugDataSpaces* g_Data;
IDebugRegisters* g_Registers;
IDebugSymbols* g_Symbols;

struct BREAKPOINT
{
    IDebugBreakpoint* Bp;
    ULONG Id;
};

BREAKPOINT g_GetVersionBp;
BREAKPOINT g_GetVersionRetBp;
BREAKPOINT g_GetVersionExBp;
BREAKPOINT g_GetVersionExRetBp;

ULONG g_EaxIndex = DEBUG_ANY_ID;
OSVERSIONINFO g_OsVer;
DWORD g_VersionNumber;
ULONG64 g_OsVerOffset;

//----------------------------------------------------------------------------
//
// Utility routines.
//
//----------------------------------------------------------------------------

void
Exit(int Code, PCSTR Format, ...)
{
    // Clean up any resources.
    if (g_Control != NULL)
    {
        g_Control->Release();
    }
    if (g_Data != NULL)
    {
        g_Data->Release();
    }
    if (g_Registers != NULL)
    {
        g_Registers->Release();
    }
    if (g_Symbols != NULL)
    {
        g_Symbols->Release();
    }
    if (g_Client != NULL)
    {
        //
        // Request a simple end to any current session.
        // This may or may not do anything but it isn't
        // harmful to call it.
        //

        g_Client->EndSession(DEBUG_END_PASSIVE);
        
        g_Client->Release();
    }

    // Output an error message if given.
    if (Format != NULL)
    {
        va_list Args;

        va_start(Args, Format);
        vfprintf(stderr, Format, Args);
        va_end(Args);
    }
    
    exit(Code);
}

void
Print(PCSTR Format, ...)
{
    va_list Args;

    printf("HEALER: ");
    va_start(Args, Format);
    vprintf(Format, Args);
    va_end(Args);
}

HRESULT
AddBp(BREAKPOINT* Bp, PCSTR Expr)
{
    HRESULT Status;
    
    if ((Status = g_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE, DEBUG_ANY_ID,
                                           &Bp->Bp)) != S_OK)
    {
        Bp->Id = DEBUG_ANY_ID;
        return Status;
    }

    if ((Status = Bp->Bp->GetId(&Bp->Id)) != S_OK ||
        (Status = Bp->Bp->SetOffsetExpression(Expr)) != S_OK ||
        (Status = Bp->Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED)) != S_OK)
    {
        Bp->Bp->Release();
        Bp->Id = DEBUG_ANY_ID;
        return Status;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// Healing routines.
//
//----------------------------------------------------------------------------

void
ApplyExePatches(PCSTR ImageName, ULONG64 BaseOffset)
{
    if (ImageName == NULL)
    {
        ImageName = "<Unknown>";
    }
    
    // This would be where any executable image patching would go.
    Print("Executable '%s' loaded at %I64x\n", ImageName, BaseOffset);
}

void
ApplyDllPatches(PCSTR ImageName, ULONG64 BaseOffset)
{
    if (ImageName == NULL)
    {
        ImageName = "<Unknown>";
    }
    
    // Any DLL-specific image patching goes here.
    Print("DLL '%s' loaded at %I64x\n", ImageName, BaseOffset);
}

void
AddVersionBps(void)
{
    //
    // Put breakpoints on GetVersion and GetVersionEx.
    //

    if (AddBp(&g_GetVersionBp, "kernel32!GetVersion") != S_OK ||
        AddBp(&g_GetVersionExBp, "kernel32!GetVersionEx") != S_OK)
    {
        Exit(1, "Unable to set version breakpoints\n");
    }

    //
    // Create the return breakpoints but leave them disabled
    // until they're needed.
    //
    
    if (g_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE, DEBUG_ANY_ID,
                                 &g_GetVersionRetBp.Bp) != S_OK ||
        g_GetVersionRetBp.Bp->GetId(&g_GetVersionRetBp.Id) != S_OK ||
        g_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE, DEBUG_ANY_ID,
                                 &g_GetVersionExRetBp.Bp) != S_OK ||
        g_GetVersionExRetBp.Bp->GetId(&g_GetVersionExRetBp.Id) != S_OK)
    {
        Exit(1, "Unable to set version breakpoints\n");
    }
}

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

class EventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        );
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        );
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        );
    STDMETHOD(LoadModule)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp
        );
    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        );
};

STDMETHODIMP_(ULONG)
EventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
EventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
EventCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask =
        DEBUG_EVENT_BREAKPOINT |
        DEBUG_EVENT_EXCEPTION |
        DEBUG_EVENT_CREATE_PROCESS |
        DEBUG_EVENT_LOAD_MODULE |
        DEBUG_EVENT_SESSION_STATUS;
    return S_OK;
}

STDMETHODIMP
EventCallbacks::Breakpoint(
    THIS_
    IN PDEBUG_BREAKPOINT Bp
    )
{
    ULONG Id;
    ULONG64 ReturnOffset;

    if (Bp->GetId(&Id) != S_OK)
    {
        return DEBUG_STATUS_BREAK;
    }

    if (Id == g_GetVersionBp.Id)
    {
        // Set a breakpoint on the return address of the call
        // so that we can patch up any returned information.
        if (g_Control->GetReturnOffset(&ReturnOffset) != S_OK ||
            g_GetVersionRetBp.Bp->SetOffset(ReturnOffset) != S_OK ||
            g_GetVersionRetBp.Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
    }
    else if (Id == g_GetVersionExBp.Id)
    {
        ULONG64 StackOffset;
        
        // Remember the OSVERSIONINFO structure pointer.
        if (g_Registers->GetStackOffset(&StackOffset) != S_OK ||
            g_Data->ReadPointersVirtual(1, StackOffset + 4,
                                        &g_OsVerOffset) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
        
        // Set a breakpoint on the return address of the call
        // so that we can patch up any returned information.
        if (g_Control->GetReturnOffset(&ReturnOffset) != S_OK ||
            g_GetVersionExRetBp.Bp->SetOffset(ReturnOffset) != S_OK ||
            g_GetVersionExRetBp.Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
    }
    else if (Id == g_GetVersionRetBp.Id)
    {
        // Turn off the breakpoint.
        if (g_GetVersionRetBp.Bp->
            RemoveFlags(DEBUG_BREAKPOINT_ENABLED) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
        
        DEBUG_VALUE Val;
        
        // Change eax to alter the returned version value.
        Val.Type = DEBUG_VALUE_INT32;
        Val.I32 = g_VersionNumber;
        if (g_Registers->SetValue(g_EaxIndex, &Val) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }

        Print("GetVersion returns %08X\n", g_VersionNumber);
    }
    else if (Id == g_GetVersionExRetBp.Id)
    {
        ULONG Done;
        
        // Turn off the breakpoint.
        if (g_GetVersionExRetBp.Bp->
            RemoveFlags(DEBUG_BREAKPOINT_ENABLED) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
        
        // Change the returned OSVERSIONINFO structure.
        if (g_Data->WriteVirtual(g_OsVerOffset, &g_OsVer, sizeof(g_OsVer),
                                 &Done) != S_OK ||
            Done != sizeof(g_OsVer))
        {
            return DEBUG_STATUS_BREAK;
        }

        Print("GetVersionEx returns %08X\n", g_VersionNumber);
    }
    else
    {
        return DEBUG_STATUS_NO_CHANGE;
    }
    
    return DEBUG_STATUS_GO;
}

STDMETHODIMP
EventCallbacks::Exception(
    THIS_
    IN PEXCEPTION_RECORD64 Exception,
    IN ULONG FirstChance
    )
{
    // We want to handle these exceptions on the first
    // chance to make it look like no exception ever
    // happened.  Handling them on the second chance would
    // allow an exception handler somewhere in the app
    // to be hit on the first chance.
    if (!FirstChance)
    {
        return DEBUG_STATUS_NO_CHANGE;
    }

    //
    // Check and see if the instruction causing the exception
    // is a cli or sti.  These are not allowed in user-mode
    // programs on NT so if they're present just nop them.
    //

    // sti/cli will generate privileged instruction faults.
    if (Exception->ExceptionCode != STATUS_PRIVILEGED_INSTRUCTION)
    {
        return DEBUG_STATUS_NO_CHANGE;
    }

    UCHAR Instr;
    ULONG Done;
    
    // It's a privileged instruction, so check the code for sti/cli.
    if (g_Data->ReadVirtual(Exception->ExceptionAddress, &Instr,
                            sizeof(Instr), &Done) != S_OK ||
        Done != sizeof(Instr) ||
        (Instr != 0xfb && Instr != 0xfa))
    {
        return DEBUG_STATUS_NO_CHANGE;
    }

    // It's a sti/cli, so nop it out and continue.
    Instr = 0x90;
    if (g_Data->WriteVirtual(Exception->ExceptionAddress, &Instr,
                             sizeof(Instr), &Done) != S_OK ||
        Done != sizeof(Instr))
    {
        return DEBUG_STATUS_NO_CHANGE;
    }

    // Fixed.
    if (g_Verbose)
    {
        Print("Removed sti/cli at %I64x\n", Exception->ExceptionAddress);
    }
    
    return DEBUG_STATUS_GO_HANDLED;
}

STDMETHODIMP
EventCallbacks::CreateProcess(
    THIS_
    IN ULONG64 ImageFileHandle,
    IN ULONG64 Handle,
    IN ULONG64 BaseOffset,
    IN ULONG ModuleSize,
    IN PCSTR ModuleName,
    IN PCSTR ImageName,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp,
    IN ULONG64 InitialThreadHandle,
    IN ULONG64 ThreadDataOffset,
    IN ULONG64 StartOffset
    )
{
    UNREFERENCED_PARAMETER(ImageFileHandle);
    UNREFERENCED_PARAMETER(Handle);
    UNREFERENCED_PARAMETER(ModuleSize);
    UNREFERENCED_PARAMETER(ModuleName);
    UNREFERENCED_PARAMETER(CheckSum);
    UNREFERENCED_PARAMETER(TimeDateStamp);
    UNREFERENCED_PARAMETER(InitialThreadHandle);
    UNREFERENCED_PARAMETER(ThreadDataOffset);
    UNREFERENCED_PARAMETER(StartOffset);
    
    // The process is now available for manipulation.
    // Perform any initial code patches on the executable.
    ApplyExePatches(ImageName, BaseOffset);

    // If the user requested that version calls be fixed up
    // register breakpoints to do so.
    if (g_NeedVersionBps)
    {
        AddVersionBps();
    }
    
    return DEBUG_STATUS_GO;
}

STDMETHODIMP
EventCallbacks::LoadModule(
    THIS_
    IN ULONG64 ImageFileHandle,
    IN ULONG64 BaseOffset,
    IN ULONG ModuleSize,
    IN PCSTR ModuleName,
    IN PCSTR ImageName,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp
    )
{
    UNREFERENCED_PARAMETER(ImageFileHandle);
    UNREFERENCED_PARAMETER(ModuleSize);
    UNREFERENCED_PARAMETER(ModuleName);
    UNREFERENCED_PARAMETER(CheckSum);
    UNREFERENCED_PARAMETER(TimeDateStamp);
    
    ApplyDllPatches(ImageName, BaseOffset);
    return DEBUG_STATUS_GO;
}

STDMETHODIMP
EventCallbacks::SessionStatus(
    THIS_
    IN ULONG SessionStatus
    )
{
    // A session isn't fully active until WaitForEvent
    // has been called and has processed the initial
    // debug events.  We need to wait for activation
    // before we query information about the session
    // as not all information is available until the
    // session is fully active.  We could put these
    // queries into CreateProcess as that happens
    // early and when the session is fully active, but
    // for example purposes we'll wait for an
    // active SessionStatus callback.
    // In non-callback applications this work can just
    // be done after the first successful WaitForEvent.
    if (SessionStatus != DEBUG_SESSION_ACTIVE)
    {
        return S_OK;
    }
    
    HRESULT Status;
    
    //
    // Find the register index for eax as we'll need
    // to access eax.
    //

    if ((Status = g_Registers->GetIndexByName("eax", &g_EaxIndex)) != S_OK)
    {
        Exit(1, "GetIndexByName failed, 0x%X\n", Status);
    }

    return S_OK;
}

EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Initialization and main event loop.
//
//----------------------------------------------------------------------------

void
CreateInterfaces(void)
{
    SYSTEM_INFO SysInfo;
    
    // For purposes of keeping this example simple the
    // code only works on x86 machines.  There's no reason
    // that it couldn't be made to work on all processors, though.
    GetSystemInfo(&SysInfo);
    if (SysInfo.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
    {
        Exit(1, "This program only runs on x86 machines.\n");
    }

    // Get default version information.
    g_OsVer.dwOSVersionInfoSize = sizeof(g_OsVer);
    if (!GetVersionEx(&g_OsVer))
    {
        Exit(1, "GetVersionEx failed, %d\n", GetLastError());
    }

    HRESULT Status;

    // Start things off by getting an initial interface from
    // the engine.  This can be any engine interface but is
    // generally IDebugClient as the client interface is
    // where sessions are started.
    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&g_Client)) != S_OK)
    {
        Exit(1, "DebugCreate failed, 0x%X\n", Status);
    }

    // Query for some other interfaces that we'll need.
    if ((Status = g_Client->QueryInterface(__uuidof(IDebugControl),
                                           (void**)&g_Control)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                           (void**)&g_Data)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugRegisters),
                                           (void**)&g_Registers)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugSymbols),
                                           (void**)&g_Symbols)) != S_OK)
    {
        Exit(1, "QueryInterface failed, 0x%X\n", Status);
    }
}

void
ParseCommandLine(int Argc, char** Argv)
{
    while (--Argc > 0)
    {
        Argv++;

        if (!strcmp(*Argv, "-plat"))
        {
            if (Argc < 2)
            {
                Exit(1, "-plat missing argument\n");
            }

            Argv++;
            Argc--;

            sscanf(*Argv, "%i", &g_OsVer.dwPlatformId);
            g_NeedVersionBps = TRUE;
        }
        else if (!strcmp(*Argv, "-v"))
        {
            g_Verbose = TRUE;
        }
        else if (!strcmp(*Argv, "-ver"))
        {
            if (Argc < 2)
            {
                Exit(1, "-ver missing argument\n");
            }

            Argv++;
            Argc--;

            sscanf(*Argv, "%i.%i.%i",
                   &g_OsVer.dwMajorVersion, &g_OsVer.dwMinorVersion,
                   &g_OsVer.dwBuildNumber);
            g_NeedVersionBps = TRUE;
        }
        else if (!strcmp(*Argv, "-y"))
        {
            if (Argc < 2)
            {
                Exit(1, "-y missing argument\n");
            }

            Argv++;
            Argc--;

            g_SymbolPath = *Argv;
        }
        else
        {
            // Assume process arguments begin.
            break;
        }
    }
    
    //
    // Concatenate remaining arguments into a command line.
    //
    
    PSTR CmdLine = g_CommandLine;
    
    while (Argc > 0)
    {
        BOOL Quote = FALSE;
        
        // Quote arguments with spaces.
        if (strchr(*Argv, ' ') != NULL || strchr(*Argv, '\t') != NULL)
        {
            *CmdLine++ = '"';
            Quote = TRUE;
        }

        strcpy(CmdLine, *Argv);
        CmdLine += strlen(CmdLine);

        if (Quote)
        {
            *CmdLine++ = '"';
        }

        *CmdLine++ = ' ';
        
        Argv++;
        Argc--;
    }

    *CmdLine = 0;

    if (strlen(g_CommandLine) == 0)
    {
        Exit(1, "No application command line given\n");
    }
}

void
ApplyCommandLineArguments(void)
{
    HRESULT Status;

    if (g_SymbolPath != NULL)
    {
        if ((Status = g_Symbols->SetSymbolPath(g_SymbolPath)) != S_OK)
        {
            Exit(1, "SetSymbolPath failed, 0x%X\n", Status);
        }
    }

    // Register our event callbacks.
    if ((Status = g_Client->SetEventCallbacks(&g_EventCb)) != S_OK)
    {
        Exit(1, "SetEventCallbacks failed, 0x%X\n", Status);
    }
    
    // Everything's set up so start the app.
    if ((Status = g_Client->CreateProcess(0, g_CommandLine,
                                          DEBUG_ONLY_THIS_PROCESS)) != S_OK)
    {
        Exit(1, "CreateProcess failed, 0x%X\n", Status);
    }

    // Compute the GetVersion value from the OSVERSIONINFO.
    g_VersionNumber = (g_OsVer.dwMajorVersion & 0xff) |
        ((g_OsVer.dwMinorVersion & 0xff) << 8);
    if (g_OsVer.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        g_VersionNumber |= (g_OsVer.dwBuildNumber & 0x7fff) << 16;
    }
    else
    {
        g_VersionNumber |= 0x80000000;
    }
}

void
EventLoop(void)
{
    HRESULT Status;

    for (;;)
    {
        if ((Status = g_Control->WaitForEvent(DEBUG_WAIT_DEFAULT,
                                              INFINITE)) != S_OK)
        {
            ULONG ExecStatus;
            
            // Check and see whether the session is running or not.
            if (g_Control->GetExecutionStatus(&ExecStatus) == S_OK &&
                ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
            {
                // The session ended so we can quit.
                break;
            }

            // There was a real error.
            Exit(1, "WaitForEvent failed, 0x%X\n", Status);
        }

        // Our event callbacks asked to break in.  This
        // only occurs in situations when the callback
        // couldn't handle the event.  See if the user cares.
        if (MessageBox(GetDesktopWindow(),
                       "An unusual event occurred.  Ignore it?",
                       "Unhandled Event", MB_YESNO) == IDNO)
        {
            Exit(1, "Unhandled event\n");
        }

        // User chose to ignore so restart things.
        if ((Status = g_Control->
             SetExecutionStatus(DEBUG_STATUS_GO_HANDLED)) != S_OK)
        {
            Exit(1, "SetExecutionStatus failed, 0x%X\n", Status);
        }
    }
}

void __cdecl
main(int Argc, char** Argv)
{
    CreateInterfaces();
    
    ParseCommandLine(Argc, Argv);

    ApplyCommandLineArguments();

    EventLoop();

    Exit(0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\setup\resource.h ===
#define IDD_LICENSE         4000
#define IDC_EDIT_LICENSE    4002
#define IDC_UNUSED          -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\setup\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
USE_MSVCRT=1

BINPLACE_PLACEFILE=..\..\placefil.txt

INCLUDES=

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\msisetup.c  \
        ..\msisetup.rc

UMTYPE=windows
UMENTRY=winmain

MSC_WARNING_LEVEL=/W3 /WX

TARGETLIBS=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\savedump\savedump.h ===
/*++

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    savedump.h

Abstract:

    This module contains the code to recover a dump from the system paging
    file.

Environment:

    User mode.

Revision History:

--*/

#ifndef _SAVEDUMP_H_
#define _SAVEDUMP_H_

#ifndef UNICODE
#define UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <lmcons.h>
#include <lmalert.h>
#include <ntiodump.h>
#include <sdevents.h>
#include <alertmsg.h>
#include <dbgeng.h>
#include <faultrep.h>
#include <erdirty.h>
#include <erwatch.h>

#define SUBKEY_CRASH_CONTROL         L"SYSTEM\\CurrentControlSet\\Control\\CrashControl"
#define SUBKEY_WATCHDOG_DISPLAY      L"SYSTEM\\CurrentControlSet\\Control\\Watchdog\\Display"
#define SUBKEY_RELIABILITY           L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reliability"

HRESULT
PCHPFNotifyFault(
    EEventType FaultTypeToReport,
    LPWSTR pwszDumpPath,
    SEventInfoW *pEventInfo
    );

#endif  // _SAVEDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\savedump\erwatch.h ===
/*++

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    erwatch.h

Abstract:

    This module contains the code to report pending watchdog timeout
    events at logon after dirty reboot.

Author:

    Michael Maciesowicz (mmacie) 29-May-2001

Environment:

    User mode at logon.

Revision History:

--*/

//#ifndef _ERWATCH_H_
//#define _ERWATCH_H_

//
// Localizable string IDs.
//

#define IDS_000                             100
#define IDS_001                             101
#define IDS_002                             102
#define IDS_003                             103
#define IDS_004                             104
#define IDS_005                             105

//
// Constants used by erwatch.cpp.
//

#define ER_WD_MAX_RETRY                     100
#define ER_WD_MAX_NAME_LENGTH               255
#define ER_WD_MAX_DATA_SIZE                 4096
#define ER_WD_MAX_STRING                    1024
#define ER_WD_MAX_FILE_INFO_LENGTH          255
#define ER_WD_MAX_URL_LENGTH                255
#define ER_WD_LANG_ENGLISH                  0x0409
#define ER_WD_DISABLE_BUGCHECK_FLAG         0x01
#define ER_WD_DEBUGGER_NOT_PRESENT_FLAG     0x02
#define ER_WD_BUGCHECK_TRIGGERED_FLAG       0x04

//
// Data types.
//

typedef struct _ER_WD_LANG_AND_CODE_PAGE
{
    USHORT Language;
    USHORT CodePage;
} ER_WD_LANG_AND_CODE_PAGE, *PER_WD_LANG_AND_CODE_PAGE;

typedef struct _ER_WD_DRIVER_INFO
{
    WCHAR DriverName[MAX_PATH];
    VS_FIXEDFILEINFO FixedFileInfo;
    WCHAR Comments[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR CompanyName[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR FileDescription[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR FileVersion[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR InternalName[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR LegalCopyright[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR LegalTrademarks[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR OriginalFilename[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR PrivateBuild[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR ProductName[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR ProductVersion[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR SpecialBuild[ER_WD_MAX_FILE_INFO_LENGTH + 1];
} ER_WD_DRIVER_INFO, *PER_WD_DRIVER_INFO;

typedef struct _ER_WD_PCI_ID
{
    USHORT VendorId;
    USHORT DeviceId;
    UCHAR Revision;
    ULONG SubsystemId;
} ER_WD_PCI_ID, *PER_WD_PCI_ID;

//
// Prototypes of routines supplied by erwatch.cpp.
//

HANDLE
CreateWatchdogEventFile(
    IN PWSTR FileName
    );

BOOL
CreateWatchdogEventFileName(
    OUT PWSTR FileName
    );

USHORT
GenerateSignature(
    IN PER_WD_PCI_ID PciId,
    IN PER_WD_DRIVER_INFO DriverInfo
    );

UCHAR
GetFlags(
    IN HKEY Key
    );

VOID
GetDriverInfo(
    IN HKEY Key,
    IN OPTIONAL PWCHAR Extension,
    OUT PER_WD_DRIVER_INFO DriverInfo
    );

VOID
GetPciId(
    IN HKEY Key,
    OUT PER_WD_PCI_ID PciId
    );

BOOL
SaveWatchdogEventData(
    IN HANDLE FileHandle,
    IN HKEY Key,
    IN PER_WD_DRIVER_INFO DriverInfo
    );

BOOL
WatchdogEventHandler(
    IN BOOL NotifyPcHealth
    );

BOOL
WriteWatchdogEventFile(
    IN HANDLE FileHandle,
    IN PWSTR String
    );

//#endif  // _ERWATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\savedump\erwatch.cpp ===
/*++

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    erwatch.cpp

Abstract:

    This module contains the code to report pending watchdog timeout
    events at logon after dirty reboot.

Author:

    Michael Maciesowicz (mmacie) 29-May-2001

Environment:

    User mode at logon.

Revision History:

--*/

#include "savedump.h"


HANDLE
CreateWatchdogEventFile(
    IN PWSTR FileName
    )

/*++

Routine Description:

    This routine creates watchdog event report file.

Arguments:

    FileName - Points to the watchdog event file name.

Return Value:

    File handle if successful, INVALID_HANDLE_VALUE otherwise.

--*/

{
    WCHAR Buffer[256];
    HANDLE FileHandle;
    BOOL Status;
    SYSTEMTIME Time;
    TIME_ZONE_INFORMATION TimeZone;

    //
    // Create watchdog event file.
    //

    FileHandle = CreateFile(FileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (INVALID_HANDLE_VALUE == FileHandle)
    {
        return FileHandle;
    }

    //
    // Write header info.
    //

    Status = WriteWatchdogEventFile(FileHandle, L"//\r\n// Watchdog Event Log File\r\n//\r\n\r\n");

    if (TRUE == Status)
    {
        Status = WriteWatchdogEventFile(FileHandle, L"LogType: Watchdog\r\n");
    }

    if (TRUE == Status)
    {
        GetLocalTime(&Time);

        swprintf(Buffer,
                 L"Created: %d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d\r\n",
                 Time.wYear,
                 Time.wMonth,
                 Time.wDay,
                 Time.wHour,
                 Time.wMinute,
                 Time.wSecond);

        Status = WriteWatchdogEventFile(FileHandle, Buffer);
    }

    if (TRUE == Status)
    {
        GetTimeZoneInformation(&TimeZone);

        swprintf(Buffer,
                 L"TimeZone: %d - %s\r\n",
                 TimeZone.Bias,
                 TimeZone.StandardName);

        Status = WriteWatchdogEventFile(FileHandle, Buffer);
    }

    if (TRUE == Status)
    {
        swprintf(Buffer, L"WindowsVersion: XP\r\n");

        Status = WriteWatchdogEventFile(FileHandle, Buffer);
    }

    if (TRUE == Status)
    {
        Status = WriteWatchdogEventFile(FileHandle, L"EventType: 0xEA - Thread Stuck in Device Driver\r\n");
    }

    if (FALSE == Status)
    {
        CloseHandle(FileHandle);
        FileHandle = INVALID_HANDLE_VALUE;
    }

    return FileHandle;
}

BOOL
CreateWatchdogEventFileName(
    OUT PWSTR FileName
    )

/*++

Routine Description:

    This routine generates watchdog event report full path file name.

Arguments:

    FileName - Points to the storage for generated file name (MAX_PATH
    size assumed).

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    INT Retry;
    WCHAR DirName[MAX_PATH];
    DWORD Size;
    DWORD ReturnedSize;
    SYSTEMTIME Time;

    ASSERT(NULL != FileName);

    //
    // Create %SystemRoot%\LogFiles\Watchdog directory for watchdog event files.
    //

    Size = MAX_PATH - sizeof (L"YYMMDD_HHMM_NN.wdl");

    ReturnedSize = ExpandEnvironmentStrings(L"%SystemRoot%\\LogFiles",
                                            DirName,
                                            Size);

    if ((0 == ReturnedSize) || (ReturnedSize > Size))
    {
        return FALSE;
    }

    CreateDirectory(DirName, NULL);

    ReturnedSize = ExpandEnvironmentStrings(L"%SystemRoot%\\LogFiles\\Watchdog",
                                            DirName,
                                            Size);

    if ((0 == ReturnedSize) || (ReturnedSize > Size))
    {
        return FALSE;
    }

    CreateDirectory(DirName, NULL);

    //
    // Create watchdog event file as YYMMDD_HHMM_NN.wdl.
    //

    GetLocalTime(&Time);

    for (Retry = 1; Retry < ER_WD_MAX_RETRY; Retry++)
    {
        swprintf(FileName,
                 L"%s\\%2.2d%2.2d%2.2d_%2.2d%2.2d_%2.2d.wdl",
                 DirName,
                 Time.wYear % 100,
                 Time.wMonth,
                 Time.wDay,
                 Time.wHour,
                 Time.wMinute,
                 Retry);

        if ((GetFileAttributes(FileName) == (DWORD)-1) &&
            (GetLastError() == ERROR_FILE_NOT_FOUND))
        {
            break;
        }
    }

    //
    // If we failed to create a suitable file name just fail.
    //

    if (Retry == ER_WD_MAX_RETRY)
    {
        return FALSE;
    }

    return TRUE;
}

USHORT
GenerateSignature(
    OUT PER_WD_PCI_ID PciId,
    OUT PER_WD_DRIVER_INFO DriverInfo
    )

/*++

Routine Description:

    This routine generates unique failure signature for given PCI ID and driver data.

Arguments:

    PciId - Points to PCI ID info.

    DriverInfo - Points to driver version info.

Return Value:

    Failure signature.

--*/

{
    USHORT Signature;
    PUSHORT DataPtr;
    LONG Count;
    LONG MaxCount;

    Signature = 0;

    if ((NULL == PciId) || (NULL == DriverInfo))
    {
        return Signature;
    }

    //
    // Build word CRC checksum for PciId.
    //

    MaxCount = sizeof (ER_WD_PCI_ID) / sizeof (USHORT);
    DataPtr = (PUSHORT)PciId;

    for (Count = 0; Count < MaxCount; Count++)
    {
        Signature ^= *DataPtr;
        DataPtr++;
    }

    //
    // Check for odd byte.
    //

    if (sizeof (ER_WD_PCI_ID) % sizeof (USHORT))
    {
        Signature ^= *(PUCHAR)DataPtr;
    }

    //
    // Now append DriverInfo.
    //

    MaxCount = sizeof (ER_WD_DRIVER_INFO) / sizeof (USHORT);
    DataPtr = (PUSHORT)DriverInfo;

    for (Count = 0; Count < MaxCount; Count++)
    {
        Signature ^= *DataPtr;
        DataPtr++;
    }

    //
    // Check for odd byte.
    //

    if (sizeof (ER_WD_DRIVER_INFO) % sizeof (USHORT))
    {
        Signature ^= *(PUCHAR)DataPtr;
    }

    return Signature;
}

VOID
GetDriverInfo(
    IN HKEY Key,
    IN OPTIONAL PWCHAR Extension,
    OUT PER_WD_DRIVER_INFO DriverInfo
    )

/*++

Routine Description:

    This routine collects driver's version info.

Arguments:

    Key - Watchdog open key (device specific).

    Extension - Driver file name extension if one should be appended.

    DriverInfo - Storage for driver version info.

Return Value:

--*/

{
    PVOID VersionBuffer;
    PVOID VersionValue;
    LONG WinStatus;
    DWORD Type;
    DWORD Handle;
    DWORD RegLength;
    ULONG Index;
    USHORT CodePage;
    UINT Length;

    if (NULL == DriverInfo)
    {
        return;
    }

    ZeroMemory(DriverInfo, sizeof (ER_WD_DRIVER_INFO));

    //
    // Get driver file name from registry.
    //

    RegLength = MAX_PATH;
    WinStatus = RegQueryValueEx(Key,
                                L"DriverName",
                                NULL,
                                &Type,
                                (LPBYTE)DriverInfo->DriverName,
                                &RegLength);

    if (ERROR_SUCCESS != WinStatus)
    {
        swprintf(DriverInfo->DriverName, L"%s", L"Unknown");
        return;
    }

    if (Extension)
    {
        if ((wcslen(DriverInfo->DriverName) <= wcslen(Extension)) ||
            wcscmp(DriverInfo->DriverName + wcslen(DriverInfo->DriverName) - wcslen(Extension), Extension))
        {
            wcscat(DriverInfo->DriverName, Extension);
        }
    }

    Length = GetFileVersionInfoSize(DriverInfo->DriverName, &Handle);

    if (Length)
    {
        VersionBuffer = malloc(Length);

        if (NULL != VersionBuffer)
        {
            if (GetFileVersionInfo(DriverInfo->DriverName, Handle, Length, VersionBuffer))
            {
                //
                // Get fixed file info.
                //

                if (VerQueryValue(VersionBuffer,
                                  L"\\",
                                  &VersionValue,
                                  &Length))
                {
                    CopyMemory(&(DriverInfo->FixedFileInfo),
                               VersionValue,
                               min(Length, sizeof (VS_FIXEDFILEINFO)));
                }

                //
                // Try to locate English code page.
                //

                CodePage = 0;

                if (VerQueryValue(VersionBuffer,
                                  L"\\VarFileInfo\\Translation",
                                  &VersionValue,
                                  &Length))
                {
                    for (Index = 0; Index < Length / sizeof (ER_WD_LANG_AND_CODE_PAGE); Index++)
                    {
                        if (((PER_WD_LANG_AND_CODE_PAGE)VersionValue + Index)->Language == ER_WD_LANG_ENGLISH)
                        {
                            CodePage = ((PER_WD_LANG_AND_CODE_PAGE)VersionValue + Index)->CodePage;
                            break;
                        }
                    }
                }

                if (CodePage)
                {
                    WCHAR ValueName[ER_WD_MAX_NAME_LENGTH + 1];
                    PWCHAR Destination[] =
                    {
                        DriverInfo->Comments,
                        DriverInfo->CompanyName,
                        DriverInfo->FileDescription,
                        DriverInfo->FileVersion,
                        DriverInfo->InternalName,
                        DriverInfo->LegalCopyright,
                        DriverInfo->LegalTrademarks,
                        DriverInfo->OriginalFilename,
                        DriverInfo->PrivateBuild,
                        DriverInfo->ProductName,
                        DriverInfo->ProductVersion,
                        DriverInfo->SpecialBuild,
                        NULL
                    };
                    PWCHAR Source[] =
                    {
                        L"Comments",
                        L"CompanyName",
                        L"FileDescription",
                        L"FileVersion",
                        L"InternalName",
                        L"LegalCopyright",
                        L"LegalTrademarks",
                        L"OriginalFilename",
                        L"PrivateBuild",
                        L"ProductName",
                        L"ProductVersion",
                        L"SpecialBuild",
                        NULL
                    };

                    //
                    // Read version properties.
                    //

                    for (Index = 0; Source[Index] && Destination[Index]; Index++)
                    {
                        swprintf(ValueName, L"\\StringFileInfo\\%04X%04X\\%s", ER_WD_LANG_ENGLISH, CodePage, Source[Index]);

                        if (VerQueryValue(VersionBuffer,
                                          ValueName,
                                          &VersionValue,
                                          &Length))
                        {
                            CopyMemory(Destination[Index],
                                       VersionValue,
                                       min(Length * sizeof (WCHAR), ER_WD_MAX_FILE_INFO_LENGTH * sizeof (WCHAR)));
                        }
                    }
                }
            }

            free(VersionBuffer);
        }
    }
}

UCHAR
GetFlags(
    IN HKEY Key
    )

/*++

Routine Description:

    This routine returns error signature flags based on registry
    values stored by watchdog.

Arguments:

    Key - Watchdog open key (device specific).

Return Value:

--*/

{
    UCHAR Flags;
    LONG WinStatus;
    DWORD Type;
    DWORD Value;
    DWORD Length;

    Flags = 0;

    //
    // Get watchdog values from registry.
    //

    Length = sizeof (DWORD);
    WinStatus = RegQueryValueEx(Key,
                                L"DisableBugcheck",
                                NULL,
                                &Type,
                                (LPBYTE)&Value,
                                &Length);

    if ((ERROR_SUCCESS == WinStatus) && Value)
    {
        Flags |= ER_WD_DISABLE_BUGCHECK_FLAG;
    }

    Length = sizeof (DWORD);
    WinStatus = RegQueryValueEx(Key,
                                L"DebuggerNotPresent",
                                NULL,
                                &Type,
                                (LPBYTE)&Value,
                                &Length);

    if ((ERROR_SUCCESS == WinStatus) && Value)
    {
        Flags |= ER_WD_DEBUGGER_NOT_PRESENT_FLAG;
    }

    Length = sizeof (DWORD);
    WinStatus = RegQueryValueEx(Key,
                                L"BugcheckTriggered",
                                NULL,
                                &Type,
                                (LPBYTE)&Value,
                                &Length);

    if ((ERROR_SUCCESS == WinStatus) && Value)
    {
        Flags |= ER_WD_BUGCHECK_TRIGGERED_FLAG;
    }

    return Flags;
}

VOID
GetPciId(
    IN HKEY Key,
    OUT PER_WD_PCI_ID PciId
    )

/*++

Routine Description:

    This routine collects PCI ID info.

Arguments:

    Key - Watchdog open key (device specific).

    PciId - Storage for PCI ID info.

Return Value:

--*/

{
    PWCHAR HardwareId;
    PWCHAR Token;
    PWCHAR EndPointer;
    LONG WinStatus;
    DWORD Type;
    DWORD Length;

    if (NULL == PciId)
    {
        return;
    }

    ZeroMemory(PciId, sizeof (ER_WD_PCI_ID));

    //
    // HardwareId is a MULTI_SZ - we need a bug buffer.
    //

    HardwareId = (PWCHAR)malloc(ER_WD_MAX_DATA_SIZE);

    if (NULL == HardwareId)
    {
        return;
    }

    //
    // Get HardwareId string from registry.
    //

    Length = ER_WD_MAX_DATA_SIZE;
    WinStatus = RegQueryValueEx(Key,
                                L"HardwareId",
                                NULL,
                                &Type,
                                (LPBYTE)HardwareId,
                                &Length);

    if (ERROR_SUCCESS != WinStatus)
    {
        free(HardwareId);
        return;
    }

    //
    // Make sure HardwareId is in uppercase.
    //

    _wcsupr(HardwareId);

    //
    // Get VendorId.
    //

    Token = wcsstr(HardwareId, L"VEN_");

    if (NULL != Token)
    {
        PciId->VendorId = (USHORT)wcstoul(Token + 4, &EndPointer, 16);
    }

    //
    // Get DeviceId.
    //

    Token = wcsstr(HardwareId, L"DEV_");

    if (NULL != Token)
    {
        PciId->DeviceId = (USHORT)wcstoul(Token + 4, &EndPointer, 16);
    }

    //
    // Get Revision.
    //

    Token = wcsstr(HardwareId, L"REV_");

    if (NULL != Token)
    {
        PciId->Revision = (UCHAR)wcstoul(Token + 4, &EndPointer, 16);
    }

    //
    // Get SubsystemId.
    //

    Token = wcsstr(HardwareId, L"SUBSYS_");

    if (NULL != Token)
    {
        PciId->SubsystemId = wcstoul(Token + 7, &EndPointer, 16);
    }

    free(HardwareId);
}

BOOL
SaveWatchdogEventData(
    IN HANDLE FileHandle,
    IN HKEY Key,
    IN PER_WD_DRIVER_INFO DriverInfo
    )

/*++

Routine Description:

    This routine transfers watchdog event data from registry to
    the watchdog event report file.

Arguments:

    FileHandle - Handle of open watchdog event report file.

    Key - Watchdog open key (device specific).

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    LONG WinStatus;
    DWORD Index;
    DWORD NameLength;
    DWORD DataSize;
    DWORD ReturnedSize;
    DWORD Type;
    WCHAR Name[ER_WD_MAX_NAME_LENGTH + 1];
    WCHAR DwordBuffer[20];
    PBYTE Data;
    BOOL Status = TRUE;

    ASSERT(INVALID_HANDLE_VALUE != FileHandle);

    Data = (PBYTE)malloc(ER_WD_MAX_DATA_SIZE);
    if (NULL == Data)
    {
        return FALSE;
    }

    //
    // Pull watchdog data from registry and write it to report.
    //

    for (Index = 0;; Index++)
    {
        //
        // Read watchdog registry value.
        //

        NameLength = ER_WD_MAX_NAME_LENGTH;
        DataSize = ER_WD_MAX_DATA_SIZE;

        WinStatus = RegEnumValue(Key,
                                 Index,
                                 Name,
                                 &NameLength,
                                 NULL,
                                 &Type,
                                 Data,
                                 &DataSize);

        if (ERROR_NO_MORE_ITEMS == WinStatus)
        {
            break;
        }

        if (ERROR_SUCCESS != WinStatus)
        {
            continue;
        }

        //
        // Pick up strings and dwords only.
        //

        if ((REG_EXPAND_SZ == Type) || (REG_SZ == Type) || (REG_MULTI_SZ == Type) || (REG_DWORD == Type))
        {
            //
            // Write registry entry to watchdog event file.
            //

            Status = WriteWatchdogEventFile(FileHandle, Name);
            if (TRUE != Status)
            {
                break;
            }

            Status = WriteWatchdogEventFile(FileHandle, L": ");
            if (TRUE != Status)
            {
                break;
            }

            if (REG_DWORD == Type)
            {
                swprintf(DwordBuffer, L"%u", *(PULONG)Data);
                Status = WriteWatchdogEventFile(FileHandle, DwordBuffer);
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWSTR)Data);
            }

            if (TRUE != Status)
            {
                break;
            }

            Status = WriteWatchdogEventFile(FileHandle, L"\r\n");
            if (TRUE != Status)
            {
                break;
            }
        }
    }

    //
    // Write driver info to report.
    //

    if (NULL != DriverInfo)
    {
        if (TRUE == Status)
        {
            swprintf((PWCHAR)Data, L"DriverFixedFileInfo: %08X %08X %08X %08X %08X %08X %08X %08X %08X %08X %08X %08X %08X\r\n",
                     DriverInfo->FixedFileInfo.dwSignature,
                     DriverInfo->FixedFileInfo.dwStrucVersion,
                     DriverInfo->FixedFileInfo.dwFileVersionMS,
                     DriverInfo->FixedFileInfo.dwFileVersionLS,
                     DriverInfo->FixedFileInfo.dwProductVersionMS,
                     DriverInfo->FixedFileInfo.dwProductVersionLS,
                     DriverInfo->FixedFileInfo.dwFileFlagsMask,
                     DriverInfo->FixedFileInfo.dwFileFlags,
                     DriverInfo->FixedFileInfo.dwFileOS,
                     DriverInfo->FixedFileInfo.dwFileType,
                     DriverInfo->FixedFileInfo.dwFileSubtype,
                     DriverInfo->FixedFileInfo.dwFileDateMS,
                     DriverInfo->FixedFileInfo.dwFileDateLS);

            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->Comments[0])
        {
            swprintf((PWCHAR)Data, L"DriverComments: %s\r\n", DriverInfo->Comments);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->CompanyName[0])
        {
            swprintf((PWCHAR)Data, L"DriverCompanyName: %s\r\n", DriverInfo->CompanyName);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->FileDescription[0])
        {
            swprintf((PWCHAR)Data, L"DriverFileDescription: %s\r\n", DriverInfo->FileDescription);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->FileVersion[0])
        {
            swprintf((PWCHAR)Data, L"DriverFileVersion: %s\r\n", DriverInfo->FileVersion);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->InternalName[0])
        {
            swprintf((PWCHAR)Data, L"DriverInternalName: %s\r\n", DriverInfo->InternalName);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->LegalCopyright[0])
        {
            swprintf((PWCHAR)Data, L"DriverLegalCopyright: %s\r\n", DriverInfo->LegalCopyright);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->LegalTrademarks[0])
        {
            swprintf((PWCHAR)Data, L"DriverLegalTrademarks: %s\r\n", DriverInfo->LegalTrademarks);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->OriginalFilename[0])
        {
            swprintf((PWCHAR)Data, L"DriverOriginalFilename: %s\r\n", DriverInfo->OriginalFilename);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->PrivateBuild[0])
        {
            swprintf((PWCHAR)Data, L"DriverPrivateBuild: %s\r\n", DriverInfo->PrivateBuild);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->ProductName[0])
        {
            swprintf((PWCHAR)Data, L"DriverProductName: %s\r\n", DriverInfo->ProductName);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->ProductVersion[0])
        {
            swprintf((PWCHAR)Data, L"DriverProductVersion: %s\r\n", DriverInfo->ProductVersion);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }

        if ((TRUE == Status) && DriverInfo->SpecialBuild[0])
        {
            swprintf((PWCHAR)Data, L"DriverSpecialBuild: %s\r\n", DriverInfo->SpecialBuild);
            Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
        }
    }

    if (NULL != Data)
    {
        free(Data);
        Data = NULL;
    }

    return Status;
}

BOOL
WatchdogEventHandler(
    IN BOOL NotifyPcHealth
    )

/*++

Routine Description:

    This is the boot time routine to handle pending watchdog events.

Arguments:

    NotifyPcHealth - TRUE if we should report event to PC Health, FALSE otherwise.

Return Value:

    TRUE if watchdog event(s) found and reported to PC Health, FALSE otherwise.

--*/

{
    HKEY Key;
    UCHAR Flags;
    ULONG WinStatus;
    ULONG Type;
    ULONG Length;
    ULONG Shutdown;
    ULONG EventFlag;
    ULONG Index;
    ULONG FileVersionMS;
    ULONG FileVersionLS;
    USHORT Signature;
    SEventInfoW EventInfo;
    HANDLE FileHandle;
    WCHAR WatchdogReport[MAX_PATH];
    WCHAR Stage1Url[ER_WD_MAX_URL_LENGTH + 1];
    WCHAR Stage2Url[ER_WD_MAX_URL_LENGTH + 1];
    WCHAR CorpPath[MAX_PATH];
    PWCHAR MessageBuffer;
    PWCHAR DescriptionBuffer;
    PWCHAR DeviceDescription;
    PWCHAR FinalReport;
    PWCHAR DriverName;
    PWCHAR String000;
    PWCHAR String001;
    PWCHAR String002;
    PWCHAR String003;
    PWCHAR String004;
    PWCHAR String005;
    BOOL LogStatus;
    BOOL ReturnStatus;
    HINSTANCE Instance;
    PER_WD_DRIVER_INFO DriverInfo;
    ER_WD_PCI_ID PciId;

    MessageBuffer = NULL;
    DescriptionBuffer = NULL;
    DeviceDescription = NULL;
    FinalReport = NULL;
    String000 = NULL;
    String001 = NULL;
    String002 = NULL;
    String003 = NULL;
    String004 = NULL;
    String005 = NULL;
    ReturnStatus = FALSE;
    Instance = (HINSTANCE)GetModuleHandle(NULL);
    DriverInfo = NULL;
    DriverName = NULL;

    //
    // Check if Watchdog\Display key present.
    // Note: Key not present = dirty shutdown but no watchdog event = we don't care.
    //

    WinStatus = RegOpenKey(HKEY_LOCAL_MACHINE,
                           SUBKEY_WATCHDOG_DISPLAY,
                           &Key);

    if (ERROR_SUCCESS == WinStatus)
    {
        EventFlag = 0;

        //
        // Check for clean shutdown indicator.
        //
        // TODO: Use NtQueryLastShutdownType() once implemented.
        //

        Length = sizeof (Shutdown);
        WinStatus = RegQueryValueEx(Key,
                                    L"Shutdown",
                                    NULL,
                                    &Type,
                                    (LPBYTE)&Shutdown,
                                    &Length);

        if (ERROR_SUCCESS != WinStatus)
        {
            //
            // Value not there - assume dirty shutdown.
            //

            Shutdown = 0;
        }

        //
        // If dirty shutdown check if watchdog display event captured.
        //

        if (!Shutdown)
        {
            Length = sizeof (EventFlag);
            WinStatus = RegQueryValueEx(Key,
                                        L"EventFlag",
                                        NULL,
                                        &Type,
                                        (LPBYTE)&EventFlag,
                                        &Length);

            if (ERROR_SUCCESS != WinStatus)
            {
                //
                // Value not there - watchdog display event not captured.
                //

                EventFlag = 0;
            }
        }

        if (EventFlag)
        {
            //
            // Report watchdog event to PC Health if requested.
            //

            if (NotifyPcHealth)
            {
                //
                // Allocate storage for localized strings.
                //

                String000 = (PWCHAR)malloc(ER_WD_MAX_STRING);
                String001 = (PWCHAR)malloc(ER_WD_MAX_STRING);
                String002 = (PWCHAR)malloc(ER_WD_MAX_STRING);
                String003 = (PWCHAR)malloc(ER_WD_MAX_STRING);
                String004 = (PWCHAR)malloc(ER_WD_MAX_STRING);
                String005 = (PWCHAR)malloc(ER_WD_MAX_STRING);

                //
                // Load localized strings from resources.
                //
                // Note: It's OK to pass NULL so we don't have to validate buffers.
                //

                LoadString(Instance, IDS_000, String000, ER_WD_MAX_STRING);
                LoadString(Instance, IDS_001, String001, ER_WD_MAX_STRING);
                LoadString(Instance, IDS_002, String002, ER_WD_MAX_STRING);
                LoadString(Instance, IDS_003, String003, ER_WD_MAX_STRING);
                LoadString(Instance, IDS_004, String004, ER_WD_MAX_STRING);
                LoadString(Instance, IDS_005, String005, ER_WD_MAX_STRING);

                //
                // Allocate and get DriverInfo data.
                //

                DriverInfo = (PER_WD_DRIVER_INFO)malloc(sizeof (ER_WD_DRIVER_INFO));

                if (NULL != DriverInfo)
                {
                    GetDriverInfo(Key, L".dll", DriverInfo);
                }

                //
                // Get PCI ID info.
                //

                GetPciId(Key, &PciId);

                //
                // Get watchdog event flags.
                //

                Flags = GetFlags(Key);

                //
                // Generate event signature.
                //

                Signature = GenerateSignature(&PciId, DriverInfo);

                //
                // Create watchdog report file.
                //

                LogStatus = CreateWatchdogEventFileName(WatchdogReport);

                if (TRUE == LogStatus)
                {
                    FileHandle = CreateWatchdogEventFile(WatchdogReport);

                    if (INVALID_HANDLE_VALUE == FileHandle)
                    {
                        LogStatus = FALSE;
                    }
                }
                else
                {
                    FileHandle = INVALID_HANDLE_VALUE;
                }

                if (TRUE == LogStatus)
                {
                    LogStatus = WriteWatchdogEventFile(
                        FileHandle,
                        L"\r\n//\r\n"
                        L"// The driver for the display device got stuck in an infinite loop. This\r\n"
                        L"// usually indicates a problem with the device itself or with the device\r\n"
                        L"// driver programming the hardware incorrectly. Please check with your\r\n"
                        L"// display device vendor for any driver updates.\r\n"
                        L"//\r\n\r\n");
                }

                if (TRUE == LogStatus)
                {
                    LogStatus = SaveWatchdogEventData(FileHandle, Key, DriverInfo);
                }

                if (INVALID_HANDLE_VALUE != FileHandle)
                {
                    CloseHandle(FileHandle);
                }

                FinalReport = (TRUE == LogStatus) ? WatchdogReport : NULL;

                //
                // Get device description.
                //

                DescriptionBuffer = NULL;
                DeviceDescription = NULL;
                Length = 0;

                WinStatus = RegQueryValueEx(Key,
                                            L"DeviceDescription",
                                            NULL,
                                            &Type,
                                            NULL,
                                            &Length);

                if (ERROR_SUCCESS == WinStatus)
                {
                    DescriptionBuffer = (PWCHAR)malloc(Length);

                    if (NULL != DescriptionBuffer)
                    {
                        WinStatus = RegQueryValueEx(Key,
                                                    L"DeviceDescription",
                                                    NULL,
                                                    &Type,
                                                    (LPBYTE)DescriptionBuffer,
                                                    &Length);
                    }
                    else
                    {
                        Length = 0;
                    }
                }

                if ((ERROR_SUCCESS == WinStatus) && (0 != Length))
                {
                    DeviceDescription = DescriptionBuffer;
                }
                else
                {
                    DeviceDescription = String004;
                    Length = (ER_WD_MAX_STRING + 1) * sizeof (WCHAR);
                }

                Length += 2 * ER_WD_MAX_STRING * sizeof (WCHAR);
                          

                MessageBuffer = (PWCHAR)malloc(Length);

                if (NULL != MessageBuffer)
                {
                    swprintf(MessageBuffer,
                             L"%s%s%s",
                             String003,
                             DeviceDescription,
                             String005);
                }

                //
                // Create URLs and corporate path.
                //

                if (DriverInfo)
                {
                    DriverName = DriverInfo->DriverName;
                    FileVersionMS = DriverInfo->FixedFileInfo.dwFileVersionMS;
                    FileVersionLS = DriverInfo->FixedFileInfo.dwFileVersionLS;
                }
                else
                {
                    DriverName = L"Unknown";
                    FileVersionMS = 0;
                    FileVersionLS = 0;
                }

                swprintf(Stage1Url,
                         L"\r\nStage1URL=/StageOne/Drivers_Display/%04X%04X%02X%08X/%s/%u_%u_%u_%u/%04X%02X%02X",
                         PciId.VendorId,
                         PciId.DeviceId,
                         PciId.Revision,
                         PciId.SubsystemId,
                         DriverName,
                         (USHORT)(FileVersionMS >> 16),
                         (USHORT)(FileVersionMS & 0xffff),
                         (USHORT)(FileVersionLS >> 16),
                         (USHORT)(FileVersionLS & 0xffff),
                         Signature,
                         Flags,
                         0xea);

                swprintf(Stage2Url,
                         L"\r\nStage2URL=/dw/StageTwo.asp?szAppName=Drivers.Display&szAppVer=%04X%04X%02X%08X&"
                         L"szModName=%s&szModVer=%u.%u.%u.%u&Offset=%04X%02X%02X",
                         PciId.VendorId,
                         PciId.DeviceId,
                         PciId.Revision,
                         PciId.SubsystemId,
                         DriverName,
                         (USHORT)(FileVersionMS >> 16),
                         (USHORT)(FileVersionMS & 0xffff),
                         (USHORT)(FileVersionLS >> 16),
                         (USHORT)(FileVersionLS & 0xffff),
                         Signature,
                         Flags,
                         0xea);

                swprintf(CorpPath,
                         L"\\Drivers.Display\\%04X%04X%02X%08X\\%s\\%u.%u.%u.%u\\%04X%02X%02X",
                         PciId.VendorId,
                         PciId.DeviceId,
                         PciId.Revision,
                         PciId.SubsystemId,
                         DriverName,
                         (USHORT)(FileVersionMS >> 16),
                         (USHORT)(FileVersionMS & 0xffff),
                         (USHORT)(FileVersionLS >> 16),
                         (USHORT)(FileVersionLS & 0xffff),
                         Signature,
                         Flags,
                         0xea);

                //
                // Dots are not allowed in stage1 URL, replace with _ then append .htm.
                //

                for (Index = 0; Stage1Url[Index] != UNICODE_NULL; Index++)
                {
                    if (Stage1Url[Index] == L'.')
                    {
                        Stage1Url[Index] = L'_';
                    }
                }

                wcscat(Stage1Url, L".htm");

                //
                // Fill in event record.
                //
                // TODO: Add minidump to watchdog event reports, but only when it contains stack trace
                // from the spinning thread. This is for SKUs < Server, since we're not bugchecking
                // for Server and above. We should also look into snapshot report, this can be good
                // piece of data to send along.
                //

                ZeroMemory(&EventInfo, sizeof (EventInfo));

                EventInfo.cbSEI = sizeof (EventInfo);
                EventInfo.wszEventName = L"Thread Stuck in Device Driver";
                EventInfo.wszErrMsg = String002;
                EventInfo.wszHdr = String001;
                EventInfo.wszTitle = String000;
                EventInfo.wszStage1 = Stage1Url;
                EventInfo.wszStage2 = Stage2Url;
                EventInfo.wszFileList = FinalReport;
                EventInfo.wszEventSrc = NULL;
                EventInfo.wszCorpPath = CorpPath;
                EventInfo.wszPlea = MessageBuffer;
                EventInfo.wszSendBtn = NULL;
                EventInfo.wszNoSendBtn = NULL;
                EventInfo.fUseLitePlea = FALSE;
                EventInfo.fUseIEForURLs = TRUE;
                EventInfo.fNoBucketLogs = FALSE;
                EventInfo.fNoDefCabLimit = FALSE;

                //
                // Notify PC Health.
                //

                PCHPFNotifyFault(eetUseEventInfo, NULL, &EventInfo);

                //
                // Clean up buffers.
                //

                if (NULL != DescriptionBuffer)
                {
                    free(DescriptionBuffer);
                    DescriptionBuffer = NULL;
                }

                if (NULL != MessageBuffer)
                {
                    free(MessageBuffer);
                    MessageBuffer = NULL;
                }

                if (NULL != String000)
                {
                    free(String000);
                    String000 = NULL;
                }

                if (NULL != String001)
                {
                    free(String001);
                    String001 = NULL;
                }

                if (NULL != String002)
                {
                    free(String002);
                    String002 = NULL;
                }

                if (NULL != String003)
                {
                    free(String003);
                    String003 = NULL;
                }

                if (NULL != String004)
                {
                    free(String004);
                    String004 = NULL;
                }

                if (NULL != String005)
                {
                    free(String005);
                    String005 = NULL;
                }

                if (NULL != DriverInfo)
                {
                    free(DriverInfo);
                    DriverInfo = NULL;
                }

                //
                // We trapped watchdog event and notified PC Health, set ReturnStatus to reflect this.
                //

                ReturnStatus = TRUE;
            }
        }

        //
        // Knock down watchdog's EventFlag. We do this after registering our
        // event with PC Health.
        //

        RegDeleteValue(Key, L"EventFlag");
        RegCloseKey(Key);
    }

    //
    // TODO: Handle additional device classes here when supported.
    //

    return ReturnStatus;
}

BOOL
WriteWatchdogEventFile(
    IN HANDLE FileHandle,
    IN PWSTR String
    )

/*++

Routine Description:

    This routine writes a string to watchdog event report file.

Arguments:

    FileHandle - Handle of open watchdog event report file.

    String - Points to the string to write.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    DWORD Size;
    DWORD ReturnedSize;
    PCHAR MultiByte;
    BOOL Status;

    ASSERT(INVALID_HANDLE_VALUE != FileHandle);
    ASSERT(NULL != String);

    //
    // Get buffer size for translated string.
    //

    Size = WideCharToMultiByte(CP_ACP,
                               0,
                               String,
                               -1,
                               NULL,
                               0,
                               NULL,
                               NULL);

    if (Size <= 1)
    {
        return TRUE;
    }

    MultiByte = (PCHAR)malloc(Size);

    if (NULL == MultiByte)
    {
        return FALSE;
    }

    Size = WideCharToMultiByte(CP_ACP,
                               0,
                               String,
                               -1,
                               MultiByte,
                               Size,
                               NULL,
                               NULL);

    if (Size > 0)
    {
        Status = WriteFile(FileHandle,
                           MultiByte,
                           Size - 1,
                           &ReturnedSize,
                           NULL);
    }
    else
    {
        ASSERT(FALSE);
        Status = FALSE;
    }

    free(MultiByte);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\setup\msisetup.c ===
//depot/Lab01_N/sdktools/cabs/symbolcd/tools/setup/msisetup.c#16 - edit change 2216 (text)
#include <windows.h> 
#include <stdio.h>
#include <stdlib.h>

#include "tchar.h"
#include "shlwapi.h"


#define MSI_BUILD_VER_ALPHA    816  // MSI version for Win2K Alpha WIN2KMINBUILD

#define MSI_BUILD_VER_X86     1029  // Latest MSI version for Win2K x86
#define WIN2K_MIN_BUILD_X86   2183  // Win2K RC3 
#define WIN2K_MIN_BUILD_ALPHA 2128  // Last supported Win2K Alpha build

typedef struct _CommandArgs {
    BOOL    QuietInstall;
    BOOL    StressInstall;
    BOOL    UIStressInstall;
    TCHAR   szInstDir[ _MAX_PATH*sizeof(TCHAR) ];
    TCHAR   szMsiName[ _MAX_PATH*sizeof(TCHAR) ];
    TCHAR   szProductRegKey[ _MAX_PATH*sizeof(TCHAR) ];
} COMMAND_ARGS, *PCOMMAND_ARGS;


// Function prototypes

BOOL
RunCommand(
    PTCHAR szCommandLine,
    HINSTANCE hInst
);

BOOL
GetCommandLineArgs(
    LPTSTR szCmdLine, 
    PCOMMAND_ARGS pComArgs
);


TCHAR szMSIInstFile[_MAX_PATH*sizeof(TCHAR)];
TCHAR szPkgInstFile[_MAX_PATH*sizeof(TCHAR)];
TCHAR szPkgInstCommand[_MAX_PATH*2*sizeof(TCHAR)];


// For stress installs, this command will be used to
// remove the current package but don't remove its
// files, if the current package with the same
// product ID is already installed.

TCHAR szPkgRemoveCommand[_MAX_PATH*2*sizeof(TCHAR)];
TCHAR szPkgRemoveCommand2[_MAX_PATH*2*sizeof(TCHAR)];

// If the first install fails, stress tries again without
// the quiet switch before giving a pop-up
TCHAR szPkgInstCommandNoQuiet[_MAX_PATH*2*sizeof(TCHAR)];

TCHAR szCommandFullPath[_MAX_PATH*sizeof(TCHAR)];


int WINAPI WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPTSTR lpszCmdLine,
        int nCmdShow
) 

{
    OSVERSIONINFO VersionInfo;
    SYSTEM_INFO SystemInfo;
    BOOL rc;
    BOOL MSIIsInstalled;
    PTCHAR ch;
    TCHAR szBuf[1000];
    TCHAR szSystemDirectory[_MAX_PATH];

    COMMAND_ARGS ComArgs;
    HKEY hKey;
    DWORD dwrc;
    DWORD dwSizeValue;
    DWORD dwType;

    HANDLE hFile;
    WIN32_FIND_DATA FindFileData;

    MSIIsInstalled=FALSE;

    // Get this info for later use
    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VersionInfo );
    GetSystemInfo( &SystemInfo );

    // Parse through the command line for the various arguments

    rc = GetCommandLineArgs(lpszCmdLine, &ComArgs );

    if (!rc) {
        _stprintf( szBuf, _T("%s%s%s%s%s"),
                   _T(" Usage: \n\n"),
                   _T(" setup.exe [ /q [ /i <InstDir> ] ]\n\n"),
                   _T(" /q\tGive pop-ups only for errors\n\n"),
                   _T(" /i\tInstall to <Instdir>\n\n"),
                   _T(" /n\tInstall <msi package Name>\n\n")
                 );
        MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"), 0 );
        return (1);
    } 

    //
    // Set the full path to this setup.exe
    //

    if (GetModuleFileName( NULL, szCommandFullPath, MAX_PATH ) == 0) {
        return(1);
    }

    // Put an end of string after the directory that this was
    // started from
   
    ch = szCommandFullPath + _tcslen(szCommandFullPath);
    while ( *ch != _T('\\') &&  ( ch > szCommandFullPath ) ) ch--; 
    *ch=_T('\0');

    // This will become the full path and name of the MSI file to install
    _tcscpy( szMSIInstFile, szCommandFullPath);

    // Set the full path and name of the msi package
    _tcscpy( szPkgInstFile, szCommandFullPath);
    _tcscat( szPkgInstFile, _T("\\") );
    _tcscat( szPkgInstFile, ComArgs.szMsiName );

    // See if the package exists
    hFile = FindFirstFile( szPkgInstFile, &FindFileData );
    if ( hFile == INVALID_HANDLE_VALUE ) {

        _stprintf( szBuf, _T("%s%s%s%s"),
                   _T(" The Microsoft Debugging Tools package "),
                   szPkgInstFile,
                   _T(" does not exist.\n  Setup cannot contine"),
                   _T(" for this platform.")
                 );
        MessageBox( NULL,
                    szBuf,
                    _T("Microsoft Debugging Tools"),
                    0
                  );
        return(1);

    }
    FindClose(hFile);

    // Set the command for installing the package
    _tcscpy( szPkgInstCommand, _T("msiexec /i ") );
    _tcscat( szPkgInstCommand, szPkgInstFile );

    // Set the command for removing the current package
    // that is installed.

    _tcscpy( szBuf, _T("") );
    dwrc = RegOpenKeyEx( HKEY_CURRENT_USER,
                       ComArgs.szProductRegKey,
                       0,
                       KEY_QUERY_VALUE,
                       &hKey
                     );

    if ( dwrc == ERROR_SUCCESS ) {

        _tcscpy( szBuf, _T("") );
        dwSizeValue=sizeof(szBuf);
        RegQueryValueEx ( hKey, 
                          _T("ProductCode"),
                          0,
                          &dwType,
                          (PBYTE)szBuf,
                          &dwSizeValue
                        );

        RegCloseKey(hKey);
    } 

    // Set the command to remove the current package
    // that has an Add/Remove link in the start menu
    _tcscpy(szPkgRemoveCommand2, _T("") );
    if ( _tcslen(szBuf) > 0 ) {
       _tcscpy(szPkgRemoveCommand2, _T("msiexec /x ") );
       _tcscat(szPkgRemoveCommand2, szBuf);
       _tcscat(szPkgRemoveCommand2, _T(" REMOVETHEFILES=0 /qn") );
    }

    // Set the command to remove the current package so that
    // this program works like it used to.
    _tcscpy(szPkgRemoveCommand, _T("msiexec /x ") );
    _tcscat(szPkgRemoveCommand, szPkgInstFile );
    _tcscat(szPkgRemoveCommand, _T(" REMOVETHEFILES=0 /qn") ); 

    // Add a user override installation directory
    if ( _tcslen(ComArgs.szInstDir) > 0 ) {
        _tcscat( szPkgInstCommand, _T(" INSTDIR=") );
        _tcscat( szPkgInstCommand, ComArgs.szInstDir );
    } else if ( ComArgs.UIStressInstall ) {
        GetSystemDirectory( szSystemDirectory, _MAX_PATH );
        _tcscat( szPkgInstCommand, _T(" INSTDIR=") );
        _tcscat( szPkgInstCommand, szSystemDirectory );
    }

    // If this is an "undocumented" stress install
    // don't remove the files of the previous install
    // when you upgrade
    // FEATURESTOREMOVE should never actually need to be used, unless
    // the user has something screwed up on his system where the registry
    // key and products installed don't agree, or MSI thinks there's more
    // products installed than the registry key we look at.

    if ( ComArgs.StressInstall ) {
        _tcscat( szPkgInstCommand, _T(" FEATURESTOREMOVE=\"\"") );
    }

    // If this is an "undocumented" UI stress install
    // only install the private extensions
    if ( ComArgs.UIStressInstall ) {
        _tcscat( szPkgInstCommand, 
                _T(" ADDLOCAL=DBG.DbgExts.Internal,DBG.NtsdFix.Internal") );
    }

    // Add the quiet switch
    // Save the command without a quiet switch
    _tcscpy( szPkgInstCommandNoQuiet, szPkgInstCommand);
    if ( ComArgs.QuietInstall ) {
        _tcscat( szPkgInstCommand, _T(" /qn") );
    } 

    // Do version checks for whether msi is already installed
    //
    // If this is Windows 2000 and build number is >=
    // WIN2K_MIN_BUILD_X86 then MSI is installed
    // Don't try to run instmsi.exe on Windows 2000 because
    // you will get file system protection pop-ups.
    //

    if ( (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
         (VersionInfo.dwMajorVersion >= 5.0 ) ) {

        switch (SystemInfo.wProcessorArchitecture) {

        case PROCESSOR_ARCHITECTURE_ALPHA:

          if (VersionInfo.dwBuildNumber < WIN2K_MIN_BUILD_ALPHA) {

            // The version of MSI that is on early builds of Windows
            // 2000 shouldn't be trusted for installs.

            _stprintf( szBuf, "%s",
                       _T("The Debugging Tools does not install on ")
                       _T("this version of Alpha Windows 2000.  Please upgrade ")
                       _T("your system to Windows 2000 Beta 3 ")
                       _T("before trying to install this package.")
                     );

            MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"),0);
            return(1);
          }
          break;

        case PROCESSOR_ARCHITECTURE_INTEL:

          if (VersionInfo.dwBuildNumber < WIN2K_MIN_BUILD_X86 ) {

            // The version of MSI that is on early builds of Windows
            // 2000 shouldn't be trusted for installs.

            _stprintf( szBuf, "%s%s%s%s",
                       _T("The Debugging Tools does not install on "),
                       _T("this version of Windows 2000.  Please upgrade "),
                       _T("your system to a retail version of Windows 2000 "),
                       _T("before trying to install this package.")
                     );

            MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"),0);
            return(1);
          }
          break;

        case PROCESSOR_ARCHITECTURE_IA64:
            break;

        default:
            _stprintf( szBuf, "%s",
                       _T("Unknown computer architecture.")
                     );

            MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"),0);
            return(1);
        }

        MSIIsInstalled = TRUE;

    } else if ( SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {

        //
        // For Intel OS's prior to Windows 2000, run instmsi.exe
        //
    
        //
        // NT4 X86
        //
        if ( VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) {
            _tcscat( szMSIInstFile,
                     _T("\\setup\\winnt\\i386\\instmsi.exe /q") );
        } 

        //
        // Win9x
        //
        else if ( VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) {
            _tcscat( szMSIInstFile,
                     _T("\\setup\\win9x\\instmsi.exe /q") );
        } else {

          _stprintf( szBuf, _T("%s %s"),  
                     _T("The Microsoft Debugging Tools does not install"),
                     _T("on this system.")
                   );
                          
          MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"),0); 
          return(1);
        }

    } else if ( SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA ) {
         if ( VersionInfo.dwBuildNumber >= WIN2K_MIN_BUILD_ALPHA ) { 
             MSIIsInstalled = TRUE;

         } else {
             _tcscat( szMSIInstFile,
                      _T("\\setup\\winnt\\alpha\\instmsi.exe /q"));
         }

    } else {
        MessageBox( NULL,
          _T("The Microsoft Debugging Tools cannot be installed on this system."), 
          _T("Microsoft Debugging Tools"),
          0 );

        return(1);
    }


    // Install MSI if it is not already installed
 
    if ( !MSIIsInstalled ) {

        if ( RunCommand( szMSIInstFile, hInstance ) ) {
            MSIIsInstalled = TRUE;
        }
        if (!MSIIsInstalled) {
            _stprintf( szBuf, _T("%s %s %s %s"), 
                       _T("The Windows Installer could not be installed"),
                       _T("on this system.  This is required before"),
                       _T("installing the Microsoft Debugging Tools package."),
                       _T("Try logging in as an administrator and try again.")
                     );

            MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"),0); 
            return(1);

        } 
    } 

    //
    // Now, if this is a stress install,
    // Try to remove the current package in case it is installed
    //

    if ( ComArgs.StressInstall ) {
      if ( _tcslen(szPkgRemoveCommand2) > 0 ) {
          RunCommand( szPkgRemoveCommand2, hInstance);
      }
      RunCommand( szPkgRemoveCommand, hInstance );
      if ( !RunCommand( szPkgInstCommand, hInstance ) ) {

          // Try again without the quiet switch, so that the user will get 
          // a pop-up from dbg.msi and quit calling us
          _stprintf( szBuf, _T("%s %s %s %s"),
                     _T("There were errors when trying to install the"),
                     _T("debuggers.\nClick OK to attempt an install of the"),
                     _T("debuggers with\n the GUI and you will see the"),
                     _T("correct error message.")
                   );
          MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"), 0);
          if ( !RunCommand( szPkgInstCommandNoQuiet, hInstance ) ) {
              _stprintf( szBuf, _T("%s %s %s"),
                     _T("There were still errors in the install.\n"),
                     _T("Please see http://dbg/triage/top10.html #2 "),
                     _T("for more help.")
                   );
              MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"), 0);
              return(1);
          }

      }
      return(0);
    } 

    //
    // Now, install the package dbg.msi
    //

    if ( !RunCommand( szPkgInstCommand, hInstance ) ) {
        if (ComArgs.QuietInstall) {
            _stprintf( szBuf, _T("%s %s %s %s"),
                   _T("There were errors in the Debugging Tools install."),
                   _T(" Please run "),
                   szPkgInstFile,
                   _T("to receive more detailed error information.")
                 );
            MessageBox( NULL, szBuf, _T("Microsoft Debugging Tools"),0);
        }
        return(1);


    }
    
    return(0);
}


//
// RunCommand
//
// Purpose: Install MSI
//
// Return Values:
//    0  error
//    1  successful

BOOL 
RunCommand( PTCHAR szCommandLine,
            HINSTANCE  hInst)
{
BOOL rc;
DWORD dwRet;
PROCESS_INFORMATION ProcInfo = {0};
STARTUPINFO SI= {0};


// Spawn the command line specified by szCommandLine
rc = CreateProcess(NULL,            
                   szCommandLine,
                   NULL,
                   NULL,
                   FALSE,
                   CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS, 
                   NULL,
                   NULL,
                   &SI,
                   &ProcInfo );

if ( (!rc) || (!ProcInfo.hProcess) ) {
        goto cleanup;
}

//
// Wait for command to complete ... Give it 20 minutes
//

dwRet = WaitForSingleObject(ProcInfo.hProcess, 1200000); 

if (dwRet != WAIT_OBJECT_0) {
    rc = FALSE;
    goto cleanup;

} 

// Get the process exit code

rc = GetExitCodeProcess( ProcInfo.hProcess, &dwRet); 

if (dwRet == ERROR_SUCCESS ) {
    rc = 1;
} else {
    rc = 0;
}

cleanup:

if (ProcInfo.hProcess)
    CloseHandle(ProcInfo.hProcess);            

return (rc);
}

BOOL
GetCommandLineArgs(
    LPTSTR szCmdLine, 
    PCOMMAND_ARGS pComArgs
) 
{

    ULONG  length;
    ULONG  i,cur;
    BOOL   SkippingSpaces=FALSE;
    BOOL   QuotedString=FALSE;
    BOOL   NeedSecond=FALSE;
    BOOL   rc=TRUE;
    LPTSTR *argv;
    ULONG  argc=0;
    LPTSTR szCmdLineTmp;
    TCHAR  c;

    ZeroMemory(pComArgs, sizeof(COMMAND_ARGS));


    // Create a line to use for temporary marking
    length=_tcslen(szCmdLine);

    szCmdLineTmp= (LPTSTR)malloc( (_tcslen(szCmdLine) + 1) * sizeof(TCHAR) );
    if (szCmdLineTmp==NULL) 
    {
        return FALSE;
    }
    _tcscpy(szCmdLineTmp, szCmdLine);

    // Count the number of arguments
    // Create a argv and argc

    SkippingSpaces=TRUE;
    QuotedString=FALSE;
    argc=0;
    for ( i=0; i<length; i++ ) 
    {
        c=szCmdLineTmp[i];
        switch (szCmdLineTmp[i]) {
        case _T(' '):
        case _T('\t'): if (QuotedString)
                       {
                           break;
                       } 
                       if (!SkippingSpaces)
                       {
                           SkippingSpaces=TRUE;
                       } 
                       break;

        case _T('\"'): if (QuotedString)
                       {
                           // This is the end of a quoted string
                           // The next character to read in is a space
                           QuotedString=FALSE;
                           SkippingSpaces=TRUE;
                           if ( i < (length-1) && 
                                szCmdLineTmp[i+1] != _T(' ') &&
                                szCmdLineTmp[i+1] != _T('\t') )
                           {
                               // This is the end of a quote and its not
                               // followed by a space
                               rc=FALSE;
                               goto CommandLineFinish;
                           }
                           break;
                       } 

                       if (SkippingSpaces) {

                           // This is the beginning of a quoted string
                           // Its a new argument and it follows spaces
                           argc++;
                           SkippingSpaces=FALSE;
                           QuotedString=TRUE;
                           break;
                       }

                       // This is an error -- This is a quote in the middle of a string
                       rc=FALSE;
                       goto CommandLineFinish;
                       break;

        default:       if (QuotedString) {
                           break;
                       } 
                       if (SkippingSpaces) {
                           argc++;
                           SkippingSpaces=FALSE;
                       }
                       break;
        }
    }

    if (QuotedString) 
    {
        // Make sure that all the quotes got a finished pair
        rc=FALSE;
        goto CommandLineFinish;
    }

    // Now, create argv with the correct number of entries
    
    argv=(LPTSTR*)malloc(argc * sizeof(LPTSTR) );
    if (argv==NULL)
    {
        free(szCmdLineTmp);
        return FALSE;
    }

    // Set argv to point to the correct place on szCmdLineTmp
    // and put '\0' after each token.

    SkippingSpaces=TRUE;
    QuotedString=FALSE;
    argc=0;
    for ( i=0; i<length; i++ ) 
    {
        c=szCmdLineTmp[i];
        switch (szCmdLineTmp[i]) {
        case _T(' '):
        case _T('\t'): if (QuotedString) 
                       {
                           break;
                       } 
                       if (!SkippingSpaces)
                       {
                           szCmdLineTmp[i]='\0';
                           SkippingSpaces=TRUE;
                       } 
                       break;
        
        case _T('\"'): if (QuotedString)
                       {
                           // This is the end of a quoted string
                           // The next character to read in is a space
                           QuotedString=FALSE;
                           SkippingSpaces=TRUE;
                           szCmdLineTmp[i+1]=_T('\0');
                           break;
                       } 

                       if (SkippingSpaces) {

                           // This is the beginning of a quoted string
                           // Its a new argument and it follows spaces

                           argv[argc]=szCmdLineTmp+i;
                           argc++;
                           SkippingSpaces=FALSE;
                           QuotedString=TRUE;
                           break;
                       }

                       // This is an error -- This is a quote in the middle of a string
                       rc=FALSE;
                       goto CommandLineFinish;
                       break;



        default:       if (QuotedString) 
                       {
                           break;
                       } 
                       if (SkippingSpaces) {
                           argv[argc]=szCmdLineTmp+i;
                           argc++;
                           SkippingSpaces=FALSE;
                       }
                       break;
        }
    }
   
    // Now, parse the arguments 

    NeedSecond=FALSE;

    for (i=0; i<argc; i++) {

      if (!NeedSecond) 
      {
          if ( (argv[i][0] != '/') && (argv[i][0] != '-') ) 
          {
              rc=FALSE;
              goto CommandLineFinish;
          }

          if ( _tcslen(argv[i]) != 2 )
          {
              rc=FALSE;
              goto CommandLineFinish;
          }
              
          c=argv[i][1];
          switch ( c ) 
          {
              case 'q':
              case 'Q': pComArgs->QuietInstall=TRUE;
                        break;
              case 'i':
              case 'I': NeedSecond=TRUE;;
                        break;
              case 'n':
              case 'N': NeedSecond=TRUE;
                        break;
              case 'z':
              case 'Z': pComArgs->StressInstall=TRUE;
                        break;
              case 'u':
              case 'U': pComArgs->UIStressInstall=TRUE;
                        pComArgs->StressInstall=TRUE;
                        break;
              default:  {
                            rc=FALSE;
                            goto CommandLineFinish;
                        }
          }

      } else {

           NeedSecond = FALSE;
           switch ( c ) 
           {
               case 'i':
               case 'I': _tcscpy(pComArgs->szInstDir,argv[i]);  
                         break;
               case 'n':
               case 'N': _tcscpy(pComArgs->szMsiName,argv[i]);
                         break;
               default:  {
                             rc=FALSE;
                             goto CommandLineFinish;
                         }
          }
      }

    }

    if (pComArgs->szMsiName[0] == 0) 
    {
#ifdef BUILD_X86
        _tcscpy(pComArgs->szMsiName, _T("dbg_x86.msi") );
        _tcscpy(pComArgs->szProductRegKey, _T("Software\\Microsoft\\DebuggingTools\\AddRemove") );
#elif defined(BUILD_IA64)
        _tcscpy(pComArgs->szMsiName, _T("dbg_ia64.msi") );
        _tcscpy(pComArgs->szProductRegKey, _T("Software\\Microsoft\\DebuggingTools64\\AddRemove") );
#endif
    }

CommandLineFinish:

    free(szCmdLineTmp);
    free(argv);
    
    return (rc);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\snapshot\snapshot.cpp ===
#define UNICODE
#define _UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h> 
#include <mountmgr.h>
#include <winioctl.h>
#include <ntddvol.h>
#include <ntddscsi.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <tchar.h>
#ifdef UNICODE
# define _stnprintf _snwprintf
#else
# define _stnprintf _snprintf
#endif

#define BUFFER_SIZE 64*1024*sizeof(TCHAR)
#define MIN_BUFFER_SIZE 1024*sizeof(TCHAR)
#define MAX_BUFFER_SIZE 10*1024*1024*sizeof(TCHAR)
#define MAXSTR 4*1024
#define DEFAULT_HISTORYFILES 10

VOID
PrintLoadedDrivers(
                  HANDLE hFile
                  );

ULONG
LogSystemSnapshot(
                 LPCTSTR *lpStrings,
                 PLONG BuffSize,
                 LPTSTR lpszBuff
                 );

UINT LogSystemSnapshotToFile(
                            HANDLE hFile
                            );

void WriteToLogFileW(
					 HANDLE hFile,
					 LPCWSTR lpwszInput
					 )
{
	DWORD dwWriten;
	BYTE *bBuffer;
	int nLen, nRetLen;

	nLen = wcslen(lpwszInput);
	bBuffer = (BYTE*)malloc(nLen * sizeof(WCHAR));
	if(bBuffer == 0)
		return;

	nRetLen = WideCharToMultiByte(CP_ACP, 0, lpwszInput, -1, (LPSTR)bBuffer, nLen * sizeof(WCHAR), NULL, NULL);
	if(nRetLen != 0){
		WriteFile(hFile, (LPVOID)bBuffer, nRetLen-1, &dwWriten, NULL);
	}
	free(bBuffer);
}

void WriteToLogFileA(
					 HANDLE hFile,
					 LPCSTR lpszInput
					 )
{
	DWORD dwWriten;
	WriteFile(hFile, (LPVOID)lpszInput, strlen(lpszInput), &dwWriten, NULL);
}


void WriteToLogFile(
                   HANDLE hFile,
                   LPCTSTR lpszInput
                   )
{
    DWORD dwWriten;
#ifdef _UNICODE
	WriteToLogFileW(hFile, lpszInput);
#else
    WriteToLogFileA(hFile, lpszInput);
#endif //_UNICODE
}

void 
LogLogicalDriveInfo(
	 HANDLE hFile
	);

void 
LogHardwareInfo(
	 HANDLE hFile
	);

void
LogPhyicalDiskInfo(
    HANDLE hFile
    );

void
LogHotfixes(
    HANDLE hFile
    );

void
LogOsInfo(
    HANDLE hFile
    );

void
LogBIOSInfo(
    HANDLE hFile
    );

NTSTATUS 
SnapshotRegOpenKey(
    IN LPCWSTR lpKeyName,
	IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE KeyHandle
    );

NTSTATUS
SnapshotRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPCWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    );

NTSTATUS
SnapshotRegEnumKey(
    IN HANDLE KeyHandle,
	IN ULONG Index,
    OUT LPWSTR lpKeyName,
    OUT PULONG  lpNameLength
    );

void
DeleteOldFiles(
			   LPCTSTR lpPath
			   );

ULONG CurrentBufferSize;

LPCTSTR StateTable[] = {
    TEXT("Initialized"),
    TEXT("Ready"),
    TEXT("Running"),
    TEXT("Standby"),
    TEXT("Terminated"),
    TEXT("Wait:"),
    TEXT("Transition"),
    TEXT("Unknown"),
    TEXT("Unknown"),
    TEXT("Unknown"),
    TEXT("Unknown"),
    TEXT("Unknown")
};

LPCTSTR WaitTable[] = {
    TEXT("Executive"),
    TEXT("FreePage"),
    TEXT("PageIn"),
    TEXT("PoolAllocation"),
    TEXT("DelayExecution"),
    TEXT("Suspended"),
    TEXT("UserRequest"),
    TEXT("Executive"),
    TEXT("FreePage"),
    TEXT("PageIn"),
    TEXT("PoolAllocation"),
    TEXT("DelayExecution"),
    TEXT("Suspended"),
    TEXT("UserRequest"),
    TEXT("EventPairHigh"),
    TEXT("EventPairLow"),
    TEXT("LpcReceive"),
    TEXT("LpcReply"),
    TEXT("VirtualMemory"),
    TEXT("PageOut"),
    TEXT("Spare1"),
    TEXT("Spare2"),
    TEXT("Spare3"),
    TEXT("Spare4"),
    TEXT("Spare5"),
    TEXT("Spare6"),
    TEXT("Spare7"),
    TEXT("Unknown"),
    TEXT("Unknown"),
    TEXT("Unknown")
};

LPCTSTR Empty = TEXT(" ");

BOOLEAN fUserOnly = TRUE;
BOOLEAN fSystemOnly = TRUE;
BOOLEAN fVerbose = FALSE;
BOOLEAN fPrintIt;

TCHAR lpszBuffer[BUFFER_SIZE];
TCHAR lpszFileName[MAX_PATH * sizeof(TCHAR)] ;
TCHAR lpszHdrBuffer[MAX_PATH* sizeof(TCHAR)] ;

ULONG LogSystemSnapshot(DWORD Flags, LPCTSTR *lpStrings, PLONG BuffSize, LPTSTR lpszBuff)
{
    SYSTEMTIME systime;
    TIME_ZONE_INFORMATION TimeZone ;
    LPTSTR lpszTemp;
    HANDLE hFile = NULL;
    UINT res = 0;
    LONG lBuffSize ;

    GetLocalTime(&systime);

    lBuffSize = *BuffSize ;
    *BuffSize = 0 ;

    // Set up the log path %SYSTEMDIR%\Logfiles\Shutdown
    GetSystemDirectory(lpszFileName, MAX_PATH);
    lstrcat(lpszFileName, TEXT("\\LogFiles"));  // making sure the path ..
    CreateDirectory(lpszFileName, NULL);        
    lstrcat(lpszFileName, TEXT("\\ShutDown"));  //  .. exists
    CreateDirectory(lpszFileName, NULL);    

	DeleteOldFiles(lpszFileName);

    lstrcat(lpszFileName, TEXT("\\ShutDown_"));
    lpszTemp = (LPTSTR)(lpszFileName + (lstrlen(lpszFileName)));
    _stnprintf(lpszTemp,MAX_PATH - (lstrlen(lpszFileName)),
                TEXT("%4d%02d%02d%02d%02d%02d.state"),  
                systime.wYear, systime.wMonth, systime.wDay,
                systime.wHour, systime.wMinute, systime.wSecond);

    hFile = CreateFile(lpszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return HandleToUlong(INVALID_HANDLE_VALUE);

    GetTimeZoneInformation(&TimeZone);

    _stnprintf(lpszHdrBuffer, MAX_PATH,
             TEXT("System State Snapshot of System %s on Shutdown\n")
             TEXT("Initiated by %s at %d-%d-%d %d:%d:%d (%s(%d))\n") 
             TEXT("Reason = %s/%s\n")
             TEXT("Type = %s\n")
             TEXT("Comment = %s\n\n"),
             lpStrings[1],lpStrings[0],
             systime.wYear, systime.wMonth, systime.wDay,
             systime.wHour, systime.wMinute, systime.wSecond,
             TimeZone.StandardName,TimeZone.Bias,
             lpStrings[2],lpStrings[3],lpStrings[4],lpStrings[5]);

    WriteToLogFile(hFile, lpszHdrBuffer);

    // Ok write the snapshot to the file
    res = LogSystemSnapshotToFile(hFile);

    CloseHandle(hFile);
    if (lBuffSize >= (LONG)_tcslen(lpszFileName)) {
        wsprintf(lpszBuff,TEXT("%s"),lpszFileName);
        *BuffSize = _tcslen(lpszFileName) ;
    }
    return res;
}

UINT LogSystemSnapshotToFile(
        HANDLE hFile
        )
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    BYTE* LargeBuffer1;
    NTSTATUS status;
    ULONG i;
    ULONG TotalOffset = 0;
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDayInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;
    LARGE_INTEGER Time;
    ANSI_STRING pname;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SIZE_T SumCommit;
    SIZE_T SumWorkingSet;
 
    if (hFile == INVALID_HANDLE_VALUE)
        return 1;

    //SetFileApisToOEM();

    LargeBuffer1 = (BYTE*) VirtualAlloc (NULL,
                                         MAX_BUFFER_SIZE,
                                         MEM_RESERVE,
                                         PAGE_READWRITE);
    if (LargeBuffer1 == NULL) {
        WriteToLogFile(hFile, TEXT("Memory allocation failed\n"));
        return 0;
    }

    if (VirtualAlloc (LargeBuffer1,
                      BUFFER_SIZE,
                      MEM_COMMIT,
                      PAGE_READWRITE) == NULL) {
        VirtualFree(LargeBuffer1, MAX_BUFFER_SIZE, MEM_RELEASE);
        WriteToLogFile(hFile, TEXT("Memory commit failed\n"));
        return 0;
    }

    CurrentBufferSize = BUFFER_SIZE;

    status = NtQuerySystemInformation(
                                     SystemBasicInformation,
                                     &BasicInfo,
                                     sizeof(SYSTEM_BASIC_INFORMATION),
                                     NULL
                                     );

    if (!NT_SUCCESS(status)) {
        VirtualFree(LargeBuffer1, MAX_BUFFER_SIZE, MEM_RELEASE | MEM_DECOMMIT);
        wsprintf(lpszBuffer, TEXT("Query info failed %lx\n"),status);
        WriteToLogFile(hFile, lpszBuffer);
        return(status);
    }

    status = NtQuerySystemInformation(
                                     SystemTimeOfDayInformation,
                                     &TimeOfDayInfo,
                                     sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                                     NULL
                                     );

    if (!NT_SUCCESS(status)) {
        VirtualFree(LargeBuffer1, MAX_BUFFER_SIZE, MEM_RELEASE | MEM_DECOMMIT);
        wsprintf(lpszBuffer, TEXT("Query info failed %lx\n"),status);
        WriteToLogFile(hFile, lpszBuffer);
        return(status);
    }

    Time.QuadPart = TimeOfDayInfo.CurrentTime.QuadPart -
                    TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields ( &Time, &UpTime);

    _stnprintf(lpszBuffer, BUFFER_SIZE,
               TEXT("memory: %4ld kb  uptime:%3ld %2ld:%02ld:%02ld.%03ld \n\n"),
             BasicInfo.NumberOfPhysicalPages * (BasicInfo.PageSize/1024),
             UpTime.Day,
             UpTime.Hour,
             UpTime.Minute,
             UpTime.Second,
             UpTime.Milliseconds);
    WriteToLogFile(hFile, lpszBuffer);

    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)LargeBuffer1;
    status = NtQuerySystemInformation(
                                     SystemPageFileInformation,
                                     PageFileInfo,
                                     CurrentBufferSize,
                                     NULL
                                     );

    if (NT_SUCCESS(status)) {

        //
        // Print out the page file information.
        //

        if (PageFileInfo->TotalSize == 0) {
            WriteToLogFile(hFile, TEXT("no page files in use\n"));
        } else {
            for (; ; ) {
                _stnprintf(lpszBuffer, BUFFER_SIZE,
                           TEXT("PageFile: %ls\n"), PageFileInfo->PageFileName.Buffer);
                WriteToLogFile(hFile, lpszBuffer);
                _stnprintf(lpszBuffer, BUFFER_SIZE,
                           TEXT("\tCurrent Size: %6ld kb  Total Used: %6ld kb   Peak Used %6ld kb\n"),
                         PageFileInfo->TotalSize*(BasicInfo.PageSize/1024),
                         PageFileInfo->TotalInUse*(BasicInfo.PageSize/1024),
                         PageFileInfo->PeakUsage*(BasicInfo.PageSize/1024));
                WriteToLogFile(hFile, lpszBuffer);
                if (PageFileInfo->NextEntryOffset == 0) {
                    break;
                }
                PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(
                                                             (PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
            }
        }
    }

    retry:
    status = NtQuerySystemInformation(
                                     SystemProcessInformation,
                                     LargeBuffer1,
                                     CurrentBufferSize,
                                     NULL
                                     );

    if (status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        if (VirtualAlloc (LargeBuffer1,
                          CurrentBufferSize,
                          MEM_COMMIT,
                          PAGE_READWRITE) == NULL) {
            WriteToLogFile(hFile, TEXT("Memory commit failed\n"));
            VirtualFree(LargeBuffer1, MAX_BUFFER_SIZE, MEM_DECOMMIT | MEM_RELEASE);
            return 0;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status)) {

        _stnprintf(lpszBuffer, BUFFER_SIZE, TEXT("Query info failed %lx\n"),status);
        WriteToLogFile(hFile,lpszBuffer);
        return(status);
    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //

    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    while (TRUE) {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
    }

    status = NtQuerySystemInformation(
                                     SystemPerformanceInformation,
                                     &PerfInfo,
                                     sizeof(PerfInfo),
                                     NULL
                                     );

    if ( !NT_SUCCESS(status) ) {
        VirtualFree(LargeBuffer1, MAX_BUFFER_SIZE, MEM_DECOMMIT | MEM_RELEASE);
        _stnprintf(lpszBuffer, BUFFER_SIZE, TEXT("Query perf Failed %lx\n"),status);
        WriteToLogFile(hFile, lpszBuffer);
        return 0;
    }

    status = NtQuerySystemInformation(
                                     SystemFileCacheInformation,
                                     &FileCache,
                                     sizeof(FileCache),
                                     NULL
                                     );

    if ( !NT_SUCCESS(status) ) {
        VirtualFree(LargeBuffer1, MAX_BUFFER_SIZE, MEM_DECOMMIT | MEM_RELEASE);
        _stnprintf(lpszBuffer, BUFFER_SIZE, TEXT("Query file cache Failed %lx\n"),status);
        WriteToLogFile(hFile, lpszBuffer);
        return 0;
    }

    NtQuerySystemInformation(
                            SystemBasicInformation,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            NULL
                            );

    SumWorkingSet += FileCache.CurrentSize/1024;
    _stnprintf (lpszBuffer, BUFFER_SIZE,
              TEXT("\n Memory:%7ldK Avail:%7ldK  TotalWs:%7ldK InRam Kernel:%5ldK P:%5ldK\n"),
              BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
              PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
              SumWorkingSet,
              (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
              (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
             );
    WriteToLogFile(hFile, lpszBuffer);
    _stnprintf(lpszBuffer, BUFFER_SIZE,
             TEXT(" Commit:%7ldK/%7ldK Limit:%7ldK Peak:%7ldK  Pool N:%5ldK P:%5ldK\n"),
             PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
             SumCommit,
             PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
             PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
             PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
             PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
            );
    WriteToLogFile(hFile, lpszBuffer);
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    WriteToLogFile(hFile, TEXT("\n"));


    WriteToLogFile(hFile, TEXT("    User Time   Kernel Time    Ws   Faults  Commit Pri Hnd Thd Pid Name\n"));

    _stnprintf(lpszBuffer, BUFFER_SIZE,
               TEXT("                           %6ld %8ld                         %s\n"),
             FileCache.CurrentSize/1024,
             FileCache.PageFaultCount,
             TEXT("File Cache")
            );
    WriteToLogFile(hFile, lpszBuffer);

    while (TRUE) {
        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
        }

        RtlTimeToElapsedTimeFields ( &ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields ( &ProcessInfo->KernelTime, &KernelTime);

        _stnprintf(lpszBuffer, BUFFER_SIZE,
                   TEXT("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld"),
                 UserTime.Hour,
                 UserTime.Minute,
                 UserTime.Second,
                 UserTime.Milliseconds,
                 KernelTime.Hour,
                 KernelTime.Minute,
                 KernelTime.Second,
                 KernelTime.Milliseconds
                );
        WriteToLogFile(hFile, lpszBuffer);

        _stnprintf(lpszBuffer, BUFFER_SIZE,
                   TEXT("%6ld %8ld %7ld"),
                 ProcessInfo->WorkingSetSize / 1024,
                 ProcessInfo->PageFaultCount,
                 ProcessInfo->PrivatePageCount / 1024
                );
        WriteToLogFile(hFile, lpszBuffer);

#ifdef _UNICODE
        _stnprintf(lpszBuffer, BUFFER_SIZE,
                   TEXT(" %2ld %4ld %3ld %3ld %S\n"),
                 ProcessInfo->BasePriority,
                 ProcessInfo->HandleCount,
                 ProcessInfo->NumberOfThreads,
                 HandleToUlong(ProcessInfo->UniqueProcessId),
                 ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
                                                                      ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
                );
#else
		        _stnprintf(lpszBuffer, BUFFER_SIZE,
                   TEXT(" %2ld %4ld %3ld %3ld %s\n"),
                 ProcessInfo->BasePriority,
                 ProcessInfo->HandleCount,
                 ProcessInfo->NumberOfThreads,
                 HandleToUlong(ProcessInfo->UniqueProcessId),
                 ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
                                                                      ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
                );
#endif //_UNICODE
        WriteToLogFile(hFile, lpszBuffer);

        if ( pname.Buffer ) {
            RtlFreeAnsiString(&pname);
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
    }

    //
    // Beginning of normal old style pstat output
    //
    /*
    if (0==1) {
        TotalOffset = 0;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
        WriteToLogFile(hFile, TEXT("\n"));
        while (TRUE) {
            fPrintIt = FALSE;
            if ( (ProcessInfo->ImageName.Buffer && fUserOnly) ||
                 (ProcessInfo->ImageName.Buffer==NULL && fSystemOnly) ) {

                fPrintIt = TRUE;

                pname.Buffer = NULL;
                if ( ProcessInfo->ImageName.Buffer ) {
                    RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
                }
                wsprintf(lpszBuffer, TEXT("pid:%3lx pri:%2ld Hnd:%5ld Pf:%7ld Ws:%7ldK %s\n"),
                         HandleToUlong(ProcessInfo->UniqueProcessId),
                         ProcessInfo->BasePriority,
                         ProcessInfo->HandleCount,
                         ProcessInfo->PageFaultCount,
                         ProcessInfo->WorkingSetSize / 1024,
                         ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
                                                                              ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
                        );
                WriteToLogFile(hFile, lpszBuffer);

                if ( pname.Buffer ) {
                    RtlFreeAnsiString(&pname);
                }

            }
            i = 0;
            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
            if (ProcessInfo->NumberOfThreads) {
                WriteToLogFile(hFile, TEXT(" tid pri Ctx Swtch StrtAddr    User Time  Kernel Time  State\n"));
            }
            while (i < ProcessInfo->NumberOfThreads) {
                RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);

                RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
                if ( fPrintIt ) {

                    wsprintf(lpszBuffer, TEXT(" %3lx  %2ld %9ld %p"),
                             ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                             ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority,
                             ThreadInfo->ContextSwitches,
                             ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress
                            );
                    WriteToLogFile(hFile, lpszBuffer);

                    wsprintf(lpszBuffer, TEXT(" %2ld:%02ld:%02ld.%03ld %2ld:%02ld:%02ld.%03ld"),
                             UserTime.Hour,
                             UserTime.Minute,
                             UserTime.Second,
                             UserTime.Milliseconds,
                             KernelTime.Hour,
                             KernelTime.Minute,
                             KernelTime.Second,
                             KernelTime.Milliseconds
                            );
                    WriteToLogFile(hFile, lpszBuffer);

                    wsprintf(lpszBuffer, TEXT(" %s%s\n"),
                             StateTable[ThreadInfo->ThreadState],
                             (ThreadInfo->ThreadState == 5) ?
                             WaitTable[ThreadInfo->WaitReason] : Empty
                            );
                    WriteToLogFile(hFile, lpszBuffer);
                }
                ThreadInfo += 1;
                i += 1;
            }
            if (ProcessInfo->NextEntryOffset == 0) {
                break;
            }
            TotalOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
            if ( fPrintIt ) {
                WriteToLogFile(hFile, TEXT("\n"));
            }
        }
    }
    */

    PrintLoadedDrivers(hFile);

	//Now let us log the hardware and logical drive info
	WriteToLogFile(hFile, TEXT("\n"));
	LogOsInfo(hFile);
	LogHotfixes(hFile);
	LogBIOSInfo(hFile);
	LogHardwareInfo(hFile);
	LogPhyicalDiskInfo(hFile);
	LogLogicalDriveInfo(hFile);

    return 0;
}


typedef struct _MODULE_DATA {
    ULONG CodeSize;
    ULONG DataSize;
    ULONG BssSize;
    ULONG RoDataSize;
    ULONG ImportDataSize;
    ULONG ExportDataSize;
    ULONG ResourceDataSize;
    ULONG PagedSize;
    ULONG InitSize;
    ULONG CheckSum;
    ULONG TimeDateStamp;
} MODULE_DATA, *PMODULE_DATA;

typedef struct _LOADED_IMAGE {
    BYTE* MappedAddress;
    PIMAGE_NT_HEADERS FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    int NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
} LOADED_IMAGE, *PLOADED_IMAGE;


VOID
SumModuleData(
             PMODULE_DATA Sum,
             PMODULE_DATA Current
             )
{
    Sum->CodeSize           += Current->CodeSize;
    Sum->DataSize           += Current->DataSize;
    Sum->BssSize            += Current->BssSize;
    Sum->RoDataSize         += Current->RoDataSize;
    Sum->ImportDataSize     += Current->ImportDataSize;
    Sum->ExportDataSize     += Current->ExportDataSize;
    Sum->ResourceDataSize   += Current->ResourceDataSize;
    Sum->PagedSize          += Current->PagedSize;
    Sum->InitSize           += Current->InitSize;
}
VOID
PrintModuleSeperator(
                    HANDLE hFile
                    )
{
    WriteToLogFile(hFile, TEXT("------------------------------------------------------------------------------\n"));
}

VOID
PrintModuleHeader(
                 HANDLE hFile
                 )
{
    WriteToLogFile(hFile, TEXT("  ModuleName Load Addr   Code    Data   Paged           LinkDate\n"));
    PrintModuleSeperator(hFile);
}

VOID
GetModuleData(
             HANDLE hFile,
             PMODULE_DATA Mod
             )
{
    HANDLE hMappedFile;
    PIMAGE_DOS_HEADER DosHeader;
    LOADED_IMAGE LoadedImage;
    ULONG SectionAlignment;
    PIMAGE_SECTION_HEADER Section;
    int i;
    ULONG Size;

    hMappedFile = CreateFileMapping(
                                   hFile,
                                   NULL,
                                   PAGE_READONLY,
                                   0,
                                   0,
                                   NULL
                                   );
    if ( !hMappedFile ) {
        return;
    }

    LoadedImage.MappedAddress = (BYTE*) MapViewOfFile(
                                                     hMappedFile,
                                                     FILE_MAP_READ,
                                                     0,
                                                     0,
                                                     0
                                                     );
    CloseHandle(hMappedFile);

    if ( !LoadedImage.MappedAddress ) {
        return;
    }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    DosHeader = (PIMAGE_DOS_HEADER)LoadedImage.MappedAddress;

    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
    }

    LoadedImage.FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

    if ( LoadedImage.FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
    }

    LoadedImage.NumberOfSections = LoadedImage.FileHeader->FileHeader.NumberOfSections;
    LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS));
    LoadedImage.LastRvaSection = LoadedImage.Sections;

    //
    // Walk through the sections and tally the dater
    //

    SectionAlignment = LoadedImage.FileHeader->OptionalHeader.SectionAlignment;

    for (Section = LoadedImage.Sections,i=0; i<LoadedImage.NumberOfSections; i++,Section++) {
        Size = Section->Misc.VirtualSize;

        if (Size == 0) {
            Size = Section->SizeOfRawData;
        }

        Size = (Size + SectionAlignment - 1) & ~(SectionAlignment - 1);

        if (!memcmp((const char*) Section->Name,"PAGE", 4 )) {
            Mod->PagedSize += Size;
        } else if (!_stricmp((const char*) Section->Name,"INIT" )) {
            Mod->InitSize += Size;
        } else if (!_stricmp((const char*) Section->Name,".bss" )) {
            Mod->BssSize = Size;
        } else if (!_stricmp((const char*) Section->Name,".edata" )) {
            Mod->ExportDataSize = Size;
        } else if (!_stricmp((const char*) Section->Name,".idata" )) {
            Mod->ImportDataSize = Size;
        } else if (!_stricmp((const char*) Section->Name,".rsrc" )) {
            Mod->ResourceDataSize = Size;
        } else if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
            Mod->CodeSize += Size;
        } else if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
            Mod->DataSize += Size;
        } else if (Section->Characteristics & IMAGE_SCN_MEM_READ) {
            Mod->RoDataSize += Size;
        } else {
            Mod->DataSize += Size;
        }
    }

    Mod->CheckSum = LoadedImage.FileHeader->OptionalHeader.CheckSum;
    Mod->TimeDateStamp = LoadedImage.FileHeader->FileHeader.TimeDateStamp;

    UnmapViewOfFile(LoadedImage.MappedAddress);
    return;

}

TCHAR lpszTimeBuffer[MAX_PATH];


VOID
PrintLoadedDrivers(
                  HANDLE hFile
                  )
{

    ULONG i, j, ulLen;
    LPSTR s;
	TCHAR ModuleName[MAX_PATH];
    HANDLE FileHandle;
    TCHAR KernelPath[MAX_PATH];
    TCHAR DriversPath[MAX_PATH];
    LPTSTR ModuleInfo;
    ULONG ModuleInfoLength;
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    NTSTATUS Status;
    MODULE_DATA Sum;
    MODULE_DATA Current;
    __int64 timeStamp;
    FILETIME ft;
    SYSTEMTIME st;

    WriteToLogFile(hFile, TEXT("\n"));
    //
    // Locate system drivers.
    //

    ModuleInfoLength = 64000;
    while (1) {
        ModuleInfo = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ModuleInfoLength * sizeof(TCHAR));
        if (ModuleInfo == NULL) {
            wsprintf (lpszBuffer, TEXT("Failed to allocate memory for module information buffer of size %d\n"),
                      ModuleInfoLength);
            WriteToLogFile(hFile, lpszBuffer);
            return;
        }
        Status = NtQuerySystemInformation (
                                          SystemModuleInformation,
                                          ModuleInfo,
                                          ModuleInfoLength * sizeof(TCHAR),
                                          &ReturnedLength);

        if (!NT_SUCCESS(Status)) {
            HeapFree(GetProcessHeap(), 0, (LPVOID)ModuleInfo);
            if (Status == STATUS_INFO_LENGTH_MISMATCH &&
                ReturnedLength > ModuleInfoLength * sizeof(TCHAR)) {
                ModuleInfoLength = ReturnedLength / sizeof(TCHAR);
                continue;
            }
            _stnprintf(lpszBuffer, BUFFER_SIZE,
                       TEXT("query system info failed status - %lx\n"),Status);
            WriteToLogFile(hFile, lpszBuffer);
            return;
        }
        break;
    }
    GetSystemDirectory(KernelPath,sizeof(KernelPath)/sizeof(TCHAR));
    lstrcpy(DriversPath, KernelPath);
    lstrcat(DriversPath,TEXT("\\Drivers"));
    ZeroMemory(&Sum,sizeof(Sum));
    PrintModuleHeader(hFile);

    Modules = (PRTL_PROCESS_MODULES)ModuleInfo;
    Module = &Modules->Modules[ 0 ];
    for (i=0; i<Modules->NumberOfModules; i++) {

        ZeroMemory(&Current,sizeof(Current));
        s = (LPSTR)&Module->FullPathName[ Module->OffsetToFileName ];
        //
        // try to open the file
        //

        SetCurrentDirectory(KernelPath);
#ifdef _UNICODE
		MultiByteToWideChar(CP_ACP, 0, s, -1, ModuleName, MAX_PATH);
#else
		strcpy(ModuleName, s);
#endif //_UNICODE
        FileHandle = CreateFile(
                               ModuleName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL
                               );

        if ( FileHandle == INVALID_HANDLE_VALUE ) {
            SetCurrentDirectory(DriversPath);

            FileHandle = CreateFile(
                                   ModuleName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                   );
        }

        if ( FileHandle != INVALID_HANDLE_VALUE ) {
            GetModuleData(FileHandle,&Current);
            CloseHandle(FileHandle);
        }
		else 
			continue;

        SumModuleData(&Sum,&Current);
        if (Current.TimeDateStamp) {
            timeStamp = Current.TimeDateStamp;
            timeStamp += (__int64)11644444799; //difference between filetime and time_t in seconds.
            timeStamp *= 10000000; // turn into 100 nano seconds.
            ft.dwLowDateTime = (DWORD)timeStamp;
            for (j = 0; j < 32; j++)
                timeStamp /= 2;
            ft.dwHighDateTime = (DWORD)timeStamp;
            FileTimeToSystemTime(&ft, &st);

            _stnprintf(lpszTimeBuffer, BUFFER_SIZE,
                       TEXT("%d-%d-%d %d:%d:%d\n"), st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);

			_stnprintf(lpszBuffer, BUFFER_SIZE, TEXT("%12s %p %7d %7d %7d "),//%12s %p 
                     ModuleName,
                     Module->ImageBase,
                     Current.CodeSize,
                     Current.DataSize,
                     Current.PagedSize
                    );
            WriteToLogFile(hFile, lpszBuffer);
            WriteToLogFile(hFile, lpszTimeBuffer);
        } else {
            _stnprintf(lpszBuffer, BUFFER_SIZE, TEXT("%12s %p %7d %7d %7d %S"),
                     ModuleName,
                     Module->ImageBase,
                     Current.CodeSize,
                     Current.DataSize,
                     Current.PagedSize,
                     "\n"
                    );
            WriteToLogFile(hFile, lpszBuffer);
        }
        Module++;
    }
    PrintModuleSeperator(hFile);
    _stnprintf(lpszBuffer, BUFFER_SIZE, TEXT("%12S          %7d %7d %7d\n"),
             "Total",
             Sum.CodeSize,
             Sum.DataSize,
             Sum.PagedSize
            );
    WriteToLogFile(hFile, lpszBuffer);
    HeapFree(GetProcessHeap(), 0, (LPVOID)ModuleInfo);
}


void 
LogLogicalDriveInfo(
	 HANDLE hFile
	)
{
	DWORD dwDriveMask;
	static TCHAR* tszDrives = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
	ULARGE_INTEGER i64FreeBytesToCaller;
	ULARGE_INTEGER i64TotalBytesToCaller;
	ULARGE_INTEGER i64TotalFreeBytesOnDrive;
	int iMask;
	TCHAR tszDrive[5];		//Buffer for drive such as "A:\".
	TCHAR tszBuffer[1024]; //buffer to contain info for one logical drive.
	int i;

	dwDriveMask = GetLogicalDrives();
	if(dwDriveMask != 0){
		WriteToLogFile(hFile, TEXT("Logical Drive Info:\n"));
	}

	for(i = 0; i < (int)_tcslen(tszDrives); i++){
		iMask = dwDriveMask & 0x1;
		_stprintf(tszDrive, TEXT("%c:\\"), tszDrives[i]);
		dwDriveMask >>= 1;
		if(iMask && GetDriveType(tszDrive) == DRIVE_FIXED
			&& GetDiskFreeSpaceEx(tszDrive, &i64FreeBytesToCaller, &i64TotalBytesToCaller, &i64TotalFreeBytesOnDrive))
		{
			_stprintf(tszBuffer, TEXT("\t%s\n")
					 TEXT("\t\t Free Disk Space(Bytes): %I64d\n")
					 TEXT("\t\tTotal Disk Space(Bytes): %I64d\n"),
					 tszDrive,
					 i64TotalFreeBytesOnDrive,
					 i64TotalBytesToCaller
					);
			WriteToLogFile(hFile, tszBuffer);
		}
	}
	WriteToLogFile(hFile, TEXT("\n"));
}

NTSTATUS 
SnapshotRegOpenKey(
    IN LPCWSTR lpKeyName,
	IN ACCESS_MASK DesiredAccess, 
    OUT PHANDLE KeyHandle
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      KeyName;
    RtlInitUnicodeString( &KeyName, lpKeyName );
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
	NTSTATUS Status;
    InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

	Status = (NTSTATUS)NtOpenKey( KeyHandle, KEY_READ, &ObjectAttributes );

    return Status;
}

NTSTATUS
SnapshotRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPCWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    NTSTATUS Status;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + Length;
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) malloc(BufferLength);
    if (KeyValueInformation == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = NtQueryValueKey(
                KeyHandle,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                ResultLength
                );
    if (NT_SUCCESS(Status)) {

        RtlCopyMemory(KeyValue, 
                      KeyValueInformation->Data, 
                      KeyValueInformation->DataLength
                     );

        *ResultLength = KeyValueInformation->DataLength;
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > Length) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength++] = 0;
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength] = 0;
            *ResultLength = KeyValueInformation->DataLength + sizeof(WCHAR);
        }
    }
    free(KeyValueInformation);

    return Status;
}

NTSTATUS
SnapshotRegEnumKey(
    IN HANDLE KeyHandle,
	IN ULONG Index,
    OUT LPWSTR lpKeyName,
    OUT PULONG  lpNameLength
    )
{
	UNICODE_STRING ValueName;
    ULONG BufferLength;
    NTSTATUS Status;
    PKEY_BASIC_INFORMATION pKeyBasicInformation;
    RtlInitUnicodeString( &ValueName, lpKeyName );

	BufferLength = FIELD_OFFSET(KEY_BASIC_INFORMATION, Name) + *lpNameLength;
    pKeyBasicInformation = (PKEY_BASIC_INFORMATION) malloc(BufferLength);
    if (pKeyBasicInformation == NULL) {
        return STATUS_NO_MEMORY;
    }

	Status = NtEnumerateKey(
		KeyHandle,
		Index,
		KeyBasicInformation,
		(PVOID)pKeyBasicInformation,
		BufferLength,
		lpNameLength
		);

	if (NT_SUCCESS(Status)) {
        RtlCopyMemory(lpKeyName, 
                      pKeyBasicInformation->Name, 
                      pKeyBasicInformation->NameLength
                     );

        *lpNameLength = pKeyBasicInformation->NameLength;
		if(*lpNameLength > 0)
			lpKeyName[(*lpNameLength) - 1] = L'\0';
		else lpKeyName[0] = L'\0';
    }
    free((BYTE*)pKeyBasicInformation);

    return Status;
}

void 
LogHardwareInfo(
	 HANDLE hFile
	)
{
	LPCWSTR ComputerNameKey = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName";
	LPCWSTR ComputerNameValsz = L"ComputerName";
	LPCWSTR ProcessorKey = L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor";
	LPCWSTR ProcessorSpeedValdw = L"~MHz";
	LPCWSTR ProcessorIdentifierValsz = L"Identifier";
	LPCWSTR ProcessorVendorValsz = L"VendorIdentifier";
	LPCWSTR NetcardKey = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards";
	LPCWSTR NetcardDescsz = L"Description";
	LPCWSTR NetcardServiceNamesz = L"ServiceName";
	HANDLE  hKey;
	HANDLE  hSubkey;
	WCHAR szVal[MAX_PATH];
	WCHAR szSubkey[MAX_PATH];
	DWORD dwVal;
	DWORD dwSize;
	DWORD dwSubkeyIndex;
	DWORD dwRes;
	NTSTATUS Status = STATUS_SUCCESS;

	//Get Computer Name
	Status = SnapshotRegOpenKey(ComputerNameKey, KEY_READ, &hKey);
	if(!NT_SUCCESS(Status)){
		WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information\n\n"));
		return;
	}
	dwSize = MAX_PATH * sizeof(WCHAR);
	Status = SnapshotRegQueryValueKey(hKey, ComputerNameValsz, dwSize, szVal, &dwSize);

	if(!NT_SUCCESS(Status)){
		NtClose(hKey);
		WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information\n\n"));
		return;
	}
	NtClose(hKey);
	WriteToLogFile(hFile, TEXT("Active Computer Name: "));
	szVal[dwSize] = '\0';
	WriteToLogFileW(hFile, szVal);
	WriteToLogFile(hFile, TEXT("\n"));

	//Get Processor Info
	Status = SnapshotRegOpenKey(ProcessorKey, KEY_READ, &hKey);
	if(!NT_SUCCESS(Status)){
		WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information\n\n"));
		return;
	}
	dwSubkeyIndex = 0;
	dwSize = MAX_PATH * sizeof(WCHAR);

	WriteToLogFile(hFile, TEXT("Processor Info:\n"));
	Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
	while(NT_SUCCESS(Status)){
		wcscpy(szVal, ProcessorKey);
		wcscat(szVal, L"\\");
		wcscat(szVal, szSubkey);
		Status = SnapshotRegOpenKey(szVal, KEY_READ, &hSubkey);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information\n\n"));
			return;
		}
		dwSize = sizeof(DWORD);
		Status = SnapshotRegQueryValueKey(hSubkey, ProcessorSpeedValdw, dwSize, &dwVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			NtClose(hSubkey);
			WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information\n\n"));
			return;
		}
		_stnprintf(lpszBuffer, BUFFER_SIZE,
                       TEXT("\tProcessor %s:\n")
					   TEXT("\t\tSpeed(~MHz): %d\n"), 
					   szSubkey, dwVal);
		WriteToLogFile(hFile, lpszBuffer);

		dwSize = MAX_PATH * sizeof(WCHAR);
		Status = SnapshotRegQueryValueKey(hSubkey, ProcessorIdentifierValsz, dwSize, szVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			NtClose(hSubkey);
			WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information\n\n"));
			return;
		}
		WriteToLogFile(hFile, TEXT("\t\tIdentifier: "));
		WriteToLogFileW(hFile, szVal);
		WriteToLogFile(hFile, TEXT("\n"));

		dwSize = MAX_PATH * sizeof(WCHAR);
		Status = SnapshotRegQueryValueKey(hSubkey, ProcessorVendorValsz, dwSize, &szVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			NtClose(hSubkey);
			WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information\n\n"));
			return;
		}
		WriteToLogFile(hFile, TEXT("\t\tVendor Identifier: "));
		WriteToLogFileW(hFile, szVal);
		WriteToLogFile(hFile, TEXT("\n"));

		NtClose(hSubkey);
		dwSubkeyIndex++;
		Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
	}
	NtClose(hKey);

	//Get NetCard Info
	Status = SnapshotRegOpenKey(NetcardKey, KEY_READ, &hKey);
	if(!NT_SUCCESS(Status)){
		WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information\n\n"));
		return;
	}

	WriteToLogFile(hFile, TEXT("NIC Info:\n"));
	dwSubkeyIndex = 0;
	dwSize = MAX_PATH * sizeof(WCHAR);
	Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
	while(NT_SUCCESS(Status)){
		wcscpy(szVal, NetcardKey);
		wcscat(szVal, L"\\");
		wcscat(szVal, szSubkey);
		Status = SnapshotRegOpenKey(szVal, KEY_READ, &hSubkey);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information\n\n"));
			return;
		}

		dwSize = MAX_PATH * sizeof(WCHAR);
		Status = SnapshotRegQueryValueKey(hSubkey, NetcardDescsz, dwSize, &szVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			NtClose(hSubkey);
			WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information\n\n"));
			return;
		}
		_stnprintf(lpszBuffer, BUFFER_SIZE,
                       TEXT("\tNIC %s:\n"),
					   szSubkey);
		WriteToLogFile(hFile, lpszBuffer);
		WriteToLogFile(hFile, TEXT("\t\tDescription: "));
		WriteToLogFileW(hFile, szVal);
		WriteToLogFile(hFile, TEXT("\n"));

		dwSize = MAX_PATH * sizeof(WCHAR);
		Status = SnapshotRegQueryValueKey(hSubkey, NetcardServiceNamesz, dwSize, &szVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			NtClose(hSubkey);
			WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information\n\n"));
			return;
		}
		WriteToLogFile(hFile, TEXT("\t\tService Name: "));
		WriteToLogFileW(hFile, szVal);
		WriteToLogFile(hFile, TEXT("\n"));
		NtClose(hSubkey);
		dwSubkeyIndex++;
		Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
	}
	NtClose(hKey);

}


BOOL
SnapshotIsVolumeName(
    LPWSTR Name
    )
{
    if (Name[0] == '\\' &&
        (Name[1] == '?' || Name[1] == '\\') &&
        Name[2] == '?' &&
        Name[3] == '\\' &&
        Name[4] == 'V' &&
        Name[5] == 'o' &&
        Name[6] == 'l' &&
        Name[7] == 'u' &&
        Name[8] == 'm' &&
        Name[9] == 'e' &&
        Name[10] == '{' &&
        Name[19] == '-' &&
        Name[24] == '-' &&
        Name[29] == '-' &&
        Name[34] == '-' &&
        Name[47] == '}' ) {

        return TRUE;
        }
    return FALSE;
}
void
LogPhyicalDiskInfo(
    HANDLE hFile
    )
{
    PMOUNTMGR_MOUNT_POINTS mountPoints;
    MOUNTMGR_MOUNT_POINT mountPoint;
    ULONG returnSize, success;
    SYSTEM_DEVICE_INFORMATION DevInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NumberOfDisks;
    PWCHAR deviceNameBuffer;
    ULONG i;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatus;

    DISK_GEOMETRY disk_geometry;
    PDISK_CACHE_INFORMATION disk_cache;
    PSCSI_ADDRESS scsi_address;
    PWCHAR KeyName;
	WCHAR wszVal[MAXSTR];
    HANDLE              hDisk = INVALID_HANDLE_VALUE;
    UNICODE_STRING      UnicodeName;

    ULONG SizeNeeded;
	HKEY KeyHandle;
	DWORD dwSize;

    //
    //  Get the Number of Physical Disks
    //

    RtlZeroMemory(&DevInfo, sizeof(DevInfo));

    Status =   NtQuerySystemInformation(
                    SystemDeviceInformation,
                    &DevInfo, sizeof (DevInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        WriteToLogFile(hFile, TEXT("Failed to query system information.\n\n"));
		return;
    }

    NumberOfDisks = DevInfo.NumberOfDisks;

    //
    // Open Each Physical Disk and get Disk Layout information
    //

	WriteToLogFile(hFile, TEXT("Physical Disk Info:\n"));
    for (i=0; i < NumberOfDisks; i++) {

        DISK_CACHE_INFORMATION cacheInfo;
        WCHAR               driveBuffer[20];

        HANDLE              PartitionHandle;
        HANDLE KeyHandle;
        ULONG DataLength;

        //
        // Get Partition0 handle to get the Disk layout 
        //

        deviceNameBuffer = (PWCHAR) lpszBuffer;
        swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition0", i);

        RtlInitUnicodeString(&UnicodeName, deviceNameBuffer);

        InitializeObjectAttributes(
                   &ObjectAttributes,
                   &UnicodeName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL
                   );
        Status = NtOpenFile(
                &PartitionHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );


        if (!NT_SUCCESS(Status)) {
            WriteToLogFile(hFile, TEXT("Failed calling NtOpenFile.\n\n"));
			return;
        }

        RtlZeroMemory(&disk_geometry, sizeof(DISK_GEOMETRY));
        // get geomerty information, the caller wants this
        Status = NtDeviceIoControlFile(PartitionHandle,
                       0,
                       NULL,
                       NULL,
                       &IoStatus,
                       IOCTL_DISK_GET_DRIVE_GEOMETRY,
                       NULL,
                       0,
                       &disk_geometry,
                       sizeof (DISK_GEOMETRY)
                       );
        if (!NT_SUCCESS(Status)) {
            NtClose(PartitionHandle);
            WriteToLogFile(hFile, TEXT("Failed calling NtDeviceIoControlFile 1.\n\n"));
			return;
        }
        scsi_address = (PSCSI_ADDRESS) lpszBuffer;
        Status = NtDeviceIoControlFile(PartitionHandle,
                        0,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_SCSI_GET_ADDRESS,
                        NULL,
                        0,
                        scsi_address,
                        sizeof (SCSI_ADDRESS)
                        );

        NtClose(PartitionHandle);

        if (!NT_SUCCESS(Status)) {
            WriteToLogFile(hFile, TEXT("Failed calling NtDeviceIoControlFile 2.\n\n"));
			return;
        }

        //
        // Get Manufacturer's name from Registry
        // We need to get the SCSI Address and then query the Registry with it.
        //

        KeyName = (PWCHAR) lpszBuffer;
        swprintf(KeyName, 
                 L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target ID %d\\Logical Unit Id %d",
                 scsi_address->PortNumber, scsi_address->PathId, scsi_address->TargetId, scsi_address->Lun
                );
		Status = SnapshotRegOpenKey(KeyName, KEY_READ, &KeyHandle);
        if (!NT_SUCCESS(Status)){
			WriteToLogFile(hFile, TEXT("Failed to open registry key for physical disk information\n\n"));
			return;
		}
        else {
            dwSize = MAXSTR * sizeof(WCHAR);
			Status = SnapshotRegQueryValueKey(KeyHandle, L"Identifier", dwSize, wszVal, &dwSize);
			if(!NT_SUCCESS(Status)){
				NtClose(KeyHandle);
				WriteToLogFile(hFile, TEXT("Failed to query registry value for physical disk information\n\n"));
				return;
			}
            NtClose(KeyHandle);
        }

        //
        // Package all information about this disk and write an event record
        //

		_stnprintf(lpszBuffer, BUFFER_SIZE,
				TEXT("\tDisk %d:\n")
				TEXT("\t\tBytes Per Sector: %d\n")
				TEXT("\t\tSectors Per Track: %d\n")
				TEXT("\t\tTracks Per Cylinder: %d\n")
				TEXT("\t\tNumber of Cylinders: %I64d\n")
				TEXT("\t\tPort Number: %d\n")
				TEXT("\t\tPath ID: %d\n")
				TEXT("\t\tTarget ID: %d\n")
				TEXT("\t\tLun: %d\n"),
				i,
				disk_geometry.BytesPerSector,
				disk_geometry.SectorsPerTrack,
				disk_geometry.TracksPerCylinder,
				disk_geometry.Cylinders.QuadPart,
				scsi_address->PortNumber,
				scsi_address->PathId,
				scsi_address->TargetId,
				scsi_address->Lun
				);
		WriteToLogFile(hFile, lpszBuffer);
		WriteToLogFile(hFile, TEXT("\t\tManufacturer: "));
		WriteToLogFileW(hFile, wszVal);
		WriteToLogFile(hFile, TEXT("\n"));
    }

    //
    // Get Logical Disk Information
    //
    wcscpy(wszVal, MOUNTMGR_DEVICE_NAME);
    RtlInitUnicodeString(&UnicodeName, (LPWSTR)wszVal);
    UnicodeName.MaximumLength = MAXSTR;

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &UnicodeName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL );
    Status = NtCreateFile(
                    &hDisk,
                    GENERIC_READ | SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatus,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE,
                    NULL, 0);

    if (!NT_SUCCESS(Status) ) {
        WriteToLogFile(hFile, TEXT("Failed calling NtCreateFile\n\n"));
		return;
    }
    RtlZeroMemory(lpszBuffer, MAXSTR*sizeof(WCHAR));
    RtlZeroMemory(&mountPoint, sizeof(MOUNTMGR_MOUNT_POINT));
    returnSize = 0;
    mountPoints = (PMOUNTMGR_MOUNT_POINTS) &lpszBuffer[0];

    Status = NtDeviceIoControlFile(hDisk,
                    0,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_MOUNTMGR_QUERY_POINTS,
                    mountPoints,
                    sizeof(MOUNTMGR_MOUNT_POINT),
                    mountPoints,
                    4096
                    );

    if (NT_SUCCESS(Status)) {
        WCHAR name[MAX_PATH];
        CHAR OutBuffer[MAXSTR];
        PMOUNTMGR_MOUNT_POINT point;
	    UNICODE_STRING VolumePoint;
        PVOLUME_DISK_EXTENTS VolExt;
        PDISK_EXTENT DiskExt;
        ULONG i;
		int iDisk, iPartition;
		iDisk = -1;
        
		WriteToLogFile(hFile, TEXT("Disk Partition Info:\n"));
        for (i=0; i<mountPoints->NumberOfMountPoints; i++) {
            point = &mountPoints->MountPoints[i];


            if (point->SymbolicLinkNameLength) {
                RtlCopyMemory(name,
                    (PCHAR) mountPoints + point->SymbolicLinkNameOffset,
                    point->SymbolicLinkNameLength);
                name[point->SymbolicLinkNameLength/sizeof(WCHAR)] = 0;
                if (SnapshotIsVolumeName(name)) {
                    continue;
                }
            }
            if (point->DeviceNameLength) {
                HANDLE hVolume;
                ULONG dwBytesReturned;
                PSTORAGE_DEVICE_NUMBER Number;
                DWORD IErrorMode;

                RtlCopyMemory(name,
                              (PCHAR) mountPoints + point->DeviceNameOffset,
                              point->DeviceNameLength);
                name[point->DeviceNameLength/sizeof(WCHAR)] = 0;

                RtlInitUnicodeString(&UnicodeName, name);
                UnicodeName.MaximumLength = MAXSTR;

            //
            // If the device name does not have the harddisk prefix
            // then it may be a floppy or cdrom and we want avoid 
            // calling NtCreateFile on them.
            //
                if(_wcsnicmp(name,L"\\device\\harddisk",16)) {
                    continue;
                }

                InitializeObjectAttributes(
                        &ObjectAttributes,
                        &UnicodeName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL );
            //
            // We do not want any pop up dialog here in case we are unable to 
            // access the volume. 
            //
                IErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);
                Status = NtCreateFile(
                        &hVolume,
                        GENERIC_READ | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatus,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_IF,
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL, 0);
                SetErrorMode(IErrorMode);
                if (!NT_SUCCESS(Status)) {
                    continue;
                }


                RtlZeroMemory(OutBuffer, MAXSTR);
                dwBytesReturned = 0;
                VolExt = (PVOLUME_DISK_EXTENTS) &OutBuffer;

                Status = NtDeviceIoControlFile(hVolume,
                                0,
                                NULL,
                                NULL,
                                &IoStatus,
                                IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                NULL,
                                0,
                                &OutBuffer, 
                                4096
                                );
               if (NT_SUCCESS(Status) ) {
                    ULONG j;
                    ULONG NumberOfExtents = VolExt->NumberOfDiskExtents;
					TCHAR tszTemp[MAXSTR];
                   
					if(iDisk == -1 || iDisk != (&VolExt->Extents[0])->DiskNumber){
						_stnprintf(tszTemp, MAXSTR, TEXT("\tDisk %d:\n"), (&VolExt->Extents[0])->DiskNumber);
						WriteToLogFile(hFile, tszTemp);
						iDisk = (&VolExt->Extents[0])->DiskNumber;
						iPartition = 0;
					}

					_stnprintf(tszTemp, MAXSTR,
							TEXT("\t\tPartition %d:\n"),
							iPartition);
					WriteToLogFile(hFile, tszTemp);

                    for (j=0; j < NumberOfExtents; j++) {
						DiskExt = &VolExt->Extents[j];
						_stnprintf(tszTemp, MAXSTR,
								TEXT("\t\t\tExtent %d(disk %d):\n")
								TEXT("\t\t\t\tStartingOffset: %I64d\n")
								TEXT("\t\t\t\tPartitionSize: %I64d\n"),
								j,
								DiskExt->DiskNumber,
								DiskExt->StartingOffset.QuadPart,
								DiskExt->ExtentLength.QuadPart);
						WriteToLogFile(hFile, tszTemp);
                    }
					iPartition++;
                }
                NtClose(hVolume);
            }
        }
    }
    NtClose(hDisk);
}

void
LogHotfixes(
    HANDLE hFile
    )
{
	LPCWSTR HotFixKey = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix";
	LPCWSTR wszValName = L"Installed";
	HANDLE hKey, hSubkey;
	NTSTATUS Status = STATUS_SUCCESS;
	UINT i;
	DWORD dwSize, dwVal, dwSubkeyIndex;
	WCHAR szKey[MAXSTR];
	WCHAR szSubkey[MAXSTR];


	Status = SnapshotRegOpenKey(HotFixKey, KEY_READ, &hKey);
	if (!NT_SUCCESS(Status) ) {
		WriteToLogFile(hFile, TEXT("Hotfix registry key does not exist or open failed\n\n"));
		return;
    }
	WriteToLogFile(hFile, TEXT("Hotfix Info:\n"));

	dwSubkeyIndex = 0;
	dwSize = MAXSTR * sizeof(WCHAR);
	Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
	while(NT_SUCCESS(Status)){
		wcscpy(szKey, HotFixKey);
		wcscat(szKey, L"\\");
		wcscat(szKey, szSubkey);
		Status = SnapshotRegOpenKey(szKey, KEY_READ, &hSubkey);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			return;
		}
		dwSize = sizeof(DWORD);
		Status = SnapshotRegQueryValueKey(hSubkey, wszValName, dwSize, &dwVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			NtClose(hKey);
			NtClose(hSubkey);
			WriteToLogFile(hFile, TEXT("Failed to query registry key value for hotfix info\n\n"));
			return;
		}
		_stnprintf(lpszBuffer, BUFFER_SIZE,
                       TEXT("\t%s: %d\n"), 
					   szSubkey, dwVal);
		WriteToLogFile(hFile, lpszBuffer);

		NtClose(hSubkey);
		dwSubkeyIndex++;
		Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
	}
	NtClose(hKey);
}

void
LogOsInfo(
    HANDLE hFile
    )
{
	LPCWSTR OsInfoKey = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion";
	LPCWSTR awszValName[] = {
		L"BuildLab",
		L"CurrentBuildNumber",
		L"CurrentType",
		L"CurrentVersion",
		//L"InstallDate",
		L"PathName",
		L"ProductId",
		L"ProductName",
		L"RegDone",
		L"RegisteredOrgnization",
		L"RegisteredOwner",
		L"SoftwareType",
		L"SourcePath",
		L"SystemRoot",
		L"CSDVersion"
	};
	UINT uVals = sizeof(awszValName) / sizeof(LPCWSTR);
	HANDLE hKey;
	NTSTATUS Status = STATUS_SUCCESS;
	UINT i;
	WCHAR wszVal[MAXSTR];
	DWORD dwSize;

	Status = SnapshotRegOpenKey(OsInfoKey, KEY_READ, &hKey);
	if (!NT_SUCCESS(Status) ) {
        WriteToLogFile(hFile, TEXT("Failed to open registry key for os version info\n\n"));
		return;
    }
	WriteToLogFile(hFile, TEXT("OS Version Info:\n"));

	for(i = 0; i < uVals; i++){
		dwSize = MAXSTR * sizeof(WCHAR);
		Status = SnapshotRegQueryValueKey(hKey, awszValName[i], dwSize, wszVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			continue;
		}
		WriteToLogFile(hFile, TEXT("\t"));
		WriteToLogFileW(hFile, awszValName[i]);
		WriteToLogFile(hFile, TEXT(": "));
		WriteToLogFileW(hFile, wszVal);
		WriteToLogFile(hFile, TEXT("\n"));
	}
	NtClose(hKey);
}

void
LogBIOSInfo(
    HANDLE hFile
    )
{
	LPCWSTR BiosInfoKey = L"\\Registry\\Machine\\Hardware\\Description\\System";
	LPCWSTR awszValName[] = {
		L"Identifier",
		L"SystemBiosDate",
		L"SystemBiosVersion",
		L"VideoBiosDate",
		L"VideoBiosVersion"
	};
	UINT uVals = sizeof(awszValName) / sizeof(LPCWSTR);
	HANDLE hKey;
	NTSTATUS Status = STATUS_SUCCESS;
	UINT i;
	WCHAR wszVal[MAXSTR];
	LPWSTR pwsz;
	DWORD dwSize, dwLen;

	Status = SnapshotRegOpenKey(BiosInfoKey, KEY_READ, &hKey);
	if (!NT_SUCCESS(Status) ) {
        WriteToLogFile(hFile, TEXT("Failed to open registry key for BIOS info\n\n"));
		return;
    }
	WriteToLogFile(hFile, TEXT("BIOS Info:\n"));

	for(i = 0; i < uVals; i++){
		dwSize = MAXSTR * sizeof(WCHAR);
		Status = SnapshotRegQueryValueKey(hKey, awszValName[i], dwSize, wszVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			continue;
		}
		WriteToLogFile(hFile, TEXT("\t"));
		WriteToLogFileW(hFile, awszValName[i]);
		WriteToLogFile(hFile, TEXT(": "));
		dwLen = 0;
		pwsz = wszVal;
		while(dwLen + 1< dwSize / sizeof(WCHAR)){
			if(dwLen != 0)
				WriteToLogFile(hFile, TEXT(" "));
			WriteToLogFileW(hFile, pwsz);
			dwLen += wcslen(pwsz) + 1;
			pwsz += wcslen(pwsz) + 1;
		}
		WriteToLogFile(hFile, TEXT("\n"));
	}
	NtClose(hKey);
}

void
DeleteOldFiles(
   LPCTSTR lpPath
   )
{
	LPCWSTR				ReliabilityKey = L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\Reliability";
	LPCWSTR				lpValName = L"SnapshotHistoryFiles";
	HANDLE				hKey, hFile;
	NTSTATUS			Status = STATUS_SUCCESS;
	DWORD				dwSize, dwVal;
	TCHAR				szFileName[MAX_PATH];
	WIN32_FIND_DATA		winData;
	BOOL				bFound = TRUE;
	SYSTEMTIME			systime;
	FILETIME			filetime;
	__int64				i64Filetime, i64Filetime1;

    GetSystemTime(&systime);
	SystemTimeToFileTime(&systime, &filetime);
	i64Filetime = (__int64)filetime.dwHighDateTime;
	i64Filetime <<= 32;
	i64Filetime |= (__int64)filetime.dwLowDateTime;

	Status = SnapshotRegOpenKey(ReliabilityKey, KEY_ALL_ACCESS, &hKey);
	if (NT_SUCCESS(Status)){
		dwSize = sizeof(DWORD);
		Status = SnapshotRegQueryValueKey(hKey, lpValName, dwSize, &dwVal, &dwSize);
		if(!NT_SUCCESS(Status)){
			dwVal = DEFAULT_HISTORYFILES;
		}
		NtClose(hKey);
	}
	else {
		dwVal = DEFAULT_HISTORYFILES;
	}
	
	lstrcpy(szFileName, lpPath);
	lstrcat(szFileName, TEXT("\\ShutDown_on_*"));

	hFile = FindFirstFile(szFileName, &winData);
	while(hFile != INVALID_HANDLE_VALUE && bFound){
		i64Filetime1 = (__int64)winData.ftCreationTime.dwHighDateTime;
		i64Filetime1 <<= 32;
		i64Filetime1 |= (__int64)winData.ftCreationTime.dwLowDateTime;

		if(i64Filetime - i64Filetime1 >= (const __int64)24*60*60*10000000 * dwVal){
			lstrcpy(szFileName, lpPath);
			lstrcat(szFileName, TEXT("\\"));
			lstrcat(szFileName,winData.cFileName);
			DeleteFile(szFileName);
		}
		bFound = FindNextFile(hFile, &winData);
	}

	if(hFile != INVALID_HANDLE_VALUE)
		FindClose(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\savedump\savedump.cpp ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    savedump.c

Abstract:

    This module contains the code to recover a dump from the system paging
    file.

Environment:

    Kernel mode

Revision History:

--*/

#include <savedump.h>


//
// Read/write copy of dump header.
//


BOOL Test = FALSE;

/////////////////////////////////////////////////////////////////////////////
// API for Dr. Watson / other fault handlers to call
//
// FaultTypeToReport: the type of fault, Kernel, snapshot, or ?
// pwszDumpPath:      a pointer to a string containing the dump or snapshot
//
// returns:
//          S_OK on success
//          some other system defined error code on failure

// ***************************************************************************
HRESULT
PCHPFNotifyFault(EEventType FaultTypeToReport, LPWSTR pwszDumpPath, SEventInfoW *pEventInfo)
{
    EFaultRepRetVal frrv;
    HMODULE         hmodFaultRep;
    HRESULT         hr = NOERROR;
    WCHAR           wszDll[MAX_PATH];

    GetWindowsDirectoryW(wszDll, sizeof(wszDll) / sizeof(WCHAR));
    wcscat(wszDll, L"\\system32\\faultrep.dll");

    frrv = frrvErrNoDW;
    hmodFaultRep = LoadLibraryExW(wszDll, NULL, 0);
    if (hmodFaultRep != NULL)
    {
        pfn_REPORTEREVENT pfn;
        
        pfn = (pfn_REPORTEREVENT)GetProcAddress(hmodFaultRep,
                                                  "ReportEREvent");

        if (pfn != NULL)
        {
            frrv = (*pfn)(FaultTypeToReport, pwszDumpPath, pEventInfo);
        }

        FreeLibrary(hmodFaultRep);
        hmodFaultRep = NULL;
    }

    hr = ((frrv != frrvErrNoDW) ? S_OK : HRESULT_FROM_WIN32(GetLastError()));

    return hr;

}



BOOLEAN
CreateMiniDump(
    IN PWSTR FullDumpName,
    IN PWSTR MiniDumpName
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;
    CHAR AnsiFullFileName[MAX_PATH];
    CHAR AnsiMiniFileName[MAX_PATH];

    if (WideCharToMultiByte(CP_ACP,
                            0,
                            (PWSTR)FullDumpName,
                            -1,
                            AnsiFullFileName,
                            sizeof(AnsiFullFileName),
                            NULL,
                            NULL) &&
        WideCharToMultiByte(CP_ACP,
                            0,
                            (PWSTR)MiniDumpName,
                            -1,
                            AnsiMiniFileName,
                            sizeof(AnsiMiniFileName),
                            NULL,
                            NULL))
    {
        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) != S_OK)
        {
           KdPrint (("SAVEDUMP: cannot create DebugClientInterface\n"));
        }
        else
        {
            if (DebugClient->QueryInterface(__uuidof(IDebugControl),
                                            (void **)&DebugControl) == S_OK)
            {
                if (DebugClient->OpenDumpFile(AnsiFullFileName) == S_OK)
                {
                    DebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);

                    if (DebugClient->WriteDumpFile(AnsiMiniFileName,
                                                   DEBUG_DUMP_SMALL) == S_OK)
                    {
                        Hr = S_OK;
                    }
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }

        // Security descriptor issue.
        //
        //HANDLE MiniFileHandle;
        //
        //MiniFileHandle = CreateMyFile(miniFileName, FALSE, SecurityDescriptor);
        //if (MiniFileHandle != INVALID_HANDLE_VALUE)
        //{
        //    CloseHandle( fileHandle );
        //}
    }

    return TRUE;
}



NTSTATUS
GetTargetFileNames(
    IN HKEY CrashControlKey,
    IN PWSTR MiniFilePath,
    IN PWSTR FullFilePath,
    IN ULONG DumpType
    )
{
    INT i;
    ULONG Status;
    ULONG Type;
    WCHAR FileName [ MAX_PATH + 1];
    ULONG Length;
    BOOL AddWack;
    SYSTEMTIME Time;
    WCHAR DirName [ MAX_PATH ];
    WCHAR ExpandedDirName [ MAX_PATH ];

    //
    // Minidump reads the directory from CrashControl\MiniDumpDir.
    //

    Length = sizeof (DirName);
    Status = RegQueryValueEx( CrashControlKey,
                                 L"MiniDumpDir",
                                 (LPDWORD) NULL,
                                 &Type,
                                 (LPBYTE) &DirName,
                                 &Length
                                 );

    if (Status != ERROR_SUCCESS) {

        //
        // Set to default.
        //

        wcscpy (DirName, L"%SystemRoot%\\Minidump");
    }

    ExpandEnvironmentStrings ( DirName, ExpandedDirName, MAX_PATH);

    //
    // If directory does not exist, create it. Ignore errors here because
    // they will be picked up later when we try to create the file.
    //

    CreateDirectory (ExpandedDirName, NULL);

    //
    // Format is: Mini-MM_DD_YY_HH_MM.dmp
    //

    GetLocalTime (&Time);

    if ( ExpandedDirName [ wcslen ( ExpandedDirName ) - 1 ] != L'\\' ) {
        AddWack = TRUE;
    } else {
        AddWack = FALSE;
    }

    for (i = 1; i < 100; i++) {
        swprintf (MiniFilePath,
                  L"%s%sMini%2.2d%2.2d%2.2d-%2.2d.dmp",
                  ExpandedDirName,
                  AddWack ? L"\\" : L"",
                  (int) Time.wMonth,
                  (int) Time.wDay,
                  (int) Time.wYear % 100,
                  (int) i
                  );

        if (GetFileAttributes (MiniFilePath) == (DWORD) -1 &&
            GetLastError () == ERROR_FILE_NOT_FOUND) {

            break;
        }

    }

    //
    // We failed to create a suitable file name; just fail.
    //

    if ( i == 100 ) {
        return STATUS_UNSUCCESSFUL;
    }

    if (DumpType != DUMP_TYPE_TRIAGE) {

        Length = sizeof (FileName);
        Status = RegQueryValueEx( CrashControlKey,
                                  L"DumpFile",
                                  (LPDWORD) NULL,
                                  &Type,
                                  (LPBYTE) &FileName,
                                  &Length
                                  );

        if (Status != ERROR_SUCCESS) {

            //
            // Set to default.
            //
            
            wcscpy (FileName, L"%SystemRoot%\\MEMORY.DMP");
        }

        ExpandEnvironmentStrings (FileName, FullFilePath, MAX_PATH );

    }

    return STATUS_SUCCESS;
}



VOID
LogCrashDumpEvent(
    IN PUNICODE_STRING BugcheckString,
    IN PCWSTR SavedFileName,
    IN BOOL SuccessfullySavedDump
    )
{
    HANDLE LogHandle;
    LPWSTR StringArray[3];
    WORD StringCount;
    DWORD EventId;
    BOOL Retry;
    DWORD Retries;

    //
    // Attempt to register the event source. Retry 20 times.
    //

    Retries = 0;
    
    do {

        LogHandle = RegisterEventSource( (LPWSTR) NULL,
                                         L"Save Dump"
                                         );

        //
        // Retry on specific failures (server unavailable and interface
        // unavailable).
        //
        
        if (LogHandle == NULL &&
            Retries < 20 &&
            ( GetLastError () == RPC_S_SERVER_UNAVAILABLE ||
              GetLastError () == RPC_S_UNKNOWN_IF) ) {

            Sleep ( 1500 );
            Retry = TRUE;
        } else {
            Retry = FALSE;
        }

        Retries++;

    } while (LogHandle == NULL && Retry);

    if (!LogHandle) {
        return ;
    }
    
    //
    // Set up the parameters based on whether a full crash or summary
    // was taken.
    //

    StringArray [ 0 ] = BugcheckString->Buffer;
    StringArray [ 1 ] = (PWSTR) SavedFileName;

    //
    // Report the appropriate event.
    //

    if (SuccessfullySavedDump) {
        EventId = EVENT_BUGCHECK_SAVED;
        StringCount = 2;
    } else {
        EventId = EVENT_BUGCHECK;
        StringCount = 2;
    }
    
    ReportEvent( LogHandle,
                 EVENTLOG_INFORMATION_TYPE,
                 0,
                 EventId,
                 NULL,
                 StringCount,
                 0,
                 (LPCWSTR *)StringArray,
                 NULL);
}



VOID
SendCrashDumpAlert(
    IN PUNICODE_STRING BugcheckString,
    IN PCWSTR SavedFileName,
    IN BOOL SuccessfullySavedDump
    )
{
    PADMIN_OTHER_INFO adminInfo;
    DWORD adminInfoSize;
    DWORD Length;
    DWORD i;
    ULONG winStatus;
    UCHAR VariableInfo [4096];


    //
    // Set up the administrator information variables for processing the
    // buffer.
    //

    adminInfo = (PADMIN_OTHER_INFO) VariableInfo;
    adminInfoSize = sizeof( ADMIN_OTHER_INFO );

    //
    // Format the bugcheck information into the appropriate message format.
    //

    RtlCopyMemory( (LPWSTR) ((PCHAR) adminInfo + adminInfoSize),
                   BugcheckString->Buffer,
                   BugcheckString->Length
                   );
                   
    adminInfoSize += BugcheckString->Length + sizeof( WCHAR );

    //
    // Set up the administrator alert information according to the type of
    // dump that was taken.
    //

    if (SuccessfullySavedDump) {
        adminInfo->alrtad_errcode = ALERT_BugCheckSaved;
        adminInfo->alrtad_numstrings = 3;
        wcscpy( (LPWSTR) ((PCHAR) adminInfo + adminInfoSize), SavedFileName);
        adminInfoSize += ((wcslen( SavedFileName ) + 1) * sizeof( WCHAR ));
    } else {
        adminInfo->alrtad_errcode = ALERT_BugCheck;
        adminInfo->alrtad_numstrings = 2;
    }

    //
    // Get the name of the computer and insert it into the buffer.
    //

    Length = (sizeof( VariableInfo ) - adminInfoSize) / sizeof(WCHAR);
    winStatus = GetComputerName( (LPWSTR) ((PCHAR) adminInfo + adminInfoSize),
                                 &Length );
    Length = ((Length + 1) * sizeof( WCHAR ));
    adminInfoSize += Length;

    //
    // Raise the alert.
    //

    i = 0;

    do {

        winStatus = NetAlertRaiseEx( ALERT_ADMIN_EVENT,
                                     adminInfo,
                                     adminInfoSize,
                                     L"SAVEDUMP" );
        if (winStatus) {
            if (winStatus == ERROR_FILE_NOT_FOUND) {
                if (i++ > 20) {
                    break;
                }
                if ((i & 3) == 0) {
                    KdPrint (( "SAVEDUMP: Waiting for alerter...\n" ));
                }

                Sleep( 15000 );
            }
        }
    } while (winStatus == ERROR_FILE_NOT_FOUND);
}



VOID
GetSaveDumpInfo(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4,
    IN ULONG MajorVersion,
    IN ULONG MinorVersion,
    OUT PUNICODE_STRING BugcheckString
    )
{
    ANSI_STRING ansiString1;
    ANSI_STRING ansiString2;
    CHAR buffer1[256];
    CHAR buffer2[256];

    sprintf( buffer1,
             "0x%08x (0x%08x, 0x%08x, 0x%08x, 0x%08x)",
             BugCheckCode,
             BugCheckParameter1,
             BugCheckParameter2,
             BugCheckParameter3,
             BugCheckParameter4
             );

    RtlInitAnsiString( &ansiString1, buffer1 );
    RtlAnsiStringToUnicodeString( BugcheckString, &ansiString1, TRUE );

    sprintf( buffer2,
             "Microsoft Windows [v%ld.%ld]",
              MajorVersion,
              MinorVersion
              );
}



BOOL
ReadDumpHeader(
    IN PWSTR DumpFileName,
    IN PDUMP_HEADER Header
    )
{
    HANDLE File;
    ULONG Bytes;
    BOOL Succ;

    File = CreateFile (DumpFileName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (File == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    

    Succ = ReadFile (File,
                     Header,
                     sizeof (DUMP_HEADER),
                     &Bytes,
                     NULL);

    CloseHandle (File);

    if (Succ &&
        Header->Signature == DUMP_SIGNATURE &&
        Header->ValidDump == DUMP_VALID_DUMP) {

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}



HRESULT
DoDumpConv(
    PCHAR szInputDumpFile,          // full or kernel dump
    PCHAR szOutputDumpFile,        // triage dump file
    PCHAR szSymbolPath
    )
{
    HRESULT Hr = E_FAIL;
    IDebugClient *DebugClient;
    IDebugControl *DebugControl;
    IDebugSymbols *DebugSymbols;

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }

    if ((DebugClient->QueryInterface(__uuidof(IDebugControl),
                                    (void **)&DebugControl) == S_OK) &&
        (DebugClient->QueryInterface(__uuidof(IDebugSymbols),
                                    (void **)&DebugSymbols) == S_OK))
    {
        if (DebugClient->OpenDumpFile(szInputDumpFile) == S_OK)
        {
            // Optional.  Conversion does not require symbols
            //if (DebugSymbols->SetSymbolPath("C:\\") == S_OK)

            if (szSymbolPath) {
                DebugSymbols->SetSymbolPath(szSymbolPath);
            }
            DebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
            if ((Hr = DebugClient->WriteDumpFile(szOutputDumpFile,
                                                 DEBUG_DUMP_SMALL)) == S_OK)
            {
                Hr = S_OK;
            }
        }

        DebugControl->Release();
        DebugSymbols->Release();
    }

    DebugClient->Release();


    return Hr;
}



VOID
SetSecurity(LPWSTR FileName)
{
    PSID pLocalSystemSid;
    PSID pAdminSid;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY ;

    PSECURITY_DESCRIPTOR SecurityDescriptor;
    BYTE SDBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];

    PACL pAcl;
    BYTE AclBuffer[1024];

    HANDLE fileHandle;

    HANDLE Token;
    PTOKEN_OWNER pto;
    ULONG bl = 5;
    ULONG retlen;


    fileHandle = CreateFile(FileName,
                            WRITE_DAC,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            0);

    if (fileHandle == INVALID_HANDLE_VALUE)
    {
        return;
    }


    RtlAllocateAndInitializeSid( &NtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID,
                            0, 0, 0, 0, 0, 0, 0, &pLocalSystemSid );

    RtlAllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS,
                                0, 0, 0, 0, 0, 0, &pAdminSid );

    SecurityDescriptor = (PSECURITY_DESCRIPTOR) SDBuffer;

    //
    // You can be fancy and compute the exact size, but since the
    // security descriptor capture code has to do that anyway, why
    // do it twice?
    //

    pAcl = (PACL) AclBuffer;

    RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    RtlCreateAcl(pAcl, 1024, ACL_REVISION);

    //
    // current user, Administrator and system have full control
    //

    if (OpenThreadToken(GetCurrentThread (), MAXIMUM_ALLOWED, TRUE, &Token) ||
        OpenProcessToken(GetCurrentProcess (), MAXIMUM_ALLOWED, &Token))
    {

realloc:
        pto = (PTOKEN_OWNER)malloc(bl);
        if (pto)
        {
            if (GetTokenInformation(Token, TokenOwner, pto, bl, &retlen))
            {
                RtlAddAccessAllowedAce(pAcl,
                         ACL_REVISION,
                         GENERIC_ALL | DELETE | WRITE_DAC | WRITE_OWNER,
                         pto->Owner);
            }
            else if (bl < retlen)
            {
                bl = retlen;
                free (pto);
                goto realloc;
            }

            free (pto);
        }

        CloseHandle(Token);
    }

    if (pAdminSid)
    {
        RtlAddAccessAllowedAce(pAcl,
                            ACL_REVISION,
                            GENERIC_ALL | DELETE | WRITE_DAC | WRITE_OWNER,
                            pAdminSid);
        RtlFreeSid(pAdminSid);
    }

    if (pLocalSystemSid)
    {
        RtlAddAccessAllowedAce(pAcl,
                            ACL_REVISION,
                            GENERIC_ALL | DELETE | WRITE_DAC | WRITE_OWNER,
                            pLocalSystemSid);
        RtlFreeSid(pLocalSystemSid);
    }

    RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, pAcl, FALSE);
    RtlSetOwnerSecurityDescriptor(SecurityDescriptor, pAdminSid, FALSE);

    NtSetSecurityObject(fileHandle,
                        DACL_SECURITY_INFORMATION,
                        SecurityDescriptor);

    CloseHandle(fileHandle);
}



BOOL
BugcheckEventHandler(
    IN BOOL NotifyPcHealth,
    OUT PBOOL SavedDump,
    OUT PULONG LogEvent,
    OUT PULONG SendAlert,
    OUT PUNICODE_STRING BugCheckString,
    OUT PWCHAR FileName
    )

/*++

Routine Description:

    This is the boot time routine to handle pending bugcheck event.

Arguments:

    NotifyPcHealth - TRUE if we should report event to PC Health, FALSE otherwise.

Return Value:

    TRUE if bugcheck event found and reported to PC Health, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    DUMP_HEADER Header;
    ULONG WinStatus;
    HKEY Key;
    ULONG Length;
    ULONG Overwrite;
    ULONG Type;
    ULONG TempDestination = 0;
    WCHAR MiniDumpName[MAX_PATH];
    WCHAR FullDumpName[MAX_PATH];
    PWCHAR FinalFileName;
    WCHAR SourceDumpName[MAX_PATH];
    BOOL Succ;

    *SavedDump = FALSE;
    *LogEvent = 0;
    *SendAlert = 0;

    Succ = FALSE;
    Overwrite = FALSE;
    FinalFileName = NULL;

    WinStatus = RegOpenKey( HKEY_LOCAL_MACHINE,
                            SUBKEY_CRASH_CONTROL L"\\MachineCrash",
                            &Key );

    if (WinStatus != ERROR_SUCCESS) {
        return FALSE;
    }

    Length = sizeof (Length);
    WinStatus = RegQueryValueEx( Key,
                                 L"TempDestination",
                                 (LPDWORD) NULL,
                                 &Type,
                                 (LPBYTE) &TempDestination,
                                 &Length );

    Length = sizeof (SourceDumpName);
    WinStatus = RegQueryValueEx( Key,
                                 L"DumpFile",
                                 (LPDWORD) NULL,
                                 &Type,
                                 (LPBYTE) &SourceDumpName,
                                 &Length );

    RegCloseKey (Key);

    if ((WinStatus != NO_ERROR) ||
        !ReadDumpHeader (SourceDumpName, &Header))
    {
        //
        // Dump file is not present or invalid.
        //
    
        return FALSE;
    }
    
    //
    // Open the base registry node for crash control information and get the
    // actions for what needs to occur next.
    //

    WinStatus = RegOpenKey (HKEY_LOCAL_MACHINE,
                            SUBKEY_CRASH_CONTROL,
                            &Key);

    if (WinStatus != ERROR_SUCCESS) {
        return FALSE;
    }

    Length = 4;

    WinStatus = RegQueryValueEx (Key,
                                 L"LogEvent",
                                 (LPDWORD) NULL,
                                 &Type,
                                 (LPBYTE) LogEvent,
                                 &Length);

    WinStatus = RegQueryValueEx (Key,
                                 L"SendAlert",
                                 (LPDWORD) NULL,
                                 &Type,
                                 (LPBYTE) SendAlert,
                                 &Length);


    //
    // If the dump file needs to be copied, copy it now.
    //
    
    Status = GetTargetFileNames (Key,
                                 MiniDumpName,
                                 FullDumpName,
                                 Header.DumpType);


    if (!NT_SUCCESS (Status)) {
        goto fileDone;
    }

    if (!TempDestination) {

        FinalFileName = SourceDumpName;
        *SavedDump = TRUE;

    } else {

        Overwrite = 0;

        WinStatus = RegQueryValueEx (Key,
                                     L"Overwrite",
                                     (LPDWORD) NULL,
                                     &Type,
                                     (LPBYTE) &Overwrite,
                                     &Length);

        if (!Test) {

            //
            // Set the priority class of this application down to the Lowest
            // priority class to ensure that copying the file does not overload
            // everything else that is going on during system initialization.
            //

            //
            // We do not lower the priority in test mode because it just
            // wastes time.
            //

            SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);
            SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_LOWEST);
        }

        if (Header.DumpType == DUMP_TYPE_FULL ||
            Header.DumpType == DUMP_TYPE_SUMMARY) {

            FinalFileName = FullDumpName;
            *SavedDump = CopyFileEx (SourceDumpName,
                                     FullDumpName,
                                     NULL,
                                     NULL,
                                     NULL,
                                     Overwrite ? 0 : COPY_FILE_FAIL_IF_EXISTS);

        } else if (Header.DumpType == DUMP_TYPE_TRIAGE) {

            FinalFileName = MiniDumpName;
            *SavedDump = CopyFileEx (SourceDumpName,
                                     MiniDumpName,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0);
        }

        //
        // NOTE: MoveFileEx would do the Copy and Delete as one action,
        // which may be desirable.
        //
        
        if (*SavedDump)
        {
            DeleteFile (SourceDumpName);
        }
    }

fileDone:

    RegCloseKey (Key);

    if (*SavedDump) {
#if DBG
        ASSERT (FinalFileName != NULL);
#endif

        //
        // Set the security on the file
        //
        SetSecurity(FinalFileName);
    }

    if (FinalFileName != NULL) {
        wcscpy(FileName, FinalFileName);
    }

    GetSaveDumpInfo (Header.BugCheckCode,
                     Header.BugCheckParameter1,
                     Header.BugCheckParameter2,
                     Header.BugCheckParameter3,
                     Header.BugCheckParameter4,
                     Header.MajorVersion,
                     Header.MinorVersion,
                     BugCheckString);

    //
    // Copy a minidump out, if necessary.
    //

    if (*SavedDump &&
       (Header.DumpType == DUMP_TYPE_FULL ||
        Header.DumpType == DUMP_TYPE_SUMMARY)) {

        CreateMiniDump (FullDumpName, MiniDumpName);
    }

    //
    // Whenever we have had a blue creen event we are going to post an unexpected restart
    // shutdown event screen on startup (assuming Server SKU or specially set Professional).
    // In order to make it easier on the user we attempt to prefill the comment with the bug
    // check data. If and only if we got to this point before he has first logged in.
    //

    //
    //  Open the Reliability key.
    //

    Status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        SUBKEY_RELIABILITY,
                        &Key);

    if (Status == ERROR_SUCCESS) {

        //
        // Is Dirty Shutdown set?
        //

        Length = MAX_PATH;
        Status = RegQueryValueEx(Key,
                                 L"DirtyShutDown",
                                 NULL,
                                 &Type,
                                 (LPBYTE)SourceDumpName,
                                 &Length);

        //
        // Preload the set comment.
        //

        if (Status == ERROR_SUCCESS) {

            Status = RegSetValueEx(Key,
                                   L"BugCheckString",
                                   NULL,
                                   REG_SZ,
                                   (LPBYTE)(BugCheckString->Buffer),
                                   BugCheckString->Length);
        }

        RegCloseKey(Key);
    }

    //
    // Report it to PC Health.
    //

    if (NotifyPcHealth)
    {
        PCHPFNotifyFault(eetKernelFault, MiniDumpName, NULL);
        return TRUE;
    }

    return FALSE;
}



void Usage()
{
    fprintf(stderr,"savedump -c input_dump_file output_dump_file\n");
    fprintf(stderr,"\tinput dump file is full or kernel crash dump.\n");
    fprintf(stderr,"\toutput is triage crash dump.\n");
}



VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    This is the main driving routine for the dump recovery process.

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL DumpConv;
    PCHAR ConvDumpFrom;
    PCHAR ConvDumpTo;
    PCHAR SymbolPath;
    LONG arg;
    ULONG WinStatus;
    HKEY Key;
    BOOL SavedDump;
    ULONG LogEvent;
    ULONG SendAlert;
    UNICODE_STRING BugCheckString;
    WCHAR FileName[MAX_PATH];
    PWCHAR FinalFileName;

    DumpConv = FALSE;
    ConvDumpTo = NULL;
    ConvDumpFrom = NULL;
    SymbolPath = NULL;
    SavedDump = FALSE;
    LogEvent = 0;
    SendAlert = 0;
    *FileName = UNICODE_NULL;
    FinalFileName = NULL;

    for (arg = 1; arg < argc; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            switch (argv[arg][1]) {
            case 'c':
            case 'C':
                DumpConv = TRUE;
                if (arg+2<argc) {
                    ConvDumpFrom = argv[++arg];
                    ConvDumpTo   = argv[++arg];
                } else {
                    Usage();
                    exit (-1);
                }
                break;
#if DBG
            case 'y':
            case 'Y':
                if (++arg < argc) {
                    SymbolPath = argv[arg];
                }
                break;
            case 't':
            case 'T':

                Test = TRUE;
                break;
#endif
            default:
                break;
            }
        }

    }
    
    if (DumpConv) {
        if (!ConvDumpFrom || !ConvDumpTo) {
            Usage();
            exit (-1);
        }
        if (DoDumpConv(ConvDumpFrom, ConvDumpTo, SymbolPath) != S_OK) {
            fprintf(stderr, "Dump conversion failed, please check in source dump is vaild\n"
                    "by loading it in the debugger as 'kd.exe -z <dump> -y <symbols>\n");

        }

        ANSI_STRING ansiString;
        UNICODE_STRING unicodeString;
        WCHAR buffer[MAX_PATH+1];

        unicodeString.Buffer = buffer;
        unicodeString.MaximumLength = MAX_PATH*sizeof(WCHAR);
        unicodeString.Length = 0;

        RtlInitAnsiString( &ansiString, ConvDumpTo );
        RtlAnsiStringToUnicodeString( &unicodeString, &ansiString, FALSE );

        buffer[unicodeString.Length / sizeof(WCHAR)] = 0;
        SetSecurity(buffer);

        return;
    }

    //
    // Handle dirty shutdown events.
    //

    BugcheckEventHandler(TRUE,
                         &SavedDump,
                         &LogEvent,
                         &SendAlert,
                         &BugCheckString,
                         FileName);

    WatchdogEventHandler(TRUE);
    DirtyShutdownEventHandler(TRUE);

    //
    // Knock down reliability ShutdownEventPending flag. We must always try to do this
    // since somebody can set this flag and recover later on (e.g. watchdog's EventFlag
    // cleared). With this flag set savedump will always run and we don't want that.
    //
    // Note: This flag is shared between multiple components. Only savedump is allowed
    // to clear this flag, all others components are only allowed to set it to trigger
    // savedump run at next logon.
    //

    WinStatus = RegOpenKey(HKEY_LOCAL_MACHINE,
                           SUBKEY_RELIABILITY,
                           &Key);

    if (ERROR_SUCCESS == WinStatus)
    {
        RegDeleteValue(Key, L"ShutdownEventPending");
        RegCloseKey(Key);
    }

    //
    // We delay time consuming opertaions till the end. We had the case where SendCrashDumpAlert
    // delayed PC Health pop-ups few minutes.
    //

    if (SavedDump) {
        FinalFileName = FileName;
    }

    if (LogEvent) {
        LogCrashDumpEvent (&BugCheckString,
                           FinalFileName,
                           SavedDump);
    }

    if (SendAlert) {
        SendCrashDumpAlert (&BugCheckString,
                            FinalFileName,
                            SavedDump);
    }

    //
    // BUGBUG: We should call RtlFreeUnicodeString for BugCheckString (and somehow determine
    // if it was allocated). I'm not doing this now since original code didn't do this
    // either and I don't want to introduce additional complexity at this moment.
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symsrv.h ===
/*
 * symsrv.h
 */

#ifdef __cplusplus
extern "C" {
#endif


void
AppendHexStringWithDWORD(
    PSTR sz,
    DWORD value
);


void
AppendHexStringWithGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    );


void
AppendHexStringWithOldGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    );


VOID
EnsureTrailingBackslash(
    LPSTR sz
);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\snapshot\test\testsnap.c ===
#define UNICODE
#define _UNICODE
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


#define MAX_SNAPSHOT_SIZE   2048
typedef BOOL (*SNAPSHOTFUNC)(DWORD Flags, LPCTSTR *lpStrings, PLONG MaxBuffSize, LPTSTR SnapShotBuff);

_cdecl main()
{
    HANDLE hEventLog;
    PSID pUserSid = NULL;
    PTOKEN_USER pTokenUser = NULL;
    DWORD dwSidSize = sizeof(SID), dwEventID;
    WCHAR szProcessName[MAX_PATH + 1], szReason[128];
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR lpStrings[7];
    WORD wEventType, wStringCnt;
    WCHAR szShutdownType[32], szMinorReason[32];
    BOOL bRet = FALSE;  
    HMODULE hSnapShot;
    SNAPSHOTFUNC pSnapShotProc;
    struct {
        DWORD Reason ;
        WCHAR SnapShotBuf[MAX_SNAPSHOT_SIZE];
    } SnapShot ;
    LONG SnapShotSize = MAX_SNAPSHOT_SIZE ;
    WCHAR wszDll[MAX_PATH];
    INT sTicks, eTicks;

    wStringCnt = 6;
    lpStrings[0] = L"TestProcess";
    lpStrings[1] = L"TestComputer";
    lpStrings[2] = L"4";
    lpStrings[3] = L"2";
    lpStrings[4] = L"Reboot";
    lpStrings[5] = L"This is a test comment";


    //take a snapshot if shutdown is unplanned.


    //GetWindowsDirectoryW(wszDll, sizeof(wszDll) / sizeof(WCHAR));
    //wcsncat(wszDll, L"\\system32\\snapshot.dll",MAX_PATH - wcslen(wszDll));
    wsprintf(wszDll,L"snapshot.dll");

    hSnapShot = LoadLibrary(wszDll);
    if (! hSnapShot) {
        printf("Load %S failed!\n",wszDll);
    } else {
        pSnapShotProc = (SNAPSHOTFUNC)GetProcAddress(hSnapShot, "LogSystemSnapshot");
        if (!pSnapShotProc) {
            printf("GetProcAddress for LogSystemSnapshot on snapshot.dll failed!\n");
        } else {
            SnapShotSize = MAX_SNAPSHOT_SIZE ;
            __try { // Assume the worst about the snapshot DLL!

                printf("Calling the snapshot DLL\n");

                sTicks = GetTickCount();
                (*pSnapShotProc)(0,lpStrings,&SnapShotSize,&SnapShot.SnapShotBuf[0]);
                eTicks = GetTickCount();

            } __except(EXCEPTION_EXECUTE_HANDLER) {

                printf("Exception Occurred!\n");
                wsprintf(SnapShot.SnapShotBuf, L"State Snapshot took an exception\n");
                eTicks = sTicks = 0 ;

            }
            SnapShotSize = wcslen(SnapShot.SnapShotBuf) ;
        }
        FreeLibrary(hSnapShot);

        if (SnapShotSize > 0) {
           printf("Snapshot buffer is %d bytes\n%S\n",SnapShotSize,SnapShot.SnapShotBuf);
           printf("Time Taken %dms\n",eTicks-sTicks);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symsrv\symsrvp.h ===
/*
 * symsrvp.h
 */

#define CHUNK_SIZE			4096L
enum {
    stFTP = 0,
    stHTTP,
    stHTTPS,
    stUNC,
    stError
};

#define CF_COMPRESSED   0x1

enum {
    ptrValue = 0,
    ptrDWORD,
    ptrGUID,
    ptrOldGUID,
    ptrNumPtrTypes
};

#define TLS // __declspec( thread )

BOOL inetCopy(DWORD, LPCSTR, LPCSTR, LPCSTR, DWORD);
BOOL ftpCopy(DWORD, LPCSTR, LPCSTR, LPCSTR, DWORD);
BOOL httpCopy(DWORD, LPCSTR, LPCSTR, LPCSTR, DWORD);
BOOL fileCopy(DWORD, LPCSTR, LPCSTR, LPCSTR, DWORD);

typedef BOOL (*COPYPROC)(DWORD, LPCSTR, LPCSTR, LPCSTR, DWORD);

typedef struct _SRVTYPEINFO {
    LPCSTR   tag;
    COPYPROC copyproc;
    int      taglen;
} SRVTYPEINFO, *PSRVTYPEINFO;

#ifdef GLOBALS_DOT_C
 #define EXTERN 
#else
 #define EXTERN extern
#endif

EXTERN TLS SRVTYPEINFO gtypeinfo[stError];
EXTERN TLS HINSTANCE ghSymSrv;
EXTERN TLS HINTERNET ghint;
EXTERN TLS UINT_PTR  goptions;
EXTERN TLS DWORD     gparamptr;
EXTERN TLS BOOL      ginetDisabled;
EXTERN TLS PSYMBOLSERVERCALLBACKPROC gcallback;
EXTERN TLS CHAR      gsrvsite[_MAX_PATH];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symsrv\symsrv.c ===
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <windows.h>
#include <wininet.h>
#include <setupapi.h>
#include <dbghelp.h>
#include "symsrv.h"
#include "symsrvp.h"

#if 0
TLS SRVTYPEINFO gtypeinfo[stError] =
{
    {"ftp://",   inetCopy, 6},
    {"http://",  inetCopy, 7},
    {"https://", inetCopy, 8},
    {"",         fileCopy, 0}
};

TLS HINSTANCE ghSymSrv  = 0;
TLS HINTERNET ghint     = INVALID_HANDLE_VALUE;
TLS UINT_PTR  goptions  = 0;
TLS DWORD     gparamptr = ptrValue;
TLS BOOL      ginetDisabled = FALSE;
TLS PSYMBOLSERVERCALLBACKPROC gcallback = NULL;
TLS CHAR      gsrvsite[_MAX_PATH];
#endif

BOOL
SetError(
    DWORD err
    )
{
    SetLastError(err);
    return FALSE;
}


VOID
EnsureTrailingBackslash(
    LPSTR sz
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == '\\')
        return;

    sz[i] = '\\';
    sz[i + 1] = '\0';
}

VOID
EnsureTrailingSlash(
    LPSTR sz
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == '/')
        return;

    sz[i] = '/';
    sz[i + 1] = '\0';
}

void
AppendHexStringWithID(
    IN OUT PSTR sz,
    PVOID id,
    DWORD paramtype
    )
{
    switch (paramtype)
    {
    case ptrValue:
        AppendHexStringWithDWORD(sz, PtrToUlong(id));
        break;
    case ptrDWORD:
        AppendHexStringWithDWORD(sz, *(DWORD *)id);
        break;
    case ptrGUID:
        AppendHexStringWithGUID(sz, (GUID *)id);
        break;
    case ptrOldGUID:
        AppendHexStringWithOldGUID(sz, (GUID *)id);
        break;
    default:
        break;
    }
}


void
AppendHexStringWithDWORD(
    IN OUT PSTR sz,
    IN DWORD value
    )
{
    CHAR buf[_MAX_PATH];

    assert(sz);

    if (!value)
        return;

    sprintf(buf, "%s%x", sz, value);
    strcpy(sz, buf);
}


void
AppendHexStringWithGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    )
{
    CHAR buf[_MAX_PATH];
    int i;

    assert(sz);

    if (!guid)
        return;

    // append the first DWORD in the pointer

    sprintf(buf, "%08X", guid->Data1);
    strcat(sz, buf);

    // this will catch the passing of a PDWORD and avoid
    // all the GUID parsing

    if (!guid->Data2 && !guid->Data3) {
        BYTE byte;
        int i;
        for (i = 0, byte = 0; i < 8; i++) {
            byte |= guid->Data4[i];
            if (byte)
                break;
        }
        if (!byte) {
            return;
        }

    }

    // go ahead and add the rest of the GUID

    sprintf(buf, "%04X", guid->Data2);
    strcat(sz,buf);
    sprintf(buf, "%04X", guid->Data3);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[0]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[1]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[2]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[3]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[4]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[5]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[6]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[7]);
    strcat(sz,buf);
}


void
AppendHexStringWithOldGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    )
{
    CHAR buf[_MAX_PATH];
    int i;

    assert(sz);

    if (!guid)
        return;

    // append the first DWORD in the pointer

    sprintf(buf, "%x", guid->Data1);
    strcat(sz,buf);

    // this will catch the passing of a PDWORD and avoid
    // all the GUID parsing

    if (!guid->Data2 && !guid->Data3) {
        BYTE byte;
        int i;
        for (i = 0, byte = 0; i < 8; i++) {
            byte |= guid->Data4[i];
            if (byte)
                break;
        }
        if (!byte) {
            return;
        }

    }

    // go ahead and add the rest of the GUID

    sprintf(buf, "%x", guid->Data2);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data3);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[0]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[1]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[2]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[3]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[4]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[5]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[6]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[7]);
    strcat(sz,buf);
}


void inetClose();

BOOLEAN
DllMain(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

{
    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:
        ghSymSrv = (HINSTANCE)DllHandle;
        break;

    case DLL_PROCESS_DETACH:
        inetClose();
        break;

    }

    return TRUE;
}


void
dprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "SYMSRV: ";
    va_list args;

    if (!gcallback || !format)
        return;

    va_start(args, format);
    _vsnprintf(buf + 8, sizeof(buf) - 9, format, args);
    va_end(args);
    gcallback(SSRVACTION_TRACE, (ULONG64)buf, 0);
}

void
eprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    if (!gcallback || !format)
        return;

    va_start(args, format);
    _vsnprintf(buf + 9, sizeof(buf) - 9, format, args);
    va_end(args);
    gcallback(SSRVACTION_TRACE, (ULONG64)buf, 0);
}


char
ChangeLastChar(
    LPSTR sz,
    char  newchar
    )
{
    char c;
    DWORD len;

    len = strlen(sz) - 1;
    c = sz[len];
    sz[len] = newchar;

    return c;
}

void inetClose()
{
    if (ghint && ghint != INVALID_HANDLE_VALUE)
        InternetCloseHandle(ghint);
    ghint = INVALID_HANDLE_VALUE;
}


BOOL inetOpen()
{
    DWORD dw;

    // internet handle is null, then we know from previous
    // attempts that it can't be opened, so bail

    if (!ghint)
        return FALSE;

    // initialize the internet connection

    if (ghint == INVALID_HANDLE_VALUE) {

        dw = InternetAttemptConnect(0);
        if (dw != ERROR_SUCCESS) {
            ghint = 0;
            return FALSE;
        }

        ghint = InternetOpen("Microsoft Symbol Server",
                             INTERNET_OPEN_TYPE_PRECONFIG,
                             NULL,
                             NULL,
                             0);
    }

    ginetDisabled = FALSE;

    return (ghint) ? TRUE : FALSE;
}


VOID
ConvertBackslashes(
    LPSTR sz
    )
{
    for (; *sz; sz++) {
        if (*sz == '\\')
            *sz = '/';
    }
}


BOOL
MassageSiteAndFileName(
    IN  LPCSTR srcSite,
    IN  LPCSTR srcFile,
    OUT LPSTR  site,
    OUT LPSTR  file
    )
{
    CHAR          prefix[_MAX_PATH];
    CHAR         *c;

    *prefix = 0;
    *file = 0;
    strcpy(site, srcSite);
    for (c = site; *c;  c++) {
        if (*c == '\\' || *c == '/') {
            *c++ = 0;
            strcpy(prefix, c);
            break;
        }
    }

    if (*prefix) {
        strcpy(file, prefix);
        EnsureTrailingSlash(file);
    }
    strcat(file, srcFile);

    ConvertBackslashes(file);

    return TRUE;

}


DWORD
inetPrompt(
    HINTERNET hreq,
    DWORD     err
    )
{
    if (goptions & SSRVOPT_UNATTENDED)
        return err;

    err = InternetErrorDlg(GetDesktopWindow(),
                           hreq,
                           err,
                           FLAGS_ERROR_UI_FILTER_FOR_ERRORS       |
                           FLAGS_ERROR_UI_FLAGS_GENERATE_DATA     |
                           FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
                           NULL);
    return err;
}


BOOL
UncompressFile(
    IN LPCSTR src,
    IN LPCSTR trg
    )
{
    DWORD rc;

    rc = SetupDecompressOrCopyFile(src, trg, 0);
    if (rc != ERROR_SUCCESS) 
        return SetError(rc);

    return TRUE;
}


BOOL
fileCopy(
    IN DWORD  unused1,
    IN LPCSTR unused2,
    IN LPCSTR src,
    IN LPCSTR trg,
    IN DWORD  comp
    )
{
    OFSTRUCT of;
    INT      fhSrc = -1;
    INT      fhDst = -1;
    BOOL     rc    = FALSE;

    if (!comp)
        rc = CopyFile(src, trg, TRUE);
    else
        rc = UncompressFile(src, trg);

    if (!rc) {
        if (GetLastError() == ERROR_PATH_NOT_FOUND)
            SetLastError(ERROR_FILE_NOT_FOUND);
    }

    return rc;
}

BOOL
ftpCopy(
    IN DWORD  unused,
    IN LPCSTR site,
    IN LPCSTR srv,
    IN LPCSTR trg,
    IN DWORD  comp
    )
{
    BOOL      rc = FALSE;
    HINTERNET hsite;
    CHAR      ftppath[_MAX_PATH + 50];
    LPSTR     subdir;
    DWORD     context = 1;

    if (!inetOpen())
        return FALSE;

    // parse the ftp site spec;

    strcpy(ftppath, site);
    subdir = strchr(ftppath, '/');
    if (!subdir)
        subdir = strchr(ftppath, '\\');
    if (subdir) {
        *subdir++ = 0;
        if (!*subdir)
            subdir = 0;
    }

    hsite = InternetConnect(ghint,
                            ftppath,
                            INTERNET_DEFAULT_FTP_PORT,
                            NULL,
                            NULL,
                            INTERNET_SERVICE_FTP,
                            0,
                            (DWORD_PTR)&context);

    if (hsite)
    {
        if ((!subdir) ||
            (rc = FtpSetCurrentDirectory(hsite, subdir)))
        {
            rc = FtpGetFile(hsite,
                            srv,
                            trg,
                            FALSE,  // fail if exists
                            0,
                            FTP_TRANSFER_TYPE_BINARY,
                            (DWORD_PTR)&context);
        }

        InternetCloseHandle(hsite);
    }

    return rc;
}


DWORD
httpRequest(
    HINTERNET hfile
    )
{
    DWORD err = ERROR_SUCCESS;

    while (!HttpSendRequest(hfile, NULL, 0, NULL, 0))
    {
        err = GetLastError();
        switch (err)
        {
        // These cases get input from the user in oder to try again.
        case ERROR_INTERNET_INCORRECT_PASSWORD:
        case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED:
            err = inetPrompt(hfile,err);
            if (err != ERROR_SUCCESS && err != ERROR_INTERNET_FORCE_RETRY)
            {
                err = ERROR_ACCESS_DENIED;
                return err;
            }
            break;
    
        // These cases get input from the user in order to try again.
        // However, if the user bails, don't use this internet 
        // connection again in this session.
        case ERROR_INTERNET_INVALID_CA:
        case ERROR_INTERNET_SEC_CERT_DATE_INVALID:
        case ERROR_INTERNET_SEC_CERT_CN_INVALID:
        case ERROR_INTERNET_POST_IS_NON_SECURE:
            err = inetPrompt(hfile,err);
            if (err != ERROR_SUCCESS && err != ERROR_INTERNET_FORCE_RETRY)
            {
                ginetDisabled = TRUE;
                err = ERROR_NOT_READY;
                return err;
            }
            break;
        
        // no go - give up the channel
        case ERROR_INTERNET_SECURITY_CHANNEL_ERROR:
            ginetDisabled = TRUE;
            err = ERROR_NOT_READY;
            return err;

        // Tell the user something went wrong and get out of here.
        case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR:
        default:
            inetPrompt(hfile,err);
            return err;
        }
    }
        
    return err;
}


DWORD
httpGetFileInfo(
    HINTERNET hfile
    )
{
    BOOL  rc;
    DWORD err;
    DWORD status;
    DWORD cbstatus = sizeof(status);
    DWORD index    = 0;

    do {
        err = httpRequest(hfile);
        if (err != ERROR_SUCCESS)
            return err;
    
        rc = HttpQueryInfo(hfile,
                           HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                           &status,
                           &cbstatus,
                           &index);
        if (!rc) {
            if (err = GetLastError())
                return err;
            return ERROR_INTERNET_EXTENDED_ERROR;
        }
    
        switch (status)
        {
        case HTTP_STATUS_DENIED:    // need a valid login?
            err = inetPrompt(hfile, ERROR_INTERNET_INCORRECT_PASSWORD);
            // user entered a password - try again
            if (err == ERROR_INTERNET_FORCE_RETRY)
                break;
            // user cancelled
            ginetDisabled = TRUE;
            return ERROR_NOT_READY;
        
        case HTTP_STATUS_FORBIDDEN:
            ginetDisabled = TRUE;
            return ERROR_ACCESS_DENIED;

        case HTTP_STATUS_NOT_FOUND: 
            return ERROR_FILE_NOT_FOUND;
    
        case HTTP_STATUS_OK:
           return ERROR_SUCCESS;
        }
    } while (err == ERROR_INTERNET_FORCE_RETRY);

    return ERROR_INTERNET_EXTENDED_ERROR;
}


DWORD
httpCopyFile(
    IN HINTERNET hsite,
    IN LPSTR     srcfile,
    IN LPSTR     trgfile,
    IN DWORD     flags
    )
{
    HINTERNET     hfile;
    DWORD         read;
    DWORD         written;
    DWORD         err = 0;
    BYTE          buf[CHUNK_SIZE];
    BOOL          rc = FALSE;
    HANDLE        hf = INVALID_HANDLE_VALUE;

    // get the file from the site

    hfile = HttpOpenRequest(hsite,
                            "GET",
                            srcfile,
                            HTTP_VERSION,
                            NULL,
                            NULL,
                            flags,
                            0);
    if (!hfile)
        goto cleanup;

    err = httpGetFileInfo(hfile);
    if (err)
        goto cleanup;

    // write the file

    hf = CreateFile(trgfile,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if (hf == INVALID_HANDLE_VALUE)
        goto cleanup;
        
    do
    {
        rc = InternetReadFile(hfile,
                              (LPVOID)buf,
                              CHUNK_SIZE,
                              &read);
        if (!rc || !read)
            break;
        rc = WriteFile(hf, (LPVOID)buf, read, &written, NULL);
    }
    while (rc);

    dprint("%s copied from %s\n", srcfile, gsrvsite);

cleanup:

    // if there was an error, save it and set it later

    if (!err)
        err = GetLastError();

    // If target file is open, close it.
    // If the file is compressed, expand it.
    // If there is an error, delete target.

    if (hf != INVALID_HANDLE_VALUE)
        CloseHandle(hf);

    // close shop

    if (hfile)
        InternetCloseHandle(hfile);
    
    SetLastError(err);

    return err;
}

BOOL
httpCopy(
    IN DWORD  srvtype,
    IN LPCSTR site,
    IN LPCSTR srv,
    IN LPCSTR trg,
    IN DWORD  comp
    )
{
    BOOL          rc;
    DWORD         err;
    CHAR          file[_MAX_PATH];
    CHAR          srvsite[_MAX_PATH];
    CHAR          trgfile[_MAX_PATH];
    INTERNET_PORT port;
    DWORD         flags = INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION;
    HINTERNET     hsite;

    // parse the site name and file path

    MassageSiteAndFileName(site, srv, srvsite, file);
    strcpy(trgfile, trg);
    strcpy(gsrvsite, srvsite);

    // initialize the connection

    if (!inetOpen())
        return FALSE;
    
    if (srvtype == stHTTPS) {
        port = INTERNET_DEFAULT_HTTPS_PORT;
        flags |= INTERNET_FLAG_SECURE;
    } else {
        port  = INTERNET_DEFAULT_HTTP_PORT;
    }

    hsite = InternetConnect(ghint,
                            srvsite,
                            port,
                            NULL,
                            NULL,
                            INTERNET_SERVICE_HTTP,
                            0,
                            0);
    if (!hsite)
        return FALSE;

    // okay, do it!

    err = httpCopyFile(hsite, file, trgfile, flags);
    if (!err)
        goto cleanup;
    
    if (err != ERROR_FILE_NOT_FOUND)
        goto cleanup;

    // look for a compressed version of the file

    ChangeLastChar(file, '_');
    ChangeLastChar(trgfile, '_');
    err = httpCopyFile(hsite, file, trgfile, flags);
    if (err) 
        goto cleanup;
     
    rc = UncompressFile(trgfile, trg);
    DeleteFile(trgfile);
    if (!rc) {
        DeleteFile(trg);
        err = GetLastError();
    }

cleanup:

    InternetCloseHandle(hsite);
    
    return err ? FALSE : TRUE;
}


BOOL
inetCopy(
    IN DWORD  srvtype,
    IN LPCSTR site,
    IN LPCSTR srv,
    IN LPCSTR trg,
    IN DWORD  comp
    )
{
    BOOL  rc;
    DWORD err;
    CHAR  cSrv[_MAX_PATH + 50];
    CHAR  cTrg[_MAX_PATH + 50];

    if (ginetDisabled) {
        SetLastError(ERROR_NOT_READY);
        return FALSE;
    }

    if (srvtype == stFTP)
        rc = ftpCopy(srvtype, site, srv, trg, comp);
    else
        rc = httpCopy(srvtype, site, srv, trg, comp);
    if (rc)
        return rc;

    err = GetLastError();
    if (err != ERROR_FILE_NOT_FOUND) 
        return rc;
    
    strcpy(cSrv, srv);
    ChangeLastChar(cSrv, '_');
    strcpy(cTrg, trg);
    ChangeLastChar(cTrg, '_');

    if (srvtype == stFTP)
        rc = ftpCopy(srvtype, site, cSrv, cTrg, comp);
    else
        rc = httpCopy(srvtype, site, cSrv, cTrg, comp);
    if (!rc)
        return rc;

    rc = UncompressFile(cTrg, trg);
    DeleteFile(cTrg);

    return rc;
}


/*
 * stolen from dbghelp.dll to avoid circular dll loads
 */

BOOL
EnsurePathExists(
    LPCSTR DirPath,
    LPSTR  ExistingPath
    )
{
    CHAR dir[_MAX_PATH + 1];
    LPSTR p;
    DWORD dw;

    if (ExistingPath)
        *ExistingPath = 0;

    __try {
        // Make a copy of the string for editing.

        strcpy(dir, DirPath);

        p = dir;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p++;
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p++;
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = 0;
                dw = GetFileAttributes(dir);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(dir,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            return FALSE;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        return FALSE;
                    } else {
                        if (ExistingPath)
                            strcpy(ExistingPath, dir);
                    }
                }

                *p = '\\';
            }
            p++;
        }
        SetLastError(NO_ERROR);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
        return(FALSE);
    }

    return TRUE;
}


BOOL
UndoPath(
    LPCSTR DirPath,
    LPCSTR BasePath
    )
{
    CHAR dir[_MAX_PATH + 1];
    LPSTR p;
    DWORD dw;

    dw = GetLastError();

    __try
    {
        strcpy(dir, DirPath);
        for (p = dir + strlen(dir); p > dir; p--)
        {
            if (*p == '\\')
            {
                *p = 0;
                if (*BasePath && !_stricmp(dir, BasePath))
                    break;
                if (!RemoveDirectory(dir))
                    break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        return(FALSE);
    }

    SetLastError(dw);

    return TRUE;
}


/*
 * Given a string, find the next '*' and zero it
 * out to convert the current token into it's
 * own string.  Return the address of the next character,
 * if there are any more strings to parse.
 */

PSTR
GetToken(
    PSTR sz
    )
{
    PSTR p = sz;

    for (;*p; p++) {
        if (*p == '*') {
            *p = 0;
            if (*++p)
                return p;
            break;
        }
    }

    return sz;
}


enum {
    rfpNone = 0,
    rfpFile,
    rfpCompressed
};


DWORD
GetStoreType(
    LPCSTR sz
    )
{
    DWORD i;

    for (i = 0; i < stError; i++) {
        if (!_strnicmp(sz, gtypeinfo[i].tag, gtypeinfo[i].taglen)) {
            return i;
        }
    }

    return stError;
}


BOOL
BuildRelativePath(
    OUT LPSTR rpath,
    IN  LPCSTR filename,
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3      // third number in directory name
    )
{
    LPSTR p;

    assert(rpath);

    strcpy(rpath, filename);
    EnsureTrailingBackslash(rpath);
    AppendHexStringWithID(rpath, id, gparamptr);
    AppendHexStringWithDWORD(rpath, val2);
    AppendHexStringWithDWORD(rpath, val3);

    for (p = rpath + strlen(rpath) - 1; p > rpath; p--) {
        if (*p == '\\') {
            dprint("Insufficient information querying for %s\n", filename);
            SetLastError(ERROR_MORE_DATA);
            return FALSE;
        }
        if (*p != '0')
            return TRUE;
    }

    return TRUE;
}

BOOL
ResolveFilePath(
    IN  DWORD srvtype,
    OUT LPSTR path,
    IN  LPCSTR root,
    IN  LPCSTR rpath,
    IN  LPCSTR file
    )
/*
 * ResolveFilePath
 *
 * given path components, creates a fully qualified path to
 * the symbol file
 *
 * srvtype - type of server we a looking at
 *           UNC, FTP, or HTTP
 *
 * path    - buffer to store manufactered symbol path.  Must be
 *           at least _MAX_PATH characters
 *
 * root    - for of the server path to look in
 *
 * rpath   - relative path from the server root
 *
 * file    - name of symbol file
 *
 * returns true if file was found in the manufactured path, false
 * otherwise.  If ftp is true, the return is always false.
 */
{
    CHAR   fpath[_MAX_PATH + 1];
    HANDLE hptr;
    DWORD  size;
    DWORD  cb;
    CHAR  *p;
    CHAR   c;
    DWORD  rc;

    assert(path && root && *root && rpath && &rpath && file && *file);

    // create file path, save directory path as well

    if (srvtype == stUNC) {
        strcpy(path, root);
        EnsureTrailingBackslash(path);
    } else {
        *path = 0;
    }

    strcat(path, rpath);
    EnsureTrailingBackslash(path);

    strcpy(fpath, path);
    strcat(path, file);

    // if this is an http or ftp path, we're done.

    if (srvtype != stUNC)
        return rfpNone;

    // if symbol file exists, return it

    if (GetFileAttributes(path) != 0xFFFFFFFF)
        return rfpFile;

    // look for a compressed version of the file

    c = ChangeLastChar(path, '_');
    rc = GetFileAttributes(path);
    ChangeLastChar(path, c);
    if (rc != 0xFFFFFFFF)
        return rfpCompressed;

    // look for pointer and read it

    strcat(fpath, "file.ptr");
    if (GetFileAttributes(fpath) == 0xFFFFFFFF)
        return rfpNone;

    hptr = CreateFile(fpath,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

    if (hptr == INVALID_HANDLE_VALUE)
        goto cleanup;

    rc = rfpNone;

    size = GetFileSize(hptr, NULL);
    if (!size || size > _MAX_PATH)
        goto cleanup;

    ZeroMemory(path, _MAX_PATH * sizeof(path[0]));
    if (!ReadFile(hptr, path, size, &cb, 0))
        goto cleanup;

    if (cb != size)
        goto cleanup;

    for (p = path; *p; p++) {
        if (*p == 10  || *p == 13)
        {
            *p = 0;
            break;
        }
    }

    // see if pointer is valid

    if (GetFileAttributes(path) == 0xFFFFFFFF) {
        c = ChangeLastChar(path, '_');
        rc = GetFileAttributes(path);
        ChangeLastChar(path, c);
        if (rc != 0xFFFFFFFF)
            rc = rfpCompressed;
        else
            rc = rfpNone;
    } else {
        rc = (path[strlen(path) - 1] == '_') ? rfpCompressed : rfpFile;
    }

cleanup:
    switch (rc)
    {
    case rfpNone:
        dprint("%s - bad pointer\n", fpath);
        break;
    case rfpFile:
        dprint("%s - pointer OK\n", fpath);
        break;
    }
    if (hptr && hptr != INVALID_HANDLE_VALUE)
        CloseHandle(hptr);
    return rc;
}


BOOL
SymbolServerClose()
{
    inetClose();
    return TRUE;
}


BOOL
TestParameters(
    IN  PCSTR params,   // server and cache path
    IN  PCSTR filename, // name of file to search for
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3,     // third number in directory name
    OUT PSTR  path      // return validated file path here
    )
{
    __try {
        if (path)
            *path = 0;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return SetError(ERROR_INVALID_PARAMETER);
    }

    if (!path || !params || !*params || (!id && !val2 && !val3))
        return SetError(ERROR_INVALID_PARAMETER);

    switch (gparamptr)
    {
    case ptrGUID:
    case ptrOldGUID:
        // this test should AV if a valid GUID pointer wasn't passed in
        __try {
            GUID *guid = (GUID *)id;
            BYTE b;
            b = guid->Data4[8];
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return SetError(ERROR_INVALID_PARAMETER);
        }
        break;
    case ptrDWORD:
        // this test should AV if a valid DWORD pointer wasn't passed in
        __try {
            DWORD dword = *(DWORD *)id;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return SetError(ERROR_INVALID_PARAMETER);
        }
        break;
    }

    return TRUE;
}


BOOL
SymbolServer(
    IN  PCSTR params,   // server and cache path
    IN  PCSTR filename, // name of file to search for
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3,     // third number in directory name
    OUT PSTR  path      // return validated file path here
    )
{
    PSTR  targdir;
    PSTR  srcdir;
    PSTR  p;
    CHAR  sz[_MAX_PATH * 2 + 2];
    CHAR  rpath[_MAX_PATH];
    CHAR  spath[_MAX_PATH];
    CHAR  epath[_MAX_PATH];
    DWORD type = stUNC;
    DWORD rfp;
    BOOL  rc;

    if (!TestParameters(params, filename, id, val2, val3, path))
        return FALSE;

    // parse parameters

    strcpy(sz, params);
    targdir = sz;            // 1st path is where the symbol should be
    srcdir  = GetToken(sz);  // 2nd optional path is the server to copy from

    // if the first store is not UNC, then we have an error...

    type = GetStoreType(targdir);
    switch (type) {
    case stUNC:
        break;
    case stError:
        return SetError(ERROR_INVALID_PARAMETER);
    default:
        return SetError(ERROR_INVALID_NAME);
    }

    // build the relative path to the target symbol file

    if (!BuildRelativePath(rpath, filename, id, val2, val3))
        return FALSE;

    rfp = ResolveFilePath(type, path, targdir, rpath, filename);
    if (rfp == rfpFile) {
        dprint("%s - OK\n", path);
        return TRUE;
    }

    // if this not a cached target, error

    if (srcdir == targdir) {
        if (rfp == rfpCompressed) {
            SetLastError(ERROR_INVALID_NAME);
        } else {
            dprint("%s - file not found.\n", path);
            SetLastError(ERROR_FILE_NOT_FOUND);
        }
        return FALSE;
    }

    // build path to symbol server

    type = GetStoreType(srcdir);
    if (type == stError) {
        return SetError(ERROR_INVALID_PARAMETER);
    }
    srcdir += gtypeinfo[type].taglen;

    rfp = ResolveFilePath(type, spath, srcdir, rpath, filename);

    // copy from server to specified symbol path

    EnsurePathExists(path, epath);
    rc = gtypeinfo[type].copyproc(type, srcdir, spath, path, rfp == rfpCompressed);
    if (!rc)
        return FALSE;

    // test the results and set the return value

    if (GetFileAttributes(path) != 0xFFFFFFFF) {
        dprint("%s - OK\n", path);
        return TRUE;
    }
    UndoPath(path, epath);
    dprint("%s - file not found.\n", path);
    dprint("%s - file not found.\n", spath);

    return FALSE;
}

BOOL
SymbolServerSetOptions(
    UINT_PTR options,
    ULONG64  data
    )
{
    if (options & SSRVOPT_CALLBACK) {
        if (data) {
            goptions |= SSRVOPT_CALLBACK;
            gcallback = (PSYMBOLSERVERCALLBACKPROC)data;
        } else {
            goptions &= ~SSRVOPT_CALLBACK;
            gcallback = NULL;
        }
    }

    if (options & SSRVOPT_DWORD) {
        if (data) {
            goptions |= SSRVOPT_DWORD;
            gparamptr = ptrValue;
        } else {
            goptions &= ~SSRVOPT_DWORD;
            gparamptr = 0;
        }
    }

    if (options & SSRVOPT_DWORDPTR) {
        if (data) {
            goptions |= SSRVOPT_DWORDPTR;
            gparamptr = ptrDWORD;
        } else {
            goptions &= ~SSRVOPT_DWORDPTR;
            gparamptr = 0;
        }
    }

    if (options & SSRVOPT_GUIDPTR) {
        if (data) {
            goptions |= SSRVOPT_GUIDPTR;
            gparamptr = ptrGUID;
        } else {
            goptions &= ~SSRVOPT_GUIDPTR;
            gparamptr = 0;
        }
    }

    if (options & SSRVOPT_OLDGUIDPTR) {
        if (data) {
            goptions |= SSRVOPT_OLDGUIDPTR;
            gparamptr = ptrOldGUID;
        } else {
            goptions &= ~SSRVOPT_OLDGUIDPTR;
            gparamptr = 0;
        }
    }

    if (options & SSRVOPT_UNATTENDED) {
        if (data) {
            goptions |= SSRVOPT_UNATTENDED;
        } else {
            goptions &= ~SSRVOPT_UNATTENDED;
        }
    }

    return TRUE;
}


UINT_PTR
SymbolServerGetOptions(
    )
{
    return goptions;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symstore\msvcrtp.c ===
#include <..\..\imagehlp\msvcrtp.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symsrv\inet.c ===
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <windows.h>
#include <wininet.h>
#include <setupapi.h>
#include <dbghelp.h>
#include "symsrv.h"
#include "symsrvp.h"

#ifndef SYMSTORE

typedef struct _INETSITE {
    DWORD     type;
    HINTERNET hint;
    char      site[_MAX_PATH];
    BOOL      disabled;
} INETSITE, *PINETSITE;

TLS PINETSITE gsites;
TLS DWORD     gcsites = 0;

PINETSITE
inetAddSite(
    )
{
    int       i;
    PINETSITE is;

    // look for an empty slot in the already existing list

//    is = inetUnusedSite();
    is = NULL;
    
    if (!is) {
        // not found: allow a new list or realloc to new size

        i = gcsites + 1;
        if (!gsites) {
            assert(gcsites == 0);
            is = (PINETSITE)malloc(sizeof(INETSITE));
        } else {
            assert(gcsites);
            is = (PINETSITE)realloc(gsites, i * sizeof(INETSITE));
        }
    
        if (!is) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    
        // reset the pointer and increment the count
    
        gsites = is;
        is = gsites + gcsites;
        gcsites++;
    }

    return NULL;
}

#endif







#if 0















BOOL
SetError(
    DWORD err
    )
{
    SetLastError(err);
    return FALSE;
}


VOID
EnsureTrailingBackslash(
    LPSTR sz
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == '\\')
        return;

    sz[i] = '\\';
    sz[i + 1] = '\0';
}

VOID
EnsureTrailingSlash(
    LPSTR sz
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == '/')
        return;

    sz[i] = '/';
    sz[i + 1] = '\0';
}

void
AppendHexStringWithID(
    IN OUT PSTR sz,
    PVOID id,
    DWORD paramtype
    )
{
    switch (paramtype)
    {
    case ptrValue:
        AppendHexStringWithDWORD(sz, PtrToUlong(id));
        break;
    case ptrDWORD:
        AppendHexStringWithDWORD(sz, *(DWORD *)id);
        break;
    case ptrGUID:
        AppendHexStringWithGUID(sz, (GUID *)id);
        break;
    case ptrOldGUID:
        AppendHexStringWithOldGUID(sz, (GUID *)id);
        break;
    default:
        break;
    }
}


void
AppendHexStringWithDWORD(
    IN OUT PSTR sz,
    IN DWORD value
    )
{
    CHAR buf[_MAX_PATH];

    assert(sz);

    if (!value)
        return;

    sprintf(buf, "%s%x", sz, value);
    strcpy(sz, buf);
}


void
AppendHexStringWithGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    )
{
    CHAR buf[_MAX_PATH];
    int i;

    assert(sz);

    if (!guid)
        return;

    // append the first DWORD in the pointer

    sprintf(buf, "%08X", guid->Data1);
    strcat(sz, buf);

    // this will catch the passing of a PDWORD and avoid
    // all the GUID parsing

    if (!guid->Data2 && !guid->Data3) {
        BYTE byte;
        int i;
        for (i = 0, byte = 0; i < 8; i++) {
            byte |= guid->Data4[i];
            if (byte)
                break;
        }
        if (!byte) {
            return;
        }

    }

    // go ahead and add the rest of the GUID

    sprintf(buf, "%04X", guid->Data2);
    strcat(sz,buf);
    sprintf(buf, "%04X", guid->Data3);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[0]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[1]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[2]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[3]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[4]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[5]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[6]);
    strcat(sz,buf);
    sprintf(buf, "%02X", guid->Data4[7]);
    strcat(sz,buf);
}


void
AppendHexStringWithOldGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    )
{
    CHAR buf[_MAX_PATH];
    int i;

    assert(sz);

    if (!guid)
        return;

    // append the first DWORD in the pointer

    sprintf(buf, "%x", guid->Data1);
    strcat(sz,buf);

    // this will catch the passing of a PDWORD and avoid
    // all the GUID parsing

    if (!guid->Data2 && !guid->Data3) {
        BYTE byte;
        int i;
        for (i = 0, byte = 0; i < 8; i++) {
            byte |= guid->Data4[i];
            if (byte)
                break;
        }
        if (!byte) {
            return;
        }

    }

    // go ahead and add the rest of the GUID

    sprintf(buf, "%x", guid->Data2);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data3);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[0]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[1]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[2]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[3]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[4]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[5]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[6]);
    strcat(sz,buf);
    sprintf(buf, "%x", guid->Data4[7]);
    strcat(sz,buf);
}



#ifndef SYMSTORE

void inetClose();

BOOLEAN
DllMain(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

{
    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:
        ghSymSrv = (HINSTANCE)DllHandle;
        break;

    case DLL_PROCESS_DETACH:
        inetClose();
        break;

    }

    return TRUE;
}


void
dprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "SYMSRV: ";
    va_list args;

    if (!gcallback || !format)
        return;

    va_start(args, format);
    _vsnprintf(buf + 8, sizeof(buf) - 9, format, args);
    va_end(args);
    gcallback(SSRVACTION_TRACE, (ULONG64)buf, 0);
}

void
eprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    if (!gcallback || !format)
        return;

    va_start(args, format);
    _vsnprintf(buf + 9, sizeof(buf) - 9, format, args);
    va_end(args);
    gcallback(SSRVACTION_TRACE, (ULONG64)buf, 0);
}


char
ChangeLastChar(
    LPSTR sz,
    char  newchar
    )
{
    char c;
    DWORD len;

    len = strlen(sz) - 1;
    c = sz[len];
    sz[len] = newchar;

    return c;
}

void inetClose()
{
    if (ghint && ghint != INVALID_HANDLE_VALUE)
        InternetCloseHandle(ghint);
    ghint = INVALID_HANDLE_VALUE;
}


BOOL inetOpen()
{
    DWORD dw;

    // internet handle is null, then we know from previous
    // attempts that it can't be opened, so bail

    if (!ghint)
        return FALSE;

    // initialize the internet connection

    if (ghint == INVALID_HANDLE_VALUE) {

        dw = InternetAttemptConnect(0);
        if (dw != ERROR_SUCCESS) {
            ghint = 0;
            return FALSE;
        }

        ghint = InternetOpen("Microsoft Symbol Server",
                             INTERNET_OPEN_TYPE_PRECONFIG,
                             NULL,
                             NULL,
                             0);
    }

    ginetDisabled = FALSE;

    return (ghint) ? TRUE : FALSE;
}


VOID
ConvertBackslashes(
    LPSTR sz
    )
{
    for (; *sz; sz++) {
        if (*sz == '\\')
            *sz = '/';
    }
}


BOOL
MassageSiteAndFileName(
    IN  LPCSTR srcSite,
    IN  LPCSTR srcFile,
    OUT LPSTR  site,
    OUT LPSTR  file
    )
{
    CHAR          prefix[_MAX_PATH];
    CHAR         *c;

    *prefix = 0;
    *file = 0;
    strcpy(site, srcSite);
    for (c = site; *c;  c++) {
        if (*c == '\\' || *c == '/') {
            *c++ = 0;
            strcpy(prefix, c);
            break;
        }
    }

    if (*prefix) {
        strcpy(file, prefix);
        EnsureTrailingSlash(file);
    }
    strcat(file, srcFile);

    ConvertBackslashes(file);

    return TRUE;

}


DWORD
inetPrompt(
    HINTERNET hreq,
    DWORD     err
    )
{
    if (goptions & SSRVOPT_UNATTENDED)
        return err;

    err = InternetErrorDlg(GetDesktopWindow(),
                           hreq,
                           err,
                           FLAGS_ERROR_UI_FILTER_FOR_ERRORS       |
                           FLAGS_ERROR_UI_FLAGS_GENERATE_DATA     |
                           FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
                           NULL);
    return err;
}


BOOL
UncompressFile(
    IN LPCSTR src,
    IN LPCSTR trg
    )
{
    DWORD rc;

    rc = SetupDecompressOrCopyFile(src, trg, 0);
    if (rc != ERROR_SUCCESS) 
        return SetError(rc);

    return TRUE;
}


BOOL
fileCopy(
    IN DWORD  unused1,
    IN LPCSTR unused2,
    IN LPCSTR src,
    IN LPCSTR trg,
    IN DWORD  comp
    )
{
    OFSTRUCT of;
    INT      fhSrc = -1;
    INT      fhDst = -1;
    BOOL     rc    = FALSE;

    if (!comp)
        rc = CopyFile(src, trg, TRUE);
    else
        rc = UncompressFile(src, trg);

    if (!rc) {
        if (GetLastError() == ERROR_PATH_NOT_FOUND)
            SetLastError(ERROR_FILE_NOT_FOUND);
    }

    return rc;
}

BOOL
ftpCopy(
    IN DWORD  unused,
    IN LPCSTR site,
    IN LPCSTR srv,
    IN LPCSTR trg,
    IN DWORD  comp
    )
{
    BOOL      rc = FALSE;
    HINTERNET hsite;
    CHAR      ftppath[_MAX_PATH + 50];
    LPSTR     subdir;
    DWORD     context = 1;

    if (!inetOpen())
        return FALSE;

    // parse the ftp site spec;

    strcpy(ftppath, site);
    subdir = strchr(ftppath, '/');
    if (!subdir)
        subdir = strchr(ftppath, '\\');
    if (subdir) {
        *subdir++ = 0;
        if (!*subdir)
            subdir = 0;
    }

    hsite = InternetConnect(ghint,
                            ftppath,
                            INTERNET_DEFAULT_FTP_PORT,
                            NULL,
                            NULL,
                            INTERNET_SERVICE_FTP,
                            0,
                            (DWORD_PTR)&context);

    if (hsite)
    {
        if ((!subdir) ||
            (rc = FtpSetCurrentDirectory(hsite, subdir)))
        {
            rc = FtpGetFile(hsite,
                            srv,
                            trg,
                            FALSE,  // fail if exists
                            0,
                            FTP_TRANSFER_TYPE_BINARY,
                            (DWORD_PTR)&context);
        }

        InternetCloseHandle(hsite);
    }

    return rc;
}


DWORD
httpRequest(
    HINTERNET hfile
    )
{
    DWORD err = ERROR_SUCCESS;

    while (!HttpSendRequest(hfile, NULL, 0, NULL, 0))
    {
        err = GetLastError();
        switch (err)
        {
        // These cases get input from the user in oder to try again.
        case ERROR_INTERNET_INCORRECT_PASSWORD:
        case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED:
            err = inetPrompt(hfile,err);
            if (err != ERROR_SUCCESS && err != ERROR_INTERNET_FORCE_RETRY)
            {
                err = ERROR_ACCESS_DENIED;
                return err;
            }
            break;
    
        // These cases get input from the user in order to try again.
        // However, if the user bails, don't use this internet 
        // connection again in this session.
        case ERROR_INTERNET_INVALID_CA:
        case ERROR_INTERNET_SEC_CERT_DATE_INVALID:
        case ERROR_INTERNET_SEC_CERT_CN_INVALID:
        case ERROR_INTERNET_POST_IS_NON_SECURE:
            err = inetPrompt(hfile,err);
            if (err != ERROR_SUCCESS && err != ERROR_INTERNET_FORCE_RETRY)
            {
                ginetDisabled = TRUE;
                err = ERROR_NOT_READY;
                return err;
            }
            break;
        
        // no go - give up the channel
        case ERROR_INTERNET_SECURITY_CHANNEL_ERROR:
            ginetDisabled = TRUE;
            err = ERROR_NOT_READY;
            return err;

        // Tell the user something went wrong and get out of here.
        case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR:
        default:
            inetPrompt(hfile,err);
            return err;
        }
    }
        
    return err;
}


DWORD
httpGetFileInfo(
    HINTERNET hfile
    )
{
    BOOL  rc;
    DWORD err;
    DWORD status;
    DWORD cbstatus = sizeof(status);
    DWORD index    = 0;

    do {
        err = httpRequest(hfile);
        if (err != ERROR_SUCCESS)
            return err;
    
        rc = HttpQueryInfo(hfile,
                           HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                           &status,
                           &cbstatus,
                           &index);
        if (!rc) {
            if (err = GetLastError())
                return err;
            return ERROR_INTERNET_EXTENDED_ERROR;
        }
    
        switch (status)
        {
        case HTTP_STATUS_DENIED:    // need a valid login?
            err = inetPrompt(hfile, ERROR_INTERNET_INCORRECT_PASSWORD);
            // user entered a password - try again
            if (err == ERROR_INTERNET_FORCE_RETRY)
                break;
            // user cancelled
            ginetDisabled = TRUE;
            return ERROR_NOT_READY;
        
        case HTTP_STATUS_FORBIDDEN:
            ginetDisabled = TRUE;
            return ERROR_ACCESS_DENIED;

        case HTTP_STATUS_NOT_FOUND: 
            return ERROR_FILE_NOT_FOUND;
    
        case HTTP_STATUS_OK:
           return ERROR_SUCCESS;
        }
    } while (err == ERROR_INTERNET_FORCE_RETRY);

    return ERROR_INTERNET_EXTENDED_ERROR;
}


DWORD
httpCopyFile(
    IN HINTERNET hsite,
    IN LPSTR     srcfile,
    IN LPSTR     trgfile,
    IN DWORD     flags
    )
{
    HINTERNET     hfile;
    DWORD         read;
    DWORD         written;
    DWORD         err = 0;
    BYTE          buf[CHUNK_SIZE];
    BOOL          rc = FALSE;
    HANDLE        hf = INVALID_HANDLE_VALUE;

    // get the file from the site

    hfile = HttpOpenRequest(hsite,
                            "GET",
                            srcfile,
                            HTTP_VERSION,
                            NULL,
                            NULL,
                            flags,
                            0);
    if (!hfile)
        goto cleanup;

    err = httpGetFileInfo(hfile);
    if (err)
        goto cleanup;

    // write the file

    hf = CreateFile(trgfile,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if (hf == INVALID_HANDLE_VALUE)
        goto cleanup;
        
    do
    {
        rc = InternetReadFile(hfile,
                              (LPVOID)buf,
                              CHUNK_SIZE,
                              &read);
        if (!rc || !read)
            break;
        rc = WriteFile(hf, (LPVOID)buf, read, &written, NULL);
    }
    while (rc);

    dprint("%s copied from %s\n", srcfile, gsrvsite);

cleanup:

    // if there was an error, save it and set it later

    if (!err)
        err = GetLastError();

    // If target file is open, close it.
    // If the file is compressed, expand it.
    // If there is an error, delete target.

    if (hf != INVALID_HANDLE_VALUE)
        CloseHandle(hf);

    // close shop

    if (hfile)
        InternetCloseHandle(hfile);
    
    SetLastError(err);

    return err;
}

BOOL
httpCopy(
    IN DWORD  srvtype,
    IN LPCSTR site,
    IN LPCSTR srv,
    IN LPCSTR trg,
    IN DWORD  comp
    )
{
    BOOL          rc;
    DWORD         err;
    CHAR          file[_MAX_PATH];
    CHAR          srvsite[_MAX_PATH];
    CHAR          trgfile[_MAX_PATH];
    INTERNET_PORT port;
    DWORD         flags = INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION;
    HINTERNET     hsite;

    // parse the site name and file path

    MassageSiteAndFileName(site, srv, srvsite, file);
    strcpy(trgfile, trg);
    strcpy(gsrvsite, srvsite);

    // initialize the connection

    if (!inetOpen())
        return FALSE;
    
    if (srvtype == stHTTPS) {
        port = INTERNET_DEFAULT_HTTPS_PORT;
        flags |= INTERNET_FLAG_SECURE;
    } else {
        port  = INTERNET_DEFAULT_HTTP_PORT;
    }

    hsite = InternetConnect(ghint,
                            srvsite,
                            port,
                            NULL,
                            NULL,
                            INTERNET_SERVICE_HTTP,
                            0,
                            0);
    if (!hsite)
        return FALSE;

    // okay, do it!

    err = httpCopyFile(hsite, file, trgfile, flags);
    if (!err)
        goto cleanup;
    
    if (err != ERROR_FILE_NOT_FOUND)
        goto cleanup;

    // look for a compressed version of the file

    ChangeLastChar(file, '_');
    ChangeLastChar(trgfile, '_');
    err = httpCopyFile(hsite, file, trgfile, flags);
    if (err) 
        goto cleanup;
     
    rc = UncompressFile(trgfile, trg);
    DeleteFile(trgfile);
    if (!rc) {
        DeleteFile(trg);
        err = GetLastError();
    }

cleanup:

    InternetCloseHandle(hsite);
    
    return err ? FALSE : TRUE;
}


BOOL
inetCopy(
    IN DWORD  srvtype,
    IN LPCSTR site,
    IN LPCSTR srv,
    IN LPCSTR trg,
    IN DWORD  comp
    )
{
    BOOL  rc;
    DWORD err;
    CHAR  cSrv[_MAX_PATH + 50];
    CHAR  cTrg[_MAX_PATH + 50];

    if (ginetDisabled) {
        SetLastError(ERROR_NOT_READY);
        return FALSE;
    }

    if (srvtype == stFTP)
        rc = ftpCopy(srvtype, site, srv, trg, comp);
    else
        rc = httpCopy(srvtype, site, srv, trg, comp);
    if (rc)
        return rc;

    err = GetLastError();
    if (err != ERROR_FILE_NOT_FOUND) 
        return rc;
    
    strcpy(cSrv, srv);
    ChangeLastChar(cSrv, '_');
    strcpy(cTrg, trg);
    ChangeLastChar(cTrg, '_');

    if (srvtype == stFTP)
        rc = ftpCopy(srvtype, site, cSrv, cTrg, comp);
    else
        rc = httpCopy(srvtype, site, cSrv, cTrg, comp);
    if (!rc)
        return rc;

    rc = UncompressFile(cTrg, trg);
    DeleteFile(cTrg);

    return rc;
}


/*
 * stolen from dbghelp.dll to avoid circular dll loads
 */

BOOL
EnsurePathExists(
    LPCSTR DirPath,
    LPSTR  ExistingPath
    )
{
    CHAR dir[_MAX_PATH + 1];
    LPSTR p;
    DWORD dw;

    if (ExistingPath)
        *ExistingPath = 0;

    __try {
        // Make a copy of the string for editing.

        strcpy(dir, DirPath);

        p = dir;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p++;
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p++;
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = 0;
                dw = GetFileAttributes(dir);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(dir,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            return FALSE;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        return FALSE;
                    } else {
                        if (ExistingPath)
                            strcpy(ExistingPath, dir);
                    }
                }

                *p = '\\';
            }
            p++;
        }
        SetLastError(NO_ERROR);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
        return(FALSE);
    }

    return TRUE;
}


BOOL
UndoPath(
    LPCSTR DirPath,
    LPCSTR BasePath
    )
{
    CHAR dir[_MAX_PATH + 1];
    LPSTR p;
    DWORD dw;

    dw = GetLastError();

    __try
    {
        strcpy(dir, DirPath);
        for (p = dir + strlen(dir); p > dir; p--)
        {
            if (*p == '\\')
            {
                *p = 0;
                if (*BasePath && !_stricmp(dir, BasePath))
                    break;
                if (!RemoveDirectory(dir))
                    break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        return(FALSE);
    }

    SetLastError(dw);

    return TRUE;
}


/*
 * Given a string, find the next '*' and zero it
 * out to convert the current token into it's
 * own string.  Return the address of the next character,
 * if there are any more strings to parse.
 */

PSTR
GetToken(
    PSTR sz
    )
{
    PSTR p = sz;

    for (;*p; p++) {
        if (*p == '*') {
            *p = 0;
            if (*++p)
                return p;
            break;
        }
    }

    return sz;
}


enum {
    rfpNone = 0,
    rfpFile,
    rfpCompressed
};


DWORD
GetStoreType(
    LPCSTR sz
    )
{
    DWORD i;

    for (i = 0; i < stError; i++) {
        if (!_strnicmp(sz, gtypeinfo[i].tag, gtypeinfo[i].taglen)) {
            return i;
        }
    }

    return stError;
}


BOOL
BuildRelativePath(
    OUT LPSTR rpath,
    IN  LPCSTR filename,
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3      // third number in directory name
    )
{
    LPSTR p;

    assert(rpath);

    strcpy(rpath, filename);
    EnsureTrailingBackslash(rpath);
    AppendHexStringWithID(rpath, id, gparamptr);
    AppendHexStringWithDWORD(rpath, val2);
    AppendHexStringWithDWORD(rpath, val3);

    for (p = rpath + strlen(rpath) - 1; p > rpath; p--) {
        if (*p == '\\') {
            dprint("Insufficient information querying for %s\n", filename);
            SetLastError(ERROR_MORE_DATA);
            return FALSE;
        }
        if (*p != '0')
            return TRUE;
    }

    return TRUE;
}

BOOL
ResolveFilePath(
    IN  DWORD srvtype,
    OUT LPSTR path,
    IN  LPCSTR root,
    IN  LPCSTR rpath,
    IN  LPCSTR file
    )
/*
 * ResolveFilePath
 *
 * given path components, creates a fully qualified path to
 * the symbol file
 *
 * srvtype - type of server we a looking at
 *           UNC, FTP, or HTTP
 *
 * path    - buffer to store manufactered symbol path.  Must be
 *           at least _MAX_PATH characters
 *
 * root    - for of the server path to look in
 *
 * rpath   - relative path from the server root
 *
 * file    - name of symbol file
 *
 * returns true if file was found in the manufactured path, false
 * otherwise.  If ftp is true, the return is always false.
 */
{
    CHAR   fpath[_MAX_PATH + 1];
    HANDLE hptr;
    DWORD  size;
    DWORD  cb;
    CHAR  *p;
    CHAR   c;
    DWORD  rc;

    assert(path && root && *root && rpath && &rpath && file && *file);

    // create file path, save directory path as well

    if (srvtype == stUNC) {
        strcpy(path, root);
        EnsureTrailingBackslash(path);
    } else {
        *path = 0;
    }

    strcat(path, rpath);
    EnsureTrailingBackslash(path);

    strcpy(fpath, path);
    strcat(path, file);

    // if this is an http or ftp path, we're done.

    if (srvtype != stUNC)
        return rfpNone;

    // if symbol file exists, return it

    if (GetFileAttributes(path) != 0xFFFFFFFF)
        return rfpFile;

    // look for a compressed version of the file

    c = ChangeLastChar(path, '_');
    rc = GetFileAttributes(path);
    ChangeLastChar(path, c);
    if (rc != 0xFFFFFFFF)
        return rfpCompressed;

    // look for pointer and read it

    strcat(fpath, "file.ptr");
    if (GetFileAttributes(fpath) == 0xFFFFFFFF)
        return rfpNone;

    hptr = CreateFile(fpath,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

    if (hptr == INVALID_HANDLE_VALUE)
        goto cleanup;

    rc = rfpNone;

    size = GetFileSize(hptr, NULL);
    if (!size || size > _MAX_PATH)
        goto cleanup;

    ZeroMemory(path, _MAX_PATH * sizeof(path[0]));
    if (!ReadFile(hptr, path, size, &cb, 0))
        goto cleanup;

    if (cb != size)
        goto cleanup;

    for (p = path; *p; p++) {
        if (*p == 10  || *p == 13)
        {
            *p = 0;
            break;
        }
    }

    // see if pointer is valid

    if (GetFileAttributes(path) == 0xFFFFFFFF) {
        c = ChangeLastChar(path, '_');
        rc = GetFileAttributes(path);
        ChangeLastChar(path, c);
        if (rc != 0xFFFFFFFF)
            rc = rfpCompressed;
        else
            rc = rfpNone;
    } else {
        rc = (path[strlen(path) - 1] == '_') ? rfpCompressed : rfpFile;
    }

cleanup:
    switch (rc)
    {
    case rfpNone:
        dprint("%s - bad pointer\n", fpath);
        break;
    case rfpFile:
        dprint("%s - pointer OK\n", fpath);
        break;
    }
    if (hptr && hptr != INVALID_HANDLE_VALUE)
        CloseHandle(hptr);
    return rc;
}


BOOL
SymbolServerClose()
{
    inetClose();
    return TRUE;
}


BOOL
TestParameters(
    IN  PCSTR params,   // server and cache path
    IN  PCSTR filename, // name of file to search for
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3,     // third number in directory name
    OUT PSTR  path      // return validated file path here
    )
{
    __try {
        if (path)
            *path = 0;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return SetError(ERROR_INVALID_PARAMETER);
    }

    if (!path || !params || !*params || (!id && !val2 && !val3))
        return SetError(ERROR_INVALID_PARAMETER);

    switch (gparamptr)
    {
    case ptrGUID:
    case ptrOldGUID:
        // this test should AV if a valid GUID pointer wasn't passed in
        __try {
            GUID *guid = (GUID *)id;
            BYTE b;
            b = guid->Data4[8];
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return SetError(ERROR_INVALID_PARAMETER);
        }
        break;
    case ptrDWORD:
        // this test should AV if a valid DWORD pointer wasn't passed in
        __try {
            DWORD dword = *(DWORD *)id;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return SetError(ERROR_INVALID_PARAMETER);
        }
        break;
    }

    return TRUE;
}


BOOL
SymbolServer(
    IN  PCSTR params,   // server and cache path
    IN  PCSTR filename, // name of file to search for
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3,     // third number in directory name
    OUT PSTR  path      // return validated file path here
    )
{
    PSTR  targdir;
    PSTR  srcdir;
    PSTR  p;
    CHAR  sz[_MAX_PATH * 2 + 2];
    CHAR  rpath[_MAX_PATH];
    CHAR  spath[_MAX_PATH];
    CHAR  epath[_MAX_PATH];
    DWORD type = stUNC;
    DWORD rfp;
    BOOL  rc;

    if (!TestParameters(params, filename, id, val2, val3, path))
        return FALSE;

    // parse parameters

    strcpy(sz, params);
    targdir = sz;            // 1st path is where the symbol should be
    srcdir  = GetToken(sz);  // 2nd optional path is the server to copy from

    // if the first store is not UNC, then we have an error...

    type = GetStoreType(targdir);
    switch (type) {
    case stUNC:
        break;
    case stError:
        return SetError(ERROR_INVALID_PARAMETER);
    default:
        return SetError(ERROR_INVALID_NAME);
    }

    // build the relative path to the target symbol file

    if (!BuildRelativePath(rpath, filename, id, val2, val3))
        return FALSE;

    rfp = ResolveFilePath(type, path, targdir, rpath, filename);
    if (rfp == rfpFile) {
        dprint("%s - OK\n", path);
        return TRUE;
    }

    // if this not a cached target, error

    if (srcdir == targdir) {
        if (rfp == rfpCompressed) {
            SetLastError(ERROR_INVALID_NAME);
        } else {
            dprint("%s - file not found.\n", path);
            SetLastError(ERROR_FILE_NOT_FOUND);
        }
        return FALSE;
    }

    // build path to symbol server

    type = GetStoreType(srcdir);
    if (type == stError) {
        return SetError(ERROR_INVALID_PARAMETER);
    }
    srcdir += gtypeinfo[type].taglen;

    rfp = ResolveFilePath(type, spath, srcdir, rpath, filename);

    // copy from server to specified symbol path

    EnsurePathExists(path, epath);
    rc = gtypeinfo[type].copyproc(type, srcdir, spath, path, rfp == rfpCompressed);
    if (!rc)
        return FALSE;

    // test the results and set the return value

    if (GetFileAttributes(path) != 0xFFFFFFFF) {
        dprint("%s - OK\n", path);
        return TRUE;
    }
    UndoPath(path, epath);
    dprint("%s - file not found.\n", path);
    dprint("%s - file not found.\n", spath);

    return FALSE;
}

BOOL
SymbolServerSetOptions(
    UINT_PTR options,
    ULONG64  data
    )
{
    if (options & SSRVOPT_CALLBACK) {
        if (data) {
            goptions |= SSRVOPT_CALLBACK;
            gcallback = (PSYMBOLSERVERCALLBACKPROC)data;
        } else {
            goptions &= ~SSRVOPT_CALLBACK;
            gcallback = NULL;
        }
    }

    if (options & SSRVOPT_DWORD) {
        if (data) {
            goptions |= SSRVOPT_DWORD;
            gparamptr = ptrValue;
        } else {
            goptions &= ~SSRVOPT_DWORD;
            gparamptr = 0;
        }
    }

    if (options & SSRVOPT_DWORDPTR) {
        if (data) {
            goptions |= SSRVOPT_DWORDPTR;
            gparamptr = ptrDWORD;
        } else {
            goptions &= ~SSRVOPT_DWORDPTR;
            gparamptr = 0;
        }
    }

    if (options & SSRVOPT_GUIDPTR) {
        if (data) {
            goptions |= SSRVOPT_GUIDPTR;
            gparamptr = ptrGUID;
        } else {
            goptions &= ~SSRVOPT_GUIDPTR;
            gparamptr = 0;
        }
    }

    if (options & SSRVOPT_OLDGUIDPTR) {
        if (data) {
            goptions |= SSRVOPT_OLDGUIDPTR;
            gparamptr = ptrOldGUID;
        } else {
            goptions &= ~SSRVOPT_OLDGUIDPTR;
            gparamptr = 0;
        }
    }

    if (options & SSRVOPT_UNATTENDED) {
        if (data) {
            goptions |= SSRVOPT_UNATTENDED;
        } else {
            goptions &= ~SSRVOPT_UNATTENDED;
        }
    }

    return TRUE;
}


UINT_PTR
SymbolServerGetOptions(
    )
{
    return goptions;
}

#endif // #ifndef SYMSTORE










#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symsrv\globals.c ===
/*
 * globals.c
 */

#define GLOBALS_DOT_C   1

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <windows.h>
#include <wininet.h>
#include <setupapi.h>
#include <dbghelp.h>
#include "symsrv.h"
#include "symsrvp.h"

TLS SRVTYPEINFO gtypeinfo[stError] =
{
    {"ftp://",   inetCopy, 6},
    {"http://",  inetCopy, 7},
    {"https://", inetCopy, 8},
    {"",         fileCopy, 0}
};

TLS HINSTANCE ghSymSrv  = 0;
TLS HINTERNET ghint     = INVALID_HANDLE_VALUE;
TLS UINT_PTR  goptions  = 0;
TLS DWORD     gparamptr = ptrValue;
TLS BOOL      ginetDisabled = FALSE;
TLS PSYMBOLSERVERCALLBACKPROC gcallback = NULL;
TLS CHAR      gsrvsite[_MAX_PATH];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symsrv\dload.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <dbghelp.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <wininet.h>
    
#include <delayimp.h>

#define FreeLib(hDll)   \
    {if (hDll && hDll != INVALID_HANDLE_VALUE) FreeLibrary(hDll);}

typedef struct
{
    PCHAR Name;
    FARPROC Function;
} FUNCPTRS;

#if DBG
void
OutputDBString(
    CHAR *text
    );
#endif

extern HINSTANCE ghSymSrv;

DWORD FailSetupDecompressOrCopyFile(
    PCTSTR SourceFileName, // filename of the source file
    PCTSTR TargetFileName, // filename after copy operation
    PUINT CompressionType  // optional, source file compression
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    return ERROR_MOD_NOT_FOUND;
}

DWORD FailInternetAttemptConnect(
    IN DWORD dwReserved
    )
{ 
    SetLastError(ERROR_MOD_NOT_FOUND);
    return ERROR_MOD_NOT_FOUND;
}

HINTERNET FailInternetOpen(
    IN LPCTSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCTSTR lpszProxyName,
    IN LPCTSTR lpszProxyBypass,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    return 0;
}

HINTERNET FailInternetConnect(
    IN HINTERNET hInternet,
    IN LPCTSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCTSTR lpszUserName,
    IN LPCTSTR lpszPassword,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    return 0;
}

BOOL FailFtpGetFile(
    IN HINTERNET hConnect,
    IN LPCTSTR lpszRemoteFile,
    IN LPCTSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    return FALSE;
}

BOOL FailInternetCloseHandle(
    IN HINTERNET hInternet
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    return FALSE;
}

DWORD FailInternetErrorDlg(
    IN HWND hWnd,
    IN OUT HINTERNET hRequest,
    IN DWORD dwError,
    IN DWORD dwFlags,
    IN OUT LPVOID *lppvData
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    return ERROR_MOD_NOT_FOUND;
}


FUNCPTRS FailPtrs[] = {
    {"SetupDecompressOrCopyFile",   (FARPROC)FailSetupDecompressOrCopyFile},
    {"InternetAttemptConnect",      (FARPROC)FailInternetAttemptConnect},
    {"InternetOpen",                (FARPROC)FailInternetOpen},
    {"InternetConnect",             (FARPROC)FailInternetConnect},
    {"FtpGetFile",                  (FARPROC)FailFtpGetFile},
    {"InternetErrorDlg",            (FARPROC)FailInternetErrorDlg},
    {NULL, NULL}
};

FUNCPTRS *FailFunctions[1] = {FailPtrs};

HINSTANCE hDelayLoadDll[1];

FARPROC
FindFailureProc(
                UINT Index,
                const char *szProcName
                )
{
    FUNCPTRS *fp = FailFunctions[Index];
    UINT x = 0;

    while (fp[x].Name) {
        if (!lstrcmpi(fp[x].Name, szProcName)) {
            return fp[x].Function;
        }
        x++;
    }
    return NULL;
}


FARPROC
WINAPI
SymSrvDelayLoadHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    )
{
    FARPROC rc = NULL;

    if (dliStartProcessing == unReason)
    {
        DWORD iDll = 0;  // currently there is only one delayloaded dll
        
        if (!hDelayLoadDll[iDll] || hDelayLoadDll[iDll] == INVALID_HANDLE_VALUE) {
            hDelayLoadDll[iDll] = LoadLibrary(pDelayInfo->szDll);
            if (!hDelayLoadDll[iDll]) {
                hDelayLoadDll[iDll] = INVALID_HANDLE_VALUE;
            }
        }
            
        if (INVALID_HANDLE_VALUE != hDelayLoadDll[iDll] && ghSymSrv) 
            rc = GetProcAddress(hDelayLoadDll[iDll], pDelayInfo->dlp.szProcName);

        if (!rc) 
            rc = FindFailureProc(iDll, pDelayInfo->dlp.szProcName);
#if DBG
        if (!rc) 
            OutputDBString("BogusDelayLoad function encountered...\n");
#endif
    }

    if (rc && ghSymSrv) 
        *pDelayInfo->ppfn = rc;
    
    return rc;
}


#if 0
typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;
#endif



PfnDliHook __pfnDliNotifyHook = SymSrvDelayLoadHook;
PfnDliHook __pfnDliFailureHook = NULL;


#if DBG

void
OutputDBString(
    CHAR *text
    )
{
    CHAR sz[256];

    sprintf(sz, "SYMSRV: %s", text);
    OutputDebugString(sz);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symstore\symstore.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include "symutil.h"
#include "symsrv.h"

typedef struct _FILE_INFO {
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       Signature;
    TCHAR       szName[_MAX_PATH+ _MAX_FNAME + _MAX_EXT + 2];
} FILE_INFO, *PFILE_INFO;

// Prototypes

PCOM_ARGS
GetCommandLineArgs(
    int argc,
    char **argv
);

BOOL
InitializeTrans(
    PTRANSACTION *pTrans,
    PCOM_ARGS pArgs,
    PHANDLE hFile
);

BOOL
DeleteTrans(
    PTRANSACTION pTrans,
    PCOM_ARGS pArgs
);


VOID
Usage (
    VOID
);

StoreDirectory(
    LPTSTR szDir,
    LPTSTR szFName,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts,
    LPTSTR szPath
);

DWORD
StoreAllDirectories(
    LPTSTR szDir,
    LPTSTR szFName,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts,
    LPTSTR szPath
);

BOOL
CorrectPath(
    LPTSTR szFileName,
    LPTSTR szPathName,
    LPTSTR szCorrectPath
);

BOOL
AddTransToFile(
    PTRANSACTION pTrans,
    LPTSTR szFileName,
    PHANDLE hFile
);

BOOL
UpdateServerFile(
    PTRANSACTION pTrans,
    LPTSTR szServerFileName
);

BOOL GetNextId(
    LPTSTR szMasterFileName,
    LPTSTR *szId,
    PHANDLE hFile
);

BOOL
DeleteEntry(
    LPTSTR szDir,
    LPTSTR szId
);

BOOL
CopyTheFile(
    LPTSTR szDir,
    LPTSTR szFilePathName
);

BOOL
DeleteTheFile(
    LPTSTR szDir,
    LPTSTR szFilePathName
);

BOOL
StoreSystemTime(
    LPTSTR *szTime,
    LPSYSTEMTIME lpSystemTime
);

BOOL
StoreSystemDate(
    LPTSTR *szDate,
    LPSYSTEMTIME lpSystemTime
);

ULONG GetMaxLineOfHistoryFile(
    VOID
);

ULONG GetMaxLineOfTransactionFile(
    VOID
);

ULONG GetMaxLineOfRefsPtrFile(
    VOID
);

BOOL GetSrcDirandFileName (
    LPTSTR szStr,
    LPTSTR szSrcDir,
    LPTSTR szFileName
);

PCOM_ARGS pArgs;

HANDLE hTransFile;
DWORD StoreFlags;

PTRANSACTION pTrans;
LONG lMaxTrans;
LONG NumSkippedFiles=0;

int
_cdecl
main( int argc, char **argv)
{

    DWORD NumErrors = 0;
    FILE_COUNTS FileCounts;
    BOOL rc;
    HANDLE hFile;

    hFile=0;

    // This also initializes the name of the Log File
    pArgs = GetCommandLineArgs(argc, argv);

    // Initialize the transaction record
    // Opens the master file (hFile) and leaves it open
    // Get exclusive access to this file

    InitializeTrans(&pTrans, pArgs, &hFile);
    if (pArgs->StoreFlags != ADD_DONT_STORE) {
        AddTransToFile(pTrans, pArgs->szMasterFileName, &hFile);
    }
    CloseHandle(hFile);

    if (pArgs->TransState==TRANSACTION_DEL) {

        rc = DeleteTrans(pTrans,pArgs);
        UpdateServerFile(pTrans, pArgs->szServerFileName);

        return(rc);
    }

    if ( pArgs->StoreFlags == ADD_STORE ||
         pArgs->StoreFlags == ADD_STORE_FROM_FILE ) {

        // Update server file
        UpdateServerFile(pTrans, pArgs->szServerFileName);
    }

    // Make sure the directory path exists for the transaction
    // file if we are doing ADD_DONT_STORE

    if ( pArgs->StoreFlags == ADD_DONT_STORE ) {

        if ( !MakeSureDirectoryPathExists(pTrans->szTransFileName) ) {
            printf("Cannot create the directory %s - GetLastError() = %d\n",
                   pTrans->szTransFileName, GetLastError() );
            exit(1);
        }

        // Open the file and move the file pointer to the end if we are
        // in appending mode.

        if (pArgs->AppendStoreFile)
        {
            hTransFile = CreateFile(pTrans->szTransFileName,
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                         );
            if (hTransFile == INVALID_HANDLE_VALUE ) {
                printf("Cannot create file %s - GetLastError = %d\n",
                        pTrans->szTransFileName, GetLastError() );
                exit(1);
            }

            if ( SetFilePointer( hTransFile, 0, NULL, FILE_END )
                 == INVALID_SET_FILE_POINTER ) {
                printf("Cannot move to end of file %s - GetLastError = %d\n",
                       pTrans->szTransFileName, GetLastError() );
                exit(1);
            }

        } else {
            hTransFile = CreateFile(pTrans->szTransFileName,
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                         );

            if (hTransFile == INVALID_HANDLE_VALUE ) {
                printf("Cannot create file %s - GetLastError = %d\n",
                        pTrans->szTransFileName, GetLastError() );
                exit(1);
            }
        }

    } else {
        hTransFile = CreateFile(pTrans->szTransFileName,
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          CREATE_NEW,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                         );
        if (hTransFile == INVALID_HANDLE_VALUE ) {
            printf("Cannot create a new file %s - GetLastError = %d\n",
                    pTrans->szTransFileName, GetLastError() );
            exit(1);
        }
    }

    StoreFlags=pArgs->StoreFlags;


    if (hTransFile == INVALID_HANDLE_VALUE ) {
        printf("Cannot create a new file %s - GetLastError = %d\n",
               pTrans->szTransFileName, GetLastError() );
        exit(1);
    }

    memset( &FileCounts, 0, sizeof(FILE_COUNTS) );

    if ( pArgs->StoreFlags==ADD_STORE_FROM_FILE ) {

        // This will only store pointers
        NumErrors += StoreFromFile(
                            pArgs->pStoreFromFile,
                            pArgs->szSymbolsDir,
                            &FileCounts
                            );
        fclose(pArgs->pStoreFromFile);

    } else if ( !pArgs->Recurse ) {

        NumErrors += StoreDirectory(
                            pArgs->szSrcDir,
                            pArgs->szFileName,
                            pArgs->szSymbolsDir,
                            &FileCounts,
                            pArgs->szSrcPath
                            );
    } else {

        NumErrors += StoreAllDirectories(
                            pArgs->szSrcDir,
                            pArgs->szFileName,
                            pArgs->szSymbolsDir,
                            &FileCounts,
                            pArgs->szSrcPath
                            );
    }

    if (pArgs->szSrcPath) {
        printf("SYMSTORE: Number of pointers stored = %d\n",FileCounts.NumPassedFiles);
    } else {
        printf("SYMSTORE: Number of files stored = %d\n",FileCounts.NumPassedFiles);
    }
    printf("SYMSTORE: Number of errors = %d\n",NumErrors);
    printf("SYMSTORE: Number of ignored files = %d\n", NumSkippedFiles);

    SetEndOfFile(hTransFile);
    CloseHandle(hTransFile);

    return (0);

}

DWORD
StoreAllDirectories(
    LPTSTR szDir,
    LPTSTR szFName,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts,
    LPTSTR szPath
)

/* ++

   IN szDir     Directory of files to Store

-- */

{

    HANDLE hFindFile;
    TCHAR szCurPath[_MAX_PATH+2];
    TCHAR szFilePtrPath[_MAX_PATH+2];    // This is the path that will get stored as a
                                         // pointer to the file.
    LPTSTR szPtrPath = NULL;

    BOOL Found = FALSE;
    DWORD NumBadFiles=0;

    LPWIN32_FIND_DATA lpFindFileData;



    NumBadFiles += StoreDirectory(szDir,
                                      szFName,
                                      szDestDir,
                                      pFileCounts,
                                      szPath
                                      );

    lpFindFileData = (LPWIN32_FIND_DATA) malloc (sizeof(WIN32_FIND_DATA) );
    if (!lpFindFileData) {
        printf("Symchk: Not enough memory.\n");
        exit(1);
    }

    // Look for all the subdirectories
    _tcscpy(szCurPath, szDir);
    _tcscat(szCurPath, _T("*.*") );

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szCurPath, lpFindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    }

    while ( Found ) {
        if ( lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            if ( !_tcscmp(lpFindFileData->cFileName, _T(".")) ||
                 !_tcscmp(lpFindFileData->cFileName, _T("..")) ) {
            }
            else {
                // Get the current path that we are searching in
                _tcscpy(szCurPath, szDir);
                _tcscat(szCurPath, lpFindFileData->cFileName);
                EnsureTrailingBackslash(szCurPath);

                // Get the current path to use as the pointer to the
                // file, if we are storing file pointers instead of
                // files in this tree.
                if ( szPath ) {
                    _tcscpy(szFilePtrPath, szPath);
                    _tcscat(szFilePtrPath, lpFindFileData->cFileName);
                    EnsureTrailingBackslash(szFilePtrPath);
                    szPtrPath = szFilePtrPath;
                }

                NumBadFiles += StoreAllDirectories(
                                    szCurPath,
                                    szFName,
                                    szDestDir,
                                    pFileCounts,
                                    szPtrPath
                                    );
            }
        }
        Found = FindNextFile(hFindFile, lpFindFileData);
    }
    free(lpFindFileData);
    FindClose(hFindFile);
    return(NumBadFiles);
}


StoreDirectory(
    LPTSTR szDir,
    LPTSTR szFName,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts,
    LPTSTR szPath
)
{
    HANDLE hFindFile;
    TCHAR szFileName[_MAX_PATH+2];
    TCHAR szCurPath[_MAX_PATH+2];
    TCHAR szCurFileName[_MAX_PATH+2];
    TCHAR szCurPtrFileName[_MAX_PATH+2];  // Ptr to the file to put in "file.ptr"
                                          // instead of storing the file.
    BOOL Found, length, rc;
    DWORD NumBadFiles=0;
    BOOL skipped = 0;
    USHORT rc_flag;

    LPWIN32_FIND_DATA lpFindFileData;

    // Create the file name
    _tcscpy(szFileName, szDir);
    _tcscat(szFileName, szFName);

    // Get the current path that we are searching in
    _tcscpy(szCurPath, szDir);

    lpFindFileData = (LPWIN32_FIND_DATA) malloc (sizeof(WIN32_FIND_DATA) );
    if (!lpFindFileData) {
        printf("Symchk: Not enough memory.\n");
        exit(1);
    }

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szFileName, lpFindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE ) {
        Found = FALSE;
    }

    while ( Found ) {
        // Found a file, not a directory
        if ( !(lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            _tcscpy(szCurFileName, szCurPath);
            _tcscat(szCurFileName, lpFindFileData->cFileName );

            if ( szPath ) {
                _tcscpy(szCurPtrFileName, szPath);
                _tcscat(szCurPtrFileName, lpFindFileData->cFileName );
            }

            // Figure out if its a dbg or pdb
            length = _tcslen(szCurFileName);
            rc = FALSE;
            skipped = FALSE;
            if (length > 4 ) {
                if ( _tcsicmp(_T(".dbg"), szCurFileName + length - 4) == 0 ) {
                   if ( szPath ) {
                       rc = StoreDbg( szDestDir, szCurFileName, szCurPtrFileName );
                   }
                   else {
                       rc = StoreDbg( szDestDir, szCurFileName, NULL );
                   }
                }
                else if ( _tcsicmp(_T(".pdb"), szCurFileName + length - 4) == 0 ) {
                   if ( szPath ) {
                       rc = StorePdb( szDestDir, szCurFileName, szCurPtrFileName );
                   } else {
                       rc = StorePdb( szDestDir, szCurFileName, NULL );
                   }
                }
                else {
                   if ( szPath ) {
                       rc = StoreNtFile( szDestDir, szCurFileName, szCurPtrFileName, &rc_flag );
                   } else {
                       rc = StoreNtFile( szDestDir, szCurFileName, NULL, &rc_flag );
                   }

                   if (rc_flag == FILE_SKIPPED) {

                      NumSkippedFiles++;
                      skipped = TRUE;

                      if(pArgs->VerboseOutput)
                      {
                          printf("SYMSTORE: Skipping %s - not a dbg, pdb, or executable\n", szCurFileName);
                      }
                   }
                }
            }

            if (!skipped && !rc) {
               pFileCounts->NumFailedFiles++;
               NumBadFiles++;
               printf("SYMSTORE: ERROR: Could not store %s\n", szCurFileName);
            }
            else if (!skipped) {
               pFileCounts->NumPassedFiles++;
               if (pFileCounts->NumPassedFiles % 50 == 0)
               {
                  printf(".");
               }
            }
        }
        Found = FindNextFile(hFindFile, lpFindFileData);
    }
    free(lpFindFileData);
    FindClose(hFindFile);
    return(NumBadFiles);
}


VOID
Usage (
    VOID
    )

{
    puts("\n"
         "Usage:\n"
         "symstore add [/r] [/p] [/l] /f File /s Store /t Product [/v Version]\n"
         "             [/c Comment]\n\n"
         "symstore add [/r] [/p] [/l] /g Share /f File /x IndexFile [/a]\n\n"
         "symstore add /y IndexFile /g Share /s Store [/p] /t Product [/v Version]\n"
         "             [/c Comment]\n\n"
         "symstore del /i ID /s Store\n\n"
         "    /f File         Network path of files or directories to add.\n\n"
         "    /g Share        This is the server and share where the symbol files were\n"
         "                    originally stored.  When used with /f, Share should be\n"
         "                    identical to the beginning of the File specifier.  When\n"
         "                    used with the /y, Share should be the location of the\n"
         "                    original symbol files, not the index file.  This allows\n"
         "                    you to later change this portion of the file path in case\n"
         "                    you move the symbol files to a different server and share.\n\n"
         "    /i ID           Transaction ID string.\n\n"
         "    /l              Allows the file to be in a local directory rather than a\n"
         "                    network path. (This option is only used with the /p option.)\n\n"
         "    /p              Causes SymStore to store a pointer to the file, rather than\n"
         "                    the file itself.\n\n"
         "    /r              Add files or directories recursively.\n\n"
         "    /s Store        Root directory for the symbol store.\n\n"
         "    /t Product      Name of the product.\n\n"
         "    /v Version      Version of the product.\n\n"
         "    /c Comment      Comment for the transaction.\n\n"
         "    /x IndexFile    Causes SymStore not to store the actual symbol files in the\n"
         "                    symbol store.  Instead, information is stored which will\n"
         "                    allow the files to be added later.\n\n"
         "    /y IndexFile    This reads the data from a file created with /x.\n\n"
         "    /a              Causes SymStore to append new indexing information\n"
         "                    to an existing index file. (This option is only used with\n"
         "                    /x option.)\n\n"
         "    /o              Give verbose output.\n\n"
         "\n" );
    exit(1);
}


PCOM_ARGS
GetCommandLineArgs(
    int argc,
    char **argv
)

{
   PCOM_ARGS pArgs;
   int i,cur,length;
   TCHAR c;
   BOOL NeedSecond = FALSE;
   BOOL StorePtrs = FALSE;
   BOOL AllowLocalNames = FALSE;
   BOOL rc;

   LPTSTR szFileArg = NULL;
   TCHAR  szNameExt[_MAX_FNAME + _MAX_EXT + 1];

   HANDLE fHandle;
   WIN32_FIND_DATA FindFileData;

   if (argc <= 2) Usage();

   pArgs = (PCOM_ARGS)malloc( sizeof(COM_ARGS) );
   if (!pArgs) MallocFailed();
   memset( pArgs, 0, sizeof(COM_ARGS) );

   if (!_tcsicmp(argv[1], _T("add")) ){
      pArgs->TransState = TRANSACTION_ADD;
      pArgs->StoreFlags=ADD_STORE;

   } else if (!_tcsicmp(argv[1], _T("del")) ) {
      pArgs->TransState = TRANSACTION_DEL;
      pArgs->StoreFlags=DEL;

   } else {
      printf("ERROR: First argument needs to be ""add"" or ""del""\n");
      exit(1);
   }

   for (i=2; i<argc; i++) {

     if (!NeedSecond) {
        if ( (argv[i][0] == '/') || (argv[i][0] == '-') ) {
          length = _tcslen(argv[i]) -1;

          for (cur=1; cur <= length; cur++) {
            c = argv[i][cur];

            switch (c) {
                case 'a':   pArgs->AppendStoreFile = TRUE;
                            break;
                case 'c':   NeedSecond = TRUE;
                            break;
                case 'f':   NeedSecond = TRUE;
                            break;
                case 'g':   NeedSecond = TRUE;
                            break;
                case 'i':   NeedSecond = TRUE;
                            break;
                case 'l':   AllowLocalNames=TRUE;
                            break;
                case 'r':   if (pArgs->TransState==TRANSACTION_DEL) {
                                printf("ERROR: /r is an incorrect parameter with del\n\n");
                                exit(1);
                            }
                            pArgs->Recurse = TRUE;
                            break;
                case 'p':   StorePtrs = TRUE;
                            if (pArgs->TransState==TRANSACTION_DEL) {
                                printf("ERROR: /p is an incorrect parameter with del\n\n");
                                exit(1);
                            }
                            break;
                case 's':   NeedSecond = TRUE;
                            break;
                case 't':   NeedSecond = TRUE;
                            break;
                case 'v':   NeedSecond = TRUE;
                            break;
                case 'x':   NeedSecond = TRUE;
                            break;
                case 'y':   NeedSecond = TRUE;
                            break;
                case 'o':   pArgs->VerboseOutput = TRUE;
                            break;
                            
                default:    Usage();
            }
          }
        }
        else {
            printf("ERROR: Expecting a / option before %s\n", argv[i] );
            exit(1);
        }
     }
     else {
        NeedSecond = FALSE;
        switch (c) {
            case 'c':   if (pArgs->TransState==TRANSACTION_DEL) {
                            printf("ERROR: /c is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        if ( _tcslen(argv[i]) > MAX_COMMENT ) {
                            printf("ERROR: Comment must be %d characters or less\n", MAX_COMMENT);
                            exit(1);
                        }
                        pArgs->szComment = (LPTSTR)malloc( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pArgs->szComment) MallocFailed();
                        _tcscpy(pArgs->szComment, argv[i]);
                        break;

            case 'i':   if (pArgs->TransState==TRANSACTION_ADD) {
                            printf("ERROR: /i is an incorrect parameter with add\n\n");
                            exit(1);
                        }
                        if ( _tcslen(argv[i]) != MAX_ID ) {
                            printf("ERROR: /i ID is not a valid ID length\n");
                            exit(1);
                        }
                        pArgs->szId = (LPTSTR)malloc( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pArgs->szId) MallocFailed();
                        _tcscpy(pArgs->szId, argv[i]);
                        break;

            case 'f':   if (pArgs->TransState==TRANSACTION_DEL) {
                            printf("ERROR:  /f is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        szFileArg = argv[i];
                        break;
            case 'g':   if (pArgs->TransState==TRANSACTION_DEL) {
                            printf("ERROR:  /g is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        pArgs->szShareName=(LPTSTR) malloc( (_tcslen(argv[i]) + 2) * sizeof(TCHAR) );
                        if (!pArgs->szShareName) MallocFailed();
                        _tcscpy(pArgs->szShareName, argv[i]);
                        pArgs->ShareNameLength=_tcslen(pArgs->szShareName);
                        break;

            case 's':   if ( _tcslen(argv[i]) > (_MAX_PATH-2) ) {
                            printf("ERROR: Path following /s is too long\n");
                            exit(1);
                        }
                        // Be sure to allocate enough to add a trailing backslash
                        pArgs->szRootDir = (LPTSTR) malloc ( (_tcslen(argv[i]) + 2) * sizeof(TCHAR) );
                        if (!pArgs->szRootDir) MallocFailed();
                        _tcscpy(pArgs->szRootDir,argv[i]);
                        EnsureTrailingBackslash(pArgs->szRootDir);
                        break;

            case 't':   if (pArgs->TransState==TRANSACTION_DEL) {
                            printf("ERROR: /t is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        if ( _tcslen(argv[i]) > MAX_PRODUCT ) {
                            printf("ERROR: Product following /t must be <= %d characters\n",
                                    MAX_PRODUCT);
                            exit(1);
                        }
                        pArgs->szProduct = (LPTSTR) malloc ( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pArgs->szProduct) MallocFailed();
                        _tcscpy(pArgs->szProduct,argv[i]);
                        break;

            case 'v':   if (pArgs->TransState==TRANSACTION_DEL) {
                            printf("ERROR: /v is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        if ( _tcslen(argv[i]) > MAX_VERSION  ) {
                            printf("ERROR: Version following /v must be <= %d characters\n",
                                    MAX_VERSION);
                            exit(1);
                        }
                        pArgs->szVersion = (LPTSTR) malloc ( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pArgs->szVersion) MallocFailed();
                        _tcscpy(pArgs->szVersion,argv[i]);
                        break;

            case 'x':   pArgs->szTransFileName = (LPTSTR) malloc ( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pArgs->szTransFileName) MallocFailed();
                        _tcscpy(pArgs->szTransFileName,argv[i]);
                        pArgs->StoreFlags = ADD_DONT_STORE;

                        // Since we are throwing away the first part of this path, we can allow
                        // local paths for the files to be stored on the symbols server
                        AllowLocalNames=TRUE;

                        break;

            case 'y':   if (pArgs->TransState==TRANSACTION_DEL) {
                            printf("ERROR:  /f is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        pArgs->StoreFlags = ADD_STORE_FROM_FILE;
                        szFileArg = argv[i];
                        break;

            default:    Usage();
        }
     }
   }
   // Check that everything has been entered
   if (NeedSecond) {
        printf("ERROR: /%c must be followed by an argument\n\n", c);
        exit(1);
   }

   if ( pArgs->StoreFlags == ADD_STORE_FROM_FILE ) {

        if (pArgs->szShareName == NULL ) {
            printf("/g must be used when /y is used. \n");
            exit(1);
        }

        EnsureTrailingBackslash(pArgs->szShareName);

        hTransFile = CreateFile(szFileArg,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                         );
        if (hTransFile == INVALID_HANDLE_VALUE ) {
            printf("Cannot open file %s - GetLastError = %d\n",
                    szFileArg, GetLastError() );
            exit(1);
        }
   }


   if ( pArgs->StoreFlags == ADD_DONT_STORE ) {

       if (pArgs->szShareName == NULL ) {
            printf("/g must be used when /x is used. \n");
            exit(1);
       }

       // Verify that szShare is a prefix of szFileArg

       if (szFileArg == NULL ) {
            printf("/f <file> is a required parameter\n");
            exit(1);
       }

       if ( _tcslen(szFileArg) < pArgs->ShareNameLength ) {
            printf("/g %s must be a prefix of /f %s\n",pArgs->szShareName, szFileArg);
            exit(1);
       }

       if ( _tcsncicmp(pArgs->szShareName, szFileArg, pArgs->ShareNameLength) != 0 ) {
            printf("/g %s must be a prefix of /f %s\n", pArgs->szShareName, szFileArg);
            exit(1);
       }

       // Now, make sure that szFileArg has a trailing backslash
       EnsureTrailingBackslash(pArgs->szShareName);
       pArgs->ShareNameLength=_tcslen(pArgs->szShareName);

       // Set the symbol directory under the server to ""
       // so that tcscpy's will work correctly in the rest of the

       pArgs->szSymbolsDir = (LPTSTR) malloc ( sizeof(TCHAR) * 2 );
       if ( !pArgs->szSymbolsDir) MallocFailed();
       _tcscpy( pArgs->szSymbolsDir, _T("") );
   }

   // Get the various symbol server related file names

   if ( pArgs->StoreFlags == ADD_STORE ||
        pArgs->StoreFlags == ADD_STORE_FROM_FILE  ||
        pArgs->StoreFlags == DEL ) {

       if ( pArgs->szRootDir == NULL ) {

            // Verify that the root of the symbols server was entered
            printf("ERROR: /s server is a required parameter\n\n");
            exit(1);
       }

       // Store the name of the symbols dir

       pArgs->szSymbolsDir = (LPTSTR) malloc ( sizeof(TCHAR) *
                             (_tcslen(pArgs->szRootDir) + 1) );
       if (!pArgs->szSymbolsDir) MallocFailed();
       _stprintf(pArgs->szSymbolsDir, "%s", pArgs->szRootDir);

       // Verify that the symbols dir exists

       if ( !MakeSureDirectoryPathExists(pArgs->szSymbolsDir) ) {
           printf("Cannot create the directory %s - GetLastError() = %d\n",
           pArgs->szSymbolsDir, GetLastError() );
           exit(1);
       }

       // Store the name of the admin dir

       pArgs->szAdminDir = (LPTSTR) malloc ( sizeof(TCHAR) *
                (_tcslen(pArgs->szRootDir) + _tcslen(_T("000admin\\")) + 1) );
       if (!pArgs->szAdminDir) MallocFailed();
       _stprintf(pArgs->szAdminDir, "%s000admin\\", pArgs->szRootDir);

       // Verify that the Admin dir exists

       if ( !MakeSureDirectoryPathExists(pArgs->szAdminDir) ) {
            printf("Cannot create the directory %s - GetLastError() = %d\n",
            pArgs->szAdminDir, GetLastError() );
            exit(1);
       }

       // Store the name of the master file

       pArgs->szMasterFileName = (LPTSTR) malloc ( sizeof(TCHAR) *
            (_tcslen(pArgs->szAdminDir) + _tcslen(_T("history.txt")) + 1) );
       if (!pArgs->szMasterFileName ) MallocFailed();
       _stprintf(pArgs->szMasterFileName, "%shistory.txt", pArgs->szAdminDir);

       //
       // Store the name of the "server" file - this contains all
       // the transactions that currently make up the server
       //

       pArgs->szServerFileName = (LPTSTR) malloc ( sizeof(TCHAR) *
            (_tcslen(pArgs->szAdminDir) + _tcslen(_T("server.txt")) + 1) );
       if (!pArgs->szServerFileName ) MallocFailed();
       _stprintf(pArgs->szServerFileName, "%sserver.txt", pArgs->szAdminDir);

   }

   if ( pArgs->StoreFlags==DEL && !pArgs->szId ) {
        printf("ERROR: /i id is a required parameter\n\n");
        exit(1);
   }

   // Done if this is a delete transaction

   if ( pArgs->StoreFlags == DEL ) {
        return(pArgs);
   }

   if ( pArgs->StoreFlags == ADD_STORE ||
        pArgs->StoreFlags == ADD_STORE_FROM_FILE ) {

       if ( !pArgs->szProduct ) {
          printf("ERROR: /t product is a required parameter\n\n");
          exit(1);
       }

       // Since Version and Comment are optional parameters, initialize them to
       // the empty string if they haven't been assigned

       if ( !pArgs->szVersion ) {
           pArgs->szVersion = (LPTSTR)malloc(sizeof(TCHAR) );
           if (!pArgs->szVersion) MallocFailed();
           _tcscpy(pArgs->szVersion,_T("") );
       }

       if ( !pArgs->szComment ) {
           pArgs->szComment = (LPTSTR)malloc(sizeof(TCHAR) );
           if (!pArgs->szComment) MallocFailed();
           _tcscpy(pArgs->szComment,_T("") );
       }

       if ( !pArgs->szUnused ) {
           pArgs->szUnused = (LPTSTR)malloc(sizeof(TCHAR) );
           if (!pArgs->szUnused) MallocFailed();
           _tcscpy(pArgs->szUnused,_T("") );
       }
   }


   if ( pArgs->StoreFlags == ADD_STORE ||
        pArgs->StoreFlags == ADD_DONT_STORE )
   {
     pArgs->szSrcDir = (LPTSTR) malloc ( (_MAX_PATH+_MAX_FNAME+_MAX_EXT+2) * sizeof(TCHAR) );
     if (!pArgs->szSrcDir ) MallocFailed();
     pArgs->szFileName = (LPTSTR) malloc ( (_MAX_FNAME + _MAX_EXT + 1) * sizeof(TCHAR) );
     if (!pArgs->szFileName ) MallocFailed();

     // Decide what part of szFileArg is a file name and what part of it
     // is a directory

     rc = GetSrcDirandFileName( szFileArg, pArgs->szSrcDir, pArgs->szFileName);

     if (!rc)
     {
         Usage();
     }

     // Get the pointer path if we are storing pointers
     // Later, if pArgs->szSrcPath == NULL is used as a way of telling if
     // the user wanted pointers or files.

     if (StorePtrs ) {
        if ( !AllowLocalNames ) {
            // Make sure that they are entering a network path.
            // The reason is that this is the path that will be used to
            // add and delete entries from the symbols server.  And, when
            // pointers are used, this is the path the debugger will use to
            // get the file.

            if ( _tcslen(szFileArg) >= 2 ) {
                if ( szFileArg[0] != '\\' || szFileArg[1] != '\\' ) {
                    printf("ERROR: /f must be followed by a network path\n");
                    exit(1);
                }
            } else {
                printf("ERROR: /f must be followed by a network path\n");
                exit(1);
            }
        }
        pArgs->szSrcPath = (LPTSTR) malloc ( (_tcslen(pArgs->szSrcDir)+1) * sizeof(TCHAR) );
        if (pArgs->szSrcPath == NULL ) MallocFailed();
        _tcscpy(pArgs->szSrcPath, pArgs->szSrcDir);
     }
   }

   if ( pArgs->StoreFlags == ADD_STORE_FROM_FILE ) {

     pArgs->pStoreFromFile = _tfopen(szFileArg, _T("r") );

     if (!pArgs->pStoreFromFile ) {
        printf("Cannot open file %s - GetLastError = %d\n",
               szFileArg, GetLastError() );
        exit(1);
     }

   }

   return (pArgs);
}

BOOL
CorrectPath(
    LPTSTR szFileName,
    LPTSTR szPathName,
    LPTSTR szCorrectPath
)
{
    // To return TRUE, szPathName should equal szCorrectPath + \ + szFileName
    // The only hitch is that there could be extraneous \'s

    TCHAR CorrectPathx[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 2];
    TCHAR PathNamex[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 2];

    LONG length, index, i;

    // Get rid of any extra \'s
    length = _tcslen(szPathName);
    PathNamex[0] = szPathName[0];
    index = 1;
    for (i=1; i<=length; i++) {
        if ( (szPathName[i-1] != '\\') || (szPathName[i] != '\\') ) {
            PathNamex[index] = szPathName[i];
            index++;
        }
    }

    length = _tcslen(szCorrectPath);
    CorrectPathx[0] = szCorrectPath[0];
    index = 1;
    for (i=1; i<=length; i++) {
        if ( (szCorrectPath[i-1] != '\\') || (szCorrectPath[i] != '\\') ) {
            CorrectPathx[index] = szCorrectPath[i];
            index++;
        }
    }

    // Make sure that the correct path doesn't end in a '\'
    length = _tcslen(CorrectPathx);
    if ( CorrectPathx[length-1] == '\\' ) CorrectPathx[length-1] = '\0';

    _tcscat(CorrectPathx,"\\");
    _tcscat(CorrectPathx,szFileName);

    if ( _tcsicmp(CorrectPathx, szPathName) == 0) return TRUE;
    else return FALSE;
}


BOOL
InitializeTrans(
    PTRANSACTION *pTrans,
    PCOM_ARGS pArgs,
    PHANDLE hFile
)
{
    BOOL rc;
    SYSTEMTIME SystemTime;

    lMaxTrans = MAX_ID + MAX_VERSION + MAX_PRODUCT + MAX_COMMENT +
                TRANS_NUM_COMMAS + TRANS_EOL + TRANS_ADD_DEL + TRANS_FILE_PTR +
                MAX_DATE + MAX_TIME + MAX_UNUSED;

    *pTrans = NULL;
    *pTrans = (PTRANSACTION) malloc( sizeof(TRANSACTION) );
    if (!*pTrans) {
        printf("SYMSTORE: Not enough memory to allocate a TRANSACTION\n");
        exit(1);
    }
    memset(*pTrans,0,sizeof(TRANSACTION) );

    //
    // If this is a delete transaction, then use the ID that was entered from
    // the command line to set the ID of the transaction to be deleted.
    //
    if (pArgs->TransState==TRANSACTION_DEL ) {
        (*pTrans)->TransState = pArgs->TransState;
        (*pTrans)->szId = pArgs->szId;
        rc = GetNextId(pArgs->szMasterFileName,&((*pTrans)->szDelId),hFile);

    } else if ( pArgs->StoreFlags == ADD_DONT_STORE ) {
        rc = TRUE;
    } else{

        rc = GetNextId(pArgs->szMasterFileName,&((*pTrans)->szId),hFile );
    }

    if (!rc) {
        printf("SYMSTORE: Cannot create a new transaction ID number\n");
        exit(1);
    }

    // If the things that are needed for both types of adding
    // That is, creating a transaction file only, and adding the
    // files to the symbols server

    if (pArgs->TransState==TRANSACTION_ADD) {
        (*pTrans)->TransState = pArgs->TransState;
        (*pTrans)->FileOrPtr = pArgs->szSrcPath ? STORE_PTR : STORE_FILE;
    }

    // If this is a add, but don't store the files, then the transaction
    // file name is already in pArgs.

    if (pArgs->StoreFlags == ADD_DONT_STORE) {
        (*pTrans)->szTransFileName=(LPTSTR)malloc( sizeof(TCHAR) *
                        (_tcslen(pArgs->szTransFileName) + 1) );
        if (!(*pTrans)->szTransFileName ) {
            printf("Malloc cannot allocate memory for (*pTrans)->szTransFileName \n");
            exit(1);
        }
        _tcscpy( (*pTrans)->szTransFileName, pArgs->szTransFileName );
        return TRUE;
    }

    // Now, set the full path name of the transaction file
    (*pTrans)->szTransFileName=(LPTSTR)malloc( sizeof(TCHAR) *
                    (_tcslen( pArgs->szAdminDir ) +
                     _tcslen( (*pTrans)->szId   ) +
                     1 ) );
    if (!(*pTrans)->szTransFileName ) {
        printf("Malloc cannot allocate memory for (*pTrans)->szTransFilename \n");
        exit(1);
    }
    _stprintf( (*pTrans)->szTransFileName, "%s%s",
                    pArgs->szAdminDir,
                    (*pTrans)->szId );

    (*pTrans)->szProduct = pArgs->szProduct;
    (*pTrans)->szVersion = pArgs->szVersion;
    (*pTrans)->szComment = pArgs->szComment;
    (*pTrans)->szUnused = pArgs->szUnused;


    // Set the time and date
    GetLocalTime(&SystemTime);
    StoreSystemTime( & ((*pTrans)->szTime), &SystemTime );
    StoreSystemDate( & ((*pTrans)->szDate), &SystemTime );


    return (TRUE);
}

//
// AddTransToFile
//
// Purpose - Add a record to the end of the Master File
//

BOOL
AddTransToFile(
    PTRANSACTION pTrans,
    LPTSTR szFileName,
    PHANDLE hFile
)
{
    LPTSTR szBuf=NULL;
    LPTSTR szBuf2=NULL;
    TCHAR szTransState[4];
    TCHAR szFileOrPtr[10];
    DWORD dwNumBytesToWrite;
    DWORD dwNumBytesWritten;
    DWORD FileSizeHigh;
    DWORD FileSizeLow;

    assert (pTrans);

    // Master file should already be opened
    assert(*hFile);

    // Create the buffer to store one record in
    szBuf = (LPTSTR) malloc( sizeof(TCHAR) * (lMaxTrans + 1) );
    if (!szBuf) MallocFailed();

    // Create the buffer to store one record in
    szBuf2 = (LPTSTR) malloc( sizeof(TCHAR) * (lMaxTrans + 1) );
    if (!szBuf2) MallocFailed();

    // Move to the end of the file
    SetFilePointer( *hFile,
                    0,
                    NULL,
                    FILE_END );


    if (pTrans->TransState == TRANSACTION_ADD)
    {
        _tcscpy(szTransState,_T("add"));
        switch (pTrans->FileOrPtr) {
          case STORE_FILE:      _tcscpy(szFileOrPtr,_T("file"));
                                break;
          default:              printf("Incorrect value for pTrans->FileOrPtr - assuming ptr\n");
          case STORE_PTR:       _tcscpy(szFileOrPtr,_T("ptr"));
                                break;
        }
        _stprintf(szBuf2, "%s,%s,%s,%s,%s,%s,%s,%s,%s",
                pTrans->szId,
                szTransState,
                szFileOrPtr,
                pTrans->szDate,
                pTrans->szTime,
                pTrans->szProduct,
                pTrans->szVersion,
                pTrans->szComment,
                pTrans->szUnused
            );
    }
    else if (pTrans->TransState == TRANSACTION_DEL)
    {
        _tcscpy(szTransState,_T("del"));
        _stprintf(szBuf2, "%s,%s,%s",
                pTrans->szDelId,
                szTransState,
                pTrans->szId);

    }
    else
    {
        printf("SYMSTORE: The transaction state is unknown\n");
        free(szBuf);
        free(szBuf2);
        return (FALSE);
    }


    // If this is not the first line in the file, then put a '\n' before the
    // line.

    FileSizeLow = GetFileSize(*hFile, &FileSizeHigh);
    dwNumBytesToWrite = (_tcslen(szBuf2) ) * sizeof(TCHAR);

    if ( FileSizeLow == 0 && FileSizeHigh == 0 ) {

        _stprintf(szBuf,"%s", szBuf2);
    } else {

        _stprintf(szBuf,"\n%s", szBuf2);
        dwNumBytesToWrite += 1 * sizeof(TCHAR);
    }

    // Append this to the master file

    WriteFile( *hFile,
               (LPCVOID)szBuf,
               dwNumBytesToWrite,
               &dwNumBytesWritten,
               NULL
             );

    free(szBuf);
    free(szBuf2);

    if ( dwNumBytesToWrite != dwNumBytesWritten )
    {
        printf( "FAILED to write to %s, with GetLastError = %d\n",
                szFileName,
                GetLastError());
        return (FALSE);
    }

    return (TRUE);
}


BOOL GetNextId(
    LPTSTR szMasterFileName,
    LPTSTR *szId,
    PHANDLE hFile
)
{
    LPWIN32_FIND_DATA lpFindFileData;
    LONG lFileSize,lId;
    LPTSTR szbuf;
    LONG i,NumLeftZeros;
    BOOL Found;
    LONG lNumBytesToRead;

    DWORD dwNumBytesRead;
    DWORD dwNumBytesToRead;
    DWORD dwrc;
    BOOL  rc;
    TCHAR TempId[MAX_ID + 1];
    DWORD First;
    DWORD timeout;

    *szId = (LPTSTR)malloc( (MAX_ID + 1) * sizeof(TCHAR) );
    if (!*szId) MallocFailed();
    memset(*szId,0,MAX_ID + 1);

    szbuf = (LPTSTR) malloc( (lMaxTrans + 1) * sizeof(TCHAR) );
    if (!szbuf) MallocFailed();
    memset(szbuf,0,lMaxTrans+1);

    lpFindFileData = (LPWIN32_FIND_DATA) malloc (sizeof(WIN32_FIND_DATA) );
    if (!lpFindFileData) MallocFailed();

    // If the MasterFile is empty, then use the number "0000000001"
    *hFile = FindFirstFile((LPCTSTR)szMasterFileName, lpFindFileData);
    if ( *hFile == INVALID_HANDLE_VALUE) {
        _tcscpy(*szId, _T("0000000001") );
    }

    // Otherwise, get the last number from the master file
    // Open the Master File

    timeout=0;
    First = 1;
    do {

        *hFile = CreateFile(
                    szMasterFileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

        if ( *hFile == INVALID_HANDLE_VALUE ) {
            *hFile = CreateFile( szMasterFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
        }

        // Only print a message the first time through

        if ( First && *hFile == INVALID_HANDLE_VALUE ) {
            First = 0;
            printf("Waiting to open %s ... \n", szMasterFileName);
        }

        if ( *hFile == INVALID_HANDLE_VALUE ) {
            SleepEx(1000,0);
            timeout+=1;
        }

    } while ( *hFile == INVALID_HANDLE_VALUE && timeout <= 50 );

    if (timeout > 50 ) {
        printf("Timed out -- could not open %s\n", szMasterFileName);
        return(1);
    }

    if (!_tcscmp(*szId, _T("0000000001") ) ) goto finish_GetNextId;

    // Read the last record in from the end of the file.  Allocate one more space to
    // read in the next to last '\n', so we can verify that we are at the beginning of
    // the last record

    lFileSize = GetFileSize(*hFile,NULL);
    if ( lFileSize < (TRANS_NUM_COMMAS + TRANS_EOL + TRANS_ADD_DEL + TRANS_FILE_PTR +
                      MAX_ID) ) {
        printf("The file %s does not have accurate transaction records in it\n",
                szMasterFileName);
        CloseHandle(*hFile);
        exit(1);
    }


    lNumBytesToRead = lFileSize < (lMaxTrans+1) ? lFileSize : (lMaxTrans + 1);
    lNumBytesToRead *= sizeof(TCHAR);

    dwNumBytesToRead = (DWORD)lNumBytesToRead;

    dwrc = SetFilePointer(*hFile,(-1 * dwNumBytesToRead),NULL,FILE_END);
    if ( dwrc == INVALID_SET_FILE_POINTER) {
        printf("SYMSTORE: Could not set file pointer\n");
        CloseHandle(*hFile);
        exit(1);
    }

    rc = ReadFile(*hFile,(LPVOID)szbuf,dwNumBytesToRead,&dwNumBytesRead,NULL);
    if ( !rc ) {
        printf("SYMSTORE: Read file of %s failed - GetLastError() == %d\n",
                szMasterFileName, GetLastError() );
        CloseHandle(*hFile);
        exit(1);
    }

    if ( dwNumBytesToRead != dwNumBytesRead ) {
        printf("SYMSTORE: Read file failure for %s - dwNumBytesToRead = %d, dwNumBytesRead = %d\n",
                szMasterFileName,dwNumBytesToRead, dwNumBytesRead );
        CloseHandle(*hFile);
        exit(1);
    }

    // Now search from the end of the string until you get to the beginning of the string
    // or a '\n'. Count down from the end of the file.

    i = lNumBytesToRead - TRANS_NUM_COMMAS;
    Found = FALSE;

    while ( !Found && (i != 0 ) ) {
        if ( szbuf[i] == '\n' ) {
            Found = TRUE;
        } else {
            i--;
        }
    }

    // Move to the first character of the record
    if (Found) i++;

    // Now, verify that the next ten characters are the ID
    if ( szbuf[i + MAX_ID] != ',' ) {
        printf("There is a comma missing after the ID number of the\n");
        printf("last record in the file %s\n", szMasterFileName);
        CloseHandle(*hFile);
        exit(1);
    } else {
        szbuf[i + MAX_ID] = '\0';
    }

    // Now increment the number
    lId = atoi(szbuf + i);
    if (lId == 9999999999) {
        printf("The last ID number has been used.  No more transactions are allowed\n");
        CloseHandle(*hFile);
        exit(1);
    }
    lId++;
    _itoa(lId, TempId, 10);

    // Now pad the left side with zeros
    // *szId was already set to 0
    NumLeftZeros = MAX_ID - _tcslen(TempId);
    _tcscpy( (*szId) + NumLeftZeros, TempId);
    for (i=0; i < NumLeftZeros; i++) {
        (*szId)[i] = '0';
    }


    if (_tcslen(*szId) != MAX_ID ) {
        printf("Could not obtain a correct Id number\n");
        CloseHandle(*hFile);
        exit(1);
    }


    finish_GetNextId:

    free(szbuf);
    free(lpFindFileData);
    return (TRUE);
}

VOID
MallocFailed()
{
    printf("SYMSTORE: Malloc failed to allocate enough memory\n");
    exit(1);
}


BOOL
DeleteTrans(
    PTRANSACTION pTrans,
    PCOM_ARGS pArgs
)
{
FILE *pFile;
LONG MaxLine;
LPTSTR szBuf;
TCHAR szDir[_MAX_PATH + 2];
TCHAR *token;
TCHAR seps[] = _T(",");


    // First, go get the transaction file
    // and delete its entries from the symbols server

    pFile = _tfopen(pTrans->szTransFileName, _T("r") );

    if (!pFile ) {
        printf("Cannot open file %s - GetLastError = %d\n",
               pTrans->szTransFileName, GetLastError() );
        exit(1);
    }

    // Figure out the maximum line length
    // Add space for 1 commas and a '\0'

    MaxLine = GetMaxLineOfTransactionFile();
    szBuf = (LPTSTR)malloc(MaxLine * sizeof(TCHAR) );
    if (!szBuf) MallocFailed();

    while ( (!feof(pFile)) && fgets(szBuf, MaxLine, pFile))
    {
        // Find the first token that ends with ','
        token=_tcstok(szBuf, seps);

        // Compute the directory we are deleting from
        _tcscpy(szDir,pArgs->szSymbolsDir);
        _tcscat(szDir,token);
        EnsureTrailingBackslash(szDir);

        // Delete entry
        DeleteEntry(szDir, pTrans->szId);
    }

    free(szBuf);
    fclose(pFile);
    return(TRUE);
}

BOOL
DeleteEntry(
    LPTSTR szDir,
    LPTSTR szId
)
/*++ This deletes szID from the directory szDir on the symbols server

-- */

{
    LPTSTR szRefsFile; // Full path and name of the refs.ptr file
    LPTSTR szTempFile; // Full path and name for a temporaty refs.ptr file
    LPTSTR szPtrFile;  // Full path and name of the pointer file
    LPTSTR szParentDir;
    FILE *fRefsFile;
    FILE *fTempFile;
    FILE *fPtrFile;

    LPTSTR szBuf;      // Used to process entries in the refs file


    TCHAR *token;
    TCHAR seps[] = _T(",");

    fpos_t CurFilePos;
    fpos_t IdFilePos;
    fpos_t PrevFilePos;
    fpos_t Prev2FilePos;

    BOOL IdIsFile;
    BOOL Found;
    BOOL rc = FALSE;
    ULONG MaxLine;     // Maximim length of a record in refs.ptr
    ULONG NumLines = 0;
    ULONG NumFiles = 0;
    ULONG NumPtrs = 0;
    ULONG IdLineNum = 0;
    ULONG CurLine = 0;
    ULONG i;
    LONG j;
    DWORD len;

    ULONG ReplaceIsFile;
    ULONG ReplaceLineNum;

    szRefsFile = (LPTSTR) malloc ( (_tcslen(szDir) + _tcslen(_T("refs.ptr")) + 1) * sizeof(TCHAR) );
    if (!szRefsFile) MallocFailed();
    _stprintf(szRefsFile, "%srefs.ptr", szDir );

    szPtrFile = (LPTSTR) malloc ( (_tcslen(szDir) + _tcslen(_T("file.ptr")) + 1) * sizeof(TCHAR) );
    if (!szPtrFile) MallocFailed();
    _stprintf(szPtrFile, "%sfile.ptr", szDir);

    szTempFile = (LPTSTR) malloc ( (_tcslen(szRefsFile) + _tcslen(".tmp") + 1) * sizeof(TCHAR) );
    if (!szTempFile) MallocFailed();
    _stprintf(szTempFile, "%s.tmp", szRefsFile );

    MaxLine = GetMaxLineOfRefsPtrFile();
    szBuf = (LPTSTR) malloc( MaxLine * sizeof(TCHAR) );
    if ( !szBuf ) MallocFailed();
    ZeroMemory(szBuf,MaxLine*sizeof(TCHAR));

    fRefsFile = _tfopen(szRefsFile, _T("r+") );
    if ( fRefsFile == NULL ) {
       // BARB - Check for corruption -- if the file doesn't exist,
       // verify that the parent directory structure doesn't exist either
       goto finish_DeleteEntry;
    }

    //
    // Read through the refs.ptr file and gather information
    //

    NumFiles = 0;
    NumPtrs = 0;

    Found = FALSE;
    NumLines = 0;
    fgetpos( fRefsFile, &CurFilePos);
    PrevFilePos = CurFilePos;   // Position of the current line
    Prev2FilePos = CurFilePos;  // Position of the line before the current line

    while ( _fgetts( szBuf, MaxLine, fRefsFile) != NULL ) {

      len=_tcslen(szBuf);
      if ( len > 3 ) {


        // CurFilePos is set to the next character to be read
        // We need to remember the beginning position of this line (PrevFilePos)
        // And the beginning position of the line before this line (Prev2FilePos)

        Prev2FilePos = PrevFilePos;
        PrevFilePos = CurFilePos;
        fgetpos( fRefsFile, &CurFilePos);

        NumLines++;

        token = _tcstok(szBuf, seps);  // Look at the ID

        if ( _tcscmp(token,szId) == 0 ) {

            // We found the ID
            Found = TRUE;
            IdFilePos = PrevFilePos;
            IdLineNum = NumLines;

            token = _tcstok(NULL, seps);  // Look at the "file" or "ptr" field

            if (token && ( _tcscmp(token,_T("file")) == 0)) {
                IdIsFile = TRUE;
            } else if (token && ( _tcscmp(token,_T("ptr")) == 0 )) {
                IdIsFile = FALSE;
            } else {
                printf("SYMSTORE: Error in %s - entry for %s does not contain ""file"" or ""ptr""\n",
                        szRefsFile, szId);
                rc = FALSE;
                goto finish_DeleteEntry;
            }
        } else {

            // Record info about the other records
            token = _tcstok(NULL, seps);  // Look at the "file" or "ptr" field

            if (token && ( _tcscmp(token,_T("file")) == 0)) {
                NumFiles++;
            } else if (token && ( _tcscmp(token,_T("ptr")) == 0 )) {
                NumPtrs++;
            } else {
                printf("SYMSTORE: Error in %s - entry for %s does not contain ""file"" or ""ptr""\n",
                        szRefsFile, szId);
                rc = FALSE;
                goto finish_DeleteEntry;
            }
        }
      }

      ZeroMemory(szBuf, MaxLine*sizeof(TCHAR));
    }

    fclose(fRefsFile);

    // If we didn't find the ID we are deleting, then don't do anything in this directory

    if (IdLineNum == 0 ) goto finish_DeleteEntry;

    // If there was only one record, then just delete everything
    if (NumLines == 1) {
        DeleteAllFilesInDirectory(szDir);

        // Delete this directory
        rc = RemoveDirectory(szDir);

        if ( !rc ) {
            printf("SYMSTORE: Could not delete %s, GetLastError=%d\n",
                    szDir, GetLastError() );
            goto finish_DeleteEntry;
        }

        // If the first directory was deleted, remove the parent directory

        szParentDir=(LPTSTR)malloc(_tcslen(szDir) + 1 );
        if ( szParentDir == NULL  ) MallocFailed();

        // First figure out the parent directory

        _tcscpy(szParentDir, szDir);

        // szDir ended with a '\' -- find the previous one

        j = _tcslen(szParentDir)-2;
        while (  j >=0 && szParentDir[j] != '\\' ) {
            j--;
        }
        if (j<0) {
            printf("SYMSTORE: Could not delete the parent directory of %s\n",
                   szDir);
        }
        else {
            szParentDir[j+1] = '\0';
            // This call will remove the directory only if its empty
            RemoveDirectory(szParentDir);
        }

        free(szParentDir);
        goto finish_DeleteEntry;
    }

    //
    // Get the replacement info for this deletion
    //

    if ( IdLineNum == NumLines ) {
        ReplaceLineNum = NumLines-1;
    } else {
        ReplaceLineNum = NumLines;
    }


    //
    // Now, delete the entry from refs.ptr
    // Rename "refs.ptr" to "refs.ptr.tmp"
    // Then copy refs.ptr.tmp line by line to refs.ptr, skipping the line we are
    // supposed to delete
    //

    rename( szRefsFile, szTempFile);

    fTempFile= _tfopen(szTempFile, "r" );
    if (fTempFile == NULL) {
        goto finish_DeleteEntry;
    }
    fRefsFile= _tfopen(szRefsFile, "w" );
    if (fRefsFile == NULL) {
        fclose(fTempFile);
        goto finish_DeleteEntry;
    }

    CurLine = 0;

    i=0;
    while ( _fgetts( szBuf, MaxLine, fTempFile) != NULL ) {

      len=_tcslen(szBuf);
      if ( len > 3 ) {
        i++;
        if ( i != IdLineNum ) {

            // Make sure that the last line doesn't end with a '\n'
            if ( i == NumLines || (IdLineNum == NumLines && i == NumLines-1) ) {
                if ( token[_tcslen(token)-1] == '\n' ) {
                    token[_tcslen(token)-1] = '\0';
                }
            }

            _fputts( szBuf, fRefsFile);

        }


        // This is the replacement, either get the new file, or update file.ptr

        if ( i == ReplaceLineNum ) {

            // This is the replacement information,
            // Figure out if it is a file or a pointer

            token = _tcstok(szBuf, seps);  // Skip the ID number
            token = _tcstok(NULL, seps);   // Get "file" or "ptr" field

            if ( _tcscmp(token,_T("file")) == 0) {
                ReplaceIsFile = TRUE;
            } else if ( _tcscmp(token,_T("ptr")) == 0 ) {
                ReplaceIsFile = FALSE;
            } else {
                printf("SYMSTORE: Error in %s - entry for %s does not contain ""file"" or ""ptr""\n",
                        szRefsFile, szId);
                rc = FALSE;
                goto finish_DeleteEntry;
            }

            token = _tcstok(NULL, seps);  // Get the replacement path and filename

            // Strip off the last character if it is a '\n'
            if ( token[_tcslen(token)-1] == '\n' ) {
                token[_tcslen(token)-1] = '\0';
            }

            //
            // If the replacement is a file, then copy the file
            // If the replacement if a ptr, then update "file.ptr"
            //

            rc = TRUE;

            if (ReplaceIsFile) {
                rc = CopyTheFile(szDir, token);
                DeleteFile(szPtrFile);

            } else {

                //
                // Put the new pointer into "file.ptr"
                //

                fPtrFile = _tfopen(szPtrFile, _T("w") );
                if ( !fPtrFile ) {
                    printf("SYMSTORE: Could not open %s for writing\n", szPtrFile);
                    rc = FALSE;
                } else {
                    _fputts( token, fPtrFile);
                    fclose(fPtrFile);
                }


                //
                // If the deleted record was a "file", and we are placing it with a
                // pointer, and there are no other "file" records in refs.ptr, then
                // delete the file from the directory.
                //
                if ( IdIsFile && NumFiles == 0 ) {
                    DeleteTheFile(szDir, token);
                }
            }
        }
      }
    }

    fclose(fTempFile);
    fclose(fRefsFile);

    // Now, delete the temporary file

    DeleteFile(szTempFile);

    finish_DeleteEntry:

    free (szBuf);
    free (szRefsFile);
    free (szPtrFile);
    free (szTempFile);
    return (rc);
}


BOOL
CopyTheFile(
    LPTSTR szDir,
    LPTSTR szFilePathName
)
/*++

    IN szDir            The directory that the file is copied to
    IN szFilePathName   The full path and name of the file to be copied

    "CopyTheFile" copies szFilePathName to the directory
    szDir, if the file does not already exist in szDir

--*/
{
BOOL rc;
USHORT j;
LPTSTR szFileName;


    // Figure out index in "szFilePathName" where the file name starts
    j = _tcslen(szFilePathName) - 1;

    if ( szFilePathName[j] == '\\' ) {
        printf("SYMSTORE: %s\refs.ptr has a bad file name %s\n",
                szDir, szFilePathName);
        return(FALSE);
    }

    while ( szFilePathName[j] != '\\' && j != 0 ) j--;

    if ( j == 0 ) {
        printf("SYMSTORE: %s\refs.ptr has a bad file name for %s\n",
                szDir, szFilePathName );
        return(FALSE);
    }

    // Set j == the index of first character after the last '\' in szFilePathName
    j++;

    // Allocate and store the full path and name of
    szFileName = (LPTSTR) malloc ( sizeof(TCHAR) *
                                               (_tcslen(szDir) + _tcslen(szFilePathName+j) + 1) );
    if ( szFileName == NULL ) MallocFailed();

    _stprintf(szFileName, "%s%s", szDir, szFilePathName+j );


    // If this file doesn't exist, then copy it


    rc = MyCopyFile( szFilePathName, szFileName );

    free(szFileName);
    return(rc);
}


BOOL
DeleteTheFile(
    LPTSTR szDir,
    LPTSTR szFilePathName
)
/*++

    IN szDir            The directory that the file is to be deleted from

    IN szFilePathName   The file name of the file to be deleted.  It is
                        preceded by the wrong path.  That's why we need to
                        strip off the file name and add it to szDir


    "DeleteTheFile" figures out the file name at the end of szFilePathName,
    and deletes it from szDir if it exists.  It will delete the file and/or
    the corresponding compressed file name that has the same name with a _
    at the end of it.

--*/
{
BOOL rc,returnval=TRUE;
USHORT j;
LPTSTR szFileName;
DWORD dw;


    // Figure out index in "szFilePathName" where the file name starts
    j = _tcslen(szFilePathName) - 1;

    if ( szFilePathName[j] == '\\' ) {
        printf("SYMSTORE: %s\refs.ptr has a bad file name %s\n",
                szDir, szFilePathName);
        return(FALSE);
    }

    while ( szFilePathName[j] != '\\' && j != 0 ) j--;

    if ( j == 0 ) {
        printf("SYMSTORE: %s\refs.ptr has a bad file name for %s\n",
                szDir, szFilePathName );
        return(FALSE);
    }

    // Set j == the index of first character after the last '\' in szFilePathName
    j++;

    // Allocate and store the full path and name of
    szFileName = (LPTSTR) malloc ( sizeof(TCHAR) *
                                               (_tcslen(szDir) + _tcslen(szFilePathName+j) + 1) );
    if ( szFileName == NULL ) MallocFailed();

    _stprintf(szFileName, "%s%s", szDir, szFilePathName+j );

    // See if the file exists
    dw = GetFileAttributes( szFileName );    
    if ( dw != 0xffffffff ) {
        rc = DeleteFile( szFileName );
        if (!rc && GetLastError() != ERROR_NOT_FOUND ) {
            printf("SYMSTORE: Could not delete %s - GetLastError = %d\n",
                   szFileName, GetLastError() );
            returnval=FALSE;
        } 
    }

    // See if the compressed file exists and delete it.

    szFileName[ _tcslen(szFileName) -1 ] = _T('_');
    dw = GetFileAttributes( szFileName );    
    if ( dw != 0xffffffff ) {
        rc = DeleteFile( szFileName );
        if (!rc && GetLastError() != ERROR_NOT_FOUND ) {
            printf("SYMSTORE: Could not delete %s - GetLastError = %d\n",
                   szFileName, GetLastError() );
            returnval=FALSE;
        } 
    }

    free(szFileName);
    return(returnval);
}


BOOL
UpdateServerFile(
    PTRANSACTION pTrans,
    LPTSTR szServerFileName
)
/* ++
    IN pTrans         // Transaction Info
    IN szServerFile   // Full path and name of the server transaction file
                      // This file tells what is currently on the server

    Purpose:  UpdateServerFile adds the transaction to the server text file if this is an
    "add.  If this is a "del", it deletes it from the server file.  The "server.txt" file
    is in the admin directory.

-- */
{
ULONG i;
ULONG NumLines;
ULONG IdLineNum;
LPTSTR szBuf;
LPTSTR szTempFileName;
FILE *fTempFile;
FILE *fServerFile;
ULONG MaxLine;

TCHAR *token;
TCHAR seps[]=",";

BOOL rc;
HANDLE hFile;
DWORD First;
DWORD timeout;

    if (pTrans->TransState == TRANSACTION_ADD ) {

        // Open the File -- wait until we can get access to it

        First = 1;
        timeout=0;
        do {

            hFile = CreateFile(
                        szServerFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

            if ( hFile == INVALID_HANDLE_VALUE ) {
                hFile = CreateFile(
                            szServerFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
            }

            if ( First && hFile == INVALID_HANDLE_VALUE ) {
                First = 0;
                printf("Waiting to open %s ... \n", szServerFileName);
            }

            if ( hFile == INVALID_HANDLE_VALUE ) {
                SleepEx(1000,0);
                timeout++;

            }

        } while ( hFile == INVALID_HANDLE_VALUE && timeout <= 50 );

        if ( timeout > 50 ) {
            printf("Timed out -- could not open %s\n", szServerFileName);
            return (1);
        }

        rc = AddTransToFile(pTrans, szServerFileName,&hFile);

        CloseHandle(hFile);
        return(rc);
    }

    if (pTrans->TransState != TRANSACTION_DEL) {
        return(FALSE);
    }

    //
    // Now, delete this transaction ID from the file
    // Get the name of the temporary file
    // and open it for writing
    //

    szTempFileName = (LPTSTR)malloc(sizeof(TCHAR) *
                                    _tcslen(szServerFileName) + _tcslen(".tmp") + 1 );
    if (szTempFileName == NULL) MallocFailed();
    _stprintf(szTempFileName, "%s.tmp", szServerFileName);

    fTempFile = _tfopen(szTempFileName, _T("w") );
    if ( fTempFile == NULL ) {
        printf("SYMSTORE: Cannot create a temporary file %s\n", szTempFileName);
        exit(1);
    }


    //
    // Open the Server file for reading
    //

    fServerFile = _tfopen(szServerFileName, _T("r") );
    if ( fServerFile == NULL ) {
        printf("SYMSTORE: Cannot create a temporary file %s\n", szServerFileName);
        exit(1);
    }


    //
    // Allocate enough space to hold a line of the master file
    //
    MaxLine = GetMaxLineOfHistoryFile();

    szBuf = (LPTSTR)malloc(sizeof(TCHAR) * MaxLine);
    if (szBuf == NULL) MallocFailed();

    //
    // Copy the master file to the temporary file.
    //

    // Do some stuff so that we don't put an extra '\n' at the end of the file
    // Figure out how many lines there are and which line the ID is on.
    // If we are removing the last line of the file, then the next to the last
    // line needs to have a '\n' stripped from it.
    //
    NumLines = 0;
    IdLineNum = 0;

    while ( _fgetts( szBuf, MaxLine, fServerFile) != NULL ) {

        NumLines++;

        token = _tcstok(szBuf,seps);
        if (_tcscmp(token, pTrans->szId) == 0 ) {
            IdLineNum = NumLines;
        }

    }
    fclose(fServerFile);

    // Now, reopen it and copy it, deleting the line with ID in it

    fServerFile = _tfopen(szServerFileName, _T("r") );
    if ( fServerFile == NULL ) {
        printf("SYMSTORE: Cannot create a temporary file %s\n", szServerFileName);
        exit(1);
    }

    for (i=1; i<=NumLines; i++ ) {

        _fgetts( szBuf, MaxLine, fServerFile);

        if ( i != IdLineNum ) {

           // Make sure that the last line doesn't end with a '\n'
           if ( i == NumLines || (IdLineNum == NumLines && i == NumLines-1) ) {
               if ( szBuf[_tcslen(szBuf)-1] == '\n' ) {
                   szBuf[_tcslen(szBuf)-1] = '\0';
               }
           }

           _fputts( szBuf, fTempFile);

        }
    }

    fclose(fServerFile);
    fclose(fTempFile);

    // Now, delete the original Server file and
    // replace it with the temporary file

    rc = DeleteFile(szServerFileName);
    if (!rc) {
        printf("SYMSTORE: Could not delete %s to update it with %s\n",
                szServerFileName, szTempFileName);
        exit(1);
    }

    rc = _trename(szTempFileName, szServerFileName);
    if ( rc != 0 ) {
        printf("SYMSTORE: Could not rename %s to %s\n",
                szTempFileName, szServerFileName);
        exit(1);
    }

    free(szBuf);
    free(szTempFileName);

    return(TRUE);
}



BOOL
StoreSystemTime(
    LPTSTR *szBuf,
    LPSYSTEMTIME lpSystemTime
)
{

    TCHAR Hour[20];
    TCHAR Minute[20];
    TCHAR Second[20];

    (*szBuf) = (LPTSTR) malloc (20 * sizeof(TCHAR) );
    if ( (*szBuf) == NULL ) MallocFailed();

    _itoa(lpSystemTime->wHour, Hour, 10);
    _itoa(lpSystemTime->wMinute, Minute, 10);
    _itoa(lpSystemTime->wSecond, Second, 10);

    _stprintf(*szBuf, "%2s:%2s:%2s", Hour, Minute, Second );

    if ( (*szBuf)[0] == ' ' ) (*szBuf)[0] = '0';
    if ( (*szBuf)[3] == ' ' ) (*szBuf)[3] = '0';
    if ( (*szBuf)[6] == ' ' ) (*szBuf)[6] = '0';

    return(TRUE);
}

BOOL
StoreSystemDate(
    LPTSTR *szBuf,
    LPSYSTEMTIME lpSystemTime
)
{

    TCHAR Day[20];
    TCHAR Month[20];
    TCHAR Year[20];

    (*szBuf) = (LPTSTR) malloc (20 * sizeof(TCHAR) );
    if ( (*szBuf) == NULL ) MallocFailed();

    _itoa(lpSystemTime->wMonth, Month, 10);
    _itoa(lpSystemTime->wDay, Day, 10);
    _itoa(lpSystemTime->wYear, Year, 10);

    _stprintf(*szBuf, "%2s/%2s/%2s", Month, Day, Year+2 );

    if ( (*szBuf)[0] == ' ' ) (*szBuf)[0] = '0';
    if ( (*szBuf)[3] == ' ' ) (*szBuf)[3] = '0';

    return(TRUE);
}


ULONG GetMaxLineOfTransactionFile(
    VOID
)

/*++
    This returns the maximum length of a line in a transaction file.
    The transaction file is a unique file for each transaction that
    gets created in the admin directory.  Its name is a number
    (i.e., "0000000001")
--*/

{
ULONG Max;

    Max = (_MAX_PATH * 2 + 3) * sizeof(TCHAR);
    return(Max);
}

ULONG GetMaxLineOfHistoryFile(
    VOID
)
/*++
    This returns the maximum length of a line in the history file.
    The history file contains one line for every transaction.  It exists
    in the admin directory.
--*/

{
ULONG Max;

    Max = MAX_ID + MAX_VERSION + MAX_PRODUCT + MAX_COMMENT +
            TRANS_NUM_COMMAS + TRANS_EOL + TRANS_ADD_DEL + TRANS_FILE_PTR +
            MAX_DATE + MAX_TIME + MAX_UNUSED;
    Max *= sizeof(TCHAR);
    return(Max);
}

ULONG GetMaxLineOfRefsPtrFile(
    VOID
)
/* ++
    This returns the maximum length of a line in the refs.ptr file.
    This file exists in the individual directories of the symbols server.
-- */

{
ULONG Max;

    Max = _MAX_PATH+2 + MAX_ID + TRANS_FILE_PTR + 3;
    Max *= sizeof(TCHAR);
    return(Max);
}


/*
    GetSrcDirandFileName

    This procedure takes a path and separates it into two
    strings.  One string for the directory portion of the path
    and one string for the file name portion of the path.


    szStr      - INPUT string that contains a path
    szSrcDir   - OUTPUT string that contains the directory
                 followed by a backslash
    szFileName - OUTPUT string that contains the file name

*/

BOOL GetSrcDirandFileName (
    LPTSTR szStr,
    LPTSTR szSrcDir,
    LPTSTR szFileName
)
{

    DWORD szStrLength;
    DWORD found, i, j, lastslash;

    HANDLE fHandle;
    WIN32_FIND_DATA FindFileData;

    szStrLength = _tcslen(szStr);
    if ( szStrLength == 0 )
    {
        return (FALSE);
    }

    // See if the user entered "."
    // If so, set the src directory to . followed by a \, and
    // set the file name to *

    if ( szStrLength == 1 && szStr[0] == _T('.') )
    {
        _tcscpy( szSrcDir, _T(".\\") );
        _tcscpy( szFileName, _T("*") );
        return (TRUE);
    }

    // Give an error if the end of the string is a colon
    if ( szStr[szStrLength-1] == _T(':') )
    {
        printf("SYMSTORE: ERROR: path %s does not specify a file\n", szStr);
        return (FALSE);
    }


    // See if this is a file name only.  See if there are no
    // backslashes in the string.

    found = 0;
    for ( i=0; i<szStrLength; i++ )
    {
        if ( szStr[i] == _T('\\') )
        {
            found = 1;
        }
    }
    if ( !found )
    {
       // This is a file name only, so set the directory to
       // the current directory.
        _tcscpy( szSrcDir, _T(".\\") );

       // Set the file name to szStr
       _tcscpy( szFileName, szStr );
       return (TRUE);
    }

    // See if this is a network server and share with no file
    // name after it.  If it is, use * for the file name.

    if ( szStr[0] == szStr[1] && szStr[0] == _T('\\') )
    {
        // Check the third character to see if its part of
        // a machine name.

        if (szStrLength < 3 )
        {
            printf("SYMSTORE: ERROR: %s is not a correct UNC path\n", szStr);
            return (FALSE);
        }

        switch (szStr[2]) {
            case _T('.'):
            case _T('*'):
            case _T(':'):
            case _T('\\'):
            case _T('?'):
                printf("SYMSTORE: ERROR: %s is not a correct UNC path\n",szStr);
                return (FALSE);
            default: break;
        }

        // Search for the next backslash.  This is the backslash between
        // the server and the share (\\server'\'share)

        i=3;
        while ( i<szStrLength && szStr[i] != _T('\\') )
        {
            i++;
        }

        // If the next backslash is at the end of the string, then
        // this is an error because the share part of \\server\share
        // is empty.

        if ( i == szStrLength )
        {
            printf("SYMSTORE: ERROR: %s is not a correct UNC path\n",szStr);
            return (FALSE);
        }

        // We've found \\server\ so far.
        // see if there is at least one more character.

        i++;
        if ( i >= szStrLength )
        {
            printf("SYMSTORE: ERROR: %s is not a correct UNC path\n", szStr);
            return (FALSE);
        }

        switch (szStr[i]) {
            case _T('.'):
            case _T('*'):
            case _T(':'):
            case _T('\\'):
            case _T('?'):
                printf("SYMSTORE: ERROR: %s is not correct UNC path\n",szStr);
                return (FALSE);
            default: break;
        }

        // Now, we have \\server\share so far -- if there are no more
        // backslashes, then the filename is * and the directory is
        // szStr
        i++;
        while ( i < szStrLength && szStr[i] != _T('\\') )
        {
            i++;
        }
        if ( i == szStrLength )
        {

            // verify that there are no wildcards in this
            found = 0;
            for ( j=0; j<szStrLength; j++ )
            {
              if ( szStr[j] == _T('*') || szStr[j] == _T('?') )
              {
                printf("SYMSTORE: ERROR: Wildcards are not allowed in \\\\server\\share\n"); return (FALSE);
              }
            }

            _tcscpy( szSrcDir, szStr );
            _tcscat( szSrcDir, _T("\\") );

            _tcscpy( szFileName, _T("*") );
            return (TRUE);
        }
    }

    // See if this has wildcards in it.  If it does, then the
    // wildcards are only allowed in the file name part of the
    // string.  The last entry is a file name then.

    found = 0;
    for ( i=0; i<szStrLength; i++ )
    {

        // Keep track of where the last directory ended
        if ( szStr[i] == _T('\\') )
        {
            lastslash=i;
        }

        if ( szStr[i] == _T('*') || szStr[i] == _T('?') )
        {
            found = 1;
        }

        if ( found && szStr[i] == _T('\\') )
        {
            printf("SYMSTORE: ERROR: Wildcards are only allowed in the filename\n");
            return (FALSE);
        }
    }

    // If there was a wildcard
    // then use the last backslash as the location for splitting between
    // the directory and the file name.

    if ( found )
    {
        _tcsncpy( szSrcDir, szStr, (lastslash+1) * sizeof (TCHAR) );
        *(szSrcDir+lastslash+1)=_T('\0');

        _tcscpy( szFileName, szStr+lastslash + 1 );
        return (TRUE);
    }


    // See if this is a directory.  If it is then make sure there is
    // a blackslash after the directory and use * for the file name.

    fHandle = FindFirstFile(szStr, &FindFileData);

    if ( fHandle != INVALID_HANDLE_VALUE &&
         (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
    {
        // If it is a directory then make sure that it ends in a \
        // and use * for the filename

        _tcscpy( szSrcDir, szStr );
        EnsureTrailingBackslash(szSrcDir);
        _tcscpy( szFileName, _T("*") );
        return (TRUE);
    }

    // Otherwise, go backwards from the end of the string and find
    // the last backslash.  Divide it up into directory and file name.

    i=szStrLength-1;
    while ( szStr[i] != _T('\\') )
    {
        i--;
    }
    _tcsncpy( szSrcDir, szStr, i+1 );
    *(szSrcDir+i+1)=_T('\0');

    _tcscpy( szFileName, szStr+i+1 );
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\cvtodbg\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symstore\symutil.c ===
#include <assert.h>
#include "symutil.h"
#define PDB_LIBRARY
#include "pdb.h"
#include "dbghelp.h"
#include "cvinfo.h"
#include "cvexefmt.h"
#include "exe_vxd.h"
#include "share.h"
#include "winbase.h"
#include "symsrv.h"

// Stuff for Checking symbols


// Typedefs

typedef struct _NB10I {
   DWORD   dwSig;    // NB10
   DWORD   dwOffset; // offset, always 0
   SIG     sig;
   AGE     age;
   char    szPDB[_MAX_PATH];
}NB10I, *PNB10I;

typedef struct _FILE_INFO {
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    TCHAR       szName[MAX_PATH];
} FILE_INFO, *PFILE_INFO;


PIMAGE_SEPARATE_DEBUG_HEADER
MapDbgHeader (
    LPTSTR szFileName,
    PHANDLE phFile
);

BOOL
UnmapFile(
    LPCVOID phFileMap,
    HANDLE hFile
);

BOOL
AddToReferenceCount(
    LPTSTR szDir,           // Directory where refs.ptr belongs
    LPTSTR szFileName,      // Full path and name of the file that is referenced.
    LPTSTR szPtrOrFile      // Was a file or a pointer written
);


BOOL
StoreFile(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szString2,
    LPTSTR szPtrFileName
);

BOOL
StoreFilePtr(
    LPTSTR szDestDir,
    LPTSTR szString2,
    LPTSTR szPtrFileName
);

BOOL
GetString2(
    LPTSTR szFileName,
    GUID *guid,
    DWORD dwNum1,
    DWORD dwNum2,
    LPTSTR szDirName
);

PIMAGE_DOS_HEADER
MapFileHeader (
    LPTSTR szFileName,
    PHANDLE phFile
);


PIMAGE_NT_HEADERS
GetNtHeader (
    PIMAGE_DOS_HEADER pDosHeader,
    HANDLE hDosFile
);

BOOL
ResourceOnlyDll(
    PVOID pImageBase,
    BOOLEAN bMappedAsImage
);


PIMAGE_SEPARATE_DEBUG_HEADER
MapDbgHeader (
    LPTSTR szFileName,
    PHANDLE phFile
)
{
    HANDLE hFileMap;
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader;

    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*phFile == INVALID_HANDLE_VALUE) {
        CloseHandle(*phFile);
        return(NULL);
    }

    hFileMap = CreateFileMapping( *phFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                                  );

    if ( !hFileMap) {
        CloseHandle(*phFile);
        CloseHandle(hFileMap);
        return(NULL);
    }


    pDbgHeader = (PIMAGE_SEPARATE_DEBUG_HEADER) MapViewOfFile( hFileMap,
                            FILE_MAP_READ,
                            0,  // high
                            0,  // low
                            0   // whole file
                            );
    CloseHandle(hFileMap);

    if ( !pDbgHeader ) {
        UnmapFile((LPCVOID)pDbgHeader, *phFile);
        return(NULL);
    }

    return (pDbgHeader);
}

BOOL
UnmapFile( LPCVOID phFileMap, HANDLE hFile )
{
    if ((PHANDLE)phFileMap != NULL) {
        UnmapViewOfFile( phFileMap );
    }
    if (hFile) {
        CloseHandle(hFile);
    }
    return TRUE;
}


BOOL
StoreDbg(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName
    )

/* ++

    Routine Description:
        Stores this file as "szDestDir\szFileName\Checksum"

    Return Value:
        TRUE -  file was stored successfully
        FALSE - file was not stored successfully

-- */
{

    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader;
    HANDLE hFile;
    BOOL rc;
    TCHAR szString[_MAX_PATH];

    ZeroMemory(szString, _MAX_PATH * sizeof(TCHAR) );

    pDbgHeader = MapDbgHeader ( szFileName, &hFile );

    if (pDbgHeader == NULL) {
        printf("ERROR: StoreDbg(), %s was not opened successfully\n",szFileName);
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return FALSE;
    }

    GetString2( szFileName,
                NULL, 
                (DWORD) pDbgHeader->TimeDateStamp,
                (DWORD) pDbgHeader->SizeOfImage,
                szString
              ); 

    rc = StoreFile( szDestDir, 
                    szFileName,
                    szString,
                    szPtrFileName );

    UnmapFile((LPCVOID)pDbgHeader, hFile);
    return rc;
}

BOOL
StorePdb(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName
    )

/*++

    Routine Description:
        Validates the PDB

    Return Value:
        TRUE    PDB validates
        FALSE   PDB doesn't validate
--*/

{

    BOOL rc;

    BOOL valid;
    PDB *pdb;
    EC ec;
    char szError[cbErrMax] = _T("");
    SIG sig;
    AGE age;
    SIG70 sig70;
    TCHAR szString[_MAX_PATH];

    DBI *pdbi;

   
    ZeroMemory( szString, _MAX_PATH * sizeof(TCHAR) ); 
    ZeroMemory( &sig70, sizeof(SIG70) );
    pdb=NULL;

    __try
    {
        valid = PDBOpen( szFileName,
                   _T("r"),
                   0,
                   &ec,
                   szError,
                   &pdb
                   );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
       valid=FALSE;
    }

    if ( !valid ) {
       return FALSE;
    }

    // The DBI age is created when the exe is created.
    // This age will not change if an operation is performed
    // on the PDB that increments its PDB age.

    if ( !PDBOpenDBI(pdb, pdbRead, NULL, &pdbi) ) {
        // OpenDBI failed
        DBIClose(pdbi);
        return FALSE;
    }

    sig = PDBQuerySignature(pdb);
    age = pdbi->QueryAge();
    rc = PDBQuerySignature2(pdb, &sig70);

    DBIClose(pdbi);
    PDBClose(pdb);

    if (rc) {
        GetString2( szFileName,
                    &sig70,
                    (DWORD) sig,
                    (DWORD) age,
                    szString );
    } else {
        GetString2( szFileName,
                    NULL,
                    (DWORD) sig,
                    (DWORD) age,
                    szString );
    }

    rc = StoreFile( szDestDir,
                    szFileName,
                    szString,
                    szPtrFileName
                  );

    return (rc);
}



P_LIST
GetList(
    LPTSTR szFileName
)

{

    /* GetList gets the list and keeps the original file name which could
     * have included the path to the file
     * Note, it can be merged with GetExcludeList.  I first created it for
     * use in creating the symbols CD, and didn't want to risk entering a
     * bug into symchk
     */

    P_LIST pList;

    FILE  *fFile;
    TCHAR szCurFile[_MAX_FNAME+1], *c;
    TCHAR fname[_MAX_FNAME+1], ext[_MAX_EXT+1];
    DWORD i;
    LPTSTR szEndName;
    ULONG RetVal = FALSE;


    pList = (P_LIST)malloc(sizeof(LIST));
    if (pList)
    {
        pList->dNumFiles = 0;
        if (  (fFile = _tfopen(szFileName,_T("r") )) == NULL )
        {
            // printf( "Cannot open the exclude file %s\n",szFileName );
        }
        else
        {
            while ( _fgetts(szCurFile,_MAX_FNAME,fFile) ) {
                if ( szCurFile[0] == ';' ) continue;
                (pList->dNumFiles)++;
            }

            // Go back to the beginning of the file
            fseek(fFile,0,0);
            pList->List = (LIST_ELEM*)malloc( sizeof(LIST_ELEM) *
                                                   (pList->dNumFiles));
            if (pList->List)
            {
                i = 0;
                while ( i < pList->dNumFiles )
                {
                    memset(szCurFile,'\0',sizeof(TCHAR) * (_MAX_FNAME+1) );
                    _fgetts(szCurFile,_MAX_FNAME,fFile);

                    // Replace the \n with \0
                    c = NULL;
                    c  = _tcschr(szCurFile, '\n');
                    if ( c != NULL) *c='\0';

                    if ( szCurFile[0] == ';' ) continue;

                    if ( _tcslen(szCurFile) > _MAX_FNAME ) {
                        printf("File %s has a string that is too large\n",szFileName);
                        break;
                    }

                    // Allow for spaces and a ; after the file name
                    // Move the '\0' back until it has erased the ';' and any
                    // tabs and spaces that might come before it
                    szEndName = _tcschr(szCurFile, ';');
                    if (szEndName != NULL ) {
                        while ( *szEndName == ';' || *szEndName == ' '
                                                || *szEndName == '\t' ){
                            *szEndName = '\0';
                            if ( szEndName > szCurFile ) szEndName--;
                        }
                    }

                    _tcscpy(pList->List[i].Path,szCurFile);

                    _tsplitpath(szCurFile,NULL,NULL,fname,ext);

                    _tcscpy(pList->List[i].FName,fname);
                    _tcscat(pList->List[i].FName,ext);

                    i++;
                }

                if (i == pList->dNumFiles)
                {
                    RetVal = TRUE;
                }
                else
                {
                    free(pList->List);
                }
            }

            fclose(fFile);
        }

        if (!RetVal)
        {
            free(pList);
            pList = NULL;
        }
    }

            // Sort the List
            // qsort( (void*)pList->List, (size_t)pList->dNumFiles,
            //       (size_t)sizeof(LIST_ELEM), SymComp2 );


    return (pList);

}


BOOL
GetString2(
    LPTSTR szFileName,
    GUID *guid,
    DWORD dwNum1,
    DWORD dwNum2,
    LPTSTR szString
)
{

    TCHAR szFileNameOnly[_MAX_FNAME + _MAX_EXT];
    TCHAR szExt[_MAX_EXT];

    _tcscpy( szString, _T("") );

    _tsplitpath(szFileName, NULL, NULL, szFileNameOnly, szExt);

    _tcscat(szString, szFileNameOnly);
    _tcscat(szString, szExt);
    EnsureTrailingBackslash(szString);

    if (guid != NULL) {
        AppendHexStringWithGUID( szString, guid );
    } else {
        AppendHexStringWithDWORD( szString, dwNum1 );
    }
    AppendHexStringWithDWORD( szString, dwNum2 );
    return (TRUE);
}

BOOL
StoreFile(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szString2,
    LPTSTR szPtrFileName
)
{
    TCHAR szPathName[_MAX_PATH + _MAX_FNAME + 2];
    TCHAR szFileNameOnly[_MAX_FNAME + _MAX_EXT];
    TCHAR szExt[_MAX_EXT];
    TCHAR szBuf[_MAX_PATH * 3];
    TCHAR szRefsDir[_MAX_PATH * 3];
    TCHAR szFileNameComp[_MAX_PATH * 3];
    TCHAR szPathNameComp[_MAX_PATH + _MAX_FNAME + 2];

    DWORD dwNumBytesToWrite;
    DWORD dwNumBytesWritten;
    BOOL rc;
    DWORD dwSizeDestDir;

    DWORD dwFileSizeLow;
    DWORD dwFileSizeHigh;
    DWORD dw;

    // If ADD_DONT_STORE, then write the function parameters
    // to a file so we can call this function exactly when
    // running ADD_STORE_FROM_FILE

    if ( StoreFlags == ADD_DONT_STORE ) {

        // Don't need to store szDestDir because it will
        // be given when adding from file

        dwFileSizeLow = GetFileSize(hTransFile, &dwFileSizeHigh);

        _stprintf(szBuf,"%s,%s,",
              szFileName+pArgs->ShareNameLength,
              szString2);

        if ( szPtrFileName != NULL ) {
            _tcscat(szBuf, szPtrFileName+pArgs->ShareNameLength);
        }
        _tcscat(szBuf, _T(",\r\n") );

        dwNumBytesToWrite = _tcslen(szBuf) * sizeof(TCHAR);
        WriteFile(  hTransFile,
                    (LPCVOID)szBuf,
                    dwNumBytesToWrite,
                    &dwNumBytesWritten,
                    NULL
                    );

        if ( dwNumBytesToWrite != dwNumBytesWritten ) {
            printf( "FAILED to write to %s, with GetLastError = %d\n",
                    szPathName,
                    GetLastError()
                    );
            return (FALSE);
        } else {
            return (TRUE);

        }
    }

    if ( szPtrFileName != NULL ) {
        rc = StoreFilePtr ( szDestDir,
                            szString2,
                            szPtrFileName
                          );
        return (rc);
    }

    _tsplitpath(szFileName, NULL, NULL, szFileNameOnly, szExt);
    _tcscat(szFileNameOnly, szExt);

    _stprintf( szPathName, "%s%s", 
               szDestDir, 
               szString2 );

    // Save a copy for writing refs.ptr
    _tcscpy(szRefsDir, szPathName);

    // Create the directory to store the file if its not already there
    EnsureTrailingBackslash(szPathName);

    if ( !MakeSureDirectoryPathExists( szPathName ) ) {
        printf("Could not create %s\n", szPathName);
        return (FALSE);
    }

    _tcscat( szPathName, szFileNameOnly );

    // Enter this into the log, skipping the Destination directory
    // at the beginning of szPathName
    //
    dwSizeDestDir = _tcslen(szDestDir);

    dwFileSizeLow = GetFileSize(hTransFile, &dwFileSizeHigh);

    if ( dwFileSizeLow == 0 && dwFileSizeHigh == 0 ) {
        _stprintf( szBuf,"%s,%s", szRefsDir+dwSizeDestDir, szFileName );
    } else {
        _stprintf( szBuf,"\n%s,%s", szRefsDir+dwSizeDestDir, szFileName );
    }

    dwNumBytesToWrite = _tcslen(szBuf) * sizeof(TCHAR);
    WriteFile( hTransFile,
               (LPCVOID)szBuf,
               dwNumBytesToWrite,
               &dwNumBytesWritten,
               NULL
               );

    if ( dwNumBytesToWrite != dwNumBytesWritten ) {
        printf( "FAILED to write to %s, with GetLastError = %d\n",
                szPathName,
                GetLastError()
              );
        return (FALSE);
    }
   
    rc = MyCopyFile(szFileName, szPathName);
    if (!rc) return (FALSE);

    EnsureTrailingBackslash(szRefsDir);
    rc = AddToReferenceCount(szRefsDir, szFileName, _T("file") );

    return (rc);
}


BOOL
StoreFilePtr(
    LPTSTR szDestDir,
    LPTSTR szString2,
    LPTSTR szPtrFileName
)
{

    /*
        szPathName  The full path with "file.ptr" appended to it.
                    This is the path for storing file.ptr



    */
    TCHAR szPathName[_MAX_PATH + _MAX_FNAME + 2];
    TCHAR szRefsDir[_MAX_PATH * 3];

    HANDLE hFile;
    DWORD dwNumBytesToWrite;
    DWORD dwNumBytesWritten;
    DWORD rc;
    DWORD dwSizeDestDir;

    DWORD dwFileSizeLow;
    DWORD dwFileSizeHigh;
    DWORD timeout;
    DWORD First;

    WIN32_FIND_DATA FindFileData;

    _stprintf( szPathName, "%s%s", 
               szDestDir, 
               szString2 );

    // Save a copy for creating refs.ptr
    _tcscpy(szRefsDir, szPathName);

    EnsureTrailingBackslash( szPathName );
    _stprintf( szPathName, "%s%s", szPathName, _T("file.ptr") );


    if ( !MakeSureDirectoryPathExists( szPathName ) ) {
        printf("Could not create %s\n", szPathName);
        return (FALSE);
    }

    // Put this file into file.ptr.  If file.ptr is already there, then
    // replace the contents with this pointer

    // Wait for the file to become available

    timeout=0;
    First = 1;
    do {
        hFile = CreateFile( szPathName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );


        // Only print this message the first time the loop
        // is repeated.

        if ( First && hFile == INVALID_HANDLE_VALUE ) {
            First = 0;
            printf("Failed to open %s for writing, with GetLastError = %d\n",
                   szPathName,
                   GetLastError()
                  );
        }

        // Make sure that delete didn't come through and remove the directory
        if ( !MakeSureDirectoryPathExists( szPathName ) ) {
            printf("Could not create %s\n", szPathName);
            return (FALSE);
        }

        if ( hFile == INVALID_HANDLE_VALUE ) {
            SleepEx(1000,0);
            timeout++;
        }

    } while ( hFile == INVALID_HANDLE_VALUE  && timeout <= 50 ) ;

    if ( timeout > 50 ) {
        printf("Timed out -- could not open %s\n", szPathName);
        return (1);
    }

    dwNumBytesToWrite = _tcslen(szPtrFileName) * sizeof(TCHAR);

    WriteFile( hFile,
               (LPCVOID)szPtrFileName,
               dwNumBytesToWrite,
               &dwNumBytesWritten,
               NULL
             );

    if ( dwNumBytesToWrite != dwNumBytesWritten ) {
          printf( "FAILED to write %s, with GetLastError = %d\n",
                  szPathName,
                  GetLastError()
                );
          CloseHandle(hFile);
          return (FALSE);
    }

    // Enter this into the log, skipping the first part that is the root
    // of the symbols server
    //
    dwSizeDestDir = _tcslen(szDestDir);
    dwFileSizeLow = GetFileSize(hTransFile, &dwFileSizeHigh);

    if ( dwFileSizeLow == 0 && dwFileSizeHigh == 0 ) {
        _stprintf( szPathName, "%s,%s", szRefsDir + dwSizeDestDir, szPtrFileName);
    } else {
        _stprintf( szPathName, "\n%s,%s", szRefsDir + dwSizeDestDir, szPtrFileName);
    }

    dwNumBytesToWrite = _tcslen(szPathName) * sizeof(TCHAR);
    WriteFile( hTransFile,
               (LPCVOID)(szPathName),
               dwNumBytesToWrite,
               &dwNumBytesWritten,
               NULL
             );

    if ( dwNumBytesToWrite != dwNumBytesWritten ) {
        printf( "FAILED to write to %s, with GetLastError = %d\n",
                szPathName,
                GetLastError()
              );
        return (FALSE);
    }

    // File.ptr was created successfully, now, add the contents of
    // szPathName to refs.ptr

    EnsureTrailingBackslash(szRefsDir);
    rc = AddToReferenceCount( szRefsDir, szPtrFileName, "ptr");
    if (!rc) {
        printf("AddToReferenceCount failed for %s,ptr,%s",
                szDestDir, szPtrFileName);
    }

    // If you close this handle sooner, there will be problems if add and
    // delete are running at the same time.  The delete process can come in
    // and delete the directory before AddToReferenceCount gets called.
    // Then the CreateFile in there fails.

    CloseHandle(hFile);

    return (rc);
}

DWORD
StoreFromFile(
    FILE *pStoreFromFile,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts
) {

    LPTSTR szFileName;
    DWORD  dw1,dw2;
    LPTSTR szPtrFileName;
    LPTSTR szBuf;

    TCHAR szFullFileName[_MAX_PATH*2];
    TCHAR szFullPtrFileName[_MAX_PATH*2];

    TCHAR szString[_MAX_PATH];
    LPTSTR token2,token3,token4;
    ULONG i,comma_count,token_start;

    BOOL rc;

    ZeroMemory( szString,_MAX_PATH*sizeof(TCHAR) );

    // Read in each line of the file

    szBuf = (LPTSTR)malloc(_MAX_PATH * 4 * sizeof(TCHAR) );
    if (!szBuf) MallocFailed();

    while ( !feof( pStoreFromFile) ) {

        szFileName=NULL;
        szPtrFileName=NULL;
        _tcscpy(szBuf, _T("") );

        if (!fgets( szBuf, _MAX_PATH*4, pStoreFromFile))
        {
            break;
        }

        if (_tcscmp(szBuf, _T("") ) == 0 )
        {
            break;
        }

        _tcscpy( szFullFileName, pArgs->szShareName );
        _tcscpy( szFullPtrFileName, pArgs->szShareName );


        // Step through szBuf and count how many commas there are
        // If there are 3 commas, this is a new style file.  If there
        // are 4 commas, this is an old style file.

        token2=NULL;
        token3=NULL;
        token4=NULL;

        comma_count=0;
        i=0;
        token_start=i;

        while ( szBuf[i] != _T('\0') && comma_count < 4 ) {
            if ( szBuf[i] == _T(',') ) {
                switch (comma_count) 
                {
                    case 0: szFileName=szBuf;
                            break;
                    case 1: token2=szBuf+token_start;
                            break;
                    case 2: token3=szBuf+token_start;
                            break;
                    case 3: token4=szBuf+token_start;
                            break;
                    default: break; 
                }
                token_start=i+1;
                szBuf[i]=_T('\0');
                comma_count++;
            }
            i++;
        }

        _tcscat( szFullFileName, szFileName);

        if ( comma_count == 3 ) {
            //This is the new style
            _tcscpy( szString,token2);
            if ( *token3 != _T('\0') ) {
                szPtrFileName=token3;
            }
        } else {
            dw1=atoi(token2);
            dw2=atoi(token3);
            if ( *token4 != _T('\0') ) {
                szPtrFileName=token4;
            }
            GetString2( szFileName, NULL, dw1,dw2,szString );
        }  

        if ( szPtrFileName != NULL ) {
            _tcscat( szFullPtrFileName, szPtrFileName);
        }


        if ( szFileName != NULL ) {

            if ( szPtrFileName == NULL ) {
                rc = StoreFile(szDestDir,szFullFileName,szString,NULL);

            } else {
                rc = StoreFile(szDestDir,szFullFileName,szString,szFullPtrFileName);
            }

            if (rc) {
                pFileCounts->NumPassedFiles++;

            } else {
                pFileCounts->NumFailedFiles++;
            }
        }
    }
    free(szBuf);
    return(pFileCounts->NumFailedFiles);
}

BOOL
AddToReferenceCount(
    LPTSTR szDir,           // Directory where refs.ptr belongs
    LPTSTR szFileName,      // Full path and name of the file that is referenced.
    LPTSTR szPtrOrFile      // Was a file or a pointer written
)
{

    HANDLE hFile;
    TCHAR szRefsEntry[_MAX_PATH * 3];
    TCHAR szRefsFileName[_MAX_PATH + 1];
    DWORD dwPtr=0;
    DWORD dwError=0;
    DWORD dwNumBytesToWrite=0;
    DWORD dwNumBytesWritten=0;
    BOOL  FirstEntry = FALSE;
    DWORD First;

    _stprintf( szRefsFileName,"%s\\%s", szDir, _T("refs.ptr") );


    // Find out if this is the first entry in the file or not
    // First, try opening an existing file. If that doesn't work
    // then create a new one.

    First=1;
    do {
        FirstEntry = FALSE;
        hFile = CreateFile( szRefsFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

        if ( hFile == INVALID_HANDLE_VALUE ) {
            FirstEntry = TRUE;
            hFile = CreateFile( szRefsFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
        }

        // Only print a message the first time through

        if ( First  && hFile == INVALID_HANDLE_VALUE ) {
            First = 0;
            printf( "Trying to get write access to %s ...\n", szRefsFileName);
        }
    } while ( hFile == INVALID_HANDLE_VALUE);


    dwPtr = SetFilePointer( hFile,
                    0,
                    NULL,
                    FILE_END );

    if (dwPtr == INVALID_SET_FILE_POINTER) {
        // Obtain the error code.
        dwError = GetLastError() ;
        printf("Failed to move to the end of the file %s with GetLastError = %d\n",
                szRefsFileName, dwError);

        SetEndOfFile(hFile);
        CloseHandle(hFile);
        return(FALSE);
    }


    //
    // Put in a '\n' if this isn't the first entry
    //

    if ( FirstEntry ) {
        _stprintf( szRefsEntry, "%s,%s,%s", pTrans->szId, szPtrOrFile, szFileName);
    } else {
        _stprintf( szRefsEntry, "\n%s,%s,%s", pTrans->szId, szPtrOrFile, szFileName);
    }

    dwNumBytesToWrite = (_tcslen(szRefsEntry)  ) * sizeof(TCHAR);

    WriteFile( hFile,
               (LPCVOID) szRefsEntry,
               dwNumBytesToWrite,
               &dwNumBytesWritten,
               NULL
             );

    if ( dwNumBytesToWrite != dwNumBytesWritten ) {
        printf( "FAILED to write %s, with GetLastError = %d\n",
                szRefsEntry,
                GetLastError()
              );
        SetEndOfFile(hFile);
        CloseHandle(hFile);
        return (FALSE);
    }

    SetEndOfFile(hFile);
    CloseHandle(hFile);
    return (TRUE);
}


BOOL
DeleteAllFilesInDirectory(
    LPTSTR szDir
)
{

    HANDLE hFindFile;
    BOOL Found = FALSE;
    BOOL rc = TRUE;
    LPTSTR szBuf;
    LPTSTR szDir2;
    LPWIN32_FIND_DATA lpFindFileData;

    szDir2 = (LPTSTR)malloc( (_tcslen(szDir) + 4) * sizeof(TCHAR) );
    if (szDir2 == NULL) MallocFailed();
    _tcscpy( szDir2, szDir);
    _tcscat( szDir2, _T("*.*") );

    szBuf = (LPTSTR)malloc( ( _tcslen(szDir) + _MAX_FNAME + _MAX_EXT + 2 )
                            * sizeof(TCHAR) );
    if (szBuf == NULL) MallocFailed();


    lpFindFileData = (LPWIN32_FIND_DATA) malloc (sizeof(WIN32_FIND_DATA) );
    if (!lpFindFileData) MallocFailed();

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szDir2, lpFindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    }

    while ( Found ) {

        if ( !(lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
            _stprintf(szBuf, "%s%s", szDir, lpFindFileData->cFileName);
            if (!DeleteFile(szBuf)) {
                rc = FALSE;
            }
        }
        Found = FindNextFile(hFindFile, lpFindFileData);
    }
    free(lpFindFileData);
    FindClose(hFindFile);
    free(szDir2);
    free(szBuf);
    return(rc);
}

BOOL
StoreNtFile(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName,
    USHORT *rc
    )

/*++

    Routine Description:
        Stores this file as "szDestDir\szFileName\Checksum"

    Return Value:
        TRUE -  file was stored successfully
        FALSE - file was not stored successfully

--*/
{

    BOOL temp_rc;
    HANDLE DosFile = 0;

    PIMAGE_DOS_HEADER pDosHeader = NULL;
    PIMAGE_NT_HEADERS pNtHeader = NULL;
    ULONG TimeDateStamp;
    ULONG SizeOfImage;
    TCHAR szString[_MAX_PATH];

    ZeroMemory(szString, _MAX_PATH*sizeof(TCHAR) );

    pDosHeader = MapFileHeader( szFileName, &DosFile );
    if ( pDosHeader == NULL ) {
        *rc = FILE_SKIPPED;
        return FALSE;
    };

    pNtHeader = GetNtHeader( pDosHeader, DosFile);
    if ( pNtHeader == NULL ) {
        UnmapFile((LPCVOID)pDosHeader,DosFile);
        *rc = FILE_SKIPPED;
        return FALSE;
    }

    __try {
        // Resource Dll's shouldn't have symbols
        if ( ResourceOnlyDll((PVOID)pDosHeader, FALSE) ) {
            *rc = FILE_SKIPPED;
            return FALSE;
        }

        TimeDateStamp = pNtHeader->FileHeader.TimeDateStamp;

        if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            SizeOfImage = ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.SizeOfImage;
        } else {
            if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                SizeOfImage = ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.SizeOfImage;
            } else {
                SizeOfImage = 0;
            }
        }

    } __finally {
        UnmapFile((LPCVOID)pDosHeader,DosFile);
    }

    GetString2( szFileName,
                NULL,
                (DWORD) TimeDateStamp,
                (DWORD) SizeOfImage,
                szString );

    temp_rc = StoreFile( szDestDir, 
                         szFileName, 
                         szString,
                         szPtrFileName );

    if (temp_rc) {
        *rc = FILE_STORED;
        return (TRUE);
    }
    else {
        *rc = FILE_ERRORED;
        return (FALSE);
    }
}


PIMAGE_DOS_HEADER
MapFileHeader (
    LPTSTR szFileName,
    PHANDLE phFile
)

{

    /*
        Creates a file mapping and returns Handle for the DOS_HEADER
        If the file does not have a DOS_HEADER, then it returns NULL.

        If it returns NULL, then this file needs to be skipped.


    */
    HANDLE hFileMap;
    PIMAGE_DOS_HEADER pDosHeader = NULL;

    // phFile map needs to be returned, so it can be closed later
    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                          );

    if (*phFile == INVALID_HANDLE_VALUE) {
        return(NULL);
    }

    hFileMap = CreateFileMapping( *phFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                                );

    if ( !hFileMap) {
        CloseHandle(*phFile);
        return(NULL);
    }

    pDosHeader = (PIMAGE_DOS_HEADER) MapViewOfFile( hFileMap,
                                                    FILE_MAP_READ,
                                                    0,  // high
                                                    0,  // low
                                                    0   // whole file
                                                  );

    CloseHandle(hFileMap);

    if ( !pDosHeader ) {
        UnmapFile((LPCVOID)pDosHeader, *phFile);
        return(NULL);
    }

    //
    // Check to determine if this is an NT image (PE format)

    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        UnmapFile((LPCVOID)pDosHeader,*phFile);
        return(NULL);
    }

    return (pDosHeader);
}



PIMAGE_NT_HEADERS
GetNtHeader ( PIMAGE_DOS_HEADER pDosHeader,
              HANDLE hDosFile
            )
{

    /*
        Returns the pointer the address of the NT Header.  If there isn't
        an NT header, it returns NULL
    */
    PIMAGE_NT_HEADERS pNtHeader = NULL;
    LPBY_HANDLE_FILE_INFORMATION lpFileInfo;


    if (lpFileInfo = (LPBY_HANDLE_FILE_INFORMATION) malloc
                         (sizeof(BY_HANDLE_FILE_INFORMATION)))
    {
        //
        // If the image header is not aligned on a long boundary.
        // Report this as an invalid protect mode image.
        //
        if ( ((ULONG)(pDosHeader->e_lfanew) & 3) == 0)
        {
            if (GetFileInformationByHandle( hDosFile, lpFileInfo) &&
                ((ULONG)(pDosHeader->e_lfanew) <= lpFileInfo->nFileSizeLow))
            {
                pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)pDosHeader +
                                                (ULONG)pDosHeader->e_lfanew);

                if (pNtHeader->Signature != IMAGE_NT_SIGNATURE)
                {
                    pNtHeader = NULL;
                }
            }
        }

        free(lpFileInfo);
    }

    return pNtHeader;
}


BOOL
ResourceOnlyDll(
               PVOID pImageBase,
               BOOLEAN bMappedAsImage
               )

/*++

Routine Description:

    Returns true if the image is a resource only dll.

--*/

{

    PVOID pExports, pImports, pResources;
    DWORD dwExportSize, dwImportSize, dwResourceSize;

    pExports = ImageDirectoryEntryToData(pImageBase,
                                         bMappedAsImage,
                                         IMAGE_DIRECTORY_ENTRY_EXPORT,
                                         &dwExportSize);

    pImports = ImageDirectoryEntryToData(pImageBase,
                                         bMappedAsImage,
                                         IMAGE_DIRECTORY_ENTRY_IMPORT,
                                         &dwImportSize);

    pResources = ImageDirectoryEntryToData(pImageBase,
                                           bMappedAsImage,
                                           IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                           &dwResourceSize);

    if (pResources && dwResourceSize &&
        !pImports && !dwImportSize &&
        !pExports && !dwExportSize) {
        return (TRUE);
    } else {
        return (FALSE);
    }
}

BOOL
MyCopyFile(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName
)
/*++

Routine description:
    This handles whether the file is a compressed file or not.  First it
    tries to copy in the compressed version of the file.  If that works,
    then it will delete the uncompressed file if it exists in the target.

    If the compressed file is not there, then it copies in the 
    uncompressed file.

--*/
{

    TCHAR lpExistingFileName_C[_MAX_PATH*3];  // Compressed version name
    TCHAR lpNewFileName_C[_MAX_PATH*3];       // Compressed version
    DWORD dw;
    BOOL rc;


    // Put a _ at the end of the compressed names

    _tcscpy( lpExistingFileName_C, lpExistingFileName );
    lpExistingFileName_C[ _tcslen(lpExistingFileName_C) - 1 ] = _T('_');
    _tcscpy( lpNewFileName_C, lpNewFileName );
    lpNewFileName_C[ _tcslen( lpNewFileName_C ) - 1 ] = _T('_');

    // If the compressed file exists, copy it instead of the uncompressed file

    dw = GetFileAttributes( lpExistingFileName_C );
    if ( dw != 0xffffffff) {
        rc = CopyFile( lpExistingFileName_C, lpNewFileName_C, TRUE );
        if ( !rc && GetLastError() != ERROR_FILE_EXISTS  ) {
            printf("CopyFile failed to copy %s to %s - GetLastError() = %d\n",
                   lpExistingFileName_C, lpNewFileName_C, GetLastError() );
            return (FALSE);
        }
        SetFileAttributes( lpNewFileName_C, FILE_ATTRIBUTE_NORMAL );

        // If the uncompressed file exists, delete it
        dw = GetFileAttributes( lpNewFileName );
        if ( dw != 0xffffffff ) {
           rc = DeleteFile( lpNewFileName );
           if (!rc) {
               printf("Keeping %s, but could not delete %s\n",
                  lpNewFileName_C, lpNewFileName );
           }
        }
    } else {
        // Compressed file doesn't exist, try the uncompressed
        dw = GetFileAttributes( lpExistingFileName );
        if ( dw != 0xffffffff ) {
            rc = CopyFile( lpExistingFileName, lpNewFileName, TRUE );
            if ( !rc && GetLastError() != ERROR_FILE_EXISTS ) {
                printf("CopyFile failed to copy %s to %s - GetLastError() = %d\n",
                       lpExistingFileName, lpNewFileName, GetLastError() );
                return (FALSE);
            }
            SetFileAttributes( lpNewFileName, FILE_ATTRIBUTE_NORMAL );
        }
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symstore\symutil.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <assert.h>
#include "symsrv.h"

#define IGNORE_IF_SPLIT     130
#define ERROR_IF_SPLIT      131
#define ERROR_IF_NOT_SPLIT  132

#define TRANSACTION_ADD     201
#define TRANSACTION_DEL     202
#define DONT_STORE_FILES    203
#define STORE_FILE          204
#define STORE_PTR           205

#define DEL                 210
#define ADD_STORE           206
#define ADD_DONT_STORE      207
#define ADD_STORE_FROM_FILE 208

#define MAX_VERSION          20
#define MAX_PRODUCT         120
#define MAX_COMMENT         120
#define MAX_ID               10
#define MAX_DATE              8
#define MAX_TIME              8
#define MAX_UNUSED            0

// Define some constants for lengths in the transaction record
// in order to define the maximum length of the record that will
// be written to the master file.
#define TRANS_NUM_COMMAS       8
#define TRANS_EOL              1
#define TRANS_ADD_DEL          3
#define TRANS_FILE_PTR         4


// Define some constants for determining what happened when an NT
// file was stored
#define FILE_STORED             1
#define FILE_SKIPPED            2
#define FILE_ERRORED            3


typedef struct _TRANSACTION {
    LPTSTR szId;          // Id for this transaction
                          // This always refers to the transaction file that
                          // is being deleted or added

    LPTSTR szDelId;       // Id for a delete transaction
                          // This is just appended to the master file, there is
                          // no file created for it.

    DWORD  TransState;    // State of this transaction
    DWORD  FileOrPtr;     // Are we storing files or pointers?
    LPTSTR szProduct;     // Name of the product being added
    LPTSTR szVersion;     // Version of the product
    LPTSTR szComment;     // Description
    LPTSTR szTransFileName; // Full Path and name of the Transaction file
    LPTSTR szTime;
    LPTSTR szDate;
    LPTSTR szUnused;
} TRANSACTION, *PTRANSACTION;

/* ++
    Description of the fields in COM_ARGS

    szSrcDir        Directory where source files exist

    szFileName      File name(s) to store in the symbols server.
                    This may contain wild card characters

    Recurse         Recurse into subdirectories

    szRootDir       Root Directory of the symbols server

    szSymbolsDir    Symbols Directory under the root of the symbols server

    szSrcPath       Path to the files.  If this is not NULL,
                    then store a pointer to the files instead of
                    the files. Typically, this is the same as szSrcDir.
                    The difference is that szSrcPath is the path that
                    the debugger will use to find the symbol file.
                    Thus, it needs to be a network share, whereas szSrcDir
                    can be a local path.

    szId            Reference string for this transaction.  This must be
                    unique for each transaction.

    szAdminDir      Admin directory under the root of the symbols server

    szProduct       Name of the product
    szVersion       Version of the product
    szComment       Text description ... optional
    szMasterFileName The full path and name of the master file.  This contains
                     the master transaction record for each transaction.
    szServerFileName The full path and name of the file that contains a list of
                     all the transactions that are currently stored in the server.
    szTransFileName The full path and name of the file that contains a list of
                    all the files added by this transaction.  This only gets
                    initialized during GetCommandLineArgs if symstore is only
                    supposed to store the transaction file and not store any
                    files on the symbol server.
    szShareName     This is used with the /x option.  It is a prefix of
                    szFileName.  It is the part of szFileName that may
                    change later when the files are added to the server.
    TransState     Is this TRANSACTION_ADD or TRANSACTION_DEL 
    StoreFlags     Possible values: STORE or DONT_STORE
    AppendStoreFile When storing to a file instead of adding the files to the
                    symbol server, open the file with append.

-- */
typedef struct _COMMAND_ARGS {
    LPTSTR  szSrcDir;
    LPTSTR  szFileName;
    BOOL    Recurse;
    LPTSTR  szRootDir;
    LPTSTR  szSymbolsDir;
    LPTSTR  szSrcPath;
    LPTSTR  szId;
    LPTSTR  szAdminDir;
    LPTSTR  szProduct;
    LPTSTR  szVersion;
    LPTSTR  szComment;
    LPTSTR  szUnused;
    LPTSTR  szMasterFileName;
    LPTSTR  szServerFileName;
    LPTSTR  szTransFileName;  
    LPTSTR  szShareName;
    DWORD   ShareNameLength;
    DWORD   TransState;
    DWORD   StoreFlags;
    BOOL    AppendStoreFile;
    FILE    *pStoreFromFile;
    BOOL    VerboseOutput;
} COM_ARGS, *PCOM_ARGS;

typedef struct _FILE_COUNTS {
    DWORD   NumPassedFiles;
    DWORD   NumIgnoredFiles;
    DWORD   NumFailedFiles;
} FILE_COUNTS, *PFILE_COUNTS;



BOOL
StoreDbg(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName
);

BOOL
StorePdb(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName        // If this is NULL, then the file is stored.
                                // If this is not NULL, then a pointer to 
                                // the file is stored.
);

BOOL
DeleteAllFilesInDirectory(
    LPTSTR szDir
);

DECLSPEC_NORETURN
VOID
MallocFailed(
    VOID
);


typedef struct _LIST_ELEM {
    CHAR FName[_MAX_PATH];
    CHAR Path[_MAX_PATH];
} LIST_ELEM, *P_LIST_ELEM;

typedef struct _LIST {
    LIST_ELEM *List;      // Pointers to the file names
    DWORD dNumFiles;
} LIST, *P_LIST;

P_LIST
GetList(
    LPTSTR szFileName
);

BOOL
InList(
    LPTSTR szFileName,
    P_LIST pExcludeList
);

BOOL
StoreNtFile(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName,
    USHORT *rc
);

DWORD
StoreFromFile(
    FILE *pStoreFromFile,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts
);

BOOL
MyCopyFile(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName
);

extern HANDLE hTransFile;
extern DWORD StoreFlags;
extern PCOM_ARGS pArgs;
extern PTRANSACTION pTrans;
extern LONG lMaxTrans;  // Maximum number of characters in a transaction record
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\sources.inc ===
INCLUDES=..\include;..\..\dbg-common

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

USE_CRTDLL = 1

TARGETLIBS      =  $(SDK_LIB_PATH)\kernel32.lib   \
                   $(SDK_LIB_PATH)\shlwapi.lib    \
                   $(SDK_LIB_PATH)\dbghelp.lib    \
                   $(SDK_LIB_PATH)\version.lib    \
                   $(SDK_LIB_PATH)\imagehlp.lib   \
                   $(SDK_LIB_PATH)\user32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\include\cvcommon.h ===
/*
 *   PROTOTYPES, TYPEDEFS and other items for cvcommon.c
 */

DWORD   CreateSignature( PPOINTERS p );
DWORD   CreateDirectories( PPOINTERS p );
DWORD   CreateModuleDirectoryEntries( PPOINTERS p );
DWORD   CreateSegMapDirectoryEntries( PPOINTERS p );
DWORD   CreateSrcModulesDirectoryEntries( PPOINTERS p );
DWORD   CreatePublicDirectoryEntries( PPOINTERS p );
DWORD   CreateSymbolHashTable( PPOINTERS p );
DWORD   CreateAddressSortTable( PPOINTERS p );
DWORD   DWordXorLrl(char * szSym);
OMFModule *     NextMod(OMFModule * pMod);
VOID    UpdatePtrs( PPOINTERS p, PPTRINFO pi, LPVOID lpv, DWORD count );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symsrv\symstore\inc\pdb.h ===
// Debug Information API
// Copyright (C) 1993-1996, Microsoft Corp.  All Rights Reserved.

#pragma once

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __PDB_INCLUDED__
#define __PDB_INCLUDED__

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned __int64 DWORDLONG;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SIG;        // unique (across PDB instances) signature
typedef ULONG   AGE;        // no. of times this instance has been updated
typedef const char*     SZ_CONST;   // const string
typedef void *          PV;
typedef const void *    PCV;

#ifdef  LNGNM
#define LNGNM_CONST	const
#else   // LNGNM
#define LNGNM_CONST
#endif  // LNGNM

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
} GUID;

#endif // !GUID_DEFINED

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;

#endif // !_HRESULT_DEFINED


typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

enum {
#ifdef LNGNM
    PDBIntv70   = 20000406,
    PDBIntv70Dep = 20000301,
#else
    PDBIntv70   = 20000301,
#endif
    PDBIntv69   = 19990511,
    PDBIntv61   = 19980914,
    PDBIntv50a  = 19970116,
    PDBIntv60   = PDBIntv50a,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
#ifdef LNGNM
    PDBIntv     = PDBIntv70,   // Now we support both 50 & 60, 69 is only an intermediate version
    PDBIntvAlt  = PDBIntv50,   
    PDBIntvAlt2 = PDBIntv60,   
    PDBIntvAlt3 = PDBIntv69,
#else
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntvAlt2 = PDBIntv60,   // Alternate (backward compatible) supported interface
    PDBIntvAlt3 = PDBIntv61,
    PDBIntv     = PDBIntv69,
#endif  
};

enum {
    PDBImpvVC2  = 19941610,
    PDBImpvVC4  = 19950623,
    PDBImpvVC41 = 19950814,
    PDBImpvVC50 = 19960307,
    PDBImpvVC98 = 19970604,
    PDBImpvVC70 = 20000404,
    PDBImpvVC70Dep = 19990604,  // deprecated vc70 implementation version
#ifdef LNGNM
    PDBImpv     = PDBImpvVC70,
#else
    PDBImpv     = PDBImpvVC98,
#endif
};


enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
};

// cvinfo.h type index, intentionally typedef'ed here to check equivalence.
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.

typedef CV_typ_t        TI;     // PDB name for type index
typedef CV_typ16_t      TI16;   // 16-bit version
typedef unsigned long   NI;     // name index
typedef TI *            PTi;
typedef TI16 *          PTi16;

typedef BYTE            ITSM;   // type server map index
typedef ITSM*           PITSM;

typedef BOOL    (__stdcall *PFNVALIDATEDEBUGINFOFILE) (const char * szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancilliary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    char *  szMod;                      // exe/dll
    char *  szLib;                      // lib if appropriate
    char *  szObj;                      // object file
    char * *rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char  szValidatedFile[PDB_MAX_PATH];// output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
    char *  szExe;                      // exe/dll
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

typedef BOOL ( __stdcall * PfnFindDebugInfoFile) ( PSEARCHDEBUGINFO );

#define PdbInterface struct

PdbInterface PDB;                   // program database
PdbInterface DBI;                   // debug information within the PDB
PdbInterface Mod;                   // a module within the DBI
PdbInterface TPI;                   // type info within the DBI
PdbInterface GSI;                   // global symbol info
PdbInterface SO;                    
PdbInterface Stream;                // some named bytestream in the PDB
PdbInterface StreamImage;           // some memory mapped stream
PdbInterface NameMap;              // name mapping
PdbInterface Enum;                 // generic enumerator
PdbInterface EnumNameMap;          // enumerate names within a NameMap
PdbInterface EnumContrib;          // enumerate contributions
PdbInterface Dbg;                   // misc debug data (FPO, OMAP, etc)
PdbInterface Src;                   // Src file data
PdbInterface EnumSrc;               // Src file enumerator
PdbInterface SrcHash;               // Src file hasher
PdbInterface EnumLines;

typedef PdbInterface PDB PDB;
typedef PdbInterface DBI DBI;
typedef PdbInterface Mod Mod;
typedef PdbInterface TPI TPI;
typedef PdbInterface GSI GSI;
typedef PdbInterface SO SO;
typedef PdbInterface Stream Stream;
typedef PdbInterface StreamImage StreamImage;
typedef PdbInterface NameMap NameMap;
typedef PdbInterface Enum Enum;
typedef PdbInterface EnumStreamNames EnumStreamNames;
typedef PdbInterface EnumNameMap EnumNameMap;
typedef PdbInterface EnumContrib EnumContrib;
typedef PdbInterface WidenTi WidenTi;
typedef PdbInterface Dbg Dbg;
typedef PdbInterface EnumThunk EnumThunk;
typedef PdbInterface Src Src;
typedef PdbInterface EnumSrc EnumSrc;
typedef PdbInterface SrcHash SrcHash;

typedef SrcHash *   PSrcHash;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_ILLEGAL_TYPE_EDIT,   // trying to edit types in read-only mode
    EC_INVALID_EXECUTABLE,  // not recogized as a valid executable
    EC_DBG_NOT_FOUND,       // A required .DBG file was not found
    EC_NO_DEBUG_INFO,       // No recognized debug info found
    EC_INVALID_EXE_TIMESTAMP, // Invalid timestamp on Openvalidate of exe
    EC_RESERVED, // RESERVED for future use
    EC_DEBUG_INFO_NOT_IN_PDB, // returned by OpenValidateX
    EC_MAX
};

#if !defined(pure)
#define  pure = 0
#endif

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#ifdef PDB_SERVER
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllexport) RTYPE PDBCALL
#elif   defined(PDB_LIBRARY)
#define PDB_IMPORT_EXPORT(RTYPE)    RTYPE PDBCALL
#else
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL
#endif

#define PDBAPI PDB_IMPORT_EXPORT

#ifndef IN
#define IN                  /* in parameter, parameters are IN by default */
#endif
#ifndef OUT
#define OUT                 /* out parameter */
#endif

// Type of callback arg to PDB::OpenValidate5

enum POVC
{
    povcNotifyDebugDir,
    povcNotifyOpenDBG,
    povcNotifyOpenPDB,
    povcNotifySymbolServerQuery,
    povcReadExecutableAt,
    povcReadExecutableAtRVA,
};

typedef int (PDBCALL *PDBCALLBACK)();

typedef PDBCALLBACK (PDBCALL *PfnPDBQueryCallback)(void *pvClient, enum POVC povc);

typedef void (PDBCALL *PfnPDBNotifyDebugDir)(void *pvClient, BOOL fExecutable, const struct _IMAGE_DEBUG_DIRECTORY *pdbgdir);
typedef void (PDBCALL *PfnPDBNotifyOpenDBG)(void *pvClient, const wchar_t *wszDbgPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifyOpenPDB)(void *pvClient, const wchar_t *wszPdbPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifySymbolServerQuery)(void *pvClient, const char *szURL, HRESULT hr);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAt)(void *pvClient, DWORDLONG fo, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAtRVA)(void *pvClient, DWORD rva, DWORD cb, void *pv);

// type of callback arg to PDB::GetRawBytes
typedef BOOL (PDBCALL *PFNfReadPDBRawBytes)(const void *, long);

// WidenTi interface needs a couple of structures to communicate info back
// and forth.
struct OffMap {
    ULONG       offOld;
    ULONG       offNew;
};
typedef struct OffMap   OffMap;
typedef OffMap *        POffMap;

struct SymConvertInfo {
    ULONG       cbSyms;             // size necessary for converting a block
    ULONG       cSyms;              // count of symbols, necessary to allocate
                                    // mpoffOldoffNew array.
    BYTE *      pbSyms;             // block of symbols (output side)
    OffMap *    rgOffMap;           // OffMap rgOffMap[cSyms]
};
typedef struct SymConvertInfo   SymConvertInfo;
enum { wtiSymsNB09 = 0, wtiSymsNB10 = 1 };

// Filter values for PDBCopyTo
enum { 
    copyRemovePrivate       = 0x00000001,   // remove private debug information
    copyCreateNewSig        = 0x00000002,   // create new signature for target pdb
};

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,   // deprecated
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
#if !defined(VER60)
    dbgtypeTokenRidMap,
    dbgtypeXData,
    dbgtypePData,
    dbgtypeNewFPO,
#endif
    dbgtypeMax          // must be last!
};

typedef enum DBGTYPE DBGTYPE;

// Linker data necessary for relinking an image.  Record contains two SZ strings
// off of the end of the record with two offsets from the base 
//
enum VerLinkInfo {
    vliOne = 1,
    vliTwo = 2,
    vliCur = vliTwo,
};

struct LinkInfo {
    ULONG           cb;             // size of the whole record.  computed as
                                    //  sizeof(LinkInfo) + strlen(szCwd) + 1 +
                                    //  strlen(szCommand) + 1
    ULONG           ver;            // version of this record (VerLinkInfo)
    ULONG           offszCwd;       // offset from base of this record to szCwd
    ULONG           offszCommand;   // offset from base of this record
    ULONG           ichOutfile;     // index of start of output file in szCommand
    ULONG           offszLibs;      // offset from base of this record to szLibs

    // The command includes the full path to the linker, the -re and -out:...
    // swithches.
    // A sample might look like the following:
    // "c:\program files\msdev\bin\link.exe -re -out:debug\foo.exe"
    // with ichOutfile being 48.
    // the -out switch is guaranteed to be the last item in the command line.
#ifdef __cplusplus
    VerLinkInfo Ver() const {
        return VerLinkInfo(ver);
    }
    long Cb() const {
        return cb;
    }
    char *     SzCwd() const {
        return (char *)((char *)(this) + offszCwd);
    }
    char *    SzCommand() const {
        return (char *)((char *)(this) + offszCommand);
    }
    char *    SzOutFile() const {
        return SzCommand() + ichOutfile;
    }
    LinkInfo() :
        cb(0), ver(vliCur), offszCwd(0), offszCommand(0), ichOutfile(0)
    {
    }
    char *    SzLibs() const {
        return (char *)((char *)(this) + offszLibs);
    }

#endif
};

#ifdef LNGNM
#ifdef __cplusplus
struct LinkInfoW : public LinkInfo
{
    wchar_t* SzCwdW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCwd);
    }
    wchar_t* SzCommandW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCommand);
    }
    wchar_t* SzOutFileW() const {
        return SzCommandW() + ichOutfile;
    }
    wchar_t* SzLibsW() const {
        return (wchar_t *)((wchar_t *)(this) + offszLibs);
    }
};
#else
typedef struct LinkInfo LinkInfoW;
#endif  // __cplusplus

typedef LinkInfoW * PLinkInfoW;

#endif  // LNGNM

typedef struct LinkInfo LinkInfo;
typedef LinkInfo *      PLinkInfo;


//
// Source (Src) info
//
// This is the source file server for virtual and real source code.
// It is structured as an index on the object file name concatenated
// with 
enum SrcVer {
    srcverOne = 19980827,
};

enum SrcCompress {
    srccompressNone,
    srccompressRLE,
    srccompressHuffman,
    srccompressLZ,
};

#ifdef LNGNM
struct tagSrcHeader {
#else
struct SrcHeader {
#endif
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
#ifndef LNGNM
    unsigned char   szNames[1]; // file names (szFile "\0" szObj "\0" szVirtual,
                                //  as in: "f.cpp" "\0" "f.obj" "\0" "*inj:1:f.obj")
                                // in the case of non-virtual files, szVirtual is
                                // the same as szFile.
#endif
};

#ifdef LNGNM
struct SrcHeader : public tagSrcHeader
{
    unsigned char szNames[1];   // see comment above
};

struct SrcHeaderW : public tagSrcHeader
{
    wchar_t szNames[1];   // see comment above
};

typedef struct SrcHeaderW    SrcHeaderW;
typedef SrcHeaderW *         PSrcHeaderW;
typedef const SrcHeaderW *   PCSrcHeaderW;

//cassert(offsetof(SrcHeader,szNames) == sizeof(tagSrcHeader));
//cassert(offsetof(SrcHeaderW,szNames) == sizeof(tagSrcHeader));

#endif      // LNGNM

typedef struct SrcHeader    SrcHeader;
typedef SrcHeader *         PSrcHeader;
typedef const SrcHeader *   PCSrcHeader;

// header used for storing the info and for output to clients who are reading
//
struct SrcHeaderOut {
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned long   niFile;
    unsigned long   niObj;
    unsigned long   niVirt;
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
    short           sPad;
    union {
        void *      pvReserved1;
        __int64     pv64Reserved2;
    };
};

typedef struct SrcHeaderOut SrcHeaderOut;
typedef SrcHeaderOut *      PSrcHeaderOut;
typedef const SrcHeaderOut *PCSrcHeaderOut;

struct SrcHeaderBlock {
    __int32     ver;
    __int32     cb;
    struct {
        DWORD   dwLowDateTime;
        DWORD   dwHighDateTime;
    } ft;
    __int32     age;
    BYTE        rgbPad[44];
};

typedef struct SrcHeaderBlock   SrcHeaderBlock;


#ifdef __cplusplus

struct IStream;

// C++ Binding

PdbInterface PDB {                 // program database
    enum {
        intv  = PDBIntv,
#if defined(LNGNM)
        intvVC70Dep = PDBIntv70Dep, // deprecated
#endif
        intvAlt = PDBIntvAlt,
        intvAlt2 = PDBIntvAlt2,
        intvAlt3 = PDBIntvAlt3,
    };

    static PDBAPI(BOOL)
           OpenValidate(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           Open(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate3(
               const char *szExecutable,
               const char *szSearchPath,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT char szDbgPath[PDB_MAX_PATH],
               OUT DWORD *pfo,
               OUT DWORD *pcb,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate4(
               const wchar_t *wszPDB,
               const char *szMode,
               PCSIG70 pcsig70,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) OpenInStream(
               IStream *pIStream,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) ExportValidateInterface(INTV intv);
    static PDBAPI(BOOL) ExportValidateImplementation(IMPV impv);

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual EC   QueryLastError(OUT char szError[cbErrMax]) pure;
    virtual char*QueryPDBName(OUT char szPDB[PDB_MAX_PATH]) pure;
    virtual SIG  QuerySignature() pure;
    virtual AGE  QueryAge() pure;
    virtual BOOL CreateDBI(const char* szTarget, OUT DBI** ppdbi) pure;
    virtual BOOL OpenDBI(const char* szTarget, const char* szMode, OUT DBI** ppdbi ) pure;
    virtual BOOL OpenTpi(const char* szMode, OUT TPI** pptpi) pure;

    virtual BOOL Commit() pure;
    virtual BOOL Close() pure;
    virtual BOOL OpenStream(const char* szStream, OUT Stream** ppstream) pure;
    virtual BOOL GetEnumStreamNameMap(OUT Enum** ppenum) pure;
    virtual BOOL GetRawBytes(PFNfReadPDBRawBytes fSnarfRawBytes) pure;
    virtual IMPV QueryPdbImplementationVersion() pure;

    virtual BOOL OpenDBIEx(const char* szTarget, const char* szMode, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn=0) pure;

    virtual BOOL CopyTo(const char *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;

    //
    // support for source file data
    //
    virtual BOOL OpenSrc(OUT Src** ppsrc) pure;

    virtual EC   QueryLastErrorExW(OUT wchar_t *wszError, size_t cchMax) pure;
    virtual wchar_t *QueryPDBNameExW(OUT wchar_t *wszPDB, size_t cchMax) pure;
    virtual BOOL QuerySignature2(PSIG70 psig70) pure;
    virtual BOOL CopyToW(const wchar_t *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;
    virtual BOOL fIsSZPDB() const pure;
#ifdef LNGNM
    virtual BOOL OpenStreamW(const wchar_t * szStream, OUT Stream** ppstream) pure;
#endif


    inline BOOL ValidateInterface()
    {
        return ExportValidateInterface(intv);
    }

    static PDBAPI(BOOL)
           Open2W(
               const wchar_t *wszPDB,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx2W(
               const wchar_t *wszPDB,
               const char *szMode,
               long cbPage,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate5(
               const wchar_t *wszExecutable,
               const wchar_t *wszSearchPath,
               void *pvClient,
               PfnPDBQueryCallback pfnQueryCallback,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);


};


// Review: a stream directory service would be more appropriate
// than Stream::Delete, ...

PdbInterface Stream {
    virtual long QueryCb() pure;
    virtual BOOL Read(long off, void* pvBuf, long* pcbBuf) pure;
    virtual BOOL Write(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Replace(void* pvBuf, long cbBuf) pure;
    virtual BOOL Append(void* pvBuf, long cbBuf) pure;
    virtual BOOL Delete() pure;
    virtual BOOL Release() pure;
    virtual BOOL Read2(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Truncate(long cb) pure;
};

PdbInterface StreamImage {
    static PDBAPI(BOOL) open(Stream* pstream, long cb, OUT StreamImage** ppsi);
    virtual long size() pure;
    virtual void* base() pure;
    virtual BOOL noteRead(long off, long cb, OUT void** ppv) pure;
    virtual BOOL noteWrite(long off, long cb, OUT void** ppv) pure;
    virtual BOOL writeBack() pure;
    virtual BOOL release() pure;
};

PdbInterface DBI {             // debug information
    enum { intv = PDBIntv };
    virtual IMPV QueryImplementationVersion() pure;
    virtual INTV QueryInterfaceVersion() pure;
    virtual BOOL OpenMod(const char* szModule, const char* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteMod(const char* szModule) pure;
    virtual BOOL QueryNextMod(Mod* pmod, Mod** ppmodNext) pure;
    virtual BOOL OpenGlobals(OUT GSI **ppgsi) pure;
    virtual BOOL OpenPublics(OUT GSI **ppgsi) pure;
    virtual BOOL AddSec(USHORT isect, USHORT flags, long off, long cb) pure;
    virtual BOOL QueryModFromAddr(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb) pure;
    virtual BOOL QuerySecMap(OUT BYTE* pb, long* pcb) pure;
    virtual BOOL QueryFileInfo(OUT BYTE* pb, long* pcb) pure;
    virtual void DumpMods() pure;
    virtual void DumpSecContribs() pure;
    virtual void DumpSecMap() pure;

    virtual BOOL Close() pure;
    virtual BOOL AddThunkMap(long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                    struct SO* psoSectMap, unsigned nSects,
                    USHORT isectThunkTable, long offThunkTable) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL getEnumContrib(OUT Enum** ppenum) pure;
    virtual BOOL QueryTypeServer( ITSM itsm, OUT TPI** pptpi ) pure;
    virtual BOOL QueryItsmForTi( TI ti, OUT ITSM* pitsm ) pure;
    virtual BOOL QueryNextItsm( ITSM itsm, OUT ITSM *inext ) pure;
    virtual BOOL QueryLazyTypes() pure;
    virtual BOOL SetLazyTypes( BOOL fLazy ) pure;   // lazy is default and can only be turned off
    virtual BOOL FindTypeServers( OUT EC* pec, OUT char szError[cbErrMax] ) pure;
    virtual void DumpTypeServers() pure;
    virtual BOOL OpenDbg(DBGTYPE dbgtype, OUT Dbg **ppdbg) pure;
    virtual BOOL QueryDbgTypes(OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype) pure;
    // apis to support EnC work
    virtual BOOL QueryAddrForSec(OUT USHORT* pisect, OUT long* poff, 
            USHORT imod, long cb, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdb( OUT PDB** pppdb ) pure;
    virtual BOOL AddLinkInfo(IN PLinkInfo ) pure;
    virtual BOOL QueryLinkInfo(PLinkInfo, OUT long * pcb) pure;
    // new to vc6
    virtual AGE  QueryAge() const pure;
    virtual void * QueryHeader() const pure;
    virtual void FlushTypeServers() pure;
    virtual BOOL QueryTypeServerByPdb(const char* szPdb, OUT ITSM* pitsm) pure;

#ifdef LNGNM        // Long filename support
    virtual BOOL OpenModW(const wchar_t* szModule, const wchar_t* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteModW(const wchar_t* szModule) pure;
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL QueryTypeServerByPdbW( const wchar_t* szPdb, OUT ITSM* pitsm ) pure;
    virtual BOOL AddLinkInfoW(IN PLinkInfoW ) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual USHORT QueryMachineType() const pure;
    virtual void SetMachineType(USHORT wMachine) pure;
    virtual void RemoveDataForRva( ULONG rva, ULONG cb ) pure;
#endif

};

PdbInterface Mod {             // info for one module within DBI
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BOOL AddTypes(BYTE* pbTypes, long cb) pure;
    virtual BOOL AddSymbols(BYTE* pbSym, long cb) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL AddSecContrib(USHORT isect, long off, long cb, ULONG dwCharacteristics) pure;
    virtual BOOL QueryCBName(OUT long* pcb) pure;
    virtual BOOL QueryName(OUT char szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySymbols(BYTE* pbSym, long* pcb) pure;
    virtual BOOL QueryLines(BYTE* pbLines, long* pcb) pure;

    virtual BOOL SetPvClient(void *pvClient) pure;
    virtual BOOL GetPvClient(OUT void** ppvClient) pure;
    virtual BOOL QueryFirstCodeSecContrib(OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
//
// Make all users of this api use the real one, as this is exactly what it was
// supposed to query in the first place
//
#define QuerySecContrib QueryFirstCodeSecContrib

    virtual BOOL QueryImod(OUT USHORT* pimod) pure;
    virtual BOOL QueryDBI(OUT DBI** ppdbi) pure;
    virtual BOOL Close() pure;
    virtual BOOL QueryCBFile(OUT long* pcb) pure;
    virtual BOOL QueryFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryTpi(OUT TPI** pptpi) pure; // return this Mod's Tpi
    // apis to support EnC work
    virtual BOOL AddSecContribEx(USHORT isect, long off, long cb, ULONG dwCharacteristics, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QueryItsm(OUT USHORT* pitsm) pure;
    virtual BOOL QuerySrcFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdbFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL ReplaceLines(BYTE* pbLines, long cb) pure;
#ifdef LNGNM
    // V7 line number support
	virtual bool GetEnumLines( EnumLines** ppenum ) pure;
	virtual bool QueryLineFlags( OUT DWORD* pdwFlags ) pure;	// what data is present?
	virtual bool QueryFileNameInfo( 
                    IN DWORD        fileId,                 // source file identifier
                    OUT wchar_t*    szFilename,             // file name string 
                    IN OUT DWORD*   pccFilename,            // length of string
                    OUT DWORD*      pChksumType,            // type of chksum
                    OUT BYTE*       pbChksum,   	        // pointer to buffer for chksum data
                    IN OUT DWORD*   pcbChksum		        // number of bytes of chksum (in/out)
                    ) pure; 	    
    // Long filenames support
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL AddLinesW(const wchar_t* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          ULONG lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL QueryNameW(OUT wchar_t szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySrcFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryPdbFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
#endif
};

PdbInterface TPI {             // type info

    enum { intv = PDBIntv };

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;

    virtual BOOL QueryTi16ForCVRecord(BYTE* pb, OUT TI16* pti) pure;
    virtual BOOL QueryCVRecordForTi16(TI16 ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi16(TI16 ti, OUT BYTE** ppb) pure;
    virtual TI16 QueryTi16Min() pure;
    virtual TI16 QueryTi16Mac() pure;

    virtual long QueryCb() pure;
    virtual BOOL Close() pure;
    virtual BOOL Commit() pure;

    virtual BOOL QueryTi16ForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI16* pti) pure;
    virtual BOOL SupportQueryTiForUDT() pure;

    // the new versions that truly take 32-bit types
    virtual BOOL fIs16bitTypePool() pure;
    virtual BOOL QueryTiForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti) pure;
    virtual BOOL QueryTiForCVRecord(BYTE* pb, OUT TI* pti) pure;
    virtual BOOL QueryCVRecordForTi(TI ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi(TI ti, OUT BYTE** ppb) pure;
    virtual TI   QueryTiMin() pure;
    virtual TI   QueryTiMac() pure;
    virtual BOOL AreTypesEqual( TI ti1, TI ti2 ) pure;
    virtual BOOL IsTypeServed( TI ti ) pure;
#ifdef LNGNM
    virtual BOOL QueryTiForUDTW(const wchar_t *wcs, BOOL fCase, OUT TI* pti) pure;
#endif
};

PdbInterface GSI {
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BYTE* NextSym(BYTE* pbSym) pure;
    virtual BYTE* HashSym(const char* szName, BYTE* pbSym) pure;
    virtual BYTE* NearestSym(USHORT isect, long off, OUT long* pdisp) pure;      //currently only supported for publics
    virtual BOOL Close() pure;
    virtual BOOL getEnumThunk(USHORT isect, long off, OUT EnumThunk** ppenum) pure;
    virtual unsigned long OffForSym(BYTE *pbSym) pure;
    virtual BYTE* SymForOff(unsigned long off) pure;
#ifdef LNGNM
    virtual BYTE* HashSymW(const wchar_t *wcsName, BYTE* pbSym) pure;
#endif
};


PdbInterface NameMap {
    static PDBAPI(BOOL) open(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
    virtual BOOL close() pure;
    virtual BOOL reinitialize() pure;
    virtual BOOL getNi(const char* sz, OUT NI* pni) pure;
    virtual BOOL getName(NI ni, OUT const char** psz) pure;
    virtual BOOL getEnumNameMap(OUT Enum** ppenum) pure;
    virtual BOOL contains(const char* sz, OUT NI* pni) pure;
    virtual BOOL commit() pure;
    virtual BOOL isValidNi(NI ni) pure;
#ifdef LNGNM
    virtual BOOL getNiW(const wchar_t* sz, OUT NI* pni) pure;
    virtual BOOL getNameW(NI ni, OUT wchar_t* szName, IN OUT size_t * pcch) pure;
    virtual BOOL containsW(const wchar_t *sz, OUT NI* pni) pure;
#endif
};

#define __ENUM_INCLUDED__
PdbInterface Enum {
    virtual void release() pure;
    virtual void reset() pure;
    virtual BOOL next() pure;
};

PdbInterface EnumNameMap : Enum {
    virtual void get(OUT const char** psz, OUT NI* pni) pure;
};

PdbInterface EnumContrib : Enum {
    virtual void get(OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual void getCrcs(OUT DWORD* pcrcData, OUT DWORD* pcrcReloc ) pure;
    virtual bool fUpdate(IN long off, IN long cb) pure;
};

PdbInterface EnumThunk: Enum {
	virtual void get( OUT USHORT* pisect, OUT long* poff, OUT long* pcb ) pure;
};

struct CV_Line_t;
struct CV_Column_t;
PdbInterface EnumLines: public Enum
{
    // 
    // Blocks of lines are always in offset order, lines within blocks are also ordered by offset
    //
    virtual bool getLines( 	
        OUT DWORD*      fileId, 	// id for the filename
        OUT DWORD*      poffset,	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines, 	// number of lines (in/out)
        OUT CV_Line_t*  pLines		// pointer to buffer for line info
        ) = 0;
    virtual bool getLinesColumns( 	
        OUT DWORD*      fileId,     // id for the filename	    
        OUT DWORD*      poffset, 	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines,    // number of lines (in/out)
        OUT CV_Line_t*  pLines,		// pointer to buffer for line info
        OUT CV_Column_t*pColumns	// pointer to buffer for column info
        ) = 0;
};

//
// interface to use to widen type indices from 16 to 32 bits
// and store the results in a new location.
//
PdbInterface WidenTi {
public:
    static PDBAPI(BOOL)
    fCreate (
        WidenTi *&,
        unsigned cTypeInitialCache =256,
        BOOL fNB10Syms =wtiSymsNB09
        );

    virtual void
    release() pure;

    virtual BYTE /* TYPTYPE */ *
    pTypeWidenTi ( TI ti16, BYTE /* TYPTYPE */ * ) pure;

    virtual BYTE /* SYMTYPE */ *
    pSymWidenTi ( BYTE /* SYMTYPE */ * ) pure;

    virtual BOOL
    fTypeWidenTiNoCache ( BYTE * pbTypeDst, BYTE * pbTypeSrc, long & cbDst ) pure;

    virtual BOOL
    fSymWidenTiNoCache ( BYTE * pbSymDst, BYTE * pbSymSrc, long & cbDst ) pure;

    virtual BOOL
    fTypeNeedsWidening ( BYTE * pbType ) pure;

    virtual BOOL
    fSymNeedsWidening ( BYTE * pbSym ) pure;

    virtual BOOL
    freeRecord ( void * ) pure;

    // symbol block converters/query.  symbols start at doff from pbSymIn,
    // converted symbols will go at sci.pbSyms + doff, cbSyms are all including
    // doff.
    virtual BOOL
        fQuerySymConvertInfo (
        SymConvertInfo &    sciOut,
        BYTE *              pbSym,
        long                cbSym,
        int                 doff =0
        ) pure;

    virtual BOOL
    fConvertSymbolBlock (
        SymConvertInfo &    sciOut,
        BYTE *              pbSymIn,
        long                cbSymIn,
        int                 doff =0
        ) pure;
};

// interface for managing Dbg data
PdbInterface Dbg {
   // close Dbg Interface
   virtual BOOL Close() pure;
   // return number of elements (NOT bytes)
   virtual long QuerySize() pure;
   // reset enumeration index
   virtual void Reset() pure;
   // skip next celt elements (move enumeration index)
   virtual BOOL Skip(ULONG celt) pure;
   // query next celt elements into user-supplied buffer
   virtual BOOL QueryNext(ULONG celt, OUT void *rgelt) pure;
   // search for an element and fill in the entire struct given a field.
   // Only supported for the following debug types and fields:
   // DBG_FPO              'ulOffStart' field of FPO_DATA
   // DBG_FUNC             'StartingAddress' field of IMAGE_FUNCTION_ENTRY
   // DBG_OMAP             'rva' field of OMAP
   virtual BOOL Find(IN OUT void *pelt) pure;
   // remove debug data
   virtual BOOL Clear() pure;
   // append celt elements
   virtual BOOL Append(ULONG celt, const void *rgelt) pure;
   // replace next celt elements
   virtual BOOL ReplaceNext(ULONG celt, const void *rgelt) pure;
};

PdbInterface Src {
    // close and commit the changes (when open for write)
    virtual bool
    Close() pure;

    // add a source file or file-ette
    virtual bool
    Add(IN PCSrcHeader psrcheader, IN const void * pvData) pure;

    // remove a file or file-ette or all of the injected code for
    // one particular compiland (using the object file name)
    virtual bool
    Remove(IN SZ_CONST szFile) pure;

    // query and copy the header/control data to the output buffer
    virtual bool
    QueryByName(IN SZ_CONST szFile, OUT PSrcHeaderOut psrcheaderOut) const pure;

    // copy the file data (the size of the buffer is in the SrcHeaderOut
    // structure) to the output buffer.
    virtual bool
    GetData(IN PCSrcHeaderOut pcsrcheader, OUT void * pvData) const pure;

    // create an enumerator to traverse all of the files included
    // in the mapping.
    virtual bool
    GetEnum(OUT EnumSrc ** ppenum) const pure;

    // Get the header block (master header) of the Src data.
    // Includes age, time stamp, version, and size of the master stream
    virtual bool
    GetHeaderBlock(SrcHeaderBlock & shb) const pure;
#ifdef LNGNM
    virtual bool RemoveW(IN wchar_t *wcsFile) pure;
    virtual bool QueryByNameW(IN wchar_t *wcsFile, OUT PSrcHeaderOut psrcheaderOut) const pure;
    virtual bool AddW(IN PCSrcHeaderW psrcheader, IN const void * pvData) pure;
#endif
};

PdbInterface EnumSrc : Enum {
    virtual void get(OUT PCSrcHeaderOut * ppcsrcheader) pure;
};


PdbInterface SrcHash {

    // Various types we need
    //
    
    // Tri-state return type
    //
    enum TriState {
        tsYes,
        tsNo,
        tsMaybe,
    };

    // Hash identifier
    //
    enum HID {
        hidNone,
        hidMD5,
        hidMax,
    };

    // Define machine independent types for storage of HashID and size_t
    //
    typedef __int32 HashID_t;
    typedef unsigned __int32 CbHash_t;

    // Create a SrcHash object with the usual two-stage construction technique
    //
    static PDBAPI(bool)
    FCreateSrcHash(OUT PSrcHash &);

    // Accumulate more bytes into the hash
    //
    virtual bool
    FHashBuffer(IN PCV pvBuf, IN size_t cbBuf) pure;

    // Query the hash id
    //
    virtual HashID_t
    HashID() const pure;

    // Query the size of the hash 
    //
    virtual CbHash_t
    CbHash() const pure;

    // Copy the hash bytes to the client buffer
    //
    virtual void
    GetHash(OUT PV pvHash, IN CbHash_t cbHash) const pure;

    // Verify the incoming hash against a target buffer of bytes
    // returning a yes it matches, no it doesn't, or indeterminate.
    //
    virtual TriState
    TsVerifyHash(
        IN HID,
        IN CbHash_t cbHash,
        IN PCV pvHash,
        IN size_t cbBuf,
        IN PCV pvBuf
        ) pure;

    // Reset this object to pristine condition
    //
    virtual bool
    FReset() pure;

    // Close off and release this object
    //
    virtual void
    Close() pure;
};

#endif  // __cplusplus

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

typedef BOOL (PDBCALL *PfnPDBOpen)(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **);

PDBAPI(BOOL)
PDBOpen(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpen2W(
    const wchar_t *wszPDB,
    const char *szMode,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx2W(
    const wchar_t *wszPDB,
    const char *szMode,
    long cbPage,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate3(
    const char *szExecutable,
    const char *szSearchPath,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate4(
    const wchar_t *wszPDB,
    const char *szMode,
    PCSIG70 pcsig70,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate5(
    const wchar_t *wszExecutable,
    const wchar_t *wszSearchPath,
    void *pvClient,
    PfnPDBQueryCallback pfnQueryCallback,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI(BOOL)
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface(void)
{
    return PDBExportValidateInterface(PDBIntv);
}

typedef BOOL (PDBCALL *PfnPDBExportValidateInterface)(INTV);

__inline BOOL PDBValidateInterfacePfn(PfnPDBExportValidateInterface pfn)
{
    return (*pfn)(PDBIntv);
}

PDBAPI(EC)     PDBQueryLastError(PDB *ppdb, OUT char szError[cbErrMax]);
PDBAPI(INTV)   PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI(IMPV)   PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI(char*)  PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI(SIG)    PDBQuerySignature(PDB* ppdb);
PDBAPI(BOOL)   PDBQuerySignature2(PDB* ppdb, PSIG70 psig70);
PDBAPI(AGE)    PDBQueryAge(PDB* ppdb);
PDBAPI(BOOL)   PDBCreateDBI(PDB* ppdb, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenDBIEx(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn);
PDBAPI(BOOL)   PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenTpi(PDB* ppdb, const char* szMode, OUT TPI** pptpi);
PDBAPI(BOOL)   PDBCommit(PDB* ppdb);
PDBAPI(BOOL)   PDBClose(PDB* ppdb);
PDBAPI(BOOL)   PDBOpenStream(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
PDBAPI(BOOL)   PDBCopyTo(PDB *ppdb, const char *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBCopyToW(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBfIsSZPDB(PDB *ppdb);

PDBAPI(INTV)   DBIQueryInterfaceVersion(DBI* pdbi);
PDBAPI(IMPV)   DBIQueryImplementationVersion(DBI* pdbi);
PDBAPI(BOOL)   DBIOpenMod(DBI* pdbi, const char* szModule, const char* szFile, OUT Mod** ppmod);
PDBAPI(BOOL)   DBIDeleteMod(DBI* pdbi, const char* szModule);
PDBAPI(BOOL)   DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI(BOOL)   DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIAddSec(DBI* pdbi, USHORT isect, USHORT flags, long off, long cb);
PDBAPI(BOOL)   DBIAddPublic(DBI* pdbi, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb);
PDBAPI(BOOL)   DBIQuerySecMap(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQueryFileInfo(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQuerySupportsEC(DBI* pdbi);
PDBAPI(void)   DBIDumpMods(DBI* pdbi);
PDBAPI(void)   DBIDumpSecContribs(DBI* pdbi);
PDBAPI(void)   DBIDumpSecMap(DBI* pdbi);
PDBAPI(BOOL)   DBIClose(DBI* pdbi);
PDBAPI(BOOL)   DBIAddThunkMap(DBI* pdbi, long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                              struct SO* psoSectMap, unsigned nSects, USHORT isectThunkTable, long offThunkTable);
PDBAPI(BOOL)   DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI(BOOL)   DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI(BOOL)   DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI(BOOL)   DBIQueryNextItsm(DBI* pdbi, ITSM itsm, OUT ITSM *inext );
PDBAPI(BOOL)   DBIQueryLazyTypes(DBI* pdbi);
PDBAPI(BOOL)   DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI(BOOL)   DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI(BOOL)   DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);
PDBAPI(BOOL)   DBIAddLinkInfo(DBI* pdbi, IN PLinkInfo);
PDBAPI(BOOL)   DBIQueryLinkInfo(DBI* pdbi, PLinkInfo, IN OUT long * pcb);

PDBAPI(INTV)   ModQueryInterfaceVersion(Mod* pmod);
PDBAPI(IMPV)   ModQueryImplementationVersion(Mod* pmod);
PDBAPI(BOOL)   ModAddTypes(Mod* pmod, BYTE* pbTypes, long cb);
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb);
PDBAPI(BOOL)   ModAddPublic(Mod* pmod, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   ModAddLines(Mod* pmod, const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                           USHORT lineStart, BYTE* pbCoff, long cbCoff);
PDBAPI(BOOL)   ModAddSecContrib(Mod * pmod, USHORT isect, long off, long cb, ULONG dwCharacteristics);
PDBAPI(BOOL)   ModQueryCBName(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySymbols(Mod* pmod, BYTE* pbSym, long* pcb);
PDBAPI(BOOL)   ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb);
PDBAPI(BOOL)   ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI(BOOL)   ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI(BOOL)   ModQuerySecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryFirstCodeSecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryImod(Mod* pmod, OUT USHORT* pimod);
PDBAPI(BOOL)   ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI(BOOL)   ModClose(Mod* pmod);
PDBAPI(BOOL)   ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySrcFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQueryPdbFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySupportsEC(Mod* pmod);
PDBAPI(BOOL)   ModQueryTpi(Mod* pmod, OUT TPI** pptpi);
PDBAPI(BOOL)   ModReplaceLines(Mod* pmod, BYTE* pbLines, long cb);

PDBAPI(INTV)   TypesQueryInterfaceVersion(TPI* ptpi);
PDBAPI(IMPV)   TypesQueryImplementationVersion(TPI* ptpi);
// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)   TypesQueryTiForCVRecordEx(TPI* ptpi, BYTE* pb, OUT TI* pti);
PDBAPI(BOOL)   TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE* pb, IN OUT long* pcb);
PDBAPI(BOOL)   TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE** ppb);
PDBAPI(TI)     TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)     TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(long)   TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)   TypesClose(TPI* ptpi);
PDBAPI(BOOL)   TypesCommit(TPI* ptpi);
PDBAPI(BOOL)   TypesQueryTiForUDTEx(TPI* ptpi, LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)   TypesSupportQueryTiForUDT(TPI*);
PDBAPI(BOOL)   TypesfIs16bitTypePool(TPI*);
// Map all old ones to new ones for new compilands.
#define TypesQueryTiForCVRecord     TypesQueryTiForCVRecordEx
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx
#define TypesQueryTiForUDT          TypesQueryTiForUDTEx
PDBAPI(BOOL)    TypesAreTypesEqual( TPI* ptpi, TI ti1, TI ti2 );
PDBAPI(BOOL)    TypesIsTypeServed( TPI* ptpi, TI ti );

PDBAPI(BYTE*)  GSINextSym (GSI* pgsi, BYTE* pbSym);
PDBAPI(BYTE*)  GSIHashSym (GSI* pgsi, const char* szName, BYTE* pbSym);
PDBAPI(BYTE*)  GSINearestSym (GSI* pgsi, USHORT isect, long off,OUT long* pdisp);//currently only supported for publics
PDBAPI(BOOL)   GSIClose(GSI* pgsi);
PDBAPI(unsigned long)   GSIOffForSym( GSI* pgsi, BYTE* pbSym );
PDBAPI(BYTE*)   GSISymForOff( GSI* pgsi, unsigned long off );

PDBAPI(long)   StreamQueryCb(Stream* pstream);
PDBAPI(BOOL)   StreamRead(Stream* pstream, long off, void* pvBuf, long* pcbBuf);
PDBAPI(BOOL)   StreamWrite(Stream* pstream, long off, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamReplace(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamAppend(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamDelete(Stream* pstream);
PDBAPI(BOOL)   StreamTruncate(Stream* pstream, long cb);
PDBAPI(BOOL)   StreamRelease(Stream* pstream);

PDBAPI(BOOL)   StreamImageOpen(Stream* pstream, long cb, OUT StreamImage** ppsi);
PDBAPI(void*)  StreamImageBase(StreamImage* psi);
PDBAPI(long)   StreamImageSize(StreamImage* psi);
PDBAPI(BOOL)   StreamImageNoteRead(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageNoteWrite(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageWriteBack(StreamImage* psi);
PDBAPI(BOOL)   StreamImageRelease(StreamImage* psi);

PDBAPI(BOOL)   NameMapOpen(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
PDBAPI(BOOL)   NameMapClose(NameMap* pnm);
PDBAPI(BOOL)   NameMapReinitialize(NameMap* pnm);
PDBAPI(BOOL)   NameMapGetNi(NameMap* pnm, const char* sz, OUT NI* pni);
PDBAPI(BOOL)   NameMapGetName(NameMap* pnm, NI ni, OUT const char** psz);
PDBAPI(BOOL)   NameMapGetEnumNameMap(NameMap* pnm, OUT Enum** ppenum);
PDBAPI(BOOL)   NameMapCommit(NameMap* pnm);

PDBAPI(void)   EnumNameMapRelease(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapReset(EnumNameMap* penum);
PDBAPI(BOOL)   EnumNameMapNext(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapGet(EnumNameMap* penum, OUT const char** psz, OUT NI* pni);

PDBAPI(void)   EnumContribRelease(EnumContrib* penum);
PDBAPI(void)   EnumContribReset(EnumContrib* penum);
PDBAPI(BOOL)   EnumContribNext(EnumContrib* penum);
PDBAPI(void)   EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(void)   EnumContribGetCrcs(EnumContrib* penum, OUT DWORD* pcrcData, OUT DWORD* pcrcReloc);
PDBAPI(BOOL)   EnumContribfUpdate(EnumContrib* penum, IN long off, IN long cb);

PDBAPI(SIG)    SigForPbCb(BYTE* pb, size_t cb, SIG sig);
PDBAPI(void)   TruncStFromSz(char *stDst, const char *szSrc, size_t cbSrc);

PDBAPI(BOOL)   DbgClose(Dbg *pdbg);
PDBAPI(long)   DbgQuerySize(Dbg *pdbg);
PDBAPI(void)   DbgReset(Dbg *pdbg);
PDBAPI(BOOL)   DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI(BOOL)   DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI(BOOL)   DbgFind(Dbg *pdbg, IN OUT void *pelt);
PDBAPI(BOOL)   DbgClear(Dbg *pdbg);
PDBAPI(BOOL)   DbgAppend(Dbg *pdbg, ULONG celt, const void *rgelt);
PDBAPI(BOOL)   DbgReplaceNext(Dbg *pdbg, ULONG celt, const void *rgelt);

#if __cplusplus
};
#endif

struct SO {
    long off;
    USHORT isect;
    unsigned short pad;
};

#ifndef cbNil
#define cbNil   ((long)-1)
#endif
#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((USHORT)(-1))

#define pdbWrite                "w"
#define pdbRead                 "r"
#define pdbGetTiOnly            "i"
#define pdbGetRecordsOnly       "c"
#define pdbFullBuild            "f"
#define pdbTypeAppend           "a"
#define pdbRepro                "z"

#endif // __PDB_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\matchsym\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\cvtodbg\cvtodbg.cpp ===
//
// cvtodbg.cpp
//
// Takes a PE file and a file containing CV info, and jams the CV info
// into the PE file (trashing it). However, The Jammed PE File when 
// splitsym'ed gives a dbg file, which can be used for debugging. 
// 
//
#undef UNICODE

#include "windows.h"
#include "imagehlp.h"
#include "stdio.h"
#include "stdlib.h"
////////////////////////////////////////
//
// Data
//
char    szImageName[MAX_PATH];
char    szCVName[MAX_PATH];
char    szPdbName[MAX_PATH];
char    szPdbCurrentPath[MAX_PATH];
HANDLE  hFile           = INVALID_HANDLE_VALUE;
HANDLE  hMappedFile     = INVALID_HANDLE_VALUE;
LPVOID  pvImageBase     = NULL;

BOOL    fVerbose        = FALSE;
BOOL    fForce 			= FALSE;

typedef struct NB10I                   // NB10 debug info
    {
    DWORD   nb10;                      // NB10
    DWORD   off;                       // offset, always 0
    DWORD   sig;
    DWORD   age;
    } NB10I;

typedef struct cvinfo
    {
    NB10I nb10;
    char rgb[0x200 - sizeof(NB10I)];
    } CVINFO;


////////////////////////////////////////
//
// Forward declarations
// 
BOOL    ParseArgs(int argc, WCHAR* argv[]);
void    UpdateCodeViewInfo();
void    Usage();
void    Message(const char* szFormat, ...);
void    Error(const char *sz, ...);
void    ErrorThrow(DWORD, const char *sz, ...);
void    Throw(DWORD);
void    MapImage();
void    UnmapImage(BOOL fTouch);
BOOL    DebugDirectoryIsUseful(LPVOID, ULONG);
void    RecalculateChecksum();
ULONG   FileSize(HANDLE);


class FileMapping {
public:
    FileMapping()
        : hFile(NULL), hMapping(NULL), pView(NULL)
    {
    }

    ~FileMapping()
    {
        Cleanup();
    }

    void Cleanup()
    {
        if (pView != NULL)
            UnmapViewOfFile(pView);
        if (hMapping != NULL)
            CloseHandle(hMapping);
        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
    }

    bool Open(LPCTSTR szFile)
    {
        hFile = CreateFile(szFile,
                           GENERIC_READ,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (hFile != INVALID_HANDLE_VALUE) {
            hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
            if (hMapping != NULL) {
                pView = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
                return true;
            }
        }

        Cleanup();
        return false;
    }

    PVOID GetDataPtr()
    {
        return pView;
    }

    DWORD GetSize()
    {
        return GetFileSize(hFile, NULL);
    }

    bool IsValid()
    {
        return (pView != NULL);
    }
    
private:
    HANDLE hFile;
    HANDLE hMapping;
    PVOID pView;
};



////////////////////////////////////////
//
// Code
//
void __cdecl wmain(int argc, WCHAR* argv[])
// Main entry point
//
     {
    szPdbName[0] = 0;
    szPdbCurrentPath[0] = 0;
    if (ParseArgs(argc, argv))
        {
        __try
            {
            UpdateCodeViewInfo();
            }
        __except(EXCEPTION_EXECUTE_HANDLER)
            {
            // nothing, just don't propagate it higher to the user
            }
        }
    }


// find the code view info; 
// if new info fits in old space, rewrite; else append new cv record and fix up 
// debug directory to point to the new record; append cv info to file.
void UpdateCodeViewInfo()
    {
    PIMAGE_NT_HEADERS pntHeaders;
    ULONG cbWritten;

    MapImage();

    FileMapping cvMapping;
    if (!cvMapping.Open(szCVName))
        ErrorThrow(666, "Couldn't open CV file");
    
    pntHeaders = ImageNtHeader(pvImageBase);
    if (pntHeaders)
        {
        if (pntHeaders->OptionalHeader.MajorLinkerVersion >= 3 ||
            pntHeaders->OptionalHeader.MinorLinkerVersion >= 5)
            {
            // make it non vc generated image, we are trashing the binary anyway
            if ( pntHeaders->OptionalHeader.MajorLinkerVersion > 5)
                pntHeaders->OptionalHeader.MajorLinkerVersion = 5;

            // put dbg info back in if its already stripped.
            if (pntHeaders->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
                pntHeaders->FileHeader.Characteristics ^= IMAGE_FILE_DEBUG_STRIPPED;
            
            ULONG ibFileCvStart = FileSize(hFile);
            SetFilePointer(hFile, 0, NULL, FILE_END);

            while (ibFileCvStart & 7)                       // Align file length to 8-bytes. Slow, but clearly 
                {                                           // works! And for 7 bytes, who cares.
                BYTE zero = 0;
                WriteFile(hFile, &zero, 1, &cbWritten, NULL);
                ibFileCvStart++;
                }

            // Write out the CV info.
            WriteFile(hFile, cvMapping.GetDataPtr(), cvMapping.GetSize(), &cbWritten, NULL);
            
            // Make up a debug directory
            IMAGE_DEBUG_DIRECTORY dbgdirs[2];

            dbgdirs[0].Characteristics = pntHeaders->FileHeader.Characteristics;
            dbgdirs[0].TimeDateStamp = pntHeaders->FileHeader.TimeDateStamp;
            dbgdirs[0].MajorVersion = 0;
            dbgdirs[0].MinorVersion = 0;
            dbgdirs[0].Type = IMAGE_DEBUG_TYPE_MISC;
            dbgdirs[0].SizeOfData = 0;
            dbgdirs[0].AddressOfRawData = ibFileCvStart;
            dbgdirs[0].PointerToRawData = ibFileCvStart;

            dbgdirs[1].Characteristics = pntHeaders->FileHeader.Characteristics;
            dbgdirs[1].TimeDateStamp = pntHeaders->FileHeader.TimeDateStamp;
            dbgdirs[1].MajorVersion = 0;
            dbgdirs[1].MinorVersion = 0;
            dbgdirs[1].Type = IMAGE_DEBUG_TYPE_CODEVIEW;
            dbgdirs[1].SizeOfData = cvMapping.GetSize();
            dbgdirs[1].AddressOfRawData = ibFileCvStart;
            dbgdirs[1].PointerToRawData = ibFileCvStart;

            // Find the beginning of the first section and stick the debug directory there
            // (did we mention we're trashing the file?)

            IMAGE_SECTION_HEADER* pFirstSection = IMAGE_FIRST_SECTION(pntHeaders);

            memcpy((PBYTE)((DWORD)pvImageBase + pFirstSection->PointerToRawData), &dbgdirs, sizeof(dbgdirs));

            pntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress = pFirstSection->VirtualAddress;
            pntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size = sizeof(dbgdirs);

            }
        }
    UnmapImage(TRUE);
    }



void MapImage()
// Map the image into memory for read-write. Caller MUST call 
// Unmapimage to clean up even on failure.
    {
    if (fForce)
        SetFileAttributesA(szImageName, FILE_ATTRIBUTE_NORMAL);

    hFile = CreateFileA( szImageName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

    if (hFile == INVALID_HANDLE_VALUE) 
        {
        ErrorThrow(GetLastError(), "unable to open '%s'\n", szImageName);
        }


    hMappedFile = CreateFileMapping( hFile,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     0,
                                     NULL
                                   );
    if (!hMappedFile) 
        {
        ErrorThrow(GetLastError(), "un`able to create file mapping for '%s'\n", szImageName);
        }

    pvImageBase = MapViewOfFile(hMappedFile, FILE_MAP_WRITE, 0, 0, 0);

    if (!pvImageBase)
        {
        ErrorThrow(GetLastError(), "unable to map view of '%s'\n", szImageName);
        }
    
    }


void UnmapImage(BOOL fTouch)
// Clean up whatever MapImage does
    {
    if (pvImageBase)
        {
        FlushViewOfFile(pvImageBase, 0);
        UnmapViewOfFile(pvImageBase);
        pvImageBase = NULL;
        }

    if (hMappedFile != INVALID_HANDLE_VALUE)
        {
        CloseHandle(hMappedFile);
        hMappedFile = INVALID_HANDLE_VALUE;
        }

    if (hFile != INVALID_HANDLE_VALUE)
        {
        if (fTouch)
            {
            TouchFileTimes(hFile, NULL);
            }
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        }
    }


BOOL ParseArgs(int argc, WCHAR* argv[])
// Parse the arguments and set our flags appropriately
    {
    WCHAR* wszString;
    WCHAR c;

    szImageName[0] = L'\0';
    szCVName[0] = L'\0';

    while (--argc) 
        {
        wszString = *++argv;
        if (*wszString == L'/' || *wszString == L'-') 
            {
            while ((c = *++wszString) != L'\0')
                {
                switch (towupper( c )) 
                    {
                case L'?':
                    Usage();
                    return FALSE;

                case L'V':
                    fVerbose = TRUE;
                    break;

                default:
                    Error("invalid switch - /%c\n", c );
                    Usage();
                    return FALSE;
                    }
                }
            }
        else
            {
            if (szImageName[0] == L'\0')
                {
                wcstombs(szImageName, wszString, MAX_PATH);
                }
            else if (szCVName[0] == L'\0') 
                {
                wcstombs(szCVName, wszString, MAX_PATH);
                }
            else
                {
                Error("too many files specified\n");
                Usage();
                return FALSE;
                }
            }
        }

    if (szImageName==NULL)
        {
        Error("no image name specified\n");
        Usage();
        return FALSE;
        }

    if (szCVName==NULL)
        {
        Error("no CV filename specified\n");
        Usage();
        return FALSE;
        }

    return TRUE;
    }


void Usage()
    {
    fprintf(stderr, "Usage: cvtodbg [options] imageName cvFile\n"
            "              [-?] display this message\n"
            "              [-f] overwrite readonly files\n");
    }

void Message(const char* szFormat, ...)
    {
    va_list va;
    va_start(va, szFormat);
    fprintf (stdout, "resetpdb: ");
    vfprintf(stdout, szFormat, va);
    va_end(va);
    }

void Error(const char* szFormat, ...)
    {
    va_list va;
    va_start(va, szFormat);
    fprintf (stderr, "resetpdb: error: ");
    vfprintf(stderr, szFormat, va);
    va_end(va);
    }

void ErrorThrow(DWORD dw, const char* szFormat, ...)
    {
    va_list va;
    va_start(va, szFormat);
    fprintf (stderr, "resetpdb: error: ");
    vfprintf(stderr, szFormat, va);
    va_end(va);
    Throw(dw);
    }

void Throw(DWORD dw)
    {
    RaiseException(dw, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

BOOL DebugDirectoryIsUseful(LPVOID Pointer, ULONG Size) 
    {
    return (Pointer != NULL) &&                          
        (Size >= sizeof(IMAGE_DEBUG_DIRECTORY)) &&    
        ((Size % sizeof(IMAGE_DEBUG_DIRECTORY)) == 0);
    }

ULONG FileSize(HANDLE h)
// Answer the size of the file with this handle
    {
    BY_HANDLE_FILE_INFORMATION info;
    GetFileInformationByHandle(h, &info);
    return info.nFileSizeLow;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\include\cv.h ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    cv.h

Abstract:

    This file contains all of the type definitions for accessing
    CODEVIEW data.

Environment:

    Win32, User Mode

--*/
#include <cvinfo.h>
#include <cvexefmt.h>

// from types.h

typedef USHORT      SEGMENT;    // 32-bit compiler doesn't like "_segment"
typedef ULONG       UOFF32;
typedef USHORT      UOFF16;
typedef LONG        OFF32;
typedef SHORT       OFF16;

#if defined (ADDR_16)
    // we are operating as a 16:16 evaluator only
    // the address packet will be defined as an offset and a 16 bit filler
    typedef OFF16       OFFSET;
    typedef UOFF16      UOFFSET;
#else
    typedef OFF32       OFFSET;
    typedef UOFF32      UOFFSET;
#endif // ADDR_16

typedef UOFFSET FAR *LPUOFFSET;

// Global Segment Info table
typedef struct _sgf {
    unsigned short      fRead   :1;
    unsigned short      fWrite  :1;
    unsigned short      fExecute:1;
    unsigned short      f32Bit  :1;
    unsigned short      res1    :4;
    unsigned short      fSel    :1;
    unsigned short      fAbs    :1;
    unsigned short      res2    :2;
    unsigned short      fGroup  :1;
    unsigned short      res3    :3;
} SGF;

typedef struct _sgi {
    SGF                 sgf;        // Segment flags
    unsigned short      iovl;       // Overlay number
    unsigned short      igr;        // Group index
    unsigned short      isgPhy;     // Physical segment index
    unsigned short      isegName;   // Index to segment name
    unsigned short      iclassName; // Index to segment class name
    unsigned long       doffseg;    // Starting offset inside physical segment
    unsigned long       cbSeg;      // Logical segment size
} SGI;

typedef struct _sgm {
    unsigned short      cSeg;       // number of segment descriptors
    unsigned short      cSegLog;    // number of logical segment descriptors
} SGM;

#define FileAlign(x)  ( ((x) + p->optrs.optHdr->FileAlignment - 1) &  \
                            ~(p->optrs.optHdr->FileAlignment - 1) )
#define SectionAlign(x) (((x) + p->optrs.optHdr->SectionAlignment - 1) &  \
                            ~(p->optrs.optHdr->SectionAlignment - 1) )

#define NextSym32(m)  ((DATASYM32 *) \
  (((DWORD)(m) + sizeof(DATASYM32) + \
    ((DATASYM32*)(m))->name[0] + 3) & ~3))

#define NextSym16(m)  ((DATASYM16 *) \
  (((DWORD)(m) + sizeof(DATASYM16) + \
    ((DATASYM16*)(m))->name[0] + 1) & ~1))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\include\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Version 5.0 (using 32-bit types)
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned short	_2BYTEPAD;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#define CV_SIGNATURE_RESERVED   3L  // All signatures from 3 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7       // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))




// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types


#define T_NOTYPE        0x0000      // uncharacterized type (no type)
#define T_ABS           0x0001      // absolute symbol
#define T_SEGMENT       0x0002      // segment type
#define T_VOID          0x0003      // void
#define T_PVOID         0x0103      // near pointer to void
#define T_PFVOID        0x0203      // far pointer to void
#define T_PHVOID        0x0303      // huge pointer to void
#define T_32PVOID       0x0403      // 16:32 near pointer to void
#define T_32PFVOID      0x0503      // 16:32 far pointer to void
#define T_64PVOID       0x0603      // 64 bit pointer to void
#define T_CURRENCY      0x0004      // BASIC 8 byte currency value
#define T_NBASICSTR     0x0005      // Near BASIC string
#define T_FBASICSTR     0x0006      // Far BASIC string
#define T_NOTTRANS      0x0007      // type not translated by cvpack
#define T_BIT           0x0060      // bit
#define T_PASCHAR       0x0061      // Pascal CHAR



//      Character types


#define T_CHAR          0x0010      // 8 bit signed
#define T_UCHAR         0x0020      // 8 bit unsigned
#define T_PCHAR         0x0110      // near pointer to 8 bit signed
#define T_PUCHAR        0x0120      // near pointer to 8 bit unsigned
#define T_PFCHAR        0x0210      // far pointer to 8 bit signed
#define T_PFUCHAR       0x0220      // far pointer to 8 bit unsigned
#define T_PHCHAR        0x0310      // huge pointer to 8 bit signed
#define T_PHUCHAR       0x0320      // huge pointer to 8 bit unsigned
#define T_32PCHAR       0x0410      // 16:32 near pointer to 8 bit signed
#define T_32PUCHAR      0x0420      // 16:32 near pointer to 8 bit unsigned
#define T_32PFCHAR      0x0510      // 16:32 far pointer to 8 bit signed
#define T_32PFUCHAR     0x0520      // 16:32 far pointer to 8 bit unsigned
#define T_64PCHAR       0X0610      // 64 bit pointer to 8 bit signed
#define T_64PUCHAR      0X0620      // 64 bit pointer to 8 bit unsigned




//      really a character types

#define T_RCHAR         0x0070      // really a char
#define T_PRCHAR        0x0170      // 16:16 near pointer to a real char
#define T_PFRCHAR       0x0270      // 16:16 far pointer to a real char
#define T_PHRCHAR       0x0370      // 16:16 huge pointer to a real char
#define T_32PRCHAR      0x0470      // 16:32 near pointer to a real char
#define T_32PFRCHAR     0x0570      // 16:32 far pointer to a real char
#define T_64PRCHAR      0x0670      // 64 bit pointer to a real char



//      really a wide character types

#define T_WCHAR         0x0071      // wide char
#define T_PWCHAR        0x0171      // 16:16 near pointer to a wide char
#define T_PFWCHAR       0x0271      // 16:16 far pointer to a wide char
#define T_PHWCHAR       0x0371      // 16:16 huge pointer to a wide char
#define T_32PWCHAR      0x0471      // 16:32 near pointer to a wide char
#define T_32PFWCHAR     0x0571      // 16:32 far pointer to a wide char
#define T_64PWCHAR      0x0671      // 64 bit pointer to a wide char


//      8 bit int types


#define T_INT1          0x0068      // 8 bit signed int
#define T_UINT1         0x0069      // 8 bit unsigned int
#define T_PINT1         0x0168      // near pointer to 8 bit signed int
#define T_PUINT1        0x0169      // near pointer to 8 bit unsigned int
#define T_PFINT1        0x0268      // far pointer to 8 bit signed int
#define T_PFUINT1       0x0269      // far pointer to 8 bit unsigned int
#define T_PHINT1        0x0368      // huge pointer to 8 bit signed int
#define T_PHUINT1       0x0369      // huge pointer to 8 bit unsigned int

#define T_32PINT1       0x0468      // 16:32 near pointer to 8 bit signed int
#define T_32PUINT1      0x0469      // 16:32 near pointer to 8 bit unsigned int
#define T_32PFINT1      0x0568      // 16:32 far pointer to 8 bit signed int
#define T_32PFUINT1     0x0569      // 16:32 far pointer to 8 bit unsigned int
#define T_64PINT1       0x0668      // 64 bit pointer to 8 bit signed int
#define T_64PUINT1      0x0669      // 64 bit pointer to 8 bit unsigned int


//      16 bit short types


#define T_SHORT         0x0011      // 16 bit signed
#define T_USHORT        0x0021      // 16 bit unsigned
#define T_PSHORT        0x0111      // near pointer to 16 bit signed
#define T_PUSHORT       0x0121      // near pointer to 16 bit unsigned
#define T_PFSHORT       0x0211      // far pointer to 16 bit signed
#define T_PFUSHORT      0x0221      // far pointer to 16 bit unsigned
#define T_PHSHORT       0x0311      // huge pointer to 16 bit signed
#define T_PHUSHORT      0x0321      // huge pointer to 16 bit unsigned

#define T_32PSHORT      0x0411      // 16:32 near pointer to 16 bit signed
#define T_32PUSHORT     0x0421      // 16:32 near pointer to 16 bit unsigned
#define T_32PFSHORT     0x0511      // 16:32 far pointer to 16 bit signed
#define T_32PFUSHORT    0x0521      // 16:32 far pointer to 16 bit unsigned
#define T_64PSHORT      0x0611      // 64 bit pointer to 16 bit signed
#define T_64PUSHORT     0x0621      // 64 bit pointer to 16 bit unsigned




//      16 bit int types


#define T_INT2          0x0072      // 16 bit signed int
#define T_UINT2         0x0073      // 16 bit unsigned int
#define T_PINT2         0x0172      // near pointer to 16 bit signed int
#define T_PUINT2        0x0173      // near pointer to 16 bit unsigned int
#define T_PFINT2        0x0272      // far pointer to 16 bit signed int
#define T_PFUINT2       0x0273      // far pointer to 16 bit unsigned int
#define T_PHINT2        0x0372      // huge pointer to 16 bit signed int
#define T_PHUINT2       0x0373      // huge pointer to 16 bit unsigned int

#define T_32PINT2       0x0472      // 16:32 near pointer to 16 bit signed int
#define T_32PUINT2      0x0473      // 16:32 near pointer to 16 bit unsigned int
#define T_32PFINT2      0x0572      // 16:32 far pointer to 16 bit signed int
#define T_32PFUINT2     0x0573      // 16:32 far pointer to 16 bit unsigned int
#define T_64PINT2       0x0672      // 64 bit pointer to 16 bit signed int
#define T_64PUINT2      0x0673      // 64 bit pointer to 16 bit unsigned int




//      32 bit long types


#define T_LONG          0x0012      // 32 bit signed
#define T_ULONG         0x0022      // 32 bit unsigned
#define T_PLONG         0x0112      // near pointer to 32 bit signed
#define T_PULONG        0x0122      // near pointer to 32 bit unsigned
#define T_PFLONG        0x0212      // far pointer to 32 bit signed
#define T_PFULONG       0x0222      // far pointer to 32 bit unsigned
#define T_PHLONG        0x0312      // huge pointer to 32 bit signed
#define T_PHULONG       0x0322      // huge pointer to 32 bit unsigned

#define T_32PLONG       0x0412      // 16:32 near pointer to 32 bit signed
#define T_32PULONG      0x0422      // 16:32 near pointer to 32 bit unsigned
#define T_32PFLONG      0x0512      // 16:32 far pointer to 32 bit signed
#define T_32PFULONG     0x0522      // 16:32 far pointer to 32 bit unsigned
#define T_64PLONG       0x0612      // 64 bit pointer to 32 bit signed
#define T_64PULONG      0x0622      // 64 bit pointer to 32 bit unsigned




//      32 bit int types


#define T_INT4          0x0074      // 32 bit signed int
#define T_UINT4         0x0075      // 32 bit unsigned int
#define T_PINT4         0x0174      // near pointer to 32 bit signed int
#define T_PUINT4        0x0175      // near pointer to 32 bit unsigned int
#define T_PFINT4        0x0274      // far pointer to 32 bit signed int
#define T_PFUINT4       0x0275      // far pointer to 32 bit unsigned int
#define T_PHINT4        0x0374      // huge pointer to 32 bit signed int
#define T_PHUINT4       0x0375      // huge pointer to 32 bit unsigned int

#define T_32PINT4       0x0474      // 16:32 near pointer to 32 bit signed int
#define T_32PUINT4      0x0475      // 16:32 near pointer to 32 bit unsigned int
#define T_32PFINT4      0x0574      // 16:32 far pointer to 32 bit signed int
#define T_32PFUINT4     0x0575      // 16:32 far pointer to 32 bit unsigned int
#define T_64PINT4       0x0674      // 64 bit pointer to 32 bit signed int
#define T_64PUINT4      0x0675      // 64 bit pointer to 32 bit unsigned int




//      64 bit quad types


#define T_QUAD          0x0013      // 64 bit signed
#define T_UQUAD         0x0023      // 64 bit unsigned
#define T_PQUAD         0x0113      // near pointer to 64 bit signed
#define T_PUQUAD        0x0123      // near pointer to 64 bit unsigned
#define T_PFQUAD        0x0213      // far pointer to 64 bit signed
#define T_PFUQUAD       0x0223      // far pointer to 64 bit unsigned
#define T_PHQUAD        0x0313      // huge pointer to 64 bit signed
#define T_PHUQUAD       0x0323      // huge pointer to 64 bit unsigned
#define T_32PQUAD       0x0413      // 16:32 near pointer to 64 bit signed
#define T_32PUQUAD      0x0423      // 16:32 near pointer to 64 bit unsigned
#define T_32PFQUAD      0x0513      // 16:32 far pointer to 64 bit signed
#define T_32PFUQUAD     0x0523      // 16:32 far pointer to 64 bit unsigned
#define T_64PQUAD       0x0613      // 64 bit pointer to 64 bit signed
#define T_64PUQUAD      0x0623      // 64 bit pointer to 64 bit unsigned



//      64 bit int types


#define T_INT8          0x0076      // 64 bit signed int
#define T_UINT8         0x0077      // 64 bit unsigned int
#define T_PINT8         0x0176      // near pointer to 64 bit signed int
#define T_PUINT8        0x0177      // near pointer to 64 bit unsigned int
#define T_PFINT8        0x0276      // far pointer to 64 bit signed int
#define T_PFUINT8       0x0277      // far pointer to 64 bit unsigned int
#define T_PHINT8        0x0376      // huge pointer to 64 bit signed int
#define T_PHUINT8       0x0377      // huge pointer to 64 bit unsigned int

#define T_32PINT8       0x0476      // 16:32 near pointer to 64 bit signed int
#define T_32PUINT8      0x0477      // 16:32 near pointer to 64 bit unsigned int
#define T_32PFINT8      0x0576      // 16:32 far pointer to 64 bit signed int
#define T_32PFUINT8     0x0577      // 16:32 far pointer to 64 bit unsigned int
#define T_64PINT8       0x0676      // 64 bit pointer to 64 bit signed int
#define T_64PUINT8      0x0677      // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types


#define T_OCT           0x0014      // 128 bit signed
#define T_UOCT          0x0024      // 128 bit unsigned
#define T_POCT          0x0114      // near pointer to 128 bit signed
#define T_PUOCT         0x0124      // near pointer to 128 bit unsigned
#define T_PFOCT         0x0214      // far pointer to 128 bit signed
#define T_PFUOCT        0x0224      // far pointer to 128 bit unsigned
#define T_PHOCT         0x0314      // huge pointer to 128 bit signed
#define T_PHUOCT        0x0324      // huge pointer to 128 bit unsigned

#define T_32POCT        0x0414      // 16:32 near pointer to 128 bit signed
#define T_32PUOCT       0x0424      // 16:32 near pointer to 128 bit unsigned
#define T_32PFOCT       0x0514      // 16:32 far pointer to 128 bit signed
#define T_32PFUOCT      0x0524      // 16:32 far pointer to 128 bit unsigned
#define T_64POCT        0x0614      // 64 bit pointer to 128 bit signed
#define T_64PUOCT       0x0624      // 64 bit pointer to 128 bit unsigned

//      128 bit int types


#define T_INT16         0x0078      // 128 bit signed int
#define T_UINT16        0x0079      // 128 bit unsigned int
#define T_PINT16        0x0178      // near pointer to 128 bit signed int
#define T_PUINT16       0x0179      // near pointer to 128 bit unsigned int
#define T_PFINT16       0x0278      // far pointer to 128 bit signed int
#define T_PFUINT16      0x0279      // far pointer to 128 bit unsigned int
#define T_PHINT16       0x0378      // huge pointer to 128 bit signed int
#define T_PHUINT16      0x0379      // huge pointer to 128 bit unsigned int

#define T_32PINT16      0x0478      // 16:32 near pointer to 128 bit signed int
#define T_32PUINT16     0x0479      // 16:32 near pointer to 128 bit unsigned int
#define T_32PFINT16     0x0578      // 16:32 far pointer to 128 bit signed int
#define T_32PFUINT16    0x0579      // 16:32 far pointer to 128 bit unsigned int
#define T_64PINT16      0x0678      // 64 bit pointer to 128 bit signed int
#define T_64PUINT16     0x0679      // 64 bit pointer to 128 bit unsigned int





//      32 bit real types


#define T_REAL32        0x0040      // 32 bit real
#define T_PREAL32       0x0140      // near pointer to 32 bit real
#define T_PFREAL32      0x0240      // far pointer to 32 bit real
#define T_PHREAL32      0x0340      // huge pointer to 32 bit real
#define T_32PREAL32     0x0440      // 16:32 near pointer to 32 bit real
#define T_32PFREAL32    0x0540      // 16:32 far pointer to 32 bit real
#define T_64PREAL32     0x0640      // 64 bit pointer to 32 bit real



//      48 bit real types


#define T_REAL48        0x0044      // 48 bit real
#define T_PREAL48       0x0144      // near pointer to 48 bit real
#define T_PFREAL48      0x0244      // far pointer to 48 bit real
#define T_PHREAL48      0x0344      // huge pointer to 48 bit real
#define T_32PREAL48     0x0444      // 16:32 near pointer to 48 bit real
#define T_32PFREAL48    0x0544      // 16:32 far pointer to 48 bit real
#define T_64PREAL48     0x0644      // 64 bit pointer to 48 bit real




//      64 bit real types


#define T_REAL64        0x0041      // 64 bit real
#define T_PREAL64       0x0141      // near pointer to 64 bit real
#define T_PFREAL64      0x0241      // far pointer to 64 bit real
#define T_PHREAL64      0x0341      // huge pointer to 64 bit real
#define T_32PREAL64     0x0441      // 16:32 near pointer to 64 bit real
#define T_32PFREAL64    0x0541      // 16:32 far pointer to 64 bit real
#define T_64PREAL64     0x0641      // 64 bit pointer to 64 bit real




//      80 bit real types


#define T_REAL80        0x0042      // 80 bit real
#define T_PREAL80       0x0142      // near pointer to 80 bit real
#define T_PFREAL80      0x0242      // far pointer to 80 bit real
#define T_PHREAL80      0x0342      // huge pointer to 80 bit real
#define T_32PREAL80     0x0442      // 16:32 near pointer to 80 bit real
#define T_32PFREAL80    0x0542      // 16:32 far pointer to 80 bit real
#define T_64PREAL80     0x0642      // 64 bit pointer to 80 bit real




//      128 bit real types


#define T_REAL128       0x0043      // 128 bit real
#define T_PREAL128      0x0143      // near pointer to 128 bit real
#define T_PFREAL128     0x0243      // far pointer to 128 bit real
#define T_PHREAL128     0x0343      // huge pointer to 128 bit real
#define T_32PREAL128    0x0443      // 16:32 near pointer to 128 bit real
#define T_32PFREAL128   0x0543      // 16:32 far pointer to 128 bit real
#define T_64PREAL128    0x0643      // 64 bit pointer to 128 bit real




//      32 bit complex types


#define T_CPLX32        0x0050      // 32 bit complex
#define T_PCPLX32       0x0150      // near pointer to 32 bit complex
#define T_PFCPLX32      0x0250      // far pointer to 32 bit complex
#define T_PHCPLX32      0x0350      // huge pointer to 32 bit complex
#define T_32PCPLX32     0x0450      // 16:32 near pointer to 32 bit complex
#define T_32PFCPLX32    0x0550      // 16:32 far pointer to 32 bit complex
#define T_64PCPLX32     0x0650      // 64 bit pointer to 32 bit complex




//      64 bit complex types


#define T_CPLX64        0x0051      // 64 bit complex
#define T_PCPLX64       0x0151      // near pointer to 64 bit complex
#define T_PFCPLX64      0x0251      // far pointer to 64 bit complex
#define T_PHCPLX64      0x0351      // huge pointer to 64 bit complex
#define T_32PCPLX64     0x0451      // 16:32 near pointer to 64 bit complex
#define T_32PFCPLX64    0x0551      // 16:32 far pointer to 64 bit complex
#define T_64PCPLX64     0x0651      // 64 bit pointer to 64 bit complex




//      80 bit complex types


#define T_CPLX80        0x0052      // 80 bit complex
#define T_PCPLX80       0x0152      // near pointer to 80 bit complex
#define T_PFCPLX80      0x0252      // far pointer to 80 bit complex
#define T_PHCPLX80      0x0352      // huge pointer to 80 bit complex
#define T_32PCPLX80     0x0452      // 16:32 near pointer to 80 bit complex
#define T_32PFCPLX80    0x0552      // 16:32 far pointer to 80 bit complex
#define T_64PCPLX80     0x0652      // 64 bit pointer to 80 bit complex




//      128 bit complex types


#define T_CPLX128       0x0053      // 128 bit complex
#define T_PCPLX128      0x0153      // near pointer to 128 bit complex
#define T_PFCPLX128     0x0253      // far pointer to 128 bit complex
#define T_PHCPLX128     0x0353      // huge pointer to 128 bit real
#define T_32PCPLX128    0x0453      // 16:32 near pointer to 128 bit complex
#define T_32PFCPLX128   0x0553      // 16:32 far pointer to 128 bit complex
#define T_64PCPLX128    0x0653      // 64 bit pointer to 128 bit complex




//      boolean types


#define T_BOOL08        0x0030      // 8 bit boolean
#define T_BOOL16        0x0031      // 16 bit boolean
#define T_BOOL32        0x0032      // 32 bit boolean
#define T_BOOL64        0x0033      // 64 bit boolean
#define T_PBOOL08       0x0130      // near pointer to  8 bit boolean
#define T_PBOOL16       0x0131      // near pointer to 16 bit boolean
#define T_PBOOL32       0x0132      // near pointer to 32 bit boolean
#define T_PBOOL64       0x0133      // near pointer to 64 bit boolean
#define T_PFBOOL08      0x0230      // far pointer to  8 bit boolean
#define T_PFBOOL16      0x0231      // far pointer to 16 bit boolean
#define T_PFBOOL32      0x0232      // far pointer to 32 bit boolean
#define T_PFBOOL64      0x0233      // far pointer to 64 bit boolean
#define T_PHBOOL08      0x0330      // huge pointer to  8 bit boolean
#define T_PHBOOL16      0x0331      // huge pointer to 16 bit boolean
#define T_PHBOOL32      0x0332      // huge pointer to 32 bit boolean
#define T_PHBOOL64      0x0333      // huge pointer to 64 bit boolean

#define T_32PBOOL08     0x0430      // 16:32 near pointer to 8 bit boolean
#define T_32PFBOOL08    0x0530      // 16:32 far pointer to 8 bit boolean
#define T_32PBOOL16     0x0431      // 16:32 near pointer to 18 bit boolean
#define T_32PFBOOL16    0x0531      // 16:32 far pointer to 16 bit boolean
#define T_32PBOOL32     0x0432      // 16:32 near pointer to 32 bit boolean
#define T_32PFBOOL32    0x0532      // 16:32 far pointer to 32 bit boolean
#define T_32PBOOL64     0x0433      // 16:32 near pointer to 64 bit boolean
#define T_32PFBOOL64    0x0533      // 16:32 far pointer to 64 bit boolean

#define T_64PBOOL08     0x0630      // 64 bit pointer to 8 bit boolean
#define T_64PBOOL16     0x0631      // 64 bit pointer to 18 bit boolean
#define T_64PBOOL32     0x0632      // 64 bit pointer to 32 bit boolean
#define T_64PBOOL64     0x0633      // 64 bit pointer to 64 bit boolean


#define T_NCVPTR        0x01f0      // CV Internal type for created near pointers
#define T_FCVPTR        0x02f0      // CV Internal type for created far pointers
#define T_HCVPTR        0x03f0      // CV Internal type for created huge pointers
#define T_32NCVPTR      0x04f0      // CV Internal type for created near 32-bit pointers
#define T_32FCVPTR      0x05f0      // CV Internal type for created far 32-bit pointers
#define T_64NCVPTR      0x06f0      // CV Internal type for created near 64-bit pointers

#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))


/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */



    // leaf indices starting records but referenced from symbol records

#define LF_MODIFIER_16t     0x0001
#define LF_POINTER_16t      0x0002
#define LF_ARRAY_16t        0x0003
#define LF_CLASS_16t        0x0004
#define LF_STRUCTURE_16t    0x0005
#define LF_UNION_16t        0x0006
#define LF_ENUM_16t         0x0007
#define LF_PROCEDURE_16t    0x0008
#define LF_MFUNCTION_16t    0x0009
#define LF_VTSHAPE          0x000a
#define LF_COBOL0_16t       0x000b
#define LF_COBOL1           0x000c
#define LF_BARRAY_16t       0x000d
#define LF_LABEL            0x000e
#define LF_NULL             0x000f
#define LF_NOTTRAN          0x0010
#define LF_DIMARRAY_16t     0x0011
#define LF_VFTPATH_16t      0x0012
#define LF_PRECOMP_16t      0x0013      // not referenced from symbol
#define LF_ENDPRECOMP       0x0014      // not referenced from symbol
#define LF_OEM_16t          0x0015      // oem definable type string
#define LF_TYPESERVER       0x0016      // not referenced from symbol

    // leaf indices starting records but referenced only from type records

#define LF_SKIP_16t         0x0200
#define LF_ARGLIST_16t      0x0201
#define LF_DEFARG_16t       0x0202
#define LF_LIST             0x0203
#define LF_FIELDLIST_16t    0x0204
#define LF_DERIVED_16t      0x0205
#define LF_BITFIELD_16t     0x0206
#define LF_METHODLIST_16t   0x0207
#define LF_DIMCONU_16t      0x0208
#define LF_DIMCONLU_16t     0x0209
#define LF_DIMVARU_16t      0x020a
#define LF_DIMVARLU_16t     0x020b
#define LF_REFSYM           0x020c
                            
#define LF_BCLASS_16t       0x0400
#define LF_VBCLASS_16t      0x0401
#define LF_IVBCLASS_16t     0x0402
#define LF_ENUMERATE        0x0403
#define LF_FRIENDFCN_16t    0x0404
#define LF_INDEX_16t        0x0405
#define LF_MEMBER_16t       0x0406
#define LF_STMEMBER_16t     0x0407
#define LF_METHOD_16t       0x0408
#define LF_NESTTYPE_16t     0x0409
#define LF_VFUNCTAB_16t     0x040a
#define LF_FRIENDCLS_16t    0x040b
#define LF_ONEMETHOD_16t    0x040c
#define LF_VFUNCOFF_16t     0x040d

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
#define LF_TI16_MAX         0x1000

#define LF_MODIFIER         0x1001
#define LF_POINTER          0x1002
#define LF_ARRAY            0x1003
#define LF_CLASS            0x1004
#define LF_STRUCTURE        0x1005
#define LF_UNION            0x1006
#define LF_ENUM             0x1007
#define LF_PROCEDURE        0x1008
#define LF_MFUNCTION        0x1009
#define LF_COBOL0           0x100a
#define LF_BARRAY           0x100b
#define LF_DIMARRAY         0x100c
#define LF_VFTPATH          0x100d
#define LF_PRECOMP          0x100e      // not referenced from symbol
#define LF_OEM              0x100f      // oem definable type string
                            
    // leaf indices starting records but referenced only from type records
                            
#define LF_SKIP             0x1200
#define LF_ARGLIST          0x1201
#define LF_DEFARG           0x1202
#define LF_FIELDLIST        0x1203
#define LF_DERIVED          0x1204
#define LF_BITFIELD         0x1205
#define LF_METHODLIST       0x1206
#define LF_DIMCONU          0x1207
#define LF_DIMCONLU         0x1208
#define LF_DIMVARU          0x1209
#define LF_DIMVARLU         0x120a
                            
#define LF_BCLASS           0x1400
#define LF_VBCLASS          0x1401
#define LF_IVBCLASS         0x1402
#define LF_FRIENDFCN        0x1403
#define LF_INDEX            0x1404
#define LF_MEMBER           0x1405
#define LF_STMEMBER         0x1406
#define LF_METHOD           0x1407
#define LF_NESTTYPE         0x1408
#define LF_VFUNCTAB         0x1409
#define LF_FRIENDCLS        0x140a
#define LF_ONEMETHOD        0x140b
#define LF_VFUNCOFF         0x140c
#define LF_NESTTYPEEX       0x140d
#define LF_MEMBERMODIFY     0x140e




#define LF_NUMERIC          0x8000
#define LF_CHAR             0x8000
#define LF_SHORT            0x8001
#define LF_USHORT           0x8002
#define LF_LONG             0x8003
#define LF_ULONG            0x8004
#define LF_REAL32           0x8005
#define LF_REAL64           0x8006
#define LF_REAL80           0x8007
#define LF_REAL128          0x8008
#define LF_QUADWORD         0x8009
#define LF_UQUADWORD        0x800a
#define LF_REAL48           0x800b
#define LF_COMPLEX32        0x800c
#define LF_COMPLEX64        0x800d
#define LF_COMPLEX80        0x800e
#define LF_COMPLEX128       0x800f
#define LF_VARSTRING        0x8010
                            
#define LF_OCTWORD          0x8017
#define LF_UOCTWORD         0x8018
                            
#define LF_PAD0             0xf0
#define LF_PAD1             0xf1
#define LF_PAD2             0xf2
#define LF_PAD3             0xf3
#define LF_PAD4             0xf4
#define LF_PAD5             0xf5
#define LF_PAD6             0xf6
#define LF_PAD7             0xf7
#define LF_PAD8             0xf8
#define LF_PAD9             0xf9
#define LF_PAD10            0xfa
#define LF_PAD11            0xfb
#define LF_PAD12            0xfc
#define LF_PAD13            0xfd
#define LF_PAD14            0xfe
#define LF_PAD15            0xff

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_RESERVED    = 0x10  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**		Notes on alignment
 *		Alignment of the fields in most of the type records is done on the 
 *		basis of the TYPTYPE record base.  That is why in most of the lf*
 *		records that the CV_typ_t (32-bit types) is located on what appears to
 *		be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *		records that are in a list (lfFieldList, lfMethodList), which are
 *		aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

	Record type			Change (f == field arrangement, p = padding added)
	----------------------------------------------------------------------
	lfModifer			f
	lfPointer			fp
	lfClass				f
	lfStructure			f
	lfUnion				f
	lfEnum				f
	lfVFTPath			p
    lfPreComp           p
	lfOEM				p
	lfArgList			p
	lfDerived			p
	mlMethod			p	(method list member)
	lfBitField			f
	lfDimCon			f
	lfDimVar			p
	lfIndex				p	(field list member)
	lfBClass			f	(field list member)
	lfVBClass			f	(field list member)
	lfFriendCls			p	(field list member)
	lfFriendFcn			p	(field list member)
	lfMember			f	(field list member)
	lfSTMember			f	(field list member)
	lfVFuncTab			p	(field list member)
	lfVFuncOff			p	(field list member)
	lfNestType			p	(field list member)

	DATASYM32			f
	PROCSYM32			f
	VPATHSYM32			f
	REGREL32			f
	THREADSYM32			f
	PROCSYMMIPS			f

	
*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union  {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t			utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union  {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;




//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t	attr;           // method attribute
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t		index;          // index to type record for procedure
    unsigned long	vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
	                                // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
	                                // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
	_2BYTEPAD       pad0;			// internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
	_2BYTEPAD       pad0;		// internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
	S_REGISTER_16t	=  0x0002, // Register variable
	S_CONSTANT_16t	=  0x0003, // constant symbol
	S_UDT_16t		=  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME       =  0x0009, // path to object file name
    S_ENDARG        =  0x000a, // end of argument/return list
	S_COBOLUDT_16t	=  0x000b, // special UDT for cobol that does not symbol pack
	S_MANYREG_16t	=  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry
                       
    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address
                       
    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation
                       
    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start
                       
    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
    S_ALIGN         =  0x0402, // Used for page alignment of symbols
    S_LPROCREF      =  0x0403, // Local Reference to a procedure

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
S_TI16_MAX          =  0x1000,
	S_REGISTER		=  0x1001, // Register variable
	S_CONSTANT		=  0x1002, // constant symbol
	S_UDT			=  0x1003, // User defined type
	S_COBOLUDT		=  0x1004, // special UDT for cobol that does not symbol pack
	S_MANYREG		=  0x1005, // multiple register variable
	S_BPREL32		=  0x1006, // BP-relative
	S_LDATA32		=  0x1007, // Module-local symbol
	S_GDATA32		=  0x1008, // Global data symbol
	S_PUB32 		=  0x1009, // a public symbol (CV internal reserved)
	S_LPROC32		=  0x100a, // Local procedure start
	S_GPROC32		=  0x100b, // Global procedure start
	S_VFTABLE32 	=  0x100c, // address of virtual function table
	S_REGREL32		=  0x100d, // register relative address
	S_LTHREAD32 	=  0x100e, // local thread storage
	S_GTHREAD32 	=  0x100f, // global thread storage

	S_LPROCMIPS 	=  0x1010, // Local procedure start
	S_GPROCMIPS 	=  0x1011, // Global procedure start
                       
} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMPRO   = 0x06,
    CV_CFL_MIPSR4000    = 0x10,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43

} CV_CPU_TYPE_e;




//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO:1; // frame pointer present
            unsigned char CV_PFLAG_INT  :1; // interrupt return
            unsigned char CV_PFLAG_FAR  :1; // far return
            unsigned char CV_PFLAG_NEVER:1; // function does not return
            unsigned char unused        :4; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_REGISTER_16t
	CV_typ16_t		typind; 	// Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_MANYREG_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;



typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_CONSTANT_16t
	CV_typ16_t		typind; 	// Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_UDT_16t | S_COBOLUDT_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;





typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    CV_GENERIC_STYLE_e style;   // return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,
    THUNK_ORDINAL_ADJUSTOR,
    THUNK_ORDINAL_VCALL,
    THUNK_ORDINAL_PCODE
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table			= 0x00,	// not executable
    CEXM_MDL_jumptable		= 0x01, // Compiler generated jump table
    CEXM_MDL_datapad		= 0x02, // Data padding for alignment
    CEXM_MDL_native			= 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol			= 0x21, // cobol
    CEXM_MDL_codepad		= 0x22, // Code padding for alignment
    CEXM_MDL_code			= 0x23, // code
	CEXM_MDL_sql			= 0x30,	// sql
    CEXM_MDL_pcode			= 0x40, // pcode
    CEXM_MDL_pcode32Mac		= 0x41,	// macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var16 {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
	CV_typ16_t		root;		// type index of the root of path
	CV_typ16_t		path;		// type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;




typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var32 {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;


typedef enum CV_HREG_e {
    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

	//
	// JAVA VM registers
	//

	CV_JAVA_PC		= 1,


} CV_HREG_e;

#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\include\cvexefmt.h ===
/***    cvexefmt.h - format of CodeView information in exe
 *
 *      Structures, constants, etc. for reading CodeView information
 *      from the executable.
 *
 */

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for that will be accepted by CodeView 4.0 and
//  later.  These are executables with signatures of NB05, NB06 and NB08.
//  There is some confusion about the signatures NB03 and NB04 so none
//  of the utilites will accept executables with these signatures.  NB07 is
//  the signature for QCWIN 1.0 packed executables.

//  All of the structures described below must start on a long word boundary
//  to maintain natural alignment.  Pad space can be inserted during the
//  write operation and the addresses adjusted without affecting the contents
//  of the structures.

#ifndef _CV_INFO_INCLUDED
#include "cvinfo.h"
#endif

#ifndef    FAR
#if _M_IX86 >= 300
#define    FAR
#else
#define FAR far
#endif
#endif


//  Type of subsection entry.

#define sstModule           0x120
#define sstTypes            0x121
#define sstPublic           0x122
#define sstPublicSym        0x123   // publics as symbol (waiting for link)
#define sstSymbols          0x124
#define sstAlignSym         0x125
#define sstSrcLnSeg         0x126   // because link doesn't emit SrcModule
#define sstSrcModule        0x127
#define sstLibraries        0x128
#define sstGlobalSym        0x129
#define sstGlobalPub        0x12a
#define sstGlobalTypes      0x12b
#define sstMPC              0x12c
#define sstSegMap           0x12d
#define sstSegName          0x12e
#define sstPreComp          0x12f   // precompiled types
#define sstPreCompMap       0x130   // map precompiled types in global types
#define sstOffsetMap16      0x131
#define sstOffsetMap32      0x132
#define sstFileIndex        0x133   // Index of file names
#define sstStaticSym        0x134

typedef enum OMFHash {
    OMFHASH_NONE,           // no hashing
    OMFHASH_SUMUC16,        // upper case sum of chars in 16 bit table
    OMFHASH_SUMUC32,        // upper case sum of chars in 32 bit table
    OMFHASH_ADDR16,         // sorted by increasing address in 16 bit table
    OMFHASH_ADDR32          // sorted by increasing address in 32 bit table
} OMFHASH;

//  CodeView Debug OMF signature.  The signature at the end of the file is
//  a negative offset from the end of the file to another signature.  At
//  the negative offset (base address) is another signature whose filepos
//  field points to the first OMFDirHeader in a chain of directories.
//  The NB05 signature is used by the link utility to indicated a completely
//  unpacked file.  The NB06 signature is used by ilink to indicate that the
//  executable has had CodeView information from an incremental link appended
//  to the executable.  The NB08 signature is used by cvpack to indicate that
//  the CodeView Debug OMF has been packed.  CodeView will only process
//  executables with the NB08 signature.


typedef struct OMFSignature {
    char        Signature[4];   // "NBxx"
    long        filepos;        // offset in file
} OMFSignature;



//  directory information structure
//  This structure contains the information describing the directory.
//  It is pointed to by the signature at the base address or the directory
//  link field of a preceeding directory.  The directory entries immediately
//  follow this structure.


typedef struct OMFDirHeader {
    unsigned short  cbDirHeader;    // length of this structure
    unsigned short  cbDirEntry;     // number of bytes in each directory entry
    unsigned long   cDir;           // number of directorie entries
    long            lfoNextDir;     // offset from base of next directory
    unsigned long   flags;          // status flags
} OMFDirHeader;




//  directory structure
//  The data in this structure is used to reference the data for each
//  subsection of the CodeView Debug OMF information.  Tables that are
//  not associated with a specific module will have a module index of
//  oxffff.  These tables are the global types table, the global symbol
//  table, the global public table and the library table.


typedef struct OMFDirEntry {
    unsigned short  SubSection;     // subsection type (sst...)
    unsigned short  iMod;           // module index
    long            lfo;            // large file offset of subsection
    unsigned long   cb;             // number of bytes in subsection
} OMFDirEntry;



//  information decribing each segment in a module

typedef struct OMFSegDesc {
    unsigned short  Seg;            // segment index
    unsigned short  pad;            // pad to maintain alignment
    unsigned long   Off;            // offset of code in segment
    unsigned long   cbSeg;          // number of bytes in segment
} OMFSegDesc;




//  per module information
//  There is one of these subsection entries for each module
//  in the executable.  The entry is generated by link/ilink.
//  This table will probably require padding because of the
//  variable length module name.

typedef struct OMFModule {
    unsigned short  ovlNumber;      // overlay number
    unsigned short  iLib;           // library that the module was linked from
    unsigned short  cSeg;           // count of number of segments in module
    char            Style[2];       // debugging style "CV"
    OMFSegDesc      SegInfo[1];     // describes segments in module
    char            Name[];         // length prefixed module name padded to
                                    // long word boundary
} OMFModule;



//  Symbol hash table format
//  This structure immediately preceeds the global publics table
//  and global symbol tables.

typedef struct OMFSymHash {
    unsigned short  symhash;        // symbol hash function index
    unsigned short  addrhash;       // address hash function index
    unsigned long   cbSymbol;       // length of symbol information
    unsigned long   cbHSym;         // length of symbol hash data
    unsigned long   cbHAddr;        // length of address hashdata
} OMFSymHash;



//  Global types subsection format
//  This structure immediately preceeds the global types table.
//  The offsets in the typeOffset array are relative to the address
//  of ctypes.  Each type entry following the typeOffset array must
//  begin on a long word boundary.

typedef struct OMFTypeFlags {
    unsigned long   sig     :8;
    unsigned long   unused  :24;
} OMFTypeFlags;


typedef struct OMFGlobalTypes {
    OMFTypeFlags    flags;
    unsigned long   cTypes;         // number of types
    unsigned long   typeOffset[];   // array of offsets to types
} OMFGlobalTypes;




//  Precompiled types mapping table
//  This table should be ignored by all consumers except the incremental
//  packer.


typedef struct OMFPreCompMap {
    unsigned short  FirstType;      // first precompiled type index
    unsigned short  cTypes;         // number of precompiled types
    unsigned long   signature;      // precompiled types signature
    unsigned short  pad;
    CV_typ_t        map[];          // mapping of precompiled types
} OMFPreCompMap;




//  Source line to address mapping table.
//  This table is generated by the link/ilink utility from line number
//  information contained in the object file OMF data.  This table contains
//  only the code contribution for one segment from one source file.


typedef struct OMFSourceLine {
    unsigned short  Seg;            // linker segment index
    unsigned short  cLnOff;         // count of line/offset pairs
    unsigned long   offset[1];      // array of offsets in segment
    unsigned short  lineNbr[1];     // array of line lumber in source
} OMFSourceLine;

typedef OMFSourceLine FAR * LPSL;


//  Source file description
//  This table is generated by the linker


typedef struct OMFSourceFile {
    unsigned short  cSeg;           // number of segments from source file
    unsigned short  reserved;       // reserved
    unsigned long   baseSrcLn[1];   // base of OMFSourceLine tables
                                    // this array is followed by array
                                    // of segment start/end pairs followed by
                                    // an array of linker indices
                                    // for each segment in the file
    unsigned short  cFName;         // length of source file name
    char            Name;           // name of file padded to long boundary
} OMFSourceFile;

typedef OMFSourceFile FAR * LPSF;


//  Source line to address mapping header structure
//  This structure describes the number and location of the
//  OMFAddrLine tables for a module.  The offSrcLine entries are
//  relative to the beginning of this structure.


typedef struct OMFSourceModule {
    unsigned short  cFile;          // number of OMFSourceTables
    unsigned short  cSeg;           // number of segments in module
    unsigned long   baseSrcFile[1]; // base of OMFSourceFile table
                                    // this array is followed by array
                                    // of segment start/end pairs followed
                                    // by an array of linker indices
                                    // for each segment in the module
} OMFSourceModule;

typedef OMFSourceModule FAR * LPSM;

//  sstLibraries

typedef struct OMFLibrary {
    unsigned char   cbLibs;     // count of library names
    char            Libs[1];    // array of length prefixed lib names (first entry zero length)
} OMFLibrary;


// sstFileIndex - An index of all of the files contributing to an
//  executable.

typedef struct OMFFileIndex {
    unsigned short  cmodules;       // Number of modules
    unsigned short  cfilerefs;      // Number of file references
    unsigned short  modulelist[1];  // Index to beginning of list of files
                                    // for module i. (0 for module w/o files)
    unsigned short  cfiles[1];      // Number of file names associated
                                    // with module i.
    unsigned long   ulNames[1];     // Offsets from the beginning of this
                                    // table to the file names
    char            Names[];        // The length prefixed names of files
} OMFFileIndex;


//  Offset mapping table
//  This table provides a mapping from logical to physical offsets.
//  This mapping is applied between the logical to physical mapping
//  described by the seg map table.

typedef struct OMFOffsetMap16 {
    unsigned long   csegment;       // Count of physical segments

    // The next six items are repeated for each segment

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned short  rgoffLog[1];    // Array of logical offsets
    short           rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned short  rgoffPhys[1];   // Array of physical offsets
    short           rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap16;

typedef struct OMFOffsetMap32 {
    unsigned long   csection;       // Count of physical sections

    // The next six items are repeated for each section

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned long   rgoffLog[1];    // Array of logical offsets
    long            rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned long   rgoffPhys[1];   // Array of physical offsets
    long            rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap32;

//  Pcode support.  This subsection contains debug information generated
//  by the MPC utility used to process Pcode executables.  Currently
//  it contains a mapping table from segment index (zero based) to
//  frame paragraph.  MPC converts segmented exe's to non-segmented
//  exe's for DOS support.  To avoid backpatching all CV info, this
//  table is provided for the mapping.  Additional info may be provided
//  in the future for profiler support.

typedef struct OMFMpcDebugInfo {
    unsigned short  cSeg;           // number of segments in module
    unsigned short  mpSegFrame[1];  // map seg (zero based) to frame
} OMFMpcDebugInfo;

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for linkers that emit executables with the NB02
//  signature.  Current utilities with the exception of cvpack and cvdump
//  will not accept or emit executables with the NB02 signature.  Cvdump
//  will dump an unpacked executable with the NB02 signature.  Cvpack will
//  read an executable with the NB02 signature but the packed executable
//  will be written with the table format, contents and signature of NB08.


//  subsection type constants

#define SSTMODULE       0x101    // Basic info. about object module
#define SSTPUBLIC       0x102    // Public symbols
#define SSTTYPES        0x103    // Type information
#define SSTSYMBOLS      0x104    // Symbol Data
#define SSTSRCLINES     0x105    // Source line information
#define SSTLIBRARIES    0x106    // Names of all library files used
#define SSTIMPORTS      0x107    // Symbols for DLL fixups
#define SSTCOMPACTED    0x108    // Compacted types section
#define SSTSRCLNSEG     0x109    // Same as source lines, contains segment


typedef struct DirEntry{
    unsigned short  SubSectionType;
    unsigned short  ModuleIndex;
    long            lfoStart;
    unsigned short  Size;
} DirEntry;


//  information decribing each segment in a module

typedef struct oldnsg {
    unsigned short  Seg;         // segment index
    unsigned short  Off;         // offset of code in segment
    unsigned short  cbSeg;       // number of bytes in segment
} oldnsg;


//  old subsection module information

typedef struct oldsmd {
    oldnsg          SegInfo;     // describes first segment in module
    unsigned short  ovlNbr;      // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;        // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];   // length prefixed name of module
    oldnsg          arnsg[];     // cSeg-1 structures exist for alloc text or comdat code
} oldsmd;

typedef struct{
    unsigned short  Seg;
    unsigned long   Off;
    unsigned long   cbSeg;
} oldnsg32;

typedef struct {
    oldnsg32        SegInfo;     // describes first segment in module
    unsigned short  ovlNbr;      // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;        // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];   // length prefixed name of module
    oldnsg32        arnsg[];     // cSeg-1 structures exist for alloc text or comdat code
} oldsmd32;

// OMFSegMap - This table contains the mapping between the logical segment indices
// used in the symbol table and the physical segments where the program is loaded

typedef struct OMFSegMapDesc {
    unsigned short  flags;       // descriptor flags bit field.
    unsigned short  ovl;         // the logical overlay number
    unsigned short  group;       // group index into the descriptor array
    unsigned short  frame;       // logical segment index - interpreted via flags
    unsigned short  iSegName;    // segment or group name - index into sstSegName
    unsigned short  iClassName;  // class name - index into sstSegName
    unsigned long   offset;      // byte offset of the logical within the physical segment
    unsigned long   cbSeg;       // byte count of the logical segment or group
} OMFSegMapDesc;

typedef struct OMFSegMap {
    unsigned short  cSeg;        // total number of segment descriptors
    unsigned short  cSegLog;     // number of logical segment descriptors
    OMFSegMapDesc   rgDesc[0];   // array of segment descriptors
} OMFSegMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\include\strings.h ===
#if ! defined( _RES_STR_ )
#define _RES_STR_

#ifdef RESOURCES
#define RES_STR(a, b, c) b, c
STRINGTABLE
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
BEGIN
#else

enum _RESOURCEIDS {
#define RES_STR(a, b, c) a = b,
#endif


RES_STR(ERR_OPEN_INPUT_FILE,    1,      "The file '%s' could not be openned for reading")
RES_STR(ERR_INVALID_PE,         2,      "'%s' is not a valid PE exe file with debug info")
RES_STR(ERR_NO_DEST,            3,      "Need to specify a destination for the converted debug information")
RES_STR(ERR_OPEN_WRITE_FILE,    4,      "Cannot open the file '%s' for writing")
RES_STR(ERR_EDIT_DBG_FILE,      5,      "Cannot edit name file in DBG file")
RES_STR(ERR_MAP_FILE,           6,      "Cannot map the file '%s'")
RES_STR(ERR_NO_COFF,            7,      "No COFF debug information present to be converted")
RES_STR(ERR_NOT_MAPPED,         8,      "Cannot add CV info unless debug information is mapped")
RES_STR(ERR_COFF_TO_CV,         9,      "Cannot convert COFF debug information to CodeView debug information")
RES_STR(ERR_OP_UNKNOWN,         10,     "Operation '%s' is unknown")
RES_STR(ERR_NO_MEMORY,          11,     "Out of memory")
RES_STR(ERR_FILE_PTRS,          12,     "INTERNAL: cannot set file pointers")
RES_STR(ERR_SET_EOF,            13,     "INTERNAL: cannot set the end of file markder")
RES_STR(ERR_CHECKSUM_CALC,      14,     "INTERNAL: cannot compute the image checksum")

#ifdef RESOURCES
END
#else
};
#endif

#endif // _RES_STR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\include\symcvt.h ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    symcvt.h

Abstract:

    This file contains all of the type definitions and prototypes
    necessary to access the symcvt library.

Environment:

    Win32, User Mode

--*/


typedef struct tagPTRINFO {
    DWORD                       size;
    DWORD                       count;
    PUCHAR                      ptr;
} PTRINFO, *PPTRINFO;

typedef struct tagIMAGEPOINTERS {
    char                        szName[MAX_PATH];
    HANDLE                      hFile;
    HANDLE                      hMap;
    DWORD                       fsize;
    PUCHAR                      fptr;
    BOOLEAN                     fRomImage;
    PIMAGE_DOS_HEADER           dosHdr;
    PIMAGE_NT_HEADERS           ntHdr;
    PIMAGE_ROM_HEADERS          romHdr;
    PIMAGE_FILE_HEADER          fileHdr;
    PIMAGE_OPTIONAL_HEADER      optHdr;
    PIMAGE_SEPARATE_DEBUG_HEADER sepHdr;
    int                         cDebugDir;
    PIMAGE_DEBUG_DIRECTORY *    rgDebugDir;
    PIMAGE_SECTION_HEADER       sectionHdrs;
    PIMAGE_SECTION_HEADER       debugSection;
    PIMAGE_SYMBOL               AllSymbols;
    PUCHAR                      stringTable;
    int                         numberOfSymbols;
    int                         numberOfSections;
    PCHAR *                     rgpbDebugSave;
} IMAGEPOINTERS, *PIMAGEPOINTERS;

#define COFF_DIR(x)             ((x)->rgDebugDir[IMAGE_DEBUG_TYPE_COFF])
#define CV_DIR(x)               ((x)->rgDebugDir[IMAGE_DEBUG_TYPE_CODEVIEW])

typedef struct _MODULEINFO {
    DWORD               iMod;
    DWORD               cb;
    DWORD               SrcModule;
    LPSTR               name;
} MODULEINFO, *LPMODULEINFO;

typedef struct tagPOINTERS {
    IMAGEPOINTERS               iptrs;         // input file pointers
    IMAGEPOINTERS               optrs;         // output file pointers
    PTRINFO                     pCvStart;      // start of cv info
    PUCHAR                      pCvCurr;       // current cv pointer
    PTRINFO                     pCvModules;    // module information
    PTRINFO                     pCvSrcModules; // source module information
    PTRINFO                     pCvPublics;    // publics information
    PTRINFO                     pCvSegName;    // segment names
    PTRINFO                     pCvSegMap;     // segment map
    PTRINFO                     pCvSymHash;    // symbol hash table
    PTRINFO                     pCvAddrSort;   // address sort table
    LPMODULEINFO                pMi;
    DWORD                       modcnt;
} POINTERS, *PPOINTERS;

typedef  char *  (* CONVERTPROC) (HANDLE, char *);

#define align(_n)       ((4 - (( (DWORD)_n ) % 4 )) & 3)

#ifdef _SYMCVT_SOURCE_
#define SYMCVTAPI
#else
#define SYMCVTAPI DECLSPEC_IMPORT
#endif

PUCHAR  SYMCVTAPI ConvertSymbolsForImage( HANDLE, char * );
BOOL    SYMCVTAPI ConvertCoffToCv( PPOINTERS p );
BOOL    SYMCVTAPI ConvertSymToCv( PPOINTERS p );
BOOL    SYMCVTAPI MapInputFile ( PPOINTERS p, HANDLE hFile, char *fname);
BOOL    SYMCVTAPI UnMapInputFile ( PPOINTERS p );
BOOL    SYMCVTAPI CalculateNtImagePointers( PIMAGEPOINTERS p );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\matchsym\symres.cpp ===
/*
    Copyright 1999 Microsoft Corporation
    
    Neptune data collection server
    
    Walter Smith (wsmith) 

    Matches Symbols with The Corresponding Binary

 */
 
#include <windows.h>


#include <dbghelp.h>
#include <symres.h>
#include <stdio.h>
#include <stdlib.h>
#include <shlwapi.h> 
#include <sys\stat.h>
#include <string.h>
#undef UNICODE

void                         
UndecorateSymbol(
        LPTSTR szSymbol         // [in] [out] function name undecorated in place
        )
{
    char             szTemp[MAX_PATH];
    PIMAGEHLP_SYMBOL pihsym;
    DWORD            dwSize;
   
    dwSize = sizeof(IMAGEHLP_SYMBOL)+MAX_PATH;
    pihsym = (IMAGEHLP_SYMBOL *) malloc(dwSize);
    pihsym->SizeOfStruct = dwSize;
    pihsym->Address = 0;
    pihsym->Flags = 0;
    pihsym->MaxNameLength = MAX_PATH;
    wcstombs(pihsym->Name,szSymbol, lstrlen(szSymbol));
    SymUnDName(pihsym,szTemp,MAX_PATH);
    mbstowcs(szSymbol,szTemp, strlen(szTemp));
}

// select file from list of open files, or open and add to list
// maintain files in usage order, least recently used at end of list
OPENFILE*                                           // pointer to open file info
SymbolResolver::GetFile(
        LPWSTR szwModule                            // [in] name of file
        )
{
    OPENFILE*                       pFile = NULL;
    MAPDEF                          map;
    DWORD                           dwCread;
    WCHAR                           wszBuffer[MAX_PATH];

    wcscpy(wszBuffer, szwModule);
    PathRemoveExtension(wszBuffer);
    PathAddExtension(wszBuffer, L".sym");

    pFile = new OPENFILE;
        // open SYM file
    pFile->hfFile = CreateFileW(wszBuffer,
                               GENERIC_READ,
                               FILE_SHARE_READ, 
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL, 
                               NULL);

    if (pFile->hfFile == INVALID_HANDLE_VALUE) return NULL;
    // copy filename and version into pFile node
    lstrcpyW(pFile->szwName, szwModule);

    // read map definition
    ReadFile(pFile->hfFile, &map, sizeof(MAPDEF)-1, &dwCread, NULL);

    if (dwCread != sizeof(MAPDEF)-1)
    {   
        if (pFile->hfFile)
            CloseHandle(pFile->hfFile);
        if (pFile)
            delete pFile;       
        throw E_FAIL;
    }

    pFile->ulFirstSeg = map.md_spseg*16;
    pFile->nSeg = map.md_cseg;
    pFile->psCurSymDefPtrs = NULL;
  
    return pFile;
}


// parse sym file to resolve address
// read segment defintion for dwSection 
ULONG                                   // return offset of segment definition, 0 if failed
SymbolResolver::GetSegDef(OPENFILE*     pFile,            // [in] pointer to open file info
        DWORD         dwSection,        // [in] section number
        SEGDEF*       pSeg)              // [out] pointer to segment definition
{
    ULONG   ulCurSeg = pFile->ulFirstSeg;
    int     iSectionIndex = 0;
    DWORD   dwCread;

    // step through segments
    while (iSectionIndex < pFile->nSeg)
    {
        // go to segment beginning
        if (SetFilePointer(pFile->hfFile, ulCurSeg, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            ulCurSeg = 0;
            break;
        }

        // read seg defn
        if (!ReadFile(pFile->hfFile, pSeg, sizeof(SEGDEF)-1, &dwCread, NULL))
        {
            ulCurSeg = 0;
            break;
        }

        iSectionIndex++;
        if (iSectionIndex == (int)dwSection)   // gotcha
        {
            break;
        }

        // go to next segment definition
        ulCurSeg = pSeg->gd_spsegnext*16; 
    }

    // found our section and it's non-empty?
    if (iSectionIndex != (int)dwSection || !pSeg->gd_csym) // no
    {
        ulCurSeg = 0;
    }

    return ulCurSeg;
}

// parse sym file to resolve address
bool 
SymbolResolver::GetNameFromAddr(
        LPWSTR      szwModule,           // [in] name of symbol file
        DWORD       dwSection,           // [in] section part of address to resolve
        DWORD       dwOffsetToRva,      // [in] Section base
        UINT_PTR     uRva,              // [in] offset part of address to resolve
        LPWSTR      wszFuncName          // [out] resolved function name, 
        )      
{
    SEGDEF              seg;
    DWORD               dwSymAddr;
    TCHAR               sztFuncName[MAX_NAME+1];
    int                 i;
    int                 nNameLen;
    DWORD               dwCread;
    int                 nToRead;
    unsigned char       cName;
    ULONG               ulCurSeg;
    ULONG               ulSymNameOffset = 0;
    HANDLE              hfFile;
    OPENFILE*           pFile = NULL;
    DWORD               dwArrayOffset;
    DWORD               dwSymOffset;
    bool fResult = false;

    // get file from open list, or open file
    pFile = GetFile(szwModule);

    if (!pFile)
        return false;
        
    if ((ulCurSeg = GetSegDef(pFile, dwSection, &seg)) == 0)
    {
        goto Cleanup;
    }    
    
    BYTE* pSymDefPtrs;

    // big symbols?
    if (seg.gd_type & MSF_BIGSYMDEF) 
    {
        dwArrayOffset = seg.gd_psymoff * 16;
        pSymDefPtrs = (BYTE*)(new BYTE[seg.gd_csym*3]);
    }
    else
    {
        dwArrayOffset = seg.gd_psymoff;
        pSymDefPtrs = (BYTE*)(new BYTE[seg.gd_csym*2]);
    }
    hfFile = pFile->hfFile;

    SetFilePointer(hfFile, ulCurSeg + dwArrayOffset, NULL, FILE_BEGIN);
                        
        // read symbol definition pointers array 
    ReadFile(hfFile, pSymDefPtrs, seg.gd_csym * ((seg.gd_type & MSF_BIGSYMDEF)?3:2), &dwCread, NULL);

    pFile->psCurSymDefPtrs = pSymDefPtrs;

    // save this section 
    pFile->dwCurSection = dwSection;
    
    // read symbols

    for (i = 0; i < seg.gd_csym; i++)
    {
        // go to offset of sym defintion 
        if (seg.gd_type & MSF_BIGSYMDEF)
        {
            dwSymOffset = pFile->psCurSymDefPtrs[i*3+0]
                          + pFile->psCurSymDefPtrs[i*3+1]*256
                          + pFile->psCurSymDefPtrs[i*3+2]*65536;
        }
        else
        {
            dwSymOffset = pFile->psCurSymDefPtrs[i*2+0]
                          + pFile->psCurSymDefPtrs[i*2+1]*256;
        }

        SetFilePointer(hfFile, ulCurSeg + dwSymOffset, NULL, FILE_BEGIN);

        // read symbol address DWORD 
        ReadFile(hfFile,&dwSymAddr,sizeof(DWORD),&dwCread,NULL);

        // symbol address is 1 word or two?
        nToRead = sizeof(SHORT) + ((seg.gd_type & MSF_32BITSYMS) * sizeof(SHORT));

        // calculate offset of symbol name 
        ulSymNameOffset = ulCurSeg + dwSymOffset + nToRead;

        // use just lower word of address if 16-bit symbol
        if (!(seg.gd_type & MSF_32BITSYMS))
        {
            dwSymAddr = dwSymAddr & 0x0000FFFF;
        }
        dwSymAddr += dwOffsetToRva;
        
        if (dwSymAddr > uRva )  break;
        if (dwSymAddr == uRva )
        {
            // do we have our function?
            // if current address is greater than offset, then since we are 
            // traversing in the increasing order of addresses, the previous 
            // symbol must be our quarry

            SetFilePointer(hfFile, ulSymNameOffset, NULL, FILE_BEGIN);

            // read length of name
            ReadFile(hfFile,&cName,sizeof(TCHAR),&dwCread,NULL);

            nNameLen = (int) cName;

            // read symbol name
            ReadFile(hfFile,sztFuncName,nNameLen,&dwCread,NULL);

            sztFuncName[nNameLen/2 - (nNameLen+1)%2] = TCHAR('\0');
        
            UndecorateSymbol(sztFuncName);
       
            StrCpyNW(wszFuncName, sztFuncName, MAX_NAME);
            fResult = true;
        }
    }   

Cleanup:

    if (pFile->hfFile)
        CloseHandle(pFile->hfFile);

    if (pFile->psCurSymDefPtrs)
        delete pFile->psCurSymDefPtrs;

    if (pFile)    
        delete pFile;

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\symcvt\file.c ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module handles all file i/o for SYMCVT.  This includes the
    mapping of all files and establishing all file pointers for the
    mapped file(s).

Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define _SYMCVT_SOURCE_
#include "symcvt.h"

static BOOL CalculateOutputFilePointers( PIMAGEPOINTERS pi, PIMAGEPOINTERS po );
static BOOL CalculateInputFilePointers( PIMAGEPOINTERS p );

 
MapInputFile (
              PPOINTERS   p,
              HANDLE      hFile,
              char *      fname
              )
/*++

Routine Description:

    Maps the input file specified by the fname argument and saves the
    file handle & file pointer in the POINTERS structure.


Arguments:

    p        - Supplies pointer to a POINTERS structure
    hFile    - OPTIONAL Supplies handle for file if already open
    fname    - Supplies ascii string for the file name

Return Value:

    TRUE     - file mapped ok
    FALSE    - file could not be mapped

--*/

{
    BOOL        rVal = TRUE;

    memset( p, 0, sizeof(POINTERS) );

    strcpy( p->iptrs.szName, fname );

    if (hFile != NULL) {

        p->iptrs.hFile = hFile;

    } else {

        p->iptrs.hFile = CreateFileA(p->iptrs.szName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );
    }

    if (p->iptrs.hFile == INVALID_HANDLE_VALUE) {

        rVal = FALSE;

    } else {

        p->iptrs.fsize = GetFileSize( p->iptrs.hFile, NULL );
        p->iptrs.hMap = CreateFileMapping( p->iptrs.hFile,
                                           NULL,
                                           PAGE_READONLY,
                                           0,
                                           0,
                                           NULL
                                         );

        if (p->iptrs.hMap == INVALID_HANDLE_VALUE) {

            p->iptrs.hMap = NULL;
            rVal = FALSE;

        } else {

            p->iptrs.fptr = MapViewOfFile( p->iptrs.hMap,
                                           FILE_MAP_READ,
                                           0, 0, 0 );
            if (p->iptrs.fptr == NULL) {
                CloseHandle( p->iptrs.hMap );
                p->iptrs.hMap = NULL;
                rVal = FALSE;
            }
        }
    }

    if (!hFile && p->iptrs.hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(p->iptrs.hFile);
        p->iptrs.hFile = NULL;
    }

    return rVal;
}                               /* MapInputFile() */



BOOL
UnMapInputFile (
    PPOINTERS p
    )
/*++

Routine Description:

    Unmaps the input file specified by the fname argument and then
    closes the file.


Arguments:

    p        - pointer to a POINTERS structure

Return Value:

    TRUE     - file mapped ok
    FALSE    - file could not be mapped

--*/

{
    if ( p->iptrs.fptr ) {
        UnmapViewOfFile( p->iptrs.fptr );
        p->iptrs.fptr = NULL;
    }
    if ( p->iptrs.hMap ) {
        CloseHandle( p->iptrs.hMap );
        p->iptrs.hMap = NULL;
    }
    if (p->iptrs.hFile != NULL) {
        CloseHandle( p->iptrs.hFile );
        p->iptrs.hFile = NULL;
    }
    return TRUE;
}                               /* UnMapInputFile() */


BOOL
FillInSeparateImagePointers(
                            PIMAGEPOINTERS      p
                            )
/*++

Routine Description:

    This routine will go through the exe file and fill in the
    pointers needed relative to the separate debug information files

Arguments:

    p  - Supplies the structure to fill in

Return Value:

    TRUE if successful and FALSE otherwise.

--*/

{
    int                         li;
    int                         numDebugDirs;
    PIMAGE_DEBUG_DIRECTORY      pDebugDir;
    PIMAGE_COFF_SYMBOLS_HEADER  pCoffHdr;

    p->sectionHdrs = (PIMAGE_SECTION_HEADER)
      (p->fptr + sizeof(IMAGE_SEPARATE_DEBUG_HEADER));

    numDebugDirs = p->sepHdr->DebugDirectorySize/sizeof(IMAGE_DEBUG_DIRECTORY);

    if (numDebugDirs == 0) {
        return FALSE;
    }

    /*
     *  For each debug directory, determine the debug directory type
     *  and cache any information about them.
     */

    pDebugDir = (PIMAGE_DEBUG_DIRECTORY)
      (p->fptr + sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
       p->sepHdr->NumberOfSections * sizeof(IMAGE_SECTION_HEADER) +
       p->sepHdr->ExportedNamesSize);

    for (li=0; li<numDebugDirs; li++, pDebugDir++) {
        if (((int) pDebugDir->Type) > p->cDebugDir) {
            p->cDebugDir += 10;
            p->rgDebugDir = realloc((char *) p->rgDebugDir,
                                    p->cDebugDir * sizeof(p->rgDebugDir[0]));
            memset(&p->rgDebugDir[p->cDebugDir-10], 0,
                   10*sizeof(p->rgDebugDir[0]));
        }

        p->rgDebugDir[pDebugDir->Type] = pDebugDir;
    }

    if (p->rgDebugDir[IMAGE_DEBUG_TYPE_COFF] != NULL) {
        pCoffHdr = (PIMAGE_COFF_SYMBOLS_HEADER) (p->fptr +
          p->rgDebugDir[IMAGE_DEBUG_TYPE_COFF]->PointerToRawData);
        p->AllSymbols = (PIMAGE_SYMBOL)
          ((char *) pCoffHdr + pCoffHdr->LvaToFirstSymbol);
        p->stringTable = pCoffHdr->NumberOfSymbols * IMAGE_SIZEOF_SYMBOL +
          (char *) p->AllSymbols;
        p->numberOfSymbols = pCoffHdr->NumberOfSymbols;
    }
    p->numberOfSections = p->sepHdr->NumberOfSections;

    return TRUE;
}                               /* FillInSeparateImagePointers() */



BOOL
CalculateNtImagePointers(
    PIMAGEPOINTERS p
    )
/*++

Routine Description:

    This function reads an NT image and its associated COFF headers
    and file pointers and build a set of pointers into the mapped image.
    The pointers are all relative to the image's mapped file pointer
    and allow direct access to the necessary data.

Arguments:

    p        - pointer to a IMAGEPOINTERS structure

Return Value:

    TRUE     - pointers were created
    FALSE    - pointers could not be created

--*/
{
    PIMAGE_DEBUG_DIRECTORY      debugDir;
    PIMAGE_SECTION_HEADER       sh;
    DWORD                       i, li, rva, numDebugDirs;
    PIMAGE_FILE_HEADER          pFileHdr;
    PIMAGE_OPTIONAL_HEADER      pOptHdr;
    DWORD                       offDebugInfo;

    try {
        /*
         *      Based on wheither or not we find the dos (MZ) header
         *      at the beginning of the file, attempt to get a pointer
         *      to where the PE header is suppose to be.
         */

        p->dosHdr = (PIMAGE_DOS_HEADER) p->fptr;
        if (p->dosHdr->e_magic == IMAGE_DOS_SIGNATURE) {
            p->ntHdr = (PIMAGE_NT_HEADERS)
              ((DWORD)p->dosHdr->e_lfanew + p->fptr);
            p->fRomImage = FALSE;
        } else if (p->dosHdr->e_magic == IMAGE_SEPARATE_DEBUG_SIGNATURE) {
            p->sepHdr = (PIMAGE_SEPARATE_DEBUG_HEADER) p->fptr;
            p->dosHdr = NULL;
            p->fRomImage = FALSE;
            return FillInSeparateImagePointers(p);
        } else {
            p->romHdr = (PIMAGE_ROM_HEADERS) p->fptr;
            if (p->romHdr->FileHeader.SizeOfOptionalHeader ==
                                          IMAGE_SIZEOF_ROM_OPTIONAL_HEADER &&
                p->romHdr->OptionalHeader.Magic ==
                                          IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
                //
                // its a rom image
                //
                p->fRomImage = TRUE;
                p->ntHdr = NULL;
                p->dosHdr = NULL;
            } else {
                p->fRomImage = FALSE;
                p->ntHdr = (PIMAGE_NT_HEADERS) p->fptr;
                p->dosHdr = NULL;
                p->romHdr = NULL;
            }
        }

        /*
         *  What comes next must be a PE header.  If not then pop out
         */

        if ( p->ntHdr ) {
            if ( p->dosHdr && (DWORD)p->dosHdr->e_lfanew > (DWORD)p->fsize ) {
                return FALSE;
            }

            if ( p->ntHdr->Signature != IMAGE_NT_SIGNATURE ) {
                return FALSE;
            }

            /*
             *  We did find a PE header so start setting pointers to various
             *      structures in the exe file.
             */

            pFileHdr = p->fileHdr = &p->ntHdr->FileHeader;
            pOptHdr = p->optHdr = &p->ntHdr->OptionalHeader;
        } else if (p->romHdr) {
            pFileHdr = p->fileHdr = &p->romHdr->FileHeader;
            pOptHdr = (PIMAGE_OPTIONAL_HEADER) &p->romHdr->OptionalHeader;
            p->optHdr = (PIMAGE_OPTIONAL_HEADER) &p->romHdr->OptionalHeader;
        } else {
            return FALSE;
        }

        if (!(pFileHdr->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
            return FALSE;
        }

        if (pFileHdr->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
            return(FALSE);
        }

        /*
         *  If they exists then get a pointer to the symbol table and
         *      the string table
         */

        if (pFileHdr->PointerToSymbolTable) {
            p->AllSymbols = (PIMAGE_SYMBOL)
                              (pFileHdr->PointerToSymbolTable + p->fptr);
            p->stringTable = (LPSTR)((ULONG)p->AllSymbols +
                           (IMAGE_SIZEOF_SYMBOL * pFileHdr->NumberOfSymbols));
            p->numberOfSymbols = pFileHdr->NumberOfSymbols;
        }

        p->numberOfSections = pFileHdr->NumberOfSections;

        if (p->romHdr) {

            sh = p->sectionHdrs = (PIMAGE_SECTION_HEADER) (p->romHdr+1);

            p->cDebugDir = 10;
            p->rgDebugDir = calloc(sizeof(IMAGE_DEBUG_DIRECTORY) * 10, 1);

            debugDir = 0;

            for (i=0; i<pFileHdr->NumberOfSections; i++, sh++) {
                if (!strcmp(sh->Name, ".rdata")) {
                    debugDir = (PIMAGE_DEBUG_DIRECTORY)(sh->PointerToRawData + p->fptr);
                }

                if (strncmp(sh->Name,".debug",8)==0) {
                    p->debugSection = sh;
                }
            }

            if (debugDir) {
                do {
                    if ((int)debugDir->Type > p->cDebugDir) {
                        p->cDebugDir += 10;
                        p->rgDebugDir = realloc((char *) p->rgDebugDir,
                                            p->cDebugDir * sizeof(p->rgDebugDir[0]));
                        memset(&p->rgDebugDir[p->cDebugDir-10],
                                0,
                                10*sizeof(IMAGE_DEBUG_DIRECTORY));
                    }
                    p->rgDebugDir[debugDir->Type] = debugDir;
                    debugDir++;
                } while (debugDir->Type != 0);
            }
        } else {

            /*
             *  Locate the debug directory
             */

            rva =
              pOptHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

            numDebugDirs =
              pOptHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                sizeof(IMAGE_DEBUG_DIRECTORY);

            if (numDebugDirs == 0) {
                return FALSE;
            }

            sh = p->sectionHdrs = IMAGE_FIRST_SECTION( p->ntHdr );

            /*
             * Find the section the debug directory is in.
             */

            for (i=0; i<pFileHdr->NumberOfSections; i++, sh++) {
                if (rva >= sh->VirtualAddress &&
                    rva < sh->VirtualAddress+sh->SizeOfRawData) {
                    break;
                }
            }

            /*
             *   For each debug directory, determine the debug directory
             *      type and cache any information about them.
             */

            debugDir = (PIMAGE_DEBUG_DIRECTORY) ( rva - sh->VirtualAddress +
                                                 sh->PointerToRawData +
                                                 p->fptr );

            for (li=0; li<numDebugDirs; li++, debugDir++) {
                if (((int) debugDir->Type) > p->cDebugDir) {
                    p->cDebugDir += 10;
                    p->rgDebugDir = realloc((char *) p->rgDebugDir,
                                            p->cDebugDir * sizeof(p->rgDebugDir[0]));
                    memset(&p->rgDebugDir[p->cDebugDir-10], 0,
                           10*sizeof(p->rgDebugDir[0]));
                }
                p->rgDebugDir[debugDir->Type] = debugDir;
                offDebugInfo = debugDir->AddressOfRawData;
            }

            /*
             *  Check to see if the debug information is mapped and if
             *      there is a section called .debug
             */

            sh = p->sectionHdrs = IMAGE_FIRST_SECTION( p->ntHdr );

            for (i=0; i<pFileHdr->NumberOfSections; i++, sh++) {
                if ((offDebugInfo >= sh->VirtualAddress) &&
                    (offDebugInfo < sh->VirtualAddress+sh->SizeOfRawData)) {
                    p->debugSection = sh;
                    break;
                }
            }
        }

        return TRUE;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
}                               /* CalcuateNtImagePointers() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\matchsym\symres.h ===
/*
    Copyright 1999 Microsoft Corporation
    
    Symbol resolver class

    Walter Smith (wsmith)

    changed Sivarudrappa Mahesh (smahesh)
 */

#pragma once

#include "symdef.h"

class SymbolResolver {
public:
    
OPENFILE*                                           // pointer to open file info
GetFile(LPWSTR szwModule                            // [in] name of file
        );

ULONG                                   // return offset of segment definition, 0 if failed
GetSegDef(OPENFILE*     pFile,            // [in] pointer to open file info
        DWORD         dwSection,        // [in] section number
        SEGDEF*       pSeg);              // [out] pointer to segment definition

bool 
GetNameFromAddr(
        LPWSTR      szwModule,           // [in] name of symbol file
        DWORD       dwSection,           // [in] section part of address to resolve
        DWORD       dwOffsetToRva,
        UINT_PTR    UOffset,              // [in] offset part of address to resolve
        LPWSTR      szwFuncName          // [out] resolved function name, 
        );       

private:
    WCHAR       m_szwSymDir[MAX_PATH];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\symcvt\cvcommon.c ===
/*++

Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    cvcommon.c

Abstract:

    This file contians a set of common routines which are used in
    doing symbol conversions from one type of symbols to CodeView
    symbols.

Author:

    Wesley A. Witt (wesw) 19-April-1993
    Jim Schaad (jimsch) 22 May 1993

--*/

#include        <windows.h>
#include        <stdlib.h>
#include        "cv.h"
#include        "symcvt.h"
#include        "cvcommon.h"

typedef struct tagSYMHASH {
    DWORD       dwHashVal;         // hash value for the symbol
    DWORD       dwHashBucket;      // hash bucket number
    DATASYM32 * dataSym;           // pointer to the symbol info
} SYMHASH;

typedef struct tagOFFSETSORT {
    DWORD       dwOffset;          // offset for the symbol
    DWORD       dwSection;         // section number of the symbol
    DATASYM32 * dataSym;           // pointer to the symbol info
} OFFSETSORT;


int __cdecl SymHashCompare( const void *arg1, const void *arg2 );
int __cdecl OffsetSortCompare( const void *arg1, const void *arg2 );

DWORD
CreateSignature( PPOINTERS p )

/*++

Routine Description:

    Creates the CODEVIEW signature record.  Currently this converter only
    generates NB09 data (MS C/C++ 8.0).


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    number of records generates, this is always 1.

--*/

{
    OMFSignature        *omfSig;

    omfSig = (OMFSignature *) p->pCvCurr;
    strcpy( omfSig->Signature, "NB09" );
    omfSig->filepos = 0;
    p->pCvStart.size += sizeof(OMFSignature);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFSignature);
    return 1;
}                               /* CreateSignature() */

DWORD
CreateDirectories( PPOINTERS p )

/*++

Routine Description:

    This is the control function for the generation of the CV directories.
    It calls individual functions for the generation of specific types of
    debug directories.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directories created.

--*/

{
    OMFDirHeader        *omfDir = (OMFDirHeader *)p->pCvCurr;
    OMFSignature        *omfSig = (OMFSignature *)p->pCvStart.ptr;
    OMFDirEntry         *omfDirEntry = NULL;

    omfSig->filepos = (DWORD)p->pCvCurr - (DWORD)p->pCvStart.ptr;

    omfDir->cbDirHeader = sizeof(OMFDirHeader);
    omfDir->cbDirEntry  = sizeof(OMFDirEntry);
    omfDir->cDir        = 0;
    omfDir->lfoNextDir  = 0;
    omfDir->flags       = 0;

    p->pCvStart.size += sizeof(OMFDirHeader);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirHeader);

    omfDir->cDir += CreateModuleDirectoryEntries( p );
    omfDir->cDir += CreatePublicDirectoryEntries( p );
    omfDir->cDir += CreateSegMapDirectoryEntries( p );
    omfDir->cDir += CreateSrcModulesDirectoryEntries( p );

    strcpy(p->pCvCurr, "NB090000");
    p->pCvStart.size += 8;
    p->pCvCurr += 8;
    *((DWORD *) (p->pCvCurr-4)) = p->pCvStart.size;

    return omfDir->cDir;
}                               /* CreateDirectories() */

DWORD
CreateModuleDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates directory entries for each module in the image.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directory entries created.

--*/

{
    OMFDirEntry   *omfDirEntry = NULL;
    OMFModule     *m = NULL;
    OMFModule     *mNext = NULL;
    DWORD         i = 0;
    DWORD         mSize = 0;
    DWORD         lfo = (DWORD)p->pCvModules.ptr - (DWORD)p->pCvStart.ptr;

    m = (OMFModule *) p->pCvModules.ptr;
    for (i=0; i<p->pCvModules.count; i++) {
        mNext = NextMod(m);

        omfDirEntry = (OMFDirEntry *) p->pCvCurr;

        mSize = (DWORD)mNext - (DWORD)m;
        omfDirEntry->SubSection = sstModule;
        omfDirEntry->iMod       = (USHORT) i + 1;
        omfDirEntry->lfo        = lfo;
        omfDirEntry->cb         = mSize;

        lfo += mSize;

        p->pCvStart.size += sizeof(OMFDirEntry);
        p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

        m = mNext;
    }

    return p->pCvModules.count;
}                               /* CreateModuleDirectoryEntries() */

DWORD
CreatePublicDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates the directory entry for the global publics.

Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directory entries created, always 1.

--*/

{
    OMFDirEntry   *omfDirEntry = (OMFDirEntry *) p->pCvCurr;

    omfDirEntry->SubSection = sstGlobalPub;
    omfDirEntry->iMod       = 0xffff;
    omfDirEntry->lfo        = (DWORD)p->pCvPublics.ptr - (DWORD)p->pCvStart.ptr;
    omfDirEntry->cb         = p->pCvPublics.size;

    p->pCvStart.size += sizeof(OMFDirEntry);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

    return 1;
}                               /* CreatePublicDirectoryEntries() */


DWORD
CreateSegMapDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates the directory entry for the segment map.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directory entries created, always 1.

--*/

{
    OMFDirEntry   *omfDirEntry = (OMFDirEntry *) p->pCvCurr;

    omfDirEntry->SubSection = sstSegMap;
    omfDirEntry->iMod       = 0xffff;
    omfDirEntry->lfo        = (DWORD)p->pCvSegMap.ptr - (DWORD)p->pCvStart.ptr;
    omfDirEntry->cb         = p->pCvSegMap.size;

    p->pCvStart.size += sizeof(OMFDirEntry);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

    return 1;
}                               /* CreateSegMapDirectoryEntries() */

DWORD
CreateSrcModulesDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates directory entries for each source module in the image.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directory entries created.

--*/

{
    OMFDirEntry         *omfDirEntry = NULL;
    DWORD               i;
    DWORD               lfo = (DWORD)p->pCvSrcModules.ptr - (DWORD)p->pCvStart.ptr;
    DWORD               j = lfo;
    OMFSourceModule     *m;


    //
    // if there were no linenumber conversions then bail out
    //
    if (!p->pCvSrcModules.count) {
        return 0;
    }

    for (i=0; i<p->pCvSrcModules.count; i++) {

        if (!p->pMi[i].SrcModule) {
            continue;
        }

        omfDirEntry = (OMFDirEntry *) p->pCvCurr;

        omfDirEntry->SubSection = sstSrcModule;
        omfDirEntry->iMod = (USHORT) p->pMi[i].iMod;
        omfDirEntry->lfo = lfo;
        omfDirEntry->cb = p->pMi[i].cb;

        m = (OMFSourceModule*) p->pMi[i].SrcModule;

        lfo += omfDirEntry->cb;

        p->pCvStart.size += sizeof(OMFDirEntry);
        p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);
    }

    free( p->pMi );

    return p->pCvSrcModules.count;
}                               /* CreateSrcModulesDirectoryEntries() */


#define byt_toupper(b)      (b & 0xDF)
#define dwrd_toupper(dw)    (dw & 0xDFDFDFDF)

DWORD
DWordXorLrl( char *szSym )

/*++

Routine Description:

    This function will take an ascii character string and generate
    a hash for that string.  The hash algorithm is the CV NB09 hash
    algorithm.


Arguments:

    szSym    - a character pointer, the first char is the string length


Return Value:

    The generated hash value.

--*/

{
    char                *pName = szSym+1;
    int                 cb =  (int)(*szSym & 0x000000FF); // byte to int conversion.
    char                *pch;
    char                c;
    DWORD               hash = 0, ulEnd = 0;
    DWORD UNALIGNED     *pul;

    // Replace all "::" with "__" for hashing purposes

    c = *(pName+cb);
    *(pName+cb) = '\0';
    pch = strstr( pName, "::" );
    if ( pch ) {
        *pch++ = '_';
        *pch   = '_';
    }
    *(pName+cb) = c;

    // If we're standard call, skip the trailing @999

    pch = pName + cb - 1;
    while (isdigit(*pch)) {
        pch--;
    }

    if (*pch == '@') {
        cb = pch - pName;
    }

    // If we're fastcall, skip the leading '@'

    if (*pName == '@') {
        pName++;
        cb--;
    }

    // Calculate the odd byte hash.

    while (cb & 3) {
        ulEnd |= byt_toupper (pName[cb-1]);
        ulEnd <<=8;
        cb--;
    }

    pul = (DWORD UNALIGNED *)pName;

    // calculate the dword hash for the remaining

    while (cb) {
        hash ^= dwrd_toupper(*pul);
        hash = _lrotl (hash, 4);
        pul++;
        cb -=4;
    }

    // or in the remainder

    hash ^= ulEnd;

    return hash;
}                               /* DWordXorLrl() */


OMFModule *
NextMod(
        OMFModule *             pMod
        )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    char *      pb;

    pb = (char *) &(pMod->SegInfo[pMod->cSeg]);
    pb += *pb + 1;
    pb = (char *) (((unsigned long) pb + 3) & ~3);

    return (OMFModule *) pb;
}                               /* NextMod() */


int
__cdecl
SymHashCompare(
               const void *     arg1,
               const void *     arg2
               )
/*++

Routine Description:

    Sort compare function for sorting SYMHASH records by hashed
    bucket number.


Arguments:

    arg1     - record #1
    arg2     - record #2


Return Value:

   -1        - record #1 is < record #2
    0        - records are equal
    1        - record #1 is > record #2

--*/

{
    if (((SYMHASH*)arg1)->dwHashBucket < ((SYMHASH*)arg2)->dwHashBucket) {
        return -1;
    }
    if (((SYMHASH*)arg1)->dwHashBucket > ((SYMHASH*)arg2)->dwHashBucket) {
        return 1;
    }

    // BUGBUG: Should we second sort on the hash value?

    return 0;
}                               /* SymHashCompare() */

// Symbol Offset/Hash structure

typedef struct _SOH {
    DWORD uoff;
    DWORD ulHash;
} SOH;

#define MINHASH     6           // Don't create a hash with fewer than 6 slots

DWORD
CreateSymbolHashTable(
    PPOINTERS p
    )
/*++

Routine Description:

    Creates the CV symbol hash table.  This hash table is used
    primarily by debuggers to access symbols in a quick manner.

Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)

Return Value:

    The number of buckets is the hash table.

--*/
{
    DWORD           i;
    DWORD           j;
    int             k;
    DWORD           numsyms;
    DWORD           numbuckets;
    OMFSymHash      *omfSymHash;
    DATASYM32       *dataSymStart;
    DATASYM32       *dataSym;
    LPVOID          pHashData;
    USHORT          *pCHash;
    DWORD           *pHashTable;
    DWORD           *pBucketCounts;
    DWORD           *pChainTable;
    SYMHASH         *symHashStart;
    SYMHASH         *symHash;
//    DWORD           dwHashVal;
    char *          sz;

    numsyms = p->pCvPublics.count;
    numbuckets = (numsyms+9) / 10;
    numbuckets = (1 + numbuckets) & ~1;
    numbuckets = __max(numbuckets, MINHASH);

    symHashStart =
    symHash = (SYMHASH *) malloc( numsyms * sizeof(SYMHASH) );
    if (symHashStart == NULL) {
        return 0;
    }

    memset( symHashStart, 0, numsyms * sizeof(SYMHASH) );

    pHashData = (LPVOID) p->pCvCurr;
    pCHash = (USHORT *) pHashData;
    pHashTable = (DWORD *) ((DWORD)pHashData + sizeof(DWORD));
    pBucketCounts = (DWORD *) ((DWORD)pHashTable +
                                  (sizeof(DWORD) * numbuckets));
    memset(pBucketCounts, 0, sizeof(DWORD) * numbuckets);

    pChainTable = (DWORD *) ((DWORD)pBucketCounts +
                                 ((sizeof(ULONG) * numbuckets)));

    omfSymHash = (OMFSymHash *) p->pCvPublics.ptr;
    dataSymStart =
    dataSym = (DATASYM32 *) ((DWORD)omfSymHash + sizeof(OMFSymHash));

    *pCHash = (USHORT)numbuckets;

    /*
     *  cruise thru the symbols and calculate the hash values
     *  and the hash bucket numbers; save the info away for later use
     */
    for (i=0; i<numsyms; i++, symHash++) {
        switch( dataSym->rectyp ) {
        case S_PUB16:
            sz = dataSym->name;
            break;

        case S_PUB32:
            sz = ((DATASYM32 *) dataSym)->name;
            break;

        default:
            continue;
        }

        symHash->dwHashVal = DWordXorLrl( sz );
        symHash->dwHashBucket = symHash->dwHashVal % numbuckets;
        pBucketCounts[symHash->dwHashBucket] += 1;
        symHash->dataSym = dataSym;
        dataSym = ((DATASYM32 *) ((char *) dataSym + dataSym->reclen + 2));
    }

    qsort( (void*)symHashStart, numsyms, sizeof(SYMHASH), SymHashCompare );

    j = (char *)pChainTable - (char *)pHashData;
    for (i=0, k = 0;
         i < numbuckets;
         k += pBucketCounts[i], i += 1, pHashTable++ )
    {
        *pHashTable = (DWORD) j + (k * sizeof(DWORD) * 2);
    }

    dataSymStart = (DATASYM32 *) (PUCHAR)((DWORD)omfSymHash);
    for (i=0,symHash=symHashStart; i<numsyms; i++,symHash++,pChainTable++) {
        *pChainTable = (DWORD) (DWORD)symHash->dataSym - (DWORD)dataSymStart;
        ++pChainTable;
        *pChainTable = symHash->dwHashVal;
    }

    UpdatePtrs( p, &p->pCvSymHash, (LPVOID)pChainTable, numsyms );

    omfSymHash->symhash = 10;
    omfSymHash->cbHSym = p->pCvSymHash.size;

    free( symHashStart );

    return numbuckets;
}                               /* CreateSymbolHashTable() */

VOID
UpdatePtrs( PPOINTERS p, PPTRINFO pi, LPVOID lpv, DWORD count )

/*++

Routine Description:

    This function is called by ALL functions that put data into the
    CV data area.  After putting the data into the CV memory this function
    must be called.  It will adjust all of the necessary pointers so the
    the next guy doesn't get hosed.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)
    pi       - the CV pointer that is to be updated
    lpv      - current pointer into the CV data
    count    - the number of items that were placed into the CV data


Return Value:

    void

--*/

{
    if (!count) {
        return;
    }

    pi->ptr = p->pCvCurr;
    pi->size = (DWORD) ((DWORD)lpv - (DWORD)p->pCvCurr);
    pi->count = count;

    p->pCvStart.size += pi->size;
    p->pCvCurr = (PUCHAR) lpv;

    return;
}                               /* UpdatePtrs() */

int
__cdecl
OffsetSortCompare( const void *arg1, const void *arg2 )

/*++

Routine Description:

    Sort compare function for sorting OFFETSORT records by section number.


Arguments:

    arg1     - record #1
    arg2     - record #2


Return Value:

   -1        - record #1 is < record #2
    0        - records are equal
    1        - record #1 is > record #2

--*/

{
    if (((OFFSETSORT*)arg1)->dwSection < ((OFFSETSORT*)arg2)->dwSection) {
        return -1;
    }
    if (((OFFSETSORT*)arg1)->dwSection > ((OFFSETSORT*)arg2)->dwSection) {
        return 1;
    }
    if (((OFFSETSORT*)arg1)->dwOffset < ((OFFSETSORT*)arg2)->dwOffset) {
        return -1;
    }
    if (((OFFSETSORT*)arg1)->dwOffset > ((OFFSETSORT*)arg2)->dwOffset) {
        return 1;
    }
    return 0;
}                               /* OffsetSortCompare() */

DWORD
CreateAddressSortTable( PPOINTERS p )

/*++

Routine Description:


    Creates the CV address sort table. This hash table is used
    primarily by debuggers to access symbols in a quick manner when
    all you have is an address.

Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    The number of sections in the table.

--*/

{
    DWORD               i;
    DWORD               j;
    int                 k;
    DWORD               numsyms = p->pCvPublics.count;
    DWORD               numsections;
    OMFSymHash          *omfSymHash;
    DATASYM32           *dataSymStart;
    DATASYM32           *dataSym;
    LPVOID              pAddressData;
    USHORT              *pCSeg;
    DWORD               *pSegTable;
    DWORD               *pOffsetCounts;
    DWORD               *pOffsetTable;
    OFFSETSORT          *pOffsetSortStart;
    OFFSETSORT          *pOffsetSort;

    extern int          CSymSegs;

    if (p->iptrs.fileHdr) {
        numsections = p->iptrs.fileHdr->NumberOfSections;
    } else if (p->iptrs.sepHdr) {
        numsections = p->iptrs.sepHdr->NumberOfSections;
    } else {
        numsections = CSymSegs;
    }

    pOffsetSortStart =
      pOffsetSort = (OFFSETSORT *) malloc( numsyms * sizeof(OFFSETSORT) );

    if (pOffsetSort == NULL) {
        return 0;
    }

    memset( pOffsetSortStart, 0, numsyms * sizeof(OFFSETSORT) );

    pAddressData = (LPVOID) p->pCvCurr;
    pCSeg = (USHORT *) pAddressData;
    pSegTable = (DWORD *) ((DWORD)pAddressData + sizeof(DWORD));
    pOffsetCounts = (DWORD *) ((DWORD)pSegTable +
                                (sizeof(DWORD) * numsections));
    pOffsetTable = (DWORD *) ((DWORD)pOffsetCounts +
                              ((sizeof(DWORD) * numsections)));
//    if (numsections & 1) {
//        pOffsetTable = (DWORD *) ((DWORD)pOffsetTable + 2);
//    }

    omfSymHash = (OMFSymHash *) p->pCvPublics.ptr;
    dataSymStart =
      dataSym = (DATASYM32 *) ((DWORD)omfSymHash + sizeof(OMFSymHash));

    *pCSeg = (USHORT)numsections;

    for (i=0;
         i<numsyms;
         i++, pOffsetSort++)
    {
        switch(dataSym->rectyp) {
        case S_PUB16:
            pOffsetSort->dwOffset = dataSym->off;
            pOffsetSort->dwSection = dataSym->seg;
            break;

        case S_PUB32:
            pOffsetSort->dwOffset = ((DATASYM32 *) dataSym)->off;
            pOffsetSort->dwSection = ((DATASYM32 *) dataSym)->seg;
        }

        pOffsetSort->dataSym = dataSym;
        pOffsetCounts[pOffsetSort->dwSection - 1] += 1;
        dataSym = ((DATASYM32 *) ((char *) dataSym + dataSym->reclen + 2));    }

//#if 0
    qsort((void*)pOffsetSortStart, numsyms, sizeof(OFFSETSORT), OffsetSortCompare );
//#endif

    j = (DWORD) (DWORD)pOffsetTable - (DWORD)pAddressData;
    for (i=0, k=0;
         i < numsections;
         k += pOffsetCounts[i], i += 1, pSegTable++)
    {
        *pSegTable = (DWORD) j + (k * sizeof(DWORD) * 2);
    }

    dataSymStart = (DATASYM32 *) (PUCHAR)((DWORD)omfSymHash);
    for (i=0, pOffsetSort=pOffsetSortStart;
         i < numsyms;
         i++, pOffsetSort++, pOffsetTable++)
    {
        *pOffsetTable = (DWORD)pOffsetSort->dataSym - (DWORD)dataSymStart;
        pOffsetTable++;
        *pOffsetTable = pOffsetSort->dwOffset;
    }

    UpdatePtrs( p, &p->pCvAddrSort, (LPVOID)pOffsetTable, numsyms );

    omfSymHash->addrhash = 12;
    omfSymHash->cbHAddr = p->pCvAddrSort.size;

    free( pOffsetSortStart );

    return numsections;
}                               /* CreateAddressSort() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\symcvt\cofftocv.c ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    cv.c

Abstract:

    This module handles the conversion activities requires for converting
    COFF debug data to CODEVIEW debug data.

Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <imagehlp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "cv.h"
#define _SYMCVT_SOURCE_
#include "symcvt.h"
#include "cvcommon.h"

typedef struct tagOFFSETSORT {
    DWORD       dwOffset;          // offset for the symbol
    DWORD       dwSection;         // section number of the symbol
    DATASYM32   *dataSym;          // pointer to the symbol info
} OFFSETSORT;


#define n_name          N.ShortName
#define n_zeroes        N.Name.Short
#define n_nptr          N.LongName[1]
#define n_offset        N.Name.Long

static LPSTR GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable, char *s );
DWORD  CreateModulesFromCoff( PPOINTERS p );
DWORD  CreatePublicsFromCoff( PPOINTERS p );
DWORD  CreateSegMapFromCoff( PPOINTERS p );
DWORD  CreateSrcLinenumbers( PPOINTERS p );



LONG
GuardPageFilterFunction(
    DWORD                ec,
    LPEXCEPTION_POINTERS lpep
    )

/*++

Routine Description:

    This function catches all exceptions from the convertcofftocv function
    and all that it calls.  The purpose of this function is allocate memory
    when it is necessary.  This happens because the cofftocv conversion cannot
    estimate the memory requirements before the conversion takes place.  To
    handle this properly space in the virtual address space is reserved, the
    reservation amount is 10 times the image size.  The first page is commited
    and then the conversion is started.  When an access violation occurs and the
    page that is trying to be access has a protection of noaccess then the
    page is committed.  Any other exception is not handled.

Arguments:

    ec      - the ecxeption code (should be EXCEPTION_ACCESS_VIOLATION)
    lpep    - pointer to the exception record and context record


Return Value:

    EXCEPTION_CONTINUE_EXECUTION    - access violation handled
    EXCEPTION_EXECUTE_HANDLER       - unknown exception and is not handled

--*/

{
    LPVOID                      vaddr;
    SYSTEM_INFO                 si;
    MEMORY_BASIC_INFORMATION    mbi;


    if (ec == EXCEPTION_ACCESS_VIOLATION) {
        vaddr = (LPVOID)lpep->ExceptionRecord->ExceptionInformation[1];
        VirtualQuery( vaddr, &mbi, sizeof(mbi) );
        if (mbi.AllocationProtect == PAGE_NOACCESS) {
            GetSystemInfo( &si );
            VirtualAlloc( vaddr, si.dwPageSize, MEM_COMMIT, PAGE_READWRITE );
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

//  return EXCEPTION_CONTINUE_SEARCH;
    return EXCEPTION_EXECUTE_HANDLER;
}


BOOL
ConvertCoffToCv( PPOINTERS p )

/*++

Routine Description:

    This is the control function for the conversion of COFF to CODEVIEW
    debug data.  It calls individual functions for the conversion of
    specific types of debug data.


Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    TRUE     - conversion succeded
    FALSE    - conversion failed

--*/

{
    SYSTEM_INFO                 si;
    DWORD                       cbsize;
    BOOL                        rval = TRUE;


    GetSystemInfo( &si );
    cbsize = max( p->iptrs.fsize * 10, si.dwPageSize * 10 );

    //
    // reserve all necessary pages
    //
    p->pCvCurr = p->pCvStart.ptr = VirtualAlloc( NULL, cbsize, MEM_RESERVE, PAGE_NOACCESS );

    //
    // commit the first pages
    //
    VirtualAlloc( p->pCvCurr, min( cbsize, 5 * si.dwPageSize), MEM_COMMIT, PAGE_READWRITE );


    try {

        CreateSignature( p );
        CreateModulesFromCoff( p );
        CreatePublicsFromCoff( p );
        CreateSymbolHashTable( p );
        CreateAddressSortTable( p );
        CreateSegMapFromCoff( p );
//      CreateSrcLinenumbers( p );
        CreateDirectories( p );

    } except ( GuardPageFilterFunction( GetExceptionCode(), GetExceptionInformation() )) {

        VirtualFree( p->pCvStart.ptr, cbsize, MEM_DECOMMIT );
        p->pCvStart.ptr = NULL;
        rval = FALSE;

    }

    if (rval) {
        p->pCvCurr = malloc( p->pCvStart.size );
        CopyMemory( p->pCvCurr, p->pCvStart.ptr, p->pCvStart.size );
        VirtualFree( p->pCvStart.ptr, cbsize, MEM_DECOMMIT );
        p->pCvStart.ptr = p->pCvCurr;
    }

    return rval;
}


DWORD
CreateModulesFromCoff( PPOINTERS p )

/*++

Routine Description:

    Creates the individual CV module records.  There is one CV module
    record for each .FILE record in the COFF debug data.  This is true
    even if the COFF size is zero.


Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    The number of modules that were created.

--*/

{
    int                 i,j;
    DWORD               dwOff;
    DWORD               numaux;
    DWORD               nummods = 0;
    char                szSymName[256];
    PIMAGE_SYMBOL       Symbol;
    PIMAGE_AUX_SYMBOL   AuxSymbol;
    OMFModule           *m = NULL;
    int                 cSeg = 0;
    char *              pb;
    BOOLEAN             rgfCode[500];


    memset(rgfCode, 2, sizeof(rgfCode));

    for (i=0,j=0, Symbol=p->iptrs.AllSymbols;
         i<(int)p->iptrs.numberOfSymbols;
         i+=numaux+1,Symbol+=numaux+1) {

        numaux = Symbol->NumberOfAuxSymbols;
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {
            j++;
        }

    }

    p->pMi = (LPMODULEINFO) malloc( sizeof(MODULEINFO) * (j + 1) );
    ZeroMemory( p->pMi, sizeof(MODULEINFO) * (j + 1) );


    if (!j) {
        //
        //  Handle the situation where there are not any .file records in the
        //  COFF symbol table.  This can happen for ROM images.  If this happens
        //  then we will fabricate a bogus module.
        //
        m = (OMFModule *) p->pCvCurr;
        m->ovlNumber = 0;
        m->iLib = 0;
        m->Style[0] = 'C';
        m->Style[1] = 'V';

        for (i=0,j=0, dwOff=0; i<p->iptrs.numberOfSections; i++) {
            if (p->iptrs.sectionHdrs[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) {
                m->SegInfo[j].Seg = i + 1;
                m->SegInfo[j].cbSeg = p->iptrs.sectionHdrs[i].SizeOfRawData;
                m->SegInfo[j++].Off = dwOff;
            }
            dwOff += p->iptrs.sectionHdrs[i].SizeOfRawData;
        }

        m->cSeg = (unsigned short) j;

        strcpy(szSymName,"foo.c");
        pb = (char *) &m->SegInfo[j];
        *pb = (char)strlen(szSymName);
        memcpy(pb+1, szSymName, *pb);

        p->pMi[0].name = _strdup(szSymName);
        p->pMi[0].iMod = 1;
        p->pMi[0].cb = 0;
        p->pMi[0].SrcModule = 0;

        m = NextMod(m);
        p->modcnt = 1;
        UpdatePtrs( p, &p->pCvModules, (LPVOID)m, 1 );

        return 1;
    }


    for (i=0, Symbol = p->iptrs.AllSymbols;
         i < (int) p->iptrs.numberOfSymbols;
         i += numaux + 1, Symbol += numaux + 1) {

        //
        // Get the number of aux symbol records for this symbol
        //
        numaux = Symbol->NumberOfAuxSymbols;
        AuxSymbol = (PIMAGE_AUX_SYMBOL) (Symbol+1);

        if ((i == 0) && ((Symbol+numaux+1)->StorageClass != IMAGE_SYM_CLASS_FILE)) {
            //
            // we have a situation where the first '.file' record
            // is missing.  currently this only happens with the
            // claxp compiler on alpha.
            //
            m = (OMFModule *) p->pCvCurr;
            cSeg = 0;
            m->ovlNumber = 0;
            m->iLib = 0;
            m->Style[0] = 'C';
            m->Style[1] = 'V';
            strcpy( szSymName, "fake.c" );
        } else

        //
        //  If this is a FILE record -- then we need to create a
        //      module item to correspond to this file record.
        //

        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {
            if (m == NULL) {
                m = (OMFModule *) p->pCvCurr;
            } else {
                //
                //      Clean up the last item,  if we saw any
                //      section records then drop them in here
                //

                if (cSeg > 0) {
                    m->cSeg  = (unsigned short) cSeg;
                    pb = (char *) &m->SegInfo[cSeg];
                    *pb = (char)strlen(szSymName);
                    memcpy(pb+1, szSymName, *pb);

                    p->pMi[nummods].name = _strdup(szSymName);
                    p->pMi[nummods].iMod = nummods + 1;
                    p->pMi[nummods].cb = 0;
                    p->pMi[nummods].SrcModule = 0;

                    m = NextMod(m);
                    nummods++;
                }
            }

            cSeg = 0;
            m->ovlNumber        = 0;
            m->iLib             = 0;
            m->Style[0]         = 'C';
            m->Style[1]         = 'V';

            /*
             *  Save off the file name to use when we have finished
             *  processing this module
             */

            memcpy(szSymName, (char *)AuxSymbol, numaux*sizeof(IMAGE_AUX_SYMBOL));
            szSymName[numaux*sizeof(IMAGE_AUX_SYMBOL)] = 0;

        }
        /*
         *  We have found a "SECTION" record.  Add the info to the
         *      module record
         */
        else
        if ((Symbol->SectionNumber & 0xffff) > 0xfff0) {
            continue;
        } else
        if (Symbol->SectionNumber > sizeof(rgfCode)/sizeof(rgfCode[0])) {
            return 0;
        } else
        if ((m != NULL) &&
            (rgfCode[Symbol->SectionNumber] != 0) &&
            (Symbol->StorageClass == IMAGE_SYM_CLASS_STATIC) &&
            ((*Symbol->n_name == '.') ||
             (Symbol->Type == IMAGE_SYM_TYPE_NULL)) &&
            (Symbol->NumberOfAuxSymbols == 1) &&
            (AuxSymbol->Section.Length != 0)) {

            if (rgfCode[Symbol->SectionNumber] == 2) {
                if ((p->iptrs.sectionHdrs[Symbol->SectionNumber - 1].
                    Characteristics & IMAGE_SCN_CNT_CODE) == 0) {
                    rgfCode[Symbol->SectionNumber] = 0;
                    continue;
                }
                rgfCode[Symbol->SectionNumber] = 1;
            }

            m->SegInfo[cSeg].Seg = Symbol->SectionNumber;
            m->SegInfo[cSeg].cbSeg = AuxSymbol->Section.Length;
            m->SegInfo[cSeg].Off = Symbol->Value -
                     p->iptrs.sectionHdrs[Symbol->SectionNumber-1].
                       VirtualAddress;
            cSeg += 1;
        }
    }

    /*
     *  Wrap up the last possible open module record
     */

    if (m != NULL) {
        if (cSeg > 0) {
            m->cSeg             = (unsigned short) cSeg;
            pb = (char *) &m->SegInfo[cSeg];
            *pb = (char)strlen(szSymName);
            memcpy(pb+1, szSymName, *pb);

            p->pMi[nummods].name = _strdup(szSymName);
            p->pMi[nummods].iMod = nummods + 1;
            p->pMi[nummods].cb = 0;
            p->pMi[nummods].SrcModule = 0;

            m = NextMod(m);
            nummods++;
        }
    }


    p->modcnt = nummods;
    UpdatePtrs( p, &p->pCvModules, (LPVOID)m, nummods );

    return nummods;
}


DWORD
CreatePublicsFromCoff( PPOINTERS p )

/*++

Routine Description:

    Creates the individual CV public symbol records.  There is one CV
    public record created for each COFF symbol that is marked as EXTERNAL
    and has a section number greater than zero.  The resulting CV publics
    are sorted by section and offset.


Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    The number of publics created.

--*/

{
    int                 i;
    DWORD               numaux;
    DWORD               numsyms = 0;
    char                szSymName[256];
    PIMAGE_SYMBOL       Symbol;
    OMFSymHash          *omfSymHash;
    DATASYM32           *dataSym;
    DATASYM32           *dataSym2;

    omfSymHash = (OMFSymHash *) p->pCvCurr;
    dataSym = (DATASYM32 *) (PUCHAR)((DWORD)omfSymHash + sizeof(OMFSymHash));

    for (i= 0, Symbol = p->iptrs.AllSymbols;
         i < p->iptrs.numberOfSymbols;
         i += numaux + 1, Symbol += numaux + 1) {

        if ((Symbol->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) &&
            (Symbol->SectionNumber > 0)) {

            if (GetSymName( Symbol, p->iptrs.stringTable, szSymName )) {
                dataSym->rectyp = S_PUB32;
                dataSym->seg = Symbol->SectionNumber;
                dataSym->off = Symbol->Value -
                     p->iptrs.sectionHdrs[Symbol->SectionNumber-1].VirtualAddress;
                dataSym->typind = 0;
                dataSym->name[0] = (char)strlen( szSymName );
                strcpy( &dataSym->name[1], szSymName );
                dataSym2 = NextSym32( dataSym );
                dataSym->reclen = (USHORT) ((DWORD)dataSym2 - (DWORD)dataSym) - 2;
                dataSym = dataSym2;
                numsyms += 1;
            }
        }
        numaux = Symbol->NumberOfAuxSymbols;
    }

    UpdatePtrs( p, &p->pCvPublics, (LPVOID)dataSym, numsyms );

    omfSymHash->cbSymbol = p->pCvPublics.size - sizeof(OMFSymHash);
    omfSymHash->symhash  = 0;
    omfSymHash->addrhash = 0;
    omfSymHash->cbHSym   = 0;
    omfSymHash->cbHAddr  = 0;

    return numsyms;
}                               /* CreatePublisFromCoff() */


DWORD
CreateSrcLinenumbers(
    PPOINTERS p
    )

/*++

Routine Description:

    Creates the individual CV soure line number records.


Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    The number of publics created.

--*/

{
    typedef struct _SEGINFO {
        DWORD   start;
        DWORD   end;
        DWORD   cbLines;
        DWORD   ptrLines;
        DWORD   va;
        DWORD   num;
        BOOL    used;
    } SEGINFO, *LPSEGINFO;

    typedef struct _SRCINFO {
        LPSEGINFO   seg;
        DWORD       numSeg;
        DWORD       cbSeg;
        CHAR        name[MAX_PATH+1];
    } SRCINFO, *LPSRCINFO;

    typedef struct _SECTINFO {
        DWORD       va;
        DWORD       size;
        DWORD       ptrLines;
        DWORD       numLines;
    } SECTINFO, *LPSECTINFO;


    DWORD               i;
    DWORD               j;
    DWORD               k;
    DWORD               l;
    DWORD               actual;
    DWORD               sidx;
    DWORD               NumSrcFiles;
    DWORD               SrcFileCnt;
    DWORD               numaux;
    PIMAGE_SYMBOL       Symbol;
    PIMAGE_AUX_SYMBOL   AuxSymbol;
    BOOL                first = TRUE;
    OMFSourceModule     *SrcModule;
    OMFSourceFile       *SrcFile;
    OMFSourceLine       *SrcLine;
    LPBYTE              lpb;
    LPDWORD             lpdw;
    PUSHORT             lps;
    PUCHAR              lpc;
    PIMAGE_LINENUMBER   pil, pilSave;
    LPSRCINFO           si;
    LPSECTINFO          sections;


    //
    // setup the section info structure
    //
    sections = (LPSECTINFO) malloc( sizeof(SECTINFO) * p->iptrs.numberOfSections );
    for (i=0; i<(DWORD)p->iptrs.numberOfSections; i++) {
        sections[i].va        = p->iptrs.sectionHdrs[i].VirtualAddress;
        sections[i].size      = p->iptrs.sectionHdrs[i].SizeOfRawData;
        sections[i].ptrLines  = p->iptrs.sectionHdrs[i].PointerToLinenumbers;
        sections[i].numLines  = p->iptrs.sectionHdrs[i].NumberOfLinenumbers;
    }

    //
    // count the number of source files that contibute linenumbers
    //
    SrcFileCnt = 100;
    si = (LPSRCINFO) malloc( sizeof(SRCINFO) * SrcFileCnt );
    ZeroMemory( si, sizeof(SRCINFO) * SrcFileCnt );
    for (i=0, j=0, Symbol=p->iptrs.AllSymbols, NumSrcFiles=0;
         i<(DWORD)p->iptrs.numberOfSymbols;
         i+=(numaux+1), Symbol+=(numaux + 1)) {

        numaux = Symbol->NumberOfAuxSymbols;
        AuxSymbol = (PIMAGE_AUX_SYMBOL) (Symbol+1);

        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {

            if (!first) {
                si[NumSrcFiles].cbSeg = j;
                NumSrcFiles++;
                if (NumSrcFiles == SrcFileCnt) {
                    SrcFileCnt += 100;
                    si = (LPSRCINFO) realloc( si, sizeof(SRCINFO) * SrcFileCnt );
                }
            }

            memcpy(si[NumSrcFiles].name, (char *)AuxSymbol, numaux*sizeof(IMAGE_AUX_SYMBOL));
            si[NumSrcFiles].name[numaux*sizeof(IMAGE_AUX_SYMBOL)] = 0;
            si[NumSrcFiles].numSeg = 100;
            si[NumSrcFiles].seg = (LPSEGINFO) malloc( sizeof(SEGINFO) * si[NumSrcFiles].numSeg );
            ZeroMemory( si[NumSrcFiles].seg, sizeof(SEGINFO) * si[NumSrcFiles].numSeg );
            first = FALSE;
            j = 0;

        }

        //
        // we do not want to look for segment information until we
        // have found a valid source file
        //
        if (first) {
            continue;
        }

        //
        // check the symbol to see if it is a segment record
        //
        if (numaux && Symbol->StorageClass == IMAGE_SYM_CLASS_STATIC &&
            (*Symbol->n_name == '.' ||
             ((Symbol->Type & 0xf) == IMAGE_SYM_TYPE_NULL && AuxSymbol->Section.Length)) &&
            AuxSymbol->Section.NumberOfLinenumbers > 0) {

            //
            // find the section that this symbol belongs to
            //
            for (k=0; k<(DWORD)p->iptrs.numberOfSections; k++) {
                if (Symbol->Value >= sections[k].va &&
                    Symbol->Value < sections[k].va + sections[k].size) {

                    sidx = k;
                    break;

                }
            }

            if (k != (DWORD)p->iptrs.numberOfSections &&
                p->iptrs.sectionHdrs[k].NumberOfLinenumbers) {

                pil = (PIMAGE_LINENUMBER) (p->iptrs.fptr + sections[sidx].ptrLines);
                k = 0;

                while( k < AuxSymbol->Section.NumberOfLinenumbers ) {

                    //
                    // count the linenumbers in this section or sub-section
                    //
                    for ( pilSave=pil,l=0;
                          k<AuxSymbol->Section.NumberOfLinenumbers;
                          k++,pilSave++,l++ ) {

                        if ((k != (DWORD)AuxSymbol->Section.NumberOfLinenumbers-1) &&
                            (pilSave->Linenumber > (pilSave+1)->Linenumber)) {
                            pilSave++;
                            l++;
                            break;
                        }

                    }

                    //
                    // pil     == beginning of the range
                    // pilSave == end of the range
                    //

                    si[NumSrcFiles].seg[j].start =
                                     (pil->Type.VirtualAddress - sections[sidx].va);

                    if (sections[sidx].numLines == l) {
                        pilSave--;
                        si[NumSrcFiles].seg[j].end =
                                     (pilSave->Type.VirtualAddress - sections[sidx].va) + 1;
//                                   (Symbol->Value - sections[sidx].va) + 1;
                    } else {
                        si[NumSrcFiles].seg[j].end =
                                     (pilSave->Type.VirtualAddress - sections[sidx].va) - 1;
//                                   (Symbol->Value - sections[sidx].va) - 1;
                    }

                    si[NumSrcFiles].seg[j].ptrLines = sections[sidx].ptrLines;
                    si[NumSrcFiles].seg[j].cbLines = l;
                    si[NumSrcFiles].seg[j].va = sections[sidx].va;
                    si[NumSrcFiles].seg[j].num = sidx + 1;
                    si[NumSrcFiles].seg[j].used = FALSE;

                    sections[sidx].ptrLines += (l * sizeof(IMAGE_LINENUMBER));
                    sections[sidx].numLines -= l;

                    j++;
                    if (j == si[NumSrcFiles].numSeg) {
                        si[NumSrcFiles].numSeg += 100;
                        si[NumSrcFiles].seg = (LPSEGINFO) realloc( si[NumSrcFiles].seg, sizeof(SEGINFO) * si[NumSrcFiles].numSeg );
                    }
                    k++;
                    pil = pilSave;
                }

            }

        }

    }

    lpb = (LPBYTE) p->pCvCurr;

    //
    // if there is nothing to do then bail out
    //
    if (!NumSrcFiles) {
        UpdatePtrs( p, &p->pCvSrcModules, (LPVOID)lpb, 0 );
        return 0;
    }

    for (i=0,actual=0,l=0; i<NumSrcFiles; i++) {

        if (si[i].cbSeg == 0) {
            continue;
        }

        //
        // create the source module header
        //
        SrcModule = (OMFSourceModule*) lpb;
        SrcModule->cFile = 1;
        SrcModule->cSeg = (USHORT)si[i].cbSeg;
        SrcModule->baseSrcFile[0] = 0;

        //
        // write the start/end pairs
        //
        lpdw = (LPDWORD) ((LPBYTE)SrcModule + sizeof(OMFSourceModule));
        for (k=0; k<si[i].cbSeg; k++) {
            *lpdw++ = si[i].seg[k].start;
            *lpdw++ = si[i].seg[k].end;
        }

        //
        // write the segment numbers
        //
        lps = (PUSHORT) lpdw;
        for (k=0; k<si[i].cbSeg; k++) {
            *lps++ = (USHORT)si[i].seg[k].num;
        }

        //
        // align to a dword boundry
        //
        lps = (PUSHORT) ((LPBYTE)lps + align(lps));

        //
        // update the base pointer
        //
        SrcModule->baseSrcFile[0] = (DWORD) ((LPBYTE)lps - (LPBYTE)SrcModule);

        //
        // write the source file record
        //
        SrcFile = (OMFSourceFile*) lps;
        SrcFile->cSeg = (USHORT)si[i].cbSeg;
        SrcFile->reserved = 0;

        for (k=0; k<si[i].cbSeg; k++) {
            SrcFile->baseSrcLn[k] = 0;
        }

        //
        // write the start/end pairs
        //
        lpdw = (LPDWORD) ((LPBYTE)SrcFile + 4 + (4 * si[i].cbSeg));
        for (k=0; k<si[i].cbSeg; k++) {
            *lpdw++ = si[i].seg[k].start;
            *lpdw++ = si[i].seg[k].end;
        }

        //
        // write the source file name
        //
        lpc = (PUCHAR) lpdw;
        k = strlen(si[i].name);
        *lpc++ = (UCHAR) k;
        strcpy( lpc, si[i].name );
        lpb = lpc + k;

        //
        // find the module info struct
        //
        for (; l<p->modcnt; l++) {
            if (_stricmp(p->pMi[l].name,si[i].name)==0) {
                break;
            }
        }

        p->pMi[l].SrcModule = (DWORD) SrcModule;

        //
        // align to a dword boundry
        //
        lpb = (LPBYTE) (lpb + align(lpb));

        //
        // create the line number pairs
        //
        for (k=0; k<si[i].cbSeg; k++) {

            //
            // find the first line number that applies to this segment
            //
            pil = (PIMAGE_LINENUMBER) (p->iptrs.fptr + si[i].seg[k].ptrLines);

            //
            // update the base pointer
            //
            SrcFile->baseSrcLn[k] = (DWORD) (lpb - (LPBYTE)SrcModule);

            //
            // write the line numbers
            //
            SrcLine = (OMFSourceLine*) lpb;
            SrcLine->Seg = (USHORT)si[i].seg[k].num;
            SrcLine->cLnOff = (USHORT) si[i].seg[k].cbLines;
            pilSave = pil;
            lpdw = (LPDWORD) (lpb + 4);
            for (j=0; j<SrcLine->cLnOff; j++) {
                *lpdw++ = pil->Type.VirtualAddress - si[i].seg[k].va;
                pil++;
            }
            lps = (PUSHORT) lpdw;
            pil = pilSave;
            for (j=0; j<SrcLine->cLnOff; j++) {
                *lps++ = pil->Linenumber;
                pil++;
            }

            //
            // align to a dword boundry
            //
            lps = (PUSHORT) ((LPBYTE)lps + align(lps));

            lpb = (LPBYTE) lps;
        }

        p->pMi[l].cb = (DWORD)lpb - (DWORD)SrcModule;
        actual++;

    }

    UpdatePtrs( p, &p->pCvSrcModules, (LPVOID)lpb, actual );

    //
    // cleanup all allocated memory
    //

    free( sections );

    for (i=0; i<SrcFileCnt; i++) {
        if (si[i].seg) {
            free( si[i].seg );
        }
    }

    free( si );

    return NumSrcFiles;
}                               /* CreateSrcLinenumbers() */


DWORD
CreateSegMapFromCoff( PPOINTERS p )

/*++

Routine Description:

    Creates the CV segment map.  The segment map is used by debuggers
    to aid in address lookups.  One segment is created for each COFF
    section in the image.

Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    The number of segments in the map.

--*/

{
    int                         i;
    SGM                         *sgm;
    SGI                         *sgi;
    PIMAGE_SECTION_HEADER       sh;


    sgm = (SGM *) p->pCvCurr;
    sgi = (SGI *) ((DWORD)p->pCvCurr + sizeof(SGM));

    sgm->cSeg = (unsigned short) p->iptrs.numberOfSections;
    sgm->cSegLog = (unsigned short) p->iptrs.numberOfSections;

    sh = p->iptrs.sectionHdrs;

    for (i=0; i<p->iptrs.numberOfSections; i++, sh++) {
        sgi->sgf.fRead        = (USHORT) (sh->Characteristics & IMAGE_SCN_MEM_READ) ==    IMAGE_SCN_MEM_READ;
        sgi->sgf.fWrite       = (USHORT) (sh->Characteristics & IMAGE_SCN_MEM_WRITE) ==   IMAGE_SCN_MEM_WRITE;
        sgi->sgf.fExecute     = (USHORT) (sh->Characteristics & IMAGE_SCN_MEM_EXECUTE) == IMAGE_SCN_MEM_EXECUTE;
        sgi->sgf.f32Bit       = 1;
        sgi->sgf.fSel         = 0;
        sgi->sgf.fAbs         = 0;
        sgi->sgf.fGroup       = 1;
        sgi->iovl             = 0;
        sgi->igr              = 0;
        sgi->isgPhy           = (USHORT) i + 1;
        sgi->isegName         = 0;
        sgi->iclassName       = 0;
        sgi->doffseg          = 0;
        sgi->cbSeg            = sh->SizeOfRawData;
        sgi++;
    }

    UpdatePtrs( p, &p->pCvSegMap, (LPVOID)sgi, i );

    return i;
}


LPSTR
GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable, char *s )

/*++

Routine Description:

    Extracts the COFF symbol from the image symbol pointer and puts
    the ascii text in the character pointer passed in.


Arguments:

    Symbol        - COFF Symbol Record
    StringTable   - COFF string table
    s             - buffer for the symbol string


Return Value:

    void

--*/

{
    DWORD i;

    if (Symbol->n_zeroes) {
        for (i=0; i<8; i++) {
            if ((Symbol->n_name[i]>0x1f) && (Symbol->n_name[i]<0x7f)) {
                *s++ = Symbol->n_name[i];
            }
        }
        *s = 0;
    }
    else {
        if (StringTable[Symbol->n_offset] == '?') {
            i = UnDecorateSymbolName( &StringTable[Symbol->n_offset],
                                  s,
                                  255,
                                  UNDNAME_COMPLETE                |
                                  UNDNAME_NO_LEADING_UNDERSCORES  |
                                  UNDNAME_NO_MS_KEYWORDS          |
                                  UNDNAME_NO_FUNCTION_RETURNS     |
                                  UNDNAME_NO_ALLOCATION_MODEL     |
                                  UNDNAME_NO_ALLOCATION_LANGUAGE  |
                                  UNDNAME_NO_MS_THISTYPE          |
                                  UNDNAME_NO_CV_THISTYPE          |
                                  UNDNAME_NO_THISTYPE             |
                                  UNDNAME_NO_ACCESS_SPECIFIERS    |
                                  UNDNAME_NO_THROW_SIGNATURES     |
                                  UNDNAME_NO_MEMBER_TYPE          |
                                  UNDNAME_NO_RETURN_UDT_MODEL     |
                                  UNDNAME_NO_ARGUMENTS            |
                                  UNDNAME_NO_SPECIAL_SYMS         |
                                  UNDNAME_NAME_ONLY
                                );
            if (!i) {
                return NULL;
            }
        } else {
            strcpy( s, &StringTable[Symbol->n_offset] );
        }
    }

    return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\symedit\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\matchsym\symdef.h ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    symdef.h

Abstract:
    SYM file structures header

Revision History:

    Brijesh Krishnaswami (brijeshk) - 04/29/99 - Created
********************************************************************/

#ifndef _SYMDEF_H
#define _SYMDEF_H





#define MAX_PATH    260
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


// SYM File Structures

#pragma pack(1)                     // pack all data structures declared here 


// For each map within a symbol file (MAPDEF)

struct mapdef_s {
    unsigned short md_spmap;        // 16 bit SEG ptr to next map (0 if end) 
    unsigned char  md_abstype;      //  8 bit map/abs sym flags 
    unsigned char  md_pad;          //  8 bit pad 
    unsigned short md_segentry;     // 16 bit entry point segment value 
    unsigned short md_cabs;         // 16 bit count of constants in map 
    unsigned short md_pabsoff;      // 16 bit ptr to constant offsets 
    unsigned short md_cseg;         // 16 bit count of segments in map 
    unsigned short md_spseg;        // 16 bit SEG ptr to segment chain 
    unsigned char  md_cbnamemax;    //  8 bit maximum symbol name length 
    unsigned char  md_cbname;       //  8 bit symbol table name length 
    unsigned char  md_achname[1];   // <n> name of symbol table (.sym ) 
};

//#define CBMAPDEF    FIELDOFFSET(struct mapdef_s, md_achname)

struct endmap_s {
    unsigned short em_spmap;        // end of map chain (SEG ptr 0) 
    unsigned char  em_rel;          // release 
    unsigned char  em_ver;          // version 
};




// For each segment/group within a symbol table: (SEGDEF)


struct segdef_s {
    unsigned short gd_spsegnext;    // 16 bit SEG ptr to next segdef (0 if end),
                                    //  relative to mapdef 
    unsigned short gd_csym;         // 16 bit count of symbols in sym list 
    unsigned short gd_psymoff;      // 16 bit ptr to symbol offsets array,
                                    // 16 bit SEG ptr if MSF_BIG_GROUP set,
                                    //  either relative to segdef 
    unsigned short gd_lsa;          // 16 bit Load Segment address 
    unsigned short gd_in0;          // 16 bit instance 0 physical address 
    unsigned short gd_in1;          // 16 bit instance 1 physical address 
    unsigned short gd_in2;          // 16 bit instance 2 physical address 
    unsigned char  gd_type;         // 16 or 32 bit symbols in group 
    unsigned char  gd_pad;          // pad byte to fill space for gd_in3 
    unsigned short gd_spline;       // 16 bit SEG ptr to linedef,
                                    //  relative to mapdef 
    unsigned char  gd_fload;        // 8 bit boolean 0 if seg not loaded 
    unsigned char  gd_curin;        // 8 bit current instance 
    unsigned char  gd_cbname;       // 8 bit Segment name length 
    unsigned char  gd_achname[1];   // <n>  name of segment or group 
};

// values for md_abstype, gd_type 
#define MSF_32BITSYMS   0x01        // 32-bit symbols 
#define MSF_ALPHASYMS   0x02        // symbols sorted alphabetically, too 


// values for gd_type only 
#define MSF_BIGSYMDEF   0x04        // bigger than 64K of symdefs 


// values for md_abstype only 
#define MSF_ALIGN32 0x10            // 2MEG max symbol file, 32 byte alignment 
#define MSF_ALIGN64 0x20            // 4MEG max symbol file, 64 byte alignment 
#define MSF_ALIGN128    0x30        // 8MEG max symbol file, 128 byte alignment 
#define MSF_ALIGN_MASK  0x30





//  Followed by a list of SYMDEF's..
//  for each symbol within a segment/group: (SYMDEF)
 
struct symdef16_s {
    unsigned short sd_val;          // 16 bit symbol addr or const 
    unsigned char  sd_cbname;       //  8 bit symbol name length 
    unsigned char  sd_achname[1];   // <n> symbol name 
};


struct symdef_s {
    unsigned long sd_lval;          // 32 bit symbol addr or const 
    unsigned char sd_cbname;        //  8 bit symbol name length 
    unsigned char sd_achname[1];    // <n> symbol name 
};




#pragma pack()            // stop packing 


typedef struct mapdef_s MAPDEF;
typedef struct segdef_s SEGDEF;


// SYM file info for open files
typedef struct _osf {
    WCHAR   szwName[MAX_PATH];         // file name
    WCHAR   szwVersion[MAX_PATH];      // version
    DWORD   dwCheckSum;                 // checksum
    HANDLE  hfFile;                     // file handle 
    ULONG   ulFirstSeg;                 // first section's offset
    int     nSeg;                       // number of sections
    DWORD   dwCurSection;               // section for which symbol defintion ptrs are already available
    BYTE*  psCurSymDefPtrs;            // pointer to array of symbol defintion offsets
}   OPENFILE;


#define MAXOPENFILES 10
#define MAX_NAME 256


#ifdef __cplusplus
}
#endif  // __cplusplus


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\symcvt\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\matchsym\matchsym.cpp ===
// Adapted from Minidbg.c
// Original Authors : Matthew Hendel (math) and Matt Ruhlen (mruhlen)
// Copyright (c) 1999 Microsoft Corporation
// 
// Changed by (smahesh)
// The MdpExc Program which resolves sym files has been adapted to match sym files with
// the corresponding binary images. This is done by comparing the RVA's of the exported
// functions in the binary image with the RVA's of their symbols in the sym file.


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys\stat.h>
#include <string.h>
#include <shlwapi.h>
#include "symres.h"
#include <dbghelp.h>

#define MAX_PATH 260
#define MAXSYMNAME 512

// parameter is used to typecast the result to the appropriate pointer type.
#define MakePtr( cast, ptr, addValue ) (cast)( (DWORD)(ptr) + (addValue) )

typedef DWORD ULONG_PTR;


PVOID
OpenMapping(
    IN PCWSTR FilePath
    )
{
    HANDLE hFile;
    HANDLE hMappedFile;
    PVOID MappedFile;
    

    hFile = CreateFileW(
                FilePath,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if (hFile == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    hMappedFile = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if (!hMappedFile) {
        CloseHandle (hFile);
        return FALSE;
    }

    MappedFile = MapViewOfFile (
                        hMappedFile,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    CloseHandle (hMappedFile);
    CloseHandle (hFile);

    return MappedFile;
}


PIMAGE_SECTION_HEADER GetEnclosingSectionHeader(DWORD rva, PIMAGE_NT_HEADERS pNTHeader)
{
	PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(pNTHeader);
    unsigned i;
    
    for ( i=0; i < pNTHeader->FileHeader.NumberOfSections; i++, section++ )  {
        // Is the RVA within this section?
        if ( (rva >= section->VirtualAddress) && 
             (rva < (section->VirtualAddress + section->Misc.VirtualSize)))
            return section;
    }
    
    return 0;

}


//   Compares the RVA's of the Exported Methods in the Binary with the RVA's of the corresponding
//   Symbols in the Sym file.
bool CheckSymFile(LPWSTR wszDllFileName, LPWSTR wszSymFileName)
{
    PVOID Mapping;
    PIMAGE_DOS_HEADER dosHeader;
    PIMAGE_EXPORT_DIRECTORY exportDir;
    PIMAGE_SECTION_HEADER header;
    PIMAGE_NT_HEADERS pNTHeader;
    INT delta;
    LPSTR filename;
    DWORD base;
    DWORD i;
    PDWORD functions;
    PWORD  ordinals;
    LPSTR *name;
    DWORD exportsStartRVA, exportsEndRVA;

    bool fResult = true;
    Mapping   = OpenMapping(wszDllFileName);
    dosHeader = (PIMAGE_DOS_HEADER)Mapping;

    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE )	{
        return false;
    }

    base            = (DWORD) dosHeader;
    pNTHeader       = MakePtr(PIMAGE_NT_HEADERS, dosHeader, dosHeader->e_lfanew );
    exportsStartRVA = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    exportsEndRVA   = exportsStartRVA + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    // Get the IMAGE_SECTION_HEADER that contains the exports.  This is
    // usually the .edata section, but doesn't have to be.
    header = GetEnclosingSectionHeader(exportsStartRVA, pNTHeader);
    if ( !header ) {
        printf("No Exports Table Found:");
        return false; 
    }

    delta     = (INT)(header->VirtualAddress - header->PointerToRawData);
    exportDir = MakePtr(PIMAGE_EXPORT_DIRECTORY, base, exportsStartRVA - delta);
    filename  = (PSTR)(exportDir->Name - delta + base);
    functions = (PDWORD)((DWORD)exportDir->AddressOfFunctions - delta + base);
    ordinals  = (PWORD)((DWORD)exportDir->AddressOfNameOrdinals - delta + base);
    name      = (PSTR *)((DWORD)exportDir->AddressOfNames - delta + base);

    PIMAGE_SECTION_HEADER pSecHeader;
    
    for (i=0; i < exportDir->NumberOfFunctions; i++) {
        DWORD entryPointRVA = functions[i];
        DWORD j;

        if ( entryPointRVA == 0 )   // Skip over gaps in exported function
            continue;               // ordinals (the entrypoint is 0 for
                                    // these functions).
                                    
        pSecHeader = ImageRvaToSection(pNTHeader, Mapping, entryPointRVA);
                                    
        // See if this function has an associated name exported for it.
        
        for ( j=0; j < exportDir->NumberOfNames; j++ ) {
            if ( ordinals[j] == i ) {
                SymbolResolver sr;
                WCHAR wszFunctionName[MAX_NAME];
                wszFunctionName[0] = L'\0';
				
                if (sr.GetNameFromAddr(wszSymFileName, 1, pSecHeader->VirtualAddress, entryPointRVA, wszFunctionName)) 
                    ;
                else if (sr.GetNameFromAddr(wszSymFileName, 2, pSecHeader->VirtualAddress, entryPointRVA, wszFunctionName))
                    ;
                else {
                    printf("\nNot Found  %s %S", (char *)(name[j] - delta + base), wszFunctionName );
                    fResult = false;
                }    
            }
        }

        // Is it a forwarder?  If so, the entry point RVA is inside the
        // .edata section, and is an RVA to the DllName.EntryPointName
        if ((entryPointRVA >= exportsStartRVA) &&
                (entryPointRVA <= exportsEndRVA)) {
            SymbolResolver sr;
            WCHAR wszFunctionName[MAX_NAME];
            wszFunctionName[0] = L'\0';
            if (sr.GetNameFromAddr(wszSymFileName, 1, pSecHeader->VirtualAddress, entryPointRVA, wszFunctionName)) 
                ;
            else if (sr.GetNameFromAddr(wszSymFileName, 2, pSecHeader->VirtualAddress, entryPointRVA, wszFunctionName))
                ;
            else {
                printf("Not Found  %s %S", (char *)(entryPointRVA - delta + base), wszFunctionName );
                fResult = false;
            }
        }
    }

    return fResult; 
}


void __cdecl wmain(int argc,WCHAR ** argv)
{
    WCHAR wszDllFileName[MAX_PATH] = L"";
    WCHAR wszSymFileName[MAX_PATH] = L"";
    bool fVerbose = false;
    int  nCount   = 0;
    
    __try {

        if (argc < 2 || argc > 4) {
            printf("\nUsage: Symchk [-v] [Binary] [Sym File]");
            printf("\n[v] Verbose");
            return;
        }    

        nCount++;

        if (argv[nCount][0] == L'-' && argc > 3) {
            fVerbose = true;
            nCount++;
        } 

        StrCpyNW(wszDllFileName, argv[nCount], MAX_NAME);
        nCount++;
        StrCpyNW(wszSymFileName, argv[nCount], MAX_NAME);

        if (CheckSymFile(wszDllFileName, wszSymFileName))
            printf("\n Result: Sym File Matched");
    }
    __except(1)	{
        // do nothing, just don't pass it to the user.
    }

    return;         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\symcvt\symcvt.c ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    symcvt.c

Abstract:

    This module is the shell for the SYMCVT DLL.  The DLL's purpose is
    to convert the symbols for the specified image.  The resulting
    debug data must conform to the CODEVIEW spec.

    Currently this DLL converts COFF symbols and C7/C8 MAPTOSYM SYM files.

Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define _SYMCVT_SOURCE_
#include "symcvt.h"

PUCHAR
ConvertSymbolsForImage(
                       HANDLE      hFile,
                       char *      fname
    )
/*++

Routine Description:

    Calls the appropriate conversion routine based on the file contents.


Arguments:

    hFile         -  file handle for the image (may be NULL)
    fname         -  file name for the image (may not have correct path)


Return Value:

    NULL             - could not convert the symbols
    Valid Pointer    - a pointer to malloc'ed memory that contains the
                       CODEVIEW symbols

--*/
{
    POINTERS   p;
    char       szDrive    [_MAX_DRIVE];
    char       szDir      [_MAX_DIR];
    char       szFname    [_MAX_FNAME];
    char       szExt      [_MAX_EXT];
    char       szSymName  [MAX_PATH];
    PUCHAR     rVal;


    if (!MapInputFile( &p, hFile, fname)) {

        rVal = NULL;

    } else if (CalculateNtImagePointers( &p.iptrs )) {

        //
        // we were able to compute the nt image pointers so this must be
        // a nt PE image.  now we must decide if there are coff symbols
        // if there are then we do the cofftocv conversion.
        //
        // btw, this is where someone would convert some other type of
        // symbols that are in a nt PE image. (party on garth..)
        //

//      if (!COFF_DIR(&p.iptrs)) {
        if (!p.iptrs.numberOfSymbols) {
            rVal = NULL;
        } else {
            ConvertCoffToCv( &p );
            rVal = p.pCvStart.ptr;
        }
        UnMapInputFile( &p );

    } else {

        UnMapInputFile ( &p );

        _splitpath( fname, szDrive, szDir, szFname, szExt );
        _makepath( szSymName, szDrive, szDir, szFname, "sym" );

        if (!MapInputFile( &p, NULL, szSymName)) {

            rVal = NULL;

        } else {

            //
            // must be a wow/dos app and there is a .sym file so lets to
            // the symtocv conversion
            //

            ConvertSymToCv( &p );
            UnMapInputFile( &p );

            rVal = p.pCvStart.ptr;
        }

    }

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\callswin.cpp ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    callswin.cpp

Abstract:

    This module contains the main line code for display of calls window.

Environment:

    Win32, User Mode

--*/


#include "precomp.hxx"
#pragma hdrstop

#define MIN_FRAMES 10
#define MORE_LESS 10

#define CALLS_CONTEXT_ID_BASE 0x100

#define TBB_MORE    9
#define TBB_LESS    10

// The IDs of the buttons are the bit shift of the
// corresponding flag.
TBBUTTON g_CallsTbButtons[] =
{
    TEXT_TB_BTN(0, "Args", BTNS_CHECK),
    TEXT_TB_BTN(1, "Func info", BTNS_CHECK),
    TEXT_TB_BTN(2, "Source", BTNS_CHECK),
    TEXT_TB_BTN(3, "Addrs", BTNS_CHECK),
    TEXT_TB_BTN(4, "Headings", BTNS_CHECK),
    TEXT_TB_BTN(5, "Nonvolatile regs", BTNS_CHECK),
    TEXT_TB_BTN(6, "Frame nums", BTNS_CHECK),
    TEXT_TB_BTN(7, "Arg types", BTNS_CHECK),
    SEP_TB_BTN(),
    TEXT_TB_BTN(TBB_MORE, "More", 0),
    TEXT_TB_BTN(TBB_LESS, "Less", 0),
    SEP_TB_BTN(),
    TEXT_TB_BTN(ID_SHOW_TOOLBAR, "Toolbar", 0),
};

#define NUM_CALLS_MENU_BUTTONS \
    (sizeof(g_CallsTbButtons) / sizeof(g_CallsTbButtons[0]))
#define NUM_CALLS_TB_BUTTONS \
    (NUM_CALLS_MENU_BUTTONS - 2)

HMENU CALLSWIN_DATA::s_ContextMenu;

//
//
//
CALLSWIN_DATA::CALLSWIN_DATA()
    : SINGLE_CHILDWIN_DATA(1024)
{
    m_enumType = CALLS_WINDOW;
    m_Flags = 0;
    m_Frames = 20;
    m_FramesFound = 0;
    m_TextOffset = 0;
}

void
CALLSWIN_DATA::Validate()
{
    SINGLE_CHILDWIN_DATA::Validate();

    Assert(CALLS_WINDOW == m_enumType);
}

HRESULT
CALLSWIN_DATA::ReadState(void)
{
    HRESULT Status;

    Empty();
    
    //
    // Record the raw frame data first.
    //

    // Preallocate space to record the raw frames.
    if (AddData(sizeof(DEBUG_STACK_FRAME) * m_Frames) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Allocate a separate buffer to hold the frames while
    // calling OutputStackTrace on them.  We can't just pass
    // in the state buffer pointer as resizing of the state
    // buffer may cause the data pointer to change.
    PDEBUG_STACK_FRAME RawFrames = (PDEBUG_STACK_FRAME)malloc(m_DataUsed);
    if (RawFrames == NULL)
    {
        return E_OUTOFMEMORY;
    }

    Status = g_pDbgControl->GetStackTrace(0, 0, 0, RawFrames, m_Frames,
                                          &m_FramesFound);
    if (Status != S_OK)
    {
        free(RawFrames);
        return Status;
    }
    
    m_TextOffset = m_DataUsed;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(FALSE)) != S_OK)
    {
        return Status;
    }

    // If nonvolatile registers were requested we can't use just
    // our saved frames as they require full context information.
    Status = g_pOutCapControl->
        OutputStackTrace(DEBUG_OUTCTL_THIS_CLIENT |
                         DEBUG_OUTCTL_OVERRIDE_MASK |
                         DEBUG_OUTCTL_NOT_LOGGED,
                         (m_Flags & DEBUG_STACK_NONVOLATILE_REGISTERS) ?
                         NULL : RawFrames, m_FramesFound, m_Flags);
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(TRUE);
        if (Status == S_OK)
        {
            g_OutStateBuf.ReplaceChar('\n', 0);
        }
    }
    else
    {
        g_OutStateBuf.End(TRUE);
    }

    // Now that the state buffer is stable put the raw frame
    // data in.
    memcpy(m_Data, RawFrames, m_TextOffset);
    free(RawFrames);
    
    return Status;
}

void
CALLSWIN_DATA::Copy()
{
    LRESULT Line = SendMessage(m_hwndChild, LB_GETCURSEL, 0, 0);
    Assert(Line != LB_ERR);

    LRESULT Len = SendMessage(m_hwndChild, LB_GETTEXTLEN, Line, 0);
    if (Len <= 0)
    {
        return;
    }

    Len++;
    
    PSTR Text = (PSTR)malloc(Len);

    if (!Text) 
    {
        return;
    }
    SendMessage(m_hwndChild, LB_GETTEXT, Line, (LPARAM)Text);
    Text[Len - 1] = 0;

    CopyToClipboard(Text);

    free (Text);
    return;

}

HMENU
CALLSWIN_DATA::GetContextMenu(void)
{
    ULONG i;
    
    //
    // We only keep one menu around for all call windows
    // so apply the menu check state for this particular
    // window.
    // In reality there's only one calls window anyway,
    // but this is a good example of how to handle
    // multi-instance windows.
    //

    for (i = 0; i < NUM_CALLS_TB_BUTTONS; i++)
    {
        CheckMenuItem(s_ContextMenu, i + CALLS_CONTEXT_ID_BASE,
                      MF_BYCOMMAND | ((m_Flags & (1 << i)) ? MF_CHECKED : 0));
    }
    CheckMenuItem(s_ContextMenu, ID_SHOW_TOOLBAR + CALLS_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_ShowToolbar ? MF_CHECKED : 0));
    
    return s_ContextMenu;
}

void
CALLSWIN_DATA::OnContextMenuSelection(UINT Item)
{
    Item -= CALLS_CONTEXT_ID_BASE;

    switch(Item)
    {
    case TBB_MORE:
        m_Frames += MORE_LESS;
        break;
    case TBB_LESS:
        if (m_Frames >= MIN_FRAMES + MORE_LESS)
        {
            m_Frames -= MORE_LESS;
        }
        break;
    case ID_SHOW_TOOLBAR:
        SetShowToolbar(!m_ShowToolbar);
        break;
    default:
        m_Flags ^= 1 << Item;
        SyncUiWithFlags(1 << Item);
        break;
    }
    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
    }
    UiRequestRead();
}

BOOL
CALLSWIN_DATA::CodeExprAtCaret(PSTR Expr, PULONG64 Offset)
{
    BOOL Succ = FALSE;
    LRESULT Line = SendMessage(m_hwndChild, LB_GETCURSEL, 0, 0);

    // If the column headers are on ignore that line.
    if (m_Flags & DEBUG_STACK_COLUMN_NAMES)
    {
        if (Line == 0)
        {
            return Succ;
        }
        else
        {
            Line--;
        }
    }
    
    if (Line >= 0 && (ULONG)Line < m_FramesFound)
    {
        if (UiLockForRead() == S_OK)
        {
            PDEBUG_STACK_FRAME RawFrames = (PDEBUG_STACK_FRAME)m_Data;
            if (Expr != NULL)
            {
                sprintf(Expr, "0x%I64x", RawFrames[Line].InstructionOffset);
            }
            if (Offset != NULL)
            {
                *Offset = RawFrames[Line].InstructionOffset;
            }
            Succ = TRUE;
            UnlockStateBuffer(this);
        }
    }
    
    return Succ;
}

HRESULT
CALLSWIN_DATA::
StackFrameAtCaret(PDEBUG_STACK_FRAME pFrame)
{
    LRESULT Line = SendMessage(m_hwndChild, LB_GETCURSEL, 0, 0);

    // If the column headers are on ignore that line.
    if (m_Flags & DEBUG_STACK_COLUMN_NAMES)
    {
        if (Line == 0)
        {
            return E_INVALIDARG;
        }
        else
        {
            Line--;
        }
    }
    
    if (Line >= 0 && (ULONG)Line < m_FramesFound && pFrame)
    {
        if (UiLockForRead() == S_OK)
        {
            PDEBUG_STACK_FRAME RawFrames = (PDEBUG_STACK_FRAME)m_Data;
            *pFrame = RawFrames[Line];
            UnlockStateBuffer(this);
        }
    }
    
    return S_OK;
}

BOOL
CALLSWIN_DATA::OnCreate(void)
{
    if (s_ContextMenu == NULL)
    {
        s_ContextMenu = CreateContextMenuFromToolbarButtons
            (NUM_CALLS_MENU_BUTTONS, g_CallsTbButtons, CALLS_CONTEXT_ID_BASE);
        if (s_ContextMenu == NULL)
        {
            return FALSE;
        }
    }
    
    m_Toolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                               WS_CHILD | WS_VISIBLE |
                               TBSTYLE_WRAPABLE | TBSTYLE_LIST | CCS_TOP,
                               0, 0, m_Size.cx, 0, m_Win, (HMENU)ID_TOOLBAR,
                               g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }
    SendMessage(m_Toolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_Toolbar, TB_ADDBUTTONS, NUM_CALLS_TB_BUTTONS,
                (LPARAM)&g_CallsTbButtons);
    SendMessage(m_Toolbar, TB_AUTOSIZE, 0, 0);
    
    RECT Rect;
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top;
    m_ShowToolbar = TRUE;

    m_hwndChild = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        _T("LISTBOX"),                              // class name
        NULL,                                       // title
        WS_CHILD | WS_VISIBLE
        | WS_MAXIMIZE
        | WS_HSCROLL | WS_VSCROLL
        | LBS_NOTIFY | LBS_WANTKEYBOARDINPUT
        | LBS_NOINTEGRALHEIGHT,                     // style
        0,                                          // x
        m_ToolbarHeight,                            // y
        m_Size.cx,                                  // width
        m_Size.cy - m_ToolbarHeight,                // height
        m_Win,                                      // parent
        0,                                          // control id
        g_hInst,                                    // hInstance
        NULL                                        // user defined data
        );

    if (m_hwndChild != NULL)
    {
        SetFont( FONT_FIXED );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

LRESULT
CALLSWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (HIWORD(wParam) == LBN_DBLCLK)
    {
        ULONG64 Offset;
        if (CodeExprAtCaret(NULL, &Offset) &&
            Offset != DEBUG_INVALID_OFFSET)
        {
            UIC_DISPLAY_CODE_DATA* DispCode =
                StartStructCommand(UIC_DISPLAY_CODE);
            if (DispCode != NULL)
            {
                DispCode->Offset = Offset;
                FinishCommand();
            }
        }

        DEBUG_STACK_FRAME StkFrame;
        if (StackFrameAtCaret(&StkFrame) == S_OK)
        {
            UIC_SET_SCOPE_DATA* SetScope =
                StartStructCommand(UIC_SET_SCOPE);
            if (SetScope != NULL)
            {
                SetScope->StackFrame = StkFrame;
                FinishCommand();
            }
        }
        return 0;
    }

    if ((HWND)lParam == m_Toolbar)
    {
        OnContextMenuSelection(LOWORD(wParam) + CALLS_CONTEXT_ID_BASE);
        return 0;
    }
    
    return 0;
}

LRESULT
CALLSWIN_DATA::OnVKeyToItem(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (LOWORD(wParam) == VK_RETURN)
    {
        ULONG64 Offset;
        if (CodeExprAtCaret(NULL, &Offset) &&
            Offset != DEBUG_INVALID_OFFSET)
        {
            UIC_DISPLAY_CODE_DATA* DispCode =
                StartStructCommand(UIC_DISPLAY_CODE);
            if (DispCode != NULL)
            {
                DispCode->Offset = Offset;
                FinishCommand();
            }
        }
        DEBUG_STACK_FRAME StkFrame;
        if (StackFrameAtCaret(&StkFrame) == S_OK)
        {
            UIC_SET_SCOPE_DATA* SetScope =
                StartStructCommand(UIC_SET_SCOPE);
            if (SetScope != NULL)
            {
                SetScope->StackFrame = StkFrame;
                FinishCommand();
            }
        }

    }
    else if (_T('G') == LOWORD(wParam))
    {
        ULONG64 Offset;
        if (CodeExprAtCaret(NULL, &Offset) &&
            Offset != DEBUG_INVALID_OFFSET)
        {
            PrintStringCommand(UIC_EXECUTE, "g 0x%I64x", Offset);
        }
    }
    else if (_T('R') == LOWORD(wParam))
    {
        OnUpdate(UPDATE_BUFFER);
    }
    else
    {
        // Default behavior.
        return -1;
    }

    // Keystroke processed.
    return -2;
}

void
CALLSWIN_DATA::OnUpdate(
    UpdateType Type
    )
{
    if (Type != UPDATE_BUFFER)
    {
        return;
    }
    
    LRESULT lbItem;
    int     nFrameCount;
    HRESULT Status;

    lbItem = SendMessage( m_hwndChild, LB_GETCURSEL, 0, 0 );
    
    SendMessage( m_hwndChild, WM_SETREDRAW, FALSE, 0L );
    SendMessage( m_hwndChild, LB_RESETCONTENT, 0, 0 );

    Status = UiLockForRead();
    if (Status == S_OK)
    {
        PSTR Buf = (PSTR)m_Data + m_TextOffset;
        // Ignore final terminator.
        PSTR End = (PSTR)m_Data + m_DataUsed - 1;
        ULONG Width = 0;

        nFrameCount = 0;

        while (Buf < End)
        {
            ULONG Len = strlen(Buf) + 1;
            ULONG StrWidth = (Len - 1) * m_Font->Metrics.tmAveCharWidth;
            SendMessage(m_hwndChild, LB_ADDSTRING, 0, (LPARAM)Buf);
            Buf += Len;
            if (StrWidth > Width)
            {
                Width = StrWidth;
            }
            nFrameCount++;
        }

        SendMessage(m_hwndChild, LB_SETHORIZONTALEXTENT, Width, 0);
        UnlockStateBuffer(this);
    }
    else
    {
        SendLockStatusMessage(m_hwndChild, LB_ADDSTRING, Status);
        nFrameCount = 1;
    }

    SendMessage( m_hwndChild, LB_SETCURSEL,
                 (lbItem > nFrameCount) ? 0 : lbItem, 0 );
    SendMessage( m_hwndChild, WM_SETREDRAW, TRUE, 0L );
}

ULONG
CALLSWIN_DATA::GetWorkspaceSize(void)
{
    return SINGLE_CHILDWIN_DATA::GetWorkspaceSize() + 2 * sizeof(ULONG);
}

PUCHAR
CALLSWIN_DATA::SetWorkspace(PUCHAR Data)
{
    Data = SINGLE_CHILDWIN_DATA::SetWorkspace(Data);
    *(PULONG)Data = m_Flags;
    Data += sizeof(ULONG);
    *(PULONG)Data = m_Frames;
    Data += sizeof(ULONG);
    return Data;
}

PUCHAR
CALLSWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    Data = SINGLE_CHILDWIN_DATA::ApplyWorkspace1(Data, End);

    if (End - Data >= 2 * sizeof(ULONG))
    {
        m_Flags = *(PULONG)Data;
        Data += sizeof(ULONG);
        m_Frames = *(PULONG)Data;
        Data += sizeof(ULONG);

        SyncUiWithFlags(0xffffffff);
        UiRequestRead();
    }

    return Data;
}

void
CALLSWIN_DATA::SyncUiWithFlags(ULONG Changed)
{
    ULONG i;

    //
    // Set toolbar button state from flags.
    //

    for (i = 0; i < NUM_CALLS_TB_BUTTONS; i++)
    {
        if (Changed & (1 << i))
        {
            SendMessage(m_Toolbar, TB_SETSTATE, g_CallsTbButtons[i].idCommand,
                        TBSTATE_ENABLED |
                        ((m_Flags & (1 << i)) ? TBSTATE_CHECKED : 0));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\symedit\symedit.c ===
/*++

Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    symedit.c

Abstract:


Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <symcvt.h>
#include <cv.h>
#include "strings.h"
#include <imagehlp.h>

#undef UNICODE

#define MAX_PATH 260 

//  prototypes for this module

BOOL    CalculateOutputFilePointers( PIMAGEPOINTERS pi, PIMAGEPOINTERS po );
void    ProcessCommandLineArgs( int argc, WCHAR *argv[] );
void    PrintCopyright( void );
void    PrintUsage( void );
void    FatalError( int, ... );
BOOL    MapOutputFile ( PPOINTERS p, char *fname, int );
void    ComputeChecksum(  char *szExeFile );
void    ReadDebugInfo( PPOINTERS p );
void    WriteDebugInfo( PPOINTERS p, BOOL);
void    MungeDebugHeadersCoffToCv( PPOINTERS  p, BOOL fAddCV );
void    MungeExeName( PPOINTERS p, char * szExeName );
void    DoCoffToCv(char *, char *, BOOL);
void    DoSymToCv(char *, char *, char *, char *);
void    DoNameChange(char *, char *, char *);
void    DoExtract(char *, char *, char *);
void    DoStrip(char *, char *);

IMAGE_DEBUG_DIRECTORY   DbgDirSpare;

#define AdjustPtr(ptr) (((ptr) != NULL) ? \
                          ((DWORD)ptr - (DWORD)pi->fptr + (DWORD)po->fptr) : \
                          ((DWORD)(ptr)))


int _cdecl
wmain(
    int        argc,
    WCHAR *     argv[]
    )
/*++

Routine Description:

    Shell for this utility.

Arguments:

    argc     - argument count
    argv     - argument pointers


Return Value:

    0        - image was converted
    >0       - image could not be converted

--*/

{
    // Scan the command line and check what operations we are doing

    ProcessCommandLineArgs( argc, argv );
    return 0;
}


__inline void PrintCopyright( void )
{
    puts( "\nMicrosoft(R) Windows NT SymEdit Version 1.0\n"
          "(C) 1989-1995 Microsoft Corp. All rights reserved.\n");
}


__inline void PrintUsage( void )
{
    PrintCopyright();
    puts ("\nUsage: SYMEDIT <OPERATION> -q -o<file out> <file in>\n\n"
          "\t<OPERATION> is:\n"
          "\tC\tModify CodeView symbol information\n"
          "\tN\tEdit name field\n"
          "\tX\tExtract debug information\n"
          "\tS\tStrip all debug information\n\n"
          "Options:\n"
          "\t-a\t\tAdd CodeView debug info to file\n" 
          "\t-n<name>\tName to change to\n"
          "\t-o<file>\tspecify output file\n"
          "\t-q\t\tquiet mode\n"
          "\t-r\t\tReplace COFF debug info with CV info\n"
          "\t-s<file>\tSym file source");
}


void
ProcessCommandLineArgs(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    Processes the command line arguments and sets global flags to
    indicate the user's desired behavior.

Arguments:

    argc     - argument count
    argv     - argument pointers


Return Value:

    void

--*/

{
    int     i;
    BOOL    fQuiet = FALSE;
    BOOL    fSilent = FALSE;
    char    szOutputFile[MAX_PATH];
    char    szInputFile[MAX_PATH];
    char    szExeName[MAX_PATH];
    char    szDbgFile[MAX_PATH];
    char    szSymFile[MAX_PATH];
    int     iOperation;
    BOOLEAN fAddCV = FALSE;

    // Minimun number of of arguments is 2 -- program and operation

    if (argc < 2 ||
        (wcscmp(argv[1], L"-?") == 0) ||
        (wcscmp(argv[1], L"?") == 0) )
    {
        PrintUsage();
        exit(1);
    }

    // All operations on 1 character wide

    if (argv[1][1] != 0) {
        FatalError(ERR_OP_UNKNOWN, argv[1]);
    }

    // Validate the operation

    switch( argv[1][0] ) {
        case L'C':
        case L'N':
        case L'X':
        case L'S':
            iOperation = argv[1][0];
            break;
        default:
            FatalError(ERR_OP_UNKNOWN, argv[1]);
    }

    // Parse out any other switches on the command line

    for (i=2; i<argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            switch (towupper(argv[i][1])) {

                // Add the CV debug information section rather than
                // replace the COFF section with the CV info.

                case L'A':
                    fAddCV = TRUE;
                    break;

                // Specify the output name for the DBG file

                case L'D':
                    if (argv[i][2] == 0) {
                        i += 1;
                        wcstombs(szDbgFile, argv[i], MAX_PATH);
                    } else {
                        wcstombs(szDbgFile, &argv[i][2], MAX_PATH);
                    }
                    break;

                // Specify a new name to shove into the name of the
                // debuggee field in the Misc. Debug info field

                case L'N':
                    if (argv[i][2] == 0) {
                        i += 1;
                        wcstombs(szExeName, argv[i], MAX_PATH);
                    } else {
                        wcstombs(szExeName, &argv[i][2], MAX_PATH);
                    }
                    break;

                // Specify the name of the output file

                case L'O':
                    if (argv[i][2] == 0) {
                        i += 1;
                        wcstombs(szOutputFile,argv[i], MAX_PATH);
                    } else {
                        wcstombs(szOutputFile, &argv[i][2], MAX_PATH);
                    }
                    break;

                // Be quite and don't put out the banner

                case L'Q':
                    fQuiet = TRUE;
                    fSilent = TRUE;
                    break;

                //  Replace COFF debug information with CODEVIEW debug information

                case L'R':
                    break;

                //  Convert a Symbol File to CV info

                case L'S':
                    if (argv[i][2] == 0) {
                        i += 1;
                        wcstombs(szSymFile, argv[i], MAX_PATH);
                    } else {
                        wcstombs(szSymFile, &argv[i][2], MAX_PATH);
                    }
                    break;

                // Print the command line options

                case L'?':
                    PrintUsage();
                    exit(1);
                    break;

                // Unrecognized option

                default:
                    FatalError( ERR_OP_UNKNOWN, argv[i] );
                    break;
            }
        } else {
            //  No leading switch character -- must be a file name

            wcstombs(szInputFile, &argv[i][0], MAX_PATH);

            //  Process the file(s)

            if (!fQuiet) {
                PrintCopyright();
                fQuiet = TRUE;
            }

            if (!fSilent) {
                printf("processing file: %s\n", szInputFile );
            }

            //  Do switch validation cheching and setup any missing global variables

            switch ( iOperation ) {

                // For conversions -- there are three types
                //
                //      1.  Coff to CV -- add
                //      2.  Coff to CV -- replace
                //      3.  SYM to CV --- add
                //      4.  SYM to CV -- seperate file
                //
                //      Optional input file (not needed for case 4)
                //      Optional output file
                //      Optional sym file (implys sym->CV)
                //      Optional DBG file

                case 'C':
                    if (szSymFile == NULL) {
                        DoCoffToCv(szInputFile, szOutputFile, fAddCV);
                    } else {
                        DoSymToCv(szInputFile, szOutputFile, szDbgFile, szSymFile);
                    }
                    break;

                //  For changing the name of the debuggee --
                //      Must specify input file
                //      Must specify new name
                //      Optional output file

                case 'N':
                    DoNameChange(szInputFile, szOutputFile, szExeName);
                    break;

                //  For extraction of debug information
                //      Must specify input file
                //      Optional output file name
                //      Optional debug file name

                case 'X':
                    DoExtract(szInputFile, szOutputFile, szDbgFile);
                    break;

                //  For full strip of debug information
                //      Must specify input file
                //      Optional output file

                case 'S':
                    DoStrip(szInputFile, szOutputFile);
                    break;
            }
        }
    }
    return;
}


void
ReadDebugInfo(
    PPOINTERS   p
    )

/*++

Routine Description:

    This function will go out and read in all of the debug information
    into memory -- this is required because the input and output
    files might be the same, if so then writing out informaiton may
    destory data we need at a later time.

Arguments:

    p   - Supplies a pointer to the structure describing the debug info file

Return Value:

    None.

--*/

{
    int                         i;
//    int                         cb;
//    char *                      pb;
//    PIMAGE_COFF_SYMBOLS_HEADER  pCoffDbgInfo;

    // Allocate space to save pointers to debug info

    p->iptrs.rgpbDebugSave = (PCHAR *) malloc(p->iptrs.cDebugDir * sizeof(PCHAR));
    memset(p->iptrs.rgpbDebugSave, 0, p->iptrs.cDebugDir * sizeof(PCHAR));

    // Check each possible debug type record

    for (i=0; i<p->iptrs.cDebugDir; i++) {

        // If there was debug information then copy over the
        // description block and cache in the actual debug data.

        if (p->iptrs.rgDebugDir[i] != NULL) {
            p->iptrs.rgpbDebugSave[i] =
              malloc( p->iptrs.rgDebugDir[i]->SizeOfData );
            if (p->iptrs.rgpbDebugSave[i] == NULL) {
                FatalError(ERR_NO_MEMORY);
            }
            __try {
                memcpy(p->iptrs.rgpbDebugSave[i],
                       p->iptrs.fptr +
                       p->iptrs.rgDebugDir[i]->PointerToRawData,
                       p->iptrs.rgDebugDir[i]->SizeOfData );
            } __except(EXCEPTION_EXECUTE_HANDLER ) {
                free(p->iptrs.rgpbDebugSave[i]);
                p->iptrs.rgpbDebugSave[i] = NULL;
            }
        }
    }
    return;
}


void
WriteDebugInfo(
    PPOINTERS   p,
    BOOL        fAddCV
    )
/*++

Routine Description:

    This function will go out and read in all of the debug information
    into memory -- this is required because the input and output
    files might be the same, if so then writing out informaiton may
    destory data we need at a later time.

Arguments:

    p   - Supplies a pointer to the structure describing the debug info file

Return Value:

    None.

--*/

{
    ULONG  PointerToDebugData = 0; //  Offset from the start of the file
                                   //  to the current location to write
                                   //  debug information out.
    ULONG  BaseOfDebugData = 0;
    int    i, flen;
    PIMAGE_DEBUG_DIRECTORY  pDir, pDbgDir = NULL;

    if (p->optrs.debugSection) {
        BaseOfDebugData = PointerToDebugData =
          p->optrs.debugSection->PointerToRawData;
    } else if (p->optrs.sepHdr) {
        BaseOfDebugData =  PointerToDebugData =
          sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
          p->optrs.sepHdr->NumberOfSections * sizeof(IMAGE_SECTION_HEADER) +
          p->optrs.sepHdr->ExportedNamesSize;
    }

    //  Step 2. If the debug information is mapped, we know this
    //          from the section headers, then we may need to write
    //          out a new debug director to point to the debug information

    if (fAddCV) {
        if (p->optrs.optHdr) {
            p->optrs.optHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].
              VirtualAddress = p->optrs.debugSection->VirtualAddress;
            p->optrs.optHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size +=
              sizeof(IMAGE_DEBUG_DIRECTORY);
        } else if (p->optrs.sepHdr) {
            p->optrs.sepHdr->DebugDirectorySize += sizeof(IMAGE_DEBUG_DIRECTORY);
        } else {
            exit(1);
        }

        if (p->optrs.sepHdr) {
            pDbgDir = (PIMAGE_DEBUG_DIRECTORY) malloc(p->optrs.cDebugDir * sizeof(IMAGE_DEBUG_DIRECTORY));
            for (i=0; i<p->optrs.cDebugDir; i++) {
                if (p->optrs.rgDebugDir[i] != NULL) {
                    pDbgDir[i] = *(p->optrs.rgDebugDir[i]);
                    p->optrs.rgDebugDir[i] = &pDbgDir[i];
                }
            }
        }
        for (i=0; i<p->optrs.cDebugDir; i++) {
            if (p->optrs.rgDebugDir[i]) {
                pDir = (PIMAGE_DEBUG_DIRECTORY) (PointerToDebugData +
                                                 p->optrs.fptr);
                *pDir = *(p->optrs.rgDebugDir[i]);
                p->optrs.rgDebugDir[i] = pDir;
                PointerToDebugData += sizeof(IMAGE_DEBUG_DIRECTORY);
            }
        }
    }

    // Step 3.  For every debug info type, write out the debug information
    //          and update any header information required

    for (i=0; i<p->optrs.cDebugDir; i++) {
        if (p->optrs.rgDebugDir[i] != NULL) {
            if (p->optrs.rgpbDebugSave[i] != NULL) {
                p->optrs.rgDebugDir[i]->PointerToRawData =
                  PointerToDebugData;
                if (p->optrs.debugSection) {
                    p->optrs.rgDebugDir[i]->AddressOfRawData =
                      p->optrs.debugSection->VirtualAddress +
                        PointerToDebugData - BaseOfDebugData;
                }
                memcpy(p->optrs.fptr + PointerToDebugData,
                       p->optrs.rgpbDebugSave[i],
                       p->optrs.rgDebugDir[i]->SizeOfData);

                if ((i == IMAGE_DEBUG_TYPE_COFF) &&
                    (p->optrs.fileHdr != NULL)) {

                    PIMAGE_COFF_SYMBOLS_HEADER  pCoffDbgInfo;
                    pCoffDbgInfo = (PIMAGE_COFF_SYMBOLS_HEADER)p->optrs.rgpbDebugSave[i];
                    p->optrs.fileHdr->PointerToSymbolTable =
                      PointerToDebugData + pCoffDbgInfo->LvaToFirstSymbol;
                }
            }
            PointerToDebugData += p->optrs.rgDebugDir[i]->SizeOfData;
        }
    }

    // Step 4.  Clean up any COFF structures if we are replacing
    //          the coff information with CV info.

    if ((p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_COFF] == NULL) &&
        (p->optrs.fileHdr != NULL)) {

        // Since there is no coff debug information -- clean out
        // both fields pointing to the debug info

        p->optrs.fileHdr->PointerToSymbolTable = 0;
        p->optrs.fileHdr->NumberOfSymbols = 0;
    }

    // Step 5.  Correct the alignments if needed.  If there is a real .debug
    //          section in the file (i.e. it is mapped) then update it.

    if (p->optrs.debugSection) {
        p->optrs.debugSection->SizeOfRawData =
          FileAlign(PointerToDebugData - BaseOfDebugData);

        // update the optional header with the new image size

        p->optrs.optHdr->SizeOfImage =
          SectionAlign(p->optrs.debugSection->VirtualAddress +
                       p->optrs.debugSection->SizeOfRawData);
        p->optrs.optHdr->SizeOfInitializedData +=
          p->optrs.debugSection->SizeOfRawData;
    }

    // calculate the new file size

    if (p->optrs.optHdr != NULL) {
        flen = FileAlign(PointerToDebugData);
    } else {
        flen = PointerToDebugData;
    }

    // finally, update the eof pointer and close the file

    UnmapViewOfFile( p->optrs.fptr );

    if (!SetFilePointer( p->optrs.hFile, flen, 0, FILE_BEGIN )) {
        FatalError( ERR_FILE_PTRS );
    }

    if (!SetEndOfFile( p->optrs.hFile )) {
        FatalError( ERR_SET_EOF );
    }

    CloseHandle( p->optrs.hFile );

    // Exit -- we are done.

    return;
}



void
MungeDebugHeadersCoffToCv(
    PPOINTERS   p,
    BOOL        fAddCV
    )

/*++

Routine Description:


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)

Return Value:

    void

--*/

{
    if (!fAddCV) {
        CV_DIR(&p->optrs) = COFF_DIR(&p->optrs);
        COFF_DIR(&p->optrs) = 0;
    } else {
        CV_DIR(&p->optrs) = &DbgDirSpare;
        *(COFF_DIR(&p->optrs)) = *(COFF_DIR(&p->iptrs));
    };

    *CV_DIR(&p->optrs) = *(COFF_DIR(&p->iptrs));
    CV_DIR(&p->optrs)->Type = IMAGE_DEBUG_TYPE_CODEVIEW;
    CV_DIR(&p->optrs)->SizeOfData =  p->pCvStart.size;
    p->optrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_CODEVIEW] = p->pCvStart.ptr;

    return;
}



BOOL
MapOutputFile (
    PPOINTERS p,
    char *fname,
    int cb
    )

/*++

Routine Description:

    Maps the output file specified by the fname argument and saves the
    file handle & file pointer in the POINTERS structure.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)
    fname    - ascii string for the file name


Return Value:

    TRUE     - file mapped ok
    FALSE    - file could not be mapped

--*/

{
    BOOL    rval;
    HANDLE  hMap   = NULL;
    DWORD   oSize;

    rval = FALSE;

    p->optrs.hFile = CreateFileA( fname,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_ALWAYS,
                        0,
                        NULL );

    if (p->optrs.hFile == INVALID_HANDLE_VALUE) {
       goto exit;
    }

    oSize = p->iptrs.fsize;
    if (p->pCvStart.ptr != NULL) {
        oSize += p->pCvStart.size;
    }
    oSize += cb;
    oSize += p->iptrs.cDebugDir * sizeof(IMAGE_DEBUG_DIRECTORY);

    hMap = CreateFileMapping( p->optrs.hFile, NULL, PAGE_READWRITE,
                                0, oSize, NULL );

    if (hMap == NULL) {
       goto exit;
    }

    p->optrs.fptr = MapViewOfFile( hMap, FILE_MAP_WRITE, 0, 0, 0 );

    CloseHandle(hMap);

    if (p->optrs.fptr == NULL) {
       goto exit;
    }
    rval = TRUE;
exit:
    return rval;
}


BOOL
CalculateOutputFilePointers(
    PIMAGEPOINTERS pi,
    PIMAGEPOINTERS po
    )

/*++

Routine Description:

    This function calculates the output file pointers based on the
    input file pointers.  The same address is used but they are all
    re-based off the output file's file pointer.

Arguments:

    p        - pointer to a IMAGEPOINTERS structure (see symcvt.h)


Return Value:

    TRUE     - pointers were created
    FALSE    - pointers could not be created

--*/
{
    int i;

    // fixup the pointers relative the fptr for the output file
    po->dosHdr       = (PIMAGE_DOS_HEADER)      AdjustPtr(pi->dosHdr);
    po->ntHdr        = (PIMAGE_NT_HEADERS)      AdjustPtr(pi->ntHdr);
    po->fileHdr      = (PIMAGE_FILE_HEADER)     AdjustPtr(pi->fileHdr);
    po->optHdr       = (PIMAGE_OPTIONAL_HEADER) AdjustPtr(pi->optHdr);
    po->sectionHdrs  = (PIMAGE_SECTION_HEADER)  AdjustPtr(pi->sectionHdrs);
    po->sepHdr       = (PIMAGE_SEPARATE_DEBUG_HEADER) AdjustPtr(pi->sepHdr);
    po->debugSection = (PIMAGE_SECTION_HEADER)  AdjustPtr(pi->debugSection);
    po->AllSymbols   = (PIMAGE_SYMBOL)          AdjustPtr(pi->AllSymbols);
    po->stringTable  = (PUCHAR)                 AdjustPtr(pi->stringTable);

    // move the data from the input file to the output file
    memcpy( po->fptr, pi->fptr, pi->fsize );

    po->cDebugDir = pi->cDebugDir;
    po->rgDebugDir = malloc(po->cDebugDir * sizeof(po->rgDebugDir[0]));
    memset(po->rgDebugDir, 0, po->cDebugDir * sizeof(po->rgDebugDir[0]));

    for (i=0; i<po->cDebugDir; i++) {
        po->rgDebugDir[i] = (PIMAGE_DEBUG_DIRECTORY) AdjustPtr(pi->rgDebugDir[i]);
    }
    po->rgpbDebugSave = pi->rgpbDebugSave;

    return TRUE;
}


void
FatalError(
    int  idMsg,
    ...
    )
/*++

Routine Description:

    Prints a message string to stderr and then exits.

Arguments:

    s        - message string to be printed

Return Value:

    void

--*/

{
    va_list marker;
    char    rgchFormat[256];
    char    rgch[256];

    LoadStringA(GetModuleHandle(NULL), idMsg, rgchFormat, sizeof(rgchFormat));

    va_start(marker, idMsg);
    vsprintf(rgch, rgchFormat, marker);
    va_end(marker);

    fprintf(stderr, "%s\n", rgch);

    exit(1);
}


void
ComputeChecksum(
    char *szExeFile
    )

/*++

Routine Description:

    Computes a new checksum for the image by calling imagehlp.dll

Arguments:

    szExeFile - exe file name


Return Value:

    void

--*/

{
    DWORD              dwHeaderSum = 0;
    DWORD              dwCheckSum = 0;
    HANDLE             hFile;
    DWORD              cb;
    IMAGE_DOS_HEADER   dosHdr;
    IMAGE_NT_HEADERS   ntHdr;

    if (MapFileAndCheckSumA(szExeFile, &dwHeaderSum, &dwCheckSum) != CHECKSUM_SUCCESS) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    hFile = CreateFileA( szExeFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                      );

    // seek to the beginning of the file
    SetFilePointer( hFile, 0, 0, FILE_BEGIN );

    // read in the dos header
    if ((ReadFile(hFile, &dosHdr, sizeof(dosHdr), &cb, 0) == FALSE) || (cb != sizeof(dosHdr))) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    // read in the pe header
    if ((dosHdr.e_magic != IMAGE_DOS_SIGNATURE) ||
        (SetFilePointer(hFile, dosHdr.e_lfanew, 0, FILE_BEGIN) == -1L)) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    // read in the nt header
    if ((!ReadFile(hFile, &ntHdr, sizeof(ntHdr), &cb, 0)) || (cb != sizeof(ntHdr))) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    if (SetFilePointer(hFile, dosHdr.e_lfanew, 0, FILE_BEGIN) == -1L) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    ntHdr.OptionalHeader.CheckSum = dwCheckSum;

    if (!WriteFile(hFile, &ntHdr, sizeof(ntHdr), &cb, NULL)) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    CloseHandle(hFile);
    return;
}


void
MungeExeName(
    PPOINTERS   p,
    char *      szExeName
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    None.

--*/

{
    PIMAGE_DEBUG_MISC   pMiscIn;
    PIMAGE_DEBUG_MISC   pMiscOut;
    int                 cb;
    int                 i;

    for (i=0; i<p->iptrs.cDebugDir; i++) {
        if (p->optrs.rgDebugDir[i] != 0) {
            *(p->optrs.rgDebugDir[i]) = *(p->iptrs.rgDebugDir[i]);
        }
    }

    pMiscIn = (PIMAGE_DEBUG_MISC)
      p->iptrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_MISC];

    if (p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC] == NULL) {
        p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC] = &DbgDirSpare;
        memset(&DbgDirSpare, 0, sizeof(DbgDirSpare));
    }

    pMiscOut = (PIMAGE_DEBUG_MISC)
      p->optrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_MISC] =
      malloc(p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]->SizeOfData +
             strlen(szExeName));
    cb = p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]->SizeOfData;

    while ( cb > 0 ) {
        if (pMiscIn->DataType == IMAGE_DEBUG_MISC_EXENAME) {
            pMiscOut->DataType = IMAGE_DEBUG_MISC_EXENAME;
            pMiscOut->Length = (sizeof(IMAGE_DEBUG_MISC) +
                                strlen(szExeName) + 3) & ~3;
            pMiscOut->Unicode = FALSE;
            strcpy(&pMiscOut->Data[0], szExeName);
            szExeName = NULL;
        } else {
            memcpy(pMiscOut, pMiscIn, pMiscIn->Length);
        }

        p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]->SizeOfData +=
          (pMiscOut->Length - pMiscIn->Length);

        cb -= pMiscIn->Length;
        pMiscIn = (PIMAGE_DEBUG_MISC) (((char *) pMiscIn) + pMiscIn->Length);
        pMiscOut = (PIMAGE_DEBUG_MISC) (((char *) pMiscOut) + pMiscOut->Length);
    }

    if (szExeName) {
        pMiscOut->DataType = IMAGE_DEBUG_MISC_EXENAME;
        pMiscOut->Length = (sizeof(IMAGE_DEBUG_MISC) +
                            strlen(szExeName) + 3) & ~3;
        pMiscOut->Unicode = FALSE;
        strcpy(&pMiscOut->Data[0], szExeName);
    }

    return;
}


/***    DoCoffToCv
 *
 *
 */

void DoCoffToCv(
    char * szInput,
    char * szOutput,
    BOOL fAddCV
    )
{
    POINTERS    p;

    // Do default checking

    if (szOutput == NULL) {
        szOutput = szInput;
    }

    // Open the input file name and setup the pointers into the file

    if (!MapInputFile( &p, NULL, szInput )) {
        FatalError( ERR_OPEN_INPUT_FILE, szInput );
    }

    // Now, if we thing we are playing with PE exes then we need
    // to setup the pointers into the map file

    if (!CalculateNtImagePointers( &p.iptrs )) {
        FatalError( ERR_INVALID_PE, szInput );
    }

    // We are about to try and do the coff to cv symbol conversion.
    //
    // Verify that the operation is legal.
    //
    // 1.  We need to have coff debug information to start with
    // 2.  If the debug info is not mapped then we must not
    //     be trying to add CodeView info.

    if ((p.iptrs.AllSymbols == NULL) || (COFF_DIR(&p.iptrs) == NULL)) {
        FatalError( ERR_NO_COFF );
    }

    if (fAddCV && (p.iptrs.debugSection == 0) && (p.iptrs.sepHdr == NULL)) {
        FatalError( ERR_NOT_MAPPED );
    }

    // Now go out an preform the acutal conversion.

    if (!ConvertCoffToCv( &p )) {
        FatalError( ERR_COFF_TO_CV );
    }

    // Read in any additional debug information in the file

    ReadDebugInfo(&p);

    // Open the output file and adjust the pointers so that we are ok.

    if (!MapOutputFile( &p, szOutput, 0 )) {
        FatalError( ERR_MAP_FILE, szOutput );
    }

    CalculateOutputFilePointers( &p.iptrs, &p.optrs );

    // Munge the various debug information structures to preform the correct
    // operations

    MungeDebugHeadersCoffToCv( &p, fAddCV );

    // Free our handles on the input file

    UnMapInputFile(&p);

    // Write out the debug information to the end of the exe

    WriteDebugInfo( &p, fAddCV );

    // and finally compute the checksum

    if (p.iptrs.fileHdr != NULL) {
        ComputeChecksum( szOutput );
    }

    return;
}

/***    DoSymToCv
 *
 */

void
DoSymToCv(
    char * szInput,
    char * szOutput,
    char * szDbg,
    char * szSym
    )
{
    POINTERS    p;
    HANDLE      hFile;
    DWORD       cb;
    OFSTRUCT    ofs;

    // Open the input file name and setup the pointers into the file

    if (!MapInputFile( &p, NULL, szSym )) {
        FatalError(ERR_OPEN_INPUT_FILE, szSym);
    }

    // Now preform the desired operation

    if ((szOutput == NULL) && (szDbg == NULL)) {
        szOutput = szInput;
    }

    ConvertSymToCv( &p );

    if (szOutput) {
        if (szOutput != szInput) {
            if (OpenFile(szInput, &ofs, OF_EXIST) == 0) {
                FatalError(ERR_OPEN_INPUT_FILE, szInput);
            }
            if (CopyFileA(szInput, szOutput, FALSE) == 0) {
                FatalError(ERR_OPEN_WRITE_FILE, szOutput);
            }
        }
        hFile = CreateFileA(szOutput, GENERIC_WRITE, 0, NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,  NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            FatalError(ERR_OPEN_WRITE_FILE, szOutput);
        }
        SetFilePointer(hFile, 0, 0, FILE_END);
    } else if (szDbg) {
        hFile = CreateFileA(szDbg, GENERIC_WRITE, 0, NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,  NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            FatalError(ERR_OPEN_WRITE_FILE, szDbg);
        }
    }

    WriteFile(hFile, p.pCvStart.ptr, p.pCvStart.size, &cb, NULL);
    CloseHandle(hFile);

    return;
}


void
DoNameChange(
    char * szInput,
    char * szOutput,
    char * szNewName
    )
{
    POINTERS    p;

    // Open the input file name and setup the pointers into the file

    if (!MapInputFile( &p, NULL, szInput )) {
        FatalError(ERR_OPEN_INPUT_FILE, szInput);
    }

    // Now, if we thing we are playing with PE exes then we need
    // to setup the pointers into the map file

    if (!CalculateNtImagePointers( &p.iptrs )) {
        FatalError(ERR_INVALID_PE, szInput);
    }

    //  Now preform the desired operation

    if (szOutput == NULL) {
        szOutput = szInput;
    }

    if (szNewName == NULL) {
        szNewName = szOutput;
    }

    if (p.iptrs.sepHdr != NULL) {
        FatalError(ERR_EDIT_DBG_FILE);
    }

    // Read in all of the debug information

    ReadDebugInfo(&p);

    // Open the output file and adjust the pointers.

    if (!MapOutputFile(&p, szOutput,
                       sizeof(szNewName) * 2 + sizeof(IMAGE_DEBUG_MISC))) {
        FatalError(ERR_MAP_FILE, szOutput);
    }

    CalculateOutputFilePointers(&p.iptrs, &p.optrs);

    // Munge the name of the file

    MungeExeName(&p, szNewName);

    // Close the input file

    UnMapInputFile(&p);

    // Write out the debug information to the end of the exe

    WriteDebugInfo(&p, FALSE);

    // and finally compute the checksum

    if (p.iptrs.fileHdr != NULL) {
        ComputeChecksum( szOutput );
    }

    return;
}


void
DoStrip(
    char * szInput,
    char * szOutput
    )
{
    char OutputFile[_MAX_PATH];

    // Make sure we only have the path to the output file (it will always be
    //  named filename.DBG)

    if (szOutput != NULL) {
        CopyFileA(szInput, szOutput, FALSE);
    }

    SplitSymbols(szOutput, NULL, OutputFile, SPLITSYM_EXTRACT_ALL);

    // Always delete the output file.

    DeleteFileA(OutputFile);

    return;
}


void
DoExtract(
    char * szInput,
    char * szOutput,
    char * szDbgFile
    )
{
    char OutputFile[_MAX_PATH];
    char szExt[_MAX_EXT];
    char szFileName[_MAX_FNAME];

    if (szOutput != NULL) {
        CopyFileA(szInput, szOutput, FALSE);
        szInput = _strdup(szOutput);
        _splitpath(szOutput, NULL, NULL, szFileName, szExt);
        *(szOutput + strlen(szOutput) - strlen(szFileName) - strlen(szExt)) = '\0';
    }

    SplitSymbols(szInput, szOutput, OutputFile, 0);

    CopyFileA(szDbgFile, OutputFile, TRUE);

    if (szOutput) {
        free(szInput);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\symtodbg\symcvt\symtocv.c ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    symtocv.c

Abstract:

    This module handles the conversion activities requires for converting
    C7/C8 SYM files to CODEVIEW debug data.

Author:

    Wesley A. Witt (wesw) 13-April-1993
    Modified: Sivarudrappa Mahesh (smahesh) 08-September-2000

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "cv.h"
#define _SYMCVT_SOURCE_
#include "symcvt.h"
#include "cvcommon.h"

typedef struct tagSYMNAME {
    BYTE        length;
    char        name[1];
} SYMNAME, *PSYMNAME;

typedef struct tagSYMSYMBOL {
    DWORD       offset;
    SYMNAME     symName;
} SYMSYMBOL, *PSYMSYMBOL;

typedef struct tagSYMFILEHEADER {
    DWORD       fileSize;
    WORD        reserved1;
    WORD        numSyms;
    DWORD       reserved2;
    WORD        nextOffset;
    BYTE        reserved3;
    SYMNAME     symName;
} SYMFILEHEADER, *PSYMFILEHEADER;

typedef struct tagSYMHEADER {
    WORD        nextOffset;
    WORD        numSyms;
    WORD        symOffsetsOffset;
    WORD        segment;
    BYTE        reserved2[6];
    BYTE        type;
    BYTE        reserved3[5];
    SYMNAME     symName;
} SYMHEADER, *PSYMHEADER;

#define SIZEOFSYMFILEHEADER   16
#define SIZEOFSYMHEADER       21
#define SIZEOFSYMBOL           3

#define SYM_SEGMENT_NAME       0
#define SYM_SYMBOL_NAME        1
#define SYM_SEGMENT_ABS        2
#define SYM_SYMBOL_ABS         3

typedef struct tagENUMINFO {
    DATASYM32           *dataSym;
    DATASYM32           *dataSym2;
    DWORD               numsyms;
    SGI                 *sgi;
} ENUMINFO, *PENUMINFO;

typedef BOOL (CALLBACK* SYMBOLENUMPROC)(PSYMNAME pSymName, int symType,
                                        SEGMENT segment, UOFF32 offset,
                                        PENUMINFO pEnumInfo);


static VOID   GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable,
                          char * s );
DWORD  CreateModulesFromSyms( PPOINTERS p );
DWORD  CreatePublicsFromSyms( PPOINTERS p );
DWORD  CreateSegMapFromSyms( PPOINTERS p );
static BOOL   EnumSymbols( PPOINTERS p, SYMBOLENUMPROC lpEnumProc,
                           PENUMINFO pEnumInfo  );

int             CSymSegs;


BOOL CALLBACK
SymbolCount(PSYMNAME pSymName, int symType, SEGMENT segment,
            UOFF32 offset, PENUMINFO pEnumInfo )
{
    if ((symType == SYM_SEGMENT_NAME) && (segment > 0)) {
        CSymSegs += 1;
    }
    pEnumInfo->numsyms++;
    return TRUE;
}


BOOL
ConvertSymToCv( PPOINTERS p )

/*++

Routine Description:

    This is the control function for the conversion of COFF to CODEVIEW
    debug data.  It calls individual functions for the conversion of
    specific types of debug data.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    TRUE     - conversion succeded
    FALSE    - conversion failed

--*/

{
    ENUMINFO            enumInfo;
    DWORD               dwSize;
    
    CSymSegs         = 0;
    enumInfo.numsyms = 0;
    
    EnumSymbols( p, SymbolCount, &enumInfo );
    
    dwSize = (enumInfo.numsyms * (sizeof(DATASYM32) + 10)) + 512000;
    p->pCvCurr = p->pCvStart.ptr = malloc(dwSize);
    
    if (p->pCvStart.ptr == NULL) {
        return FALSE;
    }
    memset( p->pCvStart.ptr, 0, dwSize );

    try {
        CreateSignature( p );
        CreatePublicsFromSyms( p );
        CreateSymbolHashTable( p );
        CreateAddressSortTable( p );
        CreateSegMapFromSyms( p );
        CreateModulesFromSyms( p );
        CreateDirectories( p );
        p->pCvStart.ptr = realloc( p->pCvStart.ptr, p->pCvStart.size );
        return TRUE;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        free( p->pCvStart.ptr );
        p->pCvStart.ptr = NULL;
        return FALSE;

    }
}


DWORD
CreateModulesFromSyms( PPOINTERS p )

/*++

Routine Description:

    Creates the individual CV module records.  There is one CV module
    record for each .FILE record in the COFF debug data.  This is true
    even if the COFF size is zero.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    The number of modules that were created.

--*/

{
    char                szDrive    [_MAX_DRIVE];
    char                szDir      [_MAX_DIR];
    char                szFname    [_MAX_FNAME];
    char                szExt      [_MAX_EXT];
    OMFModule           *m;
    int                 i;
    char *              pb;

    _splitpath( p->iptrs.szName, szDrive, szDir, szFname, szExt );

    m = (OMFModule *) p->pCvCurr;

    m->ovlNumber        = 0;
    m->iLib             = 0;
    m->cSeg             = (unsigned short) CSymSegs;
    m->Style[0]         = 'C';
    m->Style[1]         = 'V';
    for (i=0; i<CSymSegs; i++) {
        m->SegInfo[i].Seg   = i+1;
        m->SegInfo[i].pad   = 0;
        m->SegInfo[i].Off   = 0;
        m->SegInfo[i].cbSeg = 0xffff;
    }
    pb = (char *) &m->SegInfo[CSymSegs];
    sprintf( &pb[1], "%s.c", szFname );
    pb[0] = (char)strlen( &pb[1] );

    pb = (char *) NextMod(m);

    UpdatePtrs( p, &p->pCvModules, (LPVOID)pb, 1 );

    return 1;
}


BOOL CALLBACK
ConvertASymtoPublic(PSYMNAME pSymName, int symType, SEGMENT segment,
                    UOFF32 offset, PENUMINFO pEnumInfo )
{
    if (symType != SYM_SYMBOL_NAME) {
        return TRUE;
    }

    pEnumInfo->dataSym->rectyp     = S_PUB32;
    pEnumInfo->dataSym->seg        = segment;
    pEnumInfo->dataSym->off        = offset;
    pEnumInfo->dataSym->typind     = 0;
    pEnumInfo->dataSym->name[0]    = pSymName->length;
    strncpy( &pEnumInfo->dataSym->name[1], pSymName->name, pSymName->length );
    pEnumInfo->dataSym2 = NextSym32( pEnumInfo->dataSym );
    pEnumInfo->dataSym->reclen = (USHORT) ((DWORD)pEnumInfo->dataSym2 -
                                  (DWORD)pEnumInfo->dataSym) - 2;
    pEnumInfo->dataSym = pEnumInfo->dataSym2;
    pEnumInfo->numsyms++;

    return TRUE;
}


DWORD
CreatePublicsFromSyms( PPOINTERS p )

/*++

Routine Description:

    Creates the individual CV public symbol records.  There is one CV
    public record created for each COFF symbol that is marked as EXTERNAL
    and has a section number greater than zero.  The resulting CV publics
    are sorted by section and offset.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    The number of publics created.

--*/

{
    OMFSymHash          *omfSymHash;
    ENUMINFO            enumInfo;


    enumInfo.dataSym = (DATASYM32 *)
                 (PUCHAR)((DWORD)p->pCvCurr + sizeof(OMFSymHash));
    enumInfo.numsyms = 0;

    EnumSymbols( p, ConvertASymtoPublic, &enumInfo );

    omfSymHash = (OMFSymHash *) p->pCvCurr;
    UpdatePtrs(p, &p->pCvPublics, (LPVOID)enumInfo.dataSym,
               enumInfo.numsyms );

    omfSymHash->cbSymbol = p->pCvPublics.size - sizeof(OMFSymHash);
    omfSymHash->symhash  = 0;
    omfSymHash->addrhash = 0;
    omfSymHash->cbHSym   = 0;
    omfSymHash->cbHAddr  = 0;

    return enumInfo.numsyms;
}


BOOL CALLBACK
ConvertASegment( PSYMNAME pSymName, int symType, SEGMENT segment,
            UOFF32 offset, PENUMINFO pEnumInfo )
{
    if (symType != SYM_SEGMENT_NAME) {
        return TRUE;
    }

    if (segment == 0) {
        return TRUE;
    }

    pEnumInfo->numsyms++;

    pEnumInfo->sgi->sgf.fRead        = TRUE;
    pEnumInfo->sgi->sgf.fWrite       = TRUE;
    pEnumInfo->sgi->sgf.fExecute     = TRUE;
    pEnumInfo->sgi->sgf.f32Bit       = 0;
    pEnumInfo->sgi->sgf.fSel         = 0;
    pEnumInfo->sgi->sgf.fAbs         = 0;
    pEnumInfo->sgi->sgf.fGroup       = 1;
    pEnumInfo->sgi->iovl             = 0;
    pEnumInfo->sgi->igr              = 0;
    pEnumInfo->sgi->isgPhy           = (USHORT) pEnumInfo->numsyms;
    pEnumInfo->sgi->isegName         = 0;
    pEnumInfo->sgi->iclassName       = 0;
    pEnumInfo->sgi->doffseg          = offset;
    pEnumInfo->sgi->cbSeg            = 0xFFFF;
    pEnumInfo->sgi++;

    return TRUE;
}


DWORD
CreateSegMapFromSyms( PPOINTERS p )

/*++

Routine Description:

    Creates the CV segment map.  The segment map is used by debuggers
    to aid in address lookups.  One segment is created for each COFF
    section in the image.

Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    The number of segments in the map.

--*/

{
    SGM          *sgm;
    ENUMINFO     enumInfo;


    sgm = (SGM *) p->pCvCurr;
    enumInfo.sgi = (SGI *) ((DWORD)p->pCvCurr + sizeof(SGM));
    enumInfo.numsyms = 0;

    EnumSymbols( p, ConvertASegment, &enumInfo );

    sgm->cSeg = (USHORT)enumInfo.numsyms;
    sgm->cSegLog = (USHORT)enumInfo.numsyms;

    UpdatePtrs( p, &p->pCvSegMap, (LPVOID)enumInfo.sgi, enumInfo.numsyms );

    return enumInfo.numsyms;
}


BOOL
EnumSymbols( PPOINTERS p, SYMBOLENUMPROC lpEnumProc, PENUMINFO pEnumInfo )

/*++

Routine Description:

    This function enumerates all symbols ine the mapped SYM file


Arguments:

    p             -  pointer to a POINTERS structure
    lpEnumProc    -  function to be called once for each function
    pEnumInfo     -  data to be passed between the caller and the enum func

Return Value:

    TRUE     - success
    FALSE    - failure

--*/

{
    PSYMFILEHEADER      pSymFileHead;
    PSYMHEADER          pSymHead;
    PSYMHEADER          pSymHead2;
    PSYMSYMBOL          pSymSymbol;
    DWORD               i;
    DWORD               startPosition;
    DWORD               position;
    BOOL                fV86Mode;
    WORD                Segment;
    UOFF32              Offset;
    BYTE*               pSymOffsets;
    DWORD               dwSymOffset;

    pSymFileHead = (PSYMFILEHEADER) p->iptrs.fptr;
    pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymFileHead + SIZEOFSYMFILEHEADER +
                               pSymFileHead->symName.length + 1);

    if (!lpEnumProc(&pSymFileHead->symName, SYM_SEGMENT_ABS,
                    0, 0, pEnumInfo )) {
        return FALSE;
    }

    for (i=0; i<pSymFileHead->numSyms; i++) {
        if (!lpEnumProc(&pSymSymbol->symName, SYM_SYMBOL_ABS,
                        0, pSymSymbol->offset, pEnumInfo )) {
            return FALSE;
        }
        pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymSymbol + SIZEOFSYMBOL +
                                   pSymSymbol->symName.length);
    }

    position = startPosition = ((LONG)pSymFileHead->nextOffset) << 4;

    //
    //  Determine if this is a V86Mode sym file.
    //
    //  We'll read the first two headers. If their segment numbers are
    //  not 1 and 2, then we assume V86Mode.
    //
    pSymHead  = (PSYMHEADER) ((DWORD)p->iptrs.fptr + position);
    position  = ((LONG)pSymHead->nextOffset) << 4;
    if ( position != startPosition && position != 0 ) {
        pSymHead2 = (PSYMHEADER) ((DWORD)p->iptrs.fptr + position);
    } else {
        pSymHead2 = NULL;
    }

    if ( pSymHead->segment == 1 &&
         (!pSymHead2 || pSymHead2->segment == 2)) {
        fV86Mode = FALSE;
    } else {
        fV86Mode = TRUE;
        Segment  = 0;
    }

    position = startPosition;

    do {
        pSymHead = (PSYMHEADER) ((DWORD)p->iptrs.fptr + position);
        // BIG SYMDEF
        if (pSymHead->type & 0x04) { 
            pSymOffsets = (BYTE*) ((DWORD)pSymHead + (pSymHead->symOffsetsOffset << 4));
        }
        else {
            pSymOffsets = (BYTE*) ((DWORD)pSymHead + pSymHead->symOffsetsOffset);
        }

        if ( fV86Mode ) {
            Segment++;
            Offset  = pSymHead->segment;
        } else {
            Segment = pSymHead->segment;
            Offset  = 0;
        }

        position = ((LONG)pSymHead->nextOffset) << 4;

        if (!lpEnumProc( &pSymHead->symName, SYM_SEGMENT_NAME,
                        Segment, Offset, pEnumInfo )) {
            return FALSE;
        }

        for (i=0; i<pSymHead->numSyms; i++) {
            // BIG SYMDEF
            if (pSymHead->type & 0x04) { 
                pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymHead + 
                                            pSymOffsets[i*3+0] + 
                                            pSymOffsets[i*3+1] * 256 + 
                                            pSymOffsets[i*3+2] * 65536);
                dwSymOffset = pSymSymbol->offset;
            }    
            else {
                // HACKHACK: The Symbol Name and Offset are contiguous in the case of
                // MSF_32BITSYMS and are separated by 2 bytes in all other cases. 
                pSymSymbol  = (PSYMSYMBOL)((DWORD)pSymHead + 
                                            pSymOffsets[i*2+0] + 
                                            pSymOffsets[i*2+1] * 256);
                dwSymOffset = pSymSymbol->offset;
                pSymSymbol  = (PSYMSYMBOL)((DWORD)pSymHead + 
                                            pSymOffsets[i*2+0] + 
                                            pSymOffsets[i*2+1] * 256 - 
                                            sizeof(SHORT) * (1 - (pSymHead->type & 0x01)));
            }
            // MSF_32BITSYMS
            if (pSymHead->type & 0x01) { 
                if (!lpEnumProc(&pSymSymbol->symName, SYM_SYMBOL_NAME,
                                Segment, dwSymOffset,
                                pEnumInfo )) {
                    return FALSE;
                }
            }
            // 16 BIT SYMS 
            else { 
                if (!lpEnumProc(&pSymSymbol->symName, SYM_SYMBOL_NAME,
                                Segment, dwSymOffset & 0x0000FFFF,
                                pEnumInfo )) {
                    return FALSE;
                }
            }
        }
    } while ( position != startPosition && position != 0 );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\arrange.cpp ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    arrange.cpp

Abstract:

    This module contains the default MDI tiling (arrange) code for
    windowing arrangement.

--*/


#include "precomp.hxx"
#pragma hdrstop

#define AUTO_ARRANGE_WARNING_LIMIT 3
// Multiple events closely together don't each get their own
// count in order to prevent warnings on full-drag message
// series.  This delay should be relatively large to
// avoid problems with people pausing during a full-drag move.
#define AUTO_ARRANGE_WARNING_DELAY 2500

// DeferWindowPos flags to restrict change to position only.
#define POS_ONLY (SWP_NOACTIVATE | SWP_NOZORDER)

ULONG g_AutoArrangeWarningCount;
ULONG g_AutoArrangeWarningTime;

BOOL
IsAutoArranged(WIN_TYPES Type)
{
    if (g_WinOptions & WOPT_AUTO_ARRANGE)
    {
        if (g_WinOptions & WOPT_ARRANGE_ALL)
        {
            return TRUE;
        }

        return Type != DOC_WINDOW && Type != DISASM_WINDOW;
    }

    return FALSE;
}

void
DisplayAutoArrangeWarning(PCOMMONWIN_DATA CmnWin)
{
    //
    // If this window is under automatic arrangement
    // control and has been rearranged a few times,
    // let the user know that auto-arrange may override
    // what the user has done.
    //
    // In order to prevent false positives we avoid
    // giving any warnings if the window is being
    // moved automatically or if we're getting a series
    // of changes in a short period of time, such as
    // if the user has full-drag enabled so that many
    // move or size events can occur rapidly.
    //
    // Display the warning only once per execution.
    //
    
    if (g_AutoArrangeWarningCount == 0xffffffff ||
        CmnWin == NULL ||
        CmnWin->m_InAutoOp > 0 ||
        !IsAutoArranged(CmnWin->m_enumType) ||
        g_AutoArrangeWarningTime >
        GetTickCount() - AUTO_ARRANGE_WARNING_DELAY)
    {
        return;
    }

    if (++g_AutoArrangeWarningCount >= AUTO_ARRANGE_WARNING_LIMIT)
    {
        InformationBox(STR_Auto_Arrange_Is_Enabled);
        g_AutoArrangeWarningCount = 0xffffffff;
    }
    else
    {
        g_AutoArrangeWarningTime = GetTickCount();
    }
}

void
ArrangeInRect(HDWP Defer, int X, int Y, int Width, int Height,
              BOOL Vertical, ULONG Types, int Count, BOOL Overlay)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA Data;
    int PerWin, Remain, Extra;

    if (Overlay)
    {
        Remain = 0;
    }
    else if (Vertical)
    {
        PerWin = Height / Count;
        Remain = Height - PerWin * Count;
        Height = PerWin + (Remain ? 1 : 0);
    }
    else
    {
        PerWin = Width / Count;
        Remain = Width - PerWin * Count;
        Width = PerWin + (Remain ? 1 : 0);
    }
        
    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        Data = ACTIVE_WIN_ENTRY(Entry);
        if ((Types & (1 << Data->m_enumType)) == 0 ||
            IsIconic(Data->m_Win))
        {
            continue;
        }

        DeferWindowPos(Defer, Data->m_Win, NULL, X, Y,
                       Width, Height, POS_ONLY);

        if (Overlay)
        {
            // All windows are stacked on top of each other.
        }
        else if (Vertical)
        {
            Y += Height;
            if (--Remain == 0)
            {
                Height--;
            }
        }
        else
        {
            X += Width;
            if (--Remain == 0)
            {
                Width--;
            }
        }
    }
}

void 
Arrange(void)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA pWinData;
    int         NumDoc, NumMem, NumWatchLocals, NumWin;
    int         NumLeft, NumRight;
    BOOL        AnyIcon = FALSE;
    HWND        hwndChild;
    HWND        hwndCpu;
    HWND        hwndWatch;
    HWND        hwndLocals;
    HWND        hwndCalls;
    HWND        hwndCmd;
    HWND        hwndDisasm;
    HWND        hwndScratch;
    HWND        hwndProcThread;

    // initialize to non-existent
    NumLeft = NumRight = 0;
    NumDoc = NumMem = NumWatchLocals = NumWin = 0;
    hwndWatch = hwndLocals = hwndCpu = hwndCalls = NULL;
    hwndCmd = hwndDisasm = hwndScratch = hwndProcThread = NULL;

    hwndChild = MDIGetActive(g_hwndMDIClient, NULL);
    if (hwndChild && IsZoomed(hwndChild))
    {
        // If there's a maximized window it covers the MDI
        // client area and arranging will have no visual effect.
        // Don't even bother to rearrange underlying windows
        // as this causes problems when switching between child
        // windows while a child is maximized.
        return;
    }

    //
    // Windows are either left-side windows or right-side windows.
    // Left-side windows are wider and can be relatively short,
    // while right-side windows are narrow but want height.
    // Left-side windows want to be 80 columns wide while
    // right side windows have both a minimum width and a desired
    // width.
    //
    // Right-side windows fill whatever space is left over to
    // the right of the left-side windows.  If that space is
    // less than the minimum the left-side windows have to give up space.
    //
    // Vertically each side is split up according to the specific
    // windows present.  On the right side the windows are
    // space equally top-to-bottom.
    // On the left side watch and locals windows are packed together
    // in one vertical area, as are memory windows.  Calls,
    // disassembly, document and command windows each get their own band.
    //

    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        pWinData = ACTIVE_WIN_ENTRY(Entry);
        // This window is participating in an operation
        // which may cause window messages.
        pWinData->m_InAutoOp++;
        
        hwndChild = pWinData->m_Win;
        if (hwndChild == NULL)
        {
            continue;
        }
        
        if (IsIconic(hwndChild))
        {
            AnyIcon = TRUE;
            continue;
        }

        NumWin++;
            
        switch (pWinData->m_enumType)
        {
        default:
            Assert(!_T("Unknown window type"));
            break;

        case WATCH_WINDOW:
            hwndWatch = hwndChild;
            if (++NumWatchLocals == 1)
            {
                NumLeft++;
            }
            break;
            
        case LOCALS_WINDOW:
            hwndLocals = hwndChild;
            if (++NumWatchLocals == 1)
            {
                NumLeft++;
            }
            break;
            
        case CPU_WINDOW:
            hwndCpu = hwndChild;
            NumRight++;
            break;
            
        case CALLS_WINDOW:
            hwndCalls = hwndChild;
            NumLeft++;
            break;
            
        case DOC_WINDOW:
            if ((g_WinOptions & WOPT_ARRANGE_ALL) == 0)
            {
                break;
            }
            
            if (++NumDoc == 1)
            {
                NumLeft++;
            }
            break;
            
        case DISASM_WINDOW:
            if ((g_WinOptions & WOPT_ARRANGE_ALL) == 0)
            {
                break;
            }
            
            hwndDisasm = hwndChild;
            NumLeft++;
            break;
            
        case CMD_WINDOW:
            hwndCmd = hwndChild;
            NumLeft++;
            break;

        case SCRATCH_PAD_WINDOW:
            hwndScratch = hwndChild;
            NumRight++;
            break;
            
        case MEM_WINDOW:
            if (++NumMem == 1)
            {
                NumLeft++;
            }
            break;

        case PROCESS_THREAD_WINDOW:
            hwndProcThread = hwndChild;
            NumLeft++;
            break;
        }
    }

    HDWP Defer = BeginDeferWindowPos(NumWin);
    if (Defer == NULL)
    {
        goto EndAutoOp;
    }

    // Now we have a count of all multiple wins and existence of special cases
    
    int AvailWidth = (int)g_MdiWidth;
    int AvailHeight = (int)g_MdiHeight;

    int X, Y, Width, MaxWidth, Height, RemainY;
        
    //
    // If icons present, don't cover them
    //
    if (AnyIcon)
    {
        AvailHeight -= GetSystemMetrics(SM_CYCAPTION) +
            GetSystemMetrics(SM_CYFRAME);
    }

    int LeftWidth = NumLeft > 0 ? LEFT_SIDE_WIDTH : 0;

    if (NumRight > 0)
    {
        switch(g_ActualProcType)
        {
        default:
            Width = RIGHT_SIDE_MIN_WIDTH_32;
            MaxWidth = RIGHT_SIDE_DESIRED_WIDTH_32;
            break;

        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AXP64:
        case IMAGE_FILE_MACHINE_AMD64:
            Width = RIGHT_SIDE_MIN_WIDTH_64;
            MaxWidth = RIGHT_SIDE_DESIRED_WIDTH_64;
            break;
        }

        if (AvailWidth < LeftWidth + Width)
        {
            // Not enough space for left side to be at
            // its desired width.
            if (NumLeft == 0)
            {
                // No left-side windows to take space from.
                Width = AvailWidth;
            }
            else
            {
                LeftWidth = AvailWidth - Width;
                if (LeftWidth < LEFT_SIDE_MIN_WIDTH)
                {
                    // We stole too much space so neither
                    // side can meet their minimum widths.  Just
                    // split the available space up.
                    Width = AvailWidth / 2;
                    LeftWidth = AvailWidth - Width;
                }
            }
        }
        else
        {
            // Take up space on the right side up to the
            // desired width but no more.  This gives
            // any extra space to the left side as the right
            // side doesn't really need any more than its desired
            // width.
            Width = AvailWidth - LeftWidth;
            if (Width > MaxWidth)
            {
                Width = MaxWidth;
                LeftWidth = AvailWidth - Width;
            }
        }

        X = LeftWidth;
        Y = 0;
        Height = AvailHeight / NumRight;
        
        if (hwndCpu != NULL)
        {
            DeferWindowPos(Defer, hwndCpu, NULL, X, Y,
                           Width, Height, POS_ONLY);
            Y += Height;
            Height = AvailHeight - Height;
        }

        if (hwndScratch != NULL)
        {
            DeferWindowPos(Defer, hwndScratch, NULL, X, Y,
                           Width, Height, POS_ONLY);
        }
    }
    else
    {
        LeftWidth = AvailWidth;
    }

    if (NumLeft == 0)
    {
        goto EndDefer;
    }

    int CmdHeight;
    int BiasedNumLeft;
    
    // Compute the size of each vertical band within the left side.
    // When doing so bias things so the command window gets
    // a 2.0 share to account for the fact that it has both
    // output and input areas.  Also give it any remainder
    // space left when dividing.
    BiasedNumLeft = NumLeft * 2 + (hwndCmd != NULL ? 2 : 0);
    Height = (AvailHeight * 2) / BiasedNumLeft;
    if (hwndCmd != NULL)
    {
        CmdHeight = AvailHeight - Height * (NumLeft - 1);
        RemainY = 0;
    }
    else
    {
        RemainY = Height * (NumLeft + 1) - AvailHeight;
    }
    Y = 0;

    // Place the watch and locals windows at the top.
    if (NumWatchLocals > 0)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        X = 0;
        Width = LeftWidth / NumWatchLocals;

        if (hwndWatch != NULL)
        {
            DeferWindowPos(Defer, hwndWatch, NULL, X, Y,
                           Width, Height, POS_ONLY);
            X += Width;
            Width = LeftWidth - X;
        }
        if (hwndLocals != NULL)
        {
            DeferWindowPos(Defer, hwndLocals, NULL, X, Y,
                           Width, Height, POS_ONLY);
            X += Width;
            Width = LeftWidth - X;
        }

        Y += Height;
    }

    // Place all the memory windows next.
    if (NumMem > 0)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        ArrangeInRect(Defer, 0, Y, LeftWidth, Height,
                      FALSE, 1 << MEM_WINDOW, NumMem, FALSE);
        
        Y += Height;
    }

    // Disasm window.
    if (hwndDisasm != NULL)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        DeferWindowPos(Defer, hwndDisasm, NULL, 0, Y,
                       LeftWidth, Height, POS_ONLY);
        
        Y += Height;
    }
    
    // Doc windows.
    if (NumDoc > 0)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        ArrangeInRect(Defer, 0, Y, LeftWidth, Height,
                      FALSE, 1 << DOC_WINDOW, NumDoc,
                      (g_WinOptions & WOPT_OVERLAY_SOURCE) != 0);
        
        Y += Height;
    }

    // Command window.
    if (hwndCmd != NULL)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        DeferWindowPos(Defer, hwndCmd, NULL, 0, Y,
                       LeftWidth, CmdHeight, POS_ONLY);
        
        Y += CmdHeight;
    }

    // Calls window.
    if (hwndCalls != NULL)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        DeferWindowPos(Defer, hwndCalls, NULL, 0, Y,
                       LeftWidth, Height, POS_ONLY);
        
        Y += Height;
    }

    // Processes and threads window.
    if (hwndProcThread != NULL)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        DeferWindowPos(Defer, hwndProcThread, NULL, 0, Y,
                       LeftWidth, Height, POS_ONLY);
        
        Y += Height;
    }

 EndDefer:
    EndDeferWindowPos(Defer);

 EndAutoOp:
    // The auto-op is finished.
    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        pWinData = ACTIVE_WIN_ENTRY(Entry);
        pWinData->m_InAutoOp--;
    }
}

void
UpdateSourceOverlay(void)
{
    // If we're turning off overlay just leave the windows
    // the way they are.
    if ((g_WinOptions & WOPT_OVERLAY_SOURCE) == 0)
    {
        return;
    }

    // If doc windows are auto-arranged just handle it
    // that way.
    if (IsAutoArranged(DOC_WINDOW))
    {
        Arrange();
        return;
    }
    
    // Source overlay was just turned on.  Pile all source
    // windows on top of the first one.
    
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA WinData;
    int X, Y;

    X = -INT_MAX;
    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        WinData = ACTIVE_WIN_ENTRY(Entry);
        if (WinData->m_enumType == DOC_WINDOW &&
            !IsIconic(WinData->m_Win))
        {
            if (X == -INT_MAX)
            {
                RECT Rect;
                
                // First window, remember its position.
                GetWindowRect(WinData->m_Win, &Rect);
                MapWindowPoints(GetDesktopWindow(), g_hwndMDIClient,
                                (LPPOINT)&Rect, 1);
                X = Rect.left;
                Y = Rect.top;
            }
            else
            {
                // Line up with the first window.
                SetWindowPos(WinData->m_Win, NULL, X, Y, 0, 0,
                         SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
            }
        }
    }
}

void
SetAllFonts(ULONG FontIndex)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA WinData;

    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        WinData = ACTIVE_WIN_ENTRY(Entry);
        if (WinData != NULL)
        {
            WinData->SetFont(FontIndex);
            // Treat this like a resize as the line height
            // may change.
            WinData->OnSize();
        }
    }

    if (g_WinOptions & WOPT_AUTO_ARRANGE)
    {
        Arrange();
    }
}

void
CloseAllWindows(void)
{
    HWND Win, Next;
    
    Win = MDIGetActive(g_hwndMDIClient, NULL);
    while (Win != NULL)
    {
        Next = GetNextWindow(Win, GW_HWNDNEXT);
        SendMessage(g_hwndMDIClient, WM_MDIDESTROY, (WPARAM)Win, 0);
        Win = Next;
    }
}

void
UpdateAllColors(void)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA WinData;

    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        WinData = ACTIVE_WIN_ENTRY(Entry);
        if (WinData != NULL)
        {
            WinData->UpdateColors();
        }
    }
}

PCOMMONWIN_DATA
FindNthWindow(ULONG Nth, ULONG Types)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA WinData;

    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        WinData = ACTIVE_WIN_ENTRY(Entry);
        if (WinData != NULL &&
            ((1 << WinData->m_enumType) & Types) &&
            Nth-- == 0)
        {
            return WinData;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\callswin.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    callswin.h

Abstract:

    This module contains the main line code for display of calls window.

Environment:

    Win32, User Mode

--*/

#ifndef __CALLSWIN_H__
#define __CALLSWIN_H__

#define MAX_FRAMES  1000

class CALLSWIN_DATA : public SINGLE_CHILDWIN_DATA
{
public:
    ULONG m_Flags;
    ULONG m_Frames;

    // Set in ReadState.
    ULONG m_FramesFound;
    ULONG m_TextOffset;

    static HMENU s_ContextMenu;
    
    CALLSWIN_DATA();

    virtual void Validate();

    virtual HRESULT ReadState(void);
    
    virtual void Copy();

    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual BOOL CodeExprAtCaret(PSTR Expr, PULONG64 Offset);
    virtual HRESULT StackFrameAtCaret(PDEBUG_STACK_FRAME pFrame);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnVKeyToItem(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

    void SyncUiWithFlags(ULONG Changed);
};
typedef CALLSWIN_DATA *PCALLSWIN_DATA;

#endif // #ifndef __CALLSWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\cmdwin.cpp ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    cmdwin.cpp

Abstract:

    New command window UI.

--*/

#include "precomp.hxx"
#pragma hdrstop

#define MAX_CMDWIN_LINES 30000

// Minimum window pane size.
#define MIN_PANE_SIZE 20

BOOL g_AutoCmdScroll = TRUE;

//
//
//
CMDWIN_DATA::CMDWIN_DATA()
    // State buffer isn't currently used.
    : COMMONWIN_DATA(256)
{
    m_enumType = CMD_WINDOW;
    m_bTrackingMouse = FALSE;
    m_nDividerPosition = 0;
    m_EditHeight = 0;
    m_hwndHistory = NULL;
    m_hwndEdit = NULL;
    m_bHistoryActive = FALSE;
    m_Prompt = NULL;
    m_PromptWidth = 0;
    m_OutputIndex = 0;
    m_OutputIndexAtEnd = TRUE;
    m_FindSel.cpMin = 1;
    m_FindSel.cpMax = 0;
    m_FindFlags = 0;
}

void
CMDWIN_DATA::Validate()
{
    COMMONWIN_DATA::Validate();

    Assert(CMD_WINDOW == m_enumType);

    Assert(m_hwndHistory);
    Assert(m_hwndEdit);
}

void
CMDWIN_DATA::Find(PTSTR Text, ULONG Flags)
{
    RicheditFind(m_hwndHistory, Text, Flags,
                 &m_FindSel, &m_FindFlags, FALSE);
}

BOOL
CMDWIN_DATA::OnCreate(void)
{
    m_EditHeight = 3 * m_Font->Metrics.tmHeight / 2;
    m_nDividerPosition = m_Size.cy - m_EditHeight;

    m_hwndHistory = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        RICHEDIT_CLASS,                             // class name
        NULL,                                       // title
        WS_CLIPSIBLINGS
        | WS_CHILD | WS_VISIBLE
        | WS_HSCROLL | WS_VSCROLL
        | ES_AUTOHSCROLL | ES_AUTOVSCROLL
        | ES_NOHIDESEL
        | ES_MULTILINE | ES_READONLY,               // style
        0,                                          // x
        0,                                          // y
        100,                                        // width
        100,                                        // height
        m_Win,                                      // parent
        (HMENU) IDC_RICHEDIT_CMD_HISTORY,           // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data
    if ( !m_hwndHistory )
    {
        return FALSE;
    }

    m_PromptWidth = 4 * m_Font->Metrics.tmAveCharWidth;
    
    m_Prompt = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        "STATIC",                                   // class name
        "",                                         // title
        WS_CLIPSIBLINGS
        | WS_CHILD | WS_VISIBLE,                    // style
        0,                                          // x
        100,                                        // y
        m_PromptWidth,                              // width
        100,                                        // height
        m_Win,                                      // parent
        (HMENU) IDC_STATIC,                         // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data
    if ( m_Prompt == NULL )
    {
        return FALSE;
    }

    m_hwndEdit = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        RICHEDIT_CLASS,                             // class name
        NULL,                                       // title
        WS_CLIPSIBLINGS
        | WS_CHILD | WS_VISIBLE
        | WS_VSCROLL | ES_AUTOVSCROLL
        | ES_NOHIDESEL
        | ES_MULTILINE,                             // style
        m_PromptWidth,                              // x
        100,                                        // y
        100,                                        // width
        100,                                        // height
        m_Win,                                      // parent
        (HMENU) IDC_RICHEDIT_CMD_EDIT,              // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data
    if ( !m_hwndEdit )
    {
        return FALSE;
    }

    SetFont( FONT_FIXED );

    // Tell the edit control we want notification of keyboard input
    // so that we can automatically set focus to the edit window.
    SendMessage(m_hwndHistory, EM_SETEVENTMASK, 0, ENM_KEYEVENTS |
                ENM_MOUSEEVENTS);

    // Tell the edit controls, that we want notification of keyboard input
    // This is so we can process the enter key, and then send that text into
    // the History window.
    SendMessage(m_hwndEdit, EM_SETEVENTMASK, 0, ENM_KEYEVENTS |
                ENM_MOUSEEVENTS);

    return TRUE;
}

void
CMDWIN_DATA::SetFont(ULONG FontIndex)
{
    COMMONWIN_DATA::SetFont(FontIndex);

    SendMessage(m_hwndHistory, WM_SETFONT, (WPARAM)m_Font->Font, TRUE);
    SendMessage(m_hwndEdit, WM_SETFONT, (WPARAM)m_Font->Font, TRUE);
    SendMessage(m_Prompt, WM_SETFONT, (WPARAM)m_Font->Font, TRUE);
}

BOOL
CMDWIN_DATA::CanCopy()
{
    HWND hwnd = m_bHistoryActive ? m_hwndHistory : m_hwndEdit;
    CHARRANGE chrg;

    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&chrg);
    return chrg.cpMin != chrg.cpMax;
}

BOOL
CMDWIN_DATA::CanCut()
{
    return !m_bHistoryActive && CanCopy() &&
        (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY) == 0;
}

BOOL
CMDWIN_DATA::CanPaste()
{
    return !m_bHistoryActive 
        && SendMessage(m_hwndEdit, EM_CANPASTE, CF_TEXT, 0);
}

void
CMDWIN_DATA::Copy()
{
    HWND hwnd = m_bHistoryActive ? m_hwndHistory : m_hwndEdit;

    SendMessage(hwnd, WM_COPY, 0, 0);
}

void
CMDWIN_DATA::Cut()
{
    SendMessage(m_hwndEdit, WM_CUT, 0, 0);
}

void
CMDWIN_DATA::Paste()
{
    SendMessage(m_hwndEdit, WM_PASTE, 0, 0);
}

BOOL
CMDWIN_DATA::CanSelectAll()
{
    return m_bHistoryActive;
}

void
CMDWIN_DATA::SelectAll()
{
    CHARRANGE Sel;

    Sel.cpMin = 0;
    Sel.cpMax = INT_MAX;
    SendMessage(m_hwndHistory, EM_EXSETSEL, 0, (LPARAM)&Sel);
}

LRESULT
CMDWIN_DATA::OnCommand(WPARAM wParam, LPARAM lParam)
{
    int  idEditCtrl = (int) LOWORD(wParam); // identifier of edit control 
    WORD wNotifyCode = HIWORD(wParam);      // notification code 
    HWND hwndEditCtrl = (HWND) lParam;      // handle of edit control 

    switch (wNotifyCode)
    {
    case EN_SETFOCUS:
        m_bHistoryActive = IDC_RICHEDIT_CMD_HISTORY == idEditCtrl;
        return 0;

    }

    return 1;
}
    
void 
CMDWIN_DATA::OnSetFocus()
{
    if (m_bHistoryActive)
    {
        ::SetFocus(m_hwndHistory);
    }
    else
    {
        ::SetFocus(m_hwndEdit);
    }
}

void 
CMDWIN_DATA::OnSize(void)
{
    const int nDividerHeight = GetSystemMetrics(SM_CYEDGE);
    int nHistoryHeight;

    // Attempt to keep the input area the same size as it was
    // and modify the output area.  If the input area would
    // take up more than half the window shrink it also.
    if (m_EditHeight > (int)m_Size.cy / 2)
    {
        m_EditHeight = m_Size.cy / 2;
    }
    else if (m_EditHeight < MIN_PANE_SIZE)
    {
        m_EditHeight = MIN_PANE_SIZE;
    }
    nHistoryHeight = m_Size.cy - m_EditHeight - nDividerHeight / 2;
    m_nDividerPosition = m_Size.cy - m_EditHeight;

    if ((int)m_PromptWidth > m_Size.cx / 2)
    {
        m_PromptWidth = m_Size.cx / 2;
    }

    MoveWindow(m_hwndHistory,
               0, 
               0, 
               m_Size.cx, 
               nHistoryHeight, 
               TRUE
               );

    MoveWindow(m_Prompt,
               0,
               nHistoryHeight + nDividerHeight,
               m_PromptWidth,
               m_Size.cy - nHistoryHeight - nDividerHeight, 
               TRUE
               );
    
    MoveWindow(m_hwndEdit, 
               m_PromptWidth,
               nHistoryHeight + nDividerHeight,
               m_Size.cx - m_PromptWidth, 
               m_Size.cy - nHistoryHeight - nDividerHeight, 
               TRUE
               );

    if (g_AutoCmdScroll)
    {
        // Keep the caret visible in both windows.
        SendMessage(m_hwndHistory, EM_SCROLLCARET, 0, 0);
        SendMessage(m_hwndEdit, EM_SCROLLCARET, 0, 0);
    }
}

void
CMDWIN_DATA::OnButtonDown(ULONG Button)
{
    if (Button & MK_LBUTTON)
    {
        m_bTrackingMouse = TRUE;
        SetCapture(m_Win);
    }
}

void
CMDWIN_DATA::OnButtonUp(ULONG Button)
{
    if (Button & MK_LBUTTON)
    {
        if (m_bTrackingMouse)
        {
            m_bTrackingMouse = FALSE;
            ReleaseCapture();
        }
    }
}

void
CMDWIN_DATA::OnMouseMove(ULONG Modifiers, ULONG X, ULONG Y)
{
    if (MK_LBUTTON & Modifiers && m_bTrackingMouse)
    {
        // We are resizing the History & Edit Windows
        // Y position centered vertically around the cursor
        ULONG EdgeHeight = GetSystemMetrics(SM_CYEDGE);
        MoveDivider(Y - EdgeHeight / 2);
    }
}

LRESULT
CMDWIN_DATA::OnNotify(WPARAM wParam, LPARAM lParam)
{
    MSGFILTER * lpMsgFilter = (MSGFILTER *) lParam;
    
    if (EN_MSGFILTER != lpMsgFilter->nmhdr.code)
    {
        return 0;
    }

    if (WM_RBUTTONDOWN == lpMsgFilter->msg ||
        WM_RBUTTONDBLCLK == lpMsgFilter->msg)
    {
        // If there's a selection copy it to the clipboard
        // and clear it.  Otherwise try to paste.
        if (CanCopy())
        {
            Copy();
            
            CHARRANGE Sel;
            HWND hwnd = m_bHistoryActive ? m_hwndHistory : m_hwndEdit;
            SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&Sel);
            Sel.cpMax = Sel.cpMin;
            SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&Sel);
        }
        else if (SendMessage(m_hwndEdit, EM_CANPASTE, CF_TEXT, 0))
        {
            SetFocus(m_hwndEdit);
            Paste();
        }
        
        // Ignore right-button events.
        return 1;
    }
    else if (lpMsgFilter->msg < WM_KEYFIRST || lpMsgFilter->msg > WM_KEYLAST)
    {
        // Process all non-key events.
        return 0;
    }
    else if (WM_SYSKEYDOWN == lpMsgFilter->msg ||
             WM_SYSKEYUP == lpMsgFilter->msg ||
             WM_SYSCHAR == lpMsgFilter->msg)
    {
        // Process menu operations though the default so
        // that the Alt-minus menu works.
        return 1;
    }

    // Allow tab to toggle between the windows.
    // Make sure that it isn't a Ctrl-Tab or Alt-Tab.
    if (WM_KEYUP == lpMsgFilter->msg && VK_TAB == lpMsgFilter->wParam &&
        GetKeyState(VK_CONTROL) >= 0 && GetKeyState(VK_MENU) >= 0)
    {
        HWND hwnd = m_bHistoryActive ? m_hwndEdit : m_hwndHistory;
        SetFocus(hwnd);
        return 1;
    }
    else if ((WM_KEYDOWN == lpMsgFilter->msg &&
              VK_TAB == lpMsgFilter->wParam) ||
             (WM_CHAR == lpMsgFilter->msg &&
              '\t' == lpMsgFilter->wParam))
    {
        return 1;
    }

    switch (wParam)
    {
    case IDC_RICHEDIT_CMD_HISTORY:
        // Ignore key-ups to ignore the tail end of
        // menu operations.  The switch below will occur on
        // key-down anyway so key-up doesn't need to do it.
        if (WM_KEYUP == lpMsgFilter->msg)
        {
            return 0;
        }
        
        // Allow keyboard navigation in the history text.
        if (WM_KEYDOWN == lpMsgFilter->msg)
        {
            switch(lpMsgFilter->wParam)
            {
            case VK_LEFT:
            case VK_RIGHT:
            case VK_UP:
            case VK_DOWN:
            case VK_PRIOR:
            case VK_NEXT:
            case VK_HOME:
            case VK_END:
            case VK_SHIFT:
            case VK_CONTROL:
                return 0;
            }
        }

        // Forward key events to the edit window.
        SetFocus(m_hwndEdit);
        SendMessage(m_hwndEdit, lpMsgFilter->msg, lpMsgFilter->wParam,
                    lpMsgFilter->lParam);
        return 1; // ignore

    case IDC_RICHEDIT_CMD_EDIT:
        // If the window isn't accepting input don't do history.
        if (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY)
        {
            return 1;
        }
        
        static HISTORY_LIST *pHistoryList = NULL;

        switch (lpMsgFilter->msg)
        {
        case WM_KEYDOWN:
            switch (lpMsgFilter->wParam)
            {
            default:
                return 0;

            case VK_RETURN:

                // Reset the history list
                pHistoryList = NULL;
                    
                int nLen;
                TEXTRANGE TextRange;
                
                // Get length.
                // +1 we have to take into account the null terminator.
                nLen = GetWindowTextLength(lpMsgFilter->nmhdr.hwndFrom) +1;

                // Get everything
                TextRange.chrg.cpMin = 0;
                TextRange.chrg.cpMax = -1;
                TextRange.lpstrText = (PTSTR) calloc(nLen, sizeof(TCHAR));

                if (TextRange.lpstrText)
                {
                    // Okay got the text
                    GetWindowText(m_hwndEdit, 
                                  TextRange.lpstrText,
                                  nLen
                                  );
                    SetWindowText(m_hwndEdit, 
                                  _T("") 
                                  );

                    CmdExecuteCmd(TextRange.lpstrText, UIC_CMD_INPUT);

                    free(TextRange.lpstrText);
                }

                // ignore the event
                return 1;

            case VK_UP:
            case VK_DOWN:
                CHARRANGE End;
                LRESULT LineCount;

                End.cpMin = INT_MAX;
                End.cpMax = INT_MAX;

                if (IsListEmpty( (PLIST_ENTRY) &m_listHistory ))
                {
                    return 0; // process
                }
                    
                LineCount = SendMessage(m_hwndEdit, EM_GETLINECOUNT, 0, 0);
                if (LineCount != 1)
                {
                    // If more than 1 line, then scroll through the text
                    // unless at the top or bottom line.
                    if (VK_UP == lpMsgFilter->wParam)
                    {
                        if (SendMessage(m_hwndEdit, EM_LINEINDEX, -1, 0) != 0)
                        {
                            return 0;
                        }
                    }
                    else
                    {
                        if (SendMessage(m_hwndEdit, EM_LINEFROMCHAR, -1, 0) <
                            LineCount - 1)
                        {
                            return 0;
                        }
                    }
                } 

                if (NULL == pHistoryList)
                {
                    // first time scrolling thru the list,
                    // start at the beginning
                    pHistoryList = (HISTORY_LIST *) m_listHistory.Flink;
                    SetWindowText(m_hwndEdit, pHistoryList->m_psz);
                    // Put the cursor at the end.
                    SendMessage(m_hwndEdit, EM_EXSETSEL, 0, (LPARAM)&End);
                    SendMessage(m_hwndEdit, EM_SCROLLCARET, 0, 0);
                    return 1; // ignore
                }
                        
                if (VK_UP == lpMsgFilter->wParam)
                {
                    // up
                    if (pHistoryList->Flink != (PLIST_ENTRY) &m_listHistory)
                    {
                        pHistoryList = (HISTORY_LIST *) pHistoryList->Flink;
                    }
                    else
                    {
                        return 0; // process
                    }
                    SetWindowText(m_hwndEdit, pHistoryList->m_psz);
                    // Put the cursor at the end.
                    SendMessage(m_hwndEdit, EM_EXSETSEL, 0, (LPARAM)&End);
                    SendMessage(m_hwndEdit, EM_SCROLLCARET, 0, 0);
                    return 1; // ignore
                }
                else
                {
                    // down
                    if (pHistoryList->Blink != (PLIST_ENTRY) &m_listHistory)
                    {
                        pHistoryList = (HISTORY_LIST *) pHistoryList->Blink;
                    }
                    else
                    {
                        return 0; // process
                    }
                    SetWindowText(m_hwndEdit, pHistoryList->m_psz);
                    // Put the cursor at the end.
                    SendMessage(m_hwndEdit, EM_EXSETSEL, 0, (LPARAM)&End);
                    SendMessage(m_hwndEdit, EM_SCROLLCARET, 0, 0);
                    return 1; // ignore
                }
                    
            case VK_ESCAPE:
                // Clear the current command.
                SetWindowText(m_hwndEdit, "");
                // Reset the history list
                pHistoryList = NULL;
                return 1;
            }
        }

        // process the event
        return 0;
    }

    return 0;
}

void
CMDWIN_DATA::OnUpdate(UpdateType Type)
{
    PSTR Prompt = NULL;
    
    if (Type == UPDATE_EXEC ||
        Type == UPDATE_INPUT_REQUIRED)
    {
        if (Type == UPDATE_INPUT_REQUIRED ||
            g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            SendMessage(m_hwndEdit, EM_SETBKGNDCOLOR, TRUE, 0);
            SendMessage(m_hwndEdit, EM_SETREADONLY, FALSE, 0);
            SetWindowText(m_hwndEdit, _T(""));

            //
            // If WinDBG is minized and we breakin, flash the window
            //

            if (IsIconic(g_hwndFrame) && g_FlashWindowEx != NULL)
            {
                FLASHWINFO FlashInfo = {sizeof(FLASHWINFO), g_hwndFrame,
                                        FLASHW_ALL | FLASHW_TIMERNOFG,
                                        0, 0};

                g_FlashWindowEx(&FlashInfo);
            }
        }
        else
        {
            PSTR Message;

            if (!g_SessionActive ||
                g_ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
            {
                Message = "Debuggee not connected";
            }
            else
            {
                Message = "Debuggee is running...";
            }
            SetWindowText(m_hwndEdit, Message);
            SendMessage(m_hwndEdit, EM_SETBKGNDCOLOR, 0,
                        GetSysColor(COLOR_3DFACE));
            SendMessage(m_hwndEdit, EM_SETREADONLY, TRUE, 0);
        }

        if (Type == UPDATE_INPUT_REQUIRED)
        {
            // Indicate this is an input string and not debugger
            // commands.
            Prompt = "Input>";
        }
        else
        {
            // Put the existing prompt back.
            Prompt = g_PromptText;
        }
    }
    else if (Type == UPDATE_PROMPT_TEXT)
    {
        Prompt = g_PromptText;
    }

    if (Prompt != NULL)
    {
        if (Prompt[0] != 0)
        {
            ULONG Width = (strlen(Prompt) + 1) *
                m_Font->Metrics.tmAveCharWidth;
            if (Width != m_PromptWidth)
            {
                m_PromptWidth = Width;
                OnSize();
            }
        }
        
        SetWindowText(m_Prompt, Prompt);
    }
}

ULONG
CMDWIN_DATA::GetWorkspaceSize(void)
{
    return COMMONWIN_DATA::GetWorkspaceSize() + sizeof(int);
}

PUCHAR
CMDWIN_DATA::SetWorkspace(PUCHAR Data)
{
    Data = COMMONWIN_DATA::SetWorkspace(Data);
    // The divider position is relative to the top of
    // the window.  This means that if the window
    // grows suddenly the edit area will grow to
    // fill the space rather than keeping it the same
    // size.  To avoid this we save the position
    // relative to the bottom of the window so that
    // the edit window stays the same size even when
    // the overall window changes size.
    // Previous versions didn't do this inversion, so
    // we mark the new style with a negative value.
    *(int*)Data = -(int)(m_Size.cy - m_nDividerPosition);
    Data += sizeof(int);
    return Data;
}

PUCHAR
CMDWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    Data = COMMONWIN_DATA::ApplyWorkspace1(Data, End);

    if (End - Data >= sizeof(int))
    {
        int Pos = *(int*)Data;
        // Handle old-style top-relative positive values and
        // new-style bottom-relative negative values.
        MoveDivider(Pos >= 0 ? Pos : m_Size.cy + Pos);
        Data += sizeof(int);
    }

    return Data;
}
    
void
CMDWIN_DATA::MoveDivider(int Pos)
{
    if (Pos == m_nDividerPosition)
    {
        return;
    }
    
    m_nDividerPosition = Pos;
    m_EditHeight = m_Size.cy - m_nDividerPosition;

    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
    }
    
    SendMessage(m_Win, WM_SIZE, SIZE_RESTORED, 
                MAKELPARAM(m_Size.cx, m_Size.cy));
}

void 
CMDWIN_DATA::AddCmdToHistory(PCSTR pszCmd)
/*++
Description:
    Add a command to the command history.

    If the command already exists, just move it to 
    the beginning of the list. This way we don't 
    repeat commands.
--*/
{
    Assert(pszCmd);

    HISTORY_LIST *p = NULL;
    BOOL fWhiteSpace;
    BOOL fFoundDuplicate;

    //
    // Does the command contain whitespace? If it does, it may be a command
    // that requires arguments. If it does have arguments, then string
    // comparisons must be case sensitive.
    //
    fWhiteSpace = _tcscspn(pszCmd, _T(" \t") ) != _tcslen(pszCmd);

    p = (HISTORY_LIST *) m_listHistory.Flink;
    while (p != &m_listHistory)
    {
        fFoundDuplicate = FALSE;

        if (fWhiteSpace)
        {
            if ( !_tcscmp(p->m_psz, pszCmd) )
            {
                fFoundDuplicate = TRUE;
            }
        }
        else
        {
            if ( !_tcsicmp(p->m_psz, pszCmd) )
            {
                fFoundDuplicate = TRUE;
            }
        }

        if (fFoundDuplicate)
        {
            RemoveEntryList( (PLIST_ENTRY) p );
            InsertHeadList( (PLIST_ENTRY) &m_listHistory, (PLIST_ENTRY) p);
            return;
        }

        p = (HISTORY_LIST *) p->Flink;
    }

    // This cmd is new to the list, add it
    p = new HISTORY_LIST;
    if (p != NULL)
    {
        p->m_psz = _tcsdup(pszCmd);
        if (p->m_psz != NULL)
        {
            InsertHeadList( (PLIST_ENTRY) &m_listHistory, (PLIST_ENTRY) p);
        }
        else
        {
            delete p;
        }
    }
}

void
CMDWIN_DATA::AddText(PTSTR Text, COLORREF Fg, COLORREF Bg)
{
    CHARRANGE OrigSel;
    POINT OrigScroll;
    CHARRANGE TextRange;

#if 0
    DebugPrint("Add %d chars, %p - %p\n",
               strlen(Text), Text, Text + strlen(Text));
#endif
    
    SendMessage(m_hwndHistory, WM_SETREDRAW, FALSE, 0);
    SendMessage(m_hwndHistory, EM_EXGETSEL, 0, (LPARAM)&OrigSel);
    SendMessage(m_hwndHistory, EM_GETSCROLLPOS, 0, (LPARAM)&OrigScroll);
    
    // The selection is lost when adding text so discard
    // any previous find results.
    if (g_AutoCmdScroll && m_FindSel.cpMax >= m_FindSel.cpMin)
    {
        m_FindSel.cpMin = 1;
        m_FindSel.cpMax = 0;
    }

    //
    // are there too many lines in the buffer?
    //
    
    INT Overflow;
    
    Overflow = (INT)SendMessage(m_hwndHistory, EM_GETLINECOUNT, 0, 0) -
        MAX_CMDWIN_LINES;
    if (Overflow > 0)
    {
        //
        // delete more than we need to so it doesn't happen
        // every time a line is printed.
        //
        TextRange.cpMin = 0;
        // Get the character index of the 50th line past the overflow.
        TextRange.cpMax = (LONG)
            SendMessage(m_hwndHistory, 
                        EM_LINEINDEX, 
                        Overflow + 50,
                        0
                        );

        SendMessage(m_hwndHistory, 
                    EM_EXSETSEL, 
                    0,
                    (LPARAM) &TextRange
                    );
        
        SendMessage(m_hwndHistory, 
                    EM_REPLACESEL, 
                    FALSE,
                    (LPARAM) _T("")
                    );

        m_OutputIndex -= TextRange.cpMax;
        if (!g_AutoCmdScroll)
        {
            if (m_FindSel.cpMax >= m_FindSel.cpMin)
            {
                m_FindSel.cpMin -= TextRange.cpMax;
                m_FindSel.cpMax -= TextRange.cpMax;
                if (m_FindSel.cpMin < 0)
                {
                    // Find is at least partially gone so
                    // throw it away.
                    m_FindSel.cpMin = 1;
                    m_FindSel.cpMax = 0;
                }
            }
            OrigSel.cpMin -= TextRange.cpMax;
            OrigSel.cpMax -= TextRange.cpMax;
            if (OrigSel.cpMin < 0)
            {
                OrigSel.cpMin = 0;
            }
            if (OrigSel.cpMax < 0)
            {
                OrigSel.cpMax = 0;
            }
        }
    }

    //
    // Output the text to the cmd window.  The command
    // window is emulating a console window so we need
    // to emulate the effects of backspaces and carriage returns.
    //

    for (;;)
    {
        PSTR Stop, Scan;
        char Save;

        // Find the first occurrence of an emulated char.
        // If the output index is at the end of the text
        // there's no need to specially emulate newline.
        // This is a very common case and not splitting
        // up output for it greatly enhances append performance.
        Stop = strchr(Text, '\r');
        Scan = strchr(Text, '\b');
        if (Stop == NULL || (Scan != NULL && Scan < Stop))
        {
            Stop = Scan;
        }
        if (!m_OutputIndexAtEnd)
        {
            Scan = strchr(Text, '\n');
            if (Stop == NULL || (Scan != NULL && Scan < Stop))
            {
                Stop = Scan;
            }
        }

        // Add all text up to the emulated char.
        if (Stop != NULL)
        {
            Save = *Stop;
            *Stop = 0;
        }

        if (*Text)
        {
            LONG Len = strlen(Text);

            // Replace any text that might already be there.
            TextRange.cpMin = m_OutputIndex;
            TextRange.cpMax = m_OutputIndex + Len;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            SendMessage(m_hwndHistory, EM_REPLACESEL, 
                        FALSE, (LPARAM)Text);

            m_OutputIndex = TextRange.cpMax;
            
            CHARFORMAT2 Fmt;

            ZeroMemory(&Fmt, sizeof(Fmt));
            Fmt.cbSize = sizeof(Fmt);
            Fmt.dwMask = CFM_COLOR | CFM_BACKCOLOR;
            Fmt.crTextColor = Fg;
            Fmt.crBackColor = Bg;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            SendMessage(m_hwndHistory, EM_SETCHARFORMAT,
                        SCF_SELECTION, (LPARAM)&Fmt);
            
            TextRange.cpMin = TextRange.cpMax;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
        }

        // If there weren't any emulated chars all the remaining text
        // was just added so we're done.
        if (Stop == NULL)
        {
            break;
        }

        Text = Stop;
        *Stop = Save;

        // Emulate the character.
        if (Save == '\b')
        {
            TextRange.cpMax = m_OutputIndex;
            do
            {
                if (m_OutputIndex > 0)
                {
                    m_OutputIndex--;
                }
            } while (*(++Text) == '\b');
            TextRange.cpMin = m_OutputIndex;

            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            SendMessage(m_hwndHistory, EM_REPLACESEL,
                        FALSE, (LPARAM)"");
        }
        else if (Save == '\n')
        {
            // Move the output position to the next line.
            // This routine always appends text to the very
            // end of the control so that's always the last
            // position in the control.
            TextRange.cpMin = INT_MAX;
            TextRange.cpMax = INT_MAX;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            
            do
            {
                SendMessage(m_hwndHistory, EM_REPLACESEL,
                            FALSE, (LPARAM)"\n");
            } while (*(++Text) == '\n');
            
            SendMessage(m_hwndHistory, EM_EXGETSEL, 
                        0, (LPARAM)&TextRange);
            m_OutputIndex = TextRange.cpMax;
            m_OutputIndexAtEnd = TRUE;
        }
        else if (Save == '\r')
        {
            // Return the output position to the beginning of
            // the current line.
            TextRange.cpMin = m_OutputIndex;
            TextRange.cpMax = m_OutputIndex;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            m_OutputIndex = (LONG)
                SendMessage(m_hwndHistory, EM_LINEINDEX, -1, 0);
            m_OutputIndexAtEnd = FALSE;
            
            while (*(++Text) == '\r')
            {
                // Advance.
            }
        }
        else
        {
            Assert(FALSE);
        }
    }

    if (g_AutoCmdScroll)
    {
        // Force the window to scroll to the bottom of the text.
        SendMessage(m_hwndHistory, EM_SCROLLCARET, 0, 0);
    }
    else
    {
        // Restore original selection.
        SendMessage(m_hwndHistory, EM_EXSETSEL, 0, (LPARAM)&OrigSel);
        SendMessage(m_hwndHistory, EM_SETSCROLLPOS, 0, (LPARAM)&OrigScroll);
    }

    SendMessage(m_hwndHistory, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndHistory, NULL, TRUE);
}

void
CMDWIN_DATA::Clear(void)
{
    SetWindowText(m_hwndHistory, "");
    m_OutputIndex = 0;
    m_OutputIndexAtEnd = TRUE;
}

void
ClearCmdWindow(void)
{
    HWND CmdWin = GetCmdHwnd();
    if (CmdWin == NULL)
    {
        return;
    }
    
    PCMDWIN_DATA CmdWinData = GetCmdWinData(CmdWin);
    if (CmdWinData == NULL)
    {
        return;
    }

    CmdWinData->Clear();
}

BOOL
CmdOutput(PTSTR pszStr, COLORREF Fg, COLORREF Bg)
{
    PCMDWIN_DATA pCmdWinData;
    BOOL fRet = TRUE;

    //
    //  Ensure that the command window exists
    //

    if ( !GetCmdHwnd() )
    {
        if ( !NewCmd_CreateWindow(g_hwndMDIClient) )
        {
            return FALSE;
        }
    }

    pCmdWinData = GetCmdWinData(GetCmdHwnd());
    if (!pCmdWinData)
    {
        return FALSE;
    }

    pCmdWinData->AddText(pszStr, Fg, Bg);
    
    return TRUE;
}


int
CDECL
CmdLogVar(
    WORD wFormat,
    ...
    )
{
    TCHAR szFormat[MAX_MSG_TXT];
    TCHAR szText[MAX_VAR_MSG_TXT];
    va_list vargs;

    // load format string from resource file
    Dbg(LoadString(g_hInst, wFormat, (PTSTR)szFormat, MAX_MSG_TXT));
    va_start(vargs, wFormat);
    _vstprintf(szText, szFormat, vargs);
    va_end(vargs);

    COLORREF Fg, Bg;

    GetOutMaskColors(DEBUG_OUTPUT_NORMAL, &Fg, &Bg);
    return CmdOutput(szText, Fg, Bg);
}

void
CmdLogFmt(
    PCTSTR  lpFmt,
    ...
    )
{
    TCHAR szText[MAX_VAR_MSG_TXT];
    va_list vargs;


    va_start(vargs, lpFmt);
    _vsntprintf(szText, MAX_VAR_MSG_TXT-1, lpFmt, vargs);
    va_end(vargs);

    COLORREF Fg, Bg;

    GetOutMaskColors(DEBUG_OUTPUT_NORMAL, &Fg, &Bg);
    CmdOutput(szText, Fg, Bg);
}

void
CmdOpenSourceFile(PSTR File)
{
    char Found[MAX_SOURCE_PATH];

    if (File == NULL)
    {
        CmdLogFmt("Usage: .open filename\n");
        return;
    }
    
    // Look up the reported file along the source path.
    // XXX drewb - Use first-match and then element walk to
    // determine ambiguities and display resolution UI.
    if (g_pUiLocSymbols->
        FindSourceFile(0, File,
                       DEBUG_FIND_SOURCE_BEST_MATCH |
                       DEBUG_FIND_SOURCE_FULL_PATH,
                       NULL, Found, sizeof(Found), NULL) != S_OK)
    {
        CmdLogFmt("Unable to find '%s'\n", File);
    }
    else
    {
        OpenOrActivateFile(Found, NULL, -1, TRUE, TRUE);
    }
}

BOOL
DirectCommand(PSTR Command)
{
    char Term;
    PSTR Scan, Arg;

    //
    // Check and see if this is a UI command
    // vs. a command that should go to the engine.
    //
    
    while (isspace(*Command))
    {
        Command++;
    }
    Scan = Command;
    while (*Scan && !isspace(*Scan))
    {
        Scan++;
    }
    Term = *Scan;
    *Scan = 0;

    // Advance to next nonspace char for arguments.
    if (Term != 0)
    {
        Arg = Scan + 1;
        while (isspace(*Arg))
        {
            Arg++;
        }
        if (*Arg == 0)
        {
            Arg = NULL;
        }
    }
    else
    {
        Arg = NULL;
    }

    if (!_strcmpi(Command, ".cls"))
    {
        ClearCmdWindow();
    }
    else if (!_strcmpi(Command, ".hh"))
    {
        if (Arg == NULL)
        {
            OpenHelpTopic(HELP_TOPIC_TABLE_OF_CONTENTS);
        }
        else
        {
            OpenHelpIndex(Arg);
        }
    }
    else if (!_strcmpi(Command, ".lsrcpath") ||
             !_strcmpi(Command, ".lsrcpath+"))
    {
        *Scan = Term;
        
        // Apply source path changes to the local symbol
        // object to update its source path.
        if (g_RemoteClient)
        {
            char Path[MAX_ENGINE_PATH];
            
            // Convert .lsrcpath to .srcpath.
            Command[1] = '.';
            g_pUiLocControl->Execute(DEBUG_OUTCTL_IGNORE, Command + 1,
                                     DEBUG_EXECUTE_NOT_LOGGED |
                                     DEBUG_EXECUTE_NO_REPEAT);
            if (g_pUiLocSymbols->GetSourcePath(Path, sizeof(Path),
                                               NULL) == S_OK)
            {
                CmdLogFmt("Local source search path is: %s\n", Path);
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetString(WSP_GLOBAL_LOCAL_SOURCE_PATH, Path);
                }
            }
            
            // Refresh windows affected by the source path.
            InvalidateStateBuffers(1 << EVENT_BIT);
            UpdateEngine();
        }
        else
        {
            CmdLogFmt("lsrcpath is only enabled for remote clients\n");
        }
    }
    else if (!_strcmpi(Command, ".open"))
    {
        CmdOpenSourceFile(Arg);
    }
    else if (!_strcmpi(Command, ".restart"))
    {
        AddEnumCommand(UIC_RESTART);
    }
    else if (!_strcmpi(Command, ".server"))
    {
        // We don't interpret this but we need to update
        // the title.
        SetTitleServerText("Server '%s'", Arg);
        *Scan = Term;
        return FALSE;
    }
    else
    {
        *Scan = Term;
        return FALSE;
    }

    // Handled so no need to patch up the command.
    return TRUE;
}

int
CmdExecuteCmd(
    PCTSTR pszCmd,
        UiCommand UiCmd
    )
{
    PCMDWIN_DATA    pCmdWinData = NULL;
    PTSTR           pszDupe = NULL;
    PTSTR           pszToken = NULL;

    if ( !GetCmdHwnd() )
    {
        NewCmd_CreateWindow(g_hwndMDIClient);
    }
    pCmdWinData = GetCmdWinData(GetCmdHwnd());

    pszDupe = _tcsdup(pszCmd);
    pszToken = _tcstok(pszDupe, _T("\r\n") );

    if (pszToken == NULL)
    {
        // Blank command, important for repeats in
        // the engine but not for the history window.
        AddStringCommand(UiCmd, pszCmd);
    }
    else
    {
        for (; pszToken; pszToken = _tcstok(NULL, _T("\r\n") ) )
        {
            if (pCmdWinData)
            {
                pCmdWinData->AddCmdToHistory(pszToken);
            }

            if (!DirectCommand(pszToken))
            {
                AddStringCommand(UiCmd, pszToken);
            }
        }
    }

    free(pszDupe);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\cmdwin.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    ncmdwin.h

Abstract:

    Command Window data structure and definition
    
Environment:

    Win32, User Mode

--*/

extern BOOL g_AutoCmdScroll;

class CMDWIN_DATA : public COMMONWIN_DATA {
public:
    //
    // Internal class
    //
    class HISTORY_LIST : public LIST_ENTRY {
    public:
        PTSTR           m_psz;

        HISTORY_LIST()
        {
            InitializeListHead( (PLIST_ENTRY) this );
            m_psz = NULL;
        }

        virtual ~HISTORY_LIST()
        {
            RemoveEntryList( (PLIST_ENTRY) this );

            if (m_psz) {
                free(m_psz);
            }
        }
    };



public:
    //
    // Used to resize the divided windows.
    //
    BOOL                m_bTrackingMouse;
    int                 m_nDividerPosition;
    int                 m_EditHeight;

    //
    // Handle to the two main cmd windows.
    //
    HWND                m_hwndHistory;
    HWND                m_hwndEdit;
    BOOL                m_bHistoryActive;

    // Prompt display static text control.
    HWND                m_Prompt;
    ULONG               m_PromptWidth;
    
    HISTORY_LIST        m_listHistory;

    // Character index to place output at.
    LONG                m_OutputIndex;
    BOOL                m_OutputIndexAtEnd;

    CHARRANGE           m_FindSel;
    ULONG               m_FindFlags;


    CMDWIN_DATA();

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);

    virtual BOOL CanCopy();
    virtual BOOL CanCut();
    virtual BOOL CanPaste();
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();
    virtual BOOL CanSelectAll();
    virtual void SelectAll();
    
    virtual void Find(PTSTR Text, ULONG Flags);
    
    // Functions called in response to WM messages
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSetFocus(void);
    virtual void OnSize(void);
    virtual void OnButtonDown(ULONG Button);
    virtual void OnButtonUp(ULONG Button);
    virtual void OnMouseMove(ULONG Modifiers, ULONG X, ULONG Y);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

    void MoveDivider(int Pos);
    void AddCmdToHistory(PCSTR);
    void AddText(PTSTR Text, COLORREF Fg, COLORREF Bg);
    void Clear(void);
};
typedef CMDWIN_DATA *PCMDWIN_DATA;

void ClearCmdWindow(void);
BOOL CmdOutput(PTSTR pszStr, COLORREF Fg, COLORREF Bg);
void CmdLogFmt(PCTSTR buf, ...);
int  CmdExecuteCmd(PCTSTR, UiCommand);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\cwcreate.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    cwcreate.cpp

Abstract:

    This module contains the code for the new window architecture.

--*/

#include "precomp.hxx"
#pragma hdrstop

HWND
New_CreateWindow(
    HWND      hwndParent,
    WIN_TYPES Type,
    UINT      uClassId,
    UINT      uWinTitle,
    PRECT     pRect
    )
/*++
Description
    Generic rotuine to create a child window.

Arguments
    hwndParent  - handle to parent window
    uClassId    - resource string ID containing class name
    uWinTitle   - resource string ID containing window title
    pRect       - Rect describing the position of the window.
                  If NULL, CW_USEDEFAULT is used to specify the
                  location of the window.

--*/
{
    TCHAR   szClassName[MAX_MSG_TXT];
    TCHAR   szWinTitle[MAX_MSG_TXT];
    int     nX = CW_USEDEFAULT;
    int     nY = CW_USEDEFAULT;
    int     nWidth = CW_USEDEFAULT;
    int     nHeight = CW_USEDEFAULT;
    COMMONWIN_CREATE_DATA Data;

    if (pRect)
    {
        nX = pRect->left;
        nY = pRect->top;
        nWidth = pRect->right;
        nHeight = pRect->bottom;
    }

    // get class name and tile
    Dbg(LoadString(g_hInst, uClassId, szClassName, _tsizeof(szClassName)));
    Dbg(LoadString(g_hInst, uWinTitle, szWinTitle, _tsizeof(szWinTitle)));

    Data.Type = Type;

    BOOL TopMax;
    MDIGetActive(g_hwndMDIClient, &TopMax);
    
    HWND Win = CreateWindowEx(
        WS_EX_MDICHILD | WS_EX_CONTROLPARENT,       // Extended style
        szClassName,                                // class name
        szWinTitle,                                 // title
        WS_CLIPCHILDREN | WS_CLIPSIBLINGS
        | WS_OVERLAPPEDWINDOW | WS_VISIBLE |
        (TopMax ? WS_MAXIMIZE : 0),                 // style
        nX,                                         // x
        nY,                                         // y
        nWidth,                                     // width
        nHeight,                                    // height
        hwndParent,                                 // parent
        NULL,                                       // menu
        g_hInst,                                    // hInstance
        &Data                                       // user defined data
        );

    // Creation is considered an automatic operation in
    // order to distinguish things occuring during creation
    // from normal user operations.  Now that create is
    // finished, decrement to indicate the create op is over.
    if (Win != NULL)
    {
        COMMONWIN_DATA* CmnWin = GetCommonWinData(Win);
        if (CmnWin != NULL)
        {
            CmnWin->m_InAutoOp--;
        }
    }

    return Win;
}



HWND
NewWatch_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            WATCH_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_WatchWin_Title,
                            NULL
                            );
}

HWND
NewLocals_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            LOCALS_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_LocalsWin_Title,
                            NULL
                            );
}

HWND
NewDisasm_CreateWindow(
    HWND hwndParent
    )
{
    RECT Rect;

    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT,
            DISASM_WIDTH, DISASM_HEIGHT);
    return New_CreateWindow(hwndParent,
                            DISASM_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_DisasmWin_Title,
                            &Rect
                            );
}

HWND
NewQuickWatch_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            QUICKW_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_QuickWatchWin_Title,
                            NULL
                            );
}

HWND
NewMemory_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            MEM_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_MemoryWin_Title,
                            NULL
                            );
}

HWND
NewCalls_CreateWindow(
    HWND hwndParent
    )
{
    RECT Rect;
    
    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT,
            CALLS_WIDTH, CALLS_HEIGHT);
    return New_CreateWindow(hwndParent,
                            CALLS_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_CallsWin_Title, 
                            &Rect
                            );
}

HWND
NewCmd_CreateWindow(
    HWND hwndParent
    )
{
    RECT Rect;

    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT, CMD_WIDTH, CMD_HEIGHT);
    return New_CreateWindow(hwndParent,
                            CMD_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_CmdWin_Title,
                            &Rect
                            );
}

HWND
NewCpu_CreateWindow(
    HWND hwndParent
    )
{
    RECT Rect;

    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT,
            g_Ptr64 ? CPU_WIDTH_64 : CPU_WIDTH_32, CPU_HEIGHT);
    return New_CreateWindow(hwndParent,
                            CPU_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_CpuWin_Title,
                            &Rect
                            );
}

HWND
NewDoc_CreateWindow(
    HWND hwndParent
    )
/*++
Routine Description:

  Create the command window.

Arguments:

    hwndParent - The parent window to the command window. In an MDI document,
        this is usually the handle to the MDI client window: g_hwndMDIClient

Return Value:

    If successful, creates a valid window handle to the new command window.

    NULL if the window was not created.

--*/
{
    RECT Rect;

    // Set default geometry.
    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT,
            DOC_WIDTH, DOC_HEIGHT);
    
    if (g_WinOptions & WOPT_OVERLAY_SOURCE)
    {
        PLIST_ENTRY Entry;
        PCOMMONWIN_DATA WinData;
        
        // If we're stacking up document windows go
        // find the first one and use it as a template.
        for (Entry = g_ActiveWin.Flink;
             Entry != &g_ActiveWin;
             Entry = Entry->Flink)
        {
            WinData = ACTIVE_WIN_ENTRY(Entry);
            if (WinData->m_enumType == DOC_WINDOW &&
                !IsIconic(WinData->m_Win))
            {
                GetWindowRect(WinData->m_Win, &Rect);
                MapWindowPoints(GetDesktopWindow(), g_hwndMDIClient,
                                (LPPOINT)&Rect, 2);
                Rect.right -= Rect.left;
                Rect.bottom -= Rect.top;
            }
        }
    }

    return New_CreateWindow(hwndParent,
                            DOC_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_DocWin_Title,
                            &Rect
                            );
}

HWND
NewScratch_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            SCRATCH_PAD_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_Scratch_Pad_Title, 
                            NULL
                            );
}

HWND
NewProcessThread_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            PROCESS_THREAD_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_Process_Thread_Title, 
                            NULL
                            );
}


HWND
New_OpenDebugWindow(
    WIN_TYPES   winType,
    BOOL        bUserActivated,
    ULONG       Nth
    )
/*++

Routine Description:

    Opens Cpu, Watch, Locals, Calls, or Memory Window under MDI
    Handles special case for memory win's

Arguments:

    winType - Supplies Type of debug window to be openned
    
    bUserActivated - Indicates whether this action was initiated by the
                user or by windbg. The value is to determine the Z order of
                any windows that are opened.

Return Value:

    Window handle.

    NULL if an error occurs.

--*/
{
    HWND hwndActivate = NULL;
    PCOMMONWIN_DATA CmnWin;

    switch (winType)
    {
    default:
        Assert(!_T("Invalid window type. Ignorable error."));
        break;

    case CMD_WINDOW:
        if (GetCmdHwnd())
        {
            hwndActivate = GetCmdHwnd();
        }
        else
        {
            return NewCmd_CreateWindow(g_hwndMDIClient);
        }
        break;

    case WATCH_WINDOW:
        if (GetWatchHwnd())
        {
            hwndActivate = GetWatchHwnd();
        }
        else
        {
            return NewWatch_CreateWindow(g_hwndMDIClient);
        }
        break;

    case LOCALS_WINDOW:
        if (GetLocalsHwnd())
        {
            hwndActivate = GetLocalsHwnd();
        }
        else
        {
            return NewLocals_CreateWindow(g_hwndMDIClient);
        }
        break;

    case CPU_WINDOW:
        if (GetCpuHwnd())
        {
            hwndActivate = GetCpuHwnd();
        }
        else
        {
            return NewCpu_CreateWindow(g_hwndMDIClient);
        }
        break;

    case SCRATCH_PAD_WINDOW:
        if (GetScratchHwnd())
        {
            hwndActivate = GetScratchHwnd();
        }
        else
        {
            return NewScratch_CreateWindow(g_hwndMDIClient);
        }
        break;

    case DISASM_WINDOW:
        if (!bUserActivated && GetSrcMode_StatusBar() &&
            NULL == GetDisasmHwnd() &&
            (g_WinOptions & WOPT_AUTO_DISASM) == 0)
        {
            return NULL;
        }

        if (GetDisasmHwnd())
        {
            hwndActivate = GetDisasmHwnd();
        }
        else
        {
            return NewDisasm_CreateWindow(g_hwndMDIClient);
        }
        break;

    case MEM_WINDOW:
        // Memory windows normally open a fresh window
        // whenever an open request occurs, but when applying
        // workspaces we don't want to continually add
        // new memory windows.  In the workspace case we
        // reuse existing memory windows as much as possible.
        if (Nth != NTH_OPEN_ALWAYS &&
            (CmnWin = FindNthWindow(Nth, 1 << winType)) != NULL)
        {
            hwndActivate = CmnWin->m_Win;
            break;
        }
        
        hwndActivate = NewMemory_CreateWindow(g_hwndMDIClient);
        if (hwndActivate)
        {
            MEMWIN_DATA * pMemWinData = GetMemWinData(hwndActivate);
            Assert(pMemWinData);

            // If this window is being created from a workspace
            // don't pop up the properties dialog.
            if ( Nth == NTH_OPEN_ALWAYS &&
                 pMemWinData->HasEditableProperties() )
            {
                pMemWinData->EditProperties();
                pMemWinData->UiRequestRead();
            }
        }
        break;

    case DOC_WINDOW:
        return NewDoc_CreateWindow(g_hwndMDIClient);

    case QUICKW_WINDOW:
        if (GetQuickWatchHwnd())
        {
            hwndActivate = GetQuickWatchHwnd();
        }
        else
        {
            return NewQuickWatch_CreateWindow(g_hwndMDIClient);
        }
        break;

    case CALLS_WINDOW:
        if (GetCallsHwnd())
        {
            hwndActivate = GetCallsHwnd();
        }
        else
        {
            return NewCalls_CreateWindow(g_hwndMDIClient);
        }
        break;
        
    case PROCESS_THREAD_WINDOW:
        if (GetProcessThreadHwnd())
        {
            hwndActivate = GetProcessThreadHwnd();
        }
        else
        {
            return NewProcessThread_CreateWindow(g_hwndMDIClient);
        }
        break;
    }

    if (hwndActivate)
    {
        if (GetKeyState(VK_SHIFT) < 0 &&
            GetKeyState(VK_CONTROL) >= 0)
        {
            SendMessage(g_hwndMDIClient, WM_MDIDESTROY,
                        (WPARAM)hwndActivate, 0);
        }
        else
        {
            if (IsIconic(hwndActivate))
            {
                OpenIcon(hwndActivate);
            }
            
            ActivateMDIChild(hwndActivate, bUserActivated);
        }
    }    

    return hwndActivate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\cmnwin.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    cmnwin.cpp

Abstract:

    This module contains the code for the common window architecture.

--*/

#include "precomp.hxx"
#pragma hdrstop

ULONG g_WinOptions = WOPT_AUTO_ARRANGE | WOPT_AUTO_DISASM;

LIST_ENTRY g_ActiveWin;

PCOMMONWIN_DATA g_IndexedWin[MAXVAL_WINDOW];
HWND g_IndexedHwnd[MAXVAL_WINDOW];

INDEXED_FONT g_Fonts[FONT_COUNT];

BOOL g_LineMarkers = FALSE;

#define CW_WSP_SIG3 '3WCW'

//
//
//
COMMONWIN_DATA::COMMONWIN_DATA(ULONG ChangeBy)
    : StateBuffer(ChangeBy)
{
    m_Size.cx = 0;
    m_Size.cy = 0;
    m_CausedArrange = FALSE;
    // Creation is an automatic operation so
    // InAutoOp is initialized to a non-zero value.
    // After CreateWindow returns it is decremented.
    m_InAutoOp = 1;
    m_enumType = MINVAL_WINDOW;
    m_Font = &g_Fonts[FONT_FIXED];
    m_FontHeight = 0;
    m_LineHeight = 0;
    m_Toolbar = NULL;
    m_ShowToolbar = FALSE;
    m_ToolbarHeight = 0;
    m_MinToolbarWidth = 0;
    m_ToolbarEdit = NULL;
}

void
COMMONWIN_DATA::Validate()
{
    Assert(MINVAL_WINDOW < m_enumType);
    Assert(m_enumType < MAXVAL_WINDOW);
}

void 
COMMONWIN_DATA::SetFont(ULONG FontIndex)
{
    m_Font = &g_Fonts[FontIndex];
    m_FontHeight = m_Font->Metrics.tmHeight;
    m_LineHeight = m_Size.cy / m_FontHeight;
}

BOOL
COMMONWIN_DATA::CanCopy()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        DWORD Start, End;
        SendMessage(m_ToolbarEdit, EM_GETSEL,
                    (WPARAM)&Start, (WPARAM)&End);
        return Start != End;
    }
    else
    {
        return FALSE;
    }
}

BOOL
COMMONWIN_DATA::CanCut()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        DWORD Start, End;
        SendMessage(m_ToolbarEdit, EM_GETSEL,
                    (WPARAM)&Start, (WPARAM)&End);
        return Start != End;
    }
    else
    {
        return FALSE;
    }
}

BOOL
COMMONWIN_DATA::CanPaste()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
COMMONWIN_DATA::Copy()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        SendMessage(m_ToolbarEdit, WM_COPY, 0, 0);
    }
}

void
COMMONWIN_DATA::Cut()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        SendMessage(m_ToolbarEdit, WM_CUT, 0, 0);
    }
}

void
COMMONWIN_DATA::Paste()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        SendMessage(m_ToolbarEdit, WM_PASTE, 0, 0);
    }
}

BOOL
COMMONWIN_DATA::CanSelectAll()
{
    return FALSE;
}

void
COMMONWIN_DATA::SelectAll()
{
}

BOOL 
COMMONWIN_DATA::HasEditableProperties()
{
    return FALSE;
}

BOOL 
COMMONWIN_DATA::EditProperties()
/*++
Returns
    TRUE - If properties were edited
    FALSE - If nothing was changed
--*/
{
    return FALSE;
}

HMENU
COMMONWIN_DATA::GetContextMenu(void)
{
    return NULL;
}

void
COMMONWIN_DATA::OnContextMenuSelection(UINT Item)
{
    // Nothing to do.
}

BOOL
COMMONWIN_DATA::CanGotoLine(void)
{
    return FALSE;
}

void
COMMONWIN_DATA::GotoLine(ULONG Line)
{
    // Do nothing.
}

void
COMMONWIN_DATA::Find(PTSTR Text, ULONG Flags)
{
    // Do nothing.
}

BOOL
COMMONWIN_DATA::CodeExprAtCaret(PSTR Expr, PULONG64 Offset)
{
    return FALSE;
}

void
COMMONWIN_DATA::ToggleBpAtCaret(void)
{
    char CodeExpr[MAX_OFFSET_EXPR];
    ULONG64 Offset;
    
    if (!CodeExprAtCaret(CodeExpr, &Offset) &&
        Offset != DEBUG_INVALID_OFFSET)
    {
        MessageBeep(0);
        ErrorBox(NULL, 0, ERR_No_Code_For_File_Line);
        return;
    }

    ULONG CurBpId = DEBUG_ANY_ID;

    // This doesn't work too well with duplicate
    // breakpoints, but that should be a minor problem.
    if (IsBpAtOffset(NULL, Offset, &CurBpId) != BP_NONE)
    {
        PrintStringCommand(UIC_SILENT_EXECUTE, "bc %d", CurBpId);
    }
    else
    {
        PrintStringCommand(UIC_SILENT_EXECUTE, "bp %s", CodeExpr);
    }
}

BOOL
COMMONWIN_DATA::OnCreate(void)
{
    return TRUE;
}

LRESULT
COMMONWIN_DATA::OnCommand(WPARAM wParam, LPARAM lParam)
{
    return 1;
}

void
COMMONWIN_DATA::OnSetFocus(void)
{
}

void
COMMONWIN_DATA::OnSize(void)
{
    RECT Rect;
    
    // Resize the toolbar.
    if (m_Toolbar != NULL && m_ShowToolbar)
    {
        // If the toolbar gets too small sometimes it's better
        // to just let it get clipped rather than have it
        // try to fit into a narrow column.
        if (m_Size.cx >= m_MinToolbarWidth)
        {
            MoveWindow(m_Toolbar, 0, 0, m_Size.cx, m_ToolbarHeight, TRUE);
        }

        // Record what size it ended up.
        GetClientRect(m_Toolbar, &Rect);
        m_ToolbarHeight = Rect.bottom - Rect.top;

        if (m_FontHeight != 0)
        {
            if (m_ToolbarHeight >= m_Size.cy)
            {
                m_LineHeight = 0;
            }
            else
            {
                m_LineHeight = (m_Size.cy - m_ToolbarHeight) / m_FontHeight;
            }
        }
    }
    else
    {
        Assert(m_ToolbarHeight == 0);
    }
}

void
COMMONWIN_DATA::OnButtonDown(ULONG Button)
{
}

void
COMMONWIN_DATA::OnButtonUp(ULONG Button)
{
}

void
COMMONWIN_DATA::OnMouseMove(ULONG Modifiers, ULONG X, ULONG Y)
{
}

void
COMMONWIN_DATA::OnTimer(WPARAM TimerId)
{
}

LRESULT
COMMONWIN_DATA::OnGetMinMaxInfo(LPMINMAXINFO Info)
{
    return 1;
}

LRESULT
COMMONWIN_DATA::OnVKeyToItem(WPARAM wParam, LPARAM lParam)
{
    return -1;
}

LRESULT
COMMONWIN_DATA::OnNotify(WPARAM wParam, LPARAM lParam)
{
    return 0;
}

void
COMMONWIN_DATA::OnUpdate(UpdateType Type)
{
}

void
COMMONWIN_DATA::OnDestroy(void)
{
}

LRESULT
COMMONWIN_DATA::OnOwnerDraw(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

ULONG
COMMONWIN_DATA::GetWorkspaceSize(void)
{
    return 3 * sizeof(ULONG) + sizeof(WINDOWPLACEMENT);
}

PUCHAR
COMMONWIN_DATA::SetWorkspace(PUCHAR Data)
{
    // First store the special signature that marks
    // this version of the workspace data.
    *(PULONG)Data = CW_WSP_SIG3;
    Data += sizeof(ULONG);

    // Store the size saved by this layer.
    *(PULONG)Data = COMMONWIN_DATA::GetWorkspaceSize();
    Data += sizeof(ULONG);

    //
    // Store the actual data.
    //

    *(PULONG)Data = m_ShowToolbar;
    Data += sizeof(ULONG);
    
    LPWINDOWPLACEMENT Place = (LPWINDOWPLACEMENT)Data;
    Place->length = sizeof(WINDOWPLACEMENT);
    GetWindowPlacement(m_Win, Place);
    Data += sizeof(WINDOWPLACEMENT);

    return Data;
}

PUCHAR
COMMONWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    ULONG_PTR Size = End - Data;
    
    // There are three versions of the base COMMONWIN data.
    // 1. RECT.
    // 2. WINDOWPLACEMENT.
    // 3. CW_WSP_SIG3 sized block.
    // All three cases can be easily distinguished.

    if (Size > 2 * sizeof(ULONG) &&
        *(PULONG)Data == CW_WSP_SIG3 &&
        Size >= *(PULONG)(Data + sizeof(ULONG)))
    {
        Size = *(PULONG)(Data + sizeof(ULONG)) - 2 * sizeof(ULONG);
        Data += 2 * sizeof(ULONG);
        
        if (Size >= sizeof(ULONG))
        {
            SetShowToolbar(*(PULONG)Data);
            Size -= sizeof(ULONG);
            Data += sizeof(ULONG);
        }
    }

    if (Size >= sizeof(WINDOWPLACEMENT) &&
        ((LPWINDOWPLACEMENT)Data)->length == sizeof(WINDOWPLACEMENT))
    {
        LPWINDOWPLACEMENT Place = (LPWINDOWPLACEMENT)Data;

        if (!IsAutoArranged(m_enumType))
        {
            SetWindowPlacement(m_Win, Place);
        }
        
        return (PUCHAR)(Place + 1);
    }
    else
    {
        LPRECT Rect = (LPRECT)Data;
        Assert((PUCHAR)(Rect + 1) <= End);
    
        if (!IsAutoArranged(m_enumType))
        {
            MoveWindow(m_Win, Rect->left, Rect->top,
                       (Rect->right - Rect->left), (Rect->bottom - Rect->top),
                       TRUE);
        }
    
        return (PUCHAR)(Rect + 1);
    }
}

void
COMMONWIN_DATA::UpdateColors(void)
{
    // Nothing to do.
}

void
COMMONWIN_DATA::UpdateSize(ULONG Width, ULONG Height)
{
    m_Size.cx = Width;
    m_Size.cy = Height;
    if (m_FontHeight != 0)
    {
        m_LineHeight = m_Size.cy / m_FontHeight;
    }
}

void
COMMONWIN_DATA::SetShowToolbar(BOOL Show)
{
    if (!m_Toolbar)
    {
        return;
    }
    
    m_ShowToolbar = Show;
    if (m_ShowToolbar)
    {
        ShowWindow(m_Toolbar, SW_SHOW);
    }
    else
    {
        ShowWindow(m_Toolbar, SW_HIDE);
        m_ToolbarHeight = 0;
    }

    OnSize();
    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
    }
}

PCOMMONWIN_DATA
NewWinData(WIN_TYPES Type)
{
    switch(Type)
    {
    case DOC_WINDOW:
        return new DOCWIN_DATA;
    case WATCH_WINDOW:
        return new WATCHWIN_DATA;
    case LOCALS_WINDOW:
        return new LOCALSWIN_DATA;
    case CPU_WINDOW:
        return new CPUWIN_DATA;
    case DISASM_WINDOW:
        return new DISASMWIN_DATA;
    case CMD_WINDOW:
        return new CMDWIN_DATA;
    case SCRATCH_PAD_WINDOW:
        return new SCRATCH_PAD_DATA;
    case MEM_WINDOW:
        return new MEMWIN_DATA;
#if 0
    case QUICKW_WINDOW:
        // XXX drewb - Unimplemented.
        return new QUICKWWIN_DATA;
#endif
    case CALLS_WINDOW:
        return new CALLSWIN_DATA;
    case PROCESS_THREAD_WINDOW:
        return new PROCESS_THREAD_DATA;
    default:
        Assert(FALSE);
        return NULL;
    }
}

LRESULT
CALLBACK
COMMONWIN_DATA::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PCOMMONWIN_DATA pWinData = GetCommonWinData(hwnd);

#if 0
    {
        DebugPrint("CommonWin msg %X for %p, args %X %X\n",
                   uMsg, pWinData, wParam, lParam);
    }
#endif

    if (uMsg != WM_CREATE && pWinData == NULL)
    {
        return DefMDIChildProc(hwnd, uMsg, wParam, lParam);
    }
    
    switch (uMsg)
    {
    case WM_CREATE:
        RECT rc;
        COMMONWIN_CREATE_DATA* Data;

        Assert(NULL == pWinData);

        Data = (COMMONWIN_CREATE_DATA*)
            ((LPMDICREATESTRUCT)
             (((CREATESTRUCT *)lParam)->lpCreateParams))->lParam;

        pWinData = NewWinData(Data->Type);
        if (!pWinData)
        {
            return -1; // Fail window creation
        }
        Assert(pWinData->m_enumType == Data->Type);

        pWinData->m_Win = hwnd;
        
        GetClientRect(hwnd, &rc);
        pWinData->m_Size.cx = rc.right;
        pWinData->m_Size.cy = rc.bottom;
            
        if ( !pWinData->OnCreate() )
        {
            delete pWinData;
            return -1; // Fail window creation
        }

        // store this in the window
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pWinData);

#if DBG
        pWinData->Validate();
#endif
            
        g_IndexedWin[Data->Type] = pWinData;
        g_IndexedHwnd[Data->Type] = hwnd;
        InsertHeadList(&g_ActiveWin, &pWinData->m_ActiveWin);

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }

        SendMessage(hwnd, WM_SETICON, 0, (LPARAM)
                    LoadIcon(g_hInst,
                             MAKEINTRESOURCE(pWinData->m_enumType +
                                             MINVAL_WINDOW_ICON)));

        // A new buffer has been created so put it in the list
        // then wake up the engine to fill it.
        Dbg_EnterCriticalSection(&g_QuickLock);
        InsertHeadList(&g_StateList, pWinData);
        Dbg_LeaveCriticalSection(&g_QuickLock);
        UpdateEngine();

        // Force initial updates so that the window starts
        // out with a state which matches the current debug
        // session's state.
        PostMessage(hwnd, WU_UPDATE, UPDATE_BUFFER, 0);
        PostMessage(hwnd, WU_UPDATE, UPDATE_EXEC, 0);

        if (g_WinOptions & WOPT_AUTO_ARRANGE)
        {
            Arrange();
        }
        return 0;

    case WM_COMMAND:
        if (pWinData->OnCommand(wParam, lParam) == 0)
        {
            return 0;
        }
        break;
        
    case WM_SETFOCUS:
        pWinData->OnSetFocus();
        break;

    case WM_MOVE:
        // When the frame window is minimized or restored
        // a move to 0,0 comes through.  Ignore this so
        // as to not trigger the warning.
        if (!IsIconic(g_hwndFrame) && lParam != 0)
        {
            DisplayAutoArrangeWarning(pWinData);
        }
        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
        
    case WM_SIZE:
        if (wParam == SIZE_MAXHIDE || wParam == SIZE_MAXSHOW)
        {
            // We don't care about cover/uncover events.
            break;
        }
        
        DisplayAutoArrangeWarning(pWinData);
        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        
        pWinData->UpdateSize(LOWORD(lParam), HIWORD(lParam));

        // No need to run sizing code for minimize.
        if (wParam == SIZE_MINIMIZED)
        {
            // The minimized window will leave a hole so
            // arrange to fill it and leave space for the
            // minimized window.
            if (g_WinOptions & WOPT_AUTO_ARRANGE)
            {
                pWinData->m_CausedArrange = TRUE;
                Arrange();
            }
            break;
        }

        if (wParam == SIZE_RESTORED && pWinData->m_CausedArrange)
        {
            // If we're restoring a window that caused
            // a rearrange when it was minimized we
            // need to update things to account for it.
            pWinData->m_CausedArrange = FALSE;
            
            if (g_WinOptions & WOPT_AUTO_ARRANGE)
            {
                Arrange();
            }
        }
        else if (wParam == SIZE_MAXIMIZED)
        {
            // Ask for a rearrange on restore just
            // for consistency with minimize.
            pWinData->m_CausedArrange = TRUE;
        }

        pWinData->OnSize();
        break;

    case WM_LBUTTONDOWN:
        pWinData->OnButtonDown(MK_LBUTTON);
        return 0;
    case WM_LBUTTONUP:
        pWinData->OnButtonUp(MK_LBUTTON);
        return 0;
    case WM_MBUTTONDOWN:
        pWinData->OnButtonDown(MK_MBUTTON);
        return 0;
    case WM_MBUTTONUP:
        pWinData->OnButtonUp(MK_MBUTTON);
        return 0;
    case WM_RBUTTONDOWN:
        pWinData->OnButtonDown(MK_RBUTTON);
        return 0;
    case WM_RBUTTONUP:
        pWinData->OnButtonUp(MK_RBUTTON);
        return 0;

    case WM_MOUSEMOVE:
        pWinData->OnMouseMove((ULONG)wParam, LOWORD(lParam), HIWORD(lParam));
        return 0;

    case WM_TIMER:
        pWinData->OnTimer(wParam);
        return 0;

    case WM_GETMINMAXINFO:
        if (pWinData->OnGetMinMaxInfo((LPMINMAXINFO)lParam) == 0)
        {
            return 0;
        }
        break;
        
    case WM_VKEYTOITEM:
        return pWinData->OnVKeyToItem(wParam, lParam);
        
    case WM_NOTIFY:
        return pWinData->OnNotify(wParam, lParam);
        
    case WU_UPDATE:
        pWinData->OnUpdate((UpdateType)wParam);
        return 0;

    case WU_RECONFIGURE:
        pWinData->OnSize();
        break;

    case WM_DESTROY:
        pWinData->OnDestroy();
        
        SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
        g_IndexedWin[pWinData->m_enumType] = NULL;
        g_IndexedHwnd[pWinData->m_enumType] = NULL;
        RemoveEntryList(&pWinData->m_ActiveWin);
        
        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        
        // Mark this buffer as ready for cleanup by the
        // engine when it gets around to it.
        pWinData->m_Win = NULL;
        if (pWinData == g_FindLast)
        {
            g_FindLast = NULL;
        }
        UpdateEngine();
        
        if (g_WinOptions & WOPT_AUTO_ARRANGE)
        {
            Arrange();
        }
        break;
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
        // 
        // Both these messages must be handled by owner drawn windows
        // 
        return pWinData->OnOwnerDraw(uMsg, wParam, lParam);
    }
    
    return DefMDIChildProc(hwnd, uMsg, wParam, lParam);
}


//
//
//
SINGLE_CHILDWIN_DATA::SINGLE_CHILDWIN_DATA(ULONG ChangeBy)
    : COMMONWIN_DATA(ChangeBy)
{
    m_hwndChild = NULL;
}

void 
SINGLE_CHILDWIN_DATA::Validate()
{
    COMMONWIN_DATA::Validate();

    Assert(m_hwndChild);
}

void 
SINGLE_CHILDWIN_DATA::SetFont(ULONG FontIndex)
{
    COMMONWIN_DATA::SetFont(FontIndex);

    SendMessage(m_hwndChild, 
                WM_SETFONT, 
                (WPARAM) m_Font->Font,
                (LPARAM) TRUE
                );
}

BOOL
SINGLE_CHILDWIN_DATA::CanCopy()
{
    if (GetFocus() != m_hwndChild)
    {
        return COMMONWIN_DATA::CanCopy();
    }
    
    switch (m_enumType)
    {
    default:
        Assert(!"Unknown type");
        return FALSE;

    case CMD_WINDOW:
        Assert(!"Should not be handled here since this is only for windows"
            " with only one child window.");
        return FALSE;

    case WATCH_WINDOW:
    case LOCALS_WINDOW:
    case CPU_WINDOW:
    case QUICKW_WINDOW:
        return -1 != ListView_GetNextItem(m_hwndChild,
                                          -1, // Find the first match
                                          LVNI_FOCUSED
                                          );

    case CALLS_WINDOW:
        return LB_ERR != SendMessage(m_hwndChild, LB_GETCURSEL, 0, 0);

    case DOC_WINDOW:
    case DISASM_WINDOW:
    case MEM_WINDOW:
    case SCRATCH_PAD_WINDOW:
        CHARRANGE chrg;
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&chrg);
        return chrg.cpMin != chrg.cpMax;

    case PROCESS_THREAD_WINDOW:
        return NULL != TreeView_GetSelection(m_hwndChild);
    }
}

BOOL
SINGLE_CHILDWIN_DATA::CanCut()
{
    if (GetFocus() != m_hwndChild)
    {
        return COMMONWIN_DATA::CanCut();
    }
    
    switch (m_enumType)
    {
    default:
        Assert(!"Unknown type");
        return FALSE;

    case CMD_WINDOW:
        Assert(!"Should not be handled here since this is only for windows"
            " with only one child window.");
        return FALSE;

    case WATCH_WINDOW:
    case LOCALS_WINDOW:
    case CPU_WINDOW:
    case QUICKW_WINDOW:
    case CALLS_WINDOW:
    case DOC_WINDOW:
    case DISASM_WINDOW:
    case MEM_WINDOW:
    case PROCESS_THREAD_WINDOW:
        return FALSE;
        
    case SCRATCH_PAD_WINDOW:
        CHARRANGE chrg;
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&chrg);
        return chrg.cpMin != chrg.cpMax;
    }
}

BOOL
SINGLE_CHILDWIN_DATA::CanPaste()
{
    if (GetFocus() != m_hwndChild)
    {
        return COMMONWIN_DATA::CanPaste();
    }
    
    switch (m_enumType)
    {
    default:
        Assert(!"Unknown type");
        return FALSE;

    case CMD_WINDOW:
        Assert(!"Should not be handled here since this is only for windows"
            " with only one child window.");
        return FALSE;

    case WATCH_WINDOW:
    case LOCALS_WINDOW:
    case CPU_WINDOW:
    case QUICKW_WINDOW:
    case CALLS_WINDOW:
    case DOC_WINDOW:
    case DISASM_WINDOW:
    case MEM_WINDOW:
    case PROCESS_THREAD_WINDOW:
        return FALSE;
        
    case SCRATCH_PAD_WINDOW:
        return TRUE;
    }
}

void
SINGLE_CHILDWIN_DATA::Copy()
{
    if (GetFocus() != m_hwndChild)
    {
        COMMONWIN_DATA::Copy();
    }
    else
    {
        SendMessage(m_hwndChild, WM_COPY, 0, 0);
    }
}

void
SINGLE_CHILDWIN_DATA::Cut()
{
    if (GetFocus() != m_hwndChild)
    {
        COMMONWIN_DATA::Paste();
    }
}

void
SINGLE_CHILDWIN_DATA::Paste()
{
    if (GetFocus() != m_hwndChild)
    {
        COMMONWIN_DATA::Paste();
    }
}

void
SINGLE_CHILDWIN_DATA::OnSetFocus()
{
    ::SetFocus(m_hwndChild);
}

void
SINGLE_CHILDWIN_DATA::OnSize(void)
{
    COMMONWIN_DATA::OnSize();
    MoveWindow(m_hwndChild, 0, m_ToolbarHeight,
               m_Size.cx, m_Size.cy - m_ToolbarHeight, TRUE);
}

//
//
//
PROCESS_THREAD_DATA::PROCESS_THREAD_DATA()
    : SINGLE_CHILDWIN_DATA(512)
{
    m_enumType = PROCESS_THREAD_WINDOW;
    m_NumProcesses = 0;
}

void
PROCESS_THREAD_DATA::Validate()
{
    SINGLE_CHILDWIN_DATA::Validate();

    Assert(PROCESS_THREAD_WINDOW == m_enumType);
}

HRESULT
PROCESS_THREAD_DATA::ReadState(void)
{
    HRESULT Status;
    ULONG CurProc, CurThread;
    ULONG NumProc, NumThread;
    ULONG TotalThread, MaxThread;
    ULONG Proc, Thread;
    PULONG ProcIds, ProcSysIds, ProcThreads, ProcNames;
    PULONG ThreadIds, ThreadSysIds;
    ULONG ThreadsDone;
    char ExeName[MAX_PATH];

    if ((Status = g_pDbgSystem->GetCurrentProcessId(&CurProc)) != S_OK ||
        (Status = g_pDbgSystem->GetCurrentThreadId(&CurThread)) != S_OK ||
        (Status = g_pDbgSystem->GetNumberProcesses(&NumProc)) != S_OK ||
        (Status = g_pDbgSystem->
         GetTotalNumberThreads(&TotalThread, &MaxThread)) != S_OK)
    {
        return Status;
    }

    Empty();
    
    ProcIds = (PULONG)AddData((NumProc * 4 + TotalThread * 2) * sizeof(ULONG));
    if (ProcIds == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    ProcSysIds = ProcIds + NumProc;
    
    if ((Status = g_pDbgSystem->
         GetProcessIdsByIndex(0, NumProc, ProcIds, ProcSysIds)) != S_OK)
    {
        return Status;
    }

    ThreadsDone = 0;
    for (Proc = 0; Proc < NumProc; Proc++)
    {
        PSTR ExeStore;

        // Refresh pointers on every loop in case a resize
        // caused buffer movement.
        ProcIds = (PULONG)GetDataBuffer();
        ProcSysIds = ProcIds + NumProc;
        ProcThreads = ProcSysIds + NumProc;
        ProcNames = ProcThreads + NumProc;
        ThreadIds = ProcNames + NumProc + ThreadsDone;
        ThreadSysIds = ThreadIds + TotalThread;
        
        if ((Status = g_pDbgSystem->
             SetCurrentProcessId(ProcIds[Proc])) != S_OK ||
            FAILED(Status = g_pDbgSystem->
                   GetCurrentProcessExecutableName(ExeName,
                                                   sizeof(ExeName),
                                                   NULL)) ||
            (Status = g_pDbgSystem->GetNumberThreads(&NumThread)) != S_OK ||
            (Status = g_pDbgSystem->
             GetThreadIdsByIndex(0, NumThread,
                                 ThreadIds, ThreadSysIds)) != S_OK)
        {
            goto CurProc;
        }

        ProcThreads[Proc] = NumThread;
        ThreadsDone += NumThread;
        ProcNames[Proc] = strlen(ExeName) + 1;

        if (ProcNames[Proc] > 1)
        {
            ExeStore = (PSTR)AddData(ProcNames[Proc]);
            if (ExeStore == NULL)
            {
                Status = E_OUTOFMEMORY;
                goto CurProc;
            }

            strcpy(ExeStore, ExeName);
        }
    }

    m_NumProcesses = NumProc;
    m_TotalThreads = TotalThread;
    
    Status = S_OK;
    
 CurProc:
    g_pDbgSystem->SetCurrentProcessId(CurProc);

    return Status;
}

BOOL
PROCESS_THREAD_DATA::OnCreate(void)
{
    if (!SINGLE_CHILDWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    m_hwndChild = CreateWindow(
        WC_TREEVIEW,                                // class name
        NULL,                                       // title
        WS_CLIPSIBLINGS |
        WS_CHILD | WS_VISIBLE |
        WS_HSCROLL | WS_VSCROLL |
        TVS_HASBUTTONS | TVS_LINESATROOT |
        TVS_HASLINES,                               // style
        0,                                          // x
        0,                                          // y
        m_Size.cx,                                  // width
        m_Size.cy,                                  // height
        m_Win,                                      // parent
        (HMENU) IDC_PROCESS_TREE,                   // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data
    if (!m_hwndChild)
    {
        return FALSE;
    }
    
    SetFont(FONT_FIXED);
    
    return TRUE;
}

LRESULT
PROCESS_THREAD_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    LPNMTREEVIEW Tvn;
    HTREEITEM Sel;

    Tvn = (LPNMTREEVIEW)Lpm;
    if (Tvn->hdr.idFrom != IDC_PROCESS_TREE)
    {
        return FALSE;
    }
    
    switch(Tvn->hdr.code)
    {
    case NM_DBLCLK:
        TVHITTESTINFO HitTest;
        
        if (!GetCursorPos(&HitTest.pt))
        {
            break;
        }
        ScreenToClient(m_hwndChild, &HitTest.pt);
        Sel = TreeView_HitTest(m_hwndChild, &HitTest);
        if (Sel != NULL &&
            (HitTest.flags & TVHT_ONITEMLABEL))
        {
            SetCurThreadFromProcessTreeItem(m_hwndChild, Sel);
        }
        break;
    }

    return FALSE;
}

void
PROCESS_THREAD_DATA::OnUpdate(UpdateType Type)
{
    if (Type != UPDATE_BUFFER &&
        Type != UPDATE_EXEC)
    {
        return;
    }
    
    HRESULT Status;
    
    Status = UiLockForRead();
    if (Status != S_OK)
    {
        return;
    }
    
    ULONG NumThread;
    ULONG Proc, Thread;
    PULONG ProcIds, ProcSysIds, ProcThreads, ProcNames;
    PULONG ThreadIds, ThreadSysIds;
    char Text[MAX_PATH + 64];
    PSTR Names;
    HTREEITEM CurThreadItem = NULL;

    ProcIds = (PULONG)GetDataBuffer();
    ProcSysIds = ProcIds + m_NumProcesses;
    ProcThreads = ProcSysIds + m_NumProcesses;
    ProcNames = ProcThreads + m_NumProcesses;
    ThreadIds = ProcNames + m_NumProcesses;
    ThreadSysIds = ThreadIds + m_TotalThreads;
    Names = (PSTR)(ThreadSysIds + m_TotalThreads);
    
    TreeView_DeleteAllItems(m_hwndChild);

    for (Proc = 0; Proc < m_NumProcesses; Proc++)
    {
        HTREEITEM ProcItem;
        TVINSERTSTRUCT Insert;

        sprintf(Text, "%03d:%x ", ProcIds[Proc], ProcSysIds[Proc]);
        if (ProcNames[Proc] > 1)
        {
            strcpy(Text + strlen(Text), Names);
            Names += strlen(Names) + 1;
        }
        
        Insert.hParent = TVI_ROOT;
        Insert.hInsertAfter = TVI_LAST;
        Insert.item.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;
        Insert.item.pszText = Text;
        Insert.item.state =
            ProcIds[Proc] == g_CurProcessId ? TVIS_EXPANDED | TVIS_BOLD: 0;
        Insert.item.stateMask = TVIS_EXPANDED | TVIS_BOLD;
        // Parameter is the thread ID to set to select the given thread.
        Insert.item.lParam = (LPARAM)ThreadIds[0];
        ProcItem = TreeView_InsertItem(m_hwndChild, &Insert);

        for (Thread = 0; Thread < ProcThreads[Proc]; Thread++)
        {
            HTREEITEM ThreadItem;
            
            sprintf(Text, "%03d:%x", ThreadIds[Thread], ThreadSysIds[Thread]);
            Insert.hParent = ProcItem;
            Insert.hInsertAfter = TVI_LAST;
            Insert.item.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;
            Insert.item.pszText = Text;
            Insert.item.state =
                ProcIds[Proc] == g_CurProcessId &&
                ThreadIds[Thread] == g_CurThreadId ?
                TVIS_BOLD : 0;
            Insert.item.stateMask = TVIS_BOLD;
            Insert.item.lParam = (LPARAM)ThreadIds[Thread];
            ThreadItem = TreeView_InsertItem(m_hwndChild, &Insert);
            if (Insert.item.state & TVIS_BOLD)
            {
                CurThreadItem = ThreadItem;
            }
        }

        ThreadIds += ProcThreads[Proc];
        ThreadSysIds += ProcThreads[Proc];
    }

    if (CurThreadItem)
    {
        TreeView_Select(m_hwndChild, CurThreadItem, TVGN_CARET);
    }
    
    UnlockStateBuffer(this);
}

void
PROCESS_THREAD_DATA::SetCurThreadFromProcessTreeItem(HWND Tree, HTREEITEM Sel)
{
    TVITEM Item;
                
    Item.hItem = Sel;
    Item.mask = TVIF_CHILDREN | TVIF_PARAM;
    TreeView_GetItem(Tree, &Item);
    g_pUiSystem->SetCurrentThreadId((ULONG)Item.lParam);
}


//
//
//
EDITWIN_DATA::EDITWIN_DATA(ULONG ChangeBy)
    : SINGLE_CHILDWIN_DATA(ChangeBy)
{
    m_TextLines = 0;
    m_Highlights = NULL;
}

void
EDITWIN_DATA::Validate()
{
    SINGLE_CHILDWIN_DATA::Validate();
}

void 
EDITWIN_DATA::SetFont(ULONG FontIndex)
{
    SINGLE_CHILDWIN_DATA::SetFont(FontIndex);

    // Force the tabstop size to be recomputed
    // with the new font.
    SendMessage(m_hwndChild, EM_SETTABSTOPS, 1, (LPARAM)&g_TabWidth);
}

BOOL
EDITWIN_DATA::CanSelectAll()
{
    return TRUE;
}

void
EDITWIN_DATA::SelectAll()
{
    CHARRANGE Sel;

    Sel.cpMin = 0;
    Sel.cpMax = INT_MAX;
    SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Sel);
}

BOOL
EDITWIN_DATA::OnCreate(void)
{
    m_hwndChild = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        RICHEDIT_CLASS,                             // class name
        NULL,                                       // title
        WS_CLIPSIBLINGS
        | WS_CHILD | WS_VISIBLE
        | WS_VSCROLL | ES_AUTOVSCROLL
        | WS_HSCROLL | ES_AUTOHSCROLL
        | ES_READONLY
        | ES_MULTILINE,                             // style
        0,                                          // x
        m_ToolbarHeight,                            // y
        m_Size.cx,                                  // width
        m_Size.cy - m_ToolbarHeight,                // height
        m_Win,                                      // parent
        (HMENU) 0,                                  // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data

    if (m_hwndChild)
    {
        SetFont( FONT_FIXED );
        SendMessage(m_hwndChild, EM_SETBKGNDCOLOR, FALSE,
                    g_Colors[COL_PLAIN].Color);
    }

    return m_hwndChild != NULL;
}

LRESULT
EDITWIN_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    NMHDR* Hdr = (NMHDR*)Lpm;
    if (Hdr->code == EN_SAVECLIPBOARD)
    {
        // Indicate that the clipboard contents should
        // be kept alive.
        return 0;
    }
    else if (Hdr->code == EN_MSGFILTER)
    {
        MSGFILTER* Filter = (MSGFILTER*)Lpm;
        
        if (WM_SYSKEYDOWN == Filter->msg ||
            WM_SYSKEYUP == Filter->msg ||
            WM_SYSCHAR == Filter->msg)
        {
            // Force default processing for menu operations
            // so that the Alt-minus menu comes up.
            return 1;
        }
    }

    return 0;
}

void
EDITWIN_DATA::OnDestroy(void)
{
    EDIT_HIGHLIGHT* Next;
    
    while (m_Highlights != NULL)
    {
        Next = m_Highlights->Next;
        delete m_Highlights;
        m_Highlights = Next;
    }

    SINGLE_CHILDWIN_DATA::OnDestroy();
}

void
EDITWIN_DATA::UpdateColors(void)
{
    SendMessage(m_hwndChild, EM_SETBKGNDCOLOR, FALSE,
                g_Colors[COL_PLAIN].Color);
    UpdateBpMarks();
}

void
EDITWIN_DATA::SetCurrentLineHighlight(ULONG Line)
{
    //
    // Clear any other current line highlight in this window.
    // Also, oOnly one doc window can have a current IP highlight so if
    // this is a doc window getting a current IP highlight make
    // sure no other doc windows have a current IP highlight.
    //
    if (m_enumType == DOC_WINDOW && ULONG_MAX != Line)
    {
        RemoveActiveWinHighlights(1 << DOC_WINDOW, EHL_CURRENT_LINE);
    }
    else
    {
        RemoveAllHighlights(EHL_CURRENT_LINE);
    }
    
    if (ULONG_MAX != Line)
    {
        AddHighlight(Line, EHL_CURRENT_LINE);

        CHARRANGE crSet;
        
        // Set the caret on the current line.  This automatically
        // scrolls the line into view if necessary and prevents
        // the view from snapping back to whatever old selection
        // there was.

        HWND OldFocus = ::SetFocus(m_hwndChild);
        
        crSet.cpMax = crSet.cpMin = (LONG)
            SendMessage(m_hwndChild, EM_LINEINDEX, Line, 0);
        SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&crSet);

        ::SetFocus(OldFocus);
    }
}
    
EDIT_HIGHLIGHT*
EDITWIN_DATA::GetLineHighlighting(ULONG Line)
{
    EDIT_HIGHLIGHT* Hl;
    
    for (Hl = m_Highlights; Hl != NULL; Hl = Hl->Next)
    {
        if (Hl->Line == Line)
        {
            return Hl;
        }
    }

    return NULL;
}

void
EDITWIN_DATA::ApplyHighlight(EDIT_HIGHLIGHT* Hl)
{
    CHARRANGE crOld;

    // Get the old selection
    SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &crOld);

    //
    // Compute the highlight information.
    //

    char Markers[LINE_MARKERS + 1];
    CHARFORMAT2 cf;
    ULONG TextCol, BgCol;

    Markers[2] = 0;
    ZeroMemory(&cf, sizeof(cf));
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_COLOR | CFM_BACKCOLOR;
    
    if (Hl->Flags & EHL_CURRENT_LINE)
    {
        Markers[1] = '>';
        switch(Hl->Flags & EHL_ANY_BP)
        {
        case EHL_ENABLED_BP:
            Markers[0] = 'B';
            TextCol = COL_BP_CURRENT_LINE_TEXT;
            BgCol = COL_BP_CURRENT_LINE;
            break;
        case EHL_DISABLED_BP:
            Markers[0] = 'D';
            TextCol = COL_BP_CURRENT_LINE_TEXT;
            BgCol = COL_BP_CURRENT_LINE;
            break;
        default:
            Markers[0] = ' ';
            TextCol = COL_CURRENT_LINE_TEXT;
            BgCol = COL_CURRENT_LINE;
            break;
        }
    }
    else
    {
        Markers[1] = ' ';
        switch(Hl->Flags & EHL_ANY_BP)
        {
        case EHL_ENABLED_BP:
            Markers[0] = 'B';
            TextCol = COL_ENABLED_BP_TEXT;
            BgCol = COL_ENABLED_BP;
            break;
        case EHL_DISABLED_BP:
            Markers[0] = 'D';
            TextCol = COL_DISABLED_BP_TEXT;
            BgCol = COL_DISABLED_BP;
            break;
        default:
            Markers[0] = ' ';
            TextCol = COL_PLAIN_TEXT;
            BgCol = COL_PLAIN;
            break;
        }
    }

    cf.crTextColor = g_Colors[TextCol].Color;
    cf.crBackColor = g_Colors[BgCol].Color;
    
    //
    // Select the line to be highlighted
    //
    
    CHARRANGE crNew;
    
    crNew.cpMin = (LONG)SendMessage(m_hwndChild, EM_LINEINDEX, Hl->Line, 0);

    if (g_LineMarkers)
    {
        // Replace the markers at the beginning of the line.
        crNew.cpMax = crNew.cpMin + 2;
        SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&crNew);
        SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)Markers);
    }

    // Color the line.
    crNew.cpMax = crNew.cpMin + (LONG)
        SendMessage(m_hwndChild, EM_LINELENGTH, crNew.cpMin, 0) + 1;
    if (g_LineMarkers)
    {
        crNew.cpMin += 2;
    }
    SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM) &crNew);
    SendMessage(m_hwndChild, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    // Restore the old selection
    SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM) &crOld);
}

EDIT_HIGHLIGHT*
EDITWIN_DATA::AddHighlight(ULONG Line, ULONG Flags)
{
    EDIT_HIGHLIGHT* Hl;

    // Search for an existing highlight record for the line.
    Hl = GetLineHighlighting(Line);

    if (Hl == NULL)
    {
        Hl = new EDIT_HIGHLIGHT;
        if (Hl == NULL)
        {
            return NULL;
        }

        Hl->Data = 0;
        Hl->Line = Line;
        Hl->Flags = 0;
        Hl->Next = m_Highlights;
        m_Highlights = Hl;
    }

    Hl->Flags |= Flags;
    ApplyHighlight(Hl);

    return Hl;
}

void
EDITWIN_DATA::RemoveHighlight(ULONG Line, ULONG Flags)
{
    EDIT_HIGHLIGHT* Hl;
    EDIT_HIGHLIGHT* Prev;
    
    // Search for an existing highlight record for the line.
    Prev = NULL;
    for (Hl = m_Highlights; Hl != NULL; Hl = Hl->Next)
    {
        if (Hl->Line == Line)
        {
            break;
        }

        Prev = Hl;
    }

    if (Hl == NULL)
    {
        return;
    }

    Hl->Flags &= ~Flags;
    ApplyHighlight(Hl);

    if (Hl->Flags == 0)
    {
        if (Prev == NULL)
        {
            m_Highlights = Hl->Next;
        }
        else
        {
            Prev->Next = Hl->Next;
        }

        delete Hl;
    }
}

void
EDITWIN_DATA::RemoveAllHighlights(ULONG Flags)
{
    EDIT_HIGHLIGHT* Hl;
    EDIT_HIGHLIGHT* Next;
    EDIT_HIGHLIGHT* Prev;

    Prev = NULL;
    for (Hl = m_Highlights; Hl != NULL; Hl = Next)
    {
        Next = Hl->Next;

        if (Hl->Flags & Flags)
        {
            Hl->Flags &= ~Flags;
            ApplyHighlight(Hl);

            if (Hl->Flags == 0)
            {
                if (Prev == NULL)
                {
                    m_Highlights = Hl->Next;
                }
                else
                {
                    Prev->Next = Hl->Next;
                }

                delete Hl;
            }
            else
            {
                Prev = Hl;
            }
        }
        else
        {
            Prev = Hl;
        }
    }
}

void
EDITWIN_DATA::RemoveActiveWinHighlights(ULONG Types, ULONG Flags)
{
    PLIST_ENTRY Entry = g_ActiveWin.Flink;

    while (Entry != &g_ActiveWin)
    {
        PEDITWIN_DATA WinData = (PEDITWIN_DATA)
            ACTIVE_WIN_ENTRY(Entry);
            
        if (Types & (1 << WinData->m_enumType))
        {
            WinData->RemoveAllHighlights(Flags);
        }

        Entry = Entry->Flink;
    }
}

void
EDITWIN_DATA::UpdateBpMarks(void)
{
    // Empty implementation for derived classes
    // that do not show BP marks.
}

int
EDITWIN_DATA::CheckForFileChanges(PCSTR File, FILETIME* LastWrite)
{
    HANDLE Handle;
    
    Handle = CreateFile(File, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 
                        NULL);
    if (Handle == INVALID_HANDLE_VALUE)
    {
        goto Changed;
    }

    FILETIME NewWrite;
    
    if (!GetFileTime(Handle, NULL, NULL, &NewWrite))
    {
        if (!GetFileTime(Handle, &NewWrite, NULL, NULL))
        {
            ZeroMemory(&NewWrite, sizeof(NewWrite));
        }
    }

    CloseHandle(Handle);

    if (CompareFileTime(LastWrite, &NewWrite) == 0)
    {
        // No change.
        return IDCANCEL;
    }

 Changed:
    return QuestionBox(ERR_File_Has_Changed, MB_YESNO, File);
}

//
//
//
SCRATCH_PAD_DATA::SCRATCH_PAD_DATA()
    : EDITWIN_DATA(16)
{
    m_enumType = SCRATCH_PAD_WINDOW;
}

void
SCRATCH_PAD_DATA::Validate()
{
    EDITWIN_DATA::Validate();

    Assert(SCRATCH_PAD_WINDOW == m_enumType);
}

void
SCRATCH_PAD_DATA::Cut()
{
    SendMessage(m_hwndChild, WM_CUT, 0, 0);
}

void
SCRATCH_PAD_DATA::Paste()
{
    SendMessage(m_hwndChild, WM_PASTE, 0, 0);
}

BOOL
SCRATCH_PAD_DATA::OnCreate(void)
{
    if (!EDITWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    SendMessage(m_hwndChild, EM_SETOPTIONS, ECOOP_AND, ~ECO_READONLY);
    return TRUE;
}

//
//
//
DISASMWIN_DATA::DISASMWIN_DATA()
    : EDITWIN_DATA(2048)
{
    m_enumType = DISASM_WINDOW;
    sprintf(m_OffsetExpr, "0x%I64x", g_EventIp);
    m_UpdateExpr = FALSE;
    m_FirstInstr = 0;
    m_LastInstr = 0;
}

void
DISASMWIN_DATA::Validate()
{
    EDITWIN_DATA::Validate();

    Assert(DISASM_WINDOW == m_enumType);
}

HRESULT
DISASMWIN_DATA::ReadState(void)
{
    HRESULT Status;
    // Sample these values right away in case the UI changes them.
    ULONG LinesTotal = m_LineHeight;
    ULONG LinesBefore = LinesTotal / 2;
    ULONG Line;
    DEBUG_VALUE Value;

    if ((Status = g_pDbgControl->Evaluate(m_OffsetExpr, DEBUG_VALUE_INT64,
                                          &Value, NULL)) != S_OK)
    {
        return Status;
    }

    m_PrimaryInstr = Value.I64;
    
    // Reserve space at the beginning of the buffer to
    // store the line to offset mapping table.
    PULONG64 LineMap;
    
    Empty();
    LineMap = (PULONG64)AddData(sizeof(ULONG64) * LinesTotal);
    if (LineMap == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // We also need to allocate a temporary line map to
    // pass to the engine for filling.  This can't be
    // the state buffer data since that may move as
    // output is generated.
    LineMap = new ULONG64[LinesTotal];
    if (LineMap == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(FALSE)) != S_OK)
    {
        delete LineMap;
        return Status;
    }

    Status = g_pOutCapControl->
        OutputDisassemblyLines(DEBUG_OUTCTL_THIS_CLIENT |
                               DEBUG_OUTCTL_OVERRIDE_MASK |
                               DEBUG_OUTCTL_NOT_LOGGED,
                               LinesBefore, LinesTotal, m_PrimaryInstr,
                               DEBUG_DISASM_EFFECTIVE_ADDRESS |
                               DEBUG_DISASM_MATCHING_SYMBOLS,
                               &m_PrimaryLine, &m_FirstInstr, &m_LastInstr,
                               LineMap);

    memcpy(m_Data, LineMap, sizeof(ULONG64) * LinesTotal);
    delete LineMap;

    if (Status != S_OK)
    {
        g_OutStateBuf.End(FALSE);
        return Status;
    }

    m_TextLines = LinesTotal;
    m_TextOffset = LinesTotal * sizeof(ULONG64);
    
    // The line map is generated with offsets followed by
    // invalid offsets for continuation lines.  We want
    // the offsets to be on the last line of the disassembly
    // for a continuation set so move them down.
    // We don't want to move the offsets down to blank lines,
    // though, such as the blank lines that separate bundles
    // in IA64 disassembly.
    LineMap = (PULONG64)m_Data;
    PULONG64 LineMapEnd = LineMap + m_TextLines;
    PULONG64 SetStart;
    PSTR Text = (PSTR)m_Data + m_TextOffset;
    PSTR PrevText;
        
    while (LineMap < LineMapEnd)
    {
        if (*LineMap != DEBUG_INVALID_OFFSET)
        {
            SetStart = LineMap;
            for (;;)
            {
                PrevText = Text;
                Text = strchr(Text, '\n') + 1;
                LineMap++;
                if (LineMap >= LineMapEnd ||
                    *LineMap != DEBUG_INVALID_OFFSET ||
                    *Text == '\n')
                {
                    break;
                }
            }
            LineMap--;
            Text = PrevText;
            
            if (LineMap > SetStart)
            {
                *LineMap = *SetStart;
                *SetStart = DEBUG_INVALID_OFFSET;
            }
        }
            
        LineMap++;
        Text = strchr(Text, '\n') + 1;
    }
    
#ifdef DEBUG_DISASM
    LineMap = (PULONG64)m_Data;
    for (Line = 0; Line < m_TextLines; Line++)
    {
        DebugPrint("%d: %I64x\n", Line, LineMap[Line]);
    }
#endif

    return g_OutStateBuf.End(TRUE);
}

BOOL
DISASMWIN_DATA::CodeExprAtCaret(PSTR Expr, PULONG64 Offset)
{
    BOOL Succ = FALSE;
    LRESULT LineChar;
    LONG Line;
    PULONG64 LineMap;
    
    if (UiLockForRead() != S_OK)
    {
        goto NoCode;
    }
    
    LineChar = SendMessage(m_hwndChild, EM_LINEINDEX, -1, 0);
    Line = (LONG)SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, LineChar);
    if (Line < 0 || (ULONG)Line >= m_TextLines)
    {
        goto UnlockNoCode;
    }

    ULONG64 LineOff;
    
    // Look up the offset in the line map.  If it's part of
    // a multiline group move forward to the offset.
    LineMap = (PULONG64)m_Data;
    LineOff = LineMap[Line];
    while ((ULONG)(Line + 1) < m_TextLines && LineOff == DEBUG_INVALID_OFFSET)
    {
        Line++;
        LineOff = LineMap[Line];
    }

    if (Expr != NULL)
    {
        sprintf(Expr, "0x%I64x", LineOff);
    }
    if (Offset != NULL)
    {
        *Offset = LineOff;
    }
    Succ = TRUE;
    
 UnlockNoCode:
    UnlockStateBuffer(this);
 NoCode:
    return Succ;
}

BOOL
DISASMWIN_DATA::OnCreate(void)
{
    RECT Rect;
    int i;
    ULONG Height;

    Height = GetSystemMetrics(SM_CYVSCROLL) + 4 * GetSystemMetrics(SM_CYEDGE);
    
    m_Toolbar = CreateWindowEx(0, REBARCLASSNAME, NULL,
                               WS_VISIBLE | WS_CHILD |
                               WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                               CCS_NODIVIDER | CCS_NOPARENTALIGN |
                               RBS_VARHEIGHT | RBS_BANDBORDERS,
                               0, 0, m_Size.cx, Height, m_Win,
                               (HMENU)ID_TOOLBAR,
                               g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }

    REBARINFO BarInfo;
    BarInfo.cbSize = sizeof(BarInfo);
    BarInfo.fMask = 0;
    BarInfo.himl = NULL;
    SendMessage(m_Toolbar, RB_SETBARINFO, 0, (LPARAM)&BarInfo);

    m_ToolbarEdit = CreateWindowEx(WS_EX_CLIENTEDGE, "EDIT", NULL,
                                   WS_VISIBLE | WS_CHILD | ES_AUTOHSCROLL,
                                   0, 0, 18 * m_Font->Metrics.tmAveCharWidth,
                                   Height, m_Toolbar, (HMENU)IDC_EDIT_OFFSET,
                                   g_hInst, NULL);
    if (m_ToolbarEdit == NULL)
    {
        return FALSE;
    }

    SendMessage(m_ToolbarEdit, WM_SETFONT, (WPARAM)m_Font->Font, 0);
    SendMessage(m_ToolbarEdit, EM_LIMITTEXT, sizeof(m_OffsetExpr) - 1, 0);
    
    GetClientRect(m_ToolbarEdit, &Rect);

    REBARBANDINFO BandInfo;
    BandInfo.cbSize = sizeof(BandInfo);
    BandInfo.fMask = RBBIM_STYLE | RBBIM_TEXT | RBBIM_CHILD | RBBIM_CHILDSIZE;
    BandInfo.fStyle = RBBS_FIXEDSIZE;
    BandInfo.lpText = "Offset:";
    BandInfo.hwndChild = m_ToolbarEdit;
    BandInfo.cxMinChild = Rect.right - Rect.left;
    BandInfo.cyMinChild = Rect.bottom - Rect.top;
    SendMessage(m_Toolbar, RB_INSERTBAND, -1, (LPARAM)&BandInfo);

    // If the toolbar is allowed to shrink too small it hangs
    // while resizing.  Just let it clip off below a certain width.
    m_MinToolbarWidth = BandInfo.cxMinChild * 2;
    
    PSTR PrevText = "Previous";
    m_PreviousButton =
        AddButtonBand(m_Toolbar, PrevText, PrevText, IDC_DISASM_PREVIOUS);
    m_NextButton =
        AddButtonBand(m_Toolbar, "Next", PrevText, IDC_DISASM_NEXT);
    if (m_PreviousButton == NULL || m_NextButton == NULL)
    {
        return FALSE;
    }

    // Maximize the space for the offset expression.
    SendMessage(m_Toolbar, RB_MAXIMIZEBAND, 0, FALSE);
    
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top;
    m_ShowToolbar = TRUE;
    
    if (!EDITWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    // Suppress the scroll bar as the text is always
    // fitted to the window size.
    SendMessage(m_hwndChild, EM_SHOWSCROLLBAR, SB_VERT, FALSE);

    SendMessage(m_hwndChild, EM_SETEVENTMASK, 0, ENM_KEYEVENTS);

    return TRUE;
}

LRESULT
DISASMWIN_DATA::OnCommand(WPARAM Wpm, LPARAM Lpm)
{
    switch(LOWORD(Wpm))
    {
    case IDC_EDIT_OFFSET:
        if (HIWORD(Wpm) == EN_CHANGE)
        {
            // This message is sent on every keystroke
            // which causes a bit too much updating.
            // Set up a timer to trigger the actual
            // update in half a second.
            SetTimer(m_Win, IDC_EDIT_OFFSET, EDIT_DELAY, NULL);
            m_UpdateExpr = TRUE;
        }
        break;
    case IDC_DISASM_PREVIOUS:
        ScrollLower();
        break;
    case IDC_DISASM_NEXT:
        ScrollHigher();
        break;
    }
    
    return 0;
}

void
DISASMWIN_DATA::OnSize(void)
{
    EDITWIN_DATA::OnSize();

    // Force buffer to refill for new line count.
    UiRequestRead();
}

void
DISASMWIN_DATA::OnTimer(WPARAM TimerId)
{
    if (TimerId == IDC_EDIT_OFFSET && m_UpdateExpr)
    {
        m_UpdateExpr = FALSE;
        GetWindowText(m_ToolbarEdit, m_OffsetExpr, sizeof(m_OffsetExpr));
        UiRequestRead();
    }
}

LRESULT
DISASMWIN_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    MSGFILTER* Filter = (MSGFILTER*)Lpm;

    if (Filter->nmhdr.code != EN_MSGFILTER)
    {
        return EDITWIN_DATA::OnNotify(Wpm, Lpm);
    }
    
    if (Filter->msg == WM_KEYDOWN)
    {
        switch(Filter->wParam)
        {
        case VK_UP:
        {
            CHARRANGE range;

            SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &range);
            if (!SendMessage(m_hwndChild, EM_LINEFROMCHAR, range.cpMin, 0)) 
            {
                // up arrow on top line, scroll
                ScrollLower();
                return 1;
            }
            break;
        }
        case VK_DOWN:
        {
            CHARRANGE range;
            int MaxLine;

            SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &range);
            MaxLine = (int) SendMessage(m_hwndChild, EM_GETLINECOUNT, 0, 0);

            if (MaxLine == (1+SendMessage(m_hwndChild, EM_LINEFROMCHAR, range.cpMin, 0)))
            {
                // down arrow on bottom line, scroll
                ScrollHigher();
                return 1;
            }
            break;
        }
        
        case VK_PRIOR:
            ScrollLower();
            return 1;
        case VK_NEXT:
            ScrollHigher();
            return 1;
        }
    }
    else if (WM_SYSKEYDOWN == Filter->msg ||
             WM_SYSKEYUP == Filter->msg ||
             WM_SYSCHAR == Filter->msg)
    {
        // Force default processing for menu operations
        // so that the Alt-minus menu comes up.
        return 1;
    }

    return 0;
}

void
DISASMWIN_DATA::OnUpdate(UpdateType Type)
{
    if (Type == UPDATE_BP ||
        Type == UPDATE_END_SESSION)
    {
        UpdateBpMarks();
        return;
    }
    else if (Type != UPDATE_BUFFER)
    {
        return;
    }
    
    HRESULT Status;
    
    Status = UiLockForRead();
    if (Status == S_OK)
    {
        PULONG64 LineMap;
        ULONG Line;

        if (!g_LineMarkers)
        {
            SendMessage(m_hwndChild, WM_SETTEXT,
                        0, (LPARAM)m_Data + m_TextOffset);
        }
        else
        {
            SendMessage(m_hwndChild, WM_SETTEXT, 0, (LPARAM)"");
            PSTR Text = (PSTR)m_Data + m_TextOffset;
            for (;;)
            {
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)"  ");
                PSTR NewLine = strchr(Text, '\n');
                if (NewLine != NULL)
                {
                    *NewLine = 0;
                }
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)Text);
                if (NewLine == NULL)
                {
                    break;
                }
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)"\n");
                *NewLine = '\n';
                Text = NewLine + 1;
            }
        }

        // Highlight the last line of multiline disassembly.
        LineMap = (PULONG64)m_Data;
        Line = m_PrimaryLine;
        while (Line + 1 < m_TextLines &&
               LineMap[Line] == DEBUG_INVALID_OFFSET)
        {
            Line++;
        }
        
        SetCurrentLineHighlight(Line);
        
        UnlockStateBuffer(this);

        UpdateBpMarks();

        EnableWindow(m_PreviousButton, m_FirstInstr != m_PrimaryInstr);
        EnableWindow(m_NextButton, m_LastInstr != m_PrimaryInstr);
    }
    else
    {
        SendLockStatusMessage(m_hwndChild, WM_SETTEXT, Status);
        RemoveCurrentLineHighlight();
    }
}

void
DISASMWIN_DATA::UpdateBpMarks(void)
{
    if (m_TextLines == 0 ||
        UiLockForRead() != S_OK)
    {
        return;
    }

    if (g_BpBuffer->UiLockForRead() != S_OK)
    {
        UnlockStateBuffer(this);
        return;
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    // Remove existing BP highlights.
    RemoveAllHighlights(EHL_ANY_BP);
    
    //
    // Highlight every line that matches a breakpoint.
    //
    
    PULONG64 LineMap = (PULONG64)m_Data;
    BpBufferData* BpData = (BpBufferData*)g_BpBuffer->GetDataBuffer();
    ULONG Line;
    BpStateType State;

    for (Line = 0; Line < m_TextLines; Line++)
    {
        if (*LineMap != DEBUG_INVALID_OFFSET)
        {
            State = IsBpAtOffset(BpData, *LineMap, NULL);
            if (State != BP_NONE)
            {
                AddHighlight(Line, State == BP_ENABLED ?
                             EHL_ENABLED_BP : EHL_DISABLED_BP);
            }
        }

        LineMap++;
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);
    
    UnlockStateBuffer(g_BpBuffer);
    UnlockStateBuffer(this);
}

void
DISASMWIN_DATA::SetCurInstr(ULONG64 Offset)
{
    // Any pending user update is now irrelevant.
    m_UpdateExpr = FALSE;
    sprintf(m_OffsetExpr, "0x%I64x", Offset);
    // Force engine to update buffer.
    UiRequestRead();
}


void
RicheditFind(HWND Edit,
             PTSTR Text, ULONG Flags,
             CHARRANGE* SaveSel, PULONG SaveFlags,
             BOOL HideSel)
{
    if (Text == NULL)
    {
        // Clear last find.
        if (SaveSel->cpMax >= SaveSel->cpMin)
        {
            if (*SaveFlags & FR_DOWN)
            {
                SaveSel->cpMin = SaveSel->cpMax;
            }
            else
            {
                SaveSel->cpMax = SaveSel->cpMin;
            }
            if (HideSel)
            {
                SendMessage(Edit, EM_SETOPTIONS, ECOOP_AND, ~ECO_NOHIDESEL);
            }
            SendMessage(Edit, EM_EXSETSEL, 0, (LPARAM)SaveSel);
            SendMessage(Edit, EM_SCROLLCARET, 0, 0);
            SaveSel->cpMin = 1;
            SaveSel->cpMax = 0;
        }
    }
    else
    {
        LRESULT Match;
        FINDTEXTEX Find;

        SendMessage(Edit, EM_EXGETSEL, 0, (LPARAM)&Find.chrg);
        if (Flags & FR_DOWN)
        {
            Find.chrg.cpMax = LONG_MAX;
        }
        else
        {
            Find.chrg.cpMax = 0;
        }
        Find.lpstrText = Text;
        Match = SendMessage(Edit, EM_FINDTEXTEX, Flags, (LPARAM)&Find);
        if (Match != -1)
        {
            *SaveSel = Find.chrgText;
            *SaveFlags = Flags;
            if (HideSel)
            {
                SendMessage(Edit, EM_SETOPTIONS, ECOOP_OR, ECO_NOHIDESEL);
            }
            SendMessage(Edit, EM_EXSETSEL, 0, (LPARAM)SaveSel);
            SendMessage(Edit, EM_SCROLLCARET, 0, 0);
        }
        else
        {
            InformationBox(ERR_No_More_Matches, Text);
            SetFocus(g_FindDialog);
        }
    }
}

#undef DEFINE_GET_WINDATA
#undef ASSERT_CLASS_TYPE


#ifndef DBG

#define ASSERT_CLASS_TYPE(p, ct)        ((VOID)0)

#else

#define ASSERT_CLASS_TYPE(p, ct)        if (p) { AssertType(*p, ct); }

#endif



#define DEFINE_GET_WINDATA(ClassType, FuncName)         \
ClassType *                                             \
Get##FuncName##WinData(                                 \
    HWND hwnd                                           \
    )                                                   \
{                                                       \
    ClassType *p = (ClassType *)                        \
        GetWindowLongPtr(hwnd, GWLP_USERDATA);          \
                                                        \
    ASSERT_CLASS_TYPE(p, ClassType);                    \
                                                        \
    return p;                                           \
}


#include "fncdefs.h"


#undef DEFINE_GET_WINDATA
#undef ASSERT_CLASS_TYPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\cmnwin.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    cmnwin.h

Abstract:

    Header for common window architecture functions.    

Environment:

    Win32, User Mode

--*/

// Millisecond delay value before evaluating input in
// edit boxes.  Required because there's only a per-character
// change notification and we don't want to reevaluate on
// every character.
#define EDIT_DELAY 500

// Several windows have edit boxes for entering offset
// expressions.
#define MAX_OFFSET_EXPR (MAX_PATH + 64)

//
// Window-related options.
//

#define WOPT_AUTO_ARRANGE       0x00000001
#define WOPT_ARRANGE_ALL        0x00000002
#define WOPT_AUTO_DISASM        0x00000004
#define WOPT_OVERLAY_SOURCE     0x00000008

extern ULONG g_WinOptions;
extern ULONG g_AutoArrangeWarningCount;

enum
{
    FONT_FIXED,
    FONT_VARIABLE,
    FONT_COUNT
};

struct INDEXED_FONT
{
    HFONT Font;
    TEXTMETRIC Metrics;
    LOGFONT LogFont;
    BOOL LogFontSet;
};

extern INDEXED_FONT g_Fonts[];

#define LINE_MARKERS 2

extern BOOL g_LineMarkers;

//----------------------------------------------------------------------------
//
// COMMONWIN_DATA and family.
//
//----------------------------------------------------------------------------

// List of all commonwin's still associated with an HWND.
// This list entry is a member of the commonwin and is
// different from the derivation list entry.  Use
// the ACTIVE_WIN_ENTRY macro to get from an entry to
// the actual commonwin.
extern LIST_ENTRY g_ActiveWin;

#define ACTIVE_WIN_ENTRY(Entry) \
    ((PCOMMONWIN_DATA) \
     ((PUCHAR)(Entry) - FIELD_OFFSET(COMMONWIN_DATA, m_ActiveWin)))

struct COMMONWIN_CREATE_DATA
{
    WIN_TYPES Type;
};

//
// Data common to all window structures
//
class COMMONWIN_DATA : public StateBuffer
{
public:
    LIST_ENTRY          m_ActiveWin;
    SIZEL               m_Size;
    ULONG               m_CausedArrange;
    ULONG               m_InAutoOp;
    INDEXED_FONT*       m_Font;
    // Height of current font.
    ULONG               m_FontHeight;
    // Height of window in lines of the current font, rounded down.
    ULONG               m_LineHeight;

    // Toolbar if this window has one.
    HWND                m_Toolbar;
    BOOL                m_ShowToolbar;
    int                 m_ToolbarHeight;
    int                 m_MinToolbarWidth;
    HWND                m_ToolbarEdit;
    
    COMMONWIN_DATA(ULONG ChangeBy);

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);

    virtual BOOL CanCopy();
    virtual BOOL CanCut();
    virtual BOOL CanPaste();
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();
    virtual BOOL CanSelectAll();
    virtual void SelectAll();

    virtual BOOL HasEditableProperties();
    virtual BOOL EditProperties();

    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual BOOL CanGotoLine(void);
    virtual void GotoLine(ULONG Line);

    virtual void Find(PTSTR Text, ULONG Flags);
    
    virtual BOOL CodeExprAtCaret(PSTR Expr, PULONG64 Offset);
    virtual void ToggleBpAtCaret(void);
    
    // Functions called in response to WM messages
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSetFocus(void);
    virtual void OnSize(void);
    virtual void OnButtonDown(ULONG Button);
    virtual void OnButtonUp(ULONG Button);
    virtual void OnMouseMove(ULONG Modifiers, ULONG X, ULONG Y);
    virtual void OnTimer(WPARAM TimerId);
    virtual LRESULT OnGetMinMaxInfo(LPMINMAXINFO Info);
    virtual LRESULT OnVKeyToItem(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);
    virtual void OnDestroy(void);
    virtual LRESULT OnOwnerDraw(UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

    virtual void UpdateColors(void);
    
    void UpdateSize(ULONG Width, ULONG Height);
    void SetShowToolbar(BOOL Show);

    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam);
};
typedef COMMONWIN_DATA *PCOMMONWIN_DATA;


//
// Data common to all window structures
// that only have one child
//
class SINGLE_CHILDWIN_DATA : public COMMONWIN_DATA
{
public:
    HWND    m_hwndChild;


    SINGLE_CHILDWIN_DATA(ULONG ChangeBy);

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);

    virtual BOOL CanCopy();
    virtual BOOL CanCut();
    virtual BOOL CanPaste();
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();

    // Functions called in response to WM messages
    virtual void OnSetFocus(void);
    virtual void OnSize(void);
};
typedef SINGLE_CHILDWIN_DATA *PSINGLE_CHILDWIN_DATA;

#define IDC_PROCESS_TREE 1234

class PROCESS_THREAD_DATA : public SINGLE_CHILDWIN_DATA
{
public:
    // Set in ReadState.
    ULONG m_NumProcesses, m_TotalThreads;

    PROCESS_THREAD_DATA();

    virtual void Validate();

    virtual HRESULT ReadState(void);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    void SetCurThreadFromProcessTreeItem(HWND Tree, HTREEITEM Sel);
};
typedef PROCESS_THREAD_DATA *PPROCESS_THREAD_DATA;


#define EHL_CURRENT_LINE 0x00000001
#define EHL_ENABLED_BP   0x00000002
#define EHL_DISABLED_BP  0x00000004

#define EHL_ANY_BP (EHL_ENABLED_BP | EHL_DISABLED_BP)

struct EDIT_HIGHLIGHT
{
    EDIT_HIGHLIGHT* Next;
    ULONG64 Data;
    ULONG Line;
    ULONG Flags;
};

class EDITWIN_DATA : public SINGLE_CHILDWIN_DATA
{
public:
    // Total number of lines in the edit window.
    ULONG m_TextLines;

    EDIT_HIGHLIGHT* m_Highlights;

    EDITWIN_DATA(ULONG ChangeBy);

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);
    
    virtual BOOL CanSelectAll();
    virtual void SelectAll();
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnDestroy(void);

    virtual void UpdateColors(void);

    void SetCurrentLineHighlight(ULONG Line);
    void RemoveCurrentLineHighlight(void)
    {
        SetCurrentLineHighlight(ULONG_MAX);
    }
    EDIT_HIGHLIGHT* GetLineHighlighting(ULONG Line);
    
    void ApplyHighlight(EDIT_HIGHLIGHT* Hl);
    EDIT_HIGHLIGHT* AddHighlight(ULONG Line, ULONG Flags);
    void RemoveHighlight(ULONG Line, ULONG Flags);
    void RemoveAllHighlights(ULONG Flags);
    static void RemoveActiveWinHighlights(ULONG Types, ULONG Flags);

    // Base implementation does nothing.
    virtual void UpdateBpMarks(void);

    int CheckForFileChanges(PCSTR File, FILETIME* LastWrite);
};
typedef EDITWIN_DATA *PEDITWIN_DATA;


class SCRATCH_PAD_DATA : public EDITWIN_DATA
{
public:
    SCRATCH_PAD_DATA();

    virtual void Validate();

    virtual void Cut();
    virtual void Paste();

    virtual BOOL OnCreate(void);
};
typedef SCRATCH_PAD_DATA *PSCRATCH_PAD_DATA;


#define IDC_DISASM_PREVIOUS 1234
#define IDC_DISASM_NEXT     1235

class DISASMWIN_DATA : public EDITWIN_DATA
{
public:
    char m_OffsetExpr[MAX_OFFSET_EXPR];
    BOOL m_UpdateExpr;
    HWND m_PreviousButton;
    HWND m_NextButton;

    // Set in ReadState.
    ULONG64 m_FirstInstr;
    ULONG64 m_PrimaryInstr;
    ULONG64 m_LastInstr;
    ULONG m_PrimaryLine;
    ULONG m_TextOffset;

    DISASMWIN_DATA();

    virtual void Validate();

    virtual HRESULT ReadState(void);
    
    virtual BOOL CodeExprAtCaret(PSTR Expr, PULONG64 Offset);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSize(void);
    virtual void OnTimer(WPARAM TimerId);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);
    virtual void UpdateBpMarks(void);

    void SetCurInstr(ULONG64 Offset);

    void ScrollLower(void)
    {
        if (m_FirstInstr != 0)
        {
            SetCurInstr(m_FirstInstr);
        }
    }
    void ScrollHigher(void)
    {
        if (m_LastInstr != 0)
        {
            SetCurInstr(m_LastInstr);
        }
    }
};
typedef DISASMWIN_DATA *PDISASMWIN_DATA;



// Array of active commonwin's indexed by WIN_TYPES.
extern PCOMMONWIN_DATA g_IndexedWin[];
extern HWND g_IndexedHwnd[];

#define GetWatchHwnd()          g_IndexedHwnd[WATCH_WINDOW]
#define GetLocalsHwnd()         g_IndexedHwnd[LOCALS_WINDOW]
#define GetCpuHwnd()            g_IndexedHwnd[CPU_WINDOW]
#define GetDisasmHwnd()         g_IndexedHwnd[DISASM_WINDOW]
#define GetCmdHwnd()            g_IndexedHwnd[CMD_WINDOW]
#define GetScratchHwnd()        g_IndexedHwnd[SCRATCH_PAD_WINDOW]
#define GetCallsHwnd()          g_IndexedHwnd[CALLS_WINDOW]
#define GetQuickWatchHwnd()     g_IndexedHwnd[QUICKW_WINDOW]
#define GetProcessThreadHwnd()  g_IndexedHwnd[PROCESS_THREAD_WINDOW]


// Size of caption bar plus window frame.
#define WIN_EXTRA_HEIGHT \
    (2 * GetSystemMetrics(SM_CYBORDER) + 3 * GetSystemMetrics(SM_CYFRAME) + \
     GetSystemMetrics(SM_CYCAPTION))

// Attempt to make most text windows 80 chars wide by default.
// Most windows end up with a scroll bar so add that in on top.
#define WIDTH_80 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 80 + GetSystemMetrics(SM_CXVSCROLL))

// Make all the left-side windows (command, stack, ...) 80 columns.
#define LEFT_SIDE_WIDTH WIDTH_80
// Require some space for left-side windows.
#define LEFT_SIDE_MIN_WIDTH \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 15 + GetSystemMetrics(SM_CXVSCROLL))
#define LEFT_SIDE_MIN_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 5 + WIN_EXTRA_HEIGHT)

// Make all the right-side windows (cpu, ...) narrow.
#define RIGHT_SIDE_MIN_WIDTH_32 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 15 + GetSystemMetrics(SM_CXVSCROLL))
#define RIGHT_SIDE_DESIRED_WIDTH_32 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 25 + GetSystemMetrics(SM_CXVSCROLL))
#define RIGHT_SIDE_MIN_WIDTH_64 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 20 + GetSystemMetrics(SM_CXVSCROLL))
#define RIGHT_SIDE_DESIRED_WIDTH_64 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 30 + GetSystemMetrics(SM_CXVSCROLL))

#define DOC_WIDTH       WIDTH_80
#define DISASM_WIDTH    WIDTH_80
#define CMD_WIDTH       WIDTH_80
#define CALLS_WIDTH     WIDTH_80

// Give plenty of room for the command window.
#define CMD_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 38)
#define CMD_MIN_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 25)

#define CPU_WIDTH_32 RIGHT_SIDE_DESIRED_WIDTH_32
#define CPU_WIDTH_64 RIGHT_SIDE_DESIRED_WIDTH_64
#define CPU_HEIGHT g_MdiHeight

// Keep the calls window short but with enough lines to be useful.
#define CALLS_MIN_HEIGHT LEFT_SIDE_MIN_HEIGHT
#define CALLS_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 10 + WIN_EXTRA_HEIGHT)

// Give the code windows enough lines to provide useful context.
#define DISASM_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 30 + WIN_EXTRA_HEIGHT)
#define DOC_HEIGHT DISASM_HEIGHT

void Arrange(void);
BOOL IsAutoArranged(WIN_TYPES Type);
void DisplayAutoArrangeWarning(PCOMMONWIN_DATA CmnWin);
void UpdateSourceOverlay(void);
void SetAllFonts(ULONG FontIndex);
void CloseAllWindows(void);
void UpdateAllColors(void);
PCOMMONWIN_DATA FindNthWindow(ULONG Nth, ULONG Types);

void RicheditFind(HWND Edit,
                  PTSTR Text, ULONG Flags,
                  CHARRANGE* SaveSel, PULONG SaveFlags,
                  BOOL HideSel);

#define NTH_OPEN_ALWAYS 0xffffffff

HWND
New_OpenDebugWindow(
    WIN_TYPES   winType,
    BOOL        bUserActivated,
    ULONG       Nth
    );

HWND
New_CreateWindow(
    HWND      hwndParent,
    WIN_TYPES Type,
    UINT      uClassId,
    UINT      uWinTitle,
    PRECT     pRect
    );

HWND 
NewCmd_CreateWindow(
    HWND
    );

HWND
NewWatch_CreateWindow(
    HWND
    );

HWND
NewLocals_CreateWindow(
    HWND
    );

HWND
NewCpu_CreateWindow(
    HWND
    );

HWND
NewDisasm_CreateWindow(
    HWND
    );

HWND
NewQuickWatch_CreateWindow(
    HWND
    );

HWND
NewCalls_CreateWindow(
    HWND
    );

HWND
NewDoc_CreateWindow(
    HWND
    );

HWND
NewMemory_CreateWindow(
    HWND
    );

HWND
NewScratch_CreateWindow(
    HWND
    );

HWND
NewProcessThread_CreateWindow(
    HWND
    );

#undef DEFINE_GET_WINDATA

#define DEFINE_GET_WINDATA(ClassType, FuncName)   \
    class ClassType * Get##FuncName##WinData(HWND);

#include "fncdefs.h"

#undef DEFINE_GET_WINDATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\docwin.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    docwin.cpp

Abstract:

    This module contains the code for the new doc windows.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <dbghelp.h>

ULONG g_TabWidth = 32;
BOOL g_DisasmActivateSource;

//
//
//
DOCWIN_DATA::DOCWIN_DATA()
    // State buffer isn't currently used.
    : EDITWIN_DATA(256)
{
    m_enumType = DOC_WINDOW;

    ZeroMemory(m_szFoundFile, _tsizeof(m_szFoundFile));
    ZeroMemory(m_szSymFile, _tsizeof(m_szSymFile));
    ZeroMemory(&m_LastWriteTime, sizeof(m_LastWriteTime));

    m_FindSel.cpMin = 1;
    m_FindSel.cpMax = 0;
    m_FindFlags = 0;
}

void
DOCWIN_DATA::Validate()
{
    EDITWIN_DATA::Validate();

    Assert(DOC_WINDOW == m_enumType);
}

BOOL
DOCWIN_DATA::CanGotoLine(void)
{
    return m_TextLines > 0;
}

void
DOCWIN_DATA::GotoLine(ULONG Line)
{
    CHARRANGE Sel;
                
    Sel.cpMin = (LONG)SendMessage(m_hwndChild, EM_LINEINDEX, Line - 1, 0);
    Sel.cpMax = Sel.cpMin;
    SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Sel);
}

void
DOCWIN_DATA::Find(PTSTR Text, ULONG Flags)
{
    RicheditFind(m_hwndChild, Text, Flags,
                 &m_FindSel, &m_FindFlags, TRUE);
}

BOOL
DOCWIN_DATA::CodeExprAtCaret(PSTR Expr, PULONG64 Offset)
{
    LRESULT LineChar;
    LONG Line;
    
    LineChar = SendMessage(m_hwndChild, EM_LINEINDEX, -1, 0);
    Line = (LONG)SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, LineChar);
    if (Line < 0)
    {
        return FALSE;
    }

    // Convert to one-based.
    Line++;
    
    if (Offset != NULL)
    {
        *Offset = DEBUG_INVALID_OFFSET;
    }

    if (Expr == NULL)
    {
        // Caller is just checking whether it's possible
        // to get an expression or not, such as the
        // menu enable code.  This code always considers
        // it possible since it can't know for sure without
        // a full symbol check.
        return TRUE;
    }
    
    //
    // First attempt to resolve the source line using currently
    // loaded symbols.  This is done directly from the UI
    // thread for synchronous behavior.  The assumption is
    // that turning off symbol loads will limit the execution
    // time to something reasonably quick.
    //

    DEBUG_VALUE Val;
    HRESULT Status;
    
    sprintf(Expr, "`<U>%s:%d+`", m_pszSymFile, Line);
    Status = g_pUiControl->Evaluate(Expr, DEBUG_VALUE_INT64, &Val, NULL);

    // Don't preserve the <U>nqualified option in the actual
    // expression returned as it's just a temporary override.
    sprintf(Expr, "`%s:%d+`", m_pszSymFile, Line);

    if (Status == S_OK)
    {
        if (Offset != NULL)
        {
            *Offset = Val.I64;
        }
        return TRUE;
    }

    ULONG SymOpts;

    if (g_pUiSymbols->GetSymbolOptions(&SymOpts) == S_OK &&
        (SymOpts & SYMOPT_NO_UNQUALIFIED_LOADS))
    {
        // The user isn't allowing unqualified loads so
        // further searches won't help.
        return FALSE;
    }

    // We weren't able to resolve the expression with the
    // existing symbols so we'll need to do a full search.
    // This can be very expensive, so allow the user to cancel.
    if (!g_QuietMode)
    {
        int Mode = QuestionBox(STR_Unresolved_Source_Expr, MB_YESNOCANCEL);
        if (Mode == IDCANCEL)
        {
            return FALSE;
        }
        else if (Mode == IDYES)
        {
            if (g_pUiControl->Evaluate(Expr, DEBUG_VALUE_INT64,
                                       &Val, NULL) == S_OK)
            {
                if (Offset != NULL)
                {
                    *Offset = Val.I64;
                }
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    // Let the expression go without trying to further resolve it.
    return TRUE;
}

void
DOCWIN_DATA::ToggleBpAtCaret(void)
{
    LRESULT LineChar;
    LONG Line;
    
    LineChar = SendMessage(m_hwndChild, EM_LINEINDEX, -1, 0);
    Line = (LONG)SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, LineChar);
    if (Line < 0)
    {
        return;
    }

    // If we have a breakpoint on this line remove it.
    EDIT_HIGHLIGHT* Hl = GetLineHighlighting(Line);
    if (Hl != NULL && (Hl->Flags & EHL_ANY_BP))
    {
        PrintStringCommand(UIC_SILENT_EXECUTE, "bc %d", (ULONG)Hl->Data);
        return;
    }

    //
    // No breakpoint exists so add a new one.
    //
    
    char CodeExpr[MAX_OFFSET_EXPR];
    ULONG64 Offset;

    if (!CodeExprAtCaret(CodeExpr, &Offset))
    {
        MessageBeep(0);
        ErrorBox(NULL, 0, ERR_No_Code_For_File_Line);
    }
    else
    {
        if (Offset != DEBUG_INVALID_OFFSET)
        {
            char SymName[MAX_OFFSET_EXPR];
            ULONG64 Disp;
            
            // Check and see whether this offset maps
            // exactly to a symbol.  If it does, use
            // the symbol name to be more robust in the
            // face of source changes.
            // Symbols should be loaded at this point since
            // we just used them to resolve the source
            // expression that produced Offset, so we
            // can safely do this on the UI thread.
            if (g_pUiSymbols->GetNameByOffset(Offset, SymName, sizeof(SymName),
                                              NULL, &Disp) == S_OK &&
                Disp == 0)
            {
                strcpy(CodeExpr, SymName);
            }
        }
        
        PrintStringCommand(UIC_SILENT_EXECUTE, "bu %s", CodeExpr);
    }
}

BOOL
DOCWIN_DATA::OnCreate(void)
{
    if (!EDITWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    SendMessage(m_hwndChild, EM_SETEVENTMASK,
                0, ENM_SELCHANGE | ENM_KEYEVENTS);
    SendMessage(m_hwndChild, EM_SETTABSTOPS, 1, (LPARAM)&g_TabWidth);
    
    return TRUE;
}

LRESULT
DOCWIN_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    SELCHANGE* SelChange = (SELCHANGE*)Lpm;

    if (SelChange->nmhdr.code == EN_SELCHANGE)
    {
        int Line = (int)
            SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0,
                        SelChange->chrg.cpMin);
        LRESULT LineFirst =
            SendMessage(m_hwndChild, EM_LINEINDEX, Line, 0);
        SetLineColumn_StatusBar(Line + 1,
                                (int)(SelChange->chrg.cpMin - LineFirst) + 1);
        return 0;
    }

    return EDITWIN_DATA::OnNotify(Wpm, Lpm);
}

void
DOCWIN_DATA::OnUpdate(
    UpdateType Type
    )
{
    if (Type == UPDATE_BP ||
        Type == UPDATE_BUFFER ||
        Type == UPDATE_END_SESSION)
    {
        UpdateBpMarks();
    }
    else if (Type == UPDATE_START_SESSION)
    {
        if (m_szFoundFile[0] &&
            CheckForFileChanges(m_szFoundFile, &m_LastWriteTime) == IDYES)
        {
            char Found[MAX_SOURCE_PATH], Sym[MAX_SOURCE_PATH];

            // Save away filenames since they're copied over
            // on a successful load.
            strcpy(Found, m_szFoundFile);
            strcpy(Sym, m_szSymFile);
            
            if (!LoadFile(Found, Sym))
            {
                PostMessage(g_hwndMDIClient, WM_MDIDESTROY, (WPARAM)m_Win, 0);
            }
        }
    }
}

ULONG
DOCWIN_DATA::GetWorkspaceSize(void)
{
    ULONG Len = EDITWIN_DATA::GetWorkspaceSize();
    Len += _tcslen(m_szFoundFile) + 1;
    Len += _tcslen(m_szSymFile) + 1;
    return Len;
}

PUCHAR
DOCWIN_DATA::SetWorkspace(PUCHAR Data)
{
    PTSTR Str = (PTSTR)EDITWIN_DATA::SetWorkspace(Data);
    _tcscpy(Str, m_szFoundFile);
    Str += _tcslen(m_szFoundFile) + 1;
    _tcscpy(Str, m_szSymFile);
    Str += _tcslen(m_szSymFile) + 1;
    return (PUCHAR)Str;
}

PUCHAR
DOCWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    PTSTR Found = (PTSTR)EDITWIN_DATA::ApplyWorkspace1(Data, End);
    PTSTR Sym = Found + _tcslen(Found) + 1;
    if (Found[0])
    {
        if (FindDocWindowByFileName(Found, NULL, NULL) ||
            !LoadFile(Found, Sym[0] ? Sym : NULL))
        {
            PostMessage(g_hwndMDIClient, WM_MDIDESTROY, (WPARAM)m_Win, 0);
        }
    }
    return (PUCHAR)(Sym + _tcslen(Sym) + 1);
}
    
void
DOCWIN_DATA::UpdateBpMarks(void)
{
    if (m_TextLines == 0 ||
        g_BpBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    // Remove existing BP highlights.
    RemoveAllHighlights(EHL_ANY_BP);
    
    //
    // Highlight every line that matches a breakpoint.
    //
    
    BpBufferData* BpData = (BpBufferData*)g_BpBuffer->GetDataBuffer();
    ULONG i;

    for (i = 0; i < g_BpCount; i++)
    {
        if (BpData[i].FileOffset)
        {
            PSTR FileSpace;
            ULONG Line;
            PSTR FileStop, MatchStop;
            ULONG HlFlags;

            FileSpace = (PSTR)g_BpBuffer->GetDataBuffer() +
                BpData[i].FileOffset;
            // Adjust to zero-based.
            Line = *(ULONG UNALIGNED *)FileSpace - 1;
            FileSpace += sizeof(Line);
            
            // If this document's file matches some suffix
            // of the breakpoint's file at the path component
            // level then do the highlight.  This can result in
            // extra highlights for multiple files with the same
            // name but in different directories.  That's a rare
            // enough problem to wait for somebody to complain
            // before trying to hack some better check up.
            if (SymMatchFileName(FileSpace, (PSTR)m_pszSymFile,
                                 &FileStop, &MatchStop) ||
                *MatchStop == '\\' ||
                *MatchStop == '/' ||
                *MatchStop == ':')
            {
                if (BpData[i].Flags & DEBUG_BREAKPOINT_ENABLED)
                {
                    HlFlags = EHL_ENABLED_BP;
                }
                else
                {
                    HlFlags = EHL_DISABLED_BP;
                }

                EDIT_HIGHLIGHT* Hl = AddHighlight(Line, HlFlags);
                if (Hl != NULL)
                {
                    Hl->Data = BpData[i].Id;
                }
            }
        }
    }

    UnlockStateBuffer(g_BpBuffer);

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);
}

DWORD 
CALLBACK 
EditStreamCallback(
    DWORD_PTR     dwFileHandle,   // application-defined value
    LPBYTE        pbBuff,     // data buffer
    LONG          cb,         // number of bytes to read or write
    LONG          *pcb        // number of bytes transferred
    )
{
    HRESULT Status;
    PathFile* File = (PathFile*)dwFileHandle;
    
    if ((Status = File->Read(pbBuff, cb, (PDWORD)pcb)) != S_OK)
    {
        return Status;
    }

    // Edit out page-break characters (^L's) as richedit
    // gives them their own line which throws off line numbers.
    while (cb-- > 0)
    {
        if (*pbBuff == '\f')
        {
            *pbBuff = ' ';
        }

        pbBuff++;
    }
    
    return 0; // No error
}

BOOL 
DOCWIN_DATA::LoadFile(
    PCTSTR pszFoundFile,
    PCTSTR pszSymFile
    )
/*++
Returns
    TRUE - Success, file opened and loaded
    FALSE - Failure, file not loaded
--*/
{
    Assert(pszFoundFile);

    BOOL        bRet = TRUE;
    HCURSOR     hcursor = NULL;
    EDITSTREAM  editstr = {0};
    PathFile   *File = NULL;

    if ((OpenPathFile(pszFoundFile, 0, &File)) != S_OK)
    {
        ErrorBox(NULL, 0, ERR_File_Open, pszFoundFile);
        bRet = FALSE;
        goto exit;
    }

    // Store last write time to check for file changes.
    if (File->GetLastWriteTime(&m_LastWriteTime) != S_OK)
    {
        ZeroMemory(&m_LastWriteTime, sizeof(m_LastWriteTime));
    }

    // Set the Hour glass cursor
    hcursor = SetCursor( LoadCursor(NULL, IDC_WAIT) );

    // Select all of the text so that it will be replaced
    SendMessage(m_hwndChild, EM_SETSEL, 0, -1);

    // Put the text into the window
    editstr.dwCookie = (DWORD_PTR)File;
    editstr.pfnCallback = EditStreamCallback;

    SendMessage(m_hwndChild,
                EM_STREAMIN,
                SF_TEXT,
                (LPARAM) &editstr
                );

    // Restore cursor
    SetCursor(hcursor);

    _tcsncpy(m_szFoundFile, pszFoundFile, _tsizeof(m_szFoundFile) - 1 );
    m_szFoundFile[ _tsizeof(m_szFoundFile) - 1 ] = 0;
    if (pszSymFile != NULL && pszSymFile[0])
    {
        _tcsncpy(m_szSymFile, pszSymFile, _tsizeof(m_szSymFile) - 1 );
        m_szSymFile[ _tsizeof(m_szSymFile) - 1 ] = 0;
        m_pszSymFile = m_szSymFile;
    }
    else
    {
        // No symbol file information so just use the found filename.
        m_szSymFile[0] = 0;
        m_pszSymFile = strrchr(m_szFoundFile, '\\');
        if (m_pszSymFile == NULL)
        {
            m_pszSymFile = strrchr(m_szFoundFile, '/');
            if (m_pszSymFile == NULL)
            {
                m_pszSymFile = strrchr(m_szFoundFile, ':');
                if (m_pszSymFile == NULL)
                {
                    m_pszSymFile = m_szFoundFile - 1;
                }
            }
        }
        m_pszSymFile++;
    }

    SetWindowText(m_Win, m_szFoundFile);

    if (SendMessage(m_hwndChild, WM_GETTEXTLENGTH, 0, 0) == 0)
    {
        m_TextLines = 0;
    }
    else
    {
        m_TextLines = (ULONG)SendMessage(m_hwndChild, EM_GETLINECOUNT, 0, 0);
    }

    if (g_LineMarkers)
    {
        // Insert marker space before every line.
        for (ULONG i = 0; i < m_TextLines; i++)
        {
            CHARRANGE Ins;

            Ins.cpMin = (LONG)SendMessage(m_hwndChild, EM_LINEINDEX, i, 0);
            Ins.cpMax = Ins.cpMin;
            SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Ins);
            SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)"  ");
        }
    }
    
    // Request that the engine update the line map for the file.
    UiRequestRead();
    
exit:
    delete File;
    return bRet;
}

BOOL
SameFileName(PCSTR Name1, PCSTR Name2)
{
    while (*Name1)
    {
        if (!(((*Name1 == '\\' || *Name1 == '/') &&
               (*Name2 == '\\' || *Name2 == '/')) ||
              toupper(*Name1) == toupper(*Name2)))
        {
            return FALSE;
        }

        Name1++;
        Name2++;
    }

    return *Name2 == 0;
}

BOOL
FindDocWindowByFileName(
    IN          PCTSTR          pszFile,
    OPTIONAL    HWND           *phwnd,
    OPTIONAL    PDOCWIN_DATA   *ppDocWinData
    )
/*++
Returns
    TRUE - If the window is currently open.
    FALSE - Not currently open.
--*/
{
    Assert(pszFile);

    PLIST_ENTRY Entry;
    PDOCWIN_DATA pTmp;

    Entry = g_ActiveWin.Flink;

    while (Entry != &g_ActiveWin)
    {
        pTmp = (PDOCWIN_DATA)ACTIVE_WIN_ENTRY(Entry);
        if ( pTmp->m_enumType == DOC_WINDOW &&
             SameFileName(pTmp->m_szFoundFile, pszFile) )
        {
            if (ppDocWinData)
            {
                *ppDocWinData = pTmp;
            }
            if (phwnd)
            {
                *phwnd = pTmp->m_Win;
            }
            return TRUE;
        }

        Entry = Entry->Flink;
    }

    return FALSE;
}

BOOL
OpenOrActivateFile(PCSTR FoundFile, PCSTR SymFile, ULONG Line,
                   BOOL Activate, BOOL UserActivated)
{
    HWND hwndDoc = NULL;
    PDOCWIN_DATA pDoc;
    BOOL Activated = FALSE;

    if ( FindDocWindowByFileName( FoundFile, &hwndDoc, &pDoc) )
    {
        if (Activate)
        {
            // Found it. Now activate it.
            ActivateMDIChild(hwndDoc, UserActivated);
            Activated = TRUE;
        }
    }
    else
    {
        hwndDoc = NewDoc_CreateWindow(g_hwndMDIClient);
        if (hwndDoc == NULL)
        {
            return FALSE;
        }
        pDoc = GetDocWinData(hwndDoc);
        Assert(pDoc);

        if (!pDoc->LoadFile(FoundFile, SymFile))
        {
            DestroyWindow(pDoc->m_Win);
            return FALSE;
        }

        Activated = TRUE;
    }
    
    // Success. Now highlight the line.
    pDoc->SetCurrentLineHighlight(Line);
        
    return Activated;
}

void
UpdateCodeDisplay(
    ULONG64 Ip,
    PCSTR   FoundFile,
    PCSTR   SymFile,
    ULONG   Line,
    BOOL    UserActivated
    )
{
    // Update the disassembly window if there's one
    // active or there's no source information.

    BOOL Activated = FALSE;
    HWND hwndDisasm = GetDisasmHwnd();
        
    if (hwndDisasm == NULL && FoundFile == NULL &&
        (g_WinOptions & WOPT_AUTO_DISASM))
    {
        // No disassembly window around and no source so create one.
        hwndDisasm = NewDisasm_CreateWindow(g_hwndMDIClient);
    }

    if (hwndDisasm != NULL)
    {
        PDISASMWIN_DATA pDis = GetDisasmWinData(hwndDisasm);
        Assert(pDis);

        pDis->SetCurInstr(Ip);
    }
        
    if (FoundFile != NULL)
    {
        //
        // We now know the file name and line number. Either
        // it's open or we open it.
        //

        Activated = OpenOrActivateFile(FoundFile, SymFile, Line,
                                       GetSrcMode_StatusBar() ||
                                       g_DisasmActivateSource,
                                       UserActivated);
    }
    else
    {
        // No source file was found so make sure no
        // doc windows have a highlight.
        EDITWIN_DATA::RemoveActiveWinHighlights(1 << DOC_WINDOW,
                                                EHL_CURRENT_LINE);
    }

    if ((!Activated || !GetSrcMode_StatusBar()) && hwndDisasm != NULL)
    {
        // No window has been activated yet so fall back
        // on activating the disassembly window.
        ActivateMDIChild(hwndDisasm, UserActivated);
    }
}

void
SetTabWidth(ULONG TabWidth)
{
    PLIST_ENTRY Entry;
    PDOCWIN_DATA DocData;

    g_TabWidth = TabWidth;
    if (g_Workspace != NULL)
    {
        g_Workspace->SetUlong(WSP_GLOBAL_TAB_WIDTH, TabWidth);
    }
    
    Entry = g_ActiveWin.Flink;
    while (Entry != &g_ActiveWin)
    {
        DocData = (PDOCWIN_DATA)ACTIVE_WIN_ENTRY(Entry);
        if (DocData->m_enumType == DOC_WINDOW)
        {
            SendMessage(DocData->m_hwndChild, EM_SETTABSTOPS,
                        1, (LPARAM)&g_TabWidth);
        }

        Entry = Entry->Flink;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\docwin.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    docwin.h

Environment:

    Win32, User Mode

--*/

#define MAX_SOURCE_PATH 1024

extern ULONG g_TabWidth;
extern BOOL g_DisasmActivateSource;

class DOCWIN_DATA : public EDITWIN_DATA
{
public:
    // Two filenames are kept for source files, the filename
    // by which the file was opened on the local file system
    // and the original filename from symbolic information (or NULL
    // if the file was not opened as a result of symbol lookup).
    // The found filename is the one presented to the user while
    // the symbol filename is for line symbol queries.
    TCHAR       m_szFoundFile[MAX_SOURCE_PATH];
    TCHAR       m_szSymFile[MAX_SOURCE_PATH];
    PCTSTR      m_pszSymFile;
    FILETIME    m_LastWriteTime;
    CHARRANGE   m_FindSel;
    ULONG       m_FindFlags;

    DOCWIN_DATA();

    virtual void Validate();

    virtual BOOL CanGotoLine(void);
    virtual void GotoLine(ULONG Line);

    virtual void Find(PTSTR Text, ULONG Flags);

    virtual BOOL CodeExprAtCaret(PSTR Expr, PULONG64 Offset);
    virtual void ToggleBpAtCaret(void);
    virtual void UpdateBpMarks(void);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);
    
    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);
    
    virtual BOOL LoadFile(PCTSTR FoundFile, PCTSTR SymFile);
};
typedef DOCWIN_DATA *PDOCWIN_DATA;

BOOL
FindDocWindowByFileName(
    IN          PCTSTR          pszFile,
    OPTIONAL    HWND           *phwnd,
    OPTIONAL    PDOCWIN_DATA   *ppDocWinData
    );

BOOL OpenOrActivateFile(PCSTR FoundFile, PCSTR SymFile, ULONG Line,
                        BOOL Activate, BOOL UserActivated);
void UpdateCodeDisplay(ULONG64 Ip, PCSTR FoundFile, PCSTR SymFile, ULONG Line,
                       BOOL UserActivated);

VOID AddDocHwnd(HWND);
VOID RemoveDocHwnd(HWND);

void SetTabWidth(ULONG TabWidth);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\dialogs.h ===
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)





#define ID_SETBREAK_COMMAND                2200
#define ID_SETBREAK_THREAD                 2202
#define ID_SETBREAK_BREAKPOINT             2203
#define ID_SETBREAK_REMOVE                 2204
#define ID_SETBREAK_REMOVEALL              2205
#define ID_SETBREAK_DISABLE                2206
#define ID_SETBREAK_ENABLE                 2207

#define IDD_DLG_FILEOPEN_EXPLORER_EXTENSION_EXE_ARGS  2250
#define IDC_EDIT_ARGS                                 2251
#define IDC_EXEOPEN_CHILD_PROCESSES                   2252

#define IDD_DLG_KERNEL_COM                 2300
#define IDC_KD_BAUDRATE                    2301
#define IDC_KD_PORT                        2302

#define IDD_DLG_KERNEL_1394                2310
#define IDC_KD_1394_CHANNEL                2311

#define IDD_DLG_KERNEL_LOCAL               2320

#define IDD_DLG_CONNECTTOREMOTE            2400
#define IDC_REM_CONNECT_LABEL              2401
#define IDC_REM_CONNECT                    2402
#define IDC_REM_BROWSE                     2403

#define IDD_DLG_BROWSE_SERVERS             2450
#define IDC_BROWSE_MACHINE                 2451
#define IDC_BROWSE_REFRESH                 2452
#define IDC_BROWSE_SERVERS_LIST            2453

#define IDD_DLG_SYMBOLS                    2500
#define IDC_SYMPATH_LABEL                  2501
#define IDC_SYMPATH                        2502

#define IDD_DLG_REG_CUSTOMIZE              2600
#define IDC_REGCUST_ENTRY                  2601



#define IDD_DLG_MEMORY                     3012
#define IDD_DLG_BREAKPOINTS                3013
#define IDD_DLG_MEM_PHYSICAL               3014
#define IDD_DLG_MEM_VIRTUAL                3015
#define IDD_DLG_MEM_BUS_DATA               3016
#define IDD_DLG_MEM_CONTROL                3017
#define IDD_DLG_MEM_IO                     3018
#define IDD_DLG_MEM_MSR                    3019


#define IDC_LIST_CALLS                     3255


#define IDC_STATUS_BAR                     4000
#define IDC_TOOLBAR                        4001
#define IDC_RICHEDIT_CMD_HISTORY           4002
#define IDC_RICHEDIT_CMD_EDIT              4003
#define IDC_RICHEDIT_DOC_EDIT              4004
#define IDC_LISTVIEW                       4005

#define IDC_COMBO_MEM_TYPE                 4007
#define IDC_EDIT_MEM_ADDRESS               4008

#define IDC_COMBO_INTERFACE_TYPE           4009
#define IDC_EDIT_ADDRESS_SPACE             4010
#define IDC_EDIT_OFFSET                    4011
#define IDC_COMBO_BUS_DATA_TYPE            4012
#define IDC_EDIT_BUS_NUMBER                4013
#define IDC_EDIT_SLOT_NUMBER               4014
#define IDC_COMBO_DISPLAY_FORMAT           4015
#define IDC_EDIT_PROCESSOR                 4016

#define IDD_DLG_GOTO_LINE                  4100
#define IDC_LINE_ENTRY                     4101

#define IDD_DLG_GOTO_ADDRESS               4200
#define IDC_ADDRESS_ENTRY                  4201

#define IDD_DLG_LOG_FILE                   4300
#define IDC_LOG_FILE_NAME                  4301
#define IDC_LOG_CLOSE                      4302
#define IDC_LOG_APPEND                     4303

#define IDD_DLG_IMAGE_PATH                 4350
#define IDC_IMAGE_PATH                     4351

#define IDD_DLG_SOURCE_PATH                4400
#define IDC_SOURCE_PATH                    4401
#define IDC_LOCAL_SOURCE                   4402

#define IDD_DLG_ATTACH_PROCESS             4450
#define IDC_ATTACH_PID                     4451
#define IDC_ATTACH_PROC_LIST               4452
#define IDC_ATTACH_NONINVASIVE             4453

#define IDD_DLG_EVENT_FILTERS              4499
#define IDD_DLG_EXCEPTION_FILTER           4500
#define IDC_FILTER_ADD                     4501
#define IDC_FILTER_REMOVE                  4502
#define IDC_FILTER_ENABLED                 4503
#define IDC_FILTER_DISABLED                4504
#define IDC_FILTER_OUTPUT                  4505
#define IDC_FILTER_IGNORE                  4506
#define IDC_FILTERS                        4507
#define IDC_FILTER_CODE                    4508
#define IDC_FILTER_HANDLED                 4509
#define IDC_FILTER_NOT_HANDLED             4510
#define IDC_FILTER_ARGUMENT                4511
#define IDD_DLG_FILTER_ARGUMENT            4512
#define IDD_DLG_FILTER_COMMAND             4513
#define IDC_FILTER_COMMAND                 4514
#define IDC_FILTER_COMMAND2                4515

#define IDD_DLG_OPTIONS                    4550
#define IDC_OPTION_TAB_WIDTH               4551
#define IDC_OPTION_REPEAT_COMMANDS         4552
#define IDC_OPTION_COLOR_LIST              4553
#define IDC_OPTION_COLOR_DISPLAY           4554
#define IDC_OPTION_COLOR_CHANGE            4555
#define IDC_OPTION_DISASM_ACTIVATE_SOURCE  4556
#define IDC_OPTION_AUTO_CMD_SCROLL         4557

#define IDD_DLG_CLEAR_WORKSPACE            4600
#define IDC_CLW_SAVE_LIST                  4601
#define IDC_CLW_CLEAR                      4602
#define IDC_CLW_CLEAR_ALL                  4603
#define IDC_CLW_SAVE                       4604
#define IDC_CLW_SAVE_ALL                   4605
#define IDC_CLW_CLEAR_LIST                 4606

#define IDD_DLG_MODULES                    4625
#define IDC_MODULE_LIST                    4626

#define IDD_DLG_WORKSPACE_IO               4650
#define IDC_WORKSPACE_LIST                 4651
#define IDC_WORKSPACE_NAME                 4652

#define IDD_DLG_ADD_TO_COMMAND_HISTORY     4675
#define IDC_ATCH_TEXT                      4676

#define IDD_DLG_DELETE_WORKSPACES          4700
#define IDC_DELETE_WORKSPACE               4701
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\makefile.inc ===
$(O)\res_str.i: res_str.h
    $(TARGET_CPP) -EP -DRESOURCES -Tc res_str.h > $@

$(O)\windbg.res: $(O)\res_str.i dialogs.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\fncdefs.h ===
#if defined(DEFINE_GET_WINDATA)

DEFINE_GET_WINDATA(COMMONWIN_DATA, Common)
DEFINE_GET_WINDATA(CMDWIN_DATA, Cmd)
DEFINE_GET_WINDATA(SCRATCH_PAD_DATA, Scratch)
DEFINE_GET_WINDATA(CPUWIN_DATA, Cpu)
DEFINE_GET_WINDATA(CALLSWIN_DATA, Calls)
DEFINE_GET_WINDATA(MEMWIN_DATA, Mem)
DEFINE_GET_WINDATA(DISASMWIN_DATA, Disasm)
DEFINE_GET_WINDATA(LOCALSWIN_DATA, Locals)
DEFINE_GET_WINDATA(WATCHWIN_DATA, Watch)
DEFINE_GET_WINDATA(DOCWIN_DATA, Doc)
DEFINE_GET_WINDATA(PROCESS_THREAD_DATA, ProcessThread)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\format.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    format.h

Abstract:

    Formatting functions.

Environment:

    Win32, User Mode

--*/

typedef UINT FMTTYPE;

#define fmtAscii    0
#define fmtInt      1
#define fmtUInt     2
#define fmtFloat    3
#define fmtAddress  4
#define fmtUnicode  5
#define fmtBit      6
#define fmtBasis    0x0f

// override logic to force radix
#define fmtSpacePad 0x1000
#define fmtOverRide 0x2000
#define fmtZeroPad  0x4000
#define fmtNat      0x8000


int
CPCopyString(
    PTSTR *lplps,
    PTSTR lpT,
    TCHAR chEscape,
    BOOL fQuote
    );

BOOL
CPFormatMemory(
    LPCH    lpchTarget,
    DWORD    cchTarget,
    LPBYTE  lpbSource,
    DWORD    cBits,
    FMTTYPE fmtType,
    DWORD    radix
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\dualwin.cpp ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    dualwin.cpp

Abstract:

    Header for new window architecture functions.    

--*/


#include "precomp.hxx"
#pragma hdrstop

#define NAME_BUFFER 1024

BOOL g_UseTextMode = FALSE;

//
// DUALLISTWIN_DATA methods
//
DUALLISTWIN_DATA::DUALLISTWIN_DATA(ULONG ChangeBy)
    : SINGLE_CHILDWIN_DATA(ChangeBy)
{
    m_wFlags = DL_EDIT_SECONDPANE;
    m_hwndEditControl = NULL;
    m_nItem_LastSelected = -1;
    m_nSubItem_LastSelected = 0;
    m_nItem_CurrentlyEditing = -1;
    m_nSubItem_CurrentlyEditing = -1;
}

void
DUALLISTWIN_DATA::Validate()
{
    SINGLE_CHILDWIN_DATA::Validate();
}

void 
DUALLISTWIN_DATA::SetFont(ULONG FontIndex)
{
    SINGLE_CHILDWIN_DATA::SetFont(FontIndex);

    SendMessage(m_hwndEditControl, WM_SETFONT, 
                (WPARAM)m_Font->Font, TRUE);
}

BOOL
DUALLISTWIN_DATA::OnCreate(void)
{
    m_hwndChild = CreateWindowEx(
                      WS_EX_CLIENTEDGE,                           // Extended style
                      WC_LISTVIEW,                                // class name
                      NULL,                                       // title
                      WS_CHILD | WS_VISIBLE
                      | WS_MAXIMIZE
                      | WS_HSCROLL | WS_VSCROLL
                      | LVS_SHOWSELALWAYS
                      | LVS_REPORT | LVS_SINGLESEL
                      | ((m_enumType != CPU_WINDOW) 
                         ? LVS_OWNERDRAWFIXED : 0),            // style
                      0,                                          // x
                      0,                                          // y
                      CW_USEDEFAULT,                              // width
                      CW_USEDEFAULT,                              // height
                      m_Win,                                      // parent
                      0,                                          // control id
                      g_hInst,                                    // hInstance
                      NULL                                        // user defined data
                      );

    if (m_hwndChild == NULL)
    {
        return FALSE;
    }

    m_hwndEditControl = CreateWindowEx(
                            0,                                          // Extended style
                            RICHEDIT_CLASS,                             // class name
                            NULL,                                       // title
                            WS_CHILD,
                            0,                                          // x
                            0,                                          // y
                            CW_USEDEFAULT,                              // width
                            CW_USEDEFAULT,                              // height
                            m_Win,                                      // parent
                            0,                                          // control id
                            g_hInst,                                    // hInstance
                            NULL                                        // user defined data
                            );

    if (m_hwndEditControl == NULL)
    {
        DestroyWindow(m_hwndChild);
        return FALSE;
    }

    SetFont(FONT_FIXED);

    SendMessage(m_hwndEditControl,
        EM_SETEVENTMASK,
        0,
        (LPARAM) ENM_KEYEVENTS | ENM_MOUSEEVENTS
        );

    return TRUE;
}

LRESULT
DUALLISTWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    WORD wCode = HIWORD(wParam);
    WORD wId = LOWORD(wParam);
    HWND hwnd = (HWND) lParam;

    if (hwnd != m_hwndEditControl)
    {
        return 1; // Not handled
    }

    switch (wCode)
    {
    default:
        return 1; // not handled

    case EN_KILLFOCUS:
        //
        // Duplicate code in OnNotify : EN_MSGFILTER
        //
        if (-1 != m_nItem_CurrentlyEditing)
        {
            if (!SetItemFromEdit(m_nItem_CurrentlyEditing,
                                 m_nSubItem_CurrentlyEditing))
            {
                break;
            }

            ShowWindow(hwnd, SW_HIDE);
            SetFocus(m_hwndChild);

            InvalidateItem(m_nItem_CurrentlyEditing);

            m_nItem_CurrentlyEditing = -1;
            m_nSubItem_CurrentlyEditing = -1;
        }
        break;
    }

    return 0;
}

LRESULT
DUALLISTWIN_DATA::OnNotify(
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Branch depending on the specific notification message. 
    switch (((LPNMHDR) lParam)->code)
    {
    case LVN_ITEMCHANGED:
        InvalidateItem( ((LPNMLISTVIEW) lParam)->iItem);
        break;

    case NM_CLICK:
    case NM_DBLCLK:
        // Figure out whether an item or a sub-item was clicked
        OnClick((LPNMLISTVIEW) lParam);
        break;
    case NM_CUSTOMDRAW:
        return OnCustomDraw((LPNMLVCUSTOMDRAW)lParam);

    case EN_MSGFILTER:
        //
        // Duplicate code in OnCommand : EN_KILLFOCUS
        //
        if (WM_KEYDOWN == ((MSGFILTER *)lParam)->msg)
        {
            MSGFILTER * pMsgFilter = (MSGFILTER *) lParam;

            switch (pMsgFilter->wParam)
            {
            case VK_RETURN:
                // Ignore this message so the richedit
                // doesn't beep.
                return 1;
            }
        }
        else if (WM_CHAR == ((MSGFILTER *)lParam)->msg)
        {
            MSGFILTER * pMsgFilter = (MSGFILTER *) lParam;

            switch (pMsgFilter->wParam)
            {
            case VK_RETURN:
                if (!SetItemFromEdit(m_nItem_CurrentlyEditing,
                                     m_nSubItem_CurrentlyEditing))
                {
                    break;
                }
                // fall through...

            case VK_ESCAPE:
                InvalidateItem(m_nItem_CurrentlyEditing);

                //
                // Invalidate these before changing focus, so that Itemchanged 
                // doesn't get called again on same item
                //
                m_nItem_CurrentlyEditing = -1;
                m_nSubItem_CurrentlyEditing = -1;

                //
                // Hide the edit box and set focus to the list view
                //
                ShowWindow(m_hwndEditControl, SW_HIDE);
                SetFocus(m_hwndChild);

                break;
            }
        }
        else if (WM_RBUTTONDOWN == ((MSGFILTER *)lParam)->msg ||
                 WM_RBUTTONDBLCLK == ((MSGFILTER *)lParam)->msg)
        {
            // process cpoy/passte selection
            if (CanCopy())
            {
                Copy();

                CHARRANGE Sel;
                SendMessage(m_hwndEditControl, EM_EXGETSEL, 0, (LPARAM)&Sel);
                Sel.cpMax = Sel.cpMin;
                SendMessage(m_hwndEditControl, EM_EXSETSEL, 0, (LPARAM)&Sel);
            }
            else if (SendMessage(m_hwndEditControl, EM_CANPASTE, CF_TEXT, 0))
            {
                SetFocus(m_hwndEditControl);
                Paste();
            }

            // Ignore right-button events.
            return 1;

        }
        return 0; // process this message
    case LVN_COLUMNCLICK:
//      LVN_COLUMNCLICK pnmv = (LPNMLISTVIEW) lParam; 

        break;

    }

    return DefMDIChildProc(m_Win, WM_NOTIFY, wParam, lParam);
}


BOOL
DUALLISTWIN_DATA::ClearList(ULONG ClearFrom)
{
    if (!ClearFrom)
    {
        return ListView_DeleteAllItems(m_hwndChild);
    }
    else
    {
        ULONG nItems = ListView_GetItemCount(m_hwndChild);
        BOOL  res = TRUE;

        while (res && (ClearFrom < nItems))
        {
            res = ListView_DeleteItem(m_hwndChild, --nItems);
        }

        return res;
    }
}

void
DUALLISTWIN_DATA::InvalidateItem(
    int nItem
    )
{
    RECT rc = {0};

    if (-1 == nItem)
    {
        // Invalidate the entire window
        GetClientRect(m_hwndChild, &rc);
    }
    else
    {
        // Invalidate the item row
        if (!ListView_GetItemRect(m_hwndChild,nItem,&rc,LVIR_BOUNDS))
        {
            // Invalidate the entire window
            GetClientRect(m_hwndChild, &rc);
        }
    }
    InvalidateRect(m_hwndChild, &rc, TRUE);
}

void
DUALLISTWIN_DATA::ItemChanged(
    int Item,
    PCSTR Text
    )
{
    // Do-nothing placeholder.
}

LRESULT 
DUALLISTWIN_DATA::OnCustomDraw(LPNMLVCUSTOMDRAW Custom)
{
    static int s_SelectedItem = -1;
    static ULONG s_SubItem;
    
    switch (Custom->nmcd.dwDrawStage)
    {
    case CDDS_PREPAINT:
        s_SelectedItem = ListView_GetNextItem(m_hwndChild, -1, LVNI_SELECTED);
        if (m_wFlags & DL_CUSTOM_ITEMS)
        {
            return CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
        }
        else
        {
            return CDRF_NOTIFYPOSTPAINT;
        }

    case CDDS_ITEMPREPAINT:
        s_SubItem = 0;
        return CDRF_NOTIFYSUBITEMDRAW;
    case CDDS_ITEMPREPAINT | CDDS_SUBITEM:
        return OnCustomItem(s_SubItem++, Custom);
        
    case CDDS_POSTPAINT:
        if (-1 != s_SelectedItem)
        {
            RECT rc;

            // If we ask for subitem 0, then we get the rectangle for the
            // entire item, so we ask for item 1, and do the math

            Dbg( ListView_GetSubItemRect(m_hwndChild,
                                         s_SelectedItem,
                                         1,
                                         LVIR_BOUNDS,
                                         &rc));

            if (0 == m_nSubItem_LastSelected)
            {
                rc.right = rc.left - 1;
                rc.left = 0;
            }

            InvertRect(Custom->nmcd.hdc, &rc);
        }
        
        return CDRF_NOTIFYPOSTPAINT;

    default:
        return 0;
    }
}

LRESULT
DUALLISTWIN_DATA::OnCustomItem(ULONG SubItem, LPNMLVCUSTOMDRAW Custom)
{
    return CDRF_DODEFAULT;
}

void
DUALLISTWIN_DATA::OnClick(
    LPNMLISTVIEW Notify
    )
{
    LVHITTESTINFO lvHTInfo = {0};

    lvHTInfo.pt = Notify->ptAction;

    if (-1 != ListView_SubItemHitTest(m_hwndChild, &lvHTInfo) )
    {
        // success

        //
        // If the user click on a different item than the one currently selected
        // then the LVN_ITEMCHANGED message will take care of updating the screen.
        //
        // If the user clicked on the currently slected item then we need to 
        // check whether he wants to edit the contents or select a different subitem.
        //
        if (m_nItem_CurrentlyEditing == lvHTInfo.iItem
            && m_nSubItem_CurrentlyEditing == lvHTInfo.iSubItem)
        {
            ShowWindow(m_hwndEditControl, SW_SHOW);

            SetFocus(m_hwndEditControl);
        } else if (m_nItem_LastSelected == lvHTInfo.iItem
            && m_nSubItem_LastSelected == lvHTInfo.iSubItem)
        {
            // If we clicked on the currently selected item & subitem
            // then the user wants to edit the text.
            //
            // Is editing allowed
            if ( ( (0 == m_nSubItem_LastSelected) &&
                (m_wFlags & DL_EDIT_LEFTPANE) )       ||
                ( (1 == m_nSubItem_LastSelected) &&
                (m_wFlags & DL_EDIT_SECONDPANE) )      ||
                ( (2 == m_nSubItem_LastSelected) &&
                (m_wFlags & DL_EDIT_THIRDPANE) ) )
            {
                m_nItem_CurrentlyEditing = m_nItem_LastSelected;
                m_nSubItem_CurrentlyEditing = m_nSubItem_LastSelected;

                EditText();
            }
        }
        else
        {
            // User wants to select a different subitem
            m_nItem_LastSelected = lvHTInfo.iItem;
            m_nSubItem_LastSelected = lvHTInfo.iSubItem;
            InvalidateItem(lvHTInfo.iItem);
        }
    }
}

void
DUALLISTWIN_DATA::EditText()
{
    RECT rc;
    TCHAR sz[NAME_BUFFER * 10], *psz;
    LVITEM lvi = {0};

    // Get the item's text
    ListView_GetItemText(m_hwndChild, 
        m_nItem_CurrentlyEditing, 
        m_nSubItem_CurrentlyEditing, 
        sz, 
        _tsizeof(sz)
        );

    // If we ask for subitem 0, then we get the rectangle for the
    // entire item, so we ask for item m_nItem_CurrentlyEditing, and do the math 
    // if we need subitem 0
    Dbg( ListView_GetSubItemRect(m_hwndChild,
        m_nItem_CurrentlyEditing,
        (m_nSubItem_CurrentlyEditing ? m_nSubItem_CurrentlyEditing : 1),
        LVIR_BOUNDS,
        &rc));

    psz = &sz[0];
    if (0 == m_nSubItem_CurrentlyEditing)
    {
        rc.right = rc.left - 1;
        rc.left = 0;
    
        while (*psz && (*psz == ' ')) { 
            ++psz;
        }
    }

    SetWindowText(m_hwndEditControl, psz);

    CHARRANGE charRange={0};

    charRange.cpMax = strlen(psz);
    charRange.cpMin = 0;
    SendMessage(m_hwndEditControl, EM_EXSETSEL, (WPARAM) 0, (LPARAM) &charRange);
    SendMessage(m_hwndEditControl, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);


    POINT ChildBase = {0, 0};
    MapWindowPoints(m_hwndChild, m_Win, &ChildBase, 1);

    MoveWindow(m_hwndEditControl,
        rc.left + ChildBase.x,
        rc.top + ChildBase.y,
        rc.right - rc.left,
        rc.bottom - rc.top,
        FALSE);

    ShowWindow(m_hwndEditControl, SW_SHOW);

    SetFocus(m_hwndEditControl);
}


BOOL
DUALLISTWIN_DATA::CanCopy()
{
    HWND hwnd = (m_nItem_CurrentlyEditing == -1) ? m_hwndChild : m_hwndEditControl;
    CHARRANGE chrg;

    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM) (CHARRANGE *) &chrg);

    return chrg.cpMin != chrg.cpMax;
}

BOOL
DUALLISTWIN_DATA::CanCut()
{
    return(m_nItem_CurrentlyEditing != -1)  && CanCopy();
}

BOOL
DUALLISTWIN_DATA::CanPaste()
{
    return(m_nItem_CurrentlyEditing != -1) 
        && SendMessage(m_hwndEditControl,
                       EM_CANPASTE,
                       CF_TEXT,
                       0
                       );
}

CHAR ListCopy[500];

void
DUALLISTWIN_DATA::Copy()
{
    if ((m_nItem_CurrentlyEditing == -1) &&
        (m_nItem_LastSelected != -1))
    {
        PCHAR sz = &ListCopy[0];

        ZeroMemory(sz, sizeof(ListCopy));
        if (!GlobalLock( (HGLOBAL) sz)) 
        {
            return;
        }
        ListView_GetItemText(m_hwndChild, m_nItem_LastSelected, m_nSubItem_LastSelected,
                             sz, sizeof(ListCopy));

        CopyToClipboard(sz);
    }
    else
    {
        SendMessage(m_hwndEditControl, WM_COPY, 0, 0);
    }

}

void
DUALLISTWIN_DATA::Cut()
{
    SendMessage(m_hwndEditControl, WM_CUT, 0, 0);
}

void
DUALLISTWIN_DATA::Paste()
{
    SendMessage(m_hwndEditControl, WM_PASTE, 0, 0);
}

ULONG
DUALLISTWIN_DATA::GetItemFlags(ULONG Item)
{
    LVITEM LvItem;
    
    LvItem.mask = LVIF_PARAM;
    LvItem.iItem = Item;
    LvItem.iSubItem = 0;
    if (ListView_GetItem(m_hwndChild, &LvItem))
    {
        return (ULONG)LvItem.lParam;
    }
    else
    {
        return 0;
    }
}

void
DUALLISTWIN_DATA::SetItemFlags(ULONG Item, ULONG Flags)
{
    LVITEM LvItem;
    
    LvItem.mask = LVIF_PARAM;
    LvItem.iItem = Item;
    LvItem.iSubItem = 0;
    LvItem.lParam = (LPARAM)Flags;
    ListView_SetItem(m_hwndChild, &LvItem);
}

BOOL
DUALLISTWIN_DATA::SetItemFromEdit(ULONG Item, ULONG SubItem)
{
    //
    // Save the text from the edit box to list item.
    // 
    int nLen = GetWindowTextLength(m_hwndEditControl) + 1;
    PTSTR psz = (PTSTR)calloc( nLen, sizeof(TCHAR) );
    if (psz == NULL)
    {
        return FALSE;
    }

    GetWindowText(m_hwndEditControl, psz, nLen);

    ListView_SetItemText(m_hwndChild, Item, SubItem, psz);
    SetItemFlags(Item, GetItemFlags(Item) | ITEM_CHANGED);

    ItemChanged(Item, psz);

    free(psz);
    return TRUE;
}

//
// SYMWIN_DATA methods
//

HMENU SYMWIN_DATA::s_ContextMenu;

SYMWIN_DATA::SYMWIN_DATA(IDebugSymbolGroup **pDbgSymbolGroup)
    : DUALLISTWIN_DATA(2048)
{
    m_pWinSyms = NULL;
    m_nWinSyms = 0; 
    m_pDbgSymbolGroup = pDbgSymbolGroup;
    m_NumSymsDisplayed = 0;
    m_DisplayTypes = FALSE;
    m_DisplayOffsets = FALSE;
    m_RefreshItem = 0;
    m_UpdateItem = -1;
    m_SplitWindowAtItem = 0;
    m_MaxNameWidth = 0;
    m_NumCols = 0;
    SetMaxSyms(1);
    // Use text for Accessibility readers
    SystemParametersInfo(SPI_GETSCREENREADER, 0, &g_UseTextMode, 0);

}

#define VALUE_COLM  1
#define TYPE_COLM   2
#define OFFSET_COLM (m_DisplayTypes ? 3 : 2)

SYMWIN_DATA::~SYMWIN_DATA()    
{
    if (m_pWinSyms)
    {
        free (m_pWinSyms);
    }
    return;
}


void 
SYMWIN_DATA::Validate()
{
    DUALLISTWIN_DATA::Validate();
}

#define SYMWIN_CONTEXT_ID_BASE 0x100

#define SYMWIN_TBB_TYPECAST 0
#define SYMWIN_TBB_OFFSETS  1

TBBUTTON g_SymWinTbButtons[] =
{
    TEXT_TB_BTN(SYMWIN_TBB_TYPECAST, "Typecast", BTNS_CHECK),
    TEXT_TB_BTN(SYMWIN_TBB_OFFSETS, "Offsets", BTNS_CHECK),
    SEP_TB_BTN(),
    TEXT_TB_BTN(ID_SHOW_TOOLBAR, "Toolbar", 0),
};

#define NUM_SYMWIN_MENU_BUTTONS \
    (sizeof(g_SymWinTbButtons) / sizeof(g_SymWinTbButtons[0]))
#define NUM_SYMWIN_TB_BUTTONS \
    (NUM_SYMWIN_MENU_BUTTONS - 2)

#define IsAParent(Sym) ((Sym)->SubElements)
#define SYM_LEVEL(sym) ((sym)->Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK)
#define IsRootSym(Sym) !SYM_LEVEL(Sym)

HMENU
SYMWIN_DATA::GetContextMenu(void)
{
    //
    // We only keep one menu around for all call windows
    // so apply the menu check state for this particular
    // window.
    //

    CheckMenuItem(s_ContextMenu, SYMWIN_TBB_TYPECAST + SYMWIN_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_DisplayTypes ? MF_CHECKED : 0));
    CheckMenuItem(s_ContextMenu, SYMWIN_TBB_OFFSETS + SYMWIN_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_DisplayOffsets ? MF_CHECKED : 0));
    CheckMenuItem(s_ContextMenu, ID_SHOW_TOOLBAR + SYMWIN_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_ShowToolbar ? MF_CHECKED : 0));
    
    return s_ContextMenu;
}

void
SYMWIN_DATA::OnContextMenuSelection(UINT Item)
{
    ULONG Changed = 0;
    
    Item -= SYMWIN_CONTEXT_ID_BASE;
    
    switch(Item)
    {
    case SYMWIN_TBB_TYPECAST:
        SetDisplayTypes(Item, !m_DisplayTypes);
        Changed = 1 << SYMWIN_TBB_TYPECAST;
        break;
    case SYMWIN_TBB_OFFSETS:
        SetDisplayTypes(Item, !m_DisplayOffsets);
        Changed = 1 << SYMWIN_TBB_OFFSETS;
        break;
    case ID_SHOW_TOOLBAR:
        SetShowToolbar(!m_ShowToolbar);
        break;
    }
    SyncUiWithFlags(Changed);
}
    
BOOL
SYMWIN_DATA::OnCreate(void)
{
    if (s_ContextMenu == NULL)
    {
        s_ContextMenu = CreateContextMenuFromToolbarButtons
            (NUM_SYMWIN_MENU_BUTTONS, g_SymWinTbButtons,
             SYMWIN_CONTEXT_ID_BASE);
        if (s_ContextMenu == NULL)
        {
            return FALSE;
        }
    }
    
    if (!DUALLISTWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    m_Toolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                    WS_CHILD | WS_VISIBLE |
                    TBSTYLE_WRAPABLE | TBSTYLE_LIST | CCS_TOP,
                    0, 0, m_Size.cx, 0, m_Win, (HMENU)ID_TOOLBAR,
                    g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }
    SendMessage(m_Toolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_Toolbar, TB_ADDBUTTONS, NUM_SYMWIN_TB_BUTTONS,
        (LPARAM)&g_SymWinTbButtons);
    SendMessage(m_Toolbar, TB_AUTOSIZE, 0, 0);

    RECT Rect;
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top + GetSystemMetrics(SM_CYEDGE);
    m_ShowToolbar = TRUE;

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    RECT        rc;
    LV_COLUMN   lvc = {0};

    GetClientRect(m_hwndChild, &rc);
    rc.right -= rc.left + GetSystemMetrics(SM_CXVSCROLL);

    //initialize the columns
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM | LVCF_TEXT;
    lvc.fmt = LVCFMT_LEFT;
    lvc.iSubItem = 0;

    lvc.cx = m_Font->Metrics.tmAveCharWidth * 20;
    if (lvc.cx > rc.right / 2)
    {
        lvc.cx = rc.right / 2;
    }
    lvc.pszText = _T("Name");
    Dbg( (0 == ListView_InsertColumn(m_hwndChild, 0, &lvc)) );

    // Give the rest of the space to the value.
    lvc.cx = rc.right - lvc.cx;
    lvc.pszText = _T("Value");
    Dbg( (1 == ListView_InsertColumn(m_hwndChild, 1, &lvc)) );
    m_NumCols = 2;

    ListView_SetExtendedListViewStyle(m_hwndChild, 
        LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT
        );
    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);


    return TRUE;
}

void
SYMWIN_DATA::OnSize(void)
{
    DUALLISTWIN_DATA::OnSize();

//    ListView_SetColumnWidth(m_hwndChild, 0 , m_MaxNameWidth);
}


LRESULT
SYMWIN_DATA::OnNotify(
    WPARAM              wParam,
    LPARAM              lParam
    )
{
    if (((LPNMHDR) lParam)->code == LVN_KEYDOWN)
    {
        if (m_nItem_LastSelected != -1 &&
            m_nItem_CurrentlyEditing == -1 &&
            g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            NMLVKEYDOWN * pNmKeyDown = (NMLVKEYDOWN *) lParam;

            switch (pNmKeyDown->wVKey)
            {
            case VK_LEFT:
                if (m_nSubItem_LastSelected == 0)
                {
                    ExpandSymbol(m_nItem_LastSelected, FALSE);
                    return TRUE;
                }
                break;
            case VK_RIGHT:
                if (m_nSubItem_LastSelected == 0)
                {
                    ExpandSymbol(m_nItem_LastSelected, TRUE);
                    return TRUE;
                }
                break;
            case VK_RETURN:
                switch (m_nSubItem_LastSelected) { 
                case 0:
                    if (IsRootSym(&m_pWinSyms[m_nItem_LastSelected]) && (m_enumType == WATCH_WINDOW))
                    {
                        m_nItem_CurrentlyEditing   = m_nItem_LastSelected;
                        m_nSubItem_CurrentlyEditing=0;
                        EditText();
                    }
                    break;
                case 1:
                    if (!(m_pWinSyms[m_nItem_LastSelected].Flags & DEBUG_SYMBOL_READ_ONLY))
                    {
                        m_nItem_CurrentlyEditing   = m_nItem_LastSelected;
                        m_nSubItem_CurrentlyEditing=1;
                        EditText();
                    }
                    break;
                case 2:
                    m_nItem_CurrentlyEditing   = m_nItem_LastSelected;
                    m_nSubItem_CurrentlyEditing=2;
                    EditText();
                    break;
                default:
                    break;
                }
                break;
            default:
                break;
            }
            
        }
    }
    else if (((LPNMHDR) lParam)->code == LVN_ITEMCHANGED)
    {
        LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam; 

        if (pnmv->uNewState & LVIS_SELECTED) 
        {
            m_nItem_LastSelected = pnmv->iItem;
            m_nSubItem_LastSelected = pnmv->iSubItem;
        }
    }
    return DUALLISTWIN_DATA::OnNotify(wParam, lParam);
}

void
SYMWIN_DATA::OnUpdate(
    UpdateType Type
    )
{
    if (Type == UPDATE_EXEC)
    {
        // Disallow editing when the debuggee is running.
        if (g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            if (m_enumType != LOCALS_WINDOW)
            {
                m_wFlags |= DL_EDIT_LEFTPANE;
            }
            else
            {
                m_wFlags &= ~DL_EDIT_LEFTPANE;
            }
            ListView_SetTextBkColor(m_hwndChild, GetSysColor(COLOR_WINDOW));
        }
        else
        {
            m_wFlags = 0;
            ListView_SetTextBkColor(m_hwndChild, GetSysColor(COLOR_3DFACE));
        }
        InvalidateRect(m_hwndChild, NULL, FALSE);
        return;
    }
    else if (Type != UPDATE_BUFFER)
    {
        return;
    }
    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    UpdateNames();

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);
}

void 
SYMWIN_DATA::ExpandSymbol(
    ULONG Index, 
    BOOL Expand
    )
{
    //
    // Expand the Item
    //
    UIC_SYMBOL_WIN_DATA* WatchItem;

    WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
    if (WatchItem != NULL)
    {

        WatchItem->Type = EXPAND_SYMBOL;
        WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
        WatchItem->u.ExpandSymbol.Index = Index;
        WatchItem->u.ExpandSymbol.Expand = Expand;
        FinishCommand();
        UiRequestRead();
    }

}

ULONG
SYMWIN_DATA::GetWorkspaceSize(void)
{
    return DUALLISTWIN_DATA::GetWorkspaceSize() + 2*sizeof(BOOL);
}

PUCHAR
SYMWIN_DATA::SetWorkspace(PUCHAR Data)
{
    Data = DUALLISTWIN_DATA::SetWorkspace(Data);
    *(PBOOL)Data = m_DisplayTypes;
    Data += sizeof(BOOL);
    *(PBOOL)Data = m_DisplayOffsets;
    Data += sizeof(BOOL);
    
    return Data;
}

PUCHAR
SYMWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    UIC_SYMBOL_WIN_DATA* WatchItem;
    
    Data = DUALLISTWIN_DATA::ApplyWorkspace1(Data, End);

    // Clear the window
    WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
    if (WatchItem != NULL)
    {
        WatchItem->Type = DEL_SYMBOL_WIN_ALL;
        WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
        FinishCommand();
    }

    ULONG Changed = 0;
    
    if (End - Data >= sizeof(BOOL))
    {
        SetDisplayTypes(SYMWIN_TBB_TYPECAST, *(PBOOL)Data);
        Changed |= 1 << SYMWIN_TBB_TYPECAST;
        Data += sizeof(BOOL);
    }
    if (End - Data >= sizeof(BOOL))
    {
        SetDisplayTypes(SYMWIN_TBB_OFFSETS, *(PBOOL)Data);
        Changed |= 1 << SYMWIN_TBB_OFFSETS;
        Data += sizeof(BOOL);
    }
    SyncUiWithFlags(Changed);

    return Data;
}

BOOL
SYMWIN_DATA::AddListItem(
    ULONG iItem,
    PSTR ItemText, 
    ULONG Level, 
    BOOL  HasChildren, 
    BOOL  Expanded)
{
    HBITMAP hbmp;
    LVITEM  LvItem = {0};
    CHAR Name[NAME_BUFFER], OldName[NAME_BUFFER];
    ULONG i;

    LvItem.mask = LVIF_TEXT | LVIF_INDENT;
    Name[0] = 0;
    
    ULONG NameUsed = strlen(Name);

    // HACK - Column qutosize doesn't take indent into account
    // while autosizing the column, so padd with spaces in front to make it work
    i=0;
    while (i<=(Level+2))
    { 
        Name[i++]=' ';
    }
    Name[i]=0;
    
    strcat(Name, ItemText);

    LvItem.pszText = Name;
    LvItem.iItem = iItem;
    LvItem.iIndent = Level + 1;
    if ((ULONG)ListView_GetItemCount(m_hwndChild) <= iItem) 
    {
        ListView_InsertItem(m_hwndChild, &LvItem);
        return TRUE;
    }
    else
    {
        ListView_GetItemText(m_hwndChild, iItem, 0, OldName, sizeof(OldName));
        ListView_SetItem(m_hwndChild, &LvItem);
        return (strcmp(Name, OldName) != 0);
    }

}

void
SYMWIN_DATA::UpdateNames()
{
    ULONG   Sym, Items;
    PSTR    Buf;
    HRESULT Status;
    PDEBUG_SYMBOL_PARAMETERS SymParams = GetSymParam();
    BOOL    NameChanged;
    HDC     hDC = GetDC(m_hwndChild);
    TEXTMETRIC tm = {0}; 

    Items = ListView_GetItemCount(m_hwndChild);
    GetTextMetrics(hDC, &tm);    
    ReleaseDC(m_hwndChild, hDC); 

    if (UiLockForRead() == S_OK)
    {
        Buf = (PSTR)GetDataBuffer();

        ULONG Len, i;
        CHAR  Name[NAME_BUFFER], Value[NAME_BUFFER], Type[NAME_BUFFER], Offset[20];
        ULONG LastArgSym=-1, LastParent=0;

        Items = 0;
        
        if (m_UpdateItem < m_SplitWindowAtItem) 
        {
            LastArgSym = m_UpdateItem;
            m_SplitWindowAtItem = 0;
        }

        for (Sym = m_UpdateItem; Sym < m_NumSymsDisplayed; Sym++)
        {
            PSTR EndTag, pName;
            PSTR NameSt, NameEn;
            PSTR OffSt, OffEn;

            if (Buf == NULL)
            {
                strcpy(Name, _T("Unknown"));
                strcpy(Value, _T(""));
            } else
            {
                // DebugPrint("SYM_WIN: Buffer left %s\n", Buf);
                
                Name[0] = 0;
                EndTag = strstr(Buf, DEBUG_OUTPUT_NAME_END);
                if (!EndTag)
                {
                    break;
                }

                NameSt = Buf;
                NameEn = EndTag;

                Buf = EndTag + strlen(DEBUG_OUTPUT_NAME_END);
                EndTag = strstr(Buf, DEBUG_OUTPUT_VALUE_END);
                if (!EndTag)
                {
                    break;
                }

                Len = (ULONG) (EndTag - Buf);
                if (Len >= sizeof(Value))
                {
                    Len = sizeof(Value) - 1;
                }
                memcpy(Value, Buf, Len);
                Value[Len] = 0;

                Buf = EndTag + strlen(DEBUG_OUTPUT_VALUE_END);

                if (m_DisplayOffsets)
                {

                    EndTag = strstr(Buf, DEBUG_OUTPUT_OFFSET_END);
                    if (!EndTag)
                    {
                        EndTag = Buf;
                    }

                    Len = (ULONG) (EndTag - Buf);
                    if (Len >= sizeof(Offset))
                    {
                        Len = sizeof(Offset) - 1;
                    }
                    memcpy(Offset, Buf, Len);
                    Offset[Len] = 0;

                    Buf = EndTag + strlen(DEBUG_OUTPUT_OFFSET_END);
                    
                }
                

                Len = (ULONG) (NameEn - NameSt);
                if (Len >= sizeof(Name) - 10)
                {
                    Len = sizeof(Name) - 11;
                }
                strncat(Name, NameSt, Len);

                if (m_DisplayTypes)
                {

                    EndTag = strstr(Buf, DEBUG_OUTPUT_TYPE_END);
                    if (!EndTag)
                    {
                        EndTag = Buf;
                    }

                    Len = (ULONG) (EndTag - Buf);
                    if (Len >= sizeof(Type))
                    {
                        Len = sizeof(Type) - 1;
                    }
                    memcpy(Type, Buf, Len);
                    Type[Len] = 0;

                    Buf = EndTag + strlen(DEBUG_OUTPUT_TYPE_END);
                }
            }

            if (GetMaxSyms() > Sym)
            {
                NameChanged =
                    AddListItem(Sym, Name, SYM_LEVEL((SymParams + Sym)), 
                                SymParams[Sym].SubElements, SymParams[Sym].Flags & DEBUG_SYMBOL_EXPANDED);
            } else
            {
                break;
            }
            
            if (!(SymParams[Sym].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK))
            {
                LastParent = Sym;

                if ((SymParams[Sym].Flags & DEBUG_SYMBOL_IS_ARGUMENT) &&
                    (m_enumType == LOCALS_WINDOW))
                {
                    LastArgSym = Sym;
                }

                if ((LastParent > LastArgSym) && !m_SplitWindowAtItem)
                {
                    m_SplitWindowAtItem = Sym;
                }
            }
               
            
            if (!NameChanged) 
            {
                // Check if the value changed
                PCHAR OldValue = &Name[0];
                ListView_GetItemText(m_hwndChild, Sym, VALUE_COLM, OldValue, sizeof(Name));

                if (strcmp(OldValue, Value))
                {
                    // Value changed
                    SymParams[Sym].Flags |= ITEM_VALUE_CHANGED;
                    //                    ListView_SetTextColor(m_hwndChild, RGB(0xff, 0, 0));
                } else
                {
                    SymParams[Sym].Flags &= ~ITEM_VALUE_CHANGED;
                }

            }
            ListView_SetItemText(m_hwndChild, Sym, VALUE_COLM, Value);

            if (m_DisplayOffsets)
            {
                ListView_SetItemText(m_hwndChild, Sym, OFFSET_COLM, Offset);

            }
            if (m_DisplayTypes)
            {
                ListView_SetItemText(m_hwndChild, Sym, TYPE_COLM, Type);
            }

            if (Sym < sizeof(m_ListItemLines)) 
            {
    
                m_ListItemLines[Sym] = 2;
            }
        }

        UnlockStateBuffer(this);
    }
    
    ClearList(m_NumSymsDisplayed);

    if (Items == 0 && (m_enumType == WATCH_WINDOW))
    {
        //
        // add a dummy to enable adding new items
        //
        LVITEM  LvItem = {0};
        LvItem.mask = LVIF_TEXT | LVIF_INDENT;
        LvItem.pszText = "";
        LvItem.iItem = m_NumSymsDisplayed;
        ListView_InsertItem(m_hwndChild, &LvItem);
        // ListView_SetItemText(m_hwndChild, m_NumSymsDisplayed, 1, "Dummy");
    }
    m_MaxNameWidth = 0;
    m_UpdateItem = -1;
}

#define ALLOCATE_CHUNK 0x100
HRESULT
SYMWIN_DATA::SetMaxSyms(
    ULONG nSyms
    )
{
    if (m_nWinSyms < nSyms)
    {
        m_nWinSyms = ALLOCATE_CHUNK * ((nSyms + ALLOCATE_CHUNK - 1 )/ ALLOCATE_CHUNK);
        m_pWinSyms = (DEBUG_SYMBOL_PARAMETERS *) realloc(m_pWinSyms, m_nWinSyms*sizeof(DEBUG_SYMBOL_PARAMETERS));
    }
    if (m_pWinSyms)
    {
        return S_OK;
    }
    m_nWinSyms = 0;
    return E_OUTOFMEMORY;
}

LRESULT
SYMWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if ((HWND) lParam == m_Toolbar)
    {
        OnContextMenuSelection(LOWORD(wParam) + SYMWIN_CONTEXT_ID_BASE);
        return 0;
    }

    return DUALLISTWIN_DATA::OnCommand(wParam, lParam);
}


void
SYMWIN_DATA::OnClick(
    LPNMLISTVIEW Notify
    )
{

    LVHITTESTINFO lvHTInfo = {0};
    RECT          itemRect;
    ULONG         item;

    lvHTInfo.pt = Notify->ptAction;

    if (-1 != ListView_SubItemHitTest(m_hwndChild, &lvHTInfo) &&
        (m_NumSymsDisplayed > (ULONG) lvHTInfo.iItem) &&
        (g_ExecStatus == DEBUG_STATUS_BREAK))
    {
        PDEBUG_SYMBOL_PARAMETERS SymParams = GetSymParam();
    
            item = lvHTInfo.iItem;
            if (ListView_GetItemRect(m_hwndChild, lvHTInfo.iItem, &itemRect, LVIR_BOUNDS))
            {
                if (((int) SYM_LEVEL(&SymParams[item]) * m_IndentWidth < Notify->ptAction.x)  &&
                     (Notify->ptAction.x < (int) (itemRect.left + m_IndentWidth * (2+SYM_LEVEL(&SymParams[item])))) &&
                    (lvHTInfo.iSubItem == 0) &&
                    (SymParams[item].SubElements))
                {
                    BOOL Expand = TRUE;    
                    if (SymParams[item].SubElements)
                    {
                        if ((m_NumSymsDisplayed > item + 1)  &&
                            (SymParams[item+1].ParentSymbol == item) &&
                            ((SymParams[item+1].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) ==
                             (SymParams[item].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) + 1))
                         {
                            //
                            // Already expanded
                            //
                            Expand = FALSE;
                        }
    
                        ExpandSymbol(item, Expand);
                    }
                    m_RefreshItem = item;
                    
                    m_nItem_LastSelected = lvHTInfo.iItem;
                    m_nSubItem_LastSelected = lvHTInfo.iSubItem;

                    return;
                }
            }
    
            //
            // Check if ok to edit right pane
            //
            if (SymParams[lvHTInfo.iItem].Flags & DEBUG_SYMBOL_READ_ONLY)
            {
                m_wFlags &= ~DL_EDIT_SECONDPANE;            
            }
            else
            {
                m_wFlags |= DL_EDIT_SECONDPANE;
            }
            //
            // Check if ok to edit left pane
            //
            if ((SymParams[lvHTInfo.iItem].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) ||
                (m_enumType != WATCH_WINDOW))
            {
                m_wFlags &= ~DL_EDIT_LEFTPANE;            
            }
            else
            {
                m_wFlags |= DL_EDIT_LEFTPANE;
            }
            
            if (m_DisplayTypes) 
            {
                m_wFlags |= DL_EDIT_THIRDPANE;
            } 
            else
            {
                m_wFlags &= ~DL_EDIT_THIRDPANE;
            }
    }
    else if ((m_enumType == WATCH_WINDOW) &&
             (g_ExecStatus == DEBUG_STATUS_BREAK) &&
             (m_NumSymsDisplayed == (ULONG) lvHTInfo.iItem))
    {
        m_wFlags |= DL_EDIT_LEFTPANE;
    }

    //
    // Default processing
    //
    DUALLISTWIN_DATA::OnClick(Notify);
}

HRESULT
SYMWIN_DATA::ReadState(void)
{
    HRESULT Status;
    ULONG   getSyms;

    if (m_pDbgSymbolGroup == NULL ||
        *m_pDbgSymbolGroup == NULL)
    {
        return E_UNEXPECTED;
    }

    (*m_pDbgSymbolGroup)->GetNumberSymbols(&m_NumSymsDisplayed);
    if (m_NumSymsDisplayed < m_RefreshItem) 
    {
        // numsyms changed since last click - might happen for locals
        
        m_RefreshItem = 0;
    }
    getSyms = m_NumSymsDisplayed - m_RefreshItem;
    if (m_NumSymsDisplayed > GetMaxSyms())
    {
        if ((Status = SetMaxSyms(m_NumSymsDisplayed)) != S_OK)
        {
            m_NumSymsDisplayed = 0;
            return Status;
        }
    }

    (*m_pDbgSymbolGroup)->GetSymbolParameters(m_RefreshItem, getSyms, GetSymParam() + m_RefreshItem);
    Empty();

    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(TRUE)) != S_OK)
    {
        return Status;
    }
    (*m_pDbgSymbolGroup)->OutputSymbols(DEBUG_OUTCTL_THIS_CLIENT |
        DEBUG_OUTCTL_OVERRIDE_MASK |
        DEBUG_OUTCTL_NOT_LOGGED, 
        (m_DisplayOffsets ? 0 : DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS) | 
        (m_DisplayTypes ? 0 : DEBUG_OUTPUT_SYMBOLS_NO_TYPES), 
        m_RefreshItem, 
        m_NumSymsDisplayed - m_RefreshItem);

    Status = g_OutStateBuf.End(FALSE);
    m_UpdateItem = m_RefreshItem;
    m_RefreshItem = 0;
    return Status;
}

void
SYMWIN_DATA::ItemChanged(int Item, PCSTR Text)
{
    UIC_SYMBOL_WIN_DATA* WatchItem;

    if (m_nItem_CurrentlyEditing == -1)
    {
        return;
    }

    if (m_nSubItem_CurrentlyEditing == 0)
    {
        //
        // First delete, then add the item
        // 

        if (Item < (int) GetMaxSyms() && Item < (int) m_NumSymsDisplayed)
        {
            //  
            // See if this item can be changed or not - only root and dummy can be chnged
            //
            if ((GetSymParam())[Item].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK)
            {
                UiRequestRead();
                return;
            }
        }

        WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
        if (WatchItem != NULL)
        {

            WatchItem->Type = DEL_SYMBOL_WIN_INDEX;

            WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
            WatchItem->u.DelIndex = Item;
            FinishCommand();
        }
        else
        {
            // XXX drewb - Failure?
        }


        WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
        while ((*Text == ' ' || *Text == '+' || *Text == '-') && 
            *Text != '\0' )
            Text++; 
        if (WatchItem != NULL)
        {
            PCHAR End;

            WatchItem->Type = ADD_SYMBOL_WIN;
            WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
            strcpy(m_ChangedName, Text);
            End = strchr(m_ChangedName, ' ');
            if (End)
                *End = 0;
            WatchItem->u.Add.Name = m_ChangedName;
            WatchItem->u.Add.Index = Item;
            FinishCommand();
        }

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }

    } else if (m_nSubItem_CurrentlyEditing == 1)
    {
        WatchItem = StartStructCommand(UIC_SYMBOL_WIN);

        if (WatchItem != NULL)
        {
            strcpy(m_ChangedName, Text);
            WatchItem->Type = EDIT_SYMBOL;
            WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
            WatchItem->u.WriteSymbol.Index = m_nItem_CurrentlyEditing;
            WatchItem->u.WriteSymbol.Value = m_ChangedName;
            FinishCommand();
        }
    } else if (m_nSubItem_CurrentlyEditing == 2)
    {
        WatchItem = StartStructCommand(UIC_SYMBOL_WIN);

        if (WatchItem != NULL)
        {
            strcpy(m_ChangedName, Text);
            WatchItem->Type = EDIT_TYPE;
            WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
            WatchItem->u.OutputAsType.Index = m_nItem_CurrentlyEditing;
            WatchItem->u.OutputAsType.Type = m_ChangedName;
            FinishCommand();
        }
    }
    UiRequestRead();
}

void
SYMWIN_DATA::SetDisplayTypes(LONG Id, BOOL Set)
{
    if (Id == g_SymWinTbButtons[0].idCommand ||
        Id == g_SymWinTbButtons[1].idCommand) 
    {
        //
        // Add / remove a column
        //
        if (Id == g_SymWinTbButtons[0].idCommand) 
        {
            m_wFlags |= DL_EDIT_THIRDPANE;
            
            if (Set == m_DisplayTypes)
            {
                return;
            }

            m_DisplayTypes = Set;
        }
        else
        {
            if (Set == m_DisplayOffsets)
            {
                return;
            }

            m_DisplayOffsets = Set;
        }

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        if (Id == g_SymWinTbButtons[1].idCommand) 
        {
            //UiRequestRead();
            //return;
        }
        
        if (Set)
        {
            LV_COLUMN   lvc = {0};
            int         Col1Width;

            Col1Width = ListView_GetColumnWidth(m_hwndChild, VALUE_COLM);

            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM | LVCF_TEXT;
            lvc.fmt = LVCFMT_LEFT;
            lvc.iSubItem = 0;

            if (Col1Width >= (m_Font->Metrics.tmAveCharWidth * 20))
            {
                lvc.cx = max(Col1Width / 4,
                             m_Font->Metrics.tmAveCharWidth * 10);
                Col1Width -= lvc.cx;
            } else
            {
                lvc.cx = Col1Width >> 1;
                Col1Width -= lvc.cx;
            }
            ListView_SetColumnWidth(m_hwndChild, VALUE_COLM, Col1Width);


            lvc.pszText = _T((Id == g_SymWinTbButtons[0].idCommand) ? "Type" : "Offset");
            ListView_InsertColumn(
                m_hwndChild, 
                ((Id == g_SymWinTbButtons[0].idCommand) ? TYPE_COLM : OFFSET_COLM), 
                &lvc);
            m_NumCols++;
        }
        else
        {
            if (Id == g_SymWinTbButtons[0].idCommand) 
            {
                m_wFlags &= ~DL_EDIT_THIRDPANE;
            }

            int         Col2Width;
            int         Col1Width;
            int         ColToDel = ((Id == g_SymWinTbButtons[0].idCommand) ? TYPE_COLM : OFFSET_COLM);


            Col1Width = ListView_GetColumnWidth(m_hwndChild, VALUE_COLM);
            Col2Width = ListView_GetColumnWidth(m_hwndChild, ColToDel);

            ListView_DeleteColumn(m_hwndChild, ColToDel);
            ListView_SetColumnWidth(m_hwndChild, VALUE_COLM, Col1Width + Col2Width);
            m_NumCols--;
        }
        UiRequestRead();
    }
}


//the basic rutine making the ... thing 
LPTSTR MakeShortString(HDC hDC, LPTSTR lpszLong, LONG nColumnLen, LONG nOffset, PULONG pActualLen )
{
    static const _TCHAR szThreeDots[]=_T("...");
    SIZE strSz;

    int nStringLen=lstrlen(lpszLong);

    if(nStringLen==0 || (GetTextExtentPoint(hDC, lpszLong,nStringLen,
                                            &strSz), strSz.cx + nOffset < nColumnLen)) {
        *pActualLen = nStringLen ? strSz.cx : 0;
        return(lpszLong);
    }
    *pActualLen = strSz.cx;

    static _TCHAR szShort[1024];

    if (nStringLen < sizeof(szShort) - 4) 
    {
        lstrcpy(szShort,lpszLong);
    } else 
    {
        nStringLen = sizeof(szShort) - 4;
        ZeroMemory(szShort, sizeof(szShort));
        strncpy(szShort,lpszLong, nStringLen);
    }
    GetTextExtentPoint(hDC, szThreeDots, sizeof(szThreeDots), &strSz);
    int nAddLen = strSz.cx;

    for(int i=nStringLen-1; i > 0; i--)
    {
        szShort[i]=0;
        GetTextExtentPoint(hDC, szShort, i, &strSz);

        if(strSz.cx + nOffset + nAddLen < nColumnLen)
            break;
    }
    lstrcat(szShort,szThreeDots);
    return(szShort);
}

void DrawRectangle(HDC hDc, POINT pt, ULONG width)
{
    POINT corners[5];

    corners[0] = pt;
    corners[1].x = pt.x; corners[1].y = pt.y + width;
    corners[2].x = pt.x + width; corners[2].y = pt.y + width;
    corners[3].x = pt.x + width; corners[3].y = pt.y;
    corners[4] = pt;

    Polyline(hDc, &corners[0], 5);
}

void DrawHorizLine(HDC hDc, POINT start, ULONG length, ULONG thick)
{
    POINT curr, pt = start;

    while (thick) 
    { 
        MoveToEx(hDc, pt.x, pt.y, &curr);
        LineTo(hDc, pt.x + length, pt.y);

        --thick;
        ++pt.y;
    }
}

void DrawPlus(HDC hDc, POINT topLeft, ULONG width)
{
    if (g_UseTextMode) 
    {
        TextOut(hDc, topLeft.x, topLeft.y - width/2, "+", 1);
        return;
    }
    POINT curr, pt = topLeft;
        DrawRectangle(hDc, pt, width);

    MoveToEx(hDc, pt.x, pt.y + width/2, &curr);
        LineTo(hDc, pt.x + width, pt.y + width/2);

    MoveToEx(hDc, pt.x + width/2, pt.y, &curr);
        LineTo(hDc, pt.x + width/2, pt.y + width);
}


void DrawMinus(HDC hDc, POINT topLeft, ULONG width)
{
    if (g_UseTextMode) 
    {
        TextOut(hDc, topLeft.x, topLeft.y - width/2, "-", 1);
        return;
    }
    
    POINT curr, pt = topLeft;
        DrawRectangle(hDc, pt, width);

    MoveToEx(hDc, pt.x, pt.y + width/2, &curr);
        LineTo(hDc, pt.x + width, pt.y + width/2);
}



void DrawIndentLevel(HDC hDc, ULONG Indent, RECT leftRect)
{
    POINT curr, pt;
    ULONG i;
    INT   width, height;

    pt.x = leftRect.left;
    pt.y = leftRect.top;

    width = leftRect.right - leftRect.left;
    height = leftRect.bottom - leftRect.top;

    for (i=0;i<Indent; i++,pt.x+=width) 
    { 
        if (g_UseTextMode) 
        {
            TextOut(hDc, pt.x, pt.y, "|",1);
            continue;
        }
        MoveToEx(hDc, pt.x + width/2, pt.y, &curr);
        LineTo(hDc, pt.x + width/2, pt.y + height);
        if (i+1==Indent) 
        {
            MoveToEx(hDc, pt.x + width/2, pt.y + height/2, &curr);
            LineTo(hDc, pt.x + width - 1, pt.y + height/2);
        }
    } 
}

#define NAME_LEFT_PAD 6

void
SYMWIN_DATA::DrawTreeItem(HDC hDC, ULONG itemID, RECT ItemRect, PULONG pIndentOffset)
{
    ULONG RectWidth;
    ULONG level;
    TEXTMETRIC tm;

    if (itemID >= m_NumSymsDisplayed) 
    {
        return;
    }

    // derive the Width of +/- from tm
    GetTextMetrics(hDC, &tm);    
    RectWidth = (tm.tmHeight * 2) / 3;

    level = m_pWinSyms[itemID].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK;

    // Rectangle for One indent level
    RECT IndentRc;
    IndentRc = ItemRect;
    IndentRc.left  = ItemRect.left + 2;
    IndentRc.right = IndentRc.left + RectWidth + 1;
    DrawIndentLevel(hDC, level, IndentRc);

    *pIndentOffset = level * (RectWidth+1) + NAME_LEFT_PAD;
    POINT pt;
    pt.x = ItemRect.left + *pIndentOffset - 4;
    pt.y = (ItemRect.top + ItemRect.bottom - RectWidth) / 2;

    if (m_pWinSyms[itemID].Flags & DEBUG_SYMBOL_EXPANDED) 
    {
        DrawMinus(hDC, pt, RectWidth);
    } else if (m_pWinSyms[itemID].SubElements)
    {
        DrawPlus(hDC, pt, RectWidth);
    }

    m_IndentWidth   = RectWidth+1;
    *pIndentOffset += RectWidth+1;
}
    
LRESULT
SYMWIN_DATA::OnOwnerDraw(UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    LPDRAWITEMSTRUCT lpdis; 
    TEXTMETRIC tm; 
    ULONG IndentOffset = 0, ActualWidth;

    
    if (uMsg == WM_MEASUREITEM) 
    {
        MEASUREITEMSTRUCT *lpmis = (MEASUREITEMSTRUCT * ) lParam;
        HDC hDC = GetDC(m_hwndChild);
        GetTextMetrics(hDC, &tm);    
        lpmis->CtlType = ODT_LISTVIEW;
        lpmis->itemHeight = tm.tmHeight;
        lpmis->itemWidth  = m_MaxNameWidth;
        ReleaseDC(m_hwndChild, hDC); 

        return TRUE;
    }
    else
    {
        // Assert (uMsg == WM_DRAWITEM);
    }
    
    lpdis = (LPDRAWITEMSTRUCT) lParam; 
    
    int y; 
    TCHAR Buffer[NAME_BUFFER];
    int Col;
    LPTSTR pszText=&Buffer[0];

 
    // If there are no list box items, skip this message. 
    if (lpdis->itemID == -1) 
    { 
        return FALSE;
    } 
 
    switch (lpdis->itemAction) 
    { 
    case ODA_SELECT: 
    case ODA_DRAWENTIRE:
    {
        HBRUSH hBrush;
        BOOL   DelBrush = FALSE;
        DWORD  dwOldTextColor, dwOldBkColor, TextColor;
 
        if (g_ExecStatus != DEBUG_STATUS_BREAK)
        {
            dwOldTextColor = ListView_GetTextColor(m_hwndChild);
            dwOldBkColor =   ListView_GetBkColor(m_hwndChild);
            
            hBrush = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
            DelBrush = TRUE;

            TextColor = dwOldTextColor =
                SetTextColor(lpdis->hDC, dwOldTextColor);
            dwOldBkColor = SetBkColor(lpdis->hDC, GetSysColor(COLOR_3DFACE));
        }
        else if (lpdis->itemState & ODS_SELECTED)
        {
            hBrush = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
            DelBrush = TRUE;

            dwOldTextColor =
                SetTextColor(lpdis->hDC, 
                             TextColor = GetSysColor(COLOR_HIGHLIGHTTEXT));
            dwOldBkColor =
                SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
        }
        else // item not selected
        {
            hBrush = (HBRUSH) CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            DelBrush = TRUE;
            dwOldTextColor =
                SetTextColor(lpdis->hDC, 
                             TextColor = GetSysColor(COLOR_WINDOWTEXT));
            dwOldBkColor = SetBkColor(lpdis->hDC, GetSysColor(COLOR_WINDOW));
        }

        if (hBrush != NULL)
        {
            FillRect(lpdis->hDC, (LPRECT)&lpdis->rcItem, hBrush);
            if (DelBrush)
            {
                DeleteObject(hBrush);
            }
        }


        // Display the text associated with the item. 

        ListView_GetItemText(m_hwndChild, lpdis->itemID,
                             0, Buffer, sizeof(Buffer));
 
        GetTextMetrics(lpdis->hDC, &tm); 
 
        y = (lpdis->rcItem.bottom + lpdis->rcItem.top - 
             tm.tmHeight) / 2; 
        
        RECT rc = lpdis->rcItem;                
        
        if (m_SplitWindowAtItem && (lpdis->itemID == m_SplitWindowAtItem)) 
        {
            POINT pt = {rc.left, rc.top-1};

            DrawHorizLine(lpdis->hDC, pt, rc.right - rc.left, 2);

            rc.top ++;
        }

        LV_COLUMN lvc;
        lvc.mask = LVCF_FMT | LVCF_WIDTH;
        
        RECT rc2;
        ListView_GetSubItemRect(m_hwndChild, lpdis->itemID,
                                1, LVIR_BOUNDS,
                                &rc2);
        
        rc.right = rc2.left;

        DrawTreeItem(lpdis->hDC, lpdis->itemID, rc, &IndentOffset);

        while (*pszText && *pszText == ' ') { 
            ++pszText;
        }
        pszText = MakeShortString(lpdis->hDC, pszText, rc.right-rc.left,
                                  2 + IndentOffset, &ActualWidth);
        TextOut(lpdis->hDC, rc.left + IndentOffset, y,
                pszText, strlen(pszText));

        if (m_MaxNameWidth < (2 + IndentOffset*3/2 + ActualWidth)) {
            m_MaxNameWidth = 2 + IndentOffset*3/2 + ActualWidth;
        }

        for (Col = 1; 
             //ListView_GetColumn(m_hwndChild, Col, &lvc);
             Col < (int) m_NumCols;
             Col++) 
        { 
            ULONG SaveColor;

            if (!ListView_GetSubItemRect(m_hwndChild,
                                         lpdis->itemID,
                                         Col,
                                         LVIR_BOUNDS,
                                         &rc))
            {
                // invalid coulmn
                break;
            }

            ListView_GetItemText(m_hwndChild, lpdis->itemID,
                                 Col, Buffer, sizeof(Buffer));
            int nRetLen = strlen(Buffer);

            if (nRetLen == 0)
            {
                pszText="";
            }
            else
            {
                pszText = MakeShortString(lpdis->hDC, Buffer,
                                          rc.right - rc.left, 2, &ActualWidth);
            }
                
            if ((Col == 1) &&
                (m_NumSymsDisplayed > lpdis->itemID)) 
            {
                if (m_pWinSyms[lpdis->itemID].Flags & ITEM_VALUE_CHANGED) 
                {
                    SetTextColor(lpdis->hDC, RGB(0xff,0,0));
                }
            }
            
            TextOut(lpdis->hDC, rc.left + 2, y, pszText, strlen(pszText));
            
            if (m_pWinSyms[lpdis->itemID].Flags & ITEM_VALUE_CHANGED) 
            {
                SetTextColor(lpdis->hDC, TextColor);
            }
        }
        
        // restore text and back ground color of list box's selection
        SetTextColor(lpdis->hDC, dwOldTextColor);
        SetBkColor(lpdis->hDC, dwOldBkColor);
        
        return TRUE;
    }
    
    case ODA_FOCUS: 
        // Do not process focus changes. The focus caret 
        // (outline rectangle) indicates the selection. 
        break; 
    } 

    return DefMDIChildProc(m_Win, WM_DRAWITEM, wParam, lParam);
}

void
SYMWIN_DATA::SyncUiWithFlags(ULONG Changed)
{
    if (Changed & (1 << SYMWIN_TBB_TYPECAST))
    {
        SendMessage(m_Toolbar, TB_SETSTATE, SYMWIN_TBB_TYPECAST,
                    TBSTATE_ENABLED |
                    (m_DisplayTypes ? TBSTATE_CHECKED : 0));
    }
    if (Changed & (1 << SYMWIN_TBB_OFFSETS))
    {
        SendMessage(m_Toolbar, TB_SETSTATE, SYMWIN_TBB_OFFSETS,
                    TBSTATE_ENABLED |
                    (m_DisplayOffsets ? TBSTATE_CHECKED : 0));
    }
}

//
// WATCHWIN_DATA methods
//

extern IDebugSymbolGroup * g_pDbgWatchSymbolGroup;
WATCHWIN_DATA::WATCHWIN_DATA()
    : SYMWIN_DATA(&g_pDbgWatchSymbolGroup)
{
    m_wFlags   = DL_EDIT_LEFTPANE;
    m_enumType = WATCH_WINDOW;
}

void 
WATCHWIN_DATA::Validate()
{
    SYMWIN_DATA::Validate();

    Assert(WATCH_WINDOW == m_enumType);
}

HRESULT
WATCHWIN_DATA::ReadState(void)
{
    m_pDbgSymbolGroup = &g_pDbgWatchSymbolGroup;
    return SYMWIN_DATA::ReadState();
}

#define WATCH_WRKSPC_TAG          0x40404040
//
// Workspace
//     0                4        8
//     WATCH_WRKSPC_TAG NUM syms [Null terminated names]
//
ULONG
WATCHWIN_DATA::GetWorkspaceSize(void)
{
    ULONG i;
    ULONG Size = 2*sizeof(ULONG);
    PDEBUG_SYMBOL_PARAMETERS SymParam;

    for (SymParam = GetSymParam(), i=0;
         i < m_NumSymsDisplayed; 
         SymParam++, i++) 
    { 
        if (IsRootSym(SymParam)) 
        {
            CHAR Text[500]={0};

            ListView_GetItemText(m_hwndChild, i, 0, Text, sizeof(Text));

            Size+= strlen(Text) + 1;
        }
    }
    return SYMWIN_DATA::GetWorkspaceSize() + Size;
}

PUCHAR
WATCHWIN_DATA::SetWorkspace(PUCHAR Data)
{
    Data = SYMWIN_DATA::SetWorkspace(Data);
    PULONG pNumSyms, watchWrkspc = (PULONG) Data;

    *watchWrkspc  = WATCH_WRKSPC_TAG;
    pNumSyms = (PULONG) (Data + sizeof(ULONG));
    *pNumSyms = 0;
    Data += 2 * sizeof(ULONG);
    
    ULONG i;
    PDEBUG_SYMBOL_PARAMETERS SymParam;

    for (SymParam = GetSymParam(), i=0;
         i < m_NumSymsDisplayed; 
         SymParam++, i++) 
    { 
        if (IsRootSym(SymParam)) 
        {
            CHAR Text[500]={0}, *pName=&Text[0];

            ListView_GetItemText(m_hwndChild, i, 0, Text, sizeof(Text));
            strcpy((PCHAR) Data, pName);
            Data+= strlen(pName) + 1;
            *pNumSyms = *pNumSyms + 1;
        }
    }

    return Data;
}

PUCHAR
WATCHWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    Data = SYMWIN_DATA::ApplyWorkspace1(Data, End);

    if (*((PULONG) Data) == WATCH_WRKSPC_TAG &&
        End >= Data + 2 * sizeof(ULONG)) 
    {
        Data += sizeof(ULONG);

        ULONG NumSyms = *((PULONG) Data);
        ULONG i=0; 
        Data += sizeof(ULONG);

        PCHAR Name = (PCHAR) Data, pCopyName = &m_ChangedName[0];

        while ((Data < End) && (i<NumSyms)) 
        {

            UIC_SYMBOL_WIN_DATA* WatchItem;
            
            while (*Name == ' ') 
            { // eat out space in begining
                ++Name;
            }
            if (pCopyName + strlen(Name) >= &m_ChangedName[sizeof(m_ChangedName) - 1]) {
                Data = End;
                break;
            }
            strcpy(pCopyName, Name);
            WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
            if (WatchItem != NULL)
            {

                WatchItem->Type = ADD_SYMBOL_WIN;
                WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
                WatchItem->u.Add.Name = pCopyName;
                WatchItem->u.Add.Index = i;
                FinishCommand();
            }
            ++i;
            pCopyName += strlen(pCopyName) + 1;
            while (*Data != 0) {
                ++Data;
            }
            ++Data;
            Name = (PCHAR) Data;
        }
    }
    return Data;
}

//
// LOCALSWIN_DATA methods
//
extern IDebugSymbolGroup * g_pDbgLocalSymbolGroup;
LOCALSWIN_DATA::LOCALSWIN_DATA()
    : SYMWIN_DATA(&g_pDbgLocalSymbolGroup)
{
    m_enumType = LOCALS_WINDOW;
}

void 
LOCALSWIN_DATA::Validate()
{
    DUALLISTWIN_DATA::Validate();

    Assert(LOCALS_WINDOW == m_enumType);
}

LOCALSWIN_DATA::~LOCALSWIN_DATA()
{
}

BOOL
LOCALSWIN_DATA::OnCreate(void)
{

    if (!SYMWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    //
    // Get the locals list from engine
    //

    UIC_SYMBOL_WIN_DATA* WatchItem;

    WatchItem = StartStructCommand(UIC_SYMBOL_WIN);

    if (WatchItem != NULL)
    {
        WatchItem->Type = ADD_SYMBOL_WIN;

        WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
        WatchItem->u.Add.Name = "*";
        WatchItem->u.Add.Index = 0;
        FinishCommand();
    }
    else
    {
        // XXX drewb - Failure?
    }

    return TRUE;

}

HRESULT
LOCALSWIN_DATA::ReadState(void)
{
    HRESULT Hr;
    IDebugSymbolGroup *pLocalSymbolGroup;
    //
    // Get the new locals 
    //
    if ((Hr = g_pDbgSymbols->GetScopeSymbolGroup(DEBUG_SCOPE_GROUP_LOCALS,
                                                g_pDbgLocalSymbolGroup, 
                                                &pLocalSymbolGroup)) == E_NOTIMPL)
    {
        // Older engine version
        Hr = g_pDbgSymbols->GetScopeSymbolGroup(DEBUG_SCOPE_GROUP_ALL,
                                                g_pDbgLocalSymbolGroup, 
                                                &pLocalSymbolGroup);
    }
    if (Hr == S_OK) 
    {
        g_pDbgLocalSymbolGroup = pLocalSymbolGroup;
        m_pDbgSymbolGroup = &g_pDbgLocalSymbolGroup;
    }
    else
    {
        //
        // Keep the old values
        //
        return E_PENDING;
    }

    return SYMWIN_DATA::ReadState();
}

//
// CPUWIN_DATA methods
// 

HMENU CPUWIN_DATA::s_ContextMenu;

CPUWIN_DATA::CPUWIN_DATA()
    : DUALLISTWIN_DATA(1024)
{
    m_wFlags |= DL_CUSTOM_ITEMS;
    m_enumType = CPU_WINDOW;
    m_NamesValid = FALSE;
    m_NewSession = TRUE;
}

void
CPUWIN_DATA::Validate()
{
    DUALLISTWIN_DATA::Validate();

    Assert(CPU_WINDOW == m_enumType);
}

HRESULT
CPUWIN_DATA::ReadState(void)
{
    HRESULT Status;
    PDEBUG_VALUE OldVals;
    ULONG NumOld;
    PDEBUG_VALUE Vals;
    PDEBUG_VALUE Coerced;
    PULONG Types;
    PBOOL Changed;

    NumOld = m_DataUsed / (sizeof(DEBUG_VALUE) + sizeof(BOOL));

    Empty();

    //
    // Retrieve all register values and diff them.
    // Also keep space for a coercion type map and
    // temporary coerced values.
    //

    OldVals = (PDEBUG_VALUE)
        AddData(g_NumRegisters * (3 * sizeof(DEBUG_VALUE) + sizeof(ULONG) +
                                  sizeof(BOOL)));
    if (OldVals == NULL)
    {
        return E_OUTOFMEMORY;
    }
    Changed = (PBOOL)(OldVals + g_NumRegisters);
    Coerced = (PDEBUG_VALUE)(Changed + g_NumRegisters);
    Vals = Coerced + g_NumRegisters;
    Types = (PULONG)(Vals + g_NumRegisters);

    Status = g_pDbgRegisters->GetValues(g_NumRegisters, NULL, 0, Vals);
    if (Status != S_OK)
    {
        return Status;
    }

    ULONG i;

    // Coerce values into known types.
    // If it's an integer value coerce it to 64-bit.
    // If it's a float value coerce to 64-bit also,
    // which loses precision but has CRT support for
    // formatting.
    for (i = 0; i < g_NumRegisters; i++)
    {
        if (Vals[i].Type >= DEBUG_VALUE_INT8 &&
            Vals[i].Type <= DEBUG_VALUE_INT64)
        {
            Types[i] = DEBUG_VALUE_INT64;
        }
        else if (Vals[i].Type >= DEBUG_VALUE_FLOAT32 &&
                 Vals[i].Type <= DEBUG_VALUE_FLOAT128)
        {
            Types[i] = DEBUG_VALUE_FLOAT64;
        }
        else if (Vals[i].Type == DEBUG_VALUE_VECTOR64 ||
                 Vals[i].Type == DEBUG_VALUE_VECTOR128)
        {
            Types[i] = Vals[i].Type;
        }
        else
        {
            // Unknown type.
            return E_INVALIDARG;
        }
    }

    if ((Status = g_pDbgControl->
        CoerceValues(g_NumRegisters, Vals, Types, Coerced)) != S_OK)
    {
        return Status;
    }

    // Diff new values against the old.
    for (i = 0; i < g_NumRegisters; i++)
    {
        if (i < NumOld)
        {
            switch(Types[i])
            {
            case DEBUG_VALUE_INT64:
                Changed[i] = Coerced[i].I64 != OldVals[i].I64;
                break;
            case DEBUG_VALUE_FLOAT64:
                Changed[i] = Coerced[i].F64 != OldVals[i].F64;
                break;
            case DEBUG_VALUE_VECTOR64:
                Changed[i] = memcmp(Coerced[i].RawBytes, OldVals[i].RawBytes,
                                    8);
                break;
            case DEBUG_VALUE_VECTOR128:
                Changed[i] = memcmp(Coerced[i].RawBytes, OldVals[i].RawBytes,
                                    16);
                break;
            }
        }
        else
        {
            Changed[i] = FALSE;
        }
    }

    // Copy new values into permanent storage area.
    memmove(OldVals, Coerced, g_NumRegisters * sizeof(*Vals));
    
    // Trim off temporary information.
    RemoveTail(g_NumRegisters * (2 * sizeof(DEBUG_VALUE) + sizeof(ULONG)));

    return Status;
}

#define CPU_CONTEXT_ID_BASE 0x100

TBBUTTON g_CpuTbButtons[] =
{
    TEXT_TB_BTN(ID_CUSTOMIZE, "Customize...", 0),
    SEP_TB_BTN(),
    TEXT_TB_BTN(ID_SHOW_TOOLBAR, "Toolbar", 0),
};

#define NUM_CPU_MENU_BUTTONS \
    (sizeof(g_CpuTbButtons) / sizeof(g_CpuTbButtons[0]))
#define NUM_CPU_TB_BUTTONS \
    (NUM_CPU_MENU_BUTTONS - 2)

HMENU
CPUWIN_DATA::GetContextMenu(void)
{
    //
    // We only keep one menu around for all CPU windows
    // so apply the menu check state for this particular
    // window.
    // In reality there's only one CPU window anyway,
    // but this is a good example of how to handle
    // multi-instance windows.
    //

    CheckMenuItem(s_ContextMenu, ID_SHOW_TOOLBAR + CPU_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_ShowToolbar ? MF_CHECKED : 0));
    
    return s_ContextMenu;
}

void
CPUWIN_DATA::OnContextMenuSelection(UINT Item)
{
    Item -= CPU_CONTEXT_ID_BASE;
    
    switch(Item)
    {
    case ID_CUSTOMIZE:
        if (!m_NamesValid ||
            (g_RegisterNamesBuffer->UiLockForRead() != S_OK))
        {
            ErrorBox(NULL, 0, ERR_No_Register_Names);
        }
        else
        {
            StartDialog(IDD_DLG_REG_CUSTOMIZE, DlgProc_RegCustomize,
                        (LPARAM)this);
            UnlockStateBuffer(g_RegisterNamesBuffer);
        }
        break;
    case ID_SHOW_TOOLBAR:
        SetShowToolbar(!m_ShowToolbar);
        break;
    }
}

BOOL
CPUWIN_DATA::OnCreate(void)
{
    if (s_ContextMenu == NULL)
    {
        s_ContextMenu = CreateContextMenuFromToolbarButtons
            (NUM_CPU_MENU_BUTTONS, g_CpuTbButtons, CPU_CONTEXT_ID_BASE);
        if (s_ContextMenu == NULL)
        {
            return FALSE;
        }
    }
    
    if (!DUALLISTWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    m_Toolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                    WS_CHILD | WS_VISIBLE |
                    TBSTYLE_WRAPABLE | TBSTYLE_LIST | CCS_TOP,
                    0, 0, m_Size.cx, 0, m_Win, (HMENU)ID_TOOLBAR,
                    g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }
    SendMessage(m_Toolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_Toolbar, TB_ADDBUTTONS, NUM_CPU_TB_BUTTONS,
        (LPARAM)&g_CpuTbButtons);
    SendMessage(m_Toolbar, TB_AUTOSIZE, 0, 0);

    RECT Rect;
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top + GetSystemMetrics(SM_CYEDGE);
    m_ShowToolbar = TRUE;

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    RECT        rc;
    LV_COLUMN   lvc = {0};

    GetClientRect(m_hwndChild, &rc);
    rc.right -= rc.left + GetSystemMetrics(SM_CXVSCROLL);

    //initialize the columns
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM | LVCF_TEXT;
    lvc.fmt = LVCFMT_LEFT;
    lvc.iSubItem = 0;

    // Keep the register name column narrow since most names are short.
    lvc.cx = m_Font->Metrics.tmAveCharWidth * 7;
    if (lvc.cx > rc.right / 2)
    {
        lvc.cx = rc.right / 2;
    }
    lvc.pszText = _T("Reg");
    Dbg( (0 == ListView_InsertColumn(m_hwndChild, 0, &lvc)) );

    // Give the rest of the space to the value.
    lvc.cx = rc.right - lvc.cx;
    lvc.pszText = _T("Value");
    Dbg( (1 == ListView_InsertColumn(m_hwndChild, 1, &lvc)) );

    ListView_SetExtendedListViewStyle(m_hwndChild, 
        LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT
        );

    if (g_RegisterNamesBuffer->UiLockForRead() == S_OK)
    {
        UpdateNames((PSTR)g_RegisterNamesBuffer->GetDataBuffer());
        m_NamesValid = TRUE;
        UnlockStateBuffer(g_RegisterNamesBuffer);
    }
    else
    {
        UpdateNames(NULL);
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);

    return TRUE;
}

LRESULT
CPUWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if ((HWND)lParam == m_Toolbar)
    {
        OnContextMenuSelection(LOWORD(wParam) + CPU_CONTEXT_ID_BASE);
        return 0;
    }

    return DUALLISTWIN_DATA::OnCommand(wParam, lParam);
}

void
CPUWIN_DATA::OnSize(void)
{
    DUALLISTWIN_DATA::OnSize();

    // The register label column stays fixed in size so
    // resize the value column to fit the remaining space.
    ListView_SetColumnWidth(m_hwndChild, 1, LVSCW_AUTOSIZE_USEHEADER);
}

void
CPUWIN_DATA::OnUpdate(UpdateType Type)
{
    if (Type == UPDATE_EXEC)
    {
        // Disallow editing when the debuggee is running.
        if (g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            m_wFlags |= DL_EDIT_SECONDPANE;
            ListView_SetTextBkColor(m_hwndChild, GetSysColor(COLOR_WINDOW));
        }
        else
        {
            m_wFlags &= ~DL_EDIT_SECONDPANE;
            ListView_SetTextBkColor(m_hwndChild, GetSysColor(COLOR_3DFACE));
        }
        InvalidateRect(m_hwndChild, NULL, FALSE);
        return;
    }
    else if (Type == UPDATE_START_SESSION ||
             Type == UPDATE_END_SESSION)
    {
        m_NamesValid = FALSE;
        m_NewSession = Type == UPDATE_START_SESSION;
        return;
    }
    else if (Type != UPDATE_BUFFER)
    {
        return;
    }

    ULONG ul;
    TCHAR sz[256];
    PTSTR Str;
    PDEBUG_VALUE Vals, Val;
    BOOL ChangeFlag;
    PBOOL Changed;
    HRESULT Status;

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    if (!m_NamesValid &&
        g_RegisterNamesBuffer->UiLockForRead() == S_OK)
    {
        UpdateNames((PSTR)g_RegisterNamesBuffer->GetDataBuffer());
        m_NamesValid = TRUE;
        UnlockStateBuffer(g_RegisterNamesBuffer);
    }

    Status = UiLockForRead();
    if (Status == S_OK)
    {
        Vals = (PDEBUG_VALUE)m_Data;
        Changed = (PBOOL)(Vals + g_NumRegisters);
    }

    for (ul = 0; ul < g_NumRegisters; ul++)
    {
        ChangeFlag = FALSE;
        
        if (Status == S_FALSE)
        {
            _tcscpy(sz, _T("Retrieving"));
        }
        else if (FAILED(Status))
        {
            _tcscpy(sz, _T("Error"));
        }
        else
        {
            Val = Vals + MAP_REGISTER(ul);
            // If this is a new session consider everything
            // unchanged since comparisons may be against
            // values from the previous session.
            if (!m_NewSession)
            {
                ChangeFlag = Changed[MAP_REGISTER(ul)];
            }

            // Buffer values are coerced into known types.
            switch(Val->Type)
            {
            case DEBUG_VALUE_INT64:
                CPFormatMemory(sz, sizeof(sz), (LPBYTE)&Val->I64,
                               64, fmtUInt, g_NumberRadix);
                break;
            case DEBUG_VALUE_FLOAT64:
                CPFormatMemory(sz, sizeof(sz), (LPBYTE)&Val->F64,
                               64, fmtFloat, 10);
                break;
            case DEBUG_VALUE_VECTOR64:
                // Assume they want it as v4i16.
                Str = sz;
                CPFormatMemory(Str, sizeof(sz) - (ULONG)(Str - sz),
                               (LPBYTE)&Val->VI16[3], 16, fmtUInt,
                               g_NumberRadix);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, sizeof(sz) - (ULONG)(Str - sz),
                               (LPBYTE)&Val->VI16[2], 16, fmtUInt,
                               g_NumberRadix);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, sizeof(sz) - (ULONG)(Str - sz),
                               (LPBYTE)&Val->VI16[1], 16, fmtUInt,
                               g_NumberRadix);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, sizeof(sz) - (ULONG)(Str - sz),
                               (LPBYTE)&Val->VI16[0], 16, fmtUInt,
                               g_NumberRadix);
                break;
            case DEBUG_VALUE_VECTOR128:
                // Assume they want it as v4f32.
                Str = sz;
                CPFormatMemory(Str, sizeof(sz) - (ULONG)(Str - sz),
                               (LPBYTE)&Val->VF32[3], 32, fmtFloat, 10);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, sizeof(sz) - (ULONG)(Str - sz),
                               (LPBYTE)&Val->VF32[2], 32, fmtFloat, 10);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, sizeof(sz) - (ULONG)(Str - sz),
                               (LPBYTE)&Val->VF32[1], 32, fmtFloat, 10);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, sizeof(sz) - (ULONG)(Str - sz),
                               (LPBYTE)&Val->VF32[0], 32, fmtFloat, 10);
                break;
            default:
                Assert(FALSE);
                break;
            }
        }

        if (ChangeFlag)
        {
            SetItemFlags(ul, GetItemFlags(ul) | ITEM_CHANGED);
        }
        else
        {
            SetItemFlags(ul, GetItemFlags(ul) & ~ITEM_CHANGED);
        }
        ListView_SetItemText(m_hwndChild, ul, 1, sz);
    }

    if (Status == S_OK)
    {
        UnlockStateBuffer(this);
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);
    m_NewSession = FALSE;
}

void
CPUWIN_DATA::ItemChanged(int Item, PCSTR Text)
{
    UIC_SET_REG_DATA* SetRegData;

    SetRegData = StartStructCommand(UIC_SET_REG);
    if (SetRegData != NULL)
    {
        SetRegData->Reg = MAP_REGISTER((ULONG)Item);

        // If the text contains a decimal point set it as
        // a float value, otherwise use an integer value.
        // XXX drewb - This should probably be more sophisticated,
        // perhaps by remembering the types of registers.
        if (strchr(Text, '.') != NULL)
        {
            SetRegData->Val.Type = DEBUG_VALUE_FLOAT64;
            if (sscanf(Text, "%lf", &SetRegData->Val.F64) != 1)
            {
                SetRegData->Val.F64 = 0.0;
            }
        }
        else
        {
            SetRegData->Val.Type = DEBUG_VALUE_INT64;
            switch(g_NumberRadix)
            {
            case 10:
                if (sscanf(Text, "%I64d", &SetRegData->Val.I64) != 1)
                {
                    SetRegData->Val.I64 = 0;
                }
                break;
            default:
                if (sscanf(Text, "%I64x", &SetRegData->Val.I64) != 1)
                {
                    SetRegData->Val.I64 = 0;
                }
                break;
            }
            // XXX drewb - What about IA64 NAT bits?
            SetRegData->Val.Nat = FALSE;
        }

        FinishCommand();
    }
}

LRESULT
CPUWIN_DATA::OnCustomItem(ULONG SubItem, LPNMLVCUSTOMDRAW Custom)
{
    if (SubItem == 1)
    {
        // Check changed flag stored in lParam.
        if (Custom->nmcd.lItemlParam & ITEM_CHANGED)
        {
            Custom->clrText = RGB(0xff, 0, 0);
        }
    }
    return CDRF_NOTIFYSUBITEMDRAW;
}

void
CPUWIN_DATA::UpdateNames(PSTR Buf)
{
    ULONG ul;
    PSTR Name;
    LVITEM lvitem = {0};

    if (Buf != NULL)
    {
        AssertStateBufferLocked(g_RegisterNamesBuffer);
    }

    ListView_DeleteAllItems(m_hwndChild);

    lvitem.mask = LVIF_TEXT;

    for (ul = 0; ul < g_NumRegisters; ul++)
    {
        if (Buf == NULL)
        {
            Name = _T("Unknown");
        }
        else
        {
            ULONG MapIndex = MAP_REGISTER(ul);

            Name = Buf;
            while (MapIndex-- > 0)
            {
                Name += strlen(Name) + 1;
            }
        }

        lvitem.pszText = Name;
        lvitem.iItem = ul;
        ListView_InsertItem(m_hwndChild, &lvitem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\dualwin.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    dualwin.h

Abstract:

    Header for new window architecture functions.    

Environment:

    Win32, User Mode

--*/

//
// Allow editing of right & left panes
//
#define DL_EDIT_LEFTPANE    0x0001
#define DL_EDIT_SECONDPANE  0x0002
#define DL_EDIT_THIRDPANE   0x0004
#define DL_CUSTOM_ITEMS     0x0008

// Item flags for Get/SetItemFlags.
#define ITEM_CHANGED 0x00000001

#define ITEM_VALUE_CHANGED   0x10000000

class DUALLISTWIN_DATA : public SINGLE_CHILDWIN_DATA
{
public:
    DWORD   m_wFlags;
    // Handle to the list view control.
    HWND    m_hwndEditControl;
    int     m_nItem_LastSelected;
    int     m_nSubItem_LastSelected;
    // Item and subitem currently being edited
    int     m_nItem_CurrentlyEditing;
    int     m_nSubItem_CurrentlyEditing;

    DUALLISTWIN_DATA(ULONG ChangeBy);

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

    virtual BOOL ClearList(ULONG ClearFrom);
    virtual void EditText();
    virtual void InvalidateItem(int);

    virtual void ItemChanged(int Item, PCSTR Text);
    
    virtual LRESULT OnCustomDraw(LPNMLVCUSTOMDRAW Custom);
    virtual LRESULT OnCustomItem(ULONG SubItem, LPNMLVCUSTOMDRAW Custom);
    virtual void OnClick(LPNMLISTVIEW);

    virtual BOOL CanCopy();
    virtual BOOL CanCut();
    virtual BOOL CanPaste();
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();

    ULONG GetItemFlags(ULONG Item);
    void SetItemFlags(ULONG Item, ULONG Flags);
    BOOL SetItemFromEdit(ULONG Item, ULONG SubItem);
};
typedef DUALLISTWIN_DATA *PDUALLISTWIN_DATA;



class CPUWIN_DATA : public DUALLISTWIN_DATA
{
public:
    BOOL m_NamesValid;
    BOOL m_NewSession;
    
    static HMENU s_ContextMenu;

    CPUWIN_DATA();

    virtual void Validate();

    virtual HRESULT ReadState(void);
    
    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSize(void);
    virtual void OnUpdate(UpdateType Type);

    virtual void ItemChanged(int Item, PCSTR Text);
    
    virtual LRESULT OnCustomItem(ULONG SubItem, LPNMLVCUSTOMDRAW Custom);
    
    void UpdateNames(PSTR Buf);
};
typedef CPUWIN_DATA * PCPUWIN_DATA;



class SYMWIN_DATA : public DUALLISTWIN_DATA
{
public:
    SYMWIN_DATA(IDebugSymbolGroup **pDbgSymbolGroup);
    ~SYMWIN_DATA();

    static HMENU s_ContextMenu;

    virtual void Validate();
    
    virtual HRESULT ReadState(void);

    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual BOOL OnCreate(void);
    virtual void OnSize(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnNotify(WPARAM  wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

    virtual void ItemChanged(int Item, PCSTR Text);
    virtual void OnClick(LPNMLISTVIEW);
    virtual LRESULT OnOwnerDraw(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    void UpdateNames();
    BOOL AddListItem(ULONG iItem, PSTR ItemText, 
                     ULONG Level, BOOL HasChildren, BOOL Expanded);
    HRESULT      SetMaxSyms(ULONG nSyms);
    ULONG        GetMaxSyms() { return m_nWinSyms;}
    PDEBUG_SYMBOL_PARAMETERS GetSymParam() { return m_pWinSyms;}
    void SetDisplayTypes(LONG Id, BOOL Set);
    void DrawTreeItem(HDC hDC, ULONG itemID, RECT ItemRect, PULONG pIndentOffset);
    void ExpandSymbol(ULONG Index, BOOL Expand);

    void SyncUiWithFlags(ULONG Changed);
    
private:
    ULONG                    m_LastIndex;
    PDEBUG_SYMBOL_PARAMETERS m_pWinSyms;
    ULONG                    m_nWinSyms;
    BOOL                     m_DisplayTypes;
    BOOL                     m_DisplayOffsets;
    ULONG                    m_SplitWindowAtItem;
    LONG                     m_IndentWidth;
    ULONG                    m_NumCols;
    UCHAR                    m_ListItemLines[2048];

protected:    
    ULONG                    m_MaxNameWidth;
    CHAR                     m_ChangedName[1024];
    ULONG                    m_RefreshItem;
    ULONG                    m_UpdateItem;
    ULONG                    m_NumSymsDisplayed;
    IDebugSymbolGroup      **m_pDbgSymbolGroup;
};

class WATCHWIN_DATA : public SYMWIN_DATA
{
public:
    WATCHWIN_DATA();

    virtual void Validate();
    HRESULT ReadState(void);
    
    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

private:
};
typedef WATCHWIN_DATA *PWATCHWIN_DATA;



class LOCALSWIN_DATA : public SYMWIN_DATA
{
public:
    LOCALSWIN_DATA();
    ~LOCALSWIN_DATA();

    virtual BOOL OnCreate(void);
    virtual void Validate();
    HRESULT ReadState(void);
};
typedef LOCALSWIN_DATA *PLOCALSWIN_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\engine.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    newwin.cpp

Abstract:

    This module contains the code for the new window architecture.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <dbghelp.h>

#if 0
#define DBG_CALLBACK
#endif

// Windows that change behavior depending on the execution status.
#define UPDATE_EXEC_WINDOWS     \
    ((1 << CPU_WINDOW) |        \
     (1 << DISASM_WINDOW) |     \
     (1 << CMD_WINDOW) |        \
     (1 << LOCALS_WINDOW) |     \
     (1 << WATCH_WINDOW) |      \
     (1 << MEM_WINDOW))

// Windows that use symbol information.
#define UPDATE_SYM_WINDOWS      \
    ((1 << DOC_WINDOW) |        \
     (1 << WATCH_WINDOW) |      \
     (1 << LOCALS_WINDOW) |     \
     (1 << DISASM_WINDOW) |     \
     (1 << QUICKW_WINDOW) |     \
     (1 << CALLS_WINDOW) |      \
     (1 << EVENT_BIT) |         \
     (1 << BP_BIT))

// Symbol options that cause visible changes and
// therefore require a refresh.  Note that this
// doesn't include options that would cause a visible
// change only after symbol reload as things will
// get refreshed when the load notifications come in.
#define REFRESH_SYMOPT          \
    (~(SYMOPT_CASE_INSENSITIVE | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES | \
       SYMOPT_LOAD_ANYTHING | SYMOPT_IGNORE_CVREC | \
       SYMOPT_NO_UNQUALIFIED_LOADS | SYMOPT_EXACT_SYMBOLS))

//
// Session initialization parameters.
//

// Turn on verbose output or not.
BOOL g_Verbose;
// Dump file to open or NULL.
PTSTR g_DumpFile;
PTSTR g_DumpPageFile;
// Process server to use.
PSTR g_ProcessServer;
// Full command line with exe name.
PSTR g_DebugCommandLine;
// Process creation flags.
ULONG g_DebugCreateFlags = DEBUG_ONLY_THIS_PROCESS;
// Process ID to attach to or zero.
ULONG g_PidToDebug;
// Process name to attach to or NULL.
PSTR g_ProcNameToDebug;
BOOL g_DetachOnExit;
ULONG g_AttachProcessFlags = DEBUG_ATTACH_DEFAULT;
// Kernel connection options.
ULONG g_AttachKernelFlags = DEBUG_ATTACH_KERNEL_CONNECTION;
PSTR g_KernelConnectOptions;

// Remoting options.
BOOL g_RemoteClient;
ULONG g_HistoryLines = 10000;

//
// Debug engine interfaces for the engine thread.
//
IDebugClient        *g_pDbgClient;
IDebugClient2       *g_pDbgClient2;
IDebugControl       *g_pDbgControl;
IDebugSymbols       *g_pDbgSymbols;
IDebugSymbolGroup   *g_pDbgWatchSymbolGroup;
IDebugSymbolGroup   *g_pDbgLocalSymbolGroup = NULL;
IDebugRegisters     *g_pDbgRegisters;
IDebugDataSpaces    *g_pDbgData;
IDebugSystemObjects *g_pDbgSystem;

//
// Debug engine interfaces for the UI thread.
//
IDebugClient        *g_pUiClient;
IDebugControl       *g_pUiControl;
IDebugSymbols       *g_pUiSymbols;
IDebugSymbols2      *g_pUiSymbols2;
IDebugSystemObjects *g_pUiSystem;

//
// Debug engine interfaces for private output capture.
//
IDebugClient        *g_pOutCapClient;
IDebugControl       *g_pOutCapControl;
IDebugSymbols       *g_pOutCapSymbols;
//
// Debug engine interfaces for local source file lookup.
//
IDebugClient        *g_pLocClient;
IDebugControl       *g_pLocControl;
IDebugSymbols       *g_pLocSymbols;
IDebugClient        *g_pUiLocClient;
IDebugControl       *g_pUiLocControl;
IDebugSymbols       *g_pUiLocSymbols;

ULONG g_ActualProcType = IMAGE_FILE_MACHINE_UNKNOWN;
char g_ActualProcAbbrevName[32];
ULONG g_NumRegisters;
ULONG g_CommandSequence;
ULONG g_TargetClass = DEBUG_CLASS_UNINITIALIZED;
ULONG g_TargetClassQual;
BOOL g_Ptr64;
ULONG g_ExecStatus = DEBUG_STATUS_NO_DEBUGGEE;
ULONG g_EngOptModified;
ULONG g_EngineThreadId;
HANDLE g_EngineThread;
PSTR g_InitialCommand;
char g_PromptText[32];
BOOL g_WaitingForEvent;
ULONG g_NumberRadix;
BOOL g_IgnoreCodeLevelChange;
BOOL g_CodeLevelLocked;
BOOL g_IgnoreFilterChange;
ULONG g_LastProcessExitCode;
ULONG g_SymOptions;
ULONG g_TypeOptions;

BOOL g_InputStarted;
BOOL g_Invisible;

enum
{
    ENDING_NONE,
    ENDING_RESTART,
    ENDING_STOP,
    ENDING_EXIT
};

ULONG g_EndingSession = ENDING_NONE;

void SetLocalScope(PDEBUG_STACK_FRAME);

BOOL g_SessionActive;
void SessionActive(void);
void SessionInactive(void);

StateBuffer g_UiCommandBuffer(MAX_COMMAND_LEN);
StateBuffer g_UiOutputBuffer(2048);

//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DefOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// Command window output callbacks.
//
//----------------------------------------------------------------------------

class OutputCallbacks : public DefOutputCallbacks
{
public:
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};
    
STDMETHODIMP
OutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    LockUiBuffer(&g_UiOutputBuffer);

    HRESULT Status;
    ULONG Len;
    PSTR DataStart;

    Len = sizeof(Mask) + strlen(Text) + 1;
    if ((DataStart = (PSTR)g_UiOutputBuffer.AddData(Len)) != NULL)
    {
        *(ULONG UNALIGNED *)DataStart = Mask;
        DataStart += sizeof(Mask);
        strcpy(DataStart, Text);
        
        UpdateUi();
        Status = S_OK;
    }
    else
    {
        Status = E_OUTOFMEMORY;
    }
    
    UnlockUiBuffer(&g_UiOutputBuffer);
    return Status;
}

OutputCallbacks g_OutputCb;

//----------------------------------------------------------------------------
//
// Input callbacks.
//
//----------------------------------------------------------------------------

class InputCallbacks :
    public IDebugInputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugInputCallbacks.
    STDMETHOD(StartInput)(
        THIS_
        IN ULONG BufferSize
        );
    STDMETHOD(EndInput)(
        THIS
        );
};

STDMETHODIMP
InputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugInputCallbacks))
    {
        *Interface = (IDebugInputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
InputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
InputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
InputCallbacks::StartInput(
    THIS_
    IN ULONG BufferSize
    )
{
    HRESULT Status;
    ULONG Len;

    //
    // Pull the first command input command out
    // of the UI's command buffer and use it as input.
    //

    LockUiBuffer(&g_UiCommandBuffer);

    UiCommandData* CmdData =
        (UiCommandData*)g_UiCommandBuffer.GetDataBuffer();
    UiCommandData* CmdEnd = (UiCommandData*)
        ((PBYTE)g_UiCommandBuffer.GetDataBuffer() +
         g_UiCommandBuffer.GetDataLen());
    
    while (CmdData < CmdEnd)
    {
        if (CmdData->Cmd == UIC_CMD_INPUT)
        {
            break;
        }

        CmdData = (UiCommandData*)((PBYTE)CmdData + CmdData->Len);
    }
        
    if (CmdData < CmdEnd)
    {
        g_OutputCb.Output(DEBUG_OUTPUT_NORMAL, (PSTR)(CmdData + 1));
        g_OutputCb.Output(DEBUG_OUTPUT_NORMAL, "\n");

        g_pDbgControl->ReturnInput((PSTR)(CmdData + 1));
        
        g_UiCommandBuffer.
            RemoveMiddle((ULONG)((PBYTE)CmdData -
                                 (PBYTE)g_UiCommandBuffer.GetDataBuffer()),
                         CmdData->Len);
    }
    else
    {
        g_InputStarted = TRUE;
        // Didn't find any input waiting.
        // Let the command window know that input is needed.
        UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_INPUT_REQUIRED);
    }

    UnlockUiBuffer(&g_UiCommandBuffer);
    return S_OK;
}

STDMETHODIMP
InputCallbacks::EndInput(
    THIS
    )
{
    g_InputStarted = FALSE;
    // Reset the command window's state to what it was.
    UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_EXEC);
    return S_OK;
}

InputCallbacks g_InputCb;

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

// This is safe to do from the engine thread as
// it just sets a flag.
#define DIRTY_WORKSPACE(Flags)                                                \
if (!g_RemoteClient &&                                                        \
    g_EndingSession == ENDING_NONE && !g_Invisible && g_Workspace != NULL)    \
{                                                                             \
    g_Workspace->AddDirty(Flags);                                             \
}

STDMETHODIMP_(ULONG)
EventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
EventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
EventCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask =
        DEBUG_EVENT_CREATE_THREAD |
        DEBUG_EVENT_EXIT_THREAD |
        DEBUG_EVENT_CREATE_PROCESS |
        DEBUG_EVENT_EXIT_PROCESS |
        DEBUG_EVENT_SESSION_STATUS |
        DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
        DEBUG_EVENT_CHANGE_ENGINE_STATE |
        DEBUG_EVENT_CHANGE_SYMBOL_STATE;
    return S_OK;
}

STDMETHODIMP
EventCallbacks::CreateThread(
    THIS_
    IN ULONG64 Handle,
    IN ULONG64 DataOffset,
    IN ULONG64 StartOffset
    )
{
    ULONG InvFlags =
        (1 << PROCESS_THREAD_WINDOW);
    
#ifdef DBG_CALLBACK
    DebugPrint(" CT\n");
#endif
    
    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE && InvFlags)
    {
        InvalidateStateBuffers(InvFlags);
        UpdateEngine();
    }
    
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ExitThread(
    THIS_
    IN ULONG ExitCode
    )
{
    ULONG InvFlags =
        (1 << PROCESS_THREAD_WINDOW);
    
#ifdef DBG_CALLBACK
    DebugPrint(" ET\n");
#endif
    
    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE && InvFlags)
    {
        InvalidateStateBuffers(InvFlags);
        UpdateEngine();
    }
    
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::CreateProcess(
    THIS_
    IN ULONG64 ImageFileHandle,
    IN ULONG64 Handle,
    IN ULONG64 BaseOffset,
    IN ULONG ModuleSize,
    IN PCSTR ModuleName,
    IN PCSTR ImageName,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp,
    IN ULONG64 InitialThreadHandle,
    IN ULONG64 ThreadDataOffset,
    IN ULONG64 StartOffset
    )
{
    ULONG InvFlags =
        (1 << PROCESS_THREAD_WINDOW);
    
#ifdef DBG_CALLBACK
    DebugPrint("CPR\n");
#endif
    
    // Use this opportunity to get initial insertion
    // of any workspace breakpoints and process other workspace
    // commands which may be queued.
    ProcessEngineCommands(TRUE);

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE && InvFlags)
    {
        InvalidateStateBuffers(InvFlags);
        UpdateEngine();
    }
    
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ExitProcess(
    THIS_
    IN ULONG ExitCode
    )
{
    ULONG InvFlags =
        (1 << PROCESS_THREAD_WINDOW);
    
#ifdef DBG_CALLBACK
    DebugPrint("EPR\n");
#endif
    
    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE && InvFlags)
    {
        InvalidateStateBuffers(InvFlags);
        UpdateEngine();
    }
    
    g_LastProcessExitCode = ExitCode;
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::SessionStatus(
    THIS_
    IN ULONG Status
    )
{
#ifdef DBG_CALLBACK
    DebugPrint(" SS %X\n", Status);
#endif
    
    switch(Status)
    {
    case DEBUG_SESSION_ACTIVE:
        SessionActive();
        break;
    case DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE:
    case DEBUG_SESSION_END_SESSION_ACTIVE_DETACH:
    case DEBUG_SESSION_END:
    case DEBUG_SESSION_REBOOT:
    case DEBUG_SESSION_HIBERNATE:
        SessionInactive();
        break;
    }
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ChangeDebuggeeState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    ULONG InvFlags =
        (1 << WATCH_WINDOW) |
        (1 << LOCALS_WINDOW) |
        (1 << DISASM_WINDOW) |
        (1 << QUICKW_WINDOW) |
        (1 << CALLS_WINDOW);
    
    // Invalidate everything that changed.
    if (Flags & DEBUG_CDS_REGISTERS)
    {
        InvFlags |= (1 << EVENT_BIT) | (1 << CPU_WINDOW);
    }
    if (Flags & DEBUG_CDS_DATA)
    {
        InvFlags |=
            (1 << MEM_WINDOW);
    }
    
#ifdef DBG_CALLBACK
    DebugPrint("CDS %X, arg %I64X, inv %X\n", Flags, Argument, InvFlags);
#endif

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE)
    {
        InvalidateStateBuffers(InvFlags);
    }
    if (InvFlags != 0)
    {
        UpdateEngine();
    }
    return S_OK;
}

STDMETHODIMP
EventCallbacks::ChangeEngineState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    ULONG InvFlags = 0;

    // If the current thread changed we need to get
    // new context information for the thread.
    if (Flags & DEBUG_CES_CURRENT_THREAD)
    {
        InvFlags |=
            (1 << LOCALS_WINDOW) |
            (1 << CPU_WINDOW) |
            (1 << DISASM_WINDOW) |
            (1 << CALLS_WINDOW) |
            (1 << EVENT_BIT) |
            (1 << BP_BIT);
    }

    // If the effective processor changed we need to update
    // anything related to processor information.
    if (Flags & DEBUG_CES_EFFECTIVE_PROCESSOR)
    {
        InvFlags |=
            (1 << CPU_WINDOW) |
            (1 << DISASM_WINDOW) |
            (1 << CALLS_WINDOW) |
            (1 << BP_BIT);
    }

    // If breakpoints changed we need to update the breakpoint cache.
    if (Flags & DEBUG_CES_BREAKPOINTS)
    {
        InvFlags |= (1 << BP_BIT);
        
        // If it's a bulk edit it's coming from a thread or process exit
        // or from a session shutdown rather than a user operation.
        // We only want to remember user-driven changes in the workspace.
        if (Argument != DEBUG_ANY_ID)
        {
            InvFlags |= (1 << BP_CMDS_BIT);
            DIRTY_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
        }
    }

    // If the code level changed we need to update the toolbar.
    if (Flags & DEBUG_CES_CODE_LEVEL)
    {
        InvFlags |= (1 << BP_BIT);

        // If this isn't a notification due to a change
        // from windbg itself the user must have changed
        // things via a command.  If the user does
        // change things from the command window lock
        // the code level so that it isn't overridden
        // automatically.
        if (!g_Invisible && !g_IgnoreCodeLevelChange)
        {
            g_CodeLevelLocked = TRUE;
            PostMessage(g_hwndFrame, WU_UPDATE,
                        UPDATE_BUFFER, (ULONG)Argument);
        }
        else
        {
            // Setting the source mode from the GUI enables
            // the source setting to float along with whether
            // the GUI can display source code or not.
            g_CodeLevelLocked = FALSE;
        }
    }

    if (Flags & DEBUG_CES_EXECUTION_STATUS)
    {
        // If this notification came from a wait completing
        // we want to wake up things thread so that new
        // commands can be processed.  If it came from inside
        // a wait we don't want to wake up as the engine
        // may go back to running at any time.
        if ((Argument & DEBUG_STATUS_INSIDE_WAIT) == 0 &&
            (ULONG)Argument != g_ExecStatus)
        {
            g_ExecStatus = (ULONG)Argument;
                
            UpdateBufferWindows(UPDATE_EXEC_WINDOWS, UPDATE_EXEC);

            if (InvFlags == 0)
            {
                // Force the loop waiting in DispatchCallbacks to go around.
                UpdateEngine();
            }
        }
    }
        
    // If the log file changed we need to update the workspace.
    if (Flags & DEBUG_CES_LOG_FILE)
    {
        DIRTY_WORKSPACE(WSPF_DIRTY_LOG_FILE);
    }

    // If event filters changed we need to update the filter cache.
    if ((Flags & DEBUG_CES_EVENT_FILTERS) &&
        !g_IgnoreFilterChange)
    {
        InvFlags |= (1 << FILTER_BIT);
        DIRTY_WORKSPACE(WSPF_DIRTY_FILTERS);
    }

    if (Flags & DEBUG_CES_RADIX)
    {
        g_NumberRadix = (ULONG)Argument;
        InvFlags |=
            (1 << WATCH_WINDOW) |
            (1 << LOCALS_WINDOW) |
            (1 << CPU_WINDOW);
    }
    
#ifdef DBG_CALLBACK
    DebugPrint("CES %X, arg %I64X, inv %X\n", Flags, Argument, InvFlags);
#endif
    
    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE)
    {
        InvalidateStateBuffers(InvFlags);
    }
    if (InvFlags != 0)
    {
        UpdateEngine();
    }
    return S_OK;
}

STDMETHODIMP
EventCallbacks::ChangeSymbolState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    ULONG InvFlags = 0;

    // If module information changed we need to update
    // everything that might display or depend on symbols.
    if (Flags & (DEBUG_CSS_LOADS |
                 DEBUG_CSS_UNLOADS))
    {
        InvFlags |= UPDATE_SYM_WINDOWS | (1 << MODULE_BIT);
    }

    // If the scope changed we need to update scope-related windows.
    if (Flags & DEBUG_CSS_SCOPE)
    {
        InvFlags |=
            (1 << WATCH_WINDOW) |
            (1 << LOCALS_WINDOW) |
            (1 << CALLS_WINDOW);
    }

    // If paths changed we need to update
    // the event state in case we can suddenly load source.
    if (Flags & DEBUG_CSS_PATHS)
    {
        InvFlags |= (1 << EVENT_BIT);
        DIRTY_WORKSPACE(WSPF_DIRTY_PATHS);
    }

    // If certain options changed we need to update
    // everything that might display or depend on symbols.
    if (Flags & DEBUG_CSS_SYMBOL_OPTIONS)
    {
        if ((g_SymOptions ^ (ULONG)Argument) & REFRESH_SYMOPT)
        {
            InvFlags |= UPDATE_SYM_WINDOWS;
        }

        g_SymOptions = (ULONG)Argument;
    }

    // If certain options changed we need to update
    // everything that might display or depend on symbols.
    if (Flags & DEBUG_CSS_TYPE_OPTIONS)
    {
        InvFlags |=
            (1 << WATCH_WINDOW) |
            (1 << LOCALS_WINDOW) |
            (1 << CALLS_WINDOW);

        if (g_pUiSymbols2 != NULL) 
        {
            g_pUiSymbols2->GetTypeOptions( &g_TypeOptions );
            
            if (g_Workspace != NULL)
            {
                g_Workspace->SetUlong(WSP_GLOBAL_TYPE_OPTIONS,
                                      g_TypeOptions);
            }
        }

    }

#ifdef DBG_CALLBACK
    DebugPrint("CSS %X, arg %I64X, inv %X\n", Flags, Argument, InvFlags);
#endif

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE)
    {
        InvalidateStateBuffers(InvFlags);
    }
    if (InvFlags != 0)
    {
        UpdateEngine();
    }
    return S_OK;
}

EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Inter-thread communication.
//
//----------------------------------------------------------------------------

#define COMMAND_OVERHEAD (sizeof(ULONG64) + sizeof(UiCommandData))

PVOID
StartCommand(UiCommand Cmd, ULONG Len)
{
    UiCommandData* Data;
    
    // Round length up to a multiple of ULONG64s for
    // alignment.
    Len = ((Len + sizeof(ULONG64) - 1) & ~(sizeof(ULONG64) - 1)) +
        sizeof(UiCommandData);

    if (Len > MAX_COMMAND_LEN)
    {
        return NULL;
    }
    
    LockUiBuffer(&g_UiCommandBuffer);

    Data = (UiCommandData *)g_UiCommandBuffer.AddData(Len);
    if (Data == NULL)
    {
        return Data;
    }

    Data->Cmd = Cmd;
    Data->Len = Len;

    return Data + 1;
}

void
FinishCommand(void)
{
    UnlockUiBuffer(&g_UiCommandBuffer);

    // Wake up the engine to process the command.
    UpdateEngine();
}

BOOL
AddStringCommand(UiCommand Cmd, PCSTR Str)
{
    ULONG StrLen = strlen(Str) + 1;
    PSTR Data;

    // If we're adding command input we may need
    // to send it directly to the engine in response
    // to an input request.
    if (Cmd == UIC_CMD_INPUT)
    {
        LockUiBuffer(&g_UiCommandBuffer);

        if (g_InputStarted)
        {
            g_OutputCb.Output(DEBUG_OUTPUT_NORMAL, Str);
            g_OutputCb.Output(DEBUG_OUTPUT_NORMAL, "\n");
            g_pUiControl->ReturnInput(Str);
            g_InputStarted = FALSE;
            UnlockUiBuffer(&g_UiCommandBuffer);
            return TRUE;
        }
    }

    Data = (PSTR)StartCommand(Cmd, StrLen);
    
    if (Cmd == UIC_CMD_INPUT)
    {
        UnlockUiBuffer(&g_UiCommandBuffer);
    }
    
    if (Data == NULL)
    {
        return FALSE;
    }

    memcpy(Data, Str, StrLen);

    FinishCommand();
    return TRUE;
}

BOOL
AddStringMultiCommand(UiCommand Cmd, PSTR Str)
{
    //
    // Given a string with multiple commands separated
    // by newlines, break the string into multiple
    // commands, one per line.  This allows arbitrarily
    // large command strings without running into
    // the MAX_COMMAND_LEN limit as long as each individual
    // line fits within that limit.
    //
    while (*Str)
    {
        PSTR Scan, LastNl;
        ULONG Len;
        BOOL Status;
        
        Scan = Str + 1;
        Len = 1;
        LastNl = NULL;
        while (*Scan && Len < (MAX_COMMAND_LEN - COMMAND_OVERHEAD))
        {
            if (*Scan == '\n')
            {
                LastNl = Scan;
            }

            Scan++;
            Len++;
        }

        // If the rest of the command string doesn't fit
        // within the limit it needs to be split.
        // If there's no newline to break it at
        // the command is too large to be processed.
        if (*Scan && !LastNl)
        {
            return FALSE;
        }

        // Split if necessary.
        if (*Scan)
        {
            *LastNl = 0;
        }

        // Add the head (which may be the whole remainder).
        Status = AddStringCommand(Cmd, Str);

        if (*Scan)
        {
            *LastNl = '\n';
            
            if (!Status)
            {
                return FALSE;
            }
            
            Str = LastNl + 1;
        }
        else
        {
            return Status;
        }
    }

    return TRUE;
}

BOOL __cdecl
PrintStringCommand(UiCommand Cmd, PCSTR Format, ...)
{
    char Buf[MAX_COMMAND_LEN - COMMAND_OVERHEAD];
    va_list Args;

    va_start(Args, Format);
    _vsnprintf(Buf, sizeof(Buf), Format, Args);
    va_end(Args);
    return AddStringCommand(Cmd, Buf);
}

void
WriteData(UIC_WRITE_DATA_DATA* WriteData)
{
    ULONG Written;
    
    switch(WriteData->Type)
    {
    default:
        Assert(!"Unhandled condition");
        break;

    case PHYSICAL_MEM_TYPE:
        g_pDbgData->WritePhysical(WriteData->Offset,
                                  WriteData->Data, 
                                  WriteData->Length, 
                                  &Written
                                  );
        break;

    case VIRTUAL_MEM_TYPE:
        g_pDbgData->WriteVirtual(WriteData->Offset, 
                                 WriteData->Data, 
                                 WriteData->Length, 
                                 &Written
                                 );
        break;

    case CONTROL_MEM_TYPE:
        g_pDbgData->WriteControl(WriteData->Any.control.Processor, 
                                 WriteData->Offset, 
                                 WriteData->Data, 
                                 WriteData->Length, 
                                 &Written
                                 );
        break;

    case IO_MEM_TYPE:
        g_pDbgData->WriteIo(WriteData->Any.io.interface_type,
                            WriteData->Any.io.BusNumber,
                            WriteData->Any.io.AddressSpace,
                            WriteData->Offset,
                            WriteData->Data, 
                            WriteData->Length, 
                            &Written
                            );
        break;
            
    case MSR_MEM_TYPE:
        Assert(WriteData->Length == sizeof(ULONG64));
        g_pDbgData->WriteMsr((ULONG)WriteData->Offset, 
                             *(PULONG64)WriteData->Data
                             );
        break;

    case BUS_MEM_TYPE:
        g_pDbgData->WriteBusData(WriteData->Any.bus.bus_type,
                                 WriteData->Any.bus.BusNumber,
                                 WriteData->Any.bus.SlotNumber,
                                 (ULONG)WriteData->Offset,
                                 WriteData->Data, 
                                 WriteData->Length, 
                                 &Written
                                 );
        break;
    }
}

void 
ProcessWatchCommand(
    UIC_SYMBOL_WIN_DATA *SymWinData
    )
{
    PDEBUG_SYMBOL_GROUP pSymbolGroup;
    if (!SymWinData->pSymbolGroup ||
        !(pSymbolGroup = *SymWinData->pSymbolGroup))
    {
        return;
    }
    switch (SymWinData->Type)
    { 
    case ADD_SYMBOL_WIN:
        pSymbolGroup->AddSymbol(SymWinData->u.Add.Name,
                                &SymWinData->u.Add.Index);
        break;

    case DEL_SYMBOL_WIN_INDEX: 
        pSymbolGroup->RemoveSymbolByIndex(SymWinData->u.DelIndex);
        break;

    case DEL_SYMBOL_WIN_NAME: 
        pSymbolGroup->RemoveSymbolByName(SymWinData->u.DelName);
        break;

    case QUERY_NUM_SYMBOL_WIN: 
        pSymbolGroup->GetNumberSymbols(SymWinData->u.NumWatch);
        break;

    case GET_NAME: 
        pSymbolGroup->GetSymbolName(SymWinData->u.GetName.Index,
                                    SymWinData->u.GetName.Buffer,
                                    SymWinData->u.GetName.BufferSize,
                                    SymWinData->u.GetName.NameSize);
        break;

    case GET_PARAMS: 
        pSymbolGroup->
            GetSymbolParameters(SymWinData->u.GetParams.Start,
                                SymWinData->u.GetParams.Count,
                                SymWinData->u.GetParams.SymbolParams);
        break;

    case EXPAND_SYMBOL: 
        pSymbolGroup->ExpandSymbol(SymWinData->u.ExpandSymbol.Index,
                                   SymWinData->u.ExpandSymbol.Expand);
        break;
    case EDIT_SYMBOL:
        pSymbolGroup->WriteSymbol(SymWinData->u.WriteSymbol.Index,
                                  SymWinData->u.WriteSymbol.Value);
        break;
    case EDIT_TYPE:
        pSymbolGroup->OutputAsType(SymWinData->u.OutputAsType.Index,
                                  SymWinData->u.OutputAsType.Type);
        break;
    case DEL_SYMBOL_WIN_ALL:
    {
        ULONG nSyms = 0;

        pSymbolGroup->GetNumberSymbols(&nSyms);

        while (nSyms) 
        { 
            pSymbolGroup->RemoveSymbolByIndex(0);
            pSymbolGroup->GetNumberSymbols(&nSyms);
        }

        }
    }
}

void
ProcessCommand(UiCommandData* CmdData)
{
    DEBUG_VALUE Val;
    HRESULT Status;
    
    switch(CmdData->Cmd)
    {
    case UIC_CMD_INPUT:
    case UIC_EXECUTE:
        PSTR Str;
        ULONG StrLen;
        
        // Make sure the command has a newline at the end.
        Str = (PSTR)(CmdData + 1);
        StrLen = strlen(Str);
        if (StrLen > 0 && Str[StrLen - 1] == '\n')
        {
            // Trim existing newline as we're adding one.
            Str[StrLen - 1] = 0;
        }
        
        if (g_RemoteClient)
        {
            // Identify self before command.
            g_pDbgClient->OutputIdentity(DEBUG_OUTCTL_ALL_OTHER_CLIENTS,
                                         DEBUG_OUTPUT_IDENTITY_DEFAULT,
                                         "[%s] ");
        }
                
        g_pDbgControl->OutputPrompt(DEBUG_OUTCTL_ALL_CLIENTS, " %s\n", Str);
        g_pDbgControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                               Str, DEBUG_EXECUTE_NOT_LOGGED);
        break;

    case UIC_SILENT_EXECUTE:
        // Execute the command without displaying it.
        g_pDbgControl->Execute(DEBUG_OUTCTL_IGNORE,
                               (PCSTR)(CmdData + 1),
                               DEBUG_EXECUTE_NOT_LOGGED |
                               DEBUG_EXECUTE_NO_REPEAT);
        break;

    case UIC_INVISIBLE_EXECUTE:
        // Execute the command without displaying it and
        // ignore any notifications.
        g_Invisible = TRUE;
        g_pDbgControl->Execute(DEBUG_OUTCTL_IGNORE,
                               (PCSTR)(CmdData + 1),
                               DEBUG_EXECUTE_NOT_LOGGED |
                               DEBUG_EXECUTE_NO_REPEAT);
        g_Invisible = FALSE;
        break;

    case UIC_SET_REG:
        UIC_SET_REG_DATA* SetRegData;
        SetRegData = (UIC_SET_REG_DATA*)(CmdData + 1);
        g_pDbgRegisters->SetValue(SetRegData->Reg, &SetRegData->Val);
        break;

    case UIC_RESTART:
        if (g_RemoteClient || g_DebugCommandLine == NULL)
        {
            g_pDbgControl->
                Output(DEBUG_OUTPUT_ERROR,
                       "Only user-mode created processes may be restarted\n");
        }
        else
        {
            if ((Status = g_pDbgClient->
                 EndSession(DEBUG_END_ACTIVE_TERMINATE)) != S_OK)
            {
                InformationBox(ERR_Internal_Error, Status, "EndSession");
            }
            else
            {
                g_EndingSession = ENDING_RESTART;
            }
        }
        break;

    case UIC_END_SESSION:
        ULONG OldEnding;
        ULONG OldExec;
        
        // Mark the session as ending to avoid workspace
        // deadlock problems.
        OldEnding = g_EndingSession;
        OldExec = g_ExecStatus;
        g_EndingSession = ENDING_STOP;
        g_ExecStatus = DEBUG_STATUS_NO_DEBUGGEE;
        
        if (!g_RemoteClient)
        {
            if ((Status = g_pDbgClient->
                 EndSession(DEBUG_END_ACTIVE_TERMINATE)) != S_OK)
            {
                InformationBox(ERR_Internal_Error, Status, "EndSession");
                g_EndingSession = OldEnding;
                g_ExecStatus = OldExec;
            }
        }
        break;

    case UIC_WRITE_DATA:
        WriteData((UIC_WRITE_DATA_DATA*)(CmdData + 1));
        break;

    case UIC_SYMBOL_WIN: 
        ProcessWatchCommand((UIC_SYMBOL_WIN_DATA*) (CmdData + 1));
        break;

    case UIC_DISPLAY_CODE:
        FillCodeBuffer(((UIC_DISPLAY_CODE_DATA*)(CmdData + 1))->Offset,
                       TRUE);
        break;
        
    case UIC_DISPLAY_CODE_EXPR:
        if (g_pDbgControl->Evaluate((PSTR)(CmdData + 1), DEBUG_VALUE_INT64,
                                    &Val, NULL) != S_OK)
        {
            Val.I64 = 0;
        }
        FillCodeBuffer(Val.I64, TRUE);
        break;
        
    case UIC_SET_SCOPE:
        SetLocalScope(&(((UIC_SET_SCOPE_DATA *)(CmdData + 1))->StackFrame));
        InvalidateStateBuffers(1 << LOCALS_WINDOW);
        break;

    case UIC_SET_FILTER:
        UIC_SET_FILTER_DATA* SetFilter;
        SetFilter = (UIC_SET_FILTER_DATA*)(CmdData + 1);
        if (SetFilter->Index != 0xffffffff)
        {
            DEBUG_SPECIFIC_FILTER_PARAMETERS Params;

            Params.ExecutionOption = SetFilter->Execution;
            Params.ContinueOption = SetFilter->Continue;
            g_pDbgControl->SetSpecificFilterParameters(SetFilter->Index, 1,
                                                       &Params);
        }
        else
        {
            DEBUG_EXCEPTION_FILTER_PARAMETERS Params;

            Params.ExecutionOption = SetFilter->Execution;
            Params.ContinueOption = SetFilter->Continue;
            Params.ExceptionCode = SetFilter->Code;
            g_pDbgControl->SetExceptionFilterParameters(1, &Params);
        }
        break;

    case UIC_SET_FILTER_ARGUMENT:
        UIC_SET_FILTER_ARGUMENT_DATA* SetFilterArg;
        SetFilterArg = (UIC_SET_FILTER_ARGUMENT_DATA*)(CmdData + 1);
        g_pDbgControl->SetSpecificFilterArgument(SetFilterArg->Index,
                                                 SetFilterArg->Argument);
        break;

    case UIC_SET_FILTER_COMMAND:
        UIC_SET_FILTER_COMMAND_DATA* SetFilterCmd;
        SetFilterCmd = (UIC_SET_FILTER_COMMAND_DATA*)(CmdData + 1);
        if (SetFilterCmd->Which == 0)
        {
            g_pDbgControl->SetEventFilterCommand(SetFilterCmd->Index,
                                                 SetFilterCmd->Command);
        }
        else
        {
            g_pDbgControl->SetExceptionFilterSecondCommand
                (SetFilterCmd->Index, SetFilterCmd->Command);
        }
        break;
    }
}

void
ProcessEngineCommands(BOOL Internal)
{
#ifdef DBG_CALLBACK
    DebugPrint("ProcessEngineCommands\n");
#endif
    
    // Check for commands to execute.  We do not
    // want to hold the lock while doing so because
    // the commands may include things that cause waits
    // and we don't want to lock out the GUI.

    LockUiBuffer(&g_UiCommandBuffer);

    while (g_UiCommandBuffer.GetDataLen() > 0)
    {
        //
        // Remove the first command from the buffer.
        //

        // Extra char is for forcing a newline on executes.
        char CmdBuf[MAX_COMMAND_LEN + 1];
        UiCommandData* CmdData;

        // Copy command to local buffer.
        CmdData = (UiCommandData*)g_UiCommandBuffer.GetDataBuffer();
        memcpy(CmdBuf, CmdData, CmdData->Len);
        CmdData = (UiCommandData*)CmdBuf;

        // Remove command from queue and release the queue for
        // the UI thread to use again.
        g_UiCommandBuffer.RemoveHead(CmdData->Len);
        UnlockUiBuffer(&g_UiCommandBuffer);

        ProcessCommand(CmdData);

        InterlockedIncrement((PLONG)&g_CommandSequence);
        
        // Lock the buffer again for the next command retrieval.
        LockUiBuffer(&g_UiCommandBuffer);

        if (g_EndingSession != ENDING_NONE)
        {
            // If we're ending a session just throw away the rest
            // of the commands.
            g_UiCommandBuffer.Empty();
        }
    }
    
    UnlockUiBuffer(&g_UiCommandBuffer);

    if (!Internal && g_EndingSession == ENDING_NONE)
    {
        ReadStateBuffers();
    }
}

//----------------------------------------------------------------------------
//
// Engine processing.
//
//----------------------------------------------------------------------------

HRESULT
InitializeEngineInterfaces(void)
{
    HRESULT Hr;

    if ((Hr = g_pUiClient->CreateClient(&g_pDbgClient)) != S_OK)
    {
        InformationBox(ERR_Internal_Error, Hr, "Engine CreateClient");
        return Hr;
    }

    if ((Hr = g_pDbgClient->
         QueryInterface(IID_IDebugControl,
                        (void **)&g_pDbgControl)) != S_OK ||
        (Hr = g_pDbgClient->
         QueryInterface(IID_IDebugSymbols,
                        (void **)&g_pDbgSymbols)) != S_OK ||
        (Hr = g_pDbgClient->
         QueryInterface(IID_IDebugRegisters,
                        (void **)&g_pDbgRegisters)) != S_OK ||
        (Hr = g_pDbgClient->
         QueryInterface(IID_IDebugDataSpaces,
                        (void **)&g_pDbgData)) != S_OK ||
        (Hr = g_pDbgClient->
         QueryInterface(IID_IDebugSystemObjects,
                        (void **)&g_pDbgSystem)) != S_OK)
    {
        if (Hr == RPC_E_VERSION_MISMATCH)
        {
            InformationBox(ERR_Remoting_Version_Mismatch);
        }
        else
        {
            InformationBox(ERR_Internal_Error, Hr, "Engine QueryInterface");
        }
        return Hr;
    }

    //
    // Try and get higher version interfaces.
    //
    
    if (g_pDbgClient->
        QueryInterface(IID_IDebugClient2,
                       (void **)&g_pDbgClient2) != S_OK)
    {
        g_pDbgClient2 = NULL;
    }
        
    if (g_RemoteClient)
    {
        // Create a local client to do local source file lookups.
        if ((Hr = g_pUiLocClient->CreateClient(&g_pLocClient)) != S_OK ||
            (Hr = g_pLocClient->
             QueryInterface(IID_IDebugControl,
                            (void **)&g_pLocControl)) != S_OK ||
            (Hr = g_pLocClient->
             QueryInterface(IID_IDebugSymbols,
                            (void **)&g_pLocSymbols)) != S_OK)
        {
            InformationBox(ERR_Internal_Error, Hr, "Engine local client");
            return Hr;
        }
    }
    else
    {
        g_pLocClient = g_pDbgClient;
        g_pLocClient->AddRef();
        g_pLocControl = g_pDbgControl;
        g_pLocControl->AddRef();
        g_pLocSymbols = g_pDbgSymbols;
        g_pLocSymbols->AddRef();
    }
    
    // Create separate client for private output capture
    // during state buffer filling.  The output capture client
    // sets its output mask to nothing so that it doesn't
    // receive any normal input.  During private output capture
    // the output control is set to THIS_CLIENT | OVERRIDE_MASK to force
    // output to just the output capture client.
    if ((Hr = g_pDbgClient->CreateClient(&g_pOutCapClient)) != S_OK ||
        (Hr = g_pOutCapClient->
         QueryInterface(IID_IDebugControl,
                        (void **)&g_pOutCapControl)) != S_OK)
    {
        InformationBox(ERR_Internal_Error, Hr, "Engine output capture client");
        return Hr;
    }
    
    // Set callbacks.
    if ((Hr = g_pDbgClient->SetOutputCallbacks(&g_OutputCb)) != S_OK ||
        (Hr = g_pDbgClient->SetInputCallbacks(&g_InputCb)) != S_OK ||
        (Hr = g_pDbgClient->SetEventCallbacks(&g_EventCb)) != S_OK ||
        (g_RemoteClient &&
         (Hr = g_pLocClient->SetOutputCallbacks(&g_OutputCb))) != S_OK ||
        (Hr = g_pOutCapClient->SetOutputMask(0)) != S_OK ||
        (Hr = g_pOutCapClient->SetOutputCallbacks(&g_OutStateBuf)) != S_OK ||
        (Hr = g_pOutCapClient->
         QueryInterface(IID_IDebugSymbols, 
                        (void **)&g_pOutCapSymbols)) != S_OK)
    {
        InformationBox(ERR_Internal_Error, Hr, "Engine callbacks");
        return Hr;
    }

    // Create a watch window client 
    if ((Hr = g_pOutCapSymbols->
         CreateSymbolGroup(&g_pDbgWatchSymbolGroup)) != S_OK)
    {
        InformationBox(ERR_Internal_Error, Hr, "Engine CreateSymbolGroup");
        return Hr;
    }
    
    // Create a local window client 
    if ((Hr = g_pOutCapSymbols->
         GetScopeSymbolGroup(DEBUG_SCOPE_GROUP_LOCALS,
                             NULL, &g_pDbgLocalSymbolGroup)) == E_NOTIMPL)
    {
        // Older version
        Hr = g_pOutCapSymbols->
            GetScopeSymbolGroup(DEBUG_SCOPE_GROUP_ALL,
                                NULL, &g_pDbgLocalSymbolGroup);
    }
    if (Hr != S_OK ||
        (Hr = g_FilterTextBuffer->Update()) != S_OK)
    {
        InformationBox(ERR_Internal_Error, Hr, "Engine GetScopeSymbolGroup");
        return Hr;
    }

    if ((Hr = g_pDbgControl->GetRadix(&g_NumberRadix)) != S_OK)
    {
        InformationBox(ERR_Internal_Error, Hr, "Engine GetRadix");
        return Hr;
    }
    
    if (g_RemoteClient)
    {
        return S_OK;
    }
    
    //
    // Set up initial state for things that are important
    // when starting the debug session.
    //

    if (g_Verbose)
    {
        DWORD OutMask;
        
        g_pDbgClient->GetOutputMask(&OutMask);
        OutMask |= DEBUG_OUTPUT_VERBOSE;
        g_pDbgClient->SetOutputMask(OutMask);
        g_pDbgControl->SetLogMask(OutMask);
    }

    // Always load line numbers for source support.
    g_pDbgSymbols->AddSymbolOptions(SYMOPT_LOAD_LINES);

    // Set the source stepping mode
    g_IgnoreCodeLevelChange = TRUE;
    if (GetSrcMode_StatusBar())
    {
        g_pDbgControl->SetCodeLevel(DEBUG_LEVEL_SOURCE);
    }
    else
    {
        g_pDbgControl->SetCodeLevel(DEBUG_LEVEL_ASSEMBLY);
    }
    g_IgnoreCodeLevelChange = FALSE;

    // If this is a user-mode debug session default to
    // initial and final breaks.  Don't override settings
    // that were given on the command line, though.

    g_IgnoreFilterChange = TRUE;
    if (g_DebugCommandLine != NULL ||
        g_PidToDebug != 0 ||
        g_ProcNameToDebug != NULL)
    {
        g_pDbgControl->AddEngineOptions((DEBUG_ENGOPT_INITIAL_BREAK |
                                         DEBUG_ENGOPT_FINAL_BREAK) &
                                        ~g_EngOptModified);
    }
    else
    {
        g_pDbgControl->RemoveEngineOptions((DEBUG_ENGOPT_INITIAL_BREAK |
                                            DEBUG_ENGOPT_FINAL_BREAK) &
                                           ~g_EngOptModified);
    }
    g_IgnoreFilterChange = FALSE;

    return S_OK;
}

void
DiscardEngineState(void)
{
    LockUiBuffer(&g_UiOutputBuffer);
    g_UiOutputBuffer.Empty();
    UnlockUiBuffer(&g_UiOutputBuffer);
    
    g_TargetClass = DEBUG_CLASS_UNINITIALIZED;
    g_ExecStatus = DEBUG_STATUS_NO_DEBUGGEE;
}

void
ReleaseEngineInterfaces(void)
{
    DiscardEngineState();
    
    RELEASE(g_pLocControl);
    RELEASE(g_pLocSymbols);
    RELEASE(g_pLocClient);

    RELEASE(g_pDbgWatchSymbolGroup);
    RELEASE(g_pDbgLocalSymbolGroup);
    
    RELEASE(g_pOutCapControl);
    RELEASE(g_pOutCapSymbols);
    RELEASE(g_pOutCapClient);
    
    RELEASE(g_pDbgControl);
    RELEASE(g_pDbgSymbols);
    RELEASE(g_pDbgRegisters);
    RELEASE(g_pDbgData);
    RELEASE(g_pDbgSystem);
    RELEASE(g_pDbgClient2);
    RELEASE(g_pDbgClient);
}

BOOL
ExtractWspName(PSTR CommandLine, PSTR Buf, ULONG BufLen)
{
    PSTR Scan = CommandLine;
    PSTR Start;

    while (isspace(*Scan))
    {
        Scan++;
    }

    if (!*Scan)
    {
        return FALSE;
    }
    else if (*Scan == '"')
    {
        Start = ++Scan;
        
        // Look for closing quote.
        while (*Scan && *Scan != '"')
        {
            Scan++;
        }
    }
    else
    {
        // Look for whitespace.
        Start = Scan++;

        while (*Scan && !isspace(*Scan))
        {
            Scan++;
        }
    }

    ULONG Len = (ULONG) (ULONG64) (Scan - Start);
    if (Len == 0)
    {
        return FALSE;
    }
    
    if (Len >= BufLen)
    {
        Len = BufLen - 1;
    }
    memcpy(Buf, Start, Len);
    Buf[Len] = 0;

    return TRUE;
}

HRESULT
StartSession(void)
{
    TCHAR WspName[MAX_PATH];
    ULONG WspKey;
    PTSTR WspValue;
    HRESULT Hr;

    // Reset things to the default priority first.
    // If necessary, priority will be increased in certain code
    // paths later.
    SetPriorityClass(GetCurrentProcess(), g_DefPriority);
    
    if (!g_RemoteClient)
    {
        if (g_DumpFile != NULL)
        {
            WspKey = WSP_NAME_DUMP;
            WspValue = g_DumpFile;
            EngSwitchWorkspace(WspKey, WspValue);
            
            if (g_DumpPageFile != NULL)
            {
                if (g_pDbgClient2 == NULL)
                {
                    ErrorBox(NULL, 0, ERR_Cant_Add_Dump_Info_File);
                    Hr = E_NOINTERFACE;
                    goto ResetWorkspace;
                }
            
                if ((Hr = g_pDbgClient2->AddDumpInformationFile
                     (g_DumpPageFile, DEBUG_DUMP_FILE_PAGE_FILE_DUMP)) != S_OK)
                {
                    ErrorBox(NULL, 0, ERR_Add_Dump_Info_File_Failed,
                             g_DumpPageFile, Hr);
                    goto ResetWorkspace;
                }
            }

            Hr = g_pDbgClient->OpenDumpFile(g_DumpFile);
            if (Hr != S_OK)
            {
                if ((HRESULT_FACILITY(Hr)) == FACILITY_WIN32)
                {
                    // Win32 errors on open generally mean some
                    // kind of file error.
                    ErrorBox(NULL, 0, ERR_Invalid_Dump_File_Name,
                             g_DumpFile, Hr);
                }
                else
                {
                    ErrorBox(NULL, 0, ERR_Unable_To_Open_Dump,
                             g_DumpFile, Hr);
                }

                goto ResetWorkspace;
            }
        }
        else if (g_DebugCommandLine != NULL ||
                 g_PidToDebug != 0 ||
                 g_ProcNameToDebug != NULL)
        {
            ULONG64 Server = 0;
            ULONG Pid;
            
            WspKey = WSP_NAME_USER;
            WspValue = g_ProcessServer != NULL ?
                g_ProcessServer : g_WorkspaceDefaultName;
            if (g_DebugCommandLine != NULL)
            {
                if (ExtractWspName(g_DebugCommandLine,
                                   WspName, sizeof(WspName)))
                {
                    WspValue = WspName;
                }
            }
            EngSwitchWorkspace(WspKey, WspValue);
            
            if (g_ProcessServer != NULL)
            {
                Hr = g_pDbgClient->ConnectProcessServer(g_ProcessServer,
                                                        &Server);
                if (Hr != S_OK)
                {
                    ErrorBox(NULL, 0, ERR_Connect_Process_Server,
                             g_ProcessServer, Hr);
                    goto ResetWorkspace;
                }
                
                // Default to not automatically bringing up a disassembly
                // window as it is very expensive to remote all
                // the virtual reads done for it.
                g_WinOptions &= ~WOPT_AUTO_DISASM;
            }

            if (g_ProcNameToDebug != NULL)
            {
                Hr = g_pDbgClient->GetRunningProcessSystemIdByExecutableName
                    (Server, g_ProcNameToDebug, DEBUG_GET_PROC_ONLY_MATCH,
                     &Pid);
                if (Hr != S_OK)
                {
                    ErrorBox(NULL, 0, ERR_Get_Named_Process,
                             g_ProcNameToDebug, Hr);
                    goto ResetWorkspace;
                }
            }
            else
            {
                Pid = g_PidToDebug;
            }
        
            Hr = g_pDbgClient->CreateProcessAndAttach(Server,
                                                      g_DebugCommandLine,
                                                      g_DebugCreateFlags,
                                                      Pid,
                                                      g_AttachProcessFlags);
            if (Hr != S_OK)
            {
                if (g_DebugCommandLine != NULL)
                {
                    ErrorBox(NULL, 0, ERR_Invalid_Process_Create,
                             g_DebugCommandLine, Hr);
                }
                else
                {
                    ErrorBox(NULL, 0, ERR_Invalid_Process_Attach,
                             Pid, Hr);
                }
                goto ResetWorkspace;
            }

            if (g_DetachOnExit &&
                (Hr = g_pDbgClient->
                 AddProcessOptions(DEBUG_PROCESS_DETACH_ON_EXIT)) != S_OK)
            {
                ErrorBox(NULL, 0, ERR_No_Detach_On_Exit);
            }
        
            if (Server != 0)
            {
                g_pDbgClient->DisconnectProcessServer(Server);
            }
            
            // Bump up our priority so that the debugger stays responsive
            // even when the debuggee is running.
            SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
        }
        else
        {
            // Default to not automatically bringing up a disassembly
            // window as it is very expensive in kernel debugging.
            g_WinOptions &= ~WOPT_AUTO_DISASM;

            WspKey = WSP_NAME_KERNEL;
            WspValue = g_WorkspaceDefaultName;
            EngSwitchWorkspace(WspKey, WspValue);
            
            Hr = g_pDbgClient->AttachKernel(g_AttachKernelFlags,
                                            g_KernelConnectOptions);
            if (Hr != S_OK)
            {
                if (g_AttachKernelFlags == DEBUG_ATTACH_LOCAL_KERNEL)
                {
                    if (Hr == E_NOTIMPL)
                    {
                        ErrorBox(NULL, 0, ERR_No_Local_Kernel_Debugging);
                    }
                    else
                    {
                        ErrorBox(NULL, 0, ERR_Failed_Local_Kernel_Debugging,
                                 Hr);
                    }
                }
                else
                {
                    ErrorBox(NULL, 0, ERR_Invalid_Kernel_Attach,
                             g_KernelConnectOptions, Hr);
                }

                goto ResetWorkspace;
            }
        }
    }
    else
    {
        WspKey = WSP_NAME_REMOTE;
        WspValue = g_WorkspaceDefaultName;
        EngSwitchWorkspace(WspKey, WspValue);
        
        // Use a heuristic of 45 characters per line.
        g_pDbgClient->ConnectSession(DEBUG_CONNECT_SESSION_DEFAULT,
                                     g_HistoryLines * 45);
    }

    PostMessage(g_hwndFrame, WU_ENGINE_STARTED, 0, S_OK);
    return S_OK;

 ResetWorkspace:
    // We just switched to this workspace but
    // we're failing and we want to abandon it.
    if (g_Workspace != NULL && !g_ExplicitWorkspace)
    {
        // Make sure this doesn't cause a popup.
        g_Workspace->ClearDirty();
        
        EngSwitchWorkspace(WSP_NAME_BASE,
                           g_WorkspaceDefaultName);
    }
    return Hr;
}

void
SetLocalScope(PDEBUG_STACK_FRAME pStackFrame)
{
    DEBUG_STACK_FRAME LocalFrame;

    if (!pStackFrame)
    {
        // Get and use the default scope
        if (g_pDbgSymbols->ResetScope() != S_OK ||
            g_pDbgSymbols->GetScope(NULL, &LocalFrame, NULL, 0) != S_OK)
        {
            return;
        }

        pStackFrame = &LocalFrame;
    }
    else if (FAILED(g_pDbgSymbols->SetScope(0, pStackFrame, NULL, 0)))
    {
        return;
    }
    
}

void
SessionActive(void)
{
    HRESULT Hr;

    // This can get called twice if a remote client connects
    // just as a session is becoming active.
    if (g_SessionActive)
    {
        return;
    }
    g_SessionActive = TRUE;
    
    // XXX drewb - Eventually this should handle multiple
    // processor types for IA64.
    if ((Hr = g_pDbgControl->
         GetActualProcessorType(&g_ActualProcType)) != S_OK ||
        FAILED(Hr = g_pDbgControl->
               GetProcessorTypeNames(g_ActualProcType, NULL, 0, NULL,
                                     g_ActualProcAbbrevName,
                                     sizeof(g_ActualProcAbbrevName),
                                     NULL)) ||
        (Hr = g_pDbgRegisters->
         GetNumberRegisters(&g_NumRegisters)) != S_OK)
    {
        ErrorExit(g_pDbgClient,
                  "Debug target initialization failed, 0x%X\n", Hr);
    }

    g_RegisterNamesBuffer->RequestRead();
    g_RegisterNamesBuffer->Update();
    
    if (FAILED(Hr = g_pDbgControl->IsPointer64Bit()))
    {
        ErrorExit(g_pDbgClient,
                  "Unable to get debuggee pointer size, 0x%X\n", Hr);
    }
    g_Ptr64 = Hr == S_OK;

    // The same machine could theoretically debug many different
    // processor types over kernel connections or via different
    // processor dumps.  Workspaces contain processor-related
    // information, such as register maps, so allow for different
    // workspaces based on the processor type.  This is only
    // done when a default workspace would otherwise be used,
    // though to reduce workspace explosion.
    if (!g_RemoteClient &&
        g_TargetClass == DEBUG_CLASS_KERNEL &&
        g_DumpFile == NULL)
    {
        if (g_ExplicitWorkspace)
        {
            // Reapply the workspace after a reboot to get
            // breakpoints and other engine state back.
            // Don't restart the session when doing so.
            if (g_Workspace != NULL)
            {
                Workspace* Wsp = g_Workspace;
                g_Workspace = NULL;
                Wsp->Apply(WSP_APPLY_AGAIN);
                g_Workspace = Wsp;
            }
        }
        else
        {
            EngSwitchWorkspace(WSP_NAME_KERNEL, g_ActualProcAbbrevName);
        }
    }

    InvalidateStateBuffers(BUFFERS_ALL);
    UpdateBufferWindows((1 << CPU_WINDOW) | (1 << DOC_WINDOW),
                        UPDATE_START_SESSION);
    UpdateEngine();
}

void
SessionInactive(void)
{
    if (!g_RemoteClient && g_EndingSession != ENDING_STOP)
    {
        EngSwitchWorkspace(WSP_NAME_BASE,
                           g_WorkspaceDefaultName);
    }

    g_SessionActive = FALSE;
    
    delete g_RegisterMap;
    g_RegisterMap = NULL;
    g_RegisterMapEntries = 0;
    g_ActualProcType = IMAGE_FILE_MACHINE_UNKNOWN;
    g_NumRegisters = 0;
    InvalidateStateBuffers(BUFFERS_ALL);
    UpdateBufferWindows((1 << CPU_WINDOW) | (1 << DOC_WINDOW) |
                        (1 << DISASM_WINDOW), UPDATE_END_SESSION);
    UpdateEngine();
    SetPriorityClass(GetCurrentProcess(), g_DefPriority);
}

void
StopOrEndDebugging(void)
{
    //
    // If the session was started from the command line
    // assume that debugging is done and exit.
    // If the session was started from the UI treat it
    // like a stop debugging request.
    //
    
    if (g_CommandLineStart)
    {
        EngSwitchWorkspace(WSP_NAME_BASE,
                           g_WorkspaceDefaultName);
        g_Exit = TRUE;
        PostMessage(g_hwndFrame, WU_UPDATE, UPDATE_EXIT, 0);
    }
    else
    {
        PostMessage(g_hwndFrame, WM_COMMAND,
                    0xffff0000 | IDM_DEBUG_STOPDEBUGGING, 0);
        g_EndingSession = ENDING_STOP;
    }
}
    

BOOL
CallBugCheckExtension(
    void
    )
{
    HRESULT Status = E_FAIL;

    ULONG Code;
    ULONG64 Args[4];

    // Run the bugcheck analyzers if this dump has a bugcheck.
    if (g_pDbgControl->ReadBugCheckData(&Code, &Args[0], &Args[1], &Args[2], &Args[3]) != S_OK ||
        Code == 0)
    {
        return FALSE;
    }

    if (g_pDbgClient != NULL)
    {
        char ExtName[32];

        // Extension name has to be in writable memory as it
        // gets lower-cased.
        strcpy(ExtName, "AnalyzeBugCheck");
        
        // See if any existing extension DLLs are interested
        // in analyzing this bugcheck.
        Status = g_pDbgControl->CallExtension(NULL, ExtName, "");
    }

    if (Status != S_OK)
    {
        if (g_pDbgClient == NULL)
        {
            g_OutputCb.Output(DEBUG_OUTPUT_ERROR,"WARNING: Unable to locate a client for "
                              "bugcheck analysis\n");
        }
        
        g_OutputCb.Output(DEBUG_OUTPUT_NORMAL,
                          "*******************************************************************************\n"
                          "*                                                                             *\n"
                          "*                        Bugcheck Analysis                                    *\n"
                          "*                                                                             *\n"
                          "*******************************************************************************\n");

        g_pDbgControl->Execute(DEBUG_OUTCTL_AMBIENT, ".bugcheck", DEBUG_EXECUTE_DEFAULT);
        g_OutputCb.Output(DEBUG_OUTPUT_NORMAL,"\n");
        g_pDbgControl->Execute(DEBUG_OUTCTL_AMBIENT, "kb", DEBUG_EXECUTE_DEFAULT);
        g_OutputCb.Output(DEBUG_OUTPUT_NORMAL,"\n");
    } else 
    {
        return TRUE;
    }

    return FALSE;
}

DWORD
WINAPI
EngineLoop(LPVOID Param)
{
    HRESULT Hr;
    DEBUG_STACK_FRAME StkFrame;    
    ULONG64 InstructionOffset;

    if ((Hr = InitializeEngineInterfaces()) != S_OK ||
        (Hr = StartSession()) != S_OK)
    {
        ReleaseEngineInterfaces();
        PostMessage(g_hwndFrame, WU_ENGINE_STARTED, 0, Hr);
        return 0;
    }

    g_EngineThreadId = GetCurrentThreadId();
    
    Hr = g_pDbgControl->GetDebuggeeType(&g_TargetClass, &g_TargetClassQual);
    if (Hr != S_OK)
    {
        ErrorExit(g_pDbgClient, "Unable to get debuggee type, 0x%X\n", Hr);
    }
    
    // Set initial execution state.
    if ((Hr = g_pDbgControl->GetExecutionStatus(&g_ExecStatus)) != S_OK)
    {
        ErrorExit(g_pDbgClient, "Unable to get execution status, 0x%X\n", Hr);
    }

    if (g_ExecStatus != DEBUG_STATUS_NO_DEBUGGEE)
    {
        // Session is already active.
        SessionActive();
    }
    
    UpdateBufferWindows(UPDATE_EXEC_WINDOWS, UPDATE_EXEC);

    if (g_RemoteClient)
    {
        // Request an initial read of everything.
        InvalidateStateBuffers(BUFFERS_ALL);
        ReadStateBuffers();

        // The server may be in an input request, which
        // we would have been notified of back during
        // ConnectSession.  If we're still in an input
        // request switch to input mode.
        if (g_InputStarted)
        {
            UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_INPUT_REQUIRED);
        }
    }

    for (;;)
    {
        if (!g_RemoteClient)
        {
            g_WaitingForEvent = TRUE;
            
            Hr = g_pDbgControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);

            g_WaitingForEvent = FALSE;
            
            if (FAILED(Hr))
            {
                // The debug session may have ended.  If so,
                // stop or end things based on how the session
                // was started.
                if (g_pDbgControl->GetExecutionStatus(&g_ExecStatus) == S_OK &&
                    g_ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
                {
                    g_pDbgClient->EndSession(DEBUG_END_PASSIVE);
                    StopOrEndDebugging();
                    break;
                }
            
                // Inform the user of the failure and go back to
                // command processing.
                g_OutputCb.Output(DEBUG_OUTPUT_ERROR, "WaitForEvent failed\n");
            }

            BOOL DisplayRegs = TRUE;

            if (g_TargetClass == DEBUG_CLASS_KERNEL &&
                (g_TargetClassQual == DEBUG_DUMP_SMALL || g_TargetClassQual == DEBUG_DUMP_DEFAULT ||
                 g_TargetClassQual == DEBUG_DUMP_FULL)) 
            {
                if (CallBugCheckExtension())
                {
                    DisplayRegs = FALSE;
                }
            }

            if (DisplayRegs)
            {
                g_pDbgControl->OutputCurrentState(DEBUG_OUTCTL_ALL_CLIENTS,
                                                  DEBUG_CURRENT_DEFAULT);

            }
            ReadStateBuffers();
        }

        while (!g_Exit &&
               g_EndingSession == ENDING_NONE &&
               (g_RemoteClient || g_ExecStatus == DEBUG_STATUS_BREAK))
        {
            if (!g_InputStarted)
            {
                // Tell the command window to display a prompt to
                // indicate the engine is ready to process commands.
                if (g_pDbgControl->GetPromptText(g_PromptText,
                                                 sizeof(g_PromptText),
                                                 NULL) != S_OK)
                {
                    strcpy(g_PromptText, "?Err");
                }
                UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_PROMPT_TEXT);

                PostMessage(g_hwndFrame, WU_ENGINE_IDLE, 0, 0);
            }
            
            // Wait until engine processing is needed.
            Hr = g_pDbgClient->DispatchCallbacks(INFINITE);
            if (FAILED(Hr))
            {
                if (g_RemoteClient && HRESULT_FACILITY(Hr) == FACILITY_RPC)
                {
                    // A remote client was unable to communicate
                    // with the server so shut down the session.
                    InformationBox(ERR_Client_Disconnect);
                    StopOrEndDebugging();
                    break;
                }
                else
                {
                    // A failure here is a critical problem as
                    // something is seriously wrong with the engine
                    // if it can't do a normal DispatchCallbacks.
                    ErrorExit(g_pDbgClient,
                              "Engine thread wait failed, 0x%X\n", Hr);
                }
            }

            if (!g_InputStarted)
            {
                // Take away the prompt while the engine is working.
                g_PromptText[0] = 0;
                UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_PROMPT_TEXT);
            }
            
            ProcessEngineCommands(FALSE);
        }

        if (g_Exit)
        {
            g_EndingSession = ENDING_EXIT;
            break;
        }
        
        if (g_EndingSession != ENDING_NONE)
        {
            // Force windows to display empty state.
            InvalidateStateBuffers(BUFFERS_ALL);
            UpdateBufferWindows(BUFFERS_ALL, UPDATE_BUFFER);

            if (g_EndingSession == ENDING_RESTART)
            {
                if (StartSession() != S_OK)
                {
                    // If we couldn't restart go into
                    // the stop-debugging state.
                    g_EndingSession = ENDING_STOP;
                    break;
                }
                
                g_EndingSession = ENDING_NONE;
            }
            else
            {
                break;
            }
        }
    }

    if (g_EndingSession == ENDING_NONE)
    {
        // Wake up the message pump for exit.
        PostMessage(g_hwndFrame, WM_CLOSE, 0, 0);
    }

    ULONG Code;
    
    if (!g_RemoteClient && g_DebugCommandLine != NULL)
    {
        // Return exit code of last process to exit.
        Code = g_LastProcessExitCode;
    }
    else
    {
        Code = S_OK;
    }

    if (g_EndingSession != ENDING_STOP && g_pDbgClient != NULL)
    {
        g_pDbgClient->EndSession(DEBUG_END_REENTRANT);
    }
    
    ReleaseEngineInterfaces();

    g_EngineThreadId = 0;
    
    if (g_EndingSession != ENDING_STOP)
    {
        //
        // Wait for UI to finish up.
        //

        while (!g_Exit)
        {
            Sleep(50);
        }

        ExitDebugger(g_pDbgClient, Code);
    }
    else
    {
        g_EndingSession = ENDING_NONE;
    }
    
    return 0;
}

void
UpdateEngine(void)
{
    if (g_pUiClient != NULL && g_pDbgClient != NULL)
    {
        g_pUiClient->ExitDispatch(g_pDbgClient);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\format.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Purpose:

    Formatting functions.

--*/


#include "precomp.hxx"
#pragma hdrstop



#define MAXNESTING      (50)

static TCHAR rgchOpenQuote[] = { _T('\"'), _T('\''), _T('('), _T('{'), _T('[') };
static TCHAR rgchCloseQuote[] = { _T('\"'), _T('\''), _T(')'), _T('}'), _T(']') };
#define MAXQUOTE        (_tsizeof(rgchOpenQuote) / _tsizeof(rgchOpenQuote[0]))

static TCHAR rgchDelim[] = { _T(' '), _T('\t'), _T(',') };
#define MAXDELIM        (_tsizeof(rgchDelim) / _tsizeof(rgchDelim[0]))

//extern  LPSHF   Lpshf;





int
CPCopyString(
    PTSTR * lplps,
    PTSTR lpT,
    TCHAR  chEscape,
    BOOL  fQuote
    )
/*++

Routine Description:

    Scan and copy an optionally quoted C-style string.  If the first character is
    a quote, a matching quote will terminate the string, otherwise the scanning will
    stop at the first whitespace encountered.  The target string will be null
    terminated if any characters are copied.

Arguments:

    lplps    - Supplies a pointer to a pointer to the source string

    lpt      - Supplies a pointer to the target string

    chEscape - Supplies the escape character (typically '\\')

    fQuote   - Supplies a flag indicating whether the first character is a quote

Return Value:

    The number of characters copied into lpt[].  If an error occurs, -1 is returned.

--*/
{
    PTSTR lps = *lplps;
    PTSTR lpt = lpT;
    int   i;
    int   n;
    int   err = 0;
    TCHAR  cQuote = _T('\0');

    if (fQuote) {
        if (*lps) {
            cQuote = *lps++;
        }
    }

    while (!err) {

        if (*lps == 0)
        {
            if (fQuote) {
                err = 1;
            } else {
                *lpt = _T('\0');
            }
            break;
        }
        else if (fQuote && *lps == cQuote)
        {
            *lpt = _T('\0');
            // eat the quote
            lps++;
            break;
        }
        else if (!fQuote &&  (!*lps || *lps == _T(' ') || *lps == _T('\t') || *lps == _T('\r') || *lps == _T('\n')))
        {
            *lpt = _T('\0');
            break;
        }

        else if (*lps != chEscape)
        {
            *lpt++ = *lps++;
        }
        else
        {
            switch (*++lps) {
              case 0:
                err = 1;
                --lps;
                break;

              default:     // any char - usually escape or quote
                *lpt++ = *lps;
                break;

              case _T('b'):    // backspace
                *lpt++ = _T('\b');
                break;

              case _T('f'):    // formfeed
                *lpt++ = _T('\f');
                break;

              case _T('n'):    // newline
                *lpt++ = _T('\n');
                break;

              case _T('r'):    // return
                *lpt++ = _T('\r');
                break;

              case _T('s'):    // space
                *lpt++ = _T(' ');
                break;

              case _T('t'):    // tab
                *lpt++ = _T('\t');
                break;

              case _T('0'):    // octal escape
                for (n = 0, i = 0; i < 3; i++) {
                    ++lps;
                    if (*lps < _T('0') || *lps > _T('7')) {
                        --lps;
                        break;
                    }
                    n = (n<<3) + *lps - _T('0');
                }
                *lpt++ = (UCHAR)(n & 0xff);
                break;
            }
            lps++;    // skip char from switch
        }

    }  // while

    if (err) {
        return -1;
    } else {
        *lplps = lps;
        return (int) (lpt - lpT);
    }
}



BOOL
CPFormatMemory(
    LPCH    lpchTarget,
    DWORD    cchTarget,
    LPBYTE  lpbSource,
    DWORD    cBits,
    FMTTYPE fmtType,
    DWORD    radix
    )

/*++

Routine Description:

    CPFormatMemory.

    formats a value by template

Arguments:

    lpchTarget - Destination buffer.

    cchTarget - Size of destination buffer.

    lpbSource - Data to be formatted.

    cBits - Number of bits in the data.

    fmtType - Determines how the data will be treated?? UINT, float, real, ...

    radix - Radix to use when formatting.

Return Value:

    TRUE - Success

    FALSE - Bad things happened

--*/
{
    LONG64      l;
    long        cb;
    ULONG64     ul = 0;
    TCHAR        rgch[512] = {0};
    
    
    Assert (radix == 8 || radix == 10 || radix == 16 ||
            (fmtType & fmtBasis) == fmtAscii ||
            (fmtType & fmtBasis) == fmtUnicode);
    Assert (cBits != 0);
    Assert (cchTarget <= _tsizeof(rgch));
    
    switch (fmtType & fmtBasis) {
    //
    //  Format from memory bytes into an integer format number
    //
    case fmtInt:
        
        if (radix == 10) {
            
            switch( (cBits + 7)/8 ) {
            case 1:
                l = *(signed char *)lpbSource;
                if (fmtType & fmtZeroPad) {
                    _stprintf(rgch, _T("%0*I64d"), cchTarget-1, l);
                } else if (fmtType & fmtSpacePad) {
                    _stprintf(rgch, _T("% *I64d"), cchTarget-1, l);
                } else {
                    _stprintf(rgch, _T("% I64d"), l);
                }
                break;
                
            case 2:
                l = *(short *)lpbSource;
                if (fmtType & fmtZeroPad) {
                    _stprintf(rgch, _T("%0*I64d"), cchTarget-1, l);
                } else if (fmtType & fmtSpacePad) {
                    _stprintf(rgch, _T("% *I64d"), cchTarget-1, l);
                } else {
                    _stprintf(rgch, _T("% I64d"), l);
                }
                break;
                
            case 4:
                l = *(long *)lpbSource;
                if (fmtType & fmtZeroPad) {
                    _stprintf(rgch, _T("%0*I64d"), cchTarget-1, l);
                } else if (fmtType & fmtSpacePad) {
                    _stprintf(rgch, _T("% *I64d"), cchTarget-1, l);
                } else {
                    _stprintf(rgch, _T("% I64d"), l);
                }
                break;
                
            case 8:
                l = *(LONG64 *)lpbSource;
                if (fmtType & fmtZeroPad) {
                    _stprintf(rgch, _T("%0*I64d"), cchTarget-1, l);
                } else if (fmtType & fmtSpacePad) {
                    _stprintf(rgch, _T("% *I64d"), cchTarget-1, l);
                } else {
                    _stprintf(rgch, _T("% I64d"), l);
                }
                break;

            default:
                return FALSE; // Bad format
            }
            
            
            if (_tcslen(rgch) >= cchTarget) {
                return FALSE; // Overrun
            }
            
            _tcscpy(lpchTarget, rgch);
            
            break;
        }
        //
        // then we should handle this as UInt
        //
        
    case fmtUInt:
        
        cb = (cBits + 7)/8;
        switch( cb ) {
        case 1:
            ul = *(BYTE *) lpbSource;
            break;
            
        case 2:
            ul = *(USHORT *) lpbSource;
            break;
            
        case 4:
            ul = *(ULONG *) lpbSource;
            break;
            
//
// MBH - bugbug - CENTAUR bug;
// putting contents of instead of address of structure
// for return value in a0.
//

        case 8:
            ul = *(ULONG64 *) lpbSource;
            break;
            
            
        default:
            if (radix != 16 || (fmtType & fmtZeroPad) == 0) {
                return FALSE; // Bad format
            }
        }
        
        if (fmtType & fmtZeroPad) {
            switch (radix) {
            case 8:
                _stprintf(rgch, _T("%0*.*I64o"), cchTarget-1, cchTarget-1, ul);
                break;
            case 10:
                _stprintf(rgch, _T("%0*.*I64u"), cchTarget-1, cchTarget-1, ul);
                break;
            case 16:
                if (cb <= 8) {
                    _stprintf(rgch, _T("%0*.*I64x"), cchTarget-1, cchTarget-1, ul);
                } else {
                    // handle any size:
                    // NOTENOTE a-kentf this is dependent on byte order
                    for (l = 0; l < cb; l++) {
                        _stprintf(rgch+l+l, _T("%02.2x"), lpbSource[cb - l - 1]);
                    }
                    //_stprintf(rgch, _T("%0*.*x"), cchTarget-1, cchTarget-1, ul);
                }
                break;
            }
        } else if (fmtType & fmtSpacePad) {
            switch (radix) {
            case 8:
                _stprintf(rgch, _T("% *.*I64o"), cchTarget-1, cchTarget-1, ul);
                break;
            case 10:
                _stprintf(rgch, _T("% *.*I64u"), cchTarget-1, cchTarget-1, ul);
                break;
            case 16:
                if (cb <= 8) {
                    _stprintf(rgch, _T("% *.*I64x"), cchTarget-1, cchTarget-1, ul);
                } else {
                    // handle any size:
                    // NOTENOTE a-kentf this is dependent on byte order
                    /*for (l = 0; l < cb; l++) {
                        _stprintf(rgch+l+l, _T("% 2.2x"), lpbSource[cb - l - 1]);
                    }*/
                    _stprintf(rgch, _T("% *.*I64x"), cchTarget-1, cchTarget-1, ul);
                }
                break;
            }
        } else {
            switch (radix) {
            case 8:
                _stprintf(rgch, _T("%I64o"), ul);
                break;
            case 10:
                _stprintf(rgch, _T("%I64u"), ul);
                break;
            case 16:
                _stprintf(rgch, _T("%I64x"), ul);
                break;
            }
        }
            
        
        if (_tcslen(rgch) >= cchTarget) {
            return FALSE; // Overrun
        }
        
        _tcscpy(lpchTarget, rgch);
        
        break;
        
        
    case fmtAscii:
        if ( cBits != 8 ) {
            return FALSE; // Bad format
        }
        lpchTarget[0] = *(BYTE *) lpbSource;
        if ((lpchTarget[0] < _T(' ')) || (lpchTarget[0] > 0x7e)) {
            lpchTarget[0] = _T('.');
        }
        lpchTarget[1] = 0;
        return TRUE; // success

    case fmtUnicode:
        if (cBits != 16) {
            return FALSE; // Bad format
        }
        Assert((DWORD)MB_CUR_MAX <= cchTarget);
        if ((wctomb(lpchTarget, *(LPWCH)lpbSource) == -1) ||
            (lpchTarget[0] < _T(' ')) ||
            (lpchTarget[0] > 0x7e)) {
            lpchTarget[0] = _T('.');
        }
        lpchTarget[1] = 0;
        return TRUE; // success

    case fmtFloat:
        switch ( cBits ) {
        case 4*8:
            _stprintf(rgch, _T("% 12.6e"),*((float *) lpbSource));
            break;

        case 8*8:
            //            _stprintf(rgch, _T("% 17.11le"), *((double *) lpbSource));
            _stprintf(rgch, _T("% 21.14le"), *((double *) lpbSource));
            break;

        case 10*8:
            if (_uldtoa((_ULDOUBLE *)lpbSource, 25, rgch) == NULL) {
                return FALSE; // Bad format
            }
            break;

        case 16*8:
            // v-vadimp this is an IA64 float - may have to rethink the format here
            // what we are getting here is really FLOAT128
            if (_uldtoa((_ULDOUBLE *)(lpbSource), 30, rgch) == NULL) {
                return FALSE; // Bad format
            }
            break;

        default:
            return FALSE; // Bad format

        }

        if (_tcslen(rgch) >= cchTarget) {
            return FALSE; // Overrun
        }

        _tcsncpy(lpchTarget, rgch, cchTarget-1);
        lpchTarget[cchTarget-1] = 0;
        return TRUE; // success

    case fmtBit:
        {
            WORD i,j,shift=0; //shift will allow for a blank after each 8 bits
            for (i=0;i<cBits/8;i++)  {
                for(j=0;j<8;j++) {
                    if((lpbSource[i]>>j) & 0x1) {
                        rgch[i*8+j+shift]=_T('1');
                    } else {
                        rgch[i*8+j+shift]=_T('0');
                    }
                }
                rgch[(i+1)*8+shift]=_T(' ');
                shift++;
            }
            rgch[cBits+shift-1]=_T('\0');
            _tcscpy(lpchTarget,rgch);
        }
        return TRUE; // success

    default:

        return FALSE; // Bad format

    }

    return TRUE; // success
}                   /* CPFormatMemory() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\engine.h ===
//----------------------------------------------------------------------------
//
// Engine interface code.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __ENGINE_H__
#define __ENGINE_H__

#define RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define MAX_ENGINE_PATH 4096

//
// Session initialization parameters.
//

// Turn on verbose output or not.
extern BOOL g_Verbose;
// Dump file to open or NULL.
extern PTSTR g_DumpFile;
extern PTSTR g_DumpPageFile;
// Process server to use.
extern PSTR g_ProcessServer;
// Full command line with exe name.
extern PSTR g_DebugCommandLine;
// Process creation flags.
extern ULONG g_DebugCreateFlags;
// Process ID to attach to or zero.
extern ULONG g_PidToDebug;
// Process name to attach to or NULL.
extern PSTR g_ProcNameToDebug;
extern BOOL g_DetachOnExit;
extern ULONG g_AttachProcessFlags;
// Kernel connection options.
extern ULONG g_AttachKernelFlags;
extern PSTR g_KernelConnectOptions;

// Remoting options.
extern BOOL g_RemoteClient;
extern ULONG g_HistoryLines;

// Type options.
extern ULONG g_TypeOptions;
//
// Debug engine interfaces for the engine thread.
//
extern IDebugClient        *g_pDbgClient;
extern IDebugClient2       *g_pDbgClient2;
extern IDebugControl       *g_pDbgControl;
extern IDebugSymbols       *g_pDbgSymbols;
extern IDebugRegisters     *g_pDbgRegisters;
extern IDebugDataSpaces    *g_pDbgData;
extern IDebugSystemObjects *g_pDbgSystem;

//
// Debug engine interfaces for the UI thread.
//
extern IDebugClient        *g_pUiClient;
extern IDebugControl       *g_pUiControl;
extern IDebugSymbols       *g_pUiSymbols;
extern IDebugSymbols2      *g_pUiSymbols2;
extern IDebugSystemObjects *g_pUiSystem;

//
// Debug engine interfaces for private output capture.
//
extern IDebugClient        *g_pOutCapClient;
extern IDebugControl       *g_pOutCapControl;

//
// Debug engine interfaces for local source file lookup.
//
extern IDebugClient        *g_pLocClient;
extern IDebugControl       *g_pLocControl;
extern IDebugSymbols       *g_pLocSymbols;
extern IDebugClient        *g_pUiLocClient;
extern IDebugControl       *g_pUiLocControl;
extern IDebugSymbols       *g_pUiLocSymbols;

extern ULONG g_ActualProcType;
extern char g_ActualProcAbbrevName[32];
extern ULONG g_NumRegisters;
extern ULONG g_CommandSequence;
extern ULONG g_TargetClass;
extern ULONG g_TargetClassQual;
extern BOOL g_Ptr64;
extern ULONG g_ExecStatus;
extern ULONG g_EngOptModified;
extern ULONG g_EngineThreadId;
extern HANDLE g_EngineThread;
extern PSTR g_InitialCommand;
extern char g_PromptText[];
extern BOOL g_WaitingForEvent;
extern BOOL g_SessionActive;
extern ULONG g_NumberRadix;
extern BOOL g_IgnoreCodeLevelChange;
extern ULONG g_LastProcessExitCode;
extern BOOL g_CodeLevelLocked;

// Target exists and is not running.
#define IS_TARGET_HALTED() \
    (g_ExecStatus == DEBUG_STATUS_BREAK)

//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes.
//
//----------------------------------------------------------------------------

class DefOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

//----------------------------------------------------------------------------
//
// EventCallbacks.
//
//----------------------------------------------------------------------------

class EventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );

    STDMETHOD(CreateThread)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG64 DataOffset,
        IN ULONG64 StartOffset
        );
    STDMETHOD(ExitThread)(
        THIS_
        IN ULONG ExitCode
        );
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        );
    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        );
    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        );
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
};

extern EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Data space read/write support.
//
//----------------------------------------------------------------------------

//
// Begin types originally defined in NTIOAPI.H
//


//
// Define the I/O bus interface types.
//
typedef enum _INTERFACE_TYPE
{
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
} INTERFACE_TYPE, *PINTERFACE_TYPE;


//
// Define types of bus information.
//
typedef enum _BUS_DATA_TYPE
{
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

//
// End types originally defined in NTIOAPI.H
//

enum MEMORY_TYPE
{
    VIRTUAL_MEM_TYPE = 0,
    MIN_MEMORY_TYPE = 0, // Placed here so that symbol lookup finds this first
    PHYSICAL_MEM_TYPE,
    CONTROL_MEM_TYPE,
    IO_MEM_TYPE,
    MSR_MEM_TYPE,
    BUS_MEM_TYPE,
    MAX_MEMORY_TYPE
};


struct IO_MEMORY_DATA
{
    ULONG           BusNumber;
    ULONG           AddressSpace;
    INTERFACE_TYPE  interface_type;
};

struct BUS_MEMORY_DATA
{
    ULONG           BusNumber;
    ULONG           SlotNumber;
    BUS_DATA_TYPE   bus_type;
};

struct MSR_MEMORY_DATA
{
    // Placeholder in case data is needed later.
};

struct PHYSICAL_MEMORY_DATA
{
    // Placeholder in case data is needed later.
};

struct VIRTUAL_MEMORY_DATA
{
    // Placeholder in case data is needed later.
};

struct CONTROL_MEMORY_DATA
{
    ULONG           Processor;
};

struct ANY_MEMORY_DATA
{
    union
    {
        IO_MEMORY_DATA          io;
        BUS_MEMORY_DATA         bus;
        MSR_MEMORY_DATA         msr;
        CONTROL_MEMORY_DATA     control;
        PHYSICAL_MEMORY_DATA    physical;
        VIRTUAL_MEMORY_DATA     virt;
    };
};

//----------------------------------------------------------------------------
//
// Inter-thread communication.
//
// UI buffers are used for transferring information between the
// UI thread and the engine thread, such as commands and output.
// They have a separate lock to avoid contention with state filling.
// If state buffers had individual locks this would be unnecessary.
//
// The UI reads text output from the output buffer for display
// in the command window.
//
// The UI queues commands to the command buffer for execution
// by the engine.
//
//----------------------------------------------------------------------------

// This must be at least MAX_PATH, and also must
// be large enough for the largest single command window
// command expected.
#define MAX_COMMAND_LEN 4096

#define LockUiBuffer(Buffer) Dbg_EnterCriticalSection(&(Buffer)->m_Lock)
#define UnlockUiBuffer(Buffer) Dbg_LeaveCriticalSection(&(Buffer)->m_Lock)

extern class StateBuffer g_UiOutputBuffer;

// Commands from the UI to the engine.
enum UiCommand
{
    // Distinguish command input from other commands so
    // that the input callbacks have a specific token to
    // look for user input.
    UIC_CMD_INPUT,
    UIC_EXECUTE,
    UIC_SILENT_EXECUTE,
    UIC_INVISIBLE_EXECUTE,
    UIC_SET_REG,
    UIC_RESTART,
    UIC_END_SESSION,
    UIC_WRITE_DATA,
    UIC_SYMBOL_WIN,
    UIC_DISPLAY_CODE,
    UIC_DISPLAY_CODE_EXPR,
    UIC_SET_SCOPE,
    UIC_GET_SYM_PATH,
    UIC_SET_SYM_PATH,
    UIC_SET_FILTER,
    UIC_SET_FILTER_ARGUMENT,
    UIC_SET_FILTER_COMMAND,
};

struct UiCommandData
{
    UiCommand Cmd;
    ULONG Len;
};

struct UIC_SET_REG_DATA
{
    ULONG Reg;
    DEBUG_VALUE Val;
};

struct UIC_WRITE_DATA_DATA
{
    MEMORY_TYPE Type;
    ANY_MEMORY_DATA Any;
    ULONG64 Offset;
    ULONG Length;
    UCHAR Data[16];
};

enum SYMBOL_WIN_CALL_TYPE
{
    ADD_SYMBOL_WIN,
    DEL_SYMBOL_WIN_INDEX,
    DEL_SYMBOL_WIN_NAME,
    QUERY_NUM_SYMBOL_WIN,
    GET_NAME,
    GET_PARAMS,
    EXPAND_SYMBOL,
    EDIT_SYMBOL,
    EDIT_TYPE,
    DEL_SYMBOL_WIN_ALL
};

typedef struct UIC_SYMBOL_WIN_DATA
{
    SYMBOL_WIN_CALL_TYPE Type;
    PDEBUG_SYMBOL_GROUP *pSymbolGroup;
    union
    {
        struct
        {
            PCSTR Name;
            ULONG Index;
        } Add;
        PCSTR DelName;
        ULONG DelIndex;
        PULONG NumWatch;
        struct
        {
            ULONG Index;
            PSTR Buffer;
            ULONG BufferSize;
            PULONG NameSize;
        } GetName;
        struct
        {
            ULONG Start;
            ULONG Count;
            PDEBUG_SYMBOL_PARAMETERS SymbolParams;
        } GetParams;
        struct
        {
            ULONG Index;
            BOOL  Expand;
        } ExpandSymbol;
        struct
        {
            ULONG Index;
            PSTR  Value;
        } WriteSymbol;
        struct
        {
            ULONG Index;
            PSTR  Type;
        } OutputAsType;
    } u;
} UIC_SYMBOL_WIN_DATA;

struct UIC_DISPLAY_CODE_DATA
{
    ULONG64 Offset;
};

struct UIC_SET_SCOPE_DATA
{
    DEBUG_STACK_FRAME StackFrame;
};

struct UIC_SET_FILTER_DATA
{
    ULONG Index;
    ULONG Code;
    ULONG Execution;
    ULONG Continue;
};

struct UIC_SET_FILTER_ARGUMENT_DATA
{
    ULONG Index;
    char Argument[1];
};

struct UIC_SET_FILTER_COMMAND_DATA
{
    ULONG Which;
    ULONG Index;
    char Command[1];
};

PVOID StartCommand(UiCommand Cmd, ULONG Len);
void FinishCommand(void);

BOOL AddStringCommand(UiCommand Cmd, PCSTR Str);
BOOL AddStringMultiCommand(UiCommand Cmd, PSTR Str);
BOOL __cdecl PrintStringCommand(UiCommand Cmd, PCSTR Format, ...);

#define StartStructCommand(Struct) \
    ((Struct ## _DATA*)StartCommand(Struct, sizeof(Struct ## _DATA)))

#define AddEnumCommand(Cmd) \
    (StartCommand(Cmd, 0) != NULL ? (FinishCommand(), TRUE) : FALSE)

// Wake up the UI thread to do UI processing.
#define UpdateUi() \
    PostMessage(g_hwndFrame, WM_NOTIFY, 0, 0)

// Wake up the engine thread to do engine processing.
void UpdateEngine(void);

void ProcessEngineCommands(BOOL Internal);
void DiscardEngineState(void);
DWORD WINAPI EngineLoop(LPVOID Param);

#endif // #ifndef __ENGINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\memlist.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\memwin.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    Memwin.cpp

Abstract:

    This module contains the main line code for display of multiple memory
    windows and the subclassed win proc to handle editing, display, etc.

--*/


#include "precomp.hxx"
#pragma hdrstop

_INTERFACE_TYPE_NAMES rgInterfaceTypeNames[MaximumInterfaceType] =
{
    { Internal,             "Internal" },
    { Isa,                  "Isa" },
    { Eisa,                 "Eisa" },
    { MicroChannel,         "MicroChannel" },
    { TurboChannel,         "TurboChannel" },
    { PCIBus,               "PCIBus" },
    { VMEBus,               "VMEBus" },
    { NuBus,                "NuBus" },
    { PCMCIABus,            "PCMCIABus" },
    { CBus,                 "CBus" },
    { MPIBus,               "MPIBus" },
    { MPSABus,              "MPSABus" },
    { ProcessorInternal,    "ProcessorInternal" },
    { InternalPowerBus,     "InternalPowerBus" },
    { PNPISABus,            "PNPISABus" },
    { PNPBus,               "PNPBus" }
};

_BUS_TYPE_NAMES rgBusTypeNames[MaximumBusDataType] =
{
    { Cmos,                     "Cmos" },
    { EisaConfiguration,        "EisaConfiguration" },
    { Pos,                      "Pos" },
    { CbusConfiguration,        "CbusConfiguration" },
    { PCIConfiguration,         "PCIConfiguration" },
    { VMEConfiguration,         "VMEConfiguration" },
    { NuBusConfiguration,       "NuBusConfiguration" },
    { PCMCIAConfiguration,      "PCMCIAConfiguration" },
    { MPIConfiguration,         "MPIConfiguration" },
    { MPSAConfiguration,        "MPSAConfiguration" },
    { PNPISAConfiguration,      "PNPISAConfiguration" },
    { SgiInternalConfiguration, "SgiInternalConfiguration" }
};

PSTR g_MemTypeNames[] =
{
    "Virtual:", "Physical:", "Control:", "I/O:", "MSR:", "Bus data:"
};


//
//
//
MEMWIN_DATA::MEMWIN_DATA()
    : EDITWIN_DATA(512)
{
    m_enumType = MEM_WINDOW;

    ZeroMemory(&m_GenMemData, sizeof(m_GenMemData));
    
    strcpy(m_OffsetExpr, FormatAddr64(g_EventIp));
    m_GenMemData.memtype = VIRTUAL_MEM_TYPE;
    m_GenMemData.nDisplayFormat = 2;
    m_Columns = 4;
    m_WindowDataSize = 0;
}

void
MEMWIN_DATA::Validate()
{
    EDITWIN_DATA::Validate();

    Assert(MEM_WINDOW == m_enumType);
}

HRESULT
MEMWIN_DATA::ReadState(void)
{
    HRESULT Status;
    ULONG DataSize;
    ULONG DataNeeded;
    PVOID Data;
    ULONG64 Offset;
    DEBUG_VALUE Value;
    ULONG i;

    // Evaluate offset expression.
    if ((Status = g_pDbgControl->Evaluate(m_OffsetExpr, DEBUG_VALUE_INT64,
                                          &Value, NULL)) != S_OK)
    {
        return Status;
    }
    
    Offset = Value.I64;
    
    // Compute how much data to retrieve.  We don't want to
    // create a big matrix of memtype/display format so just
    // ask for a chunk of data big enough for any display format.
    DataNeeded = m_LineHeight * m_Columns * 2 * sizeof(ULONG64);

    Empty();
    Data = AddData(DataNeeded);
    if (Data == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ULONG Read;
    
    switch(m_GenMemData.memtype)
    {
    default:
        Assert(!"Unhandled condition");
        Status = E_FAIL;
        break;

    case PHYSICAL_MEM_TYPE:
        Status = g_pDbgData->ReadPhysical(Offset,
                                          Data, 
                                          DataNeeded, 
                                          &Read
                                          );
        break;

    case VIRTUAL_MEM_TYPE:
        Status = g_pDbgData->ReadVirtual(Offset,
                                         Data, 
                                         DataNeeded, 
                                         &Read
                                         );
        break;

    case CONTROL_MEM_TYPE:
        Status = g_pDbgData->ReadControl(m_GenMemData.any.control.Processor, 
                                         Offset,
                                         Data, 
                                         DataNeeded, 
                                         &Read
                                         );
        break;

    case IO_MEM_TYPE:
        Status = g_pDbgData->ReadIo(m_GenMemData.any.io.interface_type,
                                    m_GenMemData.any.io.BusNumber,
                                    m_GenMemData.any.io.AddressSpace,
                                    Offset,
                                    Data, 
                                    DataNeeded, 
                                    &Read
                                    );
        break;

    case MSR_MEM_TYPE:
        Read = 0;
        for (i = 0; i < DataNeeded / sizeof(ULONG64); i++)
        {
            if ((Status = g_pDbgData->ReadMsr((ULONG)Offset + i,
                                              (PULONG64)Data + i
                                              )) != S_OK)
            {
                // Assume an error means we've run out of MSRs to
                // read.  If some were read, don't consider it an error.
                if (Read > 0)
                {
                    Status = S_OK;
                }
                break;
            }

            Read += sizeof(ULONG64);
        }
        break;

    case BUS_MEM_TYPE:
        Status = g_pDbgData->ReadBusData(m_GenMemData.any.bus.bus_type,
                                         m_GenMemData.any.bus.BusNumber,
                                         m_GenMemData.any.bus.SlotNumber,
                                         (ULONG)Offset,
                                         Data, 
                                         DataNeeded, 
                                         &Read
                                         );
        break;
    }
    
    if (Status == S_OK)
    {
        // Trim data back if read didn't get everything.
        RemoveTail(DataNeeded - Read);
        m_OffsetRead = Offset;
    }

    return Status;
}

BOOL 
MEMWIN_DATA::HasEditableProperties()
{
    return TRUE;
}

BOOL 
MEMWIN_DATA::EditProperties()
/*++
Returns
    TRUE - If properties were edited
    FALSE - If nothing was changed
--*/
{
    if (g_TargetClass != DEBUG_CLASS_UNINITIALIZED)
    {
        INT_PTR Res = DisplayOptionsPropSheet(GetParent(m_hwndChild),
                                              g_hInst,
                                              m_GenMemData.memtype
                                              );
        if (IDOK == Res)
        {
            UpdateOptions();
            return TRUE; // Properties have been changed
        }
    }
    
    MessageBeep(0);
    return FALSE;         // No Debuggee or User Cancel out.
}

BOOL
MEMWIN_DATA::OnCreate(void)
{
    RECT Rect;
    int i;
    ULONG Height;

    Height = GetSystemMetrics(SM_CYVSCROLL) + 4 * GetSystemMetrics(SM_CYEDGE);
    
    m_Toolbar = CreateWindowEx(0, REBARCLASSNAME, NULL,
                               WS_VISIBLE | WS_CHILD |
                               WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                               CCS_NODIVIDER | CCS_NOPARENTALIGN |
                               RBS_VARHEIGHT | RBS_BANDBORDERS,
                               0, 0, m_Size.cx, Height, m_Win,
                               (HMENU)ID_TOOLBAR,
                               g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }

    REBARINFO BarInfo;
    BarInfo.cbSize = sizeof(BarInfo);
    BarInfo.fMask = 0;
    BarInfo.himl = NULL;
    SendMessage(m_Toolbar, RB_SETBARINFO, 0, (LPARAM)&BarInfo);

    REBARBANDINFO BandInfo;
    BandInfo.cbSize = sizeof(BandInfo);
    BandInfo.fMask = RBBIM_TEXT | RBBIM_CHILD | RBBIM_CHILDSIZE;
    
    m_ToolbarEdit = CreateWindowEx(WS_EX_CLIENTEDGE, "EDIT", NULL,
                                   WS_VISIBLE | WS_CHILD | ES_AUTOHSCROLL,
                                   0, 0, 18 *
                                   m_Font->Metrics.tmAveCharWidth,
                                   Height, m_Toolbar, (HMENU)IDC_EDIT_OFFSET,
                                   g_hInst, NULL);
    if (m_ToolbarEdit == NULL)
    {
        return FALSE;
    }

    SendMessage(m_ToolbarEdit, WM_SETFONT, (WPARAM)m_Font->Font, 0);
    SendMessage(m_ToolbarEdit, EM_LIMITTEXT, sizeof(m_OffsetExpr) - 1, 0);
    
    GetClientRect(m_ToolbarEdit, &Rect);
    
    BandInfo.lpText = "Offset:";
    BandInfo.hwndChild = m_ToolbarEdit;
    BandInfo.cxMinChild = Rect.right - Rect.left;
    BandInfo.cyMinChild = Rect.bottom - Rect.top;
    SendMessage(m_Toolbar, RB_INSERTBAND, -1, (LPARAM)&BandInfo);

    m_FormatCombo = CreateWindowEx(0, "COMBOBOX", NULL,
                                   WS_VISIBLE | WS_CHILD | WS_VSCROLL |
                                   CBS_SORT | CBS_DROPDOWNLIST, 0, 0,
                                   15 * m_Font->Metrics.tmAveCharWidth,
                                   (g_nMaxNumFormatsMemWin *
                                    m_Font->Metrics.tmHeight / 2),
                                   m_Toolbar, (HMENU)IDC_COMBO_DISPLAY_FORMAT,
                                   g_hInst, NULL);
    if (m_FormatCombo == NULL)
    {
        return FALSE;
    }

    SendMessage(m_FormatCombo, WM_SETFONT, (WPARAM)m_Font->Font, 0);
    
    for (i = 0; i < g_nMaxNumFormatsMemWin; i++)
    {
        LRESULT Idx;

        // The format strings will be sorted so mark them with
        // their true index for retrieval when selected.
        Idx = SendMessage(m_FormatCombo, CB_ADDSTRING,
                          0, (LPARAM)g_FormatsMemWin[i].lpszDescription);
        SendMessage(m_FormatCombo, CB_SETITEMDATA, (WPARAM)Idx, i);
    }
    
    GetClientRect(m_FormatCombo, &Rect);
    
    BandInfo.lpText = "Display format:";
    BandInfo.hwndChild = m_FormatCombo;
    BandInfo.cxMinChild = Rect.right - Rect.left;
    BandInfo.cyMinChild = Rect.bottom - Rect.top;
    SendMessage(m_Toolbar, RB_INSERTBAND, -1, (LPARAM)&BandInfo);

    PSTR PrevText = "Previous";
    m_PreviousButton =
        AddButtonBand(m_Toolbar, PrevText, PrevText, IDC_MEM_PREVIOUS);
    m_NextButton =
        AddButtonBand(m_Toolbar, "Next", PrevText, IDC_MEM_NEXT);
    if (m_PreviousButton == NULL || m_NextButton == NULL)
    {
        return FALSE;
    }

    // Maximize the space for the offset expression.
    SendMessage(m_Toolbar, RB_MAXIMIZEBAND, 0, FALSE);
    
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top + GetSystemMetrics(SM_CYEDGE);
    m_ShowToolbar = TRUE;
    
    if (!EDITWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    // Switch background color back to window default as
    // this window does not use custom colors.
    SendMessage(m_hwndChild, EM_SETBKGNDCOLOR, FALSE,
                
                
                GetSysColor(COLOR_WINDOW));
    SendMessage(m_hwndChild, EM_SETEVENTMASK, 0, ENM_KEYEVENTS);
    UpdateOptions();
    return TRUE;
}

LRESULT
MEMWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(LOWORD(wParam))
    {
    case IDC_EDIT_OFFSET:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            // This message is sent on every keystroke
            // which causes a bit too much updating.
            // Set up a timer to trigger the actual
            // update in half a second.
            SetTimer(m_Win, IDC_EDIT_OFFSET, EDIT_DELAY, NULL);
            m_UpdateExpr = TRUE;
        }
        break;
        
    case IDC_COMBO_DISPLAY_FORMAT:
        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            LRESULT Sel = SendMessage((HWND)lParam, CB_GETCURSEL, 0, 0);
            if (Sel != CB_ERR)
            {
                m_GenMemData.nDisplayFormat = (int)
                    SendMessage((HWND)lParam, CB_GETITEMDATA, (WPARAM)Sel, 0);
                UpdateOptions();
                UiRequestRead();
            }
        }
        break;
        
    case IDC_MEM_PREVIOUS:
        ScrollLower();
        break;
    case IDC_MEM_NEXT:
        ScrollHigher();
        break;
    }

    return 0;
}

void
MEMWIN_DATA::OnSize(void)
{
    EDITWIN_DATA::OnSize();

    // Force buffer to refill for new line count.
    UiRequestRead();
}

void
MEMWIN_DATA::OnTimer(WPARAM TimerId)
{
    char Buffer[MAX_OFFSET_EXPR];
    
    if (TimerId == IDC_EDIT_OFFSET && m_UpdateExpr)
    {
        m_UpdateExpr = FALSE;
        if (SendMessage(m_ToolbarEdit, EM_GETMODIFY, 0,0)) 
        {
            GetWindowText(m_ToolbarEdit, m_OffsetExpr, sizeof(m_OffsetExpr));
            SendMessage(m_ToolbarEdit, EM_SETMODIFY, 0,0); 
            UiRequestRead();
        }
//      KillTimer(m_Win, IDC_EDIT_OFFSET);
    }
}

LRESULT
MEMWIN_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    LPNMHDR Hdr = (LPNMHDR)Lpm;

    switch(Hdr->code)
    {
    case RBN_HEIGHTCHANGE:
        PostMessage(m_Win, WU_RECONFIGURE, 0, 0);
        break;
    case EN_MSGFILTER:
        MSGFILTER* Filter = (MSGFILTER*)Lpm;

        if (Filter->msg == WM_KEYDOWN)
        {
            switch(Filter->wParam)
            {
            case VK_UP:
            {
                CHARRANGE range;

                SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &range);
                if (!SendMessage(m_hwndChild, EM_LINEFROMCHAR,
                                 range.cpMin, 0)) 
                {
                    // up arrow on top line, scroll
                    ScrollLower();
                    return TRUE;
                }
                break;
            }
            case VK_DOWN:
            {
                CHARRANGE range;
                int MaxLine;

                SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &range);
                MaxLine = (int)SendMessage(m_hwndChild, EM_GETLINECOUNT, 0, 0);

                if (MaxLine == (1 + SendMessage(m_hwndChild, EM_LINEFROMCHAR,
                                                range.cpMin, 0)))
                {
                    // down arrow on bottom line, scroll
                    ScrollHigher();
                    return TRUE;
                }
                break;
            }
        
            case VK_PRIOR:
                ScrollLower();
                return TRUE;
            case VK_NEXT:
                ScrollHigher();
                return TRUE;
                
            case VK_LEFT: case VK_RIGHT:
                break;
            case VK_DELETE:
                MessageBeep(0);
                return TRUE;
            default:
                // Allow default processing of everything else
                return TRUE;
            }
        }
        else if (Filter->msg == WM_KEYUP)
        {
            return TRUE;
        }

        if (ES_READONLY & GetWindowLongPtr(m_hwndChild, GWL_STYLE)) 
        {
            break;
        }
        if (Filter->msg == WM_CHAR)
        {
            switch(Filter->wParam)
            {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
            case 'a': case 'A': case 'b': case 'B': case 'c':
            case 'C': case 'd': case 'D': case 'e': case 'E':
            case 'f': case 'F':
            {
                CHARRANGE value;
                ULONG charIndex;
                ULONG64 Address; 
                CHAR writeval[2] = {0};

                writeval[0] = (CHAR) tolower((CHAR) Filter->wParam);
                Address = GetAddressOfCurValue(&charIndex, &value);
                if (Address) 
                {
                    TEXTRANGE textRange;

                    SendMessage(m_hwndChild, EM_SETSEL,
                                charIndex, charIndex+1);
                    SendMessage(m_hwndChild, EM_REPLACESEL,
                                FALSE, (LPARAM) &writeval); 
                    
                    textRange.chrg = value;
                    textRange.lpstrText = &m_ValueExpr[0];
                    if (SendMessage(m_hwndChild, EM_GETTEXTRANGE,
                                    0, (LPARAM) &textRange))
                    {
                        m_ValueExpr[charIndex - value.cpMin] = writeval[0];
                        WriteValue(Address);
                        SendMessage(m_hwndChild, EM_SETSEL,
                                    charIndex+1, charIndex+1);
                        return TRUE;
                    }
                }
            }

            default:
                MessageBeep(0);
                return TRUE;
            }
        }
        break;
    }
    
    return EDITWIN_DATA::OnNotify(Wpm, Lpm);
}

void
MEMWIN_DATA::OnUpdate(
    UpdateType Type
    )
{
    if (Type != UPDATE_BUFFER)
    {
        return;
    }
    
    HRESULT Status;
    
    Status = UiLockForRead();
    if (Status == S_OK)
    {
        ULONG charIndex;
        SendMessage(m_hwndChild, EM_GETSEL, (WPARAM) &charIndex, NULL);
        
        SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

        CHARRANGE Sel;
            
        // Select everything so it's all replaced.
        Sel.cpMin = 0;
        Sel.cpMax = -1;
        SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Sel);

        TCHAR Buf[64];
        TCHAR CharBuf[64];
        TCHAR* ColChar;
        ULONG Row, Col;
        ULONG64 Offset;
        ULONG64 DataEnd;
        PUCHAR Data;
        ULONG Bytes;
        _FORMATS_MEM_WIN* Fmt = g_FormatsMemWin + m_GenMemData.nDisplayFormat;

        Offset = m_OffsetRead;
        Data = (PUCHAR)m_Data;
        DataEnd = Offset + m_DataUsed;
        Bytes = (Fmt->cBits + 7) / 8;
        
        for (Row = 0; Row < m_LineHeight; Row++)
        {
            SendMessage(m_hwndChild, EM_REPLACESEL, FALSE,
                        (LPARAM)FormatAddr64(Offset));

            ColChar = CharBuf;
            *ColChar++ = ' ';
            *ColChar++ = ' ';
            
            for (Col = 0; Col < m_Columns; Col++)
            {
                if (Offset < DataEnd)
                {
                    _tcscpy(Buf, _T(" "));
                    
                    // If the formatting succeeds,
                    // Buf contains the formatted data.
                    if (!CPFormatMemory(Buf + 1,
                                        (DWORD)min(_tsizeof(Buf) - 1,
                                                   Fmt->cchMax + 1),
                                        Data,
                                        Fmt->cBits,
                                        Fmt->fmtType,
                                        Fmt->radix))
                    {
                        // Else we don't know what to format
                        for (UINT uTmp = 0; uTmp < Bytes; uTmp++)
                        {
                            m_AllowWrite = FALSE;
                            _tcscat(Buf + 1, _T("??"));
                        }
                    }

                    if (Fmt->fTwoFields)
                    {
                        if (!CPFormatMemory(ColChar, 1, Data, 8,
                                            fmtAscii, 0))
                        {
                            *ColChar = '?';
                        }

                        ColChar++;
                    }
                }
                else
                {
                    m_AllowWrite = FALSE;
                    _tcscpy(Buf, _T(" ????????"));
                    *ColChar++ = '?';
                }
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)Buf);
                
                Data += Bytes;
                Offset += Bytes;
            }

            if (Fmt->fTwoFields)
            {
                *ColChar = 0;
                SendMessage(m_hwndChild, EM_REPLACESEL,
                            FALSE, (LPARAM)CharBuf);
            }
            
            // Don't complete the last line to avoid leaving
            // a blank line at the bottom.
            if (Row < m_LineHeight - 1)
            {
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)"\n");
            }
        }

        m_WindowDataSize = (ULONG)(Offset - m_OffsetRead);
        
        UnlockStateBuffer(this);
        
        SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
        InvalidateRect(m_hwndChild, NULL, TRUE);
        
        SendMessage(m_hwndChild, EM_SETSEL, charIndex, charIndex);
    }
    else
    {
        SendLockStatusMessage(m_hwndChild, WM_SETTEXT, Status);
    }
}

void
MEMWIN_DATA::UpdateColors(void)
{
    // Do not change colors.
}
    
void
MEMWIN_DATA::ScrollLower(void)
{
    ULONG64 Offs = m_OffsetRead;
    
    if (Offs >= m_WindowDataSize)
    {
        Offs -= m_WindowDataSize;
    }
    else
    {
        Offs = 0;
    }
    sprintf(m_OffsetExpr, "0x%I64x", Offs);
    UiRequestRead();
}

void
MEMWIN_DATA::ScrollHigher(void)
{
    ULONG64 Offs = m_OffsetRead;
    
    if (Offs + m_WindowDataSize > Offs)
    {
        Offs += m_WindowDataSize;
    }
    else
    {
        Offs = (ULONG64)-1 - m_WindowDataSize;
    }
    sprintf(m_OffsetExpr, "0x%I64x", Offs);
    UiRequestRead();
}

void
MEMWIN_DATA::UpdateOptions(void)
{
    REBARBANDINFO BandInfo;

    BandInfo.cbSize = sizeof(BandInfo);
    BandInfo.fMask = RBBIM_TEXT;
    BandInfo.lpText = g_MemTypeNames[m_GenMemData.memtype];
    SendMessage(m_Toolbar, RB_SETBANDINFO, 0, (LPARAM)&BandInfo);
    SetWindowText(m_ToolbarEdit, m_OffsetExpr);

    m_AllowWrite = (m_GenMemData.memtype == PHYSICAL_MEM_TYPE ||
        m_GenMemData.memtype == VIRTUAL_MEM_TYPE) &&  
        ((g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType & fmtBasis) == fmtUInt ||
         (g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType & fmtBasis) == fmtInt ||
         (g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType & fmtBasis) == fmtAddress
         ) &&
        g_FormatsMemWin[m_GenMemData.nDisplayFormat].radix == 16;
    
    SendMessage(m_hwndChild, EM_SETREADONLY, !m_AllowWrite, 0);

    for (LONG Idx = 0; Idx < g_nMaxNumFormatsMemWin; Idx++)
    {
        if ((LONG)SendMessage(m_FormatCombo, CB_GETITEMDATA, Idx, 0) ==
            m_GenMemData.nDisplayFormat)
        {
            SendMessage(m_FormatCombo, CB_SETCURSEL, Idx, 0);
            break;
        }
    }

    switch(m_GenMemData.memtype)
    {
    case MSR_MEM_TYPE:
        m_Columns = 1;
        break;
    default:
        if ((g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType &
             fmtBasis) == fmtAscii ||
            (g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType &
             fmtBasis) == fmtUnicode ||
            g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits == 8)
        {
            m_Columns = 16;
        }
        else if (g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits == 16)
        {
            m_Columns = 8;
        }
        else if (g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits > 64)
        {
            m_Columns = 2;
        }
        else
        {
            m_Columns = 4;
        }
        break;
    }
}

void
MEMWIN_DATA::WriteValue(
    ULONG64 Offset
    )
{
    if (!m_AllowWrite) 
    {
        return;
    }
    ULONG64 Data;
    ULONG Size;
    DEBUG_VALUE Value;

    // Evaluate value expression.
    if (g_pDbgControl->Evaluate(m_ValueExpr, DEBUG_VALUE_INT64,
                                &Value, NULL) != S_OK)
    {
        return;
    }
    Data = Value.I64;
    Size = g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits / 8;
    UIC_WRITE_DATA_DATA* WriteData;

    WriteData = StartStructCommand(UIC_WRITE_DATA);
    if (WriteData == NULL)
    {
        return;
    }

    // Fill in WriteData members.
    memcpy(WriteData->Data, &Data, Size);
    WriteData->Length = Size;
    WriteData->Offset = Offset;
    WriteData->Type = m_GenMemData.memtype;
    WriteData->Any  = m_GenMemData.any;
    FinishCommand();
}

ULONG64 
MEMWIN_DATA::GetAddressOfCurValue(
    PULONG pCharIndex,
    CHARRANGE *pCRange
    )
{
    CHARRANGE range;
    ULONG CurLine, FirstLineChar, CurCol;

    SendMessage(m_hwndChild, EM_EXGETSEL, NULL, (LPARAM) &range);
    CurLine = (ULONG)SendMessage(m_hwndChild, EM_LINEFROMCHAR, range.cpMin, 0);
    FirstLineChar = (ULONG)SendMessage(m_hwndChild, EM_LINEINDEX, CurLine, 0);
    CurCol = range.cpMin - FirstLineChar;

    ULONG Length;
    PCHAR pLineTxt = (PCHAR)
        malloc(Length = ((ULONG)SendMessage(m_hwndChild, EM_LINELENGTH,
                                            FirstLineChar, 0) + 2));

    if (!pLineTxt) 
    {
        return 0;
    }

    Assert(Length >= CurCol);

    ZeroMemory(pLineTxt, Length);
 //   Assert (Length = (ULONG) SendMessage(m_hwndChild, EM_GETLINE, (WPARAM) CurLine, (LPARAM) pLineTxt)); 
    TEXTRANGE textrange;
    textrange.chrg.cpMin = FirstLineChar;
    textrange.chrg.cpMax = FirstLineChar + Length-2;
    textrange.lpstrText = (LPSTR) pLineTxt;
    SendMessage(m_hwndChild, EM_GETTEXTRANGE, 0, (LPARAM) &textrange);

    ULONG ValueCol=0, Index=0, ValueIndex=0;
    while (pLineTxt[CurCol] == ' ') 
    {
        CurCol++;
    }
    while (Index < CurCol) 
    { 
        if (pLineTxt[Index] == ' ') 
        {
            if (ValueIndex != Index) 
            {
                ValueCol++;
            }
            ValueIndex = Index+1;
        }
        ++Index;
    }
    
    if (!ValueIndex || !pLineTxt[CurCol]) // cursor on address column
    { 
        free (pLineTxt);
        return 0;    
    }
    
    ULONG Bytes;
    Bytes = (g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits + 7) / 8;

    ULONG64 Offset;
    Offset = m_OffsetRead + (CurLine * Bytes * m_Columns) + (ValueCol - 1)*Bytes;

    for (Index = ValueIndex; pLineTxt[Index] && pLineTxt[Index] != ' '; Index++) ;
    memcpy(m_ValueExpr, pLineTxt+ValueIndex, Index - ValueIndex);
    m_ValueExpr[Index-ValueIndex]=0;

    free (pLineTxt);
    if (pCharIndex) 
    {
        *pCharIndex = FirstLineChar + CurCol;
    }
    if (pCRange) 
    {
        pCRange->cpMin = FirstLineChar + CurCol - (CurCol - ValueIndex);
        pCRange->cpMax = pCRange->cpMin + Index - ValueIndex;
    }
    return Offset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\menu.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    Menu.c

Abstract:

    This module contains the support for Windbg's menu.

--*/

#include "precomp.hxx"
#pragma hdrstop

MRU_ENTRY* g_MruFiles[MAX_MRU_FILES];
HMENU g_MruMenu;

//
// EnableMenuItemTable contains the menu IDs for all menu items whose
// enabled state needs to be determined dynamically i.e. based on the state
// of Windbg.
//

UINT
g_EnableMenuItemTable[ ] =
{
    IDM_FILE_CLOSE,
    IDM_FILE_OPEN_EXECUTABLE,
    IDM_FILE_ATTACH,
    IDM_FILE_OPEN_CRASH_DUMP,
    IDM_FILE_CONNECT_TO_REMOTE,
    IDM_FILE_KERNEL_DEBUG,
    IDM_FILE_SAVE_WORKSPACE,
    IDM_FILE_SAVE_WORKSPACE_AS,
    IDM_FILE_CLEAR_WORKSPACE,

    IDM_EDIT_CUT,
    IDM_EDIT_COPY,
    IDM_EDIT_PASTE,
    IDM_EDIT_SELECT_ALL,
    IDM_EDIT_ADD_TO_COMMAND_HISTORY,
    IDM_EDIT_CLEAR_COMMAND_HISTORY,
    IDM_EDIT_FIND,
    IDM_EDIT_GOTO_ADDRESS,
    IDM_EDIT_GOTO_LINE,
    IDM_EDIT_BREAKPOINTS,
    IDM_EDIT_PROPERTIES,

    IDM_VIEW_TOGGLE_VERBOSE,
    IDM_VIEW_SHOW_VERSION,

    IDM_DEBUG_GO,
    IDM_DEBUG_GO_UNHANDLED,
    IDM_DEBUG_GO_HANDLED,
    IDM_DEBUG_RESTART,
    IDM_DEBUG_STOPDEBUGGING,
    IDM_DEBUG_BREAK,
    IDM_DEBUG_STEPINTO,
    IDM_DEBUG_STEPOVER,
    IDM_DEBUG_STEPOUT,
    IDM_DEBUG_RUNTOCURSOR,
    IDM_DEBUG_SOURCE_MODE,
    IDM_DEBUG_SOURCE_MODE_ON,
    IDM_DEBUG_SOURCE_MODE_OFF,
    IDM_DEBUG_EVENT_FILTERS,
    IDM_DEBUG_MODULES,
    IDM_KDEBUG_TOGGLE_BAUDRATE,
    IDM_KDEBUG_TOGGLE_INITBREAK,
    IDM_KDEBUG_RECONNECT,

    IDM_WINDOW_CASCADE,
    IDM_WINDOW_TILE_HORZ,
    IDM_WINDOW_TILE_VERT,
    IDM_WINDOW_ARRANGE,
    IDM_WINDOW_ARRANGE_ICONS,
    IDM_WINDOW_AUTO_ARRANGE,
    IDM_WINDOW_ARRANGE_ALL,
    IDM_WINDOW_OVERLAY_SOURCE,
    IDM_WINDOW_AUTO_DISASM,
};

#define ELEMENTS_IN_ENABLE_MENU_ITEM_TABLE          \
    ( sizeof( g_EnableMenuItemTable ) / sizeof( g_EnableMenuItemTable[ 0 ] ))


UINT
CommandIdEnabled(
    IN UINT uMenuID
    )

/*++

Routine Description:

    Determines if a menu item is enabled/disabled based on the current
    state of the debugger.

Arguments:

    uMenuID - Supplies a menu id whose state is to be determined.

Return Value:

    UINT - Returns ( MF_ENABLED | MF_BYCOMMAND ) if the supplied menu ID
        is enabled, ( MF_GRAYED | MF_BYCOMMAND) otherwise.

--*/
{
    BOOL fEnabled;
    HWND hwndChild = MDIGetActive(g_hwndMDIClient, NULL);
    PCOMMONWIN_DATA pCommonWinData;
    WIN_TYPES nDocType;

    nDocType = MINVAL_WINDOW;
    pCommonWinData = NULL;
    if (hwndChild != NULL)
    {
        pCommonWinData = GetCommonWinData(hwndChild);
        if (pCommonWinData != NULL)
        {
            nDocType = pCommonWinData->m_enumType;
        }
    }


    //
    // Assume menu item is not enabled.
    //

    fEnabled = FALSE;

    switch( uMenuID )
    {
    case IDM_FILE_SAVE_WORKSPACE:
    case IDM_FILE_SAVE_WORKSPACE_AS:
    case IDM_FILE_CLEAR_WORKSPACE:
        fEnabled = g_Workspace != NULL;
        break;
        
    case IDM_DEBUG_SOURCE_MODE:
    case IDM_DEBUG_SOURCE_MODE_ON:
    case IDM_DEBUG_SOURCE_MODE_OFF:
        fEnabled = TRUE;

        CheckMenuItem(g_hmenuMain, 
                      IDM_DEBUG_SOURCE_MODE,
                      GetSrcMode_StatusBar() ? MF_CHECKED : MF_UNCHECKED
                      );
        break;

    case IDM_FILE_CLOSE:
        fEnabled = (NULL != hwndChild);
        break;

    case IDM_FILE_OPEN_EXECUTABLE:
    case IDM_FILE_ATTACH:
    case IDM_FILE_OPEN_CRASH_DUMP:
    case IDM_FILE_CONNECT_TO_REMOTE:
    case IDM_FILE_KERNEL_DEBUG:
        fEnabled = g_TargetClass == DEBUG_CLASS_UNINITIALIZED &&
            !g_RemoteClient;
        break;

    case IDM_EDIT_CUT:
        if ( pCommonWinData )
        {
            fEnabled = pCommonWinData->CanCut();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;

    case IDM_EDIT_COPY:
        if ( pCommonWinData )
        {
            fEnabled = pCommonWinData->CanCopy();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;

    case IDM_EDIT_PASTE:
        //
        // If the window is normal, is not read only and is a document
        // or cmdwin, determine if the clipboard contains pastable data
        // (i.e. clipboard format CF_TEXT).
        //

        if ( !(pCommonWinData && pCommonWinData->CanPaste()) )
        {
            fEnabled = FALSE;
        }
        else
        {
            fEnabled = FALSE;
            if (OpenClipboard(g_hwndFrame))
            {
                UINT uFormat = 0;
                while ( uFormat = EnumClipboardFormats( uFormat ))
                {
                    if ( uFormat == CF_TEXT )
                    {
                        fEnabled = TRUE;
                        break;
                    }
                }
                CloseClipboard();
            }
        }
        break;

    case IDM_EDIT_SELECT_ALL:
        if ( pCommonWinData )
        {
            fEnabled = pCommonWinData->CanSelectAll();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;

    case IDM_EDIT_ADD_TO_COMMAND_HISTORY:
    case IDM_EDIT_CLEAR_COMMAND_HISTORY:
        fEnabled = GetCmdHwnd() != NULL;
        break;

    case IDM_EDIT_GOTO_LINE:
        fEnabled = pCommonWinData != NULL && pCommonWinData->CanGotoLine();
        break;
        
    case IDM_EDIT_FIND:
        fEnabled = hwndChild != NULL;
        break;
        
    case IDM_EDIT_GOTO_ADDRESS:
        fEnabled = g_TargetClass != DEBUG_CLASS_UNINITIALIZED;
        break;
        
    case IDM_EDIT_BREAKPOINTS:
        fEnabled = IS_TARGET_HALTED();
        break;
        
    case IDM_EDIT_PROPERTIES:
        if (pCommonWinData)
        {
            fEnabled = pCommonWinData->HasEditableProperties();
        }
        else
        {
            fEnabled = FALSE;
        }
        break;

    case IDM_VIEW_TOGGLE_VERBOSE:
    case IDM_VIEW_SHOW_VERSION:
        fEnabled = g_TargetClass != DEBUG_CLASS_UNINITIALIZED;
        break;
        
    case IDM_DEBUG_GO:
    case IDM_DEBUG_GO_HANDLED:
    case IDM_DEBUG_GO_UNHANDLED:
        fEnabled = IS_TARGET_HALTED();
        break;

    case IDM_DEBUG_RESTART:
        // If no debuggee is running we can only restart if
        // enough information was given on the command line.
        // If a debuggee is running we can only restart
        // created user-mode processes.
        fEnabled =
            (g_TargetClass == DEBUG_CLASS_UNINITIALIZED &&
             g_CommandLineStart == 1) ||
            (g_DebugCommandLine != NULL &&
             g_TargetClass == DEBUG_CLASS_USER_WINDOWS &&
             !g_RemoteClient &&
             IS_TARGET_HALTED());
        break;

    case IDM_DEBUG_STOPDEBUGGING:
        // Technically we can support stopping while the
        // debuggee is running, but that will generally
        // require terminating the engine thread as it
        // will most likely be busy and not able to
        // quickly exit to stop.  If we terminate the
        // engine thread at a random point it may
        // leave the engine in an unstable or locked state,
        // so restrict restarts to situations where
        // the engine thread should be available.
        fEnabled = g_RemoteClient || IS_TARGET_HALTED();
        break;

    case IDM_DEBUG_BREAK:
        fEnabled = g_TargetClass != DEBUG_CLASS_UNINITIALIZED;
        break;

    case IDM_DEBUG_STEPINTO:
    case IDM_DEBUG_STEPOVER:
    case IDM_DEBUG_STEPOUT:
        fEnabled = IS_TARGET_HALTED();
        break;

    case IDM_DEBUG_RUNTOCURSOR:
        //
        // If the document can return a code address for
        // its cursor it is a candidate for run-to-cursor.
        //

        fEnabled = FALSE;

        if (IS_TARGET_HALTED() && pCommonWinData)
        {
            fEnabled = pCommonWinData->CodeExprAtCaret(NULL, NULL);
        }
        break;

    case IDM_DEBUG_EVENT_FILTERS:
    case IDM_DEBUG_MODULES:
        fEnabled = IS_TARGET_HALTED();
        break;

    case IDM_KDEBUG_TOGGLE_BAUDRATE:
    case IDM_KDEBUG_TOGGLE_INITBREAK:
    case IDM_KDEBUG_RECONNECT:
        fEnabled = g_TargetClass == DEBUG_CLASS_KERNEL &&
            g_TargetClassQual == DEBUG_KERNEL_CONNECTION;
        break;
        
    case IDM_WINDOW_CASCADE:
    case IDM_WINDOW_TILE_HORZ:
    case IDM_WINDOW_TILE_VERT:
    case IDM_WINDOW_ARRANGE:
    case IDM_WINDOW_ARRANGE_ICONS:
        fEnabled = hwndChild != NULL;
        break; 

    case IDM_WINDOW_AUTO_ARRANGE:
        CheckMenuItem(g_hmenuMain, 
                      IDM_WINDOW_AUTO_ARRANGE,
                      g_WinOptions & WOPT_AUTO_ARRANGE ? MF_CHECKED : MF_UNCHECKED
                      );
        fEnabled = TRUE;
        break;

    case IDM_WINDOW_ARRANGE_ALL:        
        CheckMenuItem(g_hmenuMain, 
                      IDM_WINDOW_ARRANGE_ALL,
                      g_WinOptions & WOPT_ARRANGE_ALL ? MF_CHECKED : MF_UNCHECKED
                      );
        fEnabled = TRUE;
        break;

    case IDM_WINDOW_OVERLAY_SOURCE:
        CheckMenuItem(g_hmenuMain, 
                      IDM_WINDOW_OVERLAY_SOURCE,
                      g_WinOptions & WOPT_OVERLAY_SOURCE ? MF_CHECKED : MF_UNCHECKED
                      );
        fEnabled = TRUE;
        break;

    case IDM_WINDOW_AUTO_DISASM:
        CheckMenuItem(g_hmenuMain, 
                      IDM_WINDOW_AUTO_DISASM,
                      g_WinOptions & WOPT_AUTO_DISASM ? MF_CHECKED : MF_UNCHECKED
                      );
        fEnabled = TRUE;
        break;

    case IDM_FILE_OPEN:
    case IDM_VIEW_COMMAND:
    case IDM_VIEW_WATCH:
    case IDM_VIEW_CALLSTACK:
    case IDM_VIEW_MEMORY:
    case IDM_VIEW_LOCALS:
    case IDM_VIEW_REGISTERS:
    case IDM_VIEW_DISASM:
    case IDM_VIEW_SCRATCH:
    case IDM_VIEW_TOOLBAR:
    case IDM_VIEW_STATUS:
    case IDM_VIEW_FONT:
    case IDM_VIEW_OPTIONS:
    case IDM_EDIT_TOGGLEBREAKPOINT:
    case IDM_EDIT_LOG_FILE:
        // These items are not dynamically enabled
        // but are present in the toolbar.  The toolbar
        // code requests enable state for every item on it
        // so these entries need to be present to return TRUE.
        fEnabled = TRUE;
        break;
    
    default:
        DebugPrint("CommandIdEnabled: Unhandled %d (%X)\n",
                   uMenuID, uMenuID - MENU_SIGNATURE);
        // We should have handled everything.
        Assert(0);
        break;
    }

    ToolbarIdEnabled(uMenuID, fEnabled);

    return (( fEnabled ) ? MF_ENABLED : MF_GRAYED ) | MF_BYCOMMAND;
}





VOID
InitializeMenu(
    IN HMENU hMenu
    )

/*++

Routine Description:

    InitializeMenu sets the enabled/disabled state of all menu items whose
    state musr be determined dynamically.

Arguments:

    hMenu - Supplies a handle to the menu bar.

Return Value:

    None.

--*/

{
    INT     i;

    Dbg(hMenu);

    //
    // Iterate thrrough the table, enabling/disabling menu items
    // as appropriate.
    //

    for ( i = 0; i < ELEMENTS_IN_ENABLE_MENU_ITEM_TABLE; i++ )
    {
        EnableMenuItem(hMenu,
                       g_EnableMenuItemTable[ i ],
                       CommandIdEnabled( g_EnableMenuItemTable[ i ])
                       );
    }
}

ULONG
MruEntrySize(PTSTR File)
{
    ULONG Len = strlen(File) + 1;
    return sizeof(MRU_ENTRY) + (Len & ~3);
}

void
ClearMruMenu(void)
{
    while (GetMenuItemCount(g_MruMenu) > 0)
    {
        if (!DeleteMenu(g_MruMenu, 0, MF_BYPOSITION))
        {
            break;
        }
    }
}

VOID
AddFileToMru(ULONG FileUse, PTSTR File)
{
    ULONG Len = MruEntrySize(File);
    MRU_ENTRY* Entry = (MRU_ENTRY*)malloc(Len);
    if (Entry == NULL)
    {
        return;
    }

    if (g_MruFiles[0] == NULL)
    {
        // MRU list is empty.  Delete placeholder menu entry.
        ClearMruMenu();
    }
    else if (g_MruFiles[MAX_MRU_FILES - 1] != NULL)
    {
        // MRU list is full, free up the oldest entry.
        free(g_MruFiles[MAX_MRU_FILES - 1]);
    }

    // Push entries down.
    memmove(g_MruFiles + 1, g_MruFiles,
            (MAX_MRU_FILES - 1) * sizeof(*g_MruFiles));

    g_MruFiles[0] = Entry;
    Entry->FileUse = FileUse;
    strcpy(Entry->FileName, File);

    //
    // Insert file in MRU menu.
    //

    MENUITEMINFO Item;
    ULONG i;

    ZeroMemory(&Item, sizeof(Item));
    Item.cbSize = sizeof(Item);

    // Renumber existing items and remove any excess.
    i = GetMenuItemCount(g_MruMenu);
    while (i-- > 0)
    {
        if (i >= MAX_MRU_FILES)
        {
            DeleteMenu(g_MruMenu, i, MF_BYPOSITION);
        }
        else
        {
            Item.fMask = MIIM_ID;
            GetMenuItemInfo(g_MruMenu, i, TRUE, &Item);
            Item.wID++;
            SetMenuItemInfo(g_MruMenu, i, TRUE, &Item);
        }
    }
    
    Item.fMask = MIIM_FTYPE | MIIM_ID | MIIM_STRING;
    Item.fType = MFT_STRING;
    Item.wID = IDM_FILE_MRU_FILE1;
    Item.dwTypeData = g_MruFiles[0]->FileName;
    InsertMenuItem(g_MruMenu, 0, TRUE, &Item);
    
    DrawMenuBar(g_hwndFrame);

    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_MRU_LIST);
    }
}

void
ClearMru(void)
{
    ULONG i;

    for (i = 0; i < MAX_MRU_FILES; i++)
    {
        if (g_MruFiles[i] != NULL)
        {
            free(g_MruFiles[i]);
            g_MruFiles[i] = NULL;
        }
        else
        {
            break;
        }
    }

    ClearMruMenu();
    DrawMenuBar(g_hwndFrame);
}

ULONG
GetMruSize(void)
{
    ULONG i;
    ULONG Size = 0;

    for (i = 0; i < MAX_MRU_FILES; i++)
    {
        if (g_MruFiles[i] != NULL)
        {
            Size += MruEntrySize(g_MruFiles[i]->FileName);
        }
        else
        {
            break;
        }
    }

    return Size;
}

PUCHAR
ReadMru(PUCHAR Data, PUCHAR End)
{
    ClearMru();

    ULONG i;

    i = 0;
    while (Data < End)
    {
        MRU_ENTRY* DataEntry = (MRU_ENTRY*)Data;
        ULONG Len = MruEntrySize(DataEntry->FileName);
        
        g_MruFiles[i] = (MRU_ENTRY*)malloc(Len);
        if (g_MruFiles[i] == NULL)
        {
            Data = End;
            break;
        }

        g_MruFiles[i]->FileUse = DataEntry->FileUse;
        strcpy(g_MruFiles[i]->FileName, DataEntry->FileName);
        Data += Len;
        i++;
    }
        
    MENUITEMINFO Item;

    ZeroMemory(&Item, sizeof(Item));
    Item.cbSize = sizeof(Item);
    Item.fMask = MIIM_FTYPE | MIIM_ID | MIIM_STRING;
    Item.fType = MFT_STRING;
    for (i = 0; i < MAX_MRU_FILES; i++)
    {
        if (g_MruFiles[i] == NULL)
        {
            break;
        }
        
        Item.wID = IDM_FILE_MRU_FILE1 + i;
        Item.dwTypeData = g_MruFiles[i]->FileName;
        InsertMenuItem(g_MruMenu, i, TRUE, &Item);
    }
    
    DrawMenuBar(g_hwndFrame);
    
    return Data;
}

PUCHAR
WriteMru(PUCHAR Data)
{
    ULONG i;

    for (i = 0; i < MAX_MRU_FILES; i++)
    {
        if (g_MruFiles[i] != NULL)
        {
            MRU_ENTRY* DataEntry = (MRU_ENTRY*)Data;
            ULONG Len = MruEntrySize(g_MruFiles[i]->FileName);

            DataEntry->FileUse = g_MruFiles[i]->FileUse;
            strcpy(DataEntry->FileName, g_MruFiles[i]->FileName);
            Data += Len;
        }
        else
        {
            break;
        }
    }
    
    return Data;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\memwin.h ===
struct _FORMATS_MEM_WIN {
    DWORD   cBits;
    FMTTYPE fmtType;
    DWORD   radix;
    DWORD   fTwoFields;
    DWORD   cchMax;
    PTSTR   lpszDescription;
};

extern _FORMATS_MEM_WIN g_FormatsMemWin[];
extern const int g_nMaxNumFormatsMemWin;





//
// Enum type and string identifier
//
extern struct _INTERFACE_TYPE_NAMES {
    INTERFACE_TYPE  type;
    PTSTR           psz;
} rgInterfaceTypeNames[MaximumInterfaceType];

extern struct _BUS_TYPE_NAMES {
    BUS_DATA_TYPE   type;
    PTSTR           psz;
} rgBusTypeNames[MaximumBusDataType];


struct GEN_MEMORY_DATA {
    MEMORY_TYPE memtype;
    int         nDisplayFormat;
    ANY_MEMORY_DATA any;
};

#define IDC_MEM_PREVIOUS 1234
#define IDC_MEM_NEXT     1235


class MEMWIN_DATA : public EDITWIN_DATA {
public:
    char            m_OffsetExpr[MAX_OFFSET_EXPR];
    BOOL            m_UpdateExpr;
    ULONG64         m_OffsetRead;
    GEN_MEMORY_DATA m_GenMemData;
    HWND            m_FormatCombo;
    HWND            m_PreviousButton;
    HWND            m_NextButton;
    ULONG           m_Columns;
    BOOL            m_AllowWrite;
    BOOL            m_UpdateValue;
    char            m_ValueExpr[MAX_OFFSET_EXPR];
    ULONG           m_WindowDataSize;

    MEMWIN_DATA();

    virtual void Validate();

    virtual BOOL HasEditableProperties();
    virtual BOOL EditProperties();

    virtual HRESULT ReadState(void);

    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSize(void);
    virtual void OnTimer(WPARAM TimerId);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    virtual void UpdateColors(void);

    void ScrollLower(void);
    void ScrollHigher(void);
    
    void WriteValue(ULONG64 Offset);
    void UpdateOptions(void);
    ULONG64 GetAddressOfCurValue(
        PULONG pCharIndex,
        CHARRANGE *pCRange
        );
};
typedef MEMWIN_DATA *PMEMWIN_DATA;





INT_PTR
DisplayOptionsPropSheet(
    HWND                hwndOwner,
    HINSTANCE           hinst,
    MEMORY_TYPE         memtypeStartPage
    );

















#if 0



#define MAX_CHUNK_TOREAD 4096 // maximum chunk of memory to read at one go


LRESULT
CALLBACK
MemoryEditProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

/*
void ViewMem(int view, BOOL fVoidCache);


extern TCHAR   memText[MAX_MSG_TXT]; //the selected text for memory dlg
*/

struct memItem {
    char    iStart;
    char    cch;
    char    iFmt;
};

struct memWinDesc {
    int     iFormat;
    ATOM    atmAddress;
    BOOL    fLive;
    BOOL    fHaveAddr;
    BOOL    fBadRead;               // dis we really read mem or just ??
    PTSTR   lpbBytes;
    memItem *lpMi;
    UINT    cMi;
    BOOL    fEdit;
    BOOL    fFill;
    UINT    cPerLine;
    //ADDR    addr;
    //ADDR    orig_addr;
    //ADDR    old_addr;
    TCHAR   szAddress[MAX_MSG_TXT]; //the mem address expression in ascii
    UINT    cbRead;
};

/*
extern struct memWinDesc    MemWinDesc[MAX_VIEWS];
extern struct memWinDesc    TempMemWinDesc;

//
//  Define the set of memory formats
//

enum {
    MW_ASCII = 0,
    MW_BYTE,
    MW_SHORT,
    MW_SHORT_HEX,
    MW_SHORT_UNSIGNED,
    MW_LONG,
    MW_LONG_HEX,
    MW_LONG_UNSIGNED,
    MW_QUAD,
    MW_QUAD_HEX,
    MW_QUAD_UNSIGNED,
    MW_REAL,
    MW_REAL_LONG,
    MW_REAL_TEN
};
*/

#if 0
#define MEM_FORMATS {\
            1,  /* ASCII */ \
            1,  /* BYTE  */ \
            2,  /* SHORT */ \
            2,  /* SHORT_HEX */ \
            2,  /* SHORT_UNSIGNED */ \
            4,  /* LONG */ \
            4,  /* LONG_HEX */ \
            4,  /* LONG_UNSIGNED */ \
            8,  /* QUAD */ \
            8,  /* QUAD_HEX */ \
            8,  /* QUAD_UNSIGNED */ \
            4,  /* REAL */ \
            8,  /* REAL_LONG */ \
           10,  /* REAL_TEN */ \
           16   /*  */ \
} 
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\memopts.cpp ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    Memory.c

Abstract:

    This module contains the memory options dialog callback and supporting
    routines to choose options for memory display.

--*/

#include "precomp.hxx"
#pragma hdrstop



_FORMATS_MEM_WIN g_FormatsMemWin[] = {
    {8,  fmtAscii,               0, FALSE,  1,  _T("ASCII")},
    {16, fmtUnicode,             0, FALSE,  1,  _T("Unicode")},
    {8,  fmtInt  | fmtZeroPad,  16, TRUE,   2,  _T("Byte")},
    {16, fmtInt  | fmtSpacePad, 10, FALSE,  6,  _T("Short")},
    {16, fmtUInt | fmtZeroPad,  16, FALSE,  4,  _T("Short Hex")},
    {16, fmtUInt | fmtSpacePad, 10, FALSE,  5,  _T("Short Unsigned")},
    {32, fmtInt  | fmtSpacePad, 10, FALSE,  11, _T("Long")},
    {32, fmtUInt | fmtZeroPad,  16, FALSE,  8,  _T("Long Hex")},
    {32, fmtUInt | fmtSpacePad, 10, FALSE,  10, _T("Long Unsigned")},
    {64, fmtInt  | fmtSpacePad, 10, FALSE,  21, _T("Quad")},
    {64, fmtUInt | fmtZeroPad,  16, FALSE,  16, _T("Quad Hex")},
    {64, fmtUInt | fmtSpacePad, 10, FALSE,  20, _T("Quad Unsigned")},
    {32, fmtFloat,              10, FALSE,  14, _T("Real (32-bit)")},
    {64, fmtFloat,              10, FALSE,  23, _T("Real (64-bit)")},
    {80, fmtFloat,              10, FALSE,  25, _T("Real (10-byte)")},
    {128,fmtFloat,              10, FALSE,  42, _T("Real (16-byte)")}
};

const int g_nMaxNumFormatsMemWin = sizeof(g_FormatsMemWin) / sizeof(g_FormatsMemWin[0]);




HWND hwndMemOptsParent = NULL;


void
Init(HWND, 
    HINSTANCE,
    LPPROPSHEETHEADER,
    PROPSHEETPAGE [],
    const int
    );


INT_PTR CALLBACK DlgProc_Physical_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Virtual_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_IO_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Bus_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Control_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_MSR_Mem(HWND, UINT, WPARAM, LPARAM);

INT_PTR 
CALLBACK 
DlgProc_MemoryProperties(MEMORY_TYPE, HWND, UINT, WPARAM, LPARAM);


int
MemType_To_DlgId(
    MEMORY_TYPE memtype
    )
{
    int i;
    struct {    
        MEMORY_TYPE memtype;
        int         nId;
    } rgMap[] = {
        { PHYSICAL_MEM_TYPE,    IDD_DLG_MEM_PHYSICAL },
        { VIRTUAL_MEM_TYPE,     IDD_DLG_MEM_VIRTUAL },
        { BUS_MEM_TYPE,         IDD_DLG_MEM_BUS_DATA },
        { CONTROL_MEM_TYPE,     IDD_DLG_MEM_CONTROL },
        { IO_MEM_TYPE,          IDD_DLG_MEM_IO },
        { MSR_MEM_TYPE,         IDD_DLG_MEM_MSR }
    };

    for (i=0; i<sizeof(rgMap)/sizeof(rgMap[0]); i++) {
        if (memtype == rgMap[i].memtype) {
            return rgMap[i].nId;
        }
    }

    Assert(!"This should not happen");
    return 0;
}


INT_PTR
DisplayOptionsPropSheet(
    HWND                hwndOwner,
    HINSTANCE           hinst,
    MEMORY_TYPE         memtypeStartPage
    )
/*++
Routine Description:
    Will Initialize and display the Options property sheet. Handle the return codes,
    and the commitment of changes to the debugger.

Arguments:
    hwndOwner
    hinst
        Are both used initialize the property sheet dialog.
    nStart - Is used to specify the page that is to be initially
        displayed when the prop sheet first appears. The default
        value is 0. The values specified correspond to array index
        of the PROPSHEETPAGE array.

Returns
    Button pushed IDOK, etc...
--*/
{
    INT_PTR nRes = 0;
    PROPSHEETHEADER psh = {0};
    PROPSHEETPAGE apsp[MAX_MEMORY_TYPE] = {0};
    int nNumPropPages = sizeof(apsp) / sizeof(PROPSHEETPAGE);

    Init(hwndOwner, hinst, &psh, apsp, nNumPropPages);

    {
        //
        // Figure out the initial page to be displayed
        //

        int i;
        int nStartPage = 0;
        int nId = MemType_To_DlgId(memtypeStartPage);

        for (i=0; i<MAX_MEMORY_TYPE; i++) {
            if ( (PVOID)(MAKEINTRESOURCE(nId)) == (PVOID)(apsp[i].pszTemplate) ) {
                nStartPage = i;
                break;
            }
        }
        
        psh.nStartPage = nStartPage;
    }


    hwndMemOptsParent = hwndOwner;

    nRes = PropertySheet(&psh);

    hwndMemOptsParent = NULL;

    if (IDOK == nRes) {
        // Save workspace changes here
    }

    return nRes;
}


void
Init(
    HWND                hwndOwner,
    HINSTANCE           hinst,
    LPPROPSHEETHEADER   lppsh,
    PROPSHEETPAGE       apsp[],
    const int           nMaxPropPages
    )
/*++
Routine Description:
    Initializes the property sheet header and pages.

Arguments:
    hwndOwner
    hinst
        Are both used by the PROPSHEETHEADER & PROPSHEETPAGE structure.
        Please see the docs for the these structures for more info.

    lppsh
        Standard prop sheet structure.

    apsp[]
        An array of prop pages
        Standard prop sheet structure.

    nNumPropPages
        Number of prop pages in the "apsp" array.
--*/
{
    int nPropIdx;

    memset(lppsh, 0, sizeof(PROPSHEETHEADER));

    lppsh->dwSize = sizeof(PROPSHEETHEADER);
    lppsh->dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    lppsh->hwndParent = hwndOwner;
    lppsh->hInstance = hinst;
    lppsh->pszCaption = "Memory Options";
    lppsh->nPages = 0;
    lppsh->ppsp = apsp;

    // Init the first one, then copy its contents to all the others
    memset(apsp, 0, sizeof(PROPSHEETPAGE));
    apsp[0].dwSize = sizeof(PROPSHEETPAGE);
//    apsp[0].dwFlags = PSP_HASHELP;
    apsp[0].hInstance = hinst;

    for (nPropIdx = 1; nPropIdx < nMaxPropPages; nPropIdx++) {
        memcpy(&(apsp[nPropIdx]), &apsp[0], sizeof(PROPSHEETPAGE));
    }



    // Only init the distinct values
    nPropIdx = 0;
    apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_VIRTUAL);
    apsp[nPropIdx].pfnDlgProc  = DlgProc_Virtual_Mem;

    if (g_TargetClass == DEBUG_CLASS_KERNEL)
    {
        nPropIdx = 1;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_PHYSICAL);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_Physical_Mem;

        nPropIdx = 2;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_BUS_DATA);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_Bus_Mem;

        nPropIdx = 3;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_CONTROL);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_Control_Mem;

        nPropIdx = 4;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_IO);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_IO_Mem;

        nPropIdx = 5;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_MSR);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_MSR_Mem;
    }

    Assert(nPropIdx < nMaxPropPages);
    lppsh->nPages = nPropIdx + 1;
}


INT_PTR
CALLBACK
DlgProc_MemoryProperties(
    MEMORY_TYPE memtype,
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT nPos;
    MEMWIN_DATA *pMemWinData = GetMemWinData( hwndMemOptsParent );

    switch (uMsg) {
    
/*    
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, "windbg.hlp", HELP_WM_HELP,
            (DWORD_PTR)(LPVOID) HelpArray );
        return TRUE;
        
    case WM_CONTEXTMENU:
        WinHelp ((HWND) wParam, "windbg.hlp", HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID) HelpArray );
        return TRUE;
*/
        
    case WM_COMMAND:
        /*{
            WORD wNotifyCode = HIWORD(wParam);  // notification code
            WORD wID = LOWORD(wParam);          // item, control, or accelerator identifier
            HWND hwndCtl = (HWND) lParam;       // handle of control
            BOOL bEnabled;
            
            switch(wID) {
            case ID_ENV_SRCHPATH:
                if (BN_CLICKED == wNotifyCode) {
                    BOOL b = IsDlgButtonChecked(hDlg, ID_ENV_SRCHPATH);
                    
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_EXECUTABLE_SEARCH_PATH), b);
                    EnableWindow(GetDlgItem(hDlg, IDC_BUT_BROWSE), b);
                    
                    return TRUE;
                }
                break;
            }
        }*/
        break;
        
    case WM_INITDIALOG:
        { // begin Prog & Arguments code block
            
            int         nIdx;
            TCHAR       szTmp[MAX_MSG_TXT];
           
            
            //
            // Enter the display formats 
            //
            for (nIdx=0; nIdx < g_nMaxNumFormatsMemWin; nIdx++) {
                
                nPos = SendDlgItemMessage(hDlg,
                                          IDC_COMBO_DISPLAY_FORMAT,
                                          CB_ADDSTRING,
                                          0,
                                          (LPARAM) g_FormatsMemWin[nIdx].lpszDescription
                                          );

                SendDlgItemMessage(hDlg, 
                                   IDC_COMBO_DISPLAY_FORMAT, 
                                   CB_SETITEMDATA, 
                                   (WPARAM) nPos, 
                                   (LPARAM) (UINT) nIdx
                                   );
            }

            SendDlgItemMessage(hDlg, 
                               IDC_COMBO_DISPLAY_FORMAT, 
                               CB_SELECTSTRING, 
                               (WPARAM) -1, 
                               (LPARAM) g_FormatsMemWin[pMemWinData->m_GenMemData.nDisplayFormat].lpszDescription
                               );
            
            //
            // Update the offset. Offset is common to all dialogs
            //
            SendDlgItemMessage(hDlg, IDC_EDIT_OFFSET, EM_LIMITTEXT,
                               sizeof(pMemWinData->m_OffsetExpr) - 1, 0);
            SetDlgItemText(hDlg, IDC_EDIT_OFFSET, pMemWinData->m_OffsetExpr);
            
            switch (memtype) {
            default:
                Assert(!"Unhandled value");
                break;
                
            case VIRTUAL_MEM_TYPE:
                // Nothing to do
                break;
                
            case PHYSICAL_MEM_TYPE:
                // Nothing to do
                break;
                
            case CONTROL_MEM_TYPE:                
                SendDlgItemMessage(hDlg, IDC_EDIT_PROCESSOR, EM_LIMITTEXT,
                                   32, 0);
                
                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.control.Processor);
                SetDlgItemText(hDlg, IDC_EDIT_PROCESSOR, szTmp);
                break;
                
            case IO_MEM_TYPE:
                SendDlgItemMessage(hDlg, IDC_EDIT_BUS_NUMBER, EM_LIMITTEXT,
                                   32, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_ADDRESS_SPACE, EM_LIMITTEXT,
                                   32, 0);

                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.io.BusNumber);
                SetDlgItemText(hDlg, IDC_EDIT_BUS_NUMBER, szTmp);

                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.io.AddressSpace);
                SetDlgItemText(hDlg, IDC_EDIT_ADDRESS_SPACE, szTmp);

                
                //
                // Enter the interface types
                //
                for (nIdx = 0; nIdx < sizeof(rgInterfaceTypeNames) /
                         sizeof(rgInterfaceTypeNames[0]); nIdx++) {
                
                    nPos = SendDlgItemMessage(hDlg,
                                              IDC_COMBO_INTERFACE_TYPE,
                                              CB_ADDSTRING,
                                              0,
                                              (LPARAM) rgInterfaceTypeNames[nIdx].psz
                                              );

                    SendDlgItemMessage(hDlg, 
                                       IDC_COMBO_INTERFACE_TYPE, 
                                       CB_SETITEMDATA, 
                                       (WPARAM) nPos, 
                                       (LPARAM) (UINT) nIdx
                                       );
                }

                if (memtype == pMemWinData->m_GenMemData.memtype) {
                    nIdx = pMemWinData->m_GenMemData.any.io.interface_type;
                } else {
                    nIdx = 0;
                }
                SendDlgItemMessage(hDlg, 
                                   IDC_COMBO_INTERFACE_TYPE, 
                                   CB_SELECTSTRING, 
                                   (WPARAM) -1, 
                                   (LPARAM) rgInterfaceTypeNames[nIdx].psz
                                   );
                break;
                
            case MSR_MEM_TYPE:
                // Nothing to do
                break;
                
            case BUS_MEM_TYPE:
                SendDlgItemMessage(hDlg, IDC_EDIT_BUS_NUMBER, EM_LIMITTEXT,
                                   32, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_SLOT_NUMBER, EM_LIMITTEXT,
                                   32, 0);
                
                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.bus.BusNumber);
                SetDlgItemText(hDlg, IDC_EDIT_BUS_NUMBER, szTmp);

                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.bus.SlotNumber);
                SetDlgItemText(hDlg, IDC_EDIT_SLOT_NUMBER, szTmp);

                //
                // Enter the bus types
                //
                for (nIdx = 0; nIdx < sizeof(rgBusTypeNames) /
                         sizeof(rgBusTypeNames[0]); nIdx++) {
                
                    nPos = SendDlgItemMessage(hDlg,
                                              IDC_COMBO_BUS_DATA_TYPE,
                                              CB_ADDSTRING,
                                              0,
                                              (LPARAM) rgBusTypeNames[nIdx].psz
                                              );

                    SendDlgItemMessage(hDlg, 
                                       IDC_COMBO_BUS_DATA_TYPE, 
                                       CB_SETITEMDATA, 
                                       (WPARAM) nPos, 
                                       (LPARAM) (UINT) nIdx
                                       );
                }

                if (memtype == pMemWinData->m_GenMemData.memtype) {
                    nIdx = pMemWinData->m_GenMemData.any.bus.bus_type;
                } else {
                    nIdx = 0;
                }
                SendDlgItemMessage(hDlg, 
                                   IDC_COMBO_BUS_DATA_TYPE, 
                                   CB_SELECTSTRING, 
                                   (WPARAM) -1, 
                                   (LPARAM) rgBusTypeNames[nIdx].psz
                                   );
                break;
            }
            
            return FALSE;
        } // end Prog & Arguments code block
        break;
        
    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            pMemWinData->m_GenMemData.memtype = memtype;
            return 0;
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
            return 1;
            
        case PSN_APPLY:
            if (memtype != pMemWinData->m_GenMemData.memtype) {
                // This isn't the current page so ignore.
                break;
            }
            
            int         nIdx;
            TCHAR       szTmp[MAX_MSG_TXT];
            ULONG64     u64; // tmp value

            //
            // Get the display formats 
            //
            nPos = SendDlgItemMessage(hDlg, 
                                      IDC_COMBO_DISPLAY_FORMAT, 
                                      CB_GETCURSEL, 
                                      0, 
                                      0
                                      );

            if (CB_ERR == nPos) {
                pMemWinData->m_GenMemData.nDisplayFormat = 0;
            } else {
                nIdx = (int)SendDlgItemMessage(hDlg, 
                                               IDC_COMBO_DISPLAY_FORMAT, 
                                               CB_GETITEMDATA, 
                                               (WPARAM) nPos, 
                                               0
                                               );
                if (CB_ERR == nIdx) {
                    pMemWinData->m_GenMemData.nDisplayFormat = 0;
                } else {
                    pMemWinData->m_GenMemData.nDisplayFormat = nIdx;
                }
            }

            //
            // Update the offset. Offset is common to all dialogs
            //
            GetDlgItemText(hDlg, IDC_EDIT_OFFSET,
                           pMemWinData->m_OffsetExpr,
                           sizeof(pMemWinData->m_OffsetExpr));
    
            switch (memtype) {
            default:
                Assert(!"Unhandled value");
                break;
        
            case VIRTUAL_MEM_TYPE:
                // Nothing to do
                break;
        
            case PHYSICAL_MEM_TYPE:
                // Nothing to do
                break;
        
            case CONTROL_MEM_TYPE:                
                GetDlgItemText(hDlg, IDC_EDIT_PROCESSOR,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.control.Processor) != 1)
                {
                    pMemWinData->m_GenMemData.any.control.Processor = 0;
                }
                break;
        
            case IO_MEM_TYPE:
                GetDlgItemText(hDlg, IDC_EDIT_BUS_NUMBER,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.io.BusNumber) != 1)
                {
                    pMemWinData->m_GenMemData.any.io.BusNumber = 0;
                }
                
                GetDlgItemText(hDlg, IDC_EDIT_ADDRESS_SPACE,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.io.AddressSpace) != 1)
                {
                    pMemWinData->m_GenMemData.any.io.AddressSpace = 0;
                }
                
                //
                // Get the interface types
                //
                nPos = SendDlgItemMessage(hDlg, 
                                          IDC_COMBO_INTERFACE_TYPE, 
                                          CB_GETCURSEL, 
                                          0, 
                                          0
                                          );

                if (CB_ERR == nPos) {
                    pMemWinData->m_GenMemData.any.io.interface_type =
                        _INTERFACE_TYPE(0);
                } else {
                    nIdx = (int)SendDlgItemMessage(hDlg, 
                                                   IDC_COMBO_INTERFACE_TYPE, 
                                                   CB_GETITEMDATA, 
                                                   (WPARAM) nPos, 
                                                   0
                                                   );
                    if (CB_ERR == nIdx) {
                        pMemWinData->m_GenMemData.any.io.interface_type =
                            _INTERFACE_TYPE(0);
                    } else {
                        pMemWinData->m_GenMemData.any.io.interface_type =
                            _INTERFACE_TYPE(nIdx);
                    }
                }
                break;
        
            case MSR_MEM_TYPE:
                // Nothing to do
                break;
        
            case BUS_MEM_TYPE:
                GetDlgItemText(hDlg, IDC_EDIT_BUS_NUMBER,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.bus.BusNumber) != 1)
                {
                    pMemWinData->m_GenMemData.any.bus.BusNumber = 0;
                }

                GetDlgItemText(hDlg, IDC_EDIT_SLOT_NUMBER,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.bus.SlotNumber) != 1)
                {
                    pMemWinData->m_GenMemData.any.bus.SlotNumber = 0;
                }

                //
                // Get the bus type
                //
                nPos = SendDlgItemMessage(hDlg, 
                                          IDC_COMBO_BUS_DATA_TYPE, 
                                          CB_GETCURSEL, 
                                          0, 
                                          0
                                          );

                if (CB_ERR == nPos) {
                    pMemWinData->m_GenMemData.any.bus.bus_type =
                        _BUS_DATA_TYPE(0);
                } else {
                    nIdx = (int)SendDlgItemMessage(hDlg, 
                                                   IDC_COMBO_BUS_DATA_TYPE, 
                                                   CB_GETITEMDATA, 
                                                   (WPARAM) nPos, 
                                                   0
                                                   );
                    if (CB_ERR == nIdx) {
                        pMemWinData->m_GenMemData.any.bus.bus_type =
                            _BUS_DATA_TYPE(0);
                    } else {
                        pMemWinData->m_GenMemData.any.bus.bus_type =
                            _BUS_DATA_TYPE(nIdx);
                    }
                }
                break;
            }
    
            return FALSE;
        }
        break;
    }

    return FALSE;
}


#if 0
void
Workspace_ApplyChanges(
    HWND hDlg
    )
{
    BOOL bChecked = FALSE;
    char sz[_MAX_PATH];


    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO_AUTO_SAVE_WORKSPACE) ) {
            
        g_contGlobalPreferences_WkSp.m_bAlwaysSaveWorkspace = TRUE;
        g_contGlobalPreferences_WkSp.m_bPromptBeforeSavingWorkspace = FALSE;

    } else if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO_PROMPT_BEFORE_SAVING_WORKSPACE)) {

        g_contGlobalPreferences_WkSp.m_bPromptBeforeSavingWorkspace = TRUE;
        g_contGlobalPreferences_WkSp.m_bAlwaysSaveWorkspace = TRUE;

    } else {

        g_contGlobalPreferences_WkSp.m_bPromptBeforeSavingWorkspace = FALSE;
        g_contGlobalPreferences_WkSp.m_bAlwaysSaveWorkspace = FALSE;

    }

    bChecked = (IsDlgButtonChecked(hDlg,ID_LFOPT_APPEND) == BST_CHECKED);
    if (bChecked != g_contWorkspace_WkSp.m_bLfOptAppend) {
        g_contWorkspace_WkSp.m_bLfOptAppend = bChecked;
    }

    bChecked = (IsDlgButtonChecked(hDlg,ID_LFOPT_AUTO) == BST_CHECKED);
    if (bChecked != g_contWorkspace_WkSp.m_bLfOptAuto) {
        g_contWorkspace_WkSp.m_bLfOptAuto = bChecked;
    }

    GetDlgItemText(hDlg, ID_LFOPT_FNAME, sz, sizeof(sz));

    if (strlen(sz) == 0) {
        Assert(strlen(DEFAULT_CMD_WINDOW_LOGFILENAME) < sizeof(sz));
        strcpy( sz, DEFAULT_CMD_WINDOW_LOGFILENAME );
    } 
    
    if (0 == g_contWorkspace_WkSp.m_pszLogFileName
        || strcmp(sz, g_contWorkspace_WkSp.m_pszLogFileName)) {

        FREE_STR(g_contWorkspace_WkSp.m_pszLogFileName);
        g_contWorkspace_WkSp.m_pszLogFileName = _strdup(sz);
    }

}
#endif


INT_PTR 
CALLBACK 
DlgProc_Physical_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(PHYSICAL_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}
    
INT_PTR 
CALLBACK 
DlgProc_Virtual_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(VIRTUAL_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR 
CALLBACK 
DlgProc_IO_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(IO_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR 
CALLBACK 
DlgProc_Bus_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(BUS_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR 
CALLBACK 
DlgProc_Control_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(CONTROL_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR 
CALLBACK 
DlgProc_MSR_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(MSR_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\miscdbg.cpp ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    miscdbg.cpp

Abstract:

    Contains code to aid in internal debugging.

--*/

#include "precomp.hxx"
#pragma hdrstop


#ifdef DBG

VOID
Dbg_Windbg_InitializeCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION  pDbgCritSec,
    PTSTR                         pszName,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    InitializeCriticalSection( &pDbgCritSec->cs );
    pDbgCritSec->Initialize(pszName);
}


BOOL
Dbg_Windbg_TryEnterCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION  pDbgCritSec,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    BOOL b = TryEnterCriticalSection( &pDbgCritSec->cs );
    
    if (b) {
        ++pDbgCritSec->nLockCount;
        pDbgCritSec->OwnerId = GetCurrentThreadId();

        DPRINT(DP_CRITSEC_VERBOSE, 
               ( _T(" *** TryEnterCriticalSection \'%s\' %s %d\n"), 
               pDbgCritSec->pszName,
               pszFile, 
               nLine
               ) );

        pDbgCritSec->pszLock_LastFile = pszFile;
        pDbgCritSec->nLock_LastFile = nLine;
    }

    if (pDbgCritSec->nLockCount++ > 1) {
        DPRINT(DP_CRITSEC_INFO, 
               ( _T(" *** INFO: Locked twice. \'%s\' %s %d\n"), 
               pDbgCritSec->pszName, 
               pszFile, 
               nLine
               ) );
    }

    return b;
}


VOID
Dbg_Windbg_EnterCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION  pDbgCritSec,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    if (pDbgCritSec->nLockCount
        && GetCurrentThreadId() != pDbgCritSec->OwnerId ) {
        
        DPRINT(DP_CRITSEC_INFO, 
               ( _T(" *** INFO: Waiting on another thread. \'%s\' %s %d\n"), 
               pDbgCritSec->pszName, 
               pszFile, 
               nLine
               ) );
    }
    
    EnterCriticalSection( &pDbgCritSec->cs );

    pDbgCritSec->OwnerId = GetCurrentThreadId();
    pDbgCritSec->pszLock_LastFile = pszFile;
    pDbgCritSec->nLock_LastFile = nLine;

    if (pDbgCritSec->nLockCount++ > 1) {
        DPRINT(DP_CRITSEC_INFO, 
               ( _T(" *** INFO: Locked twice. \'%s\' %s %d\n"), 
               pDbgCritSec->pszName, 
               pszFile, 
               nLine
               ) );
    }

    DPRINT(DP_CRITSEC_VERBOSE, 
           ( _T(" *** Dbg_EnterCriticalSection \'%s\' %s %d\n"), 
           pDbgCritSec->pszName,
           pszFile, 
           nLine
           ) );
}


VOID
Dbg_Windbg_LeaveCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION  pDbgCritSec,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    DPRINT(DP_CRITSEC_VERBOSE, 
           ( _T(" *** Dbg_LeaveCriticalSection \'%s\' %s %d\n"), 
           pDbgCritSec->pszName,
           pszFile, 
           nLine
           ) );

    if (GetCurrentThreadId() != pDbgCritSec->OwnerId ) {
        
        DPRINT(DP_CRITSEC_ERROR, 
               ( _T(" *** ERROR: Not owner. Dbg_LeaveCriticalSection \'%s\' %s %d\n"), 
               pDbgCritSec->pszName,
               pszFile, 
               nLine
               ) );

        Assert(!"API lock released when not owned");
    }
    if (pDbgCritSec->nLockCount < 1) {

        DPRINT(DP_CRITSEC_ERROR, 
               ( _T(" *** ERROR: Count is 0. Dbg_LeaveCriticalSection \'%s\' %s %d\n"), 
               pDbgCritSec->pszName,
               pszFile, 
               nLine
               ) );
        Assert(!"API Lock released when count is 0");

    } else {
        if (--pDbgCritSec->nLockCount == 0) {
            pDbgCritSec->OwnerId = 0;
        }
        LeaveCriticalSection(&pDbgCritSec->cs);
    }

    pDbgCritSec->pszUnlock_LastFile = pszFile;
    pDbgCritSec->nUnlock_LastFile = nLine;
}


VOID
Dbg_Windbg_DeleteCriticalSection(
    PDBG_WINDBG_CRITICAL_SECTION pDbgCritSec,
    PTSTR                         pszFile,
    int                           nLine
    )
{
    DeleteCriticalSection( &pDbgCritSec->cs );
    pDbgCritSec->Delete();
}

#endif // DBG



VOID
DebugPrint(
    PTSTR szFormat,
    ...
    )
{
    __declspec( thread ) static TCHAR   rgchDebug[1024 * 4];
    __declspec( thread ) static va_list marker;

    va_start( marker, szFormat );

    if (-1 == _vsntprintf(rgchDebug, _tsizeof(rgchDebug), szFormat, marker ) ) {
        rgchDebug[_tsizeof(rgchDebug)-1] = 0;
    }

    va_end( marker);

    OutputDebugString( rgchDebug );
}                               /* DebugPrint() */



#ifdef _CPPRTTI
BOOL
RttiTypesEqual(
    const type_info & t1, 
    const type_info & t2
    )
{
    return t1 == t2;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\miscdbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    miscdbg.h

Abstract:

    

Environment:

    Win32, User Mode

--*/


#ifndef DBG

//
// Debugging code for critical sections
//
#define DBG_CRITICAL_SECTION            CRITICAL_SECTION


#define Dbg_InitializeCriticalSection   InitializeCriticalSection
#define Dbg_TryEnterCriticalSection     TryEnterCriticalSection
#define Dbg_EnterCriticalSection        EnterCriticalSection

#define Dbg_LeaveCriticalSection        LeaveCriticalSection
#define Dbg_DeleteCriticalSection       DeleteCriticalSection

#define Dbg_CriticalSectionOwned(p)     FALSE
#define Dbg_CriticalSectionUnowned(p)   FALSE

#else


typedef struct _DBG_WINDBG_CRITICAL_SECTION {
    CRITICAL_SECTION    cs;
    int	                nLockCount;
    DWORD               OwnerId;
    PTSTR               pszName;

    PTSTR               pszLock_LastFile;
    int                 nLock_LastFile;
    
    PTSTR               pszUnlock_LastFile;
    int                 nUnlock_LastFile;

    void
    Initialize(
        PTSTR pszCritSecName
        )
    {
        //
        // Initialize the structure here to rather than in the CPP file,
        // because it is common to add member variables and forget to initialize
        // them in the CPP file. So we do it here.
        //
        nLockCount = 0;
        OwnerId = 0;
        pszName = _tcsdup(pszCritSecName);
        pszLock_LastFile = NULL;
        nLock_LastFile = 0;    
        pszUnlock_LastFile = NULL;
        nUnlock_LastFile = 0;
    }

    void
    Delete()
    {
        free(pszName);
    }
    

} DBG_WINDBG_CRITICAL_SECTION, *PDBG_WINDBG_CRITICAL_SECTION;

#define DBG_CRITICAL_SECTION            _DBG_WINDBG_CRITICAL_SECTION

#define Dbg_InitializeCriticalSection(p)    Dbg_Windbg_InitializeCriticalSection(p, _T(#p), _T(__FILE__), __LINE__);
#define Dbg_TryEnterCriticalSection(p)      Dbg_Windbg_TryEnterCriticalSection(p, _T(__FILE__), __LINE__);
#define Dbg_EnterCriticalSection(p)         Dbg_Windbg_EnterCriticalSection(p, _T(__FILE__), __LINE__);
#define Dbg_LeaveCriticalSection(p)         Dbg_Windbg_LeaveCriticalSection(p, _T(__FILE__), __LINE__);
#define Dbg_DeleteCriticalSection(p)        Dbg_Windbg_DeleteCriticalSection(p, _T(__FILE__), __LINE__);

#define Dbg_CriticalSectionOwned(p)         ((p)->OwnerId == GetCurrentThreadId())
#define Dbg_CriticalSectionUnowned(p)       ((p)->OwnerId == 0)


VOID Dbg_Windbg_InitializeCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, PTSTR, int);
BOOL Dbg_Windbg_TryEnterCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, int);
VOID Dbg_Windbg_EnterCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, int);
VOID Dbg_Windbg_LeaveCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, int);
VOID Dbg_Windbg_DeleteCriticalSection(PDBG_WINDBG_CRITICAL_SECTION, PTSTR, int);


//
// Code to aid in outputing messages
//

#define DP_CRITSEC_WARN         0x00000001
#define DP_CRITSEC_ERROR        0x00000002
#define DP_CRITSEC_INFO         0x00000004
#define DP_CRITSEC_VERBOSE      0x00000008
#define DP_FATAL_ERROR          0x00000010

#define DP_CRITSEC_ALL          ( DP_CRITSEC_WARN | DP_CRITSEC_ERROR | DP_CRITSEC_INFO | DP_CRITSEC_VERBOSE )



#define MIN_VERBOSITY_LEVEL (DP_FATAL_ERROR | DP_CRITSEC_ERROR)

extern DWORD dwVerboseLevel;

#define DPRINT(dwFlag, args)        \
    if (dwFlag & dwVerboseLevel) {  \
        (DebugPrint) args;          \
    }



#endif

void DebugPrint(PTSTR, ...);


//
//
// RTTI: Used for sanity checks, to be removed from the retail version.
// Used to verify the type of object we are referencing.
//
// ei:
//    AssertType(pPointer, ClassFoo *);
//      Verify that the pointer we have is of that type.
//
//    AssertType(*pPointer, ClassFoo);
//      Verify that what we are pointing to, is of that object.
//
//    AssertChildOf(*pPointer, ClassFoo);
//      Verify that pPointer points to a class derived from ClassFoo.
//
#ifdef _CPPRTTI

BOOL RttiTypesEqual(const type_info & t1, const type_info & t2);

#define AssertType(Obj1, Obj2)		Assert( RttiTypesEqual(typeid(Obj1), typeid(Obj2)) )
#define AssertNotType(Obj1, Obj2)	Assert( !RttiTypesEqual(typeid(Obj1), typeid(Obj2)) )

#else

#define AssertType(Obj1, Obj2)					((void)0)
#define AssertNotType(Obj1, Obj2)				((void)0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\menu.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    Menu.h

Abstract:

    This module contains the function prototypes and identifiers for
    Windbg's menus and menu items.

--*/


//
// Offset from the bottom of the menu to the popup menu
//
//
//
//      File
//      |----------------|
//      | Open           |
//
//          etc....
//
//      |----------------|
//      | MRU Files     >|       GetMenuItemCount() - 4
//      | MRU Files     >|       GetMenuItemCount() - 3
//      |----------------|       GetMenuItemCount() - 2
//      | Exit           |       GetMenuItemCount() - 1
//      |----------------|
//



// Top-level popup menus must start at this value and
// be separated by this value.
// MENU_SIGNATURE is also added in.
#define IDM_BASE 100

//
// Width of names in File and Program menu.
//
#define FILES_MENU_WIDTH            ( 72 )

enum
{
    FILE_USE_UNUSED,
    FILE_USE_SOURCE,
    FILE_USE_DUMP,
    FILE_USE_EXECUTABLE,
};

#define MAX_MRU_FILES 16

struct MRU_ENTRY
{
    ULONG FileUse;
    // This array actually contains the full name, rounded
    // to an even multiple of four bytes.
    TCHAR FileName[4];
};

extern MRU_ENTRY* g_MruFiles[];
extern HMENU g_MruMenu;

VOID
InitializeMenu(
    IN HMENU hmenu
    );

UINT
CommandIdEnabled(
    IN UINT uMenuID
    );

VOID AddFileToMru(ULONG FileUse, PTSTR File);
ULONG GetMruSize(void);
PUCHAR ReadMru(PUCHAR Data, PUCHAR End);
PUCHAR WriteMru(PUCHAR Data);

//
// Menu Resource Signature
//

#define MENU_SIGNATURE              0x4000


//
// File
//

#define IDM_FILE                    ( 100 | MENU_SIGNATURE )
#define IDM_FILE_OPEN               ( IDM_FILE + 1 )
#define IDM_FILE_CLOSE              ( IDM_FILE + 2 )
// Separator.
#define IDM_FILE_OPEN_EXECUTABLE    ( IDM_FILE + 4 )
#define IDM_FILE_ATTACH             ( IDM_FILE + 5 )
#define IDM_FILE_OPEN_CRASH_DUMP    ( IDM_FILE + 6 )
#define IDM_FILE_CONNECT_TO_REMOTE  ( IDM_FILE + 7 )
#define IDM_FILE_KERNEL_DEBUG       ( IDM_FILE + 8 )
// Separator.
#define IDM_FILE_SYMBOL_PATH        ( IDM_FILE + 10 )
#define IDM_FILE_SOURCE_PATH        ( IDM_FILE + 11 )
#define IDM_FILE_IMAGE_PATH         ( IDM_FILE + 12 )
// Separator.
#define IDM_FILE_OPEN_WORKSPACE     ( IDM_FILE + 14 )
#define IDM_FILE_SAVE_WORKSPACE     ( IDM_FILE + 15 )
#define IDM_FILE_SAVE_WORKSPACE_AS  ( IDM_FILE + 16 )
#define IDM_FILE_CLEAR_WORKSPACE    ( IDM_FILE + 17 )
#define IDM_FILE_DELETE_WORKSPACES  ( IDM_FILE + 18 )
// Separator.
#define IDM_FILE_MAP_NET_DRIVE      ( IDM_FILE + 20 )
#define IDM_FILE_DISCONN_NET_DRIVE  ( IDM_FILE + 21 )
// Separator.

// MRUs must be in sequential order. That way a position can be
// calculated by: IDM_FILE_MRU_FILE5 - IDM_FILE_MRU_FILE1, etc...
#define IDM_FILE_MRU_FILE1          ( IDM_FILE + 23 )
#define IDM_FILE_MRU_FILE2          ( IDM_FILE_MRU_FILE1 + 1  )
#define IDM_FILE_MRU_FILE3          ( IDM_FILE_MRU_FILE1 + 2  )
#define IDM_FILE_MRU_FILE4          ( IDM_FILE_MRU_FILE1 + 3  )
#define IDM_FILE_MRU_FILE5          ( IDM_FILE_MRU_FILE1 + 4  )
#define IDM_FILE_MRU_FILE6          ( IDM_FILE_MRU_FILE1 + 5  )
#define IDM_FILE_MRU_FILE7          ( IDM_FILE_MRU_FILE1 + 6  )
#define IDM_FILE_MRU_FILE8          ( IDM_FILE_MRU_FILE1 + 7  )
#define IDM_FILE_MRU_FILE9          ( IDM_FILE_MRU_FILE1 + 8  )
#define IDM_FILE_MRU_FILE10         ( IDM_FILE_MRU_FILE1 + 9  )
#define IDM_FILE_MRU_FILE11         ( IDM_FILE_MRU_FILE1 + 10 )
#define IDM_FILE_MRU_FILE12         ( IDM_FILE_MRU_FILE1 + 11 )
#define IDM_FILE_MRU_FILE13         ( IDM_FILE_MRU_FILE1 + 12 )
#define IDM_FILE_MRU_FILE14         ( IDM_FILE_MRU_FILE1 + 13 )
#define IDM_FILE_MRU_FILE15         ( IDM_FILE_MRU_FILE1 + 14 )
#define IDM_FILE_MRU_FILE16         ( IDM_FILE_MRU_FILE1 + 15 )

// ditto. same as above
#define IDM_FILE_MRU_WORKSPACE1     ( IDM_FILE_MRU_FILE16 + 1 )
#define IDM_FILE_MRU_WORKSPACE2     ( IDM_FILE_MRU_WORKSPACE1 + 1  )
#define IDM_FILE_MRU_WORKSPACE3     ( IDM_FILE_MRU_WORKSPACE1 + 2  )
#define IDM_FILE_MRU_WORKSPACE4     ( IDM_FILE_MRU_WORKSPACE1 + 3  )
#define IDM_FILE_MRU_WORKSPACE5     ( IDM_FILE_MRU_WORKSPACE1 + 4  )
#define IDM_FILE_MRU_WORKSPACE6     ( IDM_FILE_MRU_WORKSPACE1 + 5  )
#define IDM_FILE_MRU_WORKSPACE7     ( IDM_FILE_MRU_WORKSPACE1 + 6  )
#define IDM_FILE_MRU_WORKSPACE8     ( IDM_FILE_MRU_WORKSPACE1 + 7  )
#define IDM_FILE_MRU_WORKSPACE9     ( IDM_FILE_MRU_WORKSPACE1 + 8  )
#define IDM_FILE_MRU_WORKSPACE10    ( IDM_FILE_MRU_WORKSPACE1 + 9  )
#define IDM_FILE_MRU_WORKSPACE11    ( IDM_FILE_MRU_WORKSPACE1 + 10 )
#define IDM_FILE_MRU_WORKSPACE12    ( IDM_FILE_MRU_WORKSPACE1 + 11 )
#define IDM_FILE_MRU_WORKSPACE13    ( IDM_FILE_MRU_WORKSPACE1 + 12 )
#define IDM_FILE_MRU_WORKSPACE14    ( IDM_FILE_MRU_WORKSPACE1 + 13 )
#define IDM_FILE_MRU_WORKSPACE15    ( IDM_FILE_MRU_WORKSPACE1 + 14 )
#define IDM_FILE_MRU_WORKSPACE16    ( IDM_FILE_MRU_WORKSPACE1 + 15 )

// Included temporarily
#define IDM_FILE_EXIT               ( IDM_FILE_MRU_WORKSPACE16 + 1)
#define IDM_FILE_FIRST              IDM_FILE
#define IDM_FILE_LAST               IDM_FILE_EXIT


//
// Edit
//

#define IDM_EDIT                    ( 200 | MENU_SIGNATURE )
#define IDM_EDIT_CUT                ( IDM_EDIT + 1 )
#define IDM_EDIT_COPY               ( IDM_EDIT + 2 )
#define IDM_EDIT_PASTE              ( IDM_EDIT + 3 )
#define IDM_EDIT_SELECT_ALL         ( IDM_EDIT + 4 )
#define IDM_EDIT_ADD_TO_COMMAND_HISTORY ( IDM_EDIT + 5 )
#define IDM_EDIT_CLEAR_COMMAND_HISTORY ( IDM_EDIT + 6 )
#define IDM_EDIT_FIND               ( IDM_EDIT + 7 )
#define IDM_EDIT_GOTO_ADDRESS       ( IDM_EDIT + 8 )
#define IDM_EDIT_GOTO_LINE          ( IDM_EDIT + 9 )
#define IDM_EDIT_BREAKPOINTS        ( IDM_EDIT + 10 )
#define IDM_EDIT_TOGGLEBREAKPOINT   ( IDM_EDIT + 11 )
#define IDM_EDIT_LOG_FILE           ( IDM_EDIT + 12 )
#define IDM_EDIT_PROPERTIES         ( IDM_EDIT + 13 )
#define IDM_EDIT_FIRST              IDM_EDIT
#define IDM_EDIT_LAST               IDM_EDIT_PROPERTIES


//
// View
//

#define IDM_VIEW                    ( 300 | MENU_SIGNATURE )
#define IDM_VIEW_WATCH              ( IDM_VIEW + 1 )
#define IDM_VIEW_CALLSTACK          ( IDM_VIEW + 2 )
#define IDM_VIEW_MEMORY             ( IDM_VIEW + 3 )
#define IDM_VIEW_LOCALS             ( IDM_VIEW + 4 )
#define IDM_VIEW_REGISTERS          ( IDM_VIEW + 5 )
#define IDM_VIEW_DISASM             ( IDM_VIEW + 6 )
#define IDM_VIEW_COMMAND            ( IDM_VIEW + 7 )
#define IDM_VIEW_SCRATCH            ( IDM_VIEW + 8 )
#define IDM_VIEW_PROCESS_THREAD     ( IDM_VIEW + 9 )
#define IDM_VIEW_TOGGLE_VERBOSE     ( IDM_VIEW + 10 )
#define IDM_VIEW_SHOW_VERSION       ( IDM_VIEW + 11 )
#define IDM_VIEW_TOOLBAR            ( IDM_VIEW + 12 )
#define IDM_VIEW_STATUS             ( IDM_VIEW + 13 )
#define IDM_VIEW_FONT               ( IDM_VIEW + 14 )
#define IDM_VIEW_COLORS             ( IDM_VIEW + 15 )
#define IDM_VIEW_OPTIONS            ( IDM_VIEW + 16 )
#define IDM_VIEW_FIRST              IDM_VIEW
#define IDM_VIEW_LAST               IDM_VIEW_OPTIONS


//
// Debug
//

#define IDM_DEBUG                   ( 400 | MENU_SIGNATURE )
#define IDM_DEBUG_GO                ( IDM_DEBUG + 1 )
#define IDM_DEBUG_GO_HANDLED        ( IDM_DEBUG + 2 )
#define IDM_DEBUG_GO_UNHANDLED      ( IDM_DEBUG + 3 )
#define IDM_DEBUG_RESTART           ( IDM_DEBUG + 4 )
#define IDM_DEBUG_STOPDEBUGGING     ( IDM_DEBUG + 5 )
#define IDM_DEBUG_BREAK             ( IDM_DEBUG + 6 )
#define IDM_DEBUG_STEPINTO          ( IDM_DEBUG + 7 )
#define IDM_DEBUG_STEPOVER          ( IDM_DEBUG + 8 )
#define IDM_DEBUG_STEPOUT           ( IDM_DEBUG + 9 )
#define IDM_DEBUG_RUNTOCURSOR       ( IDM_DEBUG + 10 )
#define IDM_DEBUG_SOURCE_MODE       ( IDM_DEBUG + 11 )
#define IDM_DEBUG_EVENT_FILTERS     ( IDM_DEBUG + 12 )
#define IDM_DEBUG_MODULES           ( IDM_DEBUG + 13 )
#define IDM_DEBUG_KDEBUG            ( IDM_DEBUG + 14 )

// These are not used by the menu but by the toolbar
#define IDM_DEBUG_SOURCE_MODE_ON    ( IDM_DEBUG + 15 )
#define IDM_DEBUG_SOURCE_MODE_OFF   ( IDM_DEBUG + 16 )

// Not used by the toolbar or menu, but by the accelerator table
#define IDM_DEBUG_CTRL_C            ( IDM_DEBUG + 17 )

#define IDM_DEBUG_FIRST             IDM_DEBUG
#define IDM_DEBUG_LAST              IDM_DEBUG_KDEBUG


//
// Window
//

#define IDM_WINDOW                  ( 500 | MENU_SIGNATURE )
#define IDM_WINDOW_CASCADE          ( IDM_WINDOW + 1 )
#define IDM_WINDOW_TILE_HORZ        ( IDM_WINDOW + 2 )
#define IDM_WINDOW_TILE_VERT        ( IDM_WINDOW + 3 )
#define IDM_WINDOW_ARRANGE          ( IDM_WINDOW + 4 )
#define IDM_WINDOW_ARRANGE_ICONS    ( IDM_WINDOW + 5 )
#define IDM_WINDOW_AUTO_ARRANGE     ( IDM_WINDOW + 6 )
#define IDM_WINDOW_ARRANGE_ALL      ( IDM_WINDOW + 7 )
#define IDM_WINDOW_OVERLAY_SOURCE   ( IDM_WINDOW + 8 )
#define IDM_WINDOW_AUTO_DISASM      ( IDM_WINDOW + 9 )
#define IDM_WINDOWCHILD             ( IDM_WINDOW + 10 )
#define IDM_WINDOW_FIRST            IDM_WINDOW
#define IDM_WINDOW_LAST             IDM_WINDOWCHILD



//
// Help
//

#define IDM_HELP                    ( 600 | MENU_SIGNATURE )
#define IDM_HELP_CONTENTS           ( IDM_HELP + 1 )
#define IDM_HELP_INDEX              ( IDM_HELP + 2 )
#define IDM_HELP_SEARCH             ( IDM_HELP + 3 )
#define IDM_HELP_ABOUT              ( IDM_HELP + 4 )
#define IDM_HELP_FIRST              IDM_HELP
#define IDM_HELP_LAST               IDM_HELP_ABOUT



//
// Debug.Kernel submenu.
//

#define IDM_KDEBUG                  ( 10000 | MENU_SIGNATURE )
#define IDM_KDEBUG_TOGGLE_BAUDRATE  ( IDM_KDEBUG + 1 )
#define IDM_KDEBUG_TOGGLE_DEBUG     ( IDM_KDEBUG + 2 )
#define IDM_KDEBUG_TOGGLE_INITBREAK ( IDM_KDEBUG + 3 )
#define IDM_KDEBUG_RECONNECT        ( IDM_KDEBUG + 4 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\resource.h ===
#define HELPCURSOR      3001


// These icons must have the same enumeration order
// as WIN_TYPES.
#define WINDBGICON      3002
#define DOCICON         3003
#define WATCHICON       3004
#define LOCALSICON      3005
#define CPUICON         3006
#define DISASMICON      3007
#define CMDICON         3008
#define SPADICON        3009
#define MEMORYICON      3010
#define QUICKWICON      3011
#define CALLSTACKICON   3012
#define PROCTHREADICON  3013

#define MINVAL_WINDOW_ICON WINDBGICON


#define IDB_BMP_TOOLBAR     3040



#define MAIN_MENU           3050
#define MAIN_ACC            3051
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\prcdlg.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 2000  Microsoft Corporation

Module Name:

    prcdlg.h

Abstract:

    Header file for dialog-related functions.

--*/

#ifndef _PRCDLG_H_
#define _PRCDLG_H_

#define SHORT_MSG 256

// Find dialog, if open.
extern HWND g_FindDialog;
// Find text.
extern char g_FindText[256];
// Message code for FINDMSGSTRING.
extern UINT g_FindMsgString;
extern FINDREPLACE g_FindRep;
extern PCOMMONWIN_DATA g_FindLast;

extern char g_ComSettings[64];
extern char g_1394Settings[64];

PTSTR __cdecl BufferString(PTSTR Buffer, ULONG Size, ULONG StrId, ...);
void SendLockStatusMessage(HWND Win, UINT Msg, HRESULT Status);

BpStateType IsBpAtOffset(BpBufferData* DataIn, ULONG64 Offset, PULONG Id);

void StartKdPropSheet(void);

INT_PTR CALLBACK DlgProc_SetBreak(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_ConnectToRemote(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_SymbolPath(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_RegCustomize(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_GotoLine(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_GotoAddress(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_LogFile(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_KernelCom(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Kernel1394(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_KernelLocal(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_ImagePath(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_SourcePath(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_AttachProcess(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_EventFilters(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_ExceptionFilter(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_FilterArgument(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_FilterCommand(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Options(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_ClearWorkspace(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Modules(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_OpenWorkspace(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_SaveWorkspaceAs(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_AddToCommandHistory(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_DeleteWorkspaces(HWND, UINT, WPARAM, LPARAM);

extern TCHAR szOpenExeArgs[];
UINT_PTR OpenExeWithArgsHookProc(HWND, UINT, WPARAM, LPARAM);

BOOL CreateIndexedFont(ULONG FontIndex, BOOL SetAll);
void SelectFont(HWND Parent, ULONG FontIndex);

BOOL SelectColor(HWND Parent, ULONG Index);

#endif // #ifndef _PRCDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\prcdlg.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    prcdlg.cpp

Abstract:

    Contains dialog-related functions.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <time.h>

// Remote client workspaces do not contain engine information
// since a remote client attaches to many engines and it's
// rare that you'd want the same piece of engine information
// applied to every connect.
#define SAVE_ENGINE_WORKSPACE() \
    (g_Workspace != NULL && !g_RemoteClient)
#define DIRTY_ENGINE_WORKSPACE(Flags) FALSE

// Find dialog, if open.
HWND g_FindDialog;
// Find text.
char g_FindText[256];
// Message code for FINDMSGSTRING.
UINT g_FindMsgString;
FINDREPLACE g_FindRep;
PCOMMONWIN_DATA g_FindLast;

char g_ComSettings[64];
char g_1394Settings[64];

TCHAR szOpenExeArgs[2 * _MAX_PATH];
TCHAR g_DlgString[2 * _MAX_PATH];
TCHAR g_DlgString2[2 * _MAX_PATH];

PCSTR g_ExecutionNames[] =
{
    "enabled", "disabled", "output", "ignore"
};
PCSTR g_ContinueNames[] =
{
    "handled", "not handled"
};

PSTR g_SymbolTypeNames[] =
{
    "None", "COFF", "CodeView", "PDB", "Export", "Deferred", "Sym",
    "DIA",
};

PTSTR __cdecl
BufferString(PTSTR Buffer, ULONG Size, ULONG StrId, ...)
{
    va_list Args;
    TCHAR FmtStr[SHORT_MSG];

    Buffer[0] = 0;
    Buffer[Size - 1] = 0;
    Dbg(LoadString(g_hInst, StrId, FmtStr, _tsizeof(FmtStr)));
    va_start(Args, StrId);
    _vsnprintf(Buffer, Size, FmtStr, Args);
    va_end(Args);
    return Buffer;
}

void
SendLockStatusMessage(HWND Win, UINT Msg, HRESULT Status)
{
    TCHAR Str[SHORT_MSG];

    if (FAILED(Status))
    {
        BufferString(Str, _tsizeof(Str), ERR_Unable_To_Retrieve_Info,
                     FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        BufferString(Str, _tsizeof(Str),
                     STR_Retrieving_Information);
    }
    SendMessage(Win, Msg, 0, (LPARAM)Str);
}

BpStateType
IsBpAtOffset(BpBufferData* DataIn, ULONG64 Offset, PULONG Id)
{
    BpBufferData* Data;
    
    if (DataIn == NULL)
    {
        if (g_BpBuffer->UiLockForRead() != S_OK)
        {
            return BP_NONE;
        }

        Data = (BpBufferData*)g_BpBuffer->GetDataBuffer();
    }
    else
    {
        Data = DataIn;
    }
    
    ULONG i;
    BpStateType BpState = BP_NONE;

    for (i = 0; i < g_BpCount; i++)
    {
        if (Data->Offset != DEBUG_INVALID_OFFSET &&
            Data->Offset == Offset)
        {
            if (Data->Flags & DEBUG_BREAKPOINT_ENABLED)
            {
                BpState = BP_ENABLED;
            }
            else
            {
                BpState = BP_DISABLED;
            }
            if (Id != NULL)
            {
                *Id = Data->Id;
            }
            break;
        }

        Data++;
    }

    if (DataIn == NULL)
    {
        UnlockStateBuffer(g_BpBuffer);
    }

    return BpState;
}

BOOL
GetBpBufferData(ULONG Index, BpBufferData* RetData)
{
    if (Index >= g_BpCount ||
        g_BpBuffer->UiLockForRead() != S_OK)
    {
        return FALSE;
    }

    BpBufferData* Data = (BpBufferData*)g_BpBuffer->GetDataBuffer();
    *RetData = Data[Index];

    UnlockStateBuffer(g_BpBuffer);
    return TRUE;
}

void
EnableBpButtons(BOOL UpdateThread)
{
    HWND Dlg = g_BpBuffer->m_Win;
    
    LRESULT Sel = SendDlgItemMessage(Dlg, ID_SETBREAK_BREAKPOINT,
                                     LB_GETCURSEL, 0, 0);
    BOOL Enable = Sel != LB_ERR;

    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_REMOVE), Enable);
    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_DISABLE), Enable);
    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_ENABLE), Enable);

    if (UpdateThread)
    {
        BpBufferData Data;
        char Text[16];

        Text[0] = 0;
        if (Sel >= 0 &&
            GetBpBufferData((ULONG)Sel, &Data) &&
            Data.Thread != DEBUG_ANY_ID)
        {
            _itoa(Data.Thread, Text, 10);
        }
        SetWindowText(GetDlgItem(Dlg, ID_SETBREAK_THREAD), Text);
    }
    
    EnableWindow(GetDlgItem(Dlg, ID_SETBREAK_THREAD),
                 GetWindowTextLength(GetDlgItem(Dlg,
                                                ID_SETBREAK_COMMAND)) > 0);
}

void
FillBpList(HWND List)
{
    HRESULT Status;
    ULONG Width;
    RECT ListRect;

    LRESULT ListSel = SendMessage(List, LB_GETCURSEL, 0, 0);
    SendMessage(List, WM_SETREDRAW, FALSE, 0);
    SendMessage(List, LB_RESETCONTENT, 0, 0);

    GetClientRect(List, &ListRect);
    Width = ListRect.right - ListRect.left;
    
    Status = g_BpBuffer->UiLockForRead();
    if (Status == S_OK)
    {
        PSTR Buf = (PSTR)g_BpBuffer->GetDataBuffer() + g_BpTextOffset;
        // Ignore trailing terminator.
        PSTR End = (PSTR)g_BpBuffer->GetDataBuffer() +
            g_BpBuffer->GetDataLen() - 1;

        while (Buf < End)
        {
            ULONG Len, BufWidth;

            Len = strlen(Buf) + 1;
            if (Len == 1)
            {
                // Break out on empty lines to avoid displaying
                // kernel internal breakpoint information and blank
                // line separating it from the normal breakpoints.
                break;
            }
            
            SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Buf);

            // Extra char in Len due to terminator ensures there's
            // a character of extra space to the right side.
            BufWidth = g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * Len;
            if (BufWidth > Width)
            {
                Width = BufWidth;
            }
            
            Buf += Len;
        }

        UnlockStateBuffer(g_BpBuffer);
    }
    else
    {
        SendLockStatusMessage(List, LB_ADDSTRING, Status);
    }

    SendMessage(List, LB_SETHORIZONTALEXTENT, Width, 0);
    SendMessage(List, WM_SETREDRAW, TRUE, 0);
    if (ListSel != LB_ERR)
    {
        SendMessage(List, LB_SETCURSEL, ListSel, 0);
    }
    EnableBpButtons(TRUE);
}

ULONG
GetBpListId(HWND List)
{
    LRESULT ListSel = SendMessage(List, LB_GETCURSEL, 0, 0);
    if (ListSel == LB_ERR)
    {
        return DEBUG_ANY_ID;
    }

    LRESULT Len = SendMessage(List, LB_GETTEXTLEN, ListSel, 0);
    PSTR Buf = (PSTR)malloc(Len + 1);
    if (Buf == NULL)
    {
        return DEBUG_ANY_ID;
    }

    SendMessage(List, LB_GETTEXT, ListSel, (LPARAM)Buf);

    ULONG Id;
    if (sscanf(Buf, "%d", &Id) != 1)
    {
        return DEBUG_ANY_ID;
    }
    else
    {
        return Id;
    }
}

// Space for "Pending: ".
#define BP_PENDING_CHARS 9

void
AddBpCommandString(HWND List, PSTR Buf, ULONG Thread)
{
    BOOL HasThread = FALSE;
    BOOL IsBpCmd = FALSE;
    PCSTR Scan;

    //
    // If the string looks like a real command just pass
    // it on for execution.  Otherwise, assume it's
    // a code breakpoint address expression.
    //
    
    Scan = Buf + BP_PENDING_CHARS;
    
    if (*Scan == '~')
    {
        Scan++;
        HasThread = TRUE;
        
        // Skip optional thread indicator.
        if (*Scan == '.' || *Scan == '#')
        {
            Scan++;
        }
        else
        {
            while (*Scan >= '0' && *Scan <= '9')
            {
                Scan++;
            }
        }
    }
    
    if (*Scan == 'b' || *Scan == 'B')
    {
        Scan++;
        if (*Scan == 'a' || *Scan == 'A' ||
            *Scan == 'i' || *Scan == 'I' ||
            *Scan == 'p' || *Scan == 'P' ||
            *Scan == 'u' || *Scan == 'U' ||
            *Scan == 'w' || *Scan == 'W')
        {
            Scan++;

            // Skip optional bp id.
            while (*Scan >= '0' && *Scan <= '9')
            {
                Scan++;
            }
            
            if (*Scan == ' ')
            {
                IsBpCmd = TRUE;
            }
        }
        else if (*Scan == 'c' || *Scan == 'C' ||
                 *Scan == 'd' || *Scan == 'D' ||
                 *Scan == 'e' || *Scan == 'E')
        {
            Scan++;
            if (*Scan == ' ')
            {
                IsBpCmd = TRUE;
            }
        }
    }

    // Immediately add the breakpoint string to the listbox
    // to indicate that it's pending.
    memcpy(Buf, "Pending: ", BP_PENDING_CHARS);
    LRESULT Sel = SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Buf);
    if (Sel != LB_ERR && Sel != LB_ERRSPACE)
    {
        SendMessage(List, LB_SETCURSEL, Sel, 0);
    }

    Buf += BP_PENDING_CHARS;
    if (IsBpCmd)
    {
        if (HasThread || Thread == DEBUG_ANY_ID)
        {
            AddStringCommand(UIC_SILENT_EXECUTE, Buf);
        }
        else
        {
            PrintStringCommand(UIC_SILENT_EXECUTE, "~%d%s",
                               Thread, Buf);
        }
    }
    else if (Thread == DEBUG_ANY_ID)
    {
        PrintStringCommand(UIC_SILENT_EXECUTE, "bu %s", Buf);
    }
    else
    {
        PrintStringCommand(UIC_SILENT_EXECUTE, "~%dbu %s", Thread, Buf);
    }
}

INT_PTR CALLBACK
DlgProc_SetBreak(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    static UINT s_CmdLen;
    HWND List;
    HWND Ctrl;
    ULONG Id;
    
    List = GetDlgItem(Hwnd, ID_SETBREAK_BREAKPOINT);
    switch(Message)
    {
    case WM_INITDIALOG:
        s_CmdLen = 0;
        g_BpBuffer->m_Win = Hwnd;
        SendMessage(List, WM_SETFONT, (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
        SendMessage(List, LB_SETCURSEL, -1, 0);
        FillBpList(List);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case ID_SETBREAK_COMMAND:
            if (HIWORD(Wpm) == EN_CHANGE)
            {
                EnableBpButtons(FALSE);

                UINT NewLen = GetWindowTextLength
                    (GetDlgItem(Hwnd, ID_SETBREAK_COMMAND));
                if (NewLen == 1 && s_CmdLen == 0)
                {
                    // If we're starting a new breakpoint command
                    // default the thread to nothing.
                    SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_THREAD), "");
                }
                s_CmdLen = NewLen;
            }
            break;
            
        case ID_SETBREAK_BREAKPOINT:
            SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_COMMAND), "");
            EnableBpButtons(TRUE);
            break;
            
        case ID_SETBREAK_REMOVE:
            Id = GetBpListId(List);
            if (Id != DEBUG_ANY_ID)
            {
                SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_COMMAND), "");
                PrintStringCommand(UIC_SILENT_EXECUTE, "bc %d", Id);
                DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
            }
            break;

        case ID_SETBREAK_REMOVEALL:
            SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_COMMAND), "");
            AddStringCommand(UIC_SILENT_EXECUTE, "bc *");
            DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
            break;
            
        case ID_SETBREAK_ENABLE:
        case ID_SETBREAK_DISABLE:
            Id = GetBpListId(List);
            if (Id != DEBUG_ANY_ID)
            {
                SetWindowText(GetDlgItem(Hwnd, ID_SETBREAK_COMMAND), "");
                PrintStringCommand(UIC_SILENT_EXECUTE, "b%c %d",
                                   LOWORD(Wpm) == ID_SETBREAK_ENABLE ?
                                   'e' : 'd', Id);
                DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_BREAKPOINTS);
            break;
            
        case IDOK:
            char Buf[1024 + BP_PENDING_CHARS];
            UINT Thread;
            BOOL ThreadValid;

            Thread = GetDlgItemInt(Hwnd, ID_SETBREAK_THREAD,
                                   &ThreadValid, FALSE);
            if (!ThreadValid)
            {
                Thread = DEBUG_ANY_ID;
            }
            
            Ctrl = GetDlgItem(Hwnd, ID_SETBREAK_COMMAND);
            if (SendMessage(Ctrl, WM_GETTEXT, sizeof(Buf) - BP_PENDING_CHARS,
                            (LPARAM)(Buf + BP_PENDING_CHARS)) > 0)
            {
                AddBpCommandString(List, Buf, Thread);
                DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
                SendMessage(Ctrl, WM_SETTEXT, 0, (LPARAM)"");
                // A command was executed so do not close the dialog.
                break;
            }
            
            // No command so fall through to close dialog.
            
        case IDCANCEL:
            g_BpBuffer->m_Win = NULL;
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    case LB_RESETCONTENT:
        FillBpList(List);
        break;
        
    default:
        return FALSE;
    }

    return TRUE;
}


UINT_PTR
OpenExeWithArgsHookProc(
    HWND    hDlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Allows the user to specify command line arguments when opening an
    executable.

Return Value:

    TRUE if we replaced default processing of the message, FALSE otherwise

--*/
{
    switch(msg)
    {
    case WM_INITDIALOG:
        CheckDlgButton(hDlg, IDC_EXEOPEN_CHILD_PROCESSES, FALSE);
        return TRUE;

    case WM_NOTIFY:
        if (((LPOFNOTIFY) lParam)->hdr.code == CDN_FILEOK)
        {
            *szOpenExeArgs = _T(' ');

            GetDlgItemText(hDlg,
                           IDC_EDIT_ARGS,
                           szOpenExeArgs + 1,
                           sizeof(szOpenExeArgs) - 1);
            
            if (IsDlgButtonChecked(hDlg, IDC_EXEOPEN_CHILD_PROCESSES) ==
                BST_CHECKED)
            {
                g_DebugCreateFlags |= DEBUG_PROCESS;
                g_DebugCreateFlags &= ~DEBUG_ONLY_THIS_PROCESS;
            }
            else
            {
                g_DebugCreateFlags &= ~DEBUG_PROCESS;
                g_DebugCreateFlags |= DEBUG_ONLY_THIS_PROCESS;
            }
            
            return 0;
        }
    }

    return DlgFile(hDlg, msg, wParam, lParam);
}

#define NO_SERVERS "No servers registered"

void
FillServersList(HWND List, PCSTR Machine)
{
    HRESULT Status;
    
    g_pUiClient->SetOutputCallbacks(&g_UiOutStateBuf);
    g_UiOutStateBuf.SetBuffer(&g_UiOutputCapture);
    g_UiOutStateBuf.Start(TRUE);
    Status = g_pUiClient->OutputServers(DEBUG_OUTCTL_THIS_CLIENT, Machine,
                                        DEBUG_SERVERS_DEBUGGER);
    g_pUiClient->SetOutputCallbacks(NULL);
    if (Status == S_OK)
    {
        Status = g_UiOutStateBuf.End(FALSE);
    }
    else
    {
        g_UiOutStateBuf.End(FALSE);
    }
    g_UiOutStateBuf.ReplaceChar('\n', 0);

    SendMessage(List, LB_RESETCONTENT, 0, 0);
    if (Status == S_OK)
    {
        PSTR Line, End;
    
        Line = (PSTR)g_UiOutputCapture.GetDataBuffer();
        End = Line + g_UiOutputCapture.GetDataLen() - 1;
        if (Line == NULL || Line >= End)
        {
            SendMessage(List, LB_ADDSTRING, 0, (LPARAM)NO_SERVERS);
        }
        else
        {
            while (Line < End)
            {
                SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Line);
                Line += strlen(Line) + 1;
            }
        }
    }
    else
    {
        SendLockStatusMessage(List, LB_ADDSTRING, Status);
    }
    SendMessage(List, LB_SETCURSEL, 0, 0);

    g_UiOutputCapture.Free();
}

INT_PTR CALLBACK
DlgProc_BrowseServers(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Machine[128];
    LRESULT Sel;

    switch(Message)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(Hwnd, IDC_BROWSE_MACHINE, EM_LIMITTEXT,
                           sizeof(Machine) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_BROWSE_MACHINE), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_BROWSE_REFRESH:
            if (SendDlgItemMessage(Hwnd, IDC_BROWSE_MACHINE, WM_GETTEXT,
                                   sizeof(Machine), (LPARAM)Machine))
            {
                FillServersList(GetDlgItem(Hwnd, IDC_BROWSE_SERVERS_LIST),
                                Machine);
            }
            break;

        case IDC_BROWSE_SERVERS_LIST:
            switch(HIWORD(Wpm))
            {
            case LBN_DBLCLK:
                Wpm = IDOK;
                goto SelectAndEnd;
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_CONNECT_TO_REMOTE_SESSION);
            break;
            
        case IDOK:
        SelectAndEnd:
            Sel = SendDlgItemMessage(Hwnd, IDC_BROWSE_SERVERS_LIST,
                                     LB_GETCURSEL, 0, 0);
            if (Sel >= 0 &&
                SendDlgItemMessage(Hwnd, IDC_BROWSE_SERVERS_LIST,
                                   LB_GETTEXT, Sel, (LPARAM)g_DlgString) > 0 &&
                strcmp(g_DlgString, NO_SERVERS) &&
                SendDlgItemMessage(Hwnd, IDC_BROWSE_MACHINE, WM_GETTEXT,
                                   sizeof(Machine), (LPARAM)Machine))
            {
                strcat(g_DlgString, ",Server=");
                strcat(g_DlgString, Machine);
            }
            else
            {
                g_DlgString[0] = 0;
            }
            
            // Fall through.
            
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK
DlgProc_ConnectToRemote(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    TCHAR ConnectString[1024];

    switch (Message)
    {
    case WM_INITDIALOG:
        //
        // Set up the controls to reflect current values
        //
        SendDlgItemMessage(Hwnd, IDC_REM_CONNECT, EM_LIMITTEXT,
                           sizeof(ConnectString) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_REM_CONNECT), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_REM_BROWSE:
            if (StartDialog(IDD_DLG_BROWSE_SERVERS, DlgProc_BrowseServers,
                            NULL) == IDOK && g_DlgString[0])
            {
                // Skip "<Server type> - " at the beginning.
                PSTR Start = strchr(g_DlgString, '-');
                if (Start != NULL)
                {
                    SetWindowText(GetDlgItem(Hwnd, IDC_REM_CONNECT),
                                  Start + 2);
                }
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_CONNECT_TO_REMOTE_SESSION);
            break;
            
        case IDOK:
            if (SendDlgItemMessage(Hwnd, IDC_REM_CONNECT, WM_GETTEXT,
                                   sizeof(ConnectString),
                                   (LPARAM)ConnectString))
            {
                if (CreateUiInterfaces(TRUE, ConnectString))
                {
                    StartDebugging();
                    EndDialog(Hwnd, IDOK);
                }
                else if (!CreateUiInterfaces(FALSE, NULL))
                {
                    // CreateUiInterfaces discards any previous
                    // interfaces so we need to recreate something
                    // so there are UI thread interfaces.
                    InformationBox(ERR_Internal_Error, E_OUTOFMEMORY,
                                   "CreateUiInterfaces");
                    ErrorExit(NULL, "Unable to recreate UI interfaces\n");
                }
            }

            return TRUE;

        case IDCANCEL:
            EndDialog(Hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR
CALLBACK
DlgProc_SymbolPath(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    TCHAR   SymPath[MAX_ENGINE_PATH];
    ULONG   PathSize;
    LRESULT Size;
    HRESULT Hr;

    switch (Message)
    {
    case WM_INITDIALOG:
        Hr = g_pUiSymbols->GetSymbolPath(SymPath, _tsizeof(SymPath),
                                         &PathSize);
        if (Hr != S_OK)
        {
            InformationBox(ERR_Internal_Error, Hr, "UI GetSymPath");
        }

        SendDlgItemMessage(Hwnd, IDC_SYMPATH, WM_SETTEXT, 0, (LPARAM)SymPath);

        //
        // Set up the controls to reflect current values
        //
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_SYMBOL_PATH);
            break;
            
        case IDOK:
            Size = SendDlgItemMessage(Hwnd, IDC_SYMPATH, WM_GETTEXT,
                                      sizeof(SymPath), (LPARAM)SymPath);
            if (Size == 0)
            {
                InformationBox(ERR_Path_Empty);
                SetFocus(Hwnd);
                return TRUE;
            }
            SymPath[Size] = 0;

            Hr = g_pUiSymbols->SetSymbolPath(SymPath);
            if (Hr != S_OK)
            {
                InformationBox(ERR_Internal_Error, Hr, "UI SetSymPath");
            }

            if (SAVE_ENGINE_WORKSPACE())
            {
                g_Workspace->SetString(WSP_GLOBAL_SYMBOL_PATH, SymPath);
            }
                                             
            EndDialog(Hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(Hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK
DlgProc_RegCustomize(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    CPUWIN_DATA* CpuWin;

    switch(Message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(Hwnd, DWLP_USER, Lpm);
        GetRegisterMapText(GetDlgItem(Hwnd, IDC_REGCUST_ENTRY));
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_REGISTERS);
            break;
            
        case IDOK:
            ScanRegisterMapText(GetDlgItem(Hwnd, IDC_REGCUST_ENTRY));

            if (g_RegisterMap != NULL && g_Workspace != NULL)
            {
                g_Workspace->SetBuffer(WSP_GLOBAL_REGISTER_MAP,
                                       g_RegisterMap, g_RegisterMapEntries *
                                       sizeof(*g_RegisterMap));
            }
            
            CpuWin = (CPUWIN_DATA*)GetWindowLongPtr(Hwnd, DWLP_USER);
            CpuWin->UpdateNames((PSTR)g_RegisterNamesBuffer->GetDataBuffer());
            CpuWin->OnUpdate(UPDATE_BUFFER);
            
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_GotoLine(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Text[MAX_COMMAND_LEN];
    int Line;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(Hwnd, DWLP_USER, Lpm);
        SendDlgItemMessage(Hwnd, IDC_LINE_ENTRY, EM_LIMITTEXT,
                           sizeof(Text) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_LINE_ENTRY), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_GO_TO_LINE);
            break;
            
        case IDOK:
            COMMONWIN_DATA* CommonWinData;
            CommonWinData = (COMMONWIN_DATA*)GetWindowLongPtr(Hwnd, DWLP_USER);
            GetWindowText(GetDlgItem(Hwnd, IDC_LINE_ENTRY),
                          Text, sizeof(Text));
            Line = atoi(Text);
            if (Line > 0)
            {
                CommonWinData->GotoLine(Line);
            }
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_GotoAddress(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Text[MAX_COMMAND_LEN];
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(Hwnd, IDC_ADDRESS_ENTRY, EM_LIMITTEXT,
                           sizeof(Text) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_ADDRESS_ENTRY), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_GO_TO_ADDRESS);
            break;
            
        case IDOK:
            GetWindowText(GetDlgItem(Hwnd, IDC_ADDRESS_ENTRY),
                          Text, sizeof(Text));
            AddStringCommand(UIC_DISPLAY_CODE_EXPR, Text);
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_LogFile(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HRESULT Status;
    char LogFile[MAX_PATH];
    BOOL Append;
    HWND Ctrl;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        Append = FALSE;
        Ctrl = GetDlgItem(Hwnd, IDC_LOG_FILE_NAME);
        SendMessage(Ctrl, EM_LIMITTEXT, sizeof(LogFile) - 1, 0);
        Status = g_pUiControl->GetLogFile(LogFile, sizeof(LogFile), NULL,
                                          &Append);
        if (Status == E_NOINTERFACE)
        {
            // No current log file.
            SetWindowText(Ctrl, "");
        }
        else if (Status != S_OK)
        {
            SetWindowText(Ctrl, "Unable to retrieve name");
        }
        else
        {
            SetWindowText(Ctrl, LogFile);
        }
        EnableWindow(GetDlgItem(Hwnd, IDC_LOG_CLOSE), Status == S_OK);
        CheckDlgButton(Hwnd, IDC_LOG_APPEND,
                       Append ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_LOG_CLOSE:
            g_pUiControl->CloseLogFile();
            DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_LOG_FILE);
            SetWindowText(GetDlgItem(Hwnd, IDC_LOG_FILE_NAME), "");
            EnableWindow(GetDlgItem(Hwnd, IDC_LOG_CLOSE), FALSE);
            break;

        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_LOG_FILE);
            break;
            
        case IDOK:
            GetWindowText(GetDlgItem(Hwnd, IDC_LOG_FILE_NAME),
                          LogFile, sizeof(LogFile));
            Append = IsDlgButtonChecked(Hwnd, IDC_LOG_APPEND) ==
                BST_CHECKED;
            if (LogFile[0] != 0)
            {
                g_pUiControl->OpenLogFile(LogFile, Append);
                DIRTY_ENGINE_WORKSPACE(WSPF_DIRTY_LOG_FILE);
            }
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

DLGPROC g_CurrentKd;

INT_PTR
CALLBACK
DlgProc_KernelCom(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    PSTR Sep;
    
    switch (Message)
    {
    case WM_INITDIALOG:
        //
        // Set up the controls to reflect current values
        //
        SetWindowText(GetDlgItem(Hwnd, IDC_KD_PORT), g_ComSettings);
        SetWindowText(GetDlgItem(Hwnd, IDC_KD_BAUDRATE),
                      g_ComSettings + strlen(g_ComSettings) + 1);
        break;

    case WM_NOTIFY:
        switch(((LPNMHDR)Lpm)->code)
        {
        case PSN_HELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_KERNEL_DEBUGGING);
            break;

        case PSN_SETACTIVE:
            g_CurrentKd = DlgProc_KernelCom;
            return 0;
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, FALSE);
            return FALSE;
            
        case PSN_APPLY:
            if (g_CurrentKd != DlgProc_KernelCom)
            {
                // This isn't the current page so ignore.
                break;
            }
            
            TCHAR Com[256];
            TCHAR Baud[256];

            if (SendDlgItemMessage(Hwnd, IDC_KD_PORT, WM_GETTEXT,
                                   _tsizeof(Com), (LPARAM)Com) &&
                SendDlgItemMessage(Hwnd, IDC_KD_BAUDRATE, WM_GETTEXT,
                                   _tsizeof(Baud), (LPARAM)Baud))
            {
                if (PrintAllocString(&g_KernelConnectOptions, 256,
                                     "com:port=%s,baud=%s", Com, Baud))
                {
                    strcpy(g_ComSettings, Com);
                    strcpy(g_ComSettings + strlen(Com) + 1, Baud);
                    if (SAVE_ENGINE_WORKSPACE())
                    {
                        PSTR Settings[2];

                        Settings[0] = Com;
                        Settings[1] = Baud;
                        g_Workspace->SetStrings(WSP_GLOBAL_COM_SETTINGS, 2,
                                                Settings);
                    }
                }
            }
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR
CALLBACK
DlgProc_Kernel1394(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    switch (Message)
    {
    case WM_INITDIALOG:
        //
        // Set up the controls to reflect current values
        //
        SetWindowText(GetDlgItem(Hwnd, IDC_KD_1394_CHANNEL), g_1394Settings);
        break;

    case WM_NOTIFY:
        switch(((LPNMHDR)Lpm)->code)
        {
        case PSN_HELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_KERNEL_DEBUGGING);
            break;

        case PSN_SETACTIVE:
            g_CurrentKd = DlgProc_Kernel1394;
            return 0;
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, FALSE);
            return FALSE;
            
        case PSN_APPLY:
            if (g_CurrentKd != DlgProc_Kernel1394)
            {
                // This isn't the current page so ignore.
                break;
            }
            
            TCHAR Channel[256];
            PSTR Options;

            if (SendDlgItemMessage(Hwnd, IDC_KD_1394_CHANNEL, WM_GETTEXT,
                                   _tsizeof(Channel), (LPARAM)Channel))
            {
                if (PrintAllocString(&g_KernelConnectOptions, 256,
                                     "1394:channel=%s", Channel))
                {
                    strcpy(g_1394Settings, Channel);
                    if (SAVE_ENGINE_WORKSPACE())
                    {
                        g_Workspace->SetString(WSP_GLOBAL_1394_SETTINGS,
                                               g_1394Settings);
                    }
                }
            }
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR
CALLBACK
DlgProc_KernelLocal(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    switch (Message)
    {
    case WM_NOTIFY:
        switch(((LPNMHDR)Lpm)->code)
        {
        case PSN_HELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_KERNEL_DEBUGGING);
            break;

        case PSN_SETACTIVE:
            g_CurrentKd = DlgProc_KernelLocal;
            return 0;
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, FALSE);
            return FALSE;
            
        case PSN_APPLY:
            if (g_CurrentKd != DlgProc_KernelLocal)
            {
                // This isn't the current page so ignore.
                break;
            }

            g_AttachKernelFlags = DEBUG_ATTACH_LOCAL_KERNEL;
            SetWindowLongPtr(Hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

void
StartKdPropSheet(void)
{
    PROPSHEETHEADER Sheet;
    PROPSHEETPAGE Pages[3];

    ZeroMemory(&Sheet, sizeof(Sheet));
    Sheet.dwSize = sizeof(PROPSHEETHEADER);
    Sheet.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_HASHELP;
    Sheet.hwndParent = g_hwndFrame;
    Sheet.hInstance = g_hInst;
    Sheet.pszCaption = "Kernel Debugging";
    Sheet.nPages = 3;
    Sheet.ppsp = Pages;

    ZeroMemory(Pages, sizeof(Pages[0]));
    Pages[0].dwSize = sizeof(Pages[0]);
    Pages[0].dwFlags = PSP_HASHELP;
    Pages[0].hInstance = g_hInst;

    Pages[1] = Pages[0];
    Pages[2] = Pages[0];
    
    Pages[0].pszTemplate = MAKEINTRESOURCE(IDD_DLG_KERNEL_COM);
    Pages[0].pfnDlgProc = DlgProc_KernelCom;

    Pages[1].pszTemplate = MAKEINTRESOURCE(IDD_DLG_KERNEL_1394);
    Pages[1].pfnDlgProc = DlgProc_Kernel1394;

    Pages[2].pszTemplate = MAKEINTRESOURCE(IDD_DLG_KERNEL_LOCAL);
    Pages[2].pfnDlgProc = DlgProc_KernelLocal;

    g_CurrentKd = NULL;

    INT_PTR Status = PropertySheet(&Sheet);
    if (Status == IDOK)
    {
        if (g_ExplicitWorkspace && g_Workspace != NULL)
        {
            g_Workspace->SetUlong(WSP_GLOBAL_ATTACH_KERNEL_FLAGS,
                                  g_AttachKernelFlags);
        }
        StartDebugging();
    }
}

INT_PTR
CALLBACK
DlgProc_ImagePath(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    TCHAR Path[MAX_ENGINE_PATH];
    LRESULT Size;
    HRESULT Hr;

    switch(Message)
    {
    case WM_INITDIALOG:
        Hr = g_pUiSymbols->GetImagePath(Path, _tsizeof(Path), NULL);
        if (Hr != S_OK)
        {
            InformationBox(ERR_Internal_Error, Hr, "UI GetImagePath");
        }

        SendDlgItemMessage(Hwnd, IDC_IMAGE_PATH, WM_SETTEXT, 0, (LPARAM)Path);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_IMAGE_PATH);
            break;
            
        case IDOK:
            Size = SendDlgItemMessage(Hwnd, IDC_IMAGE_PATH, WM_GETTEXT,
                                      sizeof(Path), (LPARAM)Path);
            if (Size == 0)
            {
                InformationBox(ERR_Path_Empty);
                SetFocus(Hwnd);
                return TRUE;
            }
            Path[Size] = 0;

            Hr = g_pUiSymbols->SetImagePath(Path);
            if (Hr != S_OK)
            {
                InformationBox(ERR_Internal_Error, Hr, "UI SetImagePath");
            }

            if (SAVE_ENGINE_WORKSPACE())
            {
                g_Workspace->SetString(WSP_GLOBAL_IMAGE_PATH, Path);
            }
                                             
            EndDialog(Hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(Hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


INT_PTR
CALLBACK
DlgProc_SourcePath(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    TCHAR Path[MAX_ENGINE_PATH];
    LRESULT Size;
    HRESULT Hr;
    HWND Ctrl;
    ULONG Tag;

    switch(Message)
    {
    case WM_INITDIALOG:
        Ctrl = GetDlgItem(Hwnd, IDC_LOCAL_SOURCE);
        SendMessage(Ctrl, BM_SETCHECK, TRUE, 0);
        if (!g_RemoteClient)
        {
            EnableWindow(Ctrl, FALSE);
            
            Hr = g_pUiSymbols->GetSourcePath(Path, _tsizeof(Path), NULL);
        }
        else
        {
            EnableWindow(Ctrl, TRUE);

            Hr = g_pUiLocSymbols->GetSourcePath(Path, _tsizeof(Path), NULL);
        }
        if (Hr != S_OK)
        {
            InformationBox(ERR_Internal_Error, Hr, "UI GetSourcePath");
        }

        SendDlgItemMessage(Hwnd, IDC_SOURCE_PATH, WM_SETTEXT, 0, (LPARAM)Path);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_LOCAL_SOURCE:
            if (IsDlgButtonChecked(Hwnd, IDC_LOCAL_SOURCE) != BST_CHECKED)
            {
                Hr = g_pUiSymbols->GetSourcePath(Path, _tsizeof(Path), NULL);
            }
            else
            {
                Hr = g_pUiLocSymbols->GetSourcePath(Path, _tsizeof(Path),
                                                    NULL);
            }
            if (Hr != S_OK)
            {
                InformationBox(ERR_Internal_Error, Hr, "UI GetSourcePath");
            }

            SendDlgItemMessage(Hwnd, IDC_SOURCE_PATH, WM_SETTEXT, 0,
                               (LPARAM)Path);
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_SOURCE_PATH);
            break;
            
        case IDOK:
            Size = SendDlgItemMessage(Hwnd, IDC_SOURCE_PATH, WM_GETTEXT,
                                      sizeof(Path), (LPARAM)Path);
            if (Size == 0)
            {
                InformationBox(ERR_Path_Empty);
                SetFocus(Hwnd);
                return TRUE;
            }
            Path[Size] = 0;

            if (!g_RemoteClient ||
                IsDlgButtonChecked(Hwnd, IDC_LOCAL_SOURCE) != BST_CHECKED)
            {
                Hr = g_pUiSymbols->SetSourcePath(Path);
                Tag = WSP_GLOBAL_SOURCE_PATH;
            }
            else
            {
                Hr = g_pUiLocSymbols->SetSourcePath(Path);
                Tag = WSP_GLOBAL_LOCAL_SOURCE_PATH;
            }
            if (Hr != S_OK)
            {
                InformationBox(ERR_Internal_Error, Hr, "UI SetSourcePath");
            }

            if (g_Workspace != NULL)
            {
                g_Workspace->SetString(Tag, Path);
            }
                                             
            EndDialog(Hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(Hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

#define MAX_IDS 4096

void
FillProcessList(HWND List)
{
    HRESULT Status;
    ULONG Ids[MAX_IDS];
    ULONG IdCount;
    ULONG i;
    ULONG64 Server = 0;
    ULONG Extent = 0;

    SendMessage(List, LB_RESETCONTENT, 0, 0);
    
    if (g_ProcessServer != NULL)
    {
        if (g_pUiClient->
            ConnectProcessServer(g_ProcessServer, &Server) != S_OK)
        {
            SendMessage(List, LB_ADDSTRING,
                        0, (LPARAM)_T("Unable to connect to process server"));
            return;
        }
    }
    
    if ((Status = g_pUiClient->
         GetRunningProcessSystemIds(Server, Ids, MAX_IDS,
                                    &IdCount)) != S_OK)
    {
        SendMessage(List, LB_ADDSTRING,
                    0, (LPARAM)_T("Unable to get process list"));
        goto Disconnect;
    }

    if (IdCount > MAX_IDS)
    {
        SendMessage(List, LB_ADDSTRING,
                    0, (LPARAM)_T("Incomplete process list"));
        IdCount = MAX_IDS;
    }
    
    for (i = 0; i < IdCount; i++)
    {
        char IdAndExeName[MAX_PATH + 16];
        char DescBuf[2 * MAX_PATH];
        PSTR ExeName, Desc;
        LRESULT Idx;
        ULONG ItemEx;

        if (Ids[i] >= 0x80000000)
        {
            sprintf(IdAndExeName, "0x%x", Ids[i]);
        }
        else
        {
            sprintf(IdAndExeName, "%4d", Ids[i]);
        }
        ExeName = IdAndExeName + strlen(IdAndExeName);
        *ExeName++ = ' ';
        Desc = DescBuf;
        while ((Desc - DescBuf) < (ExeName - IdAndExeName))
        {
            *Desc++ = ' ';
        }

        Status = g_pUiClient->
            GetRunningProcessDescription(Server, Ids[i],
                                         DEBUG_PROC_DESC_NO_PATHS,
                                         ExeName,
                                         (ULONG)(sizeof(IdAndExeName) -
                                                 (ExeName - IdAndExeName)),
                                         NULL,
                                         Desc,
                                         (ULONG)(sizeof(DescBuf) -
                                                 (Desc - DescBuf)),
                                         NULL);
        if (FAILED(Status))
        {
            sprintf(ExeName, "Error 0x%08X", Status);
        }

        Idx = SendMessage(List, LB_ADDSTRING, 0, (LPARAM)IdAndExeName);
        SendMessage(List, LB_SETITEMDATA, Idx, TRUE);
        ItemEx = (strlen(IdAndExeName) + 1) *
            g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
        if (ItemEx > Extent)
        {
            Extent = ItemEx;
        }
        if (*Desc)
        {
            SendMessage(List, LB_ADDSTRING, 0, (LPARAM)DescBuf);
            ItemEx = (strlen(DescBuf) + 1) *
                g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
            if (ItemEx > Extent)
            {
                Extent = ItemEx;
            }
        }
    }

    SendMessage(List, LB_SETHORIZONTALEXTENT, Extent, 0);

 Disconnect:
    if (Server != 0)
    {
        g_pUiClient->DisconnectProcessServer(Server);
    }
}

INT_PTR CALLBACK
DlgProc_AttachProcess(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Text[MAX_PATH];
    HWND List;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        List = GetDlgItem(Hwnd, IDC_ATTACH_PROC_LIST);
        SendMessage(List, WM_SETFONT, (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
        FillProcessList(List);
        SendDlgItemMessage(Hwnd, IDC_ATTACH_PID, WM_SETFONT,
                           (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
        SendDlgItemMessage(Hwnd, IDC_ATTACH_PID, EM_LIMITTEXT,
                           sizeof(Text) - 1, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_ATTACH_PID), "");
        CheckDlgButton(Hwnd, IDC_ATTACH_NONINVASIVE, BST_UNCHECKED);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_ATTACH_PROC_LIST:
            LRESULT Sel;
            
            List = GetDlgItem(Hwnd, IDC_ATTACH_PROC_LIST);
            Sel = SendMessage(List, LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                if (!SendMessage(List, LB_GETITEMDATA, Sel, 0))
                {
                    Sel = -1;
                }
            }
            if (Sel < 0)
            {
                SetWindowText(GetDlgItem(Hwnd, IDC_ATTACH_PID), "");
            }
            else
            {
                SendMessage(List, LB_GETTEXT, Sel, (LPARAM)Text);
                SetWindowText(GetDlgItem(Hwnd, IDC_ATTACH_PID), Text);
            }
            break;

        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_ATTACH_TO_PROCESS);
            break;
            
        case IDOK:
            GetWindowText(GetDlgItem(Hwnd, IDC_ATTACH_PID),
                          Text, sizeof(Text));
            g_PidToDebug = strtoul(Text, NULL, 0);
            if (IsDlgButtonChecked(Hwnd, IDC_ATTACH_NONINVASIVE) ==
                BST_CHECKED)
            {
                g_AttachProcessFlags |= DEBUG_ATTACH_NONINVASIVE;
            }

            StartDebugging();

            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
FillEventFilters(HWND List)
{
    HRESULT Status;
    ULONG Width;
    RECT ListRect;

    LRESULT ListSel = SendMessage(List, LB_GETCURSEL, 0, 0);
    SendMessage(List, WM_SETREDRAW, FALSE, 0);
    SendMessage(List, LB_RESETCONTENT, 0, 0);

    GetClientRect(List, &ListRect);
    Width = ListRect.right - ListRect.left;
    
    Status = g_FilterBuffer->UiLockForRead();
    if (Status != S_OK)
    {
        SendLockStatusMessage(List, LB_ADDSTRING, Status);
        goto Update;
    }
    Status = g_FilterTextBuffer->UiLockForRead();
    if (Status != S_OK)
    {
        SendLockStatusMessage(List, LB_ADDSTRING, Status);
        goto UnlockFilter;
    }
    
    ULONG i;
    PSTR FilterArg, FilterText;
    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PDEBUG_EXCEPTION_FILTER_PARAMETERS ExParams;
    char Str[256];
    
    FilterText = (PSTR)g_FilterTextBuffer->GetDataBuffer();
    SpecParams =
        (PDEBUG_SPECIFIC_FILTER_PARAMETERS)g_FilterBuffer->GetDataBuffer();
    ExParams =
        (PDEBUG_EXCEPTION_FILTER_PARAMETERS)(SpecParams + g_NumSpecEvents);
    FilterArg = (PSTR)g_FilterBuffer->GetDataBuffer() + g_FilterArgsOffset;

    for (i = 0; i < g_NumSpecEvents; i++)
    {
        strcpy(Str, FilterText);
        if (SpecParams->ArgumentSize > 1)
        {
            strcat(Str, " ");
            strcat(Str, FilterArg);
            FilterArg += strlen(FilterArg) + 1;
        }
        sprintf(Str + strlen(Str), " - %s - %s",
                g_ExecutionNames[SpecParams->ExecutionOption],
                g_ContinueNames[SpecParams->ContinueOption]);
        SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Str);
        FilterText += strlen(FilterText) + 1;
        SpecParams++;
    }
    for (i = 0; i < g_NumSpecEx; i++)
    {
        sprintf(Str, "%s - %s - %s",
                FilterText,
                g_ExecutionNames[ExParams->ExecutionOption],
                g_ContinueNames[ExParams->ContinueOption]);
        SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Str);
        FilterText += strlen(FilterText) + 1;
        ExParams++;
    }
    for (i = 0; i < g_NumArbEx; i++)
    {
        sprintf(Str, "Exception %08X - %s - %s",
                ExParams->ExceptionCode,
                g_ExecutionNames[ExParams->ExecutionOption],
                g_ContinueNames[ExParams->ContinueOption]);
        SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Str);
        ExParams++;
    }

    UnlockStateBuffer(g_FilterTextBuffer);
 UnlockFilter:
    UnlockStateBuffer(g_FilterBuffer);

 Update:
    SendMessage(List, LB_SETHORIZONTALEXTENT, Width, 0);
    SendMessage(List, WM_SETREDRAW, TRUE, 0);
    if (ListSel != LB_ERR)
    {
        SendMessage(List, LB_SETCURSEL, ListSel, 0);
    }
}

void
GetFilterOptions(int Index, PULONG CodeArg, PULONG Exe, PULONG Cont)
{
    *CodeArg = 0;
    *Exe = 0;
    *Cont = 0;
    
    if (g_FilterBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PDEBUG_EXCEPTION_FILTER_PARAMETERS ExParams;
    
    SpecParams =
        (PDEBUG_SPECIFIC_FILTER_PARAMETERS)g_FilterBuffer->GetDataBuffer();
    ExParams =
        (PDEBUG_EXCEPTION_FILTER_PARAMETERS)(SpecParams + g_NumSpecEvents);

    if ((ULONG)Index < g_NumSpecEvents)
    {
        SpecParams += Index;
        *CodeArg = SpecParams->ArgumentSize;
        *Exe = SpecParams->ExecutionOption;
        *Cont = SpecParams->ContinueOption;
    }
    else
    {
        ExParams += Index - g_NumSpecEvents;
        *CodeArg = ExParams->ExceptionCode;
        *Exe = ExParams->ExecutionOption;
        *Cont = ExParams->ContinueOption;
    }
    
    UnlockStateBuffer(g_FilterBuffer);
}

void
GetFilterArgument(int Index, PTSTR Argument, ULONG Size)
{
    *Argument = 0;
    
    if (g_FilterBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    int i;
    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PSTR FilterArg;
    
    SpecParams =
        (PDEBUG_SPECIFIC_FILTER_PARAMETERS)g_FilterBuffer->GetDataBuffer();
    FilterArg = (PSTR)g_FilterBuffer->GetDataBuffer() + g_FilterArgsOffset;
    
    for (i = 0; i < Index; i++)
    {
        if (SpecParams->ArgumentSize > 1)
        {
            FilterArg += strlen(FilterArg) + 1;
        }

        SpecParams++;
    }

    if (SpecParams->ArgumentSize > 1)
    {
        strncat(Argument, FilterArg, Size);
    }
    
    UnlockStateBuffer(g_FilterBuffer);
}

void
GetFilterCommands(ULONG Index,
                  PTSTR Argument1, ULONG Size1,
                  PTSTR Argument2, ULONG Size2)
{
    *Argument1 = 0;
    *Argument2 = 0;
    
    if (g_FilterBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    ULONG i, Limit;
    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PSTR FilterCmd;
    ULONG CmdSize1, CmdSize2;
    
    SpecParams =
        (PDEBUG_SPECIFIC_FILTER_PARAMETERS)g_FilterBuffer->GetDataBuffer();
    FilterCmd = (PSTR)g_FilterBuffer->GetDataBuffer() + g_FilterCmdsOffset;

    if (Index < g_NumSpecEvents)
    {
        Limit = Index;
    }
    else
    {
        Limit = g_NumSpecEvents;
    }
    
    for (i = 0; i < Limit; i++)
    {
        if (SpecParams->CommandSize > 0)
        {
            FilterCmd += strlen(FilterCmd) + 1;
        }

        SpecParams++;
    }

    if (Index >= g_NumSpecEvents)
    {
        PDEBUG_EXCEPTION_FILTER_PARAMETERS ExParams =
            (PDEBUG_EXCEPTION_FILTER_PARAMETERS)SpecParams;
        while (i < Index)
        {
            if (ExParams->CommandSize > 0)
            {
                FilterCmd += strlen(FilterCmd) + 1;
            }
            if (ExParams->SecondCommandSize > 0)
            {
                FilterCmd += strlen(FilterCmd) + 1;
            }

            i++;
            ExParams++;
        }

        CmdSize1 = ExParams->CommandSize;
        CmdSize2 = ExParams->SecondCommandSize;
    }
    else
    {
        CmdSize1 = SpecParams->CommandSize;
        CmdSize2 = 0;
    }

    if (CmdSize1 > 0)
    {
        strncat(Argument1, FilterCmd, Size1-1);
    }
    if (CmdSize2 > 0)
    {
        FilterCmd += strlen(FilterCmd) + 1;
        strncat(Argument2, FilterCmd, Size2-1);
    }
    
    UnlockStateBuffer(g_FilterBuffer);
}

INT_PTR CALLBACK
DlgProc_EventFilters(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    UIC_SET_FILTER_DATA* SetFilter;
    HWND List = GetDlgItem(Hwnd, IDC_FILTERS);
    int Sel = (int)SendMessage(List, LB_GETCURSEL, 0, 0);
    HWND Remove, Command, Arg;
    ULONG CodeArg, Exe, Cont;
    UINT Id;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        g_FilterBuffer->m_Win = Hwnd;
        SendMessage(List, WM_SETFONT, (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
        FillEventFilters(List);
        break;

    case WM_COMMAND:
        Id = LOWORD(Wpm);
        switch(Id)
        {
        case IDC_FILTERS:
            Remove = GetDlgItem(Hwnd, IDC_FILTER_REMOVE);
            Arg = GetDlgItem(Hwnd, IDC_FILTER_ARGUMENT);
            Command = GetDlgItem(Hwnd, IDC_FILTER_COMMAND);
            if (Sel >= 0)
            {
                EnableWindow(Remove,
                             (ULONG)Sel >= g_NumSpecEvents + g_NumSpecEx);
                GetFilterOptions(Sel, &CodeArg, &Exe, &Cont);
                CheckRadioButton(Hwnd, IDC_FILTER_ENABLED,
                                 IDC_FILTER_IGNORE,
                                 (Exe - DEBUG_FILTER_BREAK) +
                                 IDC_FILTER_ENABLED);
                CheckRadioButton(Hwnd, IDC_FILTER_HANDLED,
                                 IDC_FILTER_NOT_HANDLED,
                                 (Cont - DEBUG_FILTER_GO_HANDLED) +
                                 IDC_FILTER_HANDLED);
                
                if ((ULONG)Sel < g_NumSpecEvents)
                {
                    GetFilterOptions(Sel, &CodeArg, &Exe, &Cont);
                    EnableWindow(Arg, CodeArg > 0);
                }

                EnableWindow(Command, TRUE);
            }
            else
            {
                EnableWindow(Remove, FALSE);
                EnableWindow(Arg, FALSE);
                EnableWindow(Command, FALSE);
            }
            break;

        case IDC_FILTER_ADD:
            StartDialog(IDD_DLG_EXCEPTION_FILTER, DlgProc_ExceptionFilter,
                        NULL);
            break;

        case IDC_FILTER_REMOVE:
            if (Sel >= 0)
            {
                SetFilter = StartStructCommand(UIC_SET_FILTER);
                if (SetFilter != NULL)
                {
                    SetFilter->Index = 0xffffffff;
                    GetFilterOptions(Sel,
                                     &SetFilter->Code,
                                     &SetFilter->Execution,
                                     &SetFilter->Continue);
                    SetFilter->Execution = DEBUG_FILTER_REMOVE;
                    FinishCommand();
                }
            }
            break;

        case IDC_FILTER_ARGUMENT:
            if (Sel >= 0 && (ULONG)Sel < g_NumSpecEvents)
            {
                GetFilterArgument(Sel, g_DlgString,
                                  sizeof(g_DlgString));
                
                if (StartDialog(IDD_DLG_FILTER_ARGUMENT,
                                DlgProc_FilterArgument,
                                NULL) == IDOK)
                {
                    UIC_SET_FILTER_ARGUMENT_DATA* SetFilterArg;
                    SetFilterArg = (UIC_SET_FILTER_ARGUMENT_DATA*)
                        StartCommand(UIC_SET_FILTER_ARGUMENT,
                                     sizeof(*SetFilterArg) +
                                     strlen(g_DlgString));
                    if (SetFilterArg != NULL)
                    {
                        SetFilterArg->Index = Sel;
                        strcpy(SetFilterArg->Argument, g_DlgString);
                        FinishCommand();
                    }
                }
            }
            break;
            
        case IDC_FILTER_COMMAND:
            if (Sel >= 0)
            {
                GetFilterCommands(Sel,
                                  g_DlgString, sizeof(g_DlgString),
                                  g_DlgString2, sizeof(g_DlgString2));

                if (StartDialog(IDD_DLG_FILTER_COMMAND,
                                DlgProc_FilterCommand,
                                (ULONG)Sel >= g_NumSpecEvents) == IDOK)
                {
                    UIC_SET_FILTER_COMMAND_DATA* SetFilterCmd;
                    
                    SetFilterCmd = (UIC_SET_FILTER_COMMAND_DATA*)
                        StartCommand(UIC_SET_FILTER_COMMAND,
                                     sizeof(*SetFilterCmd) +
                                     strlen(g_DlgString));
                    if (SetFilterCmd != NULL)
                    {
                        SetFilterCmd->Which = 0;
                        SetFilterCmd->Index = Sel;
                        strcpy(SetFilterCmd->Command, g_DlgString);
                        FinishCommand();
                    }

                    if ((ULONG)Sel <= g_NumSpecEvents)
                    {
                        break;
                    }
                    
                    SetFilterCmd = (UIC_SET_FILTER_COMMAND_DATA*)
                        StartCommand(UIC_SET_FILTER_COMMAND,
                                     sizeof(*SetFilterCmd) +
                                     strlen(g_DlgString2));
                    if (SetFilterCmd != NULL)
                    {
                        SetFilterCmd->Which = 1;
                        SetFilterCmd->Index = Sel;
                        strcpy(SetFilterCmd->Command, g_DlgString2);
                        FinishCommand();
                    }
                }
            }
            break;
            
        case IDC_FILTER_ENABLED:
        case IDC_FILTER_DISABLED:
        case IDC_FILTER_OUTPUT:
        case IDC_FILTER_IGNORE:
        case IDC_FILTER_HANDLED:
        case IDC_FILTER_NOT_HANDLED:
            if (Sel >= 0)
            {
                SetFilter = StartStructCommand(UIC_SET_FILTER);
                if (SetFilter != NULL)
                {
                    SetFilter->Index = (ULONG)Sel < g_NumSpecEvents ?
                        Sel : 0xffffffff;
                    GetFilterOptions(Sel,
                                     &SetFilter->Code,
                                     &SetFilter->Execution,
                                     &SetFilter->Continue);
                    if (Id >= IDC_FILTER_ENABLED && Id <= IDC_FILTER_IGNORE)
                    {
                        SetFilter->Execution = (Id - IDC_FILTER_ENABLED) +
                            DEBUG_FILTER_BREAK;
                    }
                    else
                    {
                        SetFilter->Continue = (Id - IDC_FILTER_HANDLED) +
                            DEBUG_FILTER_GO_HANDLED;
                    }
                    FinishCommand();
                }
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_EVENT_FILTERS);
            break;
            
        case IDCANCEL:
            g_FilterBuffer->m_Win = NULL;
            EndDialog(Hwnd, Id);
            break;
        }
        break;

    case LB_RESETCONTENT:
        FillEventFilters(List);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_ExceptionFilter(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND Code = GetDlgItem(Hwnd, IDC_FILTER_CODE);
    char CodeText[80];
    UIC_SET_FILTER_DATA* SetFilter;
    static UINT s_Execution;
    static UINT s_Continue;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendMessage(Code, EM_LIMITTEXT, sizeof(CodeText) - 1, 0);
        SetWindowText(Code, "");
        s_Execution = IDC_FILTER_ENABLED;
        s_Continue = IDC_FILTER_NOT_HANDLED;
        CheckRadioButton(Hwnd, IDC_FILTER_ENABLED,
                         IDC_FILTER_IGNORE, s_Execution);
        CheckRadioButton(Hwnd, IDC_FILTER_HANDLED,
                         IDC_FILTER_NOT_HANDLED, s_Continue);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_FILTER_ENABLED:
        case IDC_FILTER_DISABLED:
        case IDC_FILTER_OUTPUT:
        case IDC_FILTER_IGNORE:
            s_Execution = LOWORD(Wpm);
            break;

        case IDC_FILTER_HANDLED:
        case IDC_FILTER_NOT_HANDLED:
            s_Continue = LOWORD(Wpm);
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_EVENT_FILTERS);
            break;
            
        case IDOK:
            int InputCode;

            if (GetWindowText(Code, CodeText, sizeof(CodeText)) == 0)
            {
                MessageBeep(-1);
                break;
            }

            if (sscanf(CodeText, "%x", &InputCode) != 1)
            {
                MessageBeep(-1);
                break;
            }
            
            SetFilter = StartStructCommand(UIC_SET_FILTER);
            if (SetFilter != NULL)
            {
                SetFilter->Index = 0xffffffff;
                SetFilter->Code = InputCode;
                SetFilter->Execution = (s_Execution - IDC_FILTER_ENABLED) +
                    DEBUG_FILTER_BREAK;
                SetFilter->Continue = (s_Continue - IDC_FILTER_HANDLED) +
                    DEBUG_FILTER_GO_HANDLED;
                FinishCommand();
            }

            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_FilterArgument(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND Arg = GetDlgItem(Hwnd, IDC_FILTER_ARGUMENT);
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendMessage(Arg, EM_LIMITTEXT, sizeof(g_DlgString) - 1, 0);
        SetWindowText(Arg, g_DlgString);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_EVENT_FILTERS);
            break;
            
        case IDOK:
            if (GetWindowText(Arg, g_DlgString,
                              sizeof(g_DlgString)) == 0)
            {
                g_DlgString[0] = 0;
            }

            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
DlgProc_FilterCommand(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND Cmd1 = GetDlgItem(Hwnd, IDC_FILTER_COMMAND);
    HWND Cmd2 = GetDlgItem(Hwnd, IDC_FILTER_COMMAND2);
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendMessage(Cmd1, EM_LIMITTEXT, sizeof(g_DlgString) - 1, 0);
        SetWindowText(Cmd1, g_DlgString);
        SendMessage(Cmd2, EM_LIMITTEXT, sizeof(g_DlgString2) - 1, 0);
        SetWindowText(Cmd2, g_DlgString2);
        EnableWindow(Cmd2, (BOOL)Lpm);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_EVENT_FILTERS);
            break;
            
        case IDOK:
            if (GetWindowText(Cmd1, g_DlgString, sizeof(g_DlgString)) == 0)
            {
                g_DlgString[0] = 0;
            }
            if (GetWindowText(Cmd2, g_DlgString2, sizeof(g_DlgString2)) == 0)
            {
                g_DlgString2[0] = 0;
            }

            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

ULONG
EditTabToUserTab(ULONG EditTab)
{
    return EditTab / 4;
}

ULONG
UserTabToEditTab(ULONG UserTab)
{
    return UserTab * 4;
}

INT_PTR CALLBACK
DlgProc_Options(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND Ctrl;
    char Text[256];
    LRESULT Sel, Idx;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        ULONG EngOptions;
        LONG Width;
        HDC FontDc;
            
        SendDlgItemMessage(Hwnd, IDC_OPTION_TAB_WIDTH, EM_LIMITTEXT,
                           sizeof(Text) - 1, 0);
        _itoa(EditTabToUserTab(g_TabWidth), Text, 10);
        SetWindowText(GetDlgItem(Hwnd, IDC_OPTION_TAB_WIDTH), Text);
        
        g_pUiControl->GetEngineOptions(&EngOptions);
        CheckDlgButton(Hwnd, IDC_OPTION_REPEAT_COMMANDS,
                       (EngOptions & DEBUG_ENGOPT_NO_EXECUTE_REPEAT) == 0 ?
                       BST_CHECKED : BST_UNCHECKED);

        Ctrl = GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST);
        SendMessage(Ctrl, WM_SETFONT, (WPARAM)g_Fonts[FONT_VARIABLE].Font, 0);
        FontDc = GetDC(Ctrl);
        SelectObject(FontDc, g_Fonts[FONT_VARIABLE].Font);
        Width = 0;
        SendMessage(Ctrl, LB_RESETCONTENT, 0, 0);
        for (Sel = 0; Sel < COL_COUNT; Sel++)
        {
            Idx = SendMessage(Ctrl, LB_ADDSTRING,
                              0, (LPARAM)g_Colors[Sel].Name);
            SendMessage(Ctrl, LB_SETITEMDATA, Idx, Sel);
            if (FontDc != NULL)
            {
                SIZE Extent;

                if (GetTextExtentPoint32(FontDc, g_Colors[Sel].Name,
                                         strlen(g_Colors[Sel].Name),
                                         &Extent) &&
                    Extent.cx > Width)
                {
                    Width = Extent.cx;
                }
            }
        }
        for (Sel = 0; Sel < OUT_MASK_COL_COUNT; Sel++)
        {
            if (g_OutMaskColors[Sel].Name != NULL)
            {
                Idx = SendMessage(Ctrl, LB_ADDSTRING,
                                  0, (LPARAM)g_OutMaskColors[Sel].Name);
                SendMessage(Ctrl, LB_SETITEMDATA,
                            Idx, Sel + OUT_MASK_COL_BASE);
                if (FontDc != NULL)
                {
                    SIZE Extent;

                    if (GetTextExtentPoint32(FontDc, g_OutMaskColors[Sel].Name,
                                             strlen(g_OutMaskColors[Sel].Name),
                                             &Extent) &&
                        Extent.cx > Width)
                    {
                        Width = Extent.cx;
                    }
                }
            }
        }
        SendMessage(Ctrl, LB_SETCURSEL, 0, 0);
        if (FontDc != NULL)
        {
            ReleaseDC(Ctrl, FontDc);
        }
        Width += g_Fonts[FONT_VARIABLE].Metrics.tmAveCharWidth;
        SendMessage(Ctrl, LB_SETHORIZONTALEXTENT, Width, 0);
        
        CheckDlgButton(Hwnd, IDC_OPTION_DISASM_ACTIVATE_SOURCE,
                       g_DisasmActivateSource ? BST_CHECKED : BST_UNCHECKED);
        CheckDlgButton(Hwnd, IDC_OPTION_AUTO_CMD_SCROLL,
                       g_AutoCmdScroll ? BST_CHECKED : BST_UNCHECKED);
        break;

    case WM_CTLCOLORSTATIC:
        if ((HWND)Lpm == GetDlgItem(Hwnd, IDC_OPTION_COLOR_DISPLAY))
        {
            Sel = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                              LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                Idx = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                                  LB_GETITEMDATA, Sel, 0);
                INDEXED_COLOR* IdxCol = GetIndexedColor((ULONG)Idx);
                if (IdxCol != NULL)
                {
                    return (INT_PTR)IdxCol->Brush;
                }
            }
        }
        break;
        
    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_OPTION_COLOR_LIST:
            Sel = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                              LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                InvalidateRect(GetDlgItem(Hwnd, IDC_OPTION_COLOR_DISPLAY),
                               NULL, TRUE);
            }
            break;

        case IDC_OPTION_COLOR_CHANGE:
            Sel = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                              LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                Idx = SendMessage(GetDlgItem(Hwnd, IDC_OPTION_COLOR_LIST),
                                  LB_GETITEMDATA, Sel, 0);
                if (SelectColor(g_hwndFrame, (ULONG)Idx))
                {
                    InvalidateRect(GetDlgItem(Hwnd, IDC_OPTION_COLOR_DISPLAY),
                                   NULL, TRUE);
                }
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_OPTIONS);
            break;
            
        case IDOK:
            if (GetWindowText(GetDlgItem(Hwnd, IDC_OPTION_TAB_WIDTH),
                              Text, sizeof(Text)) == 0)
            {
                MessageBeep(-1);
                break;
            }

            if (sscanf(Text, "%d", &g_TabWidth) != 1)
            {
                MessageBeep(-1);
            }
            
            g_TabWidth = UserTabToEditTab(g_TabWidth);
            SetTabWidth(g_TabWidth);

            ULONG RepeatState;
            
            if (IsDlgButtonChecked(Hwnd, IDC_OPTION_REPEAT_COMMANDS) ==
                BST_CHECKED)
            {
                g_pUiControl->
                    RemoveEngineOptions(DEBUG_ENGOPT_NO_EXECUTE_REPEAT);
                RepeatState = TRUE;
            }
            else
            {
                g_pUiControl->
                    AddEngineOptions(DEBUG_ENGOPT_NO_EXECUTE_REPEAT);
                RepeatState = FALSE;
            }
            if (g_Workspace != NULL)
            {
                g_Workspace->SetUlong(WSP_GLOBAL_REPEAT_COMMANDS, RepeatState);
            }

            UpdateAllColors();
            
            g_DisasmActivateSource =
                IsDlgButtonChecked(Hwnd, IDC_OPTION_DISASM_ACTIVATE_SOURCE) ==
                BST_CHECKED;
            if (g_Workspace != NULL)
            {
                g_Workspace->SetUlong(WSP_GLOBAL_DISASM_ACTIVATE_SOURCE,
                                      g_DisasmActivateSource);
            }
            
            g_AutoCmdScroll =
                IsDlgButtonChecked(Hwnd, IDC_OPTION_AUTO_CMD_SCROLL) ==
                BST_CHECKED;
            if (g_Workspace != NULL)
            {
                g_Workspace->SetUlong(WSP_GLOBAL_AUTO_CMD_SCROLL,
                                      g_AutoCmdScroll);
            }
            
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
ClwFillSaveList(HWND List)
{
    SendMessage(List, LB_RESETCONTENT, 0, 0);

    if (g_Workspace != NULL)
    {
        WSP_ENTRY* Entry = NULL;
        LRESULT Idx;
        BOOL CommonWinDone = FALSE;
    
        while ((Entry = g_Workspace->NextEntry(Entry)) != NULL)
        {
            if (Entry->Tag == WSP_WINDOW_COMMONWIN_1)
            {
                if (CommonWinDone)
                {
                    continue;
                }
                
                CommonWinDone = TRUE;
            }
            
            Idx = SendMessage(List, LB_ADDSTRING, 0, (LPARAM)
                              GetWspTagName(Entry->Tag));
            SendMessage(List, LB_SETITEMDATA, Idx, (LPARAM)Entry->Tag);
        }
    }
    
    SendMessage(List, LB_SETCURSEL, 0, 0);
}

void
ClwMoveBetweenLists(HWND From, HWND To, LRESULT Item)
{
    LPARAM Data = SendMessage(From, LB_GETITEMDATA, Item, 0);
    SendMessage(From, LB_DELETESTRING, Item, 0);
    Item = SendMessage(To, LB_ADDSTRING, 0, (LPARAM)
                       GetWspTagName((WSP_TAG)Data));
    SendMessage(To, LB_SETITEMDATA, Item, Data);
}

void
ClwMoveAllBetweenLists(HWND From, HWND To)
{
    LRESULT Count = SendMessage(From, LB_GETCOUNT, 0, 0);
    while (Count-- > 0)
    {
        ClwMoveBetweenLists(From, To, 0);
    }
}

void
ClwMoveSelectedBetweenLists(HWND From, HWND To)
{
    int Sel[1];
    LRESULT Count;

    // Move items one at a time as the indices change
    // when items are moved.
    for (;;)
    {
        Count = SendMessage(From, LB_GETSELITEMS,
                            sizeof(Sel) / sizeof(Sel[0]), (LPARAM)Sel);
        if (Count <= 0)
        {
            break;
        }

        ClwMoveBetweenLists(From, To, Sel[0]);
    }
}

void
ClwProcessClearList(HWND List)
{
    LRESULT Count = SendMessage(List, LB_GETCOUNT, 0, 0);
    LRESULT i;
    WSP_TAG Tag;

    for (i = 0; i < Count; i++)
    {
        Tag = (WSP_TAG)SendMessage(List, LB_GETITEMDATA, i, 0);
        g_Workspace->Delete(Tag, WSP_GROUP_MASK | WSP_ITEM_MASK);
    }

    // If everything is deleted from an explicit workspace
    // delete the workspace from the explicit registry area.
    if (g_ExplicitWorkspace && g_Workspace->IsEmpty())
    {
        g_Workspace->DeleteReg(TRUE);
        delete g_Workspace;
        g_Workspace = NULL;
    }
}

INT_PTR CALLBACK
DlgProc_ClearWorkspace(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    LRESULT Sel;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        ClwFillSaveList(GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST));
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_CLW_CLEAR:
            ClwMoveSelectedBetweenLists(GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST),
                                        GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST));
            break;
        case IDC_CLW_CLEAR_ALL:
            ClwMoveAllBetweenLists(GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST),
                                   GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST));
            break;
        case IDC_CLW_SAVE:
            ClwMoveSelectedBetweenLists(GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST),
                                        GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST));
            break;
        case IDC_CLW_SAVE_ALL:
            ClwMoveAllBetweenLists(GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST),
                                   GetDlgItem(Hwnd, IDC_CLW_SAVE_LIST));
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_CLEAR_WORKSPACE);
            break;

        case IDOK:
            ClwProcessClearList(GetDlgItem(Hwnd, IDC_CLW_CLEAR_LIST));
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

enum
{
    MODCOL_NAME,
    MODCOL_START,
    MODCOL_END,
    MODCOL_TIMESTAMP,
    MODCOL_CHECKSUM,
    MODCOL_SYMBOL_TYPE,
    MODCOL_SYMBOL_FILE
};

void
InitializeModuleList(HWND List)
{
    SendMessage(List, WM_SETFONT, (WPARAM)g_Fonts[FONT_FIXED].Font, FALSE);
    
    LVCOLUMN Column;

    // First column is for the module name.
    Column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
    Column.fmt = LVCFMT_LEFT;
    Column.pszText = "Name";
    Column.cx = 15 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_NAME;
    ListView_InsertColumn(List, 0, &Column);

    // Second column is for start address.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "Start";
    Column.cx = (10 + (g_Ptr64 ? 9 : 0)) *
        g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_START;
    ListView_InsertColumn(List, 1, &Column);

    // Third column is for end address.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "End";
    Column.cx = (10 + (g_Ptr64 ? 9 : 0)) *
        g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_END;
    ListView_InsertColumn(List, 2, &Column);

    // Fourth column is for timestamp.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "Timestamp";
    Column.cx = 37 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_TIMESTAMP;
    ListView_InsertColumn(List, 3, &Column);

    // Fifth column is for checksum.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "Checksum";
    Column.cx = 10 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_CHECKSUM;
    ListView_InsertColumn(List, 4, &Column);

    // Sixth column is for symbol type.
    Column.fmt = LVCFMT_CENTER;
    Column.pszText = "Symbols";
    Column.cx = 9 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_SYMBOL_TYPE;
    ListView_InsertColumn(List, 5, &Column);

    // Seventh column is for symbol file.
    Column.fmt = LVCFMT_LEFT;
    Column.pszText = "Symbol file";
    Column.cx = 80 * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
    Column.iSubItem = MODCOL_SYMBOL_FILE;
    ListView_InsertColumn(List, 6, &Column);
}

void
FillModuleList(HWND List)
{
    LVCOLUMN Column;

    Column.mask = LVCF_FMT;
    if (!ListView_GetColumn(List, 0, &Column))
    {
        InitializeModuleList(List);
    }

    LVITEM Item;
    ULONG i;
    char Image[128];
    char Text[128];
    char Path[MAX_PATH];
    
    ListView_DeleteAllItems(List);

    if (g_ModuleBuffer->UiLockForRead() != S_OK)
    {
        Item.mask = LVIF_TEXT;
        Item.iItem = 0;
        Item.iSubItem = 0;
        Item.pszText = "Unable to retrieve module list";
        ListView_InsertItem(List, &Item);
        return;
    }

    PDEBUG_MODULE_PARAMETERS Params = (PDEBUG_MODULE_PARAMETERS)
        g_ModuleBuffer->GetDataBuffer();
    
    for (i = 0; i < g_NumModules; i++)
    {
        PSTR LoadBuf;
        ULONG LoadBufLen;
        
        if ((Params->Flags & DEBUG_MODULE_UNLOADED) ||
            g_pUiSymbols2 == NULL ||
            g_pUiSymbols2->
            GetModuleNameString(DEBUG_MODNAME_SYMBOL_FILE, DEBUG_ANY_ID,
                                Params->Base, Path, sizeof(Path),
                                NULL) != S_OK)
        {
            LoadBuf = Path;
            LoadBufLen = sizeof(Path);
        }
        else
        {
            LoadBuf = NULL;
            LoadBufLen = 0;
        }
        
        if (g_pUiSymbols->GetModuleNames(DEBUG_ANY_ID, Params->Base,
                                         Image, sizeof(Image), NULL,
                                         Text, sizeof(Text), NULL,
                                         LoadBuf, LoadBufLen, NULL) != S_OK)
        {
            strcpy(Text, "<Unable to get name>");
            if (LoadBuf != NULL)
            {
                strcpy(LoadBuf, "<Unable to get name>");
            }
        }

        if (Params->Flags & DEBUG_MODULE_UNLOADED)
        {
            strcpy(Text, "<Unloaded>");
            strcpy(Path, Image);
        }
        
        Item.mask = LVIF_TEXT | LVIF_PARAM;
        Item.iItem = i;
        Item.iSubItem = MODCOL_NAME;
        Item.pszText = Text;
        Item.lParam = i;
        ListView_InsertItem(List, &Item);

        ListView_SetItemText(List, i, MODCOL_START,
                             FormatAddr64(Params->Base));
        
        ListView_SetItemText(List, i, MODCOL_END,
                             FormatAddr64(Params->Base + Params->Size));

        if (Params->TimeDateStamp < 0xfffffffe)
        {
            time_t Time = (time_t)Params->TimeDateStamp;
            strcpy(Text, ctime(&Time));
            sprintf(Text + strlen(Text) - 1, " (%08x)", Params->TimeDateStamp);
        }
        else
        {
            sprintf(Text, "Unavailable");
        }
        ListView_SetItemText(List, i, MODCOL_TIMESTAMP, Text);

        sprintf(Text, "%08x", Params->Checksum);
        ListView_SetItemText(List, i, MODCOL_CHECKSUM, Text);

        if (Params->SymbolType != DEBUG_SYMTYPE_DEFERRED &&
            Params->SymbolType <
            sizeof(g_SymbolTypeNames) / sizeof(g_SymbolTypeNames[0]))
        {
            ListView_SetItemText(List, i, MODCOL_SYMBOL_TYPE,
                                 g_SymbolTypeNames[Params->SymbolType]);
        }
        else
        {
            ListView_SetItemText(List, i, MODCOL_SYMBOL_TYPE, "");
        }

        ListView_SetItemText(List, i, MODCOL_SYMBOL_FILE, Path);
        
        Params++;
    }

    UnlockStateBuffer(g_ModuleBuffer);
}

struct SORT_MODULE
{
    HWND List;
    int Column;
};

int CALLBACK
SortModuleCompare(LPARAM Lpm1, LPARAM Lpm2, LPARAM LpmSort)
{
    SORT_MODULE* Sort = (SORT_MODULE*)LpmSort;
    LVITEM Item;
    char Text1[MAX_PATH], Text2[MAX_PATH];
    PDEBUG_MODULE_PARAMETERS Param1, Param2;

    switch(Sort->Column)
    {
    case MODCOL_NAME:
    case MODCOL_START:
    case MODCOL_END:
    case MODCOL_CHECKSUM:
    case MODCOL_SYMBOL_TYPE:
    case MODCOL_SYMBOL_FILE:
        Item.mask = LVIF_TEXT;
        Item.iItem = (int)Lpm1;
        Item.iSubItem = Sort->Column;
        Item.pszText = Text1;
        Item.cchTextMax = sizeof(Text1);
        ListView_GetItem(Sort->List, &Item);
        Item.iItem = (int)Lpm2;
        Item.pszText = Text2;
        Item.cchTextMax = sizeof(Text2);
        ListView_GetItem(Sort->List, &Item);
        
        // Sort all empty text towards the bottom.
        if (Text1[0] == 0 && Text2[0] != 0)
        {
            return 1;
        }
        else if (Text2[0] == 0 && Text1[0] != 0)
        {
            return -1;
        }
        
        return _strcmpi(Text1, Text2);
        
    case MODCOL_TIMESTAMP:
        Item.mask = LVIF_PARAM;
        Item.iItem = (int)Lpm1;
        Item.iSubItem = 0;
        ListView_GetItem(Sort->List, &Item);
        Param1 = (PDEBUG_MODULE_PARAMETERS)
            g_ModuleBuffer->GetDataBuffer() + Item.lParam;
        Item.iItem = (int)Lpm2;
        ListView_GetItem(Sort->List, &Item);
        Param2 = (PDEBUG_MODULE_PARAMETERS)
            g_ModuleBuffer->GetDataBuffer() + Item.lParam;
        switch(Sort->Column)
        {
        case MODCOL_TIMESTAMP:
            return Param1->TimeDateStamp < Param2->TimeDateStamp ?
                -1 : (Param1->TimeDateStamp > Param2->TimeDateStamp ?
                      1 : 0);
        }
    }

    return 0;
}

void
SortModuleColumns(HWND List, int Column)
{
    if (g_ModuleBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    SORT_MODULE Sort = {List, Column};
    ListView_SortItemsEx(List, SortModuleCompare, (LPARAM)&Sort);

    UnlockStateBuffer(g_ModuleBuffer);
}

INT_PTR CALLBACK
DlgProc_Modules(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    LRESULT Sel;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        g_ModuleBuffer->m_Win = Hwnd;
        FillModuleList(GetDlgItem(Hwnd, IDC_MODULE_LIST));
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_MODULES);
            break;

        case IDCANCEL:
            g_ModuleBuffer->m_Win = NULL;
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    case WM_NOTIFY:
        if (Wpm == IDC_MODULE_LIST)
        {
            LPNMLISTVIEW Notify = (LPNMLISTVIEW)Lpm;
            
            if (Notify->hdr.code == LVN_COLUMNCLICK)
            {
                SortModuleColumns(GetDlgItem(Hwnd, IDC_MODULE_LIST),
                                  Notify->iSubItem);
            }
        }
        break;
        
    case LB_RESETCONTENT:
        FillModuleList(GetDlgItem(Hwnd, IDC_MODULE_LIST));
        break;
        
    default:
        return FALSE;
    }

    return TRUE;
}

void
EnumWorkspaceKey(HWND List, HKEY BaseKey, ULONG SubKey, BOOL ShowSubKey,
                 BOOL OmitCurrent)
{
    LONG Status;
    HKEY Key;
    char Text[128];

    sprintf(Text, WSP_REG_KEY "\\%s", g_WorkspaceKeyNames[SubKey]);
    if ((Status = RegOpenKeyEx(BaseKey, Text,
                               0, KEY_ALL_ACCESS, &Key)) != ERROR_SUCCESS)
    {
        return;
    }

    ULONG Index;
    char Name[MAX_WSP_NAME];
    ULONG NameLen;
    ULONG Type;
    ULONG Item;

    Index = 0;
    for (;;)
    {
        NameLen = sizeof(Name);
        if ((Status = RegEnumValue(Key, Index, Name, &NameLen,
                                   NULL, &Type, NULL, 0)) != ERROR_SUCCESS)
        {
            // Done with the enumeration.
            break;
        }
        if (Type != REG_BINARY)
        {
            // Only binary values should be present.
            break;
        }

        if (OmitCurrent && g_Workspace &&
            SubKey == g_Workspace->GetKey() &&
            !strcmp(g_Workspace->GetValue(), Name))
        {
            Index++;
            continue;
        }
        
        if (ShowSubKey)
        {
            sprintf(Text, "%s - %s", g_WorkspaceKeyDescriptions[SubKey], Name);
            Item = (ULONG)SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Text);
        }
        else
        {
            Item = (ULONG)SendMessage(List, LB_ADDSTRING, 0, (LPARAM)Name);
        }
        SendMessage(List, LB_SETITEMDATA, Item, SubKey);
        
        Index++;
    }

    RegCloseKey(Key);
}

void
FillWorkspaceList(HWND List)
{
    SendMessage(List, LB_RESETCONTENT, 0, 0);
    EnumWorkspaceKey(List, HKEY_CURRENT_USER, WSP_NAME_EXPLICIT,
                     FALSE, FALSE);
    EnumWorkspaceKey(List, HKEY_LOCAL_MACHINE, WSP_NAME_EXPLICIT,
                     FALSE, FALSE);
    SendMessage(List, LB_SETCURSEL, 0, 0);
}

INT_PTR CALLBACK
DlgProc_OpenWorkspace(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Name[MAX_WSP_NAME];
    LRESULT Sel;
    HRESULT Status;

    switch(Message)
    {
    case WM_INITDIALOG:
        SetWindowText(Hwnd, "Open Workspace");
        SendDlgItemMessage(Hwnd, IDC_WORKSPACE_NAME, EM_LIMITTEXT,
                           sizeof(Name) - 1, 0);
        FillWorkspaceList(GetDlgItem(Hwnd, IDC_WORKSPACE_LIST));
        SetWindowText(GetDlgItem(Hwnd, IDC_WORKSPACE_NAME), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_WORKSPACE_LIST:
            Sel = SendDlgItemMessage(Hwnd, IDC_WORKSPACE_LIST,
                                     LB_GETCURSEL, 0, 0);
            if (Sel >= 0 &&
                SendDlgItemMessage(Hwnd, IDC_WORKSPACE_LIST, LB_GETTEXT,
                                   Sel, (LPARAM)Name))
            {
                SetWindowText(GetDlgItem(Hwnd, IDC_WORKSPACE_NAME), Name);
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_OPEN_WORKSPACE);
            break;
            
        case IDOK:
            if (SendDlgItemMessage(Hwnd, IDC_WORKSPACE_NAME, WM_GETTEXT,
                                   sizeof(Name), (LPARAM)Name))
            {
                int Starts = 0;
                
                if ((Status = UiSwitchWorkspace(WSP_NAME_EXPLICIT,
                                                Name, FALSE,
                                                WSP_APPLY_EXPLICIT,
                                                &Starts)) != S_OK)
                {
                    if (Starts < 0)
                    {
                        InformationBox(ERR_Workspace_Session_Conflict, Status);
                    }
                    else
                    {
                        InformationBox(ERR_Cant_Open_Workspace, Status);
                    }
                    break;
                }
                else
                {
                    g_ExplicitWorkspace = TRUE;
                    if (Starts == 1)
                    {
                        StartDebugging();
                    }
                }
            }
            
            // Fall through.
            
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK
DlgProc_SaveWorkspaceAs(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Name[MAX_WSP_NAME];
    LRESULT Sel;
    HRESULT Status;

    switch(Message)
    {
    case WM_INITDIALOG:
        SetWindowText(Hwnd, "Save Workspace As");
        SendDlgItemMessage(Hwnd, IDC_WORKSPACE_NAME, EM_LIMITTEXT,
                           sizeof(Name) - 1, 0);
        FillWorkspaceList(GetDlgItem(Hwnd, IDC_WORKSPACE_LIST));
        SetWindowText(GetDlgItem(Hwnd, IDC_WORKSPACE_NAME),
                      g_Workspace->GetValue());
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_WORKSPACE_LIST:
            Sel = SendDlgItemMessage(Hwnd, IDC_WORKSPACE_LIST,
                                     LB_GETCURSEL, 0, 0);
            if (Sel >= 0 &&
                SendDlgItemMessage(Hwnd, IDC_WORKSPACE_LIST, LB_GETTEXT,
                                   Sel, (LPARAM)Name))
            {
                SetWindowText(GetDlgItem(Hwnd, IDC_WORKSPACE_NAME), Name);
            }
            break;
            
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_SAVE_WORKSPACE_AS);
            break;
            
        case IDOK:
            if (SendDlgItemMessage(Hwnd, IDC_WORKSPACE_NAME, WM_GETTEXT,
                                   sizeof(Name), (LPARAM)Name) == 0)
            {
                MessageBeep(0);
                break;
            }

            Status = g_Workspace->ChangeName(WSP_NAME_EXPLICIT, Name, FALSE);
            if (Status == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
            {
                if (QuestionBox(ERR_Workspace_Already_Exists, MB_YESNO,
                                Name) == IDNO)
                {
                    break;
                }
                
                Status = g_Workspace->ChangeName(WSP_NAME_EXPLICIT, Name,
                                                 TRUE);
            }

            if (Status != S_OK)
            {
                InformationBox(ERR_Cant_Save_Workspace, Status);
                break;
            }

            g_Workspace->Flush(TRUE, FALSE);

            // Fall through.
            
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return FALSE;
}

INT_PTR CALLBACK
DlgProc_AddToCommandHistory(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    char Text[MAX_COMMAND_LEN];
    PSTR TextEnd;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(Hwnd, IDC_ATCH_TEXT, EM_LIMITTEXT,
                           sizeof(Text) - 2, 0);
        SetWindowText(GetDlgItem(Hwnd, IDC_ATCH_TEXT), "");
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDHELP:
            OpenHelpTopic(HELP_TOPIC_POPUP_ADD_TO_COMMAND_OUTPUT);
            break;
            
        case IDOK:
            GetWindowText(GetDlgItem(Hwnd, IDC_ATCH_TEXT),
                          Text, sizeof(Text) - 1);
            TextEnd = Text + strlen(Text);
            *TextEnd++ = '\n';
            *TextEnd = 0;
            CmdOutput(Text,
                      g_OutMaskColors[USER_OUT_MASK_COL].Color,
                      g_OutMaskColors[USER_OUT_MASK_COL + 1].Color);
            // Send output for logging only.
            g_pUiControl->ControlledOutput(DEBUG_OUTCTL_LOG_ONLY,
                                           DEBUG_OUTPUT_NORMAL,
                                           "%s", Text);
            // Fall through.
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
FillDeleteWorkspacesList(HWND List)
{
    int i;
    
    SendMessage(List, LB_RESETCONTENT, 0, 0);

    for (i = 0; i < WSP_NAME_COUNT; i++)
    {
        EnumWorkspaceKey(List, HKEY_CURRENT_USER, i, TRUE, TRUE);
        EnumWorkspaceKey(List, HKEY_LOCAL_MACHINE, i, TRUE, TRUE);
    }
    
    SendMessage(List, LB_SETCURSEL, 0, 0);
}

INT_PTR CALLBACK
DlgProc_DeleteWorkspaces(HWND Hwnd, UINT Message, WPARAM Wpm, LPARAM Lpm)
{
    HWND List = GetDlgItem(Hwnd, IDC_WORKSPACE_LIST);
    LRESULT Sel;
    char NameBuf[MAX_WSP_NAME];
    PSTR Name;
    
    switch(Message)
    {
    case WM_INITDIALOG:
        FillDeleteWorkspacesList(List);
        break;

    case WM_COMMAND:
        switch(LOWORD(Wpm))
        {
        case IDC_WORKSPACE_LIST:
            if (HIWORD(Wpm) == LBN_DBLCLK)
            {
                goto DelItem;
            }
            break;

        case IDC_DELETE_WORKSPACE:
        DelItem:
            Sel = SendMessage(List, LB_GETCURSEL, 0, 0);
            if (Sel >= 0)
            {
                ULONG Key;

                Key = (ULONG)SendMessage(List, LB_GETITEMDATA, Sel, 0);
                SendMessage(List, LB_GETTEXT, Sel, (LPARAM)NameBuf);
                // Skip over introductory key description.
                Name = NameBuf + strlen(g_WorkspaceKeyDescriptions[Key]) + 3;
                Workspace::DeleteRegKey(TRUE, Key, Name);
                Workspace::DeleteRegKey(FALSE, Key, Name);
                FillDeleteWorkspacesList(List);
            }
            break;
            
        case IDHELP:
            // XXX drewb - Topic.
            // OpenHelpTopic(HELP_TOPIC_POPUP_GO_TO_ADDRESS);
            break;
            
        case IDCANCEL:
            EndDialog(Hwnd, LOWORD(Wpm));
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
CreateIndexedFont(ULONG FontIndex, BOOL SetAll)
{
    HFONT Font;

    Font = CreateFontIndirect(&g_Fonts[FontIndex].LogFont);
    if (Font != NULL)
    {
        if (g_Fonts[FontIndex].Font)
        {
            DeleteObject(g_Fonts[FontIndex].Font);
        }
        g_Fonts[FontIndex].Font = Font;
        g_Fonts[FontIndex].LogFontSet = TRUE;
            
        HDC Dc = GetDC(NULL);
        if (Dc != NULL)
        {
            SelectObject(Dc, Font);
            GetTextMetrics(Dc, &g_Fonts[FontIndex].Metrics);
            ReleaseDC(NULL, Dc);
        }

        if (SetAll)
        {
            SetAllFonts(FontIndex);
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
SelectFont(HWND Parent, ULONG FontIndex)
{
    CHOOSEFONT Choose;

    ZeroMemory(&Choose, sizeof(Choose));
    Choose.lStructSize = sizeof(Choose);
    Choose.hwndOwner = Parent;
    Choose.lpLogFont = &g_Fonts[FontIndex].LogFont;
    Choose.Flags = CF_FIXEDPITCHONLY | CF_FORCEFONTEXIST |
        CF_SCREENFONTS | (g_Fonts[FontIndex].LogFontSet ?
                          CF_INITTOLOGFONTSTRUCT : 0);
    if (ChooseFont(&Choose))
    {
        if (CreateIndexedFont(FontIndex, TRUE) && g_Workspace != NULL)
        {
            // If this function really is used to select different
            // fonts the tag will have to be dynamically chosen.
            g_Workspace->SetBuffer(WSP_GLOBAL_FIXED_LOGFONT,
                                   &g_Fonts[FontIndex].LogFont,
                                   sizeof(g_Fonts[FontIndex].LogFont));
        }
    }
}

BOOL
SelectColor(HWND Parent, ULONG Index)
{
    CHOOSECOLOR Choose;
    INDEXED_COLOR* IdxCol = GetIndexedColor(Index);

    ZeroMemory(&Choose, sizeof(Choose));
    Choose.lStructSize = sizeof(Choose);
    Choose.hwndOwner = Parent;
    Choose.rgbResult = IdxCol->Color;
    Choose.lpCustColors = g_CustomColors;
    Choose.Flags = CC_ANYCOLOR | CC_RGBINIT;
    if (ChooseColor(&Choose))
    {
        if (g_Workspace != NULL)
        {
            g_Workspace->SetUlong(DEF_WSP_TAG(WSP_GROUP_COLORS, Index),
                                  (ULONG)Choose.rgbResult);
        }

        SetColor(Index, Choose.rgbResult);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\res_str.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    Res_str.h

Abstract:

    This module contains the ids for loadable resource strings.

Environment:

    Win32, User Mode

--*/

#if ! defined( _RES_STR_ )
#define _RES_STR_


#ifdef RESOURCES
#define RES_STR(a, b, c) b, c
STRINGTABLE
BEGIN
#else

enum _RESOURCEIDS {
#define RES_STR(a, b, c) a = b,
#endif


//
// Error Messages
//


RES_STR(ERR_Engine_Failed,                1020, "Debugger did not start - please check your initialization parameters")
RES_STR(ERR_Assertion_Failed,             1021, "Assertion Failed")
RES_STR(ERR_Init_Application,             1022, "WinDbg cannot be initialized")
RES_STR(ERR_File_Name_Too_Long,           1023, "'%s' is too long for a filename")
RES_STR(ERR_Internal_Error,               1024, "An internal debugger error (0x%X) occurred in component '%s'.  Please contact Microsoft Technical Support.")
RES_STR(ERR_File_Open,                    1025, "The file '%s' cannot be opened")
RES_STR(ERR_Path_Too_Long,                1026, "The maximum length for a path is %d characters.\n Please truncate the following path:\n\n%s")
// Attach to a process
RES_STR(ERR_Invalid_Process_Name,         1027, "Invalid Process Name %s")
RES_STR(ERR_Invalid_Process_Id,           1028, "Invalid process ID %ld")
RES_STR(ERR_Invalid_Command_Line,         1029, "The command line arguments passed to WinDbg are invalid")
RES_STR(ERR_Bad_Remote,                   1030, "The remote debugger connection to (%s) failed")
RES_STR(ERR_Unable_To_Connect,            1031, "The debugger could not connect using '%s', result 0x%08X")
RES_STR(ERR_Invalid_Dump_File_Name,       1032, "Could not find the %s Dump File, error 0x%X")
RES_STR(ERR_Invalid_Process_Attach,       1033, "Could not attach to process %d, error 0x%X")
RES_STR(ERR_Invalid_Kernel_Attach,        1034, "Could not start kernel debugging using %s parameters, error 0x%X")
RES_STR(ERR_No_Register_Names,            1035, "Registers are not yet known")
RES_STR(ERR_Invalid_Server_Param,         1036, "The 'server' command was not given the correct parameters.  Please consult the documentation for a description of the 'server' command parameters")
RES_STR(ERR_Invalid_Remote_Param,         1037, "The 'remote' command was not given the correct parameters.  Please consult the documentation for a description of the 'remote' command parameters")
RES_STR(ERR_Fail_Inst_Postmortem_Dbg,     1039, "Windbg was not successfully installed as the default postmortem debugger.   This operation requires administrative privileges.")
RES_STR(ERR_Success_Inst_Postmortem_Dbg,  1040, "Windbg was successfully installed as the default postmortem debugger.")
RES_STR(ERR_Invalid_Process_Create,       1041, "Could not create process '%s', error 0x%X")
RES_STR(ERR_Unable_To_Open_Dump,          1042, "Failure when opening dump file '%s', error 0x%X\nIt may be corrupt or in a format not understood by the debugger")
RES_STR(ERR_Connection_In_Use,            1043, "The remoting connection is already in use")
RES_STR(ERR_Connect_Process_Server,       1044, "Unable to connect to process server '%s', error 0x%X")
RES_STR(ERR_Get_Named_Process,            1045, "Unable to find process '%s', error 0x%X")
RES_STR(ERR_Path_Empty,                   1046, "Please enter a value for the path")
RES_STR(ERR_Unable_To_Start_Process_Server, 1047, "Unable to start process server with options '%s', error 0x%X")
RES_STR(ERR_No_Detach_On_Exit,            1048, "The system does not support detach on exit")
RES_STR(ERR_No_Code_For_File_Line,        1049, "Code not found, breakpoint not set")
RES_STR(ERR_Deferred_Source_Breakpoint,     1050, "No symbolic information was found for this file.\nA deferred breakpoint has been set")
RES_STR(ERR_Cant_Open_Workspace,          1051, "Unable to open workspace, error 0x%X")
RES_STR(ERR_Workspace_Already_Exists,     1052, "Workspace %s already exists.  Overwrite?")
RES_STR(ERR_Cant_Save_Workspace,          1053, "Unable to save workspace, error 0x%X")
RES_STR(ERR_File_Has_Changed,             1054, "%s has changed since it was opened.  This may result in invalid breakpoints or other incorrect behavior.\n\nDo you want to reload the file?  NOTE: This will not update breakpoint locations")
RES_STR(ERR_Wake_Failed,                  1055, "Process %d is not a sleeping debugger")
RES_STR(ERR_Cant_Add_Dump_Info_File,      1056, "The debugger doesn't support additional dump information files")
RES_STR(ERR_Add_Dump_Info_File_Failed,    1057, "Unable to use '%s', error 0x%X")
RES_STR(ERR_Workspace_Session_Conflict,   1058, "The selected workspace will start a new debugging session.\nPlease stop the current debugging session first.")
RES_STR(ERR_Client_Disconnect,            1059, "The client cannot communicate with the server.  The session will be shut down.")

RES_STR(ERR_Cant_Modify_BP_While_Running, 1410, "Debuggee must be stopped before breakpoints can be modified.")
RES_STR(ERR_NULL_Workspace,               1419, "Workspace could not be created")
RES_STR(ERR_Unable_To_Retrieve_Info,      1420, "Unable to retrieve information, %s: %s")
RES_STR(STR_Retrieving_Information,       1421, "Retrieving information...")
RES_STR(ERR_No_More_Matches,              1422, "Can't find '%s'")
RES_STR(STR_Save_Base_Workspace,          1423, "Save base workspace information?")
RES_STR(STR_Save_Specific_Workspace,      1424, "Save %s workspace information?")
RES_STR(ERR_No_Remote_Server,             1425, "The debugger could not contact the remote server given in '%s'")
RES_STR(ERR_Remoting_Version_Mismatch,    1426, "The client is not using the same version of the remoting protocol as the server")
RES_STR(ERR_No_Local_Kernel_Debugging,    1427, "The system does not support local kernel debugging")
RES_STR(ERR_Failed_Local_Kernel_Debugging,1428, "Unable to debug the local kernel, error 0x%X")
RES_STR(STR_Save_Default_Workspace,       1429, "Save %s default workspace information?")
RES_STR(STR_Abandoning_Noninvasive_Debuggee, 1430, "Exiting without using 'q' or Stop Debugging may leave the debuggee in an unusable state.  Continue?")
RES_STR(STR_Unresolved_Source_Expr,       1431, "Symbol information for the current line could not be located in the currently loaded symbols.\nDo you want the debugger to load and search the remaining symbols?\n\nYes performs the search immediately.\nNo returns to the UI while the search proceeds.\nCancel exits the operation.")
RES_STR(STR_Engine_Still_Busy,            1432, "The debugger is still working and cannot stop.  Answer Yes to continue to wait or No to exit.")
RES_STR(STR_Auto_Arrange_Is_Enabled,      1433, "Automatic window arrangement is enabled and may move or resize your windows.\n\nThe Window.Auto Arrange menu item can be used to disable automatic arrangement.")


//
// System Strings
//

RES_STR(SYS_Main_wTitle,                    2000,"WinDbg:" VER_PRODUCTVERSION_STR " " )
RES_STR(SYS_Main_wClass,                    2001,"WindbgMainClass")
RES_STR(SYS_CommonWin_wClass,               2002,"CommonWinClass")
RES_STR(SYS_Clear,                          2003,"")
RES_STR(SYS_NewEdit_wClass,                 2006,"NewEditClass")
RES_STR(SYS_Help_File,                      2015,"debugger.chm")
RES_STR(SYS_CpuWin_Title,                   2025,"Registers")
RES_STR(SYS_WatchWin_Title,                 2026,"Watch")
RES_STR(SYS_LocalsWin_Title,                2027,"Locals")
RES_STR(SYS_DisasmWin_Title,                2028,"Disassembly")
RES_STR(SYS_CmdWin_Title,                   2029,"Command")
RES_STR(SYS_MemoryWin_Title,                2031,"Memory")
RES_STR(SYS_DocWin_Title,                   2032,"Document")
RES_STR(SYS_QuickWatchWin_Title,            2033,"Document")
RES_STR(SYS_CallsWin_Title,                 2062,"Calls")
RES_STR(SYS_Scratch_Pad_Title,              2063,"Scratch Pad")
RES_STR(SYS_Process_Thread_Title,           2064,"Processes and Threads")


//
// File-box title strings
//

RES_STR(DLG_Open_Filebox_Title,           3200,"Open Source File")
//RES_STR(DLG_SaveAs_Filebox_Title,         3201,"Save As")
//RES_STR(DLG_Merge_Filebox_Title,          3202,"Merge")
RES_STR(DLG_Browse_Filebox_Title,         3203,"Browse For File ")
RES_STR(DLG_Browse_DbugDll_Title,         3204,"Browse For DLL ")
RES_STR(DLG_Browse_For_Symbols_Title,     3205,"Open Symbol File For ")
RES_STR(DLG_Browse_LogFile_Title,         3206,"Browse For Log File")
RES_STR(DLG_Browse_Executable_Title,      3207,"Open Executable")
RES_STR(DLG_Browse_CrashDump_Title,       3208,"Open Crash Dump")



//
// Definitions for status line messages
//
// The '\t' is used to center the text in the status bar rectangle

RES_STR(STS_MESSAGE_OVERTYPE,             10201,"\tOVR")
RES_STR(STS_MESSAGE_CAPSLOCK,             10203,"\tCAPS")
RES_STR(STS_MESSAGE_NUMLOCK,              10204,"\tNUM")
RES_STR(STS_MESSAGE_LINE,                 10205,"\tLn")
RES_STR(STS_MESSAGE_COLUMN,               10206,"Col")
// RES_STR(STS_MESSAGE_SRC,                  10207,"\tSRC")
RES_STR(STS_MESSAGE_CURPROCID,            10208,"\tProc")
RES_STR(STS_MESSAGE_CURTHRDID,            10209,"\tThrd")
RES_STR(STS_MESSAGE_ASM,                  10210,"\tASM")


RES_STR(TYP_File_SOURCE,                  11011,"C/C++ Source Files")
RES_STR(TYP_File_INCLUDE,                 11012,"C/C++ Include Files")
RES_STR(TYP_File_ASMSRC,                  11013,"Assembly Source Files")
RES_STR(TYP_File_INC,                     11014,"Assembly Include Files")
RES_STR(TYP_File_RC,                      11015,"Resource Files")
RES_STR(TYP_File_DLG,                     11016,"Dialog Files")
RES_STR(TYP_File_DEF,                     11017,"Definition Files")
RES_STR(TYP_File_MAK,                     11018,"Project Files")
RES_STR(TYP_File_EXE,                     11019,"Executable Files")
RES_STR(TYP_File_LOG,                     11020,"Log Files")
RES_STR(TYP_File_DUMP,                    11021,"Crash Dump Files")
RES_STR(TYP_File_DLL,                     11022,"DLL Files")
RES_STR(TYP_File_ALL,                     11023,"All Files")

RES_STR(DEF_Ext_SOURCE,                   11051,"*.C;*.CPP;*.CXX")
RES_STR(DEF_Ext_INCLUDE,                  11052,"*.H;*.HPP;*.HXX")
RES_STR(DEF_Ext_ASMSRC,                   11053,"*.ASM;*.S")
RES_STR(DEF_Ext_INC,                      11054,"*.INC")
RES_STR(DEF_Ext_EXE,                      11055,"*.EXE")
RES_STR(DEF_Ext_LOG,                      11056,"*.LOG")
RES_STR(DEF_Ext_DUMP,                     11057,"*.DMP;*.MDMP;*.CAB")
RES_STR(DEF_Ext_RC,                       11058,"*.RC")
RES_STR(DEF_Ext_DLG,                      11059,"*.DLG")
RES_STR(DEF_Ext_DEF,                      11060,"*.DEF")
RES_STR(DEF_Ext_MAK,                      11061,"*.MAK")
RES_STR(DEF_Ext_DLL,                      11062,"*.DLL")
RES_STR(DEF_Ext_ALL,                      11063,"*.*")

RES_STR(DEF_Dump_File,                    11090,"MEMORY.DMP")


// Toolbar strings
RES_STR(TBR_FILE_OPEN,                    12000,"Open source file (Ctrl+O)")

RES_STR(TBR_EDIT_CUT,                     12002,"Cut (Ctrl+X)")
RES_STR(TBR_EDIT_COPY,                    12003,"Copy (Ctrl+C)")
RES_STR(TBR_EDIT_PASTE,                   12004,"Paste (Ctrl+V)")

RES_STR(TBR_DEBUG_GO,                     12005,"Go (F5)")
RES_STR(TBR_DEBUG_RESTART,                12006,"Restart (Ctrl+Shift+F5)")
RES_STR(TBR_DEBUG_STOPDEBUGGING,          12007,"Stop debugging (Shift+F5)")
RES_STR(TBR_DEBUG_BREAK,                  12008,"Break (Ctrl+Break)")

RES_STR(TBR_DEBUG_STEPINTO,               12009,"Step into (F11 or F8)")
RES_STR(TBR_DEBUG_STEPOVER,               12010,"Step over (F10)")
RES_STR(TBR_DEBUG_RUNTOCURSOR,            12011,"Run to cursor (Ctrl+F10 or F7)")

RES_STR(TBR_EDIT_BREAKPOINTS,             12012,"Insert or remove breakpoint (F9)")
RES_STR(TBR_DEBUG_QUICKWATCH,             12013,"Quick watch (Shift+F9)")

RES_STR(TBR_VIEW_COMMAND,                 12014,"Command (Alt+1)")
RES_STR(TBR_VIEW_WATCH,                   12015,"Watch (Alt+2)")
RES_STR(TBR_VIEW_LOCALS,                  12018,"Locals (Alt+3)")
RES_STR(TBR_VIEW_REGISTERS,               12019,"Registers (Alt+4)")
RES_STR(TBR_VIEW_MEMORY,                  12017,"Memory window (Alt+5)")
RES_STR(TBR_VIEW_CALLSTACK,               12016,"Call stack (Alt+6)")
RES_STR(TBR_VIEW_DISASM,                  12020,"Disassembly (Alt+7)")
RES_STR(TBR_VIEW_SCRATCH,                 12021,"Scratch Pad (Alt+8)")

RES_STR(TBR_DEBUG_SOURCE_MODE_ON,         12022,"Source mode on")
RES_STR(TBR_DEBUG_SOURCE_MODE_OFF,        12023,"Source mode off")

RES_STR(TBR_VIEW_FONT,                    12024,"Font")

RES_STR(TBR_EDIT_PROPERTIES,              12025,"Properties")

RES_STR(TBR_VIEW_OPTIONS,                 12026,"Options")

RES_STR(TBR_DEBUG_STEPOUT,                12027,"Step out (Shift+F11)")

RES_STR(TBR_WINDOW_ARRANGE,               12028,"Arrange windows")


#ifdef RESOURCES
    //
    // Menu Items Status bar help
    //

    IDM_FILE,                           "File operations"
    IDM_FILE_OPEN,                      "Open a source file"
    IDM_FILE_CLOSE,                     "Close active window"

    IDM_FILE_OPEN_EXECUTABLE,           "Open an executable to debug"
    IDM_FILE_ATTACH,                    "Attach to a running process"
    IDM_FILE_OPEN_CRASH_DUMP,           "Open a crash dump to debug"
    IDM_FILE_CONNECT_TO_REMOTE,         "Connect to a remote session"
    IDM_FILE_KERNEL_DEBUG,              "Start kernel debugging"
    IDM_FILE_SYMBOL_PATH,               "Set the symbol search path"
    IDM_FILE_SOURCE_PATH,               "Set the source search path"
    IDM_FILE_IMAGE_PATH,                "Set the image search path"

    IDM_FILE_OPEN_WORKSPACE,            "Open a saved workspace"
    IDM_FILE_SAVE_WORKSPACE,            "Save the current workspace"
    IDM_FILE_SAVE_WORKSPACE_AS,         "Save the current workspace with a new name"
    IDM_FILE_CLEAR_WORKSPACE,           "Remove entries from the current workspace"
    IDM_FILE_DELETE_WORKSPACES,         "Delete workspaces from the system"

    IDM_FILE_MAP_NET_DRIVE,             "Map a remote drive"
    IDM_FILE_DISCONN_NET_DRIVE,         "Disconnect a mapped remote drive"

    IDM_FILE_EXIT,                      "Exit WinDbg"

    //
    // Edit
    //
    IDM_EDIT,                           "Edit operations"
    IDM_EDIT_CUT,                       "Move the selected text to the clipboard"
    IDM_EDIT_COPY,                      "Copy the selected text to the clipboard"
    IDM_EDIT_PASTE,                     "Paste the clipboard text at the insertion point"
    IDM_EDIT_SELECT_ALL,                "Select all of the text in the active window"
    IDM_EDIT_ADD_TO_COMMAND_HISTORY,    "Add a line to the command history text"
    IDM_EDIT_CLEAR_COMMAND_HISTORY,     "Clear the command history text"
    IDM_EDIT_FIND,                      "Find some text"
    IDM_EDIT_GOTO_LINE,                 "Move to a specified line number"
    IDM_EDIT_GOTO_ADDRESS,              "Move to the specified address"
    IDM_EDIT_BREAKPOINTS,               "Edit program breakpoints"
    IDM_EDIT_LOG_FILE,                  "Open or close a log file"
    IDM_EDIT_PROPERTIES,                "Edit properties for Memory, Watch, Locals, and Call Stack windows"

    //
    // View
    //
    IDM_VIEW,                           "File navigation, status and toolbars"
    
    IDM_VIEW_COMMAND,                   "Open the command window"
    IDM_VIEW_WATCH,                     "Open the watch window"
    IDM_VIEW_CALLSTACK,                 "Open the call stack window"
    IDM_VIEW_MEMORY,                    "Open a memory window"
    IDM_VIEW_LOCALS,                    "Open the locals window"
    IDM_VIEW_REGISTERS,                 "Open the registers window"
    IDM_VIEW_DISASM,                    "Open the disassembly window"
    IDM_VIEW_SCRATCH,                   "Open the scratch pad window"
    IDM_VIEW_PROCESS_THREAD,            "Open the process and thread window"
    IDM_VIEW_TOGGLE_VERBOSE,            "Toggle the verbose output setting"
    IDM_VIEW_SHOW_VERSION,              "Display debugger and debuggee version information"
    IDM_VIEW_TOOLBAR,                   "Toggle the toolbar on or off"
    IDM_VIEW_STATUS,                    "Toggle the status bar on or off"
    IDM_VIEW_FONT,                      "View or edit the font for the current window"
    IDM_VIEW_OPTIONS,                   "View program options"

    //
    // Debug
    //
    IDM_DEBUG,                          "Debug operations"
    IDM_DEBUG_GO,                       "Run the Program"
    IDM_DEBUG_GO_UNHANDLED,             "Do not handle the exception, but continue running"
    IDM_DEBUG_GO_HANDLED,               "Handle the exception and continue running"
    IDM_DEBUG_RESTART,                  "Restart the Program"
    IDM_DEBUG_STOPDEBUGGING,            "Stop debugging the current program"
    IDM_DEBUG_BREAK,                    "Halt the current program"
    IDM_DEBUG_STEPINTO,                 "Trace into the next statement"
    IDM_DEBUG_STEPOVER,                 "Step over the next statement"
    IDM_DEBUG_STEPOUT,                  "Step out of the current function"
    IDM_DEBUG_RUNTOCURSOR,              "Run the program to the line containing the cursor"
    IDM_DEBUG_SOURCE_MODE,              "Display source when possible"
    IDM_DEBUG_EVENT_FILTERS,            "Manage event filters"
    IDM_DEBUG_MODULES,                  "View the module list"
    IDM_KDEBUG,                         "Kernel debugging control"
    IDM_KDEBUG_TOGGLE_BAUDRATE,         "Cycle through the available baud rate settings"
    IDM_KDEBUG_TOGGLE_INITBREAK,        "Cycle through the possible initial break settings"
    IDM_KDEBUG_RECONNECT,               "Request that the debugger resynchronize with the debuggee"

    //
    // Window
    //
    IDM_WINDOW,                         "Window arrangement and selection"
    IDM_WINDOW_CASCADE,                 "Arrange the windows in a cascaded view"
    IDM_WINDOW_TILE_HORZ,               "Tiles the windows so that they are wide rather than tall"
    IDM_WINDOW_TILE_VERT,               "Tiles the windows so that they are tall rather than wide"
    IDM_WINDOW_ARRANGE,                 "Arrange windows"
    IDM_WINDOW_ARRANGE_ICONS,           "Arrange icons"
    IDM_WINDOW_AUTO_ARRANGE,            "Automatically arrange all windows"
    IDM_WINDOW_ARRANGE_ALL,             "Arrange all child windows, including sources and disassembly windows"
    IDM_WINDOW_OVERLAY_SOURCE,          "Overlay source windows"
    IDM_WINDOW_AUTO_DISASM,             "Automatically open a disassembly window when source is not available"

    //
    // Help
    //
    IDM_HELP,                           "Help contents and searches"
    IDM_HELP_CONTENTS,                  "Open the help table of contents"
    IDM_HELP_INDEX,                     "Open the help index"
    IDM_HELP_SEARCH,                    "Open the help search dialog"
    IDM_HELP_ABOUT,                     "About WinDbg"



#endif

#ifdef RESOURCES
END
#else
};
#endif


#endif // _RES_STR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\statebuf.cpp ===
//----------------------------------------------------------------------------
//
// Debuggee state buffers.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop

#include <malloc.h>

#if 0
#define DBG_BUFFER
#endif

StateBuffer g_UiOutputCapture(256);

//----------------------------------------------------------------------------
//
// StateBuffer.
//
//----------------------------------------------------------------------------

StateBuffer::StateBuffer(ULONG ChangeBy)
{
    Dbg_InitializeCriticalSection(&m_Lock);
                              
    Flink = NULL;
    Blink = NULL;
    
    m_ChangeBy = ChangeBy;
    m_Win = NULL;
    m_UpdateTypes = 0;
    m_UpdateType = UPDATE_BUFFER;
    m_UpdateMessage = WU_UPDATE;
    m_Status = S_OK;
    // The buffer must start out with an outstanding
    // read request to indicate that it doesn't have valid content.
    m_ReadRequest = 1;
    m_ReadDone = 0;
    SetNoData();
}

StateBuffer::~StateBuffer(void)
{
    Free();

    Dbg_DeleteCriticalSection(&m_Lock);
}

PVOID
StateBuffer::AddData(ULONG Len)
{
    PVOID Ret;
    ULONG Needed;
    
    Needed = m_DataUsed + Len;
    if (Needed > m_DataLen)
    {
        if (Resize(Needed) != S_OK)
        {
            return NULL;
        }
    }
    
    Ret = m_Data + m_DataUsed;
    m_DataUsed += Len;
    
    return Ret;
}

BOOL
StateBuffer::AddString(PCSTR Str, BOOL SoftTerminate)
{
    ULONG Len = strlen(Str) + 1;
    PSTR Buf = (PSTR)AddData(Len);
    if (Buf != NULL)
    {
        memcpy(Buf, Str, Len);

        if (SoftTerminate)
        {
            // Back up to pack strings without intervening
            // terminators.  Buffer isn't shrunk so terminator
            // remains to terminate the overall buffer until
            // new data.
            RemoveTail(1);
        }
        
        return TRUE;
    }

    return FALSE;
}

void
StateBuffer::RemoveHead(ULONG Len)
{
    if (Len > m_DataUsed)
    {
        Len = m_DataUsed;
    }

    ULONG Left = m_DataUsed - Len;
    
    if (Len > 0 && Left > 0)
    {
        memmove(m_Data, (PBYTE)m_Data + Len, Left);
    }
    
    m_DataUsed = Left;
}

void
StateBuffer::RemoveMiddle(ULONG Start, ULONG Len)
{
    if (Start >= m_DataUsed)
    {
        return;
    }
    
    if (Start + Len > m_DataUsed)
    {
        Len = m_DataUsed - Start;
    }

    ULONG Left = m_DataUsed - Len - Start;
    
    if (Len > 0 && Left > 0)
    {
        memmove(m_Data + Start, (PBYTE)m_Data + Start + Len, Left);
    }
    
    m_DataUsed = Start + Left;
}

void
StateBuffer::RemoveTail(ULONG Len)
{
    if (Len > m_DataUsed)
    {
        Len = m_DataUsed;
    }

    m_DataUsed -= Len;
}

HRESULT
StateBuffer::Resize(ULONG Len)
{
    PBYTE NewData;
    ULONG NewLen;

    if (Len == m_DataLen)
    {
        return S_OK;
    }
    
    NewLen = m_DataLen;
    if (Len < NewLen)
    {
        do
        {
            NewLen -= m_ChangeBy;
        }
        while (NewLen > Len);
        NewLen += m_ChangeBy;
    }
    else
    {
        do
        {
            NewLen += m_ChangeBy;
        }
        while (NewLen < Len);
    }

#if DBG
    // Force every resize to go to a new memory block
    // and backfill the old block to make it obvious
    // when pointers are being held across resizes.
    if (NewLen == 0)
    {
        free(m_Data);
        NewData = NULL;
    }
    else
    {
        NewData = (PBYTE)malloc(NewLen);
        if (NewData != NULL && m_Data != NULL)
        {
            ULONG OldLen = _msize(m_Data);
            ULONG CopyLen = min(OldLen, NewLen);
            memcpy(NewData, m_Data, CopyLen);
            memset(m_Data, 0xfe, OldLen);
            free(m_Data);
        }
    }
#else
    NewData = (PBYTE)realloc(m_Data, NewLen);
#endif
    if (NewLen > 0 && NewData == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_Data = NewData;
    m_DataLen = NewLen;

    return S_OK;
}

void
StateBuffer::Free(void)
{
    free(m_Data);
    SetNoData();
}

HRESULT
StateBuffer::Update(void)
{
    ULONG Request;

    // First sample the request value.  This
    // value will be set as the done value if
    // a read is performed and therefore must
    // be sampled first to make it the most
    // conservative estimate of what was done.
    Request = m_ReadRequest;
    if (Request != m_ReadDone)
    {
        LockStateBuffer(this);
                
        m_Status = ReadState();
        // Always mark the buffer with the latest completed
        // sequence so that errors get picked up in addition
        // to successful reads.
        m_ReadDone = Request;

#ifdef DBG_BUFFER
        if (m_Status != S_OK)
        {
            DebugPrint("State buffer %p:%d fill failed, 0x%X\n",
                       this, m_enumType, m_Status);
        }
        if (m_ReadRequest != m_ReadDone)
        {
            DebugPrint("State buffer %p:%d fill out of date, "
                       "req %X, done %X\n",
                       this, m_enumType, m_ReadRequest, m_ReadDone);
        }
#endif
        
        UnlockStateBuffer(this);

        if (m_Win != NULL)
        {
            PostMessage(m_Win, m_UpdateMessage, 0, 0);
        }
        if (m_Status == S_OK && m_UpdateTypes)
        {
            UpdateBufferWindows(m_UpdateTypes, m_UpdateType);
        }
    }

    return m_Status;
}

void
StateBuffer::UiRequestRead(void)
{
    //
    // Called on the UI thread.
    //
    
    // No need to lock here as a race for
    // the read request value is not a problem.
    // If the read request value is sampled early
    // and a read request does not occur it'll
    // happen the next time around since this routine
    // also wakes the engine.
    RequestRead();
    UpdateEngine();
}

HRESULT
StateBuffer::UiLockForRead(void)
{
    ULONG Done;
    
    //
    // Called on the UI thread.
    //
    
    // First sample the read count without locking.
    Done = m_ReadDone;

    // Now check whether the request is newer than the
    // last read done.  The UI thread is the only thread
    // that updates the request count so this should be safe.
    if (Done == m_ReadRequest)
    {
        HRESULT Status;
        
        LockStateBuffer(this);

        Status = m_Status;
        if (FAILED(Status))
        {
            // If there was an error when filling the buffer
            // return it and leave the buffer unlocked.
            UnlockStateBuffer(this);
            return Status;
        }

        // Buffer is locked and valid.
        return S_OK;
    }
    else
    {
        // Buffer content is out-of-date so don't lock.
        // Make sure the engine is active to update the buffer.
        return S_FALSE;
    }
}

HRESULT
StateBuffer::ReadState(void)
{
    return S_OK;
}

//----------------------------------------------------------------------------
//
// OutputToStateBuffer.
//
//----------------------------------------------------------------------------

HRESULT
OutputToStateBuffer::Start(BOOL Empty)
{
    if (Empty)
    {
        m_Buffer->Empty();
    }
    m_DataStart = m_Buffer->GetDataLen();
    m_Status = S_OK;
    m_NewLineCount = 0;
    m_PartialLine = 0;

    return S_OK;
}

HRESULT
OutputToStateBuffer::End(BOOL RemoveLastNewLine)
{
    if (RemoveLastNewLine && m_PartialLine == 0)
    {
        // Remove the final newline so that richedit doesn't leave
        // a blank line at the bottom of the window when the
        // text is displayed.
        *((PSTR)m_Buffer->GetDataBuffer() + m_Buffer->GetDataLen() - 1) = 0;
    }
    else
    {
        // Every individual line allocates space for a terminator
        // and then backs up.  This requested space should always
        // be available.
        PVOID Data = m_Buffer->AddData(1);
        Assert(Data != NULL);
    }

    return m_Status;
}

void
OutputToStateBuffer::ReplaceChar(char From, char To)
{
    PSTR Buf = (PSTR)m_Buffer->GetDataBuffer() + m_DataStart;
    PSTR End = (PSTR)m_Buffer->GetDataBuffer() + m_Buffer->GetDataLen();

    while (Buf < End)
    {
        if (*Buf == From)
        {
            *Buf = To;
        }

        Buf++;
    }
}

STDMETHODIMP
OutputToStateBuffer::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    if (!m_Buffer->AddString(Text, TRUE))
    {
        return E_OUTOFMEMORY;
    }

    AddLines(Text);
    return S_OK;
}

void
OutputToStateBuffer::AddLines(PCSTR Start)
{
    PCSTR LastNl = Start;
    PCSTR Nl;
    
    for (;;)
    {
        Nl = strchr(LastNl, '\n');
        if (Nl == NULL)
        {
            break;
        }

        m_NewLineCount++;
        LastNl = Nl + 1;
    }

    // If the last newline wasn't at the end of the text there's
    // a partial line which needs to count in the line count
    // but only until a finishing newline comes in.
    m_PartialLine = *LastNl != 0 ? 1 : 0;
}

OutputToStateBuffer g_OutStateBuf;
OutputToStateBuffer g_UiOutStateBuf;

//----------------------------------------------------------------------------
//
// Dynamic state buffers.
//
//----------------------------------------------------------------------------

LIST_ENTRY g_StateList;

DBG_CRITICAL_SECTION g_QuickLock;

ULONG64 g_CodeIp;
char g_CodeFileFound[MAX_SOURCE_PATH];
char g_CodeSymFile[MAX_SOURCE_PATH];
ULONG g_CodeLine;
BOOL g_CodeUserActivated;
ULONG g_CodeBufferSequence;

ULONG64 g_EventIp;
ULONG64 g_EventReturnAddr = DEBUG_INVALID_OFFSET;
ULONG g_CurProcessId, g_CurProcessSysId;
ULONG g_CurThreadId, g_CurThreadSysId;
ULONG g_EventBufferRequest;
ULONG g_EventBufferDone;

void
FillCodeBuffer(ULONG64 Ip, BOOL UserActivated)
{
    char File[MAX_SOURCE_PATH];
    char Found[MAX_SOURCE_PATH];
    ULONG Line;
    ULONG64 Disp;

    // Fill local information rather than global information
    // to avoid changing the global information until all
    // event information has been collected.
    
    if (g_pDbgSymbols->
        GetLineByOffset(Ip, &Line, File, sizeof(File), NULL, &Disp) != S_OK)
    {
        // This will be hit if the buffer is too small
        // to hold the filename.  This could be switched to dynamically
        // allocate the filename buffer but that seems like overkill.
        File[0] = 0;
        Found[0] = 0;
    }
    else
    {
        // Source information is one-based but the source
        // window lines are zero-based.
        Line--;

        // Look up the reported file along the source path.
        // XXX drewb - Use first-match and then element walk to
        // determine ambiguities and display resolution UI.
        if (g_pLocSymbols->
            FindSourceFile(0, File,
                           DEBUG_FIND_SOURCE_BEST_MATCH |
                           DEBUG_FIND_SOURCE_FULL_PATH,
                           NULL, Found, sizeof(Found), NULL) != S_OK)
        {
            // XXX drewb - Display UI instead of just disabling source?
            Found[0] = 0;
        }
    }

    // Now that all of the information has been collected
    // take the lock and update the global state.
    Dbg_EnterCriticalSection(&g_QuickLock);
    
    g_CodeIp = Ip;
    strcpy(g_CodeFileFound, Found);
    strcpy(g_CodeSymFile, File);
    g_CodeLine = Line;
    g_CodeUserActivated = UserActivated;
    g_CodeBufferSequence++;

    Dbg_LeaveCriticalSection(&g_QuickLock);

    // Wake up the UI thread to process the new event location.
    UpdateUi();
}

void
FillEventBuffer(void)
{
    ULONG64 Ip;
    ULONG64 ScopeIp;
    ULONG64 RetAddr;
    ULONG ProcessId, ProcessSysId;
    ULONG ThreadId, ThreadSysId;
    ULONG Done = g_EventBufferRequest;
    HRESULT Status;

    if (g_pDbgRegisters->GetInstructionOffset(&Ip) != S_OK ||
        g_pDbgControl->GetReturnOffset(&RetAddr) != S_OK ||
        g_pDbgSystem->GetCurrentProcessId(&ProcessId) != S_OK ||
        g_pDbgSystem->GetCurrentThreadId(&ThreadId) != S_OK)
    {
        return;
    }

    // Kernel mode doesn't implement system IDs as the process
    // and threads are fakes and not real system objects.  Just
    // use zero if E_NOTIMPL is returned.
    if ((Status = g_pDbgSystem->
         GetCurrentProcessSystemId(&ProcessSysId)) != S_OK)
    {
        if (Status == E_NOTIMPL)
        {
            ProcessSysId = 0;
        }
        else
        {
            // Unexpected error, must be a real problem.
            return;
        }
    }
    if ((Status = g_pDbgSystem->
         GetCurrentThreadSystemId(&ThreadSysId)) != S_OK)
    {
        if (Status == E_NOTIMPL)
        {
            ThreadSysId = 0;
        }
        else
        {
            // Unexpected error, must be a real problem.
            return;
        }
    }
    
    // Fill code buffer with scope Ip
    if (g_pDbgSymbols->GetScope(&ScopeIp, NULL, NULL, 0) != S_OK)
    {
	return;
    }
    
    FillCodeBuffer(ScopeIp, FALSE);
    g_EventIp = Ip;
    g_EventReturnAddr = RetAddr;
    g_CurProcessId = ProcessId;
    g_CurProcessSysId = ProcessSysId;
    g_CurThreadId = ThreadId;
    g_CurThreadSysId = ThreadSysId;

    if (!g_CodeLevelLocked)
    {
        ULONG CodeLevel;
    
        if (g_CodeFileFound[0] == 0)
        {
            // No source so switch to assembly mode.
            CodeLevel = DEBUG_LEVEL_ASSEMBLY;
        }
        else
        {
            if (GetSrcMode_StatusBar())
            {
                CodeLevel = DEBUG_LEVEL_SOURCE;
            }
            else
            {
                CodeLevel = DEBUG_LEVEL_ASSEMBLY;
            }
        }
        g_IgnoreCodeLevelChange = TRUE;
        g_pDbgControl->SetCodeLevel(CodeLevel);
        g_IgnoreCodeLevelChange = FALSE;
    }
    
    g_EventBufferDone = Done;
    PostMessage(g_hwndFrame, WU_UPDATE, UPDATE_EXEC, 0);
}

class BpStateBuffer : public StateBuffer
{
public:
    BpStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = BP_BIT;
        m_UpdateMessage = LB_RESETCONTENT;
        m_UpdateTypes = (1 << DOC_WINDOW) | (1 << DISASM_WINDOW);
        m_UpdateType = UPDATE_BP;
    }

    virtual HRESULT ReadState(void);
};

// #define DBG_BPBUF
#define BP_EXTRA_ENTRIES 8

ULONG g_BpCount;
BpStateBuffer g_PrivateBpBuffer;
StateBuffer* g_BpBuffer = &g_PrivateBpBuffer;
ULONG g_BpTextOffset;

HRESULT
BpStateBuffer::ReadState(void)
{
    HRESULT Status;
    ULONG Count;
    ULONG TextOffset;
    ULONG FileOffset;
    BpBufferData* Data;
    ULONG i;
    PDEBUG_BREAKPOINT_PARAMETERS Params;
    char FileBuf[MAX_SOURCE_PATH];

    // Reserve room for BP descriptions in front of the text.
    // When doing so, reserve extra slots to allow for free
    // slots the next time around.
    Empty();
    Status = g_pDbgControl->GetNumberBreakpoints(&Count);
    if (Status != S_OK)
    {
        return Status;
    }

    TextOffset = (Count + BP_EXTRA_ENTRIES) * sizeof(BpBufferData);
    Data = (BpBufferData*)AddData(TextOffset);
    if (Data == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Allocate a temporary buffer for bulk breakpoint retrieval.
    Params = new DEBUG_BREAKPOINT_PARAMETERS[Count];
    if (Params == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // GetBreakpointParameters can return S_FALSE when there
    // are hidden breakpoints.
    if (FAILED(Status = g_pDbgControl->
               GetBreakpointParameters(Count, NULL, 0, Params)) != S_OK)
    {
        delete Params;
        return Status;
    }
    
    // Iterate over breakpoints and retrieve offsets for
    // all execution breakpoints.
    // Take advantage of the fact that Empty does not actually
    // discard data to distinguish changed breakpoints from
    // unchanged breakpoints.
    ULONG Write = 0;
    
    for (i = 0; i < Count; i++)
    {
        if (Params[i].Id == DEBUG_ANY_ID ||
            Params[i].Offset == DEBUG_INVALID_OFFSET ||
            (Params[i].BreakType == DEBUG_BREAKPOINT_DATA &&
             Params[i].DataAccessType != DEBUG_BREAK_EXECUTE))
        {
            // Not a breakpoint that we care about, skip.
            continue;
        }

        // Check and see if this offset is already known.
        ULONG Match;

        for (Match = 0; Match < g_BpCount; Match++)
        {
            // NOTE: This compresses duplicate breakpoints
            // with a first-writer-wins on the ID.
            if (Data[Match].Offset == Params[i].Offset)
            {
                break;
            }
        }
        if (Match < g_BpCount)
        {
            BpBufferData Temp;
            
            // Keep the old record for this offset to minimize
            // UI updates.
            if (Match > Write)
            {
                Temp = Data[Match];
                Data[Match] = Data[Write];
                Data[Write] = Temp;
                Match = Write;
            }

#ifdef DBG_BPBUF
            DebugPrint("Match %d:%I64X %d:%d into %d\n",
                       Params[i].Id, Params[i].Offset, Data[Match].Id,
                       Match, Write);
#endif
            
            Write++;

            // We mostly ignore flag differences.  ENABLED, however,
            // is important to have accurate and in the most-enabled
            // way.
            if ((Data[Match].Flags ^ Params[i].Flags) &
                DEBUG_BREAKPOINT_ENABLED)
            {
                if (Data[Match].Id != Params[i].Id)
                {
                    Data[Match].Flags |=
                        Params[i].Flags & DEBUG_BREAKPOINT_ENABLED;
                }
                else
                {
                    Data[Match].Flags = Params[i].Flags;
                }
                Data[Match].Thread = Params[i].MatchThread;
                Data[Match].Sequence = g_CommandSequence;
            }
        }
        else
        {
            // Fill in a new record.  This will potentially destroy
            // an old record and so reduce the effectivess of delta
            // checking but the front of the buffer is packed
            // with the extra entries to handle these changes hopefully
            // without eating into the actual entries.
#ifdef DBG_BPBUF
            DebugPrint("Write %d:%I64X into %d\n", Params[i].Id,
                       Params[i].Offset, Write);
#endif
            
            Data[Write].Offset = Params[i].Offset;
            Data[Write].Id = Params[i].Id;
            Data[Write].Flags = Params[i].Flags;
            Data[Write].Thread = Params[i].MatchThread;
            Data[Write].Sequence = g_CommandSequence;
            Write++;
        }
    }

    delete Params;
    
    // Pack unused entries at the front of the buffer so that
    // they get used first in the next delta computation.
    Count += BP_EXTRA_ENTRIES;

#ifdef DBG_BPBUF
    DebugPrint("Used %d of %d\n", Write, Count);
#endif

    if (Write < Count)
    {
        ULONG Extra = Count - Write;
        
        memmove(Data + Extra, Data, Write * sizeof(*Data));
        for (i = 0; i < Extra; i++)
        {
            Data[i].Offset = DEBUG_INVALID_OFFSET;
        }
    }

    //
    // Now go through the valid breakpoints and look up
    // what file they're in, if any.
    //

    for (i = 0; i < Count; i++)
    {
        ULONG Line;
        PSTR FileSpace;

        // Refresh every time since growth may have caused
        // a realloc.
        Data = (BpBufferData*)m_Data;
        Data[i].FileOffset = 0;
        
        if (Data[i].Offset != DEBUG_INVALID_OFFSET &&
            g_pDbgSymbols->GetLineByOffset(Data[i].Offset, &Line,
                                           FileBuf, sizeof(FileBuf), NULL,
                                           NULL) == S_OK)
        {
            // Do this first before m_DataUsed is updated and
            // Data is invalidated.
            Data[i].FileOffset = m_DataUsed;

            FileSpace = (PSTR)AddData(sizeof(Line) + strlen(FileBuf) + 1);
            if (FileSpace == NULL)
            {
                return E_OUTOFMEMORY;
            }

            *(ULONG UNALIGNED *)FileSpace = Line;
            FileSpace += sizeof(Line);
            strcpy(FileSpace, FileBuf);
        }
    }

    TextOffset = m_DataUsed;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(FALSE)) != S_OK)
    {
        return Status;
    }

    // Get breakpoint list.
    Status = g_pOutCapControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                       DEBUG_OUTCTL_OVERRIDE_MASK |
                                       DEBUG_OUTCTL_NOT_LOGGED,
                                       "bl", DEBUG_EXECUTE_NOT_LOGGED |
                                       DEBUG_EXECUTE_NO_REPEAT);
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(FALSE);
        if (Status == S_OK)
        {
            // Separate lines by nulls to make them easier
            // to process as individual strings.
            g_OutStateBuf.ReplaceChar('\n', 0);
        }
    }
    else
    {
        g_OutStateBuf.End(FALSE);
    }
    
    if (Status == S_OK)
    {
        g_BpCount = Count;
        g_BpTextOffset = TextOffset;
    }

    return Status;
}

class BpCmdsStateBuffer : public StateBuffer
{
public:
    BpCmdsStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = BP_CMDS_BIT;
    }

    virtual HRESULT ReadState(void);
};

BpCmdsStateBuffer g_PrivateBpCmdsBuffer;
StateBuffer* g_BpCmdsBuffer = &g_PrivateBpCmdsBuffer;

HRESULT
BpCmdsStateBuffer::ReadState(void)
{
    HRESULT Status;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(TRUE)) != S_OK)
    {
        return Status;
    }

    // Get breakpoint commands.
    Status = g_pOutCapControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                       DEBUG_OUTCTL_OVERRIDE_MASK |
                                       DEBUG_OUTCTL_NOT_LOGGED,
                                       ".bpcmds -e -m -p 0",
                                       DEBUG_EXECUTE_NOT_LOGGED |
                                       DEBUG_EXECUTE_NO_REPEAT);
    
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(FALSE);
    }
    else
    {
        g_OutStateBuf.End(FALSE);
    }
    
    return Status;
}

class FilterTextStateBuffer : public StateBuffer
{
public:
    FilterTextStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = MINVAL_WINDOW;
        m_UpdateMessage = 0;
    }

    virtual HRESULT ReadState(void);
};

FilterTextStateBuffer g_PrivateFilterTextBuffer;
StateBuffer* g_FilterTextBuffer = &g_PrivateFilterTextBuffer;

HRESULT
FilterTextStateBuffer::ReadState(void)
{
    HRESULT Status;
    ULONG SpecEvents, SpecEx, ArbEx;
    ULONG i;
    PSTR Text;

    if ((Status = g_pDbgControl->
         GetNumberEventFilters(&SpecEvents, &SpecEx, &ArbEx)) != S_OK)
    {
        return Status;
    }

    Empty();

    DEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    
    for (i = 0; i < SpecEvents; i++)
    {
        if ((Status = g_pDbgControl->
             GetSpecificFilterParameters(i, 1, &SpecParams)) != S_OK)
        {
            return Status;
        }

        if (SpecParams.TextSize == 0)
        {
            // Put a terminator in anyway to keep the
            // indexing correct.
            if ((Text = (PSTR)AddData(1)) == NULL)
            {
                return E_OUTOFMEMORY;
            }

            *Text = 0;
        }
        else
        {
            if ((Text = (PSTR)AddData(SpecParams.TextSize)) == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetEventFilterText(i, Text, SpecParams.TextSize,
                                    NULL)) != S_OK)
            {
                return Status;
            }
        }
    }

    DEBUG_EXCEPTION_FILTER_PARAMETERS ExParams;
    
    for (i = 0; i < SpecEx; i++)
    {
        if ((Status = g_pDbgControl->
             GetExceptionFilterParameters(1, NULL, i + SpecEvents,
                                          &ExParams)) != S_OK)
        {
            return Status;
        }

        if (ExParams.TextSize == 0)
        {
            // Put a terminator in anyway to keep the
            // indexing correct.
            if ((Text = (PSTR)AddData(1)) == NULL)
            {
                return E_OUTOFMEMORY;
            }

            *Text = 0;
        }
        else
        {
            if ((Text = (PSTR)AddData(ExParams.TextSize)) == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetEventFilterText(i + SpecEvents, Text, ExParams.TextSize,
                                    NULL)) != S_OK)
            {
                return Status;
            }
        }
    }

    return S_OK;
}

class FilterStateBuffer : public StateBuffer
{
public:
    FilterStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = FILTER_BIT;
        m_UpdateMessage = LB_RESETCONTENT;
    }

    virtual HRESULT ReadState(void);
};

FilterStateBuffer g_PrivateFilterBuffer;
StateBuffer* g_FilterBuffer = &g_PrivateFilterBuffer;
ULONG g_FilterArgsOffset;
ULONG g_FilterCmdsOffset;
ULONG g_FilterWspCmdsOffset;
ULONG g_NumSpecEvents, g_NumSpecEx, g_NumArbEx;

HRESULT
FilterStateBuffer::ReadState(void)
{
    ULONG SpecEvents, SpecEx, ArbEx;
    HRESULT Status;
    ULONG ArgsOffset, CmdsOffset, WspCmdsOffset;
    PDEBUG_SPECIFIC_FILTER_PARAMETERS SpecParams;
    PDEBUG_EXCEPTION_FILTER_PARAMETERS ExParams;
    ULONG i;

    if ((Status = g_pDbgControl->
         GetNumberEventFilters(&SpecEvents, &SpecEx, &ArbEx)) != S_OK)
    {
        return Status;
    }

    Empty();
    if ((SpecParams = (PDEBUG_SPECIFIC_FILTER_PARAMETERS)
         AddData((SpecEvents * sizeof(*SpecParams) +
                  (SpecEx + ArbEx) * sizeof(*ExParams)))) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ExParams = (PDEBUG_EXCEPTION_FILTER_PARAMETERS)(SpecParams + SpecEvents);
    
    if ((Status = g_pDbgControl->
         GetSpecificFilterParameters(0, SpecEvents, SpecParams)) != S_OK ||
        (Status = g_pDbgControl->
         GetExceptionFilterParameters(SpecEx + ArbEx, NULL, SpecEvents,
                                      ExParams)) != S_OK)
    {
        return Status;
    }

    ArgsOffset = m_DataUsed;

    for (i = 0; i < SpecEvents; i++)
    {
        if (SpecParams[i].ArgumentSize > 1)
        {
            PSTR Arg = (PSTR)AddData(SpecParams[i].ArgumentSize);
            if (Arg == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetSpecificFilterArgument(i, Arg, SpecParams[i].ArgumentSize,
                                           NULL)) != S_OK)
            {
                return Status;
            }
        }
    }
    
    CmdsOffset = m_DataUsed;

    for (i = 0; i < SpecEvents; i++)
    {
        if (SpecParams[i].CommandSize > 0)
        {
            PSTR Cmd = (PSTR)AddData(SpecParams[i].CommandSize);
            if (Cmd == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetEventFilterCommand(i, Cmd, SpecParams[i].CommandSize,
                                       NULL)) != S_OK)
            {
                return Status;
            }
        }
    }
    
    for (i = 0; i < SpecEx + ArbEx; i++)
    {
        if (ExParams[i].CommandSize > 0)
        {
            PSTR Cmd = (PSTR)AddData(ExParams[i].CommandSize);
            if (Cmd == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetEventFilterCommand(i + SpecEvents,
                                       Cmd, ExParams[i].CommandSize,
                                       NULL)) != S_OK)
            {
                return Status;
            }
        }

        if (ExParams[i].SecondCommandSize > 0)
        {
            PSTR Cmd = (PSTR)AddData(ExParams[i].SecondCommandSize);
            if (Cmd == NULL)
            {
                return E_OUTOFMEMORY;
            }

            if ((Status = g_pDbgControl->
                 GetExceptionFilterSecondCommand(i + SpecEvents,
                                                 Cmd,
                                                 ExParams[i].SecondCommandSize,
                                                 NULL)) != S_OK)
            {
                return Status;
            }
        }
    }
    
    WspCmdsOffset = m_DataUsed;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(FALSE)) != S_OK)
    {
        return Status;
    }

    // Get filter commands.
    Status = g_pOutCapControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                       DEBUG_OUTCTL_OVERRIDE_MASK |
                                       DEBUG_OUTCTL_NOT_LOGGED,
                                       ".sxcmds",
                                       DEBUG_EXECUTE_NOT_LOGGED |
                                       DEBUG_EXECUTE_NO_REPEAT);
    
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(FALSE);
    }
    else
    {
        g_OutStateBuf.End(FALSE);
    }

    if (Status == S_OK)
    {
        g_FilterArgsOffset = ArgsOffset;
        g_FilterCmdsOffset = CmdsOffset;
        g_FilterWspCmdsOffset = WspCmdsOffset;
        g_NumSpecEvents = SpecEvents;
        g_NumSpecEx = SpecEx;
        g_NumArbEx = ArbEx;
    }
    
    return Status;
}

class ModuleStateBuffer : public StateBuffer
{
public:
    ModuleStateBuffer(void) :
        StateBuffer(256)
    {
        m_enumType = MODULE_BIT;
        m_UpdateMessage = LB_RESETCONTENT;
    }

    virtual HRESULT ReadState(void);
};

ModuleStateBuffer g_PrivateModuleBuffer;
StateBuffer* g_ModuleBuffer = &g_PrivateModuleBuffer;
ULONG g_NumModules;

HRESULT
ModuleStateBuffer::ReadState(void)
{
    HRESULT Status;
    ULONG NumModules, Loaded, Unloaded;
    PDEBUG_MODULE_PARAMETERS Params;

    if ((Status = g_pDbgSymbols->GetNumberModules(&Loaded,
                                                  &Unloaded)) != S_OK)
    {
        return Status;
    }

    Empty();
    NumModules = Loaded + Unloaded;
    if (NumModules > 0)
    {
        if ((Params = (PDEBUG_MODULE_PARAMETERS)
             AddData(NumModules * sizeof(*Params))) == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if ((Status = g_pDbgSymbols->
             GetModuleParameters(NumModules, NULL, 0, Params)) != S_OK)
        {
            return Status;
        }
    }

    g_NumModules = NumModules;
    return S_OK;
}

void
ReadStateBuffers(void)
{
    // Fill event information first so other fills can
    // refer to it.
    if (g_EventBufferRequest != g_EventBufferDone)
    {
        FillEventBuffer();
    }

    g_BpBuffer->Update();
    g_BpCmdsBuffer->Update();
    g_FilterBuffer->Update();
    g_ModuleBuffer->Update();

    // No need to lock to sample the list head.
    StateBuffer* Buffer = (StateBuffer*)g_StateList.Flink;
    StateBuffer* BufferNext;

    while (Buffer != &g_StateList)
    {
        BufferNext = (StateBuffer*)Buffer->Flink;

        if (Buffer->m_Win == NULL)
        {
            // This window has been closed and can be cleaned up.
            Dbg_EnterCriticalSection(&g_QuickLock);
            RemoveEntryList(Buffer);
            Dbg_LeaveCriticalSection(&g_QuickLock);
            delete Buffer;
        }
        else
        {
            Buffer->Update();
        }

        Buffer = BufferNext;
    }
}

void
InvalidateStateBuffers(ULONG Types)
{
    // This routine can be called from both
    // the engine thread and the UI thread.
    // Care should be taken to make the code
    // here work in both threads.
    
    if (Types & (1 << EVENT_BIT))
    {
        InterlockedIncrement((PLONG)&g_EventBufferRequest);
    }
    if (Types & (1 << BP_BIT))
    {
        g_BpBuffer->RequestRead();
    }
    if (Types & (1 << BP_CMDS_BIT))
    {
        g_BpCmdsBuffer->RequestRead();
    }
    if (Types & (1 << FILTER_BIT))
    {
        g_FilterBuffer->RequestRead();
    }
    if (Types & (1 << MODULE_BIT))
    {
        g_ModuleBuffer->RequestRead();
    }

    // This routine must hold the list lock so that it
    // can traverse the list properly in the UI thread
    // when the engine thread might be deleting things.
    // The code in the lock should execute quickly to
    // avoid contention.

    Dbg_EnterCriticalSection(&g_QuickLock);
    
    StateBuffer* Buffer = (StateBuffer*)g_StateList.Flink;

    while (Buffer != &g_StateList)
    {
        if (Types & (1 << Buffer->m_enumType))
        {
            // Request a read but do not send an update to
            // the window.  The window will display the old
            // content until the buffer is updated.
            Buffer->RequestRead();
        }
        
        Buffer = (StateBuffer*)Buffer->Flink;
    }
    
    Dbg_LeaveCriticalSection(&g_QuickLock);
}

void
UpdateBufferWindows(ULONG Types, UpdateType Type)
{
    // This routine can be called from both
    // the engine thread and the UI thread.
    // Care should be taken to make the code
    // here work in both threads.
    
    // This routine must hold the list lock so that it
    // can traverse the list properly in the UI thread
    // when the engine thread might be deleting things.
    // The code in the lock should execute quickly to
    // avoid contention.

    Dbg_EnterCriticalSection(&g_QuickLock);
    
    StateBuffer* Buffer = (StateBuffer*)g_StateList.Flink;

    while (Buffer != &g_StateList)
    {
        if ((Types & (1 << Buffer->m_enumType)) &&
            Buffer->m_Win != NULL)
        {
            PostMessage(Buffer->m_Win, WU_UPDATE, Type, 0);
        }
        
        Buffer = (StateBuffer*)Buffer->Flink;
    }
    
    Dbg_LeaveCriticalSection(&g_QuickLock);
}

//----------------------------------------------------------------------------
//
// Static state buffers.
//
//----------------------------------------------------------------------------

class RegisterNamesStateBuffer : public StateBuffer
{
public:
    RegisterNamesStateBuffer(void)
        : StateBuffer(128)
    {
    }

    virtual HRESULT ReadState(void);
};

RegisterNamesStateBuffer g_PrivateRegisterNamesBuffer;
StateBuffer* g_RegisterNamesBuffer = &g_PrivateRegisterNamesBuffer;

HRESULT
RegisterNamesStateBuffer::ReadState(void)
{
    char Name[1024];
    DEBUG_REGISTER_DESCRIPTION Desc;
    ULONG i;
    HRESULT Hr;
    PSTR BufName;
    ULONG Len;

    Empty();
    for (i = 0; i < g_NumRegisters; i++)
    {
        if ((Hr = g_pDbgRegisters->GetDescription(i, Name, sizeof(Name),
                                                  NULL, &Desc)) != S_OK)
        {
            ErrorExit(g_pDbgClient,
                      "Debug target initialization failed, 0x%X\n", Hr);
        }

        Len = strlen(Name) + 1;
        BufName = (PSTR)AddData(Len);
        if (BufName == NULL)
        {
            ErrorExit(g_pDbgClient,
                      "Debug target initialization failed, 0x%X\n", Hr);
        }

        memcpy(BufName, Name, Len);
    }

    return S_OK;
}



class WatchWinStateBuffer : public StateBuffer
{
public:
    WatchWinStateBuffer(void)
        : StateBuffer(1024)
    {
    }

    virtual HRESULT ReadState(void);
};

WatchWinStateBuffer g_PrivateWatchWinBuffer;
StateBuffer* g_WatchWinBuffer = &g_PrivateWatchWinBuffer;
extern IDebugSymbolGroup * g_pDbgSymbolGroup;

HRESULT
WatchWinStateBuffer::ReadState(void)
{
    char Name[1024];
    ULONG i;
    HRESULT Hr;
    PSTR BufName;
    ULONG Count;

    Empty();

//    g_pDbgSymbolGroup->GetSymbolParameters(0, 10, &SymParams[0]);
//    g_pDbgSymbolGroup->OutputSymbols(0, 0, 0, 10);

    return S_OK;
}

PUSHORT g_RegisterMap;
ULONG g_RegisterMapEntries;

void
GetRegisterMapText(HWND Edit)
{
    ULONG i;
    PSTR Name;
    CHARRANGE Range;
    
    AssertStateBufferLocked(g_RegisterNamesBuffer);

    Range.cpMin = 0;
    Range.cpMax = INT_MAX;
    SendMessage(Edit, EM_EXSETSEL, 0, (LPARAM)&Range);
    
    for (i = 0; i < g_NumRegisters; i++)
    {
        ULONG MapIndex = MAP_REGISTER(i);
            
        Name = (PSTR)g_RegisterNamesBuffer->GetDataBuffer();
        while (MapIndex-- > 0)
        {
            Name += strlen(Name) + 1;
        }

        if (i > 0)
        {
            SendMessage(Edit, EM_REPLACESEL, 0, (LPARAM)" ");
        }
        SendMessage(Edit, EM_REPLACESEL, 0, (LPARAM)Name);
    }
}

void
ScanRegisterMapText(HWND Edit)
{
    PSTR Text, TextBuffer;
    PULONG Used, UsedBuffer;
    ULONG i;
    
    AssertStateBufferLocked(g_RegisterNamesBuffer);

    //
    // Allocate a buffer for the control text
    // and a new register map.
    //
    
    i = (ULONG)SendMessage(Edit, WM_GETTEXTLENGTH, 0, 0) + 1;
    TextBuffer = new CHAR[i];
    if (TextBuffer == NULL)
    {
        return;
    }
    Text = TextBuffer;
    
    UsedBuffer = new ULONG[g_NumRegisters];
    if (UsedBuffer == NULL)
    {
        delete TextBuffer;
        return;
    }
    Used = UsedBuffer;
        
    // Map may need to change size.
    delete g_RegisterMap;

    g_RegisterMap = new USHORT[g_NumRegisters];
    if (g_RegisterMap == NULL)
    {
        delete TextBuffer;
        delete UsedBuffer;
        return;
    }
    g_RegisterMapEntries = g_NumRegisters;

    ZeroMemory(Used, g_NumRegisters * sizeof(Used[0]));
    
    //
    // Retrieve the text and scan it for register names.
    //
    
    GetWindowText(Edit, Text, i);
    Text[i - 1] = 0;

    PSTR Name;
    BOOL End;
    PUSHORT Map;
    PUSHORT Check;
    PSTR Reg;

    Map = g_RegisterMap;
    for (;;)
    {
        while (isspace(*Text))
        {
            Text++;
        }

        if (*Text == 0)
        {
            break;
        }

        // Collect name.
        Name = Text;
        while (*Text && !isspace(*Text))
        {
            Text++;
        }

        End = *Text == 0;
        *Text = 0;

        // Check against known registers.
        Reg = (PSTR)g_RegisterNamesBuffer->GetDataBuffer();
        for (i = 0; i < g_NumRegisters; i++)
        {
            if (!Used[i] && !_strcmpi(Name, Reg))
            {
                Used[i] = TRUE;
                *Map++ = (USHORT)i;
                break;
            }

            Reg += strlen(Reg) + 1;
        }
        
        if (End)
        {
            break;
        }

        Text++;
    }

    //
    // Fill out any remaining map entries with registers
    // which aren't in the map so far.
    //
    
    PUSHORT MapEnd = g_RegisterMap + g_RegisterMapEntries;
    
    i = 0;
    while (Map < MapEnd)
    {
        while (Used[i])
        {
            i++;
        }
        Assert(i < g_NumRegisters);

        *Map++ = (USHORT)(i++);
    }
    
    delete TextBuffer;
    delete UsedBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\prcmain.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    prcmain.cpp

Abstract:

    Contains the main window proc.

--*/

#include "precomp.hxx"
#pragma hdrstop

#define TOOLBAR_UPDATE_TIMER_ID 0x100

#define WINDBG_START_DLG_FLAGS (OFN_HIDEREADONLY |      \
                                OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST)

// Path of the last files opened from a file open dlg box.
TCHAR g_ExeFilePath[_MAX_PATH];
TCHAR g_DumpFilePath[_MAX_PATH];
TCHAR g_SrcFilePath[_MAX_PATH];

BOOL g_fCheckFileDate;

// Last menu id & id state.
UINT g_LastMenuId;
UINT g_LastMenuIdState;

ULONG g_LastMapLetter;

void
ShowMapDlg(void)
{
    CONNECTDLGSTRUCT ConnDlg;
    NETRESOURCE NetRes;

    ZeroMemory(&NetRes, sizeof(NetRes));
    NetRes.dwType = RESOURCETYPE_DISK;
    ConnDlg.cbStructure = sizeof(ConnDlg);
    ConnDlg.hwndOwner = g_hwndFrame;
    ConnDlg.lpConnRes = &NetRes;
    ConnDlg.dwFlags = CONNDLG_USE_MRU;
    if (WNetConnectionDialog1(&ConnDlg) == NO_ERROR)
    {
        g_LastMapLetter = ConnDlg.dwDevNum;
    }
}

void
ShowDisconnDlg(void)
{
    WNetDisconnectDialog(g_hwndFrame, RESOURCETYPE_DISK);
}

void
SaveFileOpenPath(PTSTR Path, PTSTR Global, ULONG WspIndex)
{
    TCHAR Drive[_MAX_DRIVE];
    TCHAR Dir[_MAX_DIR];
    TCHAR NewPath[_MAX_PATH];

    _tsplitpath(Path, Drive, Dir, NULL, NULL);
    _tmakepath(NewPath, Drive, Dir, NULL, NULL);
    if (_strcmpi(NewPath, Global) != 0)
    {
        _tcscpy(Global, NewPath);
        if (g_Workspace != NULL)
        {
            g_Workspace->SetString(WspIndex, Global);
        }
    }
}

/***    MainWndProc
**
**  Synopsis:
**
**  Entry:
**
**  Returns:
**
**  Description:
**  Processes window messages.
**
*/


LRESULT
CALLBACK
MainWndProc(
    HWND  hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static UINT s_MenuItemSelected;

    HWND CommonWin;
    PCOMMONWIN_DATA CommonWinData;
    HRESULT Status;
    ULONG OutMask;

    if (message == g_FindMsgString)
    {
        FINDREPLACE* FindRep = (FINDREPLACE*)lParam;

        if (g_FindLast != NULL)
        {
            // Clear old find.
            g_FindLast->Find(NULL, 0);
            g_FindLast = NULL;
        }
        
        if (FindRep->Flags & FR_DIALOGTERM)
        {
            // Dialog has closed.
            g_FindDialog = NULL;
        }
        else
        {
            CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
            if (CommonWin != NULL &&
                (CommonWinData = GetCommonWinData(CommonWin)) != NULL)
            {
                CommonWinData->Find(FindRep->lpstrFindWhat,
                                    (FindRep->Flags & (FR_DOWN | FR_MATCHCASE |
                                                       FR_WHOLEWORD)));
                g_FindLast = CommonWinData;
            }
        }

        return 0;
    }
    
    switch (message)
    {
    case WM_CREATE:
        {
            CLIENTCREATESTRUCT ccs;
            TCHAR szClass[MAX_MSG_TXT];

            // Find window menu where children will be listed.
            ccs.hWindowMenu = GetSubMenu(GetMenu(hwnd), WINDOWMENU);
            ccs.idFirstChild = IDM_FIRSTCHILD;

            // Create the MDI client filling the client area.
            g_hwndMDIClient = CreateWindow(_T("mdiclient"),
                                           NULL,
                                           WS_CHILD | WS_CLIPCHILDREN,
                                           0, 0, 0, 0,
                                           hwnd, 
                                           (HMENU) 0xCAC, 
                                           g_hInst, 
                                           (PTSTR)&ccs
                                           );
            if (g_hwndMDIClient == NULL)
            {
                return -1;
            }

            //
            // Nothing interesting, here, just
            // trying to turn the Toolbar & Status bar into a
            // black box, so that the variables, etc. aren't
            // scattered all over the place.
            //

            if (!CreateToolbar(hwnd))
            {
                return -1;
            }

            if (!CreateStatusBar(hwnd))
            {
                return -1;
            }

            ShowWindow(g_hwndMDIClient, SW_SHOW);
            InitializeMenu(GetMenu(hwnd));

            g_hmenuMain = GetMenu(hwnd);
            if (g_hmenuMain == NULL)
            {
                return -1;
            }

            //
            // Create a one second timer to constantly update the state of the toolbar
            //
            SetTimer(hwnd, TOOLBAR_UPDATE_TIMER_ID, 1000, NULL);
        }
        break;

    case WM_TIMER:
        EnableToolbarControls();
        return 0;

    case WM_NOTIFY:
        {
            if (lParam == 0)
            {
                break;
            }
            
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;

            switch (lpnmhdr->code)
            {
            case TTN_NEEDTEXT:
                {
                    LPTOOLTIPTEXT lpToolTipText = (LPTOOLTIPTEXT) lParam;

                    lpToolTipText->lpszText = GetToolTipTextFor_Toolbar
                        ((UINT) lpToolTipText->hdr.idFrom);
                }
                break;
            }
        }
        break;

    case WM_QUERYOPEN:
        if (g_fCheckFileDate)
        {
            g_fCheckFileDate = FALSE;
            PostMessage(g_hwndFrame, WM_ACTIVATEAPP, 1, 0L);
        }
        goto DefProcessing;

    case WM_COMMAND:
        {
            WORD wNotifyCode = HIWORD(wParam); // notification code
            WORD wItemId = LOWORD(wParam);     // item, control, or
                                               // accelerator identifier
            HWND hwndCtl = (HWND) lParam;      // handle of control

            switch (wItemId)
            {
            case IDM_FILE_OPEN_EXECUTABLE:
                {
                    PTSTR  Path;
                    DWORD  Flags = WINDBG_START_DLG_FLAGS;

                    Path = (PTSTR)malloc(_MAX_PATH * 4 * sizeof(TCHAR));
                    if (Path == NULL)
                    {
                        break;
                    }
                    
                    *Path = 0;
                    
                    if (StartFileDlg(hwnd,
                                     DLG_Browse_Executable_Title,
                                     DEF_Ext_EXE,
                                     IDM_FILE_OPEN,
                                     IDD_DLG_FILEOPEN_EXPLORER_EXTENSION_EXE_ARGS,
                                     g_ExeFilePath,
                                     Path,
                                     &Flags,
                                     OpenExeWithArgsHookProc) &&
                        *Path)
                    {
                        _tcscat(Path, szOpenExeArgs);

                        SetAllocString(&g_DebugCommandLine, Path);
                        if (g_ExplicitWorkspace && g_Workspace != NULL)
                        {
                            g_Workspace->
                                SetUlong(WSP_GLOBAL_EXE_CREATE_FLAGS,
                                         g_DebugCreateFlags);
                            g_Workspace->
                                SetString(WSP_GLOBAL_EXE_COMMAND_LINE,
                                          Path);
                        }
                        SaveFileOpenPath(Path, g_ExeFilePath,
                                         WSP_GLOBAL_EXE_FILE_PATH);
                        StartDebugging();
                    }

                    if (g_DebugCommandLine != Path)
                    {
                        free(Path);
                    }
                }
                break;

            case IDM_FILE_ATTACH:
                StartDialog(IDD_DLG_ATTACH_PROCESS, DlgProc_AttachProcess,
                            NULL);
                break;

            case IDM_FILE_OPEN_CRASH_DUMP:
                {
                    PTSTR  Path;
                    DWORD  Flags = WINDBG_START_DLG_FLAGS;

                    Path = (PTSTR)malloc(_MAX_PATH * sizeof(TCHAR));
                    if (Path == NULL)
                    {
                        break;
                    }
                    
                    Dbg(LoadString(g_hInst, DEF_Dump_File,
                                   Path, _MAX_PATH));

                    if (StartFileDlg(hwnd,
                                     DLG_Browse_CrashDump_Title,
                                     DEF_Ext_DUMP,
                                     0,
                                     0,
                                     g_DumpFilePath,
                                     Path,
                                     &Flags,
                                     NULL))
                    {
                        SetAllocString(&g_DumpFile, Path);
                        if (g_ExplicitWorkspace && g_Workspace != NULL)
                        {
                            g_Workspace->
                                SetString(WSP_GLOBAL_DUMP_FILE_NAME,
                                          Path);
                        }
                        SaveFileOpenPath(Path, g_DumpFilePath,
                                         WSP_GLOBAL_DUMP_FILE_PATH);
                        StartDebugging();
                    }

                    if (g_DumpFile != Path)
                    {
                        free(Path);
                    }
                }
                break;

            case IDM_FILE_CONNECT_TO_REMOTE:
                StartDialog(IDD_DLG_CONNECTTOREMOTE, DlgProc_ConnectToRemote,
                            NULL);
                break;

            case IDM_FILE_KERNEL_DEBUG:
                StartKdPropSheet();
                break;

            case IDM_FILE_SYMBOL_PATH:
                StartDialog(IDD_DLG_SYMBOLS, DlgProc_SymbolPath, NULL);
                break;

            case IDM_FILE_IMAGE_PATH:
                StartDialog(IDD_DLG_IMAGE_PATH, DlgProc_ImagePath, NULL);
                break;

            case IDM_FILE_SOURCE_PATH:
                StartDialog(IDD_DLG_SOURCE_PATH, DlgProc_SourcePath, NULL);
                break;

            case IDM_FILE_OPEN_WORKSPACE:
                StartDialog(IDD_DLG_WORKSPACE_IO, DlgProc_OpenWorkspace,
                            FALSE);
                break;
                
            case IDM_FILE_SAVE_WORKSPACE:
                // No prompt, because we know the user wants to save.
                if (g_Workspace != NULL)
                {
                    g_Workspace->Flush(TRUE, FALSE);
                }
                break;

            case IDM_FILE_SAVE_WORKSPACE_AS:
                if (g_Workspace != NULL)
                {
                    StartDialog(IDD_DLG_WORKSPACE_IO, DlgProc_SaveWorkspaceAs,
                                TRUE);
                }
                break;
                
            case IDM_FILE_CLEAR_WORKSPACE:
                StartDialog(IDD_DLG_CLEAR_WORKSPACE, DlgProc_ClearWorkspace,
                            NULL);
                break;

            case IDM_FILE_DELETE_WORKSPACES:
                StartDialog(IDD_DLG_DELETE_WORKSPACES,
                            DlgProc_DeleteWorkspaces, NULL);
                break;

            case IDM_FILE_MAP_NET_DRIVE:
                ShowMapDlg();
                break;
                    
            case IDM_FILE_DISCONN_NET_DRIVE:
                ShowDisconnDlg();
                break;
                    
            case IDM_FILE_MRU_FILE1:
            case IDM_FILE_MRU_FILE2:
            case IDM_FILE_MRU_FILE3:
            case IDM_FILE_MRU_FILE4:
            case IDM_FILE_MRU_FILE5:
            case IDM_FILE_MRU_FILE6:
            case IDM_FILE_MRU_FILE7:
            case IDM_FILE_MRU_FILE8:
            case IDM_FILE_MRU_FILE9:
            case IDM_FILE_MRU_FILE10:
            case IDM_FILE_MRU_FILE11:
            case IDM_FILE_MRU_FILE12:
            case IDM_FILE_MRU_FILE13:
            case IDM_FILE_MRU_FILE14:
            case IDM_FILE_MRU_FILE15:
            case IDM_FILE_MRU_FILE16:
            case IDM_FILE_OPEN:
                {
                    TCHAR Path[_MAX_PATH];

                    if (IDM_FILE_OPEN == wItemId)
                    {
                        DWORD dwFlags = WINDBG_START_DLG_FLAGS;

                        Path[0] = 0;

                        if (!StartFileDlg(hwnd, 
                                          DLG_Open_Filebox_Title, 
                                          DEF_Ext_SOURCE,
                                          IDM_FILE_OPEN, 
                                          0,
                                          g_SrcFilePath,
                                          Path, 
                                          &dwFlags, 
                                          DlgFile
                                          ))
                        {
                            // User canceled, bail out
                            break;
                        }
                    }
                    else
                    {
                        WORD wFileIdx = wItemId - IDM_FILE_MRU_FILE1;

                        // Sanity check
                        Assert(wFileIdx < MAX_MRU_FILES);

                        _tcscpy(Path, g_MruFiles[wFileIdx]->FileName);
                    }

                    OpenOrActivateFile(Path, NULL, -1, TRUE, TRUE);

                    SaveFileOpenPath(Path, g_SrcFilePath,
                                     WSP_GLOBAL_SRC_FILE_PATH);
                }
                break;

            case IDM_FILE_CLOSE:
                {
                    HWND hwndChild = MDIGetActive(g_hwndMDIClient, NULL);
                    if (hwndChild)
                    {
                        SendMessage(g_hwndMDIClient, WM_MDIDESTROY,
                                    (WPARAM)hwndChild, 0L);
                    }
                }
                break;

            case IDM_FILE_EXIT:
                PostMessage(hwnd, WM_CLOSE, 0, 0L);
                break;

            case IDM_EDIT_COPY:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (!CommonWin)
                {
                    return 0;
                }

                CommonWinData = GetCommonWinData(CommonWin);
                if (CommonWinData)
                {
                    CommonWinData->Copy();
                }
                break;

            case IDM_EDIT_PASTE:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (!CommonWin)
                {
                    return 0;
                }

                CommonWinData = GetCommonWinData(CommonWin);
                if (CommonWinData)
                {
                    CommonWinData->Paste();
                }
                break;

            case IDM_EDIT_CUT:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (!CommonWin)
                {
                    return 0;
                }

                CommonWinData = GetCommonWinData(CommonWin);
                if (CommonWinData)
                {
                    CommonWinData->Cut();
                }
                break;

            case IDM_EDIT_SELECT_ALL:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (CommonWin == NULL)
                {
                    return 0;
                }
                CommonWinData = GetCommonWinData(CommonWin);
                if (CommonWinData != NULL)
                {
                    CommonWinData->SelectAll();
                }
                break;

            case IDM_EDIT_ADD_TO_COMMAND_HISTORY:
                StartDialog(IDD_DLG_ADD_TO_COMMAND_HISTORY,
                            DlgProc_AddToCommandHistory, FALSE);
                break;
                
            case IDM_EDIT_CLEAR_COMMAND_HISTORY:
                ClearCmdWindow();
                break;
                
            case IDM_EDIT_FIND:
                // FindNext box may already be there.
                if (g_FindDialog != NULL)
                {
                    SetFocus(g_FindDialog);
                }
                else
                {
                    ZeroMemory(&g_FindRep, sizeof(g_FindRep));
                    g_FindRep.lStructSize = sizeof(g_FindRep);
                    g_FindRep.hwndOwner = g_hwndFrame;
                    g_FindRep.Flags = FR_DOWN;
                    g_FindRep.lpstrFindWhat = g_FindText;
                    g_FindRep.wFindWhatLen = sizeof(g_FindText);
                    g_FindDialog = FindText(&g_FindRep);
                }
                break;

            case IDM_EDIT_PROPERTIES:
                {
                    HWND hwndmdi = MDIGetActive(g_hwndMDIClient, NULL);
                    
                    if (hwndmdi) {
                        
                        MEMWIN_DATA * pMemWinData = GetMemWinData(hwndmdi);
                        Assert(pMemWinData);
                        
                        if ( pMemWinData->HasEditableProperties() ) {
                            if (pMemWinData->EditProperties()) {
                                pMemWinData->UiRequestRead();
                            }
                        }
                    }
                }
                break;

            case IDM_EDIT_GOTO_LINE:
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (CommonWin)
                {
                    CommonWinData = GetCommonWinData(CommonWin);
                    Assert(CommonWinData);
                    StartDialog(IDD_DLG_GOTO_LINE, DlgProc_GotoLine,
                                (LPARAM)CommonWinData);
                }
                break;

            case IDM_EDIT_GOTO_ADDRESS:
                StartDialog(IDD_DLG_GOTO_ADDRESS, DlgProc_GotoAddress, NULL);
                break;

            case IDM_VIEW_REGISTERS:
                New_OpenDebugWindow(CPU_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_WATCH:
                New_OpenDebugWindow(WATCH_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_LOCALS:
                New_OpenDebugWindow(LOCALS_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_DISASM:
                New_OpenDebugWindow(DISASM_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_COMMAND:
                New_OpenDebugWindow(CMD_WINDOW, FALSE, NTH_OPEN_ALWAYS); // Not user activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_MEMORY:
                New_OpenDebugWindow(MEM_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_CALLSTACK:
                New_OpenDebugWindow(CALLS_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_SCRATCH:
                New_OpenDebugWindow(SCRATCH_PAD_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_PROCESS_THREAD:
                New_OpenDebugWindow(PROCESS_THREAD_WINDOW, TRUE, NTH_OPEN_ALWAYS); // User activated
                EnableToolbarControls();
                break;

            case IDM_VIEW_TOGGLE_VERBOSE:
                g_pUiClient->GetOtherOutputMask(g_pDbgClient, &OutMask);
                OutMask ^= DEBUG_OUTPUT_VERBOSE;
                g_pUiClient->SetOtherOutputMask(g_pDbgClient, OutMask);
                g_pUiControl->SetLogMask(OutMask);
                CmdLogFmt("Verbose mode %s.\n",
                          (OutMask & DEBUG_OUTPUT_VERBOSE) ? "ON" : "OFF");
                CheckMenuItem(g_hmenuMain, 
                              IDM_VIEW_TOGGLE_VERBOSE,
                              (OutMask & DEBUG_OUTPUT_VERBOSE) ?
                              MF_CHECKED : MF_UNCHECKED);
                break;

            case IDM_VIEW_SHOW_VERSION:
                Status = g_pUiControl->
                    OutputVersionInformation(DEBUG_OUTCTL_AMBIENT);
                if (Status == HRESULT_FROM_WIN32(ERROR_BUSY))
                {
                    CmdLogFmt("Engine is busy, try again\n");
                }
                else if (Status != S_OK)
                {
                    CmdLogFmt("Unable to show version information, 0x%X\n",
                              Status);
                }
                break;

            case IDM_VIEW_TOOLBAR:
                {
                    BOOL bVisible = !IsWindowVisible(GetHwnd_Toolbar());

                    CheckMenuItem(g_hmenuMain, 
                                  IDM_VIEW_TOOLBAR,
                                  bVisible ? MF_CHECKED : MF_UNCHECKED
                                  );
                    Show_Toolbar(bVisible);
                    if (g_Workspace != NULL)
                    {
                        g_Workspace->SetUlong(WSP_GLOBAL_VIEW_TOOL_BAR,
                                              bVisible);
                    }
                }
                break;

            case IDM_VIEW_STATUS:
                {
                    BOOL bVisible = !IsWindowVisible(GetHwnd_StatusBar());
                    CheckMenuItem(g_hmenuMain, 
                                  IDM_VIEW_STATUS,
                                  bVisible ? MF_CHECKED : MF_UNCHECKED
                                  );
                    Show_StatusBar(bVisible);
                    if (g_Workspace != NULL)
                    {
                        g_Workspace->SetUlong(WSP_GLOBAL_VIEW_STATUS_BAR,
                                              bVisible);
                    }
                }
                break;

            case IDM_VIEW_FONT:
                SelectFont(hwnd, FONT_FIXED);
                break;

            case IDM_VIEW_OPTIONS:
                StartDialog(IDD_DLG_OPTIONS, DlgProc_Options, NULL);
                break;

            case IDM_DEBUG_RESTART:
                if (g_EngineThreadId)
                {
                    AddEnumCommand(UIC_RESTART);
                }
                else if (g_CommandLineStart == 1)
                {
                    ParseCommandLine(FALSE);
                }
                break;

            case IDM_DEBUG_EVENT_FILTERS:
                StartDialog(IDD_DLG_EVENT_FILTERS, DlgProc_EventFilters, NULL);
                break;

            case IDM_DEBUG_GO:
                CmdExecuteCmd(_T("g"), UIC_EXECUTE);
                break;

            case IDM_DEBUG_GO_HANDLED:
                CmdExecuteCmd(_T("gh"), UIC_EXECUTE);
                break;

            case IDM_DEBUG_GO_UNHANDLED:
                CmdExecuteCmd(_T("gn"), UIC_EXECUTE);
                break;

            case IDM_DEBUG_RUNTOCURSOR:
            {
                char CodeExpr[MAX_OFFSET_EXPR];
                
                CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                if (CommonWin != NULL &&
                    (CommonWinData = GetCommonWinData(CommonWin)) != NULL &&
                    (CommonWinData->CodeExprAtCaret(CodeExpr, NULL)))
                {
                    PrintStringCommand(UIC_EXECUTE, "g %s", CodeExpr);
                }
                break;
            }

            case IDM_DEBUG_STEPINTO:
                CmdExecuteCmd( _T("t"), UIC_EXECUTE );
                break;

            case IDM_DEBUG_STEPOVER:
                CmdExecuteCmd( _T("p"), UIC_EXECUTE );
                break;

            case IDM_DEBUG_STEPOUT:
                if (g_EventReturnAddr != DEBUG_INVALID_OFFSET)
                {
                    PrintStringCommand(UIC_EXECUTE,
                                       "g 0x%I64x", g_EventReturnAddr);
                }
                break;
                
            case IDM_DEBUG_BREAK:
                g_pUiControl->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
                break;

            case IDM_DEBUG_STOPDEBUGGING:
                StopDebugging(HIWORD(wParam) != 0xffff);
                break;

            case IDM_EDIT_TOGGLEBREAKPOINT:
            case IDM_EDIT_BREAKPOINTS:
                if ( !IS_TARGET_HALTED() )
                {
                    ErrorBox(NULL, 0, ERR_Cant_Modify_BP_While_Running);
                    break;
                }

                if (wItemId == IDM_EDIT_TOGGLEBREAKPOINT)
                {
                    // If a disassembly or source window is up
                    // try and toggle a breakpoint at the current
                    // line.
                    CommonWin = MDIGetActive(g_hwndMDIClient, NULL);
                    if (CommonWin != NULL &&
                        (CommonWinData =
                         GetCommonWinData(CommonWin)) != NULL)
                    {
                        if (CommonWinData->m_enumType == DISASM_WINDOW ||
                            CommonWinData->m_enumType == DOC_WINDOW ||
                            CommonWinData->m_enumType == CALLS_WINDOW)
                        {
                            CommonWinData->ToggleBpAtCaret();
                            break;
                        }
                    }
                }
                
                // menu got us here or we are not in a code window
                StartDialog(IDD_DLG_BREAKPOINTS, DlgProc_SetBreak, NULL);
                break;

            case IDM_EDIT_LOG_FILE:
                StartDialog(IDD_DLG_LOG_FILE, DlgProc_LogFile, NULL);
                break;

            case IDM_DEBUG_MODULES:
                StartDialog(IDD_DLG_MODULES, DlgProc_Modules, NULL);
                break;

            case IDM_WINDOW_TILE_HORZ:
            case IDM_WINDOW_TILE_VERT:
                SendMessage(g_hwndMDIClient, 
                            WM_MDITILE,
                            (IDM_WINDOW_TILE_HORZ == wItemId) ? MDITILE_HORIZONTAL : MDITILE_VERTICAL,
                            0L
                            );
                break;

            case IDM_WINDOW_CASCADE:
                SendMessage(g_hwndMDIClient, WM_MDICASCADE, 0, 0L);
                break;

            case IDM_WINDOW_ARRANGE_ICONS:
                SendMessage(g_hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
                break;

            case IDM_WINDOW_ARRANGE:
                Arrange();
                break;

            case IDM_WINDOW_AUTO_ARRANGE:
                g_WinOptions ^= WOPT_AUTO_ARRANGE;
                if (g_AutoArrangeWarningCount != 0xffffffff)
                {
                    g_AutoArrangeWarningCount = 0;
                }
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetUlong(WSP_GLOBAL_WINDOW_OPTIONS,
                                          g_WinOptions);
                }
                break;

            case IDM_WINDOW_ARRANGE_ALL:
                g_WinOptions ^= WOPT_ARRANGE_ALL;
                if (g_WinOptions & WOPT_AUTO_ARRANGE)
                {
                    Arrange();
                }
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetUlong(WSP_GLOBAL_WINDOW_OPTIONS,
                                          g_WinOptions);
                }
                break;

            case IDM_WINDOW_OVERLAY_SOURCE:
                g_WinOptions ^= WOPT_OVERLAY_SOURCE;
                UpdateSourceOverlay();
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetUlong(WSP_GLOBAL_WINDOW_OPTIONS,
                                          g_WinOptions);
                }
                break;

            case IDM_WINDOW_AUTO_DISASM:
                g_WinOptions ^= WOPT_AUTO_DISASM;
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetUlong(WSP_GLOBAL_WINDOW_OPTIONS,
                                          g_WinOptions);
                }
                break;

            case IDM_HELP_CONTENTS:
                // Display the table of contents
                OpenHelpTopic(HELP_TOPIC_TABLE_OF_CONTENTS);
                break;

            case IDM_HELP_INDEX:
                OpenHelpIndex("");
                break;

            case IDM_HELP_SEARCH:
                OpenHelpSearch("");
                break;

            case IDM_HELP_ABOUT:
                ShellAbout( hwnd, g_MainTitleText, NULL, NULL );
                break;

                //**************************************************
                // The following commands are not accessible via menus

            case IDM_DEBUG_SOURCE_MODE:
                SetSrcMode_StatusBar(!GetSrcMode_StatusBar());
                EnableToolbarControls();

                if (GetSrcMode_StatusBar())
                {
                    AddStringCommand(UIC_INVISIBLE_EXECUTE, "l+t");
                }
                else
                {
                    AddStringCommand(UIC_INVISIBLE_EXECUTE, "l-t");
                }
                break;

            case IDM_DEBUG_SOURCE_MODE_ON:
                SetSrcMode_StatusBar(TRUE);
                EnableToolbarControls();
                AddStringCommand(UIC_INVISIBLE_EXECUTE, "l+t");
                break;

            case IDM_DEBUG_SOURCE_MODE_OFF:
                SetSrcMode_StatusBar(FALSE);
                EnableToolbarControls();
                AddStringCommand(UIC_INVISIBLE_EXECUTE, "l-t");
                break;

            case IDM_KDEBUG_TOGGLE_BAUDRATE:
                //
                // This method is reentrant so we can call it directly
                //
                g_pUiClient->SetKernelConnectionOptions("cycle_speed");
                break;

            case IDM_KDEBUG_TOGGLE_DEBUG:
                g_pUiClient->GetOtherOutputMask(g_pDbgClient, &OutMask);
                OutMask ^= DEBUG_IOUTPUT_KD_PROTOCOL;
                g_pUiClient->SetOtherOutputMask(g_pDbgClient, OutMask);
                g_pUiControl->SetLogMask(OutMask);
                break;

            case IDM_KDEBUG_TOGGLE_INITBREAK:
                {
                    ULONG EngOptions;
                    LPSTR DebugAction;

                    //
                    // These methods are reentrant so we can call directly
                    //

                    //
                    // Toggle between the following possibilities-
                    //
                    // (0) no breakin
                    // (1) -b style (same as Control-C up the wire)
                    // (2) -d style (stop on first dll load).
                    //
                    // NB -b and -d could both be on the command line
                    // but become mutually exclusive via this method.
                    // (Maybe should be a single enum type).
                    //

                    g_pUiControl->GetEngineOptions(&EngOptions);
                    if (EngOptions & DEBUG_ENGOPT_INITIAL_BREAK)
                    {
                        //
                        // Was type 1, go to type 2.
                        //

                        EngOptions |= DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
                        EngOptions &= ~DEBUG_ENGOPT_INITIAL_BREAK;

                        DebugAction = "breakin on first symbol load";
                    }
                    else if (EngOptions & DEBUG_ENGOPT_INITIAL_MODULE_BREAK)
                    {
                        //
                        // Was type 2, go to type 0.
                        //

                        EngOptions &= ~DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
                        DebugAction = "NOT breakin";
                    }
                    else
                    {
                        //
                        // Was type 0, go to type 1.
                        //

                        EngOptions |= DEBUG_ENGOPT_INITIAL_BREAK;
                        DebugAction = "request initial breakpoint";
                    }
                    g_pUiControl->SetEngineOptions(EngOptions);
                    CmdLogFmt("Will %s at next boot.\n", DebugAction);
                }
                break;

            case IDM_KDEBUG_RECONNECT:
                //
                // This method is reentrant so we can call it directly
                //
                g_pUiClient->SetKernelConnectionOptions("resync");
                break;

            default:
                goto DefProcessing;
            }
        }
        break;

    case WM_INITMENU:
        // TOOLBAR handling - a menu item has been selected.
        // Catches keyboard menu selecting.
        if (GetWindowLong(hwnd, GWL_STYLE) & WS_ICONIC) {
            break;
        }

        InitializeMenu((HMENU)wParam);
        break;


    case WM_MENUSELECT:
        {
            WORD wMenuItem      = (UINT) LOWORD(wParam);    // menu item or submenu index
            WORD wFlags         = (UINT) HIWORD(wParam);    // menu flags
            HMENU hmenu         = (HMENU) lParam;           // handle of menu clicked

            g_LastMenuId = LOWORD(wParam);

            if (0xFFFF == wFlags && NULL == hmenu)
            {
                //
                // Menu is closed, clear the Status Bar.
                //

                s_MenuItemSelected = 0;
                SetMessageText_StatusBar(SYS_Clear);
            }
            else if ( wFlags & MF_POPUP )
            {
                //
                // Get the menu ID for the pop-up menu.
                //

                s_MenuItemSelected =
                    ((wMenuItem + 1) * IDM_BASE) | MENU_SIGNATURE;
            }
            else
            {
                //
                // Get the menu ID for the menu item.
                //

                s_MenuItemSelected = wMenuItem;
            }
        }
        break;

    case WM_ENTERIDLE:
        SetMessageText_StatusBar(s_MenuItemSelected);
        break;

    case WM_CLOSE:
        TerminateApplication(TRUE);
        break;

    case WM_DRAWITEM:
        switch (wParam)
        {
        case IDC_STATUS_BAR:
            OwnerDrawItem_StatusBar((LPDRAWITEMSTRUCT) lParam);
            return TRUE;
        }
        goto DefProcessing;

    case WM_DESTROY:
        TerminateStatusBar();
        PostQuitMessage(0);
        break;

    case WM_MOVE:
        // This is to let the edit window
        // set a position of IME conversion window
        if ( MDIGetActive(g_hwndMDIClient, NULL) )
        {
            SendMessage(MDIGetActive(g_hwndMDIClient, NULL), WM_MOVE, 0, 0);
        }

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        break;

    case WM_SIZE:
        {
            RECT rc;
            int nToolbarHeight = 0;   // Toolbar
            int nStatusHeight = 0;   // status bar
            int OldToolbarHeight = 0;

            if ( IsWindowVisible(GetHwnd_Toolbar()) )
            {
                GetWindowRect(GetHwnd_Toolbar(), &rc);
                OldToolbarHeight = rc.bottom - rc.top;
            }
            
            GetClientRect (hwnd, &rc);

            // First lets resize the toolbar
            SendMessage(GetHwnd_Toolbar(), WM_SIZE, wParam,
                MAKELPARAM(rc.right - rc.left, rc.bottom - rc.top));

            // 2nd resize the status bar
            WM_SIZE_StatusBar(wParam, MAKELPARAM(rc.right - rc.left, rc.bottom - rc.top));

            //On creation or resize, size the MDI client,
            //status line and toolbar.
            if ( IsWindowVisible(GetHwnd_StatusBar()) )
            {
                RECT rcStatusBar;

                GetWindowRect(GetHwnd_StatusBar(), &rcStatusBar);

                nStatusHeight = rcStatusBar.bottom - rcStatusBar.top;
            }

            if (IsWindowVisible(GetHwnd_Toolbar()))
            {
                RECT rcToolbar;

                GetWindowRect(GetHwnd_Toolbar(), &rcToolbar);

                nToolbarHeight = rcToolbar.bottom - rcToolbar.top;
            }

            g_MdiWidth = rc.right - rc.left;
            g_MdiHeight = rc.bottom - rc.top - nStatusHeight - nToolbarHeight;
            MoveWindow(g_hwndMDIClient,
                       rc.left, rc.top + nToolbarHeight,
                       g_MdiWidth, g_MdiHeight,
                       TRUE
                       );

            SendMessage(g_hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
            // This is to let the edit window
            // set a position of IME conversion window
            if ( MDIGetActive(g_hwndMDIClient, NULL) )
            {
                SendMessage(MDIGetActive(g_hwndMDIClient, NULL), WM_MOVE, 0, 0);
            }

            if (OldToolbarHeight != nToolbarHeight)
            {
                RedrawWindow(g_hwndMDIClient, NULL, NULL,
                             RDW_ERASE | RDW_INVALIDATE | RDW_FRAME |
                             RDW_UPDATENOW | RDW_ALLCHILDREN);
            }
        }

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        break;

    case WU_START_ENGINE:
        {
            //
            // Go start the debugger engine if the appropriate debugger
            // parameters were passed in
            //

            DWORD Id;
            
            // Start the engine thread.
            g_EngineThread = CreateThread(NULL, 0, EngineLoop, NULL, 0, &Id);
            if (g_EngineThread == NULL)
            {
                ErrorBox(NULL, 0, ERR_Engine_Failed);
                break;
            }
        }
        break;

    case WU_ENGINE_STARTED:
        if ((HRESULT)lParam == S_OK)
        {
            UpdateTitleSessionText();
            if (GetCmdHwnd() == NULL)
            {
                // If the engine is started, show the command window
                // by default
                New_OpenDebugWindow(CMD_WINDOW, FALSE, NTH_OPEN_ALWAYS);
            }
        }
        break;

    case WU_ENGINE_IDLE:
        if (g_InitialCommand != NULL)
        {
            CmdLogFmt("Processing initial command '%s'\n",
                      g_InitialCommand);
            CmdExecuteCmd(g_InitialCommand, UIC_EXECUTE);
            free(g_InitialCommand);
            g_InitialCommand = NULL;
        }
        break;

    case WU_SWITCH_WORKSPACE:
        UiDelayedSwitchWorkspace();
        break;

    case WU_UPDATE:
        // Global engine status has changed, such as
        // the current process and thread.  Update
        // global UI elements.
        SetPidTid_StatusBar(g_CurProcessId, g_CurProcessSysId,
                            g_CurThreadId, g_CurThreadSysId);
        if (wParam == UPDATE_BUFFER)
        {
            SetSrcMode_StatusBar(lParam == DEBUG_LEVEL_SOURCE);
        }
        else if (wParam == UPDATE_EXEC &&
                 GetProcessThreadHwnd())
        {
            GetProcessThreadWinData(GetProcessThreadHwnd())->
                OnUpdate(UPDATE_EXEC);
        }
        break;

DefProcessing:
    default:
        return DefFrameProc(hwnd, g_hwndMDIClient, message, wParam, lParam);
    }
    
    return (0L);
}

void
TerminateApplication(BOOL Cancellable)
{
    if (g_EngineThreadId != 0 &&
        (g_AttachProcessFlags & DEBUG_ATTACH_NONINVASIVE))
    {
        if (QuestionBox(STR_Abandoning_Noninvasive_Debuggee, MB_OKCANCEL) ==
            IDCANCEL)
        {
            return;
        }    
    }
    
    if (g_Workspace != NULL)
    {
        if (g_Workspace->Flush(FALSE, Cancellable) == S_FALSE)
        {
            // User cancelled things so don't terminate.
            return;
        }
    }

    // Destroy windows to get window cleanup behavior.
    // This must occur before g_Exit is set so that
    // the engine thread doesn't come around and kill things.
    DestroyWindow(g_hwndFrame);

    g_Exit = TRUE;

    ULONG Code;

    if (!g_RemoteClient && g_DebugCommandLine != NULL)
    {
        // Return exit code of last process to exit.
        Code = g_LastProcessExitCode;
    }
    else
    {
        Code = S_OK;
    }

    if (g_EngineThreadId != 0)
    {
        UpdateEngine();
        
        // If the engine thread is idle it'll exit and call
        // ExitDebugger.  The engine may be waiting and
        // not responsive, though, so only wait a little while before
        // bailing out.
        Sleep(1000);
        if (g_pUiClient != NULL)
        {
            g_pUiClient->EndSession(DEBUG_END_REENTRANT);
        }
        ExitProcess(Code);
    }
    else
    {
        ExitDebugger(g_pUiClient, Code);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\status.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    status.cpp

--*/


#include "precomp.hxx"
#pragma hdrstop



// Adjust the size as necessary.
// Obviously, if an assert that checks for mem overwrites goes off,
// don't remove the assert, increase the char array size.
//           |
//          \|/
#define MAX_TEMP_TXT 100



//Status Bar : Structure definition
typedef struct _STATUS
{
    HWND    hwndStatusBar;

    // The actual text to be displayed for each item
    PTSTR   rgszItemText[nMAX_IDX_STATUSBAR];

    // The line column text is in the following format: Ln 000, Col 000
    // Where "Ln" & "Col" are loaded from the resource and since they could be
    // language dependent. This is why we have to clutter the structure with
    // these 2 additional references.
    PTSTR   lpszLinePrefix;
    PTSTR   lpszColumnPrefix;

    // Prefix help the user figure out which is the process & thread displays
    // Proc 000:000
    // Thrd 000:000
    PTSTR   lpszProcessPrefix;
    PTSTR   lpszThreadPrefix;

    // Indicates whether the text should be grayed out when displayed.
    // TRUE - grayed out
    // FALSE - normal color
    BOOL    rgbGrayItemText[nMAX_IDX_STATUSBAR];

    // Indicates which ones are OWNER_DRAW. This is done
    //      so we can gray things out.
    // TRUE - Owner draw
    // FALSE - Normal, status bar takes care of the drawing.
    int     rgbOwnerDrawItem[nMAX_IDX_STATUSBAR];


    // TRUE - we are in src code mode
    // FALSE - we are in assembly mode
    BOOL    bSrcMode;

    BOOL    bOverType;                               // Overtype status
    BOOL    bCapsLock;                               // CapsLock status
    BOOL    bNumLock;                                // NumLock status
} STATUS, * LPSTATUS;

static STATUS status;


///////////////////////////////////////////////////////////
// protos
void RecalcItemWidths_StatusBar(void);
void Internal_SetItemText_StatusBar(nIDX_STATUSBAR_ITEMS nId, PTSTR lpszNewText);


///////////////////////////////////////////////////////////
// Init/term functions
//
BOOL
CreateStatusBar(HWND hwndParent)
/*++
Routine Description:
    Creates and initializes the status bar.

Arguments:
    hwndParent - Hwnd to the owner of the status bar
--*/
{
    TCHAR sz[MAX_MSG_TXT];

    status.hwndStatusBar = CreateStatusWindow(
        WS_CHILD | WS_BORDER
        | WS_VISIBLE | CCS_BOTTOM,  // style
        _T(""),                     // initial text
        hwndParent,                 // parent
        IDC_STATUS_BAR);            // id
    if (status.hwndStatusBar == NULL)
    {
        return FALSE;
    }

    //
    // We recalc the sizes even though we know they are 0, because,
    // the status bar needs to know how many parts there will be.
    //
    RecalcItemWidths_StatusBar();

    //
    // These are the owner draw items.
    //
    status.rgbOwnerDrawItem[nSRCASM_IDX_STATUSBAR] = TRUE;
    status.rgbOwnerDrawItem[nOVRTYPE_IDX_STATUSBAR] = TRUE;
    status.rgbOwnerDrawItem[nCAPSLCK_IDX_STATUSBAR] = TRUE;
    status.rgbOwnerDrawItem[nNUMLCK_IDX_STATUSBAR] = TRUE;

    //
    // Load the static stuff.
    //
    Dbg(LoadString(g_hInst, STS_MESSAGE_ASM, sz, _tsizeof(sz)));
    Internal_SetItemText_StatusBar(nSRCASM_IDX_STATUSBAR, sz);

    Dbg(LoadString(g_hInst, STS_MESSAGE_OVERTYPE, sz, _tsizeof(sz)));
    Internal_SetItemText_StatusBar(nOVRTYPE_IDX_STATUSBAR, sz);

    Dbg(LoadString(g_hInst, STS_MESSAGE_CAPSLOCK, sz, _tsizeof(sz)));
    Internal_SetItemText_StatusBar(nCAPSLCK_IDX_STATUSBAR, sz);

    Dbg(LoadString(g_hInst, STS_MESSAGE_NUMLOCK, sz, _tsizeof(sz)));
    Internal_SetItemText_StatusBar(nNUMLCK_IDX_STATUSBAR, sz);

    //
    // Preload prefixes
    //
    Dbg(LoadString(g_hInst, STS_MESSAGE_CURPROCID, sz, _tsizeof(sz)));
    status.lpszProcessPrefix = _tcsdup(sz);
    Dbg(status.lpszProcessPrefix);

    Dbg(LoadString(g_hInst, STS_MESSAGE_CURTHRDID, sz, _tsizeof(sz)));
    status.lpszThreadPrefix = _tcsdup(sz);
    Dbg(status.lpszThreadPrefix);

    Dbg(LoadString(g_hInst, STS_MESSAGE_LINE, sz, _tsizeof(sz)));
    status.lpszLinePrefix = _tcsdup(sz);
    Dbg(status.lpszLinePrefix);

    Dbg(LoadString(g_hInst, STS_MESSAGE_COLUMN, sz, _tsizeof(sz)));
    status.lpszColumnPrefix = _tcsdup(sz);
    Dbg(status.lpszColumnPrefix);

    SetLineColumn_StatusBar(0, 0);
    SetPidTid_StatusBar(0, 0, 0, 0);
    SetCapsLock_StatusBar(GetKeyState(VK_CAPITAL) & 0x0001);
    SetNumLock_StatusBar(GetKeyState(VK_NUMLOCK) & 0x0001);
    SetOverType_StatusBar(FALSE);

    return TRUE;
}


void
TerminateStatusBar()
/*++
Routine Description:
    Just frees allocated resources.
--*/
{
    int i;

    for (i = 0; i < nMAX_IDX_STATUSBAR -1; i++)
    {
        if (status.rgszItemText[i])
        {
            free(status.rgszItemText[i]);
            status.rgszItemText[i] = NULL;
        }
    }

    if (status.lpszLinePrefix)
    {
        free(status.lpszLinePrefix);
        status.lpszLinePrefix = NULL;
    }

    if (status.lpszColumnPrefix)
    {
        free(status.lpszColumnPrefix);
        status.lpszColumnPrefix = NULL;
    }

    if (status.lpszProcessPrefix)
    {
        free(status.lpszProcessPrefix);
        status.lpszProcessPrefix = NULL;
    }

    if (status.lpszThreadPrefix)
    {
        free(status.lpszThreadPrefix);
        status.lpszThreadPrefix = NULL;
    }
}



///////////////////////////////////////////////////////////
// Operations that affect the entire status bar.
//
void
Show_StatusBar(
               BOOL bShow
               )
/*++
Routine Description:
    Show/Hide the status bar. Automatically resizes/updates the MDI client.

Arguments:
    bShow -     TRUE - Show status bar
                FALSE - Hide status bar
--*/
{
    RECT rect;

    // Show/Hide the toolbar
    ShowWindow(status.hwndStatusBar, bShow ? SW_SHOW : SW_HIDE);

    //Ask the frame to resize, so that everything will be correctly positioned.
    GetWindowRect(g_hwndFrame, &rect);

    SendMessage(g_hwndFrame, WM_SIZE, SIZE_RESTORED,
        MAKELPARAM(rect.right - rect.left, rect.bottom - rect.top));

    // Ask the MDIClient to redraw itself and its children.
    // This is  done in order to fix a redraw problem where some of the
    // MDIChild window are not correctly redrawn.
    Dbg(RedrawWindow(g_hwndMDIClient, NULL, NULL,
        RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_INVALIDATE | RDW_FRAME));
}                                       // UpdateToolbar()


void
WM_SIZE_StatusBar(
                  WPARAM wParam,
                  LPARAM lParam
                  )
/*++
Routine Description:
    Causes the status bar to be resized. This function is meant to be
    called from the parent window, whenever a parent window receives a
    WM_SIZE message, ie:

    // parent window proc
    switch (uMsg) {
    case WM_SIZE:
        WM_SIZE_StatusBar(wParam, lParam);
        return TRUE;
        ...
        ...
        ...
    }

Arguments:
    wParam & lParam - See docs for a desciption of the WM_SIZE message.

--*/
{
    // make the status bar resize.
    SendMessage(status.hwndStatusBar, WM_SIZE, wParam, lParam);

    // Since it was resized, the widths the text items need to be recalculated.
    // The is because  of the way that status bar positions the elements on the
    // screen. See the docs for SB_SETPARTS, for more detail. The SB_SETPARTS
    // docs will enlighten you.
    RecalcItemWidths_StatusBar();
}


HWND
GetHwnd_StatusBar()
// I'm not documenting this function, everyone can figure this one out.
{
    return status.hwndStatusBar;
}



///////////////////////////////////////////////////////////
// Main text display functions
//
void
RecalcItemWidths_StatusBar(void)
/*++
Routine description:
    The function will recalculate the width of the text items.
    The calculations don't have to be exact. Status bar is very
    forgiving and pretty much needs a rough estimate.
--*/
{
    int rgnItemWidths[nMAX_IDX_STATUSBAR];
    int i, nWidth;
    HDC hdc;

    hdc = GetDC(status.hwndStatusBar);
    Dbg(hdc);

    // Get the width of the status bar's client area.
    {
        RECT rcClient;
        GetClientRect(status.hwndStatusBar, &rcClient);
        nWidth = rcClient.right;
    }

    // Calculate the right edge coordinate for each part, and
    // copy the coordinates to the array.
    for (i = nMAX_IDX_STATUSBAR -1; i >= 0; i--) {

        rgnItemWidths[i] = nWidth;

        if (NULL == status.rgszItemText[i]) {
            // We don't have any text, but we need a position anyways.
            nWidth -= 10; // Just any old number
        } else {
            PTSTR lpsz = status.rgszItemText[i];
            SIZE size;

            // Skip over tabs.
            // 1 tab is centered, 2 is right aligned.
            // See status bar docs for more info.
            if (_T('\t') == *lpsz) {
                lpsz++;
                if (_T('\t') == *lpsz) {
                    lpsz++;
                }
            }

            Dbg(GetTextExtentPoint32(hdc, lpsz, _tcslen(lpsz), &size));

            nWidth -= size.cx;
        }
    }

    Dbg(ReleaseDC(status.hwndStatusBar, hdc));

    // Tell the status window to create the window parts.
    Dbg(SendMessage(status.hwndStatusBar, SB_SETPARTS,
        (WPARAM) nMAX_IDX_STATUSBAR, (LPARAM) rgnItemWidths));

    // The status bar invalidates the parts that changed. So it is
    // automatically updated.
}


void
Internal_SetItemText_StatusBar(
                    nIDX_STATUSBAR_ITEMS nId,
                    PTSTR lpszNewText
                    )
/*++
Routine Description:
    Set the text for a specified item.
--*/
{
    // Leave these sanity checks in here.
    // If they go off, someone did something wrong
    // or changed some important code
    Dbg((0 <= nId));
    Dbg((nId < nMAX_IDX_STATUSBAR));
    Dbg((lpszNewText));

    // Free any previous text
    if (status.rgszItemText[nId]) {
        free(status.rgszItemText[nId]);
    }

    // duplicate the text
    status.rgszItemText[nId] = _tcsdup(lpszNewText);

    // Make sure it was allocated
    Assert(status.rgszItemText[nId]);

    // Do we have any text to set?
    if (status.rgszItemText[nId]) {
        int nFormat = nId;

        // Make it owner draw???
        if (status.rgbOwnerDrawItem[nId]) {
            nFormat |= SBT_OWNERDRAW;
        }

        // Set the text
        Dbg(SendMessage(status.hwndStatusBar, SB_SETTEXT,
            (WPARAM) nFormat, (LPARAM) status.rgszItemText[nId]));
    }
}


void
InvalidateItem_Statusbar(nIDX_STATUSBAR_ITEMS nIdx)
/*++
Routine description:
    Invalidates the item's rect on the status bar, so that an update
    to that region will take place.

Arguments:
    nIdx - The status bar item that is to be updated.
--*/
{
    RECT rc;

    Dbg((0 <= nIdx));
    Dbg((nIdx < nMAX_IDX_STATUSBAR));

    SendMessage(status.hwndStatusBar, SB_GETRECT,
        (WPARAM) nIdx, (LPARAM) &rc);

    InvalidateRect(status.hwndStatusBar, &rc, FALSE);
}


void
OwnerDrawItem_StatusBar(
                        LPDRAWITEMSTRUCT lpDrawItem
                        )
/*++
Routine Description:
    Called from the parent window for owner draw text items.
    Draws an actual status bar item onto the status bar.
    Depending the the flags set, it will draw the item grayed out.

Arguments:
    See docs for WM_DRAWITEM, and Status bar -> owner draw items.
--*/
{
    PTSTR lpszItemText = (PTSTR) lpDrawItem->itemData;
    COLORREF crefOldTextColor = CLR_INVALID;
    COLORREF crefOldBkColor = CLR_INVALID;

    if (NULL == lpszItemText) {
        // nothing to do
        return;
    }

    // Set background color and save the old color.
    crefOldBkColor = SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_3DFACE));
    Assert(CLR_INVALID != crefOldBkColor);

    // should the item be grayed out?
    if (status.rgbGrayItemText[lpDrawItem->itemID]) {
        crefOldTextColor = SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_GRAYTEXT));
        Assert(CLR_INVALID != crefOldTextColor);
    }

    // draw the color coded text to the screen
    {
        UINT uFormat = DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE;

        // "\t" is used to center
        // '\t\t" is used to right align.
        // No, I did not make this up, this is the way the status bar works.
        if (_T('\t') == *lpszItemText) {
            lpszItemText++;
            if (_T('\t') == *lpszItemText) {
                // 2 tabs found
                lpszItemText++;
                uFormat |= DT_RIGHT;
            } else {
                // 1 tab found
                uFormat |= DT_CENTER;
            }
        }
        DrawText(lpDrawItem->hDC, lpszItemText, _tcslen(lpszItemText),
            &lpDrawItem->rcItem, uFormat);
    }

    // Reset the the hDC back to its old state.
    if (CLR_INVALID != crefOldTextColor) {
        Dbg((CLR_INVALID != SetTextColor(lpDrawItem->hDC, crefOldTextColor)));
    }

    if (CLR_INVALID != crefOldBkColor) {
        Dbg((CLR_INVALID != SetBkColor(lpDrawItem->hDC, crefOldBkColor)));
    }
}


void
SetItemText_StatusBar(
                    nIDX_STATUSBAR_ITEMS nId,
                    PTSTR lpszNewText
                    )
/*++
Routine Description:

Arguments:
    nId         -
    lpszNewText
--*/
{
    Internal_SetItemText_StatusBar(nId, lpszNewText);
    // If nId is 0, the we don't have to recalc the widths, because this
    // is the only one that doesn't affect the rest.
    if (nId > 0) {
        RecalcItemWidths_StatusBar();
    }
}



///////////////////////////////////////////////////////////
// Set/get specialized items on the status bar.
//
// All of the Get????_StatusBar retrieve the current value.
//
// All of the Set????_StatusBar set the new value and return the
//   previous value.
//      TRUE - Item is enabled.
//      FALSE - Item is disabled.

//
// Src/Asm mode
BOOL
GetSrcMode_StatusBar()
{
    return status.bSrcMode;
}

BOOL
SetSrcMode_StatusBar(
                     BOOL bNewValue
                     )
{
    BOOL b = status.bSrcMode;

    status.bSrcMode = bNewValue;
    status.rgbGrayItemText[nSRCASM_IDX_STATUSBAR] = bNewValue;

    InvalidateItem_Statusbar(nSRCASM_IDX_STATUSBAR);

    // Reflect the change to the menu
    InitializeMenu(GetMenu(g_hwndFrame));

    /*
    // Old code that was move in here.
    if ( (FALSE == bNewValue) && (NULL == GetDisasmHwnd()) ) {
        OpenDebugWindow(DISASM_WINDOW, TRUE); // User activated
    }
    */

    return b;
}


//
// Insert/Overtype mode
BOOL
GetOverType_StatusBar()
{
    return status.bOverType;
}


BOOL
SetOverType_StatusBar(BOOL bNewValue)
{
    BOOL b = status.bOverType;

    status.bOverType = bNewValue;
    status.rgbGrayItemText[nOVRTYPE_IDX_STATUSBAR] = !bNewValue;

    InvalidateItem_Statusbar(nOVRTYPE_IDX_STATUSBAR);

    return b;
}


//
// Num lock mode
BOOL
GetNumLock_StatusBar()
{
    return status.bNumLock;
}

BOOL
SetNumLock_StatusBar(BOOL bNewValue)
{
    BOOL b = status.bNumLock;

    status.bNumLock = bNewValue;
    status.rgbGrayItemText[nNUMLCK_IDX_STATUSBAR] = !bNewValue;

    InvalidateItem_Statusbar(nNUMLCK_IDX_STATUSBAR);

    return b;
}


//
// Caps mode
BOOL
GetCapsLock_StatusBar()
{
    return status.bCapsLock;
}

BOOL
SetCapsLock_StatusBar(BOOL bNewValue)
{
    BOOL b = status.bCapsLock;

    status.bCapsLock = bNewValue;
    status.rgbGrayItemText[nCAPSLCK_IDX_STATUSBAR] = !bNewValue;

    InvalidateItem_Statusbar(nCAPSLCK_IDX_STATUSBAR);

    return b;
}


///////////////////////////////////////////////////////////
// Specialized text display functions

void
SetMessageText_StatusBar(UINT StringId)
{
    TCHAR Str[MAX_TEMP_TXT];

    // load format string from resource file
    if (LoadString(g_hInst, StringId, Str, sizeof(Str)) == 0)
    {
        Str[0] = 0;
    }
    SetItemText_StatusBar(nMESSAGE_IDX_STATUSBAR, Str);
}

void
SetLineColumn_StatusBar(
                        int nNewLine,
                        int nNewColumn
                        )
/*++
Routine Description:
    Used to display the line and column values in text edit controls.
    Loads the prefixs "Ln" & "Col" from the string resource section.

Arguments:
    nNewLine - Line number in edit controls.
    nNewColumn - Column number in edit controls.
--*/
{
    TCHAR sz[MAX_TEMP_TXT];

    _stprintf(sz, _T("%s %d, %s %d"), status.lpszLinePrefix, nNewLine,
        status.lpszColumnPrefix, nNewColumn);

    Dbg((_tcslen(sz) < _tsizeof(sz)));

    SetItemText_StatusBar(nSRCLIN_IDX_STATUSBAR, sz);
}


void
SetPidTid_StatusBar(
    ULONG ProcessId,
    ULONG ProcessSysId,
    ULONG ThreadId,
    ULONG ThreadSysId
    )
/*++

Routine Description:

    Display the Process ID and Task ID in the status bar.

    Display format:

        Internal Process number:OS Process ID           Internal Task number:OS Task ID
        000:000                                         000:000

    If the OS ID is greater than 3 digits, then it is displayed in hex
        000:0xFFFFFFFF                                  000:0xFFFFFFFF

--*/
{
    TCHAR sz[MAX_TEMP_TXT];

    _stprintf(sz, _T("%s %03d:%x"), status.lpszProcessPrefix,
              ProcessId, ProcessSysId);

    // Sanity check, should never occur.
    // Mem overwrite?
    Assert(_tcslen(sz) < _tsizeof(sz));

    SetItemText_StatusBar(nPROCID_IDX_STATUSBAR, sz);

    _stprintf(sz, _T("%s %03d:%x"), status.lpszThreadPrefix,
              ThreadId, ThreadSysId);

    // Sanity check, should never occur.
    // Mem overwrite?
    Assert(_tcslen(sz) < _tsizeof(sz));

    SetItemText_StatusBar(nTHRDID_IDX_STATUSBAR, sz);
}



///////////////////////////////////////////////////////////
// Misc helper routines
//
/****************************************************************************

         FUNCTION: KeyboardHook

         PURPOSE: Check if keyboard hit is NUMLOCK, CAPSLOCK or INSERT

****************************************************************************/
LRESULT
KeyboardHook( 
    int iCode, 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    if (iCode == HC_ACTION) {
        if (wParam == VK_NUMLOCK
            && HIWORD(lParam) & 0x8000 // Key up
            && GetKeyState(VK_CONTROL) >= 0) { //No Ctrl

            // CAPSLOCK has been hit, refresh status
            SetNumLock_StatusBar(GetKeyState(VK_NUMLOCK) & 0x0001);

        } else if (wParam == VK_CAPITAL
            && HIWORD(lParam) & 0x8000 //Key up
            && GetKeyState(VK_CONTROL) >= 0) { //No Ctrl

            // CAPSLOCK has been hit, refresh status
            SetCapsLock_StatusBar(GetKeyState(VK_CAPITAL) & 0x0001);

        } else if (wParam == VK_INSERT
            && ((HIWORD(lParam) & 0xE000) == 0x0000) //Key down was up before and No Alt
            && GetKeyState(VK_SHIFT) >= 0   //No Shift
            && GetKeyState(VK_CONTROL) >= 0) { //No Ctrl

            // INSERT has been hit and refresh status if so
            // We can't use the up down state, since there is no indicator light
            // as a referene to the user. We simple have to toggle it.
            SetOverType_StatusBar(!GetOverType_StatusBar());
        }
    }

    return CallNextHookEx( hKeyHook, iCode, wParam, lParam );
}                                       /* KeyboardHook() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\statebuf.h ===
//----------------------------------------------------------------------------
//
// Debuggee state buffers.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef __STATEBUF_H__
#define __STATEBUF_H__

// Different WU_UPDATE qualifiers, sent in WPARAM.
enum UpdateType
{
    UPDATE_BUFFER,
    UPDATE_BP,
    UPDATE_EXEC,
    UPDATE_INPUT_REQUIRED,
    UPDATE_START_SESSION,
    UPDATE_END_SESSION,
    UPDATE_PROMPT_TEXT,
    UPDATE_EXIT
};

typedef enum
{
    MINVAL_WINDOW = 0,
    DOC_WINDOW,
    WATCH_WINDOW,
    LOCALS_WINDOW,
    CPU_WINDOW,
    DISASM_WINDOW,
    CMD_WINDOW,
    SCRATCH_PAD_WINDOW,
    MEM_WINDOW,
    QUICKW_WINDOW,
    CALLS_WINDOW,
    PROCESS_THREAD_WINDOW,
    MAXVAL_WINDOW,
    // Artificial values so there are well-defined bit
    // positions for state which is not tied to a specific window.
    EVENT_BIT,
    BP_BIT,
    BP_CMDS_BIT,
    FILTER_BIT,
    MODULE_BIT
} WIN_TYPES, * PWIN_TYPES;

#define FIRST_WINDOW ((WIN_TYPES)(MINVAL_WINDOW + 1))
#define LAST_WINDOW ((WIN_TYPES)(MAXVAL_WINDOW - 1))

//----------------------------------------------------------------------------
//
// StateBuffer.
//
// A state buffer is a dynamic container for data passed from
// the engine thread to the UI thread.  It may be used for
// holding window content, in which case it will have an HWND
// associated with it, or it can be an internal buffer for non-UI
// purposes.
//
// A list of current window-associated state buffers is kept for
// the engine to traverse when it is updating state for the UI.
// The UI thread is the only thread that can add to this list.
// The engine thread is the only thread that can remove a buffer
// from the list.  This is necessary for proper lifetime management
// of dynamically-created buffers.
//
//----------------------------------------------------------------------------

class StateBuffer : public LIST_ENTRY
{
public:
    DBG_CRITICAL_SECTION m_Lock;
    WIN_TYPES m_enumType;
    HWND m_Win;
    ULONG m_UpdateTypes;
    UpdateType m_UpdateType;
    
    StateBuffer(ULONG ChangeBy);
    virtual ~StateBuffer(void);

    PVOID AddData(ULONG Len);
    BOOL AddString(PCSTR Str, BOOL Soft